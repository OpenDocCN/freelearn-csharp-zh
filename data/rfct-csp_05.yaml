- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Object-Oriented Refactoring
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象重构
- en: In the last chapter, we saw how refactoring can help improve classes and their
    methods. In this chapter, we’ll explore the bigger picture with creative uses
    of **object-oriented programming** (**OOP**) to refactor a series of classes into
    more maintainable forms. These tools will help you perform larger and more impactful
    refactorings and make a bigger difference in improving your code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了重构如何帮助改进类及其方法。在本章中，我们将通过创造性使用 **面向对象编程** (**OOP**) 来探索更大的图景，将一系列类重构为更易于维护的形式。这些工具将帮助您执行更大、更有影响力的重构，并在改进您的代码方面产生更大的影响。
- en: 'We’ll cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Organizing classes via refactoring
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过重构组织类
- en: Refactoring and inheritance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构与继承
- en: Controlling inheritance with abstract
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用抽象控制继承
- en: Refactoring for better encapsulation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了更好的封装进行重构
- en: Improving classes with interfaces and polymorphism
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用接口和多态改进类
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The starting code for this chapter is available from GitHub at [https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)
    in the `Chapter05/Ch5BeginningCode` folder.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的起始代码可在 GitHub 的 [https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)
    上的 `Chapter05/Ch5BeginningCode` 文件夹中找到。
- en: Refactoring the flight search system
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构航班搜索系统
- en: This chapter’s code focuses on a flight scheduling system for Cloudy Skies Airlines.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码专注于云天航空公司的航班调度系统。
- en: The flight scheduling system is a simple one that tracks all active flights
    through a `FlightScheduler` class and allows external callers to search for flights
    of interest. This class in turn tracks flights through a collection of `IFlightInfo`
    instances, which may either be a `PassengerFlightInfo` or a `FreightFlightInfo`
    instance, depending on whether the flight carries passenger or freight.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 航班调度系统是一个简单的系统，它通过 `FlightScheduler` 类跟踪所有活跃的航班，并允许外部调用者搜索感兴趣的航班。这个类反过来通过 `IFlightInfo`
    实例集合跟踪航班，这些实例可能是 `PassengerFlightInfo` 或 `FreightFlightInfo` 实例，具体取决于航班是否载有乘客或货物。
- en: 'The high-level interactions of these classes can be seen in *Figure 5**.1*:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类的高级交互可以在 *图 5**.1* 中看到：
- en: '![Figure 5.1 – Classes involved in the Cloudy Skies Airline flight scheduling
    system](img/B21324_05_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 云天航空公司航班调度系统涉及的类](img/B21324_05_01.jpg)'
- en: Figure 5.1 – Classes involved in the Cloudy Skies Airline flight scheduling
    system
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 云天航空公司航班调度系统涉及的类
- en: The code currently works and even uses polymorphism effectively to track a variety
    of different flights. That being said, there are some opportunities for improvement,
    as we’ll see. Throughout this chapter, we’ll make targeted improvements while
    demonstrating the breadth of refactoring possibilities present when using object-oriented
    programming.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 代码目前运行正常，甚至有效地使用了多态来跟踪各种不同的航班。话虽如此，还有一些改进的机会，我们将在后面看到。在本章中，我们将进行有针对性的改进，同时展示使用面向对象编程时存在的重构可能性。
- en: Organizing classes via refactoring
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过重构组织类
- en: It’s not uncommon for solutions to have organizational challenges such as misnamed
    files or types existing in the wrong file or namespace.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案存在组织挑战，如文件命名不当或类型存在于错误的文件或命名空间中，这种情况并不少见。
- en: These problems may seem small, but they can make it harder for developers to
    find the code they’re looking for – particularly when first joining the project.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题可能看起来很小，但它们可能会使开发者更难找到他们正在寻找的代码——尤其是在刚加入项目时。
- en: Let’s look at a few refactorings that help developers navigate code more easily.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个有助于开发者更容易地导航代码的重构示例。
- en: Moving classes to individual files
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将类移动到单独的文件中
- en: One common mistake I’ve seen teams make is putting multiple types inside of
    the same file. Usually, a file starts with a single class or interface and then
    a developer decides to add a related type. Instead of putting the new type in
    a file of its own, the class gets added to the existing file. Once this happens
    for a few small classes, it tends to snowball after that with developers continuing
    to add new types to the file as time goes on.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到的一个常见错误是团队将多个类型放在同一个文件中。通常，一个文件从一个类或接口开始，然后开发者决定添加一个相关类型。而不是将新类型放在自己的文件中，类被添加到现有的文件中。一旦这种情况发生在几个小类上，之后往往会像滚雪球一样，随着时间的发展，开发者继续向文件中添加新的类型。
- en: Types
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 类型
- en: If you’re not familiar with the use of the word “type” in the .NET world, a
    type is a generic term that refers to anything supported by the **common type
    system** (**CTS**). Essentially, if you can use it to declare a variable, it’s
    probably a type. Some examples of types include classes, interfaces, structs,
    enums, and the various record type variants.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉 .NET 世界中“类型”一词的使用，类型是一个通用术语，指代任何由 **公共类型系统**（**CTS**）支持的实体。本质上，如果你可以用它来声明一个变量，那么它很可能是一个类型。类型的例子包括类、接口、结构体、枚举以及各种记录类型变体。
- en: 'The `IFlightInfo.cs` file from the Flight Scheduling System has a few different
    types defined in it:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 飞行调度系统中的 `IFlightInfo.cs` 文件定义了几个不同的类型：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'While this example might not seem so bad, having multiple types in a single
    file does cause a few problems:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子可能看起来不太严重，但一个文件中有多个类型确实会导致一些问题：
- en: New developers who are looking for a specific type have trouble finding which
    file contains that type without using search features.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 寻找特定类型的初学者在没有使用搜索功能的情况下很难找到包含该类型的文件。
- en: Version control systems, such as git, track changes to each file. This can increase
    confusion when teams must merge code or even determine what changed in any given
    software release.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 版本控制系统，如 git，跟踪每个文件的更改。当团队必须合并代码或确定任何给定软件版本中发生了什么更改时，这可能会增加混淆。
- en: 'The fix for this is to move each type to its own dedicated file. This can be
    done by going to the **Quick Actions** menu on a type whose name doesn’t match
    the file name. Next, select the **Move type to [new file name].cs** option as
    shown in *Figure 5**.2*:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是将每个类型移动到其专用的文件中。这可以通过访问名称与文件名不匹配的类型的 **快速操作** 菜单来完成。接下来，选择如 *图 5.2*
    所示的 **将类型移动到 [新文件名].cs** 选项：
- en: '![Figure 5.2 – Moving a type to its own file](img/B21324_05_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 将类型移动到自己的文件](img/B21324_05_02.jpg)'
- en: Figure 5.2 – Moving a type to its own file
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 将类型移动到自己的文件
- en: Selecting this option removes the type from the original file and creates a
    new file containing only the type you selected.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 选择此选项将从原始文件中移除类型，并创建一个只包含你选择的类型的新的文件。
- en: You’ll need to repeat this for every type that doesn’t match the name of the
    file in Visual Studio. One of the extra refactoring tools that ReSharper and Rider
    provide allows you to perform this refactoring for every type in the file, folder,
    or solution. This can be particularly handy if you encounter a single file with
    hundreds of types in it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为 Visual Studio 中每个名称与文件不匹配的类型重复此操作。ReSharper 和 Rider 提供的一些额外重构工具允许你为文件、文件夹或解决方案中的每个类型执行此重构。如果你遇到一个包含数百个类型的单个文件，这会特别方便。
- en: Renaming files and classes
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重命名文件和类
- en: Occasionally, you’ll find cases where a file and the type that it contains don’t
    match. This often happens when developers create a new class and then decide to
    rename it later without using the rename refactoring built into Visual Studio.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你会遇到文件和其中包含的类型名称不匹配的情况。这通常发生在开发者创建了一个新类，然后决定稍后重命名它，但没有使用 Visual Studio 内置的重命名重构功能。
- en: 'The `AirportInfo.cs` file and its `Airport` class are an example of this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`AirportInfo.cs` 文件及其 `Airport` 类是这种情况的一个例子：'
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Usually, the fix for this is to rename the file to match the name of the type
    (though occasionally you’ll determine the file was named correctly) and the class
    should be renamed to match the name of the file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，解决这个问题是将文件重命名为与类型名称匹配（尽管偶尔你会确定文件名称是正确的），并且类应该重命名为与文件名称匹配。
- en: 'With either option, open the **Quick Actions** menu on the type in question
    and select either **Rename file** or **Rename type** to ensure the file and type
    name match. See the following figure:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是哪种选择，打开相关类型的 **快速操作** 菜单，选择 **重命名文件** 或 **重命名类型**，以确保文件和类型名称匹配。请参见以下图示：
- en: '![Figure 5.3 – Options to rename the file or rename the type](img/B21324_05_03.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 重命名文件或重命名类型的选项](img/B21324_05_03.jpg)'
- en: Figure 5.3 – Options to rename the file or rename the type
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 重命名文件或重命名类型的选项
- en: I chose to rename the file to `Airport.cs`, as either option will ensure that
    the file and type have the same name. This naming consistency is a small improvement,
    but it helps developers navigate your project more easily over time.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择将文件重命名为 `Airport.cs`，因为任一选项都能确保文件和类型名称相同。这种命名一致性虽是小小的改进，但有助于开发者随着时间的推移更轻松地导航你的项目。
- en: Changing namespaces
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改命名空间
- en: .NET uses **namespaces** to organize types into a hierarchical structure. By
    convention, these namespaces should match the folders inside the project in **Solution
    Explorer**.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 使用 **命名空间** 将类型组织成层次结构。按照惯例，这些命名空间应与 **解决方案资源管理器** 中的项目文件夹相匹配。
- en: The project will start with a namespace such as `Packt.CloudySkiesAir.Chapter5`,
    and each folder nested inside of a project adds to this namespace. For example,
    a `Filters` folder in that project should use a `Packt.CloudySkiesAir.Chapter5.Filters`
    namespace.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 项目将以一个命名空间开始，例如 `Packt.CloudySkiesAir.Chapter5`，并且项目内部嵌套的每个文件夹都会添加到这个命名空间中。例如，该项目中的
    `Filters` 文件夹应使用 `Packt.CloudySkiesAir.Chapter5.Filters` 命名空间。
- en: When classes don’t use the expected namespace, it can lead to confusion.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当类没有使用预期的命名空间时，可能会导致混淆。
- en: 'As a practical example, let’s look at the `Airport.cs` file in the root of
    the `Chapter5` project as shown in *Figure 5**.4*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 作为实际示例，让我们看看 `Chapter5` 项目根目录下的 `Airport.cs` 文件，如图 *图 5**.4* 所示：
- en: '![Figure 5.4 – A project with the Airport class directly nested inside of the
    project](img/B21324_05_04.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – Airport 类直接嵌套在项目中的项目](img/B21324_05_04.jpg)'
- en: Figure 5.4 – A project with the Airport class directly nested inside of the
    project
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – Airport 类直接嵌套在项目中的项目
- en: 'In this scenario, you would expect the `Airport` class to live in the `Packt.CloudySkiesAir.Chapter5`
    namespace. However, the file uses a different namespace, as shown in the following
    code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，你可能会期望 `Airport` 类位于 `Packt.CloudySkiesAir.Chapter5` 命名空间中。然而，该文件使用了不同的命名空间，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This discrepancy can be fixed through manual editing of the namespace declaration
    or by using the **Change namespace to match folder structure** under **Quick Action**
    refactoring, as shown in *Figure 5**.5*:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种差异可以通过手动编辑命名空间声明或使用 **快速操作** 重构中的 **更改命名空间以匹配文件夹结构** 来修复，如图 *图 5**.5* 所示：
- en: '![Figure 5.5 – Changing the namespace to match the folder structure](img/B21324_05_05.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 将命名空间更改为与文件夹结构匹配](img/B21324_05_05.jpg)'
- en: Figure 5.5 – Changing the namespace to match the folder structure
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 将命名空间更改为与文件夹结构匹配
- en: I personally recommend using the `using` statements to other files as needed
    to support the namespace change.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人建议根据需要使用 `using` 语句来支持命名空间更改。
- en: Avoiding partial classes and regions
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免部分类和区域
- en: Before we move on to refactoring and inheritance, I want to cover two related
    **anti-patterns** I’ve seen in C# code when dealing with large classes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论重构和继承之前，我想谈谈我在处理大型类时在 C# 代码中看到的两个相关的 **反模式**。
- en: When developers have large classes with many different blocks of related code,
    there’s a temptation to use several language features to make organizing the file
    easier.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者拥有包含许多不同代码块的大类时，他们可能会倾向于使用多种语言特性来简化文件的组织。
- en: Many developers use the `#region` preprocessor directive to create regions of
    code that can expand and collapse.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者使用 `#region` 预处理器指令来创建可以展开和折叠的代码区域。
- en: 'For example, you could use a statement such as `#region Stuff I don''t want
    to look at right now` with a matching `#endregion` statement on its own line.
    This would create a collapsible region of code in the editor, as the collapsed
    region from lines 33–84 in *Figure* *5**.6* illustrates:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用一个如 `#region Stuff I don't want to look at right now` 的语句，后面跟着一个单独的
    `#endregion` 语句。这将创建一个可折叠的代码区域，如图 *5**.6* 中的折叠区域从第 33-84 行所示：
- en: '![Figure 5.6 – A collapsed region of code](img/B21324_05_06.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 代码折叠区域](img/B21324_05_06.jpg)'
- en: Figure 5.6 – A collapsed region of code
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 代码折叠区域
- en: '`#region` is viewed as a bad thing to rely on for code organization; it leads
    to extremely large classes instead of refactoring code into more maintainable
    patterns.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`#region` 被视为代码组织中的一个坏习惯；它会导致极其庞大的类，而不是将代码重构为更可维护的模式。'
- en: So, why does it exist at all?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么它存在呢？
- en: The `#region` directive was introduced to help hide auto-generated code commonly
    built into older versions of .NET applications. This is code that developers were
    not expected to work with and often encouraged not to modify for fear of breaking
    things.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`#region` 指令被引入是为了帮助隐藏通常嵌入到旧版 .NET 应用程序中的自动生成代码。这是开发者不期望与之交互的代码，并且通常鼓励不要修改，以免破坏其他东西。'
- en: Eventually, .NET got **partial classes** to help in scenarios that regions were
    previously used in.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，.NET 引入了 **部分类** 来帮助处理之前在区域中使用的情况。
- en: 'Partial classes are classes that are defined in *multiple files* within the
    *same project*. This will allow you to have `FlightScheduler.ItemManagement.cs`
    and `FlightScheduler.Search.cs` files that each contain parts of the larger class.
    This lets you define a large class over multiple files:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 部分类是在 *同一项目* 内的 *多个文件* 中定义的类。这将允许你拥有 `FlightScheduler.ItemManagement.cs` 和 `FlightScheduler.Search.cs`
    文件，每个文件都包含较大类的一部分。这让你可以在多个文件中定义一个大型类：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Like region directives, partial classes are intended to support automatically
    generated code. While I personally prefer partial classes to `#region` directives,
    I view both as anti-patterns when they are applied to reducing pains caused by
    large classes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与区域指令一样，部分类旨在支持自动生成的代码。虽然我个人更喜欢部分类而不是 `#region` 指令，但我认为当它们用于减少大型类带来的痛苦时，两者都是反模式。
- en: Usually, when your classes are big enough for you to want to consider `#region`
    or partial classes, you are violating the single responsibility principle and
    your class should be broken up into multiple smaller classes that are distinctly
    different from one another.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你的类足够大，以至于你想考虑 `#region` 或部分类时，你正在违反单一职责原则，你的类应该被拆分成多个更小的类，这些类彼此之间明显不同。
- en: We’ll discuss the single responsibility principle and other design principles
    in [*Chapter 8*](B21324_08.xhtml#_idTextAnchor173), *Avoiding Code Anti-patterns*
    *with SOLID*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第8章*](B21324_08.xhtml#_idTextAnchor173)，*使用SOLID避免代码反模式* 中讨论单一职责原则和其他设计原则。
- en: Refactoring and inheritance
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构与继承
- en: Now that we’ve covered some of the ways refactoring can help organize your code,
    let’s dive into refactorings related to inheritance. This is a collection of refactorings
    that involve either overriding methods, introducing inheritance, or altering in-place
    inheritance relationships to improve the maintainability of code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了一些重构可以帮助组织代码的方法，让我们深入了解与继承相关的重构。这是一组重构，涉及重写方法、引入继承或修改就地继承关系，以提高代码的可维护性。
- en: Overriding ToString
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重写ToString
- en: '`ToString` is one of the four methods that any .NET object is guaranteed to
    have due to the `virtual` definition of `ToString` on `System.Object`. This method
    is used whenever an object is converted to a string and can be particularly handy
    for logging and debugging purposes.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToString` 是任何 .NET 对象都保证拥有的四个方法之一，这是由于 `System.Object` 上 `ToString` 的 `virtual`
    定义。此方法在对象转换为字符串时使用，并且对于日志记录和调试目的特别有用。'
- en: Sometimes overriding `ToString` can simplify your code in unexpected ways.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有时重写 `ToString` 可以以意想不到的方式简化你的代码。
- en: 'Let’s look at the `BuildFlightIdentifier` method in `FreightFlightInfo.cs`.
    This method relies on the `DepartureLocation` and `ArrivalLocation` properties
    of type `Airport` to produce a string:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 `FreightFlightInfo.cs` 中的 `BuildFlightIdentifier` 方法。此方法依赖于类型为 `Airport`
    的 `DepartureLocation` 和 `ArrivalLocation` 属性来生成一个字符串：
- en: FreightFlightInfo.cs
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: FreightFlightInfo.cs
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It’s annoying to have to drill into these location properties to reach their
    `Code` property.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 需要深入到这些位置属性中才能到达它们的 `Code` 属性，这很烦人。
- en: 'If `Airport` overrides the `ToString` method and returns the airport code,
    we would be able to simplify the readability of our code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `Airport` 重写了 `ToString` 方法并返回机场代码，我们就能简化我们代码的可读性：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To do this, you can either go to `Airport.cs` and add the override manually
    or use the built-in refactoring option through the **Generate overrides...** refactoring
    (see *Figure 5**.7*):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你可以直接进入 `Airport.cs` 并手动添加重写，或者使用内置的重构选项通过 **生成重写...** 重构（见 *图5.7*）：
- en: '![Figure 5.7 – Generating overrides on a class](img/B21324_05_07.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7 – 在类上生成重写](img/B21324_05_07.jpg)'
- en: Figure 5.7 – Generating overrides on a class
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 – 在类上生成重写
- en: 'From there, you’ll need to specify which methods or properties you want to
    override. As shown in the following image, any abstract or virtual member of a
    class you’re inheriting from will be available:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，你需要指定你想要重写的方法或属性。如图所示，你从继承的类中继承的任何抽象或虚拟成员都将可用：
- en: '![Figure 5.8 – Selecting the members to override](img/B21324_05_08.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图5.8 – 选择要重写的成员](img/B21324_05_08.jpg)'
- en: Figure 5.8 – Selecting the members to override
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – 选择要重写的成员
- en: Selecting `ToString()` and clicking **OK** generates a stubbed-out method that
    can be quickly replaced with an actual implementation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 `ToString()` 并点击 **确定** 会生成一个占位符方法，可以快速替换为实际实现。
- en: 'In this class, the `ToString` method should return the airport code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，`ToString` 方法应该返回机场代码：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With this override in place, existing code can still use the `Code` property
    without issues. However, any code that previously tried to write an `Airport`
    object to the console now will see its code instead of the namespace and name
    of the class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在此覆盖到位后，现有代码仍然可以使用 `Code` 属性而不会出现问题。然而，任何之前尝试将 `Airport` 对象写入控制台中的代码现在将看到其代码而不是类的命名空间和名称。
- en: Note
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The default implementation of `ToString` in .NET is to return a string with
    the namespace and the name of the type. In this case that would have been `Packt.CloudySkiesAir.Chapter5.AirTravel.Airport`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 中 `ToString` 的默认实现是返回一个包含命名空间和类型名称的字符串。在这种情况下，它将是 `Packt.CloudySkiesAir.Chapter5.AirTravel.Airport`。
- en: Next, we should look at everywhere the `Code` property is currently being read
    from and see if it would be more readable to rely on the `ToString` override instead.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该查看 `Code` 属性当前正在被读取的所有地方，看看是否更易于阅读，可以依赖 `ToString` 覆盖。
- en: 'You can do this in any edition of Visual Studio 2022 by right-clicking on the
    `Code` property declaration and choosing **Find All References**, as shown in
    *Figure 5**.9*:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在任何版本的 Visual Studio 2022 中通过右键单击 `Code` 属性声明并选择 **查找所有引用** 来执行此操作，如图 *图
    5**.9* 所示：
- en: '![Figure 5.9 – The Find All References context menu option](img/B21324_05_09.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – 查找所有引用的上下文菜单选项](img/B21324_05_09.jpg)'
- en: Figure 5.9 – The Find All References context menu option
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 查找所有引用的上下文菜单选项
- en: 'This opens a new pane with all references of that property highlighted:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个新的面板，其中突出显示了该属性的 所有引用：
- en: '![Figure 5.10 – Find All References results](img/B21324_05_10.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10 – 查找所有引用的结果](img/B21324_05_10.jpg)'
- en: Figure 5.10 – Find All References results
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 查找所有引用的结果
- en: 'You can then modify these areas to use `ToString` where appropriate, such as
    in this modification to `PassengerFlightInfo`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以修改这些区域以在适当的地方使用 `ToString`，例如在以下对 `PassengerFlightInfo` 的修改中：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'One added benefit of overriding `ToString` in your objects is an improved display
    of the class when viewing the Visual Studio debugger:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的对象中覆盖 `ToString` 的一个额外好处是当在 Visual Studio 调试器中查看时，类的显示会得到改进：
- en: '![Figure 5.11 – ToString override displaying in debugging tools](img/B21324_05_11.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11 – 在调试工具中显示的 `ToString` 覆盖](img/B21324_05_11.jpg)'
- en: Figure 5.11 – ToString override displaying in debugging tools
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – 在调试工具中显示的 `ToString` 覆盖
- en: 'We’ll explore debugging more in [*Chapter 10*](B21324_10.xhtml#_idTextAnchor209)*:
    Defensive* *Coding Techniques*.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第 10 章*](B21324_10.xhtml#_idTextAnchor209)*：防御性编码技术* 中进一步探讨调试。
- en: Generating equality methods
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成等价方法
- en: In C#, equality for reference types (such as classes) is done using **reference
    equality** –determining whether the two objects are located at the same location
    in the **heap**.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，引用类型的等价性（如类）是通过 **引用等价性** 来实现的 – 确定两个对象是否位于堆中的相同位置。
- en: Sometimes it’s more convenient to compare different properties on two objects
    to see if their values are equivalent, even if the two objects represent two separate
    locations on the heap.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候比较两个对象的不同属性以查看它们的值是否等效会更方便，即使这两个对象代表堆上的两个不同的位置。
- en: 'The following code from the `FlightScheduler` class shows how its `Search`
    method checks to make sure the airport you’re searching for has the same airport
    code and country. Note the repeated logic when determining if two airports are
    equivalent:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下来自 `FlightScheduler` 类的代码展示了其 `Search` 方法是如何检查确保您正在搜索的机场具有相同的机场代码和国家。注意在确定两个机场等效时的重复逻辑：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code could be simplified by overriding equality members with our own customized
    implementation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用我们自己的定制实现覆盖等价成员，可以简化此代码。
- en: Equality members
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 等价成员
- en: '.NET provides two methods to determine equality: `Equals` and `GetHashCode`.
    The `Equals` method determines whether two objects are equivalent while `GetHashCode`
    is used to determine which major “bucket” an object is sorted into for `Dictionary`
    and `HashSet`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 提供了两种确定等价性的方法：`Equals` 和 `GetHashCode`。`Equals` 方法确定两个对象是否等效，而 `GetHashCode`
    用于确定对象在 `Dictionary` 和 `HashSet` 中排序到的哪个主要“桶”。
- en: You should never override only one of these two methods; whenever you override
    `Equals`, you will need to override `GetHashCode` as well. Furthermore, you want
    to make sure you use a good implementation of `GetHashCode` that evenly and consistently
    distributes objects in your class into different hash values.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您永远不应该只覆盖这两个方法中的一个；每当您覆盖 `Equals` 时，您还需要覆盖 `GetHashCode`。此外，您还想要确保您使用的是一个良好的
    `GetHashCode` 实现，该实现可以均匀且一致地将对象分布到您类中的不同哈希值中。
- en: .NET also provides an `IEquatable<T>` interface that you can implement for strongly
    typed equality comparisons, which can improve performance. Implementing `IEquatable<T>`
    is generally recommended when overriding equality members but is not detailed
    in this book. See the *Further reading* section for more information.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 还提供了一个 `IEquatable<T>` 接口，你可以实现它来进行强类型相等性比较，这可以提高性能。在重写相等性成员时，通常推荐实现 `IEquatable<T>`，但本书中并未详细说明。更多信息请参阅
    *进一步阅读* 部分。
- en: 'Equality and hash codes can get complex very quickly, but thankfully we have
    some very good tooling for generating equality members in Visual Studio. Just
    select your class and then choose **Generate Equals and GetHashCode…** from the
    **Quick Actions** menu, as shown in *Figure 5**.12*:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 相等性和哈希码可能会变得非常复杂，但幸运的是，我们在 Visual Studio 中有一些非常好的工具来生成相等性成员。只需选择你的类，然后从 **快速操作**
    菜单中选择 **生成 Equals 和 GetHashCode…**，如图 *图 5.12* 所示：
- en: '![Figure 5.12 – Generating equality member overrides](img/B21324_05_12.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12 – 生成相等性成员重写](img/B21324_05_12.jpg)'
- en: Figure 5.12 – Generating equality member overrides
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – 生成相等性成员重写
- en: 'Once you select this, Visual Studio will ask you what members should contribute
    to equality and hash code checks, as shown in *Figure 5**.13*:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择此选项，Visual Studio 将询问哪些成员应参与相等性和哈希码检查，如图 *图 5.13* 所示：
- en: '![Figure 5.13 – Selecting equality members](img/B21324_05_13.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.13 – 选择相等性成员](img/B21324_05_13.jpg)'
- en: Figure 5.13 – Selecting equality members
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 – 选择相等性成员
- en: 'Select the members that *must* be equal and click **OK** to generate your overrides:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 选择必须相等的成员并点击 **确定** 以生成重写：
- en: Airport.cs
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Airport.cs
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, Visual Studio generated a pattern matching the `Equals` implementation
    that compares the relevant properties. Additionally, the `GetHashCode` implementation
    uses the newer `HashCode.Combine` method to safely simplify the process of hash
    code generation for you.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Visual Studio 生成了一个与 `Equals` 实现匹配的模式，比较相关属性。此外，`GetHashCode` 实现使用较新的 `HashCode.Combine`
    方法来安全地简化你的哈希码生成过程。
- en: Updating equality members
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 更新相等性成员
- en: If you ever add new properties to your class that should factor into equality
    checks, be sure to update `Equals` and `GetHashCode` to include these properties.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为你的类添加了新的属性，这些属性应该影响相等性检查，请确保更新 `Equals` 和 `GetHashCode` 以包括这些属性。
- en: 'With custom equality members in place, code that previously checked both the
    airport `Code` and `Country` can be simplified to use the equality operator (`==`)
    instead:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置了自定义相等性成员之后，之前检查机场 `Code` 和 `Country` 的代码可以简化为使用相等运算符 (`==`)：
- en: FlightScheduler.cs – Search
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: FlightScheduler.cs – 搜索
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Overriding equality members can be handy when you have many similar objects
    on the heap that contain identical values. This can happen when working with **web
    services** or other places where **deserialization** occurs.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 重写相等性成员在你有很多在堆上具有相同值的相似对象时非常有用。这可能在处理 **Web 服务** 或其他发生 **反序列化** 的地方发生。
- en: Equality and records
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 相等性和记录
- en: 'You don’t always need to override equality members to get value-based equality.
    In [*Chapter 10*](B21324_10.xhtml#_idTextAnchor209)*: Defensive Coding Techniques*,
    we’ll explore strategic uses of the `record` keyword for controlling equality.
    In fact, whenever I find myself thinking about overriding equality members, I
    usually decide to make my class a record instead.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你并不总是需要重写相等性成员来获得基于值的相等性。在 [*第 10 章*](B21324_10.xhtml#_idTextAnchor209)：**防御性编码技术*
    中，我们将探讨 `record` 关键字在控制相等性方面的战略使用。事实上，每当我发现自己正在考虑重写相等性成员时，我通常会决定将我的类做成记录。
- en: Extracting a base class
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取基类
- en: Sometimes you’ll encounter cases with a high degree of duplication between classes.
    These classes are conceptually related and share not just similar member signatures,
    but identical implementations of those members.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能会遇到类之间有高度重复的情况。这些类在概念上是相关的，并且不仅共享相似的成员签名，还共享这些成员的相同实现。
- en: In these cases, it often makes sense to introduce a base class that defines
    the common shared code. **Inheritance** then allows us to remove the common code
    from multiple classes in the system and maintain it in a centralized place.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，引入一个定义公共共享代码的基类通常是有意义的。**继承**然后允许我们从系统中的多个类中移除公共代码，并在集中位置维护它。
- en: 'In our flight scheduler example (see *Figure 5**.14*), the passenger and freight
    flight classes have several shared properties:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的航班调度示例（见图 *图 5.14*），乘客和货运航班类有几个共享属性：
- en: '![Figure 5.14 – Shared members between freight and passenger flights](img/B21324_05_14.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图5.14 – 货运和客运航班之间的共享成员](img/B21324_05_14.jpg)'
- en: Figure 5.14 – Shared members between freight and passenger flights
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14 – 货运和客运航班之间的共享成员
- en: 'To address this, go to either of the two classes and choose **Extract base
    class...** from the **Quick** **Actions** menu:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，请进入任意一个类，并从**快速操作**菜单中选择**提取基类...**：
- en: '![Figure 5.15 – Extracting a base class](img/B21324_05_15.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图5.15 – 提取基类](img/B21324_05_15.jpg)'
- en: Figure 5.15 – Extracting a base class
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.15 – 提取基类
- en: Next, name the new class and select which members you want to move into it,
    as shown in *Figure 5**.16*. You can also decide whether you want any of those
    members to be declared as abstract, but note that this will mark your class as
    abstract as well.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为新类命名，并选择你想要移动到其中的成员，如图*图5.16*所示。你也可以决定是否将其中任何成员声明为抽象的，但请注意，这将使你的类也成为抽象类。
- en: '![Figure 5.16 – Configuring the new base class](img/B21324_05_16.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图5.16 – 配置新的基类](img/B21324_05_16.jpg)'
- en: Figure 5.16 – Configuring the new base class
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.16 – 配置新的基类
- en: 'Once you click **OK**, the new class will be created:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你点击**确定**，新类将被创建：
- en: FlightInfoBase.cs
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: FlightInfoBase.cs
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The class you started with now inherits from this new class and the non-abstract
    members you selected have been removed from the file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你开始时的类现在继承自这个新类，而你选择的非抽象成员已从文件中移除：
- en: PassengerFlightInfo.cs
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: PassengerFlightInfo.cs
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Extracting a base class can be very helpful for promoting code reuse, but it’s
    only half of the refactoring work; extracting a base class did not modify your
    other class.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 提取基类对于促进代码复用非常有帮助，但这只是重构工作的一半；提取基类并没有修改你的其他类。
- en: 'If you want the related flight class to also inherit from the new class, you’ll
    have to make that change manually by specifying the base class and removing any
    members that were “pulled up” to that class:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望相关的航班类也继承自新类，你必须手动进行更改，指定基类并移除任何被“提升”到该类的成员：
- en: FreightFlightInfo.cs
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: FreightFlightInfo.cs
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The result of this is that our two flight classes are now focused on the things
    that are distinct to them. Additionally, if new logic needs to be added for every
    flight, it can now be added to the base class and all inheriting classes will
    receive it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，我们的两个航班类现在专注于它们各自独特的事物。此外，如果需要为每个航班添加新的逻辑，现在可以将其添加到基类中，所有继承的类都将接收它。
- en: Moving interface implementations up the inheritance tree
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将接口实现向上移动到继承树
- en: 'One oddity you might have noticed in the last two code listings is that even
    though `FreightFlightInfo` and `PassengerFlightInfo` both now inherit from `FlightInfoBase`,
    they both separately implement the `IFlightInfo` interface, as shown in *Figure
    5**.17*:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在最后两个代码示例中注意到一个奇怪的现象，即尽管`FreightFlightInfo`和`PassengerFlightInfo`现在都继承自`FlightInfoBase`，但它们都分别实现了`IFlightInfo`接口，如图*图5.17*所示：
- en: '![Figure 5.17 – Passenger and Freight flights separately implementing IFlightInfo](img/B21324_05_17.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图5.17 – 客运和货运航班分别实现IFlightInfo](img/B21324_05_17.jpg)'
- en: Figure 5.17 – Passenger and Freight flights separately implementing IFlightInfo
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.17 – 客运和货运航班分别实现IFlightInfo
- en: When every class inheriting from a base class implements an interface, there’s
    usually a good chance that you can pull the interface implementation up into the
    base class itself.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当每个继承自基类的类都实现了一个接口时，通常有很好的机会将接口实现向上移动到基类本身。
- en: 'In this case, `FlightInfoBase` has all required members defined by the `IFlightInfo`
    interface. So, it makes sense to implement the interface, as shown here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`FlightInfoBase`类已经通过`IFlightInfo`接口定义了所有必需的成员。因此，实现该接口是有意义的，如下所示：
- en: FlightInfoBase.cs
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: FlightInfoBase.cs
- en: '[PRE14]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With the change in place, we can remove the `IFlightInfo` implementation from
    both `PassengerFlightInfo` and `FreightFlightInfo`. This simplifies the class
    definitions while still inheriting the interface implementation, as pictured here:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行更改后，我们可以从`PassengerFlightInfo`和`FreightFlightInfo`中移除`IFlightInfo`实现。这简化了类定义，同时仍然继承了接口实现，如图所示：
- en: '![Figure 5.18 – The IFlightInfo interface implementation “pulled up” into FlightInfoBase](img/B21324_05_18.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图5.18 – 将IFlightInfo接口实现“提升”到FlightInfoBase中](img/B21324_05_18.jpg)'
- en: Figure 5.18 – The IFlightInfo interface implementation “pulled up” into FlightInfoBase
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.18 – 将IFlightInfo接口实现“提升”到FlightInfoBase中
- en: By pulling the interface up into the base class, we now *guarantee* that any
    class inheriting from this class will also implement the `IFlightInfo` interface.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将接口拉入基类，我们现在**保证**任何从该类继承的类也将实现`IFlightInfo`接口。
- en: Controlling inheritance with abstract
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用抽象控制继承
- en: Now that we’ve covered some refactoring patterns around inheritance, let’s look
    at using **abstract classes** and other C# features to restrict our classes and
    ensure they’re used appropriately.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了一些关于继承的重构模式，让我们看看如何使用**抽象类**和其他C#特性来限制我们的类，并确保它们被适当使用。
- en: Communicating intent with abstract
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用抽象传达意图
- en: 'One quirk about our current design is that it is possible to instantiate a
    new instance of `FlightInfoBase` simply by writing the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前设计的一个特点是，可以通过编写以下代码简单地实例化一个新的`FlightInfoBase`实例：
- en: '[PRE15]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: While it might not make sense to you – for a new flight to exist that isn’t
    explicitly a passenger or freight flight, because the `FlightInfoBase` class is
    not marked as abstract – there’s nothing preventing anyone from instantiating
    it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能对你来说没有意义——因为存在一种既不是客运也不是货运的航班，因为`FlightInfoBase`类没有被标记为抽象类——但这并不阻止任何人实例化它。
- en: 'To mark a class as abstract, add the `abstract` keyword to its signature:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个类标记为抽象，请将其签名中的`abstract`关键字添加：
- en: FlightInfoBase.cs
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: FlightInfoBase.cs
- en: '[PRE16]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Marking classes as abstract when you do not intend for anyone to instantiate
    them accomplishes a few things:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不希望任何人实例化类时，将其标记为抽象可以完成几件事情：
- en: It communicates that the class is not intended to be instantiated
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它传达了该类不打算被实例化的意图
- en: The compiler now prevents others from instantiating your class
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器现在阻止其他人实例化你的类
- en: As we’ll see next, it allows you to add abstract members to your class
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如我们接下来将看到的，它允许你向你的类添加抽象成员
- en: Introducing abstract members
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入抽象成员
- en: Now that `FlightInfoBase` is abstract, it opens new possibilities for refactoring.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于`FlightInfoBase`是抽象的，它为重构打开了新的可能性。
- en: For example, both `FreightFlightInfo` and `PassengerFlightInfo` have `BuildFlightIdentifier`
    methods and `ToString` overrides.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`FreightFlightInfo`和`PassengerFlightInfo`都有`BuildFlightIdentifier`方法和`ToString`覆盖。
- en: '![Figure 5.19 – Repeated members in flight info classes](img/B21324_05_19.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图5.19 – 飞行信息类中的重复成员](img/B21324_05_19.jpg)'
- en: Figure 5.19 – Repeated members in flight info classes
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.19 – 飞行信息类中的重复成员
- en: While the implementation details of the `BuildFlightIdentifier` method differ,
    `ToString` overrides the return of the result of `BuildFlightIdentifier`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`BuildFlightIdentifier`方法的实现细节不同，但`ToString`方法覆盖了`BuildFlightIdentifier`的结果返回。
- en: 'We can take advantage of these commonalities by pulling both methods into the
    base class using **Pull [Member name] up...**, as shown in *Figure 5**.20*:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用**拉取[成员名称]**向上...，如图*图5**.20*所示，利用这些共同点将两个方法都拉入基类：
- en: '![Figure 5.20 – Pulling members up to the base type](img/B21324_05_20.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图5.20 – 将成员拉到基类型](img/B21324_05_20.jpg)'
- en: Figure 5.20 – Pulling members up to the base type
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.20 – 将成员拉到基类型
- en: Next, select the members you want to pull up into the parent class, making sure
    to check the **Mark abstract** checkbox for any member you want the *definition*
    of to be pulled up without also having its *implementation* pulled up.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，选择你想要拉入父类的成员，确保为任何你想要将其*定义*拉入而不将其*实现*拉入的成员勾选**标记为抽象**复选框。
- en: '![Figure 5.21 – Selecting destination and making members abstract](img/B21324_05_21.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图5.21 – 选择目的地和将成员抽象化](img/B21324_05_21.jpg)'
- en: Figure 5.21 – Selecting destination and making members abstract
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.21 – 选择目的地和将成员抽象化
- en: 'The result of this is that `FlightInfoBase` now has the `ToString` override
    as well as an abstract definition for the `BuildFlightIdentifier`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，`FlightInfoBase`现在有了`ToString`覆盖以及`BuildFlightIdentifier`的抽象定义：
- en: FlightInfoBase.cs
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: FlightInfoBase.cs
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With `BuildFlightIdentifier` abstract, our original method call remains in
    place, but it is now marked as an override:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`BuildFlightIdentifier`是抽象的，我们的原始方法调用仍然保留，但现在被标记为覆盖：
- en: PassengerFlightInfo.cs
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: PassengerFlightInfo.cs
- en: '[PRE18]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Unfortunately, the **Pull Members Up** refactoring does not modify other classes
    that also inherit from the same base class, so you now must add the override manually
    in the other flight class:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，**拉取成员向上**重构不会修改从同一基类继承的其他类，因此你现在必须手动在其他航班类中添加覆盖：
- en: '[PRE19]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Making this refactoring has simplified our code: the individual flight classes
    no longer need to override `ToString`. More importantly, if we ever add a new
    type of flight, the compiler will force it to provide a valid flight identifier
    through a `BuildFlightIdentifier` override.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 进行这次重构简化了我们的代码：单个航班类不再需要重写 `ToString`。更重要的是，如果我们以后添加新的航班类型，编译器将强制它通过 `BuildFlightIdentifier`
    重写提供一个有效的航班标识符。
- en: Sealed methods and classes
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 密封方法和类
- en: While we’re talking about abstract, virtual, and overriding methods, we should
    touch on `sealed`. The `sealed` keyword has almost the opposite effect. When a
    class is marked with `sealed`, it cannot be inherited from. When a *method* is
    marked with `sealed`, that method may not be overridden further in inheriting
    classes. Both uses of the `sealed` keyword exist to protect what a class does
    from external modification. Additionally, there can be some performance benefits
    to marking members as sealed.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论抽象、虚拟和重写方法时，我们应该提及 `sealed`。`sealed` 关键字几乎有相反的效果。当一个类被标记为 `sealed` 时，它不能被继承。当一个
    *方法* 被标记为 `sealed` 时，该方法在继承类中不能进一步重写。`sealed` 关键字的这两种用法都是为了保护类所做的操作免受外部修改。此外，将成员标记为
    `sealed` 还可能带来一些性能优势。
- en: Converting abstract methods to virtual methods
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将抽象方法转换为虚拟方法
- en: Occasionally, you’ll mark a method as abstract and later realize that many overrides
    of this method have similar implementations. When this occurs, it can make sense
    to move the method from `abstract` to `virtual` in order to provide a base implementation
    that others can *optionally* override.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你会将一个方法标记为抽象的，后来意识到这个方法许多重写有相似的实现。当这种情况发生时，将方法从 `abstract` 移动到 `virtual`
    以提供一个其他人可以选择重写的基实现是有意义的。
- en: 'Our `FlightInfoBase` class defines `BuildFlightIdentifier` as abstract:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `FlightInfoBase` 类将 `BuildFlightIdentifier` 定义为抽象：
- en: '[PRE20]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This would imply that each implementation of this method *should* be different
    from the others. However, let’s take a look at the actual implementations of this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这个方法的每个实现都应该与其他的不同。然而，让我们看看这个实际的实现：
- en: PassengerFlightInfo.cs
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PassengerFlightInfo.cs
- en: '[PRE21]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: FreightFlightInfo.cs
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreightFlightInfo.cs
- en: '[PRE25]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: While the strings for both methods are built, they both start with the flight
    identifier, the departure airport, and the arrival airport.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然两个方法字符串都构建了，但它们都以航班标识符、出发机场和到达机场开始。
- en: If we ever wanted to change the way all flights display this basic information,
    we’d need to change every class inheriting from `FlightInfoBase`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要改变所有航班显示这些基本信息的方式，我们需要更改从 `FlightInfoBase` 继承的所有类。
- en: 'Instead, we can modify `FlightInfoBase` to provide a good starting point with
    this shared information:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以修改 `FlightInfoBase` 以提供一个包含共享信息的良好起点：
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With this change, two things have happened:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这次更改导致了两件事发生：
- en: New flight classes no longer *need* to override `BuildFlightIdentifier`
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的航班类不再 *需要* 重写 `BuildFlightIdentifier`
- en: Existing overrides can call `base.BuildFlightIdentifier()` to get the common
    format of the basic flight information
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的重写可以调用 `base.BuildFlightIdentifier()` 来获取基本航班信息的通用格式
- en: 'In our case, it makes sense to continue to override the method, but we can
    now change the code to take advantage of common formatting at the base level:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，继续重写这个方法是有意义的，但现在我们可以修改代码以利用基级别的通用格式化：
- en: '`PassengerFlightInfo.cs`'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PassengerFlightInfo.cs`'
- en: '[PRE30]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`FreightFlightInfo.cs`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FreightFlightInfo.cs`'
- en: '[PRE33]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Combining our abstract class with a virtual method lets us keep flight formatting
    logic in one centralized place while still giving us the freedom to extend the
    class and modify its behavior.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的抽象类与虚拟方法结合起来，使我们能够将航班格式化逻辑集中在一个地方，同时仍然保持扩展类和修改其行为的自由。
- en: Refactoring for better encapsulation
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为了更好的封装进行重构
- en: Another core tenet of object-oriented programming is **encapsulation**. With
    encapsulation, you assert control of the data in your classes and ensure others
    work with data in ways that make sense both immediately and as the code grows
    over time.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的另一个核心原则是 **封装**。通过封装，你声明对类中数据的控制，并确保其他人以合理的方式与数据交互，无论是立即还是随着时间的推移。
- en: The following refactorings deal with the various pieces of data composing classes
    along with the data passed along to methods as parameters.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以下重构处理了组成类的各种数据以及作为参数传递给方法的参数。
- en: Encapsulating fields
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装字段
- en: The simplest encapsulation refactoring allows you to wrap all uses of a field
    into a property.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的封装重构允许你将字段的全部使用封装到一个属性中。
- en: 'In the following code example, the `PassengerFlightInfo` class has a `_passengers`
    field storing the count of passengers on the flight, and this field is used throughout
    the class when referring to the passenger count:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码示例中，`PassengerFlightInfo`类有一个`_passengers`字段，用于存储航班上的乘客数量，并且当在类中引用乘客数量时，该字段被整个类使用：
- en: '[PRE36]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This code isn’t bad, and I’d be fine with this logic in a production application.
    However, it does have a few potential drawbacks:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并不糟糕，我会在生产应用程序中接受这种逻辑。然而，它确实有几个潜在的缺点：
- en: Nothing outside of the class can read the count of passengers on the flight.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类外部无法读取航班乘客数量。
- en: Several places modify the `_passengers` field. If we wanted to add validation
    or do something every time the value changes, we’d have to modify several different
    methods.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有几个地方修改了`_passengers`字段。如果我们想在值每次更改时添加验证或执行某些操作，我们就必须修改几个不同的方法。
- en: Wrapping all uses of the `_passengers` field into a property can help with this
    by giving us a centralized place to perform validation and a property for things
    outside of the class to read.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 将`_passengers`字段的全部使用封装到属性中，可以帮助我们提供一个集中位置来执行验证，并为类外部的读取提供一个属性。
- en: 'You can use the **Encapsulate field** refactoring in the **Quick Action** menu
    to quickly wrap an existing field into a property:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用**封装字段**重构功能在**快速操作**菜单中快速将现有字段包装成属性：
- en: '![Figure 5.22 – Encapsulating the passengers field into a property](img/B21324_05_22.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图5.22 – 将乘客字段封装为属性](img/B21324_05_22.jpg)'
- en: Figure 5.22 – Encapsulating the passengers field into a property
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.22 – 将乘客字段封装为属性
- en: 'This adds a property that your class can use to read and modify the value in
    a centralized location:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这为你的类添加了一个属性，可以在集中位置读取和修改值：
- en: '[PRE37]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Keep in mind that this refactoring does make the setter public by default, which
    would allow code outside of the class to modify the `passengers` value. If you
    don’t want this, you can mark the property as having a `private` or `protected`
    set instead.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这种重构默认会将设置器公开，这将允许类外部的代码修改`passengers`值。如果你不希望这样，你可以将属性标记为具有`private`或`protected`设置。
- en: Wrapping parameters into a class
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将参数封装到类中
- en: As software systems grow, more features get added along with the code needed
    to support them. This can cause methods that were once simple to grow significantly
    in complexity and the information they require to operate.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 随着软件系统的增长，会添加更多功能以及支持它们的代码。这可能导致曾经简单的方法变得非常复杂，并且它们需要的信息也越来越多。
- en: It’s not unusual for a method that took three parameters in the early days of
    a project to suddenly find itself needing seven or eight parameters to function
    after a significant amount of development occurs.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目早期需要三个参数的方法，在经过大量开发后，突然发现自己需要七个或八个参数才能正常工作，这种情况并不少见。
- en: '`FlightScheduler`’s search method is an example of this since there are so
    many things that can factor into a flight search:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlightScheduler`的搜索方法就是这样一个例子，因为有很多因素会影响航班搜索：'
- en: FlightScheduler.cs
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: FlightScheduler.cs
- en: '[PRE38]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This method currently takes in eight different pieces of information, which
    makes calls to the method extremely hard to read:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法目前接受八种不同的信息，这使得对方法的调用非常难以阅读：
- en: '[PRE39]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: While I made that example a little hard to read on purpose, in my experience,
    complex method signatures exist in the real world. These complex methods can lead
    to subtle bugs due to confusion over which value you’re passing to which parameter
    as you read a long list of parameters.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我故意让这个例子读起来有点困难，但根据我的经验，在现实世界中确实存在复杂的方法签名。这些复杂的方法可能会导致由于在阅读参数列表时对传递给哪个参数的值感到困惑而出现微妙的错误。
- en: Looking at this code, it’s easy to imagine new things that someone might want
    to search for with regard to flights, including low and high prices, in-flight
    beverage service, free Wi-Fi, and the type of aircraft being flown. Each one of
    these new search features would further expand both the method definition and
    every caller to the method.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 看着这段代码，很容易想象到有人可能想要搜索与航班相关的新事物，包括低和高价格、机上饮料服务、免费Wi-Fi以及所飞行的飞机类型。这些新的搜索功能将进一步扩展方法定义和调用该方法的所有调用者。
- en: 'One common solution to this problem is to encapsulate related pieces of information
    into a new class. In our case, we can define a new `FlightSearch` class to wrap
    everything related to searching for a flight:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的常见方法是将相关信息封装到一个新的类中。在我们的情况下，我们可以定义一个新的`FlightSearch`类来封装与搜索航班相关的一切：
- en: FlightSearch.cs
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: FlightSearch.cs
- en: '[PRE40]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This new class allows us to track information on searches in a centralized
    place and significantly improves the signature of the search method:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新类允许我们在一个集中的地方跟踪搜索信息，并显著改进了搜索方法的签名：
- en: FlightScheduler.cs
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: FlightScheduler.cs
- en: '[PRE41]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Adding the `FlightSearch` class shrunk the method signature from eight parameters
    to just one. Additionally, if new search logic needs to be added in the future,
    these pieces of information can be added to the `FlightSearch` object without
    needing to further modify the `Search` method’s signature.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 `FlightSearch` 类将方法签名从八个参数缩减为一个。此外，如果未来需要添加新的搜索逻辑，这些信息可以添加到 `FlightSearch`
    对象中，而无需进一步修改 `Search` 方法的签名。
- en: 'Unfortunately, changing the signature of the search method breaks callers to
    the method until they are updated to use the new search object. To fix this, you
    have a few options:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，更改搜索方法的签名会中断直到它们更新为使用新搜索对象的方法调用者。为了解决这个问题，你有几个选择：
- en: Update all usages of the `Search` method to pass a `FlightSearch` object
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有对 `Search` 方法的调用更新为传递一个 `FlightSearch` 对象
- en: Create a temporary overload of the Search method that passes a `FlightSearch`
    object to the new method.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个临时的 `Search` 方法重载，将 `FlightSearch` 对象传递给新方法。
- en: The first option is somewhat self-explanatory, so let’s take a look at the second
    option.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项有些不言自明，所以让我们看看第二个选项。
- en: 'Here, we’ll create an overload of the `Search` method that takes in the eight
    old parameters, creates a `FlightSearch` object, and passes it to the new method:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个 `Search` 方法的重载，它接受八个旧参数，创建一个 `FlightSearch` 对象，并将其传递给新方法：
- en: '[PRE42]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that we marked this method as obsolete. This will warn programmers trying
    to use it and tell them what method to use instead (see *Figure 5**.23*). Marking
    things with the `Obsolete` attribute helps guide developers towards the more recent
    version. Typically, a method will be marked as obsolete and then removed from
    the project later.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已将此方法标记为已过时。这将警告试图使用它的程序员，并告诉他们应该使用哪个方法（见 *图 5**.23*）。使用 `Obsolete` 属性标记事物有助于引导开发者使用更近期的版本。通常，一个方法会被标记为已过时，然后稍后从项目中删除。
- en: '![Figure 5.23 – An obsolete warning telling the developer which method to use
    instead](img/B21324_05_23.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.23 – 一个过时的警告，告诉开发者使用哪个方法代替](img/B21324_05_23.jpg)'
- en: Figure 5.23 – An obsolete warning telling the developer which method to use
    instead
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.23 – 一个过时的警告，告诉开发者使用哪个方法代替
- en: The result of this is that we were able to simplify our method and provide a
    safe place for the data that the method needs to grow over time by introducing
    a class.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入一个类，我们能够简化我们的方法，并为随着时间的推移需要增长的数据提供了一个安全的地方：
- en: Introducing classes for common sets of parameters significantly speeds up development
    time for teams, particularly when these same objects are passed around throughout
    the system.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为常见的参数集引入类可以显著加快团队的开发时间，尤其是当这些相同的对象在整个系统中传递时。
- en: Wrapping properties into a class
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将属性封装到类中
- en: 'Sometimes you’ll find classes with sets of properties that are related to each
    other. For example, the `FlightInfoBase` class needs to track both the airport
    a plane departs from or arrives at and the time and date of that event:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你会找到具有相互关联的属性集的类。例如，`FlightInfoBase` 类需要跟踪飞机起飞或到达的机场以及该事件的日期和时间：
- en: FlightInfoBase.cs
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: FlightInfoBase.cs
- en: '[PRE43]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this scenario, information about the arrival and departure need both their
    `Airport` and the associated `DateTime` to make sense. If we needed to track the
    terminal, gate, or runway in the future, we’d need to add in properties for both
    arrival and departure.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，关于到达和出发的信息都需要它们的 `Airport` 和相关的 `DateTime` 才有意义。如果我们未来需要跟踪航站楼、登机口或跑道，我们需要为到达和出发都添加属性。
- en: 'Because these sets of properties grow together, it makes sense to wrap them
    together in their own `AirportEvent` class:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些属性集是相互增长的，所以将它们封装在自己的 `AirportEvent` 类中是有意义的：
- en: '[PRE44]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, if we need to expand the information we track on each leg of a flight,
    we can add it to this class and it will be available to both arrivals and departures.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们需要扩展我们对每个航段跟踪的信息，我们可以将其添加到这个类中，它将对到达和出发都可用。
- en: 'Of course, for this to fully work we’ll need to modify `FlightInfoBase` to
    use the new class instead of tracking its properties separately:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了使这完全工作，我们需要修改 `FlightInfoBase` 以使用新类而不是单独跟踪其属性：
- en: FlightInfoBase.cs
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: FlightInfoBase.cs
- en: '[PRE45]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'However, this change on its own won’t be enough until we update the `IFlightInfo`
    interface to match our new signature:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，直到我们更新`IFlightInfo`接口以匹配我们的新签名，这种变化本身还不够：
- en: IFlightInfo.cs
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: IFlightInfo.cs
- en: '[PRE46]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'With this change, the compiler is now satisfied with our flight classes, but
    there are now compiler errors in `FlightScheduler`’s `ScheduleFlight` method:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个变化，编译器现在对我们的航班类感到满意，但现在在`FlightScheduler`的`ScheduleFlight`方法中出现了编译错误：
- en: FlightScheduler.cs
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: FlightScheduler.cs
- en: '[PRE47]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This method is still trying to set the old properties, so it will need to be
    updated to use `AirportEvent` objects instead:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法仍在尝试设置旧属性，因此需要更新以使用`AirportEvent`对象：
- en: '[PRE48]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`FlightScheduler` also has a few more compiler errors in the search method
    due to uses of the old properties:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlightScheduler`在搜索方法中由于使用了旧属性，也出现了一些编译错误：'
- en: '[PRE49]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'These pieces of code will need to reference the new properties instead:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码片段需要引用新的属性：
- en: '[PRE50]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You may have noticed that for this simple change of wrapping properties together
    into a new object we had to make a number of changes just to get the code to compile
    again.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，为了将属性组合成一个新的对象进行这个简单的更改，我们不得不做出许多更改才能使代码再次编译。
- en: This can be normal when making structural changes like this, but the compiler
    supports you on your refactoring journey here by ensuring your code makes structural
    sense as you make your changes. In fact, I wouldn’t be brave enough to make some
    of these changes without being able to lean a little on the compiler to help me
    find places where I missed using the old way of doing things. I would encourage
    you to view the compiler as an ally on your refactoring journey.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这种结构变更时，这很正常，但编译器通过确保你的代码在变更过程中保持结构上的合理性来支持你的重构之旅。实际上，如果没有编译器的帮助，我可能不敢做出一些这些变更。我鼓励你将编译器视为重构之旅中的盟友。
- en: Favoring composition over inheritance
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优先使用组合而非继承
- en: Let’s close our discussion on encapsulation by exploring the directive to *favor
    composition over inheritance*. This was a phrase I heard a lot in the early days
    of my career, though it took me a while to grasp its meaning and implications.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过探讨“优先使用组合而非继承”的指令来结束我们对封装的讨论。这是我职业生涯早期经常听到的一句话，尽管我花了一些时间才理解它的含义和影响。
- en: By favoring composition over inheritance, we make a conscious decision that
    classes should *have something* instead of *being something*. If a class has another
    object it can hand off a responsibility instead of relying on inheritance to make
    the class more special and able to handle a specific scenario.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 通过优先使用组合而非继承，我们做出了一个有意识的决策，即类应该“拥有”某些东西，而不是“成为”某些东西。如果一个类可以将其责任转交给另一个对象，而不是依赖继承来使类更加特殊并能够处理特定场景，那么这个类就有东西。
- en: Let’s look at the flight scheduling system, for example.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看航班调度系统，例如。
- en: Cloudy Skies Airlines has decided it wants to offer charter flights. These are
    small flights that carry both passengers and cargo paid for by various companies.
    In this case, a charter flight is neither a passenger flight nor a freight flight,
    but in fact a bit of both.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Cloudy Skies Airlines已经决定它想要提供包机服务。这些小型航班既载客又载货，由不同的公司支付费用。在这种情况下，包机既不是客运航班也不是货运航班，而是两者兼而有之。
- en: 'A direct implementation of this using inheritance would look something like
    this:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 使用继承直接实现这个功能可能看起来像这样：
- en: '[PRE51]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note here that a single class has both cargo and passengers.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里一个类既有货物也有乘客。
- en: On its own, this isn’t so bad, but what if we wanted our charter flight to hold
    multiple pieces of cargo? We’d now need to have a collection of cargo strings
    with their charter companies (which might be different from one another).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，这并不糟糕，但如果我们想让我们的包机携带多件货物呢？我们现在需要有一个包含货物字符串及其包机公司的集合（这些公司可能各不相同）。
- en: Any customizations to this cargo or how it would be displayed would require
    either additional customization of this class or a separate but related class
    also inheriting from `FlightInfoBase`. It’s not too hard to imagine this system
    spawning a swarm of related classes such as `BulkCargoFlightInfo`, `ExpressFlightInfo`,
    `MedicalFlightInfo`, `HazardousCargoFlightInfo`, and more.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 对此货物或其显示方式的任何定制都需要对这个类进行额外的定制，或者创建一个单独但相关的类，这个类也继承自`FlightInfoBase`。想象这个系统产生一系列相关类，如`BulkCargoFlightInfo`、`ExpressFlightInfo`、`MedicalFlightInfo`、`HazardousCargoFlightInfo`等，并不太难。
- en: While this inheritance-based approach would work, using **composition** will
    result in more maintainable code and fewer classes.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种基于继承的方法可以工作，但使用**组合**将导致更易于维护的代码和更少的类。
- en: 'Composition lets us say that an individual flight is *composed of* cargo items.
    Cargo items can be defined using a simple `CargoItem` class:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 组合允许我们说一个单独的航班是由*组合*的货物项组成的。货物项可以使用简单的`CargoItem`类来定义：
- en: '[PRE52]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This simple approach stores the item type and its quantity and provides a string
    representation of the two.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的方法存储了项目类型及其数量，并提供了这两个的字符串表示。
- en: 'We can then incorporate this into an alternative version of `CharterFlightInfo`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将此方法纳入`CharterFlightInfo`的替代版本中：
- en: '[PRE53]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This approach allows a charter flight to be composed of different cargo items.
    Each item is then displayed in the `BuildFlightIdentifier` method using its `ToString`
    method. See the following diagram:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许包机航班由不同的货物项组成。然后，每个项目都使用其`ToString`方法在`BuildFlightIdentifier`方法中显示。请参阅以下图表：
- en: '![Figure 5.24 – CharterFlightInfo is composed of CargoItems](img/B21324_05_24.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图5.24 – CharterFlightInfo由CargoItems组成](img/B21324_05_24.jpg)'
- en: Figure 5.24 – CharterFlightInfo is composed of CargoItems
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.24 – CharterFlightInfo由CargoItems组成
- en: Composing our charter flight with `CargoItems` gives us additional flexibility.
    Not only does this arrangement pattern allow a charter flight to have multiple
    cargo items, but it also allows it to do so without you having to declare different
    classes for different cargo loads.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`CargoItems`组合我们的包机航班提供了额外的灵活性。不仅这种组合模式允许包机航班拥有多个货物项，而且它还允许这样做，而无需为不同的货物负载声明不同的类。
- en: Improving classes with interfaces and polymorphism
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用接口和多态改进类
- en: We’re nearly at the close of this chapter on object-oriented refactoring. However,
    before we close the chapter, let’s discuss a few places where introducing interfaces
    and polymorphism can help further improve our code.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了关于面向对象重构的章节。然而，在我们结束这一章之前，让我们讨论一下在哪些地方引入接口和多态可以帮助进一步改进我们的代码。
- en: Extracting interfaces
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取接口
- en: 'At the moment, our `CharterFlightInfo` class stores a list of `CargoItem`s
    representing its cargo:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的`CharterFlightInfo`类存储了一个表示其货物的`CargoItem`s列表：
- en: '[PRE54]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Each cargo item the charter flight includes must be a `CargoItem` or something
    that inherits from it. For example, if we were to create the `HazardousCargoItem`
    we discussed in the last section and try to store it in the cargo collection,
    it *must* inherit from `CargoItem` to compile.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 包机航班包含的每个货物项都必须是`CargoItem`或从它继承的某个东西。例如，如果我们创建上节中讨论的`HazardousCargoItem`并尝试将其存储在货物集合中，它*必须*从`CargoItem`继承才能编译。
- en: In many systems, you don’t want to force people to inherit from your classes
    if they want to customize the system’s behavior. In these places, it can be helpful
    to introduce an interface.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多系统中，你不想强迫人们从你的类继承，如果他们想要自定义系统的行为。在这些地方，引入一个接口可能会有所帮助。
- en: Let’s do that with our `CargoItem` class by selecting the class and then choosing
    **Extract interface…** from the **Quick** **Actions** menu.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过选择`CargoItem`类，然后从**快速操作**菜单中选择**提取接口…**来用我们的`CargoItem`类做这件事。
- en: '![Figure 5.25 – Extracting an interface](img/B21324_05_25.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![图5.25 – 提取接口](img/B21324_05_25.jpg)'
- en: Figure 5.25 – Extracting an interface
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.25 – 提取接口
- en: 'Once you’ve done this, as shown in *Figure 5**.25*, you now need to specify
    which members of the class should be included in the interface as well as what
    the interface should be called:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你做了这件事，如图*图5**.25*所示，你现在需要指定哪些类的成员应该包含在接口中，以及接口应该叫什么名字：
- en: '![Figure 5.26 – Customizing the extracted interface](img/B21324_05_26.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![图5.26 – 定制提取的接口](img/B21324_05_26.jpg)'
- en: Figure 5.26 – Customizing the extracted interface
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.26 – 定制提取的接口
- en: 'Name your interface `ICargoItem`, select both `ItemType` and `Quantity`, and
    then click `ICargoItem` interface in a new file:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的接口命名为`ICargoItem`，选择`ItemType`和`Quantity`，然后在新文件中点击`ICargoItem`接口：
- en: '[PRE55]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This will also modify `CargoItem` to implement this interface:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将修改`CargoItem`以实现此接口：
- en: '[PRE56]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Note that by default, extracting an interface will introduce both getters and
    setters on properties. If you do not need your interface to expose a way of modifying
    a property, you can remove the `set` from the property definition in the interface:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，默认情况下，提取接口会在属性上引入获取器和设置器。如果你不希望你的接口暴露修改属性的方式，你可以在接口中从属性定义中移除`set`：
- en: '[PRE57]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Removing the set *does not prevent you* from having a setter on your property
    in `CargoItem`; it just means you’re not *required* to have a setter on the property.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 移除设置器*不会阻止你*在`CargoItem`的属性上有一个设置器；它只是意味着你*不需要*在属性上有一个设置器。
- en: 'With our new interface in hand, let’s go in and modify `CharterFlightInfo`
    to store `ICargoItem`s instead of `CargoItem`s:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有了新的接口，让我们进入并修改`CharterFlightInfo`以存储`ICargoItem`而不是`CargoItem`：
- en: '[PRE58]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This change allows us to store anything that implements the interface and improves
    the flexibility of what `CharterFlightInfo` can store. However, this does introduce
    another interface to your code, which slightly increases the complexity and can
    slow down development time in the long run.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变化使我们能够存储实现该接口的任何内容，并提高了`CharterFlightInfo`可以存储的内容的灵活性。然而，这也向你的代码中引入了另一个接口，这略微增加了复杂性，并可能在长期内减缓开发时间。
- en: Be careful when introducing interfaces. Interfaces that exist for the sake of
    added abstraction will ultimately do more harm than good in your application.
    However, interfaces that are implemented by more than one class or designed to
    give another set of developers greater freedom or flexibility can ultimately do
    a lot of good in a software system.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入接口时要小心。仅仅为了增加抽象而存在的接口最终会对你的应用程序造成更多的伤害而不是好处。然而，被多个类实现或旨在给另一组开发者提供更大自由度或灵活性的接口最终可以在软件系统中带来很多好处。
- en: We’ll talk more about the appropriate place for interfaces in [*Chapter 10*](B21324_10.xhtml#_idTextAnchor209)
    when we explore SOLID. For now, let’s move on to a newer feature in C# interfaces.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们探索SOLID时，我们将更详细地讨论接口的适当位置[*第10章*](B21324_10.xhtml#_idTextAnchor209)。现在，让我们继续探讨C#接口中的新功能。
- en: Providing default interface implementations
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供默认接口实现
- en: While we’re exploring interfaces, let’s see how **default interface implementations**
    can simplify the experience of implementing an interface.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在探索接口时，让我们看看**默认接口实现**如何简化实现接口的体验。
- en: Default interface implementations allow you to provide a default implementation
    inside the interface. When a class chooses to implement this interface, it is
    not *forced to* provide implementations of methods with default implementations.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 默认接口实现允许你在接口内部提供默认实现。当一个类选择实现此接口时，它不是*被迫*提供具有默认实现的方法的实现。
- en: 'Let’s see what this means by adding a `ManifestText` property with a default
    getter and a `LogManifest` method with a default implementation to `ICargoItem`:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向`ICargoItem`添加一个具有默认获取器的`ManifestText`属性和一个具有默认实现的`LogManifest`方法来了解这意味着什么：
- en: '[PRE59]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: By adding these new members to the interface, we’d normally break anything that
    implemented the interface, such as the `CargoItem` class, unless it had those
    members. However, because we provided a *default implementation* of both properties,
    `CargoItem` no longer *must* provide implementations. Instead, it effectively
    inherits these default implementations.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这些新成员添加到接口中，我们通常会破坏实现该接口的任何内容，例如`CargoItem`类，除非它具有这些成员。然而，因为我们提供了这两个属性的*默认实现*，所以`CargoItem`不再*必须*提供实现。相反，它实际上继承了这些默认实现。
- en: 'We can still provide a version of these new members. If we did, that version
    would be used instead of the default implementation:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以提供这些新成员的版本。如果我们这样做，那么这个版本将用于替代默认实现：
- en: CargoItem.cs
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: CargoItem.cs
- en: '[PRE60]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: I don’t like default interface implementations very much because they confuse
    the concept of an interface with a contract to provide certain members.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我不太喜欢默认接口实现，因为它们混淆了接口与提供某些成员的契约的概念。
- en: However, I must concede that when adding a simple member to an interface, it
    sometimes makes sense to add a default implementation so that you don’t need to
    change existing implementations of the interface. This can save you from having
    to add the same code to many different implementations of your interface throughout
    your solution. Additionally, default interface implementations reduce the work
    needed for classes trying to implement the interface by providing a default implementation.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我必须承认，当向接口添加简单成员时，有时添加默认实现是有意义的，这样你就不需要更改接口的现有实现。这可以让你在整个解决方案中避免在接口的多个实现中添加相同的代码。此外，默认接口实现通过提供默认实现减少了尝试实现接口的类所需的工作量。
- en: Introducing polymorphism
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入多态
- en: Whenever you are working with an interface, you are intentionally supporting
    **polymorphism** in your application. This is the ability to treat different objects
    based on their similarities instead of on their differences.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你使用接口时，你故意在应用程序中支持**多态**。这是根据对象的相似性而不是它们的差异来处理不同对象的能力。
- en: The `ICargoItem` approach introduced earlier with charter flights is an example
    of polymorphism. A charter flight doesn’t care about what type of cargo it has
    as long as the cargo implements the interface. This means that we can load a charter
    flight full of different types of cargo and the class works fine with them.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 之前介绍的与包机航班相关的`ICargoItem`方法是一个多态的例子。包机航班不关心它有什么类型的货物，只要货物实现了接口即可。这意味着我们可以装满不同类型货物的包机航班，并且这个类与它们一起工作得很好。
- en: 'The chapter’s code has another place that could strongly benefit from polymorphism:
    the `FlightScheduler` `Search` method:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码中还有另一个地方可以从多态中受益：`FlightScheduler`的`Search`方法：
- en: '[PRE61]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This method has some very repetitive code (much of it omitted) that checks to
    see if the search object specifies a property. If the property was specified,
    the potential results are filtered down to only include those that match the filter.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法包含一些非常重复的代码（其中大部分被省略），用于检查搜索对象是否指定了属性。如果指定了属性，潜在的结果将被过滤，仅包括匹配过滤器的那些。
- en: 'The search method uses this approach to filter based on:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索方法使用这种方法根据以下条件进行过滤：
- en: Departure and arrival locations
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出发和到达地点
- en: Minimum/maximum departure time
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小/最大出发时间
- en: Minimum/maximum arrival time
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小/最大到达时间
- en: Minimum/maximum flight length
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小/最大飞行时长
- en: It’s not too hard to imagine new things we might filter for, such as the price
    of the flight, whether the flight has a beverage service or even the type of aircraft.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下我们可能需要过滤的新事物并不难，例如航班价格、航班是否有饮料服务，甚至是飞机的类型。
- en: 'An alternative approach would be to take in a collection of filter objects.
    These filter objects would determine whether each flight should be included in
    the results through a common `FlightFilterBase` class and a `ShouldInclude` method:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是接受一个过滤器对象的集合。这些过滤器对象将通过一个共同的`FlightFilterBase`类和一个`ShouldInclude`方法来确定每架航班是否应该包含在结果中：
- en: '[PRE62]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'With this change, `Search` could be modified to loop over all filters and only
    include results that pass through all the provided filters:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个改动，`Search`可以被修改为遍历所有过滤器，并且只包括通过所有提供过滤器的结果：
- en: '[PRE63]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This cuts our `Search` method down from over 40 lines long to only 3 lines of
    code through polymorphism.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 通过多态，这种方法将`Search`方法从超过40行代码缩短到只有3行代码。
- en: Alternative implementation
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 替代实现
- en: An interface would also work fine instead of an abstract base class.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 接口也可以很好地替代抽象基类。
- en: 'By following this design, we can create a series of classes that inherit from
    `FlightFilterBase` to provide specific filtering capabilities:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这个设计，我们可以创建一系列继承自`FlightFilterBase`的类，以提供特定的过滤功能：
- en: '![Figure 5.27 – Distinct filter classes to help simplify our search code](img/B21324_05_27.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![图5.27 – 不同的过滤器类，有助于简化我们的搜索代码](img/B21324_05_27.jpg)'
- en: Figure 5.27 – Distinct filter classes to help simplify our search code
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.27 – 不同的过滤器类，有助于简化我们的搜索代码
- en: 'We now have dedicated filters that filter out flights that don’t match their
    specific criterion. For example, the `AirportFilter` would filter out flights
    that don’t specify an airport:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了专门的过滤器，可以过滤掉不符合特定标准的航班。例如，`AirportFilter`会过滤掉未指定机场的航班：
- en: '[PRE64]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Each individual filter class is small and easy to understand, maintain, and
    test.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单独的过滤器类都很小，易于理解、维护和测试。
- en: Additionally, if we want to add a new way of filtering flights in the future,
    all we need to do is add a new class inheriting from `FlightFilterBase`. No modifications
    would be needed for the `Search` method to support this because all the method
    needs is a collection of individual filters. The `Search` method doesn’t need
    to know which filters are involved – it just needs to call the `ShouldInclude`
    method and interpret the result.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们想在将来添加新的过滤航班的方式，我们只需要添加一个新的继承自`FlightFilterBase`的类。不需要对`Search`方法进行修改以支持这一点，因为所有方法需要的是一个过滤器集合。`Search`方法不需要知道涉及哪些过滤器
    - 它只需要调用`ShouldInclude`方法并解释结果。
- en: I find a lot of beauty in polymorphic solutions and have found my programming
    style changing over the years in search of more opportunities to take advantage
    of polymorphism through inheritance or interfaces.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现多态解决方案非常美丽，并且发现我的编程风格在多年中发生了变化，以寻找更多利用继承或接口实现多态的机会。
- en: Reviewing and testing our refactored code
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查和测试我们重构的代码
- en: With these changes made, let’s take a step back and look at the result.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出这些更改后，让我们退后一步，看看结果。
- en: 'We took a flight search system and used object-oriented programming techniques
    to improve its flexibility and maintainability by doing the following:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对一个航班搜索系统进行了重构，通过以下方式使用面向对象编程技术来提高其灵活性和可维护性：
- en: Reorganizing the code into appropriate files and namespaces
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码重新组织到适当的文件和命名空间中
- en: Introducing a base class and improving code reuse in flight information
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在飞行信息中引入基类并提高代码重用性
- en: Controlling a large number of parameters by moving them into a new class
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将参数移动到新类中来控制大量参数
- en: Introducing another new class to manage common information about airport events
    including both an airport and a time component
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入一个新的类来管理关于机场事件的常见信息，包括机场和时间组件
- en: Adding a charter flight class with a flexible cargo tracking system
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个包机航班类，并配备灵活的货物跟踪系统
- en: Introducing a polymorphic way of searching flights that will be more flexible
    and maintainable over time
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入一种多态的航班搜索方式，这将随着时间的推移变得更加灵活和易于维护
- en: Refactored code
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 重构代码
- en: The final refactored code from this chapter is available in the [https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)
    repository inside of the `Chapter05/Ch5RefactoredCode` folder.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最终重构代码可在[https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)存储库中的`Chapter05/Ch5RefactoredCode`文件夹中找到。
- en: As always, refactoring should never be done without testing the code to make
    sure that no new defects were introduced in the refactoring process. Running the
    tests (see *Figure 5**.28*) provided in the solution shows a full slate of passing
    tests, which will suffice for now until we get to *Part 2* and explore testing
    in more depth.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，重构代码之前应该先测试代码，以确保重构过程中没有引入新的缺陷。运行解决方案中提供的测试（见*图5.28*）显示所有测试都通过，这目前足够了，直到我们到达*第2部分*并更深入地探讨测试。
- en: '![Figure 5.28 – Test Explorer showing that all tests pass](img/B21324_05_28.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![图5.28 – 测试资源管理器显示所有测试通过](img/B21324_05_28.jpg)'
- en: Figure 5.28 – Test Explorer showing that all tests pass
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.28 – 测试资源管理器显示所有测试通过
- en: Summary
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the various ways that object-oriented programming
    techniques such as inheritance, encapsulation, and polymorphism can be used to
    refactor code toward more maintainable forms.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何使用面向对象编程技术，如继承、封装和多态，将代码重构为更易于维护的形式。
- en: Refactoring can be a complex endeavor, and yet so many of the fundamental concepts
    of object-oriented programming can come together to build elegant, flexible, and
    maintainable solutions.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 重构可能是一项复杂的任务，但许多面向对象编程的基本概念可以结合起来，构建出优雅、灵活且易于维护的解决方案。
- en: This concludes *Part 1* of the book. In the next part of the book, we’ll look
    at how testing can give you the safety and freedom needed to safely refactor your
    code and move forward with confidence that your changes have improved the application
    without breaking anything.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的*第1部分*到此结束。在书的下一部分，我们将探讨测试如何为你提供安全感和自由度，让你可以安全地重构代码，并充满信心地继续前进，相信你的更改已经改进了应用程序而没有破坏任何东西。
- en: Questions
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Does your code follow a well-structured and consistent namespace hierarchy with
    not too many or too few classes in each namespace?
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的代码是否遵循一个结构良好且一致的命名空间层次结构，每个命名空间中的类数量既不太多也不太少？
- en: Is there any part of your code that might be improved by using inheritance to
    promote code reuse?
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的代码中是否有任何部分可以通过使用继承来提高代码重用性而得到改进？
- en: Can you think of any repetitive rules or other structures in your code that
    might benefit from polymorphism?
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能想到任何可能从多态中受益的重复规则或其他结构吗？
- en: Further reading
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can find more information about materials discussed in this chapter at
    these URLs:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下URL中找到有关本章讨论的材料更多信息：
- en: '*Inheritance in* *C#:* [https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/inheritance](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/inheritance)'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C#中的继承：* [https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/inheritance](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/inheritance)'
- en: '*Sealed* *Modifier*: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/sealed](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/sealed)'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*密封* *修饰符*：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/sealed](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/sealed)'
- en: '*IEquatable<T>:* [https://learn.microsoft.com/en-us/dotnet/api/system.iequatable-1](https://learn.microsoft.com/en-us/dotnet/api/system.iequatable-1)'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*IEquatable<T>*：[https://learn.microsoft.com/en-us/dotnet/api/system.iequatable-1](https://learn.microsoft.com/en-us/dotnet/api/system.iequatable-1)'
- en: 'Part 2: Refactoring Safely'
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2部分：安全重构
- en: In the second part of the book, we’ll cover coding techniques such as unit tests
    that help ensure your refactoring efforts don’t result in unintentional changes.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第二部分，我们将介绍诸如单元测试之类的编码技术，这些技术有助于确保您的重构工作不会导致意外的更改。
- en: This chapter focuses on various testing frameworks and standard testing practices
    before moving on to discussions about programming best practices and writing SOLID
    code.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍各种测试框架和标准测试实践，然后讨论编程最佳实践和编写SOLID代码。
- en: The final two chapters in this part focus on more advanced testing strategies
    and ways the C# language can help you detect and prevent errors from reaching
    your users.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分最后两章专注于更高级的测试策略以及C#语言如何帮助您检测和防止错误传递给用户。
- en: 'This part contains the following chapters:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 6*](B21324_06.xhtml#_idTextAnchor133)*, Unit Testing*'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B21324_06.xhtml#_idTextAnchor133)*，单元测试*'
- en: '[*Chapter 7*](B21324_07.xhtml#_idTextAnchor161)*, Test-Driven Development*'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B21324_07.xhtml#_idTextAnchor161)*，测试驱动开发*'
- en: '[*Chapter 8*](B21324_08.xhtml#_idTextAnchor173)*, Avoiding Code Anti-Patterns
    with SOLID*'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B21324_08.xhtml#_idTextAnchor173)*，使用SOLID避免代码反模式* '
- en: '[*Chapter 9*](B21324_09.xhtml#_idTextAnchor189)*, Advanced Unit Testing*'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B21324_09.xhtml#_idTextAnchor189)*，高级单元测试*'
- en: '[*Chapter 10*](B21324_10.xhtml#_idTextAnchor209)*, Defensive Coding Techniques*'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B21324_10.xhtml#_idTextAnchor209)*，防御性编码技术*'
