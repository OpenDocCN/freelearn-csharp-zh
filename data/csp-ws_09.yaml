- en: 9\. Creating API Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9. 创建API服务
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In modern software development, most logic is served through distinct web services.
    This is essential to be able to both call and make new web services as a developer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代软件开发中，大多数逻辑都是通过不同的Web服务来提供的。这对于作为开发者能够调用和创建新的Web服务至关重要。
- en: In this chapter, you will be creating your own RESTful web service using the
    ASP.NET Core Web API template. You will learn not only how to do it but also some
    of the best practices for designing and building a Web API. You will also learn
    how to protect an API using Azure Active Directory (AAD), centralize error handling,
    troubleshoot errors, generate documentation, and more.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用ASP.NET Core Web API模板创建自己的RESTful Web服务。你不仅将学习如何做到这一点，还将了解设计和管理Web
    API的一些最佳实践。你还将学习如何使用Azure Active Directory (AAD)保护API、集中处理错误、调试错误、生成文档等。
- en: By the end of this chapter, you will be able to create professional Web APIs
    that are secured with AAD, hosted on the cloud, scalable, and able to serve thousands
    of users.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够创建专业的、使用AAD保护的、托管在云上、可扩展并能服务数千用户的Web API。
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: ASP.NET Core is a part of the .NET Core framework that is targeted at creating
    web apps. Using it, you can create both frontend (such as Razor or Blazor) and
    backend (such as Web API or gRPC) applications. However, in this chapter, you
    will be focusing on creating RESTful Web APIs. Creating a new web service for
    the first time might sound like a daunting task, but don't worry too much; for
    most scenarios, there is a template to get you started. In this chapter, you will
    create a few Web APIs using ASP.NET Core 6.0.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core是.NET Core框架的一部分，旨在创建Web应用程序。使用它，你可以创建前端（如Razor或Blazor）和后端（如Web
    API或gRPC）应用程序。然而，在本章中，你将专注于创建RESTful Web API。第一次创建新的Web服务可能听起来是一项艰巨的任务，但不必过于担心；对于大多数场景，都有一个模板可以帮助你开始。在本章中，你将使用ASP.NET
    Core 6.0创建几个Web API。
- en: ASP.NET Core Web API
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core Web API
- en: In *Chapter 8*, *Creating and Using Web API Clients*, you learned how to call
    RESTful APIs. In this chapter, you will be making one. Web API is a template for
    creating RESTful Web APIs in .NET. It contains routing, Dependency Injection (DI),
    an example controller, logging, and other useful components to get you started.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第8章*，*创建和使用Web API客户端*中，你学习了如何调用RESTful API。在本章中，你将创建一个。Web API是创建.NET中RESTful
    Web API的模板。它包含路由、依赖注入（DI）、示例控制器、日志记录和其他有用的组件，帮助你开始。
- en: Creating a New Project
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新项目
- en: 'In order to create a new Web API, follow these steps:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个新的Web API，请按照以下步骤操作：
- en: Create a new directory.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的目录。
- en: Name it after a project you want to create.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据你想要创建的项目来命名它。
- en: Navigate to that directory using the `cd` command.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cd`命令导航到该目录。
- en: 'Execute the following at the command line:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中执行以下操作：
- en: '[PRE0]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That is all it takes to get started.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是开始所需的全部。
- en: 'To see whether this is executing as expected, run the following and see your
    application come to life (*Figure 9.1*):'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了查看这是否按预期执行，运行以下命令并看到你的应用程序启动（*图9.1*）：
- en: '[PRE1]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Figure 9.1: Terminal window showing the port the application is hosted on
    ](img/B16835_09_01.jpg)'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图9.1：显示应用程序托管端口的终端窗口](img/B16835_09_01.jpg)'
- en: 'Figure 9.1: Terminal window showing the port the application is hosted on'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：显示应用程序托管端口的终端窗口
- en: In *Figure 9.1*, you will see port 7021 for the `https` version of the application.
    There may be multiple ports, especially if you are hosting both `HTTP` and `HTTPs`
    versions of an application. However, the key thing to remember is that you can
    the port where an application runs (for example, through the command line).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9.1*中，你将看到应用程序的`https`版本的7021端口。可能会有多个端口，特别是如果你同时托管了应用程序的`HTTP`和`HTTPs`版本。然而，要记住的关键是你可以通过端口来识别应用程序的运行位置（例如，通过命令行）。
- en: A port is a channel through which you allow a certain application to be called
    by all other applications. It is a number that appears after a base URL and it
    allows a single application through. Those applications don't have to be outsiders;
    the same rules also apply to internal communication.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 端口是通过它允许所有其他应用程序调用特定应用程序的通道。它是一个出现在基础URL之后的数字，它允许单个应用程序通过。这些应用程序不必是外部程序；同样的规则也适用于内部通信。
- en: Localhost refers to an application hosted locally. Later in this chapter, you
    will configure the service to bind to whatever port you want.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本地主机指的是本地托管的应用程序。在本章的后面部分，你将配置服务以绑定到你想要的任何端口。
- en: Note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are 65,535 ports available on a single machine. Ports zero through 1023
    are called well-known ports because usually, the same parts of the system listen
    on them. Typically, if a single application is hosted on one machine, the port
    will be 80 for `http` and 443 for `https`. If you are hosting multiple applications,
    the ports will vary drastically (usually starting from port 1024).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 单台机器上有 65,535 个端口可用。从 0 到 1023 的端口被称为知名端口，因为通常系统的相同部分会监听这些端口。通常，如果单个应用程序托管在一台机器上，端口将是
    80 用于 `http` 和 443 用于 `https`。如果您托管多个应用程序，端口将会有很大差异（通常从端口 1024 开始）。
- en: Web API Project Structure
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Web API 项目结构
- en: 'Every Web API is made of at least two classes—`Program` and one or more controllers
    (`WeatherForecastController` in this case):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Web API 至少由两个类组成——`Program` 和一个或多个控制器（在这个例子中是 `WeatherForecastController`）：
- en: 'Program: This is the **starting point** of an application. It serves as a low-level
    runner of an application and manages dependencies.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序：这是应用程序的**起点**。它作为应用程序的低级运行者并管理依赖项。
- en: 'Controller: This is a `[Model]Controller`. In this example case, `WeatherForecastController`
    will be called using a `/weatherforecast` endpoint.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器：这是一个 `[Model]Controller`。在这个例子中，`WeatherForecastController` 将通过 `/weatherforecast`
    端点被调用。
- en: '![Figure 9.2: The newly created MyProject structure in VS Code with key parts
    highlighted ](img/B16835_09_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2：在 VS Code 中新创建的 MyProject 结构，突出显示关键部分](img/B16835_09_02.jpg)'
- en: 'Figure 9.2: The newly created MyProject structure in VS Code with key parts
    highlighted'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2：在 VS Code 中新创建的 MyProject 结构，突出显示关键部分
- en: An In-Depth Look at WeatherForecastController
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深入了解 WeatherForecastController
- en: 'The controller from the default template is preceded by two attributes:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 默认模板中的控制器前面有两个属性：
- en: '`[ApiController]`: This attribute adds common, convenient (yet opinionated)
    Web API functionality.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ApiController]`：此属性添加了常见的、方便的（但具有观点）Web API 功能。'
- en: '`[Route("[controller]")]`: This attribute is used to provide a routing pattern
    of a given controller.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Route("[controller]")]`：此属性用于提供给定控制器的路由模式。'
- en: 'For example, in cases where these attributes are absent or the request is complex,
    you would need to validate an incoming HTTP request yourself without routing out
    of the box:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这些属性不存在或请求复杂的情况下，您需要自己验证传入的 HTTP 请求，而不需要默认的路由：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This controller has `/WeatherForecast` as the route. The route is usually made
    of the word that precedes the word `Controller` unless specified otherwise. When
    developing APIs professionally, or when you have a client- and server-side application,
    it is recommended to preappend `/api` to the route, making it `[Route("api/[controller]")]`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此控制器以 `/WeatherForecast` 作为路由。路由通常由位于 `Controller` 之前的单词组成，除非有其他指定。在专业开发 API
    或拥有客户端和服务器端应用程序时，建议在路由前预先添加 `/api`，使其成为 `[Route("api/[controller]")]`。
- en: 'Next, you''ll learn about the controller class declaration. Common controller
    functions come from a derived `ControllerBase` class and a few components (usually
    a logger) and services. The only interesting bit here is that, instead of `Ilogger`,
    you use `ILogger<WeatherForecastController>`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将学习控制器类的声明。常见的控制器功能来自派生的 `ControllerBase` 类和一些组件（通常是一个日志记录器）以及服务。这里唯一有趣的部分是，您使用
    `ILogger<WeatherForecastController>` 而不是 `Ilogger`：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The reason behind using the generic part is solely for getting the context from
    the place where the log was called. Using a generic version of a logger, you use
    a fully qualified name of a class that is supplied as a generic argument. Calling
    `logger.Log` will prefix it with a context; in this case, it will be `Chapter09.Service.Controllers.WeatherForecastController[0]`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用泛型部分的原因纯粹是为了从日志被调用的地方获取上下文。使用日志记录器的泛型版本，您使用作为泛型参数提供的类的完全限定名称。调用 `logger.Log`
    将在其前面加上上下文；在这种情况下，它将是 `Chapter09.Service.Controllers.WeatherForecastController[0]`。
- en: 'Lastly, look at the following controller method:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，看看以下控制器方法：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `[HttpGet]` attribute binds the `Get` method with the root controller endpoint''s
    (`/WeatherForecast`) HTTP GET method. There is a version of that attribute for
    every HTTP method, and they are `HttpGet`, `HttpPost`, `HttpPatch`, `HttpPut`,
    and `HttpDelete`. To check whether the service works, run the application using
    the following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`[HttpGet]` 属性将 `Get` 方法与根控制器端点（`/WeatherForecast`）的 HTTP GET 方法绑定。对于每个 HTTP
    方法都有一个该属性的版本，它们是 `HttpGet`、`HttpPost`、`HttpPatch`、`HttpPut` 和 `HttpDelete`。要检查服务是否正常工作，请使用以下命令运行应用程序：'
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, the `-urls=https://localhost:7021/` argument is not a requirement. This
    argument simply makes sure that the port picked by .NET is the same as is indicated
    in this example during execution.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`-urls=https://localhost:7021/` 参数不是必需的。这个参数只是确保.NET选择的端口与在执行此示例时指示的相同。
- en: 'To see the output, navigate to `https://localhost:7021/weatherforecast/` in
    the browser. This will return a single default `WeatherForecast` upon calling
    HTTP GET:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看输出，请在浏览器中导航到 `https://localhost:7021/weatherforecast/`。这将返回在调用HTTP GET时一个默认的
    `WeatherForecast`：
- en: '`[{"date":"0001-01-01T00:00:00","temperatureC":0,"temperatureF":32,"summary":null}].`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`[{"date":"0001-01-01T00:00:00","temperatureC":0,"temperatureF":32,"summary":null}].`'
- en: Note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When `https://localhost:7021/weatherforecast/` displays an error message (`localhost
    refused to connect`), it means that the application is likely running, but on
    a different port. So, always remember to specify a port as described in the *Creating
    a New Project* section (*Step 5*).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `https://localhost:7021/weatherforecast/` 显示错误消息（`localhost refused to connect`）时，这意味着应用程序可能正在运行，但端口不同。所以，始终记得按照
    *创建新项目* 部分中描述的方式指定端口（*步骤5*）。
- en: Responding with Different Status Codes
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以不同的状态码响应
- en: 'Find out what status codes can `public IEnumerable<WeatherForecast> Get()`
    respond with. Using the following steps, you can play around with it and inspect
    what happens in the browser:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 查找 `public IEnumerable<WeatherForecast> Get()` 可以响应哪些状态码。使用以下步骤，你可以对其进行操作并在浏览器中检查发生了什么：
- en: Navigate to `https://localhost:7021/weatherforecast/` in the browser.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中导航到 `https://localhost:7021/weatherforecast/`。
- en: Click on `More tools`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `更多工具`。
- en: Select the `Developer tools` option. Alternatively, you can use the `F12` key
    to launch the developer tools.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `开发者工具` 选项。或者，你可以使用 `F12` 键来启动开发者工具。
- en: Next, click on the `Network` tab.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击 `网络` 标签。
- en: 'Click on the `Headers` tab. You will see that `https://localhost:7021/weatherforecast/`
    responds with `200` `Status Code`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `头部` 标签。你会看到 `https://localhost:7021/weatherforecast/` 返回 `200` `状态码`：
- en: '![Figure 9.3: Dev tools Network tab—inspecting response headers of a successful
    response ](img/B16835_09_03.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3：开发者工具网络标签页——检查成功响应的响应头](img/B16835_09_03.jpg)'
- en: 'Figure 9.3: Dev tools Network tab—inspecting response headers of a successful
    response'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：开发者工具网络标签页——检查成功响应的响应头
- en: 'Create a new endpoint called `GetError` that throws an exception if a rare
    circumstance arises while a program is running:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `GetError` 的新端点，如果在程序运行期间出现罕见情况，它会抛出异常：
- en: '[PRE6]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, call `https://localhost:7021/weatherforecast/error`. It responds with
    a status code of `500`:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，调用 `https://localhost:7021/weatherforecast/error`。它返回状态码为 `500`：
- en: '![Figure 9.4: Dev tools Network tab—inspecting a response with an exception
    ](img/B16835_09_04.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4：开发者工具网络标签页——检查带有异常的响应](img/B16835_09_04.jpg)'
- en: 'Figure 9.4: Dev tools Network tab—inspecting a response with an exception'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：开发者工具网络标签页——检查带有异常的响应
- en: 'What should you do if you want a different status code to be returned? For
    that, the `BaseController` class contains utility methods for returning any kind
    of status code you require. For example, if you wanted to explicitly return an
    OK response, instead of returning a value right away, you could return `Ok(value)`.
    However, if you try changing the code, you will get the following error:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想返回不同的状态码，应该怎么做？为此，`BaseController` 类包含用于返回所需任何类型状态码的实用方法。例如，如果你想显式返回一个OK响应，而不是立即返回一个值，你可以返回
    `Ok(value)`。然而，如果你尝试更改代码，你会得到以下错误：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This does not work because you do not return an HTTP status code from a controller;
    you either return some value or throw some error. To return any status code of
    your choice, you need to change the return type. For that reason, a controller
    should never have a return type of some value. It should always return the `IActionResult`
    type—a type that supports all status codes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这不起作用，因为你没有从控制器返回HTTP状态码；你要么返回某个值，要么抛出某个错误。要返回你选择的任何状态码，你需要更改返回类型。因此，控制器永远不应该有某种值的返回类型。它应该始终返回
    `IActionResult` 类型——一个支持所有状态码的类型。
- en: 'Create one more method for getting the weather for any day of the week. If
    the day is not found (a value less than `1` or more than `7`), you will explicitly
    return `404 – not found`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个获取任何一周中任何一天天气的方法。如果找不到该天（小于 `1` 或大于 `7` 的值），你将显式返回 `404 – not found`：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, you added one new `{day}` at the end of the endpoint. This is a placeholder
    value, which comes from a matching function argument (in this case, `day`). Rerunning
    the service and navigating to `https://localhost:7021/weatherforecast/weekday/8`
    will result in a `404 – not found` status code because it is more than the max
    allowed day value, which is `7`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你在端点末尾添加了一个新的 `{day}`。这是一个占位符值，来自匹配的函数参数（在这种情况下，`day`）。重新运行服务并导航到 `https://localhost:7021/weatherforecast/weekday/8`
    将导致 `404 – not found` 状态码，因为它超过了最大允许的天数值，即 `7`：
- en: '![Figure 9.5: The response to finding a weather forecast for a non-existent
    day of the week ](img/B16835_09_05.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5：寻找不存在的一周中的天气预报的响应](img/B16835_09_05.jpg)'
- en: 'Figure 9.5: The response to finding a weather forecast for a non-existent day
    of the week'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5：寻找不存在的一周中的天气预报的响应
- en: Note
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/SCudR](https://packt.link/SCudR).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/SCudR](https://packt.link/SCudR) 找到用于此示例的代码。
- en: This concludes the theoretical portion of this topic. In the following section,
    you will put this into practice with an exercise.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了本主题的理论部分。在接下来的部分，你将通过练习将其付诸实践。
- en: 'Exercise 9.01: .NET Core Current Time Service'
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.01：.NET Core 当前时间服务
- en: 'Once you have managed to run a Web API once, adding new controllers should
    be trivial. Often, whether a service is running or not, it is checked using the
    most basic logic; whether it is returning OK or getting the current `DateTime`
    value. In this exercise, you will create a simple current time service returning
    the current time in ISO standard. Perform the following steps to do so:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你成功运行了一个 Web API，添加新的控制器应该很简单。通常，检查一个服务是否在运行，最基本的方法是检查它是否返回 OK 或获取当前的 `DateTime`
    值。在这个练习中，你将创建一个简单的当前时间服务，返回 ISO 标准的当前时间。执行以下步骤来完成此操作：
- en: 'Create a new controller called `TimeController` to get the local time and further
    add functions for testing purposes:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制器 `TimeController` 来获取本地时间，并进一步添加用于测试的功能：
- en: '[PRE9]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The controller shown here isn't just for testing; it acts as business logic
    too.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的控制器不仅仅用于测试；它还充当业务逻辑。
- en: 'Add an endpoint for HTTP GET called `GetCurrentTime` that points to the `time/current`
    route. You will use it to get the current time:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `GetCurrentTime` 的 HTTP GET 端点，指向 `time/current` 路由。你将使用它来获取当前时间：
- en: '[PRE10]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Return the current `DateTime` converted to a string in ISO format:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前的 `DateTime` 转换为 ISO 格式的字符串：
- en: '[PRE11]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Navigate to `https://localhost:7021/time/current` and you should see the following
    response:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `https://localhost:7021/time/current`，你应该看到以下响应：
- en: '[PRE12]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As mentioned in the *Web API Project Structure* section, you can use the endpoint
    to determine whether a service is running or not. If it is running, then you will
    get the `DateTime` value, which you saw in the preceding output. If it is not
    running, then you would get a response with a status code of `404 – not found`.
    If it is running but with problems, then you would get the `500` status code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *Web API 项目结构* 部分所述，你可以使用端点来确定服务是否正在运行。如果它在运行，那么你会得到 `DateTime` 值，这在前面的输出中已经看到。如果它没有运行，那么你会得到一个状态码为
    `404 – not found` 的响应。如果它在运行但存在问题，那么你会得到 `500` 状态码。
- en: Note
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/OzaTd](https://packt.link/OzaTd).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/OzaTd](https://packt.link/OzaTd) 找到用于此练习的代码。
- en: So far, all your focus was on a controller. It's time you shift your attention
    to another crucial part of a Web API—the `Program` class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你所有的关注点都在控制器上。现在是时候将你的注意力转移到 Web API 的另一个关键部分——`Program` 类上。
- en: Bootstrapping a Web API
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web API 的引导
- en: The `Program` class wires up the whole API together. In layman's terms, you
    register the implementations for all the abstractions used by controllers and
    add all the necessary middleware.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Program` 类将整个 API 连接在一起。用通俗易懂的话来说，你注册了所有控制器使用的抽象实现，并添加了所有必要的中间件。'
- en: Dependency Injection
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖注入
- en: In *Chapter 2*, *Building Quality Object-Oriented Code*, you explored the concept
    of DI. In *Chapter 7*, *Creating Modern Web Applications with ASP.NET*, you had
    a look at an example of DI for logging services. In this chapter, you will get
    hands-on experience in DI and the Inversion of Control (IoC) container—a component
    used to wire up and resolve all the dependencies in a central place. In .NET Core
    and later, the default container is `Microsoft.Extensions.DependencyInjection`.
    You will learn more about that a bit later.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 2 章*，*构建面向对象的高质量代码* 中，你探讨了依赖注入（DI）的概念。在 *第 7 章*，*使用 ASP.NET 创建现代 Web 应用程序*
    中，你看到了一个用于日志服务的 DI 示例。在本章中，你将获得在依赖注入（DI）和反转控制（IoC）容器方面的实践经验——这是一个用于在中央位置连接和解决所有依赖关系的组件。在
    .NET Core 及其后续版本中，默认容器是 `Microsoft.Extensions.DependencyInjection`。你将在稍后了解更多关于它的内容。
- en: Program.cs and Minimal API
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Program.cs 和最小 API
- en: 'The simplest Web API in .NET 6 looks like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 6 中最简单的 Web API 看起来是这样的：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is a minimal API because it makes use of the top-level statements feature.
    Prior to .NET 6, you would have two methods within a `Startup` class (`Configure`
    and `ConfigureService`) and a `Program` class. Now you have a single file, `Program.cs`,
    and no classes or methods. You can still use the old way of starting an application.
    In fact, .NET 6 will generate similar classes under the hood. However, if you
    are making a new app in .NET 6, then using a minimal API should be preferred.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个最小 API，因为它使用了顶层语句功能。在 .NET 6 之前，你会在 `Startup` 类（`Configure` 和 `ConfigureService`）和
    `Program` 类中找到两个方法。现在你只有一个文件，`Program.cs`，没有类或方法。你仍然可以使用旧的方式启动应用程序。实际上，.NET 6
    将在底层生成类似的类。然而，如果你正在使用 .NET 6 创建新应用程序，那么使用最小 API 应该是首选的。
- en: 'Break down the preceding code snippet. To start the application, you first
    need to build it. So, you will create a builder using the following line of code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 分析前面的代码片段。要启动应用程序，你首先需要构建它。因此，你将使用以下代码行创建一个构建器：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`builder.Services` specifies which services are to be injected. In this case,
    you registered the implementation of the controllers. So, here you have just one
    controller calling—that is, `WeatherForecastController`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`builder.Services` 指定要注入哪些服务。在这种情况下，你注册了控制器的实现。因此，这里只有一个控制器被调用——即 `WeatherForecastController`：'
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When you use `builder.Build()`, you can access the `app` object and further
    configure the application by adding middleware. For example, to add controller
    routing, call the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `builder.Build()` 时，你可以访问 `app` 对象，并通过添加中间件进一步配置应用程序。例如，要添加控制器路由，请调用以下代码：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Lastly, `builder.Environment.IsDevelopment()` checks whether the environment
    is developed. If it is developed, it calls `app.UseDeveloperExceptionPage();`,
    which adds detailed errors when something fails.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`builder.Environment.IsDevelopment()` 检查环境是否为开发环境。如果是开发环境，它将调用 `app.UseDeveloperExceptionPage();`，在失败时添加详细错误。
- en: Logging is not mentioned anywhere; yet you still use it. A common pattern is
    to group all the related injections under the same extension method for `IServiceCollection`.
    An example of an extension method for all the controller-related functionality,
    including logging, is the `AddControllers` method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 日志在任何地方都没有被提及；但你仍然在使用它。一个常见的模式是将所有相关的注入分组在 `IServiceCollection` 的同一个扩展方法下。所有与控制器相关的功能，包括日志，的扩展方法示例是
    `AddControllers` 方法。
- en: 'You already saw the logging messages sent through the console logger right
    after you ran the API. Under the hood, the `builder.Services.AddLogging` method
    is called. This method clears all the logging providers:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在运行 API 后立即看到了通过控制台日志发送的日志消息。在底层，调用了 `builder.Services.AddLogging` 方法。此方法清除所有日志提供程序：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you run the application now, you will not see anything appear in the console
    (*Figure 9.6*):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序，你将不会在控制台（*图 9.6*）中看到任何内容：
- en: '![Figure 9.6: Running an application with no logs displayed ](img/B16835_09_06.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6：运行不显示日志的应用程序](img/B16835_09_06.jpg)'
- en: 'Figure 9.6: Running an application with no logs displayed'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6：运行不显示日志的应用程序
- en: 'However, if you modify `AddLogging` to include `Console` and `Debug` logging
    in the following way, you will see the logs as in *Figure 9.7*:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你将 `AddLogging` 修改为包含 `Console` 和 `Debug` 日志，如下所示，你将看到如图 *9.7* 所示的日志：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, add an error logging functionality to the error endpoint of `WeatherForecastController`.
    This will throw an exception when a rare circumstance arises while a program is
    running:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，向 `WeatherForecastController` 的错误端点添加错误日志功能。当程序运行时出现罕见情况时，这将抛出异常：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Restart the API with the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令重启 API：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, call `https://localhost:7021/weatherforecast/error` and this will show
    the logged message (compare *Figure 9.6* and *Figure 9.7*):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，调用`https://localhost:7021/weatherforecast/error`，这将显示记录的消息（比较*图9.6*和*图9.7*）：
- en: '![Figure 9.7: The error message, Whoops, displayed on the terminal ](img/B16835_09_07.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7：在终端上显示的错误消息，哎呀](img/B16835_09_07.jpg)'
- en: 'Figure 9.7: The error message, Whoops, displayed on the terminal'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7：在终端上显示的错误消息，哎呀
- en: The Inner Workings of the AddLogging Method
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`AddLogging`方法的工作原理'
- en: 'How does the `AddLogging` method work? The decompiled code of the `AddLogging`
    method looks like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddLogging`方法是如何工作的？`AddLogging`方法的反编译代码如下所示：'
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It is best practice not to initialize loggers by yourself. `ILoggerFactory`
    provides that functionality as a single place from which you may create loggers.
    While `ILoggerFactory` is an interface, `LoggerFactory` is an implementation of
    that interface. `AddSingleton` is a method that specifies that a single instance
    of `LoggerFactory` will be created and used whenever `ILoggerFactory` is referenced.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最好不要自己初始化日志记录器。`ILoggerFactory`提供了一个功能，可以从一个单一的位置创建日志记录器。虽然`ILoggerFactory`是一个接口，但`LoggerFactory`是此接口的实现。`AddSingleton`是一个方法，指定将创建并使用单个`LoggerFactory`实例，每当引用`ILoggerFactory`时。
- en: 'Now the question arises: why wasn''t `ILoggerFactory` used in a controller?
    `ILoggerFactory` is used under the hood when resolving an implementation of a
    controller. When exposing a controller dependency such as a `logger`, you no longer
    need to care about how it gets initialized. This is a great benefit because it
    makes the class holding a dependency both more simple and more flexible.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在问题来了：为什么在控制器中没有使用`ILoggerFactory`？在解析控制器实现时，`ILoggerFactory`在幕后使用。当公开控制器依赖项，如`logger`时，你不再需要关心它是如何初始化的。这是一个巨大的好处，因为它使得持有依赖项的类既更简单又更灵活。
- en: 'If you do want to use `ILoggerFactory` instead of `Ilogger`, you could have
    a constructor accepting the factory, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实想使用`ILoggerFactory`而不是`Ilogger`，你可以有一个接受工厂的构造函数，如下所示：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can then use it to create a `logger`, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以用它来创建一个`logger`，如下所示：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This latter `logger` functions the same as the former.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个后者的`logger`功能与前者相同。
- en: This section dealt with the `AddSingleton` method for managing service dependencies
    in a central place. Proceed to the next section to solve dependency complexities
    with DI.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了在中央位置管理服务依赖的`AddSingleton`方法。继续下一节，使用依赖注入解决依赖复杂性。
- en: The Lifetime of an Injected Component
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注入组件的生命周期
- en: The `AddSingleton` method is useful because complex applications have hundreds,
    if not thousands, of dependencies often shared across different components. It
    would be quite a challenge to manage the initialization of each. DI solves that
    problem by providing a central place for managing dependencies and their lifetimes.
    Before proceeding further, you'll need to learn more about DI lifetimes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddSingleton`方法很有用，因为复杂的应用程序有数百甚至数千个依赖项，通常跨不同组件共享。管理每个初始化都是一个相当大的挑战。依赖注入通过提供一个集中位置来管理依赖项及其生命周期来解决此问题。在继续前进之前，你需要了解更多关于依赖注入生命周期的知识。'
- en: 'There are three injected object lifetimes in .NET:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: .NET中有三种注入对象的生命周期：
- en: 'Singleton: Object initialized once per application lifetime'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例：每次应用程序生命周期初始化一次对象
- en: 'Scoped: Object initialized once per request'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围：每次请求初始化一次对象
- en: 'Transient: Object initialized every time it is referenced'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时：每次引用时初始化对象
- en: To better illustrate DI and different service lifetimes, the next section will
    refactor the existing `WeatherForecastController` code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地说明依赖注入和不同的服务生命周期，下一节将重构现有的`WeatherForecastController`代码。
- en: DI Examples within a Service
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务中的依赖注入示例
- en: A service is a holder for logic at the highest level. By itself, a controller
    should not do any business logic and just delegate a request to some other object
    that is able to handle it. Apply this principle and refactor the `GetWeekday`
    method using DI.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是最高级别逻辑的持有者。控制器本身不应执行任何业务逻辑，而应将请求委托给能够处理它的其他对象。应用此原则，并使用依赖注入重构`GetWeekday`方法。
- en: 'First, create an interface for the service to which you will move all the logic.
    This is done to create an abstraction for which you will later provide an implementation.
    An abstraction is needed because you want to move out as much logic as possible
    from the controller into other components:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为你要将所有逻辑移动到的服务创建一个接口。这样做是为了创建一个抽象，你将后来提供实现。需要一个抽象，因为你希望尽可能多地从控制器中移除逻辑：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you move a portion away from a controller, you would like to handle error
    scenarios as well. In this case, if a provided day is not between `1` and `7`,
    you will return a `404 – not found` error. However, at the service level, there
    is no concept of HTTP status codes. Therefore, instead of returning an HTTP message,
    you will be throwing an exception. For the exception to be handled properly, you
    will create a custom exception called `NoSuchWeekdayException`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一部分代码从控制器移开时，你希望同时处理错误场景。在这种情况下，如果提供的日期不在 `1` 和 `7` 之间，你将返回一个 `404 – not
    found` 错误。然而，在服务级别，没有 HTTP 状态码的概念。因此，你将抛出一个异常，而不是返回一个 HTTP 消息。为了正确处理异常，你将创建一个名为
    `NoSuchWeekdayException` 的自定义异常：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, create a class that implements the service. You will move your code here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个实现服务的类。你将把你的代码移到这里：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The only difference here as compared to the previous code is that, instead of
    returning `NotFound`, you have used `throw new NoSuchWeekdayException`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的代码相比，这里唯一的区别是，你使用了 `throw new NoSuchWeekdayException` 而不是返回 `NotFound`。
- en: 'Now, inject the service into a controller:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将服务注入到控制器中：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The cleaned-up controller method, in the *Responding with Different Status
    Codes* section, with minimum business logic, now looks like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *响应不同状态码* 部分的清理后的控制器方法，具有最少的业务逻辑，现在看起来是这样的：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It might still seem like the same code; however, the key point here is that
    the controller no longer does any business logic. It simply maps results from
    the service back to an HTTP response.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来可能还是相同的代码；然而，关键点在于控制器不再执行任何业务逻辑。它只是将服务的结果映射回一个 HTTP 响应。
- en: Note
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the *Error Handling* section, you will return to this and further remove
    code from the controller, making it as light as possible.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *错误处理* 部分中，你将回到这里并进一步从控制器中移除代码，使其尽可能轻量。
- en: 'If you run this code, you would get the following exception when calling any
    of the controller''s endpoints:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此代码，在调用控制器的任何端点时，你将得到以下异常：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This exception shows that there is no way that `WeatherForecastController`
    can figure out the implementation for `IWeatherForecastService`. So, you need
    to specify which implementation fits the needed abstraction. For example, this
    is done inside the `Program` class as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个异常表明 `WeatherForecastController` 无法确定 `IWeatherForecastService` 的实现。因此，你需要指定哪个实现适合所需的抽象。例如，这可以在
    `Program` 类中如下完成：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `AddSingleton` method reads this as for the `IWeatherForecastService`, `WeatherForecastService`
    **implementation**. In the following paragraphs, you will learn how exactly it
    works.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddSingleton` 方法将此视为 `IWeatherForecastService` 的 `WeatherForecastService`
    **实现**。在接下来的段落中，你将了解它是如何工作的。'
- en: Now that you have a service to be injected, you can explore what effect each
    injection has on service calls when calling the following controller method. For
    that point, you will slightly modify `WeatherForecastService` and `WeatherForecastController`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个要注入的服务，你可以探索每次调用以下控制器方法时每个注入对服务调用的影响。为此，你将稍微修改 `WeatherForecastService`
    和 `WeatherForecastController`。
- en: 'Within `WeatherForecastService`, do the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `WeatherForecastService` 中，执行以下操作：
- en: 'Inject a `logger`:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '注入一个 `logger`:'
- en: '[PRE31]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When the service is initialized, log a random `Guid` that changes the constructor
    to look like this:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当服务初始化时，记录一个随机的 `Guid`，将构造函数修改如下：
- en: '[PRE32]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Within `WeatherForecastController`, do the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `WeatherForecastController` 中，执行以下操作：
- en: 'Inject the second instance of `WeatherForecastService`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注入 `WeatherForecastService` 的第二个实例：
- en: '[PRE33]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Call both instances when getting a weekday:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在获取星期几时调用两个实例：
- en: '[PRE34]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `GetWeekday` method is called twice because it will help illustrate DI lifetimes
    better. Now it is time to explore different DI lifetimes.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetWeekday` 方法被调用了两次，因为这有助于更好地说明依赖注入的生命周期。现在，是时候探索不同的依赖注入生命周期了。'
- en: Singleton
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例
- en: 'Register the service as a singleton in `Program.cs` in the following way:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式在 `Program.cs` 中将服务注册为单例：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After calling the application, you will see the following logs generated while
    running the code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用应用程序后，你将看到以下日志在运行代码时生成：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you call the application again, you will see the same GUID logged:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次调用应用程序，你将看到相同的 GUID 已被记录：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This proves that the service was initialized only once.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了服务只初始化了一次。
- en: Scoped
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域
- en: 'Register the service as scoped in `Program.cs` in the following way:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式在 `Program.cs` 中将服务注册为作用域：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After calling the application, you will see the following logs generated while
    running the code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用应用程序后，你将看到以下日志在运行代码时生成：
- en: '[PRE39]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'On calling `WeatherForecastService` again, you will see the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 再次调用 `WeatherForecastService` 时，你将看到以下内容：
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is a different GUID that has been logged. This proves that the service
    was initialized once per request, but a new instance was initialized on a new
    request.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不同的 GUID，已经被记录。这证明了服务每次请求都会初始化一次，但在新的请求上会初始化一个新的实例。
- en: Transient
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 瞬态
- en: 'Register the service as transient in `Program.cs` in the following way:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中将服务注册为瞬态的方式如下：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After calling the application, you should see the following in the logs generated
    while running the code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用应用程序后，你应该在运行代码时生成的日志中看到以下内容：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: That there are two different GUIDs logged proves that both services were initialized
    using different instances. It is possible to use DI and IoC outside of the Web
    API. DI through IoC is just another library with a few extras given by the Web
    API template.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个不同的 GUID 被记录证明这两个服务都是使用不同的实例初始化的。在 Web API 之外使用 DI 和 IoC 是可能的。通过 IoC 的 DI
    只是一个带有 Web API 模板提供的少量额外功能的库。
- en: Note
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you want to use IoC outside of ASP.NET Core, install the following NuGet
    (or other IoC container): `Microsoft.Extensions.DependencyInjection`.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在 ASP.NET Core 之外使用 IoC，请安装以下 NuGet（或其他 IoC 容器）：`Microsoft.Extensions.DependencyInjection`。
- en: TryAdd
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TryAdd
- en: So far, you have wired implementations to their abstractions using an `Add[Lifetime]`
    function. However, that is not the best practice in most cases. Usually, you'll
    want a single implementation to be wired for a single abstraction. However, if
    you repeatedly call `Add[Lifetime]`, for example, the `AddSingleton` function,
    you will create a collection of implementing instances (duplicates) underneath.
    This is rarely the intention and therefore you should protect yourself against
    that.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经使用 `Add[Lifetime]` 函数将实现与其抽象连接起来。然而，在大多数情况下，这并不是最佳实践。通常，你希望单个实现与单个抽象连接。然而，如果你反复调用
    `Add[Lifetime]`，例如 `AddSingleton` 函数，你将在下面创建一个实现实例的集合（重复）。这很少是意图，因此你应该保护自己免受这种情况的影响。
- en: The cleanest way to wire dependencies is through the `TryAdd[Lifetime]` method.
    In the case of a duplicate dependency, it will simply not add a duplicate. To
    illustrate the difference between the two versions of DIs, compare the injected
    service counts using different methods. Here, you will inject two identical services
    as a singleton.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 连接依赖项最干净的方式是通过 `TryAdd[Lifetime]` 方法。在重复依赖项的情况下，它将简单地不会添加重复项。为了说明两种 DIs 版本之间的区别，比较使用不同方法注入的服务数量。在这里，你将注入两个相同的服务作为单例。
- en: 'Here you are using the `Add[Lifetime]` service as a singleton:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用 `Add[Lifetime]` 服务作为单例：
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The command will display the following output:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将显示以下输出：
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here you are using the `TryAdd[Lifetime]` service as a singleton:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用 `TryAdd[Lifetime]` 服务作为单例：
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The command will display the following output:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将显示以下输出：
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Observe that `Add[Lifetime]` added a duplicate in the output, while `TryAdd[Lifetime]`
    did not. Since you don't want duplicate dependencies, it's recommended that you
    use the `TryAdd[Lifetime]` version.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `Add[Lifetime]` 在输出中添加了重复项，而 `TryAdd[Lifetime]` 没有这样做。由于你不想有重复的依赖项，建议使用
    `TryAdd[Lifetime]` 版本。
- en: 'You can do an injection for a concrete class as well. Calling `builder.Services.AddSingleton<WeatherForecastService,
    WeatherForecastService>();` is a valid C# code; however, it does not make much
    sense. DI is used to inject an implementation into an abstraction. This will not
    work when bootstrapping the service because the following error will be displayed:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为具体的类进行注入。调用 `builder.Services.AddSingleton<WeatherForecastService, WeatherForecastService>();`
    是有效的 C# 代码；然而，这并没有太多意义。DI 用于将实现注入到抽象中。在启动服务时这不会工作，因为以下错误将会显示：
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The error occurs because there is still an abstraction-implementation binding
    to be provided. It would only work if a concrete implementation, rather than an
    abstraction, were exposed in the constructor of the controller. In practice, this
    scenario is rarely used.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 错误发生是因为仍然需要提供抽象-实现绑定。只有当控制器构造函数中暴露的是具体实现而不是抽象时，它才会工作。在实践中，这种情况很少使用。
- en: You have learned that the cleanest way of wiring dependencies is through the
    `TryAdd[Lifetime]` method. You will now create a service that accepts primitive
    arguments (`int` and `string`) and see how it manages its non-primitive dependencies
    in an IoC container.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解到通过 `TryAdd[Lifetime]` 方法是连接依赖项最干净的方式。现在你将创建一个接受原始参数（`int` 和 `string`）的服务，并查看它在
    IoC 容器中如何管理其非原始依赖项。
- en: Manual Injection Using an IoC Container
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用IoC容器进行手动注入
- en: There are scenarios in which you will need to create an instance of a service
    before injecting it. An example use case could be a service with primitive arguments
    in a constructor, in other words, a weather forecast service for a specific city
    with a configured interval for forecast refreshes. So, here, you cannot inject
    a string or an integer, but you can create a service with an integer and a string
    and inject that instead.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些场景，在注入之前你需要创建一个服务实例。一个例子用例可能是一个在构造函数中有原始参数的服务，换句话说，是一个具有配置好的预报刷新间隔的特定城市的天气预报服务。因此，在这里你不能注入一个字符串或一个整数，但你可以创建一个具有整数和字符串的服务并注入它。
- en: 'Modify `WeatherForecastService` with the said features:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`WeatherForecastService`以包含所述功能：
- en: '[PRE48]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Return to the `Program` class and try to inject a service for `New York` with
    a refresh interval of `5` (hours):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到`Program`类，尝试注入一个具有`5`（小时）刷新间隔的`New York`服务：
- en: '[PRE49]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In order to inject the service, as always, you use a version of the `builder.Services.Add[Lifetime]`
    method. However, on top of that, you provided an argument—a delegate specifying
    how a service should be created. The service provider can be accessed by calling
    the `BuildServices` method on `IServiceCollection`. This delegate takes `IServiceProvider`
    as input and uses it to build a new service.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了注入服务，就像往常一样，你使用`builder.Services.Add[Lifetime]`方法的版本。然而，在此基础上，你还提供了一个参数——一个指定如何创建服务的委托。可以通过调用`IServiceCollection`上的`BuildServices`方法来访问服务提供者。这个委托接受`IServiceProvider`作为输入，并使用它来构建一个新的服务。
- en: In this case, you did not use it and thus named the argument after the discard
    operator (`_`). The remaining contents of the function are just a simple return
    with the values from the previous paragraph (for brevity, you will not add any
    extra logic to use the new values). If you had a more complex service, for example,
    a service that requires another service, you could call the `.GetService<ServiceType>`
    method from `IServiceProvider`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你没有使用它，因此按照丢弃操作符（`_`）命名了参数。函数的其余部分只是简单地返回上一段落的值（为了简洁，你不会添加任何额外的逻辑来使用新值）。如果你有一个更复杂的服务，例如，需要一个其他服务的服务，你可以从`IServiceProvider`调用`.GetService<ServiceType>`方法。
- en: '`Build` and `Create` are two common method names. However, they should not
    be used interchangeably. Use `Build` when building a single dedicated object,
    while `Create` is used when the intention is to produce many objects of diverse
    types.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`Build`和`Create`是两个常见的函数名。然而，它们不应该被互换使用。当构建单个专用对象时使用`Build`，而当意图是生成多种类型的多个对象时使用`Create`。'
- en: Note
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/fBFRQ](https://packt.link/fBFRQ).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/fBFRQ](https://packt.link/fBFRQ)找到此示例使用的代码。
- en: 'Exercise 9.02: Displaying Current Time in a Country API Time Zone'
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.02：在Country API时区中显示当前时间
- en: In this exercise, you are tasked with creating a Web API that provides the date
    and time at different time zones of UTC. Through a URL, you will pass a number
    between `-12` and `+12` and return the time in that time zone.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你被要求创建一个Web API，该API提供UTC不同时区的日期和时间。通过URL，你将传递一个介于`-12`和`+12`之间的数字，并返回该时区的当前时间。
- en: 'Perform the following steps:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Create an interface called `ICurrentTimeProvider` with a method called `DateTime
    GetTime(string timezone)`:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ICurrentTimeProvider`的接口，其中有一个名为`DateTime GetTime(string timezone)`的方法：
- en: '[PRE50]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create a class called `CurrentTimeUtcProvider` implementing `ICurrentTimeProvider`
    to implement the logic required for the application:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`CurrentTimeUtcProvider`的类，实现`ICurrentTimeProvider`以实现应用程序所需的逻辑：
- en: '[PRE51]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Implement the method of converting the current `DateTime` to `Utc` and then
    offsetting that based on the time zone passed:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现将当前`DateTime`转换为`Utc`并根据传递的时间区进行偏移的方法：
- en: '[PRE52]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create a `CurrentTimeProviderController` controller to make sure it accepts
    `ICurrentTimeProvider` in the constructor:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`CurrentTimeProviderController`控制器以确保它接受构造函数中的`ICurrentTimeProvider`：
- en: '[PRE53]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create an `HttpGet` endpoint called `IActionResult Get(string timezoneId)`,
    which calls the current time provider and returns the current time:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`IActionResult Get(string timezoneId)`的`HttpGet`端点，该端点调用当前时间提供者并返回当前时间：
- en: '[PRE54]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Please note that `{timezoneId}` is not specified in the `HttpGet` attribute.
    This is because the pattern is used for REST parts on an endpoint; however, in
    this scenario, it is passed as an argument of a query string. If a string contains
    whitespaces or other special characters, it should be encoded before being passed.
    You can URL-encode a string using this tool: [https://meyerweb.com/eric/tools/dencoder/](https://meyerweb.com/eric/tools/dencoder/).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`{timezoneId}` 在 `HttpGet` 属性中没有指定。这是因为模式用于端点的 REST 部分；然而，在这个场景中，它作为查询字符串的参数传递。如果字符串包含空格或其他特殊字符，它应该在传递之前进行编码。你可以使用此工具对字符串进行
    URL 编码：[https://meyerweb.com/eric/tools/dencoder/](https://meyerweb.com/eric/tools/dencoder/)。
- en: 'In the `Program` class, inject the service:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program` 类中注入服务：
- en: '[PRE55]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, you injected the service as a singleton because it is stateless.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将服务作为单例注入，因为它是无状态的。
- en: 'Call the `https://localhost:7021/CurrentTime?timezone=[yourtimezone]` endpoint
    with a `timezoneid` value of your choice. For example, you can call the following
    endpoint: `https://localhost:7021/CurrentTime?timezoneid=Central%20Europe%20Standard%20Time`.'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `timezoneid` 值调用 `https://localhost:7021/CurrentTime?timezone=[yourtimezone]`
    端点。例如，你可以调用以下端点：`https://localhost:7021/CurrentTime?timezoneid=Central%20Europe%20Standard%20Time`。
- en: 'You will get the response showing the date and time at that time zone:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到显示该时区日期和时间的响应：
- en: '[PRE56]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/iqGJL](https://packt.link/iqGJL).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/iqGJL](https://packt.link/iqGJL) 找到用于此练习的代码。
- en: OpenAPI and Swagger
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenAPI 和 Swagger
- en: 'OpenAPI is a **REST API** description format. It is a specification of an API
    with the endpoints it has, the authentication methods it supports, the arguments
    it accepts, and the example requests and responses it informs. The REST API works
    with both JSON and XML formats; however, JSON is chosen frequently. Swagger is
    a collection of tools and libraries implementing the OpenAPI standard. Swagger
    generates two things:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI 是一种 **REST API** 描述格式。它定义了 API 的端点、支持的认证方法、接受的参数以及它所提供的事例请求和响应。REST
    API 可以与 JSON 和 XML 格式一起工作；然而，JSON 被频繁选择。Swagger 是一组实现 OpenAPI 标准的工具和库。Swagger
    生成两样东西：
- en: A web page to make calls to your API
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于调用你的 API 的网页
- en: Generate client code
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成客户端代码
- en: 'In .NET, there are two libraries for working with Swagger:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中，有两个库用于与 Swagger 一起工作：
- en: '`NSwag`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSwag`'
- en: '`Swashbuckle`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Swashbuckle`'
- en: Using Swagger Swashbuckle
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Swagger Swashbuckle
- en: 'In this section, you will use `Swashbuckle` to demonstrate one of many ways
    to test APIs and generate API documentation. So, install the `Swashbuckle.AspNetCore`
    package by running the following command:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将使用 `Swashbuckle` 来演示测试 API 和生成 API 文档的多种方法之一。因此，通过运行以下命令安装 `Swashbuckle.AspNetCore`
    包：
- en: '[PRE57]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Just before the `builder.Build()` call, add the following line of code in `Program.cs`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中 `builder.Build()` 调用之前，添加以下代码行：
- en: '[PRE58]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This injects the Swagger services needed to generate the Swagger schema and
    the documentation test page.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这将注入生成 Swagger 架构和文档测试页所需的 Swagger 服务。
- en: 'After `builder.Build()` in `Program.cs`, add the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中的 `builder.Build()` 之后，添加以下内容：
- en: '[PRE59]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The first line supports reaching the OpenAPI Swagger specification and the second
    one allows accessing the specification on a user-friendly web page.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行支持访问 OpenAPI Swagger 规范，第二行允许在用户友好的网页上访问规范。
- en: 'Now, run the program as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下方式运行程序：
- en: '[PRE60]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'When you navigate to `https://localhost:7021/swagger/`, you will see the following
    screen:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导航到 `https://localhost:7021/swagger/` 时，你会看到以下屏幕：
- en: '![Figure 9.8: A user-friendly Swagger endpoint ](img/B16835_09_08.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8：用户友好的 Swagger 端点](img/B16835_09_08.jpg)'
- en: 'Figure 9.8: A user-friendly Swagger endpoint'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8：用户友好的 Swagger 端点
- en: Clicking on any of the endpoints will allow you to send an HTTP request to them.
    This page can be configured to include common information about the project, such
    as the contact information, licenses it is under, description, terms of services,
    and more.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 点击任何端点都可以让你向它们发送 HTTP 请求。这个页面可以被配置为包含关于项目的常见信息，例如联系信息、许可证、描述、服务条款等等。
- en: The benefits of Swagger do not end here. If you had comments, you could include
    them on this page as well. You could also include all the possible response types
    that the endpoint produces. You can even include example requests and set them
    as defaults when calling an API.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger 的好处不止于此。如果你有注释，你还可以将它们包含在这个页面上。你还可以包含端点产生的所有可能的响应类型。你甚至可以包含示例请求，并在调用
    API 时将它们设置为默认值。
- en: 'Create a new endpoint to save a weather forecast and then another one to retrieve
    it. Document both the methods one by one. So, first, update the `IWeatherForecastService`
    interface to include the two new methods, `GetWeekday` and `GetWeatherForecast`,
    as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的端点来保存天气预报，然后另一个端点来检索它。逐一记录这两个方法。因此，首先，更新`IWeatherForecastService`接口以包含两个新方法，`GetWeekday`和`GetWeatherForecast`，如下所示：
- en: '[PRE61]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, add implementations of those methods to `WeatherForecastService`. To
    save the weather forecast, you will need storage, and the simplest storage would
    be `IMemoryCache`. Here, you will need a new field for `IMemoryCache`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，向`WeatherForecastService`添加这些方法的实现。为了保存天气预报，你需要存储，最简单的存储方式是`IMemoryCache`。在这里，你需要为`IMemoryCache`添加一个新的字段：
- en: '[PRE62]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, update the constructor to inject `IMemoryCache`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更新构造函数以注入`IMemoryCache`：
- en: '[PRE63]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, create the `SaveWeatherForecast` method to save a weather forecast:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建`SaveWeatherForecast`方法来保存天气预报：
- en: '[PRE64]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Create a `GetWeatherForecast` method to get a weather forecast:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`GetWeatherForecast`方法来获取天气预报：
- en: '[PRE65]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, go back to `WeatherForecastController` and create an endpoint for each
    method so that you can test it using the HTTP requests:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到`WeatherForecastController`并为每个方法创建一个端点，以便你可以使用HTTP请求来测试它：
- en: '[PRE66]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Please note that when creating a new weather forecast, you return a `CreatedAtAction`
    result. This returns an HTTP status code of `201` with a URI used to get the created
    resource. It was specified that, in order to get the created forecast later, you
    can use `GetWeatherForecast`. The anonymous `new { date = weatherForecast.Date.ToShortDateString()}`
    object specifies the arguments needed to call that action. You passed `Date.ToShortDateString()`
    and not just a date because a full `DateTime` contains more than what you need.
    Here, you need only a date; therefore, you explicitly cut what you don't need.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在创建新的天气预报时，你返回一个`CreatedAtAction`结果。这返回一个HTTP状态码为`201`的URI，用于获取创建的资源。指定了，为了稍后获取创建的预报，你可以使用`GetWeatherForecast`。匿名`new
    { date = weatherForecast.Date.ToShortDateString()}`对象指定了调用该操作所需的参数。你传递了`Date.ToShortDateString()`而不是仅仅一个日期，因为完整的`DateTime`包含了你不需要的信息。在这里，你只需要一个日期；因此，你明确地切掉了不需要的部分。
- en: 'Document each method by describing what it does and what status codes it can
    return. You will then add this information above each endpoint:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 通过描述每个方法的功能和它可以返回的状态码来记录每个方法。然后，你将在每个端点上方添加此信息：
- en: '[PRE67]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You have now added XML docs to the two endpoints. Using `ProducesResponseType`,
    you specified what status codes the endpoints could return. If you refresh the
    Swagger page, you will see the `SaveWeatherForecast` endpoint in Swagger:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经为这两个端点添加了XML文档。使用`ProducesResponseType`，你指定了端点可以返回哪些状态码。如果你刷新Swagger页面，你将看到Swagger中的`SaveWeatherForecast`端点：
- en: '![Figure 9.9: SaveWeatherForecast endpoint in Swagger ](img/B16835_09_09.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图9.9：Swagger中的SaveWeatherForecast端点](img/B16835_09_09.jpg)'
- en: 'Figure 9.9: SaveWeatherForecast endpoint in Swagger'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9：Swagger中的SaveWeatherForecast端点
- en: 'If you refresh the Swagger page, you will see the `GetWeatherForecast` endpoint
    in Swagger:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刷新Swagger页面，你将看到Swagger中的`GetWeatherForecast`端点：
- en: '![Figure 9.10: GetWeatherForecast endpoint in Swagger ](img/B16835_09_10.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图9.10：Swagger中的GetWeatherForecast端点](img/B16835_09_10.jpg)'
- en: 'Figure 9.10: GetWeatherForecast endpoint in Swagger'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10：Swagger中的GetWeatherForecast端点
- en: 'You can see the status code addition, but where did the comments go? By default,
    Swagger does not pick XML docs. You need to specify what it has to do by configuring
    your project file. To do so, add the following piece of code inside `<Project>`
    below the property group of a target framework:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到状态码的添加，但注释去哪里了？默认情况下，Swagger不会选择XML文档。你需要通过配置项目文件来指定它需要做什么。为此，在目标框架属性组下方`<Project>`内添加以下代码段：
- en: '[PRE68]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '![Figure 9.11: Swagger configuration to include XML docs ](img/B16835_09_11.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图9.11：包含XML文档的Swagger配置](img/B16835_09_11.jpg)'
- en: 'Figure 9.11: Swagger configuration to include XML docs'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11：包含XML文档的Swagger配置
- en: 'Lastly, go to the `Program.cs` file and replace `service.AddSwaggerGen()` with this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，转到`Program.cs`文件，将`service.AddSwaggerGen()`替换为以下内容：
- en: '[PRE69]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This is the last piece of code needed to include XML comments in the Swagger
    docs. Now, refresh the page and you should see the comments included:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这是包含XML注释在Swagger文档中所需的最后一部分代码。现在，刷新页面，你应该会看到包含的注释：
- en: '![Figure 9.12: WeatherForecast Swagger docs with XML docs included ](img/B16835_09_12.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图9.12：包含XML文档的WeatherForecast Swagger文档](img/B16835_09_12.jpg)'
- en: 'Figure 9.12: WeatherForecast Swagger docs with XML docs included'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12：包含XML文档的WeatherForecast Swagger文档
- en: Note
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/iQK5X](https://packt.link/iQK5X).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://packt.link/iQK5X](https://packt.link/iQK5X) 找到此示例使用的代码。
- en: There is a lot more that you can do with Swagger; you can include an example
    request and response and give default values to parameters. You can even create
    your own API specification standards and decorate a project namespace to apply
    the same conventions to every controller and their endpoints, but that is beyond
    the scope of this book.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Swagger 做很多事情；您可以将示例请求和响应包含在内，并为参数提供默认值。您甚至可以创建自己的 API 规范标准，并装饰项目命名空间，以便将相同的约定应用到每个控制器及其端点，但这超出了本书的范围。
- en: 'The last thing to mention is the ability to generate a client out of the Swagger
    docs. To do so, follow these steps:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要提到的是，从 Swagger 文档生成客户端的能力。要这样做，请按照以下步骤操作：
- en: In order to download the `swagger.json` OpenAPI documentation artifact, navigate
    to `https://localhost:7021/swagger/v1/swagger.json`.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了下载 `swagger.json` OpenAPI 文档工件，导航到 `https://localhost:7021/swagger/v1/swagger.json`。
- en: Right-click anywhere on the page and select the `Save as` option.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面上任何位置右键单击并选择 `另存为` 选项。
- en: Then, press the `Enter` key.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按 `Enter` 键。
- en: Next, you will use this JSON to generate client code. So, register and log in
    to [https://app.swaggerhub.com/home](https://app.swaggerhub.com/home) (you can
    use your GitHub account).
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您将使用此 JSON 生成客户端代码。因此，注册并登录到 [https://app.swaggerhub.com/home](https://app.swaggerhub.com/home)（您可以使用您的
    GitHub 账户）。
- en: 'In the new window, click the `Create New` button (`1`):'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新窗口中，点击 `创建新` 按钮（`1`）：
- en: '![Figure 9.13: SwaggerHub and the Import API window ](img/B16835_09_13.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.13：SwaggerHub 和导入 API 窗口](img/B16835_09_13.jpg)'
- en: 'Figure 9.13: SwaggerHub and the Import API window'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13：SwaggerHub 和导入 API 窗口
- en: Select the `Import and document API` option.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `导入并记录 API` 选项。
- en: Select the Swagger file you have just downloaded by clicking the `Browse` button (`2`).
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击 `浏览` 按钮（`2`）选择您刚刚下载的 Swagger 文件。
- en: 'Then, hit the `UPLOAD FILE` button:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击 `上传文件` 按钮：
- en: Note
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: When you select the file, the `IMPORT` button (`3` in *Figure 9.13*) changes
    to the `UPLOAD FILE` button (`3` in *Figure 9.14*).
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当您选择文件时，`导入` 按钮（*图 9.13* 中的 `3`）更改为 `上传文件` 按钮（*图 9.14* 中的 `3`）。
- en: '![Figure 9.14: SwaggerHub IMPORT button changed to UPLOAD FILE button ](img/B16835_09_14.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.14：SwaggerHub 导入按钮更改为上传文件按钮](img/B16835_09_14.jpg)'
- en: 'Figure 9.14: SwaggerHub IMPORT button changed to UPLOAD FILE button'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14：SwaggerHub 导入按钮更改为上传文件按钮
- en: On the next screen, leave the name of the service and the version with default values.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏，请使用默认值保留服务的名称和版本。
- en: 'Next, click the `IMPORT DEFINITION` button:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击 `导入定义` 按钮：
- en: '![Figure 9.15: SwaggerHub import Swagger service definition ](img/B16835_09_15.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.15：SwaggerHub 导入 Swagger 服务定义](img/B16835_09_15.jpg)'
- en: 'Figure 9.15: SwaggerHub import Swagger service definition'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.15：SwaggerHub 导入 Swagger 服务定义
- en: Now that the `Swagger.json` API scheme is imported, you can use it to generate
    a strongly typed C# client code to call the API. So, click the `Export` option
    (`1`).
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`Swagger.json` API 规范已导入，您可以使用它生成强类型 C# 客户端代码来调用 API。因此，点击 `导出` 选项（`1`）。
- en: Then, click the `Client SDK` option (`2`).
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击 `客户端 SDK` 选项（`2`）。
- en: 'Select the `csharp` option (`3`):![Figure 9.16: Exporting a new client in the
    C# client from SwaggerHub ](img/B16835_09_16.jpg)'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `csharp` 选项（`3`）：![图 9.16：从 SwaggerHub 导出新的 C# 客户端](img/B16835_09_16.jpg)
- en: 'Figure 9.16: Exporting a new client in the C# client from SwaggerHub'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.16：从 SwaggerHub 导出新的 C# 客户端
- en: A `csharp-client-generated.zip` file will be downloaded.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 将下载一个 `csharp-client-generated.zip` 文件。
- en: Extract the `csharp-client-generated.zip` file.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取 `csharp-client-generated.zip` 文件。
- en: 'Navigate the extracted folder and open the `IO.Swagger.sln` file. You should
    see the following:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到提取的文件夹并打开 `IO.Swagger.sln` 文件。您应该看到以下内容：
- en: '![Figure 9.17: Files generated for the client using SwaggerHub ](img/B16835_09_17.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.17：使用 SwaggerHub 生成的客户端文件](img/B16835_09_17.jpg)'
- en: 'Figure 9.17: Files generated for the client using SwaggerHub'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.17：使用 SwaggerHub 生成的客户端文件
- en: The generated client code not only has a strongly typed HTTP client but also
    includes tests. It also has a `README.md` file on how to call the client and many
    more common development scenarios.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的客户端代码不仅包含强类型 HTTP 客户端，还包括测试。它还包含一个 `README.md` 文件，说明如何调用客户端以及许多其他常见开发场景。
- en: 'Now, the question that arises is whether you should use Swagger when you already
    have Postman. While Postman is one of the most popular tools used for testing
    different kinds of Web APIs, Swagger is so much more than just a client to test
    whether the API works. Primarily, Swagger is a tool for documenting the API. From
    a conventional code, it allows you to generate all that you might need to:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，出现的一个问题是，当您已经有Postman时，是否应该使用Swagger。虽然Postman是用于测试不同类型Web API的最受欢迎的工具之一，但Swagger远不止是一个测试API是否工作的客户端。首先，Swagger是一个用于记录API的工具。从常规代码中，它允许您生成所有可能需要的内容：
- en: Test page
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试页面
- en: Test the client code
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试客户端代码
- en: Test the documentation page
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试文档页面
- en: Till now, you have learned that Swagger is a collection of tools and libraries
    implementing OpenAPI standards that are helpful for testing and documenting your
    APIs. You can now proceed to grasp error handling.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经了解到Swagger是一组实现OpenAPI标准的工具和库集合，这些工具和库对于测试和记录您的API非常有帮助。现在，您可以继续学习错误处理。
- en: Error Handling
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'You have already learned that the code within a controller should be as minimalistic
    as possible due to it being the highest level in code (direct call). Specific
    error handling should not be included in the controller code because it adds complexity
    to already-complex code. Fortunately, there is a way to map exceptions to HTTP
    status codes and set up all of them in one place—that is, via the `Hellang.Middleware.ProblemDetails`
    package. To do so, first install the package by running this command:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经了解到，由于控制器是代码中的最高级别（直接调用），其内部的代码应该尽可能简洁。特定的错误处理不应该包含在控制器代码中，因为它会增加已经复杂的代码的复杂性。幸运的是，有一种方法可以将异常映射到HTTP状态码，并在一个地方设置所有这些——那就是通过`Hellang.Middleware.ProblemDetails`包。为此，首先通过运行以下命令安装该包：
- en: '[PRE70]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Map `NoSuchWeekdayException` to HTTP status code `404`. In the `Program.cs`
    file, before `builder.Build()`, add the following code:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 将`NoSuchWeekdayException`映射到HTTP状态码`404`。在`Program.cs`文件中，在`builder.Build()`之前添加以下代码：
- en: '[PRE71]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This not only converts an exception to the right status code but also uses `ProblemDetails`—a
    standard response model based on RFC 7807—to provide faults in an HTTP response.
    Also, this excludes exception details in the error message.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅将异常转换为正确的状态码，还使用`ProblemDetails`——一个基于RFC 7807的标准响应模型——在HTTP响应中提供错误。同时，它还排除了错误消息中的异常详情。
- en: When developing a service locally, knowing what went wrong is invaluable. However,
    exposing the stack trace and other information needed to determine the error can
    expose exploits of your Web API. Thus, it's better to hide it when moving toward
    the release stage. By default, the `Hellang` library already excludes the exception
    details in upper environments, so it is better that you don't include that line.
    For demo purposes and a simplified response message, it was included here.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地开发服务时，了解出了什么问题是无价的。然而，暴露确定错误所需的堆栈跟踪和其他信息可能会暴露您的Web API的漏洞。因此，在向发布阶段过渡时，最好将其隐藏。默认情况下，`Hellang`库已经在上层环境中排除了异常详情，因此您最好不包含该行。为了演示目的和简化响应消息，这里将其包含在内。
- en: 'Before you build a demo, you also need to turn off the default developer exceptions
    page because it overrides the exceptions in `ProblemDetails`. Simply remove the
    following block of code from the `Configure` method:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建演示之前，您还需要关闭默认的开发者异常页面，因为它会覆盖`ProblemDetails`中的异常。只需从`Configure`方法中删除以下代码块：
- en: '[PRE72]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Since you already have a central place for handling `NoSuchWeekdayException`,
    you can simplify the controller method for getting `WeatherForecast` for a given date:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您已经有了处理`NoSuchWeekdayException`的中心位置，因此您可以简化获取给定日期的`WeatherForecast`的控制器方法：
- en: '[PRE73]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'When calling the endpoint with an invalid day value (for example, `9`), you
    get the following response:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用无效的天数值调用端点（例如，`9`）时，您会得到以下响应：
- en: '[PRE74]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This centralized error handling approach allows the controllers to be rid of
    all the `try-catch` blocks.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这种集中式错误处理方法使得控制器可以摆脱所有的`try-catch`块。
- en: Note
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/CntW6](https://packt.link/CntW6).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/CntW6](https://packt.link/CntW6)找到用于此示例的代码。
- en: You can now map exceptions to HTTP status codes and set them all up in one place.
    This next section will take a look at another addition to an API, which is request validation.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以映射异常到HTTP状态码，并在一个地方设置它们。接下来的这一节将探讨API的另一个新增功能，即请求验证。
- en: Request Validation
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求验证
- en: Another useful addition to an API is request validation. By default, ASP.NET
    Core has a request validator based on the required attributes. However, there
    might be complex scenarios where a combination of properties results in an invalid
    request or a custom error message for which validation is required.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: API 的另一个有用功能是请求验证。默认情况下，ASP.NET Core 使用基于所需属性的请求验证器。然而，可能存在一些复杂场景，其中属性组合会导致无效请求或需要自定义错误消息的请求，这时需要进行验证。
- en: '.NET has a great NuGet package for that: `FluentValidation.AspNetCore`. Perform
    the following steps to learn how to carry out request validation. Before you continue,
    install the package by running the following command:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 有一个很好的 NuGet 包用于此：`FluentValidation.AspNetCore`。执行以下步骤来学习如何执行请求验证。在继续之前，通过运行以下命令安装包：
- en: '[PRE75]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This package allows registering custom validators per model. It makes use of
    existing ASP.NET Core middleware, so all you must do is inject a new validator.
    Create a validator for `WeatherForecast`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 此包允许按模型注册自定义验证器。它利用现有的 ASP.NET Core 中间件，因此你只需注入一个新的验证器。为 `WeatherForecast` 创建一个验证器。
- en: 'A validator should inherit the `AbstractValidator` class. This is not obligatory,
    but it is highly recommended because it implements the common methods for functionality
    and has a default implementation for generic validation:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 验证器应该继承 `AbstractValidator` 类。这不是强制性的，但强烈推荐，因为它实现了功能性的常用方法，并为泛型验证提供了默认实现：
- en: '[PRE76]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Through a generic argument, you specified that this is a validator for `WeatherForecast`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 通过泛型参数，你指定这是一个针对 `WeatherForecast` 的验证器。
- en: 'Next is the validation itself. This is done in a constructor of a validator:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是验证本身。这是在验证器的构造函数中完成的：
- en: '[PRE77]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '`FluentValidation` is a .NET library and is all about fluent API, with self-explanatory
    methods. Here, you require a weather forecast date to be no more than one month
    in the future. The next validation is to have the temperature between `-100 C`
    and `100 C`.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`FluentValidation` 是一个 .NET 库，它完全关于流畅的 API，具有自解释的方法。在这里，你需要一个天气预报日期，不超过一个月。下一个验证是温度在
    `-100 C` 和 `100 C` 之间。'
- en: 'If you ping your API through Swagger, the following request gets displayed:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过 Swagger ping 你的 API，以下请求将显示：
- en: '[PRE78]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The response will be displayed as follows:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 响应将如下显示：
- en: '[PRE79]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: You don't have to use `FluentValidation`, especially if your API is simple and
    does not have complex rules. But in an enterprise setting, it is highly recommended
    that you do use it because the level of detail you can add to your validation
    is unlimited.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必使用 `FluentValidation`，特别是如果你的 API 简单且没有复杂规则的话。但在企业环境中，强烈建议使用它，因为你可以添加到验证中的详细程度是无限的。
- en: You learned about `FluentValidation` and the scenarios where it is useful. The
    next section will touch upon the two options for reading configuration in ASP.NET.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了 `FluentValidation` 以及其有用的场景。下一节将涉及在 ASP.NET 中读取配置的两个选项。
- en: Note
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/uOGOe](https://packt.link/uOGOe).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/uOGOe](https://packt.link/uOGOe) 找到用于此示例的代码。
- en: Configuration
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: 'In ASP.NET Core Web API, you have two options for reading configuration:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core Web API 中，你有两种读取配置的选项：
- en: '`IConfiguration`: This is a global configuration container. Even though it
    allows access to all the configuration properties, injecting it directly into
    other components is inefficient. This is because it is weakly typed and has a
    risk of you trying to get a non-existing configuration property.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IConfiguration`: 这是一个全局配置容器。尽管它允许访问所有配置属性，但直接将其注入到其他组件中是不高效的。这是因为它是弱类型的，并且存在你尝试获取不存在的配置属性的风险。'
- en: '`IOptions`: This is strongly typed and convenient because the configuration
    is fragmented into just the pieces that a component needs.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IOptions`: 这是一个强类型且方便的配置方式，因为配置被分解为组件所需的各个部分。'
- en: You can choose either of the two options. It is best practice to use `IOptions`
    in ASP.NET Core, as the configuration examples will be based on it. Whichever
    option you choose, you need to store the configuration in the `appsettings.json`
    file.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择两种选项中的任何一种。在 ASP.NET Core 中使用 `IOptions` 是最佳实践，因为配置示例将基于它。无论你选择哪种选项，你都需要将配置存储在
    `appsettings.json` 文件中。
- en: 'Move the hardcoded configuration from a constructor (weather forecast city
    and refresh interval) and move it into a configuration section in the `appsettings.json`
    file:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 将硬编码的配置（天气预测城市和刷新间隔）从构造函数中移除，并将其移动到 `appsettings.json` 文件中的配置部分：
- en: '[PRE80]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Create a model representing this configuration section:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个表示此配置部分的模型：
- en: '[PRE81]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'You no longer have to inject the two primitive values into the component. Instead,
    you will inject `IOptions<WeatherForecastConfig>`:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 你不再需要将两个原始值注入到组件中。相反，你将注入 `IOptions<WeatherForecastConfig>`：
- en: '[PRE82]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Before the JSON section is useable, you need to bind to it. This can be done
    by finding the section through `IConfiguration` (via the `builder.Configuration`
    property):'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在可以使用 JSON 部分之前，你需要将其绑定。这可以通过通过 `IConfiguration`（通过 `builder.Configuration`
    属性）找到部分来完成：
- en: '[PRE83]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In this case, `WeatherForecastConfig` has a matching section in the configuration
    file. Therefore, `nameof` was used. So, `nameof` should be preferred when using
    the alternative `string` type. That way, if the name of a type changes, the configuration
    will change consistently (or else the code won't compile).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`WeatherForecastConfig` 在配置文件中有一个匹配的部分。因此，使用了 `nameof`。因此，当使用替代的 `string`
    类型时，应首选 `nameof`。这样，如果类型的名称发生变化，配置将保持一致（否则代码将无法编译）。
- en: Remember the `BuildWeatherForecastService` method you used previously? The beauty
    of it all is that the method can be removed altogether because the service can
    be created without the need for custom initialization. If you compile and run
    the code, you will get the same response.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 记得你之前使用的 `BuildWeatherForecastService` 方法吗？它的美妙之处在于整个方法可以完全删除，因为服务可以在不需要自定义初始化的情况下创建。如果你编译并运行代码，你将得到相同的响应。
- en: Note
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/xoB0K](https://packt.link/xoB0K).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/xoB0K](https://packt.link/xoB0K)找到用于此示例的代码。
- en: 'ASP.NET Core Web API is just a collection of libraries on top of the .NET Core
    framework. You can use `appsettings.json` in other types of applications as well.
    It is better to use individual libraries regardless of the project type you choose.
    In order to use the configuration through JSON, all you need to do is to install
    the following NuGet packages:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core Web API 是在 .NET Core 框架之上的库集合。你可以在其他类型的应用程序中使用 `appsettings.json`。无论你选择的项目类型如何，最好使用单独的库。为了通过
    JSON 使用配置，你需要安装以下 NuGet 包：
- en: '`Microsoft.Extensions.Configuration`'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.Configuration`'
- en: '`Microsoft.Extensions.Configuration.EnvironmentVariables`'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.Configuration.EnvironmentVariables`'
- en: '`Microsoft.Extensions.Configuration.FileExtensions`'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.Configuration.FileExtensions`'
- en: '`Microsoft.Extensions.Configuration.Json`'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.Configuration.Json`'
- en: '`Microsoft.Extensions.Options`'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.Options`'
- en: In this section, you learned how to use `IConfiguration` and `IOptions`. Your
    API is now ready, and it already includes many standard components of a typical
    Web API. The next section will detail how you can handle this complexity in code.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何使用 `IConfiguration` 和 `IOptions`。你的 API 现在已经准备好了，并且它已经包括了典型 Web API
    的许多标准组件。下一节将详细说明你如何在代码中处理这种复杂性。
- en: Development Environments and Configuration
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发环境和配置
- en: Applications often need to have two environments—production and development.
    You want the application development environment to have premade settings, more
    detailed error messages (if possible), more detailed logging, and lastly, debugging
    enabled. All of that is not needed for a production environment and you would
    want to keep it clean.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通常需要有两个环境——生产环境和开发环境。你希望应用程序的开发环境拥有预制的设置，更详细的错误消息（如果可能的话），更详细的日志记录，最后，启用调试。所有这些在生产环境中都不需要，你希望保持其简洁。
- en: Other than the build configuration, you manage environments through different
    configuration files. The `appsettings.json` file is a base configuration file
    and is used across all environments. This configuration file should contain the
    configuration you would like for production.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 除了构建配置之外，你通过不同的配置文件来管理环境。`appsettings.json` 文件是一个基本配置文件，并在所有环境中使用。此配置文件应包含你希望用于生产的配置。
- en: The `Appsettings.development.json` file is a configuration file that will be
    applied when you build your application in debug mode. Here, `appsettings.json`
    will still be used with the development settings overriding the matching sections.
    A common example is described here.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`Appsettings.development.json` 文件是一个配置文件，当你在调试模式下构建应用程序时将应用此文件。在这里，`appsettings.json`
    仍然会使用，但开发设置将覆盖匹配的部分。一个常见的例子在此处描述。'
- en: 'Say `appsettings.json` has the following:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`appsettings.json` 包含以下内容：'
- en: '[PRE84]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'And `appsettings.development.json` has the following:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`appsettings.development.json` 包含以下内容：'
- en: '[PRE85]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Then, the settings used will be the merged file with override matching sections,
    as shown here:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将使用的设置将是具有匹配部分的合并文件，如下所示：
- en: '[PRE86]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In the next section, you will learn how to manage DI more cleanly.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何更干净地管理依赖注入（DI）。
- en: Bootstrapping
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引导
- en: Complexity needs to be handled and the complexity referred to here is the `Program`
    class. You'll need to break it out into smaller pieces and form a Bootstrapping
    directory specifying the components the service is made of.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 需要处理复杂性，这里所指的复杂性是 `Program` 类。你需要将其分解成更小的部分，并形成一个指定服务由哪些组件组成的 Bootstrapping
    目录。
- en: When breaking down code within `Program.cs`, it is recommended to use a fluent
    API pattern. This is a pattern where you can chain multiple function calls from
    a single root object. In this case, you will create several extension methods
    for the `IServiceCollection` type and chain all the module injections one by one.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中分解代码时，建议使用流畅的 API 模式。这是一种模式，其中你可以从单个根对象链式调用多个函数调用。在这种情况下，你将为
    `IServiceCollection` 类型创建几个扩展方法，并逐个链式注入所有模块。
- en: 'To reduce the complexity of the `Program` class, move the DI of different logical
    sections into different files. Each step that follows will do just that. So, split
    the controller and API baseline setup to a new file named `ControllersConfigurationSetup.cs`:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少 `Program` 类的复杂性，将不同逻辑部分的依赖注入（DI）移动到不同的文件中。接下来的每个步骤都将这样做。因此，将控制器和 API 基线设置拆分到名为
    `ControllersConfigurationSetup.cs` 的新文件中：
- en: '[PRE87]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now, move the code for logging to a new file named `LoggingSetup.cs`:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将日志代码移动到名为 `LoggingSetup.cs` 的新文件中：
- en: '[PRE88]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Next, move the request validation logic to a new file named `RequestValidatorsSetup.cs`:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将请求验证逻辑移动到名为 `RequestValidatorsSetup.cs` 的新文件中：
- en: '[PRE89]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Move the Swagger setup logic to a new file named `SwaggerSetup.cs`:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Swagger 设置逻辑移动到名为 `SwaggerSetup.cs` 的新文件中：
- en: '[PRE90]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Move the injection of the `WeatherForecast`-related classes'' code to a new
    file named `WeatherServiceSetup.cs`:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 将与 `WeatherForecast` 相关的类的代码注入移动到名为 `WeatherServiceSetup.cs` 的新文件中：
- en: '[PRE91]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Finally, move the exception mapping of HTTP status codes to a new file named
    `ExceptionMappingSetup.cs`:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将 HTTP 状态码的异常映射移动到名为 `ExceptionMappingSetup.cs` 的新文件中：
- en: '[PRE92]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Now move all the new classes under `/Bootstrap` folder:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将所有新类移动到 `/Bootstrap` 文件夹下：
- en: '![Figure 9.18: Bootstrap folder with the fragmented services injection ](img/B16835_09_18.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.18：带有碎片化服务注入的 Bootstrap 文件夹](img/B16835_09_18.jpg)'
- en: 'Figure 9.18: Bootstrap folder with the fragmented services injection'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.18：带有碎片化服务注入的 Bootstrap 文件夹
- en: '*Figure 9.18* displays the `Bootstrap` folder. This project structure itself
    demonstrates what the API is made up of. So, DI becomes as simple as the following:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9.18* 展示了 `Bootstrap` 文件夹。这个项目结构本身展示了 API 由什么组成。因此，依赖注入（DI）变得像下面这样简单：'
- en: '[PRE93]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'In some cases, you may want to pass the configuration or environment from a
    builder to other bootstrap methods or app methods multiple times. If you find
    yourself repeatedly calling `builder.X`, then consider storing each property in
    a local variable, as shown here:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能希望多次从构建器传递配置或环境到其他引导方法或应用程序方法。如果你发现自己反复调用 `builder.X`，那么考虑将每个属性存储在局部变量中，如下所示：
- en: '[PRE94]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: With this, you will no longer repeatedly access the builder and will instead
    be able to use the needed builder properties directly. This is especially useful
    if you migrate from .NET Core to .NET 6\. `Environment` and `Configuration` used
    to be properties of a `Program` class, while `Services` would be injected into
    the `ConfigureServices` method. In .NET 6, `Services` is accessed through a `builder`
    object. However, with this approach, you can still use those properties or arguments
    as they were.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你将不再反复访问构建器，而是可以直接使用所需的构建器属性。如果你从 .NET Core 迁移到 .NET 6，这特别有用。`Environment`
    和 `Configuration` 以前是 `Program` 类的属性，而 `Services` 会注入到 `ConfigureServices` 方法中。在
    .NET 6 中，`Services` 通过 `builder` 对象访问。然而，使用这种方法，你仍然可以使用这些属性或参数，就像以前一样。
- en: From now on, when referring to services, environments, or configurations, you
    will assume that you are accessing them from `builder.Services`, `builder.Environment`,
    and `builder.Configuration`, accordingly.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，当提到服务、环境或配置时，你将假设你正在从 `builder.Services`、`builder.Environment` 和 `builder.Configuration`
    访问它们，相应地。
- en: Note
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/iQK5X](https://packt.link/iQK5X).
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/iQK5X](https://packt.link/iQK5X) 找到用于此示例的代码。
- en: Calling Another API
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用另一个 API
- en: A working product is usually made of many APIs communicating with each other.
    To communicate effectively, one web service often needs to call another service.
    For example, a hospital may have a website (frontend) that calls a Web API (backend).
    This Web API orchestrates things by making calls to a booking Web API, a billing
    Web API, and a staff Web API. A staff Web API may make calls to an inventory API,
    holidays API, etc.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 一个工作产品通常由许多相互通信的API组成。为了有效通信，一个网络服务通常需要调用另一个服务。例如，一家医院可能有一个网站（前端），该网站调用Web API（后端）。这个Web
    API通过调用预订Web API、计费Web API和员工Web API来协调事务。员工Web API可能会调用库存API、假日API等。
- en: RapidAPI
  id: totrans-434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RapidAPI
- en: As discussed in *Chapter 8*, *Creating and Using Web API Clients*, there are
    various ways of making HTTP calls to other services (though HTTP is not the only
    way to call another service). This time, you will try to get weather forecasts
    from an existing API and format it in your way. For doing so, you will use the
    RapidAPI Weather API, which can be found at [https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/](https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/).
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如第8章所述，在*创建和使用Web API客户端*中，有多种方式可以对其他服务进行HTTP调用（尽管HTTP不是调用另一个服务的唯一方式）。这次，你将尝试从现有的API获取天气预报，并以你自己的方式格式化它。为此，你将使用RapidAPI
    Weather API，该API可以在[https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/](https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/)找到。
- en: Note
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: RapidAPI is a platform that supports many APIs. The site [https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/](https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/)
    is just one example. Many of the APIs present there are free; however, be aware
    that an API that is free today might become paid tomorrow. If that happens by
    the time you read this chapter, go through the examples, and explore the *Weather
    APIs* section at [https://rapidapi.com/category/Weather](https://rapidapi.com/category/Weather).
    You should be able to find similar alternatives there.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: RapidAPI是一个支持许多API的平台。网站[https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/](https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/)只是一个例子。那里展示的许多API都是免费的；然而，请注意，今天免费的API明天可能变成付费的。如果在你阅读这一章的时候发生了这种情况，请查看示例，并探索[https://rapidapi.com/category/Weather](https://rapidapi.com/category/Weather)上的*Weather
    APIs*部分。你应该能在那里找到类似的替代方案。
- en: 'This API requires a GitHub account for use. Perform the following steps to
    use the RapidAPI Weather API:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 此API使用需要GitHub账户。按照以下步骤使用RapidAPI Weather API：
- en: Log in to the website [https://rapidapi.com/community/api/open-weather-map/](https://rapidapi.com/community/api/open-weather-map/).
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录网站[https://rapidapi.com/community/api/open-weather-map/](https://rapidapi.com/community/api/open-weather-map/)。
- en: Note
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can navigate to [https://rapidapi.com/community/api/open-weather-map/](https://rapidapi.com/community/api/open-weather-map/)
    only if you are logged in. So, signup at [https://rapidapi.com/](https://rapidapi.com/)
    and create an account. This is required if you need an API key. Next login and
    select `Weather` category and choose `Open Weather` link.
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只有在登录状态下，你才能导航到[https://rapidapi.com/community/api/open-weather-map/](https://rapidapi.com/community/api/open-weather-map/)。因此，请在[https://rapidapi.com/](https://rapidapi.com/)上注册并创建一个账户。如果你需要API密钥，这是必须的。接下来登录，选择`Weather`类别并选择`Open
    Weather`链接。
- en: 'After you log in to the website, you will see the following window:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 登录网站后，你会看到以下窗口：
- en: '![Figure 9.19: Unsubscribed test page of the Visual Crossing Weather API on
    rapidapi.com ](img/B16835_09_19.jpg)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![图9.19：rapidapi.com上Visual Crossing Weather API的未订阅测试页面](img/B16835_09_19.jpg)'
- en: 'Figure 9.19: Unsubscribed test page of the Visual Crossing Weather API on rapidapi.com'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.19：rapidapi.com上Visual Crossing Weather API的未订阅测试页面
- en: Click the `Subscribe to Test` button to get access (for free) to making calls
    to the Web API. A new window will open.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Subscribe to Test`按钮以免费获取对Web API的调用权限。将打开一个新窗口。
- en: 'Select the `Basic` option, which will allow you to make 500 calls a month to
    that API. For educational purposes, the basic plan should be enough:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Basic`选项，这将允许你每月对该API进行500次调用。出于教育目的，基本计划应该足够：
- en: '![Figure 9.20: RapidAPI subscription fees with a free Basic plan highlighted
    ](img/B16835_09_20.jpg)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![图9.20：带有免费基本计划的RapidAPI订阅费用](img/B16835_09_20.jpg)'
- en: 'Figure 9.20: RapidAPI subscription fees with a free Basic plan highlighted'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20：RapidAPI订阅费用，免费的基本计划突出显示
- en: You will be redirected to the test page with the `Test Endpoint` button available
    (instead of the `Subscribe to Test` button).
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被重定向到带有`Test Endpoint`按钮的测试页面（而不是`Subscribe to Test`按钮）。
- en: Now, configure the request. The first configuration asks you to enter the intervals
    for getting the weather forecast. You want an hourly forecast, so enter `1` hour
    beside `aggregateHours` (`1`).
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，配置请求。第一个配置要求你输入获取天气预报的间隔。你想要一个小时的预报，所以在`aggregateHours`（`1`）旁边输入`1`小时。
- en: Next up is the `location` address (`2`).
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`location`地址（`2`）。
- en: In *Figure 9.21*, you can observe that the city, state, and country are specified.
    These fields ask you to enter your address. However, typing your city name would
    also work.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9.21*中，你可以看到城市、州和国家被指定。这些字段要求你输入你的地址。但是，输入你的城市名称也会起作用。
- en: 'Choose the default `contentType` option as `csv` for this API (`3`):'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于此API，选择默认的`contentType`选项为`csv`（`3`）：
- en: '![Figure 9.21: GET weather forecast data request configuration ](img/B16835_09_21.jpg)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![图9.21：GET天气预报数据请求配置](img/B16835_09_21.jpg)'
- en: 'Figure 9.21: GET weather forecast data request configuration'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.21：GET天气预报数据请求配置
- en: This API is interesting because it allows you to return data in different formats—JSON,
    XML, and CSV. It is still a Web API and not so RESTful because the data response
    type is natively CSV. If you choose JSON, it will look unnatural and significantly
    more difficult to work with.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这个API很有趣，因为它允许你以不同的格式返回数据——JSON、XML和CSV。它仍然是一个Web API，并且不是那么RESTful，因为数据响应类型是本地的CSV。如果你选择JSON，它看起来会很不自然，并且处理起来会困难得多。
- en: On the next screen, click `Code Snippets` (`1`) and then `(C#) HttpClient` (`2`)
    to see the example client code generated for you.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏幕上，点击`Code Snippets`（`1`）然后点击`(C#) HttpClient`（`2`）来查看为你生成的示例客户端代码。
- en: Next, click `Test Endpoint` (`3`) to send a request.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击`Test Endpoint`（`3`）发送请求。
- en: 'Click the `Results` tab (`4`) to view the response (in *Figure 9.22*, other
    endpoints are collapsed):'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Results`标签（`4`）来查看响应（在*图9.22*中，其他端点已折叠）：
- en: '![Figure 9.22: rapidapi.com with test request page and example code  in C#
    for making the request ](img/B16835_09_22.jpg)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![图9.22：rapidapi.com带有测试请求页面和C#示例代码的请求](img/B16835_09_22.jpg)'
- en: 'Figure 9.22: rapidapi.com with test request page and example code in C# for
    making the request'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.22：rapidapi.com带有测试请求页面和C#示例代码的请求
- en: This window provides a nice API. It is also a great way to learn how to make
    calls to it by giving multiple examples of creating clients using a variety of
    languages and technologies.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 此窗口提供了一个优秀的API。这也是通过提供多种语言和技术创建客户端的多个示例来学习如何调用它的绝佳方式。
- en: As always, you will not initialize this client directly in a client but inject
    the client somehow. In *Chapter 8*, *Creating and Using Web API Clients*, it was
    mentioned that to have a static `HttpClient` over one constantly disposed is an
    efficient practice. However, for a Web API, there is an even better alternative—`HttpClientFactory`.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，你不会直接在客户端中初始化此客户端，而是以某种方式注入客户端。在*第8章*，*创建和使用Web API客户端*中提到，为了有一个静态的`HttpClient`，这是一个高效的实践。然而，对于Web
    API来说，有一个更好的替代方案——`HttpClientFactory`。
- en: 'Before you do all that, you need to prepare a few things. First, update the
    `appsettings.json` file with the inclusion of the base URL of an API:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在做所有这些之前，你需要准备一些事情。首先，更新`appsettings.json`文件，包括API的基本URL：
- en: '[PRE95]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Next, you will need to create another class for fetching the weather details
    from the said API. For that purpose, you will need an API key. You can find it
    in the example code snippet on the API website:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要为从该API获取天气详情创建另一个类。为此，你需要一个API密钥。你可以在API网站上的示例代码片段中找到它：
- en: '![Figure 9.23: RapidAPI API key in the example code snippet ](img/B16835_09_23.jpg)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![图9.23：示例代码片段中的RapidAPI API密钥](img/B16835_09_23.jpg)'
- en: 'Figure 9.23: RapidAPI API key in the example code snippet'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.23：示例代码片段中的RapidAPI API密钥
- en: Save the API key as an environment variable because it is a secret and storing
    secrets in code is bad practice. So, name it as `x-rapidapi-key`.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将API密钥保存为环境变量，因为它是一个秘密，将秘密存储在代码中是不好的做法。所以，将其命名为`x-rapidapi-key`。
- en: 'Lastly, the returned weather forecast might be quite different from yours.
    You can see the example response by clicking the `Test Endpoint` button:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，返回的天气预报可能与你的预报大不相同。你可以通过点击`Test Endpoint`按钮来查看示例响应：
- en: '![Figure 9.24: RapidAPI example response from GET current weather data endpoint
    ](img/B16835_09_24.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![图9.24：RapidAPI从GET当前天气数据端点获取的示例响应](img/B16835_09_24.jpg)'
- en: 'Figure 9.24: RapidAPI example response from GET current weather data endpoint'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.24：RapidAPI从GET当前天气数据端点获取的示例响应
- en: Copy the results received after clicking the `Test Endpoint` button.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Test Endpoint`按钮后，复制收到的结果。
- en: Paste the results in [https://toolslick.com/generation/code/class-from-csv](https://toolslick.com/generation/code/class-from-csv).
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果粘贴到[https://toolslick.com/generation/code/class-from-csv](https://toolslick.com/generation/code/class-from-csv)。
- en: Give the class name as `WeatherForecast` and leave the rest of the settings
    as the defaults.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类名指定为`WeatherForecast`，并将其余设置保留为默认值。
- en: 'Finally, press the `GENERATE` button:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，按下`GENERATE`按钮：
- en: '![Figure 9.25: Response content pasted to  https://toolslick.com/generation/code/class-from-csv
    ](img/B16835_09_25.jpg)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
  zh: '![图9.25：将响应内容粘贴到 https://toolslick.com/generation/code/class-from-csv](img/B16835_09_25.jpg)'
- en: 'Figure 9.25: Response content pasted to [https://toolslick.com/generation/code/class-from-csv](https://toolslick.com/generation/code/class-from-csv)'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.25：将响应内容粘贴到[https://toolslick.com/generation/code/class-from-csv](https://toolslick.com/generation/code/class-from-csv)
- en: 'This will create two classes, `WeatherForecast` and `WeatherForecastClassMap`:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建两个类，`WeatherForecast`和`WeatherForecastClassMap`：
- en: '![Figure 9.26: Generated data model and mapping classes (simplified for brevity)
    ](img/B16835_09_26.jpg)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
  zh: '![图9.26：生成的数据模型和映射类（为了简洁而简化）](img/B16835_09_26.jpg)'
- en: 'Figure 9.26: Generated data model and mapping classes (simplified for brevity)'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.26：生成的数据模型和映射类（为了简洁而简化）
- en: '`WeatherForecast` represents the object to which the data from this API will
    be loaded.'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeatherForecast`表示将从该API加载数据的对象。'
- en: Create a file called `WeatherForecast.cs` under the `Dtos` folder (DTO will
    be described in detail in the *DTO and Mapping Using AutoMapper* section) and
    paste the class there.
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Dtos`文件夹下创建一个名为`WeatherForecast.cs`的文件，并将类粘贴到那里（DTO将在*DTO和AutoMapper映射*部分中详细介绍）。
- en: 'Remove the bits that do not have a connection to an already-existing `WeatherForecast`
    model. The cleaned-up model will look as follows:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除与已存在的`WeatherForecast`模型没有连接的部分。清理后的模型将如下所示：
- en: '[PRE96]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: You should know that `WeatherForecastClassMap` is a special class. It is used
    by the `CsvHelper` library, which is used for parsing CSV files. You could parse
    CSV files yourself; however, `CsvHelper` makes it a lot easier to parse.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该知道`WeatherForecastClassMap`是一个特殊类。它由`CsvHelper`库使用，该库用于解析CSV文件。你可以自己解析CSV文件；然而，`CsvHelper`使解析变得容易得多。
- en: 'To use `CsvHelper`, install its NuGet package:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用`CsvHelper`，安装其NuGet包：
- en: '[PRE97]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '`WeatherForecastCsv` represents a mapping from a CSV to a C# object.'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeatherForecastCsv`表示从CSV到C#对象的映射。'
- en: Now, create a file called `WeatherForecastClassMap.cs` under the `ClassMaps`
    folder and paste the class there.
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`ClassMaps`文件夹下创建一个名为`WeatherForecastClassMap.cs`的文件，并将类粘贴到那里。
- en: 'Keep only the mappings that match the `WeatherForecast` class that was edited
    in *Step 17*:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅保留与在*步骤17*中编辑的`WeatherForecast`类匹配的映射：
- en: '[PRE98]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Note
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/dV6wX](https://packt.link/dV6wX)
    and [https://packt.link/mGJMW](https://packt.link/mGJMW).
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/dV6wX](https://packt.link/dV6wX)和[https://packt.link/mGJMW](https://packt.link/mGJMW)找到用于此示例的代码。
- en: In the previous section, you learned how to get weather forecasts from an existing
    API and format them your way using the RapidAPI Weather API. Now it is time to
    proceed to the service client and use the models created, along with the settings,
    parse the API response, and return the current time weather.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了如何从现有的API获取天气预报，并使用RapidAPI Weather API以你的方式格式化它们。现在，是时候继续到服务客户端，使用创建的模型以及设置，解析API响应，并返回当前时间的天气。
- en: Service Client
  id: totrans-496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务客户端
- en: 'Now you have all the ingredients that are needed to create the provider class.
    You learned in *Chapter 8*, *Creating and Using Web API Clients*, that when communicating
    with another API, it''s best to create a separate component for it. So, here you
    will start from an interface abstraction, `IWeatherForecastProvider`:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了创建提供者类所需的所有成分。你在*第8章*，*创建和使用Web API客户端*中学习了，在与另一个API通信时，最好为其创建一个单独的组件。因此，这里你将从接口抽象`IWeatherForecastProvider`开始：
- en: '[PRE99]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Next, create an implementation of that interface—that is, a class taking `HttpClient`
    for DI:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建该接口的实现——即一个使用`HttpClient`进行依赖注入的类：
- en: '[PRE100]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'To implement an interface, start with writing a method definition for getting
    the current weather:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个接口，首先编写一个获取当前天气的方法定义：
- en: '[PRE101]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Next, create a request to call HTTP GET with a relative URI for getting a forecast
    of the CSV type at a given location:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个请求以调用 HTTP GET，并使用相对 URI 获取给定位置的 CSV 类型预报：
- en: '[PRE102]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Now, send a request and verify that it was a success:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，发送一个请求并验证它是否成功：
- en: '[PRE103]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'If the status code is not in the range of `200-300`, the `response.EnsureSuccessStatusCode();`
    throws an exception. Set up a CSV reader to prepare for deserializing weather
    forecasts:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态码不在 `200-300` 范围内，`response.EnsureSuccessStatusCode();` 会抛出异常。设置 CSV 读取器以准备反序列化天气预报：
- en: '[PRE104]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: You are adding a `using` statement to `StringReader` and `CsvReader` because
    both implement the `IDisposable` interface for disposing unmanaged resources.
    This happens when you use the `using` statement within a function after it returns.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在向 `StringReader` 和 `CsvReader` 添加 `using` 语句，因为它们都实现了 `IDisposable` 接口以释放非托管资源。这发生在函数返回后使用
    `using` 语句时。
- en: 'Lastly, deserialize the forecasts:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，反序列化预报：
- en: '[PRE105]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'This way, you request the API to return forecasts starting from today and stopping
    a few days in the future with 1-hour intervals. The first returned forecast is
    the forecast of the current hour—that is, the forecast that you need:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你请求 API 从今天开始返回预报，并在未来几天内以每小时间隔停止。第一个返回的预报是当前小时的预报——即你需要的那一个：
- en: '[PRE106]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Now, you will use `Newtonsoft.Json` for deserialization. Install the following
    package to do so:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将使用 `Newtonsoft.Json` 进行反序列化。安装以下包以实现此目的：
- en: '[PRE107]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Update the `AddControllersConfiguration` method by appending the following
    line on the services object:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 services 对象上追加以下行来更新 `AddControllersConfiguration` 方法：
- en: '[PRE108]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: This line replaces the default serializer with `Newtonsoft.Json`. Now, `Newtonsoft.Json`
    doesn't have to be used; however, it is a much more popular and complete library
    for serialization compared to the default one.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码用 `Newtonsoft.Json` 替换了默认序列化器。现在，不需要使用 `Newtonsoft.Json`；然而，与默认序列化器相比，它是一个更受欢迎且更完整的序列化库。
- en: Note
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/jmSwi](https://packt.link/jmSwi).
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/jmSwi](https://packt.link/jmSwi) 找到用于此示例的代码。
- en: Till now, you have learned how to create a service client and make basic HTTP
    calls using it. It's effective for grasping the basics; however, the classes the
    API uses should be coupled with the classes of the APIs it consumes. In the next
    section, you will learn how to decouple the API from third-party API models using
    a DTO and mapping via `AutoMapper`.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了如何创建服务客户端并使用它进行基本的 HTTP 调用。这对于掌握基础知识是有效的；然而，API 使用的类应该与它所消耗的 API
    的类耦合。在下一节中，你将学习如何使用 DTO 和通过 `AutoMapper` 的映射来解耦 API 与第三方 API 模型。
- en: DTO and Mapping Using AutoMapper
  id: totrans-522
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DTO 和 AutoMapper 的映射
- en: The weather forecast model from RapidAPI is a Date Transfer Object (DTO)—a model
    used just for transferring data and convenient serialization. RapidAPI may change
    its data model and, if that happens, the DTO will change as well. If you are just
    presenting the data you had received and don't need to perform any logical operations
    on it, then any change may be alright.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 RapidAPI 的天气预报模型是一个日期传输对象 (DTO)——一个仅用于传输数据且便于序列化的模型。RapidAPI 可能会更改其数据模型，如果发生这种情况，DTO
    也会随之改变。如果你只是展示接收到的数据而不需要对其执行任何逻辑操作，那么任何更改都可能没问题。
- en: However, you will usually apply business logic to a data model. You already
    know that references to a data model are scattered across multiple classes. With
    every change to a DTO, a class may have to change as well. For example, the DTO
    property that was called `weather` has now changed to `weathers`. Another example
    is of a property that was previously called `description` will now be called a
    `message`. So, renaming a DTO property like this will require you to make changes
    everywhere they are referenced. The bigger the project, the worse of an issue
    this becomes.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你通常会将对数据模型的业务逻辑应用。你已经知道数据模型引用分散在多个类中。每当 DTO 发生变化时，一个类可能也需要更改。例如，之前称为 `weather`
    的 DTO 属性现在已更改为 `weathers`。另一个例子是之前称为 `description` 的属性现在将称为 `message`。因此，像这样重命名
    DTO 属性将需要你在所有引用的地方进行更改。项目越大，这个问题就越严重。
- en: The advice of the SOLID principles is to avoid such changes (refer to *Chapter
    2*, *Building Quality Object-Oriented Code*). One of the ways to achieve this
    is by having two kinds of models—one for domain and the other for outside calls.
    This will require a mapping between foreign objects (coming from outside APIs)
    into your own.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID原则的建议是避免此类更改（参考*第2章*，*构建高质量面向对象代码*）。实现这一目标的一种方法是有两种模型——一种用于领域，另一种用于外部调用。这将需要在来自外部API的外部对象与您自己的对象之间进行映射。
- en: Mapping can be done either manually or by using some popular libraries. One
    of the most popular mapping libraries is AutoMapper. It allows you to map from
    one object to another using property names. You can also make your own mappings.
    Now, you will use this library to configure a mapping between a weather forecast
    DTO and a weather forecast model.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 映射可以通过手动方式或使用一些流行的库来完成。最受欢迎的映射库之一是AutoMapper。它允许您使用属性名称从一个对象映射到另一个对象。您也可以创建自己的映射。现在，您将使用此库来配置一个天气预测DTO和天气预测模型之间的映射。
- en: 'So, first install NuGet:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先安装NuGet：
- en: '[PRE109]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: This library allows you to inject `AutoMapper` into `ServiceCollection`. Here,
    `AutoMapper` uses the `Profile` class to define a mapping.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 此库允许您将`AutoMapper`注入到`ServiceCollection`中。在这里，`AutoMapper`使用`Profile`类来定义映射。
- en: 'A new mapping should inherit the `Profile` class. So, inside the constructor
    of the new profile, use a `CreateMap` method to provide a mapping:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 新的映射应该继承`Profile`类。因此，在新配置文件的构造函数中，使用`CreateMap`方法提供映射：
- en: '[PRE110]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Next, in order to map every property from the `CreateMap` method, call the
    `ForMember` method and specify how to do a mapping:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了从`CreateMap`方法映射每个属性，调用`ForMember`方法并指定如何进行映射：
- en: '[PRE111]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Here, the value of `TemperatureC` comes from `main.temp` inside the DTO.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`TemperatureC`的值来自DTO中的`main.temp`。
- en: 'For the other property, you will concatenate all the weather descriptions into
    one string and call that a summary (`BuildDescription`):'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他属性，您将所有天气描述连接成一个字符串，并将其称为摘要（`BuildDescription`）：
- en: '[PRE112]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Now, use the lambda method, `ForMember`, when building a weather forecast summary
    mapping:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在构建天气预测摘要映射时使用lambda方法`ForMember`：
- en: '[PRE113]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Create a `MapperSetup` class and inject `AutoMapper` from the `AddModelMappings`
    method to provide different mapping profiles:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`MapperSetup`类，并从`AddModelMappings`方法注入`AutoMapper`以提供不同的映射配置文件：
- en: '[PRE114]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Append `.AddModelMappings()` to the `services` object calls. With this, you
    can call `mapper.Map<Model.WeatherForecast>(dtoForecast);`.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 将`.AddModelMappings()`附加到`services`对象调用。有了这个，您就可以调用`mapper.Map<Model.WeatherForecast>(dtoForecast);`。
- en: Note
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/fEfdw](https://packt.link/fEfdw)
    and [https://packt.link/wDqK6](https://packt.link/wDqK6).
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/fEfdw](https://packt.link/fEfdw)和[https://packt.link/wDqK6](https://packt.link/wDqK6)找到用于此示例的代码。
- en: The `AutoMapper` mapping library allows you to map from one object to another
    by default mapping matching property names. The next section will detail how you
    can use DI to reuse `HttpClient`.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '`AutoMapper`映射库允许您通过默认映射匹配属性名称从一个对象映射到另一个对象。下一节将详细介绍如何使用依赖注入（DI）重用`HttpClient`。'
- en: HttpClient DI
  id: totrans-545
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HttpClient DI
- en: 'Continuing with DI, you now want to get into the habit of using the fragmented
    `ConfigureServices` approach. So, first, create a class called `HttpClientsSetup`
    and then create a method for adding the configured `HttpClients`:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用DI，现在您想要养成使用分段的`ConfigureServices`方法的习惯。因此，首先创建一个名为`HttpClientsSetup`的类，然后创建一个用于添加配置的`HttpClients`的方法：
- en: '[PRE115]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Next, for the injection itself, use the `AddHttpClient` method:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于注入本身，使用`AddHttpClient`方法：
- en: '[PRE116]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: In the preceding section, it was mentioned that the keys should be hidden and
    stored in environment variables. To set a default start URI of every call, set
    `BaseAddress` (`WeatherForecastProviderUrl` used in *Step 10* of the *RapidAPI*
    section).
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中提到，密钥应该被隐藏并存储在环境变量中。为了设置每个调用的默认起始URI，设置`BaseAddress`（在*RapidAPI*部分的*步骤10*中使用的`WeatherForecastProviderUrl`）。
- en: 'To append the API key on every request, get the API key that you stored in
    environment variables and assign it to default headers as `x-rapidapi-key`:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个请求中附加API密钥，获取您存储在环境变量中的API密钥，并将其分配给默认头部的`x-rapidapi-key`：
- en: '[PRE117]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'To finish the injection-builder pattern, you need to return the `services`
    object, as follows:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成注入构建器模式，您需要返回`services`对象，如下所示：
- en: '[PRE118]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Now, go back to `services` in `Program` and append the following:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到`Program`中的`services`并附加以下内容：
- en: '[PRE119]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'To integrate the client you have just set up, go to `WeatherForecastService`,
    and inject the `mapper` and `provider` components:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 要集成你刚刚设置的客户端，请转到 `WeatherForecastService`，并注入 `mapper` 和 `provider` 组件：
- en: '[PRE120]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Change the `GetWeatherForecast` method to either get the cached forecast of
    this hour or fetch a new one from the API:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `GetWeatherForecast` 方法更改为获取当前小时的缓存预报或从 API 获取新的预报：
- en: '[PRE121]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: This method, just like the preceding one, first tries to get a value from the
    cache. If the value exists, then the method returns a value. However, if the value
    does not exist, the method calls the API for the preconfigured city, maps the
    DTO forecast to the model forecast, and saves it in the cache.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法与上一个方法类似，首先尝试从缓存中获取一个值。如果值存在，则方法返回该值。但是，如果值不存在，则方法调用预配置城市的 API，将 DTO 预报映射到模型预报，并将其保存到缓存中。
- en: 'If you send an HTTP GET request to `https://localhost:7021/WeatherForecast/`,
    you should see the following response:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向 `https://localhost:7021/WeatherForecast/` 发送一个 HTTP GET 请求，你应该看到以下响应：
- en: '[PRE122]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Calling the same endpoint results in the same response. However, the response
    times are significantly faster due to the cache being used rather than repeating
    a call to the forecast API.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 调用相同的端点会产生相同的响应。然而，由于使用了缓存而不是重复调用预报 API，响应时间显著更快。
- en: Note
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/GMFmm](https://packt.link/GMFmm).
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/GMFmm](https://packt.link/GMFmm)找到此示例使用的代码。
- en: This concludes the theoretical portion of this topic. In the following section,
    you will put this into practice with an exercise.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了本主题的理论部分。在下一节中，你将通过练习将其付诸实践。
- en: 'Exercise 9.03: Performing File Operations by Calling Azure Blob Storage'
  id: totrans-568
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.03：通过调用 Azure Blob 存储执行文件操作
- en: 'A common task with a Web API is to perform a variety of operations on files,
    such as download, upload, or delete. In this exercise, you will reuse a portion
    of `FilesClient` from *Activity 8.04* of *Chapter 8*, *Building Quality Object-Oriented
    Code*, to serve as a baseline client for calling Azure Blob storage and call its
    methods via REST endpoints to do the following operations on a file:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Web API 的一个常见任务是执行各种文件操作，例如下载、上传或删除。在这个练习中，你将重用第 8 章，*构建面向对象的高质量代码*中的*活动
    8.04*中的部分 `FilesClient`，作为调用 Azure Blob 存储的基线客户端，并通过 REST 端点调用其方法来执行以下操作：
- en: Download a file.
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载一个文件。
- en: Get a shareable link with expiration time.
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取一个带有过期时间的可分享链接。
- en: Upload a file.
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传一个文件。
- en: Delete a file.
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除一个文件。
- en: 'Perform the following steps to do so:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成此操作：
- en: 'Extract an interface for `FilesClient` and call it `IFilesService`:'
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `FilesClient` 提取一个接口并命名为 `IFilesService`：
- en: '[PRE123]'
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The new interface is simplified as you will work on a single container. However,
    as per the requirements, you have added a few new methods: `Delete`, `Upload`,
    `Download`, and `GetDownloadLink`. The `Download` method is for downloading a
    file in its raw form—that is, bytes.'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 新的界面简化了，因为你将在一个单独的容器上工作。然而，根据要求，你添加了一些新的方法：`Delete`、`Upload`、`Download` 和 `GetDownloadLink`。`Download`
    方法用于以原始形式（即字节）下载文件。
- en: Create a new class called `Exercises/Exercise03/FilesService.cs`.
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Exercises/Exercise03/FilesService.cs` 的新类。
- en: Copy the following parts of [https://packt.link/XC9qG](https://packt.link/XC9qG%20)
    there.
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下部分复制到[https://packt.link/XC9qG](https://packt.link/XC9qG%20)。
- en: Rename `Client` to `Service`.
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Client` 重命名为 `Service`。
- en: 'Also change the `Exercise04` reference (used in *Chapter 8*, *Building Quality
    Object-Oriented Code*) to `Exercise03` (a new one to be used for this chapter):'
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还将第 8 章，*构建面向对象的高质量代码*中的`Exercise04`引用（用于此章节）更改为`Exercise03`（一个新引用，用于本章）：
- en: '[PRE124]'
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The constructor initializes `blobServiceClient` to get `blobClient`, which
    allows you to do operations in the *Exercice03* directory in the Azure Blob Storage
    Account. If the folder doesn''t exist, `blobServiceClient` will create it for
    you:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '构造函数初始化 `blobServiceClient` 以获取 `blobClient`，这允许你在 Azure Blob 存储账户中的 *Exercice03*
    目录中执行操作。如果文件夹不存在，`blobServiceClient` 将为你创建它： '
- en: '[PRE126]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Note
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For the preceding step to work, you will need an Azure Storage Account. So,
    refer to *Activity 8.04* of *Chapter 8*, *Building Quality Object-Oriented Code*.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使前面的步骤生效，你需要一个 Azure 存储账户。因此，请参考第 8 章，*构建面向对象的高质量代码*中的*活动 8.04*。
- en: 'Create the `ValidateFileExists` method to validate whether a file exists in
    the storage, else throw an exception (a small helper method that did not exist before):'
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `ValidateFileExists` 的方法来验证文件是否存在于存储中，否则抛出异常（一个之前不存在的小助手方法）：
- en: '[PRE127]'
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Now, create the `Delete` method to delete a file:'
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `Delete` 的方法来删除文件：
- en: '[PRE128]'
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Here, you will first get a client for the file and then check whether the file
    exists. If not, then you will throw a `FileNotFoundException` exception. If the
    file exists, then you will delete the file.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将首先获取一个文件客户端，然后检查文件是否存在。如果不存在，则抛出`FileNotFoundException`异常。如果文件存在，则删除该文件。
- en: 'Create the `UploadFile` method to upload a file:'
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`UploadFile`方法来上传文件：
- en: '[PRE129]'
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Once again, you first get a client that allows you to perform operations on
    a file. Then, feed the content and headers to it to upload.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，您首先获取一个允许您对文件执行操作的客户端。然后，向其中提供内容和头以上传。
- en: 'Create the `Download` method to download a file in bytes:'
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于以字节形式下载文件的`Download`方法：
- en: '[PRE130]'
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: This method creates a memory stream and downloads the file to it. Please note
    that this is not going to work on large files.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法创建一个内存流并将文件下载到其中。请注意，这在大文件上可能不起作用。
- en: Note
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you would like to learn more on how to process large files, please refer
    to [https://docs.microsoft.com/en-us/aspnet/core/mvc/models/file-uploads?view=aspnetcore-6.0#upload-large-files-with-streaming](https://docs.microsoft.com/en-us/aspnet/core/mvc/models/file-uploads?view=aspnetcore-6.0#upload-large-files-with-streaming).
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于如何处理大文件的信息，请参阅[https://docs.microsoft.com/en-us/aspnet/core/mvc/models/file-uploads?view=aspnetcore-6.0#upload-large-files-with-streaming](https://docs.microsoft.com/en-us/aspnet/core/mvc/models/file-uploads?view=aspnetcore-6.0#upload-large-files-with-streaming)。
- en: There is a way to present raw downloaded bytes as an image or JSON, rather than
    as generic downloadable content. With an HTTP request or response, you can send
    a header specifying the way the content should be interpreted. This header is
    called Content-Type. Each application will process this differently. In the context
    of Swagger, `image/png` will be displayed as an image, while `application/json`
    will be shown as JSON.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种方法可以将原始下载的字节呈现为图像或JSON，而不是通用可下载内容。通过HTTP请求或响应，您可以发送一个指定内容解释方式的头。这个头被称为Content-Type。每个应用程序都会以不同的方式处理它。在Swagger的上下文中，`image/png`将显示为图像，而`application/json`将显示为JSON。
- en: 'Create a `GetUri` method to get a URI of `blobClient`:'
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`GetUri`方法来获取`blobClient`的URI：
- en: '[PRE131]'
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Getting a URI requires the use of `BlobSasBuilder`, through which you can generate
    a shareable URL to a blob. Through the builder, specify the kind of resource you
    are trying to share (`"b"` stands for blob) and the expiry time. You need to set
    the permissions (to read) and pass the `sasBuilder` builder to the `blobClient`
    client to generate `sasUri`.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 获取URI需要使用`BlobSasBuilder`，通过它可以生成指向blob的可分享URL。通过构建器，指定您要尝试共享的资源类型（`"b"`代表blob）和过期时间。您需要设置权限（读取权限）并将`sasBuilder`构建器传递给`blobClient`客户端以生成`sasUri`。
- en: 'Now, use a filename to create a file download link:'
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用文件名创建一个文件下载链接：
- en: '[PRE132]'
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Inside the `ExceptionMappingSetup` class and the `AddExceptionMappings` method,
    add the following mapping:'
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ExceptionMappingSetup`类和`AddExceptionMappings`方法中，添加以下映射：
- en: '[PRE133]'
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Create an extension method to inject a module of `FileUploadService`:'
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个扩展方法来注入`FileUploadService`模块：
- en: '[PRE134]'
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: An extension method is a simplified way of showing a new method to an existing interface.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法是一种简化显示现有接口新方法的方式。
- en: 'Append it to `services` in `Program.cs` to use the `FileUploadService` module:'
  id: totrans-612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其附加到`Program.cs`中的`services`以使用`FileUploadService`模块：
- en: '[PRE135]'
  id: totrans-613
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Now, create a controller for files:'
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为文件创建一个控制器：
- en: '[PRE136]'
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Controller creation is standard on MVC architecture, and this allows users to
    access `FileService` through HTTP requests.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVC架构中，控制器创建是标准的，这允许用户通过HTTP请求访问`FileService`。
- en: 'Then, inject `IFilesService` to provide an interface through which file-related
    functionality could be accessed:'
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，注入`IFilesService`以提供一个接口，通过该接口可以访问文件相关功能：
- en: '[PRE137]'
  id: totrans-618
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Next, create an endpoint to delete a file:'
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个用于删除文件的端点：
- en: '[PRE138]'
  id: totrans-620
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Create an endpoint to download a file:'
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于下载文件的端点：
- en: '[PRE139]'
  id: totrans-622
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Create an endpoint for getting a shareable file download link:'
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于获取可分享文件下载链接的端点：
- en: '[PRE140]'
  id: totrans-624
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Create an endpoint for uploading a file:'
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于上传文件的端点：
- en: '[PRE141]'
  id: totrans-626
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '`IFormFile` is a common way of passing small files to a controller. However,
    from `IFormFile`, you need file contents as a stream. You can get this using the
    `OpenReadStream` method. Swagger allows you to use the File Explorer window to
    choose the file you want to upload.'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '`IFormFile`是将小文件传递给控制器的一种常见方式。然而，从`IFormFile`中，您需要文件内容作为流。您可以使用`OpenReadStream`方法获取它。Swagger允许您使用文件资源管理器窗口选择要上传的文件。'
- en: Now you run the API.
  id: totrans-628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行API。
- en: 'Your Swagger documentation will have a new section with the controller methods.
    Here are the responses of each:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Swagger文档将有一个新的部分，包含控制器方法。以下是每个方法的响应：
- en: 'Upload file request:'
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传文件请求：
- en: '![Figure 9.27: Upload file request in Swagger ](img/B16835_09_27.jpg)'
  id: totrans-631
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.27：Swagger 中的上传文件请求](img/B16835_09_27.jpg)'
- en: 'Figure 9.27: Upload file request in Swagger'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.27：Swagger 中的上传文件请求
- en: 'Upload file response:'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传文件响应：
- en: '![Figure 9.28: Upload file response in Swagger ](img/B16835_09_28.jpg)'
  id: totrans-634
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.28：Swagger 中的上传文件响应](img/B16835_09_28.jpg)'
- en: 'Figure 9.28: Upload file response in Swagger'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.28：Swagger 中的上传文件响应
- en: 'Get download link request:'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取下载链接请求：
- en: '![Figure 9.29: Get download link request in Swagger ](img/B16835_09_29.jpg)'
  id: totrans-637
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.29：Swagger 中的获取下载链接请求](img/B16835_09_29.jpg)'
- en: 'Figure 9.29: Get download link request in Swagger'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.29：Swagger 中的获取下载链接请求
- en: 'Get download link response:'
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取下载链接响应：
- en: '![Figure 9.30: Get download link response in Swagger ](img/B16835_09_30.jpg)'
  id: totrans-640
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.30：Swagger 中的获取下载链接响应](img/B16835_09_30.jpg)'
- en: 'Figure 9.30: Get download link response in Swagger'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.30：Swagger 中的获取下载链接响应
- en: 'Download file request:'
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载文件请求：
- en: '![Figure 9.31: Download file request in Swagger ](img/B16835_09_31.jpg)'
  id: totrans-643
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.31：Swagger 中的下载文件请求](img/B16835_09_31.jpg)'
- en: 'Figure 9.31: Download file request in Swagger'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.31：Swagger 中的下载文件请求
- en: 'Download file response:'
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载文件响应：
- en: '![Figure 9.32: Download file response in Swagger ](img/B16835_09_32.jpg)'
  id: totrans-646
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.32：Swagger 中的下载文件响应](img/B16835_09_32.jpg)'
- en: 'Figure 9.32: Download file response in Swagger'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.32：Swagger 中的下载文件响应
- en: 'Delete file request:'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除文件请求：
- en: '![Figure 9.33: Delete file request in Swagger ](img/B16835_09_33.jpg)'
  id: totrans-649
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.33：Swagger 中的删除文件请求](img/B16835_09_33.jpg)'
- en: 'Figure 9.33: Delete file request in Swagger'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.33：Swagger 中的删除文件请求
- en: 'Delete file response:'
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除文件响应：
- en: '![Figure 9.34: Delete file response in Swagger ](img/B16835_09_34.jpg)'
  id: totrans-652
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.34：Swagger 中的删除文件响应](img/B16835_09_34.jpg)'
- en: 'Figure 9.34: Delete file response in Swagger'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.34：Swagger 中的删除文件响应
- en: This exercise illustrated the remaining aspects of what you can do with a Web
    API.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习展示了你可以使用 Web API 做的剩余方面。
- en: Note
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/cTa4a](https://packt.link/cTa4a).
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/cTa4a](https://packt.link/cTa4a)找到用于此练习的代码。
- en: The volume of functionality you can serve through the web is immense. However,
    this comes with its own big problem. How do you ensure that your API is consumed
    only by the intended identities? In the next section, you will explore how to
    secure a Web API.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过网络提供的功能量是巨大的。然而，这也伴随着它自己的大问题。你如何确保你的 API 只被预期的身份消费？在下一节中，你将探索如何保护 Web API。
- en: Securing a Web API
  id: totrans-658
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护 Web API
- en: Every now and then, you'll hear about a major security breach on the news. In
    this section, you will learn how to protect a public API using AAD.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 不时地，你会在新闻中听到关于重大安全漏洞的消息。在本节中，你将学习如何使用 Azure Active Directory (AAD) 保护公共 API。
- en: Azure Active Directory
  id: totrans-660
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Azure Active Directory
- en: Azure Active Directory (AAD) is Microsoft's cloud identity and access management
    service that is used to sign in to well-known applications, such as Visual Studio,
    Office 365, and Azure, and to internal resources. AAD uses OpenID to provide user
    identity through a JavaScript Web Token.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Active Directory (AAD) 是微软的云身份和访问管理服务，用于登录到知名应用程序，如 Visual Studio、Office
    365 和 Azure，以及内部资源。AAD 使用 OpenID 通过 JavaScript Web Token 提供用户身份。
- en: JWT
  id: totrans-662
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JWT
- en: A JavaScript Web Token (JWT) is a collection of personal data encoded and sent
    over as a mechanism of authentication. A single field encoded in a JWT is called
    a claim.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript Web Token (JWT) 是一组个人数据，编码后作为身份验证机制发送。JWT 中编码的单个字段称为声明。
- en: OpenID Connect
  id: totrans-664
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenID Connect
- en: OpenID Connect (OIDC) is the protocol used for getting the ID token, which provides
    user identity or an access token. It's a layer on top of OAuth 2 to get an identity.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: OpenID Connect (OIDC) 是用于获取 ID 令牌的协议，该令牌提供用户身份或访问令牌。它是在 OAuth 2 之上的一层，用于获取身份。
- en: OAuth serves as a means of getting an access token on behalf of some user. With
    OIDC, you get an identity; this has a role and access comes from that role. When
    a user wants to log in to a website, OpenID might require them to input their
    credentials. This might sound exactly the same as OAuth; however, don't mix the
    two. OpenID is all about acquiring and verifying the user's identity and granting
    access coming with a role. OAuth, on the other hand, gives access to a user to
    do a limited set of functionalities.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 作为代表某些用户获取访问令牌的手段。使用 OIDC，你获得一个身份；这有一个角色，访问来自该角色。当用户想要登录到网站时，OpenID 可能会要求他们输入他们的凭据。这听起来可能完全一样，就像
    OAuth 一样；然而，不要混淆这两个。OpenID 完全是关于获取和验证用户的身份，并授予与角色相关的访问权限。另一方面，OAuth 给予用户访问权限以执行一组有限的操作。
- en: 'A real-life analogy would be as follows:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 一个现实生活中的类比如下：
- en: 'OpenID: You come to an airport and present your passport (which is issued by
    the government) confirming your role (passenger) and identity that way. You are
    **granted** a **passenger** role and allowed to board an airplane.'
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenID：你来到机场并出示你的护照（由政府签发），以确认你的角色（乘客）和身份。你将被**授予**乘客角色并允许登机。
- en: 'OAuth: You come to an airport and the staff asks you to take part in an emotional
    state tracking event. With your **consent**, the staff (**others**) at the airport
    can now track more of your personal data.'
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth：你来到机场，工作人员要求你参加一个情绪状态跟踪活动。在你的**同意**下，机场的工作人员（**他人**）现在可以跟踪更多你的个人数据。
- en: 'The following is a summary:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个总结：
- en: OpenID provides authentication and **verifies who you are**.
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenID提供身份验证并**验证你是谁**。
- en: OAuth is authorization that allows others to do **things on your behalf**.
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth是一种授权，允许他人代表你做**事情**。
- en: Application Registration
  id: totrans-673
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序注册
- en: 'The first step in securing a Web API using Azure is to create an application
    registration in AAD. Perform the following steps to do so:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Azure保护Web API的第一步是在AAD中创建应用程序注册。执行以下步骤以完成此操作：
- en: 'Navigate to `Azure Active Directory` by typing `active dir` in the search bar:'
  id: totrans-675
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索栏中键入`active dir`以导航到`Azure Active Directory`：
- en: '![Figure 9.35: Azure Active Directory being searched in portal.azure ](img/B16835_09_35.jpg)'
  id: totrans-676
  prefs: []
  type: TYPE_IMG
  zh: '![图9.35：在portal.azure中搜索Azure Active Directory](img/B16835_09_35.jpg)'
- en: 'Figure 9.35: Azure Active Directory being searched in portal.azure'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.35：在portal.azure中搜索Azure Active Directory
- en: In the new window, click the `App registrations` option (`1`).
  id: totrans-678
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新窗口中，点击“应用程序注册”选项（`1`）。
- en: 'Then, click the `New registration` button (`2`):'
  id: totrans-679
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击“新建注册”按钮（`2`）：
- en: '![Figure 9.36: Azure app registration ](img/B16835_09_36.jpg)'
  id: totrans-680
  prefs: []
  type: TYPE_IMG
  zh: '![图9.36：Azure应用程序注册](img/B16835_09_36.jpg)'
- en: 'Figure 9.36: Azure app registration'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.36：Azure应用程序注册
- en: In the new window, enter `Chapter09WebApi` as the name.
  id: totrans-682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新窗口中，输入`Chapter09WebApi`作为名称。
- en: 'Keep the other settings as the default and click the `Register` button:'
  id: totrans-683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持其他设置默认，并点击“注册”按钮：
- en: '![Figure 9.37: The new app registration named Chapter09WebApi ](img/B16835_09_37.jpg)'
  id: totrans-684
  prefs: []
  type: TYPE_IMG
  zh: '![图9.37：名为Chapter09WebApi的新应用程序注册](img/B16835_09_37.jpg)'
- en: 'Figure 9.37: The new app registration named Chapter09WebApi'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.37：名为Chapter09WebApi的新应用程序注册
- en: To access an API, you need at least one scope or role. In this example, you
    will create a scope called `access_as_user`.
  id: totrans-686
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问API，你需要至少一个作用域或角色。在这个例子中，你将创建一个名为`access_as_user`的作用域。
- en: Scopes in general can be used to control which part of an API is accessible
    to you. For the scope to be available for all users, you will need to select `Admins
    and users`.
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作用域通常可以用来控制API的哪些部分对你可访问。为了让作用域对所有用户可用，你需要选择`管理员和用户`。
- en: 'In this trivial example, given the token is valid, you will allow access to
    everything. So, select the `Access all as a user` option. The exact values of
    the other fields do not matter:'
  id: totrans-688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，假设令牌有效，你将允许访问一切。因此，选择“作为用户访问所有内容”选项。其他字段的精确值并不重要：
- en: '![Figure 9.38: The access_as_user scope available for all users ](img/B16835_09_38.jpg)'
  id: totrans-689
  prefs: []
  type: TYPE_IMG
  zh: '![图9.38：对所有用户可用的access_as_user作用域](img/B16835_09_38.jpg)'
- en: 'Figure 9.38: The access_as_user scope available for all users'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.38：对所有用户可用的access_as_user作用域
- en: The first step in securing a Web API using Azure was to create an application
    registration in AAD. The next topic will cover how you can implement security
    within a Web API in .NET.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Azure保护Web API的第一步是在AAD中创建应用程序注册。下一个主题将介绍如何在.NET中实现Web API的安全。
- en: Implementing Web API Security
  id: totrans-692
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现Web API安全
- en: 'This section will focus on the details of how, programmatically, you can get
    the token and work with it. So, first, install NuGet, which does JWT validation
    using the Microsoft identity platform:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将重点介绍如何通过编程方式获取令牌并使用它。因此，首先安装NuGet，它使用Microsoft身份平台进行JWT验证：
- en: '[PRE142]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'In the Bootstrap folder, create the `SecuritySetup` class:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bootstrap文件夹中，创建`SecuritySetup`类：
- en: '[PRE143]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Then, in `Program.cs`, append this to `services`:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Program.cs`中，将以下内容追加到`services`：
- en: '[PRE144]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The injected services are needed by the authorization middleware. So, add the
    following on an `app` to add authorization middleware:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 注入的服务是授权中间件所需的。因此，在`app`上添加以下内容以添加授权中间件：
- en: '[PRE145]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: This will be triggered on all endpoints decorated with the `[Authorize]` attribute.
    Make sure the preceding two lines are placed before `app.MapControllers();` or
    else the middleware will not be wired with your controllers.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在所有带有`[Authorize]`属性的端点上触发。确保前两行在`app.MapControllers();`之前放置，否则中间件将无法与你的控制器连接。
- en: 'Within `appsettings.json`, add the following configuration to link to your
    `AzureAd` security configuration:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 在`appsettings.json`中，添加以下配置以链接到您的`AzureAd`安全配置：
- en: '[PRE146]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Lastly, add the `Authorize` attribute above each controller for any kind of
    security you choose:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在每个控制器上方添加`Authorize`属性以实现您选择的任何类型的安全：
- en: '[PRE147]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: The `Authorize` attribute is essential for any type of security implementation.
    This attribute will perform the generic token validation, while `[RequiredScope("access_as_user")]`
    will check whether the `access_as_user` scope was included or not. What you now
    have is a secured API. If you try calling the `WeatherForecast` endpoints, you
    will get a `401 – Unauthorised` error.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '`Authorize`属性对于任何类型的安全实现都是必不可少的。此属性将执行通用的令牌验证，而`[RequiredScope("access_as_user")]`将检查是否包含`access_as_user`作用域。现在您拥有了一个安全的API。如果您尝试调用`WeatherForecast`端点，您将收到`401
    – 未授权`错误。'
- en: Note
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/ruj9o](https://packt.link/ruj9o).
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/ruj9o](https://packt.link/ruj9o)找到用于此示例的代码。
- en: In the next section, you will learn how to generate a token through the token
    generator app and use it to securely access your API.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何通过令牌生成器应用程序生成令牌，并使用它来安全地访问您的API。
- en: Token Generator App
  id: totrans-710
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 令牌生成器应用程序
- en: 'To call the API, you need to generate a token by creating a console application.
    Before you do that, however, you need to configure one more thing in your app
    registration. Your console application is considered a desktop app. So, when signing
    in, you need a redirect URI. This URI, returned with the code, is used to get
    the access token. To achieve this, perform the following steps:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用API，您需要通过创建控制台应用程序来生成一个令牌。但在这样做之前，您需要在应用程序注册中配置一项内容。您的控制台应用程序被视为桌面应用程序。因此，在登录时，您需要一个重定向URI。这个URI与代码一起返回，用于获取访问令牌。为了实现这一点，请执行以下步骤：
- en: From the left pane in AAD, select the `Authentication` option (`1`) to view
    all configurations with outside applications.
  id: totrans-712
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从AAD的左侧面板中选择`认证`选项（`1`）以查看所有外部应用程序的配置。
- en: 'Next, click the `Add a platform` button (`2`) to configure a new application
    (token generator):'
  id: totrans-713
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击`添加平台`按钮（`2`）以配置新应用程序（令牌生成器）：
- en: '![Figure 9.39: Authentication window with options to configure a new application
    ](img/B16835_09_39.jpg)'
  id: totrans-714
  prefs: []
  type: TYPE_IMG
  zh: '![图9.39：带有配置新应用程序选项的认证窗口](img/B16835_09_39.jpg)'
- en: 'Figure 9.39: Authentication window with options to configure a new application'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.39：带有配置新应用程序选项的认证窗口
- en: 'In the `Configure platforms` section, select the `Mobile and desktop applications`
    button (`3`) to register a console application token generator:'
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`配置平台`部分，选择`移动和桌面应用程序`按钮（`3`）以注册控制台应用程序令牌生成器：
- en: '![Figure 9.40: Selecting the Mobile and desktop applications platform for authentication
    ](img/B16835_09_40.jpg)'
  id: totrans-717
  prefs: []
  type: TYPE_IMG
  zh: '![图9.40：选择认证的移动和桌面应用程序平台](img/B16835_09_40.jpg)'
- en: 'Figure 9.40: Selecting the Mobile and desktop applications platform for authentication'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.40：选择认证的移动和桌面应用程序平台
- en: A new window will open on the screen.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上将会打开一个新窗口。
- en: Type your `Custom redirect URIs` that specify where you will return after the
    successful login to AAD when requesting the token. In this case, it doesn't matter
    so much. So, type any URL.
  id: totrans-720
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入您的`自定义重定向URI`，指定在请求令牌时成功登录到AAD后返回的位置。在这种情况下，这并不那么重要。所以，输入任何URL。
- en: 'Then, click the `Configure` button (`4`):'
  id: totrans-721
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击`配置`按钮（`4`）：
- en: '![Figure 9.41: Configuring the redirect URI ](img/B16835_09_41.jpg)'
  id: totrans-722
  prefs: []
  type: TYPE_IMG
  zh: '![图9.41：配置重定向URI](img/B16835_09_41.jpg)'
- en: 'Figure 9.41: Configuring the redirect URI'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.41：配置重定向URI
- en: 'That completes the configuration of AAD. Now that you have all the infrastructure
    for security, build a console application to generate an access token from AAD:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了AAD的配置。现在，您已经拥有了所有安全基础设施，可以构建一个控制台应用程序来从AAD生成访问令牌：
- en: First, create a new project called `Chapter09.TokenGenerator`. It will allow
    you to generate authorization tokens needed to call your API.
  id: totrans-725
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`Chapter09.TokenGenerator`的新项目。这将允许您生成调用API所需的授权令牌。
- en: Then, make it a console app on .NET Core to keep it simple and display a generated
    token.
  id: totrans-726
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将其设置为.NET Core控制台应用程序以保持简单并显示生成的令牌。
- en: 'Add `Microsoft.Identity.Client` by running the following command:'
  id: totrans-727
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令添加`Microsoft.Identity.Client`：
- en: '[PRE148]'
  id: totrans-728
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: This will allow you to request a token later.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许您稍后请求令牌。
- en: 'Next, in `Program.cs`, create a method to initialize an AAD application client.
    This will be used to prompt browser login, as if you were to log in to the Azure portal:'
  id: totrans-730
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `Program.cs` 中创建一个方法来初始化 AAD 应用程序客户端。这将用于提示浏览器登录，就像您登录到 Azure 门户一样：
- en: '[PRE149]'
  id: totrans-731
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Note
  id: totrans-732
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The values used in the preceding code will differ, depending upon the AAD subscription.
  id: totrans-733
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中使用的值将根据 AAD 订阅的不同而有所不同。
- en: As you can see, the application uses the `clientId` and `tenantId` configured
    in AAD.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，应用程序使用在 AAD 中配置的 `clientId` 和 `tenantId`。
- en: 'Create another method to use the application that requires a user login on
    Azure to get an auth token:'
  id: totrans-735
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个方法来使用需要 Azure 用户登录以获取身份验证令牌的应用程序：
- en: '[PRE150]'
  id: totrans-736
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Now, define the scopes you need:'
  id: totrans-737
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义您需要的范围：
- en: '[PRE151]'
  id: totrans-738
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Replace `api://{clientId}/{scope}` with your own application ID URI if you are
    not using a default value.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不是使用默认值，请将 `api://{clientId}/{scope}` 替换为您自己的应用程序 ID URI。
- en: 'Then, attempt to get a cached token:'
  id: totrans-740
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，尝试获取缓存的令牌：
- en: '[PRE152]'
  id: totrans-741
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The cached token retrieval is required if the login was done earlier. If you
    haven''t signed in before to get a token, you will need to log in to Azure AD:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 如果登录是在之前完成的，则需要缓存令牌检索。如果您之前没有登录以获取令牌，您将需要登录到 Azure AD：
- en: '[PRE153]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Return the access token as the result of a logged-in user so that you can use
    it later to access your APIs:'
  id: totrans-744
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将访问令牌作为已登录用户的结果返回，以便您以后可以使用它来访问您的 API：
- en: '[PRE154]'
  id: totrans-745
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Now, call the two methods and print the result (using the minimal API):'
  id: totrans-746
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，调用这两个方法并打印结果（使用最小 API）：
- en: '[PRE155]'
  id: totrans-747
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Finally, when you run the token app, it will ask you to sign in:'
  id: totrans-748
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当您运行令牌应用程序时，它将要求您登录：
- en: '![Figure 9.42: Sign-in request from Azure ](img/B16835_09_42.jpg)'
  id: totrans-749
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.42：来自 Azure 的登录请求](img/B16835_09_42.jpg)'
- en: 'Figure 9.42: Sign-in request from Azure'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.42：来自 Azure 的登录请求
- en: 'A successful sign-in redirects you to a configured redirect URI with the following message:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 成功登录后，您将被重定向到配置的重定向 URI，并显示以下消息：
- en: '[PRE156]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'You will see that the token will be returned in the console window:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到令牌将在控制台窗口中返回：
- en: '![Figure 9.43: Generated token from the app registration in the console app
    ](img/B16835_09_43.jpg)'
  id: totrans-754
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.43：控制台应用程序中的应用程序注册生成的令牌](img/B16835_09_43.jpg)'
- en: 'Figure 9.43: Generated token from the app registration in the console app'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.43：控制台应用程序中的应用程序注册生成的令牌
- en: 'Now, you can inspect the token using the [https://jwt.io/](https://jwt.io/)
    website. The following screen is displayed, showing two parts: `Encoded` and `Decoded`.
    The `Decoded` part is divided into the following sections:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用 [https://jwt.io/](https://jwt.io/) 网站检查令牌。以下屏幕显示两个部分：`Encoded` 和 `Decoded`。`Decoded`
    部分分为以下部分：
- en: '`HEADER`: This contains a type of token and the algorithm used to encrypt the token.'
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HEADER`：这包含令牌的类型和用于加密令牌的算法。'
- en: '`PAYLOAD`: The claims encoded within the token contain information, such as
    who requested the token and what access has been granted:'
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PAYLOAD`：令牌中编码的声明包含信息，例如谁请求了令牌以及授予了哪些访问权限：'
- en: '![Figure 9.44: Encoded and decoded JWT version on the jwt.io website  using
    your app registration ](img/B16835_09_44.jpg)'
  id: totrans-759
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.44：使用您的应用程序注册在 jwt.io 网站上编码和解码 JWT 版本](img/B16835_09_44.jpg)'
- en: 'Figure 9.44: Encoded and decoded JWT version on the jwt.io website using your
    app registration'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.44：使用您的应用程序注册在 jwt.io 网站上编码和解码 JWT 版本
- en: In this section, you learned how to secure an unsecured API. Security is not
    limited to just an authorization token. As a professional developer, you must
    be aware of the most common vulnerabilities in APIs. A list of the top 10 most
    common security issues is updated every four years based on the trends in the
    industry. This list is called the Open Web Application Security Project (OWASP)
    and can be reached at [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/).
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了如何保护未受保护的 API。安全性不仅限于授权令牌。作为一名专业开发者，您必须了解 API 中最常见的漏洞。根据行业趋势，这份列表每四年更新一次，称为开放
    Web 应用程序安全项目（OWASP），可在 [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)
    访问。
- en: In the next section, you will apply the changes needed for Swagger to work with
    the authorization token.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将应用 Swagger 与授权令牌一起工作的所需更改。
- en: Configuring Swagger Auth
  id: totrans-763
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 Swagger 身份验证
- en: 'To pass an authorization header through Swagger, you will need to add some
    configuration. Follow these steps to do so:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 Swagger 传递授权头，您需要添加一些配置。按照以下步骤进行操作：
- en: 'In order to render an authorization button, add the following block of code
    inside the `SwaggerSetup` class, the `AddSwagger` method, and the `services.AddSwaggerGen(cfg
    =>` section:'
  id: totrans-765
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了渲染一个授权按钮，请在`SwaggerSetup`类中的`AddSwagger`方法和`services.AddSwaggerGen(cfg =>`部分内添加以下代码块：
- en: '[PRE157]'
  id: totrans-766
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'In order to forward the value of a bearer token with an authorization header,
    add the following code snippet:'
  id: totrans-767
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将带有授权头的令牌值转发，请添加以下代码片段：
- en: '[PRE158]'
  id: totrans-768
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'When you navigate to [https://localhost:7021/index.xhtml](https://localhost:7021/index.xhtml),
    you will see that it now contains the `Authorize` button:'
  id: totrans-769
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您导航到[https://localhost:7021/index.xhtml](https://localhost:7021/index.xhtml)时，您将看到它现在包含`Authorize`按钮：
- en: '![Figure 9.45: Swagger docs with Authorize button ](img/B16835_09_45.jpg)'
  id: totrans-770
  prefs: []
  type: TYPE_IMG
  zh: '![图9.45：带有授权按钮的Swagger文档](img/B16835_09_45.jpg)'
- en: 'Figure 9.45: Swagger docs with Authorize button'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.45：带有授权按钮的Swagger文档
- en: 'Click the `Authorize` button to allow you to input the bearer token:'
  id: totrans-772
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Authorize`按钮以允许您输入令牌：
- en: '![Figure 9.46: Bearer token input after clicking the Authorize button ](img/B16835_09_46.jpg)'
  id: totrans-773
  prefs: []
  type: TYPE_IMG
  zh: '![图9.46：点击授权按钮后的令牌输入](img/B16835_09_46.jpg)'
- en: 'Figure 9.46: Bearer token input after clicking the Authorize button'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.46：点击授权按钮后的令牌输入
- en: 'Now, send a request:'
  id: totrans-775
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，发送一个请求：
- en: '![Figure 9.47: Swagger-generated request with a status of 200 generated in
    response ](img/B16835_09_47.jpg)'
  id: totrans-776
  prefs: []
  type: TYPE_IMG
  zh: '![图9.47：Swagger生成的状态为200的请求](img/B16835_09_47.jpg)'
- en: 'Figure 9.47: Swagger-generated request with a status of 200 generated in response'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.47：Swagger生成的状态为200的请求
- en: You will see that the authorization header is added, and the `ok` response (HTTP
    status code `200`) is returned.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到已添加授权头，并返回了`ok`响应（HTTP状态码`200`）。
- en: In this section, you added some configuration to pass an authorization header
    through Swagger.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您添加了一些配置以通过Swagger传递授权头。
- en: Note
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/hMc2t](https://packt.link/hMc2t).
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/hMc2t](https://packt.link/hMc2t)找到此示例使用的代码。
- en: If you make a mistake and your token validation fails, you will get either a
    `401 – unauthorized` or `403 – forbidden` status code returned (often without
    any details). Fixing this error might be a headache. However, it is not too difficult
    to get more information on what went wrong. The next section provides more details.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您出错并且令牌验证失败，您将收到`401 – 未授权`或`403 – 禁止`状态码返回（通常没有任何详细信息）。修复此错误可能很头疼。然而，获取有关出错原因的更多信息并不太难。下一节提供了更多详细信息。
- en: Troubleshooting Token Validation Errors
  id: totrans-783
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 令牌验证错误故障排除
- en: To simulate this scenario, try invalidating the client-id in `appsettings.json`
    by changing any single symbol (for example, the last letter to `b`). Run the request
    and see how the response is displayed as `401`, with nothing else appearing in
    the logs.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 要模拟此场景，尝试通过在`appsettings.json`中更改任何单个符号（例如，最后一个字母更改为`b`）来使客户端-id无效。运行请求并查看响应如何显示为`401`，日志中没有任何其他内容。
- en: 'All the validations and incoming and outcoming requests can be tracked through
    a pipeline. All you must do is change the default minimum logged level from `info`
    to `Trace`. You can do this by replacing the `appsettings.development.json` file
    contents with the following:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 所有验证和入站和出站请求都可以通过管道跟踪。您必须做的就是将默认的最小日志级别从`info`更改为`Trace`。您可以通过替换`appsettings.development.json`文件内容来实现这一点：
- en: '[PRE159]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Do not mix `appsettings.development.json` with `appsettings.json`. The former
    is used for configuration as a whole and the latter overrides the configuration
    but only in certain environments—development (local) in this case.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将`appsettings.development.json`与`appsettings.json`混合使用。前者用于整体配置，而后者覆盖配置，但仅在某些环境中生效——在本例中是开发（本地）环境。
- en: 'If you run the same request again, you will now see a verbose log in the console:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您再次运行相同的请求，您现在将在控制台看到详细的日志：
- en: '[PRE160]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Inspecting it deeper reveals the error as the following:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 深入检查会发现错误如下：
- en: '`Audience validation failed; Audiences: ''api://2d8834d3-6a27-47c9-84f1-0c9db3eeb4bb''.
    Did not match validationParameters`'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '`Audience validation failed; Audiences: ''api://2d8834d3-6a27-47c9-84f1-0c9db3eeb4bb''.
    Did not match validationParameters`'
- en: 'This error indicates a mismatched audience configured in the JWT:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误指示JWT中配置的受众不匹配：
- en: '![Figure 9.48: Token validation error with the error highlighted ](img/B16835_09_48.jpg)'
  id: totrans-793
  prefs: []
  type: TYPE_IMG
  zh: '![图9.48：带有错误高亮的令牌验证错误](img/B16835_09_48.jpg)'
- en: 'Figure 9.48: Token validation error with the error highlighted'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.48：带有错误高亮的令牌验证错误
- en: Now it is time for you to learn about the SOA architecture where components
    of a system are hosted as separate services.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候学习关于SOA架构了，在这种架构中，系统的组件作为独立的服务托管。
- en: Service-Oriented Architecture
  id: totrans-796
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向服务架构
- en: 'Software architecture has come a long way—evolving from monolithic to Service-Oriented
    Architecture (SOA). SOA is an architecture where major layers of applications
    are hosted as separate services. For example, there would be one or more Web APIs
    for data access, one or more Web APIs for business logic, and one or more client
    applications consuming it all. The flow would be like this: the client app calls
    the business Web API, which calls another business Web API or a data access Web
    API.'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构已经走了很长的路——从单体架构发展到面向服务架构（SOA）。SOA是一种将应用程序的主要层作为独立服务托管的架构。例如，将有一个或多个用于数据访问的Web
    API，一个或多个用于业务逻辑的Web API，以及一个或多个消费所有内容的客户端应用程序。流程将如下所示：客户端应用程序调用业务Web API，该API调用另一个业务Web
    API或数据访问Web API。
- en: However, modern software architecture goes one step further to bring a more
    evolved architecture, called microservice architecture.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现代软件架构更进一步，引入了一种更进化的架构，称为微服务架构。
- en: Microservice Architecture
  id: totrans-799
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微服务架构
- en: Microservice architecture is SOA with a single-responsibility principle applied.
    This means that, instead of service-as-a-layer, you now have hosted self-contained
    modules that have a single responsibility. A self-contained service has both data
    access and business logic layers. Instead of many services per layer, in this
    approach, you have many services per module.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构是应用了单一职责原则的SOA。这意味着，你不再有作为一层的服务，而是托管了具有单一职责的自包含模块。一个自包含的服务具有数据访问层和业务逻辑层。在这种方法中，每个模块都有许多服务，而不是每个层都有许多服务。
- en: The purpose of those self-contained modules is to allow multiple teams to work
    on different parts of the same system simultaneously without ever stepping on
    each other's toes. On top of that, parts in a system can be scaled and hosted
    independently and there is no single point of failure. Also, each team is free
    to use whatever technology stack they are most familiar with, as all the communication
    happens through HTTP calls.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 这些自包含模块的目的是允许多个团队同时在不同部分上工作，而不会相互干扰。除此之外，系统中的部分可以独立扩展和托管，且没有单点故障。此外，每个团队都可以自由使用他们最熟悉的任何技术栈，因为所有通信都通过HTTP调用进行。
- en: This concludes the theoretical portion of this topic. In the following section,
    you will put all that you have learned into practice with an activity.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了本主题的理论部分。在接下来的部分中，你将通过一个活动将所学知识付诸实践。
- en: 'Activity 9.01: Implementing the File Upload Service Using Microservice Architecture'
  id: totrans-803
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动九.01：使用微服务架构实现文件上传服务
- en: A microservice should be self-contained and do just one thing. In this activity,
    you will sum up the steps needed for extracting a piece of code into a microservice
    that manages how you work with files through the web (delete, upload, and download).
    This should serve as an overall effective checklist of what needs to be done when
    creating a new microservice.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应该是自包含的，只做一件事。在这个活动中，你将总结将一段代码提取到微服务中的步骤，该微服务管理你通过网页（删除、上传和下载）与文件交互的方式。这应该作为创建新微服务时需要完成的整体有效清单。
- en: 'Perform the following steps to do this:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成此操作：
- en: Create a new project. In this case, it will be a `.NET Core Web API` project
    on the .NET 6.0 framework.
  id: totrans-806
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目。在这种情况下，它将是一个基于.NET 6.0框架的`.NET Core Web API`项目。
- en: Name it `Chapter09.Activity.9.01`.
  id: totrans-807
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名为`Chapter09.Activity.9.01`。
- en: 'Now, add the commonly used NuGet packages:'
  id: totrans-808
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加常用的NuGet包：
- en: '`AutoMapper.Extensions.Microsoft.DependencyInjection`'
  id: totrans-809
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AutoMapper.Extensions.Microsoft.DependencyInjection`'
- en: '`FluentValidation.AspNetCore`'
  id: totrans-810
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FluentValidation.AspNetCore`'
- en: '`Hellang.Middleware.ProblemDetails`'
  id: totrans-811
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hellang.Middleware.ProblemDetails`'
- en: '`Microsoft.AspNetCore.Mvc.NewtonsoftJson`'
  id: totrans-812
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.AspNetCore.Mvc.NewtonsoftJson`'
- en: '`Microsoft.Identity.Web`'
  id: totrans-813
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.Identity.Web`'
- en: '`Swashbuckle.AspNetCore`'
  id: totrans-814
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Swashbuckle.AspNetCore`'
- en: Next, include the Azure Blobs Client package as `Azure.Storage.Blobs`.
  id: totrans-815
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将Azure Blobs客户端包包含为`Azure.Storage.Blobs`。
- en: Create one or more controllers for communication with the Web API. In this case,
    you will move `FileController` to the `Controllers` folder.
  id: totrans-816
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个或多个控制器以与Web API进行通信。在这种情况下，你将`FileController`移动到`Controllers`文件夹。
- en: In order to create one or more services for business logic, move `FilesService`
    to the `Services` folder and `FileServiceSetup` to the `Bootstrap` folder.
  id: totrans-817
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建一个或多个用于业务逻辑的服务，将`FilesService`移动到`Services`文件夹，将`FileServiceSetup`移动到`Bootstrap`文件夹。
- en: Then document API using XML docs and Swagger.
  id: totrans-818
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后使用 XML 文档和 Swagger 记录 API。
- en: Update the `csproj` file to include XML docs.
  id: totrans-819
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `csproj` 文件以包含 XML 文档。
- en: Copy `SwaggerSetup` to the `Bootstrap` folder.
  id: totrans-820
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `SwaggerSetup` 复制到 `Bootstrap` 文件夹。
- en: Configure `Controllers`. In this scenario, it will be a plain one-line `services.AddControllers()`
    under the `ControllersConfigurationSetup` class and the `AddControllersConfiguration`
    method.
  id: totrans-821
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 `Controllers`。在这种情况下，它将是 `ControllersConfigurationSetup` 类和 `AddControllersConfiguration`
    方法下的一个单行 `services.AddControllers()`。
- en: Configure the problem details error mappings. In this case, there are no exceptions
    that you will explicitly handle. So, you will keep it as a one-liner within the
    `ExceptionMappingSetup` class and the `AddExceptionMappings` and `services.AddProblemDetails()`
    methods.
  id: totrans-822
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置问题详细信息错误映射。在这种情况下，你将不会显式处理任何异常。因此，你将保持它在 `ExceptionMappingSetup` 类和 `AddExceptionMappings`
    以及 `services.AddProblemDetails()` 方法中的单行。
- en: Secure the API.
  id: totrans-823
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保护 API。
- en: Create AAD app registration for the new service. Refer to the *Application Registration*
    subsection in the *Securing the Web API* section.
  id: totrans-824
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新服务创建 AAD 应用程序注册。请参考“*保护 Web API*”部分中的“*应用程序注册*”子部分。
- en: Update the configuration of the new service based on the Azure AD app registration
    client, `tenant`, and `app` IDs.
  id: totrans-825
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据 Azure AD 应用程序注册客户端、`tenant` 和 `app` ID 更新新服务的配置。
- en: Inject the needed services and configure the API pipeline.
  id: totrans-826
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注入所需的服务并配置 API 管道。
- en: Copy the `Program` class.
  id: totrans-827
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制 `Program` 类。
- en: Since the `ConfigureServices` method contains extra services, you don't need
    to remove them. Leave the `Configure` method as is.
  id: totrans-828
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 `ConfigureServices` 方法包含额外的服务，你不需要删除它们。保持 `Configure` 方法不变。
- en: Run the service through Swagger and upload a test file. Don't forget to generate
    a bearer token first using the token generator app from the updated values learned
    earlier.
  id: totrans-829
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 Swagger 运行服务并上传测试文件。不要忘记首先使用之前学到的更新值生成令牌生成应用程序中的令牌。
- en: 'After that, try to get a test file that you just uploaded. You should see the
    status code `200`:'
  id: totrans-830
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，尝试获取你刚刚上传的测试文件。你应该看到状态码 `200`：
- en: 'Get download link request:'
  id: totrans-831
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取下载链接请求：
- en: '![Figure 9.49: Get download link request in Swagger ](img/B16835_09_49.jpg)'
  id: totrans-832
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.49：Swagger 中的获取下载链接请求](img/B16835_09_49.jpg)'
- en: 'Figure 9.49: Get download link request in Swagger'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.49：Swagger 中的获取下载链接请求
- en: 'Get download link response:'
  id: totrans-834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取下载链接响应：
- en: '![Figure 9.50: Get download link response in Swagger ](img/B16835_09_50.jpg)'
  id: totrans-835
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.50：Swagger 中的获取下载链接响应](img/B16835_09_50.jpg)'
- en: 'Figure 9.50: Get download link response in Swagger'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.50：Swagger 中的获取下载链接响应
- en: Note
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在 [https://packt.link/qclbF](https://packt.link/qclbF) 找到。
- en: All the services that have been created so far require considerations such as
    hosting, scaling, and availability. In the following section, you will learn about
    serverless and Azure Functions.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止创建的所有服务都需要考虑诸如托管、扩展和可用性等问题。在下一节中，你将了解无服务器和 Azure Functions。
- en: Azure Functions
  id: totrans-840
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure Functions
- en: 'In the preceding section, you learned that microservice architecture is a self-contained
    service with both data access and business logic layers. With this approach, you
    have many services per module. However, working with microservices, especially
    at the start, might seem like a hassle. It might raise doubts such as the following:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，你了解到微服务架构是一个包含数据访问层和业务逻辑层的自包含服务。采用这种方法，每个模块都有许多服务。然而，与微服务一起工作，尤其是在开始时，可能会感觉像是一项麻烦。它可能会引发以下疑问：
- en: What does not big enough mean?
  id: totrans-842
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “不够大”是什么意思？
- en: Should you host on different servers or on the same machine?
  id: totrans-843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该在不同的服务器上托管还是在同一台机器上托管？
- en: Is another cloud hosting model better?
  id: totrans-844
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种云托管模型是否更好？
- en: These questions might be overwhelming. So, a simple way of calling your code
    through HTTP is by using Azure Functions. Azure Functions is a serverless solution
    that allows you to call your functions on the cloud. Serverless does not mean
    that there is no server; you just do not need to manage it by yourself. In this
    section, you will try to port `CurrentTimeController` from *Exercise 9.02* to
    an Azure Function.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题可能令人感到压倒性。因此，通过 HTTP 调用你的代码的一种简单方法是通过使用 Azure Functions。Azure Functions
    是一种无服务器解决方案，它允许你在云中调用你的函数。无服务器并不意味着没有服务器；只是你不需要自己管理它。在本节中，你将尝试将 *练习 9.02* 中的 `CurrentTimeController`
    移植到 Azure Function。
- en: Note
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Before proceeding with the steps, install Azure Functions Core Tools first
    using the instructions here: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=v3%2Cwindows%2Ccsharp%2Cportal%2Cbash%2Ckeda#install-the-azure-functions-core-tools](https://docs.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=v3%2Cwindows%2Ccsharp%2Cportal%2Cbash%2Ckeda#install-the-azure-functions-core-tools).
    Azure Functions Core Tools also requires the Azure CLI to be installed (if you
    want to publish an Azure Functions application and not on a server). Follow the
    instructions here: [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-windows?tabs=azure-cli](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-windows?tabs=azure-cli).'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一步之前，首先使用以下说明安装 Azure Functions Core Tools：[https://docs.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=v3%2Cwindows%2Ccsharp%2Cportal%2Cbash%2Ckeda#install-the-azure-functions-core-tools](https://docs.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=v3%2Cwindows%2Ccsharp%2Cportal%2Cbash%2Ckeda#install-the-azure-functions-core-tools)。Azure
    Functions Core Tools 还需要安装 Azure CLI（如果你想要发布 Azure Functions 应用程序，而不是在服务器上）。请按照以下说明操作：[https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-windows?tabs=azure-cli](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-windows?tabs=azure-cli)。
- en: 'Perform the following steps to do so:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以实现此目的：
- en: In VS Code, click the `Extenstions` icon (`1`).
  id: totrans-849
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中，点击 `扩展` 图标 (`1`)。
- en: Then search for `azure function` in the search text box (`2`).
  id: totrans-850
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在搜索文本框中搜索 `azure function` (`2`)。
- en: 'Then, install the `Azure Functions` extension (`3`):'
  id: totrans-851
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，安装 `Azure Functions` 扩展 (`3`)：
- en: '![Figure 9.51: Searching for the Azure Functions extension in VS Code ](img/B16835_09_51.jpg)'
  id: totrans-852
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.51：在 VS Code 中搜索 Azure Functions 扩展](img/B16835_09_51.jpg)'
- en: 'Figure 9.51: Searching for the Azure Functions extension in VS Code'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.51：在 VS Code 中搜索 Azure Functions 扩展
- en: A new Azure tab will appear on the left.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧将出现一个新的 Azure 选项卡。
- en: Click the new Azure tab.
  id: totrans-855
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击新的 Azure 选项卡。
- en: On the new page, click the `Add` button (`1`).
  id: totrans-856
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新页面上，点击 `添加` 按钮 (`1`)。
- en: 'Select the `Create Function…` option (`2`):'
  id: totrans-857
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `创建函数…` 选项 (`2`)：
- en: '![Figure 9.52: The new Azure Functions extension in VS Code  with the Create
    Function… button ](img/B16835_09_52.jpg)'
  id: totrans-858
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.52：带有创建函数…按钮的 VS Code 中的新 Azure Functions 扩展](img/B16835_09_52.jpg)'
- en: 'Figure 9.52: The new Azure Functions extension in VS Code with the Create Function…
    button'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.52：带有创建函数…按钮的 VS Code 中的新 Azure Functions 扩展
- en: In the Create Function window, select `HTTP trigger`.
  id: totrans-860
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建函数窗口中，选择 `HTTP trigger`。
- en: Enter the name `GetCurrentTime.Get`.
  id: totrans-861
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入名称 `GetCurrentTime.Get`。
- en: Name the project where it is held `Pact.AzFunction`.
  id: totrans-862
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将存放项目的名称命名为 `Pact.AzFunction`。
- en: On the last screen, select `anonymous`.
  id: totrans-863
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一屏，选择 `anonymous`。
- en: At this point, there is no need to go into too much detail about this configuration.
    The key point to be considered here is that the function will be reachable publicly,
    through HTTP requests. A new project created through these steps will include
    the new Azure Function.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，没有必要对这个配置进行过多的详细说明。这里要考虑的关键点是，该函数将通过 HTTP 请求公开访问。通过这些步骤创建的新项目将包括新的 Azure
    Function。
- en: Now, navigate to the root of the new project folder to run the project.
  id: totrans-865
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，导航到新项目文件夹的根目录以运行项目。
- en: 'Next, press `F5` or click the `Start debugging to update this list…` message:'
  id: totrans-866
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按 `F5` 或点击 `开始调试以更新此列表…` 消息：
- en: '![Figure 9.53: Azure Extension window with the to-be-built project ](img/B16835_09_53.jpg)'
  id: totrans-867
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.53：带有待构建项目的 Azure 扩展窗口](img/B16835_09_53.jpg)'
- en: 'Figure 9.53: Azure Extension window with the to-be-built project'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.53：带有待构建项目的 Azure 扩展窗口
- en: 'You will notice that upon a successful build, the message changes to the function name:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在构建成功后，消息会变为函数名称：
- en: '![Figure 9.54: Azure Extension window with post-build project ](img/B16835_09_54.jpg)'
  id: totrans-870
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.54：带有后构建项目的 Azure 扩展窗口](img/B16835_09_54.jpg)'
- en: 'Figure 9.54: Azure Extension window with post-build project'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.54：带有后构建项目的 Azure 扩展窗口
- en: 'The terminal output window, displayed at the bottom of VS Code, shows the following
    details:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 底部的终端输出窗口显示了以下详细信息：
- en: '![Figure 9.55: The terminal output after a successful build ](img/B16835_09_55.jpg)'
  id: totrans-873
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.55：成功构建后的终端输出](img/B16835_09_55.jpg)'
- en: 'Figure 9.55: The terminal output after a successful build'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.55：成功构建后的终端输出
- en: 'Next, in VS Code Explorer, open `GetCurrentTime.cs`:'
  id: totrans-875
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 VS Code 探索器中打开 `GetCurrentTime.cs`：
- en: 'Note that in *Exercise 9.01*, you worked with the `GetCurrentTime` code. You will
    reuse the same code here:'
  id: totrans-876
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，在 *练习 9.01* 中，你使用了 `GetCurrentTime` 代码。你将在这里重用相同的代码：
- en: '[PRE161]'
  id: totrans-877
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: The template names are generated based on your configuration from before. An
    Azure Function is bound to an HTTP endpoint through the `[Function("GetCurrentTime")]`
    attribute.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 模板名称是根据你之前的配置生成的。Azure Function 通过 `[Function("GetCurrentTime")]` 属性绑定到 HTTP
    端点。
- en: Before you proceed, you might have noticed that, even though the function for
    getting the current time consumed a variable for `timezoneid`, there is no such
    variable here (yet). Unlike the previous REST APIs you created to pass parameters
    to an Azure Function, here you pass it through either a request body or query
    variables. The only problem here is that you will have to parse it yourself, as
    there are no bindings through attributes just like with the controller methods.
    The argument you need is just a simple string that can be passed as a query argument.
    This line parses the URI from the request and gets a `timezoneId` variable from
    the query string.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 在你继续之前，你可能已经注意到，尽管获取当前时间的函数使用了 `timezoneid` 变量，但这里还没有这样的变量（目前还没有）。与之前创建的用于将参数传递给
    Azure Function 的 REST API 不同，这里你可以通过请求体或查询变量来传递它。这里唯一的问题是，你必须自己解析它，因为没有像控制器方法那样的属性绑定。你需要的是一个简单的字符串，它可以作为查询参数传递。这一行解析请求中的
    URI 并从查询字符串中获取 `timezoneId` 变量。
- en: 'Use the `timezoneId` variable to get the current time in a specific zone:'
  id: totrans-880
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `timezoneId` 变量来获取特定时区的时间：
- en: '[PRE162]'
  id: totrans-881
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Next up is the business logic. So, use the `timezoneId` variable to get the
    current time in a specified time zone:'
  id: totrans-882
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是业务逻辑。因此，使用 `timezoneId` 变量来获取指定时区的时间：
- en: '[PRE163]'
  id: totrans-883
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Finally, serialize the results in `HTTP 200 Ok` as the `text/plain` content type:'
  id: totrans-884
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将结果序列化为 `HTTP 200 Ok` 作为 `text/plain` 内容类型：
- en: '[PRE164]'
  id: totrans-885
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Run this code and navigate to `http://localhost:7071/api/GetCurrentTime?timezoneId=Central%20European%20Standard%20Time`.
  id: totrans-886
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行此代码并导航到 `http://localhost:7071/api/GetCurrentTime?timezoneId=Central%20European%20Standard%20Time`。
- en: 'You will get the current time of that time zone, as follows:'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到该时区当前的时间，如下所示：
- en: '[PRE165]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: You have now grasped the workings of Azure Functions—a serverless solution to
    call your functions on the cloud.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经掌握了 Azure Functions 的工作原理——一种在云端调用你的函数的无服务器解决方案。
- en: It has been a long path through this book, but with the conclusion of this final
    activity, you have mastered all the concepts and skills required to create your
    own modern C# applications.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你已经走过了一段漫长的路程，但随着这个最后活动的结束，你已经掌握了创建自己的现代 C# 应用程序所需的所有概念和技能。
- en: Summary
  id: totrans-891
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to build your own REST Web API using the ASP.NET
    Core Web API template. You learned how to tackle the ever-growing complexity of
    configuration using bootstrap classes. You were introduced to the OpenAPI standard
    and Swagger, a tool used for calling an API to see whether it has successfully
    rendered the documentation. You also delved into mapping exceptions to specific
    HTTP status codes, along with how to map DTOs to domain objects and vice versa.
    In the second half of the chapter, you practiced securing the Web API using AAD,
    learned the concept of microservices, and created one yourself—both through a
    new dedicated Web API and through an Azure Function.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用 ASP.NET Core Web API 模板构建自己的 REST Web API。你学习了如何使用引导类处理配置的日益增长复杂性。你被介绍到
    OpenAPI 标准，以及用于调用 API 以查看是否成功渲染文档的 Swagger 工具。你还深入了解了将异常映射到特定的 HTTP 状态代码，以及如何将
    DTO 映射到领域对象以及反之亦然。在章节的后半部分，你练习了使用 AAD 保护 Web API，了解了微服务概念，并创建了一个——通过一个新的专用 Web
    API 和通过 Azure Function。
- en: Knowing how to create and consume Web APIs is important because that's what
    most of the software development is all about. You either consume or create Web
    APIs at some point. Even if you don't have to create one yourself, grasping the
    ins and outs of it will help you as a professional developer.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何创建和消费 Web API 非常重要，因为那正是大多数软件开发的核心。你可能在某个时候会消费或创建 Web API。即使你不需要自己创建一个，掌握它的来龙去脉也会帮助你作为一个专业开发者。
- en: This brings a close to *The C# Workshop*. Throughout this book, you have learned
    the basics of programming in C#, starting with simple programs that used arithmetic
    and logical operators, followed by the increasingly complex concepts of clean
    coding, delegates and lambdas, multithreading, client and server Web APIs, and
    Razor Pages applications.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着 *《C# 实战》* 的结束。在这本书中，你从 C# 编程的基础学起，从使用算术和逻辑运算符的简单程序开始，然后是越来越复杂的清洁编码、委托和
    lambda 表达式、多线程、客户端和服务器 Web API 以及 Razor Pages 应用程序的概念。
- en: 'This concludes the print copy of this book, but it is not the end of your journey.
    Visit the GitHub repository at [https://packt.link/sezEm](https://packt.link/sezEm)
    for bonus chapters—*Chapter 10*, *Automated Testing*, and *Chapter 11*, *Production-Ready
    C#: From Development to Deployment*—covering such topics as different forms of
    testing before you take an in-depth look at unit testing using Nunit (the most
    popular third-party testing library for C#), getting acquainted with Git and using
    GitHub to keep a remote backup of your code, enabling Continuous Deployment (CD)
    and deployment from your code to the cloud, studying the cloud using Microsoft
    Azure, in addition to learning how to use GitHub Actions to perform CI and CD
    to push application changes live in production.'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的印刷版到此结束，但这并不是您旅程的终点。访问GitHub仓库[https://packt.link/sezEm](https://packt.link/sezEm)，获取额外章节——第10章“自动化测试”和第11章“生产就绪的C#：从开发到部署”——涵盖在深入探讨使用Nunit（C#最受欢迎的第三方测试库）进行单元测试之前的不同测试形式，熟悉Git并使用GitHub来远程备份您的代码，启用持续部署（CD）并将代码部署到云端，使用Microsoft
    Azure学习云，以及学习如何使用GitHub Actions执行CI和CD，将应用程序更改实时推送到生产环境。
- en: '![Rayon](img/Jason_Hales.png)'
  id: totrans-896
  prefs: []
  type: TYPE_IMG
  zh: '![Rayon](img/Jason_Hales.png)'
- en: '**Jason Hales**'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jason Hales**'
- en: '![Rayon](img/Almantas_Karpavicius.png)'
  id: totrans-898
  prefs: []
  type: TYPE_IMG
  zh: '![Rayon](img/Almantas_Karpavicius.png)'
- en: '**Almantas Karpavicius**'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: '**Almantas Karpavicius**'
- en: '![Rayon](img/Mateus_Viegas.png)'
  id: totrans-900
  prefs: []
  type: TYPE_IMG
  zh: '![Rayon](img/Mateus_Viegas.png)'
- en: '**Mateus Viegas**'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mateus Viegas**'
- en: Hey!
  id: totrans-902
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嘿！
- en: We are Jason Hales, Almantas Karpavicius, and Mateus Viegas the authors of this
    book. We really hope you enjoyed reading our book and found it useful for learning
    C#.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是这本书的作者Jason Hales、Almantas Karpavicius和Mateus Viegas。我们真心希望您喜欢阅读我们的书，并觉得它对学习C#很有帮助。
- en: It would really help us (and other potential readers!) if you could leave a
    review on Amazon sharing your thoughts on *The C# Workshop*.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您能在亚马逊上留下对《C# Workshop》的评论，分享您的想法，这将真正对我们（以及其他潜在读者！）有所帮助。
- en: Go to the link [https://packt.link/r/1800566492](https://packt.link/r/1800566492).
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 访问链接 [https://packt.link/r/1800566492](https://packt.link/r/1800566492)。
- en: OR
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: Scan the QR code to leave your review.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描二维码留下您的评论。
- en: '![Barcode](img/qrcode.jpg)'
  id: totrans-908
  prefs: []
  type: TYPE_IMG
  zh: '![Barcode](img/qrcode.jpg)'
- en: Your review will help us to understand what's worked well in this book and what
    could be improved upon for future editions, so it really is appreciated.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 您的评论将帮助我们了解这本书中哪些内容做得很好，哪些内容需要改进以供未来版本使用，所以这真的非常感谢。
- en: Best wishes,
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 祝好，
- en: Jason Hales, Almantas Karpavicius, and Mateus Viegas
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: Jason Hales、Almantas Karpavicius和Mateus Viegas
- en: '![Packt Logo](img/Packt_Logo-1.png)'
  id: totrans-912
  prefs: []
  type: TYPE_IMG
  zh: '![Packt Logo](img/Packt_Logo-1.png)'
