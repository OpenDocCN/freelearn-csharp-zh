- en: Remote Logins and SSH
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程登录和SSH
- en: In this final chapter, we'll look at how we can implement remote host access
    and control in .NET Core. Here, we'll create a **S****ecure Shell** (**SSH**) client
    for remotely accessing computing resources over a network. We'll look at how the
    SSH.NET library supports making calls to known external resources and explore
    the underlying source code for the SSH.NET library to understand how it supports
    SSH in .NET Core. Finally, we'll look at how we can leverage it to perform a variety
    of operations on external machines over a network.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一章中，我们将探讨如何在.NET Core中实现远程主机访问和控制。在这里，我们将创建一个用于远程访问网络中计算资源的**安全壳**（**SSH**）客户端。我们将探讨SSH.NET库如何支持调用已知的外部资源，并探索SSH.NET库的底层源代码，以了解它如何在.NET
    Core中支持SSH。最后，我们将探讨如何利用它通过网络在远程机器上执行各种操作。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The Secure Shell protocol for remote device access and process execution
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于远程设备访问和进程执行的Secure Shell协议
- en: Establishing SSH connections using .NET Core
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用.NET Core建立SSH连接
- en: Executing remote commands on external machines through the SSH connections
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过SSH连接在远程机器上执行远程命令
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this final chapter, we'll be using our trusty source code editor, whether
    that's Visual Studio or Visual Studio Code, and we'll be developing and discussing
    the source code found in this book's GitHub repository, here: [https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter
    19](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter%2019).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一章中，我们将使用我们信任的源代码编辑器，无论是Visual Studio还是Visual Studio Code，我们将开发并讨论本书GitHub仓库中找到的源代码，这里：[https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter%2019](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter%2019)。
- en: We'll also be using the free (as in gratis) virtual machine host VirtualBox
    to set up a false remote host for us to interact with through our SSH software.
    You can use whatever virtualization software you may already have on your own
    machine if you want to follow along with the demonstrations in this chapter, though.
    The important thing is just to have a virtual host to interact with. The installer
    for VirtualBox can be found here: [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用免费的（免费的意思是免费）虚拟机主机VirtualBox来为我们设置一个虚假的远程主机，以便我们通过SSH软件与之交互。如果您想跟随本章中的演示，可以使用您自己机器上已有的任何虚拟化软件。但重要的是，您需要有一个虚拟主机来与之交互。VirtualBox的安装程序可以在以下位置找到：[https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads)。
- en: Finally, we'll be using an installation of the Ubuntu operating system to load
    onto our virtual machine. Ubuntu is free and open source, and a disk image for
    the OS can be found here: [https://www.ubuntu.com/download/desktop](https://www.ubuntu.com/download/desktop).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用Ubuntu操作系统的安装版加载到我们的虚拟机中。Ubuntu是免费和开源的，该操作系统的磁盘镜像可以在以下位置找到：[https://www.ubuntu.com/download/desktop](https://www.ubuntu.com/download/desktop)。
- en: Check out the following video to see the code in action: [http://bit.ly/2HYQMSu](http://bit.ly/2HYQMSu)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：[http://bit.ly/2HYQMSu](http://bit.ly/2HYQMSu)
- en: What is SSH?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是SSH？
- en: Starting from the beginning, the first step to understanding how we can leverage
    SSH in our software is to understand what SSH is, and how it works. Put simply,
    SSH is a network protocol for securely logging into a remote host. Once that remote
    login has been established, the protocol supports executing and operating remote
    resources over an otherwise unsecured network. As with all of the protocols we've
    explored throughout this book, its design is intentionally generalized for use
    in a wide variety of contexts. So, how did it begin, and how, specifically, does
    it work?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，理解我们如何在软件中利用SSH的第一步是了解SSH是什么，以及它是如何工作的。简单来说，SSH是一种用于安全登录远程主机的网络协议。一旦建立了远程登录，该协议支持在未加密的网络上执行和操作远程资源。与本书中探索的所有协议一样，其设计有意地通用化，以便在各种环境中使用。那么，它是如何开始的，具体又是如何工作的呢？
- en: The origin of SSH
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SSH的起源
- en: Originally created in 1995 by Finnish researcher Tatu Ylönen, SSH was created
    to provide a secure channel over which remote terminal access could be established.
    Ylönen was motivated by a recent password-sniffing attack that struck the network
    of the Helsinki University of Technology, where he was working at the time. Recognizing
    the inherent insecurity of more common (or at least, more common at the time)
    text-based remote terminal protocols, such as Telnet, rlogin, and FTP, his primary
    objective was to create sufficiently strong authentication and encryption to ensure
    the privacy of network communications. Through his work, users could remotely
    log into machines, and access and operate the remote machine's terminal through
    their own SSH interface.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 是由芬兰研究人员 Tatu Ylönen 在 1995 年最初创建的，旨在提供一个安全的通道，通过该通道可以建立远程终端访问。Ylönen 是由当时他在赫尔辛基科技大学网络中遭遇的最近的一次密码嗅探攻击所激发的。他认识到更常见的（或者至少在当时更常见的）基于文本的远程终端协议（如
    Telnet、rlogin 和 FTP）固有的不安全性，他的主要目标是创建足够强大的身份验证和加密，以确保网络通信的隐私。通过他的工作，用户可以远程登录到机器，并通过自己的
    SSH 接口访问和操作远程机器的终端。
- en: The original version, and subsequent minor releases of version 1, was developed
    by the SSH Communications Security, a privately held cybersecurity company founded
    by Ylönen. However, as of version 2.0, an IETF working group known as **Secsh**
    has been responsible for defining and refining the protocol. The Secsh team's
    work was formalized and accepted as a standard, dubbed **SSH-2**, in 2006.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 原始版本以及随后的 1 版本的后续小版本是由 SSH Communications Security 开发的，这是一家由 Ylönen 创立的私营网络安全公司。然而，从
    2.0 版本开始，一个名为 **Secsh** 的 IETF 工作组负责定义和改进该协议。Secsh 团队的工作在 2006 年被正式化和接受为标准，被称为
    **SSH-2**。
- en: With the release of SSH-2, the team improved the security and feature set of
    SSH-1 through the use of improved key-exchange algorithms for establishing symmetric
    keys for communication. The new version also introduced securely hashed message
    authentication codes (HMAC codes, not to be confused with the MAC address we discussed
    in [Chapter 18](80e475d9-e75c-4b52-918f-026ff6aed613.xhtml), *Network Analysis
    and Packet Inspection*). Among the features that were introduced with SSH-2 was
    support for multiple parallel terminal sessions over a single SSH connection.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 SSH-2 的发布，团队通过使用改进的密钥交换算法来建立通信的对称密钥，从而提高了 SSH-1 的安全性和功能集。新版本还引入了安全散列消息认证码（HMAC
    代码，不要与我们在第 18 章[网络分析和数据包检查](80e475d9-e75c-4b52-918f-026ff6aed613.xhtml)中讨论的 MAC
    地址混淆）来安全地散列消息。SSH-2 引入的特性之一是支持通过单个 SSH 连接进行多个并行终端会话。
- en: While it was originally built on top of, and released as, free software throughout
    its earliest releases, the protocol has since fragmented and exists in various
    open and proprietary implementations and versions. However, developers across
    the globe continued to have a need for open sourced implementations of the protocol.
    To solve this, new, open source implementations have been developed and established
    a strong foothold. This includes the OpenSSH implementation, which was developed
    by the community of developers behind OpenBSD, and first released in 1999\. Today,
    OpenSSH is the most widely used implementation of the suite of protocols and features,
    and it is the only implementation used by modern Windows machines.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管SSH最初是基于免费软件构建并作为免费软件发布的，但该协议已经分裂，存在于各种开放和专有实现和版本中。然而，全球的开发者继续需要该协议的开源实现。为了解决这个问题，开发了新的开源实现，并建立了坚实的基础。这包括由
    OpenBSD 后台开发社区开发的 OpenSSH 实现，该实现首次于 1999 年发布。今天，OpenSSH 是该协议套件中最广泛使用的实现，并且是现代
    Windows 机器唯一使用的实现。
- en: If you've ever used GitHub or BitBucket as a remote Git repository, you've likely
    used OpenSSH already and may not have even realized it. Many Git clients, including
    Atlassian's source tree, and even the default client, leverage SSH to establish
    and maintain access credentials between your machine and the remote repository
    for your code base. The single-sign on mechanism supported by something such as
    SourceTree is built entirely on OpenSSH. In fact, whenever you start SourceTree,
    the startup process also starts an instance of the PuTTY SSH client, which SourceTree
    uses to establish its own connections with your remote repositories. But now that
    you know what SSH is, we should take a moment to look at how it works.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过GitHub或BitBucket作为远程Git仓库，你很可能已经使用了OpenSSH，甚至可能都没有意识到。许多Git客户端，包括Atlassian的源树，甚至是默认客户端，都利用SSH在您的机器和远程代码仓库之间建立和维护访问凭证。由SourceTree支持的单一登录机制完全建立在OpenSSH之上。实际上，每次您启动SourceTree时，启动过程也会启动一个PuTTY
    SSH客户端的实例，SourceTree使用它来与您的远程仓库建立自己的连接。但现在您已经知道了SSH是什么，我们应该花一点时间来看看它是如何工作的。
- en: The SSH protocol design
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SSH协议设计
- en: 'The SSH protocol leverages a client-server architecture, not entirely dissimilar
    from the application-layer protocols we''ve examined all throughout this book,
    such as FTP and HTTP. The basic interaction mechanism actually looks very similar
    to the handshake and security negotiation that takes place in a TLS handshake.
    The basic interactions are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: SSH协议利用客户端-服务器架构，这与我们在整本书中检查的应用层协议（如FTP和HTTP）并不完全不同。基本交互机制实际上看起来非常类似于TLS握手过程中发生的握手和安全协商。基本交互如下：
- en: The client establishes a connection with the server, notifying the server of
    a desire to communicate via SSH
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端与服务器建立连接，通知服务器希望通过SSH进行通信
- en: The server acknowledges the request, and responds with public encryption key
    information with which the client can secure its own subsequent responses until
    a symmetric encryption scheme can be established
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器确认请求，并响应以公共加密密钥信息，客户端可以使用这些信息来保护其后续的响应，直到可以建立对称加密方案
- en: The server and the client negotiate the security structure for the connection,
    transmit any necessary keys, and establish a secure, symmetric encryption mechanism
    for use over the lifetime of the SSH session
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器和客户端协商连接的安全结构，传输任何必要的密钥，并在SSH会话的生命周期内建立用于安全通信的对称加密机制
- en: The client is free to securely log on to the remote host, transmitting and executing
    commands for which their credentials have permissions
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端可以自由安全地登录到远程主机，传输和执行其凭证有权限的命令
- en: The primary distinction between SSH and something such as TLS is that SSH is
    explicitly designed to be general purpose and connection agnostic.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: SSH与TLS等东西之间的主要区别在于，SSH被明确设计为通用和连接无关。
- en: This interaction scheme is supported by an architecture, defined by a series
    of RFCs by the IETF (4251-4256, if you're interested), as a three-tiered system
    of components with distinct responsibilities. Each tier supports a specific task
    in the process of establishing and maintaining an SSH session between a client
    and a server, and they're all well-documented by their respective standards.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种交互方案由一个由IETF（4251-4256，如果您感兴趣）定义的一系列RFC支持的架构支持，它是一个具有明确责任的三层组件系统。每一层都在客户端和服务器之间建立和维护SSH会话的过程中支持特定的任务，并且它们都由各自的标准进行了很好的记录。
- en: The transport tier
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传输层
- en: The first of these tiers is the transport layer protocol, or **SSH-TRANS**,
    which provides secure delivery of messages with all of the functionality you've
    come to expect from TLS. Since SSH is all about secure communication, it's important
    that the transport layer provides a strong authentication and encryption mechanism.
    This should include server authentication (usually through an X.509, or similar
    certificate validation mechanism), public key encryption, and message verification.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些层级中的第一个是传输层协议，或**SSH-TRANS**，它提供了与TLS中期望的所有功能的安全消息传递。由于SSH完全是关于安全通信的，因此传输层提供强大的身份验证和加密机制非常重要。这应该包括服务器身份验证（通常通过X.509或类似的证书验证机制）、公钥加密和消息验证。
- en: While RFC 4251 notes that the transport layer is likely to be implemented over
    TCP/IP in most cases, it does leave room for new or alternative protocols. The
    only aspect of a transport layer protocol that must be in place for SSH is reliability
    of transport. This rules out UDP and other connectionless protocols as viable
    transport mechanisms, since connectionless datagram delivery is considered inherently
    unreliable.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然RFC 4251指出，在大多数情况下，传输层很可能会在TCP/IP上实现，但它为新的或替代协议留出了空间。对于SSH而言，传输层协议必须具备的仅是传输的可靠性。这排除了UDP和其他无连接协议作为可行的传输机制，因为无连接数据报传输被认为是固有不可靠的。
- en: The user authentication tier
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户认证层级
- en: The next, and perhaps most critical, tier of the SSH-2 architecture is the **authentication
    protocol layer**, or **SSH-USERAUTH**. This is the layer that's responsible for
    establishing and maintaining a validated identity for any client seeking to connect
    to an SSH server. According to RFC 4252, the server is responsible for establishing
    the valid set of authentication methods that the client may use to authenticate
    themselves. From that set of authentication methods, the client is free to use
    any available method, and is free to attempt them in any order. According to the
    RFC, there are three valid authentication methods that a server might list for
    a client to attempt to authenticate by.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个，也许是最关键的，SSH-2架构层级是**认证协议层**，或**SSH-USERAUTH**。这是负责为任何试图连接到SSH服务器的客户端建立和维护验证身份的层级。根据RFC
    4252，服务器负责建立客户端可能使用的有效认证方法集。从该认证方法集中，客户端可以自由选择任何可用方法，并且可以自由尝试任何顺序。根据RFC，服务器可能列出三种有效的认证方法供客户端尝试认证。
- en: The public key authentication mode
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公钥认证模式
- en: The first of these and the only one that an SSH-2 server is actually required to
    support, according to the standard is the `publickey` authentication scheme. However,
    while there is a requirement that all servers support the ability to use public
    key authentication, there is no requirement that all clients actually have public
    keys. The public key scheme behaves very similarly to what we saw in [Chapter
    13](2b8a5eae-9085-43d1-9e48-5c21513e8339.xhtml), *Transport Layer Security*. When
    the `publickey` method is specified, the SSH client will send a signature, which
    has been generated from a private key, to the server. Once received, the server
    validates the signature as being generated with the user's private key, and upon
    successful validation, the authentication succeeds for the client.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 根据标准，这些方案中的第一个，也是SSH-2服务器实际上必须支持的，是`publickey`认证方案。然而，尽管所有服务器都必须支持使用公钥认证的能力，但并没有要求所有客户端都必须拥有公钥。公钥方案的行为与我们第13章中看到的非常相似，即*传输层安全*。当指定`publickey`方法时，SSH客户端将发送一个由私钥生成的签名到服务器。一旦收到，服务器将验证该签名是否由用户的私钥生成，并在验证成功后，客户端的认证成功。
- en: Client software will typically store a registered private key as an encrypted
    value on the local system, and restrict access to it from external processes.
    The SSH client will also, typically, use some form of password authentication
    prior to generate a public key signature to transmit over the server, though this
    is not always a requirement.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端软件通常将注册的私钥以加密值的形式存储在本地系统上，并限制外部进程对其的访问。SSH客户端通常也会在生成用于传输到服务器的公钥签名之前，使用某种形式的密码认证，尽管这并非总是必需的。
- en: The password authentication mode
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码认证模式
- en: The next valid authentication mechanism that a server might specify for use
    by a client is the **password authentication scheme**. While support for the password
    scheme is not explicitly required by the standard, it is strongly recommended
    that implementations should support password authentication*.* In this authentication
    mechanism, much as the name suggests, the connecting client provides a plain text
    password to the server over a series of packet negotiations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可能为客户端指定的下一个有效认证机制是**密码认证方案**。虽然标准并未明确要求支持密码方案，但强烈建议实现应支持密码认证*.* 在此认证机制中，正如其名所示，连接的客户端在一系列数据包协商过程中向服务器提供明文密码。
- en: Since the user authentication layer of the SSH-2 architecture rests on top of
    the transport layer, the fact that the password is transmitted as plain-text should
    be mitigated by the secure encryption of the underlying transport protocol. However,
    RFC 4252 does specify that it is the responsibility of both the server and the
    client to confirm the confidentiality of the transport layer's encryption mechanism
    prior to sending the password in plain-text. If either the client or the server
    determines that there is no encryption, or insufficient encryption, being used
    by the transport protocol, the password authentication mode should be disabled
    by both the client and the server.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SSH-2架构的用户认证层建立在传输层之上，因此密码以明文形式传输的事实应该通过底层传输协议的安全加密来缓解。然而，RFC 4252确实规定，在发送明文密码之前，服务器和客户端都有责任确认传输层加密机制的机密性。如果客户端或服务器确定传输协议没有使用加密，或者加密不足，则客户端和服务器应禁用密码认证模式。
- en: Whenever a server implements the password authentication scheme, it should also
    provide a mechanism whereby a user can change or update their password through
    the SSH connection establishment mechanism, in the event that a user's password
    has expired. This enables users who would be prompted to enter and update their
    passage upon authentication to do so through the remote terminal. However, in
    much the same way that the client and server should validate that the transport
    layer provides sufficient security prior to allowing the password authentication
    mode, they must also determine whether there is sufficient support for data integrity
    prior to supporting a password update mechanism. This is because, if the data
    was mutated or modified in transit, neither the server nor the client would have
    knowledge of the discrepancy without some form of integrity check.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器在实现密码认证方案时，应提供一种机制，允许用户在认证过程中更改或更新他们的密码，以防用户的密码已过期。这使用户能够在远程终端上通过SSH连接建立机制输入和更新他们的密码。然而，与客户端和服务器应在允许密码认证模式之前验证传输层提供足够的安全性一样，他们还必须在支持密码更新机制之前确定是否存在足够的数据完整性支持。这是因为，如果数据在传输过程中被变异或修改，没有某种形式的完整性检查，服务器和客户端都不会知道这种差异。
- en: Thus, the server would assign the new, mutated password for the user's future
    authentication attempts, but the client would have no knowledge of the mutation,
    and would subsequently fail to authenticate with the original, unmodified password.
    Therefore, if there is no assurance of data integrity provided by either a MAC
    or HMAC as part of the packets delivered by the transport layer, then the server
    must disable any password update functionality.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，服务器将为用户的未来认证尝试分配新的、变异的密码，但客户端将不知道这种变异，并且将随后无法使用原始的、未修改的密码进行认证。因此，如果没有MAC或HMAC作为传输层发送的数据包的一部分提供数据完整性保证，则服务器必须禁用任何密码更新功能。
- en: The host-based authentication mode
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于主机的认证模式
- en: The final authentication mode is the `hostbased` mode. This is the only mode
    that's explicitly noted in the standard as being optional, and it allows users
    to be authenticated based on the host machine they are connecting from (hence
    the name). This mode relies on a designated host machine having a private key
    that's provisioned for a specific individual host machine. The host then generates
    a signature from that private key, which can be validated by the server using
    the host's public key. This signature is then validated against the public key and the
    specific host name. As long as the host name provided with the signature matches
    the origin of the request, and the server's registry of valid hosts, the authentication
    succeeds.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的认证模式是`基于主机`模式。这是唯一在标准中被明确指出为可选的模式，它允许用户根据他们连接的主机进行认证（因此得名）。此模式依赖于一个指定的主机机拥有为特定主机机配置的私钥。然后主机从该私钥生成一个签名，该签名可以使用主机的公钥由服务器进行验证。然后，该签名与公钥和特定主机名进行验证。只要带有签名的提供的主机名与请求的来源以及服务器有效主机注册表相匹配，认证就成功。
- en: The connection tier
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接层
- en: Designed and intended to run on top of both the transport tier and the user
    authentication tier, the connection tier of the SSH-2 architecture defines the
    systems that support the various operations and interactions that are available
    over an SSH connection. Defined in RFC 4254, the connection tier of the stack
    is described as providing **connection ****channels** over which SSH features
    can be executed. This includes any remote terminal sessions over which the client
    can execute remote commands, and port-forwarding sessions, which allow a client
    to directly access a network connection port on the remote host and listen for
    incoming requests, and any remote login sessions for navigating within and interacting
    with the remote host.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: SSH-2架构的连接层旨在在传输层和用户认证层之上运行，定义了支持通过SSH连接可用的各种操作和交互的系统。在RFC 4254中定义，堆栈的连接层被描述为提供执行SSH功能的**连接**通道。这包括任何客户端可以执行远程命令的远程终端会话，以及允许客户端直接访问远程主机上的网络连接端口的端口转发会话，以及任何用于在远程主机内部导航和与之交互的远程登录会话。
- en: According to the RFC, a single SSH connection should implement support for multiplexing
    multiple channels over the course of a session. These channels are uniquely identified
    on both ends of the connection, though the identifiers may be different from server
    to client. Once a channel is opened, though, data can flow between hosts in what's
    known as a **window**. A window is simply a designated maximum number of bytes
    that one host can transmit to the other before further data is blocked. Once the
    window-size is reached, the transmitting host must wait for the window to be adjusted
    by the recipient host. In this way, windows are used to control the flow of traffic
    over a given SSH connection channel.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 根据RFC，单个SSH连接应在会话期间实现支持多路复用多个通道。这些通道在连接的两端都是唯一标识的，尽管标识符可能从服务器到客户端不同。一旦通道打开，数据就可以在所谓的**窗口**中在主机之间流动。窗口简单地是一个指定字节数的最大值，一个主机在进一步的数据被阻塞之前可以传输给另一个主机。一旦达到窗口大小，发送主机必须等待接收主机调整窗口。通过这种方式，窗口被用来控制给定SSH连接通道上的流量。
- en: A series of channels provisioned over a given SSH connection establish what
    is known as an **interactive session**. According to the standard, an interactive
    session is simply any remote execution of a program by the client, on the server.
    This can include port or authentication forwarding, session data transfer, or
    any number of other jobs, tasks, and activities.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定SSH连接上配置的一系列通道建立了一个所谓的**交互会话**。根据标准，交互会话仅仅是客户端在服务器上远程执行程序的行为。这可以包括端口或认证转发、会话数据传输，或任何数量的其他工作、任务和活动。
- en: The versatility of SSH
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SSH的通用性
- en: Since SSH is primarily concerned with establishing secure connections over insecure
    networks, the range of applications for it is quite extensive. It can, of course,
    provide the remote terminal interaction mechanisms that were part and parcel of
    the protocols it was designed to replace. It can be used as a passwordless authentication
    mechanism when established with public/private keys between a client and a server,
    as is the case with OpenSSH in GitHub and BitBucket.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SSH主要关注在非安全网络上建立安全连接，因此它的应用范围相当广泛。当然，它可以提供远程终端交互机制，这是它旨在取代的协议的一部分。当客户端和服务器之间使用公钥/私钥建立时，它可以作为一个无密码认证机制使用，就像GitHub和BitBucket中的OpenSSH那样。
- en: Use with FTP
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与FTP一起使用
- en: While FTP can provide a reliable client-server interaction mechanism for transferring
    files between hosts, it doesn't typically do so in a secure way. To that end,
    SSH is leveraged heavily whenever security is required for securely copying or
    transferring files between hosts. In fact, the secure protocol specification for
    FTP relies on SSH, and is explicitly entitled **SSH File Transfer Protocol,**
    or **SFTP**. The shells provided by SSH can even allow the **secure copy** (**scp**)
    Linux program to execute over a remote connection.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然FTP可以提供一种可靠的服务器-客户端交互机制，用于在主机之间传输文件，但它通常不会以安全的方式进行。因此，当需要在主机之间安全地复制或传输文件时，会大量使用SSH。事实上，FTP的安全协议规范依赖于SSH，并明确称为**SSH文件传输协议**，或**SFTP**。SSH提供的shell甚至可以允许**安全复制**（**scp**）Linux程序通过远程连接执行。
- en: 'As you may recall from [Chapter 10](ec99753c-1004-4a9f-b651-8d4bb467a879.xhtml),
    *FTP and SMTP*, FTP leverages two separate and distinct connections for its file
    transfer interactions: the control connection and the data transfer connection.
    Interestingly, since FTP leverages these two separate connections, you can optionally
    apply SSH to either of the two connections, independent of whether or not you''ve
    also leveraged SSH on the other connection. This exact interaction mechanism is
    used by the **Fast and Secure Protocol** (**FASP**).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从[第10章](ec99753c-1004-4a9f-b651-8d4bb467a879.xhtml)，“FTP和SMTP”中可能记得，FTP 利用两个独立且不同的连接进行其文件传输交互：控制连接和数据传输连接。有趣的是，由于
    FTP 利用这两个独立的连接，您可以选择性地将 SSH 应用到这两个连接中的任何一个，而不管您是否也在另一个连接上使用了 SSH。这种精确的交互机制被 **快速安全协议**（**FASP**）所使用。
- en: Use as a network tunnel
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为网络隧道使用
- en: When properly configured for it, a remote SSH server could provide a number
    of network security features and functions for the client's interactions with
    the wider internet, with the ability to facilitate port forwarding, where a client
    establishes a listening network port and then connects it directly to the input
    stream for a listening network port on the remote host. In this mechanism, any
    traffic sent to the port on the remote host will be received and processed by
    the listening port on the client host. This could allow a client device that is
    hosted behind a firewall or restricted gateway to establish an SSH connection
    with a remote device hosted outside the restriction boundaries, and begin listening
    for unrestricted network access.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当远程 SSH 服务器被正确配置时，它可以为客户端与更广泛的互联网的交互提供一系列网络安全特性和功能，包括端口转发的能力，即客户端建立一个监听网络端口，并将其直接连接到远程主机上的监听网络端口的输入流。在这个机制中，发送到远程主机端口的任何流量都将被客户端主机的监听端口接收和处理。这可能会允许位于防火墙或受限网关后面的客户端设备与位于限制边界之外的远程设备建立
    SSH 连接，并开始监听不受限制的网络访问。
- en: Taking that idea further, **OpenSSH** even offers support for a fully encrypted
    VPN service to operate between the client and the server. This provides fully
    encrypted interactions between the two hosts by bypassing any gateways, switches,
    or bridges between the two hosts, thus creating a logical "local" network with
    secure interactions and restricted access.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个想法进一步扩展，**OpenSSH** 甚至提供了客户端和服务器之间完全加密的 VPN 服务支持。这通过绕过两个主机之间的任何网关、交换机或桥接器，为两个主机之间提供了完全加密的交互，从而创建了一个具有安全交互和受限访问的逻辑“本地”网络。
- en: While it would be hyperbolic to describe the possible applications of SSH as
    being endless, they are certainly extensive. So much so as to be worth your curiosity
    and exploration. With that in mind, let's look at how we can start taking advantage
    of SSH within our software.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然将 SSH 的可能应用描述为无穷无尽可能有些夸张，但它们确实非常广泛。因此，它们值得您的兴趣和探索。考虑到这一点，让我们看看我们如何在软件中开始利用
    SSH。
- en: Establishing SSH connections
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立SSH连接
- en: While .NET Core lacks native support for establishing SSH sessions in its own
    libraries, there are a number of third-party libraries and NuGet packages that
    can fill that gap. We'll be looking at one of the most popular of those packages,
    SSH.NET, and seeing how we can use it to connect to a remote machine and start
    interacting with it through a virtual terminal.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 .NET Core 在其自身库中缺乏建立 SSH 会话的原生支持，但存在许多第三方库和 NuGet 包可以填补这一空白。我们将探讨其中最受欢迎的包之一，SSH.NET，并看看我们如何使用它来连接到远程机器并通过虚拟终端与之交互。
- en: Setting up a remote host
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置远程主机
- en: 'For the purposes of this demonstration, we''ll need to set up a remote host
    for us to SSH into. For this, we''ll be using an Ubuntu virtual machine, configured
    on our system with **VirtualBox**. We''ll be installing and operating on an Ubuntu
    image within our machine. To set this up, you''ll want to create a new VM within
    VirtualBox by clicking the New button and following the wizard. Within the wizard,
    you''ll be given the option to name your machine and select the OS type (Windows,
    Linux, macOS X, and so on) and the specific version. For this, we''ll want to
    select Linux as our type, and Ubuntu 64-bit as our version, as shown here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们需要设置一个远程主机以便我们进行SSH连接。为此，我们将使用配置在我们的系统上的Ubuntu虚拟机，使用**VirtualBox**进行配置。我们将在机器内部安装和操作Ubuntu镜像。为了设置它，你需要在VirtualBox中创建一个新的虚拟机，点击新建按钮并按照向导操作。在向导中，你将有机会给你的机器命名，并选择操作系统类型（Windows、Linux、macOS
    X等）和具体版本。为此，我们将选择Linux作为类型，Ubuntu 64位作为版本，如下所示：
- en: '![](img/8f55e5ef-2e5a-40bf-97a4-0135153c69a8.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8f55e5ef-2e5a-40bf-97a4-0135153c69a8.png)'
- en: While setting up your VM, make sure to provision at least enough resources to
    meet the minimum installation requirements for Ubuntu, including 8 GB of virtual
    disk space and 2 GB of memory. Once we've got our machine set up, we'll need to
    install Ubuntu on it. Using the image I referenced in the technical requirements,
    install Ubuntu on your newly provisioned virtual machine. While you're installing
    the operating system, make sure that when you're prompted to create a user account,
    you require a password to login. This will allow us to demonstrate the use of
    SSH for remote logins.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置虚拟机时，请确保至少提供足够的资源以满足Ubuntu的最小安装要求，包括8GB的虚拟磁盘空间和2GB的内存。一旦我们设置了机器，我们还需要在机器上安装Ubuntu。使用我在技术要求中提到的镜像，在你的新配置的虚拟机上安装Ubuntu。在安装操作系统时，确保在提示创建用户账户时，要求输入密码登录。这将允许我们演示SSH远程登录的使用。
- en: 'Once you''ve installed Ubuntu on to the virtual machine you''ve provisioned,
    you''ll need to enable SSH on the box. To do that, open up the machine''s Terminal
    and run the following commands:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在配置的虚拟机上安装了Ubuntu，你需要在机器上启用SSH。为此，打开机器的终端并运行以下命令：
- en: '![](img/9d40a466-3ae6-47e7-ac65-29d8de34f526.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9d40a466-3ae6-47e7-ac65-29d8de34f526.png)'
- en: 'Once you run that, you should see a long run of installation scripts, after
    which your SSH server will have been installed. You can check the status of the
    SSH server by running following commands:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行该程序，你应该会看到一系列的安装脚本，之后你的SSH服务器就已经安装完成了。你可以通过运行以下命令来检查SSH服务器的状态：
- en: '![](img/31e38fd3-f128-4c62-a36b-4e54aed421a1.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/31e38fd3-f128-4c62-a36b-4e54aed421a1.png)'
- en: With that done, there are a couple things I want to note about our setup. First,
    notice that the virtual box is wholly distinct from my own machine, with a unique
    user and a unique host name. Second, note that the port is listening on port `22`.
    This is the default port for SSH servers to listen on, and we'll be using this
    detail when we establish our connection with the remote machine in our C# project.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我想就我们的设置说明几点。首先，请注意虚拟机与我自己的机器完全独立，拥有唯一的用户和主机名。其次，请注意端口正在监听端口`22`。这是SSH服务器默认监听的端口，我们将在C#项目中与远程机器建立连接时使用这个细节。
- en: 'Finally, we''ll need to know how to interact with our virtual host from our
    own machine. For that, we''ll be setting up port-forwarding on our virtual machine,
    so that requests that target the designated port on our host will be forwarded
    along as requests targeting the designated host in our VM. This will make our
    lives easier when we want to establish a connection. To do that, you''ll open
    up the Network settings on your running instance and under the Advanced options,
    open the PortForwarding dialog. From there, we''ll forward along all of our SSH
    connection attempts, which will always go to port `22`, to the listening SSH port
    on our guest host (the virtual machine):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要知道如何从我们的机器与我们的虚拟主机交互。为此，我们将在虚拟机上设置端口转发，以便将针对我们主机上指定端口的请求转发到我们的虚拟机上的指定主机。这将使我们建立连接时更加方便。为此，你需要在运行实例的网络设置中打开高级选项，然后打开端口转发对话框。从那里，我们将转发所有的SSH连接尝试，这些尝试始终会连接到端口`22`，到我们的虚拟主机（虚拟机）上的监听SSH端口：
- en: '![](img/e5bb45d6-270a-4295-8013-25d916767576.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e5bb45d6-270a-4295-8013-25d916767576.png)'
- en: Once we have that configured, we'll be able to connect to our virtual machine
    just by sending a request to our localhost IP address of `127.0.0.1`, and because
    it's an SSH request targeting port `22`, the request will be forwarded. And, with
    that, it's time for us to wire up SSH.NET and connect.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们配置好，我们只需向我们的本地主机IP地址`127.0.0.1`发送请求，由于这是一个针对端口`22`的SSH请求，请求将被转发。因此，现在是时候连接SSH.NET并建立连接了。
- en: Connecting to an SSH server with SSH.NET
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SSH.NET连接到SSH服务器
- en: 'As with all of our projects, our first order of business is to create it with
    the CLI. We''ll be using another console app for this demonstration, so navigate
    to your target directory and run the following in your command prompt:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们所有的项目一样，我们的首要任务是使用命令行界面（CLI）来创建它。为此演示，我们将使用另一个控制台应用程序，所以请导航到您的目标目录，并在您的命令提示符中运行以下命令：
- en: '[PRE0]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since SSH.NET is not an out-of-the-box library with .NET Core, we''ll need
    to add the package. You can do this with either the NuGet package manager from
    within Visual Studio, or by using the .NET Core CLI to install the desired package
    from within your project file''s directory folder. The CLI command for the latter
    approach will be as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SSH.NET不是随.NET Core一起提供的库，我们需要添加这个包。您可以通过Visual Studio中的NuGet包管理器或使用.NET Core
    CLI从项目文件目录文件夹中安装所需的包来完成此操作。后一种方法的CLI命令如下：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, when you open up your `Program.cs` file, you can include the reference
    by adding the following `using` directive:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您打开您的`Program.cs`文件时，您可以通过添加以下`using`指令来包含引用：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: And, with that, we're ready to establish our connection. The SSH.NET library
    provides a wealth of abstractions for interacting with your SSH server according
    to the standard. This includes classes that encapsulate authentication modes,
    connection information, and, of course, an `SshClient` that we can work with just
    as simply as the `TcpClient` and `HttpClient` classes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们就准备好建立连接了。SSH.NET库提供了丰富的抽象，用于根据标准与SSH服务器交互。这包括封装认证模式、连接信息和，当然，我们可以像使用`TcpClient`和`HttpClient`类一样简单地使用的`SshClient`类。
- en: 'For this initial demo, we just want to establish an SSH connection using the
    login credentials for our remote machine. The purpose is to show you how you can
    establish remote access to a host using your credentials for that host. We''ll
    be using the password authentication mode, and passing in the username and password
    we created for our Ubuntu instance when we installed it on VirtualBox. Then, we''ll
    create a new `SshClient` and attempt to connect. The code for that is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个初始演示，我们只想使用远程机器的登录凭证建立SSH连接。目的是向您展示您如何使用该主机的凭证建立对主机的远程访问。我们将使用密码认证模式，并传递我们在安装Ubuntu实例时在VirtualBox中创建的用户名和密码。然后，我们将创建一个新的`SshClient`实例并尝试连接。相应的代码如下：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In our first line, you can see we're creating an instance of the `PasswordAuthenticationMethod`
    class, providing our username and password. There are classes for each of the
    authentication modes we've discussed, including one that we didn't, called the
    `KeyboardInteractiveAuthenticationMode` class. This class simply provides a way
    for users to directly authenticate through an open connection terminal, as opposed
    to passing the credentials back and forth between the client and server.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一行中，您可以看到我们正在创建一个`PasswordAuthenticationMethod`类的实例，提供了我们的用户名和密码。对于我们所讨论的每种认证模式，都有相应的类，包括一个我们没有提到的，即`KeyboardInteractiveAuthenticationMode`类。这个类简单地提供了一个用户通过开放的连接终端直接进行认证的方法，而不是在客户端和服务器之间来回传递凭证。
- en: Once we have our `AuthenticationMethod` class created, we pass it into an instance
    of the `ConnectionInfo` class. This class simply encapsulates the host, username,
    authentication method, and optional port specification (defaulting to `22`, of
    course) to be used when establishing an SSH connection. Finally, that connection
    information is passed to our `SshClient`. The `SshClient` instance is only initialized
    with the connection information as an instance property, however. Thus, we still
    have to explicitly connect to our remote server.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了`AuthenticationMethod`类，我们就将其传递给`ConnectionInfo`类的实例。这个类简单地封装了主机、用户名、认证方法和可选的端口号（默认为`22`）的指定，用于建立SSH连接。最后，将连接信息传递给我们的`SshClient`。`SshClient`实例仅初始化为连接信息的实例属性，因此我们仍然需要显式连接到我们的远程服务器。
- en: 'If you''ve configured your virtual machine as I showed you, and you run the
    application, you should see the We''ve connected! message in your application''s
    output. The question, though, is how can we verify that we actually did connect?
    By looking at the status of our listening SSH server in our Linux VM, we should
    see that the authentication credentials were accepted:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经按照我向您展示的方式配置了您的虚拟机，并运行了应用程序，您应该在应用程序的输出中看到“我们已连接！”的消息。但是，问题是，我们如何验证我们实际上已经连接上了？通过查看我们Linux虚拟机中监听SSH服务器状态，我们应该看到认证凭据已被接受：
- en: '![](img/d755204a-1681-4632-ab0c-312d0918d701.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d755204a-1681-4632-ab0c-312d0918d701.png)'
- en: And, just like that, we've remotely logged on to a host over an SSH connection.
    So, now that we know we can establish a connection, what can we actually do once
    we're logged on?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们通过SSH连接远程登录到主机。所以，现在我们知道我们可以建立连接，一旦登录，我们实际上能做什么呢？
- en: Remote execution with SSH
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SSH进行远程执行
- en: The SSH.NET library exposes operations on its `SshClient` class to perform everything
    from a simple command to opening up a shell terminal linked to the remote host.
    One of the core aspects of SSH, though, is that it is only intended to serve as
    a communication tunnel to a remote host. Therefore, the connections you can execute
    and the resources you can take advantage of will always be constrained by the
    remote host you're interacting with. In our example, we're working with an Ubuntu
    Linux host, so we're restricted to the commands and features supported by `OpenSSH`
    servers hosted on Ubuntu. With that in mind, let's look at how we can execute
    the operations available to us using SSH.NET.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: SSH.NET库暴露了其`SshClient`类的操作，以执行从简单的命令到打开与远程主机连接的shell终端的所有操作。然而，SSH的一个核心方面是它仅打算作为与远程主机的通信隧道。因此，您可以执行的连接和可以利用的资源将始终受限于您与之交互的远程主机。在我们的例子中，我们正在与一个Ubuntu
    Linux主机合作，因此我们受限于在Ubuntu上托管的`OpenSSH`服务器支持的命令和功能。考虑到这一点，让我们看看我们如何可以使用SSH.NET执行可用的操作。
- en: Creating commands in SSH.NET
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在SSH.NET中创建命令
- en: 'Now that we''ve successfully connected with our remote host using the `SshClient`
    class, we can use that client to start executing commands on that host. The pattern
    for this, as defined by SSH.NET, is to create a command, invoke its execution,
    and then observe its results. Alternatively, if you are executing exceptionally
    simple commands (as we''ll be doing in this demo), you can create and invoke your
    command in a single step. The result of invoking a command will always be an instance
    of the command, which will contain a handle to any output streams returned by
    the client, as well as the result you obtained when the command was executed.
    To see what that looks like in code, we''ll be using the Linux `uname` command,
    which simply returns information about the hardware and operating system kernel
    for the current host. I chose this because there''s no `uname` command in Windows,
    so by viewing our result, we can be sure we''re executing the calls against our
    remote host:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用`SshClient`类成功连接到远程主机，我们可以使用该客户端在该主机上执行命令。SSH.NET定义的这个模式是创建一个命令，调用其执行，然后观察其结果。或者，如果您正在执行非常简单的命令（就像我们在这次演示中将要做的），您可以在一个步骤中创建和调用您的命令。调用命令的结果将始终是命令的实例，它将包含对客户端返回的任何输出流的句柄，以及当命令执行时获得的结果。为了在代码中查看这看起来是什么样子，我们将使用Linux的`uname`命令，该命令简单地返回有关当前主机的硬件和操作系统内核的信息。我选择这个命令是因为Windows中没有`uname`命令，所以通过查看我们的结果，我们可以确信我们正在对远程主机执行调用：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It''s relatively straightforward, but it demonstrates the pattern of executing
    a command, and then using the returned instance of the `Command` class to view
    the result. By applying those lines of code to our program and then running it,
    we should see the following result returned from our VM:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这相对简单，但它演示了执行命令的模式，然后使用返回的`Command`类实例来查看结果。通过将那些代码行应用到我们的程序中并运行它，我们应该在我们的虚拟机中看到以下结果返回：
- en: '![](img/b26e544c-5b0b-4cc2-87ef-4fe9063c2efc.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b26e544c-5b0b-4cc2-87ef-4fe9063c2efc.png)'
- en: As if it wasn't clear from the operating system listed in our result, we are
    definitely connecting to our Ubuntu VM.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的结果中列出的操作系统一样明显，我们肯定是在连接到我们的Ubuntu虚拟机。
- en: Modifying our remote host
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改我们的远程主机
- en: 'To validate that we have the full permissions we should expect when logged
    in with our administrator accounts, let''s add an additional command to modify
    the directories on our VM. Then, we can confirm our full user access by confirming
    the presence of our new directory in our Ubuntu instance. To do this, we''ll add
    the following line of code to our project:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证我们登录管理员账户时应期望拥有的完整权限，让我们添加一个额外的命令来修改我们的虚拟机上的目录。然后，我们可以通过确认我们的新目录存在于我们的 Ubuntu
    实例中来确认我们的完整用户访问权限。为此，我们将添加以下代码行到我们的项目中：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you''re not familiar with the Linux filesystem standards, the `/home/tuxbox`
    root directory is the same as navigating to the `C:\Users\tuxbox\` directory in
    a Windows system. You can see that with this line of code, I intend to create
    a new directory on my remote machine, directly on the desktop, called `ssh_output`.
    After running it, I can open up my desktop directly in my VM, and I see the following
    result:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉 Linux 文件系统标准，那么 `/home/tuxbox` 根目录在 Windows 系统中相当于导航到 `C:\Users\tuxbox\`
    目录。你可以看到，通过这一行代码，我的意图是在我的远程机器上直接在桌面上创建一个名为 `ssh_output` 的新目录。运行后，我可以在我的虚拟机中直接打开我的桌面，并看到以下结果：
- en: '![](img/a701cebe-5420-4ff2-aaf0-e712634aa7fe.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a701cebe-5420-4ff2-aaf0-e712634aa7fe.png)'
- en: And, just like that, we've established a channel of secure communication from
    our software to a designated remote host.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们已经从我们的软件到指定的远程主机建立了一个安全的通信通道。
- en: If you take a little bit of time to explore the documentation, or even just
    the IntelliSense code suggestions for the SSH.NET library, you'll quickly see
    that it offers substantially more than we've looked at here. You can quickly and
    easily designate a port to forward to your remote host's listening ports, or create
    an entire shell, within a single line of code. The full breadth of features for
    it are certainly outside the scope of this book, but I'd strongly encourage you
    to take the features for a spin as you continue to learn and grow in the network
    programming space. I truly cannot overstate the value of simple, secure access
    to any remote resource you have configured to provide that kind of access.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你花点时间探索文档，或者甚至只是 SSH.NET 库的 IntelliSense 代码建议，你会很快看到它提供了比我们在这里看到的多得多的功能。你可以快速轻松地指定一个要转发到远程主机监听端口的端口，或者在一行代码内创建一个完整的
    shell。它的全部功能范围当然超出了本书的范围，但我强烈建议你在继续学习和成长于网络编程领域时尝试这些功能。我真心无法过分强调对任何已配置提供此类访问权限的远程资源的简单、安全访问的价值。
- en: For our purposes, though, I'm certain that your newfound understanding of the
    foundations of SSH, its design principles, and its implementation standards will
    give you all the tools you need to continue with your own learning. Ultimately,
    I hope that's what I've done throughout this whole book. My objective was to cover
    the foundational concepts of network programming and present them in an approachable
    and engaging way, viewed through the scope of C# development using the .NET Core
    framework. I sincerely hope I succeeded.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，就我们的目的而言，我确信你对 SSH 基础、其设计原则和其实施标准的全新理解将为你提供继续学习的所有工具。最终，我希望在整个书中我所做的一切都是如此。我的目标是涵盖网络编程的基础概念，并以一种易于接近和吸引人的方式呈现，通过
    C# 开发和使用 .NET Core 框架的视角。我真诚地希望我成功了。
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: For our final chapter, we took another extremely deep dive into an extremely
    focused topic. We learned just about everything there is to know about SSH and
    its use. We spent a fair bit of time learning about the origins and development
    history of the protocol, as well as some of the features and applications it allows.
    Next, we took a tour of the various RFCs that define the architecture of SSH.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最后一章中，我们深入研究了另一个极其专注的主题。我们几乎了解了有关 SSH 及其应用的所有知识。我们花了不少时间学习该协议的起源和发展历史，以及它允许的一些特性和应用。接下来，我们游览了定义
    SSH 架构的各个 RFC。
- en: We learned about each of the three tiers in the architectural design of the
    protocol, starting with the transport tier and the requirements for security and
    data integrity that are demanded by the standard. After that, we saw how user
    authentication was accomplished, looking at how each of the standard authentication
    modes are defined and typically implemented. Finally, we learned about the connection
    tier, and how the SSH standard characterizes the multiple, distinct interactions
    that can be happening simultaneously between two hosts connected over SSH.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了协议架构的三个层级，从传输层开始，以及标准对安全性和数据完整性的要求。之后，我们看到了用户认证是如何完成的，考察了标准认证模式是如何定义和通常实现的。最后，我们了解了连接层，以及SSH标准如何描述两个通过SSH连接的主机之间可以同时发生的多个、不同的交互。
- en: With that perspective in place, we were able to explore how we could leverage
    and interact with SSH in our C# projects. We discovered the SSH.NET library and
    took it for a spin, interacting with our own remote host. We saw how the library
    provides clean and intuitively defined abstractions for each of the architectural
    concepts we discussed earlier in this chapter. Finally, we looked at how we could
    act on behalf of our users, over SSH, to execute commands on a remote host.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了这个视角之后，我们能够探索如何在我们的C#项目中利用和交互SSH。我们发现了SSH.NET库，并尝试了与我们的远程主机交互。我们看到了这个库如何为我们之前在本章中讨论的每个架构概念提供干净且直观的定义抽象。最后，我们探讨了如何代表我们的用户通过SSH在远程主机上执行命令。
- en: And, with that, we have completed our comprehensive overview of the world of
    network programming, as seen through the lens of C# and the .NET Core framework.
    I sincerely hope it was as illuminating and informative and enjoyable for you
    to read as it was for me to research and write.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就完成了对网络编程世界的全面概述，这是通过C#和.NET Core框架的视角来看的。我真诚地希望，它对您阅读的启发和信息量，就像对我进行研究写作一样。
- en: Questions
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why was SSH originally created? What problems did it seek to solve?
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SSH最初是如何被创建的？它试图解决哪些问题？
- en: What are some of the more broadly used applications of SSH?
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SSH有哪些更广泛使用的应用？
- en: What are the three tiers of the SSH application architecture?
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SSH应用程序架构的三个层级是什么？
- en: What are the three standard authentication modes that are supported by SSH?
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SSH支持哪三种标准认证模式？
- en: What is a connection channel in the context of SSH?
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在SSH的上下文中，什么是连接通道？
- en: What is a window? How is it used?
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是窗口？它是如何被使用的？
- en: What is an interactive session?
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是交互式会话？
- en: Further reading
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: As we wrap up this book, hopefully you've taken many of my suggestions for further
    reading. This chapter focused, once again, on an advanced and extremely niche
    topic, for which there isn't much in the way of additional resources. However,
    if you are still interested in the subject of secure network tunneling, I would
    recommend the book *Understanding SSL VPN,* by Joseph Steinberg and Tim Speed.
    It gives a comprehensive look at the ins and outs of how secured VPNs work, and
    how they are administered. It's certainly something that will be of interest as
    you carry your new knowledge forward and plumb the depths of network programming.
    The book is available through Packt Publishing Ltd., and you can find a copy here: [https://www.packtpub.com/networking-and-servers/ssl-vpn-understanding-evaluating-and-planning-secure-web-based-remote-access](https://www.packtpub.com/networking-and-servers/ssl-vpn-understanding-evaluating-and-planning-secure-web-based-remote-access).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束这本书的时候，希望您已经采纳了我提出的许多进一步阅读的建议。这一章再次关注了一个高级且极其狭窄的主题，关于这个主题的资源并不多。然而，如果您仍然对安全网络隧道主题感兴趣，我推荐Joseph
    Steinberg和Tim Speed合著的《Understanding SSL VPN》一书。这本书全面地探讨了安全VPN的工作原理以及它们的行政管理。这确实是在您将新知识应用于实践并深入网络编程时可能会感兴趣的内容。这本书由Packt
    Publishing Ltd.出版，您可以通过以下链接找到副本：[https://www.packtpub.com/networking-and-servers/ssl-vpn-understanding-evaluating-and-planning-secure-web-based-remote-access](https://www.packtpub.com/networking-and-servers/ssl-vpn-understanding-evaluating-and-planning-secure-web-based-remote-access)。
