- en: Understanding Lighting Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we introduced Surface Shaders and explained how we
    can change physical properties (such as Albedo and Specular) to simulate different
    materials. How does this really work? At the heart of every Surface Shader, there
    is its **lighting model**. It's the function that takes these properties and calculates
    the final shade of each pixel. Unity usually hides this from the developers because
    in order to write a lighting model, you have to understand how light reflects
    and refracts onto surfaces. This chapter will finally show you how lighting models
    work and give you the basics to create your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom diffuse lighting model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a toon shader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Phong Specular type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a BlinnPhong Specular type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an Anisotropic Specular type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simulating the way light works is a very challenging and resource-consuming
    task. For many years, video games have used very simple lighting models which,
    despite lacking realism, were very believable. Even if most 3D engines are now
    using physically-based renderers, it is worth exploring some simpler techniques.
    The ones presented in this chapter are reasonably realistic and widely adopted
    on devices with low resources such as mobile phones. Understanding these simple
    lighting models is also essential if you want to create your own.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom diffuse lighting model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are familiar with Unity 4, you may know that the default shader it provided
    was based on a lighting model called **Lambertian reflectance**. This recipe will
    show you how it is possible to create a shader with a custom lighting model and
    explains the mathematicsinvolved and implementation. The following diagram shows
    the same geometry rendered with a Standard Shader (right) and a diffuse Lambert
    one (left):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Shaders based on Lambertian reflectance are classified as non-photorealistic;
    no object in the real world really looks like this. However, Lambert Shaders are
    still often used in low-poly games as they produce a neat contrast between the
    faces of complex geometries. The lighting model used to calculate the Lambertian
    reflectance is also very efficient, making it perfect for mobile games.
  prefs: []
  type: TYPE_NORMAL
- en: Unity has already provided us with a lighting function that we can use for our
    shaders. It is called the Lambertian lighting model. It is one of the more basic
    and efficient forms of reflectance, which you can find in a lot of games even
    today. As it is already built in the Unity Surface Shader language, we thought
    it best to start with this first and build on it. You can also find an example
    in the Unity reference manual, but we will go into more depth and explain where
    the data is coming from and why it is working the way it is. This will help you
    get a nice grounding in setting up custom lighting models so that we can build
    on this knowledge in the future recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by carrying out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new shader and give it a name (`SimpleLambert`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new material, give it a name (`SimpleLambertMat`), and assign the new
    shader to its `shader` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, create a sphere object and place it roughly in the center of the scene
    and attach the new material to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, let's create a directional light to cast some light on our object if
    one isn't created already.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When your assets have been set up in Unity, you should have a scene that resembles
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Lambertian reflectance can be achieved with the following changes to the
    shader:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by replacing the shader''s `Properties` block with the following :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Since we are removing all of the other properties, remove the `_Glossiness`,
    `_Metallic`, and `_Color` declarations inside of the `SubShader` section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the `#pragma` directive of the shader so that, instead of `Standard`,
    it uses our custom lighting model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you try to run the script now, it will complain that it doesn't know what
    the `SimpleLambert` lighting model is. We will need to create a function called
    `Lighting`  + the name that we gave here with instructions on how to light the
    object, which we will be writing later on in this recipe. In this case, it would
    be `LightingSimpleLambert`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use a very simple surface function, which just samples the texture according
    to its UV data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a function called `LightingSimpleLambert()` that will contain the following
    code for the Lambertian reflectance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Save your script and return to the Unity editor. You should notice that it
    looks somewhat different than what was there before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The effect is even easier to see if we use the cylinders we used in the previous
    chapter, [Chapter 3](part0063.html#1S2JE0-e8c76c858d514bc3b1668fda96f8fa08), *Surface
    Shaders and Texture Mapping*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00081.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As previously seen in [Chapter 2](part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08),
    *Creating Your First Shader*, the `#pragma` directive is used to specify which
    surface function to use. Choosing a different lighting model works in a similar
    fashion: `SimpleLambert` forces Cg to look for a function called `LightingSimpleLambert()`.
    Note the `Lighting` at the beginning, which is omitted in the directive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Lighting` function takes three parameters: the *surface output* (which
    contains the physical properties such as the albedo and transparency), the *direction*
    the light is coming from, and its *attenuation*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'According to Lambertian reflectance, the amount of light a surface reflects
    depends on the angle between the incident light and surface normal. If you have
    played pool billiards, you are surely familiar with this concept; the direction
    of a ball depends on its incident angle against the wall. If you hit a wall at
    a 90 degree angle, the ball will come back at you; if you hit it with a very low
    angle, its direction will be mostly unchanged. The Lambertian model makes the
    same assumption; if the light hits a triangle at a 90 degree angle, all the light
    gets reflected back. The lower the angle, the less light is reflected back to
    you. This concept is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00082.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This simple concept has to be translated into a mathematical form. In vector
    algebra, the angle between two unit vectors can be calculated via an operator
    called **dot product**. When the dot product is equal to zero, two vectors are
    orthogonal, which means that they make a 90-degree angle. When it is equal to
    one (or minus one), they are parallel to each other. Cg has a function called
    `dot()`, which implements the dot product extremely efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a light source (sun) shining on a complex surface.
    **L** indicates the light direction (called `lightDir` in the shader) and **N**
    is the normal to the surface. The light is reflected with the same angle that
    it hits the surface with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00083.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For more information on normals and what they mean mathematically check out: [https://en.wikipedia.org/wiki/Normal_(geometry)](https://en.wikipedia.org/wiki/Normal_(geometry))
  prefs: []
  type: TYPE_NORMAL
- en: 'Lambertian reflectance simply uses the `NdotL` dot product as a multiplicative
    coefficient for the intensity of light:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00084.gif)'
  prefs: []
  type: TYPE_IMG
- en: When *N* and *L* are parallel, all the light is reflected back to the source,
    causing the geometry to appear brighter. The `_LightColor0` variable contains
    the color of the light that is calculated.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to Unity 5, the intensity of the lights was different. If you are using
    an old diffuse shader based on the Lambertian model, you may notice that `NdotL` is
    multiplied by two: `(NdotL * atten * 2)`, rather than `(NdotL * atten)`. If you
    are importing a custom shader from Unity 4, you will need to correct this manually.
    Legacy Shaders, however, have already been designed taking this aspect into account.
  prefs: []
  type: TYPE_NORMAL
- en: When the dot product is negative, the light is coming from the opposite side
    of the triangle. This is not a problem for opaque geometries as triangles that
    are not facing the camera frontally are culled (discarded) and not rendered.
  prefs: []
  type: TYPE_NORMAL
- en: This basic Lambert is a great starting point when you are prototyping your shaders
    as you can get a lot accomplished in terms of writing the core functionality of
    the shader while not having to worry about the basic `Lighting` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Unity has provided us with a lighting model that has already taken the task
    of creating a Lambert lighting for you. If you look at the `UnityCG.cginc` file
    found in your Unity's installation directory under the `Data` folder, you will
    notice that you have Lambert and BlinnPhong lighting models available for you
    to use. The moment you compile your shader with `#pragma surface surf Lambert`,
    you are telling the shader to utilize Unity's implementation of the Lambert `Lighting`
    function in the `UnityCG.cginc` file so that you don't have to write that code
    over and over again. We will explore how the BlinnPhong model works later in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a toon shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most used effects in games is **toon shading**, which is also known
    as **celluloid** (**CEL**) shading. It is a non-photorealistic rendering technique
    that makes 3D models appear flat. Many games use it to give the illusion that
    the graphics are being hand-drawn rather than being 3D modeled. You can see, in
    the following diagram, a sphere rendered with a toon Shader (left) and a Standard
    Shader (right):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00085.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Achieving this effect using just surface functions is not impossible, but it
    would be extremely expensive and time consuming. The surface function, in fact,
    only works on the properties of the material, not its actual lighting condition.
    As toon shading requires us to change the way light reflects, we need to create
    our custom lighting model instead.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start this recipe by creating a shader and its material and importing
    a special texture, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new shader; in this example, we will duplicate the one made
    in the previous recipe by selecting it in the Project tab and then hit *Ctrl *+ *D*.
    We will change the name of this new `shader` to `ToonShader`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can rename an object in the Project window by single-clicking on the name.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new material for the shader (`ToonShaderMat`) and attach it to a 3D
    model. Toon shading works best on curved surfaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This recipe requires an additional texture called a **ramp map**,which will
    be used to dictate when we want to use certain colors depending on the shade received:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00086.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This book has an example texture in `Chapter 4` | `Textures` folder. If you
    decide to import your own, it is important that you select your next texture and,
    from the Inspector tab, change the ramp map''s Wrap Mode to Clamp. If you want
    the edges between the colors to be sharp, the Filter Mode should also be set to
    Point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00087.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The example project included with this book already has this step completed
    in the `Assets `| `Chapter 4 `| `Texture `| `ToonRamp` file, but it is a good
    idea to verify that this is the case before moving forward.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The toon aesthetic can be achieved with the following changes to the shader:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new property for a texture called `_RampTex`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add its relative variable in the `CGPROGRAM` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the `#pragma` directive so that it points to a function called `LightingToon()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the `LightingSimpleLambert` function with the following function instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the script, open up the `ToonShaderMat`, and assign the `Ramp` property
    to your ramp map. If all goes well, you should see something like the following
    in your scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00088.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This effect may be modified by the lighting in the scene. You can change the
    illumination of the scene by going to Window | Lighting | Settings and changing
    the Environment | Environment Lighting | Intensity Multiplier property to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main characteristic of toon shading is the way the light is rendered; surfaces
    are not shaded uniformly. To achieve this effect, we need a ramp map. Its purpose
    is to remap the Lambertian light intensity `NdotL` to another value. Using a ramp
    map without a gradient, we can force the lighting to be rendered in steps. The
    following diagram shows how the ramp map is used to correct the light intensity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00089.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many different ways whereby you can achieve a toon shading effect.
    Using different ramps can produce dramatic changes in the way your models look,
    so you should experiment in order to find the best one.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative to ramp textures is to **snap** the light intensity `NdotL`
    so that it can only assume a certain number of values equidistantly sampled from
    `0` to `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To snap a number we first multiply `NdotL` by the `_CelShadingLevels` variable, 
    round the result to an integer through the `floor` function, and then divides
    it back. This rounding is done by the `floor` function which will effectively
    remove the decimal point from a number. By doing this, the `cel` quantity is forced
    to assume one of the `_CelShadingLevels` equidistant values from `0` to `1`. This
    removes the need for a ramp texture and makes all the color steps of the same
    size. If you are going for this implementation, remember to add a property called
    `_CelShadingLevels` to your shader. You can find an example of this in the example
    code for this chapter. Try dragging the Levels property to see how it affects
    how the screenshot is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00090.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a Phong Specular type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The specularity of an object surface simply describes how shiny it is. These
    types of effects are often referred to as view-dependent effects in the shader
    world. This is because, in order to achieve a realistic Specular effect in your
    shaders, you need to include the direction of the camera or the user facing the
    object's surface. The most basic and performance-friendly Specular type is the
    Phong Specular effect. It is the calculation of the light direction reflecting
    off of the surface compared to the user's view direction. It is a very common
    Specular model used in many applications, from games to movies. While it isn't
    the most realistic in terms of accurately modeling the reflected Specular, it
    gives a great approximation of what is expected of shininess that performs well
    in most situations. Additionally, if your object is further away from the camera
    and there is no need for a very accurate Specular, this is a great way to provide
    a Specular effect to your shaders.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will be covering how to implement the per-vertex version
    of the shader and also the per-pixel version using some new parameters in the
    Surface Shader's `Input` struct. We will see the difference and discuss when and
    why to use these two different implementations for different situations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start with this recipe, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new shader (`Phong`), material(`PhongMat`), and a new scene with a
    sphere in it with a Plane underneath it (GameObject | 3D Objects | Plane).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Attach the shader to the material and the material to the object. To finish
    off your new scene, create a new directional light if one is not there already,
    so that you can see your Specular effect as you code it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00091.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to create a Phong lighting model:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be seeing a pattern at this point, but we always like to start out
    with our most basic part of the shader writing process: the creation of properties.
    So, let''s remove all of the current properties with their definitions in the
    `SubShader` block and then add the following properties to the shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We then have to make sure to add the corresponding variables to our `CGPROGRAM`
    block in our `SubShader{}` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to add our custom lighting model so that we can compute our own
    Phong Specular. Don''t worry if it doesn''t make sense at this point; we will
    cover each line of code in the *How it works...* section of this recipe. Add the
    following code to the shader''s `SubShader{}` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to tell the `CGPROGRAM` block that it needs to use our custom
    Lighting function instead of one of the built-in ones. We do this by changing
    the `#pragma` statement to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s update the `surf` function to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot demonstrates the result of our custom Phong lighting
    model using our own custom reflection vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00092.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Try changing the Specular Power property and notice the effect that you see.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's break down the Lighting function by itself, as the rest of the shader
    should be pretty familiar to you at this point.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous recipes, we have used a Lighting function that provided only
    the light direction, `lightDir`.
  prefs: []
  type: TYPE_NORMAL
- en: Unity comes with a set of Lighting functions that you can use, including one
    that provides the view direction, `viewDir`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To figure out how to write your own custom lighting mode refer to the following
    table replacing NameYouChoose with the lighting function name you gave in the
    `#pragma` statement or go to [http://docs.unity3d.com/Documentation/Components/SL-SurfaceShaderLighting.html](http://docs.unity3d.com/Documentation/Components/SL-SurfaceShaderLighting.html) for
    more details:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Not view-dependent** | `` `half4 LightingNameYouChoose` (`SurfaceOutput
    s`, `half3` `lightDir`, `half atten` ``); |'
  prefs: []
  type: TYPE_TB
- en: '| **View-dependent** | `half4 LightingNameYouChoose (SurfaceOutput s, half3
    lightDir, half3 viewDir, half atten);` |'
  prefs: []
  type: TYPE_TB
- en: 'In our case, we are using a Specular shader, so we need to have the view-dependent
    `Lighting` function structure. We have to write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will tell the shader that we want to create our own view-dependent shader.
    Always make sure that your Lighting function name is the same in your `Lighting`
    function declaration and the `#pragma` statement, or Unity will not be able to
    find your lighting model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The components that play a role in the `Phong` model are described in the following
    image. We have the light direction **L** (coupled with its perfect reflection
    **R**) and normal direction **N**. They have all been encountered before in the
    Lambertian model, with the exception of **V**, which is the **view direction**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00093.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `Phong` model assumes that the final light intensity of a reflective surface
    is given by two components, its diffuse color, and Specular value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00094.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'The diffuse component *D* remains unchanged from the Lambertian model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00095.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'The Specular component *S* is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00096.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, *p* is the Specular power defined as `_SpecPower` in the shader. The
    only unknown parameter is *R*, which is the reflection of *L* according to *N*.
    In vector algebra, this can be calculated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00097.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'This is exactly what is calculated in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This has the effect of bending the normal towards the light; as a vertex, normal
    is pointing away from the light, it is forced to look at the light. Refer to the
    following diagram for a more visual representation. The script that produces this
    debug effect is included in this book''s support page at [https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00098.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following diagram displays the final result of our Phong Specular calculation
    isolated in the shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00099.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a BlinnPhong Specular type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Blinn** is another more efficient way of calculating and estimating specularity.
    It is done by getting the half vector from the view direction and light direction.
    It was brought into the world of Cg by Jim Blinn. He found that it was much more
    efficient to just get the half vector instead of calculating our own reflection
    vectors. It cut down on the code and processing time. If you actually look at
    the built-in BlinnPhong lighting model included in the `UnityCG.cginc` file, you
    will notice that it is using the half vector as well, hence it is named BlinnPhong.
    It is just a simpler version of the full Phong calculation.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start with this recipe, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, instead of creating a whole new scene, let''s just use the objects
    and scene that we have by using File | Save Scene As..., and create a new shader
    (BlinnPhong) and material (`BlinnPhongMat`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00100.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once you have a new shader, double-click on it to launch your IDE of choice
    so that you can start editing your shader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to create a BlinnPhong lighting model:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s remove all of the current properties with their definitions in
    the `SubShader` block. Then we need to add our own properties to the `Properties`
    block so that we can control the look of the Specular highlight:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to make sure that we have created the corresponding variables
    in our `CGPROGRAM` block so that we can access the data from our `Properties`
    block, in our subshader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to create our custom lighting model that will process our Diffuse
    and Specular calculations. The code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then update the `surf` function to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To complete our shader, we will need to tell our CGPROGRAM block to use our
    custom lighting model rather than a built-in one by modifying the `#pragma` statement
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot demonstrates the results of our BlinnPhong lighting
    model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00101.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The BlinnPhong Specular is almost exactly like the Phong Specular, except that
    it is more efficient because it uses less code to achieve almost the same effect.
    Before the introduction of physically-based rendering, this approach was the default
    choice for Specular reflection in Unity 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculating the reflection vector **R** is generally expensive. The BlinnPhong
    Specular replaces it with the half vector **H** between the view direction **V**
    and light direction **L**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00102.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Instead of calculating our own reflection vector, we are simply going to get
    the vector halfway between the view direction and light direction, basically simulating
    the reflection vector. It has actually been found that this approach is more physically
    accurate than the last approach, but we thought it necessary to show you all the
    possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00103.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'According to vector algebra, the half vector can be calculated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00104.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Here |V+L| is the length of the vector V+L. In Cg, we simply need to add the
    view direction and light direction together and then normalize the result to a
    unity vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Then, we simply need to dot the vertex normal with this new half vector to get
    our main Specular value. After this, we just take it to a power of `_SpecPower`
    and multiply it by the Specular color variable. It's much lighter on the code
    and math, but still gives us a nice Specular highlight that will work for many
    real-time situations.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The light models seen in this chapter are extremely simple; no real material
    is perfectly matte or perfectly specular. Moreover, it is not uncommon for complex
    materials such as clothing, wood, and skin to require knowledge of how light scatters
    in the layers beneath the surface. Use the following table to recap the different
    lighting models encountered so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Technique** | **Type** | **Light Intensity (I)** |'
  prefs: []
  type: TYPE_TB
- en: '| Lambertian | Diffuse | ![](img/00105.gif) |'
  prefs: []
  type: TYPE_TB
- en: '| `Phong` | Specular | ![](img/00106.gif)![](img/00107.gif) |'
  prefs: []
  type: TYPE_TB
- en: '| BlinnPhong | Specular | ![](img/00108.gif)![](img/00109.gif) |'
  prefs: []
  type: TYPE_TB
- en: 'There are other interesting models such as the Oren-Nayar lighting model for
    rough surfaces: [https://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model](https://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Anisotropic Specular type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Anisotropic** is a type of Specular or reflection that simulates the directionality
    of grooves in a surface and modifies/stretches the Specular in the perpendicular
    direction. It is very useful when you want to simulate brushed metals, not a metal
    with a clear, smooth, and polished surface. Imagine the Specular that you see
    when you look at the data side of a CD or DVD or the way Specular is shaped at
    the bottom of a pot or pan. You will notice that if you carefully examine the
    surface, there is a direction to the grooves, usually in the way the metal was
    brushed. When you apply a Specular to this surface, you get a Specular stretched
    in the perpendicular direction.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe will introduce you to the concept of augmenting your Specular highlights
    to achieve different types of brushed surfaces. In future recipes, we will look
    at the ways in which we can use the concepts of this recipe to achieve other effects,
    such as stretched reflections and hair, but here, you are going to learn the fundamentals
    of the technique first. We will be using this shader as a reference for our own
    custom Anisotropic Shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://wiki.unity3d.com/index.php?title=Anisotropic_Highlight_Shader](http://wiki.unity3d.com/index.php?title=Anisotropic_Highlight_Shader).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows examples of different types of Specular effects
    that you can achieve using Anisotropic Shaders in Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00110.gif)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start this recipe by creating a shader, its material, and some lights
    for our scene:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene with some objects and lights so that we can visually debug
    our shader. In this case, we will be using some capsules, a sphere, and a cylinder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then create a new shader and material, and hook them up to your objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00111.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Lastly, we will need some sort of normal map that will indicate the directionality
    of our Anisotropic Specular highlight.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the Anisotropy normal map we will be using for
    this recipe. It is available from this book''s support page at [https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00112.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create an Anisotropic effect, we need to make the following changes to the
    shader previously created:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first need to remove the old properties and then add the properties that
    we are going to need for our shader. These will allow a lot of artistic control
    over the final appearance of the surface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We then need to make the connection between our `Properties` block and
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'our `SubShader{}` block so that we can use the data being provided by the `Properties`
    block:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create our `Lighting` function that will produce the correct Anisotropic
    effect on our surface. We will use the following code for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to use this new `Lighting` function, we need to tell the subshader''s
    `#pragma` statement to look for it instead of using one of the built-in `Lighting`
    functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We have also given the Anisotropic normal map its own UVs by declaring the
    following code in the `struct Input`. This isn''t entirely necessary as we could
    just use the UVs from the main texture, but this gives us independent control
    over the tiling of our brushed metal effect so that we can scale it to any size
    we want:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add the `struct SurfaceAnisoOutput`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to use the `surf()` function to pass the correct data to our
    `Lighting` function. Hence, we will get the per-pixel information from our Anisotropic
    normal map and set our Specular parameters as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Save your script and return to the Unity editor. Select the `AnisotropicMat`
    material and assign the Anisotropic Direction property to the texture we talked
    about in the *Getting ready* section of this recipe. Afterward, adjust the Anisotopic
    `Offset` property using the slider and notice the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Anisotropic normal map allows us to give the surface direction and helps
    us disperse the Specular highlight around the surface. The following screenshot
    demonstrates the result of our Anisotropic Shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00113.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's break down this shader into its core components and explain why we are
    getting the effect. We will mostly be covering the custom Lighting function here,
    as the rest of the shader should be pretty self-explanatory at this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first start by declaring our own `SurfaceAnisoOutput struct`. We need to
    do this in order to get the per-pixel information from the Anisotropic normal
    map, and the only way we can do this in a Surface Shader is to use a `tex2D()`
    function in the `surf()` function. The following code shows the custom surface
    output structure used in our shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We can use the `SurfaceAnisoOutput` struct as a way of interacting between the
    Lighting function and the surface function. In our case, we are storing the per-pixel
    texture information in the variable called `anisoTex` in our `surf()` function
    and then passing this data to the `SurfaceAnisoOutput` struct by storing it in
    the `AnisoDirection` variable. Once we have this, we can use the per-pixel information
    in the `Lighting` function using `s.AnisoDirection`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this data connection set up, we can move on to our actual lighting calculations.
    This begins by getting the usual out of the way, the half vector, so that we don''t
    have to do the full reflection calculation and diffuse lighting, which is the
    vertex normal dotted with the light vector or direction. This is done in Cg with
    the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we start the actual modification to the Specular to get the right look.
    We first dot the normalized sum of the vertex normal and per-pixel vectors from
    our Anisotropic normal map with the `halfVector` calculated in the previous step.
    This gives us a float value that gives a value of `1` as the surface normal, which
    is modified by the Anisotropic normal map as it becomes parallel with `halfVector`
    and `0` as it is perpendicular. Finally, we modify this value with a `sin()` function
    so that we can basically get a darker middle highlight and ultimately a ring effect
    based on `halfVector`. All the previously mentioned operations are summarized
    in the following two lines of Cg code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we scale the effect of the `aniso` value by taking it to a power of
    `s.Gloss`, and then globally decrease its strength by multiplying it by `s.Specular`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This effect is great for creating more advanced metal type surfaces, especially
    the ones that are brushed and appear to have directionality to them. It also works
    well for hair or any sort of soft surface with directionality to it. The following
    screenshot shows the result of displaying the final Anisotropic lighting calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00114.jpeg)'
  prefs: []
  type: TYPE_IMG
