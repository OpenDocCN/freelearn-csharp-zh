- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Implementing Continuous Integration with GitHub Actions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions 实现持续集成
- en: You wrote unit tests and other types of tests and you are happy about your code
    coverage and quality. So far so good, but who is going to make sure these tests
    are going to run every time the code changes? Is it the developer that is pushing
    new code? What if they forget? What if there are merge problems in source control
    that might break your tests? Who is going to check?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写了单元测试和其他类型的测试，并且对你的代码覆盖率和质量感到满意。到目前为止一切顺利，但是谁会确保每次代码更改时都会运行这些测试呢？是推送新代码的开发者吗？如果他们忘记了怎么办？如果源控制中存在可能导致测试失败的合并问题怎么办？谁来检查？
- en: You’ve already figured out the answer. It is the **continuous integration**
    (**CI**) system that you should have in place. CI is the natural companion to
    unit testing, and you can rarely find a modern project today without a CI system
    in place.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经找到了答案。这就是你应该实施的**持续集成**（**CI**）系统。CI 是单元测试的自然伴侣，你很少能在现代项目中找到没有 CI 系统的情况。
- en: 'In this chapter, we will cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: An introduction to continuous integration
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成的介绍
- en: Implementing a CI process with GitHub Actions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions 实现CI流程
- en: By the end of the chapter, you will be able to implement an end-to-end CI process
    with GitHub Actions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用 GitHub Actions 实现一个端到端的 CI 流程。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found at the following GitHub repository:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下 GitHub 仓库中找到：
- en: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/.github/workflows](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/.github/workflows)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/.github/workflows](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/.github/workflows)'
- en: Introduction to continuous integration
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成介绍
- en: The idea behind the term **CI** is that new code is continuously integrated
    with existing code, which results in a system that can be shipped to production
    at any time (or at least this is the intention).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**CI**（持续集成）这个术语背后的想法是，新代码持续与现有代码集成，这导致了一个可以随时（或至少是意图上）发货到生产的系统。'
- en: The route from software development to production is referred to as the **release
    pipeline**, where the code passes through multiple processes to reach production,
    such as compiling the code, deploying the binaries on the dev environment, allowing
    a QA to pull the code to a certain environment, and others. CI is an integral
    part of the release pipeline.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从软件开发到生产的路线被称为**发布管道**，代码在此通过多个过程到达生产，例如编译代码、在开发环境中部署二进制文件、允许质量保证人员将代码拉取到特定环境，以及其他操作。CI
    是发布管道的一个组成部分。
- en: 'A CI system requires a host so that it can do various operations on the code.
    The host is a combination of a server and an operating system:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: CI 系统需要一个主机，以便它可以在代码上执行各种操作。主机是服务器和操作系统的组合：
- en: '![Figure 11.1 – CI server in an OS ](img/Figure_11.1_B18370.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – 操作系统中的 CI 服务器](img/Figure_11.1_B18370.jpg)'
- en: Figure 11.1 – CI server in an OS
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.1 – 操作系统中的 CI 服务器](img/Figure_11.1_B18370.jpg)'
- en: 'Here are a few examples of on-premise CI servers:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些本地 CI 服务器的例子：
- en: Cruise Control
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cruise Control
- en: Team City
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Team City
- en: '**Team Foundation Server** (**TFS**)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队基础服务器**（**TFS**）'
- en: Jenkins
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins
- en: Octopus Deploy
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Octopus Deploy
- en: 'You will be able to find a SaaS solution for the previously mentioned system
    as well. However, today, the native cloud solutions are more popular, such as
    the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将能够找到之前提到的系统的 SaaS 解决方案。然而，今天，本地的云解决方案更为流行，例如以下这些：
- en: GitHub Actions
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub Actions
- en: Azure DevOps
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure DevOps
- en: AWS CodePipeline
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CodePipeline
- en: Octopus Cloud
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Octopus Cloud
- en: GitLab CI/CD
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitLab CI/CD
- en: The concepts of these systems are the same and when you learn one, you can easily
    learn another. Now, let’s see how a CI system works.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些系统的概念是相同的，当你学习其中一个时，你可以轻松地学习另一个。现在，让我们看看 CI 系统是如何工作的。
- en: CI workflow
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CI 工作流程
- en: 'A CI system applies a workflow to your code by executing a series of actions.
    The actions are configurable and may vary between one project and another based
    on the project’s needs. This is a generic workflow for a CI system:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: CI 系统通过执行一系列操作将工作流程应用于你的代码。这些操作是可配置的，并且可能因项目需求而异。这是一个 CI 系统的通用工作流程：
- en: '![Figure 11.2 – CI workflow ](img/Figure_11.2_B18370.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – CI 工作流程](img/Figure_11.2_B18370.jpg)'
- en: Figure 11.2 – CI workflow
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – CI 工作流程
- en: When a developer pushes new code into the source control, the CI system is usually
    listening for this event. It takes a copy of the code and tries to compile it
    similarly to what happens when you compile on your machine. Then, it tries to
    discover all the unit tests in your test projects and execute them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者将新代码推送到源代码控制时，CI系统通常会监听这个事件。它会复制代码并尝试以类似于您在机器上编译的方式编译它。然后，它尝试发现您测试项目中的所有单元测试并执行它们。
- en: CI systems are highly customizable, so a developer might add execution for multiple
    types of tests and other housekeeping steps.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: CI系统高度可定制，因此开发者可能会添加执行多种类型的测试和其他维护步骤。
- en: If any step fails, the CI system will abandon the build and mark it as failed,
    and notify the developer via a pre-configured way, such as an email.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何步骤失败，CI系统将放弃构建并将其标记为失败，并通过预配置的方式通知开发者，例如通过电子邮件。
- en: If all the steps pass, then a **continuous deployment** (**CD**) system can
    be plugged into the end of this process. A CD system deploys your built code (binaries)
    into servers based on your specific preferences. Therefore, you always hear the
    terms *CI/CD* used simultaneously.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有步骤都通过，那么一个**持续部署**（**CD**）系统就可以插入到这个过程的末端。CD系统会根据您的特定偏好将构建好的代码（二进制文件）部署到服务器上。因此，您通常会同时听到*CI/CD*这两个术语。
- en: Next, we are going to discuss the importance of CI in a software engineering
    process.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论在软件工程过程中持续集成（CI）的重要性。
- en: The benefits of CI systems
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CI系统的优势
- en: CI systems are usually plugged in from sprint zero of an agile process. They
    exist from day one for good reasons. Obviously, building a CI system pipeline
    takes time and effort, so there should be a justification for the added effort.
    Here, we will see the importance and benefits of a CI system.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: CI系统通常从敏捷过程的冲刺零阶段开始插入。它们从第一天开始就有很好的理由。显然，构建CI系统管道需要时间和精力，因此应该有对额外努力的正当理由。在这里，我们将看到CI系统的重要性和好处。
- en: Having the code compiling at all times
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码始终处于编译状态
- en: How many times in a team project have you pulled the latest code from source
    control and discovered that it does not compile? The CI system ensures the code
    compiles at all times and the best practice is not to pull the new code if the
    CI flags a previous push as a failure, because you won’t be able to continue working
    unless you fix the code yourself or wait for your colleague to fix it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在团队项目中，您有多少次从源代码控制中拉取最新代码，却发现它无法编译？CI系统确保代码始终可以编译，最佳实践是在CI标记之前的推送为失败时不要拉取新代码，因为除非您自己修复代码或等待同事修复，否则您无法继续工作。
- en: Of course, you will have to pull the broken build if you are intending to fix
    it, but the CI gives you an earlier indication.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果您打算修复它，您将不得不拉取损坏的构建，但CI系统会给出更早的指示。
- en: Usually, broken code in source control happens when a developer doesn’t pull
    the latest from source control, and compiles and executes the tests before pushing
    their code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，源代码控制中的代码损坏发生在开发者没有从源代码控制中拉取最新版本，而在推送代码之前编译和执行测试。
- en: Having the unit tests passing at all times
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试始终通过
- en: Developers might forget to execute the unit tests on their machine before pushing
    their code, but the CI system won’t forget!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可能会忘记在推送代码之前在自己的机器上执行单元测试，但CI系统不会忘记！
- en: As per the previous discussion in this book, where unit tests should be high-performance,
    the CI should take no time in running all your unit tests to feed back to the
    team that the build is safe and ready for them to pull the new code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 根据本书之前的讨论，单元测试应该是高性能的，CI系统应该不会花费太多时间运行所有单元测试，以便向团队反馈构建是安全的，并且已经准备好让他们拉取新代码。
- en: I have specifically mentioned unit tests as they provide fast feedback. You
    might have other types of tests that might take time to execute, and you may decide
    whether you want to execute them with every push or at certain times of the day.
    Other tests are usually slow and take minutes to execute, and you might want to
    run them in parallel but not block the feedback until they finish, which might
    be 10 minutes or an hour.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我特别提到了单元测试，因为它们可以提供快速的反馈。您可能还有其他类型的测试，这些测试可能需要时间来执行，您可能决定是否要在每次推送时执行它们或在一天中的特定时间执行。其他测试通常较慢，需要几分钟才能执行，您可能希望并行运行它们，但不要在它们完成之前阻止反馈，这可能需要10分钟或一个小时。
- en: Compiling the code in a ready state for CD
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为CD准备就绪的代码编译
- en: If the build has compiled successfully and passed testing, then this is ready
    for manual testing if you have this as part of your software engineering process
    or if you have binaries ready to be deployed to your environments by the CD process.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构建成功编译并通过了测试，那么如果这是你软件工程过程的一部分，或者你有二进制文件准备通过 CD 流程部署到你的环境中，那么它就准备好进行手动测试了。
- en: The CD process takes the output of your CI and deploys it to configured locations
    such as your dev environment, UAT, and production.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: CD 流程将 CI 的输出部署到配置的位置，如你的开发环境、UAT 和生产环境。
- en: CI is not optional anymore in today’s software engineering process, as you can
    see from the benefits. There is no excuse not to implement one. It is cheap, and
    it is easy to implement, as we are going to see next when we utilize GitHub Actions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: CI 在今天的软件工程过程中不再是可选的，正如你可以从其好处中看到的那样。没有理由不实施它。它既便宜又容易实现，正如我们将在使用 GitHub Actions
    时看到的那样。
- en: Implementing a CI process with GitHub Actions
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions 实现CI流程
- en: Initially, when I was designing the guidelines for the chapters in this book,
    I was planning to give a sample implementation using Azure DevOps, as it has a
    popular CI system. However, GitHub Actions climbed up fast and quickly became
    the developers’ choice in configuring a CI system, so I changed my mind and I
    am going to use GitHub Actions instead.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我在为本书的章节设计指南时，计划使用 Azure DevOps 提供一个示例实现，因为它有一个流行的 CI 系统。然而，GitHub Actions
    迅速崛起，并很快成为开发者配置 CI 系统的首选，所以我改变了主意，打算使用 GitHub Actions。
- en: GitHub Actions can deal with multiple programming stacks; one of them is .NET
    Core, which is what we are concerned about in this chapter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 可以处理多个编程栈；其中之一是 .NET Core，这是我们本章关注的重点。
- en: Obviously, you will need to have a GitHub account for using GitHub Actions and
    you will be glad to know that the free tier gives you 2,000 minutes/month of running
    time, which should be enough for a small solo project.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你需要一个 GitHub 账户来使用 GitHub Actions，而且你会很高兴地知道免费层每月提供 2,000 分钟的运行时间，这对于一个小型独立项目来说应该足够了。
- en: Next, we are going to use GitHub Actions as a CI system for the project in [*Chapter
    10*](B18370_10.xhtml#_idTextAnchor245), *Building an App with Repositories and
    Document DB* you don’t need to have read the chapter, we just want a solution
    that has a project and unit tests against it so we can demonstrate how Actions
    works and [*Chapter 10*](B18370_10.xhtml#_idTextAnchor245) has that.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 GitHub Actions 作为[*第 10 章*](B18370_10.xhtml#_idTextAnchor245)中项目的
    CI 系统，“使用存储库和 Document DB 构建应用程序”你不需要阅读该章节，我们只是需要一个具有项目和针对其的单元测试的解决方案，以便我们可以展示
    Actions 的工作原理，而[*第 10 章*](B18370_10.xhtml#_idTextAnchor245)就有这样的解决方案。
- en: Creating a sample project in a GitHub repo
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 GitHub 存储库中创建一个示例项目
- en: To follow along, you will need to have a GitHub account with a GitHub repository
    hosting a .NET project. If you don’t have one, then you can create a free GitHub
    account.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随操作，你需要有一个拥有 GitHub 存储库的 GitHub 账户，该存储库托管着一个 .NET 项目。如果你没有，那么你可以创建一个免费的 GitHub
    账户。
- en: 'You will need the code of [*Chapter 10*](B18370_10.xhtml#_idTextAnchor245)
    in your repository, so the fastest way to do that is to go on this book’s GitHub
    page and hit **Fork** | **Create a new fork**:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在你的存储库中拥有[*第 10 章*](B18370_10.xhtml#_idTextAnchor245)的代码，所以最快的方法是访问这本书的 GitHub
    页面并点击**Fork** | **创建新的分支**：
- en: '![Figure 11.3 – Create a new fork ](img/Figure_11.3_B18370.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 创建新的分支](img/Figure_11.3_B18370.jpg)'
- en: Figure 11.3 – Create a new fork
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 创建新的分支
- en: 'Or go to the repository URL and add `/fork` to the end, like this: [https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/fork](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/fork).
    Then hit **Create fork**:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，访问存储库 URL 并在末尾添加 `/fork`，如下所示：[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/fork](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/fork)。然后点击**创建分支**：
- en: '![Figure 11.4 – Filling in the form and hitting Create fork ](img/Figure_11.4_B18370.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – 填写表单并点击创建分支](img/Figure_11.4_B18370.jpg)'
- en: Figure 11.4 – Filling in the form and hitting Create fork
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 填写表单并点击创建分支
- en: The fork will copy the content of a repository into a newly created repository
    that you own so you can play with the code without affecting the original repository.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 分支会将存储库的内容复制到一个新创建的属于你的存储库中，这样你就可以在不影响原始存储库的情况下玩弄代码。
- en: 'While we’ve copied all the code, we are only interested in this earlier chapter
    ([*Chapter 10*](B18370_10.xhtml#_idTextAnchor245)) in the solution, located in
    the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经复制了所有代码，但我们只对解决方案中较早的章节 ([*第 10 章*](B18370_10.xhtml#_idTextAnchor245))
    感兴趣，位于以下位置：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that you have the same code, we can create the GitHub Actions CI for this
    project.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了相同的代码，我们可以为这个项目创建 GitHub Actions CI。
- en: Creating a workflow
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建工作流程
- en: First, to write any configuration for GitHub Actions, you will have to be familiar
    with YAML. YAML is a file format alternative to JSON that is geared for readability
    by humans. You will see examples of YAML as we go along.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要为 GitHub Actions 编写任何配置，您必须熟悉 YAML。YAML 是一种文件格式，是 JSON 的替代品，旨在提高人类可读性。随着我们的进行，您将看到
    YAML 的示例。
- en: 'Let’s create a workflow for the [*Chapter 10*](B18370_10.xhtml#_idTextAnchor245)
    project using the GitHub Actions wizard. From your GitHub repository, select **Actions**
    | **New workflow**:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GitHub Actions 向导为 [*第 10 章*](B18370_10.xhtml#_idTextAnchor245) 项目创建工作流程。从您的
    GitHub 仓库中选择 **操作** | **新建工作流程**：
- en: '![Figure 11.5 – Creating a new workflow ](img/Figure_11.5_B18370.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – 创建新的工作流程](img/Figure_11.5_B18370.jpg)'
- en: Figure 11.5 – Creating a new workflow
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 创建新的工作流程
- en: 'GitHub Actions comes back with a list of suggestions based on your repository
    content:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 根据您的仓库内容返回一个建议列表：
- en: '![Figure 11.6 – Suggestion list for a GitHub Actions workflow template ](img/Figure_11.6_B18370.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6 – GitHub Actions 工作流程模板的建议列表](img/Figure_11.6_B18370.jpg)'
- en: Figure 11.6 – Suggestion list for a GitHub Actions workflow template
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – GitHub Actions 工作流程模板的建议列表
- en: 'Our code is .NET Core, so the first suggestion is suitable; let’s hit **Configure**.
    We will get this page:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码是 .NET Core，因此第一个建议是合适的；让我们点击 **配置**。我们将获得以下页面：
- en: '![Figure 11.7 – Creating a workflow ](img/Figure_11.7_B18370.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7 – 创建工作流程](img/Figure_11.7_B18370.jpg)'
- en: Figure 11.7 – Creating a workflow
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – 创建工作流程
- en: 'Note that GitHub has already suggested a file location for your workflow configuration:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，GitHub 已经为您的工作流程配置建议了一个文件位置：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'GitHub Actions lives in the `workflows` directory. It also suggested the following
    YAML code for a start:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 位于 `workflows` 目录中。它还建议以下 YAML 代码作为开始：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This workflow is called `.NET` and will be triggered when someone pushes code
    into the main branch or raises a `pull` request to the main branch.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此工作流程称为 `.NET`，当有人向主分支推送代码或向主分支提出 `pull` 请求时将触发。
- en: The CI system uses the latest version of Ubuntu Linux available at GitHub Actions,
    which at the time of writing is Ubuntu 20.04\. The OS will be hosting the build
    while various actions are applied to it. Linux is usually chosen by default because
    it is more efficient to run and cheaper than Windows, and obviously supports .NET
    Core.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: CI 系统使用 GitHub Actions 可用的最新版本的 Ubuntu Linux，撰写本文时是 Ubuntu 20.04。操作系统将在应用各种操作时托管构建。Linux
    通常默认选择，因为它比 Windows 更高效且成本更低，并且显然支持 .NET Core。
- en: 'Then the execution of the steps starts with the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后步骤的执行从以下内容开始：
- en: '`actions/checkout@v3`: This action checks out your repository, so your workflow
    can access it. This is requesting version 3 of this action.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`actions/checkout@v3`：此操作检出您的仓库，以便您的流程可以访问它。这是请求此操作的版本 3。'
- en: '`actions/setup-dotnet@v2`: Fetches .NET SDK using version 2 of this library
    and specifies .NET Core 6 as the .NET version. This allows us to use .NET CLI
    after.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`actions/setup-dotnet@v2`：使用此库的版本 2 获取 .NET SDK，并指定 .NET Core 6 作为 .NET 版本。这允许我们在之后使用
    .NET CLI。'
- en: '`dotnet restore`: This is a standard .NET **command-line interface** (**CLI**)
    command to restore the NuGet packages.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dotnet restore`：这是一个标准的 .NET **命令行界面**（**CLI**）命令，用于还原 NuGet 包。'
- en: '`dotnet build`: Compiles the solution.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dotnet build`：编译解决方案。'
- en: '`dotnet test`: Executes all the test projects in the solution.'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dotnet test`：执行解决方案中的所有测试项目。'
- en: '*Steps 1* and *2* prepare your workspace on the host OS to be able to execute
    the `.NET CLI` command in the same way you would execute it on your local machine.
    As you’ve already figured out, the whole text uses YAML syntax.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 1* 和 *步骤 2* 准备主机操作系统上的工作空间，以便能够以与在本地机器上执行相同的方式执行 `.NET CLI` 命令。如您所发现的，整个文本都使用了
    YAML 语法。'
- en: 'You can go ahead and push the **Start commit** button:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以继续并点击 **开始提交** 按钮：
- en: '![Figure 11.8 – Start commit ](img/Figure_11.8_B18370.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.8 – 开始提交](img/Figure_11.8_B18370.jpg)'
- en: Figure 11.8 – Start commit
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 – 开始提交
- en: 'After this, click on the **Actions** tab to see how GitHub Actions is going
    to execute these commands:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，点击 **操作** 选项卡以查看 GitHub Actions 将如何执行这些命令：
- en: '![Figure 11.9 – Failed build ](img/Figure_11.9_B18370.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图11.9 – 失败的构建](img/Figure_11.9_B18370.jpg)'
- en: Figure 11.9 – Failed build
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 – 失败的构建
- en: 'As you’ve noticed with the red sign, the build has failed. You could click
    on the failed build to know more:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所注意到的，红色标志表明构建已失败。您可以点击失败的构建以获取更多信息：
- en: '![Figure 11.10 – Description of build failure ](img/Figure_11.10_B18370.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图11.10 – 构建失败描述](img/Figure_11.10_B18370.jpg)'
- en: Figure 11.10 – Description of build failure
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 – 构建失败描述
- en: 'You can see why this failed: it was unable to find the solution file to restore
    the dependencies. This is an expected error as our solution file for [*Chapter
    10*](B18370_10.xhtml#_idTextAnchor245) lives in the `/ch10/UqsAppointmentBooking`
    directory and not on `/` (the root), so we need to modify the YAML file to reflect
    this.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到为什么这失败了：它无法找到解决方案文件以恢复依赖项。这是一个预期的错误，因为我们的[*第10章*](B18370_10.xhtml#_idTextAnchor245)解决方案文件位于`/ch10/UqsAppointmentBooking`目录中，而不是在`/`（根目录），因此我们需要修改YAML文件以反映这一点。
- en: 'Pull the latest from source control, and you will notice that you have a new
    directory called `workflows` (`/.github/workflows`) and inside this directory,
    you will find the file that we have just created: `dotnet.yml`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码控制中拉取最新版本，您将注意到出现了一个名为`workflows`的新目录（`/.github/workflows`），在这个目录中，您可以找到我们刚刚创建的文件：`dotnet.yml`。
- en: 'You can edit this YAML file using any plain text editor. I use **Visual Studio
    Code** for this. We need to edit this file to instruct Actions where to find the
    solution file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用任何纯文本编辑器编辑此YAML文件。我使用**Visual Studio Code**进行编辑。我们需要编辑此文件以指示Actions在哪里找到解决方案文件：
- en: '[PRE3]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'I have modified the preceding YAML to include the location of the solution
    file. If you push this file to GitHub, this will trigger a build. You can see
    the results in the **Actions** tab:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经修改了前面的YAML文件以包含解决方案文件的位置。如果您将此文件推送到GitHub，这将触发构建。您可以在**操作**选项卡中查看结果：
- en: '![Figure 11.11 – Build pass ](img/Figure_11.11_B18370.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图11.11 – 构建通过](img/Figure_11.11_B18370.jpg)'
- en: Figure 11.11 – Build pass
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 – 构建通过
- en: The passing build means that all the steps that we specified in our YAML file
    have passed. You can click the passed build to look at how every step is executed
    and to ensure that your steps passed accurately and not by coincidence.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过的构建意味着我们在YAML文件中指定的所有步骤都已通过。您可以点击通过的构建来查看每个步骤的执行情况，并确保您的步骤准确通过，而不是偶然通过。
- en: We have created our CI system on GitHub Actions for our project. Now, every
    time a team member modifies the code, the CI workflow will kick in.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在GitHub Actions上为我们的项目创建了一个CI系统。现在，每当团队成员修改代码时，CI工作流程就会启动。
- en: Let’s focus a bit more on the test part.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更关注一下测试部分。
- en: CI and testing
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CI和测试
- en: 'The last line in the YAML steps is meant to trigger all available tests in
    the solution:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: YAML步骤中的最后一行是为了触发解决方案中所有可用的测试：
- en: '[PRE4]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This targets all the tests in your solution, which might be a combination of
    unit tests, Sintegration tests, integration tests, and system tests. Executing
    all the tests that you have might not be ideal based on what your project does.
    This will delay the feedback of the recent push and block other team members from
    validating that the build is safe to use.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将针对您解决方案中的所有测试，这可能是一系列单元测试、集成测试、集成测试和系统测试的组合。根据您的项目内容，执行所有测试可能并不理想。这将延迟最近提交的反馈，并阻止其他团队成员验证构建是否安全使用。
- en: 'So, you might want to restrict your workflow to unit tests only. You can modify
    the run command to the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可能希望将工作流程限制为仅单元测试。您可以修改运行命令如下：
- en: '[PRE5]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will target all tests with `Tests.Unit` in their namespace. So, you don’t
    execute all tests and you get fast feedback.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将针对所有在其命名空间中包含`Tests.Unit`的测试。因此，您不必执行所有测试，并且可以快速获得反馈。
- en: For other tests, you can write another YAML file that contains a new workflow
    and schedule it to run at a different event, such as multiple times per day.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他测试，您可以编写另一个包含新工作流程的YAML文件，并将其安排在不同的事件上运行，例如每天多次。
- en: Let’s see what happens when a test fails.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当测试失败时会发生什么。
- en: Simulating failed tests
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟失败的测试
- en: 'Let’s say that a colleague forgot to run the unit tests before pushing to source
    control, heaven forbid. We can simulate this by changing the line from [*Chapter
    10*](B18370_10.xhtml#_idTextAnchor245)*’s* `SlotService` from `||` to `&&` and
    pushing the code to source control:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一位同事在推送到源代码控制之前忘记运行单元测试，天哪。我们可以通过将[*第10章*](B18370_10.xhtml#_idTextAnchor245)*的*
    `SlotService` 从 `||` 改为 `&&` 并将代码推送到源代码控制来模拟这种情况：
- en: '![Figure 11.12 – Breaking the logic in the code to trigger failed tests ](img/Figure_11.12_B18370.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.12 – 在代码中打破逻辑以触发失败的测试](img/Figure_11.12_B18370.jpg)'
- en: Figure 11.12 – Breaking the logic in the code to trigger failed tests
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 – 在代码中打破逻辑以触发失败的测试
- en: 'This change will fail the existing unit tests in the solution, and it is usually
    trapped before pushing to source control, but if pushed, the CI system will report
    the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改将使解决方案中的现有单元测试失败，并且通常在推送到源控制之前被捕获，但如果推送，CI 系统将报告以下内容：
- en: '![Figure 11.13 – Failed tests in source control ](img/Figure_11.13_B18370.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.13 – 源控制中的失败测试](img/Figure_11.13_B18370.jpg)'
- en: Figure 11.13 – Failed tests in source control
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13 – 源控制中的失败测试
- en: 'The previous screen will show multiple failing points and if you scroll down,
    it will show you more of a description of the failed test, what was expected,
    and what was produced instead:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 上一屏将显示多个失败点，如果您向下滚动，它将显示更多关于失败的测试的描述，包括预期的结果和实际产生的结果：
- en: '![Figure 11.14 – Failed tests description ](img/Figure_11.14_B18370.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.14 – 失败测试描述](img/Figure_11.14_B18370.jpg)'
- en: Figure 11.14 – Failed tests description
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14 – 失败测试描述
- en: You can conclude what went wrong by reading the description. Obviously, we know
    what went wrong here because we broke the code on purpose. In other situations,
    we could understand what went wrong from the description of the error on GitHub
    Actions or we should be able to run the unit tests again on our local machine
    and try to figure out the situation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过阅读描述来得出什么出了问题。显然，我们知道这里出了什么问题，因为我们故意破坏了代码。在其他情况下，我们可以从 GitHub Actions 上的错误描述中了解出了什么问题，或者我们应该能够在本地机器上再次运行单元测试，并试图找出情况。
- en: You’ve seen an implementation that uses a workflow. Let’s next understand the
    concept behind it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了一个使用工作流程的实现。接下来，让我们了解其背后的概念。
- en: Understanding workflows
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解工作流程
- en: 'The module in GitHub Actions is a workflow and a workflow looks like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 中的模块是一个工作流程，而工作流程看起来是这样的：
- en: '![Figure 11.15 – Workflows ](img/Figure_11.15_B18370.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.15 – 工作流程](img/Figure_11.15_B18370.jpg)'
- en: Figure 11.15 – Workflows
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.15 – 工作流程
- en: A workflow lives in a YAML file in the `/.github/workflows` directory in your
    repository. Each workflow will run when triggered by an event(s) in your repository,
    or they can be triggered manually or at a defined schedule. In the previous example,
    the events that would trigger the workflow are pushing into the main branch and
    raising pull requests to `main`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程位于您存储库的 `/.github/workflows` 目录中的 YAML 文件中。每个工作流程将在您的存储库中由事件（s）触发时运行，或者它们可以被手动触发或按定义的时间表触发。在先前的例子中，将触发工作流程的事件是向主分支推送和向
    `main` 提交拉取请求。
- en: I hope this section did a good job of introducing you to GitHub Actions. Of
    course, there are more advanced options such as `matrix` and other features, but
    *Rome wasn’t built in a day*. You can start with the basics and progress into
    an expert quickly to gain fine control within your release pipeline.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这一节很好地介绍了您对 GitHub Actions 的了解。当然，还有更多高级选项，如 `matrix` 和其他功能，但*罗马不是一天建成的*。您可以从基础知识开始，快速进步到专家，以便在您的发布管道中获得精细的控制。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: A CI system is a must in today’s software engineering process and a continuation
    of the effort that was put into TDD.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: CI 系统是当今软件工程流程中必不可少的部分，也是对 TDD 所做努力的延续。
- en: This chapter introduced GitHub Actions as a good example of a CI system and
    used the code of [*Chapter 10*](B18370_10.xhtml#_idTextAnchor245) as a realistic
    example. By completing this chapter, I trust you should be able to add CI configuration
    to your arsenal of tools.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 GitHub Actions 作为 CI 系统的一个好例子，并使用了 [*第 10 章*](B18370_10.xhtml#_idTextAnchor245)
    的代码作为现实世界的例子。通过完成本章，我相信您应该能够将 CI 配置添加到您的工具箱中。
- en: In the next chapter, we will see how to consider adding tests to a brownfield
    project, as we don’t always have the luxury of starting a greenfield project all
    the time.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何考虑将测试添加到现有项目中，因为我们并不总是有从头开始绿色项目的奢侈。
- en: Further reading
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics discussed in the chapter, you can refer to the
    following links:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章讨论的主题，您可以参考以下链接：
- en: '*YAML files*: [https://yaml.org/](https://yaml.org/)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*YAML 文件*：[https://yaml.org/](https://yaml.org/)'
- en: '*GitHub Actions workflows*: [https://docs.github.com/en/actions/using-workflows/about-workflows](https://docs.github.com/en/actions/using-workflows/about-workflows%0D)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GitHub Actions 工作流程*：[https://docs.github.com/en/actions/using-workflows/about-workflows](https://docs.github.com/en/actions/using-workflows/about-workflows%0D)'
- en: '*Continuous Integration* by Martin Fowler: [https://martinfowler.com/articles/continuousIntegration.xhtml](https://martinfowler.com/articles/continuousIntegration.xhtml)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*持续集成* by Martin Fowler: [https://martinfowler.com/articles/continuousIntegration.xhtml](https://martinfowler.com/articles/continuousIntegration.xhtml)'
