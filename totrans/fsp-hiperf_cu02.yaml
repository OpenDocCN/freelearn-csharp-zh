- en: Chapter 2. Performance Measurement
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章。性能测量
- en: Performance measurement is often subject to many debates, but we should approach
    the ways of solving performance problems as straightforwardly as possible while
    maintaining objective processes. The results must be as objective as they can.
    To correctly define that a performance optimization is needed or not, we must
    be able to measure the running code objectively. To ensure the objectiveness of
    the performance measurement, the result must be visible as quantitative (in numbers)
    and qualitative by analyzing how the code behaves when it runs, how fast it runs,
    and how big the code is in memory.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测量经常引起许多争议，但我们应该尽可能直接地解决性能问题，同时保持客观的过程。结果必须尽可能客观。为了正确定义是否需要性能优化，我们必须能够客观地衡量运行代码。为了确保性能测量的客观性，结果必须通过分析代码运行时的行为、运行速度以及代码在内存中的大小来以定量（数字）和定性（质量）的方式可见。
- en: As a rule of thumb, it is easier to analyze quantitatively as data can be seen
    and compared more directly than when analyzed qualitatively. Understanding how
    to measure and how to interpret the measurement result can be used as a foundation
    for deducing the cause of any performance bottlenecks and can be further used
    in combination with qualitative analytics, such as deciding the best language
    construct and choosing the best strategy when dealing with concurrencies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，定量分析比定性分析更容易，因为数据可以直接看到并比较，而定性分析则不然。了解如何衡量以及如何解释测量结果可以作为推断任何性能瓶颈原因的基础，并且可以进一步与定性分析相结合，例如在处理并发时决定最佳语言结构和选择最佳策略。
- en: There are many ways to measure performance quantitatively, and we can use the
    existing tools in Visual Studio and in the .NET SDK/runtime. Understanding data
    qualitatively means that we have to understand the nature of the running code
    of F#, from the way it compiles to the way the result of the compilation works,
    which we can use to then reason the way the code runs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 定量衡量性能有许多方法，我们可以使用 Visual Studio 和 .NET SDK/runtime 中的现有工具。从定性上理解数据意味着我们必须理解
    F# 运行代码的性质，从它编译的方式到编译结果的运行方式，我们可以利用这些信息来推理代码的运行方式。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A basic understanding of the .NET SDK tool is recommended (including how to
    install it with Visual Studio) although this chapter will also describe the tools
    inside Visual Studio since Visual Studio 2015\. Please ensure that the installation
    of .NET and Visual Studio is correct to ensure that the journey to measuring performance
    described in this chapter is a smooth one.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 建议对 .NET SDK 工具有一个基本了解（包括如何使用 Visual Studio 安装它），尽管本章也将描述 Visual Studio 2015
    及以后的工具。请确保 .NET 和 Visual Studio 的安装正确，以确保本章中描述的性能测量之旅顺利。
- en: 'This chapter will cover the introduction to performance measurement, tooling,
    and the approaches to quantitative measurement with the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖性能测量的介绍、工具以及以下主题的定量测量方法：
- en: Introduction to the nature of F# code compilation, including IL assembly generated
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 代码编译性质介绍，包括生成的 IL 程序集
- en: Using CLR Profiler 4.5
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CLR Profiler 4.5
- en: Ways to measure F# code performance using tools, libraries including timers,
    API in .NET, and Visual Studio's unit test to measure performance
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工具、库（包括计时器、.NET API 和 Visual Studio 的单元测试）来衡量 F# 代码性能的方法
- en: Collective time data gathering in unit tests
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试中的集体时间数据收集
- en: Introduction to the nature of F# code compilation
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: F# 代码编译性质介绍
- en: Before we measure .NET, we need to understand the nature of F# code and the
    nature of compiling the F# code. Of course, we can just analyze and look at the
    source code. We can also try to search for any patterns of non-performing code
    of known bottlenecks, which will be explained in [Chapter 3](fsp-hiperf_cu03.html#aid-NQU22
    "Chapter 3. Optimizing Data Structures"),*Optimizing Data Structures* and [Chapter
    7](fsp-hiperf_cu07.html#aid-1ENBI1 "Chapter 7. Language Features and Constructs
    Optimization"), *Language Features and Constructs Optimization*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们衡量 .NET 之前，我们需要了解 F# 代码的性质以及 F# 代码编译的性质。当然，我们可以只是分析和查看源代码。我们还可以尝试寻找已知瓶颈的非性能代码的任何模式，这些模式将在[第
    3 章](fsp-hiperf_cu03.html#aid-NQU22 "第 3 章。优化数据结构")*优化数据结构*和[第 7 章](fsp-hiperf_cu07.html#aid-1ENBI1
    "第 7 章。语言特性和结构优化")*语言特性和结构优化*中解释。
- en: General overview of F# compiler processes and results
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F# 编译器过程和结果的概述
- en: All of the code in F# is compiled into byte codes of the IL assembly (as it's
    also an assembly language) either by the F# compiler or by using F# in interactive
    mode (by using FSI). This IL is then run in either **Debug** mode as Just In Time
    (JIT) code is further optimized by compiling it in **Release** mode. Running it
    in Release mode will yield compiled code to be optimized for .NET native by the
    Ahead Of Time (AOT) method.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: F# 中的所有代码都由 F# 编译器编译成 IL 程序集的字节码（因为它也是一种汇编语言），或者在交互模式下使用 F#（通过使用 FSI）。然后，这个
    IL 以 **调试** 模式作为即时（JIT）代码运行，进一步通过在 **发布** 模式下编译进行优化。在发布模式下运行将产生经过优化的编译代码，这些代码将通过提前编译（AOT）方法为
    .NET 本地化进行优化。
- en: 'For more information about .NET native, here is the official explanation in
    the MSDN Library:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 .NET 本地的更多信息，请参阅 MSDN 库中的官方解释：
- en: '[https://msdn.microsoft.com/en-us/library/dn584397(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/dn584397(v=vs.110).aspx)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/dn584397(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/dn584397(v=vs.110).aspx)'
- en: The IL is guaranteed to work well with other ILs as it has to conform to IL
    compliance before being enabled to run on top of .NET runtime. Therefore, running
    codes written in F# on .NET is essentially the same as running C#/VB codes on
    .NET. Both of them are coded in .NET IL. Therefore, any programming language compiler
    that runs on top of .NET has to support compiling into (sometimes called generating)
    .NET IL.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: IL 确保与其他 IL 兼容良好，因为它在能够在 .NET 运行时之上运行之前必须符合 IL 兼容性。因此，在 .NET 上运行 F# 编写的代码本质上与在
    .NET 上运行 C#/VB 代码相同。它们都使用 .NET IL 编码。因此，任何在 .NET 上运行的编程语言编译器都必须支持编译成（有时称为生成）.NET
    IL。
- en: The IL is executed on top of .NET runtime. The .NET runtime itself is one of
    the implementations of **Common Language Runtime** (**CLR**). This CLR defines
    the environment to run any IL assembly, and it also provides isolation and virtualization
    as well. This concept is known as a *managed environment*. Although it's not tightly
    tied with an underlying operating system (OS), it can provide an interop service
    with the underlying OS. In .NET runtime, the call to the Windows API is provided
    as a Platform Invoke or simply called P/Invoke.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: IL 在 .NET 运行时之上执行。.NET 运行时本身是 **公共语言运行时**（**CLR**）的众多实现之一。这个 CLR 定义了运行任何 IL
    程序集的环境，并且还提供了隔离和虚拟化功能。这个概念被称为 *托管环境*。尽管它与底层操作系统（OS）的绑定不是非常紧密，但它可以提供与底层操作系统的互操作服务。在
    .NET 运行时中，对 Windows API 的调用是通过平台调用（Platform Invoke，简称 P/Invoke）提供的。
- en: 'This is the latest official description of .NET CLR on the MSDN Library: [https://msdn.microsoft.com/en-us/library/8bs2ecf4(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/8bs2ecf4(v=vs.110).aspx).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 MSDN 库上关于 .NET CLR 的最新官方描述：[https://msdn.microsoft.com/en-us/library/8bs2ecf4(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/8bs2ecf4(v=vs.110).aspx)。
- en: The .NET IL (Intermediate Language) is basically a .NET specific assembly that
    is part of the **Common Language Infrastructure** (**CLI**) implementation standard.
    The CLI defines rules, foundations, processes, and IL instruction sets (including
    the byte codes). This CLI serves as an infrastructure for all languages on top
    of .NET runtime (or other CLR compliants such as Mono). Microsoft had submitted
    an initial version of the CLI standard in the beginning of 2001, and the first
    edition of the CLI standard was released on December 2001\. The CLI standard is
    always revised and synchronized with the release of .NET runtime rather than with
    the framework version. For example, the latest edition of CLI is now sixth edition
    and it conforms with .NET 4.0 CLR.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: .NET IL（中间语言）基本上是 .NET 特定的汇编语言，它是 **公共语言基础设施**（**CLI**）实现标准的一部分。CLI 定义了规则、基础、流程和
    IL 指令集（包括字节码）。这个 CLI 为所有基于 .NET 运行时（或其他 CLR 兼容的，如 Mono）的语言提供了一个基础设施。微软在 2001 年初提交了
    CLI 标准的初始版本，CLI 标准的第一版于 2001 年 12 月发布。CLI 标准总是与 .NET 运行时的发布同步修订，而不是与框架版本同步。例如，CLI
    的最新版本现在是第六版，它与 .NET 4.0 CLR 兼容。
- en: 'This is the official source of information about the IL and CLI standards in
    ECMA:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于 ECMA 中 IL 和 CLI 标准的官方信息来源：
- en: '[http://www.ecma-international.org/publications/standards/Ecma-335.htm](http://www.ecma-international.org/publications/standards/Ecma-335.htm)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.ecma-international.org/publications/standards/Ecma-335.htm](http://www.ecma-international.org/publications/standards/Ecma-335.htm)'
- en: The CLI standard is also implemented in Mono, not just in .NET CLR. The .NET
    CLR itself defines the corresponding related version of the .NET Framework, and
    as there are different versions of .NET CLR and the .NET Framework, this is often
    overlooked.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: CLI标准不仅在.NET CLR中实现，也在Mono中实现。.NET CLR本身定义了相应的.NET Framework版本，由于.NET CLR和.NET
    Framework有不同的版本，这一点往往被忽视。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The releases of .NET Framework versions are not the same as the releases of
    .NET runtime. For example, .NET Framework 3.5 (often called .NET 3.5) uses the
    runtime of .NET 2.0 runtime, whereas .NET 4.5 and .NET 4.6 use .NET 4.0 runtime.
    We should pay attention to this if we really want to understand the underlying
    foundation of .NET runtime/CLR.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework版本的发布并不等同于.NET运行时的发布。例如，.NET Framework 3.5（通常称为.NET 3.5）使用.NET
    2.0运行时，而.NET 4.5和.NET 4.6使用.NET 4.0运行时。如果我们真的想理解.NET运行时/CLR的底层基础，我们应该注意这一点。
- en: Although most developers don't often care about IL, it may be useful to show
    you how the code is executed. This takes place at a very low level of the compiled
    code. It is easier to start from the source code before it's compiled, therefore
    it is recommended to start with the simple one rather than the code itself at
    a higher level.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数开发者并不经常关心IL，但展示代码是如何执行的可能会有用。这发生在编译代码的非常低级别。因此，从编译前的源代码开始更容易，因此建议从简单的代码而不是更高层次的代码开始。
- en: It is also a best practice to always start from high level thinking first and
    to then go deeper to the lower level, as in IL.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 总是从高层次思考开始，然后深入到底层，例如在IL中，这也是一种最佳实践。
- en: '![General overview of F# compiler processes and results](img/image00258.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![F#编译器过程和结果的概述](img/image00258.jpeg)'
- en: From the perspective of F# code, the highest level is the source code. The source
    code can be quickly checked for correctness by compiling it or by sending it to
    FSI. This is considered an important step as we can rely on the compiler when
    performing syntax and grammar checks. The language design of F# is more abstract
    than the source code, and it is used as our foundation for checking for correctness.
    This correctness checking is performed by the parser in the compiler. It is more
    abstract than the source code that has already been compiled successfully.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从F#代码的角度来看，最高层次是源代码。源代码可以通过编译或发送到FSI来快速检查其正确性。这是一个重要的步骤，因为我们可以在执行语法和语法检查时依赖编译器。F#的语言设计比源代码更抽象，它被用作我们检查正确性的基础。这种正确性检查是由编译器中的解析器执行的。它比已经成功编译的源代码更抽象。
- en: This is a common practice, and it is also understandable from a language design
    perspective; we cannot directly analyze it as it is not easy to apply optimization.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常见的做法，从语言设计角度来看也是可以理解的；我们无法直接分析它，因为它不容易应用优化。
- en: From the compiler side, the compiler interprets and compiles the code by steps
    in phases, from lexing to parsing the resultant compiled code as IL.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从编译器的角度来看，编译器通过阶段逐步解释和编译代码，从词法分析到将生成的编译代码解析为IL。
- en: 'In general, F# compiles the code in the following steps:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，F#编译代码的步骤如下：
- en: '![General overview of F# compiler processes and results](img/image00259.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![F#编译器过程和结果的概述](img/image00259.jpeg)'
- en: 'We will only focus on the behavior of the code as related in the phases from
    **Lexing** to **Type checking** and the result of the IL (related to the **IL
    Emit** phase). The **Code generation** phase heavily depends on the previous phases,
    and it will only produce abstract IL code before going to the next phase: the
    **IL Emit** phase.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只关注从**词法分析**到**类型检查**的阶段中代码的行为，以及IL的结果（与**IL生成**阶段相关）。**代码生成**阶段高度依赖于前面的阶段，它将在进入下一个阶段：**IL生成**阶段之前只产生抽象的IL代码。
- en: At the time of the current release of F# 4.0, the steps are focused on the phases
    of the F# 4.0 compiler. The compiler is open source, and although we could dive
    deep into the work of the compiler itself, a deeper understanding of all the elements
    of the F# language specifications are beyond the scope of this book. From the
    perspective of performance optimization, we shall focus only on the code constructs,
    IL emitted, and instrumentations. We are not going to touch any further on the
    internal detail of how the F# compiler works.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 4.0 当前版本发布时，步骤集中在 F# 4.0 编译器的阶段。编译器是开源的，尽管我们可以深入探讨编译器本身的工作，但所有 F# 语言规范元素的深入理解超出了本书的范围。从性能优化的角度来看，我们将仅关注代码结构、生成的
    IL 和仪器。我们不会进一步触及 F# 编译器内部工作细节。
- en: If you want to know more, the previous steps are part of an open contribution
    process that is part of F# Foundation's missions because the F# Foundation always
    encourages open contributions to the F# compiler, language design standards, and
    other elements related to the F# Foundation architecture. This group is called
    the F# Core Engineering group.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多信息，前面的步骤是 F# 基金会使命的一部分的开源贡献过程，因为 F# 基金会始终鼓励对 F# 编译器、语言设计标准以及其他与 F# 基金会架构相关的元素进行开源贡献。这个小组被称为
    F# Core Engineering 小组。
- en: The homepage of F# Core Engineering is at [https://fsharp.github.io/](https://fsharp.github.io/).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: F# Core Engineering 的主页在 [https://fsharp.github.io/](https://fsharp.github.io/)。
- en: 'These compilation steps are described in detail in the F# Foundation''s F#
    Core Engineering group''s F# compiler guide section on their GitHub page:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些编译步骤在 F# 基金会的 F# Core Engineering 小组的 F# 编译器指南部分有详细描述，可在他们的 GitHub 页面上找到：
- en: '[https://fsharp.github.io/2015/09/29/fsharp-compiler-guide.html](https://fsharp.github.io/2015/09/29/fsharp-compiler-guide.html)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://fsharp.github.io/2015/09/29/fsharp-compiler-guide.html](https://fsharp.github.io/2015/09/29/fsharp-compiler-guide.html)'
- en: A quick overview of IL in F#
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F# 中的 IL 快速概述
- en: Let's start with the IL emitted by the F# compiler. Although the declared compatibility
    is as simple as it sounds, F# has a richer and more unique IL emitted than its
    C#/VB counterpart, but there are features in C#/VB that, currently, F# has no
    support for in the language yet. From .NET Core's perspective, the IL of F# and
    C#/VB are being developed at the same time.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 F# 编译器生成的 IL 开始。尽管声明的兼容性听起来很简单，但 F# 生成的 IL 比其 C#/VB 对应物更丰富、更独特，但 C#/VB
    中有一些特性，目前 F# 在语言中还没有支持。从 .NET Core 的角度来看，F# 和 C#/VB 的 IL 正在同时开发。
- en: 'This table summarizes the overall differences:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本表总结了总体差异：
- en: '| **Feature** | **F#** | **C#/VB** |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **特性** | **F#** | **C#/VB** |'
- en: '| Tailcall recursion (the `.tail` IL) | Yes. By default, F# will optimize simple
    recursion by translating it into a loop. | No. By default, tailcall recursion
    is not enabled in the Debug mode. But when enabled, IL emitted is not guaranteed
    to have tailcall IL. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 尾调用递归（`.tail` IL） | 是。默认情况下，F# 会通过将其转换为循环来优化简单的递归。 | 否。默认情况下，尾调用递归在调试模式下未启用。但启用时，生成的
    IL 不保证具有尾调用 IL。 |'
- en: '| Covariance/contravariance | Not available. Support is under review. | Yes.
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 可变性/逆变 | 不可用。支持正在审查中。 | 是。 |'
- en: '| Platform Invoke (P/Invoke) | Yes. | Yes. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 平台调用 (P/Invoke) | 是。 | 是。 |'
- en: '| COM objects | Partial. Because some COM objects can''t be used as dynamic,
    they must be declared as `Type.Missing`, especially when writing code that interops
    with Office COM. This is as expected because F# has no direct support for late
    bounds. | Yes. Supports COM object as late bound by marking it as dynamic typed.
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| COM 对象 | 部分支持。因为某些 COM 对象不能作为动态使用，它们必须声明为 `Type.Missing`，尤其是在编写与 Office COM
    交互的代码时。这是预期的，因为 F# 没有对后期绑定提供直接支持。 | 是。通过将其标记为动态类型支持 COM 对象作为后期绑定。 |'
- en: '| No PIA project and compile support | Not available. No definite plan in near
    future. | Yes. Not compatible with .NET Core by design because No PIA is only
    available on Windows. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 无 PIA 项目和编译支持 | 不可用。近期内没有明确的计划。 | 是。由于无 PIA 只在 Windows 上可用，因此按设计不兼容 .NET
    Core。 |'
- en: '| .NET Core IL (for .NET Core, CoreCLR, and CoreFX) for cross platform support
    | The .NET Core is not yet released, but the development is keeping up with both
    languages. | Same state as F#. The overall source code of .NET CoreCLR is mostly
    written in C#. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| .NET Core IL（用于 .NET Core、CoreCLR 和 CoreFX）以支持跨平台 | .NET Core 尚未发布，但其开发与两种语言保持同步。
    | 与 F# 相同的状态。.NET CoreCLR 的整体源代码主要用 C# 编写。 |'
- en: For more information about the progress of .NET CoreCLR, have a look at the
    official open source repository of .NET CoreCLR at [https://github.com/dotnet/coreclr](https://github.com/dotnet/coreclr).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有关.NET CoreCLR进度的更多信息，请查看.NET CoreCLR的官方开源存储库[https://github.com/dotnet/coreclr](https://github.com/dotnet/coreclr)。
- en: Now, let's dive into the IL and the generated byte codes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解IL和生成的字节码。
- en: IL tooling in .NET
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET中的IL工具
- en: Visual Studio comes with .NET SDK by default, and we can use the whole tooling
    available in .NET SDK in conjunction with the IDE experience inside Visual Studio.
    This includes everything from compiling to checking the IL generated.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio默认附带.NET SDK，我们可以使用.NET SDK中可用的所有工具，并结合Visual Studio内部的IDE体验。这包括从编译到检查生成的IL的一切。
- en: To quickly see the IL, we can use the existing tools in .NET that relate to
    the IL emitter and disassembler, ILASM, and ILDASM.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速查看中间语言（IL），我们可以使用.NET中与IL生成器和反汇编器相关的现有工具，即ILASM和ILDASM。
- en: '.NET itself, in particular .NET SDK, has many tools available for developers
    to perform development tasks, including ILDASM and ILASM. For more information
    about .NET tools in Visual Studio 2015, consult this MSDN Library:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: .NET本身，特别是.NET SDK，为开发者提供了许多工具，用于执行开发任务，包括ILDASM和ILASM。有关Visual Studio 2015中的.NET工具的更多信息，请参阅此MSDN库：
- en: '[https://msdn.microsoft.com/en-us/library/d9kh6s92(v=vs.110).aspx](https://github.com/dotnet/coreclr)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/d9kh6s92(v=vs.110).aspx](https://github.com/dotnet/coreclr)'
- en: These concepts of using ILASM to assemble IL assembly into machine code and
    ILDASM to disassemble are almost similar in terms of other assembler ecosystems.
    For example, the ILASM is conceptually equal to the Microsoft Macro Assembler
    compiler, known as MASM. It compiles Intel's processors (and its compatible) assembly
    language into byte codes that truly translate into code that the runtime can execute.
    ILASM takes the IL assembly and compiles it into a Windows PE (Portable Executable)
    file that can be in the form of EXE or DLL. ILDASM disassembles the byte code
    into the IL assembly code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ILASM将IL汇编编译成机器代码和ILDASM将字节码反汇编成IL汇编代码的概念在其他汇编器生态系统中几乎相似。例如，ILASM在概念上等同于微软宏汇编器编译器，即MASM。它将英特尔处理器的汇编语言编译成字节码，这些字节码真正转换成运行时可以执行的代码。ILASM将IL汇编编译成Windows
    PE（可移植可执行）文件，可以是EXE或DLL的形式。ILDASM将字节码反汇编成IL汇编代码。
- en: 'Unfortunately, there is no direct way to generate F# code into IL assembly
    code. In fact, the F# compiler compiles F# source codes into Window PE executable
    machine code as its final result. This is also true when compiling C#/VB source
    codes. We can see and check the generated assembly code by looking at the result
    of the disassembly first. We shall start with the easiest one: disassembly using
    ILDASM.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有直接将F#代码生成IL汇编代码的方法。实际上，F#编译器将F#源代码编译成Windows PE可执行机码作为其最终结果。当编译C#/VB源代码时也是如此。我们可以通过查看反汇编的结果来查看和检查生成的汇编代码。我们应从最简单的开始：使用ILDASM进行反汇编。
- en: Using ILDASM and ILASM to understand low-level IL assembly
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用ILDASM和ILASM理解低级IL汇编
- en: 'To illustrate the simplest sample to disassemble simple code, let''s create
    an F# console project in Visual Studio 2015 and name the project as `FSConsole01`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明反汇编简单代码的最简单示例，让我们在Visual Studio 2015中创建一个F#控制台项目，并将其命名为`FSConsole01`：
- en: '![Using ILDASM and ILASM to understand low-level IL assembly](img/image00260.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![使用ILDASM和ILASM理解低级IL汇编](img/image00260.jpeg)'
- en: 'A file will be opened in the Visual Studio editor, named `Program.fs`, which contains
    basic entry point of the F# console project. Replace the line 6 with this code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio编辑器将打开一个名为`Program.fs`的文件，它包含F#控制台项目的基本入口点。将第6行替换为以下代码：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then, build the project. We can directly build and run it by pressing *F5*,
    but the console will pop out and close instantly.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，构建项目。我们可以通过按*F5*直接构建和运行它，但控制台会立即弹出并关闭。
- en: 'The recommended way to build is to use the key combination of *Ctrl* + *F5*
    to instruct Visual Studio to run the code without debugging. This action will
    also pause after the code has finished running in the console:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 建议的构建方法是使用*Ctrl* + *F5*键组合来指示Visual Studio在不进行调试的情况下运行代码。此操作将在代码在控制台中运行完毕后暂停：
- en: '![Using ILDASM and ILASM to understand low-level IL assembly](img/image00261.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![使用ILDASM和ILASM理解低级IL汇编](img/image00261.jpeg)'
- en: Press any key or close the window.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 按任意键或关闭窗口。
- en: 'Let''s examine the IL by disassembling the executable using ILDASM. Search
    for Visual Studio''s **Developer Command Prompt for Visual Studio 2015** and select
    it:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用ILDASM反汇编可执行文件来检查IL。搜索Visual Studio的**Visual Studio 2015开发者命令提示符**并选择它：
- en: '![Using ILDASM and ILASM to understand low-level IL assembly](img/image00262.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![使用ILDASM和ILASM理解低级IL汇编](img/image00262.jpeg)'
- en: A window that shows the Command Prompt will appear. The window has a title bar
    of **Developer Command Prompt for VS 2015**. It is basically a Command Prompt
    (it is an instance of a Windows `CMD` Command Prompt) that has its environment
    variables set (including system's `PATH` environment variable).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 将会弹出一个显示命令提示符的窗口。窗口的标题栏为**Visual Studio 2015开发者命令提示符**。它基本上是一个命令提示符（它是Windows
    `CMD`命令提示符的一个实例），并且已经设置了环境变量（包括系统的`PATH`环境变量）。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'NOTE: **Developer Command Prompt for VS 2015** is not available in the Visual
    Studio 2015 Express Edition installation. It is available in the Visual Studio
    2015 Community Edition and above.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：**Visual Studio 2015开发者命令提示符**在Visual Studio 2015 Express Edition安装中不可用。它在Visual
    Studio 2015 Community Edition及以上版本中可用。
- en: 'For more information about this developer Command Prompt, consult the MSDN
    Library:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此开发者命令提示符的更多信息，请参阅MSDN库：
- en: '[https://msdn.microsoft.com/en-us/library/ms229859(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/ms229859(v=vs.110).aspx)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/ms229859(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/ms229859(v=vs.110).aspx)'
- en: 'In the command prompt, type `ILDASM` and then press *Enter*. An **ILDASM**
    window will show the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令提示符中输入`ILDASM`然后按*Enter*。一个**ILDASM**窗口将显示以下内容：
- en: '![Using ILDASM and ILASM to understand low-level IL assembly](img/image00263.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![使用ILDASM和ILASM理解低级IL汇编](img/image00263.jpeg)'
- en: 'To start disassembling `FSConsole01`, perform the following steps:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始反汇编`FSConsole01`，请执行以下步骤：
- en: From the main menu, open the **File** menu.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主菜单，打开**文件**菜单。
- en: Select **Open** and then go to the folder that stores `FSConsole01`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**打开**，然后转到存储`FSConsole01`的文件夹。
- en: Select the subfolder `bin`, the `Debug` subfolder.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择子文件夹`bin`，`Debug`子文件夹。
- en: Open `FSConsole01.exe`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`FSConsole01.exe`。
- en: 'Let''s resize a little bit so that now ILDASM will display the content of the
    EXE file as organized into metadata that contains IL:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微调整一下大小，这样ILDASM现在将显示组织成包含IL的元数据的EXE文件内容：
- en: '![Using ILDASM and ILASM to understand low-level IL assembly](img/image00264.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![使用ILDASM和ILASM理解低级IL汇编](img/image00264.jpeg)'
- en: 'The ILDASM of `FSConsole01.exe` has three nodes:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`FSConsole01.exe`的ILDASM有三个节点：'
- en: The **MANIFEST** node is a manifest of runtime information that contains the
    .NET runtime assembly it targets.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MANIFEST**节点是一个包含目标.NET运行时程序集的运行时信息清单。'
- en: '**<StartupCode$FSConsole01>** contains the necessary metadata of the `AssemblyInfo`,
    the main class of Program, and other assembly attributes.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<StartupCode$FSConsole01>**包含`AssemblyInfo`、Program的主类和其他程序集属性的必要元数据。'
- en: '**Program** contains the actual IL of the F# source code compiled into IL assembly,
    related to the `<EntryPoint>` attribute.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Program**包含编译成IL汇编的F#源代码的实际IL，与`<EntryPoint>`属性相关。'
- en: 'Now let''s expand the Program node and select the **main : int32(string[])**
    node:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '现在让我们展开Program节点并选择**main : int32(string[])**节点：'
- en: '![Using ILDASM and ILASM to understand low-level IL assembly](img/image00265.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![使用ILDASM和ILASM理解低级IL汇编](img/image00265.jpeg)'
- en: 'To further explore the source code, double-click the **main** node. ILDASM
    will display a new window that contains the IL assembly of `main`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步探索源代码，双击**main**节点。ILDASM将显示一个包含`main`的IL汇编的新窗口：
- en: '![Using ILDASM and ILASM to understand low-level IL assembly](img/image00266.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![使用ILDASM和ILASM理解低级IL汇编](img/image00266.jpeg)'
- en: 'Let''s look again at the source code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次查看源代码：
- en: '[PRE1]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we will dive into the translation of IL.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将深入到IL的翻译中。
- en: 'The `let main argv` function declaration is translated into the following IL:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`let main argv`函数声明被翻译成以下IL：'
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is crucial and it's quite similar to the main console of C#/VB as it's
    also generated as a method that uses the `public static` modifier. In F#, the
    `main` method has `int32` as its return value instead of `void` in C# (Sub in
    VB).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常重要，它与C#/VB的主控制台非常相似，因为它也是作为一个使用`public static`修饰符的方法生成的。在F#中，`main`方法的返回值类型为`int32`，而不是C#中的`void`（VB中的Sub）。
- en: The `EntryPoint` attribute is translated as `.entrypoint` combined with the
    instantiation of the `EntryPoint` attribute inside the method.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`EntryPoint`属性被翻译为`.entrypoint`，并结合方法内部`EntryPoint`属性的实例化。'
- en: The `"Hello F# world"` string is loaded into memory as indicated by the `ldstr`
    IL assembly command. Then, the next line prepares the call to F# `PrintfFormatLine`
    (as compiled from the translation of the abbreviated name of `printf`) by calling
    the `static` constructor of `Microsoft.FSharp.Core.PrintfFormat` and then calling
    the `PrintFormatLine`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`"Hello F# world"` 字符串通过 `ldstr` IL 汇编命令被加载到内存中。然后，下一行通过调用 `Microsoft.FSharp.Core.PrintfFormat`
    的 `static` 构造函数，并随后调用 `PrintFormatLine` 来准备对 F# `PrintfFormatLine`（从 `printf`
    的缩写名称翻译而来）的调用。'
- en: This is the behavior of any call to the static method, and it is related to
    .NET CLR, not the convention or the IL result from F#. When calling any static
    method for the first time, the static constructor of the class that has the static
    method (if this constructor is available) is always called first. It behaves the
    same as in C# and VB.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是任何对静态方法的调用行为，它与 .NET CLR 相关，而不是 F# 的约定或 IL 结果。当第一次调用任何静态方法时，具有该静态方法的类的 `static`
    构造函数（如果该构造函数可用）总是首先被调用。它的行为与 C# 和 VB 相同。
- en: 'Now let''s examine the IL emitted by the recursive function in F# even further.
    Let''s add the recursive factorial function. To make it more interesting, we are
    using pattern matching to match the conditions of the recursive calls. Add the
    following code before the main entry point:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进一步检查 F# 中递归函数生成的 IL。让我们添加递归阶乘函数。为了使其更有趣，我们使用模式匹配来匹配递归调用的条件。在主入口点之前添加以下代码：
- en: '[PRE3]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run ILDASM and open the compiled `FSConsole01` executable. Navigate to the
    `fact` node and then double-click the node. We will see that the IL is translated
    into a loop in the IL assembly:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 ILDASM 并打开编译后的 `FSConsole01` 可执行文件。导航到 `fact` 节点，然后双击该节点。我们会看到 IL 被转换成了 IL
    汇编中的循环：
- en: '![Using ILDASM and ILASM to understand low-level IL assembly](img/image00267.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![使用 ILDASM 和 ILASM 理解低级 IL 汇编](img/image00267.jpeg)'
- en: 'There are three branch instructions: `br.false` and two `br.s` instructions.
    These three correspond to the match branches in the code.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个分支指令：`br.false` 和两个 `br.s` 指令。这三个对应于代码中的匹配分支。
- en: In this sample recursive function of factorial, the recursive construct is optimized
    as a loop in the IL emitted. The usage of a loop also implies that the stack overflow
    will not happen as the code is not performing recursion; therefore, there is no
    need to store the function entry in the stack as with most recursive functions
    in other languages such as C# and VB. It is intrinsically faster and more efficient
    than using a stack frame to store the recursion returning point.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例的阶乘递归函数中，递归结构在 IL 生成的代码中被优化为循环。使用循环也意味着不会发生堆栈溢出，因为代码没有执行递归；因此，不需要像 C# 和
    VB 等其他语言中的大多数递归函数那样在堆栈中存储函数入口。它本质上比使用堆栈帧来存储递归返回点更快、更高效。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The choice of optimization from a recursive into a loop is what separates F#
    from C#/VB. It is faster to have a loop than to use recursion that requires stack
    frames because stack frame usage adds more overhead of pushing and popping values
    in stack manipulations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从递归到循环的优化选择是 F# 与 C#/VB 区别的关键。循环比需要堆栈帧的递归更快，因为堆栈帧的使用在堆栈操作中增加了更多的开销。
- en: A deeper discussion on recursive function and tail calls is available in [Chapter
    7](fsp-hiperf_cu07.html#aid-1ENBI1 "Chapter 7. Language Features and Constructs
    Optimization"), *Language Features and Constructs Optimization*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 关于递归函数和尾调用的更深入讨论，请参阅 [第 7 章](fsp-hiperf_cu07.html#aid-1ENBI1 "第 7 章。语言特性和结构优化")，*语言特性和结构优化*。
- en: For more information on IL assembly instructions, consult the ECMA 335 standard.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 IL 汇编指令的更多信息，请参考 ECMA 335 标准。
- en: We now have IL assemblies available to use. The output produced by ILDASM can
    be used to be the foundation of understanding IL deeper, but we need to be able
    to produce the whole IL assembly of the executable.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了可用的 IL 汇编。由 ILDASM 生成的输出可以用作更深入理解 IL 的基础，但我们需要能够生成可执行文件的全部 IL 汇编。
- en: Using the existing `FSConsole01`, we are going to transform the compiled EXE
    to a text file that contains the IL assembly.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现有的 `FSConsole01`，我们将把编译的 EXE 转换为包含 IL 汇编的文本文件。
- en: 'Open the **Developer Command Prompt for Visual Studio 2015** and change the
    folder to the `bindebug` subfolder of your `FSConsole01` project. Then, type the
    following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 **Visual Studio 2015 开发者命令提示符** 并将文件夹更改为 `FSConsole01` 项目的 `bindebug` 子文件夹。然后，输入以下内容：
- en: '[PRE4]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `/OUT` parameter means that we are not going to display ILDASM UI because
    we are going to dump the IL into a file to contain the IL assembly code as a result
    of the disassembler of ILDASM. It is a recommended best practice to name the extension
    of the file as *IL* because it is a source code of .NET IL assembly code, although
    .NET will not register IL as a filename extension on Windows.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`/OUT`参数意味着我们不会显示ILDASM UI，因为我们打算将IL转储到文件中，以包含ILDASM的反汇编结果。将文件的扩展名命名为*IL*是一个推荐的最佳实践，因为它是以.NET
    IL汇编代码为源代码，尽管.NET不会在Windows上注册IL作为文件名扩展。'
- en: 'We now have `FSConsole.IL`. Open the `FSConsole.IL` using Notepad:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`FSConsole.IL`。使用记事本打开`FSConsole.IL`：
- en: '![Using ILDASM and ILASM to understand low-level IL assembly](img/image00268.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![使用ILDASM和ILASM理解低级IL汇编](img/image00268.jpeg)'
- en: 'Press *Ctrl* + *F* and search for `Program` and then we see that the F# compiler
    emitted the class declaration of Program as `public abstract`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 按*Ctrl* + *F*并搜索`Program`，然后我们看到F#编译器将`Program`类的声明输出为`public abstract`：
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is also a form of optimization by the F# compiler because the `Program`
    class as the entrypoint *doesn''t have to be a concrete class*. This is different
    from C# as the default compile result is a concrete class. For example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是F#编译器进行优化的一种形式，因为作为入口点的`Program`类*不必是具体类*。这与C#不同，因为默认的编译结果是具体类。例如：
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However, we can modify the corresponding C#'s `Program` class to have a similar
    abstract class explicitly in the code before building and compiling it again.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以在构建和编译之前，将相应的C#的`Program`类修改为在代码中显式地有一个类似的抽象类。
- en: Let's directly modify the IL assembly code and compile it back to an executable
    using ILASM.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接修改IL汇编代码，并使用ILASM将其编译回可执行文件。
- en: 'Search for this line of code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索此行代码：
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Change the `Hello F# world` to `Hello world!` and then save the IL using a different
    name, for example, `FSConsole01a.IL`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Hello F# world`改为`Hello world!`，然后使用不同的名称保存IL，例如，`FSConsole01a.IL`。
- en: 'Then, go back to the developer''s Command Prompt and type this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，回到开发者的命令提示符，输入以下内容：
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, execute `FSConsole01a.exe` on the Command Prompt; it should now display
    `Hello world!`, as shown here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在命令提示符中执行`FSConsole01a.exe`；现在它应该显示`Hello world!`，如图所示：
- en: '![Using ILDASM and ILASM to understand low-level IL assembly](img/image00269.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![使用ILDASM和ILASM理解低级IL汇编](img/image00269.jpeg)'
- en: 'Now, we can have qualitative optimization based on IL! We also have learned
    this example of recursion as loop-one good example use case of IL analyzing. This
    IL use of a loop instead of recursion using a stack is also proof of optimization:
    F# is already one step ahead of other languages (especially non-functional languages)
    in terms of handling basic recursive functions.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以基于IL进行定性优化！我们还学习了递归作为循环的一个很好的IL分析用例。这种使用循环而不是使用堆栈的递归的IL使用也是优化的证明：F#在处理基本递归函数方面已经比其他语言（尤其是非函数式语言）领先一步。
- en: We have grabbed the basic understanding of the F# compiler and IL. Now that
    we understood the underlying IL assembly generated by F#, we can profile it using
    the CLR Profiler, a profiler tool from Microsoft.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对F#编译器和IL有了基本理解。现在，我们理解了F#生成的底层IL汇编，我们可以使用Microsoft的CLR分析器来分析它。
- en: Using CLR Profiler 4.5
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CLR分析器4.5
- en: CLR Profiler is a profiler tool used to profile any compiled PE of .NET. It
    is free and open source, although it is not available by default in the current
    installation of .NET and Visual Studio 2015.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: CLR分析器是一个用于分析任何.NET编译PE的分析器工具。它是免费和开源的，尽管它不是.NET和Visual Studio 2015当前安装的默认可用工具。
- en: 'A profiler is basically a helper tool to analyze the elements of a running
    program that relates to performances, such as:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器基本上是一个辅助工具，用于分析运行程序中与性能相关的元素，例如：
- en: Memory consumptions
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存消耗
- en: Execution time allocations in terms of classes and modules into smaller elements
    such as functions and subroutines
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行时间分配，将类和模块分配到更小的元素，如函数和子程序
- en: Examining garbage collections (if the platform has support for garbage collection)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查垃圾回收（如果平台支持垃圾回收）
- en: Based on the previous definitions, the CLR Profiler is simply a profiler to
    examine (or *to profile*) any application that runs on top of .NET CLR.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前的定义，CLR分析器只是一个用于检查（或*分析*）在.NET CLR之上运行的任何应用程序的分析器。
- en: There are profilers toolings for .NET, not just CLR Profiler, out there, unfortunately
    not all the toolings are free. Fortunately, CLR Profiler has complete features
    to profile .NET application, and it is also free and open source. We can also
    build our own profiler based on the existing CLR Profiler.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有 .NET 的分析工具，不仅仅是 CLR Profiler，但不幸的是，并非所有工具都是免费的。幸运的是，CLR Profiler 具有完整的特性来分析
    .NET 应用程序，并且它是免费和开源的。我们还可以基于现有的 CLR Profiler 构建自己的分析器。
- en: A quick overview of CLR Profiler
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CLR Profiler 的快速概述
- en: CLR Profiler has been developed since .NET 1.1, although it is not supported
    anymore. The latest CLR Profiler is available for .NET 4.5, and it can only be
    used effectively for profiling any .NET 4.0 CLR-based application, including .NET
    4.0 to .NET 4.6 applications. The next version of .NET may or may not be compatible.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: CLR Profiler 自 .NET 1.1 以来一直在开发，尽管它不再受支持。最新的 CLR Profiler 可用于 .NET 4.5，并且只能有效地用于分析任何基于
    .NET 4.0 CLR 的应用程序，包括 .NET 4.0 到 .NET 4.6 的应用程序。下一个版本的 .NET 可能或可能不兼容。
- en: 'CLR Profiler has been developed since .NET 1.1, and it is always released to
    match with the .NET runtime releases. For example, CLR Profiler version 2.0 supports
    .NET 2.0 runtime. This version 2.0 release supports .NET generics that were introduced
    in .NET 2.0 runtime. The version 3.5 supports .NET 2.0 SP1 runtime that was released
    with .NET Framework 3.5 and so do the next versions, as illustrated:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: CLR Profiler 自 .NET 1.1 以来一直在开发，并且始终与 .NET 运行时发布同步。例如，CLR Profiler 2.0 版本支持
    .NET 2.0 运行时。这个 2.0 版本发布支持在 .NET 2.0 运行时中引入的 .NET 泛型。3.5 版本支持与 .NET Framework
    3.5 一起发布的 .NET 2.0 SP1 运行时，后续版本也是如此，如图所示：
- en: '![A quick overview of CLR Profiler](img/image00270.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![CLR Profiler 的快速概述](img/image00270.jpeg)'
- en: There were some maintenance releases of CLR Profiler between the themed releases
    from version 2.0 to version 4 that were in sync with .NET runtime, but these maintenance
    releases were mostly bug fixes that addressed minor test cases involving profiling
    Platform interop with Win32 API and COM. After the release of CLR Profiler 4,
    the maintenance releases are not available, particularly, because the source code
    of CLR Profiler is also open sourced.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2.0 版本到 4.0 版本的主题发布之间，CLR Profiler 进行了一些维护发布，这些发布与 .NET 运行时同步，但这些维护发布主要是针对涉及与
    Win32 API 和 COM 进行平台互操作的小型测试用例的 bug 修复。CLR Profiler 4.0 发布后，维护发布不再可用，尤其是由于 CLR
    Profiler 的源代码也已开源。
- en: An initial version of CLR Profiler, until version 2.0, was developed within
    a closed-source model, and it was then opened as open source. The repository of
    the CLR Profiler was located at CodePlex until now.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: CLR Profiler 的初始版本，直到 2.0 版本，都是在闭源模式下开发的，然后才开源。CLR Profiler 的仓库一直位于 CodePlex。
- en: It was maintained originally by the CLR team, and was then lead by David Broman
    until now. The most interesting fact is that the CLR Profiler is written entirely
    in C++, using a mix of native Win32 C++ with managed C++. It can hook into the
    running code of the application to be profiled by first loading and examining
    the IL and then injecting some hooks as IL to monitor the execution.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 它最初由 CLR 团队维护，然后由 David Broman 领导至今。最有趣的事实是，CLR Profiler 完全用 C++ 编写，结合了本机 Win32
    C++ 和托管 C++。它可以通过首先加载和检查 IL 然后注入一些作为 IL 的钩子来监控要分析的程序的运行代码。
- en: 'To catch up with the development of CLR Profiler on CodePlex, have a look at
    this landing page:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 CLR Profiler 在 CodePlex 上的开发情况，请查看此着陆页：
- en: '[http://clrprofiler.codeplex.com/](http://clrprofiler.codeplex.com/)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://clrprofiler.codeplex.com/](http://clrprofiler.codeplex.com/)'
- en: David Broman, Microsoft's original developer of CLR Profiler, has a blog on
    MSDN as well. His blog is available at [https://blogs.msdn.microsoft.com/davbr/](https://blogs.msdn.microsoft.com/davbr/).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: David Broman，CLR Profiler 的原始开发者，在 MSDN 上也有一个博客。他的博客可在 [https://blogs.msdn.microsoft.com/davbr/](https://blogs.msdn.microsoft.com/davbr/)
    找到。
- en: A quick walkthrough of CLR Profiler in action
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CLR Profiler 的快速操作演示
- en: On the download page of CLR Profiler, choose binaries. Since we are going to
    use CLR Profiler to profile our running code, we are going to use the compiled
    CLR Profiler instead of building and compiling it from the CLR Profiler source
    code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CLR Profiler 的下载页面，选择二进制文件。由于我们打算使用 CLR Profiler 来分析我们的运行代码，我们将使用编译好的 CLR
    Profiler 而不是从 CLR Profiler 源代码构建和编译它。
- en: After we have downloaded the CLR Profiler 4.5 binaries as a ZIP file, unzip
    it to any folder. It's recommended not to use a deep folder with nested folders
    because it may not be searchable, unless we put the folder into `PATH` environment
    variable.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们下载 CLR Profiler 4.5 二进制文件作为 ZIP 文件后，将其解压缩到任何文件夹中。建议不要使用嵌套的深层文件夹，因为它可能无法搜索，除非我们将文件夹放入
    `PATH` 环境变量中。
- en: This CLR Profiler can be used to profile 32-bit and 64-bit CLR executables and
    CLR DLL. There are two binaries for the 32-bit and 64-bit versions, respectively.
    For the most common case and best practices, we should use the 32-bit CLR Profiler
    to profile 32-bit CLR executables and DLL.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此 CLR Profiler 可以用于分析 32 位和 64 位 CLR 可执行文件和 CLR DLL。分别有两个二进制文件用于 32 位和 64 位版本。对于最常见的情况和最佳实践，我们应该使用
    32 位 CLR Profiler 来分析 32 位 CLR 可执行文件和 DLL。
- en: 'Before we use CLR Profiler to profile our executable, these are some limitations
    and warnings about the known consequences of running CLR Profiler to mention:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用 CLR Profiler 分析我们的可执行文件之前，以下是一些关于运行 CLR Profiler 已知后果的限制和警告：
- en: CLR Profiler is an intrusive tool; seeing a 10 to 100x slowdown in the application
    being profiled is not unusual. Therefore, it is not the right tool to find out
    where time is spent-use other profilers for that.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CLR Profiler 是一个侵入式工具；在正在分析的应用程序中看到 10 到 100 倍的减速并不罕见。因此，它不是查找时间花费在何处的好工具——使用其他分析器来完成这项任务。
- en: Log files can be huge. By default, every allocation and every call is logged,
    which can consume gigabytes of disk space. However, allocation and call logging
    can be turned on and off selectively, either by the application or in the CLR
    Profiler UI.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志文件可能非常大。默认情况下，每个分配和每个调用都会被记录，这可能会消耗数 GB 的磁盘空间。然而，分配和调用记录可以选择性地打开或关闭，无论是通过应用程序还是通过
    CLR Profiler UI。
- en: CLR Profiler cannot *attach* to an application that is already running.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CLR Profiler 无法 *附加* 到已经运行的应用程序。
- en: CLR Profiler might get caught and be considered harmful by some antivirus programs
    such as Trend Micro, ESET, and even the older versions of Symantec and Kaspersky.
    These antiviruses might have treated CLR Profiler as harmful malware or security
    exploit software. This is truly a false alarm. CLR Profiler must be listed as
    *white list* for these antivirus programs. Also, update your antivirus detection
    data.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CLR Profiler 可能会被某些防病毒程序（如 Trend Micro、ESET 以及较旧的 Symantec 和 Kaspersky 版本）检测到，并被认为是有害的。这些防病毒程序可能将
    CLR Profiler 视为有害的恶意软件或安全漏洞软件。这实际上是一个误报。CLR Profiler 必须被列入这些防病毒程序的 *白名单*。此外，更新您的防病毒检测数据。
- en: Now, let's examine our current `FSConsole01` project. Open the solution that
    contains your `FSConsole01` project and build it. To ensure that Visual Studio
    will not interfere with CLR Profiler, close the solution and close Visual Studio.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查我们的当前 `FSConsole01` 项目。打开包含您的 `FSConsole01` 项目的解决方案并构建它。为了确保 Visual
    Studio 不会干扰 CLR Profiler，关闭解决方案并关闭 Visual Studio。
- en: 'Go to the folder that you downloaded and extract the CLR Profiler. You shall
    see two subfolders and one file: subfolders named `32`, `64`, and a Word document
    file named `CLRProfiler.doc`. The DOC file is actually a complete documentation
    of how to use CLR Profiler. Open the subfolder of `32` and then execute the `CLRProfiler.exe`
    file by opening or by double-clicking it.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 前往您下载的文件夹，并提取 CLR Profiler。您将看到两个子文件夹和一个文件：名为 `32`、`64` 的子文件夹和一个名为 `CLRProfiler.doc`
    的 Word 文档文件。DOC 文件实际上是关于如何使用 CLR Profiler 的完整文档。打开 `32` 子文件夹，然后通过打开或双击 `CLRProfiler.exe`
    文件来执行它。
- en: 'A Command Prompt and CLR Profiler UI is shown:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 显示了命令提示符和 CLR Profiler UI：
- en: '![A quick walkthrough of CLR Profiler in action](img/image00271.jpeg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![CLR Profiler 在行动中的快速浏览](img/image00271.jpeg)'
- en: 'Ignore the Command Prompt, but do not close it, as it will also close CLR Profiler.
    Before you start profiling, check the **Allocations** and **Calls** under the
    **Profile** frame:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略命令提示符，但不要关闭它，因为它也会关闭 CLR Profiler。在您开始分析之前，检查 **Profile** 选项卡下的 **Allocations**
    和 **Calls**：
- en: '![A quick walkthrough of CLR Profiler in action](img/image00272.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![CLR Profiler 在行动中的快速浏览](img/image00272.jpeg)'
- en: Also ensure that the checkbox of **Profiling active** is always checked.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 还要确保 **Profiling active** 复选框始终被勾选。
- en: 'This is the reason given in the CLR Profiler documentation as to why **Profiling
    active** is checked:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 CLR Profiler 文档中给出的原因，说明为什么 **Profiling active** 被勾选：
- en: '*The Profiling active check box lets you turn profiling on and off selectively.
    You can do that either to save time (for example during application startup),
    or to profile selectively. For example, if you wanted to see what happens in your
    Windows Forms application when a certain button gets clicked, you would clear
    this box, start your application, then check the box, click your button, and then
    clear the box again. Another usage would be to turn this off when starting to
    profile your ASP.NET application, load a specific page, and then turn it on to
    see what gets allocated in the steady state for that specific page.*'
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“正在分析”复选框允许你选择性地打开和关闭分析。你可以这样做以节省时间（例如在应用程序启动期间），或者进行选择性的分析。例如，如果你想查看当某个按钮被点击时你的
    Windows Forms 应用程序中发生了什么，你会清除这个框，启动你的应用程序，然后勾选这个框，点击你的按钮，然后再次清除这个框。另一种用法是在开始分析你的
    ASP.NET 应用程序时将其关闭，加载特定的页面，然后打开它以查看该特定页面在稳定状态下的分配情况。*'
- en: Our `FSConsole01` is a console application, and it is also a desktop application
    by nature although it is running as a console application. Therefore, we need
    to ensure that this checkbox of **Profiling active** is checked.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `FSConsole01` 是一个控制台应用程序，尽管它以控制台应用程序的形式运行，但本质上它也是一个桌面应用程序。因此，我们需要确保这个 **正在分析**
    的复选框被勾选。
- en: Click the **Start Desktop App...** button and open `FSConsole01.exe` in the
    `bindebug` folder.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **启动桌面应用程序...** 按钮，并在 `bindebug` 文件夹中打开 `FSConsole01.exe`。
- en: 'Then, CLR Profiler will show a UI that acts as container of profiling summary:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，CLR Profiler 将显示一个作为分析总结容器的 UI：
- en: '![A quick walkthrough of CLR Profiler in action](img/image00273.jpeg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![CLR Profiler 动作快速浏览](img/image00273.jpeg)'
- en: This summary is very important, as it is the starting point before starting
    to analyze the graphical data generated by CLR Profiler. The data summaries are
    grouped into sections.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个总结非常重要，因为它是开始分析 CLR Profiler 生成的图形数据之前的起点。数据摘要被分组到各个部分中。
- en: 'The important sections of the summary are explained here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 总结中的重要部分在此进行解释：
- en: The section labeled **Garbage Collection Statistics** gives statistics about
    the garbage collections that happen during the program run. The garbage collector
    in the .NET CLR is generational, which means that many garbage collections only
    consider the newest objects on the heap. These are referred to as generation 0
    collections and are quite fast. **Gen 1 collections** consider a bigger portion
    of the heap and are thus a bit slower, while **Gen 2 collections** (also referred
    to as *full collections*) consider the complete heap and can take a significant
    amount of time if the heap is large. Thus, you want to see a relatively small
    number of **Gen 2 collections** compared to **Gen 1 collections** and **Gen 0
    collections**. Finally, **Induced collections** are the collections triggered
    outside of the garbage collector, for example, by calling `GC.Collect` from the
    application. The view reachable via the **Time Line** button will be explained
    in detail in a short while.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记为 **垃圾回收统计** 的部分提供了程序运行期间发生的垃圾回收的统计数据。.NET CLR 中的垃圾回收器是分代的，这意味着许多垃圾回收只考虑堆上的最新对象。这些被称为
    0 代收集，并且非常快。**1 代收集**考虑堆的更大一部分，因此稍微慢一些，而**2 代收集**（也称为 *完全收集*）考虑整个堆，如果堆很大，可能需要相当长的时间。因此，你希望看到与**1
    代收集**和**0 代收集**相比相对较少的**2 代收集**。最后，**诱导收集**是由垃圾回收器外部触发的收集，例如，通过从应用程序中调用 `GC.Collect`。通过
    **时间线** 按钮可访问的视图将在稍后详细解释。
- en: The section **Garbage Collector Generation Sizes** gives the sizes of the various
    garbage collector generations. One additional twist is that there is a special
    area for large objects called **Large Object Heap bytes**. Note that these numbers
    are averages over the program run, which may not reflect the situation at the
    end of the run.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垃圾回收器代大小** 部分提供了各种垃圾回收器代的大小。还有一个额外的细节是，有一个专门用于大对象的区域，称为 **大对象堆字节**。请注意，这些数字是程序运行的平均值，可能不会反映运行结束时的状况。'
- en: The section **GC Handle Statistics** lists how many GC handles have been created,
    destroyed, and how many are surviving at the end of the program run. If the last
    number is particularly large, you may have a GC handle leak, which you can investigate
    by clicking on the **Allocation Graph** button next to the number.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GC 处理统计** 部分列出了在程序运行结束时创建、销毁的 GC 处理数量以及存活的数量。如果最后一个数字特别大，你可能有一个 GC 处理泄漏，你可以通过点击数字旁边的
    **分配图** 按钮来调查。'
- en: So, why do we focus mainly on garbage collectors (GC)? Because analyzing GCs
    is very useful for analyzing memory usages when running .NET applications. Examining
    GCs using CLR Profiler is also helpful when identifying memory leaks before, at,
    or after garbage collection.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们主要关注垃圾收集器（GC）呢？因为分析GC对于分析运行.NET应用程序时的内存使用非常有用。使用CLR Profiler检查GC也有助于在垃圾收集之前、期间或之后识别内存泄漏。
- en: Garbage collections in .NET happen on the heap, and they are available after
    GC has started. GC manages and stores objects used in the running program in the
    heap, and this is why it is called a **managed heap**.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: .NET中的垃圾收集在堆上发生，并在GC开始后可用。GC管理并存储运行程序中使用的对象在堆上，这就是为什么它被称为**托管堆**。
- en: The terms gen 0 and gen 1 are the generations of how it handles long-lived and
    short-lived objects.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 术语gen 0和gen 1是指它处理长期存在和短期存在对象的方式。
- en: 'There are three generations, as mentioned in the MSDN Library:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如MSDN库中所述，有三代：
- en: '**Generation 0**: This is the youngest generation and contains short-lived
    objects. An example of a short-lived object is a temporary variable. Garbage collection
    occurs most frequently in this generation. Newly allocated objects form a new
    generation of objects and are implicitly generation 0 collections, unless they
    are large objects, in which case they go on the large object heap in a generation
    2 collection. Most objects are reclaimed for garbage collection in generation
    0 and do not survive to the next generation. This generation is also called gen
    0 or simply Gen0.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第0代（Generation 0）**：这是最年轻的代，包含短期存在的对象。短期存在对象的例子是一个临时变量。垃圾收集在这个代中最频繁发生。新分配的对象形成一个新对象代，并隐式地成为第0代收集，除非它们是大型对象，在这种情况下，它们将进入第2代收集中的大型对象堆。大多数对象在第0代被回收，不会存活到下一代。这一代也称为gen
    0或简单地称为Gen0。'
- en: '**Generation 1**: This generation contains short-lived objects and serves as
    a buffer between short-lived objects and long-lived objects. This generation is
    also called gen 1 or simply Gen1.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第1代（Generation 1）**：这一代包含短期存在的对象，并在短期存在对象和长期存在对象之间充当缓冲区。这一代也称为gen 1或简单地称为Gen1。'
- en: '**Generation 2**: This generation contains long-lived objects. An example of
    a long-lived object is an object in a server application that contains static
    data that is live for the duration of the process.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第2代（Generation 2）**：这一代包含长期存在的对象。长期存在对象的例子是一个服务器应用程序中的对象，它包含在整个进程运行期间都处于活跃状态的数据。'
- en: If there are many objects that are characterized as long-lived objects during
    the runtime of an application, GC overheads will always occur at the finalization
    of the garbage collecting. This stage of finalization means that many long-lived
    objects are often called as having a condition of high cost object finalizations.
    Analyzing the GC using CLR Profiler will provide us with data on when and where
    GC overheads occur, especially when GC has many objects to handle (this will be
    shown as handles in CLR Profiler).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在应用程序运行期间有大量被表征为长期存在对象的对象，垃圾收集的最终化阶段将始终发生GC开销。这个最终化阶段意味着许多长期存在对象经常被称作具有高成本对象最终化的条件。使用CLR
    Profiler分析GC将为我们提供有关GC开销何时何地发生的资料，尤其是在GC有许多对象要处理时（这将在CLR Profiler中显示为句柄）。
- en: We can reduce the cost of finalization by using objects that implement the `IDisposable`
    interface correctly.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用正确实现`IDisposable`接口的对象来减少终结的开销。
- en: 'This tip is explained in detail in the following MSDN article by Rico Mariani,
    one of the architects of .NET BCL: [https://msdn.microsoft.com/en-us/library/ms973837.aspx](https://msdn.microsoft.com/en-us/library/ms973837.aspx).'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧在Rico Mariani（.NET BCL的架构师之一）的以下MSDN文章中有详细解释：[https://msdn.microsoft.com/en-us/library/ms973837.aspx](https://msdn.microsoft.com/en-us/library/ms973837.aspx)。
- en: 'In this article, it is recommended to use `IDisposable` interface for the following
    reason:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，建议使用`IDisposable`接口的原因如下：
- en: '*In many cases it is possible for objects that would otherwise always need
    to be finalized to avoid that cost by implementing the IDisposable interface.
    This interface provides an alternative method for reclaiming resources whose lifetime
    is well known to the programmer, and that actually happens quite a bit. Of course
    it''s better still if your objects simply use only memory and therefore require
    no finalization or disposing at all; but if finalization is necessary and there
    are many cases where explicit management of your objects is easy and practical,
    then implementing the IDisposable interface is a great way to avoid, or at least
    reduce, finalization costs.*'
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在许多情况下，通过实现 `IDisposable` 接口，原本总是需要终结的对象可以避免这种成本。该接口为程序员已知其生命周期的资源提供了一种替代方法，实际上这种情况相当常见。当然，如果你的对象仅使用内存并且因此不需要终结或销毁，那就更好了；但如果终结是必要的，并且有许多情况中显式管理你的对象既简单又实用，那么实现
    `IDisposable` 接口是避免或至少减少终结成本的一种很好的方法。*'
- en: 'The `IDisposable` interface has only one method: the `Dispose` method. It is
    crucial if we want to implement `IDisposable`, particularly, if the class that
    implements `IDisposable` is available to inherit (not marked with `SealedAttribute`
    in F#). Its detail implementation must obey the rules in the MSDN documentation:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`IDisposable` 接口只有一个方法：`Dispose` 方法。如果我们想实现 `IDisposable`，尤其是如果实现 `IDisposable`
    的类可以继承（在 F# 中没有标记为 `SealedAttribute`），这一点至关重要。其详细实现必须遵守 MSDN 文档中的规则：'
- en: It should provide one `public`, non-virtual `Dispose()` method and a `protected
    virtual Dispose(Boolean disposing)` method
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该提供一个 `public`、非虚拟的 `Dispose()` 方法和一个 `protected virtual Dispose(Boolean disposing)`
    方法
- en: The `Dispose()` method must call `Dispose(true)` and should suppress finalization
    for performance
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dispose()` 方法必须调用 `Dispose(true)` 并应抑制终结以提高性能'
- en: The base type should not include any finalizers
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础类型不应该包含任何终结器
- en: Unfortunately, there is no `protected` and `virtual` modifier support in F#;
    therefore, we could only use the F# default modifier on the `Dispose` method.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，F# 中不支持 `protected` 和 `virtual` 修饰符；因此，我们只能在 `Dispose` 方法上使用 F# 默认修饰符。
- en: It is quite easy in F# to ensure that the `Dispose` method is always called
    after we are done using the object by using F# syntactic sugar of `use` or `using`
    keywords, which translate to always call for disposal after the object is no longer
    in use. It is quite similar to the syntactic `using` in C# and VB. More details
    on this can be found in [Chapter 7](fsp-hiperf_cu07.html#aid-1ENBI1 "Chapter 7. Language
    Features and Constructs Optimization"), *Language Features and Constructs Optimization*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中确保在对象使用完毕后总是调用 `Dispose` 方法非常简单，可以通过使用 F# 的语法糖 `use` 或 `using` 关键字来实现，这相当于在对象不再使用后总是调用销毁操作。这与
    C# 和 VB 中的 `using` 语法非常相似。更多细节可以在[第7章](fsp-hiperf_cu07.html#aid-1ENBI1 "第7章。语言特性和结构优化")
    *语言特性和结构优化* 中找到。
- en: 'For a starting point to understand more on .NET Garbage Collector, visit the
    MSDN Library article titled *Fundamentals of Garbage Collection*:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 .NET 垃圾收集器的更多信息，请访问 MSDN 图书馆中名为 *垃圾收集基础* 的文章：
- en: '[https://msdn.microsoft.com/en-us/library/ee787088(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/ee787088(v=vs.110).aspx)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/ee787088(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/ee787088(v=vs.110).aspx)'
- en: Let's see a sample data of GC handles. In order to have this data presented
    to us, let's go back and focus our attention on the CLR Profiler's summary window.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 GC 处理的示例数据。为了让我们看到这些数据，让我们回到 CLR Profiler 的摘要窗口并集中注意力。
- en: 'Click the **Allocation Graph** button under **GC Handle Statistics** to see
    and check **GC handle allocations**:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **GC 处理统计** 下的 **分配图** 按钮来查看和检查 **GC 处理分配**：
- en: '![A quick walkthrough of CLR Profiler in action](img/image00274.jpeg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![CLR Profiler 动作快速浏览](img/image00274.jpeg)'
- en: In the graph, there are some lines and rectangular bars that flow from the leftmost
    rectangle. These represent the flow of how many handles the GC has. The thicker
    lines represent the biggest number of handles. These handles are further described
    in detail as thinner handles that comes from thicker rectangles. In the following
    text, the rectangular bar represents the program elements.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，有一些线条和从最左边的矩形流出的矩形条。这些代表 GC 的处理流程。较粗的线条代表处理数量最多的情况。这些处理在以下文本中详细描述为来自较粗矩形的较细处理。在以下文本中，矩形条代表程序元素。
- en: We can also drill down further by double-clicking the element that we want to
    examine.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过双击要检查的元素来进一步深入分析。
- en: 'Let''s examine the `Program::main` element:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 `Program::main` 元素：
- en: '![A quick walkthrough of CLR Profiler in action](img/image00275.jpeg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![CLR Profiler 动作快速浏览](img/image00275.jpeg)'
- en: 'Double-click the rectangular bar above the `Program::main`. A new graph window
    will appear, and it will only display the handles from `Program::main`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 双击 `Program::main` 上方的矩形条。将出现一个新的图形窗口，它将仅显示来自 `Program::main` 的句柄：
- en: '![A quick walkthrough of CLR Profiler in action](img/image00276.jpeg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![CLR Profiler 动作快速浏览](img/image00276.jpeg)'
- en: Hover the mouse over the rectangle that is labeled `ExtraTopLevelOperators::PrintFormatLine`,
    and a tooltip will show you that this object comes from `FSharp.Core.dll`. This
    tooltip hint is also important if we use references and not just F# core libraries
    and .NET BCL. We could pinpoint which part of an object holds many handles, drill
    down into the object, and then hover on it to see which object refers to which
    DLL library or executable.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 将鼠标悬停在标记为 `ExtraTopLevelOperators::PrintFormatLine` 的矩形上，将显示一个工具提示，说明该对象来自 `FSharp.Core.dll`。如果使用引用而不是仅使用
    F# 核心库和 .NET BCL，此工具提示提示也很重要。我们可以确定对象中哪个部分持有许多句柄，深入到该对象中，然后悬停在它上面以查看哪个对象引用了哪个
    DLL 库或可执行文件。
- en: We have used CLR Profiler to profile an F# console application. Combined with
    the knowledge of IL assembly language, CLR Profiler and ILDASM/ILASM provides
    us with a qualitative point of view for analyzing potential bottlenecks or even
    opportunities for further optimizations of our code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用 CLR Profiler 对 F# 控制台应用程序进行了分析。结合 IL 汇编语言的知识，CLR Profiler 和 ILDASM/ILASM
    为我们提供了分析潜在瓶颈或进一步优化我们代码的机会的定性观点。
- en: Again, it's harder to analyze qualitative data than quantitative, but we can
    set the qualitative knowledge to further understand quantitative measurement because
    understanding qualitative data at initial preparation of performance measurement
    gives us reasoning capability when we analyze our running code using simpler quantitative
    ways.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，分析定性数据比分析定量数据更困难，但我们可以将定性知识应用于进一步理解定量测量，因为理解定性数据在性能测量的初始准备阶段为我们分析运行代码提供了推理能力。
- en: Ways to measure performance quantitatively
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定量衡量性能的方法
- en: There are many ways to measure performances of any running .NET code on top
    of CLR, including F#. So, any tool used to measure F# code is essentially usable
    for other programming languages on .NET CLR as well.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以衡量 CLR 之上的任何运行 .NET 代码的性能，包括 F#。因此，任何用于测量 F# 代码的工具基本上也可以用于 .NET CLR 上的其他编程语言。
- en: 'Again, the easiest way to objectively measure performance is by using quantitative
    measurements. The following are some common ways of measuring running codes:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，客观衡量性能的最简单方法是通过使用定量测量。以下是一些常见的测量运行代码的方法：
- en: Using .NET timers
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 .NET 定时器
- en: Using native Win32 timer
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原生 Win32 定时器
- en: Using Visual Studio Diagnostic
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Visual Studio 诊断工具
- en: Running functions inside unit tests
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单元测试中运行函数
- en: The previous numbers are ordered from the subtlest and difficult to the quickest
    way of having statistical timing as performance measurements.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的数字按从最微妙且难以到最快的方式进行统计计时作为性能测量排序。
- en: Using .NET timers
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 .NET 定时器
- en: There are many timer classes in the .NET Framework but not all of them have
    a general purpose from the perspective of implementation details and in the context
    of execution environments.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 框架中有许多定时器类，但并非所有类在实现细节和执行环境上下文中都具有通用目的。
- en: 'In the context of execution environments, .NET timers are divided as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行环境上下文中，.NET 定时器被划分为以下几种：
- en: UI timers (timers that are run on an UI thread)
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI 定时器（在 UI 线程上运行的定时器）
- en: Non-UI timer (timers that are run on the common CPU thread)
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非UI定时器（在公共CPU线程上运行的定时器）
- en: All UI timers are not always synchronized with a non-UI thread, so they are
    not guaranteed to have high precision. An example of this is when using `System.Windows.Forms.Timer`,
    while at the same time having a background thread run. In the internal implementation
    of `System.Windows.Forms.Timer`, this object uses the `Win32 WM_TIMER` message
    and processes it in a message loop.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有UI定时器都与非UI线程同步，因此它们不一定保证有高精度。一个例子是在使用 `System.Windows.Forms.Timer` 的同时，还有一个后台线程在运行。在
    `System.Windows.Forms.Timer` 的内部实现中，该对象使用 `Win32 WM_TIMER` 消息，并在消息循环中处理它。
- en: In addition, the behavior of `System.Windows.Forms.Timer` is synchronous relative
    to the other UI thread, and therefore the UI thread processes this message loop
    of `WM_TIMER` as long as it is not processing other Windows messages that come
    in the middle.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`System.Windows.Forms.Timer`的行为相对于其他UI线程是同步的，因此UI线程只要不处理中间到达的其他Windows消息，就会处理`WM_TIMER`消息循环。
- en: Therefore, an elapsed event of this timer may slip as the timer has no lock
    on the current UI thread of Windows message loops, especially when there are blocking
    threads running, such as when downloading from the Internet or printing to a printer.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个计时器的超时事件可能会滑动，因为计时器对Windows消息循环的当前UI线程没有锁定，尤其是在有阻塞线程运行时，例如从互联网下载或打印到打印机。
- en: For the sake of objective measurement and also calculating with as high precision
    as possible, we are not going to use UI timers and will instead focus on non-UI
    timers.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了客观测量和尽可能高精度地计算，我们不会使用UI计时器，而是将重点放在非UI计时器上。
- en: 'The following non-UI timers are available:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是非UI计时器的可用选项：
- en: '`System.Timers.Timer`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Timers.Timer`'
- en: '`System.Threading.Timer`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Threading.Timer`'
- en: '`System.Diagnostic.Stopwatch`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Diagnostic.Stopwatch`'
- en: The `System.Timers.Timer` is a special case of timers. It may run indirectly
    on a UI thread, not just on a system worker thread. `System.Threading.Timer` always
    runs on a worker thread, and we cannot mix worker threads and UI threads easily.
    This condition is raised because the nature of `System.Threading.Timer` is asynchronous.
    But this is also a nice feature to use as it will not lock the running UI thread,
    since the thread has to be explicitly treated or handled in a different manner.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Timers.Timer`是计时器的一个特例。它可能间接在UI线程上运行，而不仅仅是系统工作线程。`System.Threading.Timer`始终在工作线程上运行，我们无法轻易混合工作线程和UI线程。这种情况发生是因为`System.Threading.Timer`的本质是异步的。但这也是一个很好的特性，因为它不会锁定正在运行的UI线程，因为线程必须以不同的方式显式处理或处理。'
- en: Using `System.Timer.Timer` is easier to use than `System.Threading.Timer` as
    it uses an event model instead of forcing to use callbacks. It's also easier to
    understand because we can control the number of ticks for triggering the elapsed
    event.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`System.Timer.Timer`比使用`System.Threading.Timer`更容易，因为它使用事件模型而不是强制使用回调。它也更易于理解，因为我们可以控制触发超时事件的滴答次数。
- en: Let's create a separate project to test the timer of `System.Timers.Timer` to
    measure our function.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个单独的项目来测试`System.Timers.Timer`的计时器，以测量我们的函数。
- en: Create a new F# console project and name it `FSTimer01`. A window editor that
    shows the opened `Program.fs` is now open.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的F#控制台项目，并将其命名为`FSTimer01`。现在打开了一个窗口编辑器，显示打开的`Program.fs`。
- en: 'Change the code of `Program.cs` as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式修改`Program.cs`的代码：
- en: '[PRE9]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Run the code by means of running without debugging, and the time elapsed will
    kick for every 1 millisecond.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 通过不调试运行代码来执行，时间间隔将每1毫秒触发一次。
- en: On my machine, it shows `time elapsed for 6`, meaning the code takes roughly
    about 6 milliseconds to execute. Again, this may vary on different machines with
    different configurations.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，它显示`time elapsed for 6`，这意味着代码大约需要6毫秒来执行。再次强调，这可能会因不同机器的不同配置而有所不同。
- en: The previous sample code is not quite accurate in terms of precision because
    it relies heavily on the elapsed event when it triggered. There might be something
    that comes before and after the timer has elapsed, and this might block the current
    thread before the elapsed event and even after the elapsed event is triggered.
    To use `System.Timers.Timer` more accurately, we should not use timer mixed with
    another blocking thread, such as I/O, or another thread that might change the
    system state, such as querying or updating operating system settings.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例代码在精度方面并不准确，因为它在触发时严重依赖于超时事件。在计时器超时前后可能有一些东西，这可能会在超时事件之前和之后阻塞当前线程。为了更准确地使用`System.Timers.Timer`，我们不应使用与另一个阻塞线程（如I/O）或可能更改系统状态的其他线程（如查询或更新操作系统设置）混合的计时器。
- en: 'For more details of comparison on these timers (other than Stopwatch), we can
    see the timers in action in this archived article in MSDN Magazine February 2004
    edition (in CHM format):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些计时器（除了Stopwatch）的更多比较细节，我们可以在MSDN杂志2004年2月版（CHM格式）的存档文章中看到计时器的实际操作：
- en: '[http://download.microsoft.com/download/3/a/7/3a7fa450-1f33-41f7-9e6d-3aa95b5a6aea/MSDNMagazineFebruary2004en-us.chm](http://download.microsoft.com/download/3/a/7/3a7fa450-1f33-41f7-9e6d-3aa95b5a6aea/MSDNMagazineFebruary2004en-us.chm)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://download.microsoft.com/download/3/a/7/3a7fa450-1f33-41f7-9e6d-3aa95b5a6aea/MSDNMagazineFebruary2004en-us.chm](http://download.microsoft.com/download/3/a/7/3a7fa450-1f33-41f7-9e6d-3aa95b5a6aea/MSDNMagazineFebruary2004en-us.chm)'
- en: 'Next, we use `System.Diagnostic.Stopwatch`, which is often called Stopwatch.
    Although this timer is quite similar to `System.Timers.Timer`, Stopwatch has its
    own algorithm flow, and it is clever enough to use a performance counter, as defined
    in the MSDN Library:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`System.Diagnostic.Stopwatch`，通常称为`Stopwatch`。尽管这个计时器与`System.Timers.Timer`非常相似，但`Stopwatch`有自己的算法流程，并且足够聪明，能够使用MSDN库中定义的性能计数器。
- en: '*The Stopwatch measures elapsed time by counting timer ticks in the underlying
    timer mechanism. If the installed hardware and operating system support a high-resolution
    performance counter, then the Stopwatch class uses that counter to measure elapsed
    time. Otherwise, the Stopwatch class uses the system timer to measure elapsed
    time.*'
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*计时器通过在底层计时器机制中计数计时器滴答来测量经过的时间。如果安装的硬件和操作系统支持高分辨率性能计数器，则`Stopwatch`类使用该计数器来测量经过的时间。否则，`Stopwatch`类使用系统计时器来测量经过的时间。*'
- en: A high resolution performance counter is obtained by calling the native (unmanaged)
    Win32 API of `QueryPerformanceCounter`. But this Win32 API should not be used
    directly as it may require some privileges. particularly elevated privileges.
    To safely determine that we have a high resolution performance counter available,
    we should use the properties of Stopwatch, `Frequency` and `IsHighResolution`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用本机（非托管）Win32 API `QueryPerformanceCounter`可以获得高分辨率性能计数器。但不应直接使用此Win32 API，因为它可能需要一些权限，尤其是提升的权限。为了安全地确定我们有一个高分辨率性能计数器可用，我们应该使用`Stopwatch`的属性`Frequency`和`IsHighResolution`。
- en: 'For more information about `System.Diagnostics.Stopwatch`, have a look at the
    official MSDN documentation:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`System.Diagnostics.Stopwatch`的更多信息，请参阅官方MSDN文档：
- en: '[https://msdn.microsoft.com/en-us/library/system.diagnostics.stopwatch(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.diagnostics.stopwatch(v=vs.110).aspx)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/system.diagnostics.stopwatch(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.diagnostics.stopwatch(v=vs.110).aspx)'
- en: It is quite easy to use Stopwatch as we do not need to pay attention to any
    time-elapsed event, because there is no specific elapsed event to handle manually.
    Stopwatch also uses .NET `TimeSpan` to measure how much time has passed from beginning
    to end.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Stopwatch`非常简单，因为我们不需要注意任何经过的时间事件，因为没有特定的经过事件需要手动处理。`Stopwatch`还使用.NET `TimeSpan`来测量从开始到结束经过的时间。
- en: Using the solution as a timer beforehand, we can test Stopwatch by creating
    a new project on top of the current solution.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用解决方案作为计时器 beforehand，我们可以在当前解决方案之上创建一个新项目来测试`Stopwatch`。
- en: Create a new console project called `FSTimer02`. A default `Program.fs` editor
    appears, so then copy the codes from the previous `Program.fs` that has the `System.Timers.Timer`
    example, as we are reusing the `fact` function.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`FSTimer02`的新控制台项目。默认的`Program.fs`编辑器出现，因此然后复制之前`Program.fs`中的代码，因为我们正在重用`fact`函数。
- en: 'Change the function body into the following code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数体更改为以下代码：
- en: '[PRE10]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This time it will show the time duration at a point after the execution of
    `Stopwatch.Start` until the point before `Stopwatch.Stop` is executed. The number
    of milliseconds of the `ElapsedMilliseconds` property is actually the same result
    of `Elapsed` as `TimeSpan`. Both properties call the same `private` method of
    Stopwatch: the `GetElapsedDateTimeTicks` method.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这次它将显示从执行`Stopwatch.Start`到执行`Stopwatch.Stop`之前的时间段。`ElapsedMilliseconds`属性的毫秒数实际上是`Elapsed`与`TimeSpan`相同的输出结果。这两个属性都调用`Stopwatch`的同一`private`方法：`GetElapsedDateTimeTicks`方法。
- en: Set the `FSTimer02` project as a startup project and then run it. The time shown
    has a tendency to be higher than the time shown by `System.Timers.Timer`. This
    is as expected because Stopwatch queries to the system performance counter first
    and then tries to decide whether a performance counter with a higher resolution
    is available. If it is available, it will try to use it; otherwise, it will use
    the existing system CPU ticks.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 将`FSTimer02`项目设置为启动项目，然后运行它。显示的时间有比`System.Timers.Timer`显示的时间更高的趋势。这是预期的，因为`Stopwatch`首先查询系统性能计数器，然后尝试确定是否有更高分辨率的性能计数器可用。如果可用，它将尝试使用它；否则，它将使用现有的系统CPU滴答。
- en: We have experienced how to use .NET timers to measure the duration of the running
    code. The data available is very useful for comparison, especially when testing
    different functions, language constructs, and when performing optimizations on
    inline functions.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了如何使用.NET计时器来测量运行代码的持续时间。这些数据对于比较非常有用，尤其是在测试不同的函数、语言构造以及在对内联函数进行优化时。
- en: But using these timers is not always the best practice, as they may be subject
    to the Windows' thread scheduler, and other running background Windows processes
    with the most administrative privileges may interfere, although, it is somehow
    possible.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 但使用这些计时器并不总是最佳实践，因为它们可能受到Windows线程调度程序的影响，并且具有最高管理权限的其他正在运行的Windows后台进程可能会干扰，尽管这在某种程度上是可能的。
- en: Running functions inside unit tests
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在单元测试中运行函数
- en: One of the most common ways to measure is by running and testing our code inside
    a unit test. It is recommended because you are forced to think about all of the
    possible scenarios for errors or exceptions that might occur, not just successful
    scenarios. Here, the term *scenario* means considering various inputs to be tested
    (including having incorrect or undesirable inputs) that are taken as parameters.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 测量的最常见方法之一是在单元测试中运行和测试我们的代码。这是推荐的，因为这将迫使你考虑所有可能发生错误或异常的场景，而不仅仅是成功的场景。在这里，术语*场景*意味着考虑各种要测试的输入（包括错误的或不希望的输入），这些输入被视为参数。
- en: A quick introduction to unit tests
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试的快速介绍
- en: There are many definitions of a unit test, but a unit test is simply a test
    that focuses on testing the smallest testable part of a program; this might be
    a simple function or a complex function that has calls to other functions. To
    cover the objectivity of the unit test, the test must also cover any scenario
    of having various inputs to test the results and the possibility of exceptions
    that may occur.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试有许多定义，但单元测试简单来说就是关注测试程序中最小可测试部分的测试；这可能是一个简单的函数，也可能是一个复杂的函数，它调用了其他函数。为了覆盖单元测试的客观性，测试还必须覆盖任何具有各种输入以测试结果和可能发生的异常的场景。
- en: It is known that unit tests are closely related to **Test-Driven Development**
    (**TDD**), where developers focus on possible scenarios that may produce different
    results or even errors as exceptions. By thinking of the possible scenarios upfront,
    the chance of having bugs in the implementation is minimized or even close to
    zero. You can also identify the failing scenarios, particularly when you consider
    an invalid input for certain functions that contain any operation with potential
    exceptions, such as division operations, square roots, or even out of memory situations.
    This is why unit test is one of the examples of TDD in action, as testing scenarios
    are being thought out before the implementation of the function.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 已知单元测试与**测试驱动开发**（**TDD**）密切相关，其中开发者专注于可能产生不同结果或甚至错误（作为异常）的潜在场景。通过提前考虑可能的场景，可以最大限度地减少实现中的错误或将其降至接近零。你还可以识别失败的场景，尤其是当你考虑某些包含潜在异常操作（如除法操作、平方根或甚至内存不足情况）的函数的无效输入时。这就是为什么单元测试是TDD实际应用的例子之一，因为测试场景是在函数实现之前被考虑的。
- en: Unit test support in Visual Studio
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Visual Studio中的单元测试支持
- en: There are many unit test frameworks in .NET ecosystems, the most popular and
    widely used being xUnit and NUnit. These two have their own integration with Visual
    Studio through a test runner UI. Visual Studio itself has built-in support for
    unit tests; it is a Microsoft Test Framework often called **MS Test**. MS Test
    provides tooling, classes, and attributes for use to support unit tests, and in
    conjunction with Visual Studio, the unit test has its own test runner UI support
    as well.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET生态系统中有许多单元测试框架，其中最受欢迎和最广泛使用的是xUnit和NUnit。这两个框架都通过测试运行器UI与Visual Studio集成。Visual
    Studio本身也内置了对单元测试的支持；它通常被称为**MS Test**的Microsoft Test Framework。MS Test提供了用于支持单元测试的工具、类和属性，并且与Visual
    Studio结合使用时，单元测试也有自己的测试运行器UI支持。
- en: All of the test frameworks, such as MS Test, xUnit, and NUnit, have integration
    support as part of the Visual Studio SDK. This extension of test runners inside
    Visual Studio has been available since Visual Studio 2010\. The extensibility
    is done to extend the base test runner, and the available tests are displayed
    at Visual Studio **Test Explorer**. The Visual Studio test runner extensibility
    runs on .NET 4 CLR, so it is language agnostic. We could also create our own extensions
    in F#, not just by using C# and VB.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试框架，如 MS Test、xUnit 和 NUnit，都是 Visual Studio SDK 的一部分，提供集成支持。Visual Studio
    内部测试运行器的扩展自 Visual Studio 2010 起就可用。这种扩展是为了扩展基本测试运行器，并且可用的测试在 Visual Studio **测试资源管理器**
    中显示。Visual Studio 测试运行器扩展在 .NET 4 CLR 上运行，因此它是语言无关的。我们也可以使用 F# 创建自己的扩展，而不仅仅是使用
    C# 和 VB。
- en: For documentation on the Visual Studio Testing Tool API, please visit MSDN at
    [https://msdn.microsoft.com/en-us/library/dd465178(v=vs.120).aspx](https://msdn.microsoft.com/en-us/library/dd465178(v=vs.120).aspx).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Visual Studio 测试工具 API 的文档，请访问 MSDN，网址为 [https://msdn.microsoft.com/en-us/library/dd465178(v=vs.120).aspx](https://msdn.microsoft.com/en-us/library/dd465178(v=vs.120).aspx)。
- en: 'For more information about the Visual Studio test runner, this is the official
    starting documentation of Visual Studio SDK:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Visual Studio 测试运行器的更多信息，这是 Visual Studio SDK 的官方起始文档：
- en: '[https://msdn.microsoft.com/en-us/library/bb166441.aspx](https://msdn.microsoft.com/en-us/library/bb166441.aspx)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/bb166441.aspx](https://msdn.microsoft.com/en-us/library/bb166441.aspx)'
- en: Unfortunately, F# in Visual Studio has no inherent or template support in the
    form of a unit test project template, unlike C# and VB. However, we can still
    leverage MS Test by using the open source library of FsUnit for MS Test. The best
    part of this FsUnit for the MS Test library is how easy it is to install as a
    NuGet package.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，与 C# 和 VB 不同，Visual Studio 中的 F# 没有固有的或模板形式的单元测试项目模板支持。然而，我们仍然可以通过使用 FsUnit
    的开源库来利用 MS Test。FsUnit for MS Test 库的最好之处在于它作为 NuGet 包安装的简便性。
- en: Note
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is recommended to use F# code files (`.fs`), instead of F# scripting, to
    implement and run F# unit tests. Running a unit test in script mode will yield
    undesirable results, including runtime exceptions, as the Visual Studio test runner
    is not meant to run integrated with F# FSI.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用 F# 代码文件（`.fs`），而不是 F# 脚本，来实现和运行 F# 单元测试。在脚本模式下运行单元测试会产生不理想的结果，包括运行时异常，因为
    Visual Studio 测试运行器并不是为了与 F# FSI 集成运行而设计的。
- en: Using FSIUnit is better than using xUnit, NUnit, or MS Test directly because
    FsUnit is created with the functional programming style at the beginning instead
    of using the common `Assert` method to test the result of a function.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 FSIUnit 比直接使用 xUnit、NUnit 或 MS Test 更好，因为 FsUnit 是从功能编程风格开始创建的，而不是使用常见的 `Assert`
    方法来测试函数的结果。
- en: Let's set up FsUnit and use it to implement a unit test in F#.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置 FsUnit 并使用它来在 F# 中实现单元测试。
- en: Using FsUnit to implement a unit test in F#
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 FsUnit 在 F# 中实现单元测试
- en: FsUnit itself has support not just for MS Test but also for xUnit and NUnit.
    FsUnit is part of many F# open source projects under the governance umbrella of
    the F# Software Foundation (FSSF). All of the F# open source projects have a landing
    page at this GitHub page, [http://fsprojects.github.io/](http://fsprojects.github.io/).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: FsUnit 不仅支持 MS Test，还支持 xUnit 和 NUnit。FsUnit 是 F# 软件基金会（FSSF）治理伞下的许多 F# 开源项目的一部分。所有
    F# 开源项目都有一个着陆页，位于这个 GitHub 页面 [http://fsprojects.github.io/](http://fsprojects.github.io/)。
- en: For more information about FsUnit, visit the official landing page at [https://fsprojects.github.io/FsUnit/index.html](https://fsprojects.github.io/FsUnit/index.html).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 FsUnit 的更多信息，请访问官方着陆页 [https://fsprojects.github.io/FsUnit/index.html](https://fsprojects.github.io/FsUnit/index.html)。
- en: 'Let''s import FsUnit for the MS Test NuGet package. First, right-click the
    project name of `FSConsole01`, then choose the **Manage NuGet packages..** menu
    item. Then, a tab of **NuGet Package Manager** for the  `FSConsole01` project
    appears as shown in the following screenshot:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们导入 FsUnit 以使用 MS Test NuGet 包。首先，右键单击 `FSConsole01` 的项目名称，然后选择 **管理 NuGet
    包..** 菜单项。然后，会出现一个 `FSConsole01` 项目的 **NuGet 包管理器** 选项卡，如图所示：
- en: '![Using FsUnit to implement a unit test in F#](img/image00277.jpeg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![使用 FsUnit 在 F# 中实现单元测试](img/image00277.jpeg)'
- en: 'Let''s do the following steps to add FsUnit NuGet package into our sample project:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤将 FsUnit NuGet 包添加到我们的示例项目中：
- en: In the search text box, type FsUnit and press *Enter*. A list of FsUnit related
    NuGet packages is shown:![Using FsUnit to implement a unit test in F#](img/image00278.jpeg)
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索文本框中输入 FsUnit 并按 *Enter*。显示 FsUnit 相关的 NuGet 包列表：![使用 FsUnit 在 F# 中实现单元测试](img/image00278.jpeg)
- en: Scroll down and choose **FSUnit30Unit.MSTest**:![Using FsUnit to implement a
    unit test in F#](img/image00279.jpeg)
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动并选择 **FSUnit30Unit.MSTest**：![使用 FsUnit 在 F# 中实现单元测试](img/image00279.jpeg)
- en: Then, click the **Install** button to download and install this package. Note
    that the **Package source** is pointing to **nuget.org**.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击 **安装** 按钮下载并安装此包。请注意，**包源** 指向 **nuget.org**。
- en: Note
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Throughout the rest of this book, we use NuGet packages to enrich our base experience
    of coding in F#. The NuGet source itself is not just from **nuget.org**; there
    are many other NuGet package sources. These NuGet package sources are often called
    NuGet feeds as these sources are displayed in actual RSS feeds before being listed
    in the Visual Studio NuGet package manager.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们使用 NuGet 包来丰富我们在 F# 中编码的基础体验。NuGet 源本身不仅来自 **nuget.org**；还有许多其他 NuGet
    包源。这些 NuGet 包源通常被称为 NuGet 资源，因为这些源在 Visual Studio NuGet 包管理器中列出之前，会显示在实际的 RSS
    资源中。
- en: For more information on NuGet, including how to host and to create your own
    NuGet packages, visit the NuGet official website at [https://www.nuget.org/](https://www.nuget.org/).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 NuGet 的更多信息，包括如何托管和创建您自己的 NuGet 包，请访问 NuGet 官方网站 [https://www.nuget.org/](https://www.nuget.org/)。
- en: The download and installation process is always projected at the **Output**
    window of the NuGet package manager.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 下载和安装过程始终显示在 NuGet 包管理器的 **输出** 窗口中。
- en: If the package already exists (hence, installed), then NuGet will check the
    existing version of the NuGet package. If the version is older, by default it
    will try to update the existing version and install the newer version.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包已经存在（因此，已安装），那么 NuGet 将检查现有 NuGet 包的版本。如果版本较旧，默认情况下，它将尝试更新现有版本并安装较新版本。
- en: 'The successful NuGet installation is shown in the **Output** window of **Package
    Manager** as **Finished**:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的 NuGet 安装在 **包管理器** 的 **输出** 窗口中显示为 **完成**：
- en: '![Using FsUnit to implement a unit test in F#](img/image00280.jpeg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![使用 FsUnit 在 F# 中实现单元测试](img/image00280.jpeg)'
- en: We can now be sure that `FS30Unit.MsTest` is available to use to perform a unit
    test in F#. However, the main MS Test framework is not yet installed. We have
    to add this library manually.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以确信 `FS30Unit.MsTest` 可用于在 F# 中执行单元测试。然而，主要的 MS Test 框架尚未安装。我们必须手动添加此库。
- en: The name of the MS Test framework library is `Microsoft.VisualStudio.QualityTools.UnitTestFramework`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: MS Test 框架库的名称是 `Microsoft.VisualStudio.QualityTools.UnitTestFramework`。
- en: This library is available as an extension library in the .NET project. It is
    also in the existing .NET **global assembly cache** (**GAC**) in Windows, installed
    by default by Visual Studio 2015 Community Edition and above.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 此库作为扩展库在 .NET 项目中可用。它也位于 Windows 中现有的 .NET **全局程序集缓存**（**GAC**）中，由 Visual Studio
    2015 社区版及以上版本默认安装。
- en: In previous versions of Visual Studio before Visual Studio 2010, the name of
    the library was different, and it was named `Microsoft.VisualStudio.TestTools.UnitTesting`.
    The change of the name reflects that the Visual Studio Unit Test Framework has
    been part of Microsoft Visual's Studio Quality Tools since the release of Visual
    Studio 2010, including Microsoft Coded UI Test, Web Test, and Windows Store Test.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2010 之前的 Visual Studio 早期版本中，库的名称不同，它被命名为 `Microsoft.VisualStudio.TestTools.UnitTesting`。名称的变化反映了自
    Visual Studio 2010 发布以来，Visual Studio 单元测试框架已成为 Microsoft Visual Studio 质量工具的一部分，包括
    Microsoft Coded UI Test、Web Test 和 Windows Store Test。
- en: The documentation of the classes and attributes of Visual Studio Unit Test Framework
    in Visual Studio 2015 is available at [https://msdn.microsoft.com/en-us/library/microsoft.visualstudio.testtools.unittesting(v=vs.140).aspx](https://msdn.microsoft.com/en-us/library/microsoft.visualstudio.testtools.unittesting(v=vs.140).aspx).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2015 中 Visual Studio 单元测试框架的类和属性的文档可在 [https://msdn.microsoft.com/en-us/library/microsoft.visualstudio.testtools.unittesting(v=vs.140).aspx](https://msdn.microsoft.com/en-us/library/microsoft.visualstudio.testtools.unittesting(v=vs.140).aspx)
    找到。
- en: 'Add this `Microsoft.VisualStudio.QualityTools.UnitTestFramework` by adding
    references to the project, and then choose the **Extensions** tab:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向项目添加引用并选择 **扩展** 选项卡来添加 `Microsoft.VisualStudio.QualityTools.UnitTestFramework`：
- en: '![Using FsUnit to implement a unit test in F#](img/image00281.jpeg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![使用 FsUnit 在 F# 中实现单元测试](img/image00281.jpeg)'
- en: Now that we have that set up, and it is available for use, we can now code the
    unit test. We can also combine our entrypoint for the F# console with the factorial
    function and the unit test. It is also recommended to separate the factorial function
    from the main module that has an entrypoint as the concern of the module that
    has the entrypoint is actually different from the factorial function.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了，并且它可供使用，我们现在可以编写单元测试。我们还可以将我们的F#控制台入口点与阶乘函数和单元测试结合起来。还建议将阶乘函数从具有入口点的模块中分离出来，因为具有入口点的模块的实际关注点与阶乘函数不同。
- en: Always pay attention to the indentation inside the modules, types, and the functions.
    F# always relies on the indentation to mark wrong indentation as that will always
    result in compiling errors.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 总是注意模块、类型和函数内部的缩进。F#总是依赖于缩进来标记错误的缩进，因为这总会导致编译错误。
- en: 'This is the official guideline on code indentation in F#:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这是F#代码缩进的官方指南：
- en: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/code-formatting-guidelines-%5Bfsharp%5D](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/code-formatting-guidelines-%5Bfsharp%5D)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/code-formatting-guidelines-%5Bfsharp%5D](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/code-formatting-guidelines-%5Bfsharp%5D)'
- en: First, we have to set multiple module files to be compiled correctly for this
    console project. The entrypoint of `Program.fs` needs to be modified to be included
    in an explicit module under the namespace, `FSConsole01`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须设置多个模块文件以正确编译此控制台项目。`Program.fs`的入口点需要修改为包含在命名空间下的显式模块中，即`FSConsole01`。
- en: 'In `Program.fs` in the code window, type the following code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码窗口中的`Program.fs`中，输入以下代码：
- en: '[PRE11]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Build it, and an error warning will show the following message:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 构建它，并将显示以下错误警告信息：
- en: '[PRE12]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Ignore this error for now, as we will fix this later.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 目前忽略这个错误，因为我们稍后会修复它。
- en: Let's move our factorial function into the unit test.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把我们的阶乘函数移入单元测试中。
- en: Create a new F# source file and name it `FSConsoleUnitTest`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的F#源文件，并将其命名为`FSConsoleUnitTest`。
- en: 'Type the following in the code window:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码窗口中输入以下内容：
- en: '[PRE13]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code in the `FSConsoleUnitTest` module shows that we now have a class of
    `FactTest` and the method to be our unit test.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`FSConsoleUnitTest`模块中的代码显示我们现在有一个`FactTest`类以及用于单元测试的方法。'
- en: The `TestClass` attribute on `FactTest` means that this class will be used by
    the test runner as the starting class to hold the unit test. The `TestMethod`
    attribute on `FactTest01` means that this method is our unit test under the `FactTest`
    class.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`FactTest`上的`TestClass`属性意味着这个类将被测试运行器用作起始类来持有单元测试。`FactTest01`上的`TestMethod`属性意味着这个方法是在`FactTest`类下的我们的单元测试。'
- en: This is a common convention as the class to be used for a unit test cannot be
    a static class. The nature of a unit test is instantiating the class that has
    the attribute of `TestClass` before running the tests inside the methods with
    the `TestMethod` attribute.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常见的约定，因为用于单元测试的类不能是静态类。单元测试的本质是在运行具有`TestMethod`属性的测试方法之前，实例化具有`TestClass`属性的类。
- en: 'For more information on creating, running, and debugging unit tests using MS
    Test (and also for other test frameworks) in Visual Studio 2015, visit this MSDN
    Library:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 有关在Visual Studio 2015中使用MS Test创建、运行和调试单元测试（以及其他测试框架）的更多信息，请访问此MSDN库：
- en: '[https://msdn.microsoft.com/library/dd264975](https://msdn.microsoft.com/library/dd264975)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/library/dd264975](https://msdn.microsoft.com/library/dd264975)'
- en: 'Let''s fix the previous error by reordering `Program.fs` to be the last order
    of the file order. We do this by right-clicking `Program.fs` and moving down `Program.fs`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过重新排序`Program.fs`为文件顺序的最后一个顺序来修复前面的错误。我们通过右键单击`Program.fs`并将`Program.fs`向下移动来实现这一点：
- en: '![Using FsUnit to implement a unit test in F#](img/image00282.jpeg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![使用FsUnit在F#中实现单元测试](img/image00282.jpeg)'
- en: Ensure that `Program.fs` is the last file.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`Program.fs`是最后一个文件。
- en: Note
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that file ordering in F# is very important.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在F#中文件排序非常重要。
- en: Build the project. Then, display the **Test Explorer** window if it's not open.
    On the General collection default setting, the **Test Explorer** menu item is
    available under the main menu **Test**.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 构建项目。如果它没有打开，请显示**测试资源管理器**窗口。在“常规”集合默认设置下，**测试资源管理器**菜单项位于主菜单**测试**下。
- en: 'The `FactTest01` test will be shown in the **Test Explorer** as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`FactTest01`测试将在**测试资源管理器**中如下显示：'
- en: '![Using FsUnit to implement a unit test in F#](img/image00283.jpeg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![使用FsUnit在F#中实现单元测试](img/image00283.jpeg)'
- en: 'Let''s run the test by clicking **Run All** on the **Test Explorer**. **Test
    Explorer** will display the number of milliseconds it takes to run the unit test
    on the right of the test method name:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击**测试资源管理器**中的**运行所有**来运行测试。**测试资源管理器**将在测试方法名称的右侧显示运行单元测试所需的毫秒数：
- en: '![Using FsUnit to implement a unit test in F#](img/image00284.jpeg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![使用FsUnit在F#中实现单元测试](img/image00284.jpeg)'
- en: The number of milliseconds may vary depending on different hardware, because
    it is influenced by the speed of the CPU and the number of CPU cores. The function
    we have tested is a simple function, but we can have a function that has parallel
    calls by utilizing .NET Task Parallel Library (TPL). The consequences of the usage
    of .NET TPL are that numbers can vary greatly across different systems with different
    configurations, such as the operating system used (in this context, the Windows
    version and edition) and different CPU specifications.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 毫秒数可能会因不同的硬件而有所不同，因为它受到CPU速度和CPU核心数量的影响。我们测试的是一个非常简单的函数，但我们可以通过利用.NET任务并行库（TPL）来实现具有并行调用的函数。使用.NET
    TPL的后果是，不同配置的系统（例如操作系统使用情况，在此上下文中为Windows版本和版本）和不同的CPU规格可能会导致数字差异很大。
- en: For example, testing using a machine that has a 4th generation core i7 2.4 Ghz
    CPU might be a little bit faster than a machine that has a 6th generation core
    i5 2.2 Ghz CPU. The number of cores may have some influence as well, as the number
    of cores in a modern CPU is always increasing.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用具有第四代核心i7 2.4 GHz CPU的机器进行测试可能比使用具有第六代核心i5 2.2 GHz CPU的机器快一点。核心数量也可能有一定的影响，因为现代CPU的核心数量总是在增加。
- en: In our code, there is no direct use of MS Test's Assert at all. This is actually
    available under the cover of FsUnit. We can look at FsUnit source codes in the
    GitHub repository of FsUnit, in particular, FsUnit code to support MS Test. All
    the code related to MS Test is under the folder named `FsUnit.MsTestUnit`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们没有直接使用MS Test的Assert。实际上，这可以在FsUnit的GitHub仓库中找到，特别是FsUnit代码以支持MS Test。所有与MS
    Test相关的代码都在名为`FsUnit.MsTestUnit`的文件夹下。
- en: To recap again, FsUnit has support for the NUnit and xUnit test frameworks,
    and both of them use the same context of implementing `Assert` methods under the
    cover of a functional FsUnit. You may use test frameworks other than MS Test,
    as long as they are supported by FsUnit. It is recommended to participate with
    or contribute to FsUnit as this project is encouraging contributors to support
    other test frameworks such as MbUnit.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 再次总结一下，FsUnit支持NUnit和xUnit测试框架，并且它们都在FsUnit的功能性封装下实现了`Assert`方法。你可以使用FsUnit支持的除MS
    Test以外的任何测试框架。建议参与或为FsUnit项目做出贡献，因为这个项目鼓励贡献者支持其他测试框架，如MbUnit。
- en: At the time of writing, FsUnit supports both F# 3.1 and F# 4.0\. But it is recommended
    to use FsUnit with F# 4.0 because this will provide you with the highest compatibility
    with the .NET 4.5 and .NET 4.6 frameworks. In addition, F# 4.0 is the closest
    work in progress to the future release of F#, which will provide support for .NET
    Core.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，FsUnit支持F# 3.1和F# 4.0。但建议使用FsUnit与F# 4.0一起使用，因为这将为你的.NET 4.5和.NET 4.6框架提供最高的兼容性。此外，F#
    4.0是与F#未来发布最接近的工作版本，它将为.NET Core提供支持。
- en: The FsUnit GitHub repository is available at [https://github.com/fsprojects/FsUnit](https://github.com/fsprojects/FsUnit).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: FsUnit的GitHub仓库可在[https://github.com/fsprojects/FsUnit](https://github.com/fsprojects/FsUnit)找到。
- en: Summary
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You learned that you can measure performance quantitatively and qualitatively.
    Although it is easier to have quantitative measurement than qualitative measurement,
    it is quite straightforward and common to have quantified data as a foundation
    to have qualitative analysis.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解到你可以从定性和定量两个方面来衡量性能。尽管定量测量比定性测量更容易，但将量化数据作为定性分析的基础是非常直接和常见的。
- en: With the help of .NET tooling ecosystem and libraries available at our disposal,
    we can ensure the objectiveness of our performance measurement. It is also recommended
    to have a basic understanding of .NET CLR memory management as our foundation
    to have performance measurement from the perspective of qualitative analysis.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET工具生态系统和可用库的帮助下，我们可以确保我们的性能测量是客观的。同时，建议对.NET CLR内存管理有一个基本的了解，作为我们进行性能测量的基础，以便从定性分析的角度进行。
- en: We will start exploring the aspects of performance optimizations with the knowledge
    and concept in this chapter, starting from F# data structures in [Chapter 3](fsp-hiperf_cu03.html#aid-NQU22
    "Chapter 3. Optimizing Data Structures"), *Optimizing Data Structures*.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用本章的知识和概念开始探索性能优化的各个方面，从[第3章](fsp-hiperf_cu03.html#aid-NQU22 "第3章。优化数据结构")中的F#数据结构，即*优化数据结构*开始。
