- en: '*Chapter 12*: NavMesh, Timeline, and a Mock Test'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to cover two main functionalities that Unity offers
    developers for issuing **AI** to our game objects and for animation that supports
    logic.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Unity has a ready-made system for our game objects to issue a path-finding algorithm
    where a game object can be given an area to patrol. This can be very handy in
    a series of games that use enemy soldiers to walk up and down a corridor looking
    for the player. A soldier can react depending on the behavior given to them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The other functionality we will be covering is the **Timeline** component, which
    is used for animation in scenarios such as cutscenes in games/films. You may be
    thinking that we already covered an animation system back in [*Chapter 4*](B18381_04_Epub.xhtml#_idTextAnchor087),
    *Applying Art, Animation, and Particles*. Yes, you are right, but for a more complex
    animation that holds multiple game objects and animations, transitions and states
    can get complex pretty easily. Also, Timeline supports a series of tracks that
    work specifically with our code, and we can add our own custom animation tracks
    to our timeline.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: These two main features will be assigned to our Killer Wave game project. The
    **Navigation Mesh** (**NavMesh**) controls a flock of small **Non-Player-Character**
    (**NPC**) robots that will move away from our player's ship as if they're panicking
    to stay alive.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Timeline will be used to apply a mid-level cutscene where our player will see
    the end-of-level boss rush past them and lights in the scene will flash red.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will end this chapter with the last mini-mock test, which will include
    questions covering the content from this chapter and previous ones.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the final scene
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing AI with NavMesh
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the timeline
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the timeline
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by reviewing what skills are covered in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The core exam skills covered in this chapter
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Programming core interaction*:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Implementing behaviors and interactions of game objects and environments
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying methods to implement camera views and movement
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working in an art pipeline*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowledge of materials, textures, and shaders: The Unity rendering API'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Knowledge of lighting: The Unity lighting API'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Knowledge of two-dimensional and three-dimensional animation: The Unity animation
    API'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Programming for the scene and environment design*:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Determining scripts for pathfinding with the Unity navigation system
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project content for this chapter can be found at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: You can download the entirety of each chapter's project files at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: All the content for this chapter is held in the chapter's `unitypackage` file,
    including a `Complete` folder that holds all of the work we'll carry out in the
    chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the *Code in Action*: [https://bit.ly/3LsC0B4](https://bit.ly/3LsC0B4).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the final scene
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to prepare our new `level3` scene in two parts
    – the first part of our game will have some three-dimensional art assets for the
    player to potentially collide with. Also, the environment will be used for our
    new fleeing enemies. The second part of this section is used to upgrade our camera's
    behavior so that instead of it being static, we now require it to move across
    the level. The player will also be given the same fixed speed as the camera.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this section, we will have an environment set up, as shown in
    the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Our third level assets'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.01_B18381.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.1 – Our third level assets
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: The arrow going from left to right in the previous screenshot shows the path
    of the camera. Once it reaches a particular point, it will stop, and the level
    will end shortly after.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that within the `level3Env` prefab is a game object that
    holds a script called `BossTrigger`. This game object contains a box collider,
    a rigid body, and a `BossTriggerBox` script.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the `BossTrigger` game object is to activate the `BossTrigger`
    collider. We will discuss this further in the *Exploring the timeline* section
    of this chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue by moving our `level3` file''s environment into the scene:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: From the `Assets/Scene` and double-click on the `level3` scene file.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Assets/Prefab`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag the `level3Env` prefab into the `_SceneAssets` game object in
    the **Hierarchy** window.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `level3Env` from the `2500`, `17`, and `-24`
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`0.55`, `0.55`, and `0.55`'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows our scene setup, which is ready for our player
    to fly into:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – The level 3 assets in place'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.02_B18381.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.2 – The level 3 assets in place
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: So, we need to make some changes to our `level3` scene so that it acts in a
    way that ensures the camera supports the new environment and the environment itself
    doesn't have extra assets that we don't need, such as the animating texture quad
    for the background and the prefab particle system for the stars flying past. Be
    aware, if any of these game objects are in a prefab state, be sure to unpack (right
    click game object in **Hierarchy** **Prefab | Unpack**) them otherwise we will
    be changing the content in levels 1 and 2.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Alter the `level3` scene in the **Hierarchy** window by doing the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, the aforementioned two assets sit within the `GameSpeed` game object
    in the `GameSpeed` game object.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We won't be using any directional lighting in our scene, so also remove `Directional
    Light` from the **Hierarchy** window.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, for the sake of running our `level3` scene without going through the entire
    game loop, we can drop our `GameManager` prefab from the `Assets/Prefab` folder
    location into the **Hierarchy** window.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our `level3` will now look like the one in the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Our Hierarchy layout so far'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.03_B18381.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.3 – Our Hierarchy layout so far
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to make it so that the **Camera** component supports a far clipping-plane
    value. To do this, we need to do the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Select the main camera in the **Hierarchy** window.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `1300`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, we have adjusted the clipping plane of the camera to show all of the `level3`
    file's environment, removed the `GameSpeed` game object that helps art assets
    for our previous levels, and added `GameManager` to `level3` to make development
    easier. We now need to turn our focus toward making the camera actually move instead
    of creating the illusion it is moving, as with `level1` and `level2`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: I have created a small script that will make the camera move from one point
    to another; everything inside the script demonstrates elements of code that we
    have already covered throughout this book. So, there's no need for you to create
    the script, but understanding it is obviously the main purpose.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to attach the script to the main camera in our scene to control
    its movement. Follow these instructions:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Select the main camera from the **Hierarchy** window.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `CameraMovement` until you see the script appear in the dropdown.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **CameraMovement** script.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on `box collider` into the drop-down list. When it appears, select it
    and check its **Is Trigger** box.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In brief, this script will translate along its *x* axis after 6 seconds when
    active. When the script reaches a particular point, it will stop; it will also
    make sure that the player stops traveling with it.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s modify our `Player` script to act on the movement of the camera for
    `level3`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Script` and double-click on the `Player` script to open it.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `Player` script, at the top where we have our global variables,
    enter the private variable and its property:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `camTravelSpeed` variable that we just entered will be used as an extra
    multiplier to set the pace of the player's ship when the camera moves along the
    *x* axis.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: The second variable, `movingScreen`, will hold the result of `Time.deltaTime`
    multiplied by `camTravelspeed`. Later, `movingScreen` will be used when it comes
    to comparing the player's ship's *x* axis.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Start` function, add the following line at the bottom of its function:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Inside the `Start` function, we will add our `width float` measurement to `movingScreen`
    (this happens after `width` has been updated in the `Start` function), as this
    will be the starting position before it receives its increments from `Time.deltaTime`
    and `camTravelspeed`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Still inside the `Player` script, scroll down to the `Movement` method.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the `Movement` method, enter the following code, which will multiply
    our player''s ship''s speed:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the code that we've just entered, we will run a check to see whether `camTravelSpeed`
    has increased from our new `CameraMovement` script. If `camTravelSpeed` has been
    updated, we fall into the scope of the `if` statement.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Within the `if` statement, we will increment the player's ship's *x* axis to
    the right, multiplied by `Time.deltaTime` and `camTravelSpeed`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: The second thing we do is add the `movingScreen` value that originally holds
    the current `width` of our playing area. However, because the screen is moving,
    we need to increment the playing area so that the player doesn't get left behind
    or go too far out of the camera view.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: The last amendment we add to our `Player` script is our horizontal movements,
    still in the `Movement` method.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll down until you get to where the player can press the *right arrow* to
    move (`Input.GetAxisRaw("Horizontal") > 0`). Within the scope of the `if` statement,
    we can amend the second `if` statement to the following:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If the player presses the *right arrow* on their keyboard/joypad, we can run
    a check to see whether the player's *x* axis is less than the `movingScreen` float
    value; plus, we will include a buffer to push the player further to the edge of
    the screen.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then do the same for when the player presses the *left arrow* on the
    keyboard/joystick within the second `if` statement:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Similar rules apply where we make use of the `movingScreen` variable, which
    is constantly incremented along with a slight buffer to keep our player's ship
    within the game screen.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Save the `Player` script.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we move on to the next script, we need to uncomment two lines of code
    in our new `CameraMovement` script so that it can interact with the `Player` script.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the `CameraMovement` script and uncomment the two following lines by
    removing `//`. The first line to uncomment is the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The second line to uncomment is the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, these two lines of code can alter the speed of the player ship.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to update our `GameManager` script so that it recognizes the difference
    between `level1`, `level2`, and `level3`, which has a moving camera.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s move to the `GameManager` script and add two main elements – the
    camera speed and noticing the difference between scenes. Let''s start by opening
    the `GameManager` script:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: From the `Assets/Script`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the `GameManager` script to open it in your IDE.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may or may not have looked into the `CameraMovement` script that we attached
    to the main camera, but inside that script is a variable called `camSpeed`. This
    variable manipulates the camera's speed; in our `GameManager` script, we set the
    speed of the main camera.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The main takeaway from this is that the `CameraMovement` script will manipulate
    the camera's speed from what is set in the `GameManager` script.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: In the `GameManger` script, scroll down to the method titled `CameraSetup`.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are going to make this method take a variable to alter the camera''s speed.
    Change the `CameraSetup` method to take a `float` value in its parameter. The
    `CameraSetup` method will first look as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It will then change to this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Within the `CameraSetup` method, we need to transfer `camSpeed` to the new
    `CameraMovement` script:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the line of code we add to our `CameraSetup` method needs to be added
    after the main camera has been stored in a `gameCamera` variable. Before continuing
    we also need to remove the reference to the `CameraSetup` from the `PlayerSpawner`
    script as we also don't need this anymore.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Open the `PlayerSpawner` script.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scroll to the bottom and remove: `GameManager.Instance.CameraSetup()`.'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the script and return to the `GameManager` script.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last thing to do in the `GameManager` script is to update the `LightandCameraSetup`
    method so that when the `CameraSetup` method within it is called, it takes a value
    that sets the main camera's speed. So, in `level1` and `level2`, we want the camera
    to continue to not move; in `level3`, we will need to apply speed to the camera.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Within `LightandCameraSetup`, replace its original `switch` statement with
    the following:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So, before, our `switch` statement had all the cases run `LightSetup` and `CameraSetup`
    within cases `3`, `4`, and `5`. But now, in the previous code, we have split the
    roles up. In cases `3` and `4`, we run `LightSetup` as usual, and now, because
    `CameraSetup` now takes a `float` value, we set the camera speed to `0`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: In case `5`, which is the build number for our `level3` scene, we ignore `LightSetup`,
    as we won't be using a directional light in this scene. We run `CameraSetup` but
    give it a value of `150`, which will also be the speed we set the `camSpeed` variable
    within the method.Save the `GameManager` script.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Press `level3` scene plays out. The following screenshot shows what we have
    so far:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Level 3 in Play mode'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.04_B18381.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.4 – Level 3 in Play mode
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous screenshot shows a series of events of what happens after we press
    **Play** in the Unity Editor Let''s go through each event sequentially:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The `level3` scene before pressing **Play** (denoted by **1.**).
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scene is in play mode and sets up the camera position and background (denoted
    by **2.**).
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The UI for the level is animated, and the enemies start floating into the game
    window (denoted by **3.**).
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player enters the level, and the scene pauses for a few seconds before the
    player gets control of their ship (denoted by **4.**).
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The camera begins to move along with the radar camera, following the progress
    of the player and the oncoming enemies (denoted by **5.**).
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will add our second enemy type (flee enemy), which will
    flee across the span of our new art.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Developing AI with NavMesh
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to introduce a new enemy that will attempt to
    flee with frenzy-type behavior from our player's ship. This enemy's behavior will
    be implemented with the use of Unity's built-in `NavMesh` functionality.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: As you can imagine, this built-in feature from Unity can answer a lot of problems
    with regard to games with NPCs, similar to ones in the Metal Gear Solid game,
    where the player has to sneak around and not get detected by the enemy soldiers.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '`NavMesh` gives the enemy soldiers a path to walk around, and then if they
    see the player, their behavior changes from `Patrolling` to `Attack`.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: So, with our game, we are going to implement `NavMesh` but make it so that our
    enemies react differently to how they would in *Metal Gear Solid*. We will add
    multiple flee enemies in clusters to our third-level scene. This chaotic, distracting
    behavior will make the final level more challenging for our players.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows our fleeing enemy with a cylindrical radius
    around it. This radius is called the agent radius and can be altered to stop other
    obstacles and enemies from intersecting with each other:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Fleeing enemies'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.05_B18381.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.5 – Fleeing enemies
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Before we add these fleeing enemies to our scene, we need to tell the fleeing
    enemies where they can move around by baking a NavMesh first.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to select the game object that we will use to bake, which also
    means we need to deselect game objects that don''t need to be **Navigation Static**.
    To bake a NavMesh, follow these instructions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: From the `_SceneAssets` game object.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `_SceneAssets`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows `_SceneAssets` selected and the static dropdown
    (denoted by **1.**), followed by **Navigation Static** being unticked (denoted
    by **2.**):'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Unticking Navigation Static'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.06_B18381.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.6 – Unticking Navigation Static
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: A window pops up asking whether we want to apply the changes to all the child
    objects. Select **Yes, change children**.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, we have just deactivated all of our environment art assets in the `level3`
    scene so that they are not recognized for navigation baking. We now need to turn
    on one of the child game objects within the `_SceneAssets` hierarchy:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'From the `corridorFloorNav`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`_SceneAssets`'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level`'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`corridorFloor`'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows that from the `corridorFloorNav` (denoted by
    **1.**):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: With `corridorFloorNav` selected, make sure its **Mesh Renderer** component
    is ticked in the **Inspector** window (denoted by **2.**).
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, select **Navigation Static** for this game object (denoted by **3.**):'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.7 – Turning on the ''corridorFloorNav'' game object, Mesh Renderer,
    and the ''Navigation Static'' layer'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.07_B18381.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.7 – Turning on the 'corridorFloorNav' game object, Mesh Renderer,
    and the 'Navigation Static' layer
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: We now need to check the `CorridorFloorNav` mesh.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Select **Window** at the top of the Unity Editor and then click on **AI | Navigation**.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It''s likely that the **Navigation** window will appear at the top-right corner
    of the Editor If it doesn''t and has appeared as a floating window somewhere in
    the Unity Editor simply click and hold on the **Navigation** tab and dock it next
    to the **Inspector** tab, as in the following screenshot:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – The Navigation window'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.08_B18381.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.8 – The Navigation window
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: In the **Navigation** window, click on the **Bake** button at the top to give
    us our **Navigation** bake options.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Information
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It's also worth noting that a game object that is manipulated in the NavMesh
    is referred to as an agent.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In this window, we are presented with a series of options for our navigation
    bake. This may look a little intimidating at first, but the blue cylinder is basically
    our agent (the fleeing enemy) and the following parameters are based on how flexible
    our agent is with the navigation path it''ll be walking around. Let''s briefly
    go through each of the options so that we are aware of its features before we
    bake:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '**Agent Radius**: This will create an invisible shield around our agent so
    that they can''t clip into other agents, walls, doors, and so on.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Agent Height**: Similar to **Agent Radius**, this gives our agent an invisible
    height; this can be useful for the game object that the NavMesh is manipulating
    to pass through doors.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max Slope**: We can alter, in degrees, how much of a slope our agent can
    walk up.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step Height**: This is similar to the **Max Slope** property, but in this
    case, this controls how much our agent is allowed to move up a step/stair.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Drop Height**: Enter a value for the maximum height the character can drop
    down from (associated with the **Off Mesh Link** component).'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jump Distance**: This specifies the value for the jump distance between the
    character and the object (associated with the **Off Mesh Link** component).'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further Information
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Information about the **Off Mesh Link** component can be found at [https://docs.unity3d.com/Manual/class-OffMeshLink.html](https://docs.unity3d.com/Manual/class-OffMeshLink.html).
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Manual Voxel**: A voxel is a three-dimensional measurement that is used to
    scale the accuracy of our navigation bake.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Voxel Size**: If the **Manual Voxel** option is ticked, this means we can
    give each agent tighter precision. The lower the number, the more accurate our
    agent will be; note that this will make the NavMesh take longer to bake.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Min Region Area**: This specifies a minimum area that a surface must have
    for it to be included in the NavMesh.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Height Mesh**: This checkbox will create a height mesh, which will improve
    the movement accuracy. This will also make navigation baking slower.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the navigation bake settings we just went through:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9 – The Navigation window with the ''Bake'' tab selected'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.09_B18381.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.9 – The Navigation window with the 'Bake' tab selected
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, the **Bake** properties of our default setup window will work just
    fine as it is.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Bake** button at the bottom right of the **Navigation** window
    and wait until the meter at the bottom-right corner of the Editor completes, as
    shown in the following screenshot:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.10 – Exporting Tiles for your NavMesh'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.10_B18381.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.10 – Exporting Tiles for your NavMesh
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Once the navigation bake has completed, `corridorFloorNav` in our **Scene**
    window will have a NavMesh sitting on top of its mesh.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'If you can''t see the navigation-baked mesh, make sure that the **Show NavMesh**
    checkbox is ticked at the bottom-right corner of the mesh. The following screenshot
    shows our NavMesh and the **Navmesh Display** box:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.11 – Our navigation mesh and its display at the bottom-right corner
    of the ''Scene'' window'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.11_B18381.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.11 – Our navigation mesh and its display at the bottom-right corner
    of the 'Scene' window
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: The last thing to do in this section is turn off the `corridorFloorNav` game
    object's **Mesh Renderer** component. We only needed this component to be active
    for the NavMesh to be baked.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'To turn off the `corridorFloorNav` game object''s **Mesh Renderer** component,
    do the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Select the `corridorFloorNav` game object in the **Hierarchy** window.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** window, uncheck the **Mesh Renderer** component.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the highlighted box that needs unchecking:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12 – Unticking the ''corridorFloorNav'' mesh'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.12_B18381.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.12 – Unticking the 'corridorFloorNav' mesh
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: This is all that is needed to allow our fleeing enemies to move around.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Further Information
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to find out more about the **Navigation** window, check out
    [https://docs.unity3d.com/Manual/Navigation.html](https://docs.unity3d.com/Manual/Navigation.html).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: So far in this section, we have discussed the requirements of AI and how it
    is used in games and how we are going to apply such methods to our fleeing enemies,
    with the use of the `NavMesh` system that Unity offers as standard.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our NavMesh baked for our agents to move around on, we can
    look into setting up our `NavMeshAgent` component to give our agents a set speed,
    acceleration, stopping distance, and more in the next section.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Customizing our agents – NavMeshAgent
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will be continuing from setting up our NavMesh but shifting
    the focus toward the agent (the fleeing enemy game object). The agent will be
    moving around the baked NavMesh.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: It is necessary for the fleeing enemy game object to be able to react and move
    within the NavMesh but also be able to move in a way that suits the behavior of
    what we're trying to achieve. For example, the enemy is to flee with an element
    of panic; so, we need to consider characteristics such as when the enemy decides
    to move, how quickly the enemy will react, and how fast the enemy can move. These
    properties, and more, come from a component called `NavMeshAgent`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '`NavMeshAgent` is a required component that will be attached to each of the
    fleeing enemy game objects. The purpose of this component is to make it so that
    the game object is recognized as an agent and will stick to the NavMesh.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add `NavMeshAgent` to the fleeing enemy, we need to create a prefab
    of the enemy so that we have a place where we can grab and clone copies of multiple
    enemies:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: From the `Assets/Model` folder and drag `enemy_flee.fbx` to the bottom of the
    **Hierarchy** window.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag `enemy_flee` from the `Assets/Prefab/Enemies`. When the window pops up
    asking if you want a variant or original. Pick original. As there is only one
    type of this enemy.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That''s our fleeing enemy created; now, we can apply a material to it by doing
    the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `Assets/Prefab/Enemies` folder and select the `enemy_flee` prefab.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Inspector** window, select the remote button of the **Mesh Renderer**
    component (denoted by **1**. in the following screenshot).
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A dropdown will appear. Type `darkRed` in the search bar at the top if you can't
    see the material on the list.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on `darkRed` from the dropdown (denoted by **2.** in the following).
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, make sure that the `0` value and that the `1`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `enemy_flee` prefab with its update material
    and the correct **Transform** values:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13 – Adding the ''darkRed'' material to the ''enemy_flee'' Mesh
    Renderer Materials slot'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.13_B18381.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.13 – Adding the 'darkRed' material to the 'enemy_flee' Mesh Renderer
    Materials slot
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed in the previous screenshot that `enemy_flee` has hard,
    shiny edges. We can make these appear smoother in our three-dimensional model
    import settings by doing the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: From the `Assets/Model` folder and select `enemy_flee`.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** window, change the property value for **Normals** from
    **Import** to **Calculate**.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can now adjust the **Smoothing Angle** value with the slider to change the
    smoothness between angles, as shown in the following screenshot:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14 – Smoothing the edges of our enemy'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.14_B18381.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.14 – Smoothing the edges of our enemy
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: In the previous screenshot, you can see three distinct stages in making the
    model look smoother. This can be done with any three-dimensional model imported
    into Unity.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你可以看到制作模型看起来更平滑的三个不同阶段。这可以通过任何导入到Unity中的三维模型来完成。
- en: Once you're happy with the **Smoothing Angle** value, click on **Apply** at
    the bottom-right corner of the **Inspector** window.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你对 **平滑角度** 值满意，点击 **检查器** 窗口右下角的 **应用**。
- en: 'Coming back to `enemy_flee` in the **Hierarchy** window, as this is an enemy,
    we also need to give it an **Enemy** tag so that the player recognizes it as such
    if and when they collide with each other:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 **层次** 窗口的 `enemy_flee`，因为这是一个敌人，我们还需要给它一个 **敌人** 标签，以便玩家在碰撞时能识别它：
- en: Click on the **Tag** parameter at the top of the **Inspector** window.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **检查器** 窗口顶部的 **标签** 参数。
- en: Select **Enemy**.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **敌人**。
- en: 'The following screenshot shows the `enemy_flee`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 `enemy_flee`：
- en: '![Figure 12.15 – Our enemy being given an ''Enemy'' tag'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.15 – 我们正在给敌人添加一个“敌人”标签'
- en: '](img/Figure_12.15_B18381.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.15 – 我们正在给敌人添加一个“敌人”标签'
- en: Figure 12.15 – Our enemy being given an 'Enemy' tag
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15 – 我们正在给敌人添加一个“敌人”标签
- en: 'We are now ready to apply `NavMeshAgent` to the `enemy_flee` game object. With
    `enemy_flee` still selected, do the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好将 `NavMeshAgent` 应用到 `enemy_flee` 游戏对象上。在 `enemy_flee` 仍然被选中时，执行以下操作：
- en: Click on the **Add Component** button in the **Inspector** window.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **检查器** 窗口中点击 **添加组件** 按钮。
- en: A drop-down list will appear. Type in `nav` and select `NavMeshAgent` from the
    list.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将出现一个下拉列表。输入 `nav` 并从列表中选择 `NavMeshAgent`。
- en: '`enemy_flee` now has `NavMeshAgent` attached to it. As previously mentioned,
    let''s go through each of the properties. The following screenshot also shows
    the `NavMeshAgent` default values (these may differ from your default values,
    but don''t be concerned, as we will be changing the majority of the values):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`enemy_flee` 现在已附加了 `NavMeshAgent`。如前所述，让我们逐一查看每个属性。以下截图也显示了 `NavMeshAgent`
    的默认值（这些值可能不同于您的默认值，但请放心，我们将更改大多数值）：'
- en: '![Figure 12.16 – The ''Nav Mesh Agent'' component (its own default values –
    ignore them)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.16 – “导航网格代理”组件（其默认值 – 忽略它们）'
- en: '](img/Figure_12.16_B18381.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.16 – “导航网格代理”组件（其默认值 – 忽略它们）'
- en: Figure 12.16 – The 'Nav Mesh Agent' component (its own default values – ignore
    them)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16 – “导航网格代理”组件（其默认值 – 忽略它们）
- en: '**Agent Type**: By default, there is only one agent type. This holds a preset
    of the name of the agent, the radius, height, step height, and max slope. To find
    out more about these values, check the previous section.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理类型**：默认情况下，只有一个代理类型。这包含代理名称、半径、高度、步高和最大坡度的预设。要了解更多关于这些值的信息，请查看前面的部分。'
- en: '**Base Offset**: This will change the placement of the agent mesh, which wraps
    around the fleeing enemy in the form of a cylinder that can only be seen in the
    **Scene** window.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础偏移**：这将改变代理网格的位置，它以圆柱的形式围绕逃跑的敌人，只能在 **场景** 窗口中看到。'
- en: '**Speed**: The maximum speed value, based on world units per second.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：基于每秒世界单位的最大速度值。'
- en: '**Angular Speed**: Sets how quickly the agent can rotate in degrees per second.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角速度**：设置代理每秒旋转的度数。'
- en: '**Acceleration**: Maximum acceleration based on world units per second squared.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加速度**：基于每秒平方世界单位的最大加速度。'
- en: '**Stopping Distance**: Agents will stop when they are at a particular measurement.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止距离**：代理将在达到特定测量值时停止。'
- en: '**Auto Braking**: The agent will slow down gradually before reaching a complete
    stop.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动制动**：代理在完全停止之前会逐渐减速。'
- en: '**Radius**: The agent''s spatial area will increase the scale of the agent
    cylinder.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半径**：代理的空间区域将增加代理圆柱的缩放比例。'
- en: '**Height**: This will increase the height of the agent''s cylinder.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高度**：这将增加代理圆柱的高度。'
- en: '**Quality**: The ranges of the accuracy of obstacle avoidance.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量**：障碍物避免的精度范围。'
- en: '**Priority**: Agents of a lower priority will be ignored by this agent when
    performing avoidance.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先级**：在执行规避时，此代理将忽略优先级较低的代理。'
- en: '**Auto Traverse Off Mesh Link**: If you want the agent to move between gaps,
    keep this checked; otherwise, custom animation will move the agent across the
    gap.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动穿越网格链接**：如果您想让代理在缝隙之间移动，请勾选此选项；否则，自定义动画将使代理穿越缝隙。'
- en: '**Auto Repath**: If the agent is no longer on the path they are walking, with
    this option checked, they will try and make their way back to the nearest point.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动重规划路径**：如果代理不再在它们正在走的路径上，勾选此选项后，它们将尝试回到最近的点。'
- en: '**Area Mask**: With navigation baking, we can set which area this agent belongs
    to.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `NavMeshAgent`, we will set its agents to a high speed, rotation, and acceleration
    value to make these enemies react fast to match their fleeing behavior.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `NavMeshAgent` values for the `enemy_flee` prefab to the ones shown
    in the following screenshot. However, it''s recommended to change and alter the
    values to make the enemies behave differently. Theres no wrong approach. But as
    a guide, match the ones in the following screenshot:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_12.17_B18381.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
- en: Figure 12.17 – 'Nav Mesh Agent' with set values
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Click **Overrides | Apply All** at the top-right corner of the **Inspector**
    window to confirm your prefab changes.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we created the fleeing enemy prefab and gave it a material.
    We also applied a `NavMeshAgent` component to our enemy so that it's calibrated
    and ready to react.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows what the fleeing enemy looks like with its `NavMeshAgent`
    component wrapped around it, which can only be seen in the **Scene** window:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.18 – Our enemy with its NavMeshAgent collider wrapped around it'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.18_B18381.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.18 – Our enemy with its NavMeshAgent collider wrapped around it
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will give the fleeing enemy prefab a collider so that
    when the player makes contact with it, the player and the enemy are destroyed
    with the soon-to-come scripting.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Adding a capsule collider to our fleeing enemy
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we are going to add a capsule collider to the fleeing enemy
    so that a collision can be detected from the player''s ship when they collide
    with each other:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: With the `enemy_flee` prefab still selected, scroll down to the bottom of the
    **Inspector** window and click on **Add Component**.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start typing `Capsule` into the drop-down window until you see **Capsule Collider**.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Capsule Collider** from the drop-down list. The fleeing enemy will
    now have a capsule collider wrapped around them.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, tick the **Is Trigger** checkbox in the **Capsule Collider** component.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `enemy_flee` prefab's settings.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `enemy_flee` game object in **Hierarchy** and delete it.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows `enemy_flee` with its capsule collider; these
    values may differ to yours:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.19 – ''enemy_flee'' with its capsule collider'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.19_B18381.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.19 – 'enemy_flee' with its capsule collider
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: The fleeing enemy is nearly ready to be tried out in the game. We just need
    to add a script to tell the game object what to do when it gets within a certain
    distance of the player. We will cover this in the next section.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Creating our fleeing enemy script
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will be making it so that the fleeing enemy detects when
    the player is getting close to them. If the player is too close, we will make
    it so that the enemy begins to flee.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be taking a script that is partially made and import it into this chapter,
    as the majority of the `EnemyFlee` script will contain a similar setup to the
    previous enemy that we made in [*Chapter 2*](B18381_02_Epub.xhtml#_idTextAnchor048)*,
    Adding and Manipulating Objects*. Follow these steps:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: From the `Assets/Script`.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the `EnemyFlee` script to begin adding its navigation code.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `EnemyFlee` script will contain similar-looking code to the `EnemyWave`
    script. The enemies in our game will carry the same properties, such as giving
    and taking damage when hit or dying, detecting a collision, and inheriting their
    own scriptable object asset. There's no real need to go through this process again.
    What we are interested in is how the `enemy_flee` game object acts.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the fleeing behavior to the `EnemyFlee` script, we need to do the following:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the script, add the AI library to give our script access to the
    **Navigation Agent** files:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In our script, we will need access to the `NavMeshAgent` component (which is
    attached to our `enemy_flee` game object). The AI library gives us this functionality.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll down in the script to where our global variables are (`health`, `travelSpeed`,
    `fireRate`, and so on) and add the following variables that we will be using with
    our navigation setup:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first variable will be used to store the reference to the player's ship,
    as we will be comparing its distance later on. The `bool` value will be used as
    part of a delayed start for our script. We will talk more about this later on
    as well.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '`enemyDistanceRun` will be used as a rule to "act" within the measured distance
    between the player and our fleeing enemy. We have also added the `SerializeField`
    attribute to this, as it will be handy to change these values in the **Inspector**
    window while keeping this variable private. Do try a different value if you think
    200 is too low. Experiment!'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have `NavMeshAgent`, which will be required to receive data from
    the player and fleeing enemy results.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Start` function that will require a short delay to get a reference
    from the player ship. Enter the following code. We will go through each step to
    see why there is a delay and the standard `ActorStats` method:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `Start` function contains the `ActorStats` method, which will update our
    enemy's abilities (the health value, points added to the score, and so on), similar
    to our `enemy_wave` game object. We will also run an `Invoke` function, which
    takes the name of the method we wish to run along with a parameter that determines
    when the method will be run.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: We are running a short `0.5f` second delay, giving the player's ship time to
    be instantiated into the scene before we take a reference from it. We set a Boolean
    value to `true` to say that the `update` function can run the content within it,
    which we will cover shortly. The final thing we do is take reference from the
    `NavMeshAgent` component attached to the game object.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: We need to add a slight amendment to our speed value in our `ActorStats` method.
    Because we are affecting `NavMeshAgent_speed`, we need to manipulate this directly.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the enemies'' speed adjustable, add the following line of code within
    `ActorStats` of the `EnemyFlee` script:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The enemy flee speed value is now hooked up.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on to the last piece of our code, the `Update` function will be measuring
    and reacting to and from the distance of our fleeing enemy and the player. Enter
    the following `Update` function and its content, and we will go through each step:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the `Update` function, we will run an `if` statement to check whether the
    `gameStarts` Boolean value is `true`; if it is `true`, we then check to see whether
    `player_ship` is still in the scene. And if that is `true`, we move on to the
    content in that `if` statement. Within this `if` statement, we use `Vector3.Distance`
    to measure the distance between the player's ship and the fleeing enemy. We then
    store the measurement as a `float` value called `distance`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Next, we run a check to see whether the distance measured is less than the `enemyDistanceRun`
    value, which is currently set to `200`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: If the `distance` variable's value is lower, then that means the player's ship
    is too close to the fleeing enemy, so we run the following steps for it to react.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Store the `Vector3` variable, which minuses the player's position from our own.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then add this `Vector3` variable to the fleeing enemy's `newPos` position
    of `Vector3`, which will be the direction for the enemy flee to run in.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we send this `newPos` position to `NavMeshAgent`.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save the `EnemyFlee` script.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are now ready to attach the `EnemyFlee` script to our `enemy_flee` prefab.
    Let''s do this now; then, we will be able to test the results:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Back in the Unity Editor navigate to the `Assets/Prefab/Enemies` folder in the
    **Project** window.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `enemy_flee` prefab.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `EnemyFlee`.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Enemy Flee` script from the drop-down list.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `BasicFlee_Enemy`, and then store it in `Assets/ScriptableObject`.
    Drag the Actor into the Actor Model area of the `EnemyFlee` script in the **Inspector**
    window, as shown in the following screenshot.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the scriptable object asset for the `EnemyFlee`
    script''s **Actor Model** parameter on the right:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.20 – The ''enemy_flee'' game object holding its ''EnemyFlee'' script
    and updated fields'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.20_B18381.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.20 – The 'enemy_flee' game object holding its 'EnemyFlee' script and
    updated fields
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: We now need to make our `enemy_flee` script recognizable on the radar map in
    the game HUD, as with the `enemy_wave` game object. As a reminder, we made a `radarPoint`
    object before in [*Chapter 9*](B18381_09_Epub.xhtml#_idTextAnchor161), *Creating
    a 2D Shop Interface and In-Game HUD*. So, in this chapter, we're going to speed
    things up and use a ready-made `radarPoint` object to attach to the `enemy_flee`
    game object. The only difference with the ready-made `radarPoint` game object
    is that I have attached a small script called `RadarRotation` that will make the
    `radarPoint` sprite always face the camera, regardless of which rotation the `enemy_flee`
    game object makes.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: The `RadarRotation` script takes the current rotation in the `Awake` function,
    followed by reapplying the rotation on `LateUpdate`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: What Is LateUpdate?
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '`LateUpdate` is the last function called in Unity''s execution order game logic.
    The benefit to this is that there is no fighting between the rotation of the `radarPoint`
    object and the `enemy_flee` rotation being called at the same time. If you would
    like to learn more about the execution order, check out [https://docs.unity3d.com/Manual/ExecutionOrder.html](https://docs.unity3d.com/Manual/ExecutionOrder.html).'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'To attach the pre-made `radarPoint` object to the `enemy_flee` prefab, we need
    to do the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Back in the `enemy_flee` prefab from `Assets/Prefab/Enemies` into the **Hierarchy**
    window.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop the `radarPoint` object from `Assets/Prefab/Enemies` onto the
    `enemy_flee` prefab in the **Hierarchy** window.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, drag and drop the `RadarRotation` script from `Assets/Script` into the
    `enemy_flee` `radarPoint` object point toward the camera.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once applied, select the `enemy_flee` prefab from the **Hierarchy** window,
    and then click on **Overrides | Apply All** at the top-right corner of the **Inspector**
    window.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `enemy_flee` prefab holding the `radarPoint`
    object, along with the `radarPoint` object in the **Inspector** window, as a reference
    to help avoid any errors:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.21 – The ''radarPoint'' game object and its Transform property
    values'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.21_B18381.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.21 – The 'radarPoint' game object and its Transform property values
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `enemy_flee` prefab is now ready to be trialed out in `enemy_flee` from
    its current location to the `_Enemies` game object in the `enemy_flee` now is
    in the **Hierarchy** window:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.22 – The ''Enemies'' game object children in the Hierarchy window'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.22_B18381.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.22 – The 'Enemies' game object children in the Hierarchy window
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the `enemy_flee` prefab to somewhere near the start of the level. I have
    placed mine at the following **Transform** values:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.23 – The ''enemy_flee'' game object placement in level 3'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.23_B18381.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.23 – The 'enemy_flee' game object placement in level 3
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: If you also have the `EnemySpawner` object in the scene close to the start of
    the level, push it back along the *x* axis as far as `1000` to get it out of the
    way.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Click the `enemy_flee` object should now start panicking and moving around to
    try and escape from you!
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Feel free to select the `enemy_flee` object in the **Hierarchy** window and
    press *Left* + *Ctrl* (*Command* on macOS) + *D* on your keyboard to spread a
    few fleeing enemies around to make the level more interesting, as shown in the
    following screenshot:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.24 – Duplicated ''enemy_flee'' game objects'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.24_B18381.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.24 – Duplicated 'enemy_flee' game objects
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows our new fleeing enemies trying to escape from
    the player in pure panic!
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.25 – Enemies fleeing from the player!'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.25_B18381.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.25 – Enemies fleeing from the player!
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Save the scene.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's the end of this section, and hopefully, you now feel comfortable with
    this introduction to using the NavMesh and agents. As you can imagine, our fleeing
    enemy could have other events attached to it, such as shooting bullets at the
    player when at a safe distance, taking cover around a corner, and calling for
    help. Adding a series of events to an NPC would require a finite state machine
    to go through each appropriate event.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we introduced a new enemy that acted differently from our current
    wave enemy. We also became familiar with the ready-made path-finding algorithms
    offered by Unity, such as `NavMesh`.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: We are going to move on to the next section, where we will introduce the timeline,
    which works as an animator but can also be used with regard to blending the logical
    behavior with our components – for example, to make a light blend into a different
    color by using scripting.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the timeline
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Timeline** is a component in the Unity Editor that is intended to put a sequence
    of animations together, which is attractive to industries such as film and TV.
    **Timeline** is also welcomed in games that may have cutscenes to help tell a
    story or introduce a player to a level. Unity also has two other useful components
    – **Animator Controller** and **Animation** **Clips** – as you will know if you
    have been following this book, as we covered these other components in [*Chapter
    4*](B18381_04_Epub.xhtml#_idTextAnchor087)*, Applying Art, Animation, and Particles*.
    They carry out the same tasks, but as a scene becomes busier with a series of
    individual animation clips, things can get messy quickly in the animator controller,
    with the multiple states transitioning between each other.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the animator controller with multiple states
    and transitions:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.26 – An example of how chaotic Animator Controllers can get'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.26_B18381.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.26 – An example of how chaotic Animator Controllers can get
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '**Timeline** supports three tasks:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Playing animations and clips
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing audio
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turning game objects on or off
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three capabilities on their own limit **Timeline** – for example, if we
    want to change the color of light, **Timeline** wouldn't be able to change the
    individual property alone. To change the color of light, we will need to change
    the light's property values in the **Animation** window itself. However, with
    some extra scripting to our timeline, we can introduce dragging and dropping game
    objects that hold components, such as a light component, where changes can be
    made on the fly.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to start by animating a large robotic craft in
    the timeline. Then, we will discuss playables and how they can extend a timeline's
    functionality. Finally, we will implement additional tracks to the timeline to
    control the color of the lights and fade the level into darkness once the player
    reaches the end of the level.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating our `Timeline` game object and adding a **Timeline**
    component to it in the next section.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Creating a timeline
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to get more familiar with the **Timeline** component
    and create some of our own animations with a large flying robot. When setting
    up the timeline, we will also discuss the components and properties that are involved.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a timeline to our scene, do the following:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: In the Unity Editor's `Assets/Scene`.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on `level3` to load the scene if it isn't loaded already.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click in the **Hierarchy** window and select **Create Empty** from the
    dropdown to create an empty game object.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on `GameObject` twice slowly to rename it.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename `GameObject` `Timeline`.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our `Timeline` game object still selected in the **Hierarchy** window,
    we can now open our **Timeline** window.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the Unity Editor, click on **Window | Sequencing** and then **Timeline**;
    the following screenshot shows this:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.27 – Selecting the ''Timeline'' game object and opening a Timeline
    window'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.27_B18381.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.27 – Selecting the 'Timeline' game object and opening a Timeline window
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s likely that the **Timeline** window will appear in the same window layout
    as your scene, which isn''t ideal, as we want to see our **Scene** while animating.
    To move the **Timeline** window to a better place, click on the name of the **Timeline**
    tag and drag it down to the bottom of the screen, where the **Console** and **Project**
    windows are. The following screenshot shows my current Unity Editor layout proportions:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.28 – Window placements in the Unity Editor'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.28_B18381.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.28 – Window placements in the Unity Editor
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: We can now continue to create our `Timeline` asset, where we will be creating
    our new animations for all of our game objects and their components.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a playable `Timeline` asset, do the following:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: With the `Timeline` game object still selected in the **Hierarchy** window,
    click on the **Create** button in the **Timeline** window.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A window browser will appear to let us select where we want to save our playable
    file.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the `Assets` folder.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the playable file a name (something relevant to what it's going to be used
    for; I'm naming mine `level3`) and click on the **Save** button.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our `Timeline` asset has been created.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: If you have been following along with this book, at first glance, the **Timeline**
    window will likely look like the **Animation** window we saw in [*Chapter 4*](B18381_04_Epub.xhtml#_idTextAnchor087)*,
    Applying Art, Animation, and Particles*. If so, that's good! A good section of
    the controls and methodology will be familiar to you. One of the main differences
    of **Timeline** is that any of the game objects can be dragged into the **Timeline**
    window without needing to have any kind of hierarchical relationship between them.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows our **Timeline** window holding the **Timeline**
    game object in its first **Timeline** track:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.29 – The Timeline window'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.29_B18381.jpg)'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.29 – The Timeline window
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, in the **Inspector** window, our **Timeline** game object has gained
    some extra components. The following screenshot shows two of the added components
    – **Playable Director** and **Animator**:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.30 – The ''Timeline'' game object holding the Playable Director
    and Animator components in the Inspector window'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.30_B18381.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.30 – The 'Timeline' game object holding the Playable Director and
    Animator components in the Inspector window
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: We worked with the **Animator** component in [*Chapter 4*](B18381_04_Epub.xhtml#_idTextAnchor087)*,
    Applying Art, Animation, and Particles*, so for more details about this particular
    component, refer back to that chapter. Also, we don't actually do anything with
    the **Animator** component; it's just a required component for our **Timeline**
    setup.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: The other component we gain when creating a `Timeline` asset file is **Playable
    Director**. It's the responsibility of this component to keep a relationship between
    the timeline and the game objects/components that are being manipulated. So, let's
    go through each of the properties under the **Playable Director** component to
    briefly get a general understanding of them.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: First, we have **Playable**. When we click on the **Create** button in the **Timeline**
    window, we create a **Playable** file. This file holds all of the animations and
    game object/component instances relating to the timeline.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have **Update Method**. This parameter offers four properties that
    control how time affects the timeline. These properties are as follows:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '**Digital Signal Processing** (**DSP**) helps to improve accuracy between our
    timeline and its audio to prevent it from going out of sync.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Game Time**: The time for the timeline will be sourced from the game''s time.
    This also means the time can be scaled (that is, slowed down or paused).'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unscaled Game Time**: This option works the same as the **Game Time** property,
    but it is not affected by scaling.'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manual**: This property uses the clock time we give it through scripting.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we have **Play On Awake**. If this checkbox is ticked, our timeline will
    play as soon as the scene is active.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'The next parameter is **Wrap Mode**. This property determines what happens
    when the timeline has finished playing:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '**Hold**: When the timeline reaches the end, it holds on to the last frame.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loop**: The timeline repeats.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**None**: The timeline plays and then resets.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Initial Time** adds a delay in seconds before the timeline begins.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have **Bindings**. When a game object or component is dragged into
    the **Timeline** window, the **Bindings** list will update and show what object
    is connected to the timeline.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have discussed the timeline and introduced it to our scene. We have
    also gone through the components that are required to make the timeline work.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are more familiar with the timeline and the components that work
    in conjunction with it, in the next subsections, we are going to incorporate our
    large boss ship into our `level3` scene and animate it through the timeline.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the boss game object in our scene
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to take a static UFO-looking game object from
    our imported project files, drop it into the scene, and attach it to the timeline.
    From there, we will animate our UFO so that it spins and moves across the scene
    on two occasions.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'To bring the large boss `UFO` game object into our scene before animating it,
    we need to do the following:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Drag and drop the `boss.prefab` object from `Assets/Prefab/Enemies` into the
    `_Enemies` game object in the **Hierarchy** window.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to position the boss so that it's in our scene but out of view
    of the camera. That way, when it comes to animating the boss in the timeline,
    we can change its position and rotation when required.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Select the `boss` game object in the `0`, `0`, and `-2000`
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`0`, `0`, and `0`'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1`, `1`, and `1`'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `boss` object still selected in the **Hierarchy** window, press *F*
    on your keyboard to see what it looks like in the **Scene** window.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the imported `boss` prefab, which contains a
    list of components and property values:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.31 – The ''boss'' game object tagged as ''Enemy'', positioned with
    the Transform component, and finally, set as a trigger with a scaled radius in
    Sphere Collider'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.31_B18381.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.31 – The 'boss' game object tagged as 'Enemy', positioned with the
    Transform component, and finally, set as a trigger with a scaled radius in Sphere
    Collider
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 'The `boss` object holds the following component and property values, as shown
    in the previous screenshot:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: Tagged as **Enemy** (denoted by **1.**).
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Transform** property values are set to the ones detailed under *step 2*
    (denoted by **2.**).
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`80` (denoted by **3.**).'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BossScript` makes the `boss` game object invincible to the player, and if
    the player makes contact with the boss, the player will die (denoted by **4.**).'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because the `boss` object is an enemy, it has a `radarPoint` object that is
    picked up on the radar (denoted by **5.**).
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we move on to the next section, we need to add a `RadarRotation` script
    to the `radarPoint` game object, which is a child of the `boss` game object. This
    script will make `radarPoint` always face the camera:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: Expand the `boss` content in the **Hierarchy** window.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `radarPoint`, and then drag and drop the `RadarRotation` script from
    `Assets/Script`, moving it from the **Project** window to the **Inspector** window.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, select the `boss` game object in the `BossScript` from `Assets/Script`
    into the **Inspector** window.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that the `boss` object is in the scene, we can add it to the timeline in
    the next section.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the boss for the timeline
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to take the `boss` game object from our `boss`
    object greet the player at the end of the level before jetting off after the player.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: Further sections will continue to make use of the timeline, including using
    specialized `boss` object animated.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 'To animate the `boss` object in the timeline, do the following:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Select the `Timeline` game object, and in the **Inspector** window, untick **Play
    On Awake**, as we will be triggering the **Timeline** animation ourselves.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To trigger the `BossTrigger` game object, which we mentioned at the beginning
    of this chapter.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: 'To have the main camera recognized as a trigger, we need to do the following:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Select the main camera in the **Hierarchy** window.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Add Component** button in the **Inspector** window.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in `Box Collider`, and when you see it in the drop-down list, select it.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tick the **Is Trigger** box under the **Box Collider** component.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s now continue setting up our `boss` game object into it:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Timeline** tab, which, as you will know if you have been following
    along with the previous sections, is found at the bottom of the Unity Editor
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Timeline` game object and the `Timeline` game object from the **Timeline**
    window because we aren't going to animate it.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `Timeline` object in the **Timeline** window and select **Delete**
    from the dropdown.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `Timeline` game object being deleted:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.32 – Deleting the ''Timeline'' game object from the Timeline window'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.32_B18381.png)'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.32 – Deleting the 'Timeline' game object from the Timeline window
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: With the `Timeline` game object still selected in the `boss` game object from
    the **Hierarchy** window down into the **Timeline** window.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A dropdown will appear with a choice of three selections:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '**Activation Track**: Turns a game object on or off'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Animation Track**: Animates the game object'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Audio Track**: Sets particular audio on or off'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because we want to animate our `boss` game object, we will choose **Animation
    Track**.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will now have the `boss` game object in our `boss` game object will gain
    an **Animator** component in the **Inspector** window.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows what our timeline currently looks like:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.33 – Timeline holding the ''boss'' game object'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.33_B18381.jpg)'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.33 – Timeline holding the 'boss' game object
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will start adding keyframes to our **Timeline** window, which will
    affect our boss''s position and rotation. Let''s start by locking our **Timeline**
    window so that when we click on another game object, it will remain active:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: Select the `Timeline` game object in the **Hierarchy** window.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Timeline** window tab.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the padlock button at the top-right corner of the **Timeline** window.
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The padlock button is highlighted in the following screenshot:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.34 – Locking the Timeline window'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.34_B18381.jpg)'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.34 – Locking the Timeline window
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: Let's now move on to the next section, where we will start adding keyframes
    to the timeline and make our `boss` game object move and rotate in two phases
    of the third level. Let's start with phase one.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: Animating the boss in the timeline – phase one
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will be adding keyframes to the `boss` game object. This
    will make the `boss` game object travel from one point to another while rotating
    on its center pivot.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: 'To start adding keyframes for the `boss` game object, do the following:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: With the `boss` game object.
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will now start recording our boss's position and rotation.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: In the `boss` game object name; the button should begin to flash.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure that the `0`, as shown in the following screenshot:'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.35 – The Timeline frame set to zero'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.35_B18381.jpg)'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.35 – The Timeline frame set to zero
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: In the `1675`, `0`, and `600`
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`60`, `-90`, and `0`'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.36 – The ''boss'' game object''s current location in our level
    3 scene'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.36_B18381.jpg)'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.36 – The 'boss' game object's current location in our level 3 scene
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to animate the `boss` object from one end of the corridor to the other,
    we need to add another keyframe for the boss. Follow these steps:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: With the record button still flashing in the `112` or change the value of the
    `112`.
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `boss` game object in the `3160`, `0`, and `600`
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`60`, `-90`, and `20`'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Information
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The **Timeline** and **Animation** windows have the same navigation rules with
    regard to zooming and panning in either window. Holding down the middle mouse
    button and moving the mouse will pan. Rolling the middle mouse wheel up or down
    zooms in and out. Hovering the mouse cursor over the animation bar and pressing
    *F* on the keyboard shows all the keyframes on the window.
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the record button next to the `boss` game object in the **Timeline**
    window to stop recording.
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and scrub (`boss` game object move from left to right while rotating.
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows a bird''s-eye view of the `boss` game object
    moving from left to right:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.37 – The ''boss'' game object will move from left to right'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.37_B18381.jpg)'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.37 – The 'boss' game object will move from left to right
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: Later on, when we play the third level, we will see a moment where the `boss`
    game object rushes past the player in the distance. For now, we will continue
    by adding more keyframes to our **Timeline** window before moving on to looking
    at playables.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to phase two of animating our `boss` game object.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: Animating the boss in the timeline – phase two
  id: totrans-517
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to animate our boss for a second time before the
    level ends as some form of resolution for the ending of this third and final level.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: We are going to continue from the same **Timeline** track that we started in
    the previous section.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s continue animating our boss from where we left off:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: Keep the **Timeline** window padlocked to stop the window from losing its display.
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `boss` object from the **Hierarchy** window.
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the record button next to the `boss` object's name in the **Timeline**
    window so that the button flashes.
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `1012` into the **Frame** parameter.
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the `boss` object still selected in the `boss` object''s position and
    rotation values to the following:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '`4545`, `0`, and `600`'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`60`, `-90`, and `0`'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows where our boss sits in phase two:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.38 – The ''boss'' game object positions'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.38_B18381.jpg)'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.38 – The 'boss' game object positions
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: With the record button still flashing, move to frame `1180` in the `boss` game
    object to the following `6390`, `0`, and `600`
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`60`, `-90`, and `20`'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, move to frame `1193` in the `boss` game object to the following `6390`,
    `0`, and `207`
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`60`, `450`, and `0`'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, move to frame `1215` in the `boss` game object to the following `5520`,
    `0`, and `50`
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`60`, `90`, and `-40`'
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, move to frame `1380` in the `boss` game object to the following `5510`,
    `0`, and `50`
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`60`, `90`, and `0`'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, move to frame `1400` in the `boss` game object to the following `5510`,
    `0`, and `50`
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`60`, `-70`, and `-40`'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, move to frame `1420` in the `boss` game object to the following `7540`,
    `0`, and `50`
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`60`, `-70`, and `0`'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the `boss` game object in the **Timeline** window to stop recording.
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows a bird''s-eye view of each of these positions
    with their **Timeline** frame numbers:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.39 – The Timeline frame numbers of where the ''boss'' game object
    will be'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.39_B18381.jpg)'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.39 – The Timeline frame numbers of where the 'boss' game object will
    be
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: If you want to adjust the `boss` game object rotation more, it is recommended
    to have **boss** selected in the **Hierarchy** window. Make sure the local position
    is selected (denoted by **1** in the following screenshot) and, with the Timeline
    still in record mode, rotate the *z* axes several times (denoted by **2**).
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.40 – Rotating the ''boss'' game object'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.40_B18381.jpg)'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.40 – Rotating the 'boss' game object
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: Finally, scrub backward and forward (move the **Timeline** indicator) in **Timeline**
    to see the result you are given.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: When you are happy, stop recording.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, the `boss` game object flies in from
    the left to the right toward where the player will be. The boss will stop rotating,
    pause, turn around, and zip off to the far right.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: Let's press `level3` scene so far, with the boss versus our player's ship throughout
    the `level3` scene.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: The player moves through the level, and the boss animation is seen on two occasions.
    What we do see that we likely shouldn't is the large yellow dot of the boss even
    when the boss has moved on. It would be good if we could make the boss disappear
    off the radar when we can't see the game object itself.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `boss` object on the left screen, which
    is not visible on the right screen but still detected on the radar:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.41 – The ''boss'' game object''s radar is still detecting the boss'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.41_B18381.jpg)'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.41 – The 'boss' game object's radar is still detecting the boss
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make use of the timeline before ending this section to simply turn the
    `radarPoint` game object off and then on when we see the `boss` game object. Follow
    these steps:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: Select the `Timeline` game object from the **Hierarchy** window.
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Timeline` tab to see the `boss` animation.
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag the boss's `radarPoint` object from the **Hierarchy** window
    into the **Timeline** window.
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Timeline** dropdown appears. This time, select **Activation Track**.
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our `radarPoint` track.
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s now add an activation clip to decide when the player should and shouldn''t
    see the `radarPoint` object. Follow these steps:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the track of the `radarPoint` object and select **Add Activation
    Clip**, as shown in the following screenshot:'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.42 – In the Timeline window, add an activation clip for our ''radarPoint''
    game object'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.42_B18381.jpg)'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.42 – In the Timeline window, add an activation clip for our 'radarPoint'
    game object
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: An `boss` game object to be active on two occasions – once when the boss moves
    past the player in the open-space area of the environment, and once at the end
    when the boss approaches the player head-on.
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the first occasion, we need to set the `35` and `95` on the timeline. We
    can do this by clicking and dragging its bar down to the `95` mark, as shown in
    the following screenshot:'
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.43 – Setting the activity of the ''radarPoint'' game object between
    set frames'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.43_B18381.jpg)'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.43 – Setting the activity of the 'radarPoint' game object between
    set frames
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: For the second occasion, we can set the `boss` object from around `1020` to
    `1420`.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeat this process by doing the following:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: Right-click and create an activation clip on the `radarPoint` track.
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scale the **Active** bar between the two **Timeline** points.
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene.
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have now set the settings so that the `boss` game object and its `radarPoint`
    object are active at the same time.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully introduced a timeline to our scene and customized it so
    that it accommodates a new game object that needs to be animated throughout the
    third and final level of our game. In the next section, we are going to look further
    into extending the features of the timeline by introducing animating lights.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: Extending the timeline
  id: totrans-585
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to add more functionality to the timeline by
    increasing its standard track selection, as shown in the following screenshot:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.44 – Expanding the functionality of our Timeline will be done next'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.44_B18381.jpg)'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.44 – Expanding the functionality of our Timeline will be done next
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: From this new extended track selection list, as shown in the previous screenshot,
    we will make use of **Light Control Track**.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to see a bigger selection from the drop-down list; this, however,
    is beyond the scope of this book. However, if you are interested, I will direct
    you to what to read to find out how to extend the list later on in this section.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: In the next few sections, we will increase our tracklist with the aid of the
    Asset Store and download a free asset from Unity to increase our **Timeline**
    functionality. Then, we will animate the lights in our scene, which wouldn't have
    been possible before.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: Adding Default Playables to the project
  id: totrans-593
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will take a shortcut in scripting to extend the timeline's
    functionality by going to the Unity Asset Store and downloading a free package
    called **Default Playables**. We will discuss the main features of playables and
    what they entail, but it is too lengthy to discuss it as a scripting approach.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: 'Playables organize, mix, and blend data through a playable graph to create
    a single output. To download and import **Default Playables** to our list, do
    the following:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your web browser and go to the Unity Asset Store: [https://assetstore.unity.com/](https://assetstore.unity.com/).'
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top of the `default playables` and press *Enter* on your keyboard.
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the only selection from the thumbnail list – **Default Playables**.
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Default Playables** shop screen, click on the **Download** button.
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once downloaded, we can now import the asset into our project by clicking on
    the **Add to My Assets** button, as shown in the following screenshot:'
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.45 – Downloading and importing the free Default Playables package
    into our project from the Asset Store'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.45_B18381.jpg)'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.45 – Downloading and importing the free Default Playables package
    into our project from the Asset Store
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: '**Default Playables** can now be downloaded from your Unity project via **Package
    Manager**.'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '**Package Manager** gives us access to assets we''ve downloaded from the **Asset
    Store** and also other "packages" we can add to our project. We will talk about
    **Package Manager** more in the next chapter.'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: 'To download **Default Playables** into our project, we need to do the following:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: In the Unity Editor, click **Window**, followed by **Package Manager**.
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Package Manager** will load in a new window. At the top-left corner of the
    window, select **Packages:**, followed by **My Assets** from the dropdown, as
    shown in the following screenshot:'
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.46 – Selecting "My Assets" from the dropdown in the Package Manager
    window'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.46_B18381.jpg)'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.46 – Selecting "My Assets" from the dropdown in the Package Manager
    window
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: We will now be presented with the assets we own from the Asset Store.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top-right corner of `default playable` to shorten the list on the left
    side, as shown in the following screenshot:'
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.47 – The Package Manager search bar highlighted at the top-right
    corner'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.47_B18381.jpg)'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.47 – The Package Manager search bar highlighted at the top-right corner
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: Select **Default Playables** at the left side of the window, followed by clicking
    **Download**, and then the **Import** button (at the bottom-right corner of the
    window).
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will then be presented with a list of folders and files that will be imported
    into the project.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **Import** button, as shown in the following screenshot:'
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.48 – The Default Playables files to be imported into the project'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.48_B18381.jpg)'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.48 – The Default Playables files to be imported into the project
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: We now have extra functionality added to our timeline, with an added folder
    in our `Assets` folder called `DefaultPlayables`. Also, as mentioned, to add even
    more functionality (such as timeline tracks) to the timeline, check out the file
    inside the `DefaultPlayables` folder named `DefaultPlayablesDocumentation`.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: Let's now move on to the next section, where we will make use of manipulating
    the lights in the scene.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating light components in the timeline
  id: totrans-625
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will continue working on the same timeline and expand it
    to hold more tracks. In the last section, we introduced a free-to-download asset
    from the Asset Store called **Default Playables** to save us from writing code
    from scratch and to offer new playables. This asset gave us the ability to add
    new tracks to our timeline. To continue adding new tracks, we will manipulate
    the lights in our third-level scene.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a light component to the timeline, we need to do the following:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the **Timeline** window is still locked, which we set in the *Preparing
    the boss for the timeline* section.
  id: totrans-628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click at the bottom-left open-space corner of the **Timeline** window
    and select **Light Control Track**, as shown in the following screenshot:'
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.49 – Adding ''Light Control Track'' to the Timeline'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.49_B18381.jpg)'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.49 – Adding 'Light Control Track' to the Timeline
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: We now have an empty light component track added to our timeline.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can add an **Animation** clip by right-clicking on the timeline''s
    track line and selecting **Add Light Control Clip**, as shown in the following
    screenshot:'
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.50 – Adding control to our lights with the control clip'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.50_B18381.jpg)'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.50 – Adding control to our lights with the control clip
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: We now have a `LightControlClip` object in our timeline. Click on this clip
    and look at the **Inspector** window. There are a few options here, but we are
    going to focus mainly on **Color**, **Intensity**, and **Range**.
  id: totrans-638
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These properties will directly change the values of the light that sits in the
    **None (Light)** parameter.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: 'Set your **Light Control Clip** values to the ones shown in the following screenshot
    in your **Inspector** window:'
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.51 – Copying the values from your ''Light Control Clip'' to the
    ones in this screenshot'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.51_B18381.jpg)'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.51 – Copying the values from your 'Light Control Clip' to the ones
    in this screenshot
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will set the duration of this clip to `100`. We can do this by either
    changing the value of the `LightControlClip` to the `100` mark, as shown in the
    following screenshot:'
  id: totrans-644
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.52 – Setting the duration of the light control clip to 100'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.52_B18381.jpg)'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.52 – Setting the duration of the light control clip to 100
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: Because this light is going to flash white and then red, ideally, it would make
    sense to have a loop between the two transitions. However, for the sake of blending
    and filling up the timeline, we are going to do it this way.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: Select `LightControlClip` and press *Ctrl* (*command* on the macOS) + *D* 25
    times to spam the track line with light control clips.
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the second `LightControlClip` object from the left and change its **Color**
    property from white to red.
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this process for clips `4`, `6`, `8`, `10`, `12`, `14`, `16`, `18`, `20`,
    `22`, `24`, and `26`.
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, zoom into the second `LightControlClip` object and move it 50% of the
    way across to its previous clip to create a blend between the color of the light,
    as in the following screenshot:'
  id: totrans-652
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.53 – 1st light clip splicing into the 2nd light clip'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.53_B18381.jpg)'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.53 – 1st light clip splicing into the 2nd light clip
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue moving each clip 50% of the way across to the previous clip''s location
    to make the lights flash white to red until the level finishes. The following
    screenshot shows the position of the third clip:'
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.54 – The 2nd light clip splicing into the 3rd'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.54_B18381.jpg)'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.54 – The 2nd light clip splicing into the 3rd
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: Once we've merged the clips, we can now duplicate our light track asset so that
    more than one light can flash.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the track asset and press *Ctrl* (*Command* on macOS) + *D* four times.
    The following screenshot uses the ***** symbol to highlight where to click, along
    with the duplicates made:'
  id: totrans-661
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.55 – Duplicating the track asset'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.55_B18381.jpg)'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.55 – Duplicating the track asset
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: As these are all the same types of tracks, we can put them into a track group
    to keep our timeline tidy.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the open-space area at the bottom left of the timeline and select
    **Track Group** from the dropdown.
  id: totrans-666
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our track group is made. Now, click and hold the top light track asset while
    holding down *Shift*, and click on the bottom light track asset to select all
    of the light track assets. Still holding down the left mouse button, drag these
    track assets into the track group.
  id: totrans-667
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `Lights`.
  id: totrans-668
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use the **+** button to expand and collapse the group.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the final result of the timeline lights:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.56 – The track group called ''Lights'' holding all our light track
    assets'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.56_B18381.jpg)'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.56 – The track group called 'Lights' holding all our light track assets
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to make a track group, follow the same process for the
    `boss` object and its `radarPoint` object, and call the track group `Boss`.
  id: totrans-674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final step is to drag and drop the five lights that will flash red and white
    into the **Game** window.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: Either click on the small, round remote button next to `light00`, `light01`,
    `light02`, `light03`, and `light04` into each parameter.
  id: totrans-676
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scrub or drag the **Timeline** indicator backward and forward on the timeline
    to see the selected lights flashing red.
  id: totrans-677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene.
  id: totrans-678
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows our player on the third level with a new set
    of AI enemies, a large boss flying in the background, and flashing lights:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.57 – The midway of level 3'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.57_B18381.jpg)'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.57 – The midway of level 3
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: 'Now would be a good time to apply the pause screen, if you haven''t already
    done so, to all three scenes. Follow these instructions if you don''t feel comfortable
    doing this on your own:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: With the `level3` scene saved, load up `level1` from the `Assets/Scene` folder
    from the **Project** window.
  id: totrans-684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Canvas` and `EventSystem` game objects, and then press *C* to copy them.
  id: totrans-685
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the `level3` scene back up.
  id: totrans-686
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Canvas` game object from the **Hierarchy** window and press *Delete*
    on your keyboard.
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Ctrl* (*Command* on macOS) + *V* to paste `EventSystem` and `Canvas`
    from the level that contains the pause screen.
  id: totrans-688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand `Canvas` and then the `LevelTitle` game object in the **Hierarchy** window.
  id: totrans-689
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Level` game object, and change the `level 1` to `level` `3` in the
    **Inspector** window.
  id: totrans-690
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene.
  id: totrans-691
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this process for `level2`.
  id: totrans-692
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows `level3` paused:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.58 – The pause screen working for level 3'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.58_B18381.jpg)'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.58 – The pause screen working for level 3
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to summarizing what we have covered in this chapter.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-698
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced a new concept to our game to make it more interesting
    than just taking place in space. Our camera and player needed to be slightly tweaked
    for the final level to support side-scrolling, instead of them being static in
    one screen, as is the case on the previous two levels. We also introduced a second
    enemy that can move around the floor, dodging other enemies in a panic-like state.
    The fleeing enemy used the navigation system that comes with Unity as standard,
    and we gave the enemy a floor to run around on. Lastly, we introduced the **Timeline**
    feature, which is related to the original animation system we used in [*Chapter
    4*](B18381_04_Epub.xhtml#_idTextAnchor087)*, Applying Art, Animation, and Particles*.
    We also discovered how **Timeline** lets any game object or component be animated
    in it without needing some form of hierarchical link between the game objects.
    Also, we extended the timeline to cover other components, such as lights, which
    we can't animate alone with the **Timeline** feature.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: The main takeaways from this chapter are the introduction of AI with a navigation
    system that can also be used for other behaviors in other games and the introduction
    of the timeline and its use to encourage creativity in projects, such as cutscenes,
    films, and animated TV sequences.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at polishing the visuals of our game, and
    we will see what tools can help us in optimizing performance and testing for bugs.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: Before you move on to the next chapter, try out the following mock test, as
    this is the last mini-mock test in this book before the big one.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: Mock test
  id: totrans-703
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are developing a game where your player is inside an office with other staff
    workers around them. When your player walks to a particular point, a trigger event
    is called to move the staff into another room with the use of **Playable Director**.
  id: totrans-704
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You notice that when the game is paused and then un-paused, the audio and animation
    are out of sync with each other.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: Which property in the **Playable Director** component will likely fix this issue?
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: Set the wrap mode to **Hold**.
  id: totrans-707
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the update method to **DSP**.
  id: totrans-708
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Initial Time** to the current time (the time when the game is paused).
  id: totrans-709
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the update method to **Unscaled Game Time**.
  id: totrans-710
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have a set of playables linked within our playable graph. We need to remove
    one of these playables and its inputs.
  id: totrans-711
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which **PlayerGraph** function should we use?
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: '`DestroyOutput`'
  id: totrans-713
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DestroyPlayable`'
  id: totrans-714
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DestroySubgraph`'
  id: totrans-715
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Destroy`'
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have developed an eight-ball pool game. One of the testers has come back
    to you, saying that the frame rate of the game drops too low when one of the players
    breaks the balls up at the start of a game. All of the balls have rigid body sphere
    colliders.
  id: totrans-717
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we improve the drop in the frame rate?
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: Use a less expensive shader on the objects that are colliding with one another.
  id: totrans-719
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the maximum allowed timestep to a range of 8–10 fps to account for this
    worst-case scenario.
  id: totrans-720
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the rigid bodies so that they are kinematic.
  id: totrans-721
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use box and capsule colliders instead of sphere colliders.
  id: totrans-722
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `NavMesh` modifier do?
  id: totrans-723
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `NavMesh` modifier determines what stage of the build process the NavMesh
    is baked at.
  id: totrans-724
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A `NavMesh` modifier describes the AI of each agent in the scene.
  id: totrans-725
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A `NavMesh` modifier allows NavMesh baking to occur outside the main thread
    so that it can be dynamically baked at runtime.
  id: totrans-726
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A `NavMesh` modifier adjusts how a game object behaves during NavMesh baking
    and can, for example, only affect certain agents.
  id: totrans-727
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Why does it help to only have the necessary boxes checked in the layer collision
    matrix?
  id: totrans-728
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unchecking boxes will hide layers so that they're not rendered.
  id: totrans-729
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Checking boxes will indicate which collisions can be ignored.
  id: totrans-730
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Checking boxes will show which layers are colliding in the frame debugger.
  id: totrans-731
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Unchecking boxes will reduce the number of layer collisions the physics system
    needs to check.
  id: totrans-732
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When we create a `Timeline` asset for a game object, what component is created
    and added to our game object?
  id: totrans-733
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PlayableBinding`'
  id: totrans-734
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PlayableDirector`'
  id: totrans-735
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PlayableOutput`'
  id: totrans-736
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PlayableGraph`'
  id: totrans-737
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In your first-person shooter, which you are testing, you notice that when the
    alarm is sounded, the enemy guards come running toward the player. When you observe
    the enemy guards advancing, you close the door on them but notice that their arms
    and heads are coming through the door that you have closed.
  id: totrans-738
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What setting do you need to increase to stop these arms and heads coming through
    objects that they shouldn't?
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: '**Step Height**'
  id: totrans-740
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Max Slope**'
  id: totrans-741
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Agent Height**'
  id: totrans-742
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Agent Radius**'
  id: totrans-743
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have got yourself involved in a classic Save the Mayor rescue game. Your
    player is a trained vigilante trying to eliminate potential attackers to harm
    the city's mayor. One of the attackers gets too close, and you take a shot to
    warn them off. The attacker runs away but returns shortly after, crawling toward
    the mayor.
  id: totrans-744
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which `NavMesh` agent property can simulate this cautious behavior?
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: '**Area Mask**'
  id: totrans-746
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Auto Braking**'
  id: totrans-747
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Stopping Distance**'
  id: totrans-748
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Priority**'
  id: totrans-749
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations – Save the Mayor was a massive success, and you have been asked
    to start development straight away on Save the Mayor 2! Your vigilante is back,
    and this time, he can jump *and* run and jump across building rooftops.
  id: totrans-750
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yet again, you have applied the `NavMesh` agent so that your vigilante can run
    and jump across buildings in a linear path. You have correctly hooked all your
    animation controls up but have noticed that your vigilante isn't animating when
    it comes to jumping between building rooftops.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: What setting or property do we need to change to solve this issue?
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: Uncheck `NavMesh` agent component.
  id: totrans-753
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increase the `NavMesh` agent component.
  id: totrans-754
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck the **Height Mesh** property in the **Bake** settings under **Navigation**.
  id: totrans-755
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increase the jump distance in the **Bake** settings under **Navigation**.
  id: totrans-756
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are working on a third-person game, and our character is using a finite state
    machine to react to their states. We currently have it set so that if we get too
    close to a particular character, they will attempt to run and hug us.
  id: totrans-757
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What finite state machine component is the programmer working on?
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: '**Actions**'
  id: totrans-759
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Transitions**'
  id: totrans-760
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Events**'
  id: totrans-761
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Rules**'
  id: totrans-762
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of these tracks can the timeline not add without applying additional coding?
  id: totrans-763
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Activation Track**'
  id: totrans-764
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Animation Track**'
  id: totrans-765
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Light Control Track**'
  id: totrans-766
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Playable Track**'
  id: totrans-767
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: One of the 3D artists has supplied you with a series of three-dimensional models
    to be applied to one of the start up scenes for the project you are currently
    developing.
  id: totrans-768
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When importing the models into the scene, you notice that all the models have
    sharp edges. You have asked the artist to make the models smoother.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: Is there anything else that can be done on the developer side to possibly fix
    these sharp three-dimensional model edges?
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the normals to a particular smoothing angle value.
  id: totrans-771
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the files through Unity instead of dragging and dropping the files.
  id: totrans-772
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply materials to each three-dimensional model.
  id: totrans-773
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure there is lighting in the scene.
  id: totrans-774
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does `LateUpdate` do?
  id: totrans-775
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replaces the standard `Update` function when frames are overloaded.
  id: totrans-776
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`LateUpdate` takes fewer resources to run, which makes it ideal for mobile
    platforms.'
  id: totrans-777
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An update is only called once on every frame. `LateUpdate` is called every three
    frames.
  id: totrans-778
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`LateUpdate` is the last item in the execution order before rendering.'
  id: totrans-779
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the advantages of using `GameObject.Find` (if any)?
  id: totrans-780
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There aren't any; it's slow and demanding.
  id: totrans-781
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If not called on every frame, it makes coding useful for referencing.
  id: totrans-782
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GameObject.Find` is deprecated.'
  id: totrans-783
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GameObject.Find` searches through library asset data outside of the Unity
    project.'
  id: totrans-784
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Do we have to import the `UnityEngine` library and `MonoBehaviour` with every
    script?
  id: totrans-785
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, as long as they are not applied to a game object.
  id: totrans-786
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, or the Unity engine rejects the script.
  id: totrans-787
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, as they act as a header to all scripts.
  id: totrans-788
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Only `MonoBehaviour` must be inherited in all cases.
  id: totrans-789
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When moving from one scene to another, you notice that the second scene is much
    darker, even though it uses the same art and lighting as the scene before it.
  id: totrans-790
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we make the lighting act how it should in the scene?
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: Make sure all the lights are turned off before being turned on in the second
    scene.
  id: totrans-792
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep all the lights on from the first scene when moving into the second scene.
  id: totrans-793
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the lights from the previous scene over to the new one when loaded
    up.
  id: totrans-794
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn off **Auto Generate** in the lighting settings and manually generate the
    lights.
  id: totrans-795
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of `Debug.Log()`?
  id: totrans-796
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is useful if developers want to know the value of a variable.
  id: totrans-797
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It sends string values to each variable.
  id: totrans-798
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: There aren't any; it's deprecated, so we don't use it.
  id: totrans-799
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It logs information into Unity's database.
  id: totrans-800
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将信息记录到Unity的数据库中。
- en: Is the Audio Mixer useful to developers?
  id: totrans-801
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 音频混音器对开发者有用吗？
- en: No, it's specifically built for audio users; developers use an AudioSource.
  id: totrans-802
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，它是专门为音频用户构建的；开发者使用AudioSource。
- en: Yes, as it can be used to hold all the sounds in one central point.
  id: totrans-803
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，因为它可以用来在一点集中存储所有声音。
- en: Only if the developer is skilled in handling audio alone.
  id: totrans-804
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有当开发者擅长单独处理音频时。
- en: Yes, it helps the performance of the audio.
  id: totrans-805
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，它有助于音频的性能。
- en: Why do some developers prefer JSON over PlayerPrefs?
  id: totrans-806
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么一些开发者更喜欢JSON而不是PlayerPrefs？
- en: PlayerPrefs was released before JSON, which gives it a bigger following.
  id: totrans-807
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: PlayerPrefs在JSON之前发布，这使得它拥有更多的追随者。
- en: JSON can be used with more data types and is a more compatible API.
  id: totrans-808
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: JSON可以与更多数据类型一起使用，并且是一个更兼容的API。
- en: Both are good; it's just a matter of personal preference.
  id: totrans-809
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两者都很好；这只是个人偏好的问题。
- en: JSON is owned by Unity, so it incorporates a lot of features.
  id: totrans-810
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: JSON由Unity拥有，因此它集成了许多功能。
- en: Why would we use a trigger box instead of a collider?
  id: totrans-811
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们会使用触发器框而不是碰撞体？
- en: Triggers and colliders carry out the same task.
  id: totrans-812
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触发器和碰撞体执行相同的任务。
- en: Triggers have more functionality and cost less to run than colliders.
  id: totrans-813
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触发器比碰撞体功能更强大，且运行成本更低。
- en: A trigger can call code when another collider/trigger enters it.
  id: totrans-814
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当另一个碰撞体/触发器进入它时，触发器可以调用代码。
- en: Triggers have different colored boxes.
  id: totrans-815
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触发器有不同的彩色框。
