# 云端编码

前几章探讨了从较低层次的概念，如单例模式和工厂模式，到特定技术（如数据库和 Web 应用）的模式。这些模式对于确保解决方案的良好设计至关重要，以确保可维护性和高效的实现。这些模式提供了一个坚实的基础，使得应用能够随着需求的变化和新功能的添加而增强和修改。

本章从更高层次的角度审视解决方案，以解决设计、实施可靠、可扩展和安全的解决方案所涉及的问题。本章中讨论的模式通常涉及包含多个应用、存储库和一系列可能的基础设施配置的环境。

软件行业持续发展，随着变化而来的是新的机遇以及新的挑战。在本章中，我们将探讨针对云的不同软件模式。许多这些模式并非新颖，它们存在于本地环境中。随着云优先解决方案成为常态，这些模式变得更加普遍，因为实现不依赖本地基础设施的解决方案变得容易。

云优先或云原生解决方案旨在针对云计算资源，而混合解决方案旨在使用云计算资源以及来自私有数据中心资源。

本章定义了在云中构建解决方案时的五个关键关注点：

+   可扩展性

+   可用性

+   安全性

+   应用设计

+   DevOps

我们将讨论这些关键关注点及其在构建云解决方案中的重要性。在讨论这些问题时，将描述可以应用于解决这些问题的不同模式。

# 技术要求

本章不需要任何特殊的技术要求或源代码，因为它主要是理论性的。

# 在云中构建解决方案时的关键考虑因素

决定迁移到云中会带来其自身的问题和挑战。在本节中，我们将讨论构建基于云的解决方案时需要考虑的五个关键领域。虽然这些问题并非云所独有，但由于可用的技术和解决方案范围广泛，因此在迁移到云时需要特别注意。

五个主要考虑因素如下：

+   **可扩展性**：这允许适应不断增长的业务增加的负载或流量。

+   **弹性/可用性**：这确保了系统在处理故障时尽可能优雅，对用户的影响最小。

+   **安全性**：这确保了私有和专有数据保持私密，并免受黑客和攻击。

+   **应用设计**：这指的是对应用进行设计，特别考虑基于云的解决方案。

+   **DevOps**：这是一个支持基于云的解决方案的开发和运行的工具和实践的集合。

根据您的业务需求，您可能需要寻找解决这些考虑因素中的一些或全部的解决方案。同时，为了您的业务利益，采用能够解决您未预见到但会为良好的应急计划做出贡献的问题的提供商也是有益的。

在以下章节中，我们将进一步详细讨论这些考虑因素以及针对它们的可用解决方案模式。

这些模式从技术类型到架构到业务流程，一个模式可以解决多个问题。

# 可扩展性

可扩展性指的是在给定工作负载下，应用能够分配和管理其使用的资源，以便在应用中保持可接受的质量水平。大多数云服务提供增加应用使用的资源质量和数量的机制。例如，Azure App Service 允许扩展 App Service 的大小和 App Service 实例的数量。

可扩展性可以被视为对有限数量资源的需求。资源可以是磁盘空间、RAM、带宽或软件的另一个可量化的方面。需求可以从用户数量、并发连接或其他会对资源产生约束的需求中产生。随着需求的增加，应用将承受压力以提供资源。当压力影响应用性能时，这被称为资源瓶颈。

例如，一个衡量标准可能是应用性能开始下降之前可以访问应用的用户数量。性能可以设定为请求的平均延迟小于 2 秒。随着用户数量的增加，可以观察系统负载，并确定影响性能的具体资源瓶颈。

# 工作负载

为了确定如何有效地解决可扩展性问题，了解系统将承受的工作负载非常重要。有四种主要类型的工作负载：静态、周期性、一生一次和不可预测的。

静态工作负载表示系统上的活动水平保持恒定。由于工作负载没有波动，这类系统不需要非常灵活的基础设施。

具有可预测工作负载变化系统的周期性工作负载。一个例子是周末或收入税到期月份活动激增的系统。这些系统可以在负载增加时扩展以维持所需的质量水平，在负载减少时缩减以节省成本。

一生一次的工作负载表明围绕特定事件设计的系统。这些系统被配置来处理事件周围的工作负载，一旦不再需要就取消配置。

不可预测的工作负载通常可以从前面提到的自动扩展功能中受益。这些系统活动的大幅波动可能尚未被业务理解，或受到其他因素的影响。

理解和设计基于云的应用程序以适应其工作负载类型对于保持高性能以及降低成本至关重要。

# 解决方案模式

我们有三种设计模式和一种架构模式可供选择，以使我们能够为系统添加可伸缩性：

+   垂直扩展

+   水平扩展

+   自动扩展

+   微服务

让我们更详细地回顾一下。

# 垂直扩展

虽然可以在本地服务器上添加物理 RAM 或额外的磁盘驱动器，但大多数云服务提供商支持轻松增加或减少系统计算能力的能力。这种扩展通常在系统扩展时几乎没有或没有停机时间。这种类型的扩展称为垂直扩展，指的是当 CPU 类型、RAM 的大小和质量或磁盘的大小和质量等资源发生改变时。

垂直扩展通常被称为*向上扩展*，而水平扩展通常被称为*向外扩展*。在这个上下文中，术语*向上*指的是资源的大小，而*向外*指的是实例的数量。

# 水平扩展

水平扩展与垂直扩展的不同之处在于，它不是改变系统的大小，而是改变涉及的系统数量。例如，一个 Web 应用程序可能运行在一个拥有 4 GB RAM 和 2 个 CPU 的单个服务器上。如果将服务器的容量增加到 8 GB RAM 和 4 个 CPU，那么这将是垂直扩展。然而，如果添加了两个配置相同的 4 GB RAM 和 2 个 CPU 的服务器，那么这将是水平扩展。

水平扩展可以通过使用某种形式的负载均衡来实现，该负载均衡将请求重定向到系统集合中，如下面的图示所示：

![](img/1248ceaf-6ac8-4e3c-b613-ad243ecee78e.png)

在云解决方案中，水平扩展通常比垂直扩展更受欢迎。这是因为，一般来说，使用几个较小的虚拟机而不是单个大型服务器来提供相同性能的度量更经济有效。

为了使水平扩展最有效，确实需要一种支持此类扩展的系统设计。例如，没有粘性会话和/或服务器上存储状态的 Web 应用程序更适合水平扩展。这是因为粘性会话会导致用户的请求被路由到同一虚拟机进行处理，随着时间的推移，虚拟机之间的路由平衡可能会变得不均匀，因此可能不是最有效的。

有状态应用程序

一个 *有状态* 的应用程序在服务器或存储库上维护有关活动会话的信息。

无状态应用程序

*无状态* 应用程序设计为不需要在服务器或存储库中存储有关活动会话的信息。这允许在单个会话中的后续请求可以发送到任何服务器进行处理，而不仅仅是整个会话期间发送到同一服务器。

设计为有状态的 Web 应用程序需要在共享存储库中维护会话或信息。无状态 Web 应用程序支持更健壮的模式，因为任何服务器在 Web 花园或 Web 农场中。这允许 Web 应用程序的单个节点失败而不会丢失会话信息。

一个 *花园* 式的 Web 应用程序是指多个相同的 Web 应用程序在同一服务器上托管，而一个 *农场* 式的 Web 应用程序是指多个相同的 Web 应用程序在不同的服务器上托管。在这两种模式中，路由都用于将多个副本暴露出来，就像它们是一个单一的应用程序一样。

# 自动扩展

使用云服务提供商而不是本地解决方案的优势在于内置的自动扩展支持。作为水平扩展的额外好处，自动扩展应用程序的能力通常是云服务的一个可配置功能。例如，Azure App Service 提供了设置自动扩展配置文件的能力，允许应用程序对条件做出反应。例如，以下截图显示了一个自动扩展配置文件：

![](img/9d5b1f53-4831-473c-af9e-263e3667205e.png)

为工作日设计的配置文件将根据服务器的负载增加或减少应用程序实例的数量。负载是通过 CPU 百分比来衡量的。如果 CPU 百分比平均超过 60%，则实例数量将增加到最多 10 个。同样，如果 CPU 百分比低于 30%，则实例数量将减少到最少 2 个。

弹性基础设施允许资源垂直或水平扩展，而无需重新部署或停机。实际上，这个术语更多地是指弹性程度，而不是指系统是否是 *弹性的*。例如，一个弹性的服务可以允许垂直和水平扩展，而无需重启服务实例。一个弹性较低的服务可以在不重启的情况下进行水平扩展，但需要在更改服务器大小时重启服务。

# 微服务

对于微服务意味着什么以及它与 **面向服务的架构**（**SOA**）如何相关，存在不同的解释。在本节中，我们将把微服务视为 SOA 的细化，而不是一种新的架构模式。微服务架构通过添加一些额外的关键原则来扩展 SOA，这些原则要求服务必须：

+   很小——因此称为 *微观*

+   围绕业务能力构建

+   与其他服务松散耦合

+   独立可维护

+   具有隔离的状态

# 小型

微服务通过将服务缩减到可能的最小尺寸，将 SOA 中的服务推进得更远。这很好地符合我们看到的某些其他模式，例如来自第二章的**简单至上**（**KISS**）和**你不需要它**（**YAGNI**）模式，见*现代软件开发模式和原则*。微服务应该只满足其需求，而不做更多。

# 业务能力

通过围绕业务能力构建服务，我们以这种方式调整我们的实现，使得当业务需求发生变化时，我们的服务将以类似的方式改变。正因为如此，业务某一领域的变更不太可能影响其他领域。

# 松散耦合

微服务应该使用如 HTTP 这样的技术无关协议在服务边界与其他服务进行交互。这允许微服务更容易地集成，更重要的是，当其他服务发生变化时，不需要重新构建微服务。这确实需要存在已知的*服务合同*。

服务合同

*服务合同*是向其他开发团队分发的服务的定义。**Web 服务描述语言**（**WSDL**）是一种广泛使用的基于 XML 的语言，用于描述服务，但其他语言，如 Swagger，也非常受欢迎。

在实现微服务时，制定一个如何管理变更的策略非常重要。通过拥有版本化的服务合同，就可以清楚地与服务客户端沟通变更。

例如，用于存储书籍库存的微服务所使用的策略可能如下：

+   每个服务都将进行版本控制并包含 Swagger 定义。

+   每个服务将从版本 1 开始。

+   当服务合同需要变更时，版本号将增加 1。

+   该服务将维护最多三个版本。

+   对服务的变更必须确保所有当前版本的行为都适宜。

前面的基本策略确实有一些有趣的含义。首先，维护服务的团队必须确保变更不会破坏现有的服务。这确保了新的部署不会破坏其他服务，同时允许部署新的功能。合同确实允许同时最多有三个服务处于活动状态，从而允许可信赖的服务独立更新。

# 独立可维护

这是微服务最显著的特征之一。拥有能够独立于其他微服务维护的微服务，使企业能够管理服务而不会影响其他服务。通过管理服务，我们包括服务的开发以及部署。根据这一原则，微服务可以以降低影响其他服务的风险以及与其他服务不同的变化速度进行更新和部署。

# 独立状态

独立状态包括数据和其他可共享的资源，包括数据库和文件。这也是微服务架构的一个显著特征。通过拥有独立的状态，我们减少了数据模型变化以支持一个服务而影响其他服务的可能性。

下图展示了更传统的 SOA 方法，其中多个服务使用单个数据库：

![图片](img/d160a26b-1edb-470c-91ef-e87a93b40e64.png)

通过要求微服务拥有独立的状态，我们就会需要每个服务一个数据库，如下图所示：

![图片](img/6b3b7c88-5528-4c3a-8215-2f707c7365f4.png)

这有一个优点，即每个服务都可以选择最适合服务需求的技术。

# 优势

微服务架构确实代表了从传统服务设计到的一种转变，并且它非常适合基于云的解决方案。微服务的优势以及为什么它们越来越受欢迎可能并不立即明显。我们已经讨论了微服务设计如何提供优雅处理变化的优势。从技术角度来看，微服务可以在服务级别和数据库级别独立扩展。

可能不清楚微服务架构对企业的益处。通过拥有小型独立的服务，企业可以探索不同的方式来维护和开发微服务。企业现在有选择以不同的方式托管服务的选择，包括不同的云提供商，以最适合独立服务。同样，服务的独立性质允许在开发服务时具有更大的灵活性。随着变化的发生，资源（即，开发团队成员）可以根据需要分配到不同的服务中，并且由于服务范围较小，所需的企业知识量也减少了。

# 弹性/可用性

弹性是指应用程序优雅处理失败的能力，而可用性是衡量应用程序工作时间的指标。即使其中一个资源变得不可操作或不可用，应用程序可能仍然具有资源集合并保持可用。

如果一个应用程序被设计成在系统完全不可操作的情况下处理一个或多个资源失败，这被称为**优雅降级**。

模式适用于隔离应用程序的元素以及处理元素之间的交互，以便当发生故障时，影响被限制。许多与弹性相关的模式侧重于应用程序内部或到其他应用程序的组件之间的消息传递。例如，Bulkhead 模式通过隔离流量到池中，以便当一个池过载或失败时，其他池不会受到不利影响。其他模式应用特定的技术来处理消息，例如重试策略或补偿事务。

可用性是许多基于云的应用程序的一个重要因素，通常，可用性是通过**服务水平协议**（**SLA**）来衡量的。在大多数情况下，SLA 规定了应用程序必须保持可操作的时间百分比。模式包括允许组件冗余以及使用技术来限制活动增加的影响。例如，基于队列的负载均衡模式通过在调用者或客户端与应用程序或服务之间充当缓冲区，使用队列来限制活动峰值可能对应用程序产生的影响。

弹性和可用性在此被识别为相关的云解决方案因素，因为一个弹性的应用程序通常允许实现严格的可用性 SLA。

# 解决方案模式

为了确保我们有一个具有弹性和可用性的系统，我们的最佳选择是寻找具有特定架构的提供商。进入**事件驱动架构**（**EDA**）。

EDA 是一种使用*事件*来驱动系统和活动行为的架构模式。其下可用的解决方案模式将帮助我们实现预期的解决方案。

# EDA

EDA 提倡松散连接的生产者和消费者的概念，其中生产者没有直接了解消费者。在这个上下文中，事件是任何变化，从用户登录系统，到下单，到进程未能成功完成。EDA 非常适合分布式系统，并允许实现高度可扩展的解决方案。

有许多与 EDA 相关的模式和途径，以下模式在本节中作为与 EDA 直接相关的内容进行展示：

+   基于队列的负载均衡

+   发布者-订阅者

+   优先队列

+   补偿事务

# 基于队列的负载均衡

基于队列的负载均衡是减少高需求发生对可用性影响的有效方式。通过在客户端和服务之间引入队列，我们能够调节或限制服务一次处理的请求数量。这允许提供更平滑的用户体验。以下图为例：

![图片](img/80878957-90a5-47bd-a052-acb18a6d198c.png)

上述图表显示了客户端向队列提交请求以进行处理，并将结果保存到表中。队列的作用是防止功能因活动突然增加而超负荷。

# 发布者订阅者

发布者订阅者模式指出存在事件发布者和事件消费者。本质上，这是事件驱动架构（EDA）的核心，因为发布者与消费者解耦，并且不关心事件是否被发送给消费者，而只关心发布事件。事件将包含用于将事件路由到感兴趣消费者的信息。然后，消费者会注册或订阅对特定事件的兴趣：

![图片](img/93444369-0f06-4847-b5ec-f974300ac2cd.png)

上述图表展示了客户服务和订单服务。客户服务充当发布者，当添加客户时提交一个事件。订单服务已订阅新的客户事件。当接收到新的客户事件时，订单服务将客户信息插入其本地存储。

通过将发布者订阅者模式引入架构，订单服务随后与客户服务解耦。这样做的一个优点是它提供了一个更灵活的架构以适应变化。例如，可以引入一个新的服务来添加新客户到解决方案中，而不需要添加到客户服务使用的相同存储库中。此外，多个服务可以订阅新的客户事件。添加欢迎邮件作为新的订阅者可以更容易地实现，而不是将此功能构建到单一的大型解决方案中。

# 优先队列

另一个相关的模式是优先队列，它提供了一种对不同事件进行不同处理的机制。使用上一节中的新客户示例，可以为新客户事件设置两个订阅者。一个订阅者可能对大多数新客户感兴趣，而另一个订阅者可能会识别出应该以不同方式处理的客户子集。例如，来自农村地区的新订阅者可能会收到有关专业运输提供商的额外信息的电子邮件。

# 补偿事务

在分布式系统中，并不总是实际或理想地以事务的形式发布命令。在此上下文中，事务指的是一种低级编程结构，它将一个或多个命令作为一个单一的操作来管理，要么全部成功，要么全部失败。在某些情况下，分布式事务可能不受支持，或者使用分布式事务的开销超过了其带来的好处。补偿事务模式就是为了处理这种情况而开发的。以下是一个基于 BizTalk 编排的示例：

![图片](img/e76b66c8-dbb6-4406-abf7-ff38d425fd48.png)

该图显示了流程中的两个步骤：在订单服务中创建秩序和从客户服务中扣除资金。该图展示了首先创建订单，然后移除资金的顺序。如果资金扣除失败，则订单将从订单服务中移除。

# 安全

安全确保应用程序不会错误地披露信息或提供超出预期用途的功能。安全包括恶意和意外行为。随着云应用程序和广泛使用各种身份提供者，仅限制访问到经过批准的用户通常具有挑战性。

最终用户的身份验证和授权需要设计和规划，因为运行在隔离中的应用程序越来越少，并且使用多个身份提供者，如 Facebook、Google 和 Microsoft，是很常见的。在某些情况下，使用模式可以直接访问资源以改善性能和可扩展性。此外，其他模式关注于在客户端和应用程序之间创建虚拟墙。

# 解决方案模式

随着行业变得更加互联互通，使用外部方进行用户认证的模式变得越来越普遍。在这里选择讨论联邦安全模式，因为它是我们系统中确保安全的最有效方法之一，并且大多数**软件即服务（SaaS**）平台都提供此功能。

# 联邦安全

联邦安全将用户或服务（消费者）的身份验证委托给一个称为**身份提供者（IdP**）的外部方。使用联邦安全的应用程序将信任 IdP 正确地验证消费者并提供关于消费者或声明的准确详情。关于消费者的这些信息以令牌的形式展示。这种场景的一个常见例子是使用社交 IdP（如 Google、Facebook 或 Microsoft）的 Web 应用程序。

联邦安全可以处理各种场景，从交互式会话到身份验证后端服务或非交互式会话。另一个常见场景是能够在一系列分别托管的应用程序中提供单一的认证体验或**单点登录（SSO**）。这种场景允许从**安全令牌服务（STS**）获取单个令牌，并使用相同的令牌向多个应用程序展示，而无需重复登录过程：

![图片](img/8b8e558d-26c7-47d9-b3b8-1bdc16566e6f.png)

联邦安全有两个主要目的。首先，它通过拥有一个单一的标识存储库来简化身份管理。这使得身份可以以集中和统一的方式管理，从而使得执行管理任务（如提供登录体验、忘记密码管理以及以一致的方式撤销密码）变得更加容易。其次，它通过在多个应用程序中提供类似体验以及只需要一种认证方式，而不是需要记住多个密码，从而提供更好的用户体验。

联邦安全有几个标准，其中两个广泛使用的是**安全断言标记语言**（**SAML**）和**OpenId Connect**（**OIDC**）。SAML 比 OIDC 更老，允许使用 XML SAML 格式交换消息。OIDC 建立在 OAuth 2.0 之上，通常使用**JSON Web Token**（**JWT**）来描述安全令牌。这两种格式都支持联邦安全、单点登录（SSO）以及许多公共身份提供者（IdP），如 Facebook、Google 和 Microsoft，都支持这两种标准。

# 应用程序设计

应用程序的设计可以非常不同，并且可能受到许多因素的影响。这些因素不仅与技术有关，而且受到参与构建、管理和维护应用程序的团队的影响。例如，某些模式与小型专用团队配合得最好，而不是与大量地理上分散的团队配合。其他与设计相关的模式处理不同类型的负载更好，并在特定场景中使用。其他模式是围绕变更频率以及如何限制变更对已发布给用户的应用程序的干扰而设计的。

# 解决方案模式

几乎所有本地模式都适用于基于云的解决方案，因此可能涵盖的模式范围令人震惊。选择缓存和 CQRS 模式，因为前者是大多数 Web 应用程序非常常见的模式，而后者改变了设计师构建解决方案的方式，并且非常适合其他架构模式，如 SOA 和微服务。

# 缓存

将从较慢的存储形式检索到的信息存储到较快的存储形式中，或称为缓存，这是一种在编程中使用了几十年的技术，可以在浏览器缓存和 RAM 等软件和硬件中看到。在本章中，我们将探讨三个示例：缓存旁路、写入缓存和静态内容托管。

# 缓存旁路

缓存旁路模式可以通过在本地或更快的存储形式中加载频繁引用的数据来提高性能。使用此模式时，维护缓存状态的责任在于应用程序。以下图示说明了这一点：

![图片](img/0fd306bb-6874-4916-83c7-54ffcdd30e3f.png)

首先，应用程序从缓存请求信息。如果信息缺失，则从数据存储中请求。然后应用程序使用信息更新缓存。一旦信息存储，它将从缓存检索并使用，而不需要引用较慢的数据存储。使用这种模式，当发生缓存未命中或数据更新时，维护缓存是应用程序的责任。

“缓存未命中”这个术语指的是数据在缓存中找不到的情况。换句话说，它缺失在缓存中。

# 写入通过缓存

写入通过缓存模式也可以像缓存旁路模式一样用于提高性能。其方法不同之处在于将缓存内容的管理从应用程序移动到缓存本身，如下面的图所示：

![图片](img/2b8f50a0-1ebe-44cd-943e-2011381bb41e.png)

对缓存中的某条信息发出请求。如果数据尚未加载，则从数据存储中检索信息，放入缓存，然后返回。如果数据已经存在，则立即返回。此模式支持通过将信息的写入传递给缓存服务来更新缓存。缓存服务随后更新缓存和数据存储中保存的信息。

# 静态内容托管

静态内容托管模式将如媒体图像、电影和其他非动态文件等静态内容移动到用于快速检索的系统。为此专门提供的服务称为**内容分发网络**（**CDN**），它能够将内容分布到多个数据中心，并将请求导向最接近调用者的数据中心，如下面的图所示：

![图片](img/d72bd427-be1a-4e5b-b152-8c8bc6e0ec2d.png)

静态内容托管是网络应用中的一种常见模式，其中从网络应用请求一个动态页面，该页面包含一系列静态内容，如 JavaScript 和图像，浏览器随后直接从 CDN 检索这些内容。这是一种有效减少网络应用流量的方法。

# 命令和查询责任分离

**命令和查询责任分离**（**CQRS**）是一个值得详细讨论的优秀软件模式，因为它在概念上简单，相对容易实现，但对应用程序和涉及的开发者都有重大影响。该模式明确地将影响应用程序状态的操作命令与仅检索数据的查询分离。简单来说，如更新、添加和删除等命令由不同的服务提供，而查询则不改变任何数据。

你可能会说 *再次 CQRS*！我们认识到我们已经在一个面向对象编程和数据库设计中使用了 CQRS 的例子。同样的原则也适用于软件开发的其他许多领域。我们在这个部分将 CQRS 作为服务设计模式提出，因为它带来了一些有趣的好处，并且与现代模式如微服务和反应式应用程序设计很好地结合。

CQRS 基于伯特朗·迈耶在 20 世纪 80 年代后期在其著作 *面向对象软件构造* 中提出的面向对象设计：[`se.ethz.ch/~meyer/publications/`](http://se.ethz.ch/~meyer/publications/)。

如果我们回顾 第五章：*实现设计模式 - .NET Core*，我们通过将库存上下文拆分为两个接口来展示这个模式：`IInventoryReadContext` 和 `IInventoryWriteContext`。作为提醒，以下是对接口的描述：

```cs
public interface IInventoryContext : IInventoryReadContext, IInventoryWriteContext { }

public interface IInventoryReadContext
{
    Book[] GetBooks();
}

public interface IInventoryWriteContext
{
    bool AddBook(string name);
    bool UpdateQuantity(string name, int quantity);
}
```

如我们所见，`GetBooks` 方法与修改库存状态的两种方法 `AddBook` 和 `UpdateQuantity` 分离。这展示了代码解决方案中的 CQRS。

同样的方法可以在服务级别上应用。如果我们以维护库存的服务为例，我们会在更新库存的服务和检索库存的服务之间拆分服务。这在下图中展示：

![图片](img/54d55117-1d9a-43ec-85f4-67b74384663e.png)

让我们先通过查看在基于云的解决方案中应用 CQRS 的挑战来探索 CQRS。

# CQRS 的挑战

在服务中使用 CQRS 模式存在重大挑战：

+   一致性

+   采用

陈旧性是衡量数据与提交版本的数据反映程度的一个指标。在大多数情况下，数据有改变的可能性，因此，一旦读取了一份数据，就有可能更新数据，使得读取的数据与源数据不一致。这是所有分布式系统的一个挑战，在这些系统中，保证显示给用户的值反映源值是不切实际的。当数据直接反映存储的内容时，我们可以称数据是一致的；当数据不反映时，它被视为不一致的。

在分布式系统中常用的一个术语是 *最终一致性*。最终一致性用于表示系统最终会变得一致。换句话说，它最终会变得一致。

另一个更微妙挑战是采用。将 CQRS 实施到既定的开发团队中可能会遇到来自不熟悉该模式且可能缺乏业务对偏离当前设计模式支持的开发商和设计师的阻力。

那么，这些好处是什么？

# 为什么使用 CQRS？

以下是使用 CQRS 的三个有力因素：

+   **协作**

+   **模型分离**

+   **独立可伸缩性**

通过独立的服务，我们可以然后独立维护、部署和扩展这些服务。这增加了我们可以在开发团队之间实现的合作水平。

通过拥有独立的服务，我们可以使用最适合我们服务模式的模型。命令服务可能直接使用简单的 SQL 语句对数据库进行操作，因为这是负责团队最熟悉的技术，而构建查询服务的团队可能使用框架来处理对数据库的复杂语句。

大多数解决方案的读取操作往往比写入操作多（或反之亦然），因此根据这一标准划分服务在许多场景中是有意义的。

# DevOps

在基于云的解决方案中，数据中心是远程托管，你通常无法完全控制或访问应用程序的所有方面。在某些情况下，例如无服务器服务，基础设施被抽象化。应用程序仍然需要暴露有关运行中的应用程序的信息，这些信息可用于管理和监控应用程序。用于管理和监控的模式对于应用程序的成功至关重要，因为它既提供了保持应用程序健康运行的能力，又为业务提供了战略信息。

# 解决方案模式

随着与监控和管理解决方案相关的商业软件包的可用性，许多企业已经获得了对其分布式系统更好的控制和理解。遥测和持续交付/持续集成被选择进行更详细的介绍，因为它们在基于云的解决方案中具有特殊价值。

# 遥测

随着软件行业的演变和分布式系统涉及更多服务和应用程序，能够对系统有一个集体和一致的观点已经成为一项巨大的资产。由 New Relic 和微软应用洞察等服务普及的**应用性能管理**（**APM**）系统使用有关应用程序和基础设施记录的信息，称为遥测，以监控、管理性能和查看系统的可用性。在基于云的解决方案中，通常无法或实际无法直接访问系统的基础设施，APM 允许将遥测发送到中央服务，进行处理，然后如图所示呈现给运维和业务：

![图片](img/3799f3e4-3f09-45ba-b16e-43093c14d35c.png)

上述图表摘自微软应用洞察，提供了一个正在运行的 Web 应用程序的高级快照。一眼望去，运维人员可以识别系统行为的变更并据此做出反应。

# 持续集成/持续部署

**持续集成/持续部署**（**CI/CD**）是一种现代开发流程，旨在通过频繁合并更改和经常部署这些更改来简化**软件交付产品生命周期**（**SDLC**）。CI 解决了企业级软件开发中可能出现的问题，其中多个程序员正在同一个代码库上工作，或者当单个产品使用多个代码分支管理时。

看一下以下图表：

![](img/242a34d7-263b-49fd-bcbd-c06e5fe5d85c.png)

在前面的示例中，有三个目标环境：开发、**用户验收测试**（**UAT**）和产品。开发环境是所有对应用程序所做的更改一起测试的初始环境。UAT 环境由**质量保证**（**QA**）团队使用，以验证系统在更改移动到面向客户的环境（在图中称为产品）之前按预期工作。代码库已被分成三个匹配的分支：主干，所有开发团队的更改都合并到其中；UAT，用于部署到 UAT 环境；以及产品代码库，用于部署到产品环境。

CI 模式通过在代码库更改时创建新的构建来应用。在构建成功后，会运行一系列单元测试来确保现有功能没有被破坏。如果构建不成功，开发团队将进行调查，并修复代码库或单元测试，以便构建通过。

然后将成功的构建推送到目标环境。主干可能被设置为每天自动将新构建推送到集成环境，而 QA 团队要求减少对环境的干扰，因此新构建仅在下班后每周推送一次。产品可能需要手动触发来协调新版本发布，以便正式发布中宣布新功能和错误修复。

对于**持续部署**和**持续交付**这两个术语存在混淆。许多资料将这两个术语区分开来，以确定部署过程是自动的还是手动的。换句话说，持续部署需要自动化的持续交付。

导致环境合并并因此将构建推送到环境或发布的触发器可能不同。在我们的开发环境示例中，我们有一套针对新构建自动运行的自动化测试。如果测试成功，则从主干分支自动合并到 UAT 代码库。UAT 和产品代码库之间的合并只有在 QA 团队签署或接受 UAT 环境中的更改后才会进行。

每个企业都会根据其特定的 SDLC 和业务需求定制 CI/CD 流程。例如，一个面向公众的网站可能需要一个快速的 SDLC 来在市场上保持竞争力，而一个内部应用程序可能需要一个更保守的方法来限制由于功能更改而造成的干扰，同时不需要员工培训。

不论如何，已经开发了一系列工具来管理组织内部的 CI/CD 流程。例如，Azure DevOps 通过允许构建管道来处理构建创建和发布到环境（包括手动和自动触发）的过程，从而帮助管理这一流程。

# 摘要

云开发需要仔细规划、维护和监控，模式可以帮助实现高度可扩展、可靠和安全的解决方案。本章讨论的许多模式适用于本地应用程序，并在云解决方案中至关重要。云优先应用程序的设计应考虑许多因素，包括可扩展性、可用性、维护、监控和安全。

可扩展的应用程序允许系统负载在波动的同时保持可接受的性能水平。负载可以通过用户数量、并发进程、数据量以及软件中的其他因素来衡量。能够水平扩展解决方案需要特定类型的应用程序开发，并且这种范式对于云计算特别重要。例如，基于队列的负载均衡模式是一种确保在增加负载下解决方案保持响应性的优秀技术。

本章中讨论的许多模式都是互补的。例如，遵循命令和查询责任分离的应用程序可能会利用联邦安全来提供单一登录体验，并使用事件驱动架构来处理应用程序不同组件之间的一致性。

在基于云的解决方案中，存在几乎无限的适用模式集合，这些模式针对分布式系统中的不同挑战。本章中展示的模式是根据它们的广度和相互补充性选择的。请参阅参考文献以探索其他适用于基于云解决方案的模式。

多么精彩的旅程！我们涵盖了从面向对象编程中使用的软件设计模式到基于云解决方案中使用的架构模式，再到更高效团队的业务模式和构建成功应用程序的模式。尽管我们试图涵盖广泛的模式，但肯定有一些模式本可以，也应该被添加。

在此，感谢 Gaurav 和 Jeffrey，并希望您在阅读《动手实践 C#和.NET Core 设计模式》时有所收获。请告诉我们您的想法，并与我们分享您最喜欢的模式。

# 问题

以下问题将帮助您巩固本章包含的信息：

1.  大多数模式都是最近开发的，并且仅适用于基于云的应用程序。这是真的还是假的？

1.  ESB 代表什么，可以在哪种类型的架构中使用：EDA、SOA 还是单体？

1.  基于队列的负载均衡主要用于 DevOps、可扩展性还是可用性？

1.  CI/CD 的好处是什么？它对大量全球分散的团队或单个小型本地化开发团队更有益吗？

1.  在遵循静态内容托管的网站上，浏览器是直接通过 CDN 检索图像和静态内容，还是由 Web 应用程序代表浏览器检索信息？

# 进一步阅读

要了解更多关于本章涵盖的主题，请参考以下书籍。这些书籍将为您提供关于本章已涵盖主题的各种深入和实战练习：

+   *《Azure 无服务器计算食谱》，作者* *Praveen Kumar Sreeram*，由* *Packt Publishing* *出版*：[`www.packtpub.com/in/virtualization-and-cloud/azure-serverless-computing-cookbook`](https://www.packtpub.com/in/virtualization-and-cloud/azure-serverless-computing-cookbook)

+   *《使用 Azure 的微服务》，作者* *Namit Tanasseri* *和* *Rahul Rai*，由* *Packt Publishing* *出版*：[`www.packtpub.com/in/virtualization-and-cloud/microservices-azure`](https://www.packtpub.com/in/virtualization-and-cloud/microservices-azure)

+   *《开发者实战 Azure》，作者* *Kamil Mrzygłód*，由* *Packt Publishing* *出版*：[`www.packtpub.com/virtualization-and-cloud/hands-azure-developers`](https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers)

+   *《使用.NET Core 2.0 构建微服务 - 第二版》，作者* *Gaurav Aroraa*，由* *Packt Publishing* *出版*：[`www.packtpub.com/application-development/building-microservices-net-core-20-second-edition`](https://www.packtpub.com/application-development/building-microservices-net-core-20-second-edition)。
