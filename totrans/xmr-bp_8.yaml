- en: Chapter 8. Building a Camera Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章. 构建相机应用程序
- en: We have reached the end of an era, learning the ins and outs of cross-platform
    development using the `Xamarin` platform.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了一个时代的尽头，学习了使用 `Xamarin` 平台进行跨平台开发的方方面面。
- en: In our last chapter, we are going to walk-through the final `Xamarin.Forms`
    project. We will introduce Effects, Triggers, and how they apply to UI elements.
    Then, we will build a `CustomRenderer` for each platform camera. The following
    topics will be covered in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们上一章中，我们将介绍 Effects、Triggers 以及它们如何应用于 UI 元素。然后，我们将为每个平台相机构建一个 `CustomRenderer`。本章将涵盖以下主题。
- en: 'Expected knowledge:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 预期知识：
- en: '`Xamarin.Forms`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Xamarin.Forms`'
- en: XAML
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XAML
- en: MVVM
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVVM
- en: C# threading
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 线程
- en: HashMap data structures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HashMap 数据结构
- en: CustomRenderers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义渲染器
- en: '`INotifiedPropertyChanged` framework'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INotifiedPropertyChanged` 框架'
- en: 'In this chapter, you will learn the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Solution setup
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案设置
- en: Building the `MainPageViewModel`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 `MainPageViewModel`
- en: Improving the `INotifiedPropertyChanged` implementation
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进 `INotifiedPropertyChanged` 实现
- en: Creating the custom UI objects
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义 UI 对象
- en: Building the `FocusView`
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 `FocusView`
- en: '`Xamarin.Forms` animations'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Xamarin.Forms` 动画'
- en: '`Xamarin.Forms` compound animations'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Xamarin.Forms` 复合动画'
- en: Building the `CameraView`
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 `CameraView`
- en: Building a control for the iOS camera
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 iOS 相机的控件
- en: Building the iOS `CameraRenderer`
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 iOS 的 `CameraRenderer`
- en: Integrating the Android Camera2 framework
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成 Android Camera2 框架
- en: Building the `CameraViewRenderer` in Android
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Android 中构建 `CameraViewRenderer`
- en: Handling native touch events through the `FocusView`
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `FocusView` 处理原生触摸事件
- en: Using RX to handle events
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 RX 处理事件
- en: Building a `VisualElementRenderer` for iOS
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 iOS 的 `VisualElementRenderer`
- en: Building the `CustomImageRenderer`
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 `CustomImageRenderer`
- en: Building the `UIImageEffect` class
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 `UIImageEffect` 类
- en: Building the `CustomImageRenderer` for Android
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 Android 的 `CustomImageRenderer`
- en: Triggers
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发器
- en: Platform effects
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台效果
- en: Building the `CameraPage`
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 `CameraPage`
- en: Adding native orientation events
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加原生方向事件
- en: Solution setup
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案设置
- en: Let's begin by creating a new `Xamarin.Forms` project and calling it `Camera`.
    We also want to create the `Camera.Portable` project. Now that we have built up
    several `Xamarin.Forms` applications, we have a lot of reusable parts that will
    be brought across to this application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的 `Xamarin.Forms` 项目并命名为 `Camera` 开始。我们还想创建 `Camera.Portable` 项目。现在我们已经构建了几个
    `Xamarin.Forms` 应用程序，我们有很多可重用的部分将跨到这个应用程序中。
- en: Starting with the `Camera.Portable` project, we want to copy in the `IoC`, `Extras`,
    and `Logging` folders used in [Chapter 7](ch07.html "Chapter 7.  Building a File
    Storage Application"), *Building a File Storage Application*. Make sure all the
    files contained in these folders are copied in accordingly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Camera.Portable` 项目开始，我们想要复制在 [第 7 章](ch07.html "第 7 章. 构建文件存储应用程序") 中使用的
    `IoC`、`Extras` 和 `Logging` 文件夹，即 *构建文件存储应用程序*。确保这些文件夹中包含的所有文件都已相应复制。
- en: Tip
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Don't forget to update namespaces in each code sheet.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记更新每个代码表中的命名空间。
- en: 'Then we want to add the following NuGet packages for every project:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们想要为每个项目添加以下 NuGet 包：
- en: Autofac
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Autofac
- en: Reactive extensions
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式扩展
- en: 'Next, we want to create a folder called **Enums**. Add in a new folder called
    `PageNames.cs` and implement the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要创建一个名为 **Enums** 的文件夹。添加一个名为 `PageNames.cs` 的新文件夹，并实现以下内容：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Like our other projects, this will be used in the navigation setup. In this
    folder, we also want to add another file called `Orientation.cs` and implement
    the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的其他项目一样，这将在导航设置中使用。在这个文件夹中，我们还想添加另一个名为 `Orientation.cs` 的文件，并实现以下内容：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This `enum` will be used with orientation settings on our `CameraPage`. Each
    different orientation setting will be handled for adjusting camera preview surface
    areas.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `enum` 将与 `CameraPage` 上的方向设置一起使用。每个不同的方向设置都将被处理以调整相机预览表面区域。
- en: 'Our next step is to create a new folder called `UI` and copy in the `INavigationService.cs`.
    We also want to add another file called `AlertArgs.cs` and implement the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是创建一个名为 `UI` 的新文件夹，并复制 `INavigationService.cs`。我们还想添加另一个名为 `AlertArgs.cs`
    的文件，并实现以下内容：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding class will be used inside all alerts that are invoked inside our
    view-models. We use a `TaskCompletionSource` object to await the method that fires
    the alert, and the `Message` object for every alert message.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类将在我们视图模型中调用的所有警报中使用。我们使用 `TaskCompletionSource` 对象等待触发警报的方法，并为每个警报消息使用 `Message`
    对象。
- en: Building the MainPageViewModel class
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 `MainPageViewModel` 类
- en: 'Let''s add the `ViewModelBase` class, which will contain the `AlertArgs` event.
    Create a new folder called `ViewModels`, add in a new file called `ViewModelBase.cs`,
    and implement the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加`ViewModelBase`类，它将包含`AlertArgs`事件。创建一个名为`ViewModels`的新文件夹，添加一个名为`ViewModelBase.cs`的新文件，并实现以下内容：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `ViewModelBase` class will be similar to the other `Xamarin.Forms` projects.
    We have the `INotifiedPropertyChanged` requirements, another `EventHandler` for
    alerts, and the `INavigationService` for navigation control.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewModelBase`类将与其他`Xamarin.Forms`项目类似。我们有`INotifiedPropertyChanged`要求，另一个用于警报的`EventHandler`，以及用于导航控制的`INavigationService`。'
- en: 'Next, we have the constructor:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有构造函数：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Improving the INotifiedPropertyChanged implementation
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进`INotifiedPropertyChanged`实现
- en: 'As you may have noticed from previous projects, our standard property implementation
    for handling property changes looks like the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从以前的项目中注意到的，我们处理属性更改的标准属性实现看起来如下：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The repeated code in every public property makes our view-model code look much
    bigger than it actually is. In all your code sheets, a good coding practice to
    think about is how you can reduce the amount of lines of code and, especially
    repeated code. The following function `SetProperty` is an example of how we can
    turn 13 lines of code into just two:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每个公共属性中的重复代码使得我们的视图模型代码看起来比实际要大得多。在你所有的代码表中，一个值得考虑的良好编码实践是如何减少代码行数，尤其是重复代码。以下`SetProperty`函数是一个例子，说明我们如何将13行代码转换为仅仅两行：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In all properties, we always check first if the value being assigned is different
    to the current value before firing the `OnPropertyChanged` function. Since this
    is a generic type function, the same logic can be used for any property on all
    view-models. Now the `DescriptionMessage` property will look like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有属性中，我们总是首先检查要分配的值是否与当前值不同，然后再触发`OnPropertyChanged`函数。由于这是一个泛型类型函数，相同的逻辑可以用于所有视图模型上的任何属性。现在`DescriptionMessage`属性将看起来如下：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s add the rest of the `ViewModelBase` as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式添加剩余的`ViewModelBase`：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding functions are the same from previous implementations. Take note
    of how we fire the `Alert` event. Since we now have access to C# 6.0, we can turn
    a standard null check on an event like the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数与之前的实现相同。注意我们是如何触发`Alert`事件的。由于我们现在可以访问C# 6.0，我们可以将标准空检查转换为以下事件：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Into this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 变成这样：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It looks much cleaner, meaning we can remove all the `if` statements.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来更干净，这意味着我们可以移除所有的`if`语句。
- en: 'Now let''s add a new file called `MainPageViewModel.cs` and implement the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加一个名为`MainPageViewModel.cs`的新文件，并实现以下内容：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Exactly like the other `MainPageViewModel` objects, the `MainPage` layout is
    the same, with two buttons, an image, and a label.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他`MainPageViewModel`对象一样，`MainPage`布局相同，有两个按钮、一个图像和一个标签。
- en: 'Now let''s add the `public` properties. We are going to use the new `SetProperty`
    function for each `public` property:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加`public`属性。我们将为每个`public`属性使用新的`SetProperty`函数：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now for the constructor, we are going to use the `Command` factory again to
    instantiate our binded `Command`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对于构造函数，我们将再次使用`Command`工厂来实例化我们的绑定`Command`：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now let''s build the next view-model for the `CameraPage`. Add a new file called
    `CameraPageViewModel.cs` to the `ViewModels` folder and implement the private
    properties to begin with:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为`CameraPage`构建下一个视图模型。在`ViewModels`文件夹中添加一个名为`CameraPageViewModel.cs`的新文件，并首先实现私有属性：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `CameraPage` is going to include an `Orientation` property for adjusting
    `Grid` rows and columns using converters. The `_photoData` property will be used
    for recording the image taken as bytes, we will also be using these bytes to bind
    to an `ImageSource`. The `_loadingMessage` and `_cameraLoading` properties are
    used when displaying a view showing the native camera hardware is busy. The `_isFlashOn`
    will be used to control UI elements displaying the status of the flash. The `CameraPage`
    will also have a target image representing the focus target. Then finally, the
    `_canCapture` is used to determine whether the camera has loaded and we are ready
    to take photos, and the `_photoEditOn` is used to bind the visibility status of
    a view showing the photo just taken.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`CameraPage`将包含一个`Orientation`属性，用于使用转换器调整`Grid`的行和列。`_photoData`属性将用于记录以字节形式拍摄的图像，我们还将使用这些字节绑定到`ImageSource`。`_loadingMessage`和`_cameraLoading`属性在显示表示原生相机硬件正在忙碌的视图时使用。`_isFlashOn`将用于控制显示闪光灯状态的UI元素。`CameraPage`还将有一个表示聚焦目标的图像。最后，`_canCapture`用于确定相机是否已加载并且我们准备好拍照，而`_photoEditOn`用于绑定显示刚刚拍摄的照片的视图的可见性状态。'
- en: 'Next, we add the `public` properties; following are two to get you started:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加`public`属性；以下有两个以供开始：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the constructor as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 添加构造函数如下：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now for the `public` functions, we have the `AddPhoto` function, this will
    take the image as bytes from the native side, and the `PhotoData` is assigned
    for the `ImageSource` binding:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对于`public`函数，我们有`AddPhoto`函数，这个函数将从原生侧以字节形式获取图像，并将`PhotoData`分配给`ImageSource`绑定：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We also have a function for resetting the variables used in the current photo
    taken. When the `PhotoEditOn` is `false`, this means we remove the view that is
    displaying the current photo taken. When the `PhotoData` property is assigned
    an empty byte array, this means we have freed the data of the image that is currently
    displaying:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个用于重置当前拍摄照片所使用的变量的函数。当`PhotoEditOn`为`false`时，这意味着我们移除了显示当前拍摄照片的视图。当`PhotoData`属性被分配一个空字节数组时，这意味着我们已释放了当前显示的图像数据：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we have two more functions that are called when the page appears and
    disappears:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当页面出现和消失时，我们有两个更多函数被调用：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `OnAppear` function simply resets the `CameraLoading` property to `false`,
    and the `OnDisappear` function resets the entire view-model; when we return to
    this page, the state is the same as the starting point (that is, the camera is
    not loading, no photo is showing)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnAppear`函数简单地重置`CameraLoading`属性为`false`，而`OnDisappear`函数重置整个视图模型；当我们返回到这个页面时，状态与起点相同（即，相机没有加载，没有照片显示）'
- en: 'Excellent! Now that we have built our view-models, let''s add the `PortableModule`
    for our IoC container as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们已经构建了视图模型，让我们为我们的IoC容器添加`PortableModule`如下：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let's begin building the user interface screens.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建用户界面屏幕。
- en: Creating the custom UI objects
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义UI对象
- en: 'Jump back in the `Camera` project and let''s begin adding a new folder called
    `Controls`. Add in a new file called `OrientationPage.cs` and implement the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`Camera`项目，让我们开始添加一个名为`Controls`的新文件夹。添加一个名为`OrientationPage.cs`的新文件，并实现以下内容：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In our previous chapter, we created an `ExtendedContentPage` for handling alerts.
    This time, the `ExtendedContentPage` will inherit the `OrientationPage`, meaning
    it will be handling orientation events as well. The `CameraPage` is going to use
    this `OrientationPage` to track orientation events to resize camera preview areas,
    and rotate the camera view.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的章节中，我们创建了一个`ExtendedContentPage`来处理警报。这次，`ExtendedContentPage`将继承`OrientationPage`，这意味着它将处理方向事件。`CameraPage`将使用这个`OrientationPage`来跟踪方向事件，以调整相机预览区域的大小，并旋转相机视图。
- en: Our next control is the `FocusView`. It is going to be used for custom rendering
    purposes so that we are able to record touch point (*x*, *y*) coordinates on a
    view plane. These touch points will then be used to focus the camera at that particular
    (*x*, *y*) coordinate.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个控件是`FocusView`。它将被用于自定义渲染目的，以便我们能够在视图平面上记录触摸点（*x*，*y*）坐标。这些触摸点将被用来聚焦到特定的（*x*，*y*）坐标。
- en: 'Our next custom control is an extension to the `Image` class. Add another file
    into the `Controls` folder called `CustomImage.cs` and implement the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个自定义控件是对`Image`类的扩展。在`Controls`文件夹中添加另一个名为`CustomImage.cs`的文件，并实现以下内容：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: These custom bindings will be used for tinting. Since this view will be used
    for a `CustomRenderer`, we will have access to native tinting features. This is
    where we will add some advanced techniques to our  `CustomRenderer`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些自定义绑定将用于着色。由于这个视图将用于 `CustomRenderer`，我们将能够访问原生着色功能。这就是我们将在此处添加一些高级技术到我们的
    `CustomRenderer` 的地方。
- en: 'Next, we are going to add two more custom bindings. The `Path` property will
    be used for the absolute path of the file, and the `Aspect` property will be used
    for the image aspect ratio so we can change the image aspect natively:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加两个额外的自定义绑定。`Path` 属性将用于文件的绝对路径，而 `Aspect` 属性将用于图像的宽高比，这样我们就可以原生地更改图像的宽高比：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Have a look at the delegate function passed in as the last parameter for each
    `Create` function. This will be called every time the property changes; the `bindable`
    object that comes from the first parameter of this delegate function is the object
    itself. We retrieve the `CustomPropertyChangedEventHandler` and fire a new event
    to signal that a property on this object has changed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 查看每个 `Create` 函数作为最后一个参数传递的委托函数。这将每次属性更改时被调用；来自此委托函数的第一个参数的 `bindable` 对象是本身。我们检索
    `CustomPropertyChangedEventHandler` 并触发一个新事件，以表示此对象上的属性已更改。
- en: 'Let''s add the following to the `CustomImage` class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `CustomImage` 类中添加以下内容：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That's all for the `CustomImage` class; let's move on to the next custom control.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomImage` 类的所有内容到此为止；让我们继续下一个自定义控件。'
- en: Building the FocusView
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 FocusView
- en: The `FocusView` is going to be used as an overlay view with a target image for
    touching focus points. This will be a `CustomRenderer` as we have to use native
    libraries for retrieving specific (*x*, *y*) coordinates on touch points.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`FocusView` 将用作带有目标图像的触摸聚焦点的叠加视图。这将是一个 `CustomRenderer`，因为我们必须使用原生库在触摸点上检索特定的
    (*x*, *y*) 坐标。'
- en: 'Start with adding a new file into the `Controls` folder called `FocusView.cs`
    and implement the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从在 `Controls` 文件夹中添加一个名为 `FocusView.cs` 的新文件开始，并实现以下内容：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first part we see here are two `Point` objects for specific (*x*, *y*) coordinates
    for portrait and landscape orientation starting points. These two points will
    be set when the view first loads. Both points will be set to the center of the
    view in both landscape and portrait orientations. We also have the _`startingPointsAssigned`
    Boolean to ensure we only set the starting focus points once.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的第一部分是两个 `Point` 对象，用于特定 (*x*, *y*) 坐标，作为纵向和横向方向的起始点。这两个点将在视图首次加载时设置。在纵向和横向方向上，这两个点都将设置为视图的中心。我们还有一个
    `_startingPointsAssigned` 布尔值，以确保我们只设置一次起始焦点点。
- en: The `CustomImage` object is used for the actual image of the target. We will
    be using the tinting properties each time a user touches to focus. The `_isAnimating`
    property is used for tracking progress of current animations (we will be animating
    the scale of the image each time a touch is detected). The constant property is
    used to hard set the height and width of the target image, and we have two events
    for detecting all user touch events.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomImage` 对象用于目标图像的实际图像。每次用户触摸以聚焦时，我们将使用着色属性。`_isAnimating` 属性用于跟踪当前动画的进度（每次检测到触摸时，我们将动画图像的缩放）。常量属性用于硬设置目标图像的高度和宽度，我们有两个事件用于检测所有用户触摸事件。'
- en: 'Next, we have a single public property for the orientation:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个用于方向的公共属性：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Xamarin.Forms animations
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Xamarin.Forms 动画
- en: '`Xamarin.Forms` has multiple functions for animating views. We have access
    to the following functions:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`Xamarin.Forms` 有多个用于动画视图的功能。我们可以访问以下功能：'
- en: '`FadeTo`: This is used to animate opacity (that is, fade in/out).'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FadeTo`：用于动画不透明度（即淡入/淡出）。'
- en: '`RotateTo`: This is used to animate rotations.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RotateTo`：用于动画旋转。'
- en: '`ScaleTo`: This is used to animate size.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScaleTo`：用于动画大小。'
- en: '`TranslateTo`: This is used to animate (*x*, *y*) positions.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TranslateTo`：用于动画 (*x*, *y*) 位置。'
- en: '`LayoutTo`: This is used to animate *x*, *y*, width, and height.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LayoutTo`：用于动画 *x*, *y*, 宽度和高度。'
- en: Tip
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Stay away from the `LayoutTo` function. Jason Smith (the creator of `Xamarin.Forms`)
    recommends you stick with the `TranslateTo` instead. The issue with `LayoutTo`
    is the parent of the view you are calling `LayoutTo` on will not be aware of the
    translation/resize that happened and will simply overwrite it at the next layout
    cycle (like when you rotate the device). This is because `LayoutTo` is calling
    the same method Layouts call to position children.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用`LayoutTo`函数。Jason Smith（`Xamarin.Forms`的创建者）建议您坚持使用`TranslateTo`。`LayoutTo`的问题在于您调用的`LayoutTo`视图的父视图将不会意识到发生的平移/调整大小，并在下一次布局周期（例如当您旋转设备时）简单地覆盖它。这是因为`LayoutTo`调用与布局调用相同的方法来定位子视图。
- en: 'We are now going to use a few of these animation functions to animate our target
    image when a use touches to focus. The `AnimateFocalTarget` function will be responsible
    for performing the animations every time a user touches the view. At first, it
    will change the tint color of the image to green, then translate the (*x*, *y*)
    coordinate to the starting position, expand the scale, fade the image, contract
    the scale, and wait a second until the tint color changes back to white:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用一些这些动画函数来在用户触摸以聚焦时动画化我们的目标图像。`AnimateFocalTarget`函数将负责在用户每次触摸视图时执行动画。最初，它将改变图像的色调颜色为绿色，然后将（*x*，*y*）坐标平移到起始位置，放大比例，淡入图像，缩小比例，然后等待一秒钟直到色调颜色变回白色：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: All these await functions, is there a cleaner way?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些等待函数，有没有更简洁的方法？
- en: In a lot of cases, you will need to combine multiple transitions at any one
    time. Let's replace the preceding combination of animations with a compound animation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在很多情况下，您可能需要同时结合多个过渡效果。让我们用复合动画替换前面的动画组合。
- en: Xamarin.Forms compound animations
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Xamarin.Forms复合动画
- en: 'Compound animations give you the ability to combine multiple animations as
    a storyboard. Let''s replace the preceding function with our new implementation
    using a compound animation as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 复合动画允许您将多个动画作为一个故事板组合起来。让我们用以下方式替换前面的函数，使用复合动画作为我们的新实现：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Each `Animation` object has the property we are animating, a start point and
    an end point, and `easing` (linear, bounce in, bounce out). All `Animation` objects
    are then added to the storyboard. The first two parameters of the `Add` function
    are the start time and finish time of that particular animation. Finally, we call
    the commit, and instead of awaiting the `Commit` function, we will use a `TaskCompletionSource`
    object to await the commit until it is finished. The `finished` action is called
    after the length of 300 milliseconds.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Animation`对象都有我们正在动画化的属性、一个起点和一个终点，以及`easing`（线性、弹入、弹出）。然后，所有`Animation`对象都被添加到故事板中。`Add`函数的前两个参数是特定动画的起始时间和结束时间。最后，我们调用提交，而不是等待`Commit`函数，我们将使用`TaskCompletionSource`对象等待提交完成。`finished`操作在300毫秒后调用。
- en: Isn't that much nicer than our previous implementation?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这难道不是比我们之前的实现更优雅吗？
- en: We should use this approach when we have multiple animations to commit at any
    one time.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们一次需要提交多个动画时，我们应该使用这种方法。
- en: 'Now let''s add the `Reset` functions to our `FocusView`. This will be called
    whenever an orientation has occurred, we will use the assign the focus point to
    the correct orientation starting point:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向`FocusView`添加`Reset`函数。这将在发生方向变化时被调用，我们将把聚焦点分配给正确的方向起始点：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `NotifyFocus` function is responsible for controlling the entire touch
    animation; this is where we will set the starting state of the `_focalTarget`
    image, call the `AddFocualTargetImg` function, and then fire the `TouchFocus`
    event. This event will be used to focus the `CameraView` through the custom renderer:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotifyFocus`函数负责控制整个触摸动画；这就是我们将设置`_focalTarget`图像的起始状态、调用`AddFocualTargetImg`函数，然后触发`TouchFocus`事件的地方。此事件将用于通过自定义渲染器聚焦`CameraView`：'
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we have the `SetFocusPoints` function to assign the starting focus
    points in each orientation (landscape and portrait). These starting points will
    always be the center of the `CameraView`. This is to ensure that the `_focalTarget`
    image is centered inside the `CameraView` on every change in orientation:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`SetFocusPoints`函数来分配每个方向（横屏和竖屏）的起始聚焦点。这些起始点将始终是`CameraView`的中心。这是为了确保在每次方向改变时`_focalTarget`图像都在`CameraView`内部居中：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That's everything for our `FocusView`. Let's add our next custom UI element,
    the `CameraView`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`FocusView`来说，这就全部了。让我们添加我们的下一个自定义UI元素，`CameraView`。
- en: Building the CameraView
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建CameraView
- en: 'Our next custom element is the UI object for rendering the native camera. Let''s
    add a new file into the `Controls` folder called `CameraView.cs` and implement
    the first part:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个自定义元素是用于渲染原生相机的UI对象。让我们在`Controls`文件夹中添加一个名为`CameraView.cs`的新文件，并实现第一部分：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There are many events to manage because we have to handle events coming from
    the `Xamarin.Forms` object in order for the native object to respond to, and vice-versa.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们必须处理来自`Xamarin.Forms`对象的来自原生对象的事件，以便原生对象能够响应，反之亦然，因此有许多事件需要管理。
- en: 'Next, we add the public properties:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加公共属性：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first `bool` is set when we receive events for the `AvailabilityChangeEventHandler`.
    The `Orientation` property is assigned every time the screen orientation changes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们收到`AvailabilityChangeEventHandler`的事件时，第一个`bool`被设置。每次屏幕方向改变时，都会分配`Orientation`属性。
- en: Tip
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Screen orientation changes will come from the native side, these events will
    come from the `AppDelegate` (iOS), `MainActivity` (Android), and `MainPage.xaml.cs`
    (Windows).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕方向改变将来自原生端，这些事件将来自`AppDelegate`（iOS）、`MainActivity`（Android）和`MainPage.xaml.cs`（Windows）。
- en: Then we have the `CameraButtonContainerWidth`, this will only be relevant for
    iOS as we need to resize the preview layer for the iOS camera when the orientation
    changes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有`CameraButtonContainerWidth`，这仅对iOS相关，因为我们需要在iOS相机方向改变时调整预览层的尺寸。
- en: 'Our next functions are all for notifying the preceding events:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的函数都是用于通知前一个事件：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we have the constructor:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有构造函数：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Excellent! Now we have the final custom control to build. Add a new `ContentView.xaml`,
    as shown in the following screenshot:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们有了构建的最终自定义控件。添加一个新的`ContentView.xaml`，如图所示：
- en: '![Building the CameraView](img/image_08_001.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![构建CameraView](img/image_08_001.jpg)'
- en: 'Call the `LoadingView.xaml` file and implement the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`LoadingView.xaml`文件并实现以下内容：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The layout of the `FocusView` consists of a `Grid` containing another `StackLayout`,
    which is centered both horizontally and vertically inside the `Grid`. The `StackLayout`
    contains an `ActivityIndicator`, which will be running every time this view is
    shown, and a `Label` to display a loading message.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`FocusView`的布局由一个包含另一个`StackLayout`的`Grid`组成，该`StackLayout`在`Grid`中水平和垂直居中。`StackLayout`包含一个`ActivityIndicator`，每次此视图显示时都会运行，以及一个`Label`用于显示加载信息。'
- en: 'Then, expand the `LoadingView.xaml.cs` and implement the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，展开`LoadingView.xaml.cs`并实现以下内容：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This view will be used on the `CameraPage`. When the camera is loading or processing
    an image, the entire screen will be cast black, displaying the `ActivityIndicator`
    and loading message, to show the user that the camera is processing.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图将在`CameraPage`中使用。当相机正在加载或处理图像时，整个屏幕将变为黑色，显示`ActivityIndicator`和加载信息，以向用户显示相机正在处理中。
- en: Building a control for the iOS camera
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建iOS相机控件
- en: 'Now that we have built the `CameraView` object in the `Xamarin.Forms` PCL,
    we are going to build the `CustomRenderer` for iOS. Jump into the **Camera.iOS**
    project and add a new folder called `Renderers`, and then add a new file called
    `CameraiOS.cs` and implement the following private properties:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在`Xamarin.Forms` PCL中构建了`CameraView`对象，我们将为iOS构建`CustomRenderer`。跳转到**Camera.iOS**项目，添加一个名为`Renderers`的新文件夹，然后添加一个名为`CameraiOS.cs`的新文件，并实现以下私有属性：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `_tag` and `_log` properties will be used for all logging that occurs when
    an exception occurs. The `_previewLayer` is used to display the video input from
    the camera; this will be set to the entire width and height of the `CameraView`.
    The `_captureSession` is used in conjunction with an `AVCaptireVideoPreviewLayer`
    object for capturing an image from the video input. The `_input` object is used
    in conjunction with an `AVCaptureDevice` and `CaptureSession`; this provides the
    video stream input, which the `CaptureSession` will use to capture an image. We
    also have an `AVCaptureStillImageOutput` object called `_output`; this is used
    to capture high-quality still images with accompanying metadata.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`_tag`和`_log`属性将用于所有异常发生时的日志记录。`_previewLayer`用于显示来自相机的视频输入；这将设置为`CameraView`的整个宽度和高度。`_captureSession`与`AVCaptireVideoPreviewLayer`对象一起使用，用于从视频输入捕获图像。`_input`对象与`AVCaptureDevice`和`CaptureSession`一起使用；这提供了视频流输入，`CaptureSession`将使用它来捕获图像。我们还有一个名为`_output`的`AVCaptureStillImageOutput`对象；这用于捕获带有相关元数据的高质量静态图像。'
- en: An `AVCaptureStillImageOutput` object also contains `AVCaptureConnections`,
    which we use for controlling the video stream orientation. Then finally, we have
    the `_device` property, which is the object that represents a physical capture
    device. In our example, we are going to use the rear camera. We will see how the
    remaining properties are used through the other functions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`AVCaptureStillImageOutput` 对象还包含 `AVCaptureConnections`，我们使用它来控制视频流的方向。然后最后，我们有
    `_device` 属性，它代表一个物理捕获设备。在我们的例子中，我们将使用后置摄像头。我们将通过其他函数了解剩余属性的使用方法。'
- en: 'Next we have to add three events that will be notified when the camera is busy,
    when the camera is available, and when a photo is taken:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须添加三个事件，当相机忙碌、可用以及拍照时将会通知这些事件：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then we have the constructor:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有构造函数：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The constructor will start with retrieving the `ILogger` object from the `IoC`
    container and assigning the `_tag` to the type name using C# 6\. Then we retrieve
    the system version information and create a new `UIView`. Setting the `AutoresizingMask`
    to `UIViewAutoresizing.FlexibleMargins` ensures that the `CameraiOS` view adjusts
    to the entire bounds of the `CustomRenderer`. Then we instantiate a new `AvCaptureSession`
    and an `AVCaptureVideoPreviewLayer`, we pass the `AVCaptureSession` object into
    the new `AVCaptureVideoPreviewLayer,` and add this layer to the `mainView` layer.
    We then retrieve the physical camera device using the `RetrieveCameraDevice` function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将从 `IoC` 容器中检索 `ILogger` 对象，并使用 C# 6 将 `_tag` 赋值给类型名称。然后我们检索系统版本信息并创建一个新的
    `UIView`。将 `AutoresizingMask` 设置为 `UIViewAutoresizing.FlexibleMargins` 确保了 `CameraiOS`
    视图调整到 `CustomRenderer` 的整个边界。然后我们实例化一个新的 `AvCaptureSession` 和一个 `AVCaptureVideoPreviewLayer`，我们将
    `AVCaptureSession` 对象传递给新的 `AVCaptureVideoPreviewLayer`，并将此层添加到 `mainView` 层。然后我们使用
    `RetrieveCameraDevice` 函数检索物理摄像头设备。
- en: 'Let''s add this function in below the constructor:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在构造函数下方添加此函数：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'On this line, add the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行，添加以下内容：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is used to retrieve the physical rear-view camera.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于检索物理后视摄像头。
- en: Now let's get back to the constructor. After we retrieved the physical device,
    we simply add the `mainView` to the `CameraiOS` view and set the layout constraints
    of the `mainView` to fill the bounds of the `CameraiOS` view.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到构造函数。在我们检索到物理设备后，我们只需将 `mainView` 添加到 `CameraiOS` 视图中，并将 `mainView` 的布局约束设置为填充
    `CameraiOS` 视图的边界。
- en: 'Next, we add the `private` functions. Our first function `AdjustPreviewLayer`
    is responsible for setting the bounds of the layer to fill the `CameraiOS` view
    when an orientation change occurs:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加 `private` 函数。我们的第一个函数 `AdjustPreviewLayer` 负责在发生方向变化时设置层的边界以填充 `CameraiOS`
    视图：
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We also need a function for setting the starting orientation:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个用于设置起始方向的函数：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then we have the `SetBusy` function, which will invoke the `Busy` EventHandler
    and set the `private` variable to keep the busy status locally:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有 `SetBusy` 函数，它将调用 `Busy` EventHandler 并设置 `private` 变量以保持忙碌状态：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we have the `CaptureImageWithMetadata` function. This is called every
    time the user clicks to take a picture (this function will be called from the
    public method `TakePhoto`). When we call the `CaptureImageWithMetadata` function,
    we must pass in an `AVCaptureStillImageOutput` object and an `AVCaptureConnection`.
    From the `AVCaptureStillImageOutput` object, we call the `CaptureStillImageTaskAsync`
    function on the `AVCaptureConnection`. The connection we pass in is linked to
    the `_previewLayer` connection. After this call is successful, we retrieve the
    raw image as a JPEG and retrieve the raw bytes to invoke the `Photo` EventHandler.
    We also use the `RotateImage` function for rotating the original `UIImage` image
    to the correct orientation:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有 `CaptureImageWithMetadata` 函数。每次用户点击拍照时都会调用此函数（此函数将从公共方法 `TakePhoto`
    调用）。当我们调用 `CaptureImageWithMetadata` 函数时，我们必须传递一个 `AVCaptureStillImageOutput`
    对象和一个 `AVCaptureConnection`。从 `AVCaptureStillImageOutput` 对象中，我们在 `AVCaptureConnection`
    上调用 `CaptureStillImageTaskAsync` 函数。我们传递的连接与 `_previewLayer` 连接相关联。在此调用成功后，我们检索原始图像作为
    JPEG 并检索原始字节数据以调用 `Photo` EventHandler。我们还使用 `RotateImage` 函数将原始 `UIImage` 图像旋转到正确的方向：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s add the `RotateImage` function:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加 `RotateImage` 函数：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the preceding function, we use the `UIGraphics` context for rebuilding and
    rotating the `UIImage` image. We start with a new `CGImage`, gather the orientation
    from the original `UIImage`, and transform this image, then redraw using the `UIGraphics.GetImageFromCurrentImageContext()` method.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，我们使用`UIGraphics`上下文来重建和旋转`UIImage`图像。我们从一个新的`CGImage`开始，从原始的`UIImage`中获取方向，然后转换这个图像，接着使用`UIGraphics.GetImageFromCurrentImageContext()`方法重新绘制。
- en: 'Now we add the public methods. Start with overriding the `Draw` function so
    that we can assign the most recent frame on the `_previewLayer`. The `Draw` function
    is called every time the screen rotates. We want to ensure the `_previewLayer`
    frame fills the bounds of the screen:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们添加公共方法。首先重写`Draw`函数，以便我们可以将最新的帧分配给`_previewLayer`。`Draw`函数在屏幕旋转时被调用。我们想要确保`_previewLayer`的帧填充屏幕的边界：
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we have the `TakePhoto` function. This will retrieve the current `AVCaptureConnection`
    from the `AVCaptureStillImageOutput`, set the connection orientation to the `_previewLayer`
    orientation, and pass the connection and output to the `CaptureImageWithMetadata`
    function:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`TakePhoto`函数。这个函数将从`AVCaptureStillImageOutput`中检索当前的`AVCaptureConnection`，将连接的方向设置为`_previewLayer`的方向，并将连接和输出传递给`CaptureImageWithMetadata`函数：
- en: '[PRE49]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't forget to look at the exception handling occurring for all functions.
    Sometimes, bizarre errors can occur (null connections, device retrieval fails)
    when dealing with camera hardware, so we must handle all exceptions that may occur.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记查看所有函数的异常处理。在处理相机硬件时，有时可能会出现奇怪的错误（空连接、设备检索失败），因此我们必须处理可能发生的所有异常。
- en: 'Next, we have the `SwitchFlash` function, which is used to turn the flash on/off
    using the `AVCaptureDevice` configurations:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`SwitchFlash`函数，它用于通过`AVCaptureDevice`配置来打开/关闭闪光灯：
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then we have the `SetBounds` function. This is called from the `OnElementPropertyChanged`
    method of the `CustomRenderer`, on any height and with property changes:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有`SetBounds`函数。这个函数是从`CustomRenderer`的`OnElementPropertyChanged`方法中调用的，在任何高度和属性更改时都会调用：
- en: '[PRE51]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `ChangeFocusPoint` function is used for focusing the camera to the touch
    point received from the user. First, we must lock the `AVCaptureDevice` configurations
    before making any changes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChangeFocusPoint`函数用于将相机聚焦到从用户接收到的触摸点上。首先，我们必须在做出任何更改之前锁定`AVCaptureDevice`配置。'
- en: Tip
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When we make changes to the `AVCaptureDevice` configurations, we must first
    call `LockForConfiguration` to notify the device that we are making changes and
    then, once we are finished, call `UnlockForConfiguration` for the changes to take
    effect.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更改`AVCaptureDevice`配置时，我们必须首先调用`LockForConfiguration`来通知设备我们正在做出更改，然后，一旦我们完成，调用`UnlockForConfiguration`以使更改生效。
- en: 'Then we check to see if the `FocusPointOfInterestSupported` is `true` and set
    the `FocusPointOfInterest` to a new `CGRect` point. We also do the same with exposure
    by first checking the `ExposurePointOfInterestSupported` is `true` and setting
    the `ExposurePointOfInterest` to a new `CGRect` point:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查`FocusPointOfInterestSupported`是否为`true`，并将`FocusPointOfInterest`设置为一个新的`CGRect`点。我们同样通过首先检查`ExposurePointOfInterestSupported`是否为`true`，并将`ExposurePointOfInterest`设置为一个新的`CGRect`点来进行曝光：
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Our next function is `InitializeCamera`, which we use to set up the `AVCaptureDevice`.
    We set the focus mode to `ContinuousAuto` and create a new `AVCaptureDeviceInput`
    using the instance of the `AVCaptureDevice`. We then create a new `AvCaptureStillImageOutput`
    object. Both the `AVCaptureDeviceInput` and `AvCaptureStillImageOutput` objects
    are assigned to the input/output of the `AVCaptureSession`, respectively. After
    this, the new `NSDictionary` is created with a key to set the video CODEC to JPEG
    (all still images taken will be in this format). Finally, the `Connection` object
    from the `_previewLayer` is retrieved, the starting orientation is set accordingly,
    and we call the `StartRunning` method on the `AVCaptureSession`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个函数是`InitializeCamera`，我们用它来设置`AVCaptureDevice`。我们将焦点模式设置为`ContinuousAuto`，并使用`AVCaptureDevice`的实例创建一个新的`AVCaptureDeviceInput`。然后我们创建一个新的`AvCaptureStillImageOutput`对象。`AVCaptureDeviceInput`和`AvCaptureStillImageOutput`对象分别被分配给`AVCaptureSession`的输入/输出。之后，我们创建一个新的`NSDictionary`，使用键来设置视频编解码器为JPEG（所有拍摄的照片都将采用这种格式）。最后，从`_previewLayer`检索`Connection`对象，根据起始方向进行设置，并在`AVCaptureSession`上调用`StartRunning`方法：
- en: '[PRE53]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Our next function is `SetWidths`, which will assign the local `_cameraButtonConatinerWidth`
    property accordingly. This `local` property is used as an extra reduction on the
    camera stream width to ensure that the camera stream does not fall behind the
    black button panel on the `CameraPage`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个函数是`SetWidths`，它将相应地分配局部`_cameraButtonConatinerWidth`属性。这个`local`属性被用作对相机流宽度的额外减少，以确保相机流不会落后于`CameraPage`上的黑色按钮面板：
- en: '[PRE54]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Next, the last function is `HandleOrientationChange`, which will be called from
    the `CustomRenderer` every time an orientation occurs because we must update the
    `VideoOrientation` property of the `AVCaptureConnection` object.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，最后一个函数是`HandleOrientationChange`，每次发生方向变化时，`CustomRenderer`都会调用它，因为我们必须更新`AVCaptureConnection`对象的`VideoOrientation`属性。
- en: Tip
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Even though `Xamarin.Forms` automatically handles the orientation changes of
    the views for you, with this `CustomRenderer` view, the video stream from the
    `AVCaptureVideoPreviewLayer` does not rotate unless we change the underlying `CALayers`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Xamarin.Forms会自动为您处理视图的朝向变化，但使用这个`CustomRenderer`视图时，除非我们更改底层的`CALayers`，否则`AVCaptureVideoPreviewLayer`的视频流不会旋转。
- en: '[PRE55]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, we have the `StopAndDispose` method. This will be called from the
    `Dipose` method of the `CustomRenderer`. It is responsible for freeing up all
    the resources involved with the camera stream, and switching off the flash if
    it is on:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`StopAndDispose`方法。这个方法将从`CustomRenderer`的`Dipose`方法中被调用。它负责释放与相机流相关的所有资源，并在开启的情况下关闭闪光灯：
- en: '[PRE56]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Well done! Now we have built the native camera control, we are going to use
    this as the control for our CustomRenderer.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！现在我们已经构建了原生相机控制，我们将使用它作为CustomRenderer的控制。
- en: Building the iOS CameraRenderer
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建iOS CameraRenderer
- en: 'Now let''s create the actual `CustomRenderer` that will use this custom iOS
    object. Add a new file into **Renderers** | **CameraView**, call it `CameraViewRenderer.cs`,
    and implement the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建实际的`CustomRenderer`，它将使用这个自定义iOS对象。在**Renderers** | **CameraView**中添加一个新文件，命名为`CameraViewRenderer.cs`，并实现以下内容：
- en: '[PRE57]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The first part of our `CustomRenderer` shows the `OnElementChanged` override.
    In all custom renderers, the `OnElementChanged` function may be called multiple
    times, so care must be taken to avoid any memory leaks that can lead to performance
    impact. Following is the approach that should be taken:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`CustomRenderer`的第一部分显示了`OnElementChanged`的覆盖实现。在所有自定义渲染器中，`OnElementChanged`函数可能会被多次调用，因此必须小心避免可能导致性能影响的任何内存泄漏。以下是需要采取的方法：
- en: '[PRE58]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now back to the `OnElementChanged` implementation, we instantiate a new `CameraiOS`
    and register the EventHandlers to the `Xamarin.Forms``CameraView` functions. This
    will fire another event that will be handled on our `CameraPage`. We then call
    `SetNativeControl` to assign the `CameraiOS` object to the `CustomRenderer` control,
    so when `CameraView` object is displayed on a `ContentPage`, a `CameraiOS` view
    will appear on top. We then register events and unregister events in both the
    if blocks to correctly dispose and assign the `CameraView` EventHandlers.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到`OnElementChanged`的实现，我们实例化一个新的`CameraiOS`，并将事件处理程序注册到`Xamarin.Forms`的`CameraView`函数上。这将触发另一个事件，该事件将在我们的`CameraPage`上被处理。然后我们调用`SetNativeControl`将`CameraiOS`对象分配给`CustomRenderer`控制，这样当`CameraView`对象在`ContentPage`上显示时，一个`CameraiOS`视图将出现在顶部。然后我们在两个if块中注册和注销事件，以正确地释放和分配`CameraView`的事件处理程序。
- en: 'Let''s add the next override for `OnElementPropertyChanged` as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加`OnElementPropertyChanged`的下一个覆盖实现如下：
- en: '[PRE59]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This function will be called for every property change on the `CameraView`.
    We will call the `SetBounds` method on the `CameraiOS` object so that our `AVCapturePreviewVideoLayer`
    always retains the latest height and width update.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将在`CameraView`的每个属性更改时被调用。我们将调用`CameraiOS`对象的`SetBounds`方法，以确保我们的`AVCapturePreviewVideoLayer`始终保留最新的高度和宽度更新。
- en: 'Now we must add the `EventHandler` functions as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须添加以下`EventHandler`函数：
- en: '[PRE60]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: All these functions will respond to events fired from the `CameraView` and call
    their respect native functions to handle control on the native camera.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都将响应从`CameraView`发出的事件，并调用它们各自的本地函数来处理原生相机的控制。
- en: Now that we have implemented control over the iOS camera, let's do the same
    for Android.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了iOS相机的控制，让我们为Android做同样的操作。
- en: Integrating the Android Camera2 framework
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成Android Camera2框架
- en: The new `Camera2` framework was introduced in API 21 (5.0 Lollipop) and provides
    a wide featured framework for controlling camera devices connected to any Android
    device.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `Camera2` 框架在 API 21（5.0 Lollipop）中引入，为控制连接到任何 Android 设备的相机设备提供了一个功能丰富的框架。
- en: 'Start by setting up the folder structure **Renderers** | **CameraView** inside
    the `Camera.Droid` project. Inside the `CameraView` folder, add a file called
    `CameraCaptureListener.cs` and implement the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 `Camera.Droid` 项目中设置文件夹结构 **Renderers** | **CameraView**。在 `CameraView`
    文件夹内，添加一个名为 `CameraCaptureListener.cs` 的文件，并实现以下内容：
- en: '[PRE61]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: All we need to do is fire an event every time the `OnCaptureCompleted` function
    is called. This function is called after all the image capture processing is completed.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是每次调用 `OnCaptureCompleted` 函数时触发一个事件。这个函数在所有图像捕获处理完成后被调用。
- en: 'Next, we have to create a callback for receiving updates about the state of
    a camera capture session. We will listen for both the `OnConfigured` and `OnConfigureFailed`
    and fire two different events so that we can handle any errors that may occur
    with the configuration of the capture session:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须创建一个回调来接收有关相机捕获会话状态的更新。我们将监听 `OnConfigured` 和 `OnConfigureFailed`，并触发两个不同的事件，以便我们可以处理可能发生的任何配置错误：
- en: '[PRE62]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Our next class is another callback for receiving updates about the state of
    the camera device. Here we will be firing events for camera availability so that
    we can pass down the availability state of the native camera to our `CameraView`
    view in the `Xamarin.Forms` project:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个类是另一个回调，用于接收有关相机设备状态的更新。在这里，我们将触发相机可用性事件，以便我们可以将原生相机的可用状态传递到 `Xamarin.Forms`
    项目中的 `CameraView` 视图：
- en: '[PRE63]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All the new `Camera2` callback objects provide excellent control with error
    handling.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 所有新的 `Camera2` 回调对象都提供了出色的控制以及错误处理。
- en: The `CameraDroid` class will be rendered on top of the `CustomRenderer`, which
    is equivalent to the `CameraiOS` object. We want to pass an instance of the `CameraDroid`
    class to the `CameraStateListener`, when the state of the camera changes, we update
    the availability status on the `CameraDroid` instance.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`CameraDroid` 类将在 `CustomRenderer` 之上渲染，这相当于 `CameraiOS` 对象。我们希望将 `CameraDroid`
    类的实例传递给 `CameraStateListener`，当相机状态改变时，我们在 `CameraDroid` 实例上更新可用状态。'
- en: 'Next, we must add another callback instance for handling image availability.
    This is where the raw image bytes will come from. Add a new file called `ImageAvailableListener.cs`
    and implement the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须添加另一个回调实例来处理图像可用性。这就是原始图像字节将来自的地方。添加一个名为 `ImageAvailableListener.cs`
    的新文件，并实现以下内容：
- en: '[PRE64]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: When the `OnImageAvailable` function is called, this means we have the raw image
    available. We call `AcquireLatestImage` on the `ImageReader` object to acquire
    the last image taken, pull the raw bytes into a `ByteBuffer`, and convert the
    `ByteBuffer` into an array of bytes.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `OnImageAvailable` 函数时，这意味着我们有可用的原始图像。我们在 `ImageReader` 对象上调用 `AcquireLatestImage`
    以获取最后拍摄的图像，将原始字节拉入一个 `ByteBuffer`，并将 `ByteBuffer` 转换为字节数组。
- en: Note
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A `ByteBuffer` comes from the `Java.Lang` framework, which we use when we want
    to implement fast low-level I/O.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`ByteBuffer` 来自 `Java.Lang` 框架，我们在需要实现快速低级 I/O 时使用它。'
- en: 'Now it''s time to implement the `CameraDroid` class. Add in a new file called
    `CameraDroid.cs` and implement the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现 `CameraDroid` 类了。添加一个名为 `CameraDroid.cs` 的新文件，并实现以下内容：
- en: '[PRE65]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `CameraDroid` class inherits `FrameLayout` and `TextureView.ISurfaceTextureListener`.
    The static `ORIENTATIONS` property is a `SpareIntArray`, which works similar to
    a `HashMap`, but it can only map integers to integers. This will be used when
    a picture is taken. We must rotate images based upon screen orientation for the
    picture orientation to appear correctly.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`CameraDroid` 类继承自 `FrameLayout` 和 `TextureView.ISurfaceTextureListener`。静态属性
    `ORIENTATIONS` 是一个 `SpareIntArray`，它的工作方式类似于 `HashMap`，但它只能将整数映射到整数。这将用于拍照时。我们必须根据屏幕方向旋转图像，以便图片方向正确显示。'
- en: We also have three event handlers like our `CameraiOS` these, are used to track
    whether the camera has taken a photo, is busy or is available.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也有三个事件处理器，类似于我们的 `CameraiOS`，用于跟踪相机是否已拍照、是否忙碌或是否可用。
- en: 'Next, we have the following `private` properties:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有以下 `private` 属性：
- en: '[PRE66]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `_tag` and `_log` properties are used for logging like our other classes.
    We are also going to include an instance of all our callbacks.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`_tag` 和 `_log` 属性用于记录，就像我们的其他类一样。我们还将包括所有回调的实例。'
- en: 'Then we have the `public` properties. Every time the `OpeningCamera` property
    is assigned, it will fire a `Busy` event. Now we can track the busy state of the
    camera inside the `CameraPage` containing the `CameraView`. We also have an instance
    of the `CameraDevice`, which represents the actual device:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有`public`属性。每次将`OpeningCamera`属性赋值时，它都会触发一个`Busy`事件。现在我们可以在包含`CameraView`的`CameraPage`内部跟踪相机的忙碌状态。我们还有一个`CameraDevice`实例，它代表实际的设备：
- en: '[PRE67]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, we have the constructor. We must first pass in the context, since we
    will be using this locally through the class. Then the `LoadShutterSound` function
    is called, which will return a Boolean once the sound has been loaded. We then
    assign `_log` from the `IoC` container and set `_tag` using the C# 6 method `GetType`.
    Using the `LayoutInflator`, we create a new `CameraLayout` and set the local `_cameraTexture`
    object. The `SurfaceTextureListener` property of the `_cameraTexture` must be
    set to the `CameraDroid` instance itself. This is why the `CameraDroid` class
    implements the `TextureView.ISurfaceTextureListener` framework. We then instantiate
    a new `CameraStateListener` and set the `Camera` property to the `CameraDroid`
    instance using the `this` keyword, and, add the orientation to rotation mappings:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有构造函数。我们首先必须传入上下文，因为我们将在类内部使用它。然后调用`LoadShutterSound`函数，该函数在声音加载完毕后会返回一个布尔值。然后我们从`IoC`容器中分配`_log`，并使用C#
    6的`GetType`方法设置`_tag`。使用`LayoutInflator`，我们创建一个新的`CameraLayout`并设置本地的`_cameraTexture`对象。`_cameraTexture`的`SurfaceTextureListener`属性必须设置为`CameraDroid`实例本身。这就是为什么`CameraDroid`类实现了`TextureView.ISurfaceTextureListener`框架。然后我们实例化一个新的`CameraStateListener`，使用`this`关键字将`Camera`属性设置为`CameraDroid`实例，并添加方向到旋转映射：
- en: '[PRE68]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now let''s move on to the `private` methods. We are going to start with `UpdatePreview`.
    This is responsible for starting the video stream through the surface texture.
    If we have both a session and camera object in play, we use the `CameraRequest.Builder`
    instance to set the capture request mode to auto. The `Handler` object that is
    created is required to run the `CameraPreview` on the main UI thread:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转到`private`方法。我们将从`UpdatePreview`开始。这个函数负责通过表面纹理启动视频流。如果我们同时有一个会话和相机对象，我们使用`CameraRequest.Builder`实例将捕获请求模式设置为自动。创建的`Handler`对象需要运行在主UI线程上的`CameraPreview`：
- en: '[PRE69]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Our next function is responsible for loading the click sound. The `LoadShutterSound`
    method is used above in the constructor. When it returns `true`, this means we
    have successfully loaded the `MediaActionSoundType.ShutterClick`, so every time
    a user takes a photo, the shutter sound will play:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个函数负责加载点击声音。在构造函数中使用了`LoadShutterSound`方法。当它返回`true`时，这意味着我们已经成功加载了`MediaActionSoundType.ShutterClick`，所以每次用户拍照时，快门声音都会播放：
- en: '[PRE70]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now we move on to the `public` methods. Our first function `OpenCamera` will
    be called when the `CameraPage` appears:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们继续到`public`方法。当`CameraPage`出现时，我们首先会调用`OpenCamera`函数：
- en: '[PRE71]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Before opening the camera, we first check if the `_context` is null and that
    we are not already opening the camera. We then flag `OpeningCamera` to true and
    retrieve the camera device from the context using the `GetSystemService` method.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开相机之前，我们首先检查`_context`是否为空，以及我们是否已经在打开相机。然后我们将`OpeningCamera`标志设置为true，并使用`GetSystemService`方法从上下文中检索相机设备。
- en: Note
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `GetSystemService` method can be used to retrieve all hardware services.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetSystemService`方法可以用来检索所有硬件服务。'
- en: Now that we have our `CameraManager` object, we call the `GetCameraIdList` method
    and retrieve the first camera ID from the list. We use this camera ID to retrieve
    the camera's characteristics that will be used for retrieving camera output sizes.
    We first use the camera output size to set the aspect ratio of the `_cameraTexture`
    and then we call `OpenCamera`, where we pass in the `cameraId` and `CameraStateListener`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`CameraManager`对象，我们调用`GetCameraIdList`方法并从列表中检索第一个相机ID。我们使用这个相机ID来检索用于检索相机输出大小的相机特性。我们首先使用相机输出大小来设置`_cameraTexture`的宽高比，然后调用`OpenCamera`，其中传入`cameraId`和`CameraStateListener`。
- en: Now we have to add a function for taking photos. We start by checking if the
    `_context` and `cameraDevice` is not null. We then invoke a `Busy` event to communicate
    to our `CameraView` and check if the shutter click sound has been loaded, then
    play if it has loaded successfully.. Then we use the camera's characteristics
    to retrieve JPEG output sizes.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要添加一个拍照的功能。我们首先检查`_context`和`cameraDevice`是否不为空。然后我们调用一个`Busy`事件来与我们的`CameraView`通信，并检查快门点击声音是否已加载，如果已加载则播放。接着我们使用相机的特性来检索JPEG输出大小。
- en: Tip
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: On every Android device, a camera will have supported output sizes for video
    streams and picture sizes. When we assign height, width, and ratio properties
    of camera display, they must be mapped to supported sizes.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个Android设备上，相机都将支持视频流和图片大小的输出大小。当我们分配相机显示的高度、宽度和比例属性时，它们必须映射到支持的大小。
- en: We then set the first output size to the function's `width` and `height` properties.
    If the characteristics fail to show any JPEG output sizes, we start with the default
    width and height (640, 480).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将第一个输出大小设置为函数的`width`和`height`属性。如果特性未能显示任何JPEG输出大小，我们以默认的宽度和高度（640，480）开始。
- en: Next, we use an `ImageReader` to retrieve and image from the `_cameraDevice`.
    We start with creating a new instance of an `ImageReader` and pass in our required
    width and height properties. An `ImageRenderer` also requires a surface, which
    is mapped to the output of a camera. When we take a picture, the `ImageReader`
    knows it will be reading from the output of the camera. We create a new `CaptureRequest.Builder`,
    which is created from the `CreateCaptureRequest` method of the `_cameraDevice`.
    Then we set the surface target to the surface we created earlier. Now the builder
    knows we are mapped to the output of the camera. We also set the capture request
    to auto, so most of the setup is taken care of. We then get the current orientation
    of the window from the `WindowManager` property (this is another service pulled
    from the `_context` using the `GetSystemService` method), and using the current
    orientation, set the rotation of the image accordingly.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`ImageReader`从`_cameraDevice`检索图像。我们首先创建一个`ImageReader`的新实例，并传入我们所需的宽度和高度属性。`ImageRenderer`还需要一个表面，该表面映射到相机的输出。当我们拍照时，`ImageReader`知道它将从相机的输出读取。我们创建一个新的`CaptureRequest.Builder`，该`Builder`是由`_cameraDevice`的`CreateCaptureRequest`方法创建的。然后我们将表面目标设置为之前创建的表面。现在`Builder`知道我们映射到相机的输出。我们还设置了捕获请求为自动，因此大多数设置都得到了处理。然后我们从`WindowManager`属性（这是通过`GetSystemService`方法从`_context`获取的另一个服务）获取窗口的当前方向，并使用当前方向相应地设置图像的旋转。
- en: Why do we have to change the orientation of the image? If we take an image on
    the current orientation, why is the image in a different orientation?
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们必须更改图像的方向？如果我们以当前方向拍摄图像，为什么图像的方向会不同？
- en: This is something we cannot control; the current orientation of the camera display
    does not map exactly how the image is interpreted when we take a picture, so we
    have to apply some minor rotation to bring the image into the same orientation
    as the camera surface.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们无法控制的事情；相机显示的当前方向并不精确地映射到我们拍照时图像的解释方式，因此我们必须应用一些微小的旋转，以便将图像调整到与相机表面相同的方向。
- en: This is a lot of work for the camera to do to prepare for capturing an image,
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这对相机来说是一项繁重的工作，以准备捕获图像，
- en: It takes a lot of work to prepare a capture session
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 准备捕获会话需要做很多工作
- en: how do we know when an image is actually taken?
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道图像实际上已经被拍摄了？
- en: All the work we have done so far is all for preparing the camera to take an
    image. We use our `ImageAvailableListener` for letting us know when the image
    is ready. Since we set up an event to hand us the image bytes, we can assign a
    delegate that will fire the `CameraDroid` so that the image bytes are passed back
    to the `CameraView` object.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止所做的一切都是为了准备相机拍照。我们使用`ImageAvailableListener`来通知我们图像何时准备好。由于我们设置了一个事件来提供图像字节，我们可以分配一个代表，它将触发`CameraDroid`，以便将图像字节传递回`CameraView`对象。
- en: Notice the use of the Handler?
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到Handler的使用了吗？
- en: The handler is used to handle the resulting JPEG in a background thread.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器用于在后台线程中处理生成的JPEG。
- en: We then create an instance of our `CameraCaptureListener` to let us know capture
    operations have completed and assign a delegate function to restart the camera
    stream when the `PhotoComplete` event has been invoked. A new `CameraCaptureStateListener`
    object is passed into the `CreateCaptureSession` method to start the capture session
    and we assign a delegate to the `OnConfiguredAction` that will store the current
    `CameraCaptureSession`. We call the `Capture` method on the session and then call
    the `Build` method on the `captureBuilder` we created earlier. This occurs every
    time the `Capture` method is called.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个 `CameraCaptureListener` 的实例，以便我们知道捕获操作已完成，并将一个委托函数分配给在 `PhotoComplete`
    事件被调用时重新启动摄像头流。一个新的 `CameraCaptureStateListener` 对象被传递到 `CreateCaptureSession`
    方法中以启动捕获会话，并将一个委托分配给 `OnConfiguredAction` 以存储当前的 `CameraCaptureSession`。我们在会话上调用
    `Capture` 方法，然后调用我们之前创建的 `captureBuilder` 上的 `Build` 方法。这发生在每次调用 `Capture` 方法时。
- en: The `captureListener` object and the handler are passed into the `Capture` method
    so that all capture processing is done on a background thread.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`captureListener` 对象和处理程序被传递到 `Capture` 方法中，以便所有捕获处理都在后台线程上完成。'
- en: Note
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This means that when a picture is taken, the processing time in between preparing
    a photo will not lock the UI thread.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当拍照时，在准备照片之间的处理时间不会锁定 UI 线程。
- en: '[PRE72]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: It takes a lot of work to prepare a capture session on an Android camera using
    the `Camera2` framework, but the advantage is we have is the ability to control
    every single step separately, and handle any exceptions that occur at any point
    during the capture operation.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Camera2` 框架在 Android 摄像头上准备捕获会话需要做很多工作，但我们的优势是能够单独控制每个步骤，并处理捕获操作过程中可能发生的任何异常。
- en: 'Our next function will be responsible for changing the focus point of the camera,
    when a touch on the `CameraView` occurs, this function will be called to change
    the focus point of the native camera:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的函数将负责在触摸 `CameraView` 时改变摄像头的焦点，这个函数将被调用以改变原生摄像头的焦点：
- en: '[PRE73]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `ChangeFocusPoint` function starts with retrieving the `cameraId` from
    the `CameraManager`. We then call the `Get` method of the camera characteristics
    to retrieve a rectangle and size of the active region of the camera sensor (that
    is, the region that actually receives light from the scene). We then retrieve
    the right and bottom bounds of this region and get the width and height of the
    `_cameraTexture`. When a user touches to focus, the point coordinate (*x*, *y*)
    passed into this function is used as the center of the focus region. As we have
    the middle point, we calculate the left and bottom points and we also use the
    `Clamp` function to make sure these points are within the width and height bounds
    of the `_cameraTexture`. We then create a new `Rect` representing the new active
    region for the camera sensor. Then, to perform the actual focus on the camera
    device, we must first disable the autofocus by calling the line:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChangeFocusPoint` 函数首先从 `CameraManager` 中检索 `cameraId`。然后我们调用摄像头的特性 `Get`
    方法来检索摄像头传感器的活动区域（即实际接收场景光线的区域）的矩形和大小。然后我们检索这个区域的右边界和下边界，并获取 `_cameraTexture` 的宽度和高度。当用户触摸以聚焦时，传递到该函数的点坐标
    (*x*, *y*) 被用作聚焦区域的中心。因为我们有中间点，我们计算左点和下点，并且我们还使用 `Clamp` 函数确保这些点在 `_cameraTexture`
    的宽度和高度边界内。然后我们创建一个新的 `Rect` 来表示摄像头传感器的新的活动区域。然后，为了在摄像头设备上执行实际的聚焦，我们必须首先通过调用以下行来禁用自动对焦：'
- en: '[PRE74]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Then assign the camera sensor''s active region by calling:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过调用以下行来分配摄像头传感器的活动区域：
- en: '[PRE75]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'And finally, reset the autofocus by calling:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过调用以下行来重置自动对焦：
- en: '[PRE76]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The operation works by disabling the autofocus, setting the active region, and
    then recalling autofocus. When the autofocus is started again, we have a new focus
    point in which the camera will adjust its focus point too.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作通过禁用自动对焦，设置活动区域，然后再次调用自动对焦来工作。当再次启动自动对焦时，我们有一个新的焦点点，其中摄像头也会调整其焦点点。
- en: We also call the `UpdatePreview` function for resetting the camera control to
    auto.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还调用 `UpdatePreview` 函数以将摄像头控制重置为自动。
- en: 'Next, we have the `Clamp` function, which is responsible for forcing the value
    passed in to be between a range. We use the following function:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有 `Clamp` 函数，它负责强制传入的值在某个范围内。我们使用以下函数：
- en: '[PRE77]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now for the `StartPreview` function, this will be responsible for starting
    the camera stream through the `TextureView`. We won''t call this unit the camera
    has been opened previously:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`StartPreview`函数，它将负责通过`TextureView`启动相机流。如果相机之前已经打开，我们不会调用这个单元：
- en: '[PRE78]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The function starts with configuring the size of the default buffer to be the
    size of the camera preview. Then we want to create a new `Surface` object for
    the output surface of the camera, which is then assigned to a new `CaptureRequest.Builder`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 函数从配置默认缓冲区的大小为相机预览的大小开始。然后我们想要为相机的输出表面创建一个新的`Surface`对象，然后将其分配给一个新的`CaptureRequest.Builder`。
- en: 'Don''t forget we have another function to control the flash of the camera.
    We simply adjust the flash mode through `CaptureRequest.Builder` object and, based
    upon the `flashOn bool` passed in, we assign either `FlashMode.Torch` or `FlashMode.Off`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记我们还有一个控制相机闪光灯的功能。我们简单地通过`CaptureRequest.Builder`对象调整闪光模式，并根据传入的`flashOn
    bool`分配`FlashMode.Torch`或`FlashMode.Off`：
- en: '[PRE79]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Next we have a public function to invoke the `Available` event, which we need
    for the `CmaptureStateListener` callback so that we keep track of the camera availability
    during a capture session:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个公开的函数来调用`Available`事件，这是为了在`CmaptureStateListener`回调中跟踪捕获会话期间的相机可用性：
- en: '[PRE80]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Next we have the `ConfigureTransform` function, which is responsible for transforming
    the texture view. Here we are handling surface orientations and matrix rotations:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`ConfigureTransform`函数，它负责转换纹理视图。在这里，我们处理表面方向和矩阵旋转：
- en: '[PRE81]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Then we have the functions that are required by every `TextureView`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有每个`TextureView`所需的函数：
- en: '[PRE82]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The `OnSurfaceTextureAvailable` function will call configure the texture''s
    transformation matrix based upon the current window''s orientation and call `StartPreview`
    to start the video stream through the texture view:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnSurfaceTextureAvailable`函数将根据当前窗口的方向配置纹理的变换矩阵，并调用`StartPreview`通过纹理视图启动视频流：'
- en: '[PRE83]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We also want to configure the texture''s transformation matrix when the surface
    size changes:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当表面大小改变时，我们还想配置纹理的变换矩阵：
- en: '[PRE84]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Wow! That was one huge implementation. Configuring the camera is not an easy
    task; it involves a lot of step-by-step procedures that must be taken correctly
    for starting the camera stream and creating a capture session. Those are the two
    most important operations of any camera implementation.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这是一个巨大的实现。配置相机不是一个容易的任务；它涉及许多必须正确执行的逐步程序，以启动相机流和创建捕获会话。这些是任何相机实现中最重要的两个操作。
- en: Building the CameraViewRenderer in Android
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android中构建CameraViewRenderer
- en: 'Now we must add the CustomRenderer for the Android camera. In the `Renderers`
    folder, add a new file called `CameraViewRender.cs` and implement the following:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须添加Android相机的CustomRenderer。在`Renderers`文件夹中，添加一个名为`CameraViewRender.cs`的新文件并实现以下内容：
- en: '[PRE85]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Our renderer contains only one private instance of the `CameraDroid` class.
    Then we override the `OnElementChanged` method:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的渲染器只包含一个`CameraDroid`类的私有实例。然后我们覆盖`OnElementChanged`方法：
- en: '[PRE86]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Tip
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Inside Android `CustomRenderers`, there is a bug with disposal using the `OnElementChanged`
    method. In some cases, this method is not called when the view is disposed, so
    we are going to override the `Dispose` method.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android的`CustomRenderers`中，使用`OnElementChanged`方法进行销毁时存在一个bug。在某些情况下，当视图被销毁时，该方法不会被调用，因此我们将覆盖`Dispose`方法。
- en: Here we follow the correct structure in the `OnElementChanged` method and instantiate
    the new control when the `Control` property is null. We also register our events
    when the new element is not null (events are registered on both the `CameraDroid`
    and `CameraView` objects).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnElementChanged`方法中，我们遵循正确的结构并实例化新的控件，当`Control`属性为null时。如果新元素不为null（事件在`CameraDroid`和`CameraView`对象上注册），我们也会注册我们的事件。
- en: 'Now let''s add the override to handle the disposal:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加覆盖功能来处理销毁：
- en: '[PRE87]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Here we simply unregister the events for both the `CameraView` and `CameraDroid`
    objects. Next, we have the `private` event delegate methods for calling the native
    camera methods:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简单地注销了`CameraView`和`CameraDroid`对象的两个事件。接下来，我们有`private`事件委托方法来调用原生相机方法：
- en: '[PRE88]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Great! We have completed our camera implementations for both iOS and Android.
    Now we have to create another renderer for the `FocusView`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们已经完成了iOS和Android的相机实现。现在我们必须为`FocusView`创建另一个渲染器。
- en: Handling native touch events through the FocusView
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过FocusView处理原生触摸事件
- en: 'Since our camera implementation is handling focus changes from touch events,
    we are required to receive these touch events from the native side. `Xamarin.Forms`
    does not have touch events that give (*x*, *y*) coordinates, so we have to do
    some more custom rendering on the `FocusView`. Let''s start with the Android implementation
    this time, inside the `Renderers` folder, add a new folder called `FocusView`,
    and add a new file called `FocusViewGestureDetector.cs`, and implement the following:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的相机实现正在处理来自触摸事件的焦距变化，因此我们需要从原生端接收这些触摸事件。`Xamarin.Forms` 没有提供包含 (*x*, *y*)
    坐标的触摸事件，因此我们不得不在 `FocusView` 上进行一些额外的自定义渲染。这次我们从 Android 实现开始，在 `Renderers` 文件夹内添加一个新的文件夹名为
    `FocusView`，并添加一个名为 `FocusViewGestureDetector.cs` 的新文件，并实现以下内容：
- en: '[PRE89]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The preceding class is very similar to the gesture detector we created for the
    `CarouselView` in the last chapter. We only use this object to retrieve the `MotionEvent`
    object from the `OnDown` method.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类与我们在上一章中为 `CarouselView` 创建的手势检测器非常相似。我们只使用这个对象从 `OnDown` 方法中检索 `MotionEvent`
    对象。
- en: 'Let''s add in another file called `FocusViewRender.c` and implement the following:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加另一个名为 `FocusViewRender.c` 的文件，并实现以下内容：
- en: '[PRE90]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `FocusViewRenderer` will contain an instance of our `FocusViewGestureDetector`
    and `GestureDetector` for handling touches on the `FocusView`. We also have a
    `LinearLayout`, which is going to be the control assigned to the `FocusView`.
    This `LinearLayout` will be blank and will only be used to receive the native
    touch events.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`FocusViewRenderer` 将包含我们的 `FocusViewGestureDetector` 和 `GestureDetector` 实例，用于处理
    `FocusView` 上的触摸事件。我们还有一个 `LinearLayout`，它将被分配给 `FocusView` 作为控件。这个 `LinearLayout`
    将是空的，并且仅用于接收原生触摸事件。'
- en: 'Then we add the override to the `OnElementChanged` function:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在 `OnElementChanged` 函数中添加重写：
- en: '[PRE91]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: When the `Control` is null, before we call the `SetNativeControl` method, we
    set up the gesture detectors.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Control` 为空时，在我们调用 `SetNativeControl` 方法之前，我们设置手势检测器。
- en: 'Now we must handle disposal as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须按照以下方式处理销毁：
- en: '[PRE92]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Then we add the remaining:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加剩余的内容：
- en: '[PRE93]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Using RX to handle events
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 RX 处理事件
- en: Have a look at the `SetGestureDetectorListener` function where we are using
    the `FromEventPattern` method from the `Observable` framework. The function must
    be typed with a particular object (that is, `MotionEvent`) that contains an `EventHandler`
    property, in this case `Touch`. Every time a `Touch` event is fired, using the
    `Window` method, we wait 0.7 seconds before doing anything (this ensures that
    we only respond to the first event taken every period set in the `Window` method).
    Once this period is reached, `SelectMany` is called and the first `Touch` event
    is retrieved from the observable sequence via the `Take` method. Then we call
    `Subscribe` to assign the `NotifyFocus` method, and pass in the `MotionEvent`
    object taken from the `SelectMany` method.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下 `SetGestureDetectorListener` 函数，我们在其中使用了来自 `Observable` 框架的 `FromEventPattern`
    方法。该函数必须使用特定的对象（即 `MotionEvent`）进行类型化，该对象包含一个 `EventHandler` 属性，在这种情况下是 `Touch`。每次
    `Touch` 事件被触发时，我们使用 `Window` 方法等待 0.7 秒后才进行任何操作（这确保了我们只对 `Window` 方法中设置的周期内获取的第一个事件做出响应）。一旦这个周期到达，就调用
    `SelectMany` 并通过 `Take` 方法从可观察序列中检索第一个 `Touch` 事件。然后我们调用 `Subscribe` 来分配 `NotifyFocus`
    方法，并传递从 `SelectMany` 方法中获取的 `MotionEvent` 对象。
- en: To summarize, the `FromEventPattern` method is very useful for controlling multiple
    events and responding with specific actions. We have applied this technique with
    touch events because we want to make sure only one touch event is processed every
    0.7 seconds. If we used a simply delegate function, a user could very fast, and
    for every touch event, the camera would run through the `ChangeFocusPoint` operation
    every time before the previous has finished, eventually crashing the application.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`FromEventPattern` 方法对于控制多个事件并以特定动作响应非常有用。我们应用了这种技术来处理触摸事件，因为我们想确保每 0.7
    秒只处理一个触摸事件。如果我们使用简单的委托函数，用户可以非常快地处理每个触摸事件，每次都会在之前的操作完成之前运行 `ChangeFocusPoint`
    操作，最终导致应用程序崩溃。
- en: Now turn attention to the `ConvertPixelsToDp` method. We have to translate the
    pixel points into DPI when translating position coordinates (*x*, *y*) between
    native Android and `Xamarin.Forms` views. This will be called for every touch
    event for both x and y before we pass the coordinate to the `CameraView`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '现在让我们关注 `ConvertPixelsToDp` 方法。当我们需要在原生 Android 和 `Xamarin.Forms` 视图之间转换位置坐标
    (*x*, *y*) 时，我们必须将像素点转换为 DPI。这将在将坐标传递给 `CameraView` 之前为每个触摸事件（x 和 y）调用。 '
- en: Note
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 1 DP equals 1.5 physical pixels.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 1 DP 等于 1.5 个物理像素。
- en: Building a VisualElementRenderer for iOS
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建iOS的VisualElementRenderer
- en: To handle native touch events on iOS, we are going to build a `VisualElementRenderer`.
    These work similar to CustomRenderers, but instead of rendering and replacing
    the entire control, we are able to render specific attributes, so we are able
    to attach native attributes to a `Xamarin.Forms` view.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理iOS上的原生触摸事件，我们将构建一个`VisualElementRenderer`。这些工作方式类似于CustomRenderers，但与渲染和替换整个控件不同，我们能够渲染特定的属性，因此我们能够将原生属性附加到`Xamarin.Forms`视图中。
- en: 'Let''s start with adding a new folder inside the `Renderers` folder called
    `FocusView`. Add in a new file called `FocusViewRendererTouchAttribute.cs` and
    implement the following:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`Renderers`文件夹内添加一个名为`FocusView`的新文件夹开始。添加一个名为`FocusViewRendererTouchAttribute.cs`的新文件，并实现以下内容：
- en: '[PRE94]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Don''t forget to add the assembly line above the namespace like the following:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在命名空间上方添加上述程序集，如下所示：
- en: '[PRE95]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: When the element is rendered, we will now have the access to the `TouchesBegan`
    override. Inside this function, we have access to the render object (`FocusView`),
    where we can call the `NotifyFocus` function and pass the current touch (*x*,
    *y*) coordinate back to the `FocusView`.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 当元素被渲染时，我们现在将能够访问`TouchesBegan`的重写。在这个函数内部，我们可以访问渲染对象（`FocusView`），在那里我们可以调用`NotifyFocus`函数并将当前的触摸（*x*，*y*）坐标传递回`FocusView`。
- en: That's all for our `FocusView` renderers. Let's now move on to the `CustomImageRenderer`
    so that we can apply color tinting to an image.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的`FocusView`渲染器的全部内容。现在让我们继续到`CustomImageRenderer`，这样我们就可以为图像应用颜色着色。
- en: Building the CustomImageRenderers
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建CustomImageRenderers
- en: 'We are going to start with the iOS implementation of the `CustomImage`. Inside
    the `Renderers` folder, add a new folder called `CustomImage`, add a new file
    called `CustomImageRenderer.cs`, and implement the following:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`CustomImage`的iOS实现开始。在`Renderers`文件夹内，添加一个名为`CustomImage`的新文件夹，添加一个名为`CustomImageRenderer.cs`的新文件，并实现以下内容：
- en: '[PRE96]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Looking at our `private` properties, we have the logging objects again, an
    integer property to hold the current system version (that is, iOS version), and
    an `UIImageView` to use as the native control. Next we have to override the `OnElementChanged`
    method:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们的`私有`属性，我们再次有日志对象，一个用于存储当前系统版本（即iOS版本）的整型属性，以及一个`UIImageView`作为原生控件。接下来，我们必须重写`OnElementChanged`方法：
- en: '[PRE97]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Remember we have to follow the same structure for instantiating the control,
    and registering and deregistering EventHandlers. In this renderer, we are going
    to apply event handling a little differently. Instead of registering multiple
    events in the `OnElementChanged` method, we only have to register and deregister
    the `CustomPropertyChanged` event. In our `CustomImage` view, with each custom
    binding, when a property is changed, we assigned a delegate that would fire this
    event with the property name for every property. Therefore, we add one delegate
    function on the renderer side called `HandleCustomPropertyChanged`, and in this
    function, we will check what property has changed and respond with an action:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们必须遵循相同的结构来实例化控件，以及注册和注销事件处理器。在这个渲染器中，我们将以稍微不同的方式应用事件处理。不是在`OnElementChanged`方法中注册多个事件，我们只需要注册和注销`CustomPropertyChanged`事件。在我们的`CustomImage`视图中，对于每个自定义绑定，当属性发生变化时，我们分配一个委托，该委托将为每个属性触发此事件。因此，我们在渲染器端添加了一个名为`HandleCustomPropertyChanged`的委托函数，在这个函数中，我们将检查哪个属性已更改，并采取相应的行动：
- en: '[PRE98]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Much cleaner than handling multiple events right?
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 比处理多个事件干净多了，对吧？
- en: 'Every time the `Path` property is changed, we call a new method called `LoadImage`.
    Before we add this function in, we are going to add a `private` method for setting
    the image aspect ratio:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 每当`Path`属性发生变化时，我们调用一个新的方法`LoadImage`。在我们添加此函数之前，我们将添加一个用于设置图像宽高比的`private`方法：
- en: '[PRE99]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: This will take a `Xamarin.Forms` image aspect ratio value and return the related
    native image aspect ratio. This value will then be used for the aspect of the
    `UIImageView`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这将接受一个`Xamarin.Forms`图像宽高比值，并返回相关的原生图像宽高比。此值将被用于`UIImageView`的宽高比。
- en: 'Let''s now add the `LoadImage` method as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们按照以下方式添加`LoadImage`方法：
- en: '[PRE100]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'This function is responsible for using the `Path` property to load an image
    into the `UIImageView`. Inside this function, we also use the `systemVersion`
    property to handle backward compatibility with color tinting. Only if the iOS
    device is using an iOS version greater than or equal to iOS 7, we apply the following
    line:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数负责使用 `Path` 属性将图像加载到 `UIImageView` 中。在此函数内部，我们还使用 `systemVersion` 属性来处理与颜色着色的向后兼容性。只有当
    iOS 设备使用 iOS 版本大于或等于 iOS 7 时，我们才应用以下行：
- en: '[PRE101]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: This tells the `UIImageView` that its `Image` should always draw as a template
    image, ignoring its color information. We have to do this before we can apply
    a tinted color.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 `UIImageView` 其 `Image` 应始终以模板图像绘制，忽略其颜色信息。我们必须在应用着色颜色之前做这件事。
- en: 'Next we have to add the `ReadBitmapImageFromStorage` function:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须添加 `ReadBitmapImageFromStorage` 函数：
- en: '[PRE102]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Using the `File.OpenRead` method, we retrieve the files stream and load it into
    a new `NSData` object, and then from this `NSData` we load this into a new `UIImage`
    and return it to the caller (that is, the `LoadImage` function).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `File.OpenRead` 方法，我们检索文件流并将其加载到一个新的 `NSData` 对象中，然后从这个 `NSData` 中加载到新的 `UIImage`
    并将其返回给调用者（即，`LoadImage` 函数）。
- en: 'We must also add the `UpdateControlColor` function for assigning the tint color
    to the `UIImageView`:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须添加 `UpdateControlColor` 函数来分配着色颜色到 `UIImageView`：
- en: '[PRE103]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Here we are using another `static` class, which will take a color and the image
    and return a new image tinted to the color passed in.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用另一个 `static` 类，它将接受一个颜色和图像，并返回一个着色到传入颜色的新图像。
- en: Building the UIImageEffects class
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 UIImageEffects 类
- en: 'Our final part to the image tinting on iOS is implementing the class that will
    return a tinted image from a template image and color. Create a new folder in
    the iOS project called `Helpers`, add a new file called `UIImageEffects.cs`, and
    implement the following:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 iOS 上对图像着色的最后一部分是实现一个类，它将从模板图像和颜色返回一个着色图像。在 iOS 项目中创建一个名为 `Helpers` 的新文件夹，添加一个名为
    `UIImageEffects.cs` 的新文件，并实现以下内容：
- en: '[PRE104]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The function starts with creating a new `UIImage` and setting it to null. We
    then create a new image context by calling `BeginImageContext` and passing in
    the image size from the `UIImage` we pass in to the function. We then wrap the
    current context in a using statement to make sure we free memory taken from image
    processing in the context. We use the current context to assign correct (*x*,
    *y*) translation and scale to match the `UIImage` passed in. After this, we create
    a new `Rect` to match the bounds of the `UIImage` we passed into the function.
    We then call `SetBlendMode` to assign the image's transparency and call `DrawImage`
    to draw the image. Now that we have drawn the image within the context, we then
    call `SetBlendMode` again to using the `CGBlendMode.SourceIn` so that it only
    draws on the nontransparent pixels. We then set the fill color of the context
    to the color we passed into the function, which will be the tint color. The image
    context will then fill the bounds of the `Rect` we created earlier. Finally, we
    end the image processing by calling `EndImageContext` and return the new `colouredImage`
    to the caller.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 函数从创建一个新的 `UIImage` 并将其设置为 null 开始。然后我们通过调用 `BeginImageContext` 并传入函数中传递的 `UIImage`
    的大小来创建一个新的图像上下文。然后我们将当前上下文包装在一个 `using` 语句中，以确保释放上下文中从图像处理中占用的内存。我们使用当前上下文来分配正确的
    (*x*, *y*) 平移和缩放以匹配传入函数的 `UIImage`。之后，我们创建一个新的 `Rect` 以匹配传入函数的 `UIImage` 的边界。然后我们调用
    `SetBlendMode` 来分配图像的不透明度并调用 `DrawImage` 来绘制图像。现在我们已经绘制了上下文中的图像，然后我们再次调用 `SetBlendMode`
    使用 `CGBlendMode.SourceIn`，这样它只绘制在非透明像素上。然后我们将上下文的填充颜色设置为传入函数的颜色，这将作为着色颜色。图像上下文将然后填充我们之前创建的
    `Rect` 的边界。最后，我们通过调用 `EndImageContext` 来结束图像处理，并将新的 `colouredImage` 返回给调用者。
- en: Fantastic! We have now used the native `UIGraphics` framework to perform image
    tinting for iOS; let's do the same for Android.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们现在已经使用原生的 `UIGraphics` 框架为 iOS 实现了图像着色；让我们为 Android 也做同样的事情。
- en: Building the CustomImageRenderer for Android
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 Android 的 CustomImageRenderer
- en: 'Add a new folder into the `Renderers` folder called `CusotmImage`, add a new
    file called `CustomImageRenderer.cs`, and implement the following:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Renderers` 文件夹中添加一个名为 `CusotmImage` 的新文件夹，添加一个名为 `CustomImageRenderer.cs`
    的新文件，并实现以下内容：
- en: '[PRE105]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: We are going to use an `ImageView` as the native control. We also have a local
    `CustomImage`, which will reference the element we are rendering on. We also have
    a local `Bitmap`, which will be the image we are tinting. Then we have the `_log`
    and `tag` properties again for logging any exceptions.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `ImageView` 作为本地控件。我们还有一个本地的 `CustomImage`，它将引用我们正在渲染的元素。我们还有一个本地的 `Bitmap`，它将是我们要着色的图像。然后我们再次有
    `_log` 和 `tag` 属性，用于记录任何异常。
- en: 'Let''s now add the `OnElementChanged` method:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加 `OnElementChanged` 方法：
- en: '[PRE106]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Here we create a new `ImageView` as the control. When the `NewElement` is not
    null, we assign it to `_customImage`, set the aspect ratio of the `ImageView`,
    add the tint color, and load the image.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个新的 `ImageView` 作为控件。当 `NewElement` 不为空时，我们将其分配给 `_customImage`，设置
    `ImageView` 的宽高比，添加着色颜色，并加载图像。
- en: 'Now we have to handle disposal by overriding the `Dispose` method:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须通过重写 `Dispose` 方法来处理销毁操作：
- en: '[PRE107]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Then we add the `private` methods. We are going to start with the `SetAspect`
    function. Like our iOS implementation, we will map the `Xamarin.Forms` image aspect
    value to the native `ImageViewScaleType`:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加 `private` 方法。我们将从 `SetAspect` 函数开始。就像我们的iOS实现一样，我们将 `Xamarin.Forms` 图像宽高比值映射到本地的
    `ImageViewScaleType`：
- en: '[PRE108]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Then we have the `delegate` function for handling all our property changes:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有处理所有属性变化的 `delegate` 函数：
- en: '[PRE109]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Our `LoadImage` is a bit better than the iOS version because it loads the image
    asynchronously:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `LoadImage` 比iOS版本要好一些，因为它可以异步加载图像：
- en: '[PRE110]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: We only call the `SetImageBitmap` on the `ImageView` if the `ImageView` and
    `Bitmap` is not null.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当 `ImageView` 和 `Bitmap` 都不为空时，我们才在 `ImageView` 上调用 `SetImageBitmap`。
- en: 'Next we have the `UpdateControlColor` function for tinting the image. Android
    offers a much simpler solution for tinting using the `SetColorFilter` function.
    We must pass in a `PorterDuff.Mode`, which the `SetColorFilter` will use to determine
    how to compose the image based on the alpha value:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们有用于着色图像的 `UpdateControlColor` 函数。Android提供了使用 `SetColorFilter` 函数的简单解决方案。我们必须传递一个
    `PorterDuff.Mode`，`SetColorFilter` 将使用它来确定如何根据alpha值组合图像：
- en: '[PRE111]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Next we have the `ReadBitmapImageFromStorage` function, where we will be loading
    a `Bitmap` from the `Path` property of the `CustomImage`. We use the `GetIdentifier`
    function from the `Resources` framework to retrieve the integer ID of the image
    resource we want to load.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们有 `ReadBitmapImageFromStorage` 函数，我们将从 `CustomImage` 的 `Path` 属性中加载一个 `Bitmap`。我们使用
    `Resources` 框架中的 `GetIdentifier` 函数来检索我们想要加载的图像资源的整数ID。
- en: Tip
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember, the image must be inside our `drawable` or `mipmap` folder for the
    image to be found.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，图像必须位于我们的 `drawable` 或 `mipmap` 文件夹中，才能找到图像。
- en: 'We then open the raw file as a stream using the `OpenRawResource` function,
    and using the `BitmapFactory` framework, we can use the raw resource stream to
    decode a `Bitmap` object that will be returned:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后使用 `OpenRawResource` 函数以流的形式打开原始文件，并使用 `BitmapFactory` 框架，我们可以使用原始资源流解码一个将返回的
    `Bitmap` 对象：
- en: '[PRE112]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Great! We have now built all our `CustomRenderers` for the solution. Let's see
    how we use these with our user interface screens.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们现在已经为解决方案构建了所有的 `CustomRenderers`。让我们看看我们如何将这些与我们的用户界面屏幕一起使用。
- en: Triggers
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发器
- en: 'The first page will consist of two buttons, an image, a label, and extra additional
    UI functionality known as **triggers**. Triggers are declarative objects used
    in XAML, which contain actions executed when certain conditions or events occur.
    The main advantage of triggers is we can box up these handle actions for as many
    UI elements that need to perform the same actions. We have the option of the following
    four different types of triggers:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 第一页将包含两个按钮、一个图像、一个标签以及称为 **触发器** 的额外附加UI功能。触发器是在XAML中使用的声明性对象，当某些条件或事件发生时执行动作。触发器的主要优点是我们可以将这些处理动作封装在需要执行相同动作的许多UI元素中。我们有以下四种不同类型触发器的选择：
- en: '**Property trigger**: This is executed when a property on a control is set
    to a particular value.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性触发器**：当控件上的属性设置为特定值时执行。'
- en: '**Data trigger**: This is same as the property trigger but uses data binding.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据触发器**：这与属性触发器相同，但使用数据绑定。'
- en: '**Event trigger**: This is occurs when an event occurs on the control.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件触发器**：当控件上发生事件时，这会发生。'
- en: '**Multi trigger**: This is allows multiple trigger conditions to be set before
    an action occurs.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多触发器**：这允许在动作发生之前设置多个触发条件。'
- en: In our solution, we are going to add two event triggers for button click events.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的解决方案中，我们将为按钮点击事件添加两个事件触发器。
- en: 'Let''s start with adding a new folder called `Triggers` into the `Camera` project,
    add a new file called `ButtonClickTrigger.cs`, and implement the following:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`Camera`项目中添加一个名为`Triggers`的新文件夹开始，添加一个名为`ButtonClickTrigger.cs`的新文件，并实现以下内容：
- en: '[PRE113]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Our first trigger is for handling the `Clicked` event on the `CameraButton`.
    When this button is clicked, the background and text color of the button will
    change. We must override the `Invoke` function to claim the `Button` performing
    the action.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个触发器是处理`CameraButton`上的`Clicked`事件。当这个按钮被点击时，按钮的背景和文字颜色将改变。我们必须重写`Invoke`函数以声明执行动作的`Button`。
- en: 'Now let''s add another folder for the `Pages`, add a new file called `MainPage.xaml`,
    and implement the following:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为`Pages`添加另一个文件夹，添加一个名为`MainPage.xaml`的新文件，并实现以下内容：
- en: '[PRE114]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: We must include the namespace reference to location of the `Triggers` folder.
    Then turn attention to the `CameraButton`, where we will attach the `ButtonClickedTrigger`.
    When the button is touched, the `Invoke` method of the trigger will be called.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须包含对`Triggers`文件夹位置的命名空间引用。然后关注`CameraButton`，我们将附加`ButtonClickedTrigger`。当按钮被触摸时，触发器的`Invoke`方法将被调用。
- en: 'The next trigger we add will perform a nice warping animation to a button when
    it is clicked. Let''s add another file called `VisualElementPopTriggerAction.cs`
    and implement the following:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的下一个触发器将在按钮被点击时执行一个漂亮的扭曲动画。让我们添加一个名为`VisualElementPopTriggerAction.cs`的新文件，并实现以下内容：
- en: '[PRE115]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The `Anchor` property is used for the point (*x*, *y*) in which the `ScaleTo`
    function will reference. Since the reference points `X` and `Y` are `0.5`, when
    animate an expansion on the button, it will expand evenly on both the left/right
    and top/bottom. The `Invoke` method will be called when the button is clicked
    to begin the animation. We are also using the Sin easing for each animation:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`Anchor`属性用于`ScaleTo`函数将引用的点（*x*，*y*）。由于参考点`X`和`Y`为`0.5`，当在按钮上动画扩展时，它将在左右和上下两边均匀扩展。当按钮被点击时，将调用`Invoke`方法开始动画。我们还在每个动画中使用Sin缓动：'
- en: Easing.SinIn
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Easing.SinIn
- en: 'Starts slow and speeds:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 慢速开始并加速：
- en: '![Easing.SinIn](img/image_08_002.jpg)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![Easing.SinIn](img/image_08_002.jpg)'
- en: Easing.SinOut
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Easing.SinOut
- en: 'Starts fast and slows down:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 快速开始并减速：
- en: '![Easing.SinOut](img/image_08_003.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![Easing.SinOut](img/image_08_003.jpg)'
- en: 'Let''s have a look at how we will use the `VisualElementPopTriggerAction` inside
    a style. Add in the `App.Xaml` file and implement the following styles:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何在样式中使用`VisualElementPopTriggerAction`。在`App.Xaml`文件中添加以下样式：
- en: '[PRE116]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Can you see what technique we are using here?
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看出我们在这里使用的技术吗？
- en: This is known as **style inheritance**. The `ButtonStyleWithTrigger` style inherits
    all the styling properties of the `BaseButtonStyle` by using the `BasedOn` property.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**样式继承**。`ButtonStyleWithTrigger`样式通过使用`BasedOn`属性继承了`BaseButtonStyle`的所有样式属性。
- en: Wait! Aren't we missing the `DescriptionLabel` from the `MainPage`?
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！我们不是遗漏了`MainPage`中的`DescriptionLabel`吗？
- en: We still have one more element to add to the `MainPage`. But first we are going
    to talk about another object used in XAML known as **PlatformEffects**.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个元素要添加到`MainPage`中。但首先，我们将讨论另一个在XAML中使用的对象，称为**PlatformEffects**。
- en: Platform effects
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台效果
- en: Platform effects are used to simplify native control customization, reducing
    the need to create `CustomRenderers` for small styling changes. This means we
    don't have to create a custom renderer every single time we want native customization.
    To implement a `PlatformEffect`, we first create a class that subclasses the `PlatformEffect`
    framework. Then we have to write platform-specific implementations for each.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 平台效果用于简化原生控件定制，减少创建`CustomRenderers`进行小样式更改的需求。这意味着我们不必每次想要原生定制时都创建一个自定义渲染器。要实现`PlatformEffect`，我们首先创建一个继承自`PlatformEffect`框架的类。然后我们必须为每个平台编写特定实现。
- en: 'Following is a small overview of how the rendering process will look among
    the different projects:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对不同项目中渲染过程的小概览：
- en: '![Platform effects](img/image_08_004.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![平台效果](img/image_08_004.jpg)'
- en: 'Let''s add a new folder called `Effects` inside the `Camera` project, add in
    a new file called `LabelShadowEffect.cs`, and implement the following:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Camera`项目中添加一个名为`Effects`的新文件夹，添加一个名为`LabelShadowEffect.cs`的新文件，并实现以下内容：
- en: '[PRE117]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Our `LabelShadowEffect` must inherit the `PlatformEffect` framework. The `Radius`
    property is responsible for the corner radius of the shadow. Then we have the
    `Color` property that will set the color of the shadow. Finally, we have the `DistanceX`
    and `DistanceY` properties for assigning the position of the shadow.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`LabelShadowEffect`必须继承`PlatformEffect`框架。`Radius`属性负责阴影的圆角。然后我们有`Color`属性，它将设置阴影的颜色。最后，我们有`DistanceX`和`DistanceY`属性来分配阴影的位置。
- en: 'Now we must create the platform implementations. Let''s start with iOS, add
    in a new folder called `Effects`, add in a new file called `LabelShadowEffectiOS.cs`,
    and implement the following:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须创建平台实现。让我们从iOS开始，添加一个名为`Effects`的新文件夹，添加一个名为`LabelShadowEffectiOS.cs`的新文件，并实现以下内容：
- en: '[PRE118]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: All `PlatformEffects` must override the `OnAttached` and `OnDetached` methods.
    The `OnAttached` method is where we set up all native shadow effects. We start
    with retrieving the first `PlatformEffect` from the `Effects` list of the `Element`
    object. Like our `CustomRenderers`, we have access to the original `Xamarin.Forms`
    element that we are customizing. In the `OnDetached` method, we would normally
    dispose any objects that are no longer required.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`PlatformEffects`都必须重写`OnAttached`和`OnDetached`方法。`OnAttached`方法是我们设置所有原生阴影效果的地方。我们从`Element`对象的`Effects`列表中检索第一个`PlatformEffect`。像我们的`CustomRenderers`一样，我们有访问我们正在自定义的原始`Xamarin.Forms`元素。在`OnDetached`方法中，我们通常会丢弃不再需要的任何对象。
- en: 'We must also add assembly lines above the namespace block like the following:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须在命名空间块上方添加类似以下的装配线：
- en: '[PRE119]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: We must add a `ResolutionGroupName` to specify the namespace for the effects;
    this prevents collisions with other effects of the same name. We also add the
    `ExportEffect` attribute to register the effect with a unique ID that is used
    by `Xamarin.Forms`, along with the group name, to locate the effect prior to applying
    it to a control.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须添加一个`ResolutionGroupName`来指定效果的命名空间；这防止了与同名的其他效果的冲突。我们还添加了`ExportEffect`属性，以使用由`Xamarin.Forms`使用的唯一ID注册效果，以及组名，以便在将效果应用于控件之前定位效果。
- en: 'Now let''s add the equivalent for Android. Add a new folder in the `Camera.Droid`
    project, add a new file called `LabelShadowEffectDroid.cs`, and implement the
    following:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加Android的等效实现。在`Camera.Droid`项目中添加一个新文件夹，添加一个名为`LabelShadowEffectDroid.cs`的新文件，并实现以下内容：
- en: '[PRE120]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: In our Android implementation, we start with retrieving the control as a native
    `TextView`. We then retrieve the first `LabelShadowEffect` object from the list
    of effects from the `Element`. We then use the method `SetShadowLayer` to create
    native shadowing on the `TextView`.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Android实现中，我们首先将控件作为原生`TextView`检索。然后从`Element`的效果列表中检索第一个`LabelShadowEffect`对象。然后我们使用`SetShadowLayer`方法在`TextView`上创建原生阴影。
- en: 'Great! Now we have our native implementations, let''s add the `DescriptionLabel`
    object to the `MainPage`:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们有我们的原生实现，让我们将`DescriptionLabel`对象添加到`MainPage`：
- en: '[PRE121]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Here we are able to attach the effect inside our XAML. We must also add the
    namespace to the `Effects` folder:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们能够在XAML内部附加效果。我们还必须在`Effects`文件夹中添加命名空间：
- en: 'This is how the `MainPage` will look once complete:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是完成后的`MainPage`的外观：
- en: '![Platform effects](img/image_08_005.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![平台效果](img/image_08_005.jpg)'
- en: Building the CameraPage
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Camera页面
- en: Now for the final page of the solution, the `CameraPage` introduces some new
    tricks to handle orientation changes with `Grid` positions. We will be using `Converters`
    to change rows and columns on the `Grid` to reposition elements when we change
    orientation.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是解决方案的最后一页，`CameraPage`引入了一些新技巧来处理`Grid`位置的朝向变化。我们将使用`Converters`来更改`Grid`上的行和列，以便在改变朝向时重新定位元素。
- en: 'We are going to start with adding some converters to the project. Let''s create
    a new folder in the `Camera` project, add a new file called `NotConverter.cs`,
    and implement the following:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从向项目中添加一些转换器开始。在`Camera`项目中创建一个新文件夹，添加一个名为`NotConverter.cs`的新文件，并实现以下内容：
- en: '[PRE122]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Our first converter is responsible for taking a Boolean value and returning
    the opposite. Next we have the `OrientationToBoolConverter`. Add a new file and
    implement the following:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个转换器负责接受一个布尔值并返回其相反值。接下来是`OrientationToBoolConverter`。添加一个新文件并实现以下内容：
- en: '[PRE123]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'This converter uses the `Orientation``enum` we created at the start of the
    chapter. It will receive an `Orientation` value and a string as the parameter
    like the following:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 此转换器使用我们在本章开头创建的`Orientation`枚举。它将接收一个`Orientation`值和一个字符串作为参数，如下所示：
- en: '[PRE124]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Note
  id: totrans-464
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Converters can take parameters as well as values, so passing a string containing
    multiple cases allows us to use a set of specific return values to map to the
    values passed in.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 转换器可以接受参数以及值，因此传递一个包含多个情况的字符串允许我们使用一组特定的返回值来映射传入的值。
- en: We will then use the `Split` method to break up the string by the comma character,
    meaning we will have two strings that will be parsed in as a Boolean. These will
    be used as the return cases for the different orientations.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用`Split`方法通过逗号字符拆分字符串，这意味着我们将有两个字符串被解析为布尔值。这些将被用作不同方向的返回情况。
- en: 'Now let''s add another converter, which will convert a Boolean into a string:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加另一个转换器，它将布尔值转换为字符串：
- en: '[PRE125]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: We will use this on the camera page when the flash is turned on/off. If the
    flash is on, the string *on* will be returned. If the flash is off, we will return
    the string *off*. We use the same method as the `OrientationToBoolConverter` as
    we pass in a string value for the return cases.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在相机页面上使用这个方法，当闪光灯打开/关闭时。如果闪光灯打开，将返回字符串`*on*`。如果闪光灯关闭，我们将返回字符串`*off*`。我们使用与`OrientationToBoolConverter`相同的方法，因为我们传递了一个字符串值作为返回情况。
- en: 'Next, add another file called `BoolToPartialConverter.cs` and implement the
    following:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加另一个名为`BoolToPartialConverter.cs`的文件并实现以下内容：
- en: '[PRE126]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: This will be used for updating opacity based upon the value being `true` or
    `false`. We use a string for the opacity values being returned for each Boolean
    value.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这将用于根据值是`true`还是`false`来更新不透明度。我们使用字符串来返回每个布尔值的不透明度值。
- en: 'Our next converter `OrientationToIntConverter` is responsible for converting
    Orientation values into integers. This is the converter that will be responsible
    for changing the rows and columns numbers when the orientation changes:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个转换器`OrientationToIntConverter`负责将方向值转换为整数。这是当方向改变时将改变行和列数字的转换器：
- en: '[PRE127]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Again, we are using a string to contain the return cases, which we parse into
    a new integer using the `Int32.Parse` method.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们使用一个字符串来包含返回情况，然后使用`Int32.Parse`方法将这些情况解析成一个新的整数。
- en: 'Our last converter will be responsible for converting a byte array into an
    `ImageSource`. This is used for the binding created from the `CameraViewModel`
    in our `Camera.Portable` project. Since we don''t have the `ImageSource` framework
    in our portable project, we will use byte arrays to hold the image data received
    from the camera:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的转换器将负责将字节数组转换为`ImageSource`。这用于从我们的`Camera.Portable`项目中的`CameraViewModel`创建的绑定。由于我们的便携式项目中没有`ImageSource`框架，我们将使用字节数组来存储从相机接收到的图像数据：
- en: '[PRE128]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: In the `Convert` method, we check to see if the byte array is not null and contains
    data, and if so, we use the `FromStream` method from the `ImageSource` framework
    to create a new `MemoryStream` from the byte array.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Convert`方法中，我们检查字节数组是否不为空且包含数据，如果是，我们使用`ImageSource`框架的`FromStream`方法从字节数组创建一个新的`MemoryStream`。
- en: 'Now that we have all our converters, we must add these to the `App.xaml`:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所有的转换器，我们必须将这些添加到`App.xaml`中：
- en: '[PRE129]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Excellent! Let's build the interface for the `CameraPage`. We will see how these
    converters are used on each UI element.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！让我们为`CameraPage`构建接口。我们将看到这些转换器在每个UI元素上的使用。
- en: 'Add a new file called `CameraPage.xaml` and implement the following:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个名为`CameraPage.xaml`的新文件并实现以下内容：
- en: '[PRE130]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'We start with an empty `Grid`, which has seven rows and six columns. The first
    element to add is the `CameraView`:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个空的`Grid`开始，它有七行和六列。首先添加的元素是`CameraView`：
- en: '[PRE131]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Here we can see the use of the `OrientationToIntConverter`. The `PageOrientation`
    property from the view-model. When this property is set, and the `OnPropertyChanged`
    method is called. The `Convert` method will return a new integer, changing the
    number of rows the `CameraView` will take up. This is the same on the `ColumnSpan`
    property; the amount of columns taken by the `CameraView` will change when the
    orientation changes.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们可以看到`OrientationToIntConverter`的使用。来自视图模型的`PageOrientation`属性。当此属性被设置，并且调用`OnPropertyChanged`方法时，`Convert`方法将返回一个新的整数，改变`CameraView`占用的行数。这在`ColumnSpan`属性上也是相同的；当方向改变时，`CameraView`占用的列数将改变。
- en: 'Next we add the `FocusView` as follows:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们按照以下方式添加`FocusView`：
- en: '[PRE132]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: This will match the entire space of the `CameraView`. The `FocusView` will lay
    on top of the `CameraView` to receive the touch events and pass the (x, y) coordinate
    down to the `CameraView` to perform a focus.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 这将匹配`CameraView`的整个空间。`FocusView`将位于`CameraView`之上以接收触摸事件并将(x, y)坐标传递给`CameraView`以执行对焦。
- en: 'Next, we are going to add another `Grid` for containing the flash and photo
    buttons:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为包含闪光灯和拍照按钮添加另一个`Grid`：
- en: '[PRE133]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Here we see the use of the `CustomImage` instead of a button because we want
    to be able to show a specific image for each button.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到使用`CustomImage`而不是按钮，因为我们希望能够为每个按钮显示特定的图像。
- en: 'This panel is positioned under the `CameraView` like the following:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这个面板位于`CameraView`下方，如下所示：
- en: '![Building the CameraPage](img/image_08_006.jpg)'
  id: totrans-494
  prefs: []
  type: TYPE_IMG
  zh: '![构建CameraPage](img/image_08_006.jpg)'
- en: 'Next we have the `LoadingView` for displaying status of camera activity for
    initialization and taking photos:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`LoadingView`用于显示相机活动的初始化和拍照状态：
- en: '[PRE134]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'We now need to add another element for the camera buttons in landscape mode:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要为横屏模式中的相机按钮添加另一个元素：
- en: '[PRE135]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The following image shows the `CameraPage` in landscape:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了横屏中的`CameraPage`：
- en: '![Building the CameraPage](img/image_08_007-1.jpg)'
  id: totrans-500
  prefs: []
  type: TYPE_IMG
  zh: '![构建CameraPage](img/image_08_007-1.jpg)'
- en: 'The last element to add is another `Grid` that will appear when we take a photo:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要添加的元素是当我们拍照时出现的另一个`Grid`：
- en: '![Building the CameraPage](img/image_08_008.jpg)'
  id: totrans-502
  prefs: []
  type: TYPE_IMG
  zh: '![构建CameraPage](img/image_08_008.jpg)'
- en: '[PRE136]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The `Grid` contains the `Image` that will be bound to the `PhotoData` property
    on the view-model. This is where we use the `ByteArrayToImageSourceConverter`.
    Whenever the byte array is changed and the `OnPropertyChanged` method is called,
    a new image will be created from the byte array in the view-model. There is also
    a `CustomImage` that will add another button for closing the screen, deleting
    the image data, and returning to the camera to take another photo.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '`Grid`包含将绑定到视图模型上的`PhotoData`属性的`Image`。这是我们使用`ByteArrayToImageSourceConverter`的地方。每当字节数组更改并且调用`OnPropertyChanged`方法时，就会从视图模型中的字节数组创建一个新的图像。还有一个`CustomImage`，它将为关闭屏幕、删除图像数据并返回相机以拍摄另一张照片添加另一个按钮。'
- en: Adding native orientation events
  id: totrans-505
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加原生方向事件
- en: Our next step is to add the notifications that are going to fire every time
    an orientation occurs. These events will come from the native side, so in order
    to have these pass down to our `Xamarin.Forms` project, we are going to use the
    static events on the `OrientationPage`.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步要添加的是每次方向发生时都会触发的通知。这些事件将来自原生端，因此为了将这些传递到我们的`Xamarin.Forms`项目中，我们将使用`OrientationPage`上的静态事件。
- en: 'Let''s start with the iOS project. Open the `AppDelegate.cs` file and add the
    following function:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从iOS项目开始。打开`AppDelegate.cs`文件并添加以下函数：
- en: '[PRE137]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: The `DidChangeStatusBarOrientation` function is contained in all `AppDelegate`
    objects. When we override this, we reference the exact orientation in the `UIApplication.SharedApplication.StatusBarOrientation`
    property of the `AppDelegate`. Every time an orientation occurs, this method will
    be called and we will then call the static method `NotifyOrientationChange` on
    the `OrientationPage` to fire the event back to the `Xamarin.Forms` page.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '`DidChangeStatusBarOrientation`函数包含在所有`AppDelegate`对象中。当我们重写它时，我们引用`AppDelegate`的`UIApplication.SharedApplication.StatusBarOrientation`属性中的确切方向。每当发生方向变化时，此方法将被调用，然后我们将调用`OrientationPage`上的静态方法`NotifyOrientationChange`来触发事件返回到`Xamarin.Forms`页面。'
- en: 'Let''s do the same for Android. Open the `MainActivity.cs` file and add the
    following:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对Android做同样的事情。打开`MainActivity.cs`文件并添加以下内容：
- en: '[PRE138]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Tip
  id: totrans-512
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Unfortunately for Android, we can only gather whether the orientation is in
    landscape or portrait. IOS has the ability to determine whether we are in landscape
    left or landscape right.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android来说，我们只能收集方向是横屏还是竖屏。iOS有确定我们是在横屏左还是横屏右的能力。
- en: Like the `DidChangeStatusBarOrientation` function, the Android `OnConfigurationChanged`
    method will be called whenever the orientation changes. We use a switch statement
    again to call the static method on the `OrientationPage`.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`DidChangeStatusBarOrientation`函数一样，每当方向改变时，Android的`OnConfigurationChanged`方法都会被调用。我们再次使用switch语句来在`OrientationPage`上调用静态方法。
- en: Let's now add the logic behind the `CameraPage`. Here we will be responding
    to the native orientation events when they occur.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来添加`CameraPage`背后的逻辑。在这里，当这些事件发生时，我们将响应原生方向事件。
- en: 'Open the `CameraPage.xaml.cs` file and implement the private properties:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`CameraPage.xaml.cs`文件并实现私有属性：
- en: '[PRE139]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: We use the `CAMERA_BUTTON_CONTAINER_WIDTH` property when we render the camera
    stream on iOS, to make sure the stream bounds do not render behind the button
    container.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在iOS上渲染相机流时，我们使用`CAMERA_BUTTON_CONTAINER_WIDTH`属性，以确保流边界不会渲染在按钮容器后面。
- en: Tip
  id: totrans-519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When the camera is rendered for iOS, we have to reduce the render bound width
    by a certain amount to make sure that the camera bounds don't render behind the
    button container. Every time the orientation changes, we will use this value to
    reduce the width of the render bounds.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 当相机为iOS渲染时，我们必须减少渲染边界宽度的一定量，以确保相机边界不会渲染在按钮容器后面。每次方向改变时，我们将使用此值来减少渲染边界的宽度。
- en: 'We also have the `CameraPageViewModel` to keep locally when we retrieve it
    from the IoC container. Let''s add the constructor as follows:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从IoC容器中检索它时，我们还有`CameraPageViewModel`用于本地保持。让我们按照以下方式添加构造函数：
- en: '[PRE140]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Here we retrieve the `CameraPageViewModel` from the IoC container. We also register
    event functions when the page appears and disappears. We also register event functions
    on the `CameraView` when we take a photo, when the camera initialization occurs,
    when the camera is loading, and when the camera is busy. Then, we register one
    event for the `TouchFocus` event on the `FocusView`. Every time a new point (*x*,
    *y*) is received, we pass this to the `CameraView` to perform a focus.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从IoC容器中检索`CameraPageViewModel`。我们还注册了页面出现和消失时的事件函数。我们还注册了在拍照时、相机初始化时、相机加载时和相机忙碌时在`CameraView`上的事件函数。然后，我们为`FocusView`上的`TouchFocus`事件注册一个事件。每次接收到新的点(*x*,
    *y*)时，我们将此传递给`CameraView`以执行对焦。
- en: 'Let''s add the `EventHandler` functions for page appearing and disappearing.
    Here we will register and deregister to the orientation `OrientationHandler` event:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加页面出现和消失的`EventHandler`函数。在这里，我们将注册和注销到`OrientationHandler`事件：
- en: '[PRE141]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Let''s add the `HandleOrientationChange` method for updating the button container
    width by resizing the width of the `ColumnDefinition`. After we resize the `ColumnDefinition`,
    we then call `Reset` on the `FocusView` object; if the camera is ready to take
    a photo, we center the focus point of the camera to the middle of the screen.
    Then call the `NotifyOrientationChange` on the `CameraView` to update the renderer
    camera stream bounds and rotation:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加用于通过调整`ColumnDefinition`的宽度来更新按钮容器宽度的`HandleOrientationChange`方法。在我们调整`ColumnDefinition`后，我们然后在`FocusView`对象上调用`Reset`；如果相机准备好拍照，我们将相机的焦点中心对准屏幕中间。然后调用`CameraView`上的`NotifyOrientationChange`来更新渲染器相机流边界和旋转：
- en: '[PRE142]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Next, we have the `HandleBusy` and `HandleLoading` functions, which simply
    set the `CameraLoading` property on the view-model:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`HandleBusy`和`HandleLoading`函数，它们只是简单地设置视图模型中的`CameraLoading`属性：
- en: '[PRE143]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Then add the `HandleShutter`, which will call the `NotifyShutter` method on
    the `CameraView`:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加`HandleShutter`，它将在`CameraView`上调用`NotifyShutter`方法：
- en: '[PRE144]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Then we have the `HandleFlash` function responsible for updating the `FlashOn`
    property of the view-model and calling the `NotifyFlash` method on the `CameraView`:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有负责更新视图模型的`FlashOn`属性并调用`CameraView`上的`NotifyFlash`方法的`HandleFlash`函数：
- en: '[PRE145]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'The `HandlePictureTaken` function is called every time the camera button is
    touched and data is received from the native camera. We then pass the byte array
    back to the view-model using the `AddPhoto` method:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 每次触摸相机按钮并从原生相机接收数据时，都会调用`HandlePictureTaken`函数。然后我们使用`AddPhoto`方法将字节数组传递回视图模型：
- en: '[PRE146]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Next we have the `HandleCameraAvailability` method, which is called when the
    native camera availability status changes. If the camera is available, we the
    set the view-model properties, assign the starting orientation, and set up `IsVisible`
    bindings on the camera button containers to the `PageOrientation` property of
    the view-model.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`HandleCameraAvailability`方法，当原生相机可用状态改变时被调用。如果相机可用，我们设置视图模型属性，分配起始方向，并在相机按钮容器上设置`IsVisible`绑定到视图模型的`PageOrientation`属性。
- en: Tip
  id: totrans-537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We must set up the `IsVisible` bindings after the camera has become available
    because a layout pass is not called on items that are invisible when the page
    is loaded. We need the height and width to be set on these items even if the items
    are invisible.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在相机可用后设置`IsVisible`绑定，因为当页面加载时，对不可见的项目不调用布局遍历。即使这些项目不可见，我们也需要设置这些项目的高度和宽度。
- en: '[PRE147]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Now we must add the `OnNavigatedTo` method. Here we will set a new binding on
    the `IsVisible` property of the `LoadingView`.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须添加`OnNavigatedTo`方法。在这里，我们将设置`LoadingView`的`IsVisible`属性上的新绑定。
- en: Note
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember, we must set the `IsVisible` binding after the page has done the layout
    so that the `LoadingView` bounds are set correctly according to the `Grid`.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们必须在页面完成布局后设置`IsVisible`绑定，以便根据`Grid`正确设置`LoadingView`的边界。
- en: 'We must also call the `SetFocusPoints` on the `FocusView` to set the starting
    focus points in both landscape and portrait. These starting points will be calculated
    from the height and width properties to get the center of the screen. Then we
    call `NotifyOpenCamera` to begin the process on the native camera to initialize
    it and open the camera. On only for iOS do we call the `NotifyWidths` method,
    so the widths of the button container are passed to the iOS native camera class:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须在`FocusView`上调用`SetFocusPoints`来设置横屏和竖屏的起始焦点。这些起始点将根据高度和宽度属性计算以获得屏幕中心。然后我们调用`NotifyOpenCamera`来在原生相机上开始初始化并打开相机。仅在iOS上我们调用`NotifyWidths`方法，因此将按钮容器的宽度传递给iOS原生相机类：
- en: '[PRE148]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Lastly, we have the `HandleDelete` method for removing the photo edit view
    and clearing the image bytes to free memory:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`HandleDelete`方法用于移除照片编辑视图并清除图像字节以释放内存：
- en: '[PRE149]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Excellent! We now have implemented our entire `CameraPage` and native camera
    implementation for iOS and Android.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 极佳！我们现在已经实现了整个`CameraPage`以及iOS和Android的原生相机实现。
- en: Challenge
  id: totrans-548
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战
- en: We have built almost everything in the `Camera.Portable` and `Camera` projects,
    but there are still pieces missing. Here is another challenge. Fill in the missing
    pieces of the solution and get it compiling The remaining files are the exact
    same from all our other `Xamarin.Forms` solutions, but now it is your turn to
    finish off the project.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Camera.Portable`和`Camera`项目中构建了几乎所有内容，但仍有一些缺失的部分。这里又是一个挑战。填写解决方案的缺失部分并编译它。剩余的文件与我们的所有其他`Xamarin.Forms`解决方案完全相同，但现在轮到你来完成项目。
- en: Tip
  id: totrans-550
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To see the finished version, refer to [https://github.com/flusharcade/chapter8-camera](https://github.com/flusharcade/chapter8-camera).
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完成版本，请参阅[https://github.com/flusharcade/chapter8-camera](https://github.com/flusharcade/chapter8-camera)。
- en: Summary
  id: totrans-552
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built complete control over the native camera hardware for
    iOS and Android. We looked at implementing Grid changes using Converters, and
    built `CustomRenderers` for accessing native tinting features and touch events.
    We also created event triggers for buttons and `PlatformEffects` for creating
    shadow on a Label on the `MainPage`.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们完全控制了iOS和Android的原生相机硬件。我们探讨了使用转换器实现网格更改，并为访问原生着色功能和触摸事件构建了`CustomRenderers`。我们还为按钮创建了事件触发器，并在`MainPage`上的标签上创建了`PlatformEffects`以创建阴影。我们还在`MainPage`上创建了事件触发器。
- en: Congratulations! We have made it to the end of our Xamarin journey.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们已经完成了Xamarin之旅的终点。
