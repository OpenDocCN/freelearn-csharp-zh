<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
<head>
    <title>6. Plotting Mathematical Expressions</title>
    <link href="epub.css" rel="stylesheet" type="text/css"/>
    <link href="68851547a55f.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content">
      <div class="chapter" title="Chapter&#160;6.&#160;Plotting Mathematical Expressions">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch06"></a>Chapter&#160;6.&#160;Plotting Mathematical Expressions</h1>
            </div>
          </div>
        </div>
        <p>In this chapter, we will create an application which will plot arbitrary mathematical expressions on a <span class="strong"><strong>Windows Presentation Foundation</strong></span> (<span class="strong"><strong>WPF</strong></span>)-based graphical surface. We will be using the GoF observer pattern for wiring expression input control and the rendering surface. In the process, we will develop a library which can evaluate arbitrary arithmetic expressions on the fly. The expression evaluator will support basic arithmetic operators (<code class="literal">+</code>, <code class="literal">-</code>, <code class="literal">*</code>, <code class="literal">/</code>, unary <code class="literal">+</code>/<code class="literal">-</code> ), trigonometric functions, and a pseudo variable (<code class="literal">$t</code>) which can represent the value of X-axis in a 2D Plane. During the course of this chapter, as a reader, you will learn the following:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">The observer pattern</li>
            <li class="listitem" style="list-style-type: disc">Parsing mathematical expressions using recursive descent</li>
            <li class="listitem" style="list-style-type: disc">Modeling <span class="strong"><strong>abstract syntax tree</strong></span> (<span class="strong"><strong>AST</strong></span>) as a composite</li>
            <li class="listitem" style="list-style-type: disc">The interpreter pattern</li>
            <li class="listitem" style="list-style-type: disc">The builder pattern</li>
            <li class="listitem" style="list-style-type: disc">Elementary WPF 2D graphics</li>
          </ul>
        </div>
        <div class="section" title="Requirements for the expressions library and app">
          <div class="titlepage">
            <div>
              <div>
                <h1 class="title"><a id="ch06lvl1sec37"></a>Requirements for the expressions library and app</h1>
              </div>
            </div>
          </div>
          <p>Before we embark on writing the library, let us scribble down a preliminary requirement statement, which is as follows:</p>
          <p>The ability to plot the result of arbitrary mathematical expressions is a common requirement for business applications. We need to parse an expression to evaluate the resulting tree-structured representation. The process of lexical analysis, parsing, modeling expression nodes, recursive evaluation, and so on should be opaque to the application programmer. The library should support some trigonometric functions and a variable (<code class="literal">$t</code>) to pass the information of the current X-coordinate of the graphics surface. The application should evaluate the value of the Y-coordinate for each value of the X-coordinate passed to the expression evaluation engine.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Solutions approach">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch06lvl1sec38"></a>Solutions approach</h1>
            </div>
          </div>
        </div>
        <p>We will divide the requirement into the two following parts:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">A library for evaluating arbitrary mathematical expressions</li>
            <li class="listitem" style="list-style-type: disc">An application which will consume the aforementioned library to plot data</li>
          </ul>
        </div>
        <p>The expression evaluator library requirements can be enumerated as follows:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">Modeling expressions as AST</li>
            <li class="listitem" style="list-style-type: disc">Writing a lexical analyzer</li>
            <li class="listitem" style="list-style-type: disc">Writing a recursive descent parser</li>
            <li class="listitem" style="list-style-type: disc">Depth first walk of the tree</li>
            <li class="listitem" style="list-style-type: disc">Supporting trigonometric functions and pseudo variable (<code class="literal">$</code>)</li>
            <li class="listitem" style="list-style-type: disc">Packaging everything as a facade pattern-based API</li>
          </ul>
        </div>
        <p>The application requirements can be enumerated as follows:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">A screen with a WPF 2D graphics surface</li>
            <li class="listitem" style="list-style-type: disc">A prompt for entering expressions</li>
            <li class="listitem" style="list-style-type: disc">Implementation of the observer for detecting a new plot request</li>
            <li class="listitem" style="list-style-type: disc">Passing the value to the expressions library for change in the X-coordinate value</li>
            <li class="listitem" style="list-style-type: disc">Rendering the resulting value</li>
          </ul>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="The graph plotter application">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch06lvl1sec39"></a>The graph plotter application</h1>
            </div>
          </div>
        </div>
        <p>The graph plotter application is a simple WPF application with a canvas and a textbox in the frame. The following image gives a snapshot of the screen after the screen has rendered the result of an expression:</p>
        <p>
</p>
        <div class="mediaobject">
          <img src="graphics/B05691_06_01.jpg" alt="The graph plotter application"/>
        </div>
        <p>
</p>
        <p>The WPF canvas gets a notification whenever there is a change in the expression textbox. If the expression in the textbox is valid, the graph will be plotted as shown in the preceding image. We will deal with the nuances of implementing an expression evaluation engine in the following sections. The following code snippet shows how the change in text gets handled:</p>
        <pre class="programlisting">    public override void  
    Observer_ExpressionChangedEvent( string expression) 
    { 
      MainWindow mw = this._ctrl as MainWindow; 
      mw.Expr = expression; 
      ExpressionBuilder builder = new  
      ExpressionBuilder(expression); 
      Exp expr_tree = builder.GetExpression(); 
 
      if ( expr_tree != null ) 
      mw.Render(); 
    } 
</pre>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="The observer pattern for UI events">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch06lvl1sec40"></a>The observer pattern for UI events</h1>
            </div>
          </div>
        </div>
        <p>We will use the GoF observer pattern to handle UI events in an automatic fashion. The moment an expression gets changed in the textbox, the window should get a notification about it, and if the expression is valid, the resulting expression will be rendered on the screen.</p>
        <div class="note" title="Note" style="">
          <div class="inner">
            <h3 class="title"><a id="note26"></a>Note</h3>
            <p>While implementing the observer pattern, we have two classes-the <code class="literal">Subject</code> class, which represents the event source, and the <code class="literal">Observer</code> class, which is a list of observers (observer who are interested in listening to the event. Whenever there is a change in the text, the <code class="literal">Subject</code> class which represents the event source sends notification to all the sinks who have subscribed to the event.</p>
          </div>
        </div>
        <p>We have already mentioned that in the case of the observer pattern, we communicate between the event source and event sinks. The event source is represented using the <code class="literal">Subject</code> class, and the event sink is represented using an <code class="literal">Observer</code> class. Let us dissect the implementation of the <code class="literal">Observer</code> class:</p>
        <pre class="programlisting">    public abstract class BaseObserver 
    { 
      protected delegate void 
      ExpressionEventHandler(string expression); 
      protected ExpressionEventHandler ExpressionChangedEvent; 
      protected Control _ctrl = null; 
      public abstract void Observer_ExpressionChangedEvent(string     
      expression);</pre>
        <p>We declare a delegate which will act as an event handler, and to make the class handle all the WPF controls, we mark the event subscriber as a WPF control. The concrete class can hold any object derived from <code class="literal">Control</code>:</p>
        <pre class="programlisting">    public BaseObserver(Control ctrl) 
    { 
      this.ExpressionChangedEvent +=  
      new ExpressionEventHandler( 
      Observer_ExpressionChangedEvent); 
      this._ctrl = ctrl; 
    } 
</pre>
        <p>In the constructor, we initialize the delegate with an address of an abstract method. This will automatically get wired to the concrete class implementation of the method. We are, effectively, using the GoF template method pattern for the observer implementation. The concrete class is mandated to implement the <code class="literal">Observer_ExpressionChangedEvent</code> method:</p>
        <pre class="programlisting">    private void OnChange(string expression) 
    { 
      if (ExpressionChangedEvent != null) 
      ExpressionChangedEvent(expression); 
    } 
    public void Update(string expression) 
    { 
      OnChange(expression); 
    } 
  } 
</pre>
        <p>Now, we will try to write the <code class="literal">Subject</code> class which acts as an event source. The <code class="literal">Subject</code> class will iterate through the list of observers to dispatch the events which the observers are interested in. Any change in the expression textbox will be relayed to the window object, which acts as a receiver of the events:</p>
        <pre class="programlisting">    public class Subject 
    { 
      List&lt;BaseObserver&gt; observers = new List&lt;BaseObserver&gt;(); 
      private delegate void NotifyHandler(string expression); 
      private event NotifyHandler NotifyEvent; 
 
      public Subject(){ 
        this.NotifyEvent += new NotifyHandler(Notify); 
      } 
 
      public void UpdateClient(string expression){ 
        OnNotify(expression); 
      } 
 
      private void OnNotify(string expression){ 
        if (NotifyEvent != null) 
        NotifyEvent(expression); 
      } 
 
      private void Notify(string expression){ 
        foreach (BaseObserver b in observers) 
        b.Update(expression); 
      } 
 
      public void RegisterClient(BaseObserver obs){ 
        observers.Add(obs); 
      } 
    } 
</pre>
        <p>The <code class="literal">BaseObserver</code> class given in the preceding code snippet is an abstract class, and we need to create a concrete class which implements <code class="literal">Observer_ExpressionChangedEvent</code>. The concrete implementation listing is given as follows:</p>
        <pre class="programlisting">    class ExpressionObserver : BaseObserver 
    { 
      public ExpressionObserver(Window _win) : 
      base(_win){ } 
 
      public override void  
      Observer_ExpressionChangedEvent(string expression) 
      { 
        MainWindow mw = this._ctrl as MainWindow; 
        mw.Expr = expression; 
        ExpressionBuilder builder = new  
        ExpressionBuilder(expression); 
        Exp expr_tree = builder.GetExpression(); 
 
        if ( expr_tree != null ) 
          mw.Render(); 
      } 
    } 
</pre>
        <p>Let us see how we can connect the <code class="literal">Subject</code> and <code class="literal">Observer</code> class. See the <code class="literal">MainWindow.cs</code> module in the source code associated with this book. A snippet of the code is given as follows:</p>
        <pre class="programlisting">    _observer = new ExpressionObserver(this); 
    _subject = new Subject(); 
    _subject.RegisterClient(_observer); 
</pre>
        <p>Whenever there is change in the text, the rendering routine will be notified. The rendering routine uses WPF 2D graphics transformations to plot the equation:</p>
        <pre class="programlisting">    private void text_changed(object sender, TextChangedEventArgs e) 
    { 
      if ( _subject != null ) 
      _subject.UpdateClient(this.ExprText.Text); 
    } 
</pre>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="The expression evaluator and interpreter pattern">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch06lvl1sec41"></a>The expression evaluator and interpreter pattern</h1>
            </div>
          </div>
        </div>
        <p>The authors of this book believe that any programmer worth his salt needs to learn the rudiments of compiler construction for implementing mini-languages or <span class="strong"><strong>domain-specific language</strong></span> (<span class="strong"><strong>DSL</strong></span>) in his work. A compiler treats expressions as data, and expressions are mostly hierarchical in nature. We use a data structure called AST for representing the nodes of an expression tree. To convert textual expressions into an AST, we need to write a parser to analyze the constituents of an expression. The subsystem which feeds data to the parser is a module called lexical analyzer, which breaks the input stream into a series of tokens.</p>
        <p>The definition of a mini language, and writing an evaluator for it,&#160;is dealt with by the GoF catalog as interpreter pattern.</p>
        <p>In software design, the interpreter pattern is a design pattern that specifies how to evaluate sentences in a (mini) language. The basic idea is to have a class for each symbol (terminal or non-terminal) in a specialized computer language. In our case, we use a mini language with double precision floating point numbers, a symbolic variable (<code class="literal">$t</code>), trigonometric functions (sine/cosine), and basic arithmetic operators. The syntax tree of a sentence in the language is an instance of the composite pattern, and is used to evaluate (interpret) the sentence for a client. Some expressions which we handle are <span class="emphasis"><em>2*3 + SIN($t)*2</em></span>, <span class="emphasis"><em>$t*100</em></span>, <span class="emphasis"><em>COS((3.14159/2) - $t)</em></span>, and so on.</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="The abstract syntax tree (AST)">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch06lvl1sec42"></a>The abstract syntax tree (AST)</h1>
            </div>
          </div>
        </div>
        <p>In computer science, an AST, or just syntax tree, is a tree representation of the abstract (simplified) syntactic structure of the source code. Each node of the tree denotes a construct of the programming language under consideration. In our expression evaluator, the nodes are numeric values (IEEE 754 floating points), binary operators, unary operators, trigonometric functions, and a variable.</p>
        <p>The syntax is abstract in the sense that it does not represent every detail that appears in the real syntax. For instance, grouping parentheses is implicit in the tree structure, and AST data structure discards parentheses. Before we model the AST, let us see some expressions and its AST representations:</p>
        <pre class="programlisting">    // AST for 5*10 
    Exp e = new BinaryExp( 
    new NumericConstant(5), 
    new NumericConstant(10), 
    OPERATOR.MUL); 
</pre>
        <p>
</p>
        <div class="mediaobject">
          <img src="graphics/B05691_06_02.jpg" alt="The abstract syntax tree (AST)"/>
        </div>
        <p>
</p>
        <p>The preceding example uses two node types, that is, <code class="literal">NumericConstant</code>, <code class="literal">BinaryExp</code>. Even the simplest expression creates a structure which seems a bit complicated.</p>
        <p>Let us look at an expression which has a unary operator as well:</p>
        <pre class="programlisting">    // AST for -(10+(30+50)) 
    Exp e = new UnaryExp( 
      new BinaryExp( 
        new NumericConstant(10), 
        new BinaryExp( 
          new NumericConstant(30), 
          new NumericConstant(50), 
        OPERATOR.PLUS), 
      OPERATOR.PLUS) 
    ,OPERATOR.MINUS); 
</pre>
        <p>
</p>
        <div class="mediaobject">
          <img src="graphics/B05691_06_03.jpg" alt="The abstract syntax tree (AST)"/>
        </div>
        <p>
</p>
        <p>Since our expression evaluator only supports a single variable, we create a context class which will store the variable in question. The class is named <code class="literal">RUNTIME_CONTEXT</code>, and the whole listing is given as follows:</p>
        <pre class="programlisting">    public class RUNTIME_CONTEXT 
    { 
      private double _t = 0 ; 
      public RUNTIME_CONTEXT(){ } 
      public double T { 
        get { return _t; } 
        set { _t = value; } 
      } 
    } 
</pre>
        <p>In any programming language, expression is what you evaluate for its value. This can be modeled as an abstract class. The numeric value which we support is of the type IEEE 754 double precision floating point:</p>
        <pre class="programlisting">    abstract class Exp{ 
      public abstract double Evaluate(RUNTIME_CONTEXT cont);
    } 
</pre>
        <p>The expression evaluator supports operators like <code class="literal">PLUS</code> (+), <code class="literal">MINUS</code> (-), <code class="literal">DIV</code> (/), and <code class="literal">MUL</code> (*). They are modeled using an enumerated type named <code class="literal">OPERATOR</code>:</p>
        <pre class="programlisting">    public enum OPERATOR{ 
      ILLEGAL = -1,PLUS, MINUS, DIV, MUL 
    } 
</pre>
        <p>We will start by creating a hierarchy of nodes for modeling an expression. We use the composite pattern to compose bigger expressions out of smaller ones:</p>
        <pre class="programlisting">    class Exp // Base class for Expression 
    class NumericConstant // Numeric Value 
    class BinaryExp // Binary Expression 
    class UnaryExp // Unary Expression 
    class SineExp // Trig fn 
    class SineExp // Trig 
    class Var // psuedo variable $t 
</pre>
        <p>The <code class="literal">NumericConstant</code> class can store an IEEE 754 double precision floating point value in it. This is a leaf node in the AST:</p>
        <pre class="programlisting">    public class NumericConstant : Exp 
    { 
      private double _value; 
      public NumericConstant(double value){ _value = value;} 
 
      public override double Evaluate(RUNTIME_CONTEXT cont) 
      { return _value;} 
    } 
</pre>
        <p>The <code class="literal">BinaryExp</code> class models a binary expression which takes two expressions (<code class="literal">ex1</code> for the left node and <code class="literal">ex2</code> for the right node), it applies the operator on both, the left-side value and the right-side value, inside the evaluate routine:</p>
        <pre class="programlisting">    public class BinaryExp : Exp 
    { 
      private Exp _ex1, _ex2; 
      private OPERATOR _op; 
 
      public BinaryExp(Exp a, Exp b, OPERATOR op) 
      { _ex1 = a; _ex2 = b; _op = op; } 
 
      public override double Evaluate(RUNTIME_CONTEXT cont) 
      { 
        switch (_op) 
        { 
          case OPERATOR.PLUS: 
            return _ex1.Evaluate(cont) + _ex2.Evaluate(cont); 
          case OPERATOR.MINUS: 
            return _ex1.Evaluate(cont) - _ex2.Evaluate(cont); 
          case OPERATOR.DIV: 
            return _ex1.Evaluate(cont) / _ex2.Evaluate(cont); 
          case OPERATOR.MUL: 
            return _ex1.Evaluate(cont) * _ex2.Evaluate(cont); 
        } 
        return Double.NaN; 
      } 
    } 
</pre>
        <p>In the case of unary expressions, we take an operator and an <code class="literal">Exp</code> node as a child:</p>
        <pre class="programlisting">    public class UnaryExp : Exp 
    { 
      private Exp _ex1; 
      private OPERATOR _op; 
      public UnaryExp(Exp a, OPERATOR op) 
      {_ex1 = a;_op = op } 
      public override double Evaluate(RUNTIME_CONTEXT cont) 
      { 
        switch (_op) 
        { 
          case OPERATOR.PLUS: 
          return _ex1.Evaluate(cont); 
          case OPERATOR.MINUS: 
          return -_ex1.Evaluate(cont); 
        } 
        return Double.NaN; 
      } 
    } 
</pre>
        <p>The sine node takes an expression as a child. We evaluate <code class="literal">_ex1</code>, and invoke <code class="literal">Math.Sin</code> on the resulting value:</p>
        <pre class="programlisting">    class SineExp : Exp 
    { 
      private Exp _ex1; 
      public SineExp(Exp a) 
      { _ex1 = a; } 
      public override double Evaluate(RUNTIME_CONTEXT cont){ 
        double val = _ex1.Evaluate(cont); 
        return Math.Sin(val); 
      } 
    } 
</pre>
        <p>The cosine node takes an expression as a child. We evaluate <code class="literal">_ex1</code>, and invoke <code class="literal">Math.Cos</code> on the resulting value:</p>
        <pre class="programlisting">    class CosExp : Exp 
    { 
      private Exp _ex1; 
      public CosExp(Exp a) 
      { _ex1 = a;} 
      public override double Evaluate(RUNTIME_CONTEXT cont){ 
        double val = _ex1.Evaluate(cont); 
        return Math.Cos(val); 
      } 
    } 
</pre>
        <p>And finally, the variables (<code class="literal">$t</code>) are modeled as follows:</p>
        <pre class="programlisting">    class Var : Exp 
    { 
      public Var(){} 
      public override double Evaluate(RUNTIME_CONTEXT cont){ 
        return cont.T; 
      } 
    } 
</pre>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="The grammar of expressions">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch06lvl1sec43"></a>The grammar of expressions</h1>
            </div>
          </div>
        </div>
        <p>The <span class="strong"><strong>Backus-Naur Form</strong></span> (<span class="strong"><strong>BNF</strong></span>) notation is used to specify the grammar for programming languages. The semantics of BNF can be learned from books, and plenty of material is available. The grammar of the expression evaluator we use is as follows:</p>
        <pre class="programlisting">    &lt;Expr&gt; ::= &lt;Term&gt; | Term { + | - } &lt;Expr&gt; 
    &lt;Term&gt; ::= &lt;Factor&gt; | &lt;Factor&gt; {*|/} &lt;Term&gt; 
    &lt;Factor&gt;::= &lt;number&gt; | ( &lt;expr&gt; ) | {+|-} &lt;factor&gt; |  
                SIN(&lt;expr&gt;) | COS(&lt;expr&gt;) | $t 
</pre>
        <p>This BNF can be converted to source code very easily.</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Lexical analysis">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch06lvl1sec44"></a>Lexical analysis</h1>
            </div>
          </div>
        </div>
        <p>The lexical analyzer groups characters into tokens including <code class="literal">'+'</code>, <code class="literal">'-'</code>, <code class="literal">'/'</code>, <code class="literal">'*'</code>, <code class="literal">SIN</code>, <code class="literal">COS</code>, and so on. In the process, the module feeds the parser when a request is made to it. Rather than doing a lexical scan of the entire input, the parser requests the next token from the lexical analyzer. In our expression evaluator, the following tokens are returned by the lexical analyzer upon request for the next token by the parser:</p>
        <pre class="programlisting">    public enum TOKEN 
    { 
      ILLEGAL_TOKEN = -1, // Not a Token 
      TOK_PLUS = 1, // '+' 
      TOK_MUL, // '*' 
      TOK_DIV, // '/' 
      TOK_SUB, // '-' 
      TOK_OPAREN, // '(' 
      TOK_CPAREN, // ')' 
      TOK_DOUBLE, // '(' 
      TOK_TPARAM, // $t 
      TOK_SIN, // SIN 
      TOK_COS, // COS 
      TOK_NULL // End of string 
    } 
</pre>
        <p>The lexical analyzer module scans through the input, and whenever it finds a token (legal or illegal), it saves the current input pointer and returns the next token. Since the listing is lengthy and code is trivial, it is given as part of the code repository. The following pseudo-code shows the schema of the lexical analyzer:</p>
        <pre class="programlisting">    while (&lt;there is input&gt;)  
    { 
      switch(currentchar) { 
        case Operands: 
          &lt;advance input pointer&gt; 
          return TOK_XXXX; 
        case '$': 
          &lt;Now Look for 't'&gt; 
          if found return TOK_TPARAM 
            else Error 
        case Number: 
          &lt;Extract the number(Advance the input)&gt; 
          return TOK_DOUBLE; 
        case 'S' or 'C': 
          &lt;Try to see whether it is SIN/COS&gt; 
          Advance the input 
          return TOK_SIN Or TOK_COS 
        default: 
          Error 
      } 
    } 
</pre>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="The parser module">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch06lvl1sec45"></a>The parser module</h1>
            </div>
          </div>
        </div>
        <p>By using recursive descent parsing, we will arrange the tokens to see whether expressions are valid, and generate the AST out of the input stream with the help of the lexical analyzer.</p>
        <p>A recursive descent parser is a top-down parser built from a set of mutually-recursive procedures, where each such procedure usually implements one of the production rules of the grammar. Thus, the structure of the resulting program closely mirrors the grammar that it recognizes:</p>
        <pre class="programlisting">    public class RDParser : Lexer 
    { 
      TOKEN Current_Token; 
      public RDParser(String str): base(str){} 
 
      public Exp CallExpr() 
      { 
        Current_Token = GetToken(); 
        return Expr(); 
      } 
</pre>
        <p>The constructor of the <code class="literal">RDParser</code> class takes the expression string as a parameter, and passes it to the <code class="literal">Lexer</code> class. Whenever the parser requires a token, it asks the <code class="literal">Lexer</code> class to provide one through the <code class="literal">GetToken()</code> method. The whole parsing process starts from the <code class="literal">CallExpr()</code> method, and inside it, a token is grabbed by the parser through the <code class="literal">Lexer</code> class:</p>
        <pre class="programlisting">    //Implementation of &lt;Expr&gt; ::= &lt;Term&gt; | Term { + | - } &lt;Expr&gt;  
    Grammar 
    public Exp Expr() 
    { 
      TOKEN l_token; 
      Exp RetValue = Term(); 
      while (Current_Token == TOKEN.TOK_PLUS ||  
      Current_Token == TOKEN.TOK_SUB) 
      { 
        l_token = Current_Token; 
        Current_Token = GetToken(); 
        Exp e1 = Expr(); 
        RetValue = new BinaryExp(RetValue, e1, 
        l_token == TOKEN.TOK_PLUS ?  
        OPERATOR.PLUS : OPERATOR.MINUS); 
      } 
      return RetValue; 
    } 
</pre>
        <p>The <code class="literal">Expr()</code> function descends down to the <code class="literal">Term()</code> function (which is listed next), and returns the subexpressions from there. As long as there are further operators of the same precedence, it recursively calls the <code class="literal">Expr()</code> method to retrieve the factors in the form of tree. A <code class="literal">BinaryExp</code> node is created to represent the subexpressions parsed so far:</p>
        <pre class="programlisting">    //Implementation of &lt;Term&gt; ::= &lt;Factor&gt; | &lt;Factor&gt; {*|/} &lt;Term&gt;     
    Grammar 
    public Exp Term() 
    { 
      TOKEN l_token; 
      Exp RetValue = Factor(); 
      while (Current_Token == TOKEN.TOK_MUL ||  
      Current_Token == TOKEN.TOK_DIV) 
      { 
        l_token = Current_Token; 
        Current_Token = GetToken(); 
        Exp e1 = Term(); 
        RetValue = new BinaryExp(RetValue, e1, 
        l_token == TOKEN.TOK_MUL ?  
        OPERATOR.MUL : OPERATOR.DIV);  
      } 
      return RetValue; 
    } 
</pre>
        <p>The term descends down to the <code class="literal">Factor()</code> method (shown next) to retrieve a node (which can be an expression itself within the parentheses), and as long as operators of the same precedence are available, it recursively calls itself to generate the terms of the same type:</p>
        <pre class="programlisting">    //Implementation of &lt;Factor&gt;::= &lt;number&gt; | ( &lt;expr&gt; ) | {+|-}   
    &lt;factor&gt; |  
    //SIN(&lt;expr&gt;) | COS(&lt;expr&gt;) | $t Grammar 
    public Exp Factor() 
    { 
      TOKEN l_token; 
      Exp RetValue = null; 
 
      if (Current_Token == TOKEN.TOK_DOUBLE) 
      { 
        RetValue = new NumericConstant(GetNumber()); 
        Current_Token = GetToken(); 
      } 
</pre>
        <p>If the parser returns a number, the factor creates a numeric node and returns the same:</p>
        <pre class="programlisting">    else if (Current_Token == TOKEN.TOK_TPARAM) 
    { 
      RetValue = new Var(); 
      Current_Token = GetToken(); 
    } 
</pre>
        <p>If the current token is <code class="literal">$t</code>, a <code class="literal">Var</code> node is returned by the factor method. After instantiating the <code class="literal">Var</code> object, the parser grabs the next token before returning the expression object instance:</p>
        <pre class="programlisting">    else if ( Current_Token == TOKEN.TOK_SIN || 
    Current_Token == TOKEN.TOK_COS) 
    { 
      TOKEN old = Current_Token; 
      Current_Token = GetToken(); 
      if (Current_Token != TOKEN.TOK_OPAREN) 
      { 
        Console.WriteLine("Illegal Token"); 
        throw new Exception(); 
      } 
      Current_Token = GetToken(); 
      RetValue = Expr();  // Recurse 
 
      if (Current_Token != TOKEN.TOK_CPAREN) 
      { 
        Console.WriteLine("Missing Closing Parenthesis\n"); 
        throw new Exception(); 
      } 
 
      Retvalue = (old == TOKEN.TOK_COS) ? 
      new CosExp(RetValue) : 
      new SineExp(RetValue); 
      Current_Token = GetToken(); 
    } 
</pre>
        <p>If the current token is <code class="literal">SIN</code> or <code class="literal">COS</code>, we call <code class="literal">Expr()</code> recursively to parse the parameters. Once <code class="literal">Expr()</code> returns, we create the appropriate node:</p>
        <pre class="programlisting">    else if (Current_Token == TOKEN.TOK_OPAREN)  
    { 
      Current_Token = GetToken(); 
      RetValue = Expr();  // Recurse 
      if (Current_Token != TOKEN.TOK_CPAREN) 
      { 
        Console.WriteLine("Missing Closing Parenthesis\n"); 
        throw new Exception(); 
      } 
      Current_Token = GetToken(); 
    } 
</pre>
        <p>If we find an opening parenthesis, a call to <code class="literal">Expr()</code> will go to parse the nested expressions:</p>
        <pre class="programlisting">    else if (Current_Token == TOKEN.TOK_PLUS ||  
    Current_Token == TOKEN.TOK_SUB) 
    { 
      l_token = Current_Token; 
      Current_Token = GetToken(); 
      RetValue = Factor(); // Recurse 
      RetValue = new UnaryExp(RetValue, 
      l_token == TOKEN.TOK_PLUS ?  
      OPERATOR.PLUS : OPERATOR.MINUS); 
    } 
    else 
    { 
      Console.WriteLine("Illegal Token"); 
      throw new Exception(); 
    } 
    return RetValue; 
  } 
} 
</pre>
        <p>The preceding code snippet handles unary operators, and if the current token is any other thing which is not supposed to be there, an error will be thrown. The syntax diagrams (also known as railroad diagrams) of the grammar realized are shown next.</p>
        <p>
<span class="strong"><strong>Expr</strong></span> is represented with the following syntax diagram. The BNF grammar gives better clarity:</p>
        <pre class="programlisting">    &lt;Expr&gt; ::= &lt;Term&gt; | Term { + | - } &lt;Expr&gt; 
</pre>
        <p>
</p>
        <div class="mediaobject">
          <img src="graphics/B05691_06_04.jpg" alt="The parser module"/>
        </div>
        <p>
</p>
        <p>The following syntax diagram represents the <span class="strong"><strong>Term.</strong></span>&#160;The BNF grammar is shown for better&#160;clarity:</p>
        <pre class="programlisting">    &lt;Term&gt; ::= &lt;Factor&gt; | &lt;Factor&gt; {*|/} &lt;Term&gt; 
</pre>
        <p>
</p>
        <div class="mediaobject">
          <img src="graphics/B05691_06_05.jpg" alt="The parser module"/>
        </div>
        <p>
</p>
        <p>
<span class="strong"><strong>Factor</strong></span> can be represented using the following railroad diagram. The BNF grammar is also shown&#160;for the sake of clarity:</p>
        <pre class="programlisting">    &lt;Factor&gt;::= &lt;number&gt; | ( &lt;expr&gt; ) | {+|-} &lt;factor&gt; | SIN(&lt;expr&gt;) |  
    COS(&lt;expr&gt;) | $t</pre>
        <p>
</p>
        <div class="mediaobject">
          <img src="graphics/B05691_06_06.jpg" alt="The parser module"/>
        </div>
        <p>
</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="The builder, facade, and expression APIs">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch06lvl1sec46"></a>The builder, facade, and expression APIs</h1>
            </div>
          </div>
        </div>
        <p>The process of interpreting an expression is a complicated process, where a lot of classes work together towards the goal. As an application developer, to focus on the task at hand, we might have to expose an API which abstracts away the complexities of lexical analysis, parsing, and AST generation. We normally use the GoF facade pattern in these contexts. But, we will use the GoF builder pattern here, as this creational pattern is more appropriate in situations where we need to create a composite object. Here, we create expressions which are modeled as composites:</p>
        <pre class="programlisting">    public class AbstractBuilder{} 
 
    public class ExpressionBuilder : AbstractBuilder 
    { 
      public string _expr_string; 
      public ExpressionBuilder(string expr) 
      { _expr_string = expr; } 
 
      public Exp GetExpression() 
      { 
        try 
        { 
          RDParser p = new RDParser(_expr_string); 
          return p.CallExpr(); 
        } 
        catch (Exception) 
        { 
          return null; 
        } 
      } 
    } 
</pre>
        <p>The <code class="literal">GetExpression()</code> method leverages recursive descent parsing and lexical analysis to create an <code class="literal">Exp</code> object composed of AST nodes. If the parse fails, the routine will return null. The <code class="literal">Builder</code> class will be used to parse an expression from its textual representation:</p>
        <pre class="programlisting">    double t = -x / 2; 
    double final = x / 2; 
    ExpressionBuilder bld = new ExpressionBuilder(expr); 
    Exp e = bld.GetExpression(); 
    if (e == null) 
      return false; 
</pre>
        <div class="note" title="Note" style="">
          <div class="inner">
            <h3 class="title"><a id="note27"></a>Note</h3>
            <p>We parse the tree once to create the AST. Once the AST has been created, we can evaluate the resulting AST many times over by changing the value in the <code class="literal">RUNTIME_CONTEXT</code> object.</p>
          </div>
        </div>
        <pre class="programlisting"> 
    RUNTIME_CONTEXT context = new RUNTIME_CONTEXT(); 
    context.T = t; 
    for (; t &lt; final; t += 4) 
    { 
      context.T=t; 
      double n = e.Evaluate(context); 
      RenderAPixel(); 
    }</pre>
        <p>The expression is parsed once, and an AST is created out of it. Once the tree has been created, it can be evaluated by changing the <code class="literal">context</code> object. In the preceding loop, <code class="literal">t</code> is updated and set to the <code class="literal">context</code> object. Each time you evaluate the tree, you evaluate against a different value of <code class="literal">t</code>.
</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Summary">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch06lvl1sec47"></a>Summary</h1>
            </div>
          </div>
        </div>
        <p>In this chapter, we created an application which plots the result of an arbitrary mathematical expression on a graphics surface. We used WPF for our rendering purpose. We also created an expression evaluator library, which uses the recursive descent parsing technique to parse an expression to a data structure called AST. The AST can be walked depth-first to evaluate the value. This is a good example of the interpreter pattern. We used the observer pattern to automatically relay the changes in the expression input to the canvas object. In the next chapter, you will learn how the .NET framework library leverages patterns to expose a good API for developers.</p>
      </div>
    </div>
</body>
</html>