- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Enhancing Security and Quality
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高安全和质量
- en: In the rapidly evolving digital world, where new cyber threats emerge with alarming
    frequency, web-based application security is not just a feature but a fundamental
    necessity. So that applications are prepared for various existing vulnerabilities,
    software engineers must consider security as part of the entire development flow
    of web-based solutions so that they can protect data, guarantee integrity and
    availability, and minimize threats that can compromise an organization.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在快速发展的数字世界中，新的网络威胁以惊人的频率出现，基于Web的应用程序安全不仅仅是特性，而是基本需求。因此，为了使应用程序能够应对各种现有漏洞，软件工程师必须将安全性视为基于Web解决方案整个开发流程的一部分，以便他们可以保护数据，保证完整性和可用性，并最小化可能损害组织的威胁。
- en: In this chapter, we’ll learn about basic security principles that every web
    developer should master, especially regarding how ASP.NET Core 9, as a powerful
    platform, can help us create secure, high-level applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解每个Web开发者都应该掌握的基本安全原则，特别是关于ASP.NET Core 9作为一个强大的平台，如何帮助我们创建安全、高级的应用程序。
- en: First, we’ll explore the essential principles of web security, understanding
    that security must be taken into consideration in all phases of developing a web
    solution.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探讨网络安全的基本原则，理解在开发Web解决方案的所有阶段都必须考虑安全性。
- en: Next, we’ll address the concepts of authentication and authorization, both of
    which are commonly used when users and applications, as well as applications and
    external applications, interact with each other. Once we have a better understanding
    of authorization and authentication flows, we’ll use the ASP.NET Core Identity
    framework to add security to an API project and learn about some important approaches
    that are available in ASP.NET Core 9 that allow us to strengthen security mechanisms
    in our applications.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论身份验证和授权的概念，这两个概念在用户和应用程序、以及应用程序和外部应用程序相互交互时都常用。一旦我们更好地理解了授权和身份验证流程，我们将使用ASP.NET
    Core Identity框架为API项目添加安全性，并了解ASP.NET Core 9中一些重要的方法，这些方法允许我们加强应用程序中的安全机制。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the security principles of web-based applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解基于Web应用程序的安全原则
- en: Comparing authorization and authentication
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较授权和身份验证
- en: Working with the ASP.NET Core Identity framework
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ASP.NET Core Identity框架
- en: Strengthening application security
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加强应用程序安全
- en: For us to have a great learning experience in this chapter, we must prepare
    our environment with some tools that will be essential for us to fully utilize
    the concepts that will be introduced.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在本章中获得良好的学习体验，我们必须准备一些工具，这些工具对我们充分利用将要介绍的概念至关重要。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, the following tools must be present in your development
    environment:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章，以下工具必须存在于您的开发环境中：
- en: '**Docker** : Docker Engine must be installed on your operating system and have
    a SQL Server container running. You can find more details about Docker and SQL
    Server in [*Chapter 4*](B21788_04.xhtml#_idTextAnchor061) .'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker**：必须在您的操作系统上安装Docker Engine，并运行一个SQL Server容器。您可以在[*第4章*](B21788_04.xhtml#_idTextAnchor061)中找到有关Docker和SQL
    Server的更多详细信息。'
- en: '**Postman** : We’ll use this tool to execute requests that are sent to the
    APIs of the developed application.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Postman**：我们将使用此工具执行发送到开发应用程序API的请求。'
- en: '**Azure Data Studio** : We’ll use this tool to connect to a SQL Server database
    so that we can execute SQL scripts.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure Data Studio**：我们将使用此工具连接到SQL Server数据库，以便我们可以执行SQL脚本。'
- en: 'The code examples for this chapter can be found in this book’s GitHub repository:
    [https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter06](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter06)
    .'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码示例可以在本书的GitHub存储库中找到：[https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter06](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter06)。
- en: Understanding the security principles of web-based applications
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解基于Web应用程序的安全原则
- en: Every year, new approaches to developing solutions emerge for the most diverse
    types of environments and devices. With this comes various challenges. Developing
    web applications that previously focused on technologies such as HTML, CSS, JavaScript,
    and a programming language of choice is no longer a reality.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每年，针对最多样化的环境和设备，都会出现新的解决方案开发方法。随之而来的是各种挑战。以前专注于HTML、CSS、JavaScript和所选编程语言的Web应用开发已不再是现实。
- en: Software engineers began to serve other contexts outside the environment of
    a programming IDE, often working with iInfrastructure, adding to a multitude of
    frameworks and tools that emerged along with the DevOps cCulture approach, and
    constant value delivery.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程师开始服务于编程IDE环境之外的其它上下文，通常与iInfrastructure合作，增加了与DevOps文化方法一同出现的众多框架和工具，以及持续的价值交付。
- en: The DevOps culture has brought a new working model where teams avoid silos and
    work together while exchanging knowledge and, consequently, learning. Therefore,
    a subject that is becoming increasingly present in the lives of solution developers
    is **security** . The term security has long ceased to be an isolated subject
    directed only at a cybersecurity team. It is now essential from the first stages
    of design and must be considered in all aspects of a solution.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps文化带来了一种新的工作模式，团队避免了孤岛效应，在交流知识的同时共同工作，因此，一个越来越出现在解决方案开发者生活中的主题是**安全**。安全这个术语早已不再是一个仅针对网络安全团队的孤立主题。它现在在设计的第一阶段就至关重要，必须考虑在解决方案的所有方面。
- en: Paying attention to threats in applications and data control and management
    has become paramount and is even a strategic factor for companies and customers
    that use applications. There are many security standards and policies from a data
    processing perspective, such as the **General Data Protection Regulation** ( **GDPR**
    ) in Europe.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 关注应用和数据的威胁以及控制和管理工作已成为至关重要的因素，甚至对公司和使用应用的用户来说是一个战略性的因素。从数据处理的角度来看，有许多安全标准和政策，例如欧洲的**通用数据保护条例**（**GDPR**）。
- en: Security is very important and ASP.NET Core 9 offers several mechanisms that
    we can use to deal with the challenges proposed by avoiding threats and maintaining
    secure and reliable applications.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性非常重要，ASP.NET Core 9提供了多种机制，我们可以利用这些机制来应对通过避免威胁和保持应用的安全和可靠性所提出的挑战。
- en: However, we must understand how security aspects are applied to web applications
    and common vulnerabilities, as well as how ASP.NET Core 9 works to prevent threats
    from occurring in applications.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们必须了解安全方面是如何应用于Web应用以及常见漏洞的，以及ASP.NET Core 9是如何防止应用中出现威胁的。
- en: Security topics in web applications
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web应用中的安全主题
- en: 'As we’ve already learned in previous chapters, in general, a web application
    has two main components: the frontend, which is responsible for interacting with
    the user, and the backend, which is responsible for processing the application’s
    business rules, providing control, and interacting with the data layer.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在前面的章节中已经学到的，一般来说，一个Web应用有两个主要组件：前端，负责与用户交互，以及后端，负责处理应用的业务规则，提供控制和与数据层交互。
- en: 'Most web applications, whether they’re client-server ones or **single-page
    applications** ( **SPAs** ), use the aforementioned approach in some way. As shown
    in *Figure 6* *.1* , several components are part of how the frontend and backend
    interact, such as the communication protocol, requests, responses, HTTP headers,
    the browser, the application server, the database, the TCP protocol, credentials,
    cookies, and local storage (browser), among others:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Web应用，无论是客户端/服务器应用还是**单页应用**（**SPAs**），都以某种方式使用上述方法。如图*图6.1*所示，几个组件是前端和后端交互的一部分，例如通信协议、请求、响应、HTTP头、浏览器、应用服务器、数据库、TCP协议、凭证、cookies和本地存储（浏览器）等：
- en: '![Figure 6.1 – Components of a SPA](img/B21788_06_1.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 单页应用（SPA）的组件](img/B21788_06_1.jpg)'
- en: Figure 6.1 – Components of a SPA
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 单页应用（SPA）的组件
- en: As we can see, several components communicate with each other. Similarly, several
    vulnerabilities can compromise the integrity of your application. In some cases,
    an information leak can have serious consequences for an organization.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，几个组件相互通信。同样，几个漏洞可能会损害你应用的安全性。在某些情况下，信息泄露可能对组织产生严重后果。
- en: As a premise, software engineers must have a security aspect set out from the
    initial design stage that can often be associated not only with communication
    protocols and interactions between systems but also with code development.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 作为前提，软件工程师必须从最初的设计阶段就设定一个安全方面，这通常不仅与通信协议和系统之间的交互有关，还与代码开发有关。
- en: Let’s say that, during the development process, a software engineer made a very
    important change that was supposed to fix a critical problem in the application.
    To quickly perform the correction, the software engineer created communication
    with the database using SQL commands and string concatenation. After carrying
    out the tests, the engineer submitted the code to the Git repository so that the
    system could be updated. There was no code review and within a few minutes, the
    fix was in the production environment.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，在开发过程中，一位软件工程师做出了一项非常重要的更改，旨在修复应用程序中的一个关键问题。为了快速执行更正，软件工程师使用SQL命令和字符串连接创建了与数据库的通信。在完成测试后，工程师将代码提交到Git仓库，以便更新系统。没有进行代码审查，几分钟内，修复就进入了生产环境。
- en: So, what’s wrong in this scenario? Initially, the software engineer acted correctly
    in providing a quick response to the problem that was found in the application
    and corrected it, and everything returned to normal. However, the approach they
    used to communicate with the database contained a vulnerability that could be
    exploited by malicious users by utilizing what’s known as **SQL** **injection
    attacks** .
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个场景中有什么问题呢？最初，软件工程师在快速响应应用程序中发现的问题并进行了更正时表现正确，一切恢复正常。然而，他们与数据库通信的方法中存在一个漏洞，恶意用户可以通过所谓的**SQL**
    **注入攻击**来利用这个漏洞。
- en: 'Let’s look at an example of some code that’s vulnerable to SQL injection attacks:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些容易受到SQL注入攻击的代码示例：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, the SQL query has been constructed by directly concatenating
    a user’s input (username) into the SQL string. This is a dangerous practice because
    it allows an attacker to alter the intended SQL query by injecting SQL code into
    the **username** variable. For example, if a user enters something like **'';
    DROP TABLE users; --** , the resulting SQL query would be as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，SQL查询是通过直接将用户的输入（用户名）连接到SQL字符串中构建的。这是一种危险的做法，因为它允许攻击者通过向**username**变量注入SQL代码来更改预期的SQL查询。例如，如果用户输入类似**';
    DROP TABLE users; --**的内容，生成的SQL查询将如下所示：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This would execute the **DROP TABLE** statement, potentially destroying data.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行**DROP TABLE**语句，可能会破坏数据。
- en: So, a simple change such as this, even with great intentions, could have a big
    impact. Likewise, simple processes can avoid this situation by implementing a
    code review, a practice where members of the engineering team analyze the code
    that should be incorporated into the main code to search for any flaws, evaluate
    code patterns and complexity, and more. The code can only be incorporated into
    the main code if it meets the quality and security criteria.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使有很好的意图，这样的简单更改也可能产生重大影响。同样，通过实施代码审查，简单的流程可以避免这种情况。代码审查是一种实践，其中工程团队成员分析应纳入主代码的代码，以寻找任何缺陷，评估代码模式和复杂性等。只有当代码满足质量和安全标准时，才能将其纳入主代码。
- en: Furthermore, while integrating the new code into the main code, automated processes
    can be executed, where it would be possible to add **static code analysis** mechanisms.
    If there are any invalid security and quality criteria, the application can’t
    be delivered to the productive environment. We’ll learn more about automated processes
    in [*Chapter 10*](B21788_10.xhtml#_idTextAnchor162) .
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在将新代码集成到主代码中时，可以执行自动化流程，其中可以添加**静态代码分析**机制。如果有任何无效的安全和质量标准，应用程序就不能交付到生产环境。我们将在[*第10章*](B21788_10.xhtml#_idTextAnchor162)中了解更多关于自动化流程的内容。
- en: Static code analysis
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 静态代码分析
- en: Static code analysis acts on security checks, coding standards, and cyclomatic
    complexity analysis, among other aspects, adding value to the application development
    process associated with automation techniques that involve **continuous integration**
    ( **CI** ) and **continuous delivery** ( **CD** ). There are several tools available
    in the market for static code analysis, with the most famous being **SonarQube**
    ( [https://hub.docker.com/_/sonarqube](https://hub.docker.com/_/sonarqube) ).
    It has a community version and can be hosted in any environment. However, it does
    have some limitations regarding how many lines of code can be analyzed. Alternatively,
    there’s a version that’s delivered as a **Software-as-a-Service** ( **SaaS** )
    offering called **Sonar** **Cloud** ( [https://www.sonarsource.com/products/sonarcloud/](https://www.sonarsource.com/products/sonarcloud/)
    ).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 静态代码分析在安全检查、编码标准和循环复杂度分析等方面发挥作用，为与自动化技术相关的应用程序开发流程增加价值，这些自动化技术包括**持续集成**（**CI**）和**持续交付**（**CD**）。市场上有多款静态代码分析工具，其中最著名的是**SonarQube**（[https://hub.docker.com/_/sonarqube](https://hub.docker.com/_/sonarqube)）。它有一个社区版本，可以托管在任何环境中。然而，它在分析代码行数方面确实有一些限制。作为替代方案，还有一个作为**软件即服务**（**SaaS**）提供的版本，称为**Sonar
    Cloud**（[https://www.sonarsource.com/products/sonarcloud/](https://www.sonarsource.com/products/sonarcloud/)）。
- en: Adding static analysis to the development flow is an excellent practice.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将静态分析添加到开发流程中是一种非常好的做法。
- en: 'In this chapter, we’ll explore other ways we can make our applications more
    secure and talk about various vulnerabilities. But first, let’s understand a common
    security model that’s used by most applications that’s based on two basic processes:
    authentication and authorization.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨其他方法来使我们的应用程序更加安全，并讨论各种漏洞。但首先，让我们了解大多数应用程序都使用的一个常见安全模型，该模型基于两个基本过程：认证和授权。
- en: Comparing authorization and authentication
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权与认证的比较
- en: As we’ve been learning, the security aspect is important throughout the application
    development flow. Despite having good intentions, we can include vulnerabilities
    in our code that directly affect our users, applications, and companies.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，安全方面在应用程序开发流程中非常重要。尽管我们有着良好的意图，但我们可能会在我们的代码中包含漏洞，这些漏洞会直接影响我们的用户、应用程序和公司。
- en: However, in addition to the code, some features require security processes.
    For example, this is the case for some service platforms, such as email managers,
    which allow users to access their messages privately once they’ve gained access
    by logging in.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除了代码之外，一些功能还需要安全流程。例如，某些服务平台（如电子邮件管理器）的情况就是这样，用户一旦通过登录获得访问权限，就可以私密地访问他们的消息。
- en: The login functionality is very important and, although it seems like a simple
    process, it requires a lot of attention. Otherwise, depending on the application,
    there may be consequences.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 登录功能非常重要，尽管它看起来是一个简单的流程，但它需要大量的关注。否则，根据应用程序的不同，可能会有后果。
- en: What would happen if there was a vulnerability upon logging into an online banking
    platform? It would probably be a big problem for the users of this bank (and also
    for the bank).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在线银行平台登录时出现漏洞，会发生什么？这可能会给该银行的用户（以及银行本身）带来大问题。
- en: Modern systems work with identity management for different aspects. As discussed
    in previous chapters, web applications can make requests to different APIs. APIs
    allow companies to provide business as services, which allows for diverse integrations
    between different applications. With this, it’s possible to have applications
    with different types of functionalities that add value to the user, such as map
    APIs, payment gateways, and even APIs that provide AI functionalities.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现代系统在处理不同方面时与身份管理协同工作。正如前几章所讨论的，Web应用程序可以向不同的API发起请求。API允许公司以服务的形式提供业务，这促进了不同应用程序之间的多样化集成。因此，可以拥有具有不同类型功能的应用程序，这些功能可以为用户提供价值，例如地图API、支付网关，甚至提供AI功能的服务API。
- en: For applications and APIs to communicate securely, an identity-based security
    mechanism is necessary. With this, we can find out who is demanding some type
    of information and why.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使应用程序和API能够安全通信，需要一个基于身份的安全机制。有了这个机制，我们可以找出谁在请求某种类型的信息以及为什么。
- en: 'This security mechanism is divided into two concepts: **authentication** and
    **authorization** .'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这种安全机制分为两个概念：**认证**和**授权**。
- en: In general, we know that this approach involves a login flow. However, it’s
    essential to understand the difference between authentication and authorization.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们知道这种方法涉及登录流程。然而，理解认证和授权之间的区别是至关重要的。
- en: Authentication
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证
- en: 'Authentication aims to answer the question, *Who* *are you?* :'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 认证旨在回答问题，“你是谁？”：
- en: '![Figure 6.2 – The authentication flow](img/B21788_06_2.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 认证流程](img/B21788_06_2.jpg)'
- en: Figure 6.2 – The authentication flow
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 认证流程
- en: '*Figure 6* *.2* shows an authentication flow where, through a login form, a
    user’s credentials are provided, such as their email and password.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6* *.2* 展示了一个认证流程，其中通过登录表单提供了用户的凭证，例如他们的电子邮件和密码。'
- en: By posting this information to the server by clicking the **log in** button,
    the application starts identifying this user by using the credentials provided.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击**登录**按钮将此信息发布到服务器，应用程序开始使用提供的凭证识别此用户。
- en: If the user is found according to these credentials, then the application is
    aware of who wants to access the system.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果根据这些凭证找到用户，那么应用程序就知道了谁想要访问系统。
- en: However, this is just one part of the process. Now that the application has
    identified the user, it’s important to understand what this user can do. This
    is done during the authorization process.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这只是过程的一部分。现在应用程序已经识别了用户，了解这个用户能做什么就很重要了。这是在授权过程中完成的。
- en: Authorization
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权
- en: 'Authorization aims to answer the question, *What can this* *user do?* :'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 授权旨在回答问题，“这个用户能做什么？”：
- en: '![Figure 6.3 – Checking permissions with the authorization flow](img/B21788_06_3.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 使用授权流程检查权限](img/B21788_06_3.jpg)'
- en: Figure 6.3 – Checking permissions with the authorization flow
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 使用授权流程检查权限
- en: After identifying the user, the application starts identifying the user’s permissions,
    as shown in *Figure 6* *.3* .
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在识别用户后，应用程序开始识别用户的权限，如图 *图 6* *.3* 所示。
- en: Authorization defines the scope in which this user can act, whether in managing
    some information or accessing a certain type of data, among other aspects. The
    authorization flow often identifies the user through roles, where it’s possible
    to group access levels within the scope of the application.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 授权定义了用户可以行动的范围，无论是管理某些信息还是访问某种类型的数据，以及其他方面。授权流程通常通过角色识别用户，在应用程序的作用域内可以分组访问级别。
- en: It’s very common to use roles because it’s possible to group the different permissions
    that a user can have within an application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用角色非常常见，因为可以将用户在应用程序中可能拥有的不同权限分组。
- en: 'In general, the authentication and authorization processes are simple. However,
    to be able to implement them securely, there are some standards that we must be
    aware of: the **OAuth 2.0** and **Open ID Connect** ( **OIDC** ) protocols.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，认证和授权过程很简单。然而，为了能够安全地实现它们，我们必须了解一些标准：**OAuth 2.0** 和 **Open ID Connect**（**OIDC**）协议。
- en: Understanding OAuth 2.0 and OIDC
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 OAuth 2.0 和 OIDC
- en: Imagine a high-security building. Here, authorization can be thought of as acquiring
    permission to enter, while authentication verifies your identity.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个高度安全的建筑。在这里，授权可以被认为是获得进入的许可，而认证则是验证你的身份。
- en: OAuth 2.0 focuses on authorization, allowing users to grant access to their
    data on one platform (such as a social media account) to another, without the
    need for them to share their actual passwords. In other words, we allow other
    applications to access a certain scope of our information without us having to
    provide certain credentials, such as what happens when we log in to some platform
    using credentials from Microsoft, Google, Facebook, and so on.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0 专注于授权，允许用户在平台之间（如社交媒体账户）授予对他们的数据的访问权限，而无需他们共享实际的密码。换句话说，我们允许其他应用程序访问我们信息的一定范围，而无需我们提供某些凭证，例如当我们使用微软、谷歌、Facebook
    等平台的凭证登录某些平台时发生的情况。
- en: 'The basic OAuth 2.0 flow can be defined as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的 OAuth 2.0 流程可以定义为以下：
- en: The user logs in to a new application using their social media account.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户使用他们的社交媒体账户登录到一个新的应用程序。
- en: The application redirects the user to the social media platform (the authorization
    server).
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序将用户重定向到社交媒体平台（授权服务器）。
- en: After logging into the social media account, the user grants the application
    permission to use their data (such as their name, email, profile photo, and more).
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在登录社交媒体账户后，用户授权应用程序使用他们的数据（例如他们的姓名、电子邮件、个人资料照片等）。
- en: The authorization server generates special tokens for the application. Tokens
    are used to gain access to user data (access tokens). In some cases, refresh tokens
    are used to provide access to new tokens.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权服务器为应用程序生成特殊的令牌。令牌用于获取用户数据（访问令牌）。在某些情况下，使用刷新令牌来提供访问新令牌。
- en: The application uses the access token to retrieve your data from the social
    media platform securely.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序使用访问令牌从社交媒体平台安全地检索您的数据。
- en: This process involves negotiating two different applications that share user
    information, without the need to enter their credentials for each new application,
    increasing security and convenience.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程涉及协商两个共享用户信息的应用程序，无需为每个新应用程序输入凭证，从而提高安全性和便利性。
- en: On the other hand, OIDC builds on OAuth 2.0, adding an authentication layer.
    It leverages the OAuth authorization framework to verify a user’s identity through
    trusted providers such as Google or Facebook.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，OIDC建立在OAuth 2.0之上，增加了一个认证层。它利用OAuth授权框架通过像Google或Facebook这样的受信任提供者验证用户的身份。
- en: 'Let’s see how OIDC complements OAuth 2.0:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看OIDC如何补充OAuth 2.0：
- en: Some applications provide the ability to log in using other social media platforms.
    In this case, during the OAuth 2.0 flow, instead of logging into the new application,
    you’re redirected to your social media login page (the OpenID provider).
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些应用程序提供了使用其他社交媒体平台登录的能力。在这种情况下，在OAuth 2.0流程中，你不会登录到新的应用程序，而是被重定向到你的社交媒体登录页面（即OpenID提供者）。
- en: The user authenticates with their social media credentials, proving their identity
    to the OpenID provider.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户使用他们的社交媒体凭证进行身份验证，向OpenID提供者证明他们的身份。
- en: With the user’s consent, the OpenID provider shares their basic profile information
    (such as name and email) with the new application via an ID token.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用户同意的情况下，OpenID提供者通过ID令牌将用户的基本个人资料信息（如姓名和电子邮件）与新的应用程序共享。
- en: OIDC enables features such as **single sign-on** ( **SSO** ), allowing you to
    access multiple applications using the same login credentials (think of logging
    into multiple websites with your Google account).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: OIDC启用诸如**单点登录**（**SSO**）等功能，允许您使用相同的登录凭证访问多个应用程序（例如，使用您的Google账户登录多个网站）。
- en: 'Although OAuth 2.0 and OIDC flows are similar and interconnected, they serve
    different purposes:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管OAuth 2.0和OIDC流程相似且相互关联，但它们服务于不同的目的：
- en: '**Focus** : OAuth 2.0 acts on authorization (granting access to data), while
    OIDC acts on the authentication layer (verifying user identity).'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重点**：OAuth 2.0作用于授权（授予数据访问权限），而OIDC作用于认证层（验证用户身份）。'
- en: '**Sharing information** : OAuth 2.0 mainly deals with access tokens, while
    OIDC introduces ID tokens containing user profile information.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息共享**：OAuth 2.0主要处理访问令牌，而OIDC引入了包含用户个人信息的ID令牌。'
- en: We can think of OAuth 2.0 as a key that opens the door to a house, while OIDC
    provides identity verification so that this key can be received.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将OAuth 2.0视为一把打开房屋大门的钥匙，而OIDC则提供身份验证，以便这把钥匙可以被接收。
- en: 'This flow is quite common in several applications we use, as shown in *Figure
    6* *.4* :'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种流程在我们使用的许多应用程序中都很常见，如图 *图 6.4* 所示：
- en: '![Figure 6.4 – Basic OAuth 2.0 flow](img/B21788_06_4.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 基本的 OAuth 2.0 流程](img/B21788_06_4.jpg)'
- en: Figure 6.4 – Basic OAuth 2.0 flow
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 基本的 OAuth 2.0 流程
- en: The authorization and authentication flows are constantly used by applications,
    allowing both to identify who the users are and define the type of permissions
    that these users can execute in a web system or API.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 授权和认证流程被应用程序不断使用，允许两者识别用户身份并定义这些用户可以在Web系统或API中执行的类型权限。
- en: Despite this straightforward explanation of the OAuth 2.0 and OIDC protocols,
    as well as concepts of authorization and authentication, the task of implementing
    this approach isn’t simple and depends on some important mechanisms to ensure
    these functionalities are running correctly.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管对OAuth 2.0和OIDC协议以及授权和认证的概念有直接的解释，但实施这种方法并不简单，并且依赖于一些重要的机制来确保这些功能正常运行。
- en: Due to this, ASP.NET Core 9 has abstractions that support the development of
    identity management while following the standards outlined so far. The abstraction
    that implements these resources is known as ASP.NET Core Identity. It has been
    evolving with each new version of the framework and allows teams to use security
    best practices in their authorization and authentication flows, as well as integrate
    with other identity providers while allowing customizations to be made. We’ll
    learn more about this approach in the next section.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，ASP.NET Core 9 提供了支持遵循之前概述的标准开发身份管理的抽象。实现这些资源的抽象称为 ASP.NET Core Identity。它随着框架的每个新版本而不断发展，允许团队在授权和认证流程中使用安全最佳实践，同时允许对其他身份提供者进行集成，并允许进行自定义。我们将在下一节中了解更多关于这种方法的信息。
- en: Working with the ASP.NET Core Identity framework
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ASP.NET Core Identity 框架
- en: Modern applications interact with different types of technologies, protocols,
    and standards. As we’ve been learning, security is extremely important at any
    level of a solution’s implementation flow. A book could easily be dedicated to
    the subject of authorization and authentication.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用程序与不同类型的技术、协议和标准进行交互。正如我们一直在学习的，在任何解决方案实现流程的任何级别，安全性都极为重要。关于授权和认证的主题，一本书很容易被专门讨论。
- en: However, the ASP.NET Core 9 platform has been evolving every year and as a result,
    the identity management model has undergone several improvements, in addition
    to some dependencies being eliminated.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，ASP.NET Core 9 平台每年都在不断发展，因此，身份管理模型已经经历了多次改进，同时消除了某些依赖项。
- en: To be able to implement authorization and authentication in our applications,
    we have ASP.NET Core Identity. It’s a membership system that adds capabilities
    to web-based applications developed in ASP.NET Core 9 and operates in both authentication
    and authorization flows.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在我们的应用程序中实现授权和认证，我们拥有 ASP.NET Core Identity。它是一个会员系统，为在 ASP.NET Core 9 中开发的基于
    Web 的应用程序添加功能，并在认证和授权流程中运行。
- en: The set of features available in ASP.NET Core Identity includes APIs, a UI,
    databases between user identity management and credentials, and the ability to
    grant and revoke permissions. This is in addition to features such as integration
    with external logins, **two-factor authentication** ( **2FA** ), password management,
    being able to block and activate accounts, and providing authentication in applications.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core Identity 可用的功能包括 API、UI、用户身份管理和凭证之间的数据库，以及授予和撤销权限的能力。这还包括与外部登录集成、**双因素认证**（**2FA**）、密码管理、能够阻止和激活账户以及在应用程序中提供认证等功能。
- en: Before we learn how to integrate an application with ASP.NET Core identity,
    let’s learn more about its structure.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习如何将应用程序与 ASP.NET Core 身份集成之前，让我们更多地了解其结构。
- en: Understanding the ASP.NET Core Identity architecture
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 ASP.NET Core Identity 架构
- en: 'ASP.NET Core Identity has an architectural structure that’s divided into the
    following layers:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core Identity 的架构结构分为以下几层：
- en: '**Identity manager** : These are service classes that are responsible for implementing
    the business logic that involves identities. We can find classes such as **UserManager**
    for user management and **RoleManager** for role management.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份管理器**：这些是负责实现涉及身份的业务逻辑的服务类。我们可以找到用于用户管理的 **UserManager** 类和用于角色管理的 **RoleManager**
    类。'
- en: '**Identity store** : The identity store is the domain entity that represents
    each piece of data in a database. We can see the identity store as a table in
    the database that’s mapped to a class such as **UserStore** or **RoleStore** ,
    among others.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份存储**：身份存储是表示数据库中每条数据的领域实体。我们可以将身份存储视为数据库中的一个表，该表映射到诸如 **UserStore** 或 **RoleStore**
    等类。'
- en: '**Data access layer** : These are classes that have the necessary logic to
    interact with the database so that they can persist and retrieve identity-related
    information.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据访问层**：这些是具有与数据库交互所需逻辑的类，以便它们可以持久化和检索与身份相关的信息。'
- en: '**Data source** : The data source is the data mechanism that will be used for
    persistence. By default, ASP.NET Core Identity uses **SQL Server** . However,
    there are other databases available, and there’s the possibility of customizing
    other data sources.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据源**：数据源是用于持久化的数据机制。默认情况下，ASP.NET Core Identity 使用 **SQL Server**。然而，还有其他数据库可供选择，并且可以自定义其他数据源。'
- en: These four layers have well-defined responsibilities and are fully extensible,
    bringing flexibility to development and allowing the identity mechanism to be
    customized according to the context required in an organization.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这四层具有明确的职责，并且完全可扩展，为开发带来了灵活性，并允许根据组织所需的上下文定制身份机制。
- en: 'ASP.NET Core Identity manages both authentication and authorization and works
    with the following types of data:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core Identity 管理身份验证和授权，并与以下类型的数据一起工作：
- en: '**Users** : These represent users in the application. This entity has some
    basic attributes implemented, but they can easily be extended.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户**：这些代表应用程序中的用户。这个实体实现了一些基本属性，但它们可以很容易地进行扩展。'
- en: '**User claims** : These are a set of statements (claims) about a user. Claims
    add information to the user’s identity.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户声明**：这是一组关于用户的声明（声明）。声明向用户的身份添加信息。'
- en: '**User logins** : These provide information about authentication with external
    providers such as Facebook, Google, Microsoft, and others, if your application
    has any integration with these providers.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户登录**：这些提供了有关与外部提供者（如 Facebook、Google、Microsoft 等）进行身份验证的信息，如果你的应用程序与这些提供者有任何集成。'
- en: '**Roles** : These are authorization groups.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角色**：这些是授权组。'
- en: Based on the information that’s managed by the ASP.NET Core Identity platform,
    we have what we need to implement authorization and authentication flows in our
    applications. However, this is a robust and highly customizable framework that
    allows various customizations to be implemented across identity types.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 基于由 ASP.NET Core Identity 平台管理的信息，我们拥有了在应用程序中实现授权和身份验证流程所需的一切。然而，这是一个强大且高度可定制的框架，允许在身份类型上实施各种自定义。
- en: Customizing Identity
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义 Identity
- en: 'If you want to customize Identity, please consult the official documentation:
    [https://learn.microsoft.com/en-us/aspnet/core/security/authentication/customize-identity-model?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/customize-identity-model?view=aspnetcore-9.0)
    .'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要自定义 Identity，请查阅官方文档：[https://learn.microsoft.com/en-us/aspnet/core/security/authentication/customize-identity-model?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/customize-identity-model?view=aspnetcore-9.0)。
- en: Now that we know more about the architectural structure of ASP.NET Core Identity,
    it’s time to add it to an application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了 ASP.NET Core Identity 的架构结构，是时候将其添加到应用程序中了。
- en: Getting started with integrating ASP.NET Core Identity
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始集成 ASP.NET Core Identity
- en: Now that we have greater knowledge about some of the security perspectives that
    are part of the context of an application, it’s time to use ASP.NET Core Identity
    to add authorization and authentication flows.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对应用程序上下文中的一些安全视角有了更深入的了解，是时候使用 ASP.NET Core Identity 来添加授权和身份验证流程了。
- en: As a basis, we’ll use the source code available in this book’s GitHub repository,
    as mentioned in the *Technical requirements* section, where you’ll be able to
    download the complete solution. The project we’ll be using is a version of the
    API project that we created in [*Chapter 5*](B21788_05.xhtml#_idTextAnchor078)
    since all assumptions related to database configurations have been created. Therefore,
    we’ll leverage the API structure and database structure created earlier. The objective
    is to implement Identity.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 作为基础，我们将使用本书 GitHub 仓库中提供的源代码，如 *技术要求* 部分所述，在那里你可以下载完整的解决方案。我们将使用的是我们在 [*第五章*](B21788_05.xhtml#_idTextAnchor078)
    中创建的 API 项目的版本，因为所有与数据库配置相关的假设都已创建。因此，我们将利用之前创建的 API 结构和数据库结构。目标是实现身份验证。
- en: Database settings
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库设置
- en: When starting a new project, you’ll need to configure **EntityFrameworkCore**
    and connect the application to a database, as we learned in [*Chapter 5*](B21788_05.xhtml#_idTextAnchor078)
    . This way, you’ll be able to follow along and configure ASP.NET Core Identity
    with ease.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动一个新项目时，你需要配置 **EntityFrameworkCore** 并将应用程序连接到数据库，正如我们在 [*第五章*](B21788_05.xhtml#_idTextAnchor078)
    中所学的那样。这样，你就能轻松地跟随并配置 ASP.NET Core Identity。
- en: 'For this application, which is a web API that connects to a SQL Server database,
    we’ll use the same model we learned about in [*Chapter 5*](B21788_05.xhtml#_idTextAnchor078)
    and use **EntityFrameworkCore** . To do so, we’ll need to add one more library:
    **Microsoft.AspNetCore.Identity.EntityFrameworkCore** . This library allows Identity
    to work with Entity Framework Core.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用程序，它是一个连接到SQL Server数据库的Web API，我们将使用我们在[*第五章*](B21788_05.xhtml#_idTextAnchor078)中学到的相同模型，并使用**EntityFrameworkCore**。为此，我们需要添加一个额外的库：**Microsoft.AspNetCore.Identity.EntityFrameworkCore**。这个库允许Identity与Entity
    Framework Core一起工作。
- en: 'Ensure this library has been added to your project by opening the **WorkingWithIdentity.csproj**
    file or running the following command in your terminal, inside the application
    directory, to install it:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过打开**WorkingWithIdentity.csproj**文件或在应用程序目录的终端中运行以下命令来确保此库已添加到您的项目中，以安装它：
- en: '[PRE2]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Creating the WorkingWithIdentity.csproj project
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 创建WorkingWithIdentity.csproj项目
- en: 'The **WorkingWithIdentity.csproj** project is a web API that will be protected
    with ASP.NET Core Identity and is available in this book’s GitHub repository,
    as described in the *Technical requirements* section. However, if you want to
    create the project for yourself, follow these steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**WorkingWithIdentity.csproj**项目是一个受ASP.NET Core Identity保护的Web API，它包含在本章的GitHub存储库中，如*技术要求*部分所述。但是，如果您想为自己创建项目，请按照以下步骤操作：'
- en: 1. Open your operating system’s terminal and access the folder where the project
    should be created.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 打开您的操作系统终端，访问应创建项目的文件夹。
- en: '2. Run the following command to create the project:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 运行以下命令以创建项目：
- en: '**dotnet new webapi -** **n WorkingWithIdentity**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**dotnet new webapi -n WorkingWithIdentity**'
- en: '3. Access the new project folder:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 访问新项目文件夹：
- en: '**cd WorkingWithIdentity**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**cd WorkingWithIdentity**'
- en: '4. Add the following NuGet packages, all of which are necessary for using the
    SQL Server database:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 添加以下NuGet包，所有这些包都是使用SQL Server数据库所必需的：
- en: '**dotnet add** **package Microsoft.EntityFrameworkCore**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**dotnet add package Microsoft.EntityFrameworkCore**'
- en: '**dotnet add** **package Microsoft.EntityFrameworkCore.SqlServer**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**dotnet add package Microsoft.EntityFrameworkCore.SqlServer**'
- en: '**dotnet add** **package Microsoft.EntityFrameworkCore.Design**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**dotnet add package Microsoft.EntityFrameworkCore.Design**'
- en: '5. Make sure you have the **dotnet-ef** tool installed. To do so, run the following
    command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 确保您已安装**dotnet-ef**工具。要这样做，请运行以下命令：
- en: '**dotnet tool install** **--** **global** **dotnet-ef**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**dotnet tool install --global dotnet-ef**'
- en: By default, the project already contains the **Microsoft.AspNetCore.Identity**
    library since we added it when we created the project. However, we still need
    to follow a few more steps to configure the project. Let’s start by configuring
    the database context so that the stores and Identity models can be mapped by **EntityFramework**
    .
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，项目已经包含了**Microsoft.AspNetCore.Identity**库，因为我们创建项目时已经添加了它。然而，我们仍然需要遵循几个额外的步骤来配置项目。让我们首先配置数据库上下文，以便存储和Identity模型可以通过**EntityFramework**进行映射。
- en: Configuring the database context
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置数据库上下文
- en: For ASP.NET Core Identity to be able to manage **users** , **roles** , **claims**
    , and **tokens** , we must configure the application by adding this capability
    to the **DbContext** class, which is responsible for interacting with the SQL
    Server database.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让ASP.NET Core Identity能够管理**用户**、**角色**、**声明**和**令牌**，我们必须通过将此功能添加到**DbContext**类（负责与SQL
    Server数据库交互的类）来配置应用程序。
- en: To do this, we must change the **BankingDbContext** class, available in the
    **Context** directory of the reference project in this chapter’s repository.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们必须更改位于本章存储库中参考项目**Context**目录下的**BankingDbContext**类。
- en: 'The first step is to change the inheritance class to **IdentityDbContext<IdentityUser>**
    , which is located in the **Microsoft.AspNetCore.Identity.EntityFrameworkCore**
    namespace. Once we’ve done this, we’ll have the following updated class:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将继承类更改为**IdentityDbContext<IdentityUser>**，它位于**Microsoft.AspNetCore.Identity.EntityFrameworkCore**命名空间中。一旦我们完成这个操作，我们将得到以下更新的类：
- en: '[PRE3]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we learned in [*Chapter 5*](B21788_05.xhtml#_idTextAnchor078) , the **DbContext**
    class is an abstraction of **Entity Framework Core** that allows the application
    to interact with the database, where each entity in the database is represented
    by properties of the **DbSet** type. This allows classes to be mapped to entities
    and vice versa.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第五章*](B21788_05.xhtml#_idTextAnchor078)中学到的，**DbContext**类是**Entity Framework
    Core**的一个抽象，它允许应用程序与数据库交互，其中数据库中的每个实体都由**DbSet**类型的属性表示。这允许类映射到实体，反之亦然。
- en: By changing the inheritance of the **BankingDbContext** class to **IdentityDb**
    **Context<IdentityUser>** , we’re reusing the default **DbContext** implementation
    from ASP.NET Identity Core. This contains the **DbSet** type for mapping the Identity
    tables that will be part of the database.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 **BankingDbContext** 类的继承改为 **IdentityDb** **Context<IdentityUser>**，我们正在重用
    ASP.NET Identity Core 的默认 **DbContext** 实现。这包含用于映射将成为数据库一部分的 Identity 表的 **DbSet**
    类型。
- en: 'To ensure that all the database settings are available in the application,
    open the **Program.cs** file and make sure that the following line of code exists
    in the file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保所有数据库设置在应用程序中可用，打开 **Program.cs** 文件，并确保文件中存在以下代码行：
- en: '[PRE4]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It’s very important to configure the **DbContext** class in the ASP.NET Core
    dependency injection container. In this case, we added the **BankingDbContext**
    class to the dependency injection context while also configuring the use of SQL
    Server, whose connection will be based on the **ConnectionString** value, which
    is passed as a parameter to the **UseSqlServer** method. This **ConnectionString**
    is obtained through the application settings, which in this case can be found
    in the **appsettings.json** file.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 依赖注入容器中配置 **DbContext** 类非常重要。在这种情况下，我们将 **BankingDbContext**
    类添加到依赖注入上下文，同时配置了使用 SQL Server，其连接将基于 **ConnectionString** 值，该值作为参数传递给 **UseSqlServer**
    方法。这个 **ConnectionString** 通过应用程序设置获得，在这种情况下，可以在 **appsettings.json** 文件中找到。
- en: At this point, we have all the necessary configurations so that ASP.NET Core
    Identity is configured in the data layer. In the next section, we’ll update the
    database so that we can add the necessary tables for identity management.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有了所有必要的配置，以便在数据层中配置 ASP.NET Core Identity。在下一节中，我们将更新数据库，以便我们可以添加用于身份管理的必要表。
- en: Updating the database
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新数据库
- en: 'In [*Chapter 5*](B21788_05.xhtml#_idTextAnchor078) , we created an API that
    simulates digital bank operations and connected it to a database using Entity
    Framework Core. For this example, we’ll use the same database – that is, **dbBanking**
    . Currently, it has the following data structure:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 5 章*](B21788_05.xhtml#_idTextAnchor078) 中，我们创建了一个模拟数字银行操作的 API，并使用 Entity
    Framework Core 连接到数据库。对于这个例子，我们将使用相同的数据库——即 **dbBanking**。目前，它具有以下数据结构：
- en: '![Figure 6.5 – The structure of the dbBanking database](img/B21788_06_5.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – dbBanking 数据库的结构](img/B21788_06_5.jpg)'
- en: Figure 6.5 – The structure of the dbBanking database
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – dbBanking 数据库的结构
- en: The **dbBanking** database consists of four tables, three of which are part
    of the application context – that is, **dbo.Accounts** , **dbo.Customers** , and
    **dbo.Movements** . The fourth table, **dbo.EFMigrationsHistory** , is responsible
    for managing the status of changes that are made to the database using migrations.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**dbBanking** 数据库由四个表组成，其中三个是应用程序上下文的一部分——即 **dbo.Accounts**、**dbo.Customers**
    和 **dbo.Movements**。第四个表，**dbo.EFMigrationsHistory**，负责管理使用迁移对数据库所做的更改的状态。'
- en: Database migrations
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库迁移
- en: In [*Chapter 5*](B21788_05.xhtml#_idTextAnchor078) , we explored how migrations
    work, their importance during application development, and changes that can be
    made dynamically to the database. If you want to learn more about how ASP.NET
    Core 9 migrations works, please refer to [https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations/?tabs=dotnet-core-cli](https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations/?tabs=dotnet-core-cli)
    .
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 5 章*](B21788_05.xhtml#_idTextAnchor078) 中，我们探讨了迁移的工作原理、它们在应用程序开发中的重要性以及可以动态对数据库进行的更改。如果您想了解更多关于
    ASP.NET Core 9 迁移的信息，请参阅 [https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations/?tabs=dotnet-core-cli](https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations/?tabs=dotnet-core-cli)。
- en: 'The **dbo.EFMigrationsHistory** table contains the history of the first entities
    that were created for the bank API. You can check the history that’s been generated
    through the code in the application’s directory structure, in the **Migrations**
    folder, as shown in *Figure 6* *.6* :'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**dbo.EFMigrationsHistory** 表包含为银行 API 创建的第一个实体的历史记录。您可以通过应用程序目录结构中的代码生成的历史记录进行检查，如图
    *图 6* *.6* 所示：'
- en: '![Figure 6.6 – Migrations classes for the API](img/B21788_06_6.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – API 的迁移类](img/B21788_06_6.jpg)'
- en: Figure 6.6 – Migrations classes for the API
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – API 的迁移类
- en: These classes are automatically generated by the Entity Framework Core command-line
    tool and should not be changed manually.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类是由 Entity Framework Core 命令行工具自动生成的，不应手动更改。
- en: After making changes to the **DbContext** class and adding the ASP.NET Core
    Identity models, we must change the database. To do so, we’ll create a new migration.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改了 **DbContext** 类并添加了 ASP.NET Core Identity 模型之后，我们必须更改数据库。为此，我们将创建一个新的迁移。
- en: 'To do this, open a terminal of your choice, access the root directory of the
    **WorkingWithIdentity** application, and execute the following command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此操作，请打开您选择的终端，访问 **WorkingWithIdentity** 应用程序的根目录，并执行以下命令：
- en: '[PRE5]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding command uses Entity Framework Core’s **ef** tool and adds a migration
    named **IdentityModels** .
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令使用了 Entity Framework Core 的 **ef** 工具，并添加了一个名为 **IdentityModels** 的迁移。
- en: 'Again, when opening the project’s **Migrations** folder, we can analyze which
    new classes were created, as shown in *Figure 6* *.7* :'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，当打开项目的 **Migrations** 文件夹时，我们可以分析创建了哪些新类，如图 *图 6* *.7* 所示：
- en: '![Figure 6.7 – Migration classes for the Identity model](img/B21788_06_7.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7 – Identity 模型的迁移类](img/B21788_06_7.jpg)'
- en: Figure 6.7 – Migration classes for the Identity model
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – Identity 模型的迁移类
- en: 'Now that we have the migration structure for the database, we must update **dbBanking**
    so that it includes the Identity tables. To do this, in your preferred terminal,
    run the following command in the project directory:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了数据库的迁移结构，我们必须更新 **dbBanking** 以包括 Identity 表。为此，在您的首选终端中，在项目目录中运行以下命令：
- en: '[PRE6]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding command reads the migrations available in the project, analyzes
    the migration history in the **dbo.EFMigrationsHistory** table in the database,
    and applies the updates, which in this case involve creating the tables necessary
    for ASP.NET Core Identity to work correctly. We’ll see the new tables that have
    been created:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令读取项目中的迁移，分析数据库中 **dbo.EFMigrationsHistory** 表中的迁移历史，并应用更新，在这种情况下涉及创建 ASP.NET
    Core Identity 正确工作所需的表。我们将看到创建的新表：
- en: '![Figure 6.8 – The database now contains ASP.NET Core Identity tables](img/B21788_06_8.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8 – 数据库现在包含 ASP.NET Core Identity 表](img/B21788_06_8.jpg)'
- en: Figure 6.8 – The database now contains ASP.NET Core Identity tables
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 – 数据库现在包含 ASP.NET Core Identity 表
- en: With that, all basic ASP.NET Core Identity settings related to the data model
    have been added successfully. However, we still need to add some other configurations
    to the project so that the application is capable of handling authorization and
    authentication. So, in the next section, we’ll add ASP.NET Core Identity services
    to the application’s dependency injection context.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，所有与数据模型相关的 ASP.NET Core Identity 基本设置都已成功添加。然而，我们还需要向项目中添加一些其他配置，以便应用程序能够处理授权和身份验证。因此，在下一节中，我们将向应用程序的依赖注入上下文中添加
    ASP.NET Core Identity 服务。
- en: Adding ASP.NET Core Identity services and routes
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 ASP.NET Core Identity 服务和路由
- en: Asp.Net Core Identity contains the necessary abstractions to deal with authorization
    and authentication mechanisms using the services available in the dependency injection
    container, in addition to wheels for authentication and token generation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Asp.Net Core Identity 包含处理授权和身份验证机制所需的抽象，这些抽象使用依赖注入容器中可用的服务，以及用于身份验证和令牌生成的工具。
- en: 'However, it’s necessary to activate these abstractions explicitly. To do so,
    we must add a few lines of code to the application. Open the **Program.cs** file
    so that we can edit them. At this point, we must follow these steps:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有必要显式激活这些抽象。为此，我们必须向应用程序中添加几行代码。打开 **Program.cs** 文件以便我们可以编辑它们。在此阶段，我们必须遵循以下步骤：
- en: Adding the required Identity namespace – that is, **using Microsoft.AspNetCore.identity;**
    .
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加所需的 Identity 命名空间 – 即，**using Microsoft.AspNetCore.identity;**。
- en: 'Add the authentication services that are responsible for determining the identity
    of users to the dependency injection container, as well as the authentication
    method. In this case, we’ll be using a bearer token: **builder.Services.AddAuthentication().AddBearerToken();**
    .'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将负责确定用户身份的认证服务以及认证方法添加到依赖注入容器中。在这种情况下，我们将使用一个 bearer 令牌：**builder.Services.AddAuthentication().AddBearerToken();**。
- en: Add the authorization services to the dependency injection container by running
    **builder.Services.AddAuthorization();** .
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 **builder.Services.AddAuthorization();** 向依赖注入容器添加授权服务。
- en: Add the Identity APIs and configure data access through Entity Framework Core
    by running **builder.Services.AddIdentityApiEndpoints<IdentityUser>().AddEntityFrameworkStores<BankingDbContext>();**
    .
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 **builder.Services.AddIdentityApiEndpoints<IdentityUser>().AddEntityFrameworkStores<BankingDbContext>();**
    来添加 Identity API 并通过 Entity Framework Core 配置数据访问。
- en: Map the Identity endpoints using **app.MapIdentityApi<IdentityUser>();** .
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **app.MapIdentityApi<IdentityUser>();** 映射 Identity 端点。
- en: 'Add each request authentication middleware to the application’s request processing
    pipeline, using the settings defined by **AddAuthentication()** to validate and
    define the user’s identity: **app.UseAuthentication();** .'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个请求身份验证中间件添加到应用程序的请求处理管道中，使用由 **AddAuthentication()** 定义的设置来验证和定义用户的身份：**app.UseAuthentication();**
    。
- en: 'Add middleware that checks authorization policies against the identity of the
    authenticated user to determine whether the user is allowed to proceed with the
    current request: **app.UseAuthorization();** .'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加中间件以检查授权策略与已认证用户的身份，以确定用户是否被允许继续当前请求：**app.UseAuthorization();** 。
- en: 'By making these changes, we’ll have the following complete code in the **Program.cs**
    file:'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这些更改，我们将在 **Program.cs** 文件中获得以下完整代码：
- en: '[PRE7]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Register account and customer routes
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注册账户和客户路由
- en: The routes that are responsible for processing requests for the Account and
    Customers APIs were registered through the **app.RegisterAccountRoutes** and **app.RegisterCustomerRoutes**
    extension methods, as highlighted in the preceding code.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 负责处理 Account 和 Customers API 请求的路由是通过 **app.RegisterAccountRoutes** 和 **app.RegisterCustomerRoutes**
    扩展方法注册的，如前述代码中突出显示的那样。
- en: This is a good practice for correctly separating responsibilities, as well as
    improving the maintainability of the **Program.cs** file code.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种良好的实践，可以正确地分离职责，同时提高 **Program.cs** 文件代码的可维护性。
- en: 'To create these extension methods, two classes were created, as shown here:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这些扩展方法，创建了两个类，如下所示：
- en: '**public static** **class AccountRoutes**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**public static** **class AccountRoutes**'
- en: '**{**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**public static** **void RegisterAccountRoutes(this**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**public static** **void RegisterAccountRoutes(this**'
- en: '**IEndpointRouteBuilder routes)**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**IEndpointRouteBuilder routes)**'
- en: '**{**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**var group =** **routes.MapGroup("/accounts");**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**var group =** **routes.MapGroup("/accounts");**'
- en: '**//** **GET: /accounts**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**//** **GET: /accounts**'
- en: '**group.MapGet("/", async (BankingDbContext** **dbContext) =>**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**group.MapGet("/", async (BankingDbContext** **dbContext) =>**'
- en: '**{**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**return await** **dbContext.Accounts.Include(a =>**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**return await** **dbContext.Accounts.Include(a =>**'
- en: '**a.Customer)**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**a.Customer)**'
- en: '**.Include(a =>** **a.Movements)**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**.Include(a =>** **a.Movements)**'
- en: '**.** **ToListAsync();**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**.** **ToListAsync();**'
- en: '**});**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**});**'
- en: '**//** **other methods**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**//** **其他方法**'
- en: '**}**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: '**}**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: '**public static** **class CustomerRoutes**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**public static** **class CustomerRoutes**'
- en: '**{**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**public static** **void RegisterCustomerRoutes(this**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**public static** **void RegisterCustomerRoutes(this**'
- en: '**IEndpointRouteBuilder routes)**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**IEndpointRouteBuilder routes)**'
- en: '**{**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**var group =** **routes.MapGroup("/customers");**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**var group =** **routes.MapGroup("/customers");**'
- en: '**//** **GET: /customers**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**//** **GET: /customers**'
- en: '**group.MapGet("/", async (BankingDbContext** **dbContext) =>**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**group.MapGet("/", async (BankingDbContext** **dbContext) =>**'
- en: '**{**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**return** **await dbContext.Customers.ToListAsync();**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**return** **await dbContext.Customers.ToListAsync();**'
- en: '**});**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**});**'
- en: '**//** **other methods**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**//** **其他方法**'
- en: '**}**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: '**}**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: The extension classes that were created here have a static method that’s responsible
    for registering the routes of the respective entities. This is a practice that
    makes code more organized and easier to read and maintain. To learn more about
    creating extension methods, go to [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/how-to-implement-and-call-a-custom-extension-method](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/how-to-implement-and-call-a-custom-extension-method)
    .
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里创建的扩展类具有一个静态方法，负责注册相应实体的路由。这是一种使代码更加组织化、易于阅读和维护的实践。要了解更多关于创建扩展方法的信息，请访问
    [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/how-to-implement-and-call-a-custom-extension-method](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/how-to-implement-and-call-a-custom-extension-method)
    。 '
- en: When analyzing the preceding code, it’s very important to consider the order
    of the highlighted lines of code; otherwise, the objects and route mappings won’t
    work correctly.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析前述代码时，考虑突出显示的代码行顺序非常重要；否则，对象和路由映射将无法正确工作。
- en: So far, the solution code presents a configuration model that already allows
    us to benefit from the authorization and authentication features of ASP.NET Core
    Identity. However, there are some cases where there’s a need to customize access
    types based on user roles. Fortunately, ASP.NET Core 9 offers a powerful feature
    that allows us to segregate the type of access to application resources, as we
    will see in the next section.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，解决方案代码展示了一个配置模型，它已经允许我们利用ASP.NET Core Identity的授权和身份验证功能。然而，在某些情况下，需要根据用户角色自定义访问类型。幸运的是，ASP.NET
    Core 9提供了一个强大的功能，允许我们将对应用程序资源的访问类型进行隔离，正如我们将在下一节中看到的。
- en: Role-based authorization
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于角色的授权
- en: 'To have greater control over the user authorization flow in the application,
    we can implement **role-based authorization** . This role-based control allows
    you to segregate the type of access to parts of your application based on the
    roles that have been assigned to users. Imagine a scenario where there are two
    roles: **Administrator** and **Reader** . By using the role-based authorization
    approach, you can ensure that only users authorized to certain areas of the application
    can access specific resources or perform specific actions in an application.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地控制应用程序中的用户授权流程，我们可以实现**基于角色的授权**。这种基于角色的控制允许您根据分配给用户的角色隔离对应用程序部分类型的访问。想象一个场景，有两个角色：**管理员**和**读者**。通过使用基于角色的授权方法，您可以确保只有有权访问应用程序特定区域的用户才能访问特定资源或执行应用程序中的特定操作。
- en: In ASP.NET Core 9, the role-based authorization approach can be implemented
    by defining policies, which extend role-based authorization with more complex
    logic, offering fine-grained control over user permissions.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET Core 9中，可以通过定义策略来实现基于角色的授权方法，这些策略通过更复杂的逻辑扩展了基于角色的授权，提供了对用户权限的精细控制。
- en: Once a policy has been defined, it can be applied to controllers, actions, or
    even Razor Pages to enforce the desired authorization behavior. Policies make
    your authorization logic more modular and reusable. This is especially useful
    in larger applications, where access control can become complex.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了策略，它就可以应用于控制器、操作，甚至Razor页面，以强制执行所需的授权行为。策略使您的授权逻辑更加模块化和可重用。这在大型应用程序中特别有用，因为访问控制可能会变得复杂。
- en: For example, consider a scenario where you want to create a policy that only
    allows users with the **Admin** role to access certain administrative resources.
    Also, you might want to create another policy that only allows users with the
    **Manager** role to be employed for over 1 year so that they can access specific
    reports. These policies can be defined in the **Program.cs** file and then applied
    to controllers or actions using the **[** **Authorize]** attribute.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个场景，您想创建一个策略，只允许具有**管理员**角色的用户访问某些管理资源。此外，您可能还想创建另一个策略，只允许具有**经理**角色的用户工作超过1年，以便他们可以访问特定的报告。这些策略可以在**Program.cs**文件中定义，然后使用**[**
    **Authorize]**属性应用于控制器或操作。
- en: 'Let’s look at a simple example of a policy that could be added to a **Program.cs**
    file:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个可以添加到**Program.cs**文件的策略的简单示例：
- en: '[PRE8]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we configured a policy called **AdminOnly** that sets
    a rule where the user has the **Admin** role. The **[Authorize]** attribute is
    then applied to an endpoint and uses the policy we created earlier, restricting
    access to users who meet the policy criteria.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们配置了一个名为**AdminOnly**的策略，该策略设置了一个规则，即用户具有**管理员**角色。然后，将**[Authorize]**属性应用于端点，并使用我们之前创建的策略，限制了符合策略标准的用户访问。
- en: 'Now, let’s look at a more complex example. Here, a custom policy has been defined
    that checks the user’s role and provides an additional claim that requires the
    user’s employment duration to be 1 year:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个更复杂的例子。在这里，已经定义了一个自定义策略，该策略检查用户的角色，并提供一个需要用户工作期限为1年的额外声明：
- en: '[PRE9]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, the **EmployeeWithExperience** policy requires that the user
    has the **Manager** role and owns a claim named **EmploymentDuration** with a
    value of **1Year** . This policy applies to the **/reports** endpoint, restricting
    access to managers only.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，**EmployeeWithExperience**策略要求用户具有**经理**角色，并拥有一个名为**EmploymentDuration**的声明，其值为**1Year**。此策略应用于**/reports**端点，仅允许经理访问。
- en: Role-based authorization and policies give you a powerful way to manage access
    to your application’s resources, allowing you to build complex authorization logic
    that goes beyond simple role checks and incorporate additional conditions and
    claims as needed.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 基于角色的授权和策略为您提供了一种强大的方式来管理对应用程序资源的访问，允许您构建超出简单角色检查的复杂授权逻辑，并根据需要包含额外的条件和声明。
- en: Now that we know more about ASP.NET Core Identity, have integrated it into our
    application, and know how to segregate access to application resources by implementing
    authorization policies, it’s time to add restrictions to the application’s routes.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对ASP.NET Core Identity有了更多的了解，已经将其集成到我们的应用程序中，并且知道如何通过实现授权策略来隔离对应用程序资源的访问，现在是时候向应用程序的路由添加限制。
- en: Securing APIs with ASP.NET Core Identity
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ASP.NET Core Identity保护API
- en: 'At this point, the application has been fully integrated with ASP.NET Core
    Identity. Now, we’ll run it so that we can analyze the results. Open a terminal
    of your choice and access the application directory. Then, run the following command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，应用程序已经完全集成了ASP.NET Core Identity。现在，我们将运行它，以便我们可以分析结果。打开您选择的终端并访问应用程序目录。然后，运行以下命令：
- en: '[PRE10]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'An address in **http://localhost:<port>** format will be provided. The port
    number may be different from the one shown in this example, but the execution
    will be the same. Access the **http://localhost:<port>/swagger/index.html** address;
    you should see the following output:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 将提供一个**http://localhost:<端口号>**格式的地址。端口号可能与示例中显示的不同，但执行结果将相同。访问**http://localhost:<端口号>/swagger/index.html**地址；您应该看到以下输出：
- en: '![Figure 6.9 – Banking API integrated with ASP.NET Core Identity](img/B21788_06_9.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9 – 集成ASP.NET Core Identity的银行API](img/B21788_06_9.jpg)'
- en: Figure 6.9 – Banking API integrated with ASP.NET Core Identity
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 – 集成ASP.NET Core Identity的银行API
- en: As we can see, new routes were added to the API. These routes are the APIs that
    are provided by ASP.NET Core Identity. Each API allows us to manage the application’s
    users and add different capabilities, such as password recovery, user creation,
    or password reset.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，API中添加了新的路由。这些路由是由ASP.NET Core Identity提供的API。每个API都允许我们管理应用程序的用户并添加不同的功能，例如密码恢复、用户创建或密码重置。
- en: 'However, upon attempting to execute an endpoint, such as performing a **GET**
    request on the **/accounts** API, we realized that we were able to obtain a valid
    response. To perform the test, simply open the **GET** method of the **/accounts**
    API, click the **Try Out** button, and then the **Execute** button. We should
    get the following response:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在尝试执行端点时，例如对**/accounts** API执行**GET**请求，我们意识到我们能够获得有效的响应。要进行测试，只需打开**/accounts**
    API的**GET**方法，点击**Try Out**按钮，然后点击**Execute**按钮。我们应该得到以下响应：
- en: '![Figure 6.10 – Requesting an API without authentication and authorization](img/B21788_06_10.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图6.10 – 未经认证和授权请求API](img/B21788_06_10.jpg)'
- en: Figure 6.10 – Requesting an API without authentication and authorization
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 – 未经认证和授权请求API
- en: As we can see, we have an HTTP status code of **200** , which means that the
    request was successful, even if the result didn’t return any existing account
    records in the database. If you have any records registered in this table in your
    local database, the result will be an array of account objects serialized in JSON
    format.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们有一个HTTP状态码为**200**，这意味着请求是成功的，即使结果没有返回数据库中的任何现有账户记录。如果您在本地的数据库表中注册了任何记录，结果将是一个以JSON格式序列化的账户对象数组。
- en: However, we want to add authentication and authorization processes to the application’s
    APIs. To do so, we must make some changes to the source code.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们希望在应用程序的API中添加认证和授权过程。为此，我们必须对源代码进行一些修改。
- en: As we know, each API has its routes registered in the **Program.cs** file. These
    routes act as entry points for requests. Since we want to protect each route so
    that only known and authorized users can consume the API, we must add a configuration
    to the routes so that when someone attempts to request the API without being authenticated,
    the request must return an HTTP **401** status code, informing the API consumer
    that there’s a need for authentication.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，每个API都在**Program.cs**文件中注册了其路由。这些路由作为请求的入口点。由于我们希望保护每个路由，以确保只有已知和授权的用户才能使用API，我们必须向路由添加配置，以便当有人尝试未经认证请求API时，请求必须返回HTTP
    **401**状态码，通知API消费者需要进行认证。
- en: In the next section, we’ll learn how to protect routes and prevent unauthorized
    requests.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何保护路由并防止未经授权的请求。
- en: Securing application routes
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护应用程序路由
- en: Even if all authentication and authorization settings are present in the application,
    it’s necessary to determine what should be protected and what shouldn’t.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 即使应用程序中所有认证和授权设置都已存在，也必须确定应该保护什么以及不应该保护什么。
- en: One of the ways we can ensure that a given API method is protected by authentication
    and authorization middleware is by adding an explicit configuration to the routes.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以确保给定的API方法通过认证和授权中间件受保护的一种方法是在路由中添加显式配置。
- en: In the application that we’re working on, the API routes were implemented in
    separate files as **extension methods** , as a good practice. So, let’s make the
    necessary change in the **AccountHandler.cs** file, located in the application’s
    **RouteHandler** directory.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们正在开发的应用程序中，API路由作为**扩展方法**在单独的文件中实现，这是一种良好的实践。因此，让我们在应用程序的**RouteHandler**目录中的**AccountHandler.cs**文件中做出必要的更改。
- en: 'To do this, we’ll configure the **/accounts** route so that it only accepts
    requests if the user is authenticated. Let’s look at the changed code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将配置**/accounts**路由，使其只接受已认证用户的请求。让我们看看修改后的代码：
- en: '[PRE11]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we added the **RequireAuthorization()** method call. We’ve already learned
    that authorization is a process that validates a user’s permissions, while authentication
    involves identifying the user. In this case, if the user isn’t authenticated,
    they can’t be authorized.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了**RequireAuthorization()**方法调用。我们已经了解到，授权是一个验证用户权限的过程，而认证涉及识别用户。在这种情况下，如果用户未认证，则无法授权。
- en: 'Again, in a terminal of your choice, inside the application directory, execute
    the following command:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在您选择的终端中，在应用程序目录内，执行以下命令：
- en: '[PRE12]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we’ll request the **/accounts** route. However, let’s execute the **Postman**
    application first. Follow the steps:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将请求**/accounts**路由。然而，让我们首先执行**Postman**应用程序。按照以下步骤操作：
- en: Go to **File** | **New** | **HTTP** .
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**文件** | **新建** | **HTTP** 。
- en: A new tab will open where you can make a request.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将打开一个新标签页，您可以在其中发起请求。
- en: Add the URL of the running application – that is, **http://localhost:<port>/accounts**
    – and check whether the selected method is **GET** .
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加运行应用程序的URL – 即**http://localhost:<端口>/accounts** – 并检查是否选择了**GET**方法。
- en: 'Then, click on the **Send** button. We’ll get the following output:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击**发送**按钮。我们将得到以下输出：
- en: '![Figure 6.11 – Requesting the protected route](img/B21788_06_11.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图6.11 – 请求受保护的路由](img/B21788_06_11.jpg)'
- en: Figure 6.11 – Requesting the protected route
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 – 请求受保护的路由
- en: '*Figure 6* *.11* highlights the return of the request with an HTTP status code
    of 401, which means that the request wasn’t authorized.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.11*突出了带有HTTP状态码401的请求返回，这意味着请求未被授权。'
- en: For a successful request for this route to be made, we must log in and configure
    the request with the authenticated user’s information.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使对这条路由的成功请求能够发起，我们必须登录并使用认证用户的详细信息配置请求。
- en: 'Before logging in, we must create a user in the application. To do this, perform
    the following steps:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在登录之前，我们必须在应用程序中创建一个用户。为此，请执行以下步骤：
- en: Create a new HTTP request in Postman.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Postman中创建一个新的HTTP请求。
- en: Set the request type to **POST** .
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将请求类型设置为**POST**。
- en: Add **http://localhost:<port>/register** as the route. This is the default route
    for creating ASP.NET Core Identity users that will be added to the application.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**http://localhost:<端口>/register**作为路由添加。这是将添加到应用程序中的ASP.NET Core Identity用户的默认路由。
- en: 'At this point, we need to define the body of the request. To do this, click
    on the **Body** tab, select the **raw** option, and add the JSON shown in *Figure
    6* *.12* :'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要定义请求的正文。为此，请点击**正文**选项卡，选择**raw**选项，并添加*图6.12*中显示的JSON：
- en: '![Figure 6.12 – Configuring the body of the register user request](img/B21788_06_12.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图6.12 – 配置注册用户请求的正文](img/B21788_06_12.jpg)'
- en: Figure 6.12 – Configuring the body of the register user request
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12 – 配置注册用户请求的正文
- en: You can change the properties of the JSON object to your liking.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以根据需要更改JSON对象的属性。
- en: Finally, click the **Send** button to make the request.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击**发送**按钮来发起请求。
- en: 'Upon being executed, we should get a response similar to the one shown in *Figure
    6* *.13* :'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，我们应该得到类似于*图6.13*所示的响应：
- en: '![Figure 6.13: Registering a new user using ASP.NET Core Identity](img/B21788_06_13.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图6.13：使用ASP.NET Core Identity注册新用户](img/B21788_06_13.jpg)'
- en: 'Figure 6.13: Registering a new user using ASP.NET Core Identity'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13：使用ASP.NET Core Identity注册新用户
- en: '*Figure 6* *.13* displays an HTTP status code of 200, informing us that the
    request was successful and that a new user has been registered in the database.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.13* 显示了一个HTTP状态码200，告知我们请求成功，并且一个新的用户已经在数据库中注册。'
- en: 'At this point, we must log in. We’ll do so using Postman. Create a new HTTP
    request and perform the following steps to configure the request:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们必须登录。我们将使用Postman来完成此操作。创建一个新的HTTP请求并执行以下步骤以配置请求：
- en: Set the request type to **POST** .
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将请求类型设置为**POST**。
- en: Set the URL to **http://localhost:<port>/login** .
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将URL设置为**http://localhost:<port>/login**。
- en: 'Select the **Body** tab, then the **raw** option, and add the following JSON:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Body**选项卡，然后选择**raw**选项，并添加以下JSON：
- en: '[PRE13]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Click the **Send** button.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发送**按钮。
- en: Make sure you’ve added the JSON parameters according to the user data you created
    in your environment.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您已根据在您的环境中创建的用户数据添加了JSON参数。
- en: 'Upon performing the request, you should see the following response:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行请求后，您应该看到以下响应：
- en: '![Figure 6.14 – Getting a login response](img/B21788_06_14.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图6.14 – 获取登录响应](img/B21788_06_14.jpg)'
- en: Figure 6.14 – Getting a login response
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14 – 获取登录响应
- en: 'In response to the login request, we can see that a JSON object with some important
    properties has been returned:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 对于登录请求的响应，我们可以看到返回了一个包含一些重要属性的JSON对象：
- en: '**tokenType** : This value will always be **Bearer** , which indicates that
    this response provides a **Bearer** token in the form of an opaque **accessToken**
    , as we configured in the **Program.cs** file.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tokenType**：此值始终为**Bearer**，这表示此响应提供了一种**Bearer**令牌，形式为不透明的**accessToken**，正如我们在**Program.cs**文件中配置的那样。'
- en: '**accessToken** : This is the token that’s generated for the authenticated
    user. It must be sent as part of the authorization request header.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**accessToken**：这是为认证用户生成的令牌。它必须作为授权请求头的一部分发送。'
- en: '**expiresIn** : A value in seconds that represents the expiration time of **accessToken**
    .'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**expiresIn**：表示**accessToken**过期时间的秒数。'
- en: '**refreshToken** : If set, we can obtain a new **access_token** value upon
    expiration by using a refresh endpoint without having to re-enter user credentials.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**refreshToken**：如果设置，我们可以在过期后通过使用刷新端点来获取新的**access_token**值，而无需重新输入用户凭据。'
- en: The values displayed in *Figure 6* *.14* will be different for each request
    and don’t represent a **JWT** . The **access token** is generated and encrypted
    in a proprietary way in this version of ASP.NET Core Identity and doesn’t follow
    a known convention. However, it’s possible to change to a **JWT** if you wish,
    as well as other configuration parameters of the token generation process.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图6.14*中显示的值对于每个请求都是不同的，并不代表**JWT**。**accessToken**在本版本ASP.NET Core Identity中以专有方式生成和加密，不遵循已知约定。然而，如果您愿意，可以将其更改为**JWT**，以及令牌生成过程的其它配置参数。
- en: ASP.NET Core Identity configurations
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core Identity配置
- en: ASP.NET Core Identity offers different authentication options, including JWT
    ( [https://jwt.io/introduction](https://jwt.io/introduction) ), cookies, and other
    settings. To learn more about the different configuration options, go to [https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.identity.identityoptions?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.identity.identityoptions?view=aspnetcore-9.0)
    .
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core Identity提供了不同的身份验证选项，包括JWT ([https://jwt.io/introduction](https://jwt.io/introduction)
    )、cookies以及其他设置。要了解更多关于不同配置选项的信息，请访问[https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.identity.identityoptions?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.identity.identityoptions?view=aspnetcore-9.0)。
- en: However, the token-based approach we’re using, even though it doesn’t involve
    a JWT, uses the same configuration process as a request being made with the authenticated
    user’s credentials. In the next section, we’ll use the **access token** value
    to make a request on the **/accounts** route and obtain a valid response.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们使用的基于令牌的方法，即使它不涉及JWT，也使用与使用认证用户凭据发出的请求相同的配置过程。在下一节中，我们将使用**access token**值对**/accounts**路由进行请求，并获取有效的响应。
- en: Requesting an API with the access token
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用访问令牌请求API
- en: The access token contains the authenticated user’s information in encrypted
    form.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌包含以加密形式存储的认证用户信息。
- en: 'For us to make a valid request on the **/accounts** route, we’ll need to pass
    the token as a parameter in the request header. So, copy the access token value
    and, in Postman, open the tab that contains the request, as shown in *Figure 6*
    *.11* , for the **/accounts** route. Then, perform the following steps:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在**/accounts**路由上发出有效的请求，我们需要在请求头中传递令牌。因此，复制访问令牌值，在Postman中打开包含请求的标签页，如*图6.11*所示，为**/accounts**路由。然后执行以下步骤：
- en: In the **GET** request tab for the **/accounts** route, click on the **Authorization**
    tab.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**/accounts**路由的**GET**请求标签页中，点击**授权**标签。
- en: For **Type** , select the **Bearer** **Token** option.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**类型**，选择**Bearer** **令牌**选项。
- en: In the **Token** field, paste the value of the access token that you obtained
    via the login request.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**令牌**字段中，粘贴通过登录请求获得的访问令牌的值。
- en: Click the **Send** button.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发送**按钮。
- en: 'As shown in *Figure 6* *.15* , an empty array is returned since no accounts
    have been registered in the database. Note that the HTTP status code is **200**
    , which means that it was a successful request:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图6.15*所示，由于数据库中没有注册任何账户，因此返回了一个空数组。请注意，HTTP状态码是**200**，这意味着这是一个成功的请求：
- en: '![Figure 6.15 – Successful accounts request](img/B21788_06_15.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![图6.15 – 成功的账户请求](img/B21788_06_15.jpg)'
- en: Figure 6.15 – Successful accounts request
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15 – 成功的账户请求
- en: So far, the application is working as expected. However, it’s important to understand
    how this authorization process works.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，应用程序按预期工作。然而，了解这个授权过程是如何工作的是非常重要的。
- en: When requesting the account route again, we inform the access token, as configured
    previously. Despite Postman having a user-friendly UI, when selecting the authentication
    type and entering the access token, Postman automatically adds an HTTP header.
    HTTP headers are key/value pairs that are part of requests and responses.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当再次请求账户路由时，我们提供之前配置的访问令牌。尽管Postman有一个用户友好的界面，但在选择认证类型并输入访问令牌时，Postman会自动添加一个HTTP头。HTTP头是请求和响应的一部分，由键/值对组成。
- en: 'For this request, the header was created with the authorization key and the
    access token value. You can check this header by clicking on the **Headers** tab
    and viewing the hidden headers, as shown in *Figure 6* *.16* :'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个请求，使用授权键和访问令牌值创建了头。您可以通过点击**头部**标签并查看隐藏的头来检查此头，如*图6.16*所示：
- en: '![Figure 6.16 – The authorization HTTP header](img/B21788_06_16.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图6.16 – 授权HTTP头](img/B21788_06_16.jpg)'
- en: Figure 6.16 – The authorization HTTP header
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16 – 授权HTTP头
- en: When making the request, the authentication and authorization **middleware**
    comes into action. The authentication middleware reads the token that was informed
    in the authorization header and fills in the user credentials for the request
    in the **HttpContext.User** object, which is part of the request. This object
    allows us to access information such as **claims** , which contain data such as
    the user’s name and email, and **roles** , which allow us to determine the user’s
    access type, such as admin, member, and so on.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在发起请求时，认证和授权**中间件**开始工作。认证中间件读取授权头中告知的令牌，并在**HttpContext.User**对象中填充请求的用户凭据，该对象是请求的一部分。此对象允许我们访问诸如**声明**等信息，这些声明包含诸如用户姓名和电子邮件等数据，以及**角色**，这些角色允许我们确定用户的访问类型，例如管理员、成员等。
- en: The ASP.NET Core 9 HttpContext object
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9的HttpContext对象
- en: In ASP.NET Core, **HttpContext.User** is a core property that represents the
    user security context associated with an HTTP request. This property is an instance
    of **ClaimsPrincipal** , a .NET class that contains the user’s identity in the
    form of claims. **HttpContext.User** is a key element in handling user authentication
    and authorization in an ASP.NET Core application.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET Core中，**HttpContext.User**是一个核心属性，它表示与HTTP请求关联的用户安全上下文。该属性是**ClaimsPrincipal**的一个实例，这是一个.NET类，它以声明的形式包含用户的身份。**HttpContext.User**是处理ASP.NET
    Core应用程序中用户认证和授权的关键元素。
- en: During the authentication process, when a request arrives at the application,
    the authentication middleware reads the authentication tokens or cookies attached
    to the request, validates them, and constructs a **ClaimsPrincipal** object. The
    **ClaimsPrincipal** object can contain one or more instances of **ClaimsIdentity**
    .
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在认证过程中，当请求到达应用程序时，认证中间件读取附加到请求的认证令牌或cookies，验证它们，并构建一个**ClaimsPrincipal**对象。**ClaimsPrincipal**对象可以包含一个或多个**ClaimsIdentity**实例。
- en: Each **ClaimsIdentity** instance can contain multiple claims. A claim is a statement
    about a subject that’s been made by an issuer and can represent the user’s identity
    attributes, such as name, role, email, and more.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 每个**ClaimsIdentity**实例可以包含多个声明。声明是由发行者做出的关于主体的陈述，可以代表用户的身份属性，如姓名、角色、电子邮件等。
- en: This process allows the use of **HttpContext.User** in application-wide authorization
    checks to determine whether the current user has permission to perform certain
    operations to ensure that only properly authenticated and authorized users can
    access certain resources or perform specific actions.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程允许在应用程序范围内的授权检查中使用**HttpContext.User**，以确定当前用户是否有权限执行某些操作，以确保只有经过适当认证和授权的用户才能访问某些资源或执行特定操作。
- en: 'The following code shows the use of **HttpContext.User** when executing an
    action. This object is automatically populated by the execution pipeline through
    middleware:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了在执行操作时使用**HttpContext.User**的方式。此对象由执行管道通过中间件自动填充：
- en: '**public** **IActionResult ExampleAction(){**'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**public** **IActionResult ExampleAction(){**'
- en: '**var user =** **HttpContext.User;**'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**var user =** **HttpContext.User;**'
- en: '**if (user.Identity.IsAuthenticated)     {**'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**if (user.Identity.IsAuthenticated)     {**'
- en: '**// Do something for** **authenticated users**'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**// 为** **认证用户执行某些操作**'
- en: '**var userName =** **user.Identity.Name;**'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**var userName =** **user.Identity.Name;**'
- en: '**// Get the** **user''s name**'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**// 获取** **用户名**'
- en: '**return** **Content($"Welcome, {userName}");**'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**return** **Content($"欢迎，{userName}");**'
- en: '**}**'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: '**else**'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**else**'
- en: '**{**'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**// Handle** **non-authenticated users**'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '**// 处理** **未认证用户**'
- en: '**return Unauthorized("You must be logged in to** **access this.");**'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '**return Unauthorized("您必须登录才能** **访问此页面。");**'
- en: '**}**'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: '**}**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: You can learn more about **HttpContext** at [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/http-context?view=aspnetcore-8.0#httpcontext-user](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/http-context?view=aspnetcore-8.0#httpcontext-user)
    .
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://learn.microsoft.com/en-us/aspnet/core/fundamentals/http-context?view=aspnetcore-8.0#httpcontext-user](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/http-context?view=aspnetcore-8.0#httpcontext-user)了解更多关于**HttpContext**的信息。
- en: Authorization middleware analyzes whether the requested route requires authorization.
    If so, it decrypts the token, analyzes whether it’s a valid token, and allows
    the request on the route to be made correctly.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 授权中间件分析请求的路线是否需要授权。如果是，它将解密令牌，分析它是否是有效的令牌，并允许在路线上的请求正确执行。
- en: What is middleware?
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是什么？
- en: During the execution flow of a request in ASP.NET Core 9, several types of processes
    are carried out, such as identifying the route to be executed, among other functionalities.
    This flow is called a pipeline. In some cases, there’s a need to add functionality
    to the execution pipeline. This is done through middleware, something we implemented
    by adding the **app.UseAuthtentication()** and **app.UseAuthorization()** method
    calls to the **Program.cs** file, which allows us to pre-process the request for
    authentication and authorization requirements. Through middleware, it’s possible
    to add functionality to both requests and responses.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET Core 9中，请求的执行流程中会执行多种类型的操作，例如确定要执行的路线以及其他功能。这个流程被称为管道。在某些情况下，需要向执行管道中添加功能。这是通过中间件实现的，我们通过在**Program.cs**文件中添加**app.UseAuthentication()**和**app.UseAuthorization()**方法调用来实现，这允许我们在认证和授权需求之前预处理请求。通过中间件，可以添加到请求和响应的功能。
- en: We’ll learn more about middleware in [*Chapter 8*](B21788_08.xhtml#_idTextAnchor132)
    .
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第8章*](B21788_08.xhtml#_idTextAnchor132)中了解更多关于中间件的内容。
- en: With each API request, the token is sent so that the user information and their
    respective accesses are loaded during the request execution flow. This is a characteristic
    of cloud-native applications. The stateless approach allows applications to be
    scalable and resilient and ensures the server doesn’t retain any information about
    a client’s state between requests, eliminating the need to manage session state.
    This leads to easier scaling and load balancing, makes it easier to scale servers
    when the need arises to handle high user demand, and allows each server instance
    to be able to handle any request without needing to know the context of previous
    requests.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次 API 请求中，都会发送令牌，以便在请求执行流程中加载用户信息和相应的访问权限。这是云原生应用程序的一个特性。无状态方法允许应用程序可扩展和弹性，并确保服务器在请求之间不保留任何关于客户端状态的任何信息，消除了管理会话状态的需求。这导致更容易进行扩展和负载均衡，当需要处理高用户需求时，更容易扩展服务器，并允许每个服务器实例能够处理任何请求，而无需了解先前请求的上下文。
- en: By not relying on server-side state, developers can avoid issues related to
    session management, such as session persistence, synchronization across distributed
    systems, and resource locking.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 通过不依赖服务器端状态，开发者可以避免与会话管理相关的问题，例如会话持久性、分布式系统间的同步以及资源锁定。
- en: Modern applications must have security as a premise by design, and the implementation
    of authentication and authorization has several advantages within the context
    of applications. However, other aspects related to security are linked not only
    to the functionalities available to users but also to the application’s source
    code. In the next section, we’ll learn how to reinforce security in applications.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用程序必须在设计上以安全为前提，并且认证和授权的实现应用程序上下文中有几个优点。然而，与安全相关的其他方面不仅与用户可用的功能相关，还与应用程序的源代码相关。在下一节中，我们将学习如何加强应用程序的安全性。
- en: Strengthening application security
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加强应用程序安全性
- en: For us to be able to create secure web-based applications, we must go beyond
    implementing the use of a security layer based on authentication and authorization,
    something we implemented when using ASP.NET Core Identity.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够创建安全的基于 Web 的应用程序，我们必须超越仅基于身份验证和授权的安全层实现，这是我们使用 ASP.NET Core Identity 时所实现的。
- en: ASP.NET Core 9 allows us to deal with security as a premise when developing
    applications, providing tools and mechanisms that facilitate the implementation
    of features that minimize possible loopholes, something that can generate attacks
    from malicious users.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9 允许我们在开发应用程序时将安全作为前提，提供工具和机制，以促进实现最小化可能漏洞的功能，这可以防止恶意用户发起攻击。
- en: Let’s learn about some good security practices that should be part of every
    software engineer’s toolbox. We’ll start by understanding how we can improve the
    process of managing sensitive configurations in our development environment.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一些应该成为每位软件工程师工具箱一部分的良好安全实践。我们将从了解如何改进我们在开发环境中管理敏感配置的过程开始。
- en: Managing secrets properly
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正确管理机密信息
- en: Every application has configurations and some of these can be sensitive, such
    as database connections, encryption keys, and even security keys for accessing
    external resources.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都有配置，其中一些可能是敏感的，例如数据库连接、加密密钥，甚至是访问外部资源的密钥。
- en: So far, we’ve learned that it’s good practice to keep such settings separate
    from the C# source code and that we can manage settings through files such as
    **appsettings.json** and even environment variables. ASP.NET Core 9 allows us
    to handle external configuration management.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解到将此类设置与 C# 源代码分开是一种良好的实践，我们可以通过诸如 **appsettings.json** 和甚至环境变量等文件来管理设置。ASP.NET
    Core 9 允许我们处理外部配置管理。
- en: Keeping the settings hard-coded is a bad practice since to change any hard-coded
    parameter, we must recompile the application. In addition, there’s the possibility
    of malicious users decompiling the application if they have access to the binaries,
    and then obtaining sensitive data.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 将设置硬编码是一种不良实践，因为要更改任何硬编码参数，我们必须重新编译应用程序。此外，如果恶意用户可以访问二进制文件，他们可能会反编译应用程序，然后获取敏感数据。
- en: Obfuscator
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 加密器
- en: Code obfuscation refers to the process of transforming application source code
    into a form that’s difficult for humans to understand but can still be executed
    by a computer. This technique is primarily used to protect intellectual property
    by making it difficult for attackers or unauthorized users to reverse engineer
    the code and understand its logic.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 代码混淆是指将应用程序源代码转换为人类难以理解但计算机仍能执行的形式的过程。这种技术主要用于通过使攻击者或未经授权的用户难以逆向工程代码和理解其逻辑来保护知识产权。
- en: The process of obfuscation involves several techniques, such as renaming variables
    and methods to meaningless symbols, removing metadata, encrypting strings, and
    altering the control flow to make the code more complex. For more information,
    go to [https://learn.microsoft.com/en-us/visualstudio/ide/dotfuscator/?view=vs-2022](https://learn.microsoft.com/en-us/visualstudio/ide/dotfuscator/?view=vs-2022)
    .
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 加密过程涉及多种技术，例如将变量和方法重命名为无意义的符号，删除元数据，加密字符串，以及改变控制流以使代码更复杂。有关更多信息，请访问[https://learn.microsoft.com/en-us/visualstudio/ide/dotfuscator/?view=vs-2022](https://learn.microsoft.com/en-us/visualstudio/ide/dotfuscator/?view=vs-2022)。
- en: Imagine a situation where our application uses an API key to connect to a payment
    gateway to process transactions from an online store, or even the database connection
    string. If this key is exposed, malicious users can potentially manipulate transaction
    data, access sensitive information, and even delete your database.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这种情况：我们的应用程序使用API密钥连接到支付网关，以处理来自在线商店的交易，或者甚至是数据库连接字符串。如果这个密钥被泄露，恶意用户可能能够操纵交易数据，访问敏感信息，甚至删除您的数据库。
- en: You might be thinking that since your code is in a private repository, and all
    settings are being kept in **appsettings.json** files, this problem is solved.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能认为，由于您的代码在私有存储库中，并且所有设置都保存在**appsettings.json**文件中，这个问题已经解决了。
- en: Of course, since it’s a private repository, the chances of an attacker gaining
    access to the data aren’t very high. However, consider that your company may work
    with employees and third-party companies that can access the data in your repository.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，由于这是一个私有存储库，攻击者获取数据的可能性并不高。然而，请考虑您的公司可能与员工和第三方公司合作，这些公司可以访问您的存储库中的数据。
- en: While it’s good practice to manage settings in **appsettings.json** files, this
    isn’t a good approach for sensitive information. With this, we avoid synchronizing
    the source code of applications with external repositories containing information
    that shouldn’t be shared.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在**appsettings.json**文件中管理设置是一种良好的实践，但这并不是处理敏感信息的良好方法。因此，我们避免了将应用程序的源代码与应用程序外部存储库同步，这些存储库包含不应共享的信息。
- en: Fortunately, ASP.NET Core 9 implements the best development practices and provides
    secret management in your local environment. Proper secret management ensures
    that sensitive data, such as API keys, isn’t hard-coded into your application’s
    source code but is stored and accessed securely, protecting your infrastructure
    and data integrity.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，ASP.NET Core 9实现了最佳开发实践，并在您的本地环境中提供了秘密管理。适当的秘密管理确保敏感数据，如API密钥，不会硬编码到应用程序的源代码中，而是安全地存储和访问，从而保护您的基础设施和数据完整性。
- en: The Secret Manager tool is included in the .NET Core SDK, so you typically don’t
    need to install anything else if you have the SDK.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密管理器工具包含在.NET Core SDK中，因此如果您已经有了SDK，通常不需要安装其他任何东西。
- en: 'To start using Secret Manager, you need to initialize it for your project.
    Navigate to the project’s **WorkingWithIdentity** directory, which we worked on
    previously, in the Command Prompt or terminal where your **.csproj** file is located.
    Then, run the following command to initialize secret storage:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用秘密管理器，您需要为您的项目初始化它。在命令提示符或终端中导航到包含您的**.csproj**文件的项目**WorkingWithIdentity**目录，这是我们之前工作过的目录。然后，运行以下命令以初始化秘密存储：
- en: '[PRE14]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding command adds a **UserSecretsId** element within a **PropertyGroup**
    value to your **.csproj** (project file). This ID uniquely identifies your project’s
    secrets.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令在**.csproj**（项目文件）中的**PropertyGroup**值内添加了一个**UserSecretsId**元素。此ID唯一标识您项目的秘密。
- en: 'You can verify the addition of the **UserSecretsId** element by opening the
    **.csproj** file in your code editor, as shown in *Figure 6* *.17* :'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在代码编辑器中打开**.csproj**文件来验证**UserSecretsId**元素的添加，如图*图6* *.17* 所示：
- en: '![Figure 6.17 – The UserSecretsId element configured in the .csproj file](img/B21788_06_17.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![图6.17 – 在.csproj文件中配置的UserSecretsId元素](img/B21788_06_17.jpg)'
- en: Figure 6.17 – The UserSecretsId element configured in the .csproj file
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17 – 在.csproj文件中配置的UserSecretsId元素
- en: 'Next, we’ll configure the connection string with the SQL Server database. To
    do this, we must add some new code by executing the following command:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用SQL Server数据库配置连接字符串。为此，我们必须通过执行以下命令添加一些新代码：
- en: '[PRE15]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Secrets naming convention
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密命名约定
- en: The notation commonly uses colons ( **:** ) to separate different levels of
    a hierarchy in the key names of secrets. This structure not only helps in organizing
    the keys logically but also aligns with how the ASP.NET Core 9 configuration system
    retrieves values from various configuration sources, such as **appsettings.json**
    , environment variables, and Secret Manager.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表示法通常使用冒号（**:**）来分隔秘密键名中的不同层级。这种结构不仅有助于逻辑上组织键，而且与ASP.NET Core 9配置系统从各种配置源检索值的方式相一致，例如**appsettings.json**、环境变量和Secret
    Manager。
- en: 'In the **WorkingWithIdentity** application, we have the following configuration
    in the **appsettings.json** file:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在**WorkingWithIdentity**应用程序中，我们在**appsettings.json**文件中有以下配置：
- en: '**"** **ConnectionStrings" {**'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**"** **ConnectionStrings" {**'
- en: '**"** **BankingDbContext": "..."**'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**"** **BankingDbContext**: "..."**'
- en: '**}**'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: The preceding JSON represents a property of the **object** type called **ConnectionStrings**
    that has a string property called **BankingDbContext** .
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的JSON表示一个名为**ConnectionStrings**的对象类型的属性，它有一个名为**BankingDbContext**的字符串属性。
- en: Based on this, the secret is called **ConnectionStrings:BankingDbContext** .
    Here, **ConnectionStrings** is the top-level category and **BankingDbContext**
    is the actual key containing the respective secret – in this case, the SQL Server
    database connection string. This notation helps to logically group related settings.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，秘密被命名为**ConnectionStrings:BankingDbContext**。在这里，**ConnectionStrings**是顶级类别，而**BankingDbContext**是包含相应秘密的实际键——在这种情况下，是SQL
    Server数据库连接字符串。这种表示法有助于逻辑上分组相关设置。
- en: Since this is a convention used by ASP.NET Core 9, there’s no need to change
    the application’s source code to obtain the database connection string.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是ASP.NET Core 9使用的约定，因此无需更改应用程序的源代码即可获取数据库连接字符串。
- en: 'When using environment variables (which don’t allow colons in variable names
    on some operating systems), colon separators are typically replaced with double
    underscores ( **__** ). So, if you were defining these secrets via environment
    variables in a production environment, you would define them like this:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用环境变量（在某些操作系统中不允许变量名中包含冒号）时，冒号分隔符通常被替换为双下划线（**__**）。所以，如果你在生产环境中通过环境变量定义这些秘密，你会这样定义它们：
- en: '**ConnectionStrings__BankingDbContext**'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**ConnectionStrings__BankingDbContext**'
- en: This naming convention ensures that when the ASP.NET Core configuration system
    reads the environment variables, it can reconstruct the hierarchy and treat them
    equivalently to secrets defined in **appsettings.json** or Secret Manager.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这种命名约定确保当ASP.NET Core配置系统读取环境变量时，它可以重建层次结构并将它们视为与在**appsettings.json**或Secret
    Manager中定义的秘密等效。
- en: There’s no need to change the application code to obtain the secret since this
    is a feature of ASP.NET Core 9 and works in the same way if you want to use environment
    variables.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是ASP.NET Core 9的功能，并且如果你想要使用环境变量，它将以相同的方式工作，因此无需更改应用程序代码来获取秘密。
- en: 'The secret that’s created is kept in the operating system; its location may
    vary from environment to environment. However, you can manage secrets using the
    **user-secrets** tool. For example, you can use it to list the secrets that exist
    on your local machine:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的秘密被保存在操作系统中；其位置可能因环境而异。然而，你可以使用**user-secrets**工具来管理秘密。例如，你可以用它来列出你本地机器上存在的秘密：
- en: '[PRE16]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can use the following command to remove a specific secret:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令来删除特定的秘密：
- en: '[PRE17]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can even clear all secrets:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以清除所有秘密：
- en: '[PRE18]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: All secrets information is kept in your operating system. When integrating the
    source code with your remote code repository, the secrets won’t be shared.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 所有秘密信息都保存在你的操作系统中。当将源代码与远程代码库集成时，秘密不会被共享。
- en: Keep in mind that the Secret Manager tool is intended for development purposes
    only. For production environments, you should use a secure vault such as **Azure
    Key Vault** , **AWS Secrets Manager** , or another secure means of managing sensitive
    configuration data. We’ll learn more about configuration management in [*Chapter
    9*](B21788_09.xhtml#_idTextAnchor146) .
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Secret Manager 工具仅适用于开发目的。对于生产环境，您应使用安全的保险库，例如 **Azure Key Vault**、**AWS
    Secrets Manager** 或其他安全方式来管理敏感配置数据。我们将在 [*第 9 章*](B21788_09.xhtml#_idTextAnchor146)
    中了解更多关于配置管理的内容。
- en: Now that we know how to better manage application secrets, let’s learn about
    other good security practices, including the use of **Hypertext Transfer Protocol
    Secure** ( **HTTPS** ) and **Cross-Origin Resource** **Sharing** ( **CORS** ).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何更好地管理应用程序的秘密，让我们学习其他良好的安全实践，包括使用 **超文本传输协议安全** ( **HTTPS** ) 和 **跨源资源共享**
    ( **CORS** )。
- en: Enforcing HTTPS and working with CORS
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制执行 HTTPS 和处理 CORS
- en: HTTPS enforcement is important for ensuring secure communication between clients
    and servers by encrypting data transmitted over the network. As we’ve already
    learned, ASP.NET Core 9 provides us with integrated middleware to enforce HTTPS,
    which can be configured to redirect all HTTP requests to HTTPS.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS 强制执行对于确保客户端和服务器之间通过加密网络传输的数据安全通信非常重要。正如我们之前所学的，ASP.NET Core 9 为我们提供了内置的中间件来强制执行
    HTTPS，这可以被配置为将所有 HTTP 请求重定向到 HTTPS。
- en: 'To enforce HTTPS in an ASP.NET Core 9 application, simply add the following
    line of code to the **Program.cs** file to add a middleware to the application’s
    execution pipeline:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 ASP.NET Core 9 应用程序中强制执行 HTTPS，只需将以下代码行添加到 **Program.cs** 文件中，以向应用程序的执行管道添加中间件：
- en: '[PRE19]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It’s important to know that adding the middleware that enforces the use of HTTPS
    is a configuration step for the application. Likewise, you must also configure
    your web server (for example, IIS, NGINX, Azure App Services, and so on) to enforce
    HTTPS and obtain a valid SSL/TLS certificate from a trusted certificate authority.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，添加强制使用 HTTPS 的中间件是应用程序的配置步骤。同样，您还必须配置您的 Web 服务器（例如，IIS、NGINX、Azure App
    Services 等）以强制执行 HTTPS 并从受信任的证书颁发机构获取有效的 SSL/TLS 证书。
- en: In addition to enforcing HTTPS, you can configure **CORS** , a feature that’s
    implemented by browsers to restrict web applications running on one origin from
    accessing resources on a different origin without explicit permission. It’s more
    common to see this type of behavior in SPA applications that use technologies
    such as **Angular** , **React** , or even pure **JavaScript** . When making an
    HTTP request through JavaScript, it’s executed in the browser, which, through
    the security mechanism, doesn’t allow a request on one origin server to be made
    to another server where the resource is hosted. Fortunately, ASP.NET Core 9 provides
    middleware to configure and manage CORS policies, allowing you to specify which
    origins, headers, and methods are allowed. This feature is interesting because
    we can only respond to certain requests based on a specific origin.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 除了强制执行 HTTPS，您还可以配置 **CORS**，这是一种由浏览器实现的功能，用于限制在一个源上运行的 Web 应用程序在没有明确权限的情况下访问不同源上的资源。在像
    **Angular**、**React** 或纯 **JavaScript** 这样的 SPA 应用程序中，更常见这种行为。当通过 JavaScript 发送
    HTTP 请求时，它将在浏览器中执行，通过安全机制，不允许一个源服务器上的请求发送到资源所在的服务器。幸运的是，ASP.NET Core 9 提供了中间件来配置和管理
    CORS 策略，允许您指定哪些源、头和方法是允许的。这个特性很有趣，因为我们只能根据特定的源响应某些请求。
- en: 'To enable and configure CORS in an ASP.NET Core 9 application, you can add
    the following code to the **Program.cs** file:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 ASP.NET Core 9 应用程序中启用和配置 CORS，您可以将以下代码添加到 **Program.cs** 文件中：
- en: '[PRE20]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s understand the preceding code:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解前面的代码：
- en: '**builder.Services.AddCors(options => { ... })** : This line adds CORS services
    to the application’s dependency injection container. The **options** parameter,
    which is of the **Action<CorsOptions>** type, allows you to configure CORS policies.'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**builder.Services.AddCors(options => { ... })**：这一行代码将 CORS 服务添加到应用程序的依赖注入容器中。**options**
    参数，其类型为 **Action<CorsOptions>**，允许您配置 CORS 策略。'
- en: '**options.AddPolicy** : In this line, we’re adding a new policy named **AllowSpecificOrigin**
    . The **builder** parameter in the Lambda expression is an instance of the **CorsPolicyBuilder**
    class, which provides methods to configure the policy.'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**options.AddPolicy**：在这一行中，我们添加了一个名为 **AllowSpecificOrigin** 的新策略。Lambda 表达式中的
    **builder** 参数是 **CorsPolicyBuilder** 类的实例，它提供了配置策略的方法。'
- en: '**builder.WithOrigins("https://myapp.com")** : The **WithOrigins** method defines
    the origins that are allowed to access the application’s resources. In this case,
    any requests coming from **https://myapp.com** will be allowed by this CORS policy.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**builder.WithOrigins("https://myapp.com")**：**WithOrigins** 方法定义了允许访问应用程序资源的来源。在这种情况下，来自
    **https://myapp.com** 的任何请求都将被此 CORS 策略允许。'
- en: '**AllowAnyHeader()** : The **AllowAnyHeader** method allows any HTTP headers
    in the request, allowing the specified origin to include any headers without being
    blocked by the CORS policy.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AllowAnyHeader()**：**AllowAnyHeader** 方法允许请求中的任何 HTTP 头部，允许指定的来源包含任何头部而不会被
    CORS 策略阻止。'
- en: '**AllowAnyMethod()** : This method defines that any HTTP methods ( **GET**
    , **POST** , **PUT** , **DELETE** , and others) can be used in the request.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AllowAnyMethod()**：此方法定义了任何 HTTP 方法（**GET**、**POST**、**PUT**、**DELETE** 以及其他）都可以在请求中使用。'
- en: '**app.UseCors("AllowSpecificOrigin")** : This triggers the CORS middleware
    in the request pipeline, referencing the previously created policy globally to
    all HTTP requests of the application.'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**app.UseCors("AllowSpecificOrigin")**：这将在请求管道中触发 CORS 中间件，全局引用先前创建的策略以应用于应用程序的所有
    HTTP 请求。'
- en: Learn more about CORS
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多关于 CORS 的信息
- en: As defined earlier, CORS is an HTTP header-based mechanism that lets you tell
    the browser which origins can load resources. ASP.NET Core 9 has an excellent
    framework for implementing CORS in your applications. To learn more, go to [https://learn.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-9.0)
    .
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，CORS 是一种基于 HTTP 头部的机制，允许您告诉浏览器哪些来源可以加载资源。ASP.NET Core 9 为在应用程序中实现 CORS
    提供了一个优秀的框架。要了解更多信息，请访问 [https://learn.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-9.0)。
- en: The preceding example illustrates the use of CORS in an ASP.NET Core 9 application.
    However, apart from the origin, it doesn’t have restrictions on the use of HTTP
    headers or methods. In some cases, it will be necessary to explicitly define the
    HTTP headers and methods that an origin can access.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例说明了在 ASP.NET Core 9 应用程序中使用 CORS。然而，除了来源之外，它对 HTTP 头部或方法的使用没有限制。在某些情况下，将有必要明确定义来源可以访问的
    HTTP 头部和方法。
- en: However, the features available in ASP.NET Core 9 give us great flexibility
    in defining different policies for different origins, creating more restricted
    and specific rules for CORS. This is an important mechanism since the browser
    uses it to allow SPAs or other applications running on the client to be able to
    consume external resources appropriately.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，ASP.NET Core 9 中可用的功能为我们提供了在定义不同来源的不同策略方面的巨大灵活性，为 CORS 创建了更受限制和更具体的规则。这是一个重要的机制，因为浏览器使用它来允许
    SPAs 或在客户端运行的其他应用程序能够适当地消耗外部资源。
- en: CORS is not a security mechanism, but its use is recommended. In the next section,
    we’ll talk about some security mechanisms we can use to prevent vulnerabilities
    in applications.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: CORS 不是一个安全机制，但建议使用。在下一节中，我们将讨论我们可以用来防止应用程序中漏洞的一些安全机制。
- en: Preventing common vulnerabilities
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防止常见漏洞
- en: When we talk about vulnerabilities in applications, several topics can be taken
    into consideration, such as source code, servers, credential management, protocols
    used, and encryption, among others.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论应用程序中的漏洞时，可以考虑几个主题，例如源代码、服务器、凭证管理、使用的协议和加密等。
- en: 'Some common vulnerabilities are already well known, but if they aren’t addressed
    in applications, they can cause some problems for organizations. ASP.NET Core
    9 offers mechanisms for dealing with several common threats in web applications:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的漏洞已经众所周知，但如果它们在应用程序中没有得到解决，它们可能会给组织带来一些问题。ASP.NET Core 9 提供了处理 Web 应用程序中几个常见威胁的机制：
- en: SQL injection
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL 注入
- en: '**Cross-site** **scripting** ( **XSS** )'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨站** **脚本**（**XSS**）'
- en: '**Cross-site request** **forgery** ( **CSRF** )'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨站请求** **伪造**（**CSRF**）'
- en: Let’s learn how to prevent each of these vulnerabilities.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何防止这些漏洞中的每一个。
- en: SQL injection
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL 注入
- en: SQL injection is a common attack where an attacker inserts malicious SQL code
    into an SQL query.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 注入是一种常见的攻击，攻击者将恶意 SQL 代码插入到 SQL 查询中。
- en: To prevent SQL injection, always use parameterized queries or ORM frameworks
    such as Entity Framework, which handle query parameters safely and help us avoid
    string concatenation. We learned about this in the *Security topics in web* *applications*
    section.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止 SQL 注入，始终使用参数化查询或 ORM 框架，如 Entity Framework，这些框架可以安全地处理查询参数并帮助我们避免字符串连接。我们已经在
    *Web 应用程序安全主题* 部分学习了这一点。
- en: XSS
  id: totrans-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XSS
- en: 'XSS attacks occur when an attacker injects malicious scripts into a web page.
    To prevent XSS, always encode or escape user input before rendering it in the
    browser. This way, if there’s any code injection in an input, for example, it
    will be encoded with special characters. ASP.NET Core 9 provides built-in helpers
    to sanitize the output, as shown in the following example:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 当攻击者将恶意脚本注入到网页中时，就会发生 XSS 攻击。为了防止 XSS，在将用户输入渲染到浏览器之前，始终对其进行编码或转义。这样，如果输入中存在任何代码注入，例如，它将被特殊字符编码。ASP.NET
    Core 9 提供了内置的辅助函数来清理输出，如下面的示例所示：
- en: '[PRE21]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding example, the JavaScript code was encoded, preventing the injected
    code from being sent and executed since, after encoding, it becomes just a string.
    To learn more about the vulnerabilities associated with XSS, go to [https://learn.microsoft.com/en-us/aspnet/core/security/cross-site-scripting?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/security/cross-site-scripting?view=aspnetcore-9.0)
    .
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，JavaScript 代码被编码，防止注入的代码被发送和执行，因为编码后它只是一个字符串。要了解更多关于与 XSS 相关的漏洞信息，请访问
    [https://learn.microsoft.com/en-us/aspnet/core/security/cross-site-scripting?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/security/cross-site-scripting?view=aspnetcore-9.0)。
- en: CSRF
  id: totrans-427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CSRF
- en: CSRF is a type of security attack in which a malicious website tricks a user’s
    browser into performing actions on another website where the user is authenticated,
    without the user’s knowledge. This can lead to unauthorized actions such as changing
    settings, transferring funds, or making purchases. ASP.NET Core provides built-in
    anti-forgery tokens to prevent CSRF attacks. These tokens are automatically included
    in forms and validated on the server.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF 是一种安全攻击类型，恶意网站欺骗用户的浏览器在用户不知情的情况下，在用户已认证的另一个网站上执行操作。这可能导致未经授权的操作，例如更改设置、转账或购物。ASP.NET
    Core 提供了内置的防伪造令牌来防止 CSRF 攻击。这些令牌会自动包含在表单中并在服务器上进行验证。
- en: 'To use anti-forgery tokens in a simplified way in Razor Pages or MVC, add the
    following code to your form:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Razor Pages 或 MVC 中以简化的方式使用防伪造令牌，请将以下代码添加到您的表单中：
- en: '[PRE22]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'At this point, we must add the **ValidateAntiForgeryToken** attribute to the
    action that will process the form request, as shown here:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们必须将 **ValidateAntiForgeryToken** 属性添加到将处理表单请求的动作中，如下所示：
- en: '[PRE23]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ASP.NET Core 9 also ¢provides other mechanisms for dealing with this vulnerability.
    You can learn more at [https://learn.microsoft.com/en-us/aspnet/core/security/anti-request-forgery?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/security/anti-request-forgery?view=aspnetcore-9.0)
    .
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9 还提供了其他机制来处理这种漏洞。您可以在 [https://learn.microsoft.com/en-us/aspnet/core/security/anti-request-forgery?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/security/anti-request-forgery?view=aspnetcore-9.0)
    上了解更多信息。
- en: As we’ve learned, applications can contain several vulnerabilities that aren’t
    only associated with the source code but also with the hosting server, communication
    protocol, and many others.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，应用程序可能包含多个漏洞，这些漏洞不仅与源代码相关，还与托管服务器、通信协议以及许多其他方面相关。
- en: In any case, the ASP.NET Core 9 platform provides several mechanisms and best
    practices that, combined and related to the requirements of the applications,
    allow us to minimize risks and keep our solutions robust, secure, and reliable
    while following the best practices of modern applications. As we progress through
    this book, we’ll learn about more mechanisms and approaches we can use to create
    increasingly robust applications.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，ASP.NET Core 9 平台提供了多种机制和最佳实践，结合应用的需求，使我们能够最小化风险，并保持我们的解决方案在遵循现代应用程序最佳实践的同时，保持稳健、安全和可靠。随着我们继续阅读本书，我们将了解更多可以用来创建越来越稳健应用程序的机制和方法。
- en: Summary
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the principles of web application security
    and how they influence the development model and the interaction with users and
    other applications. In addition, we learned about the authorization and authentication
    processes, comparing the flows of these processes and getting to know standards
    such as OAuth 2.0 and OIDC. To reinforce our knowledge about authentication and
    authorization, we worked with ASP.NET Core Identity, which provides all the mechanisms
    that support user authentication and authorization in an application, integrated
    with a database for managing identities securely. To do so, we consumed information
    securely by providing tokens provided by ASP.NET Core Identity. Finally, we discussed
    how to strengthen the security of applications, understood secret management,
    and learned about techniques such as the use of CORS to prevent common vulnerabilities
    in web applications.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了网络应用程序安全性的原则以及它们如何影响开发模型和与用户及其他应用程序的交互。此外，我们还学习了授权和认证过程，比较了这些过程的流程，并了解了OAuth
    2.0和OIDC等标准。为了加强我们对认证和授权的知识，我们使用了ASP.NET Core Identity，它提供了支持应用程序中用户认证和授权的所有机制，并与数据库集成以安全地管理身份。为此，我们通过提供ASP.NET
    Core Identity提供的令牌来安全地消费信息。最后，我们讨论了如何增强应用程序的安全性，理解了密钥管理，并学习了使用CORS等技术来防止网络应用程序中的常见漏洞。
- en: In the next chapter, we’ll learn how to add more capabilities to applications,
    understand how to implement best practices, and learn how to use caching and monitoring.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何为应用程序添加更多功能，了解如何实施最佳实践，以及如何使用缓存和监控。
- en: 'Part 3: Applying Best Practices'
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：应用最佳实践
- en: In this section, we assume that you are more familiar with the ASP.NET Core
    9 platform and most of the powerful features available in this technology. As
    we advance in the knowledge of the platform and the need to develop increasingly
    rich solutions, we must stick to best practices. Therefore, we will cover topics
    related to the addition of features that interact with the application, including
    the challenge strategy, resilience, and best practices. We will also learn how
    to implement monitoring (Logging and Tracing), allowing software engineers the
    ability to deal with bug fixes, optimizations, and proactive actions. We will
    also explore the use of Middleware to customize the interaction flow in the application.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们假设您对ASP.NET Core 9平台更加熟悉，并且熟悉该技术中大多数强大的功能。随着我们对平台知识的深入和开发越来越丰富解决方案的需求，我们必须坚持最佳实践。因此，我们将涵盖与添加与应用程序交互的功能相关的主题，包括挑战策略、弹性和最佳实践。我们还将学习如何实现监控（日志记录和跟踪），使软件工程师能够处理错误修复、优化和主动行动。我们还将探索使用中间件来自定义应用程序中的交互流程。
- en: 'This part has the following chapters:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 7*](B21788_07.xhtml#_idTextAnchor117) , *Adding Capabilities to Applications*'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B21788_07.xhtml#_idTextAnchor117) ，*为应用程序添加功能*'
- en: '[*Chapter 8*](B21788_08.xhtml#_idTextAnchor132) , *Enhancing Applications with
    Middleware in ASP.NET Core 9*'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B21788_08.xhtml#_idTextAnchor132) ，*在ASP.NET Core 9中使用中间件增强应用程序*'
- en: '[*Chapter 9*](B21788_09.xhtml#_idTextAnchor146) , *Managing Application Settings*'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B21788_09.xhtml#_idTextAnchor146) ，*管理应用程序设置*'
