<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-100"><a id="_idTextAnchor100"/>6</h1>
<h1 id="_idParaDest-101"><a id="_idTextAnchor101"/>Working with Collections</h1>
<p>Collections<a id="_idIndexMarker417"/> are a fundamental part of nearly every application, allowing us to manage and organize groups of related objects. In this chapter, we’ll explore the power of collections in the context of the MVVM design pattern, offering you the tools and knowledge to efficiently work with data in your .NET MAUI applications.</p>
<p>Up until now, our focus has primarily been on binding single values, such as titles, ratings, and commands. However, with the introduction of collections, we can take our applications to the next level. Collections empower us to represent groups of items, whether it be a collection of recipes, lists of ingredients, or arrays of user ratings. By harnessing the capabilities of collections, we can create dynamic, data-driven UIs that provide enhanced user experiences.</p>
<p>This chapter is structured into three key sections:</p>
<ul>
<li>Using <code>BindableLayout</code></li>
<li>The <code>ICollectionChanged</code> interface</li>
<li>Working with <code>CollectionView</code></li>
</ul>
<p>By the end of this chapter, you will have a strong understanding of working with collections in .NET MAUI, significantly expanding your capabilities in building rich, data-centric applications such as our <em class="italic">Recipes!</em> app. Let’s dive in!</p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor102"/>Technical requirements</h1>
<p>Throughout this chapter, we will be enhancing the functionality of the <em class="italic">Recipes!</em> app. The code base for this chapter and all the assets, including the additional classes and code required to cover the topics in this chapter effectively, can be found on GitHub at<a id="_idTextAnchor103"/><a id="_idTextAnchor104"/> <a href="https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter06">https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter06</a>. The starting point for this chapter is provided in the <code>Start</code> folder, which includes the necessary classes and code that have been added specifically for this chapter. The code in the <code>Start</code> folder serves as the starting point to follow along with this chapter’s content, building upon the foundation we established in the previous chapters. The completed code, which includes all the code we have written throughout this chapter, can be found in the <code>Finish</code> folder for reference and comparison.</p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor105"/>Using BindableLayout</h1>
<p>The <code>BindableLayout</code> class<a id="_idIndexMarker418"/> is a static class that provides <em class="italic">attached properties</em> for binding collections to layout containers. An attached property is a concept that allows you to attach additional properties to existing elements or controls. These properties are not defined within the element itself but are provided by an external class. They enable you to extend the behavior and functionality of elements without modifying their underlying code. <code>Grid.Row</code> is probably one of the most commonly used attached properties in .NET MAUI. It can be applied to any UI element, allowing you to define the row position within a <code>Grid</code> layout. It is not a property of the UI element itself; instead, it is an attached property that enhances the flexibility and power of the <code>Grid</code> layout. As such, <code>BindableLayout</code> provides a set of attached properties that can be used to bind collections of data to layout containers, such as <code>VerticalStackLayout</code> or <code>Grid</code>. You can leverage its attached properties to effortlessly bind and display dynamic collections of data.</p>
<p>Although the <code>BindableLayout</code> class’s attached properties can be added to any layout that derives from the <code>Layout</code> class, it is commonly used with layouts such as <code>VerticalStackLayout</code> and <code>HorizontalStackLayout</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout"><code>BindableLayout</code> is a <a id="_idIndexMarker419"/>lightweight and straightforward solution for displaying collections of data. It works great for scenarios with a limited number of items, offering simplicity and ease of use.</p>
<p class="callout">However, it’s important to consider that <code>BindableLayout</code> generates UI elements for each item in the collection without built-in features such as virtualization or view recycling. This means that for large collections with many items, there may be performance implications and increased memory usage.</p>
<p>Let’s have a look at how we can use <code>BindableLayout</code> to show a collection of data inside a <code>VerticalStackLayout</code>.</p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor106"/>What to show and how to show it</h2>
<p>Two essential attached <a id="_idIndexMarker420"/>properties of <code>BindableLayout</code> are <code>ItemsSource</code> and <code>ItemTemplate</code>. These two properties play a crucial role in defining what collection of data needs to be shown and how each data item should be visualized. The <code>ItemsSource</code> property is used to bind a collection of data, while the <code>ItemTemplate</code> property is used to define<a id="_idIndexMarker421"/> the <code>DataTemplate</code> for each item in the collection.</p>
<p>Since a recipe is nothing without its list of ingredients, in the first example, we are going to display the list of ingredients on <code>RecipeDetailPage</code>. However, before we dive into how to effectively use <code>BindableLayout</code>, let’s first discuss <code>RecipeIngredientViewModel</code>, which is used to hold the information of ingredients.</p>
<h3>Defining ingredients</h3>
<p>The <code>RecipeIngredientViewModel</code> class<a id="_idIndexMarker422"/> represents an ingredient within a recipe.</p>
<p>It contains the name of the ingredient and information about the required quantity of the ingredient for a specific number of servings. The purpose of the <code>DisplayAmount</code> property is to dynamically adjust and display the appropriate quantity of ingredients for the desired number of servings. It allows the user to see the adjusted amount that aligns with their selected serving size, providing accurate ingredient measurements for their recipe preparation. Let’s have a look at its <code>UpdateServings</code> method:</p>
<pre class="source-code">
public void UpdateServings(int servings)
{
    var factor = servings / (double)baseServings;
    DisplayAmount = factor * baseAmount;
}</pre> <p>This <a id="_idIndexMarker423"/>method updates the <code>DisplayAmount</code> property based on the desired number of servings, allowing the user to see the appropriate quantity of the ingredient for their selected serving size. As the setter of the <code>DisplayAmount</code> property calls the <code>PropertyChanged</code> event when its value changes, we can bind this property to a UI element in our view to dynamically display the adjusted ingredient amount based on the selected number of servings.</p>
<p>We can extend <code>IngredientsListViewModel</code> with an additional property: <code>Ingredients</code>. This property is a list of <code>RecipeIngredientViewModel</code> objects that, for demo purposes, is assigned a hard-coded list of ingredients needed for making a Caesar salad.</p>
<p>Finally, the <code>NumberOfServings</code> property is updated. The following code block shows how the <code>UpdateServings</code> method on each of the ingredients is called when the value of the <code>NumberOfServings</code> property is changed:</p>
<pre class="source-code">
public int NumberOfServings
{
    get =&gt; _numberOfServings;
    set
    {
        if (SetProperty(ref _numberOfServings, value))
        {
            Ingredients.ForEach(
                i =&gt; i.UpdateServings(value));
        }
    }
}</pre> <p>When updating <code>NumberOfServings</code>, the <code>DisplayAmount</code> property of each ingredient is updated as well, by calling the <code>UpdateServings</code> method.</p>
<p>With all <a id="_idIndexMarker424"/>of this in place, we can finally move over to XAML and see how we can bind this collection of <code>RecipeIngredientViewModels</code> to a <code>VerticalStackLayout</code> while using the attached properties of <code>BindableLayout</code>.</p>
<h3>Showing ingredients on the screen</h3>
<p>In the following steps, we’ll go <a id="_idIndexMarker425"/>through the process of setting up the XAML code to display the ingredients in a visually appealing manner. Note that everything we are about to do in XAML can also be done in code:</p>
<ol>
<li>On <code>RecipeDetailPage</code>, right below the <code>HorizontalStackLayout</code>, which holds the <code>Stepper</code> property that controls the number of servings, we can add a new <code>VerticalStackLayout</code>. As shown in the following code block, we can use the <code>ItemsSource</code> property of the <code>BindableLayout</code> class to bind to the list of ingredients:<pre class="source-code">
&lt;VerticalStackLayout
    Margin="0,10" Spacing="10"
    <strong class="bold">BindableLayout.ItemsSource="{Binding</strong>
<strong class="bold">      </strong><strong class="bold">IngredientsList.Ingredients}"</strong>&gt;
&lt;/VerticalStackLayout&gt;</pre></li> <li>Now, we need to define the UI elements that need to be rendered for each of the items in the bound collection. We can define this using the <code>ItemTemplate</code> property. This property needs a value of the <code>DataTemplate</code> class. It can be defined like this:<pre class="source-code">
&lt;VerticalStackLayout ... &gt;
    <strong class="bold">&lt;BindableLayout.ItemTemplate&gt;</strong>
<strong class="bold">        &lt;DataTemplate x:DataType=</strong>
<strong class="bold">          "vms:RecipeIngredientViewModel" &gt;</strong>
<strong class="bold">        &lt;/DataTemplate&gt;</strong>
<strong class="bold">    &lt;/BindableLayout.ItemTemplate&gt;</strong>
&lt;/VerticalStackLayout&gt;</pre><p class="list-inset">Notice that on a <code>DataTemplate</code>, we can define <code>x:DataType</code> if we want to leverage compiled bindings, as we saw in <a href="B20941_04.xhtml#_idTextAnchor069"><em class="italic">Chapter 4</em></a>, <em class="italic">Data Binding in .</em><em class="italic">NET MAUI</em>.</p></li> </ol>
<p class="callout-heading">Note</p>
<p class="callout">It’s very important to realize that the <code>BindingContext</code> of a <code>DataTemplate</code> is set to an individual item of the bound collection. Because the template is repeated for each item in the collection, UI elements named with <code>x:Name</code> in <code>DataTemplate</code> are inaccessible in the code behind. Their name is confined to that template’s scope. However, the name can still be used for element binding within the same <code>DataTemplate</code>.</p>
<ol>
<li value="3">The <a id="_idIndexMarker426"/>following code snippet shows how we can define a <code>DataTemplate</code> for the ingredients. This is how we define how each of the ingredients needs to be visualized:<pre class="source-code">
&lt;DataTemplate x:DataType=
  "vms:RecipeIngredientViewModel"&gt;
    <strong class="bold">&lt;HorizontalStackLayout Spacing="5"&gt;</strong>
<strong class="bold">        &lt;Label</strong>
<strong class="bold">            FontAttributes="Bold" FontSize="16"</strong>
<strong class="bold">            Text="{Binding IngredientName,</strong>
<strong class="bold">              StringFormat='{0}:', Mode=OneTime}"</strong>
<strong class="bold">            VerticalOptions="Center" /&gt;</strong>
<strong class="bold">        &lt;Label Text="{Binding DisplayAmount,</strong>
<strong class="bold">          </strong><strong class="bold">Mode=OneWay}" VerticalOptions="Center" /&gt;</strong>
<strong class="bold">        &lt;Label</strong>
<strong class="bold">            Text="{Binding Measurement, Mode=OneTime}"</strong>
<strong class="bold">            VerticalOptions="Center" /&gt;</strong>
<strong class="bold">    &lt;/HorizontalStackLayout&gt;</strong>
&lt;/DataTemplate&gt;</pre></li> </ol>
<p>For each <a id="_idIndexMarker427"/>ingredient, we want to render a <code>HorizontalStackLayout</code> containing a label showing the ingredient’s name, a label showing the <code>DisplayAmount</code>, and finally, a label showing the <code>Measurement</code>. <em class="italic">Figure 6</em><em class="italic">.1</em> shows what it looks like:</p>
<div><div><img alt="Figure 6.1: The Ingredients list" height="444" src="img/B20941_06_01.jpg" width="387"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1: The Ingredients list</p>
<p>Notice that <code>DisplayAmount</code> is bound <code>OneWay</code>, meaning that when the <code>PropertyChanged</code> event for this property is triggered, the label’s <code>Text</code> property is updated accordingly. All the other properties can be bound <code>OneTime</code> as their values won’t change once they’re displayed.</p>
<p class="callout-heading">Tip</p>
<p class="callout">In terms of performance, it’s worth noting that <code>OneTime</code> binding mode is generally more efficient than <code>OneWay</code> data binding. This is especially important when binding collections of data! <code>OneTime</code> binding establishes the binding once and does not track subsequent changes to the source property. Therefore, it’s advisable to use <code>OneTime</code> binding wherever possible to optimize performance and reduce unnecessary UI updates.</p>
<p>A <code>DataTemplate </code>can also<a id="_idIndexMarker428"/> be defined in a resource dictionary. This allows <code>DataTemplate</code>s to be reused, which can be especially convenient when showing the same kind of data in different parts of your app. By defining the template once in <code>Application.Resources</code> (in <code>App.xaml</code>), for example, it can be reused throughout the app. Then, we can use the <code>StaticResource</code> markup extension to bind a particular <code>DataTemplate</code> to the <code>BindableLayout</code> <code>ItemTemplate</code> property using the key that was defined in the resource dictionary. The following code block shows how to add a <code>DataTemplate</code> to the page’s resources and use it later on as the <code>ItemTemplate</code> of the <code>VerticalStackLayout</code> showing the ingredients:</p>
<pre class="source-code">
<strong class="bold">&lt;ContentPage.Resources&gt;</strong>
    <strong class="bold">&lt;DataTemplate x:Key="recipeIngredientTemplate"</strong>
<strong class="bold">              x:DataType="vms:RecipeIngredientViewModel"&gt;</strong>
        ...
    <strong class="bold">&lt;/DataTemplate&gt;</strong>
<strong class="bold">&lt;/ContentPage.Resources&gt;</strong>
...
    &lt;VerticalStackLayout
        Margin="0,10"
        BindableLayout.ItemsSource="{Binding IngredientsList.Ingredients}"
        <strong class="bold">BindableLayout.ItemTemplate="{StaticResource</strong>
<strong class="bold">          recipeIngredientTemplate}"</strong>
        Spacing="10"/&gt;</pre> <p>In the previous code snippet, a <code>DataTemplate</code> is defined within the <code>ContentPage.Resources</code> section and is assigned the <code>"recipeIngredientTemplate"</code> key. Later, this template is used in the <code>VerticalStackLayout</code> by us referencing it through the <code>StaticResource</code> markup extension, using the <code>"</code><code>recipeIngredientTemplate"</code> key.</p>
<p class="callout-heading">Note</p>
<p class="callout">In .NET MAUI, if you bind a collection without assigning a specific <code>DataTemplate</code>, the framework automatically invokes the <code>ToString</code> method of each object in the collection. The returned string value is what will be displayed on the screen.</p>
<p>With all of this <a id="_idIndexMarker429"/>in place, our app now shows a list of ingredients on the recipe’s detail page, where each ingredient is rendered using the defined <code>ItemTemplate</code>.</p>
<p>But what if not all items in a particular collection should be rendered the same way? Let’s see how we can choose a <code>DataTemplate</code> dynamically at runtime.</p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor107"/>Dynamically choosing a DataTemplate at runtime</h2>
<p>While ingredients are <a id="_idIndexMarker430"/>essential to a recipe app, not much can be done with the ingredients without a comprehensive set of cooking instructions. So, let’s bring these instructions to life within our app! In addition to the essential steps, a list of instructions may also include valuable cooking tips and additional information to enhance the cooking experience. Let’s explore how we can incorporate these cooking instructions, along with any accompanying notes, into our <em class="italic">Recipes!</em> app.</p>
<h3>Defining cooking instructions and notes</h3>
<p>In our app, we <a id="_idIndexMarker431"/>use <code>InstructionViewModel</code> and <code>NoteViewModel</code> for cooking instructions and notes, respectively. <code>InstructionViewModel</code> has <code>Index</code> and <code>Description</code> properties, while <code>NoteViewModel</code> has just a <code>Note</code> property. Both are grouped under a common parent, <code>InstructionBaseViewModel</code>, and stored in a list called <code>Instructions</code> in <code>RecipeDetailViewModel</code>.</p>
<p>For now, this list is initialized with some cooking instructions and a tip for creating a Caesar salad.</p>
<p>If we want to<a id="_idIndexMarker432"/> show this list, which contains both instructions and notes, on the screen, we would need a mechanism that would allow us to use a different <code>ItemTemplate</code>, depending on the type. Let’s see how a <code>DataTemplateSelector</code> can achieve this!</p>
<h3>Creating a DataTemplateSelector</h3>
<p>With a <code>DataTemplateSelector</code>, we can<a id="_idIndexMarker433"/> write code that determines what <code>DataTemplate</code> to use at runtime. Writing a <code>DataTemplateSelector</code> is pretty straightforward. Let’s have a look at how we can build one:</p>
<ol>
<li>In the <code>TemplateSelectors</code> by right-clicking the <strong class="bold">Recipes.Mobile</strong> project and selecting <strong class="bold">Add</strong> | <strong class="bold">New Folder</strong>.</li>
<li>Next, right-click this newly added folder, select <code>InstructionsDataTemplateSelector</code> as the name.</li>
<li>For our class to function as a <code>DataTemplateSelector</code>, it needs to inherit from <code>Microsoft.Maui.Controls.DataTemplateSelector</code>, as shown in the following snippet:<pre class="source-code">
public class InstructionsDataTemplateSelector <strong class="bold">:</strong>
<strong class="bold">  DataTemplateSelector</strong>
{
    <strong class="bold">protected override DataTemplate</strong>
<strong class="bold">      OnSelectTemplate(object item, BindableObject</strong>
<strong class="bold">        container)</strong> { }
}</pre></li> </ol>
<p>Inheriting from the <code>DataTemplateSelector</code> class requires overriding the abstract <code>OnSelectTemplate</code> method. This method is invoked at runtime to select the appropriate <code>DataTemplate</code> and takes two parameters:</p>
<ul>
<li><code>item</code> (of type <code>object</code>) is the object we want to display, such as a <code>NoteViewModel</code> or <code>InstructionViewModel</code> item in our app</li>
<li><code>container</code> (of type <code>BindableObject</code>) refers to the layout element that holds the collection, such as <code>VerticalStackLayout</code> in our example</li>
</ul>
<p>Using these parameters, the <code>OnSelectTemplate</code> method in a <code>DataTemplateSelector</code> assists you in selecting the appropriate <code>DataTemplate</code> for a given item. In our specific scenario, the method will determine the template based solely on the type of the passed-in item.</p>
<p>Let’s introduce two properties to <code>InstructionsDataTemplateSelector</code>. These two properties, <code>NoteTemplate</code> and <code>InstructionTemplate</code>, dictate which <code>DataTemplate</code> the <code>DataTemplateSelector</code> should return based on the type of the passed-in item parameter. Specifically, if it is a <code>NoteViewModel</code>, the <code>OnSelectTemplate</code> method should return <code>NoteTemplate</code>. Conversely, if it’s an <code>InstructionViewModel</code>, <code>InstructionTemplate</code> will be returned. Let’s explore how to accomplish this:</p>
<ol>
<li>Add the following properties to <code>InstructionsDataTemplateSelector</code>:<pre class="source-code">
public DataTemplate NoteTemplate { get; set; }
public DataTemplate InstructionTemplate { get; set; }</pre></li> <li>The following code block shows how we can implement the <code>OnSelectTemplate</code> method so that it checks the type of the given item and returns the<a id="_idIndexMarker434"/> appropriate <code>DataTemplate</code>:<pre class="source-code">
protected override DataTemplate OnSelectTemplate
  (object item, BindableObject container)
{
    if (item is InstructionViewModel)
        return InstructionTemplate;
    else if(item is NoteViewModel)
        return NoteTemplate;
    return null;
}</pre><p class="list-inset">If the given item isn’t an <code>InstructionViewModel</code> or <code>NoteViewModel</code> item, <code>null</code> is returned. As a result, the value returned by the object’s <code>ToString</code> method will be rendered, which is the same behavior when not providing a <code>DataTemplateSelector</code>.</p></li> </ol>
<p>That’s it <a id="_idIndexMarker435"/>for <code>InstructionsDataTemplateSelector</code>. Let’s see how we can use this <code>DataTemplateSelector</code> to show both instructions and notes in the app.</p>
<h3>Showing instructions and notes on the screen</h3>
<p>Now that the <a id="_idIndexMarker436"/>data is in place as well as the <code>DataTemplateSelector</code> that we want to use, we need to do a few things in XAML to display the recipe’s instructions and notes:</p>
<ol>
<li>Let’s start by thinking about how we want to represent a <code>InstructionViewModel</code> in the app. Here’s a template that we could add to the <code>RecipeDetailPage’s</code> resources for that data type:<pre class="source-code">
&lt;ContentPage.Resources&gt;
...
    &lt;DataTemplate <strong class="bold">x:Key="instructionTemplate"</strong>
      x:DataType="vms:InstructionViewModel"&gt;
        &lt;VerticalStackLayout Spacing="10"&gt;
            &lt;Label FontSize="20" Text="{Binding Index,
             StringFormat='{0:D2}.', Mode=OneTime}" /&gt;
            &lt;Label Margin="10,0" Text="{Binding
              Description, Mode=OneTime}" /&gt;
        &lt;/VerticalStackLayout&gt;
    &lt;/DataTemplate&gt;
&lt;/ContentPage.Resources&gt;</pre><p class="list-inset">The <code>DataTemplate</code> for an <code>InstructionViewModel</code> defines how we want to visualize this type of item: showing the <code>Index</code> property with the <code>Description</code> below it.</p><p class="list-inset">Note that we’ve given the <code>DataTemplate</code> a key (<code>instructionTemplate</code>) that we can use later on to reference this specific template.</p></li> <li>Let’s add a <code>DataTemplate</code> for the <code>NoteViewModel</code> items as well. The following<a id="_idIndexMarker437"/> code block shows a <code>DataTemplate</code> for visualizing such items:<pre class="source-code">
&lt;DataTemplate <strong class="bold">x:Key="noteTemplate"</strong> x:DataType=
  "vms:NoteViewModel"&gt;
    &lt;Grid Margin="20,0" ColumnDefinitions="35,*"&gt;
        &lt;Label
            FontFamily="MaterialIconsRegular"
            FontSize="20" Text="&amp;#xe873;"
            TextColor="LightSlateGray" /&gt;
        &lt;Label
            Grid.Column="1" FontAttributes="Italic"
            Text="{Binding Note, Mode=OneTime}"
            TextColor="LightSlateGray" /&gt;
    &lt;/Grid&gt;
&lt;/DataTemplate&gt;</pre><p class="list-inset">By using this <code>DataTemplate</code>, we can visualize notes by showing an icon –  for which we use the <code>MaterialIconsRegular</code> font – followed by the note itself. Both are in a specific color so that there is a clear distinction between notes and instructions. As before, we’ve given the <code>DataTemplate</code> a specific key (<code>noteTemplate</code>) so that we can reference it later on.</p></li> <li>Next, let’s add an <code>InstructionsDataTemplateSelector</code> to <code>RecipeDetailPage</code>. Start by adding said <code>DataTemplateSelector</code>’s namespace as an XML namespace to the page, as shown here:<pre class="source-code">
xmlns:selectors="clr-namespace:Recipes
  .Mobile.TemplateSelectors"</pre><p class="list-inset">Once this is in place, we can add an instance of the <code>InstructionsDataTemplateSelector</code> class to the page’s <code>Resources</code>, as <a id="_idIndexMarker438"/>shown in the following snippet:</p><pre class="source-code">&lt;selectors:InstructionsDataTemplateSelector
    x:Key="instructionDataTemplateSelector"
    InstructionTemplate="{StaticResource
      instructionTemplate}"
    NoteTemplate="{StaticResource noteTemplate}" /&gt;</pre><p class="list-inset">The <code>StaticResource</code> markup extension is used to reference the two <code>DataTemplate</code>s that we created earlier to assign them to the respective properties of this <code>InstructionsDataTemplateSelector</code>. Just like we did with the individual <code>DataTemplate</code>, we’ve given this instance of the <code>InstructionsDataTemplateSelector</code> a key (<code>instructionDataTemplateSelector</code>) that we can use later on to reference it.</p></li> <li>To display the list of instructions, we can add a <code>VerticalStackLayout</code> near the bottom of <code>RecipeDetailPage</code>. The following code snippet demonstrates this setup:<pre class="source-code">
&lt;VerticalStackLayout Padding="10"&gt;
    &lt;Label FontAttributes="Italic,Bold"
        FontSize="16" Text="Instructions" /&gt;
    &lt;VerticalStackLayout
        Margin="0,10" Spacing="10"
<strong class="bold">        </strong><strong class="bold">BindableLayout.ItemsSource="{Binding</strong>
<strong class="bold">          Instructions}"</strong>
<strong class="bold">        BindableLayout.ItemTemplateSelector=</strong>
<strong class="bold">          "{StaticResource instruction</strong>
<strong class="bold">            DataTemplateSelector}"</strong>/&gt;
&lt;/VerticalStackLayout&gt;
Instructions</strong> property of our ViewModel to the <code>BindableLayout</code> <code>ItemsSource</code> property. Additionally, by<a id="_idIndexMarker439"/> using the <code>StaticResource</code> markup extension and the key we used in the resource dictionary for our <code>DataTemplateSelector</code>, we set the <code>ItemTemplateSelector</code> property. The result is shown in <em class="italic">Figure 6</em><em class="italic">.2</em>:</pre></li> </ol>
<div><div><img alt="Figure 6.2: Showing instructions and notes" height="521" src="img/B20941_06_02.jpg" width="397"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2: Showing instructions and notes</p>
<p>With that, we’ve<a id="_idIndexMarker440"/> explored how to leverage <code>DataTemplate</code>s and a <code>DataTemplateSelector</code> to visualize instructions and notes within our <em class="italic">Recipes!</em> app. By defining separate <code>DataTemplate</code>s and using a <code>DataTemplateSelector</code>, we can dynamically choose the appropriate template for each item in the collection, providing a customized and intuitive display of cooking instructions and additional notes.</p>
<p>Now that we have successfully implemented the visualization of instructions and notes, let’s move on to handling empty collections.</p>
<h3>Handling empty collections</h3>
<p>Besides<a id="_idIndexMarker441"/> the <code>ItemsSource</code> and <code>ItemTemplate</code> properties, <code>BindableLayout</code> also has <code>EmptyView</code> and <code>EmptyViewTemplate</code> properties. These properties allow us to define what to show if the provided <code>ItemsSource</code> is empty or null.</p>
<p>The <code>EmptyView</code> property can be a string value or a <code>View</code>. So, in its simplest form, we could add the following to a <code>VerticalStackLayout</code> to show the shopping list:</p>
<pre class="source-code">
&lt;VerticalStackLayout
    <strong class="bold">BindableLayout.EmptyView="Nothing to see here"</strong>
    ... &gt;</pre> <p><code>"Nothing to see here"</code> is shown on the screen when the bound <code>ItemSource</code> contains no items.</p>
<p>Or, if we want to have <a id="_idIndexMarker442"/>more control over the appearance of what is shown when the collection is empty, we could also do the following:</p>
<pre class="source-code">
&lt;VerticalStackLayout
    ...&gt;
        <strong class="bold">&lt;BindableLayout.EmptyView&gt;</strong>
<strong class="bold">            &lt;Label Text="Nothing to see here"</strong>
<strong class="bold">                FontAttributes="Bold" /&gt;</strong>
<code>EmptyViewTemplate</code>, we can specify a <code>DataTemplate</code> that needs to be shown when the bound collection is empty or null. This means that in this template, you can bind to values on the parent UI element or any other accessible context within the UI hierarchy. This flexibility enables you to create dynamic and context-aware empty views that can display relevant information or provide interactive elements based on the available data context.</p>
<p>As we saw earlier, data binding and the <code>INotifyPropertyChanged</code> interface allow the UI to stay in sync with the data on ViewModels, ensuring automatic updates. However, when it comes to dynamically adding or removing items from collections, the binding engine alone will not automatically reflect these changes in the UI. To achieve this kind of behavior, we need to explore the <code>ICollectionChanged</code> interface.</p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor108"/>The ICollectionChanged interface</h1>
<p>The <code>ICollectionChanged</code> interface<a id="_idIndexMarker443"/> provides a powerful mechanism for notifying the UI about changes in a collection itself, rather than on individual items within the collection. By implementing this interface, a collection can raise events that inform the binding engine and UI elements about structural changes, such as additions, removals, or modifications to the collection itself.</p>
<p>While it is possible to assign an updated list of items to a property on your ViewModel and trigger the <code>PropertyChanged</code> event, dynamically changing a collection requires a more optimal approach. By utilizing a collection that implements the <code>INotifyCollectionChanged</code> interface, we can achieve more efficient rendering of the UI. Instead of needing to re-render the entire collection on the UI, the binding engine can perform updates in a more optimized manner, resulting in improved performance and responsiveness.</p>
<p>The <code>ICollectionChanged</code> interface defines the <code>CollectionChanged</code> event, which is raised whenever the collection undergoes a structural change. This event provides detailed information about the type of change that occurred, such as whether an item was added, removed, or modified, and the position at which the change occurred. Let’s see what this means in terms of binding modes.</p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor109"/>The ICollectionChanged interface and binding modes</h2>
<p>To use this interface as efficiently as possible, it’s very important to understand how different binding modes affect this behavior.</p>
<h3>OneTime binding</h3>
<p>When using <code>OneTime</code> binding, the<a id="_idIndexMarker444"/> UI will perfectly update when items inside the collection change. However, there’s a caveat: if a new instance is assigned to the property holding the collection, this change won’t reflect in the UI. In such cases, instead of assigning a new instance, we need to clear the existing collection and add the new items to it. Importantly, the property setter should not trigger the <code>NotifyPropertyChanged</code> event as it’s unnecessary for <code>OneTime</code> binding.</p>
<h3>OneWay binding</h3>
<p><code>OneWay</code> binding<a id="_idIndexMarker445"/> might offer more flexibility, allowing you to replace the collection with a new instance and reflect this in the UI. In this mode, make sure the property setter calls the <code>NotifyPropertyChanged</code> event to update the UI. While <code>OneWay</code> binding allows for greater flexibility, replacing an entire collection can be resource-intensive, requiring the UI to re-render the collection. This is especially important to consider when dealing with large datasets. If only a few items change, modifying the existing collection is often more efficient than replacing it.</p>
<p>By understanding these subtleties, you can make more informed decisions on what data binding mode to use.</p>
<p>Let’s put this into action and add some functionality to the <em class="italic">Recipes!</em> app by leveraging the <code>ObservableCollection</code> class.</p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor110"/>Using the ObservableCollection</h2>
<p>The <code>ObservableCollection</code> class is a <a id="_idIndexMarker446"/>specialized collection class provided by .NET that implements the <code>ICollectionChanged</code> interface out of the box.</p>
<p>Let’s enhance the functionality of our <em class="italic">Recipes!</em> app by introducing a <code>Shopping List</code> feature. We want to provide users with the ability to add ingredients from the list of recipe ingredients to a separate <code>Shopping List</code>. To achieve this, we will associate a button with each ingredient in the list. When the user taps the button, the corresponding ingredient will be added to an <code>ObservableCollection</code> named <code>ShoppingList</code>. As a result, the UI will be automatically updated each time an ingredient is added or removed from the list:</p>
<ol>
<li>Let’s start by adding an additional property, <code>ShoppingList</code>, of type <code>Observable</code><strong class="source-inline">
Collection&lt;RecipeIngredientViewModel&gt;</strong> to <code>RecipeDetailViewModel</code>:<pre class="source-code">
public ObservableCollection&lt;RecipeIngredientViewModel&gt;
ShoppingList { get; } = new();</pre><p class="list-inset">We are automatically assigning a new instance to this property, which makes perfect sense: the instance of this property will not change as we will be adding and removing items from the collection. As <code>ObservableCollection</code> implements the <code>IObservableCollection</code> interface, the UI will remain in sync as the <code>CollectionChanged</code> event will be triggered when we manipulate the collection.</p></li> <li>Currently, we<a id="_idIndexMarker447"/> don’t have functionality for managing items in the <code>ShoppingList</code> collection. So, let’s add the following to <code>RecipeDetailViewModel</code>:<pre class="source-code">
public IRelayCommand AddToShoppingListCommand { get; }
public IRelayCommand RemoveFromShoppingListCommand 
{ get; }
private void AddToShoppingList(
  RecipeIngredientViewModel viewModel)
{
    if (ShoppingList.Contains(viewModel))
        return;
    ShoppingList.Add(viewModel);
}
private void RemoveFromShoppingList
  (RecipeIngredientViewModel viewModel)
{
    if (ShoppingList.Contains(viewModel))
        ShoppingList.Remove(viewModel);
}</pre><p class="list-inset">The <code>AddToShoppingList</code> method will be <a id="_idIndexMarker448"/>responsible for adding an instance of <code>RecipeIngredientViewModel</code> to the <code>ShoppingList</code> collection if the given ViewModel isn’t already in there. The <code>RemoveFromShoppingList</code> method, on the other hand, will remove the item from <code>ShoppingList</code>.</p><p class="list-inset">For both <a id="_idIndexMarker449"/>methods, we’ve also created two corresponding commands, which we need to instantiate in the constructor of <code>RecipeDetailViewModel</code>, as shown here:</p><pre class="source-code">public RecipeDetailViewModel()
{
    ...
    AddToShoppingListCommand = new RelayCommand
      &lt;RecipeIngredientViewModel&gt;(AddToShoppingList);
    RemoveFromShoppingListCommand = new RelayCommand
      &lt;RecipeIngredientViewModel&gt;
         (RemoveFromShoppingList);
}</pre></li> <li>Next, add the following XAML to the <code>VerticalStackLayout</code> that shows the ingredients of the recipe:<pre class="source-code">
&lt;VerticalStackLayout Padding="10"&gt;
    &lt;Label ...
        Text="Ingredients list" /&gt;
    ...
    &lt;VerticalStackLayout Margin="10,0" Padding="10"&gt;
        &lt;Label
            FontAttributes="Italic,Bold"
            FontSize="16" Text="Shopping list" /&gt;
        &lt;VerticalStackLayout
            Margin="0,10" Spacing="10"
            <strong class="bold">BindableLayout.ItemsSource="{Binding</strong>
<strong class="bold">              </strong><strong class="bold">ShoppingList, Mode=OneTime}"</strong>
<strong class="bold">            BindableLayout.EmptyView="Nothing added"</strong>&gt;
        &lt;/VerticalStackLayout&gt;
    &lt;/VerticalStackLayout&gt;
&lt;/VerticalStackLayout&gt;</pre><p class="list-inset">Below the list <a id="_idIndexMarker450"/>of ingredients, we’ve added a label with the text <code>"Shopping list"</code>, followed by another <code>VerticalStackLayout</code>. The <code>ShoppingList</code> property is bound to the <code>BindableLayout.ItemsSource</code> property. We’ve added an <code>EmptyView</code> property that will be shown when no items are on the list.</p><p class="list-inset">The <code>ItemTemplate</code>, which will be rendered for each item in <code>ShoppingList</code>, will be added in a few steps.</p></li> <li>Let’s add a <code>Button</code> to the <code>ItemTemplate</code> of the <code>VerticalStackLayout</code> showing the ingredients. The <code>Button</code>’s <code>Command</code> should be bound to the <code>AddToShoppingListCommand</code> on the <code>RecipeDetailViewModel</code> as shown here:<pre class="source-code">
&lt;HorizontalStackLayout Spacing="5"&gt;
    <strong class="bold">&lt;Button</strong>
<strong class="bold">        Command="{Binding AddToShoppingListCommand,</strong>
<strong class="bold">          Source={RelativeSource AncestorType={x:Type</strong>
<strong class="bold">            vms:RecipeDetailViewModel}}}"</strong>
<strong class="bold">    CommandParameter="{Binding}"</strong>
<strong class="bold">    FontFamily="MaterialIconsRegular"</strong>
<strong class="bold">    Text="&amp;#xe854;" /&gt;</strong>
    &lt;Label
        FontAttributes="Bold"
        FontSize="16" VerticalOptions="Center"
        Text="{Binding IngredientName,
          StringFormat='{0}:'}" /&gt;
    ...
&lt;/HorizontalStackLayout&gt;</pre><p class="list-inset">The <code>Button</code>’s <code>Command</code> property is bound to the <code>AddToShoppingListCommand</code> on the <code>RecipeDetailViewModel</code>. As the <code>Button</code>’s <code>BindingContext</code> is the current <code>RecipeIngredientViewModel</code>, we need to use relative binding to point to the <code>RecipeDetailViewModel</code>. <code>CommandParameter</code> is data bound by just defining <code>{ Binding }</code>. This will bind it to the binding context of the UI element itself, which is the current <code>RecipeIngredientViewModel</code>. As a result, the <code>RecipeIngredientViewModel</code> instance is passed to the <code>AddShoppingList</code> method, allowing us to add it to the <code>ShoppingList</code> collection.</p></li> <li>Finally, we can <a id="_idIndexMarker451"/>define the <code>ItemTemplate</code> of the <code>ShoppingList</code> items. We can copy the <code>DataTemplate</code> of the <code>"Ingredients list"</code>. However, we need to update the <code>Button</code> to this:<pre class="source-code">
<strong class="bold">&lt;Button</strong>
<strong class="bold">    Command="{Binding RemoveFromShoppingListCommand,</strong>
<strong class="bold">      Source={RelativeSource AncestorType={x:Type</strong>
<strong class="bold">        vms:RecipeDetailViewModel}}}"</strong>
<strong class="bold">    CommandParameter="{Binding}"</strong>
<strong class="bold">    FontFamily="MaterialIconsRegular"</strong>
<code>Button</code> has a different icon and has its <code>Command</code> bound to <code>RemoveFromShoppingListCommand</code>, allowing the user to remove an ingredient again from the list.</p></li> </ol>
<p>With everything in place, users <a id="_idIndexMarker452"/>can now add ingredients from <code>"Ingredients list"</code> to <code>"Shopping list"</code>, from which items can also be removed again. Here’s what it looks like:</p>
<div><div><img alt="Figure 6.3: Shopping list" height="340" src="img/B20941_06_03.jpg" width="379"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3: Shopping list</p>
<p>By using <code>ObservableCollection</code> – or any collection that implements <code>IObservableCollection</code> – it becomes very easy and efficient to keep a list of objects in sync with the UI.</p>
<p class="callout-heading">Don’t overuse ObservableCollection</p>
<p class="callout">It is important to use <code>ObservableCollection</code> judiciously in your application. This specialized collection should be utilized when the collection itself dynamically changes, such as when items are added or removed, and the UI needs to reflect those changes. However, if the collection is fixed or assigned to a property in its entirety, there is no need to use <code>ObservableCollection</code>.</p>
<p>As we mentioned <a id="_idIndexMarker453"/>earlier, using <code>BindableLayout</code> is very easy to use and is perfect for showing small collections. For more advanced scenarios, there is <code>CollectionView</code>. Let’s have a look at it!</p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor111"/>Working with CollectionView</h1>
<p><code>CollectionView</code> is an <a id="_idIndexMarker454"/>advanced control specifically designed for efficiently displaying large amounts of data. It offers all the properties available in <code>BindableLayout</code>, such as <code>ItemsSource</code>, <code>ItemTemplate</code>, <code>ItemTemplateSelector</code>, <code>EmptyView</code>, and <code>EmptyViewTemplate</code>. Additionally, <code>CollectionView</code> provides a wealth of powerful features, including item grouping, header and footer support, item selection and highlighting, item virtualization, and incremental loading of data as the user scrolls. These features enable you to create highly interactive and engaging user interfaces while efficiently managing and presenting your data. Item virtualization ensures that only the visible items are rendered, optimizing performance and memory usage, especially for large collections.</p>
<p class="callout-heading">Other specialized controls</p>
<p class="callout">Aside from <code>CollectionView</code>, there are other specialized controls, such as <code>CarouselView</code> and <code>ListView</code>, for displaying collections in .NET MAUI. These controls also support <code>ItemsSource</code> binding and allow you to define an <code>ItemTemplate</code> or <code>DataTemplateSelector</code>. Each comes with a unique set of features and use cases, but the basic principles of data binding remain similar.</p>
<p>Now, let’s explore a simple example of using <code>CollectionView</code>. In our <code>RecipesOverviewViewModel</code>, we expose an <code>ObservableCollection</code> of <code>RecipeListItemViewModel</code>s called <code>Recipes</code>. Each <code>RecipeListItemViewModel</code> represents a recipe and contains a subset of properties relevant to displaying it on an overview page, such as the recipe’s ID, title, image, and favorite status. While the recipe’s ID may not be necessary for direct display on the screen, it is valuable for identifying the selected item for navigation purposes or implementing features such as “favoriting” an item from the list. For our app to start on <code>RecipesOverviewPage</code>, we need to update the <code>AppShell.xaml</code> file, as shown in the following snippet:</p>
<pre class="source-code">
&lt;ShellContent <code>AppShell.xaml</code> file, as shown earlier, and don’t worry about it.</p>
<p>To display the recipes in <code>RecipesOverviewPage</code>, we can use <code>CollectionView</code>. The <code>ItemsSource</code> property of <code>CollectionView</code> is bound to the <code>Recipes</code> property of the <code>RecipesOverviewViewModel</code> class, which serves as the page’s <code>BindingContext</code>. Similar to <code>BindableLayout</code>, we define the <code>ItemTemplate</code> property to specify how each item in the collection should be rendered. The following code snippet demonstrates this setup:</p>
<pre class="source-code">
&lt;CollectionView
    ItemsSource="{Binding Recipes}"&gt;
    &lt;CollectionView.ItemTemplate&gt;
        &lt;DataTemplate&gt;
            ...
        &lt;/DataTemplate&gt;
    &lt;/CollectionView.ItemTemplate&gt;
&lt;/CollectionView&gt;</pre> <p>The usage of <code>CollectionView</code> should feel familiar if you have worked with <code>BindableLayout</code> before. You can copy the <code>DataTemplate</code> class from <code>BindableLayout</code> and it will show up the same.</p>
<p>Now, let’s leverage one of <a id="_idIndexMarker455"/>the more powerful features of <code>CollectionView</code>: data grouping. Let’s explore how to effectively display grouped data.</p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor112"/>Displaying grouped data</h2>
<p>Grouping data in a collection is a <a id="_idIndexMarker456"/>powerful way to organize and present information in a meaningful and structured manner. By grouping related items, you can provide intuitive navigation and enhance the user experience. <code>CollectionView</code> allows us to easily display grouped data and provides both <code>GroupHeaderTemplate</code> and <code>GroupFooterTemplate</code> properties. These templates allow us to define what’s being displayed above and below a group of items. <em class="italic">Figure 6</em><em class="italic">.4</em> illustrates how a list of grouped items is rendered with group headers and footers:</p>
<div><div><img alt="Figure 6.4: Group headers and footers" height="511" src="img/B20941_06_04.jpg" width="427"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4: Group headers and footers</p>
<p><code>RecipeRatingDetailPage</code>, which <a id="_idIndexMarker457"/>can be accessed by tapping on the rating information on <code>RecipeDetailPage</code>, should show all the ratings of a recipe grouped by the number of stars. Let’s walk through the steps needed to set this up:</p>
<ol>
<li>While <code>RecipeRatingsDetailViewModel</code> already contains a list of all the reviews of a recipe, it doesn’t group the data yet. First, let’s create a class for holding a group of ratings. In the <code>RatingGroup</code> as its name.</li>
<li>The <code>RatingGroup</code> class inherits from <code>List&lt;UserReviewModel&gt;</code> and has an additional property called <code>Key</code>. Here’s what it looks like:<pre class="source-code">
public class RatingGroup : List&lt;UserReviewViewModel&gt;
{
    public string Key { get; private set; }
    public RatingGroup(string key,
        List&lt;UserReviewViewModel&gt; reviews) :
          base(reviews)
    {
        Key = key;
    }
}</pre><p class="list-inset">This class serves as a specialized list for holding <code>UserReviewViewModel</code> objects. It inherits from <code>List&lt;UserReviewViewModel&gt;</code>, meaning it can do anything a regular list can do, such as holding multiple <code>UserReviewViewModel</code> items. In addition to that, the class includes an extra property called <code>Key</code>. This property is used to group the user reviews by some criteria, such as a rating or a category.</p></li> <li>Next, add a <code>GroupedReviews</code> property to <code>RecipeRatingsDetailViewModel</code>. This property is of type <code>List&lt;RatingGroup&gt;</code>. It holds groups of reviews that are organized based on the number of stars. Each <code>RatingGroup</code> in the list will contain reviews that share<a id="_idIndexMarker458"/> the same number of stars, which is represented by the <code>Key</code> property. The following snippet shows this newly added property and how it gets initialized in the constructor:<pre class="source-code">
List&lt;RatingGroup&gt; _groupedReviews = new();
public List&lt;RatingGroup&gt; GroupedReviews
{
    get =&gt; _groupedReviews;
    private set =&gt; SetProperty(ref _groupedReviews,
      value);
}
public RecipeRatingsDetailViewModel(...)
{
   ...
    Reviews = new() { ... };
    GroupedReviews = Reviews.GroupBy(r =&gt;
      Math.Round(r.Rating / .5) * .5)
        .OrderByDescending(g =&gt; g.Key)
        .Select(g =&gt; new RatingGroup(g.Key.ToString(),
          g.ToList()))
        .ToList();
}</pre><p class="list-inset">In the constructor, we <a id="_idIndexMarker459"/>have grouped all the reviews by their rating, rounded to 0.5. We use this grouping to create a list of <code>RatingGroups</code> items that we assign to the <code>GroupedReviews</code> property.</p></li> <li>Now, we can bind the <code>GroupedReviews</code> property to the <code>CollectionView</code> on <code>RecipeRatingDetailPage</code>. When binding a grouped collection, we also need to make sure the <code>IsGrouped</code> property of <code>CollectionView</code> is set to true, as the following snippet shows:<pre class="source-code">
&lt;CollectionView
        IsGrouped="True"
        ItemsSource="{Binding GroupedReviews}"&gt;
...
&lt;/CollectionView&gt;</pre></li> <li>As we did previously, we<a id="_idIndexMarker460"/> should be defining an <code>ItemTemplate</code> to declare how each item should be rendered. Once that is in place, <code>CollectionView</code> renders all the items but there isn’t a clear distinction between the different groups yet.</li>
<li>So, let's add <code>GroupHeaderTemplate</code> and <code>GroupFooterTemplate</code> to clearly distinguish the different groups. The following code block demonstrates how this can be done:<pre class="source-code">
&lt;CollectionView.GroupHeaderTemplate&gt;
    &lt;DataTemplate x:DataType="{x:Type
      vms:RatingGroup}"&gt;
        &lt;Label
            Margin="0,25,0,0" FontSize="16"
            Text="{Binding Key, StringFormat='{0}
              stars Reviews'}" /&gt;
    &lt;/DataTemplate&gt;
&lt;/CollectionView.GroupHeaderTemplate&gt;
&lt;CollectionView.GroupFooterTemplate&gt;
    &lt;DataTemplate x:DataType="{x:Type
      vms:RatingGroup}"&gt;
        &lt;Label FontSize="12" Text="{Binding Count,
          StringFormat='{0} reviews'}" /&gt;
    &lt;/DataTemplate&gt;
&lt;/CollectionView.GroupFooterTemplate&gt;</pre><p class="list-inset">The <code>BindingContext</code> of these templates is an instance of <code>RatingGroup</code>, allowing us to bind to its properties, such as <code>Key</code> and <code>Count</code>. With this, we can make the groupings visually clear to the user.</p></li> </ol>
<p>Grouping <a id="_idIndexMarker461"/>data in <code>CollectionView</code> allows for a more organized and structured presentation of information, as shown in <em class="italic">Figure 6</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 6.5: Grouping data" height="495" src="img/B20941_06_05.jpg" width="435"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5: Grouping data</p>
<p>By leveraging the <code>GroupHeaderTemplate</code> and <code>GroupFooterTemplate</code> properties, you can enhance the user experience and provide intuitive navigation within your app.</p>
<p>Not only can <code>CollectionView</code> render your data, it also offers various interactive features to engage users with your app. From selecting items to incrementally loading data and other common functionalities, let’s discover how to get the most out of this powerful control, by keeping MVVM principles in mind.</p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor113"/>Selecting items</h2>
<p>When working<a id="_idIndexMarker462"/> with <code>CollectionView</code>, you have various options for selecting items and managing the selection state. By binding the <code>SelectedItem</code> property, you can easily track the currently selected item in your ViewModel. Additionally, you can bind the <code>SelectedItems</code> property to a collection in your ViewModel to track multiple selected items. The <code>SelectionMode</code> property allows you to define whether single or multiple items can be selected or whether or not selecting items is disabled. You can use the <code>SelectionChangedCommand</code> property to bind a command in your ViewModel that will be executed when the selection changes or handle the <code>SelectionChanged</code> event, allowing you to implement flexible and interactive item selection behavior in your app.</p>
<p>Let’s see how we can <a id="_idIndexMarker463"/>allow the user to select one or more reviews, allowing the user to report inappropriate reviews, for example:</p>
<ol>
<li>Add the following property to <code>RecipeRatingsDetailViewModel</code>:<pre class="source-code">
public ObservableCollection&lt;object&gt; SelectedReviews 
{ get; } = new();</pre><p class="list-inset">This property will hold the items that the user has selected on the <code>CollectionView</code>. Note that this <code>ObservableCollection</code> uses <code>object</code> as its type parameter, rather than a more specific type. Though it’s not explicitly documented, using <code>object</code> appears to be the only way to successfully bind multiple selections in <code>CollectionView</code>.</p></li> <li>Now, let’s add a command called <code>ReportReviewsCommand</code> that can only be executed when one or more reviews are selected, as shown here:<pre class="source-code">
public RelayCommand ReportReviewsCommand { get; }
public RecipeRatingsDetailViewModel()
{
    ...
    ReportReviewsCommand = new
        RelayCommand(ReportReviews,
        () =&gt; SelectedReviews.Any());
}
private void ReportReviews()
{
    var selectedReviews = SelectedReviews
        .Cast&lt;UserReviewViewModel&gt;().ToList();
    //do reporting
    SelectedReviews.Clear();
}</pre></li> <li>As the <code>SelectedReviews</code> property is an <code>ObservableCollection</code>, we can listen to the <code>CollectionChangedEvent</code> and call the <code>ReportReviewsCommand</code>’s <code>NotifyCanExecuteChanged</code> method. That way the <code>ReportReviewsCommand</code>’s <code>CanExecute</code> method gets re-evaluated. The following snippet<a id="_idIndexMarker464"/> shows how to implement this:<pre class="source-code">
public RecipeRatingsDetailViewModel()
{
.   ...
    SelectedReviews.CollectionChanged +=
        SelectedReviews_CollectionChanged;
}
private void SelectedReviews_CollectionChanged(object?
  sender, NotifyCollectionChangedEventArgs e)
=&gt; ReportReviewsCommand.NotifyCanExecuteChanged();</pre></li> <li>Update the <code>CollectionView</code> on <code>RecipeRatingDetailPage</code> so that its <code>SelectedItems</code> property is bound to the <code>SelectedReviews</code> property. We also need to set the<a id="_idIndexMarker465"/> appropriate <code>SelectionMode</code>, as shown here:<pre class="source-code">
&lt;CollectionView
    IsGrouped="True"
    ItemsSource="{Binding GroupedReviews}"
    <strong class="bold">SelectedItems="{Binding SelectedReviews}"</strong>
    <strong class="bold">SelectionMode="Multiple"</strong>&gt;</pre></li> </ol>
<p>By adding this code, the items the user selects on the UI will be added to the <code>SelectedReviews</code> list, while selected items that the user de-selects will be removed from it. The <code>ReportReviews</code> method, we can easily access the <code>SelectedReviews</code> property to see what items have been selected.</p>
<p>As a final example, let’s look at how we can bind the <code>SelectedItem</code> and <code>SelectionChangedCommand</code> properties to trigger something such as navigation. Let’s take a look at how to implement this on <code>RecipesOverviewPage</code>:</p>
<ol>
<li>On <code>RecipesOverviewPage</code>, update the <code>CollectionView</code> and bind its <code>SelectedItem</code> and <code>SelectionChangedCommand</code> properties, like this:<pre class="source-code">
&lt;CollectionView
    ...
    SelectedItem="{Binding SelectedRecipe,
      Mode=TwoWay}"
    SelectionChangedCommand="{Binding
      NavigateToSelectedDetailCommand}"
    SelectionMode="Single"&gt;</pre><p class="list-inset">The <code>SelectedItem</code> property is bound <code>TwoWay</code> to the <code>SelectedRecipe</code> property and <code>SelectionChangedCommand</code> is bound to <code>NavigateToSelectedDetailCommand</code>. Both properties will be added shortly. Also, the <code>SelectionMode</code> property is set to <code>"Single"</code>, allowing the user to select one item in the list.</p></li> <li>Now, let’s add the<a id="_idIndexMarker466"/> two properties mentioned earlier to <code>RecipeOverviewViewModel</code>. Here’s what they look like:<pre class="source-code">
RecipeListItemViewModel? _selectedRecipe;
public RecipeListItemViewModel? SelectedRecipe
{
    get =&gt; _selectedRecipe;
    set =&gt; SetProperty(ref _selectedRecipe, value);
}
public AsyncRelayCommand NavigateTo
  SelectedDetailCommand { get; }</pre></li> <li>The following snippet shows how the command is instantiated in the constructor of the ViewModel:<pre class="source-code">
public RecipesOverviewViewModel()
{
...
    NavigateToSelectedDetailCommand = new
      AsyncRelayCommand(NavigateToSelectedDetail);
}</pre><p class="list-inset">Because this command is bound to the <code>SelectionChangedCommand</code> of the <code>CollectionView</code>, it will get triggered when an item is selected or de-selected.</p></li> <li>The following code <a id="_idIndexMarker467"/>block shows the <code>NavigateToSelectedDetail</code> method:<pre class="source-code">
private Task NavigateToSelectedDetail()
{
    if (SelectedRecipe is not null)
    {
        //ToDo navigate to selected item
        SelectedRecipe = null;
    }
    return Task.CompletedTask;
}</pre></li> </ol>
<p>When the user selects an item in <code>CollectionView</code>, the <code>SelectedRecipe</code> property on the ViewModel will be updated. Next, <code>NavigateToSelectedDetailCommand</code> will be executed, which will call the <code>NavigateToSelectedDetail</code> method. In this method, we can access the <code>SelectedRecipe</code> property and act upon it, such as navigating to its detail page, for example. Finally, we set the <code>SelectedRecipe</code> property to null. As this property is bound <code>TwoWay</code>, the item will get de-selected in <code>CollectionView</code>. As a result, if we navigate back from <code>RecipeDetailPage</code>, no item will be selected on the overview and then we can immediately<a id="_idIndexMarker468"/> select another one.</p>
<p>Now, let’s have a look at how we can load data incrementally while the user scrolls through a large dataset.</p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor114"/>Incrementally loading data</h2>
<p>As the user scrolls through <a id="_idIndexMarker469"/>large datasets in <code>CollectionView</code>, providing a seamless and interactive user experience is crucial. The <code>RemainingItemsThreshold</code> and <code>RemainingItemsThresholdReachedCommand</code> properties allow you to effortlessly load additional items. By specifying a threshold value for the remaining items, new data is dynamically fetched and seamlessly loaded, ensuring a smooth and continuous experience. Let’s explore how to implement this interactive functionality in just a few simple steps:</p>
<ol>
<li>Add the following method to <code>RecipesOverviewViewModel</code>:<pre class="source-code">
private async Task TryLoadMoreItems()
{
    //Dummy implementation
    if (Recipes.Count &lt; TotalNumberOfRecipes)
    {
        await Task.Delay(250);
        foreach (var item in items)
        {
            Recipes.Add(item);
        }
    }
}</pre><p class="list-inset">This method adds items to the <code>Recipes</code> <code>ObservableCollection</code> class as it has fewer items than what’s defined in the <code>TotalNumberOfRecipes</code> property. It’s a pretty dumb implementation, but it should get the point across. In a real-life<a id="_idIndexMarker470"/> scenario, we would fetch this data from an API or something. We’ll look at this in <a href="B20941_10.xhtml#_idTextAnchor165"><em class="italic">Chapter 10</em></a>, <em class="italic">Working with </em><em class="italic">Remote Data</em>.</p></li> <li>Next, let’s add a command called <code>TryLoadMoreItemsCommand</code>. This is the command that should be invoked when we want to load more items. We want to instantiate it in the constructor of <code>RecipesOverviewViewModel</code>, as shown here:<pre class="source-code">
<strong class="bold">public AsyncRelayCommand TryLoadMoreItemsCommand </strong>
<strong class="bold">{ get; }</strong>
public RecipesOverviewViewModel()
{
    Recipes = new ObservableCollection
      &lt;RecipeListItemViewModel&gt;(items);
    <strong class="bold">TryLoadMoreItemsCommand = new AsyncRelayCommand</strong>
<strong class="bold">      (TryLoadMoreItems);</strong>
}</pre></li> <li>Now, we can update the <code>CollectionView</code> and add both <code>RemainingItemsThreshold</code> and <code>RemainingItemsThresholdReachedCommand</code>, as shown in the following <a id="_idIndexMarker471"/>code block:<pre class="source-code">
&lt;CollectionView
    ItemsSource="{Binding Recipes}"
    <strong class="bold">RemainingItemsThreshold="5"</strong>
    <strong class="bold">RemainingItemsThresholdReachedCommand="{Binding</strong>
<strong class="bold">      TryLoadMoreItemsCommand}"</strong>
    ...&gt;</pre><p class="list-inset">With this code in place, <code>TryLoadMoreItemsCommand</code> will be invoked as soon as the user scrolls and the number of remaining items reaches the specified threshold of five or less. The <code>TryLoadMoreItems</code> method will then add items to the <code>Recipes</code> <code>ObservableCollection</code>. Because this method implements the <code>ICollectionChanged</code> interface, the added items will be automatically added to <code>CollectionView</code>.</p></li> </ol>
<p>Incrementally loading data is a good idea when dealing with very large datasets and <code>CollectionView</code> makes it extremely convenient<a id="_idIndexMarker472"/> to implement using the <code>RemainingItemsThreshold</code> and <code>RemainingItemsThresholdReachedCommand</code> properties.</p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor115"/>Other common interactions</h2>
<p>In addition to the<a id="_idIndexMarker473"/> features we’ve discussed, it’s worth mentioning that common interactions such as pull-to-refresh and item context menus are also available in .NET MAUI. These interactions allow users to refresh the data that’s displayed in the collection and access additional actions or information specific to each item. While they are used on collections very often, it’s important to note that these features are not exclusive to <code>CollectionView</code> and can be implemented anywhere in your application.</p>
<p><code>SwipeView</code> is a<a id="_idIndexMarker474"/> versatile control that allows you to add swipe gestures to individual items in a collection. It enables users to perform actions by swiping horizontally or vertically on an item, such as deleting an item or revealing additional options.</p>
<p><code>RefreshView</code>, on<a id="_idIndexMarker475"/> the other hand, is a control that provides a standard pull-to-refresh functionality. It allows users to refresh the data that’s displayed in a collection by pulling down on the screen. When triggered, <code>RefreshView</code> executes a command to update the collection with fresh data.</p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor116"/>Summary</h1>
<p>In this chapter, we explored the powerful features and capabilities of collections in .NET MAUI. We learned how to effectively bind collections to UI elements using <code>BindableLayout</code> and <code>CollectionView</code>, enabling dynamic and efficient rendering of data. We covered topics such as data templating, item selection, grouping, and incremental loading. <code>CollectionView</code> proved to be a versatile control, offering advanced functionality such as item virtualization and seamless data loading.</p>
<p>As we continue our journey in building robust and scalable apps, in the next chapter, we will delve into the important concepts of dependency injection, services, and messaging. These fundamental aspects of app development will empower us to create modular and maintainable code, enhance code reusability, and enable effective communication between different parts of our application.</p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor117"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li><code>BindableLayout</code>: <a href="https://learn.microsoft.com/en-us/dotnet/maui/user-interface/layouts/bindablelayout">https://learn.microsoft.com/en-us/dotnet/maui/user-interface/layouts/bindablelayout</a></li>
<li><code>CollectionView</code>: <a href="https://learn.microsoft.com/dotnet/maui/user-interface/controls/collectionview">https://learn.microsoft.com/dotnet/maui/user-interface/controls/collectionview</a></li>
<li><code>ListView</code>: <a href="https://learn.microsoft.com/dotnet/maui/user-interface/controls/listview">https://learn.microsoft.com/dotnet/maui/user-interface/controls/listview</a></li>
<li><code>CarouselView</code>: <a href="https://learn.microsoft.com/dotnet/maui/user-interface/controls/carouselview">https://learn.microsoft.com/dotnet/maui/user-interface/controls/carouselview</a></li>
<li><code>SwipeView</code>: <a href="https://learn.microsoft.com/dotnet/maui/user-interface/controls/swipeview">https://learn.microsoft.com/dotnet/maui/user-interface/controls/swipeview</a></li>
<li><code>RefreshView</code>: <a href="https://learn.microsoft.com/dotnet/maui/user-interface/controls/refreshview">https://learn.microsoft.com/dotnet/maui/user-interface/controls/refreshview</a></li>
</ul>
</div>
</div>

<div><div><h1 id="_idParaDest-116" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor118"/>Part 2: Building a .NET MAUI App Using MVVM</h1>
<p>In this part, we focus on equipping you with the essential tools and techniques needed to craft a genuine .NET MAUI application that leverages the MVVM pattern. We will dive into the core mechanisms such as dependency injection, services, and messaging, which form the backbone of any robust app. We will help you master MVVM-based navigation in .NET MAUI with or without Shell, refine user interactions with precise input and validation, and connect seamlessly with remote data sources.</p>
<p>This part has the following chapters:</p>
<ul>
<li><a href="B20941_07.xhtml#_idTextAnchor119"><em class="italic">Chapter 7</em></a>, <em class="italic">Dependency Injection, Services, and Messaging</em></li>
<li><a href="B20941_08.xhtml#_idTextAnchor132"><em class="italic">Chapter 8</em></a>, <em class="italic">.NET MAUI Shell and Navigation</em></li>
<li><a href="B20941_09.xhtml#_idTextAnchor148"><em class="italic">Chapter 9</em></a>, <em class="italic">Handling User Input and Validation</em></li>
<li><a href="B20941_10.xhtml#_idTextAnchor165"><em class="italic">Chapter 10</em></a>, <em class="italic">Working with Remote Data</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</div></body></html>