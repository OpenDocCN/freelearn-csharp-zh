- en: '*Chapter 9*: Working with Data in .NET 6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the essential components for any application is the ability to persist
    data to a permanent data store; some forethought in picking the right persistent
    store can help a system scale better in the future.
  prefs: []
  type: TYPE_NORMAL
- en: One of the common operations in any application is to log in to the system,
    perform some reads/updates, log off, and then come back later to see whether the
    changes were retained. Databases play a significant role in persisting these actions,
    which are typically called **user transactions**. Apart from transactional data,
    for monitoring and debugging purposes, an application may additionally need to
    store logging data and auditing data, such as who modified the date. An important
    step for designing any such application is to understand the requirements and
    design the database accordingly. It's also important to choose/design a database
    according to various data retention requirements and any data protection policies,
    such as the **General Data Protection Regulation** (**GDPR**).
  prefs: []
  type: TYPE_NORMAL
- en: 'There can be multiple data providers for an application, such as a **Structured
    Query Language** (**SQL**) data provider, NoSQL data provider, and file data provider.
    In this chapter, we will discuss various data providers that can be used for storage
    and data handling in .NET 6\. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disk, files, and directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL, Azure Cosmos DB, and Azure Storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with EF Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a Data Access service using Azure Cosmos DB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A basic understanding of .NET Core, C#, Azure, and the .NET **command-line interface**
    (**CLI**) is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found at the following link: [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter08).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The instructions for the code can be found here: [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any web application, be it a content management system, social networking platform,
    or e-commerce application, needs to persist data to a permanent store so that
    users can retrieve, consume, and process data as needed. In [*Chapter 8*](B18507_08_Epub.xhtml#_idTextAnchor714),
    *All You Need to Know about Caching*, we discussed using cache stores; however,
    cache stores are temporary storage and data still needs to be persisted in permanent
    storage. So, we need a store that not only supports various **Create/Read/Update/Delete**
    (**CRUD**) operations on different entities but also supports high availability
    and recovers any data in case of an outage, that is, disaster recovery.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key criteria for better system design is to have a data model designed
    at an early stage of the system. The data model should try to define all the possible
    entities that are required for the system to function and interact between various
    entities. Having a data model defined early on in the system design helps in identifying
    the right strategies on how to manage data and what data store can be used, and
    in deciding various replication/partition strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Two commonly classified data stores are explained in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Relational database management system (RDBMS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Relational databases store data in tables. Each entity is defined as one or
    more tables and a database is defined using multiple tables. The process of segregating
    tables into multiple tables is called **normalization**. The relations between
    various tables are defined by foreign key constraints. Properties of entities
    are defined as columns, and multiple entities of the same type are stored as rows.
    Some commonly used relational databases are Microsoft SQL Server, MySQL, PostgresSQL,
    and Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical relational database to store employee information could possibly
    have an `employee` table defining various properties of employees, such as name,
    employee ID, and so on, and columns with employee ID as the primary key. Multiple
    employees are stored in separate rows in this table. Any properties of employees
    can further be normalized into a separate table; for example, an employee''s projects
    can be stored in a separate table (as there can be more than one project), say,
    `employeeproject`, and can be linked to the `employee` table using the employee
    ID, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Employee ER diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.1_18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – Employee ER diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are a few key characteristics of the relational database:'
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases are queried using SQL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tables mostly have a well-defined schema and constraints and are less likely
    to change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the transactions have **Atomicity/Consistency/Isolation/Durability** (**ACID**)
    properties, hence maintaining the data integrity and consistency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As data is normalized, redundancy is minimized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational databases usually support vertical scaling, that is, scaling up (they
    do support replication, but it is an expensive operation compared to replication
    in NoSQL databases).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NoSQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another kind of data store is NoSQL databases, which store data in an unstructured
    format where the data doesn't need to have a predefined schema. Most commonly,
    data is either stored as a key-value pair (such as in Redis), stored as a document
    (such as in MongoDB and CouchDB), or stored as a graph using a graph structure
    (for example, in Neo4j).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take the same employee example and persist it in a NoSQL database, such
    as MongoDB, we will end up storing it in something such as an `employee` collection,
    with each document storing all the properties of the employee, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are a few key characteristics of NoSQL databases:'
  prefs: []
  type: TYPE_NORMAL
- en: Entities do not necessarily need to support a fixed schema and, at any point
    in time, additional properties can be added.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are a good fit for unstructured data, for example, storing the location
    in a ride-sharing app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can easily support horizontal scaling at a much lower cost compared to
    relational databases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data is highly redundant; however, that gives a significant performance boost,
    as data is readily available without performing joins across tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Cosmos DB is one such cloud-managed NoSQL database that we will use in
    our e-commerce application as a data store.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the various storage options in detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: SQL, Azure Cosmos DB, and Azure Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, we talked about the broader classification of data stores into RDBMSs
    and NoSQL. In this section, let's get into the details of some of the data providers
    available in the Microsoft ecosystem and their integration with .NET 6\. There
    is a wide variety of providers, including SQL, Azure Cosmos DB, and Azure Storage,
    and the selection of data providers is completely driven by the application needs.
    However, in real life, application requirements evolve quite a bit, so the key
    is to abstract your data framework implementation with the business layer and
    **user interface** (**UI**), which further helps in evolving the design as required.
    With that, let's look at our first data provider, SQL, in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the dominant databases in the RDBMS market is Microsoft SQL Server, popularly
    known as SQL Server, which uses SQL to interact with the database. SQL Server
    supports all the RDBMS-based entities, such as tables, views, stored procedures,
    and indexes, and primarily works on the Windows environment. However, from SQL
    Server 2017 onward, it supports both Windows and Linux environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary component of SQL Server is its database engine, which takes care
    of processing queries and managing data in files. Apart from the database engine,
    SQL Server comes with various data management tools, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SQL Server Management Studio** (**SSMS**): To connect to SQL Server and perform
    operations such as creating a database, monitoring a database, querying databases,
    and backing up databases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQL Server Integration Service** (**SSIS**): For data integration and transformation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQL Server Analysis Services** (**SSAS**): For data analysis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQL Server Reporting Services** (**SSRS**): For reporting and visualization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To configure SQL Server on a local machine, we need to install one of the editions
    of SQL Server that installs the database engine and one or more preceding components.
    Installation typically involves downloading the installer and installing it either
    through the **graphical user interface** (**GUI**) or command line. For more details
    on installation, refer to [https://docs.microsoft.com/en-us/sql/database-engine/install-windows/install-sql-server?view=sql-server-ver15](https://docs.microsoft.com/en-us/sql/database-engine/install-windows/install-sql-server?view=sql-server-ver15).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: There are also other editions of SQL Server such as the Developer edition and
    Express edition, which are lightweight and free and can be downloaded from [https://www.microsoft.com/en-in/sql-server/sql-server-downloads](https://www.microsoft.com/en-in/sql-server/sql-server-downloads).
  prefs: []
  type: TYPE_NORMAL
- en: Although on-premises, SQL Server has been widely used; there is always overhead
    to managing databases, upgrades, and so on, and that's where Microsoft has come
    up with Azure SQL, which is a fully managed **Platform as a Service** (**PaaS**)
    component that runs on the same database engine as on-premises SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure SQL comes with the following variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure SQL Database (single database)**: This is a managed database server
    that allows you to create a fully isolated database with dedicated resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure SQL Database (elastic pool)**: Elastic pool allows you to run multiple
    single databases in a predefined pool of resources (in terms of CPU, memory, and
    **input/output** (**I/O**)) on a single server. It is ideal for businesses that
    have multiple databases with a mix of low and high usage. The advantage of using
    an elastic pool in such situations is that a database that needs more CPU usage
    can utilize it during high demand and release it when demand is low. The ideal
    situation to use an elastic pool is when there is a set of databases and their
    consumption is unpredictable. Anytime you see a database consistently consuming
    the same set of resources, it can be moved out of the elastic pool into a single
    database and vice versa.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure SQL Managed Instance**: This model provides a way for the seamless
    migration of on-premises SQL infrastructure to Azure SQL without re-architecting
    the on-premises applications and allows you to take advantage of PaaS. This is
    ideal for applications that have huge on-premises database infrastructure and
    need to migrate to the cloud without too much operational overhead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQL Server on VM (Windows/Linux)**: SQL VMs come under the **Infrastructure
    as a Service** (**IaaS**) category and are very similar to on-premises SQL Server,
    except that VMs are on Azure instead of your local network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It's recommended to install SSMS for performing various operations on SQL Server
    (on-premises or the cloud), as it supports all the database operations. There
    is also Azure Data Studio, which is lightweight and can connect to on-premise
    or cloud SQL Server and can be downloaded from [https://docs.microsoft.com/en-us/sql/azure-data-studio/download-azure-data-studio?view=sql-server-ver15](https://docs.microsoft.com/en-us/sql/azure-data-studio/download-azure-data-studio?view=sql-server-ver15).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: From a .NET 6 application standpoint, connecting to Azure SQL is the same as
    connecting to on-premises SQL Server. You can use ADO.NET, which we import using
    `System.Data.SqlClient` and then use the `SqlConnection` object to connect to
    SQL; then, use the `SqlCommand` object to execute the SQL query and the `SQLReader`
    class to return the values. Apart from this, we can use an **object-relational
    mapping** (**ORM**) such as **Entity Framework Core** (**EF Core**) to work with
    Azure SQL, which is discussed in the *Working with EF Core* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this section, we have briefly covered Azure SQL. However, I would recommend
    reviewing all the functionality of Azure SQL here: [https://docs.microsoft.com/en-us/azure/azure-sql/](https://docs.microsoft.com/en-us/azure/azure-sql/).
    For more samples please refer to [https://github.com/microsoft/sql-server-samples](https://github.com/microsoft/sql-server-samples).'
  prefs: []
  type: TYPE_NORMAL
- en: With this, let's move on to Azure Cosmos DB, the database our e-commerce application
    will use as a persistent store.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Cosmos DB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Azure Cosmos DB is a fully managed (PaaS) NoSQL, globally distributed, and highly
    scalable database. One of the key things about Azure Cosmos DB is its multi-modeled
    nature, which helps in passing data in various formats, such as JSON and BSON,
    using different API models, such as SQL, MongoDB, and Gremlin. Developers have
    the flexibility to query the database using the API they are comfortable with.
    For example, SQL developers can continue to query the database using SQL query
    syntax, MongoDB developers can continue to query the database using MongoDB syntax,
    and so on. Under the hood, Azure Cosmos DB stores the database in a format known
    as **atom-record-sequence** (**ARS**) and exposes data as an API depending on
    the mode selected during the creation of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing about Azure Cosmos DB is its capability to automatically
    index all the data, independent of the API model that is used. All this happens
    without developers additionally creating an index, so enabling the faster retrieval
    of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure Cosmos DB supports the following APIs to perform operations on the database,
    which we choose while creating the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SELECT * FROM product WHERE product.Name = '' Mastering enterprise application
    development Book''`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.product.find({"Name": '' Mastering enterprise application development Book''})`.
    Just like MongoDB, data is represented in BSON.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gremlin (graph) API**: This API supports using the Gremlin language to query
    and traverse data in graph format. This is ideal for situations where data can
    be represented in the form of a graph and can be queried through their relationships.
    A typical example can be a recommendation engine that can establish the relationship
    between two entities and come up with a recommendation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from these, there is the Cassandra API, which uses the **Cassandra Query
    Language** (**CQL**) to operate on databases, and then the Table API, which can
    be used by applications built on top of Azure Table storage as their data store.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, there are quite a number of APIs and more are getting added.
    Choosing the right API depends purely on the application requirements; however,
    the following few points can be used to narrow down the choice:'
  prefs: []
  type: TYPE_NORMAL
- en: If it's a new application, go with the Core (SQL) API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it's an existing application built on NoSQL, choose the relevant API based
    on the underlying data store. For example, if the existing database is MongoDB,
    choose the Mongo API, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For handling a specific scenario, such as establishing relationships between
    data, go with the Gremlin API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our enterprise application, since we are building this application from
    scratch, we will go with the Core (SQL) API as our API to interact with Azure
    Cosmos DB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple console application to start with and perform a few
    operations on Azure Cosmos DB, and we will later reuse these concepts in building
    our Data Access service:'
  prefs: []
  type: TYPE_NORMAL
- en: To start with, we need to have an Azure Cosmos DB account, so sign in to the
    Azure portal, click **Create resource**, and select **Databases** | **Azure Cosmos
    DB**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will open the **Create Azure Cosmos DB Account** page. Fill in the details
    as shown in the following screenshot and click **Review + create**. This is the
    page where we select the API we want to choose, which is the Core (SQL) API in
    our case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Create Azure Cosmos DB Account page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.2_18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – Create Azure Cosmos DB Account page
  prefs: []
  type: TYPE_NORMAL
- en: Once the account is created, navigate to **Azure Cosmos DB Account** | **Keys**.
    Copy the **URI** and **PRIMARY KEY** values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the command line and create a console application by using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the `EcommerceSample` folder and install the Azure Cosmos DB SDK
    using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this stage, we can open the folder in VS Code. Once we open the folder in
    VS Code, it will look as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.3 – EcommerceSample in VS Code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.3_18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – EcommerceSample in VS Code
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `Program.cs` and add the following static variables to the `Program` class
    that will hold the **URI** and **PRIMARY KEY** values that were copied in *Step
    3*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s add code to create an object of the `CosmosClient` class and use
    that to create an Azure Cosmos DB database. Subsequently, this object will be
    used to communicate with our Azure Cosmos DB database. As `CosmosClient` implements
    `IDisposable`, we will create it inside a `using` block so that the object can
    be disposed of automatically after the `using` block. Once you run this code and
    navigate to `Ecommerce` will be created. As we have created our Azure Cosmos DB
    account using the Core (SQL) API, this database will support querying in SQL syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s create a container that is analogous to a table in SQL by adding
    the following code after `createDatabaseResponse`. As we are using `CreateDatabaseIfNotExistsAsync`
    to create the database, running the same code will not cause any exceptions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we run this code, we can see in the Azure portal that a container with
    the name `Products` is created under the `Ecommerce` database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Products container'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.4_18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – Products container
  prefs: []
  type: TYPE_NORMAL
- en: A container is a unit in Azure Cosmos DB that is horizontally partitioned and
    replicated across multiple regions. In the preceding code, we have passed `ContainerProperties`
    while creating a container, and you can see that one of the values is `Name`,
    which is nothing but a partition key.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning is one of the key features of Azure Cosmos DB that segregates data
    within a container into multiple logical partitions based on the partition key,
    that is, all the items with the same partition key are part of the same logical
    partition. Using a partition key, Azure Cosmos DB achieves horizontal scaling
    of the database, therefore, satisfying the scalability and performance needs of
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Choosing a partition key is a key design decision, as it will significantly
    help the database to scale and better perform. Also, the partition key cannot
    be changed and has to be defined during the creation of the container. The following
    few points can be kept in mind when choosing the partition key:'
  prefs: []
  type: TYPE_NORMAL
- en: It should have a maximum number of unique values; the higher the number of unique
    values, the better the partitioning will be. For example, if we are creating a
    container for products, the product ID or name could be the partition key as these
    two attributes can uniquely identify most products. Under the hood, if a product
    name is chosen for the partition key and there are 100 products internally, it
    is represented by 100 logical containers in Azure Cosmos DB. Here, the product
    category can also be a partition key but, before choosing that as the partition
    key, we need to evaluate the sample data and decide based on the requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is no obvious unique choice, we can pick the most used field in the
    filtering query, so basically, a column that is very often used in the `where`
    clause.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In real-world applications, the creation of an Azure Cosmos DB account should
    be implemented using ARM templates or using Terraform so that templates can be
    easily integrated with **continuous deployment** (**CD**).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With this, let''s add some data to our product container and query it:'
  prefs: []
  type: TYPE_NORMAL
- en: We will add this entity based on the following sample JSON. Based on the product
    category, there could be different attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, if the product category is `Books`, there would be values in fields
    such as `Authors` and `Format`; however, if the category is `Clothing`, there
    would be values for fields such as `Size` and `Color`. This schema could be reused
    in our e-commerce application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create `Product`. One of the mandatory fields for any entity in
    Azure Cosmos DB with the Core (SQL) API is the `id` field, which is something
    like a primary key. So, it is necessary for our parent models to define the `id`
    field. These classes would look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s create the following object of the `Product` class and insert it
    into the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will call the `CreateItemAsync` method using the `productContainer`
    object, as shown in the following code snippet. (There are other ways to retrieve
    records from the database, one of which is shown in the next point.) Also, we
    should ensure that an object with the same `ProductId` value isn''t already present:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once we run this code, data should be inserted into the `Ecommerce` database
    under the `Products` container.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to query this record other than the way mentioned in the previous
    point, we can use the following code to query the database. As you can see, the
    syntax is very similar to querying data from a SQL database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, `ContainerClass` provides all the relevant methods that can be used
    for various CRUD operations. All those APIs can be found here: [https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.cosmos.container?view=azure-dotnet](https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.cosmos.container?view=azure-dotnet).'
  prefs: []
  type: TYPE_NORMAL
- en: With this foundation, we will design the data model required for our e-commerce
    application and the relevant data service layer to be consumed by various APIs.
    Up to now, we have seen SQL and NoSQL providers. Let's see what other options
    we have to persist data.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Azure Storage is a highly available and scalable data store that supports storing
    data in various formats, including files. Primarily, Azure Storage supports the
    following four types of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure Table**: A NoSQL implementation that supports persisting schemaless
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Blob**: Blobs are unstructured data that are suitable for applications
    that have lots of files to upload, download, or stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Queue**: This allows you to queue a message in any serializable format
    and can then be processed by a service. Queues are ideal for scenarios that have
    lots of service-to-service communication and act as a persistent layer for messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Files/Azure Disk**: A data store for files and ideal for systems that
    are built on native file APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are a few points that make Azure Storage one of the important
    components of application development:'
  prefs: []
  type: TYPE_NORMAL
- en: '**High availability**: Data stored in Azure Storage gives out-of-the-box support
    for replication across data centers/regions, which further ensures that hardware
    failure in one region doesn''t result in losing data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Out-of-the-box support for CDN integration that helps to cache
    and load data (especially static files) from locations (edge servers) closer to
    the user and further improves the performance. In addition to this, the storage
    type can be upgraded to premium storage, which takes advantage of SSDs to further
    speed up disk I/O and improve performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fully managed**: Hardware is fully managed by Azure for any updates/maintenance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: All the data stored on disks is encrypted and access to the data
    in Azure Storage further supports private, public, and anonymous modes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pay as you go**: Just like all other Azure services, Azure Storage also supports
    a pay-as-you-go model based on the size of the data/operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Storage accounts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s create a simple console application that uploads a file to Blob and
    downloads the file from Blob. To communicate with Azure Storage services, the
    prerequisite is to create an Azure Storage account that provides access to all
    Azure Storage services and gives us access to the data stored in Azure Storage
    over HTTP/HTTPS by a unique namespace to Azure Storage. To create an Azure Storage
    account, take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sign in to the Azure portal, click **Create resource**, and select **Storage
    Account**. This will open the **Create storage account** page. Fill in the details
    as shown in the following screenshot and click **Review + create**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Creating an Azure Storage account'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.5_18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.5 – Creating an Azure Storage account
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two important properties **Account Kind** and **Replication** for
    Standard tier. For **Account Kind****,** we have the following possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**StorageV2 (general purpose v2)**: The latest version of the account type,
    which gives access to all storage types, such as files, blobs, and queues. This
    is preferable for newly created storage accounts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage (general purpose v1)**: An older version of the account type, which
    gives access to all storage types, such as files, blobs, and queues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BlobStorage**: An account type that only supports blob storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The other is **Replication**, which supports replication of the storage data
    across data centers/regions. Possible values are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Replication options in an Azure Storage account'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.6_18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.6 – Replication options in an Azure Storage account
  prefs: []
  type: TYPE_NORMAL
- en: Once the account is created, navigate to **Storage Account** | **Keys**. Copy
    the **Connection String** value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new .NET 6 console application and install the `Azure.Storage.Blobs`
    NuGet package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To upload content to Azure Storage, we need to first create a container. We
    will make use of the `Azure.Storage.Blobs.BlobContainerClient` class and its `CreateIfNotExistsAsync`
    method to create the container if it doesn''t exist. With this, update the `Program`
    class, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to upload the file to the container for which we will make use
    of `Azure.Storage.Blobs.BlobClient`, which takes the connection string, container
    name, and blob name as input parameters. For this sample, we are uploading a local
    `sample.png` file to the blob, which we will read using the `FileStream` class,
    and pass it to the `UploadAsync` method of the `Azure.Storage.Blobs.BlobClient`
    class. Add the following code snippet after container creation in the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the sample at this stage will upload the file to the blob and display
    the blob URL in the command line. However, if we try to access the URL, it won''t
    be accessible as the blob created is private. To access private blobs, we need
    to generate a `Main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are using the `Azure.Storage.Sas.BlobSasBuilder` class to configure
    various parameters, such as permissions and the expiry time, to generate a SAS
    URI for the uploaded file. Finally, the output of the preceding code is shown
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Blob upload output and Storage Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.7_18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.7 – Blob upload output and Storage Explorer
  prefs: []
  type: TYPE_NORMAL
- en: This is a small sample that makes use of Azure Storage for a file upload. This
    can be further enhanced as an API, which can eventually be used for file upload
    and download scenarios. For our e-commerce application, we will use Azure Blob
    to store the images of the products.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For more advanced concepts on Azure Storage and samples, refer to the following
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/storage/common/storage-account-overview](https://docs.microsoft.com/en-us/azure/storage/common/storage-account-overview)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/Azure/azure-sdk-for-net/tree/master/sdk/storage/Azure.Storage.Blobs/samples](https://github.com/Azure/azure-sdk-for-net/tree/master/sdk/storage/Azure.Storage.Blobs/samples)'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have discussed various data providers available in .NET
    6\. However, one important library that simplifies persisting data is EF. Let's
    see how to integrate EF in .NET 6 applications.
  prefs: []
  type: TYPE_NORMAL
- en: Working with EF Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EF Core is an ORM that is recommended for any ASP.NET Core 6 application that
    uses a relational database as the data store. Earlier, we saw how in ADO.NET,
    we must create `Connection`, `Command`, and `Reader` objects. EF simplifies this
    process by providing abstraction and allowing developers to write application
    code, and like any other ORM, EF helps in performing various operations on databases
    using the object model paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring EF Core is as simple as installing the required NuGet packages,
    injecting the required services in the `Program` class, and then using them wherever
    required. As part of this process, one of the key classes that needs to be defined
    is the database context, and that needs to inherit the `Microsoft.EntityFrameworkCore.DbContext`
    class. Let's see how we do that along with the remaining EF Core configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration and querying
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `DbContext` class in EF Core holds all the required abstraction for our
    application to communicate with the database, so a key setup that needs to be
    part of integrating EF Core is to define our application-specific context class.
    This class will primarily hold all the SQL tables/views in the form of public
    property of the `DbSet` type, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, `Employee` is the POCO class representing tables in our database. The
    application context class should have the parameterized constructor that accepts
    `DbContextOptions` or `DbContextOptions<T>` and passes it to the base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple web application based on Razor Pages and SQLite, and
    read data using EF Core. For this sample, we will take a simple employee database
    that holds employee details with the following data model using SQLite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Employee database model'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.8_18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.8 – Employee database model
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't worked in Razor Pages before, do not worry about that; it's a
    page-based framework that can be used to build data-driven applications in ASP.NET
    Core 6 and is covered in [*Chapter 11*](B18507_11_Epub.xhtml#_idTextAnchor1228),
    *Creating an ASP.NET Core 6 Web Application*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s now create our application as mentioned in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Razor Pages application using the following command from the command
    line, which will create a new Razor Pages application inside the `EmployeeEF`
    folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the `EmployeeEF` folder and open it in Visual Studio Code, and
    then install the following NuGet packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Microsoft.EntityFrameworkCore.Sqlite`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.EntityFrameworkCore.Design`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The former package is the EF Core provider for SQLite and the latter one is
    to be used to create a database based on C# POCOs using EF Core migrations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `Models` folder and add the necessary POCO classes as follows.
    These classes represent the database schema from *Figure 9.8*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, all the columns in the database table are represented as a property with
    relevant data types. For relationships such as a foreign key, a property of the
    child type is created (known as `ICollection`, while another property of the parent
    class type is created in the child class. For example, in the preceding code,
    this is represented in the `public Icollection<Address> Addresses` and `public
    Employee Employee` properties, which define the foreign key constraint between
    the `Employee` and `Address` tables. Any property named `ID` or `<class name>ID
    (EmployeeID)` is automatically considered a primary key. Constraints can be further
    defined using the Fluent API during `OnModelCreating` or using annotations in
    `System.ComponentModel.DataAnnotations`. For more examples and details on model
    creation, refer to [https://docs.microsoft.com/en-us/ef/core/modeling](https://docs.microsoft.com/en-us/ef/core/modeling).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a class that inherits from `Microsoft.EntityFrameworkCore.DbContext` and
    name it `EmployeeContext`. Add the following code that defines our database context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the connection string in `appsettings.json`. As we are using SQLite, specifying
    the filename in the data source should be good enough. However, this will change
    as per the provider:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, inject the database context class in the `Program` class so that it is
    available across the application. Here, we additionally pass connection strings
    and configure any additional options such as a retry policy and query logging:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are almost done with the EF Core setup. So now, let's create some sample
    data that can be used to seed the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that, we will create an extension method on our database context and call
    it during startup. Create a `DbContextExtension` static class and add the following
    code to it. This code does nothing but add a few records to the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `Program` class and add the following code that seeds data during
    application startup. Since this is for a development environment, we can check
    whether the environment is a development one and add it. As we are checking what''s
    on the employee table before inserting, multiple runs of the application will
    not overwrite the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run `dotnet build` in the VS Code terminal and fix any build errors. To
    generate a database from our models and populate the database, we need to install
    `dotnet-ef` either locally or globally and run the migration commands, as follows,
    in the VS Code terminal, which would generate the `Migrations` folder and then
    the `Employee.db` file, which is our SQLite database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, to read the `Employee` table, navigate to `Index.cshtml.cs` and paste
    the following code. Here, we are injecting `EmployeeContext` and then reading
    data from the employee table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update `Index.cshtml` with the following code, which loops through the employee
    records populated in the `Employees` property of `IndexModel` and displays them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we run this code, we can see the following output in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Employee app output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.9_18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.9 – Employee app output
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, there are additional methods available in the `DbContext` class,
    such as `Add()`, `Remove()`, and `Find()`, to perform various CRUD operations,
    and methods such as `FromSqlRaw()` to execute raw SQL queries or stored procedures.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very simple example, and its main purpose is to show the capabilities
    of EF Core for real-world applications. We can use a repository pattern with a
    generic repository holding all the CRUD methods and specific repositories to perform
    specialized queries on a table. Additionally, a unit of work pattern can be used
    for transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Code first versus database first
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous sample, we have newly created POCOs and generated a database
    out of them; this style of generating a database from POCOs is known as a **code-first
    approach**. As the definition suggests, we have our POCOs defined first and then
    the database is generated.
  prefs: []
  type: TYPE_NORMAL
- en: However, many times, especially during a migration scenario or in cases where
    there is a dedicated database team, we would need to generate POCOs out of database
    tables. EF Core supports such scenarios through the **database-first approach**,
    where models and the application database context class are generated from an
    existing database.
  prefs: []
  type: TYPE_NORMAL
- en: This process of generating POCOs from database models is known as `Scaffold-DbContext`
    command, which accepts various parameters, such as a database connection string
    and the name of the application database context class, and then generates all
    the required classes needed for EF Core.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the configuration remains the same as in the code-first approach.
    A sample scaffolding command with various parameters will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In this command, we are reading a database, `Employee.DB`, generating all the
    models inside `Namespace Api.Data.Models`, generating context inside `Api.Data/Abstraction`,
    and naming the context `EmployeeContext`. In database-first, the relationship
    between classes is defined using the Fluent API as opposed to annotations.
  prefs: []
  type: TYPE_NORMAL
- en: One thing here is every time we run this command, all the POCOs will be overwritten
    along with the application context class. Secondly, this command generates a context
    class with the `protected override void OnConfiguring(DbContextOptionsBuilder
    optionsBuilder)` method in it. This method is needed only if the context class
    needs to maintain the connection string and other EF Core options. However, in
    most real-world applications, the connection string is maintained in `appsettings.json`
    and EF Core is configured in the `Program` class, so this method can be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: This means there is a cleanup involved after each time we scaffold, and a better
    way to avoid any customization is to create a partial class for our application
    database context and do all the customization there, such as adding specific models
    for stored procedures or defining any application-specific constraints. This way,
    any time we scaffold an application, customization won't be overwritten, which
    still allows us to auto-generate classes from a database.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the database-first approach or code-first approach is completely up
    to the development team, as both approaches have pros and cons and there isn't
    any specific feature that is available in one but not in the other.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`Scaffold-DbContext` supports multiple parameters; for example, you can specify
    a schema for generating POCOs for a schema. For further reading, please refer
    to [https://docs.microsoft.com/en-us/ef/core/managing-schemas/scaffolding?tabs=dotnet-core-cli](https://docs.microsoft.com/en-us/ef/core/managing-schemas/scaffolding?tabs=dotnet-core-cli).'
  prefs: []
  type: TYPE_NORMAL
- en: With this understanding, let's create the Data Access service that we will use
    in our enterprise application in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a Data Access service using Azure Cosmos DB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As NoSQL databases are all about fast access and high scalability, the schema
    for NoSQL is denormalized and so there is a high possibility of data redundancy.
    Let''s map our requirements from [*Chapter 1*](B18507_01_Epub.xhtml#_idTextAnchor020),
    *Designing and Architecting the Enterprise Application*, to various entities.
    A quick refresher of various services from the architecture is shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Services in an e-commerce application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.10_18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.10 – Services in an e-commerce application
  prefs: []
  type: TYPE_NORMAL
- en: 'For easier understanding, we will represent entities in JSON before moving
    on to POCOs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Email` field is used as a partition key:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Name` field is used as a partition key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Id` field is used as a partition key:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Id` field is used as a partition key:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A combination of `Product` and `Order` is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – E-commerce database model''s Product and Order schema'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.11_18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.11 – E-commerce database model's Product and Order schema
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, all *1:N* relationships are handled by embedding the child
    item as an array. Similarly, the `Invoice` and `User` entities schema is as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – E-commerce database model''s Invoice and User schema'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.12_18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.12 – E-commerce database model's Invoice and User schema
  prefs: []
  type: TYPE_NORMAL
- en: 'In our enterprise application, [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application),
    we will have one service interacting with the Azure Cosmos DB database. This service
    comprises the following three projects, which are explained next:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Packt.Ecommerce.Data.Models`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.Ecommerce.DataStore`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.Ecommerce.DataAccess`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first project is `Packt.Ecommerce.Data.Models`, which is a .NET Standard
    2.1 library and comprises all of our POCOs to communicate with the database. As
    discussed earlier, all the POCOs will have a common `id` property and the other
    properties described in the JSON schema in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If sample JSON is available, we can make use of JSON in C# class generation
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: '`Packt.Ecommerce.DataStore` is a .NET Standard 2.1 library and is the repository
    layer that holds a generic repository and entity-specific repositories. An important
    class in this project is `BaseRepository`, which has the following methods, and
    each method calls the respective method of the `CosmosClient` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetAsync(string filterCriteria)`: This method gets records from a container
    based on `filterCriteria`. If `filterCriteria` is empty, all the records from
    that container are retrieved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetByIdAsync(string id, string partitionKey)`: This method helps in retrieving
    any record from a container by its ID and partition key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddAsync(Tentity entity, string partitionKey)`: This method allows us to insert
    a record into a container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ModifyAsync(Tentity entity, string partitionKey)`: This method allows us to
    `UPSERT` (modify if a record is present, otherwise, insert) a record in a container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RemoveAsync(string id, string partitionKey)`: This method allows the deletion
    of a record from a container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since, in Azure Cosmos DB, each record is uniquely identified by a combination
    of ID and partition key, all these methods accept a partition key along with `id`.
    Since this is a generic repository, the signature of the class would be the following,
    which allows us to pass any POCO for our application and perform CRUD operations
    on the corresponding container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'All these methods would require an object of `Microsoft.Azure.Cosmos.Continer`
    for which we create a `readonly` private member, which is initialized in the constructor
    of the class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Now, `CosmosClient` would be plumbed into the system through dependency injection
    and would be configured in the `static` class. As a best practice, it is recommended
    to have only one instance of `CosmosClient` in the lifetime of the application
    to better reuse connections, so we will be configuring it in our ASP.NET Core
    6 dependency injection container as a singleton. We will come to this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming back to the repository layer, `BaseRepository` is additionally inherited
    in the following concrete classes, with each repository representing a corresponding
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ProductRepository`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UserRepository`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrderRepository`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InvoiceRepository`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Taking the example of `ProductRepository`, it will have the following implementation,
    where we pass the singleton instance of `CosmosClient` and additional properties
    using the `Ioptions` pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: All the other repositories will follow a similar structure. Each repository
    will implement its own interface to support dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: These repositories will evolve as and when we progress with our application
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The next project is `Packt.Ecommerce.DataAccess`, which is a Web API project
    targeting .NET 6 and will primarily have all the controllers to expose our repositories.
    Each repository would be a *1:1* mapping with the corresponding controller. So,
    for example, there would be `ProductsController` exposing `ProductRepository`
    methods as a REST API. All the controllers will use constructor injection to instantiate
    their corresponding repositories. One important thing in `Packt.Ecommerce.DataAccess`
    is the configuration of the Azure Cosmos DB database. The design of various controllers
    would be very similar to the design of the `Packt.Ecommerce.Product` Web API,
    which is discussed in [*Chapter 10*](B18507_10_Epub.xhtml#_idTextAnchor1040),
    *Creating an ASP.NET Core 6 Web API*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, we will have a corresponding section in `appsettings.json`,
    which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For the local development environment, we will use **Manage User Secrets**,
    as explained here: [https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-6.0).
    We will set the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{`'
  prefs: []
  type: TYPE_NORMAL
- en: '`  "CosmosDB:AccountEndPoint": "", //Cosmos DB End Point`'
  prefs: []
  type: TYPE_NORMAL
- en: '`  "CosmosDB:AuthKey": "" //Cosmos DB Auth key`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: However, once the service is deployed, it should make use of Azure Key Vault,
    as explained in [*Chapter 6*](B18507_06_Epub.xhtml#_idTextAnchor473), *Configuration
    in .NET 6*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will define an extension class that will hold the dependency injection mapping.
    A snippet of that is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, all the repositories would be mapped. Then, we will configure this
    in the `Program` class, along with Azure Cosmos DB configuration, by adding the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Once we are done with the configuration, this service is ready for consumption
    in other services, such as `Products`, `Orders`, and `Invoice`. This library will
    have all the necessary REST APIs to perform CRUD operations on various entities.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the creation of a Data Access service that performs CRUD operations
    on various entities, and all the operations are exposed as APIs. This service
    will be called from all the other services that we will develop in [*Chapter 10*](B18507_10_Epub.xhtml#_idTextAnchor1040),
    *Creating an ASP.NET Core 6 Web API*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about various persistent options that are available
    in .NET 6, from APIs to work with files and directories to databases such as Microsoft
    SQL Server and Azure Cosmos DB.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about ORMs, their importance, and how EF Core can be used to
    build a persistence layer while working with Microsoft SQL Server. Along the way,
    we built a data access layer for our e-commerce application using the Azure Cosmos
    DB SDK. Some of the key takeaways are the design decisions we took between SQL
    versus NoSQL, and how we can abstract a data layer with application logic and
    a UI layer that will help you to build scalable enterprise applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the foundation of RESTful APIs and the
    internals of the ASP.NET Core 6 Web API, and further build various RESTful services
    for e-commerce applications.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Say you are migrating an existing web application to use EF Core; however, there
    isn't any change in the database schema and an existing one can be used as-is.
    What is the preferable mode to use EF Core?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Database-first
  prefs: []
  type: TYPE_NORMAL
- en: b. Code-first
  prefs: []
  type: TYPE_NORMAL
- en: c. Both
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: a**'
  prefs: []
  type: TYPE_NORMAL
- en: If we are building a recommendation system for our e-commerce application and
    we are using Azure Cosmos DB, what API is best recommended in this scenario?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. The Core (SQL) API
  prefs: []
  type: TYPE_NORMAL
- en: b. The Mongo API
  prefs: []
  type: TYPE_NORMAL
- en: c. The Cassandra API
  prefs: []
  type: TYPE_NORMAL
- en: d. The Gremlin (graph) API
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: d**'
  prefs: []
  type: TYPE_NORMAL
- en: I created a container in SQL API-based databases to store user profile information
    and defined `Email` as the partition key. My system has 100 unique emails. How
    many logical partitions will my container have?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. 1.
  prefs: []
  type: TYPE_NORMAL
- en: b. 0.
  prefs: []
  type: TYPE_NORMAL
- en: c. 100.
  prefs: []
  type: TYPE_NORMAL
- en: d. Azure Cosmos DB does not support logical partitions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: c**'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A few links to understand the topics of this chapter further are provided as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/ef/core/saving/transactions](https://docs.microsoft.com/en-us/ef/core/saving/transactions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/ef/core/performance/advanced-performance-topics](https://docs.microsoft.com/en-us/ef/core/performance/advanced-performance-topics)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/core/security/gdpr?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/security/gdpr?view=aspnetcore-6.0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://aws.amazon.com/products/databases/](https://aws.amazon.com/products/databases/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
