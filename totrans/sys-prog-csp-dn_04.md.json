["```cs\npublic delegate uint ThreadProc(IntPtr lpParameter);\n```", "```cs\n[DllImport(\"kernel32.dll\", SetLastError = true)]\npublic static extern IntPtr CreateThread(\n    IntPtr lpThreadAttributes,\n    uint dwStackSize,\n    ThreadProc lpStartAddress,\n    IntPtr lpParameter,\n    uint dwCreationFlags,\n    out uint lpThreadId\n);\n[DllImport(\"kernel32.dll\", SetLastError = true)]\npublic static extern bool CloseHandle(IntPtr hObject);\n[DllImport(\"kernel32.dll\", SetLastError = true)]\npublic static extern uint WaitForSingleObject(IntPtr\nhHandle, uint dwMilliseconds);\n```", "```cs\npublic uint MyThreadFunction(IntPtr lpParameter)\n{\n    for (int i = 0; i < 1000; i++)\n        Console.WriteLine(\"Unmanaged thread\");\n    return 0;\n}\n```", "```cs\npublic void DoWork()\n{\n    uint threadId;\n    var threadHandle = CreateThread(\n        IntPtr.Zero,\n        0,\n        MyThreadFunction,\n        IntPtr.Zero,\n        0,\n        out threadId\n    );\n    // Wait for the thread to be finished\n    WaitForSingleObject(threadHandle, 1000);\n    // Clean up\n    CloseHandle(threadHandle);\n}\n```", "```cs\nvoid MyThreadFunction()\n{\n    for (var i = 0; i < 1000; i++)\n        Console.WriteLine(\"Managed thread\");\n}\n```", "```cs\nvar myManagedThread = new Thread(MyThreadFunction);\nmyManagedThread.Start();\nmyManagedThread.Join();\n```", "```cs\nvar myHugeStackSize = 8 * 1024 * 1024; // 8 MB\nvar myManagedThread = new Thread(MyThreadFunction, myHugeStackSize);\n```", "```cs\ninternal record ThreadData(int LoopCounter);\n```", "```cs\nvoid MyThreadFunction(object? myObjectData)\n{\n    // Verify that we have a ThreadData object\n    if (myObjectData is not ThreadData myData)\n        throw new ArgumentException(\"Parameter is not a                     ThreadData object\");\n    // Get the thread ID\n    var currentThreadId = Thread.CurrentThread.ManagedThreadId;\n    // Write the data to the Console\n    Console.WriteLine(\n        $\"Managed thread in Thread {currentThreadId} \" +\n        $\"with loop counter {myData.LoopCounter}\");\n}\n```", "```cs\nfor (int i = 0; i < 100; i++)\n{\n    ThreadData threadData = new(i);\n    var newThread = new Thread(MyThreadFunction);\n    newThread.Start(threadData);\n}\nConsole.ReadKey();\n```", "```cs\nfor (int i = 0; i < 100; i++)\n{\n    ThreadData threadData = new(i);\n    ThreadPool.QueueUserWorkItem(MyThreadFunction, threadData);\n}\nConsole.ReadKey();\n```", "```cs\nTask myTask = Task.Run(() => { Console.WriteLine(\"Hello from the task.\"); });\nConsole.WriteLine(\"Main thread is done.\");\nConsole.ReadKey();\n```", "```cs\nTask myTask = Task.Run(DoWork);\nConsole.WriteLine(\"Main thread is done.\");\nConsole.ReadKey();\nreturn 0;\nvoid DoWork()\n{\n    Console.WriteLine(\"Hello from the task.\");\n}\n```", "```cs\nTask myTask = new Task(DoWork);\nmyTask.Start();\n```", "```cs\nvoid DoWork(int id)\n{\n    Console.WriteLine($\"call Id {id}.\");\n}\n```", "```cs\nTask myTask = new Task(() => DoWork(1));\nmyTask.ContinueWith((prevTask) => DoWork(2));\nmyTask.Start();\n```", "```cs\nvoid DoWork(int id)\n{\n    Console.WriteLine($\"call Id {id}, \" +\n                      $\"running on thread \" +\n                      $\"{Thread.CurrentThread.ManagedThreadId}.\");\n}\n```", "```cs\nConsole.WriteLine($\"Our main thread id =\n{Thread.CurrentThread.ManagedThreadId}.\");\nTask myTask = new Task(() => DoWork(1));\nmyTask.ContinueWith((prevTask) => DoWork(2));\nmyTask.Start();\n```", "```cs\nConsole.WriteLine($\"Our main thread id =\n{Thread.CurrentThread.ManagedThreadId}.\");\nint[] myIds = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\nParallel.ForEach(myIds, (i) => DoWork(i));\n```", "```cs\nusing static System.Threading.Thread;\nnamespace ExtensionLibrary;\npublic static class StringExtensions\n{\n    public static string Dump(this string message,         ConsoleColor printColor = ConsoleColor.Cyan)\n    {\n        var oldColor = Console.ForegroundColor;\n        Console.ForegroundColor = printColor;\n      Console.WriteLine($\"({CurrentThread.ManagedThreadId})\\t :         {message}\");\n        Console.ForegroundColor = oldColor;\n        return message;\n    }\n}\n```", "```cs\nusing ExtensionLibrary;\nDoWork();\n// The program is paused until DoWork is finished.\n// This is a waste of CPU!\n\"Just before calling the long-running DoWork()\"\n    .Dump(ConsoleColor.DarkBlue);\n\"Program has finished\".Dump(ConsoleColor.DarkBlue);\nConsole.ReadKey();\nvoid DoWork()\n{\n    \"We are doing important stuff!\".Dump(ConsoleColor.DarkYellow);\n    // Do something useful, then wait a bit.\n    Thread.Sleep(1000);\n}\n```", "```cs\nusing ExtensionLibrary;\n\"Just before calling the long-running DoWork()\"\n    .Dump(ConsoleColor.DarkBlue);\nawait DoWork();\n// The program is no longer paused until DoWork is finished.\n// This allows the CPU to keep working!\n\"Program has finished\".Dump(ConsoleColor.DarkBlue);\nConsole.ReadKey();\nasync Task DoWork()\n{\n    \"We are doing important stuff!\".Dump(ConsoleColor.DarkYellow);\n    // Do something useful, then wait a bit.\n    await Task.Delay(1000);\n}\n```", "```cs\nusing ExtensionLibrary;\n\"Just before calling the long-running DoWork()\"\n    .Dump(ConsoleColor.DarkBlue);\nDoWork();\n\"Program has finished\".Dump(ConsoleColor.DarkBlue);\n//Console.ReadKey();\nasync void DoWork()\n{\n    \"We are doing important stuff!\"\n        .Dump(ConsoleColor.DarkYellow);\n    await Task.Delay(1000);\n    throw new Exception(\n        \"Something went terribly wrong.\"\n    );\n    \"We're done with the hard work.\"\n        .Dump(ConsoleColor.DarkYellow);\n}\n```", "```cs\nusing ExtensionLibrary;\n\"In the main part of the app.\".Dump(ConsoleColor.White);\nThreadPool.QueueUserWorkItem(DoSomethingForTwoSeconds);\nThreadPool.QueueUserWorkItem(DoSomethingForOneSecond);\n\"Main app is done.\\nPress any key to\nstop.\".Dump(ConsoleColor.White);\nConsole.ReadKey();\nreturn 0;\nvoid DoSomethingForOneSecond(object? notUsed)\n{\n    $\"Doing something for one second.\".Dump(ConsoleColor.Yellow);\n    Thread.Sleep(1000);\n    $\"Finished something for one second\".Dump(ConsoleColor.Yellow);\n}\nvoid DoSomethingForTwoSeconds(object? notUsed)\n{\n    \"Doing something for two\n        seconds.\".Dump(ConsoleColor.DarkYellow);\n    Thread.Sleep(2900);\n    \"Done doing something for two\n        seconds.\".Dump(ConsoleColor.DarkYellow)\n}\n```", "```cs\n\"In the main part of the app.\".Dump(ConsoleColor.White);\n// Tell the system we want to wait for 2 threads to finish.\nCountdownEvent countdown = new(2);\nThreadPool.QueueUserWorkItem(DoSomethingForOneSecond);\nThreadPool.QueueUserWorkItem(DoSomethingForTwoSeconds);\n// Do the actual waiting.\ncountdown.Wait();\n\"Main app is done.\\nPress any key to stop.\".Dump(ConsoleColor.White);\nConsole.ReadKey();\nreturn 0;\n```", "```cs\nvoid DoSomethingForOneSecond(object? notUsed)\n{\n    $\"Doing something for one second.\".Dump(ConsoleColor.Yellow);\n    Thread.Sleep(1000);\n    $\"Finished something for one second\".Dump(ConsoleColor.Yellow);\n    countdown.Signal();\n}\n```", "```cs\nManualResetEvent mre = new(false);\n```", "```cs\n// Tell the second thread it can start\nmre.Set();\n```", "```cs\n// Wait for the first thread to finish.\nmre.WaitOne();\n```", "```cs\nasync Task DoSomethingForOneSecondAsync()\n{\n    $\"Doing something for one second.\".Dump(ConsoleColor.Yellow);\n    await Task.Delay(1000);\n    $\"Finished something for one second\".Dump(ConsoleColor.Yellow);\n}\n```", "```cs\n\"In the main part of the app.\".Dump(ConsoleColor.White);\nawait DoSomethingForOneSecondAsync();\nawait DoSomethingForTwoSecondsAsync();\n\"Main app is done.\\nPress any key to stop.\".Dump(ConsoleColor.White);\nConsole.ReadKey();\nreturn 0;\n```", "```cs\nvar task1 = DoSomethingForOneSecondAsync();\nvar task2 = DoSomethingForTwoSecondsAsync();\n// Wait for all tasks to be finished\nTask.WaitAll(task1, task2);\n\"Main app is done.\\nPress any key to stop.\".Dump(ConsoleColor.White);\nConsole.ReadKey();\nreturn 0;\n```", "```cs\nasync Task DoSomethingForOneSecondAsync()\n{\n    $\"Doing something for one second.\".Dump(ConsoleColor.Yellow);\n    for(int i=0;i<1000;i++)\n        await Task.Delay(1);\n    $\"Finished something for one second\".Dump(ConsoleColor.Yellow);\n}\n```", "```cs\nusing ExtensionLibrary;\n\"In the main part of the app.\".Dump(ConsoleColor.White);\nusing var cts = new CancellationTokenSource();\nvar task1 = DoSomethingForOneSecondAsync();\nTask.WaitAny(task1);\n\"Main app is done.\\nPress any key to stop.\".Dump(ConsoleColor.White);\nConsole.ReadKey();\nreturn 0;\n```", "```cs\nawait Task.Delay(500);\n\"We got bored. Let's cancel.\".Dump(ConsoleColor.White);\ncts.Cancel();\n```", "```cs\nasync Task DoSomethingForOneSecondAsync(CancellationToken cancellationToken)\n```", "```cs\nvar task1 = DoSomethingForOneSecondAsync(cts.Token);\n```", "```cs\nasync Task DoSomethingForOneSecondAsync(CancellationToken cancellationToken)\n{\n    $\"Doing something for one second.\".Dump(ConsoleColor.Yellow);\n    bool hasBeenCancelled = false;\n    int i = 0;\n    for (i = 0; i < 1000; i++)\n    {\n        if (cancellationToken.IsCancellationRequested)\n        {\n            hasBeenCancelled = true;\n            break;\n        }\n        await Task.Delay(1);\n    }\n    if(hasBeenCancelled)\n    {\n        $\"We got interrupted after {i} iterations.\".Dump(ConsoleColor.            Yellow);\n    }\n    else\n    {\n        $\"Finished something for one second\".Dump(ConsoleColor.            Yellow);\n    }\n}\n```", "```cs\nawait Task.Delay(1, cancellationToken);\n```", "```cs\nusing ExtensionLibrary;\nint iterationCount = 100;\nThreadPool.QueueUserWorkItem(async (state) =>\n{\n    await Task.Delay(500);\n    iterationCount = 0;\n    $\"We are stopping it...\".Dump(ConsoleColor.Red);\n});\nawait WaitAWhile();\n$\"In the main part of the app.\".Dump(ConsoleColor.White);\n\"Main app is done.\\nPress any key to stop.\".Dump(ConsoleColor.White);\nConsole.ReadKey();\nreturn 0;\nasync Task WaitAWhile()\n{\n    do\n    {\n        $\"In the loop at iterations {iterationCount}\".            Dump(ConsoleColor.Yellow);\n        await Task.Delay(1);\n    }while (--iterationCount > 0) ;\n}\n```", "```cs\nlock (new object())\n{\n    iterationCount--;\n}\n```", "```cs\nvar lockObject = new object();\nMonitor.Enter(lockObject);\ntry\n{\n    iterationCount--;\n}\nfinally\n{\n    Monitor.Exit(lockObject);\n    lockObject = null;\n}\n```", "```cs\nrecord Counter(int InitialValue);\n```", "```cs\nasync Task WaitAWhile()\n{\n    var actualCounter = myCounter.InitialValue;\n    do\n    {\n        $\"In the loop at iterations {actualCounter}\".            Dump(ConsoleColor.Yellow);\n        await Task.Delay(1);\n    } while (--actualCounter > 0);\n}\n```", "```cs\nint a=42;\n```", "```cs\nprivate static volatile int _initialValue = 100;\n```", "```cs\nusing ExtensionLibrary;\nvar allLines = new List<string>();\nfor(int i = 0; i < 1000; i++)\n{\n    allLines.Add($\"Line {i:000}\");\n}\nThreadPool.QueueUserWorkItem((_) =>\n{\n    Thread.Sleep(1000);\n    allLines.Clear();\n});\nawait DumpArray(allLines);\n\"Main app is done.\\nPress any key to stop.\".Dump(ConsoleColor.White);\nConsole.ReadKey();\nreturn 0;\nasync Task DumpArray(List<string> someData)\n{\n    foreach(var data in someData)\n    {\n        data.Dump(ConsoleColor.Yellow);\n        await Task.Delay(100);\n    }\n}\n```", "```cs\nusing ExtensionLibrary;\nusing System.Collections.Concurrent;\n// We have a collection that blocks as soon as\n// 5 items have been added. Before this thread\n// can continue, one has to be taken away first.\nvar allLines = new BlockingCollection<string>(boundedCapacity:5);\nThreadPool.QueueUserWorkItem((_) => {\n    for (int i = 0; i < 10; i++)\n    {\n        allLines.Add($\"Line {i:000}\");\n        Thread.Sleep(1000);\n    }\n    allLines.CompleteAdding();\n});\n// Give the first thread some time to add items before\n// we take them away again.\nThread.Sleep(6000);\n// Read all items by taking them away\nThreadPool.QueueUserWorkItem((_) => {\n    while (!allLines.IsCompleted)\n    {\n        try\n        {\n            var item = allLines.Take();\n            item.Dump(ConsoleColor.Yellow);\n            Thread.Sleep(10);\n        }\n        catch (InvalidOperationException)\n        {\n            // This can happen if\n            // CompleteAdding has been called\n            // but the collection is already empty\n            // in our case: this thread finished before the\n            // first one\n        }\n    }\n});\n\"Main app is done.\\nPress any key to stop.\".Dump(ConsoleColor.White);\nConsole.ReadKey();\nreturn 0;\n```"]