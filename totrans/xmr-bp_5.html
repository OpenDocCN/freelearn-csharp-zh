<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Building a Stocklist Application"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Building a Stocklist Application</h1></div></div></div><p>In this chapter, we step back into <code class="literal">Xamarin.Forms</code> and look at detailing our XAML interfaces using CustomRenderers, Styles, and ControlTemplates. We will also look at the use of animations and a basic introduction to compound animations. Then, we are going to build a simple web service providing our mobile application with a JSON feed.</p><p>Expected knowledge:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">JSON serialization/deserialization</li><li class="listitem" style="list-style-type: disc">Some understanding of API controllers</li><li class="listitem" style="list-style-type: disc">Visual Studio</li><li class="listitem" style="list-style-type: disc">Some understanding of Linq queries</li><li class="listitem" style="list-style-type: disc">Some understanding of Observables and IObservables</li><li class="listitem" style="list-style-type: disc">Some knowledge of IIS</li></ul></div><p>In this chapter, you will learn the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Understanding the backend</li><li class="listitem" style="list-style-type: disc">Creating an ASP.Net Web API 2 project</li><li class="listitem" style="list-style-type: disc">Building an API controller</li><li class="listitem" style="list-style-type: disc">Setting up mobile projects</li><li class="listitem" style="list-style-type: disc">Building core mobile projects</li><li class="listitem" style="list-style-type: disc">Improving app performance</li><li class="listitem" style="list-style-type: disc">Creating a global <code class="literal">App.xaml</code></li><li class="listitem" style="list-style-type: disc">Theming with <code class="literal">ControlTemplates</code></li><li class="listitem" style="list-style-type: disc">Updating the <code class="literal">MainPageViewModel</code></li><li class="listitem" style="list-style-type: disc">Creating Stocklist web service controller</li><li class="listitem" style="list-style-type: disc"><code class="literal">ListViews</code> and <code class="literal">ObservableCollections</code></li><li class="listitem" style="list-style-type: disc">Value converters</li><li class="listitem" style="list-style-type: disc">Styles</li><li class="listitem" style="list-style-type: disc">Further optimization with XAML</li><li class="listitem" style="list-style-type: disc">Creating <code class="literal">StockItemDetailsPage</code></li><li class="listitem" style="list-style-type: disc">Custom renderers</li><li class="listitem" style="list-style-type: disc">Adding styles for custom elements</li><li class="listitem" style="list-style-type: disc">Creating the <code class="literal">StockItemDetailsPageViewModel</code></li><li class="listitem" style="list-style-type: disc">Setting up native platform projects</li><li class="listitem" style="list-style-type: disc">Hosting the Web API project locally</li></ul></div><div class="section" title="Understanding the backend"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec55"/>Understanding the backend</h1></div></div></div><p>As mobile developers, we are client side developers. We build user interfaces and absorb JSON data from web services. One advantage of developing in both server and client is the ability to tailor the back end to meet the needs of the mobile application. This can result in enhancing performance with data transactions on a web API. Building fast and reliable mobile applications can be difficult if we have to build off an old, slow-running back end. If users experience slow and unstable
applications, they will normally never return to use it again.</p><p>In this example, we will build a simple web service that our mobile application will use. Let's begin by opening up Visual Studio.</p></div></div>
<div class="section" title="Creating an ASP.Net Web API 2 project"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec56"/>Creating an ASP.Net Web API 2 project</h1></div></div></div><p>We are going to start with creating a new project in Microsoft Visual Studio. Go to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New Project</strong></span> and select a new Visual C# ASP.Net project:</p><div class="mediaobject"><img src="graphics/B05293_05_01.jpg" alt="Creating an ASP.Net Web API 2 project"/></div><p>We want to then select the <span class="strong"><strong>Empty</strong></span> template and click the <span class="strong"><strong>Web API</strong></span> checkbox.</p><div class="mediaobject"><img src="graphics/B05293_05_02.jpg" alt="Creating an ASP.Net Web API 2 project"/></div><p>We can actually test the project right away and click <span class="strong"><strong>Run</strong></span>, it will automatically deploy the site and run the application in your default browser. We now have our base <span class="strong"><strong>ASP.NET</strong></span> application template, let's look more closely at the project structure. In the Solution Explorer, starting with the <code class="literal">Models</code> folder, this is where we create all our data objects that represent the data in the application, which are the objects that will be serialized to JSON and sent over HTTP requests. Then, in the <code class="literal">Controllers</code> folder, this is where we have our API controllers, which are objects that handle HTTP requests. These are the main two areas we are going to be focusing on.</p><p>Let's start with creating a data model for a single stock item. Add a new file to the <code class="literal">Models</code> folder called <code class="literal">StockItem.cs</code>:</p><pre class="programlisting">public class StockItem &#13;
    { &#13;
        public int Id { get; set; } &#13;
        public string Name { get; set; } &#13;
        public string Category { get; set; } &#13;
        public decimal Price { get; set; } &#13;
    } &#13;
</pre><p>This object will be serialized into JSON and passed through our API controllers for the mobile application to retrieve. Normally, in every <code class="literal">MVC</code> / <code class="literal">ASP.NET</code> application, we have a data source layer and a Web API layer. In our data source layer, this is where the database sits, we store data here where our business logic layer will perform reads and writes. Our API layer will normally use the business logic layer to access the data and send over the network, a visual representation can be seen as follows:</p><div class="mediaobject"><img src="graphics/B05293_05_03.jpg" alt="Creating an ASP.Net Web API 2 project"/></div></div>
<div class="section" title="Building an API controller"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec57"/>Building an API controller</h1></div></div></div><p>Web API controllers are used to handle web requests. 99% of the time, mobile applications will always use an API layer in which it will call web requests to retrieve data, perform login, and so on. For our example, we are going to add a new empty <code class="literal">WEBAPI 2</code> controller.</p><div class="mediaobject"><img src="graphics/B05293_05_04.jpg" alt="Building an API controller"/></div><p>Implement the following:</p><pre class="programlisting">public class StockItemsController : ApiController &#13;
    { &#13;
        List&lt;StockItem&gt; StockItems = new List&lt;StockItem&gt;()           { &#13;
            new StockItem { Id = 1, Name = "Tomato Soup", Category = "Groceries", Price = 1 }, &#13;
            new StockItem { Id = 2, Name = "Yo-yo", Category = "Toys", Price = 3.75M }, &#13;
            new StockItem { Id = 3, Name = "Hammer", Category = "Hardware", Price = 16.99M } &#13;
        }; &#13;
 &#13;
        public IEnumerable&lt;StockItem&gt; GetAllStockItems() &#13;
        { &#13;
            return StockItems; &#13;
        } &#13;
 &#13;
        public StockItem GetStockItem(int id) &#13;
        { &#13;
            var stockItem = StockItems.FirstOrDefault((p) =&gt; p.Id == id); &#13;
            if (stockItem == null) &#13;
            { &#13;
                return null; &#13;
            } &#13;
 &#13;
            return StockItem; &#13;
        } &#13;
    } &#13;
</pre><p>Looking more closely at the code above, the API has two functions, one for returning all stock items, and another for returning a particular stock item. If we want to access this API controller via HTTP requests, the URLs will be:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Get all stock items</li></ul></div><pre class="programlisting">        api/GetAllStockItems &#13;
</pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Get a particular stock item by ID</li></ul></div><pre class="programlisting">        api/GetStockItem &#13;
</pre><p>Does this format look familiar?</p><p>We will use these two calls inside our mobile application to retrieve data we have sitting on the backend.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note61"/>Note</h3><p>In order to have this API live we have two options: we can either deploy the site online (that is, using Azure or Amazon), or we can host it locally (using localhost).</p></div></div><p>Let's test the API layer and run the project. When the browser opens, paste the following URL into the browser: <code class="literal">localhost:{PORT}/api/GetAllStockItems</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note62"/>Note</h3><p>The port number will be automatically assigned when the project is run so make sure you paste the correct port number specific to your project.</p></div></div><p>You should see an XML displayer with the results from the items in the API controller.</p></div>
<div class="section" title="Setting up the mobile projects"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec58"/>Setting up the mobile projects</h1></div></div></div><p>Moving back to the client side, we now need to start building our mobile applications. Let's start with creating a blank <code class="literal">Xamarin.Forms</code> application:</p><div class="mediaobject"><img src="graphics/B05293_05_05.jpg" alt="Setting up the mobile projects"/></div><p>Call the application <code class="literal">Stocklist</code>, and let's start with the iOS application.</p></div>
<div class="section" title="Building core mobile projects"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec59"/>Building core mobile projects</h1></div></div></div><p>Let's add two new PCL projects, call them <code class="literal">Stocklist.XamForms</code> and <code class="literal">Stocklist.Portable</code>.</p><div class="mediaobject"><img src="graphics/B05293_05_06.jpg" alt="Building core mobile projects"/></div><p>In the <span class="strong"><strong>Stocklist.Portable</strong></span> project we want to add the following nuget packages:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Microsoft HTTP client libraries</li><li class="listitem" style="list-style-type: disc">Autofac</li><li class="listitem" style="list-style-type: disc">Newtonsoft.Json</li><li class="listitem" style="list-style-type: disc">Reactive extensions (main library)</li></ul></div><p>In the <code class="literal">Stocklist.XamForms</code> project we want to add the following nuget packages:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Microsoft HTTP client libraries</li><li class="listitem" style="list-style-type: disc">Autofac</li><li class="listitem" style="list-style-type: disc">Xamarin.Forms</li><li class="listitem" style="list-style-type: disc">Reactive extensions (main library)</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip63"/>Tip</h3><p>Just copy the exact names of the libraries to bring up the libraries you require via the Package Manager tool.</p></div></div><p>Now that we have our projects ready to go we can begin coding. From our previous solution in <a class="link" href="ch03.html" title="Chapter 3. Building a GPS Locator Application">Chapter 3</a>, <span class="emphasis"><em>Building a GPS Locator Application</em></span>, we want to reuse some major parts, such as the <code class="literal">IoC</code> container, modules, and cross-platform navigation.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip64"/>Tip</h3><p>Keeping mobile solutions modular and decoupled makes it easier to share code between different solutions. Why do you think we have nuget packages?</p></div></div><p>Like our <code class="literal">Locator</code> application, we will reuse the <code class="literal">MainPage</code> and <code class="literal">MainPageViewModel</code> objects. Copy these items over to your new projects and place the XAML page into a new folder called <code class="literal">Pages</code> in <code class="literal">Stocklist.XamForms</code>, and place the view-model object into a new folder called <code class="literal">ViewModels</code> inside <code class="literal">Stocklist.Portable</code>.</p></div>
<div class="section" title="Improving app performance"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec60"/>Improving app performance</h1></div></div></div><p>Let's look at a few ways we can improve application performance. Mobile phones do not have desktop processors, users typically run your application an older devices, meaning the performance power maybe be lacking. This is why we must test applications on older and newer devices to compare the performance difference and any API/OS changes that may effect behavior.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip65"/>Tip</h3><p>Running applications on simulators can give different results when running on devices. Make sure you always test on physical devices before releasing.</p></div></div><p>Let's take a look at the <code class="literal">MainPage.xaml</code> page from the <code class="literal">Locator</code> project. Here we will make small tweaks in the XAML layout to slightly improve the performance. The changes are very minor and will only improve performance by a millisecond here and there, but when you combine 100s of these small improvements, the end result will make a difference.</p><p>We can see a <span class="strong"><strong>Grid</strong></span> with three elements inside, now why did we pick a Grid? Grids are good for views which we use to control any overlaying, or covering entire section/pages in which it is placed. Our first question is do we need to cover the entire screen for the landing page? No we don't, so we can replace the Grid with a <code class="literal">StackLayout</code>.</p><p>One rule to apply, don't use a Grid when a <code class="literal">StackLayout</code> will do, and don't use multiple StackLayouts when a Grid will do.</p><p>One <code class="literal">StackLayout</code> will render faster than a single Grid when we don't need to cover the screen or do any overlaying. Let's replace the containing Grid with a <code class="literal">StackLayout</code>:</p><pre class="programlisting">&lt;StackLayout x:Name="StackLayout" Spacing="10" Orientation="Vertical" Padding="10, 10, 10, 10" VerticalOptions="Center"&gt; &#13;
        &lt;Label x:Name="DesciptionLabel" Text="{Binding DescriptionMessage}" HorizontalOptions="Center" Font="Arial, 20"&gt; &#13;
            &lt;Label.TextColor&gt; &#13;
                &lt;OnPlatform x:TypeArguments="Color" &#13;
                    Android="Black" &#13;
                    WinPhone="Black" &#13;
                    iOS="Black"&gt; &#13;
                &lt;/OnPlatform&gt; &#13;
            &lt;/Label.TextColor&gt; &#13;
        &lt;/Label&gt; &#13;
 &#13;
        &lt;Button x:Name="StocklistButton" Text="{Binding LocationTitle}" Command="{Binding LocationCommand}" BackgroundColor="Silver"&gt; &#13;
            &lt;Button.TextColor&gt; &#13;
                &lt;OnPlatform x:TypeArguments="Color" &#13;
                    Android="Navy" &#13;
                    WinPhone="Blue" &#13;
                    iOS="Black"&gt; &#13;
                &lt;/OnPlatform&gt; &#13;
            &lt;/Button.TextColor&gt; &#13;
        &lt;/Button&gt; &#13;
 &#13;
        &lt;Button x:Name="ExitButton" Text="{Binding ExitTitle}" Command="{Binding ExitCommand}" BackgroundColor="Silver"&gt; &#13;
            &lt;Button.TextColor&gt; &#13;
                &lt;OnPlatform x:TypeArguments="Color" &#13;
                    Android="Navy" &#13;
                    WinPhone="Blue" &#13;
                    iOS="Black"&gt; &#13;
                &lt;/OnPlatform&gt; &#13;
            &lt;/Button.TextColor&gt; &#13;
        &lt;/Button&gt; &#13;
    &lt;/StackLayout&gt; &#13;
</pre><p>Don't stop now, let's add some more. Turn attention to the <code class="literal">DescriptionLabel</code>, creating bindings for static text values that never change is wasteful. Instead, we will use <code class="literal">Spans</code> because they are a tad faster to render. First, create a new <code class="literal">.resx</code> file called <code class="literal">LabelResources.resx</code>, add a new variable called <code class="literal">DescriptionMessage</code>, and set the value to the string <code class="literal">Welcome to the Grocery Store</code>:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; &#13;
&lt;root&gt; &#13;
    &lt;resheader name="resmimetype"&gt; &#13;
        &lt;value&gt;text/microsoft-resx&lt;/value&gt; &#13;
    &lt;/resheader&gt; &#13;
    &lt;resheader name="version"&gt; &#13;
        &lt;value&gt;2.0&lt;/value&gt; &#13;
    &lt;/resheader&gt; &#13;
    &lt;resheader name="reader"&gt; &#13;
        &lt;value&gt;System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&lt;/value&gt; &#13;
    &lt;/resheader&gt; &#13;
    &lt;resheader name="writer"&gt; &#13;
        &lt;value&gt;System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&lt;/value&gt; &#13;
    &lt;/resheader&gt; &#13;
 &#13;
    &lt;data name="DecriptionMessage" xml:space="preserve"&gt; &#13;
        &lt;value&gt;Welcome to the Grocery Store&lt;/value&gt; &#13;
    &lt;/data&gt; &#13;
&lt;/root&gt; &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note66"/>Note</h3><p>Ignore everything above the first <code class="literal">data</code> tag; this will be automatically generated when the file is created.</p></div></div><p>Now, let's import the <code class="literal">namespace</code> prefix in our <code class="literal">MainPage</code>:</p><pre class="programlisting"> &#13;
</pre><p>Add the preceding line to the starting tag of the page:</p><pre class="programlisting">&lt;ContentPage   &#13;
     &#13;
     &#13;
    x:Class="Stocklist.XamForms.Pages.MainPage" &#13;
    BackgroundColor="White"&gt; &#13;
</pre><p>Now let's rebuild the label item:</p><pre class="programlisting">&lt;Label x:Name="DesciptionLabel" HorizontalOptions="Center" &gt; &#13;
            &lt;Label.FormattedText&gt; &#13;
                &lt;FormattedString&gt; &#13;
                    &lt;Span Text="{x:Static resx:LabelResources.DecriptionMessage}"  &#13;
                        FontFamily="Arial"  &#13;
                        FontSize="24"&gt; &#13;
                        &lt;Span.ForegroundColor&gt; &#13;
                            &lt;OnPlatform x:TypeArguments="Color" &#13;
                                Android="Black" &#13;
                                WinPhone="Black" &#13;
                                iOS="Black"&gt; &#13;
                            &lt;/OnPlatform&gt; &#13;
                        &lt;/Span.ForegroundColor&gt; &#13;
                    &lt;/Span&gt; &#13;
                &lt;/FormattedString&gt; &#13;
            &lt;/Label.FormattedText&gt; &#13;
        &lt;/Label&gt;  &#13;
</pre><p>Looking at this more closely, we have a <code class="literal">Span</code> that is enclosed by a <code class="literal">FormattedString</code> tag, and the <code class="literal">FormattedString</code> tag is enclosed in the <code class="literal">Label.FormattedText</code> property. The <code class="literal">Span</code> is taking a static reference from our new <code class="literal">LabelResources</code>, and we have also moved the <code class="literal">OnPlatform</code> changes into the <code class="literal">Span</code> object (exactly the same as the label, but instead of the <code class="literal">TextColor</code> property, we are using the <code class="literal">Foreground</code> property).</p><p>These are two tiny enhancements for one label, you probably won't notice much of a difference in performance. If we had a page with a lot of static labels, it would make a small difference in loading speeds. Rendering labels is expensive.</p><p>We can also apply these performance improvements to both button titles. Let's remove the bindings for the <code class="literal">Text</code> property on both buttons and replace them with the static values. Open up the <code class="literal">LabelResources</code> file and add the static values as follows:</p><pre class="programlisting">&lt;data name="ExitTitle" xml:space="preserve"&gt; &#13;
        &lt;value&gt;Exit&lt;/value&gt; &#13;
    &lt;/data&gt; &#13;
    &lt;data name="StocklistTitle" xml:space="preserve"&gt; &#13;
        &lt;value&gt;Stock list&lt;/value&gt; &#13;
    &lt;/data&gt; &#13;
</pre><p>Then we apply it to the properties of the buttons:</p><pre class="programlisting">Text="{x:Static resx:LabelResources.StocklistTitle}"   &#13;
Text="{x:Static resx:LabelResources.ExitTitle}"  &#13;
</pre><p>To finish off the landing page, let's add an image above the buttons:</p><pre class="programlisting">&lt;Image x:Name="Image" Source="stocklist.png" IsOpaque="true" HeightRequest="120" WidthRequest="120"/&gt; &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note67"/>Note</h3><p>All image files can be retrieved from the GitHub link: <a class="ulink" href="https://github.com/flusharcade/chapter5-stocklist">https://github.com/flusharcade/chapter5-stocklist</a>.</p></div></div><p>The property <code class="literal">IsOpaque</code> is flagged to true on this image because the image is opaque. Setting this property to <code class="literal">true</code> allows another small performance enhancement. Transparent images are expensive to render.</p><p>Our last addition to the page is to set the title of the page to another static value from our <code class="literal">LabelResources</code>. Add a new value called <code class="literal">WelcomeTitle</code>:</p><pre class="programlisting">&lt;data name="WelcomeTitle" xml:space="preserve"&gt; &#13;
     &lt;value&gt;Welcome&lt;/value&gt; &#13;
&lt;/data&gt; &#13;
</pre><p>Now let's add it to the starting flag for <code class="literal">MainPage</code>:</p><pre class="programlisting">Title="{x:Static resx:LabelResources.WelcomeTitle}"  &#13;
</pre><p>Our finished implementation will look as follows:</p><pre class="programlisting">&lt;StackLayout x:Name="StackLayout" Spacing="10" Orientation="Vertical" Padding="10, 10, 10, 10" VerticalOptions="Center" HorizontalOptions="Center" &gt; &#13;
        &lt;Image x:Name="Image" Source="stocklist.png" IsOpaque="true" HeightRequest="120" WidthRequest="120"/&gt; &#13;
        &lt;Label x:Name="DesciptionLabel" &gt; &#13;
            &lt;Label.FormattedText&gt; &#13;
                &lt;FormattedString&gt; &#13;
                    &lt;Span Text="{x:Static resx:LabelResources.DecriptionMessage}"  &#13;
                        FontFamily="Arial"  &#13;
                        FontSize="24"&gt; &#13;
                        &lt;Span.ForegroundColor&gt; &#13;
                            &lt;OnPlatform x:TypeArguments="Color" &#13;
                                Android="Black" &#13;
                                WinPhone="Black" &#13;
                                iOS="Black"&gt; &#13;
                            &lt;/OnPlatform&gt; &#13;
                        &lt;/Span.ForegroundColor&gt; &#13;
                    &lt;/Span&gt; &#13;
                &lt;/FormattedString&gt; &#13;
            &lt;/Label.FormattedText&gt; &#13;
        &lt;/Label&gt; &#13;
 &#13;
        &lt;Button x:Name="StocklistButton" Text="{x:Static resx:LabelResources.StocklistTitle}" Command="{Binding StocklistCommand}" BackgroundColor="Silver"&gt; &#13;
            &lt;Button.TextColor&gt; &#13;
                &lt;OnPlatform x:TypeArguments="Color" &#13;
                    Android="Navy" &#13;
                    WinPhone="Blue" &#13;
                    iOS="Black"&gt; &#13;
                &lt;/OnPlatform&gt; &#13;
            &lt;/Button.TextColor&gt; &#13;
        &lt;/Button&gt; &#13;
 &#13;
        &lt;Button x:Name="ExitButton" Text="{x:Static resx:LabelResources.ExitTitle}" Command="{Binding ExitCommand}" BackgroundColor="Silver"&gt; &#13;
            &lt;Button.TextColor&gt; &#13;
                &lt;OnPlatform x:TypeArguments="Color" &#13;
                    Android="Navy" &#13;
                    WinPhone="Blue" &#13;
                    iOS="Black"&gt; &#13;
                &lt;/OnPlatform&gt; &#13;
            &lt;/Button.TextColor&gt; &#13;
        &lt;/Button&gt; &#13;
    &lt;/StackLayout&gt; &#13;
</pre><p>Let's review the small changes we made to this one <code class="literal">ContentPage</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Don't use a <code class="literal">StackLayout</code> when a Grid will do</li><li class="listitem" style="list-style-type: disc">Don't use multiple StackLayouts, use a Grid</li><li class="listitem" style="list-style-type: disc">Replace bindings with static values where possible</li><li class="listitem" style="list-style-type: disc">Set the <code class="literal">IsOpaque</code> flag to <code class="literal">true</code> when the image is opaque</li><li class="listitem" style="list-style-type: disc">Use <code class="literal">FormattedText</code> and <code class="literal">Span</code> on labels with static label values</li></ul></div><p>The more enhancements we can apply, the faster your application will run. We will look at more enhancements in later projects.</p></div>
<div class="section" title="Creating a global App.xaml"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec61"/>Creating a global App.xaml</h1></div></div></div><p>In all <code class="literal">Xamarin.Forms</code> projects we must create an <code class="literal">Application</code> file that inherits the <code class="literal">Application</code> class. We are going to extend this <code class="literal">Application</code> file and create a global resource dictionary. If you came from WPF you will recognize the use of a global resource dictionary that we can reference in all XAML sheets. This global resource dictionary is kept in the <code class="literal">App.xaml</code> file. It will have references to different converters, styles, and data templates. Rather than declaring static resource dictionaries at the top of every <code class="literal">ContentPage</code> or <code class="literal">ContentView</code>, we want to create only one dictionary that every XAML interface can access. This means we only create one dictionary at startup throughout the entire life of the application, rather than creating multiple dictionaries on views when they are displayed.</p><p>Let's create a new <code class="literal">ContentPage</code>, call it <code class="literal">App.xaml</code>, and place it in the <code class="literal">Stocklist.XamForms </code>project. We can now remove the <code class="literal">App.cs</code> file that already exists in this project. Inside the <code class="literal">App.xaml</code> file, implement the following:</p><pre class="programlisting">&lt;Application &#13;
     &#13;
     &#13;
    x:Class="Stocklist.XamForms.App"&gt; &#13;
    &lt;Application.Resources&gt; &#13;
        &lt;ResourceDictionary&gt; &#13;
             &#13;
        &lt;/ResourceDictionary&gt; &#13;
    &lt;/Application.Resources&gt; &#13;
&lt;/Application&gt; &#13;
</pre><p>We declare an <code class="literal">Application</code> object using XAML, and in the resources section of the application we create the global dictionary. We also need to open the <code class="literal">App.xaml.cs</code> file and initialize the component (exactly the same as the initialization of the <code class="literal">ContentPage</code> and <code class="literal">ContentView</code>), the resource dictionary, and the <code class="literal">MainPage</code> object in the Application:</p><pre class="programlisting">public partial class App : Application &#13;
    { &#13;
        public App() &#13;
        { &#13;
            this.InitializeComponent(); &#13;
 &#13;
// The Application ResourceDictionary is available in Xamarin.Forms 1.3 and later &#13;
      if (Application.Current.Resources == null) &#13;
      { &#13;
        Application.Current.Resources = new ResourceDictionary(); &#13;
      } &#13;
 &#13;
            this.MainPage = IoC.Resolve&lt;NavigationPage&gt;(); &#13;
        } &#13;
 &#13;
        protected override void OnStart() &#13;
        { &#13;
            // Handle when your app starts &#13;
        } &#13;
 &#13;
        protected override void OnSleep() &#13;
        { &#13;
            // Handle when your app sleeps &#13;
        } &#13;
 &#13;
        protected override void OnResume() &#13;
        { &#13;
            // Handle when your app resumes &#13;
        } &#13;
    } &#13;
</pre><p>Didn't we forget to do something prior to resolving <code class="literal">NavigationPage</code>?</p><p>We must add our <code class="literal">XamForms</code> module to the <code class="literal">IoC</code> container. First, let's reuse the navigation setup from the <code class="literal">Locator</code> project. Create a new folder called <code class="literal">UI</code> and copy the following files from the <code class="literal">Xamarin.Forms</code> project in the <code class="literal">Locator</code> application:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">INavigableXamarinFormsPage.cs</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">NavigationService.cs</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">XamarinNavigationExtensions.cs</code></li></ul></div><p>We will need to change the namespace in each file from <code class="literal">Locator.UI</code> to <code class="literal">Stocklist.XamForms.UI</code>, and make changes to the <code class="literal">PageNames</code> enum in the <code class="literal">GetPage</code> function:</p><pre class="programlisting">private Page GetPage(PageNames page) &#13;
        { &#13;
            switch(page) &#13;
            { &#13;
                case PageNames.MainPage: &#13;
                    return IoC.Resolve&lt;MainPage&gt; (); &#13;
                case PageNames.StocklistPage: &#13;
                    return IoC.Resolve&lt;Func&lt;StocklistPage&gt;&gt;()();  &#13;
                default: &#13;
                    return null; &#13;
            } &#13;
        } &#13;
</pre><p>Great! We now have the navigation service ready, let's register this with the <code class="literal">XamFormsModule</code>. Create a new folder in the <code class="literal">Stocklist.XamForms</code> project, add a new file for <code class="literal">XamFormsModule</code>, implementing the following:</p><pre class="programlisting">public class XamFormsModule : IModule &#13;
    { &#13;
        public void Register(ContainerBuilder builer) &#13;
        { &#13;
            builer.RegisterType&lt;MainPage&gt; ().SingleInstance(); &#13;
            builer.RegisterType&lt;StocklistPage&gt; ().SingleInstance(); &#13;
 &#13;
            builer.RegisterType&lt;Xamarin.Forms.Command&gt; ().As&lt;ICommand&gt;().SingleInstance(); &#13;
 &#13;
            builer.Register (x =&gt; new NavigationPage(x.Resolve&lt;MainPage&gt;())).AsSelf().SingleInstance(); &#13;
 &#13;
            builer.RegisterType&lt;NavigationService&gt; ().As&lt;INavigationService&gt;().SingleInstance(); &#13;
        } &#13;
    } &#13;
</pre><p>Now that our <code class="literal">XamFormsModule</code> is registered, we can resolve the <code class="literal">NavigationPage</code> and <code class="literal">NavigationService</code>.</p><p>Let's start building the items that will be contained in the global resource dictionary.</p></div>
<div class="section" title="Theming with ControlTemplates"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec62"/>Theming with ControlTemplates</h1></div></div></div><p><code class="literal">ControlTemplates</code> allow separation of logical view hierarchy from visual hierarchy. Similar to a <code class="literal">DataTemplate</code>, a <code class="literal">ControlTemplate</code> will produce the visual hierarchy for your controller page. One advantage of <code class="literal">ControlTemplates</code>, is the concept of theming. Many software applications provide settings to change user interface styles (Visual Studio and Xamarin Studio offer a dark and light theme). We are going to implement two themes for the <code class="literal">MainPage</code> and provide a <code class="literal">Button</code> to switch between the two.</p><p>Let's start with opening the <code class="literal">App.xaml</code> page, and adding the first <code class="literal">ControlTemplate</code> for the black theme:</p><pre class="programlisting">&lt;ControlTemplate x:Key="MainBlackTemplate"&gt; &#13;
                &lt;StackLayout x:Name="StackLayout" Spacing="10" Orientation="Vertical" Padding="10, 10, 10, 10" BackgroundColor="Black" &#13;
            VerticalOptions="Center" HorizontalOptions="Center" &gt; &#13;
          &lt;Image x:Name="Image" Source="stocklist.png" HeightRequest="120" WidthRequest="120"/&gt; &#13;
          &lt;Label x:Name="DesciptionLabel"&gt; &#13;
            &lt;Label.FormattedText&gt; &#13;
              &lt;FormattedString&gt; &#13;
                &lt;Span Text="{x:Static resx:LabelResources.DecriptionMessage}"  &#13;
                  FontFamily="Arial"  &#13;
                  FontSize="24" &#13;
                  ForegroundColor="White"/&gt; &#13;
              &lt;/FormattedString&gt; &#13;
            &lt;/Label.FormattedText&gt; &#13;
              &lt;/Label&gt; &#13;
 &#13;
          &lt;Button x:Name="StocklistButton"  &#13;
              Text="{x:Static resx:LabelResources.StocklistTitle}"  &#13;
              Command="{TemplateBinding StocklistCommand}" &#13;
              Style="{StaticResource HomeButtonStyle}" &#13;
              BackgroundColor="Gray" &#13;
              TextColor="White"/&gt; &#13;
 &#13;
          &lt;Button x:Name="ExitButton"  &#13;
              Text="{x:Static resx:LabelResources.ExitTitle}"  &#13;
              Command="{TemplateBinding ExitCommand}"  &#13;
              Style="{StaticResource HomeButtonStyle}" &#13;
              BackgroundColor="Gray" &#13;
              TextColor="White"/&gt; &#13;
 &#13;
          &lt;ContentPresenter /&gt; &#13;
        &lt;/StackLayout&gt; &#13;
            &lt;/ControlTemplate&gt; &#13;
</pre><p>Here we simply copy the content of the <code class="literal">MainPage</code> apply minor color changes as the templates are changed.</p><p>Now let's add another <code class="literal">ControlTemplate</code> for the white theme:</p><pre class="programlisting">&lt;ControlTemplate x:Key="MainWhiteTemplate"&gt; &#13;
                &lt;StackLayout x:Name="StackLayout" Spacing="10" Orientation="Vertical" Padding="10, 10, 10, 10" VerticalOptions="Center" HorizontalOptions="Center" &gt; &#13;
          &lt;Image x:Name="Image" Source="stocklist.png" HeightRequest="120" WidthRequest="120"/&gt; &#13;
          &lt;Label x:Name="DesciptionLabel" &gt; &#13;
            &lt;Label.FormattedText&gt; &#13;
              &lt;FormattedString&gt; &#13;
                &lt;Span Text="{x:Static resx:LabelResources.DecriptionMessage}"  &#13;
                  FontFamily="Arial"  &#13;
                  FontSize="24" &#13;
                  ForegroundColor="Black"/&gt; &#13;
              &lt;/FormattedString&gt; &#13;
            &lt;/Label.FormattedText&gt; &#13;
              &lt;/Label&gt; &#13;
 &#13;
          &lt;Button x:Name="StocklistButton"  &#13;
              Text="{x:Static resx:LabelResources.StocklistTitle}"  &#13;
              Command="{TemplateBinding StocklistCommand}" &#13;
              Style="{StaticResource HomeButtonStyle}"/&gt; &#13;
 &#13;
          &lt;Button x:Name="ExitButton"  &#13;
              Text="{x:Static resx:LabelResources.ExitTitle}"  &#13;
              Command="{TemplateBinding ExitCommand}"  &#13;
              Style="{StaticResource HomeButtonStyle}"/&gt; &#13;
 &#13;
          &lt;ContentPresenter /&gt; &#13;
        &lt;/StackLayout&gt; &#13;
            &lt;/ControlTemplate&gt; &#13;
</pre><p>Notice the use of the <code class="literal">ContentPresenter</code> object in each template?</p><p>This is used to position content that will be shared across multiple templates. Open up <code class="literal">MainPage.xaml</code> and replace the content with the following:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt; &#13;
&lt;ContentPage   &#13;
   &#13;
   &#13;
   &#13;
  x:Class="Stocklist.XamForms.Pages.MainPage" &#13;
  ControlTemplate="{StaticResource MainBlackTemplate}" &#13;
  BackgroundColor="Black" &#13;
  Title="{x:Static resx:LabelResources.WelcomeTitle}" &#13;
  StocklistCommand="{Binding StocklistCommand}"  &#13;
  ExitCommand="{Binding ExitCommand}"&gt; &#13;
  &lt;ContentPage.Content&gt; &#13;
    &lt;Button Text="Change Theme" Clicked="ChangeThemeClicked" /&gt; &#13;
  &lt;/ContentPage.Content&gt; &#13;
&lt;/ContentPage&gt; &#13;
</pre><p>The content placed on the <code class="literal">MainPage</code> will be positioned where the <code class="literal">ContentPresenter</code> objects are situated in the <code class="literal">ControlTemplates</code>. The content is simply a button that will be shared across both <code class="literal">ControlTemplates</code>. We will start by setting the default <code class="literal">ControlTemplate</code> to the black theme.</p><p>Notice the two command bindings set up on the <code class="literal">ContentPage</code>?</p><p>As our <code class="literal">ControlTemplates</code> need to bind to the <code class="literal">Commands</code> in our <code class="literal">MainPageViewModel</code>, we have to add some extra work setting up these bindings. Open up the <code class="literal">MainPage.xaml.cs</code> and implement these custom bindings:</p><pre class="programlisting">public static readonly BindableProperty StocklistCommandProperty = BindableProperty.Create("StocklistCommand", typeof(ICommand), typeof(MainPage), null); &#13;
        public static readonly BindableProperty ExitCommandProperty = BindableProperty.Create("ExitCommand", typeof(ICommand), typeof(MainPage), null); &#13;
 &#13;
        public ICommand StocklistCommand &#13;
        { &#13;
            get { return (ICommand)GetValue(StocklistCommandProperty); } &#13;
        } &#13;
 &#13;
        public ICommand ExitCommand &#13;
        { &#13;
            get { return (ICommand)GetValue(ExitCommandProperty); } &#13;
        } &#13;
</pre><p>These custom bindings will set up the link between each <code class="literal">ControlTemplate</code> and the view-model. Now each <code class="literal">Command</code> inside the <code class="literal">ControlTemplate</code> will respond to the <code class="literal">Command</code> implemented in the view-model.</p><p>Now let's finish off the <span class="strong"><strong>Change Theme</strong></span> addition. First, let's add the two template definitions:</p><pre class="programlisting">private bool _originalTemplate = true; &#13;
private ControlTemplate _blackTemplate; &#13;
private ControlTemplate _whiteTemplate; &#13;
</pre><p>The <code class="literal">originalTemplate Boolean</code> is used as a flag for switching to the opposite template with every
button click. Next, we must initiate <code class="literal">ControlTemplate</code> from our global resource dictionary:</p><pre class="programlisting">public MainPage() &#13;
    { &#13;
      InitializeComponent(); &#13;
 &#13;
      _blackTemplate = (ControlTemplate)Application.Current.Resources["MainBlackTemplate"]; &#13;
      _whiteTemplate = (ControlTemplate)Application.Current.Resources["MainWhiteTemplate"]; &#13;
    } &#13;
 &#13;
Finally, let's add the ChangeThemeClicked function for the button: &#13;
 &#13;
public void ChangeThemeClicked(object sender, EventArgs e) &#13;
    { &#13;
      _originalTemplate = !_originalTemplate; &#13;
      ControlTemplate = _originalTemplate ? _blackTemplate : _whiteTemplate; &#13;
      BackgroundColor = _originalTemplate ? Color.Black : Color.White; &#13;
    } &#13;
</pre><p>Each time the button is pressed, it will check to see if we are on the default template (the black theme) and switch to the white template if we are on the black template. We will also switch the background color between black and white to match the current theme.</p><p>All done. Now let's move over to the <code class="literal">MainPageViewModel</code> to finish up the page's <code class="literal">BindingContext</code>.</p></div>
<div class="section" title="Updating the MainPageViewModel"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec63"/>Updating the MainPageViewModel</h1></div></div></div><p>Now that we have rebuilt our <code class="literal">MainPage</code>, let's make some small changes to the <code class="literal">MainPageViewModel</code>. Since we replaced the label bindings with static values, we remove the following variables, <code class="literal">DescriptionMessage</code>, <code class="literal">ExitTitle</code>, and <code class="literal">LocationTitle</code>.</p><p>Now we should have the following <code class="literal">private</code> properties:</p><pre class="programlisting">#region Private Properties &#13;
     &#13;
        private readonly IMethods _methods; &#13;
 &#13;
        private ICommand _stocklistCommand; &#13;
 &#13;
        private ICommand _exitCommand; &#13;
 &#13;
        #endregion &#13;
</pre><p>Now simply update <code class="literal">LocationCommand</code> to the following:</p><pre class="programlisting"> public ICommand StocklistCommand &#13;
        { &#13;
            get &#13;
            { &#13;
                return stocklistCommand; &#13;
            } &#13;
 &#13;
            set &#13;
            { &#13;
                if (value.Equals(stocklistCommand)) &#13;
                { &#13;
                    return; &#13;
                } &#13;
 &#13;
                _stocklistCommand = value; &#13;
                OnPropertyChanged("StocklistCommand"); &#13;
            } &#13;
        } &#13;
</pre><p>We must also update our constructor:</p><pre class="programlisting">#region Constructors &#13;
 &#13;
        public MainPageViewModel (INavigationService navigation, Func&lt;Action, ICommand&gt; commandFactory, &#13;
            IMethods methods) : base (navigation) &#13;
        { &#13;
            this.exitCommand = commandFactory (() =&gt; methods.Exit()); &#13;
            this.stocklistCommand = commandFactory (async () =&gt; await this.Navigation.Navigate(PageNames.StocklistPage, null)); &#13;
        } &#13;
 &#13;
        #endregion &#13;
</pre><p>Here we simply rename some variables to match our application. We must also copy over the <code class="literal">Enums</code> and <code class="literal">Extras</code> folder, and replace the  <code class="literal">LocationPage</code> enum to <code class="literal">StocklistPage</code>.</p><p>Next, we need to add the <code class="literal">PortableModule</code>. Create a new folder called <code class="literal">Modules</code> and copy the <code class="literal">PortableModule</code> from <code class="literal">Location.Portable</code>. Change the <code class="literal">PortableModule</code> class to the following:</p><pre class="programlisting">public class PortableModule : IModule &#13;
    { &#13;
        public void Register(ContainerBuilder builer) &#13;
        { &#13;
            builer.RegisterType&lt;MainPageViewModel&gt; ().SingleInstance(); &#13;
            builer.RegisterType&lt;StocklistPageViewModel&gt; ().SingleInstance(); &#13;
        } &#13;
    } &#13;
</pre><p>Finally, we need to add <code class="literal">INavigationService</code>. Create a new folder called <code class="literal">UI</code> and add <code class="literal">INavigationService</code> from <code class="literal">Location.Portable</code> into the new <code class="literal">UI</code> folder.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip68"/>Tip</h3><p>Building project templates can reduce time spent setting up projects and recreating similar modules.</p></div></div><div class="mediaobject"><img src="graphics/B05293_05_07.jpg" alt="Updating the MainPageViewModel"/></div><p>Before we move any further we must update the namespaces in the code sheets copied from the <code class="literal">Locator</code> project. The easiest way is by using <span class="strong"><strong>Search </strong></span>| <span class="strong"><strong>Replace in Files...</strong></span>. We want to replace the text <code class="literal">Location.Portable</code> with the text.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note69"/>Note</h3><p>Be careful doing this; only apply a global replacement when the string is specific.</p></div></div></div>
<div class="section" title="Creating the Stocklist web service controller"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec64"/>Creating the Stocklist web service controller</h1></div></div></div><p>Let's build our client web service controller to access the API. Since we built the back end, we should be able to whip this up very quickly. Our first step is to create the object which will deserialize a <code class="literal">StockItem</code>. We refer to these as contracts. Add a new folder in your <code class="literal">Stocklist.Portable</code> project called <code class="literal">StocklistWebServiceController</code>, and add another folder in this called <code class="literal">Contracts</code>. Create a new file called <code class="literal">StockItemContract.cs</code> and implement the following:</p><pre class="programlisting">public sealed class StockItemContract &#13;
    { &#13;
        #region Public Properties &#13;
 &#13;
        public int Id { get; set;} &#13;
 &#13;
        public string Name { get; set; } &#13;
 &#13;
        public string Category { get; set; } &#13;
 &#13;
        public decimal Price { get; set; } &#13;
 &#13;
        #endregion &#13;
    } &#13;
</pre><p>Now let's go ahead and build the <code class="literal">IStocklistWebServiceController</code> interface:</p><pre class="programlisting">    public interface IStocklistWebServiceController &#13;
    { &#13;
        #region Methods and Operators &#13;
 &#13;
        IObservable&lt;StockItemContract&gt; GetAllStockItems (); &#13;
 &#13;
        Task&lt;StockItemContract&gt; GetStockItemById(int id); &#13;
 &#13;
        #endregion &#13;
    } &#13;
</pre><p>The functions match the exact functions we have in the API controller. Before we implement this interface we have to create a new file called <code class="literal">Config.resx</code> in the <code class="literal">Resources</code> folder. For now, let's just add some empty values for each URL path because we don't know these until we either have the site running locally, or if we deploy it somewhere:</p><pre class="programlisting">    &lt;data name="ApiAllItems" xml:space="preserve"&gt; &#13;
        &lt;value&gt;&lt;/value&gt; &#13;
    &lt;/data&gt; &#13;
    &lt;data name="GetStockItem" xml:space="preserve"&gt; &#13;
        &lt;value&gt;&lt;/value&gt; &#13;
    &lt;/data&gt; &#13;
</pre><p>Now let's implement the <code class="literal">IStocklistWebServiceController</code> interface. Starting the constructor; we will have to retrieve the <code class="literal">HttpClientHandler</code> (we will register this in the <code class="literal">IoC</code> container later):</p><pre class="programlisting">#region Constructors and Destructors &#13;
 &#13;
        public StocklistWebServiceController(HttpClientHandler clientHandler) &#13;
        { &#13;
            _clientHandler = clientHandler; &#13;
        } &#13;
 &#13;
        #endregion &#13;
</pre><p>Now let's implement the first function to retrieve all the items. It will use a <code class="literal">HttpClient</code> to create an <code class="literal">Observable</code> from the asynchronous function <code class="literal">SendAsync</code> via an <code class="literal">HttpClient</code>. The <code class="literal">Observable</code> stream will be generated from the results returned from this function. We will then retrieve the response as a string (this will be JSON), and deserialize the string into multiple <code class="literal">StockItemContracts</code>, which then (using Linq) will be passed into the <code class="literal">Observable</code> stream and returned to the result of the function:</p><pre class="programlisting">public IObservable&lt;StockItemContract&gt; GetAllStockItems () &#13;
        { &#13;
            var authClient = new HttpClient (this.clientHandler); &#13;
 &#13;
            var message = new HttpRequestMessage (HttpMethod.Get, new Uri (Config.ApiAllItems)); &#13;
 &#13;
            return Observable.FromAsync(() =&gt; authClient.SendAsync (message, new CancellationToken(false))) &#13;
                .SelectMany(async response =&gt;  &#13;
                    { &#13;
                        if (response.StatusCode != HttpStatusCode.OK) &#13;
                        { &#13;
                            throw new Exception("Respone error"); &#13;
                        } &#13;
 &#13;
                        return await response.Content.ReadAsStringAsync(); &#13;
                    }) &#13;
                .Select(json =&gt; JsonConvert.DeserializeObject&lt;StockItemContract&gt;(json)); &#13;
        } &#13;
</pre><p>And now for the <code class="literal">GetStockItem</code> function:</p><pre class="programlisting">public IObservable&lt;StockItemContract&gt; GetStockItem (int id) &#13;
        { &#13;
            var authClient = new HttpClient(this.clientHandler); &#13;
 &#13;
            var message = new HttpRequestMessage(HttpMethod.Get, new Uri(string.Format(Config.GetStockItem, id))); &#13;
 &#13;
            return await Observable.FromAsync(() =&gt; authClient.SendAsync(message, new CancellationToken(false))) &#13;
                .SelectMany(async response =&gt; &#13;
                    { &#13;
                        if (response.StatusCode != HttpStatusCode.OK) &#13;
                        { &#13;
                            throw new Exception("Respone error"); &#13;
                        } &#13;
 &#13;
                        return await response.Content.ReadAsStringAsync(); &#13;
                    }) &#13;
                 .Select(json =&gt; JsonConvert.DeserializeObject&lt;StockItemContract&gt;(json)); &#13;
        } &#13;
</pre><p>Great! We now have our <code class="literal">StocklistWebServiceController</code>; we now need to register this object to the interface inside the IoC container. Open up the <code class="literal">PortableModule</code> class and add the following:</p><pre class="programlisting">builer.RegisterType&lt;StocklistWebServiceController&gt; ().As&lt;IStocklistWebServiceController&gt;().SingleInstance(); &#13;
</pre></div>
<div class="section" title="ListViews and ObservableCollections"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec65"/>ListViews and ObservableCollections</h1></div></div></div><p>Now we move on to <code class="literal">StocklistPage</code> and <code class="literal">StocklistPageViewModel</code>; these will be used to display all the items we pull down from the API. On the frontend we will be using&lt;span highlight=""&gt;&amp;nbsp;&lt;/span&gt;<code class="literal">ListView</code>, they are the most common UI elements for displaying lists of data that are pulled down from any API. The beauty of <code class="literal">ListViews</code> is how they are presented via each platform. Placing a <code class="literal">ListView</code> in our XAML sheet via <code class="literal">Xamarin.Forms</code> on iOS will render a <code class="literal">UITableView</code>, on Android a native <code class="literal">ListView</code>, and in Windows a <code class="literal">FrameworkElement</code>. We can also create custom cell items and set up data bindings specific to each item, so with each contract that is deserialized, we want to have a separate view-model that will be used for representing the data on each cell.</p><p>Let's add a new file to the <code class="literal">ViewModels</code> folder in the <code class="literal">Stocklist.Portable</code> project called <code class="literal">StockItemViewModel.cs</code> and implement the constructor:</p><pre class="programlisting">public class StockItemViewModel : ViewModelBase &#13;
    { &#13;
        #region Constructors &#13;
 &#13;
        public StockItemViewModel (INavigationService navigation) : base (navigation) &#13;
        { &#13;
        } &#13;
 &#13;
        #endregion &#13;
    } &#13;
</pre><p>Now we want to add the <code class="literal">private</code> properties; they will be the same properties as in <code class="literal">StockItemContract</code>:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note70"/>Note</h3><p>We can choose to only represent certain items in a custom view cell. Inside the view-model we only create properties that will be displayed on the view.</p></div></div><pre class="programlisting">#region Private Properties &#13;
 &#13;
private int _id; &#13;
 &#13;
private string _name; &#13;
 &#13;
private string _category; &#13;
 &#13;
private decimal _price; &#13;
 &#13;
private bool _inProgress; &#13;
 &#13;
#endregion &#13;
</pre><p>Then we simply create the <code class="literal">public</code> properties for each <code class="literal">private</code> variable, following is one to get you started:</p><pre class="programlisting">public int Id &#13;
        { &#13;
            get &#13;
            { &#13;
                return id; &#13;
            } &#13;
 &#13;
            set &#13;
            { &#13;
                if (value.Equals(_id)) &#13;
                { &#13;
                    return; &#13;
                } &#13;
 &#13;
                _id = value; &#13;
                OnPropertyChanged("Id"); &#13;
            } &#13;
        } &#13;
</pre><p>Here we are building a translation layer between the objects we deserialize and the objects we want to display. This is good for separating the logic contained in the view-models, as they have extra logic for processing the data to be displayed. We want our contracts to purely reflect the properties in the JSON object.</p><p>Next, we add a public method on the view-model called <code class="literal">Apply</code>. This will take a <code class="literal">StockItemContract</code> as a parameter and update the properties of the view-model. It will be called when we want to update the data to be displayed:</p><pre class="programlisting">#region Public Methods &#13;
 &#13;
public void Apply(StockItemContract contract) &#13;
{ &#13;
     Id = contract.Id; &#13;
     Name = contract.Name; &#13;
     Category = contract.Category; &#13;
     Price = contract.Price; &#13;
} &#13;
 &#13;
#endregion &#13;
</pre><p>Our next step is to implement the StocklistPageViewModel. This view-model will contain an <code class="literal">ObservableCollection</code>, which will be used to bind to the <code class="literal">ListView</code>. After we retrieve a list of contracts, we build another list of <code class="literal">StockItemViewModels</code>. Each item will apply the data from the contract and the new <code class="literal">StockItemViewModel</code> will be added to the <code class="literal">ObservableCollection</code>. We will apply the contract to update the data and then add the view-model to <code class="literal">ObservableCollection</code>.</p><p>Let's begin by adding a new file to the <code class="literal">ViewModels</code> folder called <code class="literal">StocklistPageViewModel.cs</code>, and start by creating a new view-model with its constructor:</p><pre class="programlisting">#region Constructors &#13;
 &#13;
        public StocklistPageViewModel(INavigationService navigation, IStocklistWebServiceController stocklistWebServiceController, &#13;
            Func&lt;StockItemViewModel&gt; stockItemFactory) : base(navigation) &#13;
        { &#13;
            _stockItemFactory = stockItemFactory; &#13;
 &#13;
            _stocklistWebServiceController = stocklistWebServiceController; &#13;
 &#13;
            StockItems = new ObservableCollection&lt;StockItemViewModel&gt;(); &#13;
        } &#13;
 &#13;
        #endregion &#13;
</pre><p>The navigation service is the same as the one used in the <code class="literal">Locator</code> project. We will register this later on in <code class="literal">Stocklist.XamForms</code> project. We use the <code class="literal">IStocklistWebServiceController</code> to fetch the <code class="literal">StockItems</code> from the API.</p><p>We then need to register our <code class="literal">StockItemViewModel</code> inside <code class="literal">PortableModule</code>:</p><pre class="programlisting">public void Register(ContainerBuilder builer) &#13;
{ &#13;
            ... &#13;
 &#13;
            builer.RegisterType&lt;StockItemViewModel&gt;().InstancePerDependency(); &#13;
 &#13;
} &#13;
</pre><p>Notice how we are using the <code class="literal">InstancePerDependency</code> function instead of <code class="literal">SingleInstance</code>?
Since we are instantiating multiple items, if we used <code class="literal">SingleInstance</code>, the same data would be copied and changed across all <code class="literal">StockItemViewModels</code>.</p><p>Now let's add the <code class="literal">private</code> and <code class="literal">public</code> properties:</p><pre class="programlisting">        #region Private Properties &#13;
 &#13;
        private readonly IStocklistWebServiceController _stocklistWebServiceController ; &#13;
 &#13;
        private readonly Func&lt;StockItemViewModel&gt; _stockItemFactory; &#13;
 &#13;
        #endregion &#13;
 &#13;
        #region Public Properties &#13;
 &#13;
        public ObservableCollection&lt;StockItemViewModel&gt; StockItems; &#13;
 &#13;
        #endregion &#13;
</pre><p>Now we have all the properties, we can build the list of items for the <code class="literal">ObservableCollection</code>. Next, we add the <code class="literal">LoadAsync</code> function, it is responsible for creating the list of <code class="literal">StockItemViewModels</code>:</p><pre class="programlisting">#region Methods &#13;
 &#13;
    protected override async Task LoadAsync(IDictionary&lt;string, object&gt; parameters) &#13;
    { &#13;
      try &#13;
      { &#13;
        InProgress = true; &#13;
 &#13;
        // reset the list everytime we load the page &#13;
        StockItems.Clear(); &#13;
 &#13;
        var stockItems = await _stocklistWebServiceController.GetAllStockItems(); &#13;
 &#13;
        // for all contracts build stock item view model and add to the observable collection &#13;
        foreach (var model in stockItems.Select(x =&gt; &#13;
          { &#13;
            var model = _stockItemFactory(); &#13;
            model.Apply(x); &#13;
            return model; &#13;
          })) &#13;
        { &#13;
          StockItems.Add(model); &#13;
        } &#13;
 &#13;
        InProgress = false; &#13;
      } &#13;
      catch (Exception e) &#13;
      { &#13;
        System.Diagnostics.Debug.WriteLine(e); &#13;
      } &#13;
    } &#13;
 &#13;
    #endregion &#13;
</pre><p>The <code class="literal">LoadAsync</code> function will be used to retrieve all contracts and build a list of <code class="literal">StockItemViewModels</code>. Every time we add a new <code class="literal">StockItemViewModel</code> to <code class="literal">ObservableCollection</code>, a <code class="literal">CollectionChanged</code> event will be fired to notify the <code class="literal">ListView</code> to update.</p><p>Have a look at how we are instantiating <code class="literal">StockItemViewModel</code> through <code class="literal">stockItemfactory</code>. It uses <code class="literal">Func</code> (<code class="literal">Func&lt;StockItemViewModel&gt;</code>) to generate a new view model every time we execute <code class="literal">Func</code>. This is why we need to call <code class="literal">InstancePerDependency</code>, so separate items are created. If we left the ending function on the registration as <code class="literal">SingleInstance</code>, even though we are calling <code class="literal">Func</code> on <code class="literal">StockItemViewModel</code>, it will only ever create one object.</p><p>Now let's build the user interface for the <code class="literal">StocklistPage</code>. It will contain the <code class="literal">ListView</code> for displaying the <code class="literal">StockItems</code> from the API:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt; &#13;
&lt;ContentPage   &#13;
      &#13;
       &#13;
    x:Class="Stocklist.XamForms.Pages.StocklistPage"&gt; &#13;
    &lt;ContentPage.Content&gt; &#13;
        &lt;Grid&gt; &#13;
      &lt;Grid.RowDefinitions&gt; &#13;
        &lt;RowDefinition Height="*"/&gt; &#13;
      &lt;/Grid.RowDefinitions&gt; &#13;
 &#13;
      &lt;Grid.ColumnDefinitions&gt; &#13;
        &lt;ColumnDefinition Width="*"/&gt; &#13;
      &lt;/Grid.ColumnDefinitions&gt; &#13;
 &#13;
      &lt;ActivityIndicator  x:Name="ActivityIndicator" IsRunning="{Binding InProgress}" Grid.Row="0" Grid.Column="0"/&gt; &#13;
       &#13;
      &lt;ListView x:Name="StockItemsListView" &#13;
        IsVisible="{Binding InProgress, Converter={StaticResource notConverter}}" &#13;
        CachingStrategy="RecycleElement"  &#13;
        ItemsSource="{Binding StockItems}" &#13;
        ItemTemplate="{StaticResource ListItemTemplate}" &#13;
        SelectedItem="{Binding Selected, Mode=TwoWay}" &#13;
        RowHeight="100" &#13;
        Margin="10, 10, 10, 10" &#13;
        Grid.Row="0" Grid.Column="0"/&gt; &#13;
    &lt;/Grid&gt; &#13;
    &lt;/ContentPage.Content&gt; &#13;
&lt;/ContentPage&gt; &#13;
</pre><p>Why can't we use StackLayout?</p><p>Since we need one element overlaying another, we have to use Grid. The <code class="literal">ActivityIndicator</code> is used to show the loading progress of our <code class="literal">LoadAync</code> function. When this is loading, our <code class="literal">ListView</code> will be invisible and the loading indicator is displayed.</p></div>
<div class="section" title="Value converters"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec66"/>Value converters</h1></div></div></div><p>In some cases, there are times when we need to data bind two properties of incompatible types. A <code class="literal">Converter</code> is an object that converts the value from source to target and vice versa. Each converter must implement the <code class="literal">IValueConverter</code> interface, which implements two functions, <code class="literal">Convert</code> and <code class="literal">ConvetBack</code>. We are going to create a converter that will take a <code class="literal">bool</code> as the source, and simply return the opposite value to the value in the source.</p><p>The <code class="literal">ConvertBack</code> method will only be used if the data binding is a <code class="literal">TwoWay</code> binding.</p><p>In the <code class="literal">Stocklist.XamForms </code>project, add a new folder called <code class="literal">Converters</code>, and inside this folder create a new file called <code class="literal">NotConverter.cs</code>, implement the following:</p><pre class="programlisting">    public class NotConverter : IValueConverter &#13;
    { &#13;
        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture) &#13;
        { &#13;
            var b = value as bool?; &#13;
 &#13;
            if (b != null) &#13;
            { &#13;
                return !b; &#13;
            } &#13;
 &#13;
            return value; &#13;
        } &#13;
 &#13;
        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture) &#13;
        { &#13;
            throw new NotImplementedException(); &#13;
        } &#13;
    } &#13;
</pre><p>Even though the <code class="literal">InProgress</code> property doesn't use a two way binding, we still have to implement the <code class="literal">ConvertBack</code> function as part of the interface.</p><p>Now back to the <code class="literal">StocklistPage.xaml</code>. When the <code class="literal">bool</code> property in the view-model changes, the <code class="literal">Convert</code> function of the <code class="literal">NotConverter</code> will be called. When the <code class="literal">IsProgress</code> value changes, the converter will be called and will return the opposite value for the <code class="literal">IsVisible</code> state on the <code class="literal">ListView</code>. When the progress is running, the <code class="literal">ListView</code> is invisible, and when the progress is not running, the <code class="literal">ListView</code> is visible.</p><p>Now we are going to look at creating an <code class="literal">App.xaml</code> which will contain the DataTemplate used for each cell.</p></div>
<div class="section" title="Adding a DataTemplate to the global resource dictionary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec67"/>Adding a DataTemplate to the global resource dictionary</h1></div></div></div><p>Now let's get back to the <code class="literal">App.xaml</code> file. Since we require a custom cell in our <code class="literal">ListView</code> on the <code class="literal">StocklistPage</code>, we are going to create a <code class="literal">DataTemplate</code> in the global resource dictionary. <code class="literal">DataTemplate</code> can be created in two ways, as an inline template or in a resource dictionary. There is no better method, it's more on personal preference. In our example, we are going to be creating ours in a resource dictionary.</p><p>Open up the <code class="literal">App.xaml</code> file and insert the <code class="literal">DataTemplate</code> in the resource dictionary like this:</p><pre class="programlisting">    &lt;DataTemplate x:Key="ListItemTemplate"&gt; &#13;
        &lt;ViewCell&gt; &#13;
          &lt;StackLayout Margin="20, 15, 20, 5"&gt; &#13;
            &lt;Label x:Name="NameLabel" Text="{Binding Name}"/&gt; &#13;
            &lt;Label x:Name="CategoryLabel" Text="{Binding Category}"/&gt; &#13;
            &lt;Label x:Name="PriceLabel" Text="{Binding Price}"/&gt; &#13;
          &lt;/StackLayout&gt; &#13;
                &lt;/ViewCell&gt; &#13;
      &lt;/DataTemplate&gt; &#13;
</pre><p>Now we want to set the <code class="literal">ItemTemplate</code> property on our <code class="literal">ListView</code> in the <code class="literal">StocklistPage</code>. Open up the <code class="literal">StocklistPage</code> and add the following to the <code class="literal">ListView</code> declaration:</p><pre class="programlisting">        &lt;ListView x:Name="StockItemsListView" ItemsSource="{Binding StockItems}" ItemTemplate="{StaticResource ListItemTemplate}"/&gt; &#13;
</pre><p>If we wanted to use the inline template approach, we would do this:</p><pre class="programlisting">&lt;ListView x:Name="StockItemsListView" ItemsSource="{Binding StockItems"&gt; &#13;
            &lt;ListView.ItemTemplate&gt; &#13;
                &lt;DataTemplate&gt; &#13;
                  &lt;ViewCell&gt; &#13;
          &lt;StackLayout Margin="20, 15, 20, 5"&gt; &#13;
            &lt;Label x:Name="NameLabel" Text="{Binding Name/&gt; &#13;
            &lt;Label x:Name="CategoryLabel" Text="{Binding Category}"/&gt; &#13;
            &lt;Label x:Name="PriceLabel" Text="{Binding Price}"/&gt; &#13;
          &lt;/StackLayout&gt; &#13;
                  &lt;/ViewCell&gt; &#13;
                &lt;/DataTemplate&gt; &#13;
          &lt;/ListView.ItemTemplate&gt; &#13;
        &lt;/ListView&gt; &#13;
</pre></div>
<div class="section" title="Styles"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec68"/>Styles</h1></div></div></div><p>In our custom cell we have three labels without any styling or font assignation. We are going to spice up the look of each cell using <code class="literal">Style</code>. A <code class="literal">Style</code> groups a collection of property values into one object that can be applied to multiple visual element instances. The idea of this is to reduce repetitive markup so we can reuse similar styles across similar controls in our XAML. There are multiple ways to apply styling to a control in <code class="literal">Xamarin.Forms</code>. In this example, we will show you how to create a global style in the <code class="literal">App.xaml</code> file, and apply it to different controls in our application.</p><p>Our first global style will be for the title label in our custom cell. Let's open up the <code class="literal">App.xaml</code> file and insert the following into our resource dictionary:</p><pre class="programlisting">&lt;Style x:Key="TitleStyle" TargetType="Label"&gt; &#13;
                &lt;Setter Property="TextColor" Value="Black" /&gt; &#13;
                &lt;Setter Property="FontAttributes" Value="Bold" /&gt; &#13;
                &lt;Setter Property="FontFamily" Value="Arial" /&gt; &#13;
            &lt;/Style&gt; &#13;
</pre><p>In preceding markup, each style will contain a list of <code class="literal">Setter</code> properties. These refer to the <code class="literal">BindableProperties</code> on our control. Now that we have our <code class="literal">Style</code>, we can refer to this static resource inside our <code class="literal">DataTemplate</code>:</p><pre class="programlisting">&lt;Label x:Name="NameLabel" Text="{Binding Name}" Style="{StaticResource TitleStyle}"/&gt; &#13;
</pre><p>Great! We have just created and set our first style on a <code class="literal">Label</code>. Let's add some more styles to <code class="literal">MainPageControlTemplates</code>. We are going to style the buttons as they both share the same styled properties. Add the following to the global resource dictionary:</p><pre class="programlisting">&lt;Style x:Key="HomeButtonStyle" TargetType="Button"&gt; &#13;
                &lt;Setter Property="TextColor"&gt; &#13;
                    &lt;Setter.Value&gt; &#13;
                        &lt;OnPlatform x:TypeArguments="Color" &#13;
                            Android="Navy" &#13;
                            WinPhone="Blue" &#13;
                            iOS="Black"&gt; &#13;
                        &lt;/OnPlatform&gt; &#13;
                    &lt;/Setter.Value&gt; &#13;
                &lt;/Setter&gt; &#13;
                &lt;Setter Property="BackgroundColor" Value="Silver" /&gt; &#13;
&lt;/Style&gt; &#13;
</pre><p>Looking closer at the preceding style, we can even use the <code class="literal">&lt;OnPlatform&gt;</code> tags to change setter values based on the platform.</p><p>Now let's apply this <code class="literal">Style</code> to our <code class="literal">MainPage</code> buttons:</p><pre class="programlisting">         &#13;
&lt;Button x:Name="StocklistButton"  &#13;
                Text="{x:Static resx:LabelResources.StocklistTitle}"  &#13;
                Command="{Binding StocklistCommand}" &#13;
                Style="{StaticResource HomeButtonStyle}"/&gt; &#13;
 &#13;
        &lt;Button x:Name="ExitButton" &#13;
                Text="{x:Static resx:LabelResources.ExitTitle}" &#13;
                Command="{Binding ExitCommand}" &#13;
                Style="{StaticResource HomeButtonStyle}"/&gt; &#13;
</pre><p>See how we are reducing the size of the markup?</p><p>This is one example of how we can apply <code class="literal">Styles</code>, we will see more techniques in further chapters.</p></div>
<div class="section" title="Further optimization with XAML"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec69"/>Further optimization with XAML</h1></div></div></div><p>Previously, we talked about some minor changes we can apply to our XAML to improve on the performance. Let's look at how we can apply some performance enhancements on a <code class="literal">ListView</code>. If you have worked with any native <code class="literal">ListView</code> or <code class="literal">UITableView</code>, one of the biggest problems is the memory usage when we have a lot of elements to load whilst we are scrolling (that is, loading an image into each bitmap for every cell).</p><p>How do we solve this issue?</p><p>We use techniques for caching cells and reusing cells. Since <code class="literal">Xamarin.Forms</code> 2.0, they have introduced some new features and enhancements around cell recycling mechanisms and caching strategies on <code class="literal">ListViews</code>. In order to set a caching strategy, we have two options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">RetainElement</code>: This is the default behavior. It will generate a cell for each item in the list, cell layout will run for each cell creation. We should only be using this method if the cell layout is frequently changing, or if a cell has a large number of bindings.</li><li class="listitem" style="list-style-type: disc"><code class="literal">RecycleElement</code>: This takes advantage of native cell recycling mechanisms on iOS and Android. It will minimize the memory footprint and maximize the performance of a <code class="literal">ListView</code>. We should use this method if cells have a small to moderate amount of bindings, are similar in layout, and the cell view-model contains all the data.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip71"/>Tip</h3><p>We should always be aiming to use the second element, try to design your cells around this setting.</p></div></div><p>We are going to use the second caching strategy on our <code class="literal">ListView</code>:</p><pre class="programlisting">&lt;ListView x:Name="StockItemsListView" CachingStrategy="RecycleElement" ItemsSource="{Binding StockItems}" ItemTemplate="{StaticResource ListItemTemplate}"/&gt; &#13;
</pre><p><code class="literal">RecycleElement</code> should be used as much as possible as we always want to tailor our apps to maximize performance wherever we can. Since we have a fairly simple cell design with a small amount of bindings and we keep all the data inside our view-model, we are able to use this setting.</p><p>Now let's have a look at another simple addition we can use to improve the loading speed of our XAML sheets. Turning on XAML compilation allows your XAML sheets to be compiled rather than interpreted, which can provide multiple benefits:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Helps markup errors</li><li class="listitem" style="list-style-type: disc">Reduces application size</li><li class="listitem" style="list-style-type: disc">Removes load and instantiation time</li></ul></div><p>It is highly recommended to have this setting on with all your <code class="literal">Xamarin.Forms</code> applications as it will increase the loading speed of your user interfaces (in particular with Android). We can add the compiled XAML by opening up the <code class="literal">App.xaml.cs</code> file and pasting the code below the preceding namespace:</p><pre class="programlisting">[assembly: Xamarin.Forms.Xaml.XamlCompilation(Xamarin.Forms.Xaml.XamlCompilationOptions.Compile)] &#13;
</pre><p>If we add up all the performance additions we have applied to the project, we should see some improvement in the user interfaces as they present between different screens.</p></div>
<div class="section" title="Creating StockItemDetailsPage"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec70"/>Creating StockItemDetailsPage</h1></div></div></div><p>Now we move on to our last page of the application. We are going to add another page for displaying the details of a selected stock item from the previous <code class="literal">StocklistPage</code>. Firstly, we need to handle items selected from <code class="literal">ListView</code>, so open up <code class="literal">StocklistPage.xaml</code> and update the <code class="literal">ListView</code> element with the <code class="literal">SelectedItem</code> object bound to the <code class="literal">Selected</code> item in our view-model (we will add this after the XAML update). This will be set as a <code class="literal">TwoWay</code> binding because the data will change from both sides (from the view as we selected items, and the view-model as we will need the selected object data when we navigate to the stock details page):</p><pre class="programlisting">&lt;ListView x:Name="StockItemsListView" &#13;
        IsVisible="{Binding InProgress, Converter={StaticResource notConverter}}" &#13;
        CachingStrategy="RecycleElement"  &#13;
        ItemsSource="{Binding StockItems}" &#13;
        ItemTemplate="{StaticResource ListItemTemplate}" &#13;
        SelectedItem="{Binding Selected, Mode=TwoWay}" &#13;
        RowHeight="100" &#13;
        Margin="10, 10, 10, 10" &#13;
        Grid.Row="0" Grid.Column="0"/&gt; &#13;
</pre><p>Now let's add to the <code class="literal">StocklistPageViewModel</code>; we need to add a <code class="literal">public</code><code class="literal">StockItemViewModel</code> property that will hold the data of our binding when an item is selected from the list. The ID property of the selected <code class="literal">StockItemViewModel</code> will be passed through the navigation parameters for our <code class="literal">StockItemDetailsPage</code>:</p><pre class="programlisting">private StockItemViewModel _selected; &#13;
.... &#13;
public StockItemViewModel Selected &#13;
    { &#13;
      get &#13;
      { &#13;
        return _selected; &#13;
      } &#13;
 &#13;
      set &#13;
      { &#13;
        if (value.Equals(_selected)) &#13;
        { &#13;
          return; &#13;
        } &#13;
        else &#13;
        { &#13;
          Navigation.Navigate(Enums.PageNames.StockItemDetailsPage, new Dictionary&lt;string, object&gt;() &#13;
          { &#13;
            {"id", value.Id}, &#13;
          }).ConfigureAwait(false); &#13;
        } &#13;
 &#13;
        _selected = value; &#13;
        OnPropertyChanged("Selected"); &#13;
      } &#13;
    } &#13;
</pre><p>Now let's add the new <code class="literal">StocklistItemDetailsPage</code>. Create a new XAML <code class="literal">ContentPage</code> and add the following:</p><pre class="programlisting">&lt;ContentPage.Content&gt; &#13;
    &lt;StackLayout Margin="20, 20, 20, 5"&gt; &#13;
      &lt;Label x:Name="TitleLabel" &gt; &#13;
        &lt;Label.FormattedText&gt; &#13;
          &lt;FormattedString&gt; &#13;
            &lt;Span Text="{x:Static resx:LabelResources.StockItemDetailsTitle}"  &#13;
              FontFamily="Arial"  &#13;
              FontSize="24"&gt; &#13;
              &lt;Span.ForegroundColor&gt; &#13;
                        &lt;OnPlatform x:TypeArguments="Color" &#13;
                            Android="Black" &#13;
                            WinPhone="Black" &#13;
                            iOS="Black"&gt; &#13;
                        &lt;/OnPlatform&gt; &#13;
                    &lt;/Span.ForegroundColor&gt; &#13;
            &lt;/Span&gt; &#13;
          &lt;/FormattedString&gt; &#13;
        &lt;/Label.FormattedText&gt; &#13;
          &lt;/Label&gt; &#13;
         &#13;
      &lt;Label x:Name="NameLabel" Text="{Binding Name}" Style="{StaticResource TitleStyle}"/&gt; &#13;
      &lt;controls:CustomLabel x:Name="CategoryLabel" Text="{Binding Category}" Style="{StaticResource CustomLabelStyle}"/&gt; &#13;
            &lt;controls:CustomLabel x:Name="PriceLabel" Text="{Binding Price}" Style="{StaticResource CustomLabelStyle}"/&gt; &#13;
 &#13;
      &lt;ActivityIndicator x:Name="ActivityIndicator" IsRunning="{Binding InProgress}"/&gt; &#13;
    &lt;/StackLayout&gt; &#13;
  &lt;/ContentPage.Content&gt; &#13;
</pre><p>Looking more closely at the code, we have added four labels and <code class="literal">ActivityIndicator</code>, which are used to show the progress of our page loading the data. We have also included a custom control <code class="literal">CustomLabel</code>, we reference this item via the namespace as follows:</p><pre class="programlisting">  &#13;
</pre><p>Whatever name follows the <code class="literal">xmlns</code> keyword, this name must be called first to reference the item within the namespace we are trying to use, like this:</p><pre class="programlisting"> &lt;controls:CustomLabel/&gt; &#13;
</pre><p>Now we must create our <code class="literal">CustomLabel</code> object, which will be used for a <code class="literal">CustomRenderer</code> for Android, as we are going to set the font of this label to a custom <code class="literal">Typeface</code>, which we will include in both native projects. Create a new folder called <code class="literal">Controls</code> in the <code class="literal">Stocklist.XamForms</code> project, and create the following file, called <code class="literal">CustomLabel.cs</code>:</p><pre class="programlisting">public class CustomLabel : Label &#13;
    { &#13;
        public static readonly BindableProperty AndroidFontStyleProperty = BindableProperty.Create&lt;CustomLabel, string&gt;( &#13;
            p =&gt; p.AndroidFontStyle, default(string)); &#13;
 &#13;
        public string AndroidFontStyle &#13;
        { &#13;
            get &#13;
            { &#13;
                return (string)GetValue(AndroidFontStyleProperty); &#13;
            } &#13;
            set &#13;
            { &#13;
                SetValue(AndroidFontStyleProperty, value); &#13;
            } &#13;
        } &#13;
    } &#13;
</pre><p>In our <code class="literal">CustomLabel</code>, we are adding a custom binding, which will be used specifically to set the font style for Android. When we set the font style on the native side, we have to set the custom font by the filename not the font name, whereas in iOS we reference the custom font by the font name and not the filename.</p><p>When we set up custom bindings, we must always include a <code class="literal">static</code> property, this is our <code class="literal">BindableProperty</code>, which is used to reference the item of the UI element that we are binding on. Then we must always include the actual property which is referenced in the XAML:</p><pre class="programlisting">&lt;controls:CustomLabel AndroidFontStyle="GraCoRg_" /&gt; &#13;
</pre></div>
<div class="section" title="Custom renderers"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec71"/>Custom renderers</h1></div></div></div><p>You will find <code class="literal">Xamarin.Forms</code> covers most of the native controls via cross-platform elements such as XAML objects, but there are some UI elements which we must implement ourselves using <code class="literal">CustomRenderers</code>. <code class="literal">CustomRenderers</code> allows anyone to override the rendering process for specific controls placed in our XAML, and render native elements on the platform side. We must place a renderer specific to each platform, but for this example, we are only going to apply a custom renderer for the Android project as we want our custom labels to use custom fonts. iOS doesn't need a renderer to allow custom fonts; all we have to do is add the reference to our font file in the <code class="literal">info.plist</code> file. Open up the <code class="literal">info.plist</code> file in your iOS project and add a new entry called <code class="literal">Fonts provided by application</code> (for an array element we simply add the path of our font file <code class="literal">GraCoRg_.ttf</code>). Then add the font file into the <code class="literal">Resources</code> folder of the iOS project, make sure the build action of the font file is set to <code class="literal">BundleResource</code> (do this by right-clicking on the file):</p><div class="mediaobject"><img src="graphics/B05293_05_08.jpg" alt="Custom renderers"/></div><p>We also want to add this font file into the <code class="literal">Assets</code> folder of the Android project, and make sure we set the build action to <code class="literal">AndroidAsset</code>.</p><p>You can grab this font file from the GitHub link: <a class="ulink" href="https://github.com/flusharcade/chapter5-stocklist">https://github.com/flusharcade/chapter5-stocklist</a>.</p><p>To implement the equivalent for Android, we must create a <code class="literal">CustomRenderer</code> for the <code class="literal">CustomLabel</code> item in our <code class="literal">Controls</code> folder. Open the Android project, create a new folder called <code class="literal">Renderers</code>, and add a new file called <code class="literal">CustomLabelRenderer</code>, and implement the following:</p><pre class="programlisting">public class CustomLabelRenderer : LabelRenderer &#13;
    { &#13;
        protected override void OnElementChanged (ElementChangedEventArgs&lt;Label&gt; e)  &#13;
        { &#13;
            base.OnElementChanged (e); &#13;
 &#13;
            if (!string.IsNullOrEmpty((e.NewElement as CustomLabel)?.AndroidFontStyle)) &#13;
            { &#13;
                try &#13;
                { &#13;
                    var font = default(Typeface); &#13;
 &#13;
                    font = Typeface.CreateFromAsset(Forms.Context.ApplicationContext.Assets, (e.NewElement as CustomLabel)?.AndroidFontStyle + ".ttf"); &#13;
 &#13;
                    if (Control != null) &#13;
                    { &#13;
                        Control.Typeface = font; &#13;
                        Control.TextSize = (float)e.NewElement.FontSize; &#13;
                    } &#13;
                } &#13;
                catch (Exception ex) &#13;
                { &#13;
                    Console.WriteLine(ex); &#13;
                } &#13;
            } &#13;
        } &#13;
    } &#13;
</pre><p>In just about all the renderers, we are exposed to the <code class="literal">OnElementChanged</code> function which is called when a <code class="literal">Xamarin.Forms</code> custom control is created in order to render the corresponding native control. In some circumstances, the <code class="literal">OnElementChanged</code> method can be called multiple times, so care must be taken when instantiating a new native control in order to prevent memory leaks, which can have a large performance impact. In our case, we are not rendering a new control, so we only need to check that the <code class="literal">NewElement</code> and <code class="literal">Control</code> objects are not null when the function is called. We must also cast the <code class="literal">NewElement</code> item to our custom item, as this is the object which contains the custom binding for the <code class="literal">AndroidFontStyle</code> property. The <code class="literal">NewElement</code> will always be the custom item, so we can always cast it.</p><p>We can also now access the native UI frameworks; in this case, we are using the Android <code class="literal">Typeface</code> framework to create a custom <code class="literal">Typeface</code> which will use our font file. Then this <code class="literal">Typeface</code> is set to the <code class="literal">Typeface</code> property of the <code class="literal">Control</code> element (this is the actual element which will be displayed), in this case, because it is a <code class="literal">LabelRenderer</code>, the <code class="literal">Control</code> element is an Android <code class="literal">TextView</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note72"/>Note</h3><p>In other renderers, we can set this control element to specific native elements, which we will be doing in further chapters.</p></div></div><p>Finally, we have to add the following line to export and register the renderer:</p><pre class="programlisting">[assembly: Xamarin.Forms.ExportRenderer(typeof(Stocklist.XamForms.Controls.CustomLabel), typeof(Stocklist.Droid.Renderers.CustomLabel.CustomLabelRenderer))] &#13;
</pre></div>
<div class="section" title="Adding styles for custom elements"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec72"/>Adding styles for custom elements</h1></div></div></div><p>We still have one more addition to finalise the <code class="literal">StockItemDetailsPage</code>. We are going to add a style for the <code class="literal">CustomLabel</code>. Open up the <code class="literal">App.xaml</code> file and add the following style:</p><pre class="programlisting">&lt;Style x:Key="CustomLabelStyle" TargetType="controls:CustomLabel"&gt; &#13;
                &lt;Setter Property="TextColor" Value="Black" /&gt; &#13;
        &lt;Setter Property="FontFamily" Value="Gravur-Condensed" /&gt; &#13;
        &lt;Setter Property="AndroidFontStyle" Value="GraCoRg_" /&gt; &#13;
            &lt;/Style&gt; &#13;
</pre><p>We have included a <code class="literal">Setter</code> for the <code class="literal">AndroidFontStyle</code> property we created earlier. Don't forget we must also add the namespace reference for the <code class="literal">Controls</code>:</p><pre class="programlisting"> &#13;
</pre><p>That's everything for the user interface. Now let's move on to implementing the view-model for the <code class="literal">StockItemDetailsPage</code>.</p></div>
<div class="section" title="Creating StockItemDetailsPageViewModel"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec73"/>Creating StockItemDetailsPageViewModel</h1></div></div></div><p>Now we move on to the last view-model in our application. Add a new file called <code class="literal">StockItemDetailsPageViewModel</code> to our ViewModels folder in the <code class="literal">Stocklist.Portable</code> project.</p><p>Let's start by implementing the <code class="literal">private</code> properties:</p><pre class="programlisting">#region Private Properties &#13;
 &#13;
        private readonly IStocklistWebServiceController _stocklistWebServiceController; &#13;
 &#13;
        private int _id; &#13;
 &#13;
        private string _name; &#13;
 &#13;
        private string _category; &#13;
 &#13;
        private decimal _price; &#13;
 &#13;
        private bool _inProgress; &#13;
        &#13;
#endregion &#13;
</pre><p>You should be able to add the <code class="literal">public</code> properties yourself. Here is the first to get you started:</p><pre class="programlisting">public int Id &#13;
        { &#13;
            get &#13;
            { &#13;
                return _id; &#13;
            } &#13;
 &#13;
            set &#13;
            { &#13;
                if (value.Equals(_id)) &#13;
                { &#13;
                    return; &#13;
                } &#13;
 &#13;
                _id = value; &#13;
                OnPropertyChanged("Id"); &#13;
            } &#13;
        } &#13;
</pre><p>Now we need to add the <code class="literal">LoadAsync</code> function, which will use <code class="literal">StocklistWebServiceController</code> to pull the data from our API for a specific <code class="literal">StockItem</code>. Notice the use of the <code class="literal">InProgress</code> property, this is used to track the loading progress; as we are downloading in the background we want to display this progress to the user interface via an <code class="literal">ActivityIndicator</code>:</p><pre class="programlisting">#region Methods &#13;
 &#13;
        protected override async Task LoadAsync(IDictionary&lt;string, object&gt; parameters) &#13;
        { &#13;
            InProgress = true; &#13;
 &#13;
            if (parameters.ContainsKey("id")) &#13;
            { &#13;
                Id = (int)parameters["id"]; &#13;
            } &#13;
 &#13;
            var contract = await _stocklistWebServiceController.GetStockItem(Id); &#13;
 &#13;
            if (contract != null) &#13;
            { &#13;
                this.Name = contract.Name; &#13;
                this.Category = contract.Category; &#13;
                this.Price = contract.Price; &#13;
            } &#13;
 &#13;
            InProgress = false; &#13;
        } &#13;
 &#13;
        #endregion &#13;
</pre><p>Then we add our constructor which will pull out the registered IoC objects and assign our <code class="literal">private</code> properties accordingly:</p><pre class="programlisting">#region Constructors &#13;
 &#13;
        public StockItemDetailsPageViewModel(INavigationService navigation, IStocklistWebServiceController stocklistWebServiceController, &#13;
            Func&lt;Action, ICommand&gt; commandFactory) : base(navigation) &#13;
        { &#13;
            _stocklistWebServiceController = stocklistWebServiceController; &#13;
        } &#13;
 &#13;
        #endregion  &#13;
</pre><p>Finally, we need to register the view-model in the <code class="literal">CommonModule</code>:</p><pre class="programlisting">builer.RegisterType&lt;StockItemDetailsPageViewModel&gt;().InstancePerDependency(); &#13;
</pre><p>Add the extra enum for the <code class="literal">StockItemDetailsPage</code> to <code class="literal">PageEnums.cs</code>:</p><pre class="programlisting">public enum PageNames &#13;
    { &#13;
        MainPage, &#13;
 &#13;
        StocklistPage, &#13;
 &#13;
        StockItemDetailsPage &#13;
    } &#13;
</pre><p>And add the extra switch case to <code class="literal">NavigationService</code>:</p><pre class="programlisting">case PageNames.StockItemDetailsPage: &#13;
                    return IoC.Resolve&lt;Func&lt;StockItemDetailsPage&gt;&gt;()();  &#13;
</pre></div>
<div class="section" title="Setting up the native platform projects"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec74"/>Setting up the native platform projects</h1></div></div></div><p>Now we move on to the native platform layer and prepare the iOS, Android, and Windows Phone projects. We are going to start with iOS; let's start by adding the NuGet packages required for the project:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Microsoft HTTP client libraries</li><li class="listitem" style="list-style-type: disc">Modern HTTP client</li><li class="listitem" style="list-style-type: disc">Autofac</li><li class="listitem" style="list-style-type: disc">Reactive extensions (main library)</li></ul></div><p>Once we've added these packages to the project, let's open the <code class="literal">AppDelegate</code> file and add the same <code class="literal">InitIoC</code> function we used in the <code class="literal">Locator</code> project:</p><pre class="programlisting">private void InitIoC() &#13;
{ &#13;
  IoC.CreateContainer(); &#13;
  IoC.RegisterModule(new DroidModule()); &#13;
  IoC.RegisterModule(new SharedModule(false)); &#13;
  IoC.RegisterModule(new XamFormsModule()); &#13;
  IoC.RegisterModule(new PortableModule()); &#13;
  IoC.StartContainer(); &#13;
} &#13;
</pre><p>Then call this method before we load the application:</p><pre class="programlisting">public override bool FinishedLaunching(UIApplication app, NSDictionary options) &#13;
        { &#13;
            global::Xamarin.Forms.Forms.Init(); &#13;
 &#13;
            InitIoC(); &#13;
 &#13;
            LoadApplication(new App()); &#13;
 &#13;
            return base.FinishedLaunching(app, options); &#13;
        } &#13;
</pre><p>Before running the iOS application, let's also set up the Android project. We want to start by adding the same libraries as iOS, then opening <code class="literal">MainActivity.cs</code>, and adding the same function <code class="literal">InitIoC</code> as shown in the preceding example. Then, finally, we call the<code class="literal"> InitIoC</code> function before we load the application:</p><pre class="programlisting">protected override void OnCreate(Bundle bundle) &#13;
        { &#13;
            base.OnCreate(bundle); &#13;
 &#13;
            InitIoC(); &#13;
 &#13;
            global::Xamarin.Forms.Forms.Init(this, bundle); &#13;
 &#13;
            LoadApplication(new App()); &#13;
        } &#13;
</pre><p>Simple, right? See how much code we are simply copying from another project?</p><p>The more problems we solve in other projects, the quicker we can piece together apps that have similar functionality.</p></div>
<div class="section" title="Hosting the Web API project locally"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec75"/>Hosting the Web API project locally</h1></div></div></div><p>Before we can access the API layer from our mobile application, we have to set up hosting. For this example, we are going to walkthrough setup for hosting locally.</p><p>Hosting locally does not require much work, but it will require an instance of Windows and Mac OSX running together. You can achieve this by simply running parallels, or using a <span class="strong"><strong>Windows</strong></span> and <span class="strong"><strong>Mac</strong></span> computer.</p><p>Our first step is to open Visual Studio from our Windows instance and click the run button:</p><div class="mediaobject"><img src="graphics/B05293_05_09.jpg" alt="Hosting the Web API project locally"/></div><p>When the project starts, it will automatically open up your default web browser and show the application.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip73"/>Tip</h3><p>Since we don't have any visible web pages, we don't need to have the browser open. If the project is running, the web API will be running so we will be able to ping it over an HTTP request.</p></div></div><p>Now that we have the backend running, how do we access the API?</p><p>If you are running via two separate computers, we should be able to simply access the API through the IP address of the computer. In order to find out the IP address of the computer, open up a new command prompt window and type in <code class="literal">ipconfig</code>. This will display the IPv4 address that the computer has been assigned to on the current network.</p><div class="mediaobject"><img src="graphics/B05293_05_10.jpg" alt="Hosting the Web API project locally"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note74"/>Note</h3><p>In order for the local set up to work, please make sure both the mobile device and the computer hosting the WEB API are both on the same <span class="strong"><strong>WIFI/LAN</strong></span> connection.</p></div></div><p>To confirm we have this working, paste the following URL into a web browser on the Windows instance and see if we get results:</p><pre class="programlisting">"localhost:{port}/api/StockItems" &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note75"/>Note</h3><p>The port is automatically assigned when the project is run, so when the browser appears with the localhost URL, paste the URL extension <code class="literal">api/StockItems</code>.</p></div></div><p>Now we want to test this link on the Mac instance, but before we do, we have to change some settings in the <code class="literal">applicationhost.config</code> file located in <code class="literal">"C:\Users[YourName]\Documents\IISExpress\config\applicationhost.config"</code>.</p><p>If you are using Visual Studio 2015, it will be located in <code class="literal">/{project folder}/.vs/config/applicationhost.config</code>.</p><p>If you haven't got <span class="strong"><strong>Internet Information Services</strong></span> (<span class="strong"><strong>IIS</strong></span>) switched on, follow these steps, to install IIS to serve static content:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Click the Start button, click <span class="strong"><strong>Control Panel</strong></span>, click <span class="strong"><strong>Programs</strong></span>, and then click <span class="strong"><strong>Turn Windows features</strong></span> on or off.</li><li class="listitem">In the list of <span class="strong"><strong>Windows features</strong></span>, select <span class="strong"><strong>Internet Information Services</strong></span>, and then click <span class="strong"><strong>OK</strong></span>.</li><li class="listitem">Look through the file until you can file your application entry like this:<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note76"/>Note</h3><p>The best way to find your particular entry is by searching for the <code class="literal">port</code> number.</p></div></div><pre class="programlisting">        &lt;site name="Stocklist" id="43"&gt; &#13;
                        &lt;application path="/"&#13;
                        applicationPool="Clr4IntegratedAppPool"&gt; &#13;
                            &lt;virtualDirectory path="/" &#13;
physicalPath="C:\Users\Michael\Documents\Stocklist\Stocklist" /&gt; &#13;
                        &lt;/application&gt; &#13;
                        &lt;bindings&gt; &#13;
                            &lt;binding protocol="http" bindingInformation="*:&#13;
                            {PORT}:localhost" /&gt; &#13;
                        &lt;/bindings&gt; &#13;
        &lt;/site&gt; &#13;
</pre></li><li class="listitem">In the <code class="literal">&lt;bindings&gt;</code> section, we want to add another row:<pre class="programlisting">        &lt;binding protocol="http" bindingInformation="*:{PORT}:{IPv4 Address}" /&gt;  &#13;
</pre></li><li class="listitem">Now we want to allow incoming connections on this <code class="literal">PORT</code> and <code class="literal">IPv4 Address</code> from other computers.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note77"/>Note</h3><p>If you're running Windows 7, most incoming connections are locked down, so you need to specifically allow incoming connections to your application.</p></div></div></li><li class="listitem">First, start an administrative command prompt and run these commands, replacing <code class="literal">{IPv4}:{PORT}</code> with the <code class="literal">IPv4 Address</code> and <code class="literal">PORT</code> you are using:<pre class="programlisting">        &gt; netsh http add urlacl url=http://{IPv4}:{PORT}/ user=everyone &#13;
</pre></li><li class="listitem">This just tells <code class="literal">http.sys that it's OK to talk to this URL</code>. Next, run the following command:<pre class="programlisting">
<span class="strong"><strong>        &gt; netsh advfirewall firewall add rule name="IISExpressWeb"&#13;
        dir=in protocol=tcp localport={PORT} profile=private&#13;
        remoteip=localsubnet action=allow</strong></span>
</pre></li><li class="listitem">This adds a rule in the Windows Firewall, allowing incoming connections to the port for computers on your local subnet.</li><li class="listitem">Now we should be able to access the running API from our Mac instance. This time, paste the URL with the IPv4 address instead of <code class="literal">localhost: {IPv4 address}:{port}/api/StockItems</code>.</li><li class="listitem">If all was successful, we should have the following XML layout displayed like this:<div class="mediaobject"><img src="graphics/B05293_05_11.jpg" alt="Hosting the Web API project locally"/></div></li><li class="listitem">Excellent! Now let's add these URL settings to our mobile application. Open up the <code class="literal">Config.resx</code> file in the <code class="literal">Resources</code> folder of the <code class="literal">Stocklist.Portable </code>project, and fill in these values:<pre class="programlisting">            &lt;data name="ApiAllItems" xml:space="preserve"&gt; &#13;
                &lt;value&gt;http://{IPv4}:{PORT}/api/StockItems&lt;/value&gt; &#13;
            &lt;/data&gt; &#13;
            &lt;data name="GetById" xml:space="preserve"&gt; &#13;
                &lt;value&gt;http://{IPv4}:{PORT}/api/GetItemById&lt;/value&gt; &#13;
            &lt;/data&gt; &#13;
</pre></li></ol></div><p>Now let's test our project on iOS and Android, and we should be able to see our <code class="literal">StocklistPage</code> fill with items from our API controller.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec76"/>Summary</h1></div></div></div><p>In this chapter, we have built an application for retrieving a web service using <code class="literal">Xamarin.Forms</code>. We set up a <code class="literal">ListView</code> and created an <code class="literal">ObservableCollection</code> for displaying JSON objects. We also learned how to set up a simple web service on the back end. In the next chapter, we will create an application for both iOS and Android using the native libraries. We will use Signal R on the client and server side, and set up a hub and proxy connections via a client.</p></div></body></html>