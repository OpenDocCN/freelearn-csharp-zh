- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Unit Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Until now, we’ve been focusing on creating the app, but there is danger in going
    too far without introducing unit testing. In this chapter, we will focus on writing
    comprehensive and meaningful unit tests using best practices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直专注于创建应用程序，但如果不引入单元测试就做得太过分，是有风险的。在本章中，我们将专注于使用最佳实践编写全面而有意义的单元测试。
- en: Test-driven development (TDD)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发（TDD）
- en: Some developers believe that unit tests should come *before* the code (TDD),
    but that is beyond the scope of this book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者认为单元测试应该在代码之前（TDD）进行，但这超出了本书的范围。
- en: Unit testing is crucial to creating robust applications and knowing that your
    app works before you ship it. It is also a critical aspect of debugging, telling
    you right away if something you just changed or added broke some aspect of your
    app.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试对于创建健壮的应用程序和确保在发货前您的应用程序正常工作至关重要。它也是调试的关键方面，可以立即告诉您您刚刚更改或添加的内容是否破坏了应用程序的某些方面。
- en: To facilitate unit tests, you’ll want to use dependency injection so that you
    can mock up time-consuming services, such as APIs, databases, and so on. We’ll
    spend time with mocks, injected into our test classes, to ensure that we are processing
    data as intended.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于进行单元测试，您希望使用依赖注入，这样您就可以模拟耗时的服务，例如API、数据库等。我们将花费时间与模拟一起，确保我们正在按预期处理数据。
- en: 'The specific topics in this chapter are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的具体内容包括：
- en: Why create unit tests?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么创建单元测试？
- en: Getting started creating unit tests
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始创建单元测试
- en: Mocks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟
- en: Dependency injection
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入
- en: NSubstitute
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NSubstitute
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with this chapter, you will need Visual Studio. You will also
    install two NuGet packages, as shown in the chapter itself. If you are going to
    enter the code as you go, you’ll want to start with the source from the previous
    chapter: [https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/persistence](https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/persistence).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章内容，您需要Visual Studio。您还需要安装两个NuGet包，具体请参考本章本身所示。如果您打算边读边输入代码，您应该从上一章的源代码开始：[https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/persistence](https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/persistence)。
- en: 'The source code for this chapter can be found here: [https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/UnitTests](https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/UnitTests).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在以下位置找到：[https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/UnitTests](https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/UnitTests)。
- en: Why create unit tests?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么创建单元测试？
- en: There are many types of tests you will want to run on a production app. These
    include unit tests (testing one small part of an app – typically, a method), integration
    tests (how well the parts of the program run together), UI tests (making sure
    that interacting with the UI acts as expected), and end-to-end tests (making sure
    the entire program works as expected).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在生产应用程序上运行许多类型的测试。这些包括单元测试（测试应用程序的一个小部分——通常是方法）、集成测试（程序各部分运行在一起的效果）、UI测试（确保与UI的交互按预期进行）和端到端测试（确保整个程序按预期工作）。
- en: '**Unit tests** are a critical part of this process and are created for every
    method and every unit of logic. In fact, multiple tests are typically created
    for each unit, so that you can test the happy path, the sad path, and corner conditions.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**是这个过程的关键部分，并为每个方法和每个逻辑单元创建。实际上，通常为每个单元创建多个测试，以便您可以测试happy path、sad
    path和边界条件。'
- en: The **happy path** is when the data is as expected. The **sad path** is when
    the data is predictably wrong (for example, the user does not enter a required
    field).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**happy path**是指数据符合预期的情况。**sad path**是指数据可预测地错误（例如，用户未输入必填字段）的情况。'
- en: '`123` as the username).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: （以`123`作为用户名）。
- en: A key benefit of unit tests is that they make your code less *brittle*. Without
    unit tests, it is easy to get into a situation where a change over here breaks
    code over there, and you don’t know about the breakage until either you run the
    entire program or, worse, your customer finds it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的一个关键好处是它们可以使您的代码更少**脆弱**。没有单元测试，很容易陷入一种情况，即这里的更改破坏了那里的代码，而您直到运行整个程序或更糟糕的是，您的客户发现了这个问题，才知道代码被破坏了。
- en: Key to all of this is that research has shown that it is easier and less expensive
    to fix a bug found during a unit test than it is to find bugs found later. For
    example, in the 1990s, Capers Jones analyzed data about bugs from more than 400
    software projects and found that the cost of fixing a bug increased by a factor
    of 6 to 7 for every phase of development.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切的关键是，研究表明，在单元测试期间发现的错误比在开发后期发现的错误更容易修复且成本更低。例如，在20世纪90年代，Capers Jones分析了400多个软件项目的错误数据，并发现每个开发阶段的错误修复成本增加了6到7倍。
- en: Furthermore, unit tests act as excellent documentation for your app, describing
    precisely what you expect to happen under a wide variety of situations. Unlike
    comments, which rust – that is, become out of sync with the code – unit tests
    can never depart from the code because they will break when your code changes
    in ways that make the expected outcome change.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，单元测试是应用程序的优秀文档，精确地描述了在广泛的情况下你期望发生什么。与注释不同，注释会生锈——也就是说，与代码不同步——单元测试永远不会脱离代码，因为当你的代码以使预期结果发生变化的方式改变时，它们会中断。
- en: Vote early and vote often
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 早早投票，经常投票
- en: It is important to run all of your unit tests after every change you make to
    the code. You want to catch inadvertent and unwanted side effects as quickly as
    possible. However, for this to work, your unit tests must be *fast*. A suite of
    unit tests that take an appreciable amount of time to run will be used less often.
    The longer they take to run, the less frequently the programmer will run them.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在你对代码进行每次更改后运行所有单元测试是很重要的。你希望尽快捕捉到意外的和不受欢迎的副作用。然而，为了实现这一点，你的单元测试必须是**快速的**。一套运行时间较长的单元测试会被使用得较少。它们运行的时间越长，程序员运行它们的频率就越低。
- en: Good unit tests are not only fast but also *isolated* from one another. That
    means that one unit test does not depend on the outcome or state of another –
    it should not matter what order they are run in.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的单元测试不仅速度快，而且彼此之间是**隔离的**。这意味着一个单元测试不依赖于另一个测试的结果或状态——它们的运行顺序不应该有任何影响。
- en: 'You want to be able to look at the outcome of unit tests and immediately identify
    what went wrong so that you can fix it quickly. To accomplish this, your unit
    tests should do the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望能够查看单元测试的结果，并立即识别出出了什么问题，以便你可以快速修复它。为了实现这一点，你的单元测试应该做到以下几点：
- en: Test exactly one thing at a time
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次只测试一个东西
- en: Be well named
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名要规范
- en: If you test more than one thing in a unit test and that test fails, you won’t
    know which of the things was the culprit. Well-named unit tests make it clear
    at a glance what they are testing and thus what went wrong.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个单元测试中测试了多个东西，并且测试失败，你将不知道哪个问题是罪魁祸首。命名良好的单元测试可以让你一眼看出它们在测试什么，以及出了什么问题。
- en: 'This is an example of a bad unit test name: `DoesGetBuddiesWork`.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个糟糕的单元测试名称示例：`DoesGetBuddiesWork`。
- en: 'This is a good unit test name: `GettingBuddiesListDoesNotThrowAnException`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个好的单元测试名称：`GettingBuddiesListDoesNotThrowAnException`。
- en: If the test fails, a glance at the name of the *good unit test name* tells you
    exactly what went wrong.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试失败，查看**好的单元测试名称**可以立即告诉你出了什么问题。
- en: Unit test names
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试名称
- en: 'Some programmers use very rigid naming schemes for unit tests. For example,
    some will create the name by the name of the method followed by the condition
    followed by the expected outcome. So, you might have a name like this: `GetBuddiesList_WhenEmpty_ShouldNotThrowAnException`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员为单元测试使用非常严格的命名方案。例如，有些人会通过方法的名称、条件以及预期的结果来创建名称。所以，你可能会有这样的名称：`GetBuddiesList_WhenEmpty_ShouldNotThrowAnException`。
- en: These can be useful, as glancing at the name of the test gives you a lot of
    information.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是有用的，因为浏览测试名称可以给你提供很多信息。
- en: Remember, as the program grows, so too will your set of unit tests. When you
    have hundreds (or even thousands), you’ll want to be able to zip through your
    tests so quickly that you don’t mind running them after each meaningful change,
    and when one or more fail, you want to know what was tested without having to
    open up the test and look.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，随着程序的扩展，你的单元测试集也会随之增长。当你有成百（甚至上千）个测试时，你希望能够快速地浏览你的测试，以至于你不会介意在每次有意义的更改后运行它们，并且当其中一个或多个测试失败时，你希望知道测试了什么，而无需打开测试文件查看。
- en: Creating unit tests
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建单元测试
- en: 'To get started, right-click on the solution and choose **Add New Project**.
    In the dialog box, use the dropdown to pick **UnitTest**. There are a number of
    unit test frameworks. The two most popular are the older **NUnit** and the newer
    **xUnit**. We’ll choose **xUnit Test Project**, as shown in *Figure 9**.1*:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，右键单击解决方案并选择 **添加新项目**。在对话框中，使用下拉菜单选择 **单元测试**。有多个单元测试框架。最受欢迎的是较老的 **NUnit**
    和较新的 **xUnit**。我们将选择 **xUnit 测试项目**，如图 *图 9**.1* 所示：
- en: '![Figure 9.1 – Selecting the unit test type'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.1 – 选择单元测试类型'
- en: '](img/Figure_9.1_B19723.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.1_B19723.jpg)'
- en: Figure 9.1 – Selecting the unit test type
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 选择单元测试类型
- en: 'Click `.Tests`, as shown in the following figure:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `.Tests`，如图所示：
- en: '![Figure 9.2 – Naming the test project'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.2 – 命名测试项目'
- en: '](img/Figure_9.2_B19723.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.2_B19723.jpg)'
- en: Figure 9.2 – Naming the test project
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 命名测试项目
- en: Click **Next** and select the .NET platform (this book will use .NET 7).
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **下一步** 并选择 .NET 平台（本书将使用 .NET 7）。
- en: Visual Studio will create your project as well as the first unit test class
    and method. Since this is generic, delete that class and create one called `PreferencesTests`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 将创建你的项目以及第一个单元测试类和方法。由于这是通用的，请删除该类并创建一个名为 `PreferencesTests` 的类。
- en: Setting the project reference
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置项目引用
- en: 'Before doing anything else, we need to make `ForgetMeNotDemo.Tests` aware of
    the `ForgetMeNotDemo` project. To do so, right-click on the test project and select
    **Add** | **ProjectReference**, and check the box next to **ForgetMeNotDemo**,
    as shown in *Figure 9**.3*:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在做任何事情之前，我们需要让 `ForgetMeNotDemo.Tests` 知道 `ForgetMeNotDemo` 项目。为此，右键单击测试项目并选择
    **添加** | **项目引用**，并在 **ForgetMeNotDemo** 旁边勾选复选框，如图 *图 9**.3* 所示：
- en: '![Figure 9.3 – Referencing ForgetMeNotDemo from the unit test project'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.3 – 从单元测试项目中引用 ForgetMeNotDemo'
- en: '](img/Figure_9.3_B19723.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.3_B19723.jpg)'
- en: Figure 9.3 – Referencing ForgetMeNotDemo from the unit test project
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 从单元测试项目中引用 ForgetMeNotDemo
- en: With all that set up, we are ready to write our first unit test, designed only
    to ensure that the testing structure is in place and working.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好所有这些之后，我们就准备好编写我们的第一个单元测试了，这个测试仅用于确保测试结构已就位且正在运行。
- en: Note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This will not build. Please refer to the *Tweaking the project file* section
    that appears later in the chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将无法构建。请参阅本章后面出现的 *调整项目文件* 部分。
- en: Creating the first unit test
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建第一个单元测试
- en: 'To make sure all is right with the world, open `UnitTest1` and add a test method
    that must pass:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保世界一切正常，打开 `UnitTest1` 并添加一个必须通过测试的方法：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'xUnit tests come in two flavors:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: xUnit 测试有两种类型：
- en: '**Facts**: These are invariants – they always take the same data and should
    always pass'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事实**：这些是不变的 – 它们总是使用相同的数据，并且应该总是通过'
- en: '**Theories**: These are a suite of tests that execute the same code but are
    given different input arguments'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理论**：这是一套执行相同代码但给定不同输入参数的测试'
- en: Let’s explore the theories. The first test we created, `MustBeTrue`, simply
    asserts that the value true is `true`. This makes a good first test, as it will
    test that your unit testing is set up correctly.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索理论。我们创建的第一个测试 `MustBeTrue` 简单地断言值 `true` 是 `true`。这是一个很好的第一个测试，因为它将测试你的单元测试是否设置正确。
- en: To run this test, click on the **Test** | **Run All Tests** menu item – but
    be warned, *it* *won’t work!*
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此测试，请单击 **测试** | **运行所有测试** 菜单项 – 但请注意，*它* *不会工作*！
- en: In order to make this work, there is a bit of tweaking we have to do to the
    project file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这可行，我们需要对项目文件进行一些调整。
- en: Tweaking the project file
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整项目文件
- en: 'The problem is that your .NET MAUI `.csproj` project file lists the following
    `TargetFrameworks`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于你的 .NET MAUI `.csproj` 项目文件列出了以下 `TargetFrameworks`：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However, the unit test project file looks like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，单元测试项目文件看起来像这样：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To fix this discrepancy, exit Visual Studio and open your .NET MAUI project
    `.csproj` file using your favorite text editor (not Word or other programs that
    add special characters – I like to use Visual Studio Code, but whatever floats
    your boat). Modify `<TargetFramework>` to include .`net7.0`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这种差异，退出 Visual Studio 并使用你喜欢的文本编辑器（不是 Word 或其他添加特殊字符的程序 – 我喜欢使用 Visual Studio
    Code，但随便你用什么）打开你的 .NET MAUI 项目 `.csproj` 文件。将 `<TargetFramework>` 修改为包含 `.net7.0`：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You’re halfway there. The next issue is that we need to output the test as
    a DLL, but the output for the project is an EXE. The best way to fix this is to
    add a condition – only do the output as an EXE when the target framework is not
    7.0:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经完成了一半。下一个问题是，我们需要将测试输出为 DLL，但项目的输出是 EXE。最好的解决方法是添加一个条件 - 只有当目标框架不是 7.0 时才输出为
    EXE：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Reopen Visual Studio and open the solution. Your test should work now.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 重新打开 Visual Studio 并打开解决方案。您的测试现在应该可以工作了。
- en: Running the test
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'First, rename `UnitTest1` to `PreferencesTests`. Next, go to the menu and select
    **Test** | **Test Explorer**. This will open (surprise!) **Test Explorer**. Click
    the green *Play* button, as shown in *Figure 9**.4*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将 `UnitTest1` 重命名为 `PreferencesTests`。然后，转到菜单并选择 **测试** | **测试探索器**。这将打开（惊喜！）**测试探索器**。点击如图
    *图 9**.4* 所示的绿色 *播放* 按钮：
- en: '![Figure 9.4 – The Play button'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.4 – 播放按钮'
- en: '](img/Figure_9.4_B19723.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.4_B19723.jpg)'
- en: Figure 9.4 – The Play button
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 播放按钮
- en: 'Your project will build and Test Explorer will run your test, showing you results
    as shown in *Figure 9**.5*:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目将构建并测试探索器将运行您的测试，并显示如图 *图 9**.5* 所示的结果：
- en: '![Figure 9.5 – Test results'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.5 – 测试结果'
- en: '](img/Figure_9.5_B19723.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.5_B19723.jpg)'
- en: Figure 9.5 – Test results
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 测试结果
- en: Reading down from the top, it shows that `ForgetMeNotDemo.Tests` has one test,
    and the green check indicates that all the tests in `ForgetMeNotDemo.Tests` have
    passed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部向下阅读，它显示 `ForgetMeNotDemo.Tests` 有一个测试，绿色勾选表示 `ForgetMeNotDemo.Tests` 中的所有测试都已通过。
- en: Inside `ForgetMeNotDemo.Tests` will be a list of all the test classes – in this
    case, just the one, `PreferencesTests`, and this too shows that there is one test
    and that it passed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ForgetMeNotDemo.Tests` 内将有一个所有测试类的列表 - 在这种情况下，只有一个，`PreferencesTests`，这也显示有一个测试并且它通过了。
- en: Finally, inside `PreferencesTests` will be a list of each individual test, and
    again, the green check indicates the test passed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `PreferencesTests` 内将有一个每个单独测试的列表，再次，绿色勾选表示测试通过。
- en: Congratulations, you’ve created your first test, run it, and seen it pass!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您已经创建了第一个测试，运行了它，并看到了它通过！
- en: Now, let’s settle down to writing some tests for `ForgetMeNotDemo`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们坐下来为 `ForgetMeNotDemo` 编写一些测试。
- en: ForgetMeNotDemo unit tests
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ForgetMeNotDemo 单元测试
- en: To get started, we examine one ViewModel at a time, paying attention to the
    methods. We do this because what we want to test is the business logic, and if
    you’ve done it right, most of your business logic will be in a `ViewModel` class.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们一次检查一个 ViewModel，注意方法。我们这样做是因为我们想要测试的是业务逻辑，如果您做得正确，大部分的业务逻辑将位于 `ViewModel`
    类中。
- en: For example, turning our attention to `PreferencesViewModel`, we see the `Init()`
    method. The job of `Init` is to populate the `PreferenceList` collection. For
    now, we’ll ignore how it does this and just write a test to ensure that it does.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将我们的注意力转向 `PreferencesViewModel`，我们看到 `Init()` 方法。`Init` 的任务是填充 `PreferenceList`
    集合。目前，我们将忽略它是如何做到这一点的，只是编写一个测试来确保它确实如此。
- en: Implementing the triple-A pattern
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 AAA 模式
- en: Before we start, create an interface for `PreferenceService`, as described earlier
    in the book (open `PreferenceService`, right-click on the class name, and choose
    **Extract Interface**).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，创建一个 `PreferenceService` 的接口，正如本书前面所描述的（打开 `PreferenceService`，右键单击类名，并选择
    **提取接口**）。
- en: 'A classic design pattern for unit tests is the **Arrange, Act, Assert** (**AAA**)
    pattern. That is, you set up your test (Arrange), then you call a method or two
    (Act), and then check to make sure you have the expected results (Assert). Let’s
    see this in action (note, this test has two flaws that will be discussed):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的经典设计模式是 **Arrange, Act, Assert** (**AAA**) 模式。也就是说，您设置测试（Arrange），然后调用一个或两个方法（Act），然后检查以确保您得到了预期的结果（Assert）。让我们看看它是如何实施的（注意，这个测试有两个缺陷将在后面讨论）：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we set up `IPreferenceService`, which we’ll need to create `PreferencesViewModel`,
    and then we create an instance of that `ViewModel`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了 `IPreferenceService`，这是我们创建 `PreferencesViewModel` 所需要的，然后我们创建了一个该
    `ViewModel` 的实例。
- en: With that in place, we can call the `Init()` method.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们可以调用 `Init()` 方法。
- en: 'Now, we will test the results using Assert. Assert has many methods that you
    can use to test the success of your test. These include, but are not limited to,
    the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用 Assert 来测试结果。Assert 有许多方法，您可以使用它们来测试测试的成功。这些包括但不限于以下内容：
- en: '`Assert.True`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assert.True`'
- en: '`Assert.False`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assert.False`'
- en: '`Assert.Equal<T>(T expected,` `T actual)`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assert.Equal<T>(T expected, T actual)`'
- en: '`Assert.InRange<T>(T actual, T low,` `T high)`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assert.InRange<T>(T actual, T low, T high)`'
- en: '`Assert.Null`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assert.Null`'
- en: '`Assert.NotNull`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assert.NotNull`'
- en: '`Assert.IsType<T>(object obj)`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assert.IsType<T>(object obj)`'
- en: '`Assert.Empty(IenumerableCollection)`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assert.Empty(IenumerableCollection)`'
- en: '`Assert.Contains<T>(T expected,` `Ienumerable<t> collection)`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assert.Contains<T>(T expected,` `Ienumerable<t> collection)`'
- en: 'There are many more too. The definitive list can be found at the `xUnit` repository:
    [https://github.com/xunit/assert.xunit/blob/main/Assert.cs](https://github.com/xunit/assert.xunit/blob/main/Assert.cs).
    The various Asserts are arranged as classes, each of which has a variety of `Assert`
    methods. A partial list is shown in *Figure 9**.6*:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多。完整的列表可以在`xUnit`仓库中找到：[https://github.com/xunit/assert.xunit/blob/main/Assert.cs](https://github.com/xunit/assert.xunit/blob/main/Assert.cs)。各种断言被组织成类，每个类都有各种`Assert`方法。部分列表如图*9**.6*所示：
- en: '![Figure 9.6 – A partial list of Assert classes'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.6 – 断言类部分列表'
- en: '](img/Figure_9.6_B19723.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.6_B19723.jpg)'
- en: Figure 9.6 – A partial list of Assert classes
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 断言类部分列表
- en: 'In our case, we are asserting that, after running `Init`, `PreferenceList`
    is not empty. Open **Test Explorer** and click on the **Run All Tests In View**
    button, as shown here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们断言在运行`Init`之后，`PreferenceList`不为空。打开**测试资源管理器**，然后点击**运行视图中的所有测试**按钮，如图所示：
- en: '![Figure 9.7 – Run All Tests In View button'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.7 – 运行视图中的所有测试按钮'
- en: '](img/Figure_9.7_B19723.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.7_B19723.jpg)'
- en: Figure 9.7 – Run All Tests In View button
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 运行视图中的所有测试按钮
- en: 'The tests run, and Test Explorer gives us the results, as shown in the following
    figure:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行后，测试资源管理器会给我们显示结果，如下图所示：
- en: '![Figure 9.8 – Test Explorer results'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.8 – 测试资源管理器结果'
- en: '](img/Figure_9.8_B19723.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.8_B19723.jpg)'
- en: Figure 9.8 – Test Explorer results
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – 测试资源管理器结果
- en: 'Let us see what each numbered option in the figure means:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看图中每个编号选项的含义：
- en: '[1] The number of tests'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 测试数量'
- en: '[2] The number of tests that passed'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] 通过的测试数量'
- en: '[3] The number of tests that failed'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[3] 失败的测试数量'
- en: '[4] A summary and statement on how long the test took'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[4] 测试的总结和持续时间说明'
- en: '[5] Each passed test in the context of where the text is located. A green check
    means that it passed, and a red x indicates that it failed. Notice that the time
    for each test is listed. Also note that the tests took at most 6 milliseconds,
    but the entire test suite took 408 ms. The difference is the overhead of beginning
    the test procedure. This will soon be swamped by the time for all the tests.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[5] 在文本所在上下文中的每个通过的测试。绿色勾号表示通过，红色叉号表示失败。注意，每个测试的时间都被列出。还要注意，测试最多花费了6毫秒，但整个测试套件花费了408毫秒。这种差异是开始测试过程的开销。这很快就会被所有测试的时间所淹没。'
- en: What’s wrong with this test?
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这个测试有什么问题？
- en: I mentioned previously that this test has two significant flaws. The first is
    that the call to `Init` may not populate `PreferenceList` because the service
    may return zero records. We’ll need to adjust for that by asserting instead that
    `PreferenceList` is not null.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到，这个测试有两个显著的缺陷。第一个是调用`Init`可能不会填充`PreferenceList`，因为服务可能返回零条记录。我们需要通过断言`PreferenceList`不是null来调整这一点。
- en: 'The second, more important, problem is that the test depends on running `PreferenceService`.
    If we examine the code for `PreferenceService`, we see that the call to `GetPreferences`
    has a significant problem:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个，更重要的问题是，这个测试依赖于运行`PreferenceService`。如果我们检查`PreferenceService`的代码，我们会看到对`GetPreferences`的调用有一个重大问题：
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Right now, while developing the app, we are calling to `GetPreferencesMock`,
    which is just a method in `PreferenceService`. But that is not how we’ll finish
    the app. In [*Chapter 11*](B19723_11.xhtml#_idTextAnchor216), we’ll convert this
    to make an API call. API calls can take an unpredictably long time, and potentially,
    can grind our test to a halt.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在开发应用程序时，我们调用`GetPreferencesMock`，这只是在`PreferenceService`中的一个方法。但那不是我们完成应用程序的方式。在[*第11章*](B19723_11.xhtml#_idTextAnchor216)中，我们将将其转换为进行API调用。API调用可能需要不确定的时间，并且可能会使我们的测试停止。
- en: To solve this, we need a mock `PreferenceService` that both returns quickly
    and returns a predictable collection (or an empty collection if we want to test
    that eventuality).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要一个快速返回且返回可预测集合（或如果我们想测试这种情况，则为空集合）的模拟`PreferenceService`。
- en: Mocks
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟
- en: Often, when testing, you need to interact with a method that takes an indeterminate
    amount of time, such as retrieving data from a database or, worse, retrieving
    data from an API (that is, over the internet rather than locally from your device).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 经常在测试时，你需要与一个需要不确定时间的方法进行交互，例如从数据库中检索数据，或者更糟糕的是，从API（即从互联网而不是从你的设备本地）中检索数据。
- en: Calling this kind of method can bring your unit test to a screeching halt, making
    it almost unusable. To avoid this, we create fake representations of the database
    or the API using an object called a **mock**.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此类方法可能会使你的单元测试突然停止，使其几乎无法使用。为了避免这种情况，我们使用一个名为 **模拟** 的对象创建数据库或 API 的假表示。
- en: 'Mocks offer two advantages: they respond instantly and, perhaps as importantly,
    they respond predictably. Once written, they give the same input and mock will
    always provide the same output.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟提供了两个优点：它们会立即响应，也许更重要的是，它们的响应是可预测的。一旦编写，它们提供相同的输入，模拟将始终提供相同的输出。
- en: In order to use mocks, we’ll need to implement dependency injection for some
    of our classes, so let’s start there.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用模拟，我们需要为我们的一些类实现依赖注入，所以让我们从这里开始。
- en: Dependency injection
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: 'Until now, anytime we needed an object inside a class, we passed in the object
    or we created it in the body of the class. This creates a `PreferencesViewModel`,
    we need a `PreferenceService` object. The approach we’ve taken so far is to *new
    one up* in the constructor:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，每次我们需要在类内部使用一个对象时，我们都是传入该对象，或者在类的主体中创建它。这会创建一个 `PreferencesViewModel`，我们需要一个
    `PreferenceService` 对象。我们迄今为止采取的方法是在构造函数中 *new 一个*：
- en: '[PRE7]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Dependency injection decouples the classes and allows for more powerful unit
    testing, as we’ll see when we continue the discussion of mocks. Rather than *newing-up*
    a `PreferenceService`, we want to pass in an interface and have .NET MAUI create
    it for us (that is, no calling function will add the interface to the constructor
    call – it will be done automatically).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入解耦了类，并允许进行更强大的单元测试，正如我们在继续讨论模拟时将看到的。我们不想 *new 一个* `PreferenceService`，而是想传入一个接口，让
    .NET MAUI 为我们创建它（也就是说，没有调用函数会将接口添加到构造函数调用中 – 这将自动完成）。
- en: Not just for testing
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅用于测试
- en: Dependency injection can be used throughout your project, not only for unit
    tests. In fact, when combined with an **Inversion of Control** (**IoC**) container,
    dependency injection creates a powerful pattern for decoupling objects throughout
    the app. More on IoC containers later.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入可以在你的整个项目中使用，而不仅仅是用于单元测试。实际上，当与 **控制反转**（**IoC**）容器结合使用时，依赖注入为在整个应用程序中解耦对象创建了一个强大的模式。关于
    IoC 容器的内容将在后面介绍。
- en: Creating an interface
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建接口
- en: To do this, we first need to create an `IPreferenceService` interface.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要做这件事，我们首先需要创建一个 `IPreferenceService` 接口。
- en: Resharper
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Resharper
- en: Everything I’m about to show uses **Resharper**, an essential tool for serious
    .NET MAUI programmers, but it is not free. You can certainly do all this by hand;
    it is just that Resharper makes it much easier. Since I highly recommend buying
    Resharper, I’ll show you how to do the following with that tool. (Please note,
    as a Microsoft MVP, I get my copy of Resharper for free.)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我将展示的内容都将使用 **Resharper**，这是严肃的 .NET MAUI 程序员的一个必备工具，但它不是免费的。你当然可以手动完成所有这些；只是
    Resharper 让它变得容易得多。由于我强烈推荐购买 Resharper，我将展示如何使用该工具完成以下操作。（请注意，作为微软 MVP，我免费获得我的
    Resharper 复制品。）
- en: 'First, go to **Solution Explorer**, open **PreferenceService**, and follow
    these steps:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，转到 **解决方案资源管理器**，打开 **PreferenceService**，然后按照以下步骤操作：
- en: 'Right-click on the class name and choose **Refactor This**. A context menu
    will appear, as shown in the following figure:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击类名，选择 **重构此**。将出现一个如图所示的上下文菜单：
- en: '![Figure 9.9 – Refactor context menu'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.9 – 重构上下文菜单'
- en: '](img/Figure_9.9_B19723.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.9_B19723.jpg)'
- en: Figure 9.9 – Refactor context menu
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 重构上下文菜单
- en: 'Select **Extract Interface**, and a dialog box will appear as shown here:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **提取接口**，将出现一个如图所示的对话框：
- en: '![Figure 9.10 – Extracting the interface'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.10 – 提取接口'
- en: '](img/Figure_9.10_B19723.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.10_B19723.jpg)'
- en: Figure 9.10 – Extracting the interface
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – 提取接口
- en: Be sure to check all the public methods and choose the **Its own file** radio
    button for where to move the interface.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保选中所有公共方法，并选择将接口移动到 **其自己的文件** 单选按钮。
- en: 'Hey, presto! You’ll have an interface file in the same directory (`Services`),
    as shown in *Figure 9**.11*:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，奇迹！你将在同一目录（`Services`）中有一个接口文件，如图 *图 9.11* 所示：
- en: '![Figure 9.11 – New interface file in the Services folder'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.11 – 在服务文件夹中创建新的接口文件'
- en: '](img/Figure_9.11_B19723.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.11_B19723.jpg)'
- en: Figure 9.11 – New interface file in the Services folder
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – 在服务文件夹中创建新的接口文件
- en: 'Open your new file and you’ll see a typical C# interface:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的新文件，你会看到一个典型的 C# 接口：
- en: '[PRE8]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, check the original `PreferenceService`. Resharper was nice enough to designate
    that `PreferenceService` implements `IPreferenceService`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，检查原始的 `PreferenceService`。Resharper 足够友好地指定了 `PreferenceService` 实现 `IPreferenceService`：
- en: '[PRE9]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Please make `PreferenceService.GetPreferencesMock` public.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请将 `PreferenceService.GetPreferencesMock` 公开。
- en: With an interface, we can use constructor injection – that is, we can define
    that we’re going to pass an instance of the interface into the constructor, and
    then pass in anything that implements that interface.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用接口，我们可以使用构造函数注入——也就是说，我们可以定义我们将要传递接口实例到构造函数中，然后传递实现该接口的任何内容。
- en: Modifying the class constructor
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改类构造函数
- en: 'Let’s go back to `PreferencesViewModel`. Since we know we’re going to use dependency
    injection to send `PreferenceService` into `ViewModel`, we can modify the declaration
    of `PreferenceService` and the constructor:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 `PreferencesViewModel`。由于我们知道我们将使用依赖注入将 `PreferenceService` 发送到 `ViewModel`，我们可以修改
    `PreferenceService` 的声明和构造函数：
- en: '[PRE10]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[1] We change the local service member to an interface.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 我们将局部服务成员更改为接口。'
- en: '[2] We pass `IPreferenceService` into the constructor.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] 我们将 `IPreferenceService` 传递到构造函数中。'
- en: '[3] We assign the member to the passed-in parameter.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[3] 我们将成员分配给传入的参数。'
- en: But who calls `PreferencesViewModel` with the `IPreference` service, and where
    does that method get it?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 但是谁调用带有 `IPreference` 服务的 `PreferencesViewModel`，那个方法又是从哪里获取它的？
- en: The answer is that the IoC container is responsible for all of this.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是 IoC 容器负责所有这些。
- en: The .NET MAUI IoC container
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET MAUI IoC 容器
- en: '.NET MAUI has a built-in IoC container that we use by registering the interfaces
    we want to be managed. You do this in the `CreateMauiApp` method in `MauiProgram.cs`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 内置了一个 IoC 容器，我们通过注册我们想要管理的接口来使用它。你可以在 `MauiProgram.cs` 中的 `CreateMauiApp`
    方法中这样做：
- en: '[PRE11]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As seen in `[1]`, the first thing we do is instantiate a `MauiAppBuilder` object.
    We then tack a number of other configuration requirements onto the Builder.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如 `[1]` 中所示，我们首先实例化一个 `MauiAppBuilder` 对象。然后，我们在构建器上附加了许多其他配置要求。
- en: We’ll use that to register all the interfaces to all our services. In fact,
    we’ll also register our views and ViewModels so that we can pass them into methods
    using dependency injection.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用它来注册所有接口到我们的服务中。实际上，我们还将注册我们的视图和 ViewModels，这样我们就可以通过依赖注入将它们传递到方法中。
- en: Registering your interfaces, services, and ViewModels
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册你的接口、服务和 ViewModels
- en: .NET MAUI provides an IoC container. By registering our interfaces, services,
    and so on, .NET MAUI will supply what we need when we need it, without our having
    to *new-up* instances. Beyond that, the IoC container will also fix up all the
    dependencies.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 提供了一个 IoC 容器。通过注册我们的接口、服务等，.NET MAUI 将在我们需要时提供所需的内容，而无需我们手动创建实例。除此之外，IoC
    容器还将解决所有依赖关系。
- en: 'To register the `IPreferences` interface, we add a call to `Builder.Services.AddTransient`,
    passing in the interface and the class that implements that interface:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册 `IPreferences` 接口，我们添加一个调用 `Builder.Services.AddTransient`，传入接口和实现该接口的类：
- en: '[PRE12]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`Builder.Services` offers two ways to register your interface:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`Builder.Services` 提供了两种注册接口的方式：'
- en: '`AddTransient`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddTransient`'
- en: '`AddSingleton`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddSingleton`'
- en: You’ll use `AddTransient` when you may or may not instantiate the object (we
    may never look at the user’s preferences, and thus may never need the service).
    You use `AddSingleton` when you know you’ll want the object and there is no point
    in creating more than one.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当你可能或可能不会实例化对象时，你会使用 `AddTransient`（我们可能永远不会查看用户的偏好设置，因此可能永远不会需要该服务）。当你知道你将需要该对象，并且创建多个对象没有意义时，你会使用
    `AddSingleton`。
- en: 'While we’re here, let’s register all the ViewModels. We don’t need interfaces
    for them, as we won’t be passing them anywhere via dependency injection:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在这里时，让我们注册所有 ViewModels。我们不需要为它们提供接口，因为我们不会通过依赖注入将它们传递到任何地方：
- en: '[PRE13]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Putting it together, this is what `CreateMauiApp` looks like now:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们组合起来，这就是现在的 `CreateMauiApp` 看起来的样子：
- en: '[PRE14]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that all the registration happens before we return the result of calling
    `Build` on the `Builder` object.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有的注册都是在我们在 `Builder` 对象上调用 `Build` 的结果返回之前发生的。
- en: We will be using dependency injection to inject mock objects where objects that
    would otherwise take an unpredictable amount of time would normally be used. That
    is, rather than waiting for a database or API call, we can inject a mock database
    or a mock service and get back a response instantly and predictably.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用依赖注入来注入模拟对象，这些对象通常会被用于不可预测的时间。也就是说，我们不必等待数据库或API调用，我们可以注入一个模拟数据库或模拟服务，并立即得到一个可预测的响应。
- en: Our first decision is which mocking library to use.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是决定使用哪个模拟库。
- en: Using the NSubstitute package
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NSubstitute包
- en: There are a number of different mocking libraries available to you, some free
    and some commercial. For this book, we’ll use **NSubstitute**, an open source
    and free option available as a NuGet package.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的模拟库可供选择，有些是免费的，有些是商业的。对于这本书，我们将使用**NSubstitute**，这是一个开源且免费的选项，可以作为NuGet包使用。
- en: 'To get started, follow these steps:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请按照以下步骤操作：
- en: Right-click on your solution and choose **ManageNugetPackagesForSolution**.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击你的解决方案，选择**ManageNugetPackagesForSolution**。
- en: Go to the `NSubstitute`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`NSubstitute`。
- en: 'The first package you want is **NSubstitute** by Anthony Egerton et al., as
    shown here:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要的第一包是Anthony Egerton等人编写的**NSubstitute**，如图所示：
- en: '![Figure 9.12 – NSubstitute NuGet package'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.12 – NSubstitute NuGet包'
- en: '](img/Figure_9.12_B19723.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.12_B19723.jpg)'
- en: Figure 9.12 – NSubstitute NuGet package
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 – NSubstitute NuGet包
- en: 'On the right, click on the project you want this added to (`ForgetMeNotDemo.Tests`)
    and click on **Install**, as shown in *Figure 9**.13*:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧，点击你想要添加此内容的工程（`ForgetMeNotDemo.Tests`），然后点击**Install**，如图*图9.13*所示：
- en: '![Figure 9.13 – Installing NSubstitute'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.13 – 安装NSubstitute'
- en: '](img/Figure_9.13_B19723.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.13_B19723.jpg)'
- en: Figure 9.13 – Installing NSubstitute
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 – 安装NSubstitute
- en: 'Once that installs, install **NSubstitute.Analyzers.CSharp**, as shown in the
    following figure:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，安装**NSubstitute.Analyzers.CSharp**，如图所示：
- en: '![Figure 9.14 – Selecting NSubstitute.Analyzers.CSharp'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.14 – 选择NSubstitute.Analyzers.CSharp'
- en: '](img/Figure_9.14_B19723.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.14_B19723.jpg)'
- en: Figure 9.14 – Selecting NSubstitute.Analyzers.CSharp
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 – 选择NSubstitute.Analyzers.CSharp
- en: While not strictly required, this second library will detect potential mistakes
    in your use of NSubstitute. Install it into the test project as you did previously.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是强制性的，但这个第二个库将检测你在使用NSubstitute时可能犯的错误。像之前一样将其安装到测试项目中。
- en: Adding NSubstitute to your test fixture
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将NSubstitute添加到测试固定装置中
- en: To add NSubstitute to your test fixture, add `using NSubstitute;` to the top
    of the C# file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要将NSubstitute添加到测试固定装置中，请将`using NSubstitute;`添加到C#文件的顶部。
- en: We can now create a substitute for `PreferenceService`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建`PreferenceService`的替代品。
- en: Mocks depend on constructor dependency injection
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟依赖于构造函数依赖注入
- en: 'Turn to the constructor in `PreferencesViewModel` and notice that the service
    is injected as an interface:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 转到`PreferencesViewModel`的构造函数，注意服务被注入为一个接口：
- en: '`public` `PreferencesViewModel(IPreferenceService service)`'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`public` `PreferencesViewModel(IPreferenceService service)`'
- en: '`{`'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`{`'
- en: '`this.service =` `service;`'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`this.service =` `service;`'
- en: '`}`'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: This is critical. Mocks only work with constructor injection.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常重要。模拟只与构造函数注入一起工作。
- en: 'Back in our unit test, let’s declare a mock for the service:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的单元测试中，让我们为服务声明一个模拟：
- en: '[PRE15]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[1] Declare the mock for `IpreferenceService`.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 声明`IpreferenceService`的模拟。'
- en: '[2] Pass that mock into the constructor for `PreferencesViewModel`.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] 将该模拟传递给`PreferencesViewModel`构造函数。'
- en: Run the test. It fails with the error that the collection cannot be null. Why?
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试。它因集合不能为空而失败。为什么？
- en: The original service was returning a list of `Preference` objects, but our new
    mock is not. We need to teach the mock to return a predictable set of `Preference`
    objects.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 原始服务返回一个`Preference`对象列表，但我们的新模拟不是。我们需要教会模拟返回一组可预测的`Preference`对象。
- en: 'Here is the top of the `Arrange` method, in which we create a couple of `Preference`
    objects and then add them to a list:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Arrange`方法的顶部，我们在其中创建了一些`Preference`对象，然后将它们添加到一个列表中：
- en: '[PRE16]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can now create our substitute:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建我们的替代品：
- en: '[PRE17]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[1] Create the mock.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 创建模拟。'
- en: '[2] Tell the mock which method it will be mocking.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] 告诉模拟它将模拟哪个方法。'
- en: '[3] Tell the mock what to return when that method is invoked.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[3] 告诉模拟在调用该方法时应该返回什么。'
- en: 'We use the mock in calling the `PreferencesViewModel` constructor, which you
    will remember takes `IpreferenceService`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用模拟来调用`PreferencesViewModel`构造函数，你将记得它需要`IpreferenceService`：
- en: '[PRE18]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the `Act` portion of the test, we’ll call `Init` on that `PreferencesViewModel`
    object and then assert that the list is not empty. This will work this time because
    the service it relies on can now be predicted to return a list of two preferences.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试的`Act`部分，我们将对那个`PreferencesViewModel`对象调用`Init`，然后断言列表不为空。这次会成功，因为所依赖的服务现在可以预测会返回两个首选项的列表。
- en: Testing corner cases
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试边缘情况
- en: 'What happens if `PreferenceService` returns no records? Will that cause `ViewModel`
    to blow up? We can test that:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`PreferenceService`没有返回记录会发生什么？这会导致`ViewModel`崩溃吗？我们可以测试这一点：
- en: '[PRE19]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[1] Set up `List<Preference>` to be empty.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 将`List<Preference>`设置为空。'
- en: '[2] Have the service return the empty preferences list.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] 让服务返回空的首选项列表。'
- en: '[3] Use `Record.ExceptionAsync` and pass in the call to `Init`. This will return
    the exception or null if none was thrown.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[3] 使用`Record.ExceptionAsync`并传入对`Init`的调用。这将返回异常或null，如果没有抛出异常。'
- en: '[4] Assert that there was no exception thrown.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[4] 断言没有抛出异常。'
- en: A complete description of all the uses of NSubstitute is available at [https://nsubstitute.github.io/help.html](https://nsubstitute.github.io/help.html).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 所有NSubstitute用法的完整描述可在[https://nsubstitute.github.io/help.html](https://nsubstitute.github.io/help.html)找到。
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed the critical importance of writing unit tests and
    comprehensively testing your program. In a nutshell, unit tests allow you to code
    with confidence, knowing that if you make a change and it breaks something seemingly
    unrelated, you’ll find out about it immediately.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了编写单元测试和全面测试程序的重要性。简而言之，单元测试允许你自信地编码，知道如果你进行更改并且它破坏了看似无关的东西，你将立即发现。
- en: We saw that, at times, your unit test must interact with slower external systems
    (APIs, databases, and more) and that you can keep your subsecond response time
    by using mocks; the mocking library we chose is `NSubstitute`, though there are
    other free mocking systems as well (a very popular one is **Moq**).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，有时你的单元测试必须与较慢的外部系统（API、数据库等）交互，并且你可以通过使用模拟来保持亚秒级响应时间；我们选择的模拟库是`NSubstitute`，尽管还有其他免费的模拟系统（一个非常流行的是**Moq**）。
- en: In order to facilitate using mocks, we looked at dependency injection and briefly
    reviewed the role of IoC containers. In the next chapter, *Consuming a Rest Service*,
    we will look at getting our data from a cloud-based (Azure) service, rather than
    mocking the data.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于使用模拟，我们探讨了依赖注入并简要回顾了IoC容器的作用。在下一章*消费REST服务*中，我们将查看从基于云的服务（Azure）获取数据，而不是模拟数据。
- en: Quiz
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问答
- en: Why is it important to write unit tests?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么编写单元测试很重要？
- en: Where is most of the code you will test?
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将测试的大部分代码在哪里？
- en: Why do you use mocks?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么使用模拟？
- en: Why is dependency injection important for mocks?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么依赖注入对模拟很重要？
- en: You try it
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你试试看
- en: Identify a method in the ViewModel or service that interacts with the API or
    database, and write a unit test that uses a mock.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 识别ViewModel或服务中与API或数据库交互的方法，并编写一个使用模拟的单元测试。
- en: Part 3 – Advanced Topics
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分 - 高级主题
- en: In this final part, we will dive into ninja-level topics, including how to interact
    with a REST-based service (in our case, Azure) and how to modify the appearance
    of our app based on the runtime data.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后一部分，我们将深入探讨忍者级别的主题，包括如何与基于REST的服务（在我们的案例中是Azure）进行交互，以及如何根据运行时数据修改我们应用程序的外观。
- en: 'This part has the following chapters:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 10*](B19723_10.xhtml#_idTextAnchor187), *Consuming REST Services*'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B19723_10.xhtml#_idTextAnchor187)，*消费REST服务*'
- en: '[*Chapter 11*](B19723_11.xhtml#_idTextAnchor216), *Exploring Advanced Topics*'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B19723_11.xhtml#_idTextAnchor216)，*探索高级主题*'
