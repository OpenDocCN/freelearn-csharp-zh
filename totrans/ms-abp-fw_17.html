<html><head></head><body>
		<div><h1 id="_idParaDest-287"><em class="italic"><a id="_idTextAnchor407"/>Chapter 13</em>: Working with the Blazor WebAssembly UI</h1>
			<p>Blazor is a relatively new <strong class="bold">Single-Page Application</strong> (<strong class="bold">SPA</strong>) framework for building interactive web applications using C# instead of JavaScript. Blazor is one of the built-in UI options provided by ABP Framework.</p>
			<p>In this chapter, I will briefly discuss what Blazor is and the main pros and cons of using this new framework. I will then continue by explaining how you can create new ABP solutions using the Blazor UI option. At the end of the chapter, you will have understood the architecture and design of the ABP Blazor integration and learned about the essential ABP services that you will use in your applications. </p>
			<p>This chapter consists of the following topics:</p>
			<ul>
				<li>What is Blazor?</li>
				<li>Getting started with the ABP Blazor UI</li>
				<li>Authenticating the user</li>
				<li>Understanding the theming system</li>
				<li>Working with menus</li>
				<li>Using the basic services</li>
				<li>Using the UI services</li>
				<li>Consuming HTTP APIs</li>
				<li>Working with global scripts and styles</li>
			</ul>
			<h1 id="_idParaDest-288"><a id="_idTextAnchor408"/>Technical requirements</h1>
			<p>If you want to follow the examples in this chapter, you need to have an IDE/editor that supports ASP.NET Core development. We will use the ABP CLI at some points, so you need to install the ABP CLI, as explained in <a href="B17287_02_Epub_AM.xhtml#_idTextAnchor026"><em class="italic">Chapter 2</em></a>, <em class="italic">Getting Started with ABP Framework</em>.</p>
			<p>You can download the example application from the following GitHub repository: <a href="https://github.com/PacktPublishing/Mastering-ABP-Framework">https://github.com/PacktPublishing/Mastering-ABP-Framework</a>. It contains some of the examples given in this chapter.</p>
			<h1 id="_idParaDest-289"><a id="_idTextAnchor409"/>What is Blazor?</h1>
			<p>As I indicated in the introduction, Blazor is an SPA framework<a id="_idIndexMarker856"/> used to build interactive web applications, just like other SPA frameworks such as Angular, React, and Vue.js. However, it has one important difference – we can use C# to build the application instead of JavaScript, which means we can run .NET in browsers. Blazor uses the .NET core runtime to execute the .NET code in the browser (for Blazor WebAssembly).</p>
			<p>Running .NET in browsers is not a new idea. Microsoft has done it before with Silverlight. To run Silverlight applications, we had to install a plugin on the browser. Blazor, on the other hand, runs natively<a id="_idIndexMarker857"/> on the browser, thanks to <strong class="bold">WebAssembly</strong> technology, which is defined <a id="_idIndexMarker858"/>as the following on <a href="https://webassembly.org">https://webassembly.org</a>:</p>
			<p class="author-quote">"WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications."</p>
			<p>A higher-level language, such as C#, can be compiled into WebAssembly and run natively in the browser. WebAssembly is supported by all major web browsers, so we don't need to install any custom plugin. If you're wondering whether Blazor is the new Silverlight, I can simply say, no, it is not.</p>
			<p>As .NET developers, Blazor brings incredible opportunities<a id="_idIndexMarker859"/> to us:</p>
			<ul>
				<li>We can use our existing C# skills to develop applications by harnessing the full power of the language and the runtime.</li>
				<li>We can use existing .NET libraries, such as our favorite NuGet packages.</li>
				<li>We can share code (such as DTO classes, application service contracts, localization, and validation code) between the server and the client.</li>
				<li>We can use the familiar Razor<a id="_idIndexMarker860"/> syntax to build UI pages and components.</li>
			</ul>
			<p>Besides using C#, Blazor provides JavaScript interoperability to call JavaScript code from C# and vice versa. That means that we can use existing JavaScript libraries and write our JavaScript code whenever we need to.</p>
			<p>Writing C# and sharing code between<a id="_idIndexMarker861"/> server and client applications is a huge advantage for a .NET developer. ABP also takes advantage of this and shares the infrastructure between the MVC/Razor Pages UI and Blazor UI as much as possible. You will see that many services are very similar to the MVC/Razor Pages UI.</p>
			<p>As a .NET developer and a software company manager, I am very impressed by Blazor and will use it in future projects. However, that doesn't mean<a id="_idIndexMarker862"/> it has no drawbacks:</p>
			<ul>
				<li>The bundle size, initial load time, and runtime performance are worse than its JavaScript competitors, such as Angular and React. However, Microsoft is investing in Blazor and working hard to improve<a id="_idIndexMarker863"/> its performance. For example, <strong class="bold">Ahead-of-Time</strong> (<strong class="bold">AOT</strong>) compilation has been introduced with .NET 6.0.</li>
				<li>The UI components and ecosystem are not mature yet since Blazor is still in the early stages.</li>
				<li>Debugging is not so straightforward yet.</li>
			</ul>
			<p>If these drawbacks are tolerable for your projects, you can definitely start using Blazor today.</p>
			<p>Interestingly, Blazor has two kinds of runtime models. Until now, I have<a id="_idIndexMarker864"/> mostly talked about <strong class="bold">Blazor WebAssembly</strong>. The second model is called <strong class="bold">Blazor Server</strong>. While the component development<a id="_idIndexMarker865"/> model is identical, the hosting logic and the runtime model are completely different.</p>
			<p>With Blazor WebAssembly, .NET code runs<a id="_idIndexMarker866"/> in the browser on the Mono runtime, and we don't have to run .NET on the server side. A small initializer JavaScript code downloads the standard .NET <strong class="bold">Dynamic Link Libraries</strong> (<strong class="bold">DLLs</strong>) and runs them in the browser. This model<a id="_idIndexMarker867"/> is similar to, and a direct competitor of, Angular and React because it runs the client-side logic completely in the browser.</p>
			<p>On the other hand, Blazor Server runs .NET code completely on the server. It establishes a real-time SignalR connection between the client and the server. The browser runs JavaScript and communicates to the server over that SignalR connection. It sends events to the server, and the server<a id="_idIndexMarker868"/> executes the necessary .NET code and sends <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) changes to the browser. Finally, the browser applies the DOM changes to the UI.</p>
			<p>The Blazor Server model has a pretty faster<a id="_idIndexMarker869"/> initial load time compared to Blazor WebAssembly. However, it communicates to the server for all events and DOM changes, so we need a good and stable connection between the server and the client.</p>
			<p>My purpose in this book is not to provide a complete introduction, overview, and use cases of Blazor but to give a short enough introduction to understanding what it is. Also, this chapter will focus on Blazor WebAssembly, but most of the topics are applicable to Blazor Server.</p>
			<p>Now, we can start ABP's Blazor integration.</p>
			<h1 id="_idParaDest-290"><a id="_idTextAnchor410"/>Getting started with the ABP Blazor UI</h1>
			<p>There are two ways to start a new project using ABP's startup solution templates. You can either download it from <a href="https://abp.io/get-started">https://abp.io/get-started</a> or create it using the ABP CLI. I will use the CLI approach<a id="_idIndexMarker870"/> in this book. If you haven't installed it yet, open a command-line terminal and execute the following command:</p>
			<pre>dotnet tool install -g Volo.Abp.Cli</pre>
			<p>Now, we can create a new solution using the <code>abp new</code> command:</p>
			<pre>abp new DemoApp -u blazor</pre>
			<p><code>DemoApp</code> is the solution name in this example. I've passed the <code>-u blazor</code> parameter to specify Blazor WebAssembly. If you want to use Blazor Server, you can specify<a id="_idIndexMarker871"/> the parameter as <code>-u blazor-server</code>.</p>
			<p>I haven't specified a database provider, so it uses Entity Framework Core by default (specify the <code>-d mongodb</code> parameter if you want to use MongoDB). After creating the solution, we need to create the initial database migration. As a first step, we should execute the following command in the <code>src/DemoApp.DbMigrator</code> directory:</p>
			<pre>dotnet run</pre>
			<p>This command creates the initial code-first migration and applies against the database.</p>
			<p>The solution contains two applications: </p>
			<ul>
				<li>The first one is the server (backend) application that hosts the HTTP APIs and provides the authentication UI. </li>
				<li>The second application is the frontend Blazor WebAssembly application that contains the application UI and communicates to the server. </li>
			</ul>
			<p>So, we first run the <code>DemoApp.HttpApi.Host</code> server application for this example. Then, we can run the <code>DemoApp.Blazor</code> Blazor application to run the UI. You can click on the <code>admin</code> as the username and <code>1q2w3E*</code> as the password to log in to the application. </p>
			<p>I won't dig into the details of the application, since we've done it already in <a href="B17287_02_Epub_AM.xhtml#_idTextAnchor026"><em class="italic">Chapter 2</em></a>, <em class="italic">Getting Started with ABP Framework</em>. The next section explains how the user is authenticated.</p>
			<h1 id="_idParaDest-291"><a id="_idTextAnchor411"/>Authenticating the user</h1>
			<p><strong class="bold">OpenID Connect</strong> (<strong class="bold">OIDC</strong>) is Microsoft's suggested way<a id="_idIndexMarker872"/> to authenticate Blazor WebAssembly<a id="_idIndexMarker873"/> applications. ABP follows that suggestion and provides it as preconfigured in the startup solution. </p>
			<p>The Blazor application doesn't contain login, register, or other authentication-related UI pages. It uses the <strong class="bold">Authorization Code</strong> flow with <strong class="bold">Proof Key for Code Exchange</strong> (<strong class="bold">PKCE</strong>) enabled to redirect the user<a id="_idIndexMarker874"/> to the server application. The server<a id="_idIndexMarker875"/> handles all the authentication logic and redirects the user back to the Blazor application.</p>
			<p>The authentication configuration is stored in the <code>wwwroot/appsettings.json</code> file of the Blazor application. See the following<a id="_idIndexMarker876"/> example configuration:</p>
			<pre>  "AuthServer": {
    "Authority": "https://localhost:44306",
    "ClientId": "DemoApp_Blazor",
    "ResponseType": "code"
  }</pre>
			<p>Here, <code>Authority</code> is the backend server application's root URL. <code>ClientId</code> is the name of the Blazor application that is known by the server. Finally, <code>ResponseType</code> specifies the authorization code flow.</p>
			<p>This configuration is used in the module class, the <code>DemoAppBlazorModule</code> class for this example, as shown in the following code block:</p>
			<pre>private static void ConfigureAuthentication(
    WebAssemblyHostBuilder builder)
{
    builder.Services.AddOidcAuthentication(options =&gt;
    {
        builder.Configuration.Bind(
            "AuthServer", options.ProviderOptions);
        options.UserOptions.RoleClaim = JwtClaimTypes.Role;
        options.ProviderOptions.DefaultScopes.Add(
            "DemoApp");
        options.ProviderOptions.DefaultScopes.Add("role");
        options.ProviderOptions.DefaultScopes.Add("email");
        options.ProviderOptions.DefaultScopes.Add("phone");
    });
}</pre>
			<p><code>AuthServer</code> is the key that matches the configuration key. If you want to customize the authentication options, these<a id="_idIndexMarker877"/> are the points you need to start from. For example, you can revise the requested scopes or change the OIDC configuration. For more information<a id="_idIndexMarker878"/> about Blazor WebAssembly authentication, please refer to Microsoft's documentation: <a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/security/webassembly/">https://docs.microsoft.com/en-us/aspnet/core/blazor/security/webassembly/</a>.</p>
			<p>In the next section, I will introduce the theming system for the Blazor UI.</p>
			<h1 id="_idParaDest-292"><a id="_idTextAnchor412"/>Understanding the theming system</h1>
			<p>ABP provides a theming system<a id="_idIndexMarker879"/> for the Blazor UI, as explained when we covered the MVC/Razor Pages UI in <a href="B17287_12_Epub_AM.xhtml#_idTextAnchor356"><em class="italic">Chapter 12</em></a>, <em class="italic">Working with MVC/Razor Pages</em>. The theme system brings flexibility, so we can develop our applications and modules without depending on a particular UI theme/style.</p>
			<p>All of the ABP themes for the Blazor UI use a set of base libraries. The fundamental base library is Bootstrap, whose components are designed to work with JavaScript. Fortunately, some component libraries wrap the Bootstrap components and provide a simpler .NET API, which is more suitable for use in Blazor applications.</p>
			<p>One of these component libraries is <strong class="bold">Blazorise</strong>. It is actually an abstraction library<a id="_idIndexMarker880"/> and can work with multiple providers such as Bootstrap, Bulma, and Ant Design. ABP startup templates use the Bootstrap provider of the Blazorise library.</p>
			<p>You can learn more about Blazorise and see the components<a id="_idIndexMarker881"/> in action on its website: <a href="https://blazorise.com">https://blazorise.com</a>. The following figure is a screenshot from the form components demo:</p>
			<div><div><img src="img/Figure_13.01_B17287.jpg" alt="Figure 13.1 – Blazorise demo: form components&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.1 – Blazorise demo: form components</p>
			<p>Besides the Blazorise <a id="_idIndexMarker882"/>library, the ABP Blazor UI uses <strong class="bold">Font Awesome</strong> as the CSS font icon library. So, any module or application can use these libraries on their pages without an explicit dependency.</p>
			<p>The UI theme is responsible for rendering<a id="_idIndexMarker883"/> the layout, including the header, menu, toolbar, page alerts, and footer. </p>
			<p>In the next section, we will see how to add new items to the main menu.</p>
			<h1 id="_idParaDest-293"><a id="_idTextAnchor413"/>Working with menus</h1>
			<p>Menu management in the ABP Blazor UI is very similar<a id="_idIndexMarker884"/> to the ABP MVC/Razor Pages UI, which was covered in <a href="B17287_12_Epub_AM.xhtml#_idTextAnchor356"><em class="italic">Chapter 12</em></a>, <em class="italic">Working with MVC/Razor Pages</em>.</p>
			<p>We use <code>AbpNavigationOptions</code> to add contributors to the menu system. ABP executes all the contributors to build the menu dynamically. The startup solution includes a menu contributor and is added to <code>AbpNavigationOptions</code> as per the following example:</p>
			<pre>Configure&lt;AbpNavigationOptions&gt;(options =&gt;
{
    options.MenuContributors.Add(new
        DemoAppMenuContributor(
        context.Services.GetConfiguration()));
});</pre>
			<p><code>DemoAppMenuContributor</code> is a class that implements the <code>IMenuContributor</code> interface. The <code>IMenuContributor</code> interface defines the <code>ConfigureMenuAsync</code> method, which we should implement as shown<a id="_idIndexMarker885"/> in the following example:</p>
			<pre>public class DemoAppMenuContributor : IMenuContributor
{
    public async Task ConfigureMenuAsync(
        MenuConfigurationContext context)
    {
        if (context.Menu.Name == StandardMenus.Main)
        {
            //TODO: Configure the main menu
        }
    }
}</pre>
			<p>There are two standard menu names defined as constants in the <code>StandardMenus</code> class (in the <code>Volo.Abp.UI.Navigation</code> namespace):</p>
			<ul>
				<li><code>Main</code>: The main menu of the application.</li>
				<li><code>User</code>: The user context menu. It is opened when you click your username on the header.</li>
			</ul>
			<p>So, the preceding example checks the menu name and adds items only to the main menu. The following code block adds a new menu item to the main menu:</p>
			<pre>var l = context.GetL<a id="_idTextAnchor414"/>ocalizer&lt;DemoAppResource&gt;();
context.Menu.AddItem(
    new ApplicationMenuItem(
        DemoAppMenus.Home,
        l["Menu:Home"],
        "/home",
        icon: "fas fa-home"
    )
);</pre>
			<p>You can resolve services from dependency injection using the <code>context.ServiceProvider</code> object. The <code>context.GetLocalizer</code> method is a shortcut to resolve an <code>IStringLocalizer&lt;T&gt;</code> instance. Similarly, we can use the <code>context.IsGrantedAsync</code> shortcut method<a id="_idIndexMarker886"/> to check the permission of the current user, as shown in the following code block:</p>
			<pre>if (await context.IsGrantedAsync("MyPermissionName"))
{
    context.Menu.AddItem(...);
}</pre>
			<p>Menu items can be nested. The following example adds a <code>Crm</code> menu item and an <code>Orders</code> menu item under it:</p>
			<pre>context.Menu.AddItem(
    new ApplicationMenuItem(
        DemoAppMenus.Crm,
        l["Menu:Identity"]
    ).AddItem(new ApplicationMenuItem(
        DemoAppMenus.Orders,
        l["Menu:Orders"],
        url: "/crm/orders")
    )
);</pre>
			<p>I've called <code>AddItem</code> on the first <code>ApplicationMenuItem</code> object to add a child item. You can do the same for the <code>Orders</code> menu item to build deeper menus.</p>
			<p>We've used localization and authorization<a id="_idIndexMarker887"/> services while creating menu items. In the next section, we will see how to use these services in other parts of our Blazor application.</p>
			<h1 id="_idParaDest-294"><a id="_idTextAnchor415"/>Using the basic services</h1>
			<p>In this section, I will show you how to use some fundamental services<a id="_idIndexMarker888"/> in Blazor applications. As you will see, they are almost the same as the server-side services that we covered in earlier chapters. Let's start with the authorization service.</p>
			<h2 id="_idParaDest-295"><a id="_idTextAnchor416"/>Authorizing the users</h2>
			<p>We typically use authorization in Blazor applications to hide/disable some pages, components, and functionalities<a id="_idIndexMarker889"/> on the user interface. While the server always checks the same authorization rules for security, client-side authorization checks provide a better user experience.</p>
			<p><code>IAuthorizationService</code> is used to programmatically check permissions/policies, as on the server side. You can inject and use its methods, as shown in the following example:</p>
			<pre>public partial class Index
{
    protected override async Task OnInitializedAsync()
    {
        if (await AuthorizationService
                 .IsGrantedAsync("MyPermission"))
        {
            // TODO: ...
        }
    }
}</pre>
			<p><code>AuthorizationService</code> has different ways<a id="_idIndexMarker890"/> to work. Please refer to the <em class="italic">Working with authorization and permission systems</em> section of <a href="B17287_07_Epub_AM.xhtml#_idTextAnchor213"><em class="italic">Chapter 7</em></a>, <em class="italic">Exploring Cross-Cutting Concerns</em>, to learn more about the authorization system.</p>
			<p>The component in the preceding example is inherited from the <code>AbpComponentBase</code> class. We can directly use the <code>AuthorizationService</code> property without manual injection since the <code>AbpComponentBase</code> class pre-injects it for us. The <code>AuthorizationService</code> property type is <code>IAuthorizationService</code>.</p>
			<p>If you don't inherit from the <code>AbpComponentBase</code> class, you can inject it using the <code>[Inject]</code> attribute:</p>
			<pre>[Inject]
private IAuthorizationService AuthorizationService { get;
                                                     set; }</pre>
			<p>You can use the same <code>IAuthorizationService</code> on the view side of your Razor components when you need it. However, there are some alternative ways to make your application code cleaner. For example, you can use the <code>[Authorize]</code> attribute on a component to make it available only for authenticated users:</p>
			<pre>@page "/"
@attribute [Authorize]
&lt;p&gt;This page is visible only if you've logged in&lt;/p&gt;.</pre>
			<p>The <code>[Authorize]</code> attribute works similarly to the server side. You can pass a policy/permission name to check for a specific<a id="_idIndexMarker891"/> permission, as shown in the following example:</p>
			<pre>@page "/order-management"
@attribute [Authorize("CanManageOrders")]
&lt;p&gt;You can only see this if you have the necessary
    permission.&lt;/p&gt;</pre>
			<p>It is typical to show a part of the UI if the user has a specific permission. The following example uses the <code>AuthorizeView</code> element to show a message if the current user has permission to edit orders:</p>
			<pre>&lt;AuthorizeView Policy="CanEditOrders"&gt;
    &lt;p&gt;You can only see this if you can edit the 
        orders.&lt;/p&gt;
&lt;/AuthorizeView&gt;</pre>
			<p>In this way, you can conditionally render the action buttons or other parts of the UI.</p>
			<p>ABP is 100% compatible with Blazor's authorization<a id="_idIndexMarker892"/> system, so you can refer to Microsoft's documentation to see more examples and details: <a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/security">https://docs.microsoft.com/en-us/aspnet/core/blazor/security</a>.</p>
			<p>In the next section, we will learn how to use the localization system, another common UI service.</p>
			<h2 id="_idParaDest-296"><a id="_idTextAnchor417"/>Localizing the user interface</h2>
			<p>Blazor applications share the<a id="_idIndexMarker893"/> same API for localizing texts. We can inject and use the <code>IStringLocalizer&lt;T&gt;</code> service to get the localized texts for the current language.</p>
			<p>The following Razor component uses the <code>IStringLocalizer&lt;T&gt;</code> service:</p>
			<pre>@using DemoApp.Localization
@usi<a id="_idTextAnchor418"/>ng Microsoft.Extensions.Localization
@inject<a id="_idTextAnchor419"/> IStringLocalizer&lt;DemoAppResource&gt; L
&lt;h3&gt;@L["HelloWorld"]&lt;/h3&gt;</pre>
			<p>We use the standard <code>@inject</code> directive and specify the localization resource type in the generic <code>IStringLocalizer&lt;T&gt;</code> interface. The same interface can also be injected and used in any service in your application. Please refer to the <em class="italic">Localizing the user interface</em> section of <a href="B17287_08_Epub_AM.xhtml#_idTextAnchor249"><em class="italic">Chapter 8</em></a>, <em class="italic">Using the Features and Services of ABP</em>, to learn about working<a id="_idIndexMarker894"/> with the localization system. </p>
			<p>Next, we will learn to get information about the current user in the next section.</p>
			<h2 id="_idParaDest-297"><a id="_idTextAnchor420"/>Accessing the current user</h2>
			<p>You sometimes may need to know the current user's username, email address, and other details<a id="_idIndexMarker895"/> in your application. We use the <code>ICurrentUser</code> service to access the current user, as on the server side. The following example component renders a welcome message by the current user<a id="_idTextAnchor421"/>'s name:</p>
			<pre>@using Volo.Abp.Users
@inject ICurrentUser CurrentUser
&lt;h3&gt;Welcome @CurrentUser.Name&lt;/h3&gt;</pre>
			<p>In addition to standard properties such as <code>Name</code>, <code>Surname</code>, <code>UserName</code>, and <code>Email</code>, you can use the <code>ICurrentUser.FindClaimValue(...)</code> method to get custom claims issued by the server.</p>
			<p>I've introduced the basic ABP Blazor services typically used by all the applications. I kept them short since the APIs are almost the same with the server side, and we've already covered them in detail in previous chapters. In the next section, I will continue with the UI services used to inform the user.</p>
			<h1 id="_idParaDest-298"><a id="_idTextAnchor422"/>Using the UI services</h1>
			<p>It is common in every application<a id="_idIndexMarker896"/> to show messages, notifications, and alerts to users to inform or warn them. In the next sections, I will introduce ABP's built-in APIs for these services.</p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor423"/>Showing message boxes</h2>
			<p>Message boxes are used to show blocking messages<a id="_idIndexMarker897"/> or confirmation dialogs to the user. The user clicks on the <strong class="bold">Ok</strong> button to disable the message or clicks the <strong class="bold">Yes</strong> or <strong class="bold">Cancel</strong> buttons to make a decision on configuration dialogs.</p>
			<p>There are five types of messages – <code>Info</code>, <code>Success</code>, <code>Warn</code>, <code>Error</code>, and <code>Confirm</code>. The following example shows a <code>Success</code> message sent to the user:</p>
			<pre>@page "/"
@inherits DemoAppComponentBase
&lt;Button Color="Color.Primary"
        Clicked="ShowSuccess"&gt;Click me!&lt;/Button&gt;
@code
{
    private async Task ShowSuccess()
    {
        await Message.Success("This is a success
                               message!");
    }
}</pre>
			<p>The <code>Message</code> property, in this example, is coming from the <code>AbpComponentBase</code> class (<code>DemoAppComponentBase</code> inherits it), and its type is <code>IUiMessageService</code>. Alternatively, you can inject <code>IUiMessageService</code> manually for your components, pages, or services. All the <code>IUiMessageService</code> methods can take an extra <code>title</code> parameter and an <code>options</code> action to customize the dialog.</p>
			<p>The following figure shows the result of the preceding example:</p>
			<div><div><img src="img/Figure_13.02_B17287.jpg" alt="Figure 13.2 – A simple success message without a title&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.2 – A simple success message without a title</p>
			<p>The following example shows a confirmation<a id="_idIndexMarker898"/> dialog sent to the user and takes action if the user clicks the <strong class="bold">Yes</strong> button:</p>
			<pre>@page "/"
@inherits DemoAppComponentBase
&lt;Button Color="Color.Primary" 
        Clicked="ShowQuestion"&gt;Click me!&lt;/Button&gt;
@code
{
    private async Task ShowQuestion()
    {
        var result = await Message.Confirm(
            "Are you sure to delete the product?");
        if (result == true)
        {
            //TODO: ...
        }
    }
}</pre>
			<p>The <code>Confirm</code> method returns a <code>bool</code> value, so you<a id="_idIndexMarker899"/> can see whether the user has accepted the dialog message. The following figure shows the result of this example:</p>
			<div><div><img src="img/Figure_13.03_B17287.jpg" alt="Figure 13.3 – A confirmation dialog &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.3 – A confirmation dialog </p>
			<p>The next section explains how to show a non-blocking information message to the user.</p>
			<h2 id="_idParaDest-300"><a id="_idTextAnchor424"/>Showing notifications</h2>
			<p>Messages boxes focus users<a id="_idIndexMarker900"/> on the message. They should click the <strong class="bold">Ok</strong> button to return to the application UI. On the other hand, notifications are non-blocking informative messages. They are shown in the bottom-right corner of the screen and automatically disappear after a few seconds.</p>
			<p>There are four types of notifications – <code>Info</code>, <code>Success</code>, <code>Warn</code>, and <code>Error</code>. The following example shows a confirmation dialog and shows a <code>Success</code> notification if the user accepts the confirmation message:</p>
			<pre>@page "/"
@inherits DemoAppComponentBase
&lt;Button Color="Color.Primary" 
        Clicked="ShowQuestion"&gt;Click me!&lt;/Button&gt;
@code
{
    private async Task ShowQuestion()
    {
        var confirmed = await Message.Confirm(
            "Are you sure to delete the product?");
        if (confirmed)
        {
            //TODO: Delete the product
            await Notify.Success("Successfully deleted the
                                  product!");
        }
    }
}</pre>
			<p>The <code>Notify</code> property comes from the <code>AbpComponentBase</code> base class. You can inject the <code>IUiNotificationService</code> interface and use it anywhere to show notifications on the UI. All the notification<a id="_idIndexMarker901"/> methods can take an extra <code>title</code> parameter and an <code>options</code> action to customize the dialog. The following figure shows the result of the <code>Notify.Success</code> method used in the preceding code block:</p>
			<div><div><img src="img/Figure_13.04_B17287.jpg" alt="Figure 13.4 – An example notification message&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.4 – An example notification message</p>
			<p>The next section introduces<a id="_idIndexMarker902"/> alerts, another way to show a message to the user.</p>
			<h2 id="_idParaDest-301"><a id="_idTextAnchor425"/>Showing alerts</h2>
			<p>Using alerts is a sticky way<a id="_idIndexMarker903"/> to show a non-blocking message to the user. The user, optionally, can dismiss the alert.</p>
			<p>There are four types of alerts – <code>Info</code>, <code>Success</code>, <code>Warning</code>, and <code>Danger</code>. The following example shows a <code>Success</code> alert sent to the user:</p>
			<pre>@page "/"
@inherits DemoAppComponentBase
&lt;Button Color="Color.Primary" 
        Clicked="DeleteProduct"&gt;Click me!&lt;/Button&gt;
@code
{
    private async Task DeleteProduct()
    {
        //TODO: Delete the product
        Alerts.Success(
            text: "Successfully deleted the product.", 
            title: "Deleted!", 
            dismissible: true);
    }
}</pre>
			<p>In this example, I've used the <code>Alerts</code> property coming from the base class. You can always inject the <code>IAlertManager</code> service and use it like <code>IAlertManager.Alerts.Success(…)</code>.</p>
			<p>All of the alert<a id="_idIndexMarker904"/> methods take <code>text</code> (required), a <code>title</code> (optional), and <code>dismissible</code> (optional and default – <code>true</code>) parameters. If an alert is dismissible, then the user can make it disappear by clicking the <strong class="bold">X</strong> button. The following figure shows the alert created in the preceding example:</p>
			<div><div><img src="img/Figure_13.05_B17287.jpg" alt="Figure 13.5 – A Success alert message&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.5 – A Success alert message</p>
			<p>Alerts are rendered by the theme on top of the page content. Besides the standard <code>Info</code>, <code>Success</code>, <code>Warning</code>, and <code>Danger</code> methods, you can use the <code>Add</code> method by specifying <code>AlertType</code> to use all Bootstrap styles, such as <code>Primary</code>, <code>Secondary</code>, or <code>Dark</code>.</p>
			<p>You've now learned three ways to show information messages to the user. In the next section, we will investigate how the Blazor application consumes the HTTP APIs of the server.</p>
			<h1 id="_idParaDest-302"><a id="_idTextAnchor426"/>Consuming HTTP APIs</h1>
			<p>You can use the standard <code>HttpClient</code> to manually set up and perform an HTTP request to the server. However, ABP provides C# client proxies to call HTTP API endpoints easily. You can directly consume your application services<a id="_idIndexMarker905"/> from the Blazor UI and let ABP Framework handle the HTTP API calls for you.</p>
			<p>Let's assume that we have an application service interface, as shown in the following example:</p>
			<pre>public interface ITestAppService : IApplicationService
{
    Task&lt;int&gt; GetDataAsync();
}</pre>
			<p>Application service interfaces are defined in the <code>Application.Contracts</code> project (the <code>DemoApp.Application.Contracts</code> project for the example solution I've created). The Blazor application has a reference to that project. This way, we can use the <code>ITestAppService</code> interface on the client side.</p>
			<p>Application services are implemented in the <code>Application</code> project (the <code>DemoApp.Application</code> project for the example solution I've created). We can simply implement the <code>ITestAppService</code> interface, as shown in the following code block:</p>
			<pre>public class TestAppService : ApplicationService,
    ITestAppService
{
    public async Task&lt;int&gt; GetDataAsync()
    {
        return 42;
    }
}</pre>
			<p>Now, we can directly inject <code>ITestAppService</code> into any page/component, as with any other local service, and call its methods, just like a standard method call:</p>
			<pre>public partial class Index
{
    [Inject]
    private ITestAppService TestAppService { get; set; }
    private int Value { get; set; }
    
    protected override async Task OnInitializedAsync()
    {
        Value = await TestAppService.GetDataAsync();
    }
}</pre>
			<p>In this example, I used the standard <code>[Inject]</code> attribute on top of the <code>TestAppService</code> property to tell Blazor to inject<a id="_idIndexMarker906"/> it for me. Then, I've overridden it in the <code>OnInitializedAsync</code> method to call the <code>GetDataAsync</code> method. As we know, the <code>OnInitializedAsync</code> method is called just after the component/page is initially rendered and ready to work.</p>
			<p>It's that easy. When we call the <code>GetDataAsync</code> method, ABP actually makes an HTTP API call to the server by handling all the complexity, including authentication, error handling, and JSON serialization. It reads the server's root URL from the <code>RemoteServices</code> configuration in the <code>wwwroot/appsettings.json</code> file of the Blazor project. An example configuration is shown in the following code block:</p>
			<pre>"RemoteServices": {
  "Default": {
    "BaseUrl": "https://localhost:44306"
  }
}</pre>
			<p>In this section, I've used ABP's dynamic C# client proxy approach to consume HTTP APIs from<a id="_idIndexMarker907"/> the Blazor application. We will return to this topic in <a href="B17287_14_Epub_AM.xhtml#_idTextAnchor429"><em class="italic">Chapter 14</em></a>, <em class="italic">Building HTTP APIs and Real-Time Services</em>, by also introducing the static C# client proxies.</p>
			<p>The next section will explore how we can add script and style files to our Blazor applications.</p>
			<h1 id="_idParaDest-303"><a id="_idTextAnchor427"/>Working with global scripts and styles</h1>
			<p>Importing script and style<a id="_idIndexMarker908"/> files for the Blazor Server UI is the same as the MVC/Razor Pages UI for ABP Framework. You can refer to <a href="B17287_12_Epub_AM.xhtml#_idTextAnchor356"><em class="italic">Chapter 12</em></a>, <em class="italic">Working with MVC/Razor Pages</em>, to learn how to use it. This section is based on Blazor WebAssembly.</p>
			<p>Blazor WebAssembly is a Single-Page Application and it has a single entry point by default. The <code>index.html</code> file is in the <code>wwwroot</code> folder, as shown in the following figure:</p>
			<div><div><img src="img/Figure_13.06_B17287.jpg" alt="Figure 13.6 – The index.html file in the wwwroot folder&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.6 – The index.html file in the wwwroot folder</p>
			<p><code>index.html</code> is a plain HTML file. The server sends it to the browser without any processing. Remember that a simple static file server can serve a Blazor WebAssembly application. The browser first loads the <code>index.html</code> document and then loads the styles and scripts imported by this document.</p>
			<p>If you open the <code>index.html</code> document, you will see a part within the <code>ABP:Styles</code> comments, as shown in the following<a id="_idIndexMarker909"/> code block:</p>
			<pre>&lt;!--ABP:Styles--&gt;
&lt;link href="global.css?_v=637649661149948696"
    rel="stylesheet"/&gt;
&lt;link href="main.css" rel="stylesheet"/&gt;
&lt;!--/ABP:Styles--&gt;</pre>
			<p>This code part (including the comments) is automatically created (and then updated) by the ABP CLI when you execute the following command in the root folder of the Blazor project:</p>
			<pre>abp bundle</pre>
			<p>When you execute this command, it creates (or regenerates) the global style bundle. This bundle contains all the necessary styles, including the .NET runtime, Blazor, and other used libraries, in a minified format. Whenever you add a new Blazor-related ABP NuGet package/module into your application, you rerun the <code>abp bundle</code> command and it regenerates the bundle with the necessary dependencies included.</p>
			<p>ABP's <code>bundle</code> command does a great job. When installing a module, you don't need to know its global script files or extra dependencies. Just run this command, and you have the updated, production-ready global bundle file. Every module contributes its own dependencies into that bundle, and then ABP generates the bundle by respecting the module dependency order. To manipulate the bundle, you should define a class that implements the <code>IBundleContributor</code> interface. The Blazor project in the startup solution template already contains a bundle contributor, as shown in the following code block:</p>
			<pre>public class DemoAppBundleContributor : IBundleContributor
{
    public void AddScripts(BundleContext context)
    {
    }
    public void AddStyles(BundleContext context)
    {
        context.Add("main.css", excludeFromBundle: true);
    }
}</pre>
			<p><code>AddScripts</code> and <code>AddStyles</code> methods are used to add JavaScript and CSS files to the global bundles. You can also remove or change an existing file (which was added by a package your application depends on) using the <code>context.BundleDefinitions</code> collection, but that's rarely needed. Here, the <code>excludeFromBundle</code> parameter adds the <code>main.css</code> file separately from the global bundle. You can remove that parameter to include it in the <code>global.css</code> bundle file.</p>
			<p>Similar to the style bundle, the <code>index.html</code> file contains an <code>ABP:Scripts</code> part, as shown in the following code block:</p>
			<pre>&lt;!--ABP:Scripts--&gt;
&lt;script src="img/global.js?_v=637680281013693676"&gt;&lt;/script&gt;
&lt;!--/ABP:Scripts--&gt;</pre>
			<p>Again, this code part is created (and updated) by the ABP CLI with the <code>abp bundle</code> command. If you want<a id="_idIndexMarker910"/> to include files, you can do it inside the <code>AddScripts</code> method of your bundle contributor class. The paths of the files are considered relative to the <code>wwwroot</code> folder.</p>
			<h1 id="_idParaDest-304"><a id="_idTextAnchor428"/>Summary</h1>
			<p>This chapter was a quick introduction to the ABP Framework Blazor UI to understand its architecture and the services you will frequently use in your applications.</p>
			<p>Authentication is one of the most challenging aspects of an application, and ABP provides an industry-standard solution that you can directly use in your applications.</p>
			<p>We've learned about the services to get the current user's identity information, check the user's permissions, and localize the user interface. We also explored the services to show message boxes, notifications, and alerts to the user.</p>
			<p>ABP's dynamic C# client proxy system makes it super-easy to consume server-side HTTP APIs. Finally, you've learned how to use the global bundling system to handle bundling and minification in your Blazor applications.</p>
			<p>I intentionally didn't cover two topics in this chapter. The first one is Blazor itself. It is a very detailed topic to cover in a single chapter of a book. I advise you to read Microsoft's documentation (<a href="https://docs.microsoft.com/en-us/aspnet/core/blazor">https://docs.microsoft.com/en-us/aspnet/core/blazor</a>) or purchase a dedicated book if you are new to the Blazor framework. Check out the book <em class="italic">Web Development with Blazor</em>, by <em class="italic">Jimmy Engström</em>, from <em class="italic">Packt Publishing</em>.</p>
			<p>The second topic I haven't covered in this chapter is complex UI components, such as data tables, modals, and tabs. They are so specific to the UI kit you are using. ABP comes with the Blazorise library, and you can refer to its documentation to learn its components: <a href="https://blazorise.com/docs">https://blazorise.com/docs</a>. I also suggest going through ABP Framework's Blazor UI tutorial to understand the fundamental development model with the most-used components, data tables, and modals: <a href="https://docs.abp.io/en/abp/latest/Getting-Started">https://docs.abp.io/en/abp/latest/Getting-Started</a>.</p>
			<p>In the next chapter, we will focus on building HTTP APIs and consuming them in client applications. We will also look at using the SignalR library for real-time communication between a client and a server.</p>
		</div>
	</body></html>