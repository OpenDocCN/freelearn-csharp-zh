- en: Chapter 2. Inventory GUIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple 2D mini-game – SpaceGirl
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying single object pickups with carrying and not-carrying text
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying single object pickups with carrying and not-carrying icons
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying multiple pickups of the same object with text totals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying multiple pickups of the same object with multiple status icons
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revealing icons for multiple object pickups by changing the size of a tiled
    image
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying multiple pickups of different objects as a list of text via a dynamic
    List<> of PickUp objects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying multiple pickups of different objects as text totals via a dynamic
    Dictionary<> of PickUp objects and "enum" pickup types
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generalizing multiple icon displays using UI Grid Layout Groups (with scrollbars!)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many games involve the player collecting items or choosing from a selection
    of items. Examples could be collecting keys to open doors, collecting ammo for
    weapons, choosing from a collection of spells to cast, and so on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The recipes in this chapter offer a range of solutions for displaying to the
    player whether they are carrying an item or not, if they are allowed more than
    one of an item, and how many they have.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The big picture
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The two parts of software design for implementing inventories relate to, first,
    how we choose to represent the data about inventory items (that is, the data types
    and structures to store the data) and, secondly, how we choose to display information
    about inventory items to the player (the UI: User Interface).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Also, whilst not strictly inventory items, player properties such as lives left,
    health, or time remaining can also be designed around the same concepts that we
    present in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to first think about the nature of different inventory items for any
    particular game:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Single items:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example(s): the only key for a level, our suit of magic armor'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data type: bool (true/false)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'UI: nothing (if not carried) or text/image to show being carried'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Or perhaps text saying "no key"/"key", or two images, one showing an empty key
    outline and the second showing a full color key
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If we wish to highlight to the player that there is an option to be carrying
    this item
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Continuous item:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example(s): time left, health, shield strength'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data type: float (for example, 0.00–1.00) or integer scale (for example, 0%
    .. 100%)'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'UI: text number or image progress bar/pie chart'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Two or more of same item
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example(s): lives left, or number of arrows or bullets left'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data type: int (whole numbers)'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'UI: text count or images'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Collection of related items
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example(s): keys of different colors to open correspondingly colored doors,
    potions of different strength with different titles'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data structure: a struct or class for the general item type (for example, class
    `Key` (color/cost/doorOpenTagString), stored as an array or List<>'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'UI: text list or list/grid arrangement of icons'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Collection of different items
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example(s): keys, potions, weapons, tools—all in the same inventory system'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data structure: List<> or Dictionary<> or array of objects, which can be instances
    of different class for each item type'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of the above representations and UI display methods are illustrated by
    the recipes in this chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple 2D mini-game – SpaceGirl
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe presents the steps to create the 2DSpaceGirl mini-game, on which
    all the recipes of this chapter are based.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the images you need in a folder named `Sprites`
    in the `1362_02_01` folder. We have also provided the completed game as a Unity
    package in this folder named `Simple2DGame_SpaceGirl`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create the simple 2D mini-game *Space Girl* follow these steps:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Create a new, empty 2D project.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import supplied folder `Sprites` into your project.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert each sprite image to be of type **Sprite (2D and UI)**. To do this,
    select the sprite in the **Project** panel, then, in the **Inspector**, change
    choose **Sprite (2D and UI)** from the drop-down menu **Texture Type**, and click
    on the **Apply** button, as shown in the following screenshot:![How to do it...](img/1362OT_02_54.jpg)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the Unity Player screen size to 800 x 600: choose the **Edit** | **Project
    Settings** | **Player** menu, then for option **Resolution and Presentation**
    uncheck `Default is Full Screen,` and set the width to `800` and height to `600`,
    as shown in the following screenshot:![How to do it...](img/1362OT_02_03.jpg)'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Game** panel; if not already chosen, then choose **Standalone (800
    x 600)** from the drop-down menu, as shown in the following screenshot:![How to
    do it...](img/1362OT_02_02.jpg)
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the **Tags & Layers** properties for the current Unity project. Choose
    menu **Edit** | **Project Settings** | **Tags and Layers**. Alternatively, if
    you are already editing a GameObject, then you can select the **Add Layer…** menu
    from the **Layer** drop-down menu at the top of the **Inspector** panel, as shown
    in the following screenshot:![How to do it...](img/1362OT_02_51.jpg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Inspector** should now being displaying the **Tags & Layers** properties
    for the current Unity project. Use the expand/contract triangle tools to contract
    **Tags** and **Layers**, and to expand **Sorting Layers**.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the plus sign **+** button to add two new sorting layers, as shown in the
    following screenshot: first, add one named **Background**, and next, add one named
    **Foreground**. The sequence is important, since Unity will draw items in layers
    further down this list on top of items earlier in the list.![How to do it...](img/1362OT_02_52.jpg)'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the sprite `background-blue` from the **Project** panel (folder `Sprites`)
    into either the **Game** or **Hierarchy** panel to create a GameObject for the
    current scene.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Sorting Layer** of GameObject `background-blue` to **Background**
    (in the **Sprite Renderer** component).
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag sprite `star` from the **Project** panel (folder `Sprites`) into either
    the **Game** or **Hierarchy** panel to create a GameObject for the current scene.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** panel, add a new tag **Star** by selecting the **Add Tag…**
    option from the **Tag** drop-down menu at the top of the **Inspector** panel,
    as shown in the following screenshot:![How to do it...](img/1362OT_02_04.jpg)
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the **Star** tag to GameObject `star` in the **Hierarchy** scene.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Sorting Layer** of GameObject `star` to **Foreground** (in the **Sprite
    Renderer** component).
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add to GameObject `star` a Box Collider 2D (**Add Component** | **Physics 2D**
    | **Box Collider 2D**) and check its `Is Trigger`, as shown in the following screenshot:![How
    to do it...](img/1362OT_02_08.jpg)
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag sprite `girl1` from the **Project** panel (folder `Sprites`) into either
    the **Game** or **Hierarchy** panel to create a GameObject for the player's character
    in the current scene. Rename this GameObject `player-SpaceGirl`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Sorting Layer** of GameObject `player-SpaceGirl` to **Foreground**
    (in the **Sprite Renderer** component).
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add to GameObject `player-SpaceGirl` a Box Collider 2D (**Add Component** |
    **Physics 2D** | **Box Collider 2D**).
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add to GameObject `player-SpaceGirl` a RigidBody 2D (**Add Component** | **Physics
    2D** | **Rigid Body 2D**). Set its **Gravity Scale** to zero (so it isn't falling
    down the screen due to simulated gravity), as shown in the following screenshot:![How
    to do it...](img/1362OT_02_31.jpg)
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder for your scripts named `Scripts`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the following C# Script `PlayerMove` (in folder `Scripts`) and add an
    instance as a component to GameObject `player-SpaceGirl` in the **Hierarchy**:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Save the scene (name it **Main Scene** and save it into a new folder named `Scenes`).
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have created a player character in the scene, with its movement scripted
    component `PlayerMove`. You have also created a star GameObject (a pickup), tagged
    `Star` and with a 2D box collider that will trigger a collision when the player's
    character hits it. When you run the game, the `player-SpaceGirl` character should
    move around using the *W A S D*, arrow keys, or joystick. Currently, nothing will
    happen if the `player-SpaceGirl` character hits a star since that has yet to be
    scripted.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: You have added a background (GameObject `background-blue`) to the scene, which
    will be behind everything since it is in the rearmost sorting layer **Background**.
    Items you want to appear in front of this background (the player's character and
    the star so far) are placed on sorting layer **Foreground**. Learn more about
    Unity tags and layers at [http://docs.unity3d.com/Manual/class-TagManager.html](http://docs.unity3d.com/Manual/class-TagManager.html).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Displaying single object pickups with carrying and not-carrying text
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often the simplest inventory situation is to display text to tell players if
    they are carrying a single item (or not).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe assumes that you are starting with the project `Simple2Dgame_SpaceGirl`
    setup from the first recipe in this chapter. So, either make a copy of that project
    or do the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Create a new, empty 2D project.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `Simple2Dgame_SpaceGirl` package.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open scene **Scene1** (in the `Scenes` folder).
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Unity Player screen size to 800 x 600 (see the previous recipe for how
    to do this) and select this resolution in the **Game** panel the drop-down menu.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert each sprite image to be of type **Sprite (2D and UI)**. In the **Inspector,**
    choose **Sprite (2D and UI)** from drop-down menu **Texture Type**, and click
    on the **Apply** button.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the font you need in a folder named `Fonts`
    in the `1362_02_02` folder.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To display text to inform the user about the status of carrying a single object
    pickup, follow these steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Start with a new copy of mini-game `Simple2Dgame_SpaceGirl`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a UI **Text** object (**Create** | **UI** | **Text**). Rename it `Text-carrying-star`.
    Change its text to `Carrying star: false`.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the provided `Fonts` folder into your project.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** panel, set the font of `Text-carrying-star` to **Xolonium-Bold**
    (folder `Fonts`), and set its color to yellow. Center the text horizontally and
    vertically, and set its **Height** to `50`, and set the **Font Size** to `32`,
    as shown in the following screenshot:![How to do it...](img/1362OT_02_05.jpg)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its **Rect Transform** component, set its **Height** to `50`, as shown in
    the next screenshot:![How to do it...](img/1362OT_02_53.jpg)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit its **Rect Transform**, and while holding down *SHIFT* and *ALT* (to set
    pivot and position), choose the top-stretch box, as shown in the following screenshot:![How
    to do it...](img/1362OT_02_06.jpg)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your text should now be positioned at the middle top of the **Game** panel,
    and its width should stretch to match that of the whole panel, as shown in the
    next screenshot:![How to do it...](img/1362OT_02_07.jpg)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following C# Script `Player` to GameObject `player-SpaceGirl` in the
    **Hierarchy**:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From the **Hierarchy** view, select the GameObject `player-SpaceGirl`. Then,
    from the **Inspector**, access the **Player (Script)** component and populate
    the **Star Text** public field with UI **Text** object `Text-carrying-star`, as
    shown in the following screenshot:![How to do it...](img/1362OT_02_10.jpg)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you play the scene, after moving the character into the star, the star
    should disappear, and the onscreen UI **Text** message should change to **Carrying
    star :-)** , as shown in the following screenshot:![How to do it...](img/1362OT_02_09.jpg)
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Text` variable `starText` is a reference to the UI **Text** object `Text-carrying-star`.
    The `bool` variable `carryingStar` represents whether or not the player is carrying
    the star at any point in time; it is initialized to false.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The `UpdateStarText()` method copies the contents of the `starMessage` string
    to the text property of `starText`. The default value of this string tells the
    user that the player is not carrying the star, but an `if` statement tests the
    value of `carryingKey`, and, if that is true, then the message is changed to inform
    the player that they are carrying the star.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Each time the player's character collides with any object that has its **Is
    Trigger** set to `true`, an `OnTriggerEnter2D()` event message is sent to both
    objects involved in the collision. The `OnTriggerEnter2D()` message is passed
    a parameter that is the `Collider2D` component inside the object just collided
    with.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Our player''s `OnTriggerEnter2D()` method tests the `tag` string of the object
    collided with to see if it has the value **Star**. Since the GameObject **star**
    we created has its trigger set, and has the tag **Star**, the `if` statement inside
    this method will detect a collision with **star** and complete three actions:
    it sets the Boolean variable `carryingStar` to `true`, it calls the method `UpdateStarText()`,
    and it destroys the GameObject it has just collided with (in this case, **star**).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'NOTE: Boolean variables are often referred to as **flags.**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: The use of a bool (true/false) variable to represent whether some feature of
    the game state is true or false is very common. Programmers often refer to these
    variables as flags. So, programmers might refer to the `carryingStar` variable
    as the star-carrying flag.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: When the scene begins, via the `Start()`method, we call the `UpdateStarText()`method;
    this ensures that we are not relying on text typed into the UI **Text** object
    `Text-carrying-star` at design time, but that the UI seen by the user is always
    set by our run-time methods. This avoids problems where the words to be displayed
    to the user are changed in code and not in the **Inspector** panel—which leads
    to a mismatch between the onscreen text when the scene first runs and after it
    has been updated from a script.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A golden rule in Unity game design is to **avoid duplicating content in more
    than one place**, and, therefore, we avoid having to maintain two or more copies
    of the same content. Each duplicate is an opportunity for maintenance issues when
    some, but not all, copies of a value are changed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Maximizing use of prefabs is another example of this principle in action. This
    is also know as the DRY principal - Do Not Repeat Yourself.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some details you don''t want to miss:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The separation of view logic
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A game design pattern (best practice approach) called the **Model-View-Controller**
    pattern (**MVC**) is to separate the code that updates the UI from the code that
    changes player and game variables such as score and inventory item lists. Although
    this recipe has only one variable and one method to update the UI, well structured
    game architectures scale up to cope with more complex games, so it is often worth
    the effort of a little more code and an extra script class, even at this game-beginning
    stage, if we want our final game architecture to be well structured and maintainable.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the separation of view pattern for this recipe, we need to do
    the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following C# Script `PlayerInventoryDisplay` to GameObject `player-SpaceGirl`
    in the **Hierarchy**:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: From the **Hierarchy** view, select the GameObject `player-SpaceGirl`. Then,
    from the **Inspector**, access the `PlayerInventoryDisplay` **(Script)** component
    and populate the **Score Text** public field with the UI **Text** object `Text-carrying-star`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove the existing C# Script component `Player` and replace it with this C#
    Script `PlayerInventory` containing the following (simplified) code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As can be seen, the `PlayerInventory` script class no longer has to maintain
    a link to the UI **Text** or worry about changing the text property of that UI
    component—all that work is now the responsibility of the `PlayerInventoryDisplay`
    script. When the Player instance component detects a collision with the star,
    after changing the `carryingStar` bool flag's value to `true`, it just calls the
    `OnChangeCarryingStar()`method of the `PlayerInventoryDisplay` component.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The result is that the code for the script class `PlayerInventory` concentrates
    on the player collision and status variables, while the code for the script class
    `PlayerInventoryDisplay` handles the communication to the user. Another advantage
    of this design pattern is that the method in which the information is communicated
    to the user via the UI can be changed (for example, from text to an icon), without
    any change to the code in script class `Player`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: There is no difference in the experience of the player, and all the changes
    are to improve the architectural structure of our game code.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Displaying single object pickups with carrying and not-carrying icons
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphic icons are an effective way to inform the player that they are carrying
    an item. In this recipe, if no star is being carried, a grey-filled icon in a
    blocked-off circle is displayed; then, after the star has been picked up, a yellow-filled
    icon is displayed, as shown in the following screenshot.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying single object pickups with carrying and not-carrying icons](img/1362OT_02_14.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: In many cases, icons are clearer (they don't require reading and thinking about)
    and can also be smaller onscreen than text messages for indicating player status
    and inventory items.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe assumes that you are starting with the project `Simple2Dgame_SpaceGirl`
    setup from the first recipe in this chapter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To toggle carrying and not-carrying icons for a single object pickup, follow
    these steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Start with a new copy of the mini-game `Simple2Dgame_SpaceGirl`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy** panel, add a new UI **Image** object (**Create** | **UI**
    | **Image**). Rename it `Image-star-icon`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Image-star-icon` in the **Hierarchy** panel.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Project** panel, drag the sprite **icon_nostar_100** (folder `Sprites`)
    into the **Source Image** field in the **Inspector** (in the **Image (Script)**
    component).
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Set Native Size** button for the **Image** component. This will
    resize the UI **Image** to fit the physical pixel width and height of sprite file
    **icon_nostar_100**, as shown in the following screenshot:![How to do it...](img/1362OT_02_11.jpg)
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we will position our icon at the **top** and **left** of the **Game** panel.
    Edit the UI **Image's Rect Transform** component, and while holding down *SHIFT*
    and *ALT* (to set pivot and position), choose the top-left box. The UI **Image**
    should now be positioned at the top left of the **Game** panel, as shown in the
    following screenshot:![How to do it...](img/1362OT_02_12.jpg)
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following C# Script `Player` to GameObject `player-SpaceGirl` in the
    **Hierarchy**:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: From the **Hierarchy** view, select the GameObject `player-SpaceGirl`. Then,
    from the **Inspector**, access the **Player (Script)** component and populate
    the **Star Image** public field with UI **Image** object `Image-star-icon`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, populate the **Icon Star** public field from the **Project** panel with
    sprite `icon_star_100` and populate the **Icon No Star** public field from the
    **Project** panel with sprite `icon_nostar_100`, as shown in the following screenshot:![How
    to do it...](img/1362OT_02_13.jpg)
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now when you play the scene, you should see the no star icon (a grey-filled
    icon in a blocked-off circle) at the top left until you pick up the star, at which
    point it will change to show the carrying star icon (yellow-filled star).
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Image` variable `starImage` is a reference to the UI **Image** object `Image-star-icon`.
    `Sprite` variables `iconStar` and `iconNoStar` are references to the `Sprite`
    files in the **Project** panel—the sprites to tell the player whether or not a
    star is being carried. The `bool` variable `carryingStar` represents internally
    as program data whether or not the player is carrying the star at any point in
    time; it is initialized to `false`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Much of the logic for this recipe is the same as the previous one. Each time
    the `UpdateStarImage()`method is called, it sets the UI **Image** to the sprite
    that corresponds to the value of bool variable `carryingsStar`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Displaying multiple pickups of the same object with text totals
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When several items of the same type have been picked up, often the simplest
    way to convey what is being carried to the user is to display a text message showing
    the numeric total of each item type being carried, as shown in the following screenshot.
    In this recipe, the total number of stars collected is displayed using a UI **Text**
    object.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying multiple pickups of the same object with text totals](img/1362OT_02_15.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe assumes you are starting with project `Simple2Dgame_SpaceGirl` setup
    from the first recipe in this chapter. The font you need can be found in folder
    `1362_02_02`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To display inventory total text for multiple pickups of same type of object,
    follow these steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Start with a new copy of the mini-game `Simple2Dgame_SpaceGirl`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a UI **Text** object (**Create** | **UI** | **Text**). Rename it `Text-carrying-star`.
    Change its text to **stars = 0**.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the provided `Fonts` folder into your project.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** panel, set the font of `Text-carrying-star` to **Xolonium-Bold**
    (folder `Fonts`) and set its color to yellow. Center the text horizontally and
    vertically, and set its **Font Size** to `32`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its **Rect Transform** component, set its **Height** to `50`. Edit its **Rect
    Transform**, and while holding down *SHIFT* and *ALT* (to set pivot and position),
    choose the top-stretch box. Your text should now be positioned at the middle top
    of the **Game** panel, and its width should stretch to match that of the whole
    panel.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following C# Script `Player` to GameObject `player-SpaceGirl` in the
    **Hierarchy**:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: From the **Hierarchy** view, select the GameObject `player-SpaceGirl`. Then,
    from the **Inspector**, access the **Player (Script)** component and populate
    the **Star Text** public field with UI **Text** object `Text-carrying-star`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the GameObject `star` in the **Hierarchy** panel and make three more
    copies of this GameObject.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: Use keyboard shortcut *CTRL* + *D* (Windows) or *CMD* + *D* (Mac) to
    quickly duplicate GameObjects.'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Move these new GameObject to different parts of the screen.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the game—each time you pick up a star, the total should be displayed in
    the form **stars = 2**.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Text` variable `starText` is a reference to the UI **Text** object `Text-carrying-star`.
    The `int` variable `totalStars` represents how many stars have been collected
    so far; it is initialized to zero.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: In the `OnTriggerEnter2D()` method, the `totalStars` counter is incremented
    by 1 each time the player's character hits an object tagged **Star**. The collided
    star GameObject is destroyed and a call is made to the `UpdateStarText()`method.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The `UpdateStarText()` method updates the text content of UI **Text** object
    `Text-carrying-star` with text string `stars =` concatenated with the integer
    value inside variable `totalStars` to display the updated total number of stars
    to the user.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Displaying multiple pickups of the same object with multiple status icons
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If there is a small, fixed total number of an item to be collected rather than
    text totals, an alternative effective UI approach is to display placeholder icons
    (empty or greyed out pictures) to show the user how many of the item remain to
    be collected, and each time an item is picked up, a placeholder icon is replaced
    by a full color collected icon.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we use grey-filled star icons as the placeholders and yellow-filled
    star icons to indicate each collected star, as shown in the following screenshot.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Since our UI code is getting a little more complicated, this recipe will implement
    the MVC design pattern to separate the view code from the core player logic (as
    introduced at the end of recipe *Displaying single object pickups with carrying
    and not-carrying text*).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying multiple pickups of the same object with multiple status icons](img/1362OT_02_16.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe assumes that you are starting with the project `Simple2Dgame_SpaceGirl`
    setup from the first recipe in this chapter.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To display multiple inventory icons for multiple pickups of same type of object,
    follow these steps:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Start with a new copy of the mini-game `Simple2Dgame_SpaceGirl`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following C# Script `Player` to GameObject `player-SpaceGirl` in the
    **Hierarchy**:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Select GameObject `star` in the **Hierarchy** panel and make three more copies
    of this GameObject (Windows *CTRL* + *D* / Mac *CMD* + *D*).
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move these new GameObject to different parts of the screen.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the following C# Script `PlayerInventoryDisplay` to the GameObject `player-SpaceGirl`
    in the **Hierarchy:**
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Select the **Canvas** in the **Hierarchy** panel and add a new UI Image object
    (**Create** | **UI** | **Image**). Rename it `Image-star0`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Image-star0` in the **Hierarchy** panel.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Project** panel, drag the sprite `icon_star_grey_100` (folder `Sprites`)
    into the **Source Image** field in the **Inspector** for the **Image** component.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Set Native Size** button for this for the **Image** component.
    This will resize the UI **Image** to fit the physical pixel width and height of
    sprite file `icon_star_grey_100`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we will position our icon at the **top** and **left** of the **Game** panel.
    Edit the UI **Image's Rect Transform** component, and while holding down *SHIFT*
    and *ALT* (to set pivot and position), choose the top-left box. The UI **Image**
    should now be positioned at the top left of the **Game** panel.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make three more copies of `Image-star0` in the **Hierarchy** panel, naming them
    `Image-star1`, `Image-star2`, and `Image-star3`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** panel, change the **Pos X** position (in the **Rect Transform**
    component) of `Image-star1` to `100`, of `Image-star2` to `200`, and of `Image-star3`
    to `100`, as shown in the following screenshot:![How to do it...](img/1362OT_02_17.jpg)
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Hierarchy** view, select the GameObject `player-SpaceGirl`. Then,
    from the **Inspector**, access the **Player Inventory Display (Script)** component
    and set the **Size** property of public field **Star Playholders** to `4`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, populate the **Element 0/1/2/3** array values of public field **Star Playholders**
    with UI **Image** objects `Image-star0/1/2/3`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, populate the **Icon Star Yellow** and **Icon Star Grey** public fields
    from the **Project** panel with sprite `icon_star_100` and `icon_star_grey_100`,
    as shown in the following screenshot:![How to do it...](img/1362OT_02_18.jpg)
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, when you play the scene, you should see the sequence of four grey placeholder
    star icons initially, and each time you collide with a star, the next icon at
    the top should turn yellow.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Four UI **Image** objects `Image-star0/1/2/3` have been created at the top of
    the screen, initialized with the grey placeholder icon. The grey and yellow icon
    sprite files have been resized to be 100 x 100 pixels, making their arrangement
    horizontal positioning at design time easier, since their positions are (0,0),
    (100, 0), (200, 0), and (300,0). In a more complicated game screen, or one where
    real estate is precious, the actual size of the icons would probably be smaller
    and whatever the game graphic designer decides.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: The `int` variable `totalStars` represents how many stars have been collected
    so far; it is initialized to zero. The `PlayerInventoryDisplay` variable `playerInventory`
    is a reference to the scripted component that manages our inventory display—this
    variable is set when the scene begins to run in the `Start()` method.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: In the `OnTriggerEnter2D()`method, the `totalStars` counter is incremented by
    1 each time the player's character hits an object tagged **Star**. As well as
    destroying the hit GameObject, the `OnChangeStarTotal(…)` method of the `PlayerInventoryDisplay`
    component is called, passing the new star total integer.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The `OnChangeStarTotal(…)`method of script class `PlayerInventoryDisplay` has
    references to the four UI **Images**, and loops through each item in the array
    of Image references, setting the given number of Images to yellow, and the remaining
    to grey. This method is public, allowing it to be called from an instance of script
    class `Player`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen, the code in script class `Player` is still quite straightforward
    since we have moved all of the inventory UI logic to its own class, `PlayerInventory`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Revealing icons for multiple object pickups by changing the size of a tiled
    image
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another approach that could be taken to show increasing numbers of images is
    to make use of tiled images. The same visual effect as in the previous recipe
    can also be achieved by making use of a tiled grey star image of width 400 (showing
    four copies of the grey star icon), behind a tiled yellow star image, whose width
    is 100 times the number of stars collected. We'll adapt the previous recipe to
    illustrate this technique.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe follows on from the previous recipe in this chapter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To display grey and yellow star icons for multiple object pickups using tiled
    images, follow these steps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Make a copy of your work for the previous recipe.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy** panel, remove the four Image-star0/1/2/3 UI **Images**
    in the **Canvas**.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Canvas** in the **Hierarchy** panel and add a new UI **Image**
    object (**Create** | **UI** | **Image**). Rename it `Image-stars-grey`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Image-stars-grey` in the **Hierarchy** panel.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Project** panel, drag sprite `icon_star_grey_100` (folder `Sprites`)
    into the **Source Image** field in the **Inspector** (in the **Image (Script)**
    component).
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Set Native Size** button for this for the **Image** component.
    This will resize the UI **Image** to fit the physical pixel width and height of
    sprite file **star_empty_icon.**
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we will position our icon at the **top** and **left** of the **Game** panel.
    Edit the UI **Image's Rect Transform** component, and while holding down *SHIFT*
    and *ALT* (to set pivot and position), choose the top-left box. The UI **Image**
    should now be positioned at the top left of the **Game** panel.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** panel, change the **Width** (in the **Rect Transform**
    component) of `Image-stars-grey` to 400\. Also, set the **Image Type** (in the
    **Image (Script)** component) to **Tiled**, as shown in the following screenshot:![How
    to do it...](img/1362OT_02_19.jpg)
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a copy of `Image-stars-grey` in the **Hierarchy** panel, naming the copy
    `Image-stars-yellow`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `Image-stars-yellow` selected in **Hierarchy** panel, from the **Project**
    panel, drag the sprite `icon_star_100` (folder `Sprites`) into the **Source Image**
    field in the **Inspector** (in the **Image (Script)** component).
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the width of `Image-stars-yellow` to 0 (in the **Rect Transform** component).
    So, now we have the yellow stars tiled image above the grey tiled image, but since
    its width is zero, we don't see any of the yellow stars yet.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the existing C# Script `PlayerInventoryDisplay` with the following
    code:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: From the **Hierarchy** view, select the GameObject `player-SpaceGirl`. Then,
    from the **Inspector**, access the **Player Inventory Display (Script)** component
    and populate the **Icons Stars Yellow** public field with UI **Image** object
    `Image-stars-yellow`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UI **Image** `Image-stars-grey` is a tiled image, wide enough (400px) for grey
    sprite **icon_star_grey_100** to be shown four times. UI **Image** `Image-stars-yellow`
    is a tiled image, above the grey one, initially with width set to zero, so no
    yellow stars can be seen.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Each time a star is picked up, a call is made to the `OnChangeStarTotal(…)`method
    of the script class `PlayerInventoryDisplay` , passing the new integer number
    of stars collected. By multiplying this by the width of the yellow sprite image
    (100px), we get the correct width to set for UI **Image** `Image-stars-yellow`
    so that the corresponding number of yellow stars will now be seen by the user.
    Any stars that remain to be collected will still be seen as the grey stars that
    are not yet covered up.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: The actual task of changing the width of UI **Image** `Image-stars-yellow` is
    completed by calling the `SetSizeWithCurrentAnchors(…)` method. The first parameter
    is the axis, so we pass constant `RectTransform.Axis.Horizontal` so that it will
    be the width that is changed. The second parameter is the new size for that axis—so
    we pass a value that is 100 times the number of stars collected so far (variable
    `newWidth`).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Displaying multiple pickups of different objects as a list of text via a dynamic
    List<> of PickUp objects
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with different kinds of pickups, one approach is to use a C# **List**
    to maintain a flexible-length data structure of the items currently in the inventory.
    In this recipe, we will show you how, each time an item is picked up, a new object
    is added to such a **List** collection. An iteration through the **List** is how
    the text display of items is generated each time the inventory changes. We introduce
    a very simple `PickUp` script class, demonstrating how information about a pickup
    can be stored in a scripted component, extracted upon collision, and stored in
    our **List**.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying multiple pickups of different objects as a list of text via a
    dynamic List<> of PickUp objects](img/1362OT_02_36.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe assumes that you are starting with the project `Simple2Dgame_SpaceGirl`
    setup from the first recipe in this chapter. The font you need can be found in
    the `1362_02_02` folder.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To display inventory total text for multiple pickups of different object types,
    follow these steps:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Start with a new copy of the mini-game `Simple2Dgame_SpaceGirl`.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the tags, changing tag **Star** to **Pickup**. Ensure that the `star` GameObject
    now has the tag **Pickup**.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following C# Script `PickUp` to GameObject `star` in the **Hierarchy**:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the **Inspector**, change the description property of component **Pick Up
    (Script)** of GameObject `star` to the text `star`, as shown in the following
    screenshot:![How to do it...](img/1362OT_02_37.jpg)
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the GameObject `star` in the **Hierarchy** panel and make a copy of this
    GameObject, renaming the copy `heart`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector,** change the description property of component **Pick Up
    (Script)** of GameObject `heart` to the text `heart`. Also, drag from the **Project**
    panel (folder `Sprites`) image **healthheart** into the Sprite property of GameObject
    `heart`. The player should now see the heart image on screen for this pickup item.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the GameObject `star` in the **Hierarchy** panel and make a copy of this
    GameObject, renaming the copy `key`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector,** change the description property of component **Pick Up
    (Script)** of GameObject `key` to the text `key.` Also, drag from the **Project**
    panel (folder **Sprites**) image **icon_key_green_100** into the **Sprite** property
    of GameObject `key`. The player should now see the key image on screen for this
    pickup item.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make another one or two copies of each pickup GameObject and arrange them around
    the screen, so there are two or three each of star, heart, and key pickup GameObjects.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following C# Script `Player` to GameObject `player-SpaceGirl` in the
    **Hierarchy**:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Add a UI **Text** object (**Create** | **UI** | **Text**). Rename it `Text-inventory-list`.
    Change its text to **the quick brown fox jumped over the lazy dog the quick brown
    fox jumped over the lazy dog**, or another long list of nonsense words, to test
    the overflow settings you change in the next step.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Text (Script)** component, ensure that **Horizontal Overflow** is set
    to **Wrap**, and set **Vertical Overflow** to **Overflow**—this will ensure that
    the text will wrap onto a second or third line (if needed) and not be hidden if
    there are lots of pickups.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** panel, set its font to **Xolonium-Bold** (folder `Fonts`)
    and set its color to yellow. For the **Alignment** property, center the text horizontally
    and ensure that the text is top aligned vertically, and set the **Font Size**
    to 28 and choose a yellow text **Color**.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit its **Rect Transform** and set its **Height** to `50`. Then, while holding
    down *SHIFT* and *ALT* (to set pivot and position), choose the top-stretch box.
    The text should now be positioned at the middle top of the **Game** panel, and
    its width should stretch to match that of the whole panel.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your text should now appear at the top of the game panel.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following C# Script `PlayerInventoryDisplay` to GameObject `player-SpaceGirl`
    in the **Hierarchy**:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: From the **Hierarchy** view, select the GameObject `player-SpaceGirl`. Then,
    from the **Inspector**, access the **Player Inventory Display (Script)** component
    and populate the **Inventory Text** public field with the UI **Text** object `Text-inventory-list`.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Play the game—each time you pick up a star or key or heart, the updated list
    of what you are carrying should be displayed in the form **carrying: [key] [heart]**.'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the script class `Player`, the variable `inventory` is a C# **List<>**. This
    is a flexible data structure, which can be sorted, searched, and dynamically (at
    run time, when the game is being played) have items added to and removed from
    it. The `<PickUp>` in pointy brackets means that variable `inventory` will contain
    a list of `PickUp` objects. For this recipe, our `PickUp` class just has a single
    field, a string description, but we'll add more sophisticated data items in `PickUp`
    classes in later recipes.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: When the scene starts, the `Start()` method of script class `Player` gets a
    reference to the `PlayerInventoryDisplay` scripted component and also initializes
    variable `inventory` to be a new, empty C# List of `PickUp` objects. When the
    `OnColliderEnter2D(…)` method detects collisions with items tagged `Pickup`, the
    `PickUp` object component of the item hit is added to our `inventory` list. A
    call is also made to the `OnChangeInventory(…)` method of `playerInventoryDisplay`
    to update out inventory display to the player, passing the updated `inventory`
    **List** as a parameter.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: The script class `playerInventoryDisplay` has a public variable, linked to the
    UI **Text** object `Text-inventory-list`. The `OnChangeInventory(…)` method first
    sets the UI text to empty, and then loops through the inventory list, building
    up a string of each items description in square brackets ([key], [heart], and
    so on). If there were no items in the list, then the string is set to the text
    `(empty inventory)`. Finally, the text property of the UI **Text** object `Text-inventory-list`
    is set to the value of this string representation of what is inside variable `inventory`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some details you don''t want to miss:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Order items in the inventory list alphabetically
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It would be nice to alphabetically sort the words in the `inventory` list—both
    for neatness and consistency (so, in a game, if we pick up a key and a heart,
    it will look the same regardless of which order), but also so that items of the
    same type will be listed together, so we can easily see how many of each item
    we are carrying.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '![Order items in the inventory list alphabetically](img/1362OT_02_38.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
- en: 'To implement the alphabetic sorting of the items in the `inventory` list, we
    need to do the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following C# code to the beginning of method `OnChangeInventory(...)`
    in the script class `PlayerInventoryDisplay`:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You should now see all the items listed in alphabetic sequence. This C# code
    takes advantage of the `List.Sort(…)` method, a feature of collections whereby
    each item can be compared to the next, and they are swapped if in the wrong order
    (if the `CompareTo(…)` methods returns false).
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Displaying multiple pickups of different objects as text totals via a dynamic
    Dictionary<> of PickUp objects and "enum" pickup types
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the previous recipe worked fine, any old text might have been typed into
    the description for a pickup or perhaps mistyped (**star**, **Sstar**, **starr**,
    and so on). A much better way of restricting game properties to one of a predefined
    (enumerated) list of possible values is to use C# enums. As well as removing the
    chance of mistyping a string, it also means that we can write code to appropriately
    deal with the predefined set of possible values. In this recipe, we will improve
    our general purpose `PickUp` class by introducing three possible pickup types
    (Star, Heart, and Key), and write inventory display code that counts the number
    of each type of pickup being carried and displays these totals via a UI **Text**
    object on screen. We also switch from using a **List** to using a **Dictionary**,
    since the Dictionary data structure is designed specifically for key-value pairs,
    perfect for associating a numeric total with an enumerated pickup type.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying multiple pickups of different objects as text totals via a dynamic
    Dictionary<> of PickUp objects and "enum" pickup types](img/1362OT_02_39.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe follows on from the previous recipe in this chapter.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To display multiple pickups of different objects as text totals via a dynamic
    `Dictionary`, follow these steps:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Make a copy of your work for the previous recipe.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the content of script class `PickUp` with the following code:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Replace the content of script class `Player` with the following code:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Replace the content of script class `PlayerInventoryDisplay` with the following
    code:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the following C# Script `InventoryManager` to the GameObject `player-SpaceGirl`
    in the **Hierarchy**:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the **Hierarchy** (or **Scene**) panel, select each pickup GameObject in
    turn, and choose from the drop-down menu its corresponding **Type** in the **Inspector**
    panel. As you can see, public variables that are of an `enum` type are automatically
    restricted to the set of possible values as a combo-box drop-down menu in the
    **Inspector** panel.![How to do it...](img/1362OT_02_40.jpg)
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the game. First, you should see a message on screen stating the inventory
    is empty, and then as you pick up one or more items of each pickup type, you'll
    see text totals of each type you have collected.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each pickup GameObject in the scene has a scripted component of class `PickUp`.
    The `PickUp` object for each `Pickup` GameObject has a single property, a pickup
    type, which has to be one of the enumerated set of `Star, Key, Heart`. The `Player`
    script class gets a reference to the `InventoryManager` component via its `Start()`
    method, and each time the player's character collides with a pickup GameObject,
    it calls the `Add(…)` method of the inventory manager, passing the `PickUp` object
    of the object collided with.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, the inventory being carried by the player is being represented
    by a C# `Dictionary`. In this case, we have in script class `InventoryManager`
    a dictionary of key-value pairs, where the key is one of the possible `PickUp.PickUpType`
    enumerated values, and the value is an integer total of how many of that type
    of pickup is being carried. Each `InventoryItemTotal` object has just two properties:
    a `PickUp` type and an integer total. This extra layer of the `InventoryManager`
    has been added between script class `Player` and `PlayerInventoryDisplay` to both
    separate the `Player` behavior from how the inventory is internally stored and
    to prevent the `Player` script class from becoming too large and attempting to
    handle too many different responsibilities.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: C# dictionaries provide a `TryGetValue(…)` method, which receives parameters
    of a key and is passed a reference to a variable the same data type as the value
    for the `Dictionary`. When the `Add(…)` method of the inventory manager is called,
    the type of the `PickUp` object is tested to see if a total for this type is already
    in `Dictionary items`. If an item total is found inside the `Dictionary` for the
    given type, then the value for this item in the `Dictionary` is incremented. If
    no entry is found for the given type, then a new element is added to the `Dictionary`
    with a total of 1.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: The last action of the `Add(…)` method is to call the `OnChangeInventory(…)`
    method of the `PlayerInventoryDisplay` scripted component of the player's GameObject
    to update the text totals displayed on screen. This method in `PlayerInventoryDisplay`
    iterates through the `Dictionary`, building up a string of the type names and
    totals, and then updates the text property of the UI Text object with the string
    showing the inventory totals to the player.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about using C# lists and dictionaries in Unity in the Unity Technologies
    tutorial at [https://unity3d.com/learn/tutorials/modules/intermediate/scripting/lists-and-dictionaries](https://unity3d.com/learn/tutorials/modules/intermediate/scripting/lists-and-dictionaries).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Generalizing multiple icon displays using UI Grid Layout Groups (with scrollbars!)
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recipes in this chapter up to this point have been hand-crafted for each
    situation. While this is fine, more general and automated approaches to inventory
    UIs can sometimes save time and effort but still achieve visual and usability
    results of equal quality. In the next recipe, we will begin to explore a more
    engineered approach to inventory UIs by exploiting the automated sizing and layouts
    offered by Unity 5's Grid Layout Group component.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '![Generalizing multiple icon displays using UI Grid Layout Groups (with scrollbars!)](img/1362OT_02_20.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe assumes that you are starting with the project `Simple2Dgame_SpaceGirl`
    setup from the first recipe in this chapter. The font you need can be found in
    the `1362_02_02` folder.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To display grey and yellow star icons for multiple object pickups using UI
    grid layout groups, follow these steps:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Start with a new copy of the mini-game `Simple2Dgame_SpaceGirl`.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy** panel, create a UI Panel `Panel–background` (**Create**
    | **UI** | **Panel**).
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's now position `Panel–background` at the **top** of the **Game** panel,
    stretching the horizontal width of the canvas. Edit the UI **Image's Rect Transform**
    component, and while holding down *SHIFT* and *ALT* (to set pivot and position),
    choose the top-stretch box.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The panel will still be taking up the whole game window. So, now in the **Inspector**
    panel, change the **Height** (in the **Rect Transform** component) of `Panel–background`
    to 100, as shown in the following screenshot:![How to do it...](img/1362OT_02_21.jpg)
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a UI **Text** object (**Create** | **UI** | **Text**), rename it `Text-inventory`,
    and change its text to **Inventory**.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy** panel, child this UI Text object to panel `Panel–background`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** panel, also set the font of `Text-inventory` to **Xolonium-Bold**
    (the `Fonts` folder). Center the text horizontally, top align the text vertically,
    set its **Height** to `50`, and set the **Font Size** to `23`.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the **Rect Transform** of `Text-inventory`, and while holding down *SHIFT*
    and *ALT* (to set pivot and position), choose the top-stretch box. The text should
    now be positioned at the middle top of the **UI Panel** `Panel–background` and
    its width should stretch to match that of the whole panel.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Canvas** in the **Hierarchy** panel and add a new UI Panel object
    (**Create** | **UI** | **Image**). Rename it `Panel-slot-grid`.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position `Panel-slot-grid` at the **top** of the **Game** panel, stretching
    the horizontal width of the canvas. Edit the UI **Image's Rect Transform** component,
    and while holding down *SHIFT* and *ALT* (to set pivot and position), choose the
    top-stretch box.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** panel, change the **Height** (in the **Rect Transform**
    component) of `Panel-slot-grid` to `80` and set its **Top** to `20` (so it is
    below UI **Text** GameObject `Text-inventory`).
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the panel `Panel-slot-grid` selected in the **Hierarchy** panel, add a
    grid layout group component (**Add Component** | **Layout** | **Grid Layout Group**).
    Set **Cell Size** to `70` x `70` and **Spacing** to `5` x `5`. Also, set the **Child
    Alignment** to **Middle Center** (so our icons will have even spacing at the far
    left and right), as shown in the following screenshot:![How to do it...](img/1362OT_02_22.jpg)
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the panel `Panel-slot-grid` selected in the **Hierarchy** panel, add a
    mask (script) component (**Add Component** | **UI** | **Mask**). Uncheck the option
    **Show Mask Graphic**. Having this mask component means that any overflow of our
    grid will NOT be seen by the user—only content within the image area of the panel
    `Panel-slot-grid` will ever be visible.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add to your **Canvas** a UI **Image** object (**Create** | **UI** | **Image**).
    Rename it `Image-slot`.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy** panel, child UI **Image** object `Image-slot` to panel
    `Panel–slot-grid`.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Source Image** of `Image-slot` to the Unity provided **Knob** (circle)
    image, as shown in the following screenshot:![How to do it...](img/1362OT_02_23.jpg)
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since `Image-slot` is the only UI object inside `Panel-slot-grid,` it will be
    displayed (sized 70 x 70) in center in that panel, as shown in the following screenshot:![How
    to do it...](img/1362OT_02_24.jpg)
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each image slot will have a yellow star child image and a grey star child image.
    Let's create those now.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add to your **Canvas** a UI **Image** object (**Create | UI | Image**). Rename
    it `Image-star-yellow`.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy** panel, child UI **Image** object `Image-star-yellow` to
    image `Image–slot`.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Source Image** of `Image-star-yellow` to the `icon_star_100` image
    (in folder `Sprites`).
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we will set our yellow star icon image to fully fill its parent `Image-slot`
    by stretching horizontally and vertically. Edit the UI **Image's Rect Transform**
    component, and while holding down *SHIFT* and *ALT* (to set pivot and position),
    choose the bottom right option to fully **stretch** horizontally and vertically.
    The UI **Image** `Image-star-yellow` should now be visible in the middle of the
    `Image-slot` circular **Knob** image, as shown in the following screenshot:![How
    to do it...](img/1362OT_02_25.jpg)
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate `Image-star-yellow` in the **Hierarchy** panel, naming the copy `Image-star-grey`.
    This new GameObject should also be a child of `Image-slot`.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the **Source Image** of `Image-star-grey` to the `icon_star_grey_100`
    image (in folder `Sprites`). At any time, our inventory slot can now display nothing,
    a yellow star icon, or a grey star icon, depending on whether `Image-star-yellow`
    and `Image-star-grey` are enabled or not: we''ll control this through the inventory
    display code later in this recipe.'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Hierarchy** panel, ensure that `Image-slot` is selected, and add the
    C# Script `PickupUI` with the following code:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With the GameObject `Image-slot` selected in the **Hierarchy** panel, drag each
    of its two children `Image-star-yellow` and `Image-star-grey` into their corresponding
    **Inspector** panel **Pickup UI** slots **Star Yellow** and **Star Grey**, as
    shown in the following screenshot:![How to do it...](img/1362OT_02_27.jpg)
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy** panel, make nine duplicates of `Image-slot` in the **Hierarchy**
    panel; they should automatically be named `Image-slot 1 .. 9`. See the following
    screenshot to ensure the Hierarchy of your Canvas is correct—the parenting of
    `Image-slot` as a child of `Image-slot-grid`, and the parenting of `Image-star-yellow`
    and `Image-star-grey` as children of each `Image-slot` is very important.![How
    to do it...](img/1362OT_02_26.jpg)
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Hierarchy** panel, ensure that `player-SpaceGirl` is selected, and
    add the C# script `Player` with the following code:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the **Hierarchy** panel, ensure that `player-SpaceGirl` is selected, and
    add the C# script `PlayerInventoryModel` with the following code:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the **Hierarchy** panel, ensure that `player-SpaceGirl` is selected, and
    add the C# script `PlayerInventoryDisplay` with the following code:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With GameObject `player-SpaceGirl` selected in the **Hierarchy** panel, drag
    the ten `Image-slot` GameObjects into their corresponding locations in the **Player
    Inventory Display (Script)** component array **Slots**, in the **Inspector** panel,
    as shown in the following screenshot:![How to do it...](img/1362OT_02_28.jpg)
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene and play the game. As you pick up stars, you should see more
    of the grey stars change to yellow in the inventory display.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have created a simple panel (`Panel-background`) and text at the top of the
    game canvas—showing a greyish background rectangle and text "Inventory". We created
    a small panel inside this area (`Panel-slot-grid`), with a grid layout group component,
    which automatically sizes and lays out the 10 `Image-slot` GameObjects we created
    with the knob (circle) source image. By adding a mask component to `Panel-slot-grid`,
    we ensure that no content will overflow outside of the rectangle of the source
    image for this panel.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Each of the 10 `Image-slot` GameObjects that are children of `Panel-slot-grid`
    contains a yellow star image and a grey star image. Also, each `Image-slot` GameObjects
    has a script component `PickupUI`. The `PickupUI` script offers three public methods,
    which will show just the yellow star image, just the grey star image, or neither
    (so, an empty knob circle image will be seen).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Our player's character GameObject `player-SpaceGirl` has a very simple basic
    `Player` script—this just detected collisions with objects tagged `Star`, and
    when this happens, it removes the star GameObject collided with and calls the
    `AddStar()` method to its `playerInventoryModel` scripted component. The `PlayerInventoryModel`
    C# script class maintains a running integer total of the number of stars added
    to the inventory. Each time the `AddStar()` method is called, it increments (adds
    1) to this total, and then calls the `OnChangeStarTotal(…)` method of scripted
    component `playerInventoryDisplay`. Also, when the scene starts, an initial call
    is made to the `OnChangeStarTotal(…)` method so that the UI display for the inventory
    is set up to show that we are initially carrying no stars.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'The C# script class `PlayerInventoryDisplay` has two properties: one is a constant
    integer defining the number of slots in our inventory, which for this game we
    set to 10, and the other variable is an array of references to `PickupUI` scripted
    components—each of these is a reference to the scripted component in each of the
    10 `Image-slot` GameObjects in our `Panel-slot-grid`. When the `OnChangeStarTotal(…)`
    method is passed the number of stars we are carrying, it loops through each of
    the 10 slots. While the current slot is less than our star total, a yellow star
    is displayed, by the calling of the `DisplayYellow()` method of the current slot
    (`PickupUI` scripted component). Once the loop counter is equal to or larger than
    our star total, then all remaining slots are made to display a grey star via the
    calling of method `DisplayGrey()`.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: This recipe is an example of the **low coupling** of the MVC design pattern.
    We have designed our code to not rely or make too many assumptions about other
    parts of the game so that the chances of a change in some other part of our game
    breaking our inventory display code are much smaller. The display (view) is separated
    from the logical representation of what we are carrying (model), and changes to
    the model are made by public methods called from the player (controller).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: It might seem that we could make our code simpler by assuming that slots
    are always displaying grey (no star) and just changing one slot to yellow each
    time a yellow star is picked up. But this would lead to problems if something
    happens in the game (for example, hitting a black hole or being shot by an alien)
    that makes us drop one or more stars. C# script class `PlayerInventoryDisplay`
    makes no assumptions about which slots may or may not have been displayed grey
    or yellow or empty previously—each time it is called, it ensures that an appropriate
    number of yellow stars are displayed, and all other slots are displayed with grey
    stars.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some details you don''t want to miss:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Add a horizontal scrollbar to the inventory slot display
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can see 10 inventory slots now—but what if there are many more? One solution
    is to add a scroll bar so that the user can scroll left and right, viewing 10
    at a time, as shown in the following screenshot. Let's add a horizontal scroll
    bar to our game. This can be achieved without any C# code changes, all through
    the Unity 5 UI system.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '![Add a horizontal scrollbar to the inventory slot display](img/1362OT_02_35.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
- en: 'To implement a horizontal scrollbar for our inventory display, we need to do
    the following:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Increase the height of `Panel-background` to 130 pixels.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** panel, set the **Child Alignment** property of component
    **Grid Layout Group (Script)** of `Panel-slot-grid` to Upper Left. Then, move
    this panel to the right a little so that the 10 inventory icons are centered on
    screen.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy** panel, duplicate Image-slot 9 three more times so that
    there are now 13 inventory icons in `Panel-slot-grid`.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Scene** panel, drag the right-hand edge of panel `Panel-slot-grid`
    to make it wide enough so that all 13 inventory icons fit horizontally—of course
    the last three will be off screen, as shown in the following screenshot:![Add
    a horizontal scrollbar to the inventory slot display](img/1362OT_02_33.jpg)
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a UI **Panel** to the **Canvas** and name it `Panel-scroll-container`, and
    tint it red by setting the **Color** property of its **Image (Script)** component
    to red.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Size and position `Panel-scroll-container` so that it is just behind our `Panel-slot-grid`.
    So, you should now see a red rectangle behind the 10 inventory circle slots.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy** panel, drag `Panel-slot-grid` so that it is now childed
    to `Panel-scroll-container`.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a UI **Mask** to `Panel-scroll-container` so now you should only be able
    to see the 10 inventory icons that fit within the rectangle of this red-tinted
    panel.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: You may wish to temporarily set this mask component as inactive so that
    you can see and work on the unseen parts of `Panel-slot-grid` if required.'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add a UI **Scrollbar** to the **Canvas** and name it `Scrollbar-horizontal`.
    Move it to be just below the 10 inventory icons, and resize it to be the same
    width as the red-tinted `Panel-scroll-container`, as shown in the following screenshot:![Add
    a horizontal scrollbar to the inventory slot display](img/1362OT_02_32.jpg)
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a UI **Scroll Rect** component to `Panel-scroll-container`.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** panel, drag `Scrolbar-horizontal` to the Horizontal Scrollbar
    property of the **Scroll Rect** component of `Panel-scroll-container`.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** panel, drag `Panel-slot-grid` to the Content property of
    the **Scroll Rect** component of `Panel-scroll-container`, as shown in the following
    screenshot:![Add a horizontal scrollbar to the inventory slot display](img/1362OT_02_34.jpg)
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, ensure the **mask** component of `Panel-scroll-container` is set as active
    so that we don't see the overflow of `Panel-slot-grid` and uncheck this **mask**
    components option to **Show Mask Graphic** (so that we don't see the red rectangle
    any more).
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now have a working scrollable inventory system. Note that the last
    three new icons will just be empty circles, since the inventory display script
    does not have references to, or attempt to make, any changes to these extra three
    slots; so the script code would need to be changed to reflect every additional
    slot we add to `Panel-slot-grid`.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: The automation of PlayerInventoryDisplay getting references to all the slots
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There was a lot of dragging slots from the **Hierarchy** panel into the array
    for the scripted component `PlayerInventoryDisplay`. This takes a bit of work
    (and mistakes might be made when dragging items in the wrong order or the same
    item twice). Also, if we change the number of slots, then we may have to do this
    all over again or try to remember to drag more slots if we increase the number,
    and so on. A better way of doing things is to make the first task of the script
    class `PlayerInventoryDisplay` when the scene begins to create each of these `Image-slot`
    GameObjects as a child of `Panel-slot-grid` and populate the array at the same
    time.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the automated population of our scripted array of PickupUI objects
    for this recipe, we need to do the following:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder named `Prefabs`. In this folder, create a new empty prefab
    named `starUI`.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Hierarchy** panel**,** drag the GameObject `Image-slot` into your
    new empty prefab named `starUI`. This prefab should now turn blue, showing it
    is populated.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy** panel**,** delete GameObject `Image-slot` and all its copies
    `Image-slot 1 – 9`.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace C# Script `PlayerInventoryDisplay` in GameObject `player-SpaceGirl`
    with the following code:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With GameObject `player-SpaceGirl` selected in the **Hierarchy** panel, drag
    the GameObject `Panel-slot-grid` into **Player Inventory Display (Script)** variable
    **Slot grid**, in the **Inspector** panel.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With GameObject `player-SpaceGirl` selected in the **Hierarchy** panel, drag
    from the **Project** panel prefab `starUI` into **Player Inventory Display (Script)**
    variable **Star Slot Prefab**, in the **Inspector** panel, as shown in the following
    screenshot:![The automation of PlayerInventoryDisplay getting references to all
    the slots](img/1362OT_02_29.jpg)
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The public array has been made private and no longer needs to be populated through
    manual drag-and-drop. When you run the game, it will play just the same as before,
    with the population of the array of images in our inventory grid panel now automated.
    The `Awake()` method creates new instances of the prefab (as many as defined by
    constant `NUM_INVENTORY_SLOTS`) and immediately childed them to `Panel-slot-grid`.
    Since we have a grid layout group component, their placement is automatically
    neat and tidy in our panel.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: The scale property of the transform component of GameObjects is reset
    when a GameObject changes its parent (to maintain relative child size to parent
    size). So, it is a good idea to always reset the local scale of GameObjects to
    (1,1,1) immediately after they have been childed to another GameObject. We do
    this in the `for`-loop to `starSlotGO` immediately following the `SetParent(…)`
    statement.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Note that we use the `Awake() method` for creating the instances of the prefab
    in `PlayerInventoryDispay` so that we know this will be executed before the `Start()`
    method in `PlayerInventoryModel`—since no `Start()` method is executed until all
    `Awake()` methods for all GameObjects in the scene have been completed.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Automatically changing the grid cell size based on the number of slots in inventory
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider a situation where we wish to change the number of slots. Another alternative
    to using scrollbars is to change the cell size in the **Grid Layout Group** component.
    We can automate this through code so that the cell size is changed to ensure that
    `NUM_INVENTORY_SLOTS` will fit along the width of our panel at the top of the
    canvas.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the automated resizing of the **Grid Layout Group** cell size
    for this recipe, we need to do the following:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method `Start()` to the C# Script `PlayerInventoryDisplay`
    in GameObject `player-SpaceGirl` with the following code:'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![Automatically changing the grid cell size based on the number of slots in
    inventory](img/1362OT_02_30.jpg)'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: We write our code in the `Start()` method, rather than adding to code in the
    `Awake()` method, to ensure that the **RectTransform** of GameObject `Panel-slot-grid`
    has finished sizing (in this recipe, it stretches based on the width of the **Game**
    panel). While we can't know the sequence in which **Hierarchy** GameObjects are
    created when a scene begins, we can rely on the Unity behavior that every GameObject
    sends the `Awake()`message, and only after all corresponding `Awake()` methods
    have finished executing all objects, and then sends the `Start()` message. So,
    any code in the `Start()` method can safely assume that every GameObject has been
    initialized.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: The above screenshot shows the value of `NUM_INVENTORY_SLOTS` having been changed
    to 15, and the cell size, having been corresponding, changed, so that all 15 now
    fit horizontally in our panel. Note that the spacing between cells is subtracted
    from the calculated available with divided by the number of slots (`xCellSize
    -= gridLayoutGroup.spacing.x`) since that spacing is needed between each item
    displayed as well.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Add some help methods to the Rect Transform script class
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we wish to further change, say, the `RectTransform` properties using code,
    we can add extension methods by creating a file containing special static methods
    and using the special "this" keyword. See the following code that adds `SetWidth(…)`,
    `SetHeight(…)`, and `SetSize(…)` methods to the `RectTransform` scripted component:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Unity C# allows us to add these extensions methods by declaring `static void`
    methods whose first argument is in the form this `<ClassName> <var>`. The method
    can then be called as a built-in method defined in the original class.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: All we would need to do is create a new C# script class file `RectTransformExtensions`
    in the folder **Scripts** in the **Project** panel, containing the above code.
    In fact, you can find a whole set of useful extra `RectTransform` methods (on
    which the above is an extract) created by OrbcreationBV, and it is available online
    at [http://www.orbcreation.com/orbcreation/page.orb?1099](http://www.orbcreation.com/orbcreation/page.orb?1099).
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的所有事情就是在**项目**面板中的**脚本**文件夹中创建一个新的C#脚本类文件`RectTransformExtensions`，包含上述代码。实际上，你可以找到由OrbcreationBV创建的整个有用的额外`RectTransform`方法集（上述代码只是其中的一部分），并且这些方法在网上[http://www.orbcreation.com/orbcreation/page.orb?1099](http://www.orbcreation.com/orbcreation/page.orb?1099)可用。
- en: Conclusion
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, we introduced recipes demonstrating a range of C# data representations
    for inventory items and a range of Unity UI interface components to display the
    status and contents of player inventories at run time.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了各种C#数据表示方法，用于表示库存物品，以及一系列Unity UI界面组件，用于在运行时显示玩家库存的状态和内容。
- en: 'Inventory UI needs good quality graphical assets for a high quality result.
    Some sources of assets that you might wish to explore include the following sites:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 库存用户界面需要高质量的图形资源以获得高质量的结果。以下是一些你可能希望探索的资源来源网站：
- en: 'The graphics for our SpaceGirl mini game are from the Space Cute art by Daniel
    Cook; he generously publishes lots of 2D art for game developers to use:'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们SpaceGirl迷你游戏的图形来自Daniel Cook的Space Cute艺术作品；他慷慨地发布了大量2D艺术作品，供游戏开发者使用：
- en: '[http://www.lostgarden.com/](http://www.lostgarden.com/)'
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.lostgarden.com/](http://www.lostgarden.com/)'
- en: '[http://www.lostgarden.com/search?q=planet+cute](http://www.lostgarden.com/search?q=planet+cute)'
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.lostgarden.com/search?q=planet+cute](http://www.lostgarden.com/search?q=planet+cute)'
- en: 'Sethbyrd—lots of fun 2D graphics:'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sethbyrd——许多有趣的2D图形：
- en: '[http://www.sethbyrd.com/](http://www.sethbyrd.com/)'
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.sethbyrd.com/](http://www.sethbyrd.com/)'
- en: 'Royalty-free art for 2D games:'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于2D游戏的免版税艺术作品：
- en: '[http://www.gameart2d.com/freebies.html](http://www.gameart2d.com/freebies.html)'
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.gameart2d.com/freebies.html](http://www.gameart2d.com/freebies.html)'
