- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: 'Simplifying Containers and Kubernetes: Azure Container Apps, and Othert Tools'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化容器和 Kubernetes：Azure Container Apps 和其他工具
- en: While Kubernetes is probably the most complete orchestrator, any transition
    from monolithic development to microservices on Kubernetes faces two hard difficulties.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Kubernetes 可能是最完整的编排器，但从单体开发到 Kubernetes 上的微服务的任何过渡都面临两个难题。
- en: The first difficulty is that the cost of a Kubernetes cluster often is not justified
    by the initial low traffic of the application. In fact, a production-grade Kubernetes
    cluster typically requires multiple nodes for redundancy and reliability. While
    self-managed clusters may need at least two master nodes and three worker nodes,
    managed Kubernetes services such as **Amazon Elastic Kubernetes Service** (**Amazon
    EKS**), **Azure Kubernetes Service** (**AKS**), or **Google Kubernetes Engine**
    (**GKE**) often handle control plane redundancy at a lower cost (Amazon EKS control
    plane costs ~$72/month). Teams can start with smaller instance types and scale
    as needed, reducing the initial burden.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个困难是 Kubernetes 集群的成本往往不能由应用的初始低流量所证明。事实上，一个生产级的 Kubernetes 集群通常需要多个节点来实现冗余和可靠性。虽然自管理的集群可能至少需要两个主节点和三个工作节点，但像**Amazon
    Elastic Kubernetes Service**（**Amazon EKS**）、**Azure Kubernetes Service**（**AKS**）或**Google
    Kubernetes Engine**（**GKE**）这样的托管 Kubernetes 服务通常以较低的成本处理控制平面冗余（Amazon EKS 控制平面成本约为每月72美元）。团队可以从较小的实例类型开始，并根据需要扩展，从而减少初始负担。
- en: Another difficulty is the learning curve of Kubernetes itself. Moving the whole
    team to discrete Kubernetes knowledge/expertise might require time that we simply
    don’t have. Moreover, if we are transitioning an existing monolithic application,
    at the beginning of the transition—when the number of microservices is still low
    and their organization still resembles the same organization of the monolithic
    application—we simply don’t need all the opportunities and options offered by
    Kubernetes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个困难是 Kubernetes 本身的学习曲线。将整个团队转移到离散的 Kubernetes 知识/专业知识可能需要我们没有的时间。此外，如果我们正在过渡现有的单体应用程序，在过渡的开始——当微服务数量仍然很少，它们的组织仍然类似于单体应用程序的组织——我们根本不需要
    Kubernetes 提供的所有机会和选项。
- en: 'The preceding considerations led to the conception of **Azure Container Apps**,
    which is a serverless alternative to Kubernetes. Being a serverless option, you
    pay just for what you use and overcome the problem of the initial cluster size
    threshold. **Azure Container Apps** also lowers the learning curve thanks to the
    following features:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的考虑导致了**Azure Container Apps**的概念，它是一种无服务器的Kubernetes替代方案。作为一个无服务器选项，你只需为所使用的服务付费，并克服了初始集群大小阈值的问题。**Azure
    Container Apps**还通过以下功能降低了学习曲线：
- en: While Kubernetes offers all the building blocks for coding both tools and microservices,
    **Azure Container Apps** building blocks are the microservices themselves, so
    the developer can remain focused on the business logic without spending too much
    time on technical details. Tools such as storage solutions, message brokers, and
    other performance and security tools are taken from the hosting platform—that
    is, Azure.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然 Kubernetes 提供了构建工具和微服务的所有构建块，但**Azure Container Apps**的构建块本身就是微服务，因此开发者可以专注于业务逻辑，而无需花费太多时间在技术细节上。存储解决方案、消息代理和其他性能和安全工具都是从托管平台——即
    Azure——获取的。
- en: There are acceptable defaults for everything, so deploying an application may
    become as simple as deciding on the Docker images to deploy. Customizations can
    also be specified at a later time.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于所有内容都有可接受的默认值，因此部署应用程序可能变得像决定要部署的 Docker 镜像一样简单。也可以在以后指定自定义设置。
- en: After a short description of the various tools used to simplify the usage and
    administration of Kubernetes clusters, this chapter describes **Azure Container
    Apps** in detail and how to use it in practice. This chapter relies on preexisting
    knowledge of Kubernetes, so please read it after having studied [*Chapter 8*](Chapter_8.xhtml#_idTextAnchor205),
    *Practical Microservices Organization with Kubernetes*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在简要描述了用于简化 Kubernetes 集群使用和管理的各种工具之后，本章详细介绍了**Azure Container Apps**及其在实际中的应用。本章依赖于对
    Kubernetes 的现有知识，因此请在学习过[*第8章*](Chapter_8.xhtml#_idTextAnchor205)，*使用 Kubernetes
    进行实践微服务组织*之后阅读。
- en: 'More specifically, this chapter covers the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，本章涵盖了以下内容：
- en: Tools for simplifying Kubernetes cluster usage and administration
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化 Kubernetes 集群使用和管理的工具
- en: '**Azure Container Apps** basics and plans'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure Container Apps**的基础和计划'
- en: Deploying your microservice application with **Azure Container Apps**
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Azure Container Apps**部署您的微服务应用
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要以下内容：
- en: Visual Studio 2022 free *Community Edition*, at least.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少是Visual Studio 2022的免费*社区版*。
- en: Azure CLI. Links for both the 32-bit and 64-bit Windows installers can be found
    at[https://learn.microsoft.com/bs-latn-ba/cli/azure/install-azure-cli-windows?tabs=azure-cli](https://learn.microsoft.com/bs-latn-ba/cli/azure/install-azure-cli-windows?tabs=azure-cli)**.**
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Azure CLI。32位和64位Windows安装程序的链接可以在[https://learn.microsoft.com/bs-latn-ba/cli/azure/install-azure-cli-windows?tabs=azure-cli](https://learn.microsoft.com/bs-latn-ba/cli/azure/install-azure-cli-windows?tabs=azure-cli)找到**。**
- en: An Azure subscription.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个Azure订阅。
- en: minikube and kubectl. Please refer to the *Technical requirements* section of
    [*Chapter 8*](Chapter_8.xhtml#_idTextAnchor205), *Practical Microservices Organization
    with Kubernetes*.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: minikube和kubectl。请参阅[*第8章*](Chapter_8.xhtml#_idTextAnchor205)，“使用Kubernetes的实用微服务组织”的*技术要求*部分，*Practical
    Microservices Organization with Kubernetes*。
- en: Tools for simplifying Kubernetes clusters usage and administration
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化Kubernetes集群使用和管理的工具
- en: 'After the success of Kubernetes, a lot of products, services and open sources
    connected with it appeared. In this section, we classify them and provide some
    relevant examples. The whole offering related to Kubernetes can be classified
    as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes成功之后，出现了许多与之相关的产品、服务和开源项目。在本节中，我们将对它们进行分类并提供一些相关示例。与Kubernetes相关的整个产品组合可以按以下方式分类：
- en: Tools for packaging libraries and applications.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打包库和应用的工具。
- en: Kubernetes graphic UIs.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes图形用户界面。
- en: Administrative tools for taking and presenting various cluster metrics, handling
    alarms, and performing administrative actions.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于收集和展示各种集群指标、处理警报和执行管理操作的行政工具。
- en: Tools for handling the whole development and deployment of microservices-based
    applications that include Kubernetes as their target deployment platform.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理基于微服务应用（包括Kubernetes作为目标部署平台）的整个开发和部署的工具。
- en: Programming environments built on top of Kubernetes. These include both vertical
    applications, such as machine learning and big data tools, and general-purpose
    programming environments, such as Azure Container Apps.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立在Kubernetes之上的编程环境。这包括垂直应用，如机器学习和大数据工具，以及通用编程环境，如Azure Container Apps。
- en: When it comes to packaging tools, the most relevant is **Helm**, which became
    a de facto standard for packaging Kubernetes applications and libraries. We will
    analyze it in a dedicated subsection next.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到打包工具时，最相关的是**Helm**，它已成为打包Kubernetes应用程序和库的事实标准。我们将在下一节中分析它。
- en: Helm and Helm charts
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Helm和Helm图表
- en: '**Helm** is a package manager, and the packages it manages are called **Helm
    charts**. Helm charts are a way to organize the installation of complex Kubernetes
    applications that contain several `.yaml` files. A Helm chart is a set of `.yaml`
    files organized into folders and subfolders. Here is a typical folder structure
    of a Helm chart taken from the official documentation:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**Helm**是一个包管理器，它管理的包被称为**Helm图表**。Helm图表是组织包含多个`.yaml`文件的复杂Kubernetes应用程序的一种方式。Helm图表是一组组织到文件夹和子文件夹中的`.yaml`文件。以下是从官方文档中摘取的一个典型的Helm图表文件夹结构：'
- en: '![Figure 9.1: Folder structure of a Helm chart](img/B31916_09_1.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1：Helm图表的文件夹结构](img/B31916_09_1.png)'
- en: 'Figure 9.1: Folder structure of a Helm chart'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：Helm图表的文件夹结构
- en: 'The `.yaml` files specific to the application are placed in the top `templates`
    directory, while the `charts` directory may contain other Helm charts used as
    helper libraries. The top-level `Chart.yaml` file contains general information
    about the package (name and description), together with both the application version
    and the Helm chart version. The following is a typical example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 特定于应用的`.yaml`文件放置在顶层的`templates`目录中，而`charts`目录可能包含其他用作辅助库的Helm图表。顶层的`Chart.yaml`文件包含有关包的一般信息（名称和描述），以及应用版本和Helm图表版本。以下是一个典型的示例：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `type` can be either `application` or `library`. Only `application` charts
    can be deployed, while `library` charts are utilities for developing other charts.
    `library` charts are placed in the `charts` folder of other Helm charts.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`type`可以是`application`或`library`。只有`application`图表可以部署，而`library`图表是用于开发其他图表的实用工具。`library`图表放置在其他Helm图表的`charts`文件夹中。
- en: In order to configure each specific application installation, Helm chart `.yaml`
    files contain variables that are specified when Helm charts are installed. Moreover,
    Helm charts also provide a simple templating language that allows some declarations
    to be included only if some conditions depending on the input variables are satisfied.
    The top-level `values.yaml` file declares default values for the input variables,
    meaning that the developer needs to specify just a few variables for which they
    require different values from the defaults. We will not describe the Helm chart
    templates language because it would be too extensive, but you can find it in the
    official Helm documentation referred to in the *Further reading* section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置每个特定的应用程序安装，Helm图表`.yaml`文件包含在安装Helm图表时指定的变量。此外，Helm图表还提供了一种简单的模板语言，允许在某些条件满足的情况下包含一些声明，这些条件取决于输入变量。顶层`values.yaml`文件声明了输入变量的默认值，这意味着开发者只需指定几个需要不同值的变量。我们不会描述Helm图表模板语言，因为它过于广泛，但您可以在*进一步阅读*部分中找到官方Helm文档。
- en: 'Helm charts are usually organized in public or private repositories in a way
    that is similar to Docker images. There is a Helm client, which you can use to
    download packages from a remote repository and install charts in Kubernetes clusters.
    The Helm client can be installed on any machine with a kubectl installation through
    the Chocolatey package manager, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Helm图表通常以类似于Docker镜像的方式组织在公共或私有仓库中。有一个Helm客户端，您可以使用它从远程仓库下载软件包并在Kubernetes集群中安装图表。Helm客户端可以通过Chocolatey软件包管理器安装在安装了kubectl的任何机器上，如下所示：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In turn, you may find the Chocolatey installation procedure in the *Technical
    requirements* section of[*Chapter 8*](Chapter_8.xhtml#_idTextAnchor205), *Practical
    Microservices Organization with Kubernetes*. Helm operates with the current kubectl
    Kubernetes cluster and user.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地，您可以在[*第8章*](Chapter_8.xhtml#_idTextAnchor205)的*技术要求*部分找到关于Chocolatey安装程序的说明，即《使用Kubernetes的实用微服务组织》。Helm与当前的kubectl
    Kubernetes集群和用户一起运行。
- en: 'A remote repository must be added before using its packages, as shown in the
    following example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用其软件包之前，必须先添加远程仓库，如下所示：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The previous command makes the package information of a remote repository available
    locally and gives a local name to that remote repository. The information about
    all charts available in one or more repositories can be refreshed with the following
    command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令使远程仓库的软件包信息在本地可用，并为该远程仓库赋予一个本地名称。可以使用以下命令刷新一个或多个仓库中所有可用图表的信息：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If no repository name is specified, all local repositories are updated.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定仓库名称，则所有本地仓库都将更新。
- en: 'After that, any package from the remote repository can be installed with a
    command such as the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，可以使用以下类似命令安装远程仓库中的任何软件包：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, `<namespace>` is the Kubernetes namespace where to install the application.
    As usual, if it’s not provided, the `default` namespace is assumed. `<package
    name>` is the name of the package you would like to install, and finally, `<instance
    name>` is the name that you give to the installed application. You need this name
    to get information about the installed application with the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<namespace>`是要安装应用程序的Kubernetes命名空间。通常，如果没有提供，则假定使用`default`命名空间。`<package
    name>`是要安装的软件包的名称，最后，`<instance name>`是您为安装的应用程序提供的名称。您需要这个名称来使用以下命令获取有关已安装应用程序的信息：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can get also information about all applications installed with Helm with
    the help of the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用以下命令获取有关使用Helm安装的所有应用程序的信息：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The application name is also needed to delete the application from the cluster
    using the following command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 删除集群中的应用程序也需要应用程序名称，如下所示：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When we install an application, we may also provide a `.yaml` file with all
    the default variable values we want to override. We can also specify a specific
    version of the Helm chart; otherwise, the most recent version is used. Here is
    an example with both the version and values overridden:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们安装应用程序时，我们还可以提供一个包含所有要覆盖的默认变量值的`.yaml`文件。我们还可以指定Helm图表的特定版本；否则，将使用最新版本。以下是一个同时覆盖版本和值的示例：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, default value overrides can also be provided in line with the `--set`
    option, as shown here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，也可以按照`--set`选项提供默认值覆盖，如下所示：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can also upgrade an existing installation with the `upgrade` command, as
    shown here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`upgrade`命令升级现有安装，如下所示：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `upgrade` command may specify new value overrides with the `–f` option or
    with the `--set` option, and it can also specify the new version to install with
    `--version`. If no version is specified, the more recent version is installed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`upgrade`命令可以使用`-f`选项或`--set`选项指定新的值覆盖，也可以使用`--version`指定要安装的新版本。如果没有指定版本，将安装最新版本。'
- en: More details on Helm can be found in the official documentation at [https://helm.sh/](https://helm.sh/).
    We will show how to use Helm in practice in the later subsection about Kubernetes
    administrative tools.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于Helm的详细信息可以在官方文档[https://helm.sh/](https://helm.sh/)中找到。我们将在关于Kubernetes管理工具的后续小节中展示如何实际使用Helm。
- en: Kubernetes graphic UIs
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes图形UI
- en: There are also tools that help the definition and deployment of Kubernetes resources
    through user-friendly graphic interfaces. Among them, it is worth mentioning ArgoCD
    and Rancher UI.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 还有工具可以帮助通过用户友好的图形界面定义和部署Kubernetes资源。其中，值得提及的是ArgoCD和Rancher UI。
- en: '**ArgoCD** handles a database of Kubernetes resources and automatically updates
    a Kubernetes cluster whenever the code that defines a resource changes. ArgoCD
    simplifies a lot of Kubernetes cluster handling but automatic re-deployment of
    resources may cause issues in production environments that require zero downtime.
    We will not describe ArgoCD here, but interested readers can find more details
    in the *Further reading* section.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**ArgoCD**管理一个Kubernetes资源数据库，并在定义资源的代码更改时自动更新Kubernetes集群。ArgoCD简化了大量的Kubernetes集群管理，但资源的自动重新部署可能会在生产环境中导致需要零停机时间的问题。我们在此处不会描述ArgoCD，但感兴趣的读者可以在*进一步阅读*部分找到更多详细信息。'
- en: '**Rancher UI** enables users to interact with several Kubernetes clusters through
    a web-based UI. It has also tools for handling the whole development process,
    such as the definition of projects.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rancher UI**允许用户通过基于Web的UI与多个Kubernetes集群交互。它还提供处理整个开发过程（如项目定义）的工具。'
- en: The Rancher UI web application must be accessible from within each Kubernetes
    cluster it must handle, and requires the installation software inside each of
    the Kubernetes clusters that it must handle.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Rancher UI Web应用程序必须可以从它必须处理的每个Kubernetes集群内部访问，并且需要在它必须处理的每个Kubernetes集群内部安装软件。
- en: 'Rancher UI can also be installed on a developer’s local machine, where it can
    be used to interact with minikube. The simplest way to perform a local installation
    is through Docker. Open a Linux shell and enter the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Rancher UI也可以安装在开发者的本地机器上，在那里它可以用来与minikube交互。进行本地安装的最简单方法是使用Docker。打开Linux
    shell并输入以下代码：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A few minutes after the installation is completed, Rancher UI is available at
    `https://localhost`. If you can’t access it, wait a minute and retry.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后几分钟，Rancher UI在`https://localhost`可用。如果你无法访问它，请等待一分钟然后重试。
- en: 'Once the web interface appears for the first time, you need a temporary password.
    You can get this password with the following Linux command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次出现Web界面时，你需要一个临时密码。你可以使用以下Linux命令获取此密码：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Copy the temporary password in the Rancher UI initial page, and press **Continue**.
    The new page that appears should propose a new definitive password for the admin
    user, and the URL to be used by minikube to access Rancher UI. Fill this page
    as shown here:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rancher UI初始页面复制临时密码，然后按**继续**。出现的新页面应该建议为管理员用户提供一个新的最终密码，以及minikube访问Rancher
    UI要使用的URL。按照以下方式填写此页面：
- en: '![Figure 9.2: Rancher initial settings](img/B31916_09_2.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2：Rancher初始设置](img/B31916_09_2.png)'
- en: 'Figure 9.2: Rancher initial settings'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：Rancher初始设置
- en: Accept the proposed password, copy it, and store it in a safe place. The `host.docker.internal`
    hostname enables minikube to connect with our machine localhost.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接受建议的密码，复制它，并将其保存在安全的地方。`host.docker.internal`主机名使minikube能够连接到我们的机器localhost。
- en: 'On the dashboard, click the **Import Existing** button to start the process
    of connecting an existing cluster with Rancher UI:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在仪表板上，点击**导入现有**按钮以开始使用Rancher UI连接现有集群的过程：
- en: '![Figure 9.3: Importing an existing cluster](img/B31916_09_3.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3：导入现有集群](img/B31916_09_3.png)'
- en: 'Figure 9.3: Importing an existing cluster'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：导入现有集群
- en: 'On the new page that appears, select the [Generic](https://www.Generic.com)
    cluster option:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现的新页面上，选择[通用](https://www.Generic.com)集群选项：
- en: '![Figure 9.4: Generic cluster option](img/B31916_09_4.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4：通用集群选项](img/B31916_09_4.png)'
- en: 'Figure 9.4: Generic cluster option'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：通用集群选项
- en: 'Fill in just the cluster name and description on the page that appears, as
    shown here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在出现的页面上填写集群名称和描述，如图所示：
- en: '![](img/B31916_09_5.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![img/B31916_09_5.png]'
- en: 'Figure 9.5: Filling in the cluster information'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：填写集群信息
- en: 'Then, click the **Create** button. A page with the code to run in your cluster
    should appear. You should select the second code option since the local Rancher
    installation uses a self-signed certificate, which should be something like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击**创建**按钮。应该会显示一个包含在您的集群中运行的代码的页面。你应该选择第二个代码选项，因为本地Rancher安装使用的是自签名证书，应该类似于以下内容：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'However, this code must be executed in a Linux shell, and `kubectl` is installed
    only on Windows. Therefore, replace the preceding instruction with the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，此代码必须在Linux shell中执行，并且`kubectl`仅在Windows上安装。因此，将前面的指令替换为以下指令：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then, execute it in a Linux shell. It will create the `install.yaml` file that
    contains our Kubernetes code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在Linux shell中执行它。它将创建包含我们的Kubernetes代码的`install.yaml`文件。
- en: 'Now, we can install Rancher on minikube. Ensure that minikube is running, open
    a Windows console, and execute the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在minikube上安装Rancher。确保minikube正在运行，打开Windows控制台，并执行以下命令：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When the installation is complete, return to the dashboard; you should see
    the newly imported minikube cluster:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当安装完成后，返回仪表板；你应该看到新导入的minikube集群：
- en: '![Figure 9.6: Minikube cluster connected](img/B31916_09_6.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 9.6: Minikube cluster connected](img/B31916_09_6.png)'
- en: 'Figure 9.6: Minikube cluster connected'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6：Minikube集群已连接
- en: Click on the `minikube` link and enjoy the power of interacting with Minikube
    through a graphic UI! Here, you can see nodes, Pods, namespaces, and all types
    of Kubernetes resources, and can also define new resources.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 点击`minikube`链接，享受通过图形UI与Minikube交互的强大功能！在这里，你可以看到节点、Pods、命名空间以及所有类型的Kubernetes资源，还可以定义新的资源。
- en: 'When you have finished experimenting, stop minikube and the Rancher container
    in the Docker UI. If you don’t need to interact with minikube through Rancher
    anymore, just execute the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成实验后，在Docker UI中停止minikube和Rancher容器。如果你不再需要通过Rancher与minikube交互，只需执行以下操作：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Kubernetes administrative tools
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes行政工具
- en: Each cloud provider offers administrative UIs together with the Kubernetes offering.
    These UIs include the possibility to perform actions on the cluster, such as inspecting
    Kubernetes resources, collecting various metrics, and both querying and plotting
    these metrics. We will analyze the administrative tools offered by Azure in more
    detail in [*Chapter 10*](Chapter_10.xhtml#_idTextAnchor297), *Security and Observability
    for Serverless and Microservices Applications*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每个云服务提供商都提供了与Kubernetes服务一起的行政UI。这些UI包括对集群执行操作的可能性，例如检查Kubernetes资源、收集各种指标，以及查询和绘制这些指标。我们将在[*第10章*](Chapter_10.xhtml#_idTextAnchor297)中更详细地分析Azure提供的行政工具，*无服务器和微服务应用程序的安全性和可观察性*。
- en: However, there are also several tools offered by third parties and also several
    open source projects. Among the open source projects, it is worth mentioning the
    metrics collector called **Prometheus**, and the UI-based administrative console
    called **Grafana**. Usually, they are installed together and Prometheus works
    as a metrics source for Grafana. They can be installed on any Kubernetes cluster,
    including minikube.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有第三方提供的几个工具以及几个开源项目。在开源项目中，值得提及的是名为**Prometheus**的指标收集器，以及名为**Grafana**的基于UI的行政控制台。通常，它们一起安装，Prometheus作为Grafana的指标源。它们可以安装在任何Kubernetes集群上，包括minikube。
- en: A detailed description of these tools is beyond the purpose of the book, but
    since they are very common and are also a prerequisite for other tools, we will
    describe how to install them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具的详细描述超出了本书的目的，但鉴于它们非常常见，也是其他工具的先决条件，我们将描述如何安装它们。
- en: 'If you would like to test these tools on minikube, you need a configuration
    with more memory, and some other custom settings, so the the best option is to
    define a new profile while starting minikube with the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在minikube上测试这些工具，你需要一个具有更多内存的配置和一些其他自定义设置，因此最佳选项是在启动minikube时定义一个新的配置文件，如下所示：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, the `--extra-config` option allows the configuration of various Kubernetes
    installation options. If you don’t use minikube, you must be sure that the Kubernetes
    cluster is configured with the options passed with `--extra-config` in the preceding
    instruction. These settings enable Webhooks on the controller manager that Prometheus
    uses to collect its metrics and change the IP addresses exposed by both the controller
    and scheduler on the master nodes to enforce compatibility with Prometheus.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`--extra-config`选项允许配置各种Kubernetes安装选项。如果您不使用minikube，您必须确保Kubernetes集群已配置为使用前一个指令中通过`--extra-config`传递的选项。这些设置在Prometheus使用的控制器管理器上启用Webhooks，并强制控制器和调度器在主节点上暴露的IP地址与Prometheus兼容。
- en: 'Once all these settings are fixed, we can install both Prometheus and Grafana
    with Helm:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有这些设置都确定，我们就可以使用Helm安装Prometheus和Grafana：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first two instructions add the repositories containing Prometheus and Grafana,
    respectively, and the third instruction updates all repository local directories.
    The third instruction installs Prometheus in the `monitoring` namespace, after
    having created this namespace, and finally, the last instruction installs Grafana
    in the same namespace.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个指令添加了包含Prometheus和Grafana的存储库，第三个指令更新了所有本地存储库目录。第三个指令在创建该命名空间后，在`monitoring`命名空间中安装Prometheus，最后，最后一个指令在相同的命名空间中安装Grafana。
- en: 'After the installation, we can inspect the `monitoring` namespace to verify
    that all resources are ready:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以检查`monitoring`命名空间以验证所有资源是否就绪：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, both the Prometheus and Grafana UIs can be accessed by port-forwarding
    adequate services. Remember to use a different console window for each port-forward
    service, since the console freezes while port-forwarding:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以通过端口转发适当的服务来访问Prometheus和Grafana的UI。请记住，为每个端口转发服务使用不同的控制台窗口，因为在端口转发时控制台会冻结：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After that, Prometheus will be available at [http://localhost:9090](http://localhost:9090)
    and Grafana at http://localhost:3000\. While Prometheus doesn’t require a login,
    the default user for Grafana is `admin` and the password must be extracted from
    a Kubernetes secret, as shown here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，Prometheus将在[http://localhost:9090](http://localhost:9090)可用，Grafana在http://localhost:3000。虽然Prometheus不需要登录，但Grafana的默认用户是`admin`，密码必须从Kubernetes机密中提取，如下所示：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Copy the string returned by the preceding command; we need to Base64-decode
    it to get the actual password. As usual, Base64-decoding can be performed by opening
    a Linux console and using the `base64` command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 复制前一个命令返回的字符串；我们需要将其Base64解码以获取实际密码。通常，Base64解码可以通过打开Linux控制台并使用`base64`命令来完成：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once logged in to Grafana, we must declare Prometheus as its metrics data source.
    In the Grafana left menu, go to **Connections -> Data sources**, and then select
    **Add new data source**. In the page that appears, select **Prometheus**, as shown
    in the following figure:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到Grafana后，我们必须声明Prometheus为其指标数据源。在Grafana左侧菜单中，转到**连接 -> 数据源**，然后选择**添加新数据源**。在出现的页面上，选择**Prometheus**，如图下所示：
- en: '![Figure 9.7: Selecting Prometheus as the data source](img/B31916_09_7.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7：选择Prometheus作为数据源](img/B31916_09_7.png)'
- en: 'Figure 9.7: Selecting Prometheus as the data source'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7：选择Prometheus作为数据源
- en: 'We need to configure Prometheus as the default data source and set the URL
    at which to retrieve all metrics to [http://prometheus-server:80](http://prometheus-server:80),
    which corresponds to the address and port of the same Prometheus service we have
    port-forwarded, as shown here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将Prometheus配置为默认数据源，并将检索所有指标的URL设置为[http://prometheus-server:80](http://prometheus-server:80)，这对应于我们已端口转发的相同Prometheus服务的地址和端口，如图所示：
- en: '![Figure 9.8: Prometheus settings](img/B31916_09_8.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图9.8：Prometheus设置](img/B31916_09_8.png)'
- en: 'Figure 9.8: Prometheus settings'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8：Prometheus设置
- en: You can keep all the other default settings; just click the **Save and test**
    button. After that, click the **Dashboards** tab and import all proposed dashboards.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以保留所有其他默认设置；只需点击**保存并测试**按钮。之后，点击**仪表板**选项卡并导入所有建议的仪表板。
- en: 'Then, go to **Dashboards** in the Grafana left menu and inspect all the imported
    dashboards by clicking their links:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，转到Grafana左侧菜单中的**仪表板**并点击链接检查所有导入的仪表板：
- en: '![Figure 9.9: Available dashboards](img/B31916_09_9.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图9.9：可用的仪表板](img/B31916_09_9.png)'
- en: 'Figure 9.9: Available dashboards'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9：可用的仪表板
- en: 'If you click **new** and then **import**, you can import a dashboard from grafana.com.
    Just follow the `grafana.com/dashboards` link, select a dashboard, take its ID,
    and copy it, as shown here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击 **新建** 然后点击 **导入**，你可以从 grafana.com 导入仪表板。只需遵循 `grafana.com/dashboards`
    链接，选择一个仪表板，获取其 ID，并复制它，如下所示：
- en: '![Figure 9.10: Importing a dashboard from grafana.com](img/B31916_09_10.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.10：从 grafana.com 导入仪表板](img/B31916_09_10.png)'
- en: 'Figure 9.10: Importing a dashboard from grafana.com'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10：从 grafana.com 导入仪表板
- en: You might be required to subscribe to get a dashboard ID. Subscription is free.
    The dashboard selection pages contain links to the documentation you might be
    interested in exploring.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要订阅以获取仪表板 ID。订阅是免费的。仪表板选择页面包含你可能感兴趣的文档链接。
- en: 'If you stop minikube with `minikube stop -p <profle name>`, minikube will be
    stopped but all your data will be saved, so you can continue experimenting with
    Grafana. If you want to uninstall Grafana and Prometheus, you can do it with Helm,
    as shown here:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `minikube stop -p <profle name>` 停止 minikube，minikube 将会停止，但所有数据都将被保存，因此你可以继续使用
    Grafana 进行实验。如果你想卸载 Grafana 和 Prometheus，你可以使用 Helm 来完成，如下所示：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let’s close this section with the remaining tools.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以剩余的工具结束本节。
- en: Development environments based on Kubernetes
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于 Kubernetes 的开发环境
- en: Among the complete development platforms based on Kubernetes, it is worth mentioning
    **OpenShift** ([https://www.redhat.com/en/technologies/cloud-computing/openshift](https://www.redhat.com/en/technologies/cloud-computing/openshift)),
    which includes tools for the whole development process, including DevOps automation
    and cloud services.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 Kubernetes 的完整开发平台中，值得提及的是 **OpenShift** ([https://www.redhat.com/en/technologies/cloud-computing/openshift](https://www.redhat.com/en/technologies/cloud-computing/openshift))，它包括整个开发过程所需的工具，包括
    DevOps 自动化和云服务。
- en: OpenShift can be installed on-premises or it can be used as a PaaS service available
    in the main cloud services, Azure included ([https://azure.microsoft.com/it-it/products/openshift](https://azure.microsoft.com/it-it/products/openshift)).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 可以安装在本地，也可以作为主云服务（包括 Azure）中可用的 PaaS 服务使用 ([https://azure.microsoft.com/it-it/products/openshift](https://azure.microsoft.com/it-it/products/openshift))。
- en: Big data and machine learning frameworks use Kubernetes, but we will not discuss
    them since they are completely beyond the purpose of this book.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 大数据和机器学习框架使用 Kubernetes，但我们将不会讨论它们，因为它们完全超出了本书的目的。
- en: It is also worth mentioning simple code generators offered by some start-ups
    that create Kubernetes applications by combining containers with the help of graphic
    interfaces. Needless to say, similar tools are just aimed at creating low-cost
    applications. We will not describe them because the focus of the book is enterprise
    high-quality applications and, at the moment, there is neither an emerging general
    pattern nor an emerging specific framework.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得一提的是一些初创公司提供的简单代码生成器，它们通过图形界面将容器与 Kubernetes 应用程序结合来创建应用程序。不用说，类似的工具只是针对创建低成本应用程序的。我们不会描述它们，因为本书的重点是企业级高质量应用程序，目前既没有出现普遍的模式，也没有出现特定的框架。
- en: Instead, when it comes to higher-level abstraction alternatives to Kubernetes
    that are built on top of Kubernetes, at the time this book was written, the most
    relevant option is **Azure Container Apps,** which will be described in the remainder
    of the chapter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当涉及到基于 Kubernetes 的高级抽象替代方案时，在本书编写时，最相关的选项是 **Azure Container Apps**，本章的剩余部分将对其进行描述。
- en: Azure Container Apps basics and plans
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure Container Apps 基本和计划
- en: Azure Container Apps is available as a serverless offering with **consumption**
    plans but has also **dedicated** plans based on the horizontal scaling of virtual
    machines, called **workload profiles**. Some advanced features are available only
    with **workload profiles**. We will talk more about plans later on in this section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Container Apps 以无服务器产品形式提供，有 **消费** 计划，但也提供基于虚拟机水平扩展的 **专用** 计划，称为 **工作负载配置文件**。一些高级功能仅适用于
    **工作负载配置文件**。我们将在本节稍后详细讨论计划。
- en: 'While Kubernetes offers several kinds of independent building blocks, Azure
    Container Apps is based on just two kinds of building blocks: **applications/jobs**
    and **environments**.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Kubernetes 提供了多种独立的构建块，但 Azure Container Apps 仅基于两种类型的构建块：**应用程序/作业**和**环境**。
- en: Applications map one-to-one with microservices, while jobs are useful for long-running
    tasks and will not be discussed in this chapter.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序与微服务一一对应，而作业对于长时间运行的任务很有用，本章节将不会对其进行讨论。
- en: 'Applications automatically handle replicas—that is, each application may have
    several identical replicas exactly like a Kubernetes Deployment. Applications
    support the same configuration options as Kubernetes Deployments, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序自动处理副本——也就是说，每个应用程序可能有几个完全相同的副本，就像Kubernetes Deployment一样。应用程序支持与Kubernetes
    Deployments相同的配置选项，如下所示：
- en: Environment variables
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量
- en: Volume mounts
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 体积增加
- en: Health probes
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 健康检查
- en: CPU and memory resources configuration
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU和内存资源配置
- en: Automatic log collection
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动日志收集
- en: They also support communication configuration, secrets, and automatic scaling,
    but they are not defined as separate objects as in Kubernetes but inside the application
    configuration itself. Moreover, there is no equivalent of StatefulSets—that is,
    there is no way to implement sharding algorithms.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也支持通信配置、密钥和自动扩展，但它们不是作为单独的对象定义，而是在应用程序配置内部。此外，没有StatefulSets的等效物——也就是说，没有实现分片算法的方法。
- en: The rationale behind these choices is that the developer must map each microservice
    into a single resource instead of several coordinated resources, so they can concentrate
    mainly on business business logic without being overwhelmed by orchestrator-specific
    configuration.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选择背后的逻辑是，开发者必须将每个微服务映射到单个资源，而不是几个协调资源，这样他们就可以主要集中精力在业务逻辑上，而不会被编排特定的配置所淹没。
- en: Coordination tools such as StatefulSets are simply omitted since they don’t
    include business logic but are just used for solving coordination and parallel
    update issues. In fact, StatefulSets are used mainly to implement tools such as
    storage engines and message brokers, so the basic idea is that the developer should
    use resources already available in the cloud instead of implementing customized
    solutions so they can concentrate all their efforts on the business logic.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 像StatefulSets这样的协调工具被简单地省略了，因为它们不包括业务逻辑，只是用于解决协调和并行更新问题。实际上，StatefulSets主要用于实现存储引擎和消息代理等工具，所以基本思想是开发者应该使用云中已有的资源，而不是实现定制化解决方案，这样他们就可以将所有精力集中在业务逻辑上。
- en: Other resources, such as permissions, users, and roles, are taken from Azure,
    too. This way, your microservice application is smoothly integrated into the hosting
    cloud instead of being a self-contained deployment environment loosely coupled
    with the hosting cloud, such as Kubernetes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 其他资源，如权限、用户和角色，也来自Azure。这样，您的微服务应用程序可以顺利地集成到托管云中，而不是成为一个与托管云松散耦合的自包含部署环境，例如Kubernetes。
- en: Summing up, we can say that Azure Container Apps simplifies the implementation
    of a microservice application at the price of decreasing its portability. Once
    you implement your application to run in Azure Container Apps and to use Azure
    cloud resources, the only option to migrate to another cloud is to rewrite the
    whole orchestrator-related code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们可以这样说，Azure Container Apps以降低其可移植性的代价简化了微服务应用程序的实现。一旦您将应用程序实现为在Azure
    Container Apps中运行并使用Azure云资源，迁移到另一个云的唯一选项就是重写整个编排相关代码。
- en: Needless to say, if containers are carefully designed, they are not lost in
    the case of migrations, but the whole logic around them is lost.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，如果容器被精心设计，在迁移的情况下它们不会丢失，但围绕它们的整个逻辑会丢失。
- en: This is not a big issue if your application is small and consists of a few microservices,
    but for big applications made of hundreds or thousands of microservices, a migration
    might imply an unacceptable cost both in terms of time and money.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序很小，只包含几个微服务，这并不是一个大问题，但对于由数百或数千个微服务组成的大型应用程序，迁移可能意味着在时间和金钱方面都不可接受的成本。
- en: Therefore, Azure Container Apps is a good option for small applications or when
    you plan to deploy your application on a single cloud (Azure) and when you don’t
    need too many customizations (custom tools, highly customized tools, complex custom
    distributed algorithms, and so on). This makes it a good entry point in the world
    of distributed computing when you start the conversion of a monolithic application.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Azure Container Apps对于小型应用程序或当您计划在单个云（Azure）上部署应用程序且不需要太多定制（定制工具、高度定制的工具、复杂的定制分布式算法等）时是一个不错的选择。这使得它成为您开始将单体应用程序转换为分布式计算世界时的一个良好切入点。
- en: The boundaries of a microservice application are defined by an **environment**.
    Inside each environment, all applications can freely interact, but you can also
    decide to expose some endpoints to the **outside world**. If you use a consumption
    plan, the outside world is necessarily the internet, but with workload profiles,
    you can bypass this limitation by associating a subnet of an existing Azure virtual
    network to your environment. In fact, in this case, the outside world would be
    the remainder of the virtual network.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应用程序的边界由一个**环境**定义。在每一个环境中，所有应用程序都可以自由交互，但你也可以决定将一些端点暴露给**外部世界**。如果你使用消费计划，外部世界必然是互联网，但使用工作负载配置文件时，你可以通过将现有Azure虚拟网络的子网关联到你的环境来绕过这种限制。实际上，在这种情况下，外部世界将是虚拟网络的其余部分。
- en: There is no equivalent of Kubernetes ingresses for routing communications from
    a single environment entry point to all frontend microservices inside the environment,
    but you can implement a similar functionality by using an application as an API
    gateway (see the *Interfacing the external world* subsection of [*Chapter 2*](Chapter_2.xhtml#_idTextAnchor038),
    *Demystifying Microservices Applications*). For HTTP and HTTPS termination, you
    can configure any application for using HTTPS without the burden of creating and
    handling HTTPS certificates, since Azure will take care of this for you.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从单个环境入口点路由通信到环境内部所有前端微服务的Kubernetes入口等价物不存在，但你可以通过使用应用程序作为API网关来实现类似的功能（参见[*第2章*](Chapter_2.xhtml#_idTextAnchor038)，*揭秘微服务应用程序*）。对于HTTP和HTTPS终止，你可以配置任何应用程序使用HTTPS，而无需创建和处理HTTPS证书，因为Azure会为你处理这些。
- en: 'The following figure illustrates what we said about applications and environments:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了我们关于应用程序和环境的说法：
- en: '![Figure 9.11: Azure Container Apps organization](img/B31916_09_11.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图9.11：Azure Container Apps组织](img/B31916_09_11.png)'
- en: 'Figure 9.11: Azure Container Apps organization'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11：Azure Container Apps组织
- en: 'Take note of the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下事项：
- en: Each environment can be defined as either consumption only or a workload profile.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个环境可以定义为仅消费或工作负载配置文件。
- en: Each environment can have profiles added to it. Consumption-only environments
    can only have the default consumption profile. Workload profile environments have
    the default consumption profile but can also have customizable workload profiles
    added. Profiles will be discussed more later on in this section.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个环境都可以添加配置文件。仅消费环境只能有默认消费配置文件。工作负载配置文件环境有默认消费配置文件，但也可以添加可定制的 workload 配置文件。配置文件将在本节稍后进行讨论。
- en: Each application associated with the environment can specify which of the profiles
    associated with the environment to run on.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与环境关联的每个应用程序都可以指定在环境中运行哪个与该环境关联的配置文件。
- en: Each application is accessible with an `http://<application name>` URL from
    inside the environment. We can also decide that an application is not accessible
    with a direct link when we use a message broker.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个应用程序都可以通过`http://<application name>` URL从环境中访问。我们还可以决定在消息代理中使用时，应用程序不通过直接链接访问。
- en: Some applications can be configured for access from outside of the environment,
    in which case, they receive the `https://<application name>.<environment name>.<zone>.azurecontainerapps.io`
    URL. Here, `<zone>` is the Azure geographic zone where you defined your environment.
    *HTTP traffic must be passed on the usual 80 and 443 ports*. For pure TCP traffic,
    the developer can specify different ports.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些应用程序可以配置为从环境外部访问，在这种情况下，它们将接收`https://<application name>.<environment name>.<zone>.azurecontainerapps.io`
    URL。在这里，`<zone>`是你定义环境所在的Azure地理区域。*HTTP流量必须通过常规的80和443端口转发*。对于纯TCP流量，开发者可以指定不同的端口。
- en: Each environment has an associated virtual network. Only if the environment
    has a workload profile can you assign it a custom subnet of a virtual network.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个环境都关联一个虚拟网络。只有当环境有一个工作负载配置文件时，你才能为其分配虚拟网络的自定义子网。
- en: Environments and applications can access any Azure resources if they are granted
    the necessary permissions or credentials.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果授予了必要的权限或凭据，环境和应用程序可以访问任何Azure资源。
- en: 'The remainder of this section is organized into subsections that describe the
    following subjects:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的其余部分组织成子节，描述以下主题：
- en: Consumption-only and workload profiles
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅消费和工作负载配置文件
- en: Application versioning
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序版本控制
- en: Interacting with Azure Container Apps
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与Azure Container Apps交互
- en: Consumption-only and workload profiles
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅消费和工作负载配置文件
- en: 'Applications running in a consumption profile are billed as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在消耗型配置文件中运行的应用程序的计费方式如下：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In a few words, the application is billed proportionally to its memory, CPU,
    and request consumption. The actual constants for the various countries are available
    here: [https://azure.microsoft.com/en-us/pricing/details/container-apps/.](https://azure.microsoft.com/en-us/pricing/details/container-apps/.
    )'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，应用程序的计费是按其内存、CPU和请求消耗的比例进行的。各种国家的实际常数可以在以下链接中找到：[https://azure.microsoft.com/en-us/pricing/details/container-apps/](https://azure.microsoft.com/en-us/pricing/details/container-apps/)。
- en: 'With workload profiles, you are billed according to the CPUs and gigabytes
    of each virtual machine in use and not for the CPU and memory allocated to the
    applications. Thus, for instance, notwithstanding you use just 10% of a profile
    virtual machine, you are billed for the overall virtual machine CPU and memory.
    However, for workload profiles, there is no billing quota corresponding to the
    application requests. There is also an hourly profile-handling cost to add to
    the overall cost of each profile. The actual constants for the various countries
    are available here: [https://azure.microsoft.com/en-us/pricing/details/container-apps/.](https://azure.microsoft.com/en-us/pricing/details/container-apps/.
    )'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用作业配置文件时，你将根据使用的每个虚拟机的CPU和GB数计费，而不是根据分配给应用程序的CPU和内存计费。例如，尽管你只使用了配置文件虚拟机的10%，但你仍需为整个虚拟机的CPU和内存付费。然而，对于作业配置文件，没有与应用程序请求相对应的计费配额。还需要将每小时配置文件处理成本添加到每个配置文件的总成本中。各种国家的实际常数可以在以下链接中找到：[https://azure.microsoft.com/en-us/pricing/details/container-apps/](https://azure.microsoft.com/en-us/pricing/details/container-apps/)。
- en: Each profile can be used by several applications, and the number of virtual
    machines allocated to a profile is computed according to the CPU and memory requested
    by all applications that run in that profile. That is, a new virtual machine is
    allocated whenever the total CPU or memory requested by all applications exceeds
    the total CPUs and memory of the already allocated machines.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 每个配置文件都可以被多个应用程序使用，分配给每个配置文件的虚拟机数量是根据在该配置文件中运行的所有应用程序请求的CPU和内存来计算的。也就是说，当所有应用程序请求的总CPU或内存超过已分配机器的总CPU和内存时，就会分配一个新的虚拟机。
- en: Needless to say, one can specify both a maximum number and a minimum number
    of machines allocated to each profile. Since allocating a new virtual machine
    requires time, it is advised to set the minimum number of instances to at least
    1; otherwise, the first requests after a period of inactivity would experience
    unacceptable response times.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，可以为每个配置文件指定最大和最小分配的机器数量。由于分配新的虚拟机需要时间，建议将最小实例数设置为至少1；否则，在一段时间的不活跃之后，第一次请求可能会遇到无法接受的反应时间。
- en: The hourly CPU and memory costs of workload profiles are lower than the ones
    of consumption-only profiles but workload profiles have an hourly management cost.
    Workload profiles become convenient when the average workload exceeds 3–4 CPUs
    with 16 GB of memory. However, certain features are only available with workload
    profiles. For instance, you need a workload profile if you want to customize the
    virtual network underlying your environment by adding firewalls, or by using a
    subnet of another virtual network.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 作业配置文件的每小时CPU和内存成本低于仅消耗型配置文件的，但作业配置文件有每小时的管理成本。当平均负载超过3-4个CPU和16GB内存时，作业配置文件变得方便。然而，某些功能仅适用于作业配置文件。例如，如果你想通过添加防火墙或使用另一个虚拟网络的子网来自定义环境下的虚拟网络，你需要一个作业配置文件。
- en: 'All available workload profile types are listed on this page: [https://learn.microsoft.com/en-us/azure/container-apps/workload-profiles-overview](https://learn.microsoft.com/en-us/azure/container-apps/workload-profiles-overview).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可用的作业配置文件类型都列在此页面上：[https://learn.microsoft.com/en-us/azure/container-apps/workload-profiles-overview](https://learn.microsoft.com/en-us/azure/container-apps/workload-profiles-overview)。
- en: 'Let’s move on to a useful feature of Azure Container Apps: automatic versioning
    support.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探讨Azure Container Apps的一个有用功能：自动版本支持。
- en: Application versioning
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序版本控制
- en: Azure Container Apps automatically versions your applications. Each time you
    modify the containers or scale configuration of your application, a new version
    is automatically created.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Container Apps会自动为你的应用程序进行版本控制。每次你修改应用程序的容器或扩展配置时，都会自动创建一个新的版本。
- en: Each version is given a name and is called a **revision** of the application.
    As a default, only the last revision is active and accessible through the application
    link.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 每个版本都有一个名称，被称为应用程序的 **版本**。默认情况下，只有最后一个版本是活动状态且可以通过应用程序链接访问。
- en: However, any application may be put in **multiple-revision** mode, in which
    case, you may decide manually which revisions are **active** and which revisions
    are connected to the application link.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，任何应用程序都可以设置为 **多版本** 模式，在这种情况下，您可以手动决定哪些版本是 **活动** 的，哪些版本与应用程序链接相关联。
- en: 'If more than one revision is connected to the application link, you must specify
    how to split the traffic between them. If just one revision is attached to the
    application link but there are multiple active revisions, you may reach each active
    revision that is not attached to the application URL through its revision name,
    as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个版本连接到应用程序链接，您必须指定如何在这之间分割流量。如果只有一个版本连接到应用程序链接，但存在多个活动版本，您可以通过以下方式通过版本名称访问每个未连接到应用程序
    URL 的活动版本：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Since revision names are automatically generated and are not user-friendly,
    each revision may be attached with friendly labels that can be used to reach the
    revision with links such as the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于版本名称是自动生成的，且不友好，每个版本都可以附加友好的标签，这些标签可以用于通过以下链接等方式访问版本：
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Azure Container Apps revisions logic enables several deployment models, as
    follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 容器应用版本逻辑支持以下几种部署模型：
- en: '*Staging/production*: The newer revision is not attached to the application
    link but can be reached just through its revision link, so it can be tested in
    staging. As soon as the new revision is approved, it is attached to the application
    link and the previous revision is deactivated.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*预发布/生产*：较新的版本未连接到应用程序链接，但可以通过其版本链接访问，因此可以在预发布中进行测试。一旦新版本获得批准，它将被连接到应用程序链接，而之前的版本将被停用。'
- en: '*New features preview*: The traffic is split among the last two revisions.
    Initially, the new revision is passed a low percentage of the overall traffic,
    so that users can experiment with new features. Then, gradually, the new version
    receives more traffic till it reaches 100%, and the previous version is deactivated.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*新功能预览*：流量在最后两个版本之间分割。最初，新版本只分配到一小部分总体流量，这样用户就可以尝试新功能。然后，逐渐地，新版本接收更多的流量，直到达到
    100%，而之前的版本将被停用。'
- en: During traffic splitting, **session affinity** is enabled, so that if a user
    request is served by a revision, `r`, then all subsequent requests will continue
    being served by the same `r` revision. This way, we avoid users walking randomly
    between the two revisions.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在流量分割过程中，**会话亲和性** 被启用，这样如果用户请求由版本 `r` 服务，那么所有后续请求将继续由相同的 `r` 版本服务。这样，我们避免了用户在两个版本之间随机游走。
- en: Revisions are useful mainly for frontend services, especially if internal communication
    relies on message brokers. Testing a new version of a worker microservice requires
    a completely separate staging environment.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 版本主要用于前端服务，尤其是如果内部通信依赖于消息代理。测试工作微服务的新版本需要一个完全独立的预发布环境。
- en: We will provide more details on the practical usage of revisions at the end
    of the *Deploying your microservice application with Azure Container Apps* section.
    The next subsection explains how to interact with your microservice application
    in Azure Container Apps.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *使用 Azure 容器应用部署您的微服务应用程序* 部分的末尾提供关于版本实际使用的更多详细信息。下一小节将解释如何在 Azure 容器应用中与您的微服务应用程序交互。
- en: Interacting with Azure Container Apps
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 Azure 容器应用交互
- en: There is no equivalent of kubectl to interact with Azure Container Apps environments
    and applications. You may interact with them either through the Azure portal or
    with **Azure CLI**.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure 容器应用环境中与应用程序交互没有与 kubectl 等效的工具。您可以通过 Azure 门户或使用 **Azure CLI** 来与它们交互。
- en: Application and environment settings can be specified either with command options
    or through `.yaml` or JSON files. We will focus just on command options and `.yaml`
    files, describing just the most practical alternatives.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序和环境设置可以通过命令选项或 `.yaml` 或 JSON 文件来指定。我们将专注于命令选项和 `.yaml` 文件，仅描述最实用的选项。
- en: 'The interaction with Azure Containers Apps requires the installation of the
    **containerapp Azure CLI** extension. You can install it with the following command
    after you have logged in with `az login`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Azure 容器应用交互需要安装 **containerapp Azure CLI** 扩展。在您使用 `az login` 登录后，可以使用以下命令进行安装：
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first `upgrade` command ensures you have the latest Azure CLI version, while
    the `upgrade` option in the second command updates the extension to the latest
    version. The preceding commands are needed only once, or each time you would like
    to update to a new version.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`upgrade`命令确保您拥有最新的Azure CLI版本，而第二个命令中的`upgrade`选项将扩展更新到最新版本。前面的命令只需要执行一次，或者每次您想要更新到新版本时。
- en: 'Before starting any new session, you must register a couple of namespaces.
    Namespaces registration has the same semantics as C# `using` statements. Here
    are the required registration commands:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始任何新的会话之前，您必须注册几个命名空间。命名空间注册与C#中的`using`语句具有相同的语义。以下是所需的注册命令：
- en: '[PRE28]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, we are ready to interact with Azure Container Apps. The next section explains
    in detail how to deploy and configure your microservice application on Azure Container
    Apps.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好与Azure Container Apps进行交互。下一节将详细解释如何在Azure Container Apps上部署和配置您的微服务应用程序。
- en: Deploying your microservice application with Azure Container Apps
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Azure Container Apps部署您的微服务应用程序
- en: In this section, we will see how to define and configure your applications in
    Azure Container Apps. In the first subsection, we will describe the basic commands
    and operativity, while all configuration options and the `.yaml` file configuration
    formats will be described in a later subsection.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何在Azure Container Apps中定义和配置您的应用程序。在第一个子节中，我们将描述基本命令和操作性，而所有配置选项和`.yaml`文件配置格式将在后面的子节中描述。
- en: Basic commands and operativity
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本命令和操作性
- en: All Azure Container Apps commands start with `az containerapp`. Then, there
    is the main command and various configuration options. Configuration options may
    be passed each with a different command option or organized in a `.yaml` or JSON
    file.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Azure Container Apps命令都以`az containerapp`开头。然后是主要命令和各种配置选项。配置选项可以通过不同的命令选项传递，或者组织在`.yaml`或JSON文件中。
- en: In a PowerShell console, you can split a command into several lines with the
    help of the ` (backquote) character, as shown in all the commands in this subsection.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在PowerShell控制台中，您可以使用反引号字符（`）将命令拆分为多行，就像本节中所有命令所示。
- en: 'The `up` command is the simplest way to define an application together with
    a new environment. It is useful to perform a quick test of a container. The only
    obligatory parameters are the application name and the container image URL. For
    all other options, reasonable defaults are assumed. If you don’t specify a resource
    group and an environment, the command creates new ones:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`up`命令是定义应用程序和新的环境的最简单方法。这对于快速测试容器很有用。唯一必需的参数是应用程序名称和容器镜像URL。对于所有其他选项，将假定合理的默认值。如果您没有指定资源组和环境，则命令将创建新的：'
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let’s break this down:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下：
- en: '`name` is the application name. It is obligatory.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`是应用程序名称。这是必需的。'
- en: '`image` is the container image URL. It is obligatory. As usual, the `image`
    tag is used for image versioning, and if omitted, `latest` is assumed.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image`是容器镜像URL。这是必需的。通常，`image`标签用于镜像版本控制，如果省略，则默认为`latest`。'
- en: '`ingress` may be `internal` or `external`. In the first case, the application
    will be accessible only from inside its environment, while in the second case,
    the application will be exposed to the external world. If this parameter is omitted,
    the application will not be accessible with a direct link (useful when internal
    communication relies on a message broker).'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ingress`可以是`internal`或`external`。在前一种情况下，应用程序只能从其环境中访问，而在第二种情况下，应用程序将暴露给外部世界。如果省略此参数，则应用程序将无法通过直接链接访问（当内部通信依赖于消息代理时很有用）。'
- en: '`target-port` specifies the target port exposed by the container, if any. The
    application traffic will be redirected to this container port. If there are several
    containers, there should be just one that receives the application traffic, and
    you must specify its port. Application HTTP/S traffic must be sent to the usual
    `80` and `443` ports.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target-port`指定容器暴露的目标端口（如果有）。应用程序流量将被重定向到这个容器端口。如果有多个容器，应该只有一个接收应用程序流量，并且您必须指定其端口。应用程序HTTP/S流量必须发送到常规的`80`和`443`端口。'
- en: '`registry-server`, `registry-username`, and `registry-password` are parameters
    that specify the credentials associated with a specific image registry server,
    which should be the same as used in the `image` parameter. If specified, these
    parameters are added to the application configuration and will be used also in
    subsequent application updates. Later on, we will see how assigning an Azure identity
    to an application allows it to access Azure resources by simply granting adequate
    privileges to this identity with no need to provide passwords.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registry-server`、`registry-username`和`registry-password`是参数，用于指定与特定镜像注册表服务器关联的凭据，这些凭据应与`image`参数中使用的相同。如果指定了这些参数，它们将被添加到应用程序配置中，并在后续的应用程序更新中使用。稍后，我们将看到如何将Azure身份分配给应用程序，允许它通过仅授予足够的权限给此身份而无需提供密码来访问Azure资源。'
- en: The preexisting environment and resource group can be specified with the `--environment`
    and `--resource-group` options.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`--environment`和`--resource-group`选项指定现有的环境和资源组。
- en: The `up` commands can be used to update the application configuration or the
    application container image, but in this case, you must always pass the `--name`,
    `--environment`, and `--resource-group` parameters with the values of the preexisting
    application.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`up`命令可以用来更新应用程序配置或应用程序容器镜像，但在此情况下，你必须始终使用现有应用程序的值传递`--name`、`--environment`和`--resource-group`参数。'
- en: 'You can test the `up` command with the simple `gcr.io/google-samples/hello-app:1.0`
    image we used in the *Testing ingresses with minikube* subsection of[*Chapter
    8*](Chapter_8.xhtml#_idTextAnchor205), *Practical Microservices Organization with
    Kubernetes*. You don’t need to specify registry credentials since the registry
    is public. The container port is `8080`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用我们在[*第8章*](Chapter_8.xhtml#_idTextAnchor205)的*使用minikube测试入口*小节中使用的简单`gcr.io/google-samples/hello-app:1.0`镜像来测试`up`命令。由于仓库是公开的，你不需要指定注册表凭据。容器端口是`8080`：
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We previously created a resource group in order to decide its name. We also
    specified the name of the environment to create. The `--query properties.configuration.ingress.fqdn`
    option lets the command return the application URL, which you might also compute
    manually with the URL format we gave in the previous section. Once you have tested
    this simple single HTML page application by going to the application URL with
    your favorite browser, you can also check all Azure resources created on your
    Azure portal home page.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前创建了一个资源组来决定其名称。我们还指定了要创建的环境的名称。`--query properties.configuration.ingress.fqdn`选项允许命令返回应用程序URL，你也可以使用我们在上一节中给出的URL格式手动计算。一旦通过你喜欢的浏览器访问应用程序URL测试了这个简单的单页HTML应用程序，你还可以检查在Azure门户主页上创建的所有Azure资源。
- en: 'You can get the whole `.yaml` configuration of the application created with
    the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令获取应用程序创建的整个`.yaml`配置：
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'A good way to arrive at a properly configured application is by starting with
    default configurations, then getting the `.yaml` application configuration with
    the preceding command, modifying this `.yaml` file, and finally, submitting the
    modified `.yaml` file with the `update` command, as shown here:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的方法是先从默认配置开始，然后使用前面的命令获取`.yaml`应用程序配置，修改这个`.yaml`文件，最后，使用`update`命令提交修改后的`.yaml`文件，如下所示：
- en: '[PRE32]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Each application is univocally identified by both its name and its resource
    group, so each `update` or `delete` command must specify both of them.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都通过其名称和资源组唯一标识，因此每个`update`或`delete`命令都必须指定这两个信息。
- en: 'The simplest way to clean up all resources after the experiment is by deleting
    the whole resource group, as shown here:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 清理实验后所有资源的最简单方法是通过删除整个资源组，如下所示：
- en: '[PRE33]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When you need to deploy several applications in the same environment, the best
    way to proceed is to create the environment first with the following command:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要在同一环境中部署多个应用程序时，最好的做法是首先使用以下命令创建环境：
- en: '[PRE34]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you would like to enable workload profiles on the environment, you must also
    add the `--enable-workload-profiles` option.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在该环境中启用工作负载配置文件，你还必须添加`--enable-workload-profiles`选项。
- en: 'If you want to place all resources involved in your overall microservice application
    in a new resource group. you need to create it before creating the environment,
    as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望将你整个微服务应用程序中涉及的所有资源放置在一个新的资源组中，你需要在创建环境之前创建它，如下所示：
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Workload profiles can be added to an environment with the following instruction:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下指令将工作负载配置文件添加到环境中：
- en: '[PRE36]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, `--workload-profile-name` is the name you give to the workload profile,
    while `--workload-profile-type` is a profile type—that is, a type of virtual machine
    that you can select from the ones listed here: [https://learn.microsoft.com/en-us/azure/container-apps/workload-profiles-overview](https://learn.microsoft.com/en-us/azure/container-apps/workload-profiles-overview).
    `--min-nodes` and `--max-nodes` are, respectively, the minimum and maximum instances
    of the virtual machine that can be created.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`--workload-profile-name` 是您为工作负载配置文件指定的名称，而 `--workload-profile-type` 是配置文件类型——即您可以从以下列表中选择的一种虚拟机类型：[https://learn.microsoft.com/en-us/azure/container-apps/workload-profiles-overview](https://learn.microsoft.com/en-us/azure/container-apps/workload-profiles-overview)。`--min-nodes`
    和 `--max-nodes` 分别是可创建的虚拟机的最小和最大实例数。
- en: 'Workload profiles can also be removed at a later time with the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在稍后使用以下命令删除工作负载配置文件：
- en: '[PRE37]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When the environment is set up, you can deploy all container images in a common
    registry, and then you can start creating each application with the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当环境设置完成后，您可以在公共注册表中部署所有容器镜像，然后您可以使用以下命令开始创建每个应用程序：
- en: '[PRE38]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding command creates an application with a default configuration. If
    you want the application to run in a workload profile instead of the default consumption
    profile, you must add the `--workload-profile-name <WORKLOAD_PROFILE_NAME>` option.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令使用默认配置创建应用程序。如果您希望应用程序在工作负载配置文件中而不是默认消费配置文件中运行，您必须添加 `--workload-profile-name
    <WORKLOAD_PROFILE_NAME>` 选项。
- en: 'Then, you can extract its `.yaml` and modify it with the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用以下命令提取其 `.yaml` 文件并进行修改：
- en: '[PRE39]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You will need to use the preceding code with this code, too:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要使用前面的代码与以下代码一起使用：
- en: '[PRE40]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can also opt in for immediately specifying a `.yaml` file during the application
    creation, as shown here:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在创建应用程序时立即指定 `.yaml` 文件，如下所示：
- en: '[PRE41]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can get the list of all application revisions with the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令获取所有应用程序修订版本的列表：
- en: '[PRE42]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can get also all replicas of each revision with the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令获取每个修订版本的每个副本：
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can also get an interactive console in a container of a specific replica
    of a specific revision, similar to how Kubernetes `exec` works:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在特定修订版本的特定副本的容器中获得交互式控制台，类似于 Kubernetes 的 `exec` 命令：
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If there are several containers, you can specify the container name with the
    `--container` option.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个容器，您可以使用 `--container` 选项指定容器名称。
- en: 'You can delete an application with the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令删除应用程序：
- en: '[PRE45]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can delete a whole environment and all the applications it contains with
    the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令删除整个环境和其中包含的所有应用程序：
- en: '[PRE46]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: These commands cover most of the practical use cases. Other options and commands
    can be found in the official command reference at [https://learn.microsoft.com/it-it/cli/azure/containerapp?view=azure-cli-latest](https://learn.microsoft.com/it-it/cli/azure/containerapp?view=azure-cli-latest).
    In the next subsection, we will describe how to configure your application with
    a `.yaml` file.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令涵盖了大多数实际使用场景。其他选项和命令可以在官方命令参考中找到，链接为[https://learn.microsoft.com/it-it/cli/azure/containerapp?view=azure-cli-latest](https://learn.microsoft.com/it-it/cli/azure/containerapp?view=azure-cli-latest)。在下一小节中，我们将描述如何使用
    `.yaml` 文件配置您的应用程序。
- en: Application configuration options and the .yaml format
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序配置选项和 .yaml 格式
- en: 'The simplest way to customize the application configuration is with a `.yaml`
    file passed to the following command:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 修改应用程序配置的最简单方法是使用传递给以下命令的 `.yaml` 文件：
- en: '[PRE47]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The organization of an application `.yaml` file is shown here:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序 `.yaml` 文件的组织结构如下所示：
- en: '[PRE48]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let’s break this down:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下：
- en: The `identity` section is present only if the application has been attached
    to an Azure identity for handling its access to other resources without passwords.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当应用程序已连接到 Azure 身份以处理其无密码访问其他资源时，`identity` 部分才会存在。
- en: '`environmentId` is the Azure unique ID of the environment the application is
    in (don’t confuse it with the environment name). The simplest way to get this
    and other values is by creating an application with default values and then showing
    its `.yaml` file.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environmentId` 是应用程序所在环境的 Azure 唯一标识符（不要将其与环境名称混淆）。获取此和其他值的最简单方法是创建具有默认值的应用程序，然后显示其
    `.yaml` 文件。'
- en: '`workloadProfileName` is present only if the application is associated with
    a workload profile and contains the workload profile name.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`workloadProfileName` 仅在应用程序与工作负载配置文件相关联时存在，并包含工作负载配置文件名称。'
- en: The `ingress` section is present only if the application must be accessible
    with a direct link from inside or outside its environment. It contains all its
    direct communication-related properties, CORS settings, and traffic splitting
    between versions.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ingress` 部分仅在应用程序必须通过直接链接从其环境内部或外部访问时存在。它包含所有直接通信相关的属性、CORS 设置以及版本之间的流量分割。'
- en: '`maxInactiveRevisions` is the number of previous revisions that are saved and
    can be activated. The default is 100.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxInactiveRevisions` 表示保存并可激活的先前修订次数。默认值为 100。'
- en: The `registries` section contains information about registries that must be
    accessed with credentials. Registries that are not private and don’t need credentials
    should not be listed here. Each entry specifies either the registry username and
    password or an Azure identity with permission to access the registry. The identity
    must be listed in the i`dentity` section. For more details, see the *Associating
    an Azure identity to your application* section.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registries` 部分包含有关必须使用凭据访问的注册表的信息。不需要凭据且不是私有的注册表不应在此列出。每个条目指定注册表的用户名和密码或具有访问注册表权限的
    Azure 身份。该身份必须在 `identity` 部分中列出。有关更多详细信息，请参阅 *将 Azure 身份关联到您的应用程序* 部分。'
- en: '`secrets` are name-value pairs that are stored safely. They are equivalent
    to Kubernetes generic secrets.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secrets` 是存储在安全位置中的名称-值对。它们相当于 Kubernetes 通用密钥。'
- en: As in Kubernetes, we have `containers` and `initContainers`. `initContainers`
    work the same as in Kubernetes, but there is no way to declare `sidecar` containers,
    so `sidecar` containers must be included among the standard containers.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Kubernetes 一样，我们有 `containers` 和 `initContainers`。`initContainers` 的工作方式与
    Kubernetes 中相同，但无法声明 `sidecar` 容器，因此 `sidecar` 容器必须包含在标准容器中。
- en: 'The `scale` section contains the minimum and maximum number of application
    replicas and rules for deciding the exact number of replicas. The most common
    rules decide the number of replicas trying to maintain a target number of HTTP
    requests or TCP/IP connections per replica:'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scale` 部分包含应用程序副本的最小和最大数量以及决定确切副本数量的规则。最常见的规则是尝试维持每个副本的目标 HTTP 请求或 TCP/IP
    连接数：'
- en: '[PRE49]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Finally, we have a `volumes` section that declares all volumes mounted by containers.
    As in Kubernetes, they are referred to by a `volumeMounts` section inside the
    container definitions.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有一个 `volumes` 部分声明了容器挂载的所有卷。与 Kubernetes 一样，它们在容器定义中的 `volumeMounts` 部分中引用。
- en: All properties that were not fully specified in the previous `.yaml` file will
    be described in a separate subsection. Let’s start with containers.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 所有在先前的 `.yaml` 文件中没有完全指定的属性将在单独的子部分中描述。让我们从容器开始。
- en: Container configuration
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器配置
- en: 'The configuration of each container is similar to the one in Kubernetes but
    there are some simplifications. The schema is shown here:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 每个容器的配置与 Kubernetes 中的类似，但有一些简化。架构在此处显示：
- en: '[PRE50]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`image` and `name` are identical to the Kubernetes configuration.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`image` 和 `name` 与 Kubernetes 配置相同。'
- en: Environment variables can be defined either as name-value pairs or as `name`-`secretRef`
    pairs, where `secretRef` contains the name of a secret defined in the `secrets`
    section. In the second case, the variable value is the value of the secret.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量可以定义为名称-值对或 `name`-`secretRef` 对，其中 `secretRef` 包含在 `secrets` 部分中定义的密钥的名称。在第二种情况下，变量值是密钥的值。
- en: '`volumeMounts` is similar to Kubernetes, too. The only difference is that the
    volume name is called `name` in Kubernetes while, here, it is called `volumeName`.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`volumeMounts` 也类似于 Kubernetes。唯一的区别是，在 Kubernetes 中，卷名称称为 `name`，而在这里，它被称为
    `volumeName`。'
- en: The Kubernetes `resources` property has two properties, `requests` and `limits`,
    while here we have just a couple of values that correspond to the Kubernetes `requests`
    property. This means that we cannot specify `resources` limits as in Kubernetes.
    The reason behind this choice is probably connected to the serverless nature of
    Azure Container Apps. The meanings and units of measure of both `cpu` and `memory`
    are the same as in Kubernetes.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的 `resources` 属性有两个属性，`requests` 和 `limits`，而在这里，我们只有几个与 Kubernetes
    `requests` 属性相对应的值。这意味着我们无法像 Kubernetes 那样指定 `resources` 限制。这种选择背后的原因可能与 Azure
    Container Apps 的无服务器特性有关。`cpu` 和 `memory` 的含义和度量单位与 Kubernetes 相同。
- en: 'As you can see, liveness, readiness, and startup probes are defined in slightly
    different ways but their meaning is the same as in Kubernetes. The syntax and
    meaning of the properties after `type: liveness/readiness/startup` is identical
    to the corresponding Kubernetes configuration.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '如您所见，活跃性、就绪性和启动探测以略不同的方式定义，但它们的含义与 Kubernetes 中相同。`type: liveness/readiness/startup`
    之后属性的语法和含义与相应的 Kubernetes 配置相同。'
- en: Let’s move on to the `ingress` configuration.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到 `ingress` 配置。
- en: The ingress configuration
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 入口配置
- en: 'The `ingress` configuration mixes some Kubernetes `Service` and `Ingress` settings
    with the traffic splitting between various revisions, as shown here:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`ingress` 配置将一些 Kubernetes `Service` 和 `Ingress` 设置与各种修订版之间的流量分割混合在一起，如下所示：'
- en: '[PRE51]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let’s break this down:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下：
- en: '`external` must be set to `true` to expose the application to the outside world,
    otherwise, to `false`.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`external` 必须设置为 `true` 以将应用程序暴露给外部世界，否则设置为 `false`。'
- en: '`targetPort` is the container port to which to route the application traffic.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`targetPort` 是要路由应用程序流量的容器端口。'
- en: '`exposedPort` must be used only in case of non-HTTP/S traffic. It sets the
    application listening port. All traffic received on this port is routed to `targetPort`.
    The `exposedPort` ports of applications exposed to the outside world must be unique
    inside the environment.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在非 HTTP/S 流量的情况下使用 `exposedPort`。它设置应用程序监听端口。所有接收在此端口的流量都将路由到 `targetPort`。暴露给外部世界的应用程序的
    `exposedPort` 端口必须在环境中是唯一的。
- en: HTTP/S traffic, instead, always uses the usual `80` and `443` ports with no
    customization possibilities.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相反，HTTP/S 流量始终使用常规的 `80` 和 `443` 端口，没有定制可能性。
- en: If `allowInsecure` is `false`, HTTP traffic is automatically redirected to HTTPS.
    The default is `true`.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `allowInsecure` 设置为 `false`，HTTP 流量将自动重定向到 HTTPS。默认值为 `true`。
- en: '`clientCertificateMode` specifies whether TCP/IP client certificates are accepted
    for authentication. This setting is completely analogous to a similar setting
    exposed by Kestrel. If set to `accept`, client certificates are accepted and processed.
    If set to `required`, client certificates are obligatory, and if not provided,
    the connection is refused. If set to `ignore`, client certificates are completely
    ignored.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clientCertificateMode` 指定是否接受 TCP/IP 客户端证书进行身份验证。此设置与 Kestrel 提供的类似设置完全类似。如果设置为
    `accept`，则接受并处理客户端证书。如果设置为 `required`，则客户端证书是必需的，如果没有提供，则拒绝连接。如果设置为 `ignore`，则完全忽略客户端证书。'
- en: '`corsPolicy` contains standard web server CORS settings, which are the same
    as those supported by ASP.NET Core. For completeness, we describe all the CORS
    settings here:'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`corsPolicy` 包含标准的网络服务器 CORS 设置，与 ASP.NET Core 支持的设置相同。为了完整性，我们在这里描述所有 CORS
    设置：'
- en: If `allowCredentials` is set to `false`, CORS requests containing credentials
    are refused. The default is `false`.
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `allowCredentials` 设置为 `false`，则拒绝包含凭证的 CORS 请求。默认值为 `false`。
- en: '`maxAge` specifies the caching time of the pre-flight request. The pre-flight
    request has the only purpose of verifying whether a CORS request will be accepted
    before sending actual data.'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxAge` 指定了预检请求的缓存时间。预检请求的唯一目的是在发送实际数据之前验证 CORS 请求是否会被接受。'
- en: '`allowedOrigins` and `allowedMethods` specify, respectively, the origin domains
    from which to accept CORS requests and the accepted HTTP verbs.'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allowedOrigins` 和 `allowedMethods` 分别指定接受 CORS 请求的源域和接受的 HTTP 动词。'
- en: Regarding `allowedHeaders`, as a default, only some safe `requests` headers
    are allowed. This setting adds further `requests` headers to the ones accepted.
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 `allowedHeaders`，默认情况下，仅允许一些安全的 `requests` 头部。此设置添加了额外的 `requests` 头部到已接受的那些。
- en: Regarding `exposeHeaders`, as a default, only some safe `response` headers are
    exposed in the responses to CORS requests. This setting adds further headers to
    the ones allowed.
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 `exposeHeaders`，默认情况下，仅在某些安全的 `response` 头部中暴露 CORS 请求的响应。此设置添加了额外的头部到允许的那些。
- en: '`traffic` specifies the traffic splitting among various revisions. If a revision
    is listed with a `0` split, it will receive no application traffic but it will
    be set to active—that is, it can be reached with its revision-specific links.
    All labels added to an active revision must be specified here.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`traffic` 指定了各种修订版之间的流量分割。如果一个修订版列出了 `0` 分割，它将不会收到任何应用程序流量，但它将被设置为活动状态——也就是说，可以通过其特定修订版的链接访问它。所有添加到活动修订版的标签都必须在这里指定。'
- en: While revision handling can be done by modifying the `traffic` section, it is
    more practical to handle it with ad hoc commands.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以通过修改 `traffic` 部分来处理修订版处理，但使用临时命令处理它更为实用。
- en: 'The list of all revisions in table format for a given application can be obtained
    with the following command:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令获取给定应用程序的所有修订版的表格列表：
- en: '[PRE52]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Details about a specific revision can be obtained with the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下方式获取特定修订版的详细信息：
- en: '[PRE53]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Labels can be attached or detached from a specific revision with the following
    commands:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令将标签附加或从特定修订版中分离：
- en: '[PRE54]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'An application can be switched from single revision mode to multiple revision
    mode, and vice versa, with the following command:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令将应用程序从单修订版模式切换到多修订版模式，反之亦然：
- en: '[PRE55]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'A given revision can be activated, deactivated, or restarted with the following
    commands:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令激活、停用或重启给定修订版：
- en: '[PRE56]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, traffic splitting between revisions can be changed with the following
    command:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以使用以下命令更改修订版之间的流量分配：
- en: '[PRE57]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The next section focuses on how to define volumes in the `volumes` section.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将重点介绍如何在`volumes`部分中定义卷。
- en: Volume definition and allocation
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 卷定义和分配
- en: 'Volumes can be either `EmptyDir` (which works in the same way as Kubernetes
    `EmptyDir`) or file shares taken from Azure Files, as shown here:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 卷可以是`EmptyDir`（与Kubernetes的`EmptyDir`以相同的方式工作）或从Azure Files获取的文件共享，如下所示：
- en: '[PRE58]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here, `mystorage` is the name of a file share you created and attached to the
    environment. Therefore, you must execute the following steps to get `mystorage`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`mystorage`是您创建并附加到环境的文件共享的名称。因此，您必须执行以下步骤来获取`mystorage`：
- en: 'Define a storage account if you don’t have it:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有，请定义存储帐户：
- en: '[PRE59]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Define a file share:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个文件共享：
- en: '[PRE60]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Get the credentials to access the storage account:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取访问存储帐户的凭据：
- en: '[PRE61]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Add a file share name to the environment:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件共享名称添加到环境中：
- en: '[PRE62]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, you can define the volume in your application using the `--storage-name`
    value passed to the last command, as shown here:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用传递给最后一个命令的`--storage-name`值在您的应用程序中定义卷，如下所示：
- en: '[PRE63]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The next subsection explains how to associate an Azure identity to an application,
    thus enabling it to access Azure resources.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节解释了如何将Azure标识符关联到应用程序，从而使其能够访问Azure资源。
- en: Associating an Azure identity to your application
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Azure标识符关联到您的应用程序
- en: The Azure identity to associate with an application can be automatically generated
    and handled by Azure or can be defined manually. The main advantage of using a
    user-defined identity is that you can add the same identity to several applications.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要与应用程序关联的Azure标识符可以由Azure自动生成和处理，也可以手动定义。使用用户定义的标识符的主要优势是您可以将其添加到多个应用程序中。
- en: 'Adding a system-assigned identity to an application is very easy:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 将系统分配的标识符添加到应用程序中非常简单：
- en: '[PRE64]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The preceding command returns the Azure resource ID of the created identity.
    A system-assigned identity can be associated with the application also by adding
    `type: SystemAssigned` to the `identity` section of the application’s `.yaml`
    file, as shown here:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '前一个命令返回创建的标识符的Azure资源ID。可以通过将`type: SystemAssigned`添加到应用程序的`.yaml`文件中的`identity`部分来将系统分配的标识符与应用程序关联，如下所示：'
- en: '[PRE65]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: A user-defined identity must be created first and then assigned to the application,
    so adding a user-defined identity requires two steps.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的标识符必须首先创建，然后分配给应用程序，因此添加用户定义的标识符需要两个步骤。
- en: 'The identity can be created with the simple command shown here:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下简单命令创建标识符：
- en: '[PRE66]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `--output json` option forces the command to return information about the
    created identity in JSON format. The returned JSON object contains the Azure resource
    ID of the created identity. You need it to associate the identity with your applications
    using the following command:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`--output json`选项强制命令以JSON格式返回有关创建的标识符的信息。返回的JSON对象包含创建的标识符的Azure资源ID。您需要它来使用以下命令将标识符与您的应用程序关联：'
- en: '[PRE67]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The last step can be performed by adding the resource ID of one or more identities
    directly to the `identity` section of the application’s `.yaml` files, as shown
    here:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步可以通过将一个或多个标识符的资源ID直接添加到应用程序的`.yaml`文件中的`identity`部分来完成，如下所示：
- en: '[PRE68]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As an example, let’s see how to enable a created identity to access an Azure
    container registry. This way, we can avoid storing registry credentials in the
    application’s `.yaml` file.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看如何使创建的标识符能够访问Azure容器注册表。这样，我们可以避免在应用程序的`.yaml`文件中存储注册表凭据。
- en: 'First of all, we need the container registry resource ID. We can get it with
    the following command:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要容器注册表资源ID。我们可以使用以下命令获取它：
- en: '[PRE69]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then, we can assign the `AcrPull` role on our container registry to our identity
    with the following command:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下命令在我们的容器注册表中为我们的身份分配 `AcrPull` 角色：
- en: '[PRE70]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Finally, we must inform the application that it can use its system-assigned
    or user-assigned identity to access the registry:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须通知应用程序它可以使用其系统分配或用户分配的身份来访问注册表：
- en: '[PRE71]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The last step can also be performed by adding an entry to the `registries`
    section of the application’s `.yaml` files, as shown here:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步也可以通过向应用程序的 `.yaml` 文件中的 `registries` 部分添加条目来完成，如下所示：
- en: '[PRE72]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We have finished our Azure Container Apps trip. We will return to Azure Container
    Apps in [*Chapter 12*](Chapter_12.xhtml#_idTextAnchor345), *Simplifying Microservices
    with .NET Aspire*, where we will see how to automatically create all instructions
    to deploy a whole microservice application to Azure Container Apps, and we will
    use the book case study application as an example.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了 Azure 容器应用的旅程。我们将在 [*第 12 章*](Chapter_12.xhtml#_idTextAnchor345)，*使用
    .NET Aspire 简化微服务* 中返回 Azure 容器应用，我们将看到如何自动创建所有指令以将整个微服务应用程序部署到 Azure 容器应用，并将使用本书案例研究应用程序作为示例。
- en: Our description of Azure Container Apps is fundamentally complete and covers
    95% of practical Azure Container Apps operativity. More details can be found in
    the official documentation at [https://learn.microsoft.com/en-us/azure/container-apps/](https://learn.microsoft.com/en-us/azure/container-apps/).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 Azure 容器应用的描述是根本性的完整，并涵盖了 95% 的实际 Azure 容器应用操作。更多详细信息可以在官方文档中找到，链接为 [https://learn.microsoft.com/en-us/azure/container-apps/](https://learn.microsoft.com/en-us/azure/container-apps/)。
- en: The next chapter focuses on the security and observability of the microservice
    application.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将重点介绍微服务应用程序的安全性和可观察性。
- en: Summary
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter described Kubernetes-related tools that facilitate the administration
    and coding of distributed applications and then focused on Azure Container Apps.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了与 Kubernetes 相关的工具，这些工具有助于分布式应用程序的管理和编码，然后重点介绍了 Azure 容器应用。
- en: We described the basic ideas behind the Azure Container Apps offering, including
    its fundamental concepts and principles. Then, we described the available plans
    and how to interact with Azure Container Apps through the Azure portal.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述了 Azure 容器应用提供的基本理念，包括其基本概念和原则。然后，我们描述了可用的计划以及如何通过 Azure 门户与 Azure 容器应用交互。
- en: In particular, we described the main commands and the`.yaml` format that defines
    a whole application. We showed how all resources in Kubernetes are implemented
    in Azure Container Apps and compared the two approaches.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是我们描述了主要命令以及定义整个应用的 `.yaml` 格式。我们展示了如何在 Azure 容器应用中实现 Kubernetes 中的所有资源，并比较了两种方法。
- en: Questions
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Is it true that environments are equivalent to Kubernetes namespaces?
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 环境是否等同于 Kubernetes 命名空间？
- en: They are similar but not equivalent.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 它们相似但不等价。
- en: How does Helm simplify the deployment of Kubernetes applications and tools?
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Helm 如何简化 Kubernetes 应用程序和工具的部署？
- en: Because it allows the simultaneous deployment of several yaml files which can
    be configured according to selected options and parameters.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它允许同时部署多个 yaml 文件，这些文件可以根据选定的选项和参数进行配置。
- en: What are Prometheus and Grafana?
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Prometheus 和 Grafana 是什么？
- en: They’re administrative tools that collect metrics, and other information and
    present them to the user.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是管理工具，用于收集指标和其他信息，并将它们呈现给用户。
- en: Can you describe the URL composition of an Azure Container Apps application
    exposed to the external world?
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您能否描述一个暴露给外部世界的 Azure 容器应用 URL 的组成？
- en: '`<application name>.<Environment name>.<zone>.azurecontainerapps.io`'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`<application name>.<Environment name>.<zone>.azurecontainerapps.io`'
- en: Do environments provide access to all properties of their underlying networks?
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 环境是否提供对其底层网络的所有属性的访问？
- en: No.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 不。
- en: Which kinds of Azure identities can be associated with Azure Container Apps?
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些类型的 Azure 身份可以与 Azure 容器应用关联？
- en: User defined and System Assigned.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义和系统分配。
- en: Is it true that, in Azure Container Apps, Azure file storage allocation is automatic
    (as in Kubernetes) and requires just the declaration of volumes in the `volumes`
    section of the application’s `.yaml` file?
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Azure 容器应用中，Azure 文件存储分配是否自动（如 Kubernetes 所示）并且只需要在应用程序 `.yaml` 文件的 `volumes`
    部分声明卷？
- en: No.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 不。
- en: Is it possible to deploy an Azure Container Apps application with a single Azure
    console command without filling in any configuration file?
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否可以使用单个 Azure 控制台命令部署 Azure 容器应用应用程序，而无需填写任何配置文件？
- en: Yes, in several ways.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，有几种方式。
- en: In which section of an Azure Container Apps `.yaml` file can you define traffic
    splitting between revisions?
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Azure Container Apps 的 `.yaml` 文件中，你可以在哪个部分定义修订版之间的流量分割？
- en: '`ingress->traffic`'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`ingress->traffic`'
- en: Can the port where an Azure Container Apps application listens to HTTP/S requests
    be customized?
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Azure Container Apps 应用程序监听 HTTP/S 请求的端口可以自定义吗？
- en: No.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 不。
- en: Further reading
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'More information on Helm and Helm charts can be found in the official documentation.
    This is extremely well written and contains some good tutorials: [https://helm.sh/](https://helm.sh/).'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于 Helm 和 Helm 图表的信息可以在官方文档中找到。这是一篇写得非常好的文章，包含了一些很好的教程：[https://helm.sh/](https://helm.sh/).
- en: 'Grafana dashboards: [https://grafana.com/grafana/dashboards/](https://grafana.com/grafana/dashboards/).'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grafana 仪表板：[https://grafana.com/grafana/dashboards/](https://grafana.com/grafana/dashboards/).
- en: 'ArgoCD: [https://argo-cd.readthedocs.io/en/stable/](https://argo-cd.readthedocs.io/en/stable/)'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ArgoCD：[https://argo-cd.readthedocs.io/en/stable/](https://argo-cd.readthedocs.io/en/stable/)
- en: 'Rancher UI: [https://ranchermanager.docs.rancher.com/](https://ranchermanager.docs.rancher.com/
    )'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rancher UI：[https://ranchermanager.docs.rancher.com/](https://ranchermanager.docs.rancher.com/
    )
- en: 'OpenShift: [https://www.redhat.com/en/technologies/cloud-computing/openshift](https://www.redhat.com/en/technologies/cloud-computing/openshift).'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenShift：[https://www.redhat.com/en/technologies/cloud-computing/openshift](https://www.redhat.com/en/technologies/cloud-computing/openshift).
- en: 'Azure OpenShift: [https://azure.microsoft.com/it-it/products/openshift](https://azure.microsoft.com/it-it/products/openshift).'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure OpenShift：[https://azure.microsoft.com/it-it/products/openshift](https://azure.microsoft.com/it-it/products/openshift).
- en: 'Azure Container Apps pricing: [https://azure.microsoft.com/en-us/pricing/details/container-apps/](https://azure.microsoft.com/en-us/pricing/details/container-apps/).'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Container Apps 定价：[https://azure.microsoft.com/en-us/pricing/details/container-apps/](https://azure.microsoft.com/en-us/pricing/details/container-apps/).
- en: 'Azure Container Apps custom profiles: [https://learn.microsoft.com/en-us/azure/container-apps/workload-profiles-overview](https://learn.microsoft.com/en-us/azure/container-apps/workload-profiles-overview)'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Container Apps 自定义配置文件：[https://learn.microsoft.com/en-us/azure/container-apps/workload-profiles-overview](https://learn.microsoft.com/en-us/azure/container-apps/workload-profiles-overview)
- en: 'Azure Container Apps official documentation: [https://learn.microsoft.com/en-us/azure/container-apps/](https://learn.microsoft.com/en-us/azure/container-apps/).'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Container Apps 官方文档：[https://learn.microsoft.com/en-us/azure/container-apps/](https://learn.microsoft.com/en-us/azure/container-apps/).
- en: 'Azure Container Apps commands reference: [https://learn.microsoft.com/it-it/cli/azure/containerapp?view=azure-cli-latest](https://learn.microsoft.com/it-it/cli/azure/containerapp?view=azure-cli-latest).'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Container Apps 命令参考：[https://learn.microsoft.com/it-it/cli/azure/containerapp?view=azure-cli-latest](https://learn.microsoft.com/it-it/cli/azure/containerapp?view=azure-cli-latest).
- en: Join our community on Discord
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/PSMCSharp](https://packt.link/PSMCSharp)'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/PSMCSharp](https://packt.link/PSMCSharp)'
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/B31916_Discord-QR-Code.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![带有黑色方块的二维码 AI生成的内容可能不正确。](img/B31916_Discord-QR-Code.png)'
