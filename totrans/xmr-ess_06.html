<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. The Sharing Game</h1></div></div></div><p>In this chapter, we will discuss one of the most interesting and important aspects of developing with Xamarin: cross-platform code sharing. We will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The file linking technique</li><li class="listitem" style="list-style-type: disc">Portable Class Libraries</li><li class="listitem" style="list-style-type: disc">The pros and cons of each approach</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Sharing and reuse</h1></div></div></div><p>One of the <a class="indexterm" id="id444"/>advantages of using Xamarin and C# is the ability to share code across your mobile apps as well as other .NET solutions. The reuse of code can provide significant productivity and reliability advantages as well as reduce many of the long-term maintenance headaches that come with long-lived apps. That's great, but anyone who has been involved in software development for a long period of time understands that reuse is not free and not simple to achieve.</p><p>There are practical aspects of reuse; the question is, "Physically, how do I package my code for reuse?" For this, we can use one of the following three methods:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Share source code that can be compiled into multiple projects</li><li class="listitem" style="list-style-type: disc">Share <a class="indexterm" id="id445"/><strong>Dynamic-Link Library</strong> (<strong>DLL</strong>) that can be referenced by multiple projects</li><li class="listitem" style="list-style-type: disc">Share code as a service that can be accessed remotely by multiple clients</li></ul></div><p>There are also more strategic aspects; again the question arises, "How can I organize my code so that I can reuse more of it?" To solve this problem, we have the following options:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Create a layered approach so that data access logic and business validation is separated out of the user interface logic</li><li class="listitem" style="list-style-type: disc">Utilize interfaces and frameworks that abstract platform-specific services away from the reusable layers</li></ul></div><p>In this chapter, we will touch on both these aspects of reuse, but primarily focus on the practical side of reuse. Specifically, we will present two different approaches to bundle up the code for reuse.</p><p>So, what parts of our code should we try and reuse? In the work we have done on the <code class="literal">NationalParks</code> apps so far, one obvious set of code stands out for reuse: the persistence code, which is the logic that loads parks from a JSON file and saves them back to the same file. In <a class="link" href="ch05.html" title="Chapter 5. Developing Your First Android App with Xamarin.Android">Chapter 5</a>, <em>Developing Your First Android App with Xamarin.Android</em>, we moved towards a reusable solution by creating the <code class="literal">NationalParkData</code> singleton. In this chapter, we will demonstrate two <a class="indexterm" id="id446"/>different methods for sharing the <code class="literal">NationalParkData</code> singleton across both our projects as well as other .NET projects that might need it.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec50"/>Old school source file linking</h1></div></div></div><p>File linking refers <a class="indexterm" id="id447"/>to a technique where source code files are linked or referenced by a Xamarin project and are compiled when a build is run on the project along with the rest of the source code in the project. When using file linking, a separate DLL is not created for the files you are sharing, rather the code is compiled into the same DLL produced for the project that the file is linked to; in our case, either <code class="literal">NationalParks.iOS.dll</code> or <code class="literal">NationalParks.Droid.dll</code>.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec61"/>Creating a shared library project</h2></div></div></div><p>We will <a class="indexterm" id="id448"/>start by creating a <a class="indexterm" id="id449"/>new <code class="literal">Library</code> project to house the reusable code. To create a <code class="literal">Library</code> project, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add a new library project with the name <code class="literal">NationalParks.Data</code> to the <code class="literal">NationalParks</code> solution. You can find the <code class="literal">Library</code> project template in the <strong>New Project</strong> dialog box under <strong>C#</strong> | <strong>Library</strong>, as shown in the following screenshot:<div><img alt="Creating a shared library project" src="img/0838OT_06_01.jpg"/></div></li><li class="listitem">Remove <code class="literal">MyClass.cs</code> from the new project. When removing the file, selecting <strong>Delete</strong> will remove the file from being referenced by the project and delete the underlying file from the filesystem.</li><li class="listitem">Set the <strong>Target Framework</strong> option to <strong>Mono/.NET 4.5</strong> in the <strong>Project Options</strong> dialog box under <strong>Build</strong> | <strong>General</strong>.</li><li class="listitem">Move <a class="indexterm" id="id450"/>the <code class="literal">NationalPark.cs</code> and <code class="literal">NationalParkData.cs</code> files from <code class="literal">NationalParks.Droid</code> to <code class="literal">NationalPark.Data</code>.</li><li class="listitem">Open <code class="literal">NationalPark.cs</code> and <code class="literal">NationalParkData.cs</code> and change the namespace <a class="indexterm" id="id451"/>to <code class="literal">NationalParks.Data</code>.</li><li class="listitem">Add a public string <code class="literal">DataDir</code> property to <code class="literal">NationalParkData</code> and use it in the <code class="literal">GetFilename()</code> method, as follows:<div><pre class="programlisting">public string DataDir { get; set; }
. . .
protected string GetFilename()
{
    return Path.Combine (DataDir, "NationalParks.json");
}</pre></div></li><li class="listitem">Move the logic to load the <code class="literal">parks</code> data from the constructor to a new method named <code class="literal">Load()</code>, as shown in the following code snippet:<div><pre class="programlisting">public void Load()
{
  if (File.Exists (GetFilename())) {
    string serializedParks =
        File.ReadAllText (GetFilename());
        _parks = JsonConvert.DeserializeObject
            &lt;List&lt;NationalPark&gt;&gt; (serializedParks);
  }
  else
  _parks = new List&lt;NationalPark&gt; ();
}</pre></div></li><li class="listitem">Compile <code class="literal">NationalParks.Data</code>. You will receive compile errors due to unresolved references to Json.NET. Unfortunately, we cannot simply add a reference to the component version of Json.NET that we previously downloaded from the Xamarin component store because this version is built to be used with the Xamarin.iOS and Xamarin.Android profiles and is not binary compatible with Mono/.NET 4.5 library projects.</li><li class="listitem">Add <a class="indexterm" id="id452"/>the Json.NET library to the project using NuGet. Select <code class="literal">NationalParks.Data</code>, right-click on it, and navigate to <strong>Add</strong> | <strong>Add Packages</strong>. Enter <code class="literal">Json.NET</code> in the search field, check the <strong>Json.NET</strong> entry in the list, and <a class="indexterm" id="id453"/>select <strong>Add Packages</strong>. The following screenshot shows the <strong>Add Packages</strong> dialog box:<div><img alt="Creating a shared library project" src="img/0838OT_06_04.jpg"/></div></li><li class="listitem">Compile <code class="literal">NationalParks.Data</code>; you should receive no compile errors this time.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec62"/>Updating NationalParks.Droid to use shared files</h2></div></div></div><p>Now <a class="indexterm" id="id454"/>that we have the <code class="literal">NationalParksData</code> singleton in a separate project, we are now ready to reuse it.</p><p>To <a class="indexterm" id="id455"/>update <code class="literal">NationalParks.Droid</code> in order to use the shared solution, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Select <code class="literal">NationalPark.cs</code> and <code class="literal">NationalParksData.cs</code> in the <strong>Solution</strong> pad, right-click on it, select <strong>Remove</strong>, and then select <strong>Delete</strong>. This will remove <a class="indexterm" id="id456"/>the selected files from the project and physically delete them from the project folder.</li><li class="listitem">In <code class="literal">NationalParks.Droid</code>, add a folder named <code class="literal">NationalParks.Data</code>. This folder will not contain any files, but will simply be used within the project structure to organize links to the shared files.</li><li class="listitem">Select the <code class="literal">NationalParks.Data</code> folder, right-click on it, and navigate to <strong>Add</strong> | <strong>Add Files</strong> to add the existing files to the project.</li><li class="listitem">In the <strong>Add Files</strong> dialog box, navigate to the <code class="literal">NationalParks.Data</code> project folder, select <code class="literal">NationalPark.cs</code> and <code class="literal">NationalParkData.cs</code>, and click on <strong>Open</strong>.</li><li class="listitem">In the <strong>Add File to Folder</strong> dialog box, select <strong>Add a link to file</strong>, check the <strong>Use the same action for all selected files</strong> option, and click on <strong>OK</strong>. Expand the <strong>NationalParks.Data</strong> folder to see that two file links are added. The following screenshot shows the <strong>Add File to Folder</strong> dialog box:<div><img alt="Updating NationalParks.Droid to use shared files" src="img/0838OT_06_02.jpg"/></div></li><li class="listitem">Add a <code class="literal">using</code> clause to the <code class="literal">NationalParks.Data</code> namespace and remove any <code class="literal">using</code> directives for <code class="literal">Newtonsoft.Json</code> in <code class="literal">MainActivity</code>, <code class="literal">DetailActivity</code>, <code class="literal">EditActivity</code>, and <code class="literal">NationalParksAdapter</code>.</li><li class="listitem">In <code class="literal">MainActivity.OnCreate()</code>, set the <code class="literal">NationalParksData.DataDir</code> property and call the <code class="literal">Load()</code> method prior to creating the <code class="literal">ListView</code> adapter:<div><pre class="programlisting"> NationalParksData.Instance.DataDir =
     System.Environment.GetFolderPath (
        System.Environment.SpecialFolder.MyDocuments);
NationalParksData.Instance.Load ();</pre></div></li><li class="listitem">Compile <a class="indexterm" id="id457"/>and run the app. You should see no noticeable behavior changes, but we are now using the serialization and storage <a class="indexterm" id="id458"/>logic in a <a class="indexterm" id="id459"/>shareable way.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec63"/>Updating NationalParks.iOS to use shared files</h2></div></div></div><p>Now, let's <a class="indexterm" id="id460"/>move on to update <code class="literal">NationalParks.iOS</code>. We have a little more work to do here because if you can recall, we had the file handling logic spread out in several areas.</p><p>To <a class="indexterm" id="id461"/>update <code class="literal">NationalParks.iOS</code> in order to use the shared solution, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Remove <a class="indexterm" id="id462"/><code class="literal">NationalPark.cs</code> from the project.</li><li class="listitem">Add a folder named <code class="literal">NationalParks.Data</code> in the <code class="literal">NationalParks.Droid</code> project.</li><li class="listitem">Add file links to <code class="literal">NationalPark.cs</code> and <code class="literal">NationalParksData.cs</code>.</li><li class="listitem">Open <code class="literal">MasterViewController.cs</code>, add a <code class="literal">using</code> instance of <code class="literal">NationalParks.Data</code>, and remove the <code class="literal">using</code> instance of <code class="literal">Newtonsoft.Json</code>.</li><li class="listitem">In <code class="literal">MasterViewController.ViewDidLoad()</code>, set the <code class="literal">DataDir</code> property before creating the data source for <code class="literal">UITableView</code>:<div><pre class="programlisting">NationalParksData.Instance.DataDir =
    Environment.CurrentDirectory;
NationalParksData.Instance.Load ();</pre></div></li><li class="listitem">In <a class="indexterm" id="id463"/>the <code class="literal">DataSource</code> class, remove the <code class="literal">Parks</code> collection and remove the loading action of the <code class="literal">Parks</code> collection in the constructor.</li><li class="listitem">Update the methods in <code class="literal">DataSource</code> to reference the <code class="literal">Parks</code> collection property in <code class="literal">NationalParksData</code>.</li><li class="listitem">Remove the <code class="literal">Parks</code> property from <code class="literal">DataSource</code> and update <code class="literal">MasterViewController.PrepareForSegue()</code> to use the <code class="literal">Parks</code> property in <code class="literal">NationalParksData</code>.</li><li class="listitem">Open <code class="literal">DetailViewController</code> and add a <code class="literal">using</code> instance of <code class="literal">NationalParks.Data</code>.</li><li class="listitem">In <code class="literal">SetNavData()</code>, remove the <code class="literal">Parks</code> collection argument, corresponding private <a class="indexterm" id="id464"/>variable, and then update the navigation logic in <code class="literal">MasterViewController</code>.</li><li class="listitem">Open <code class="literal">EditViewController</code> and add a <code class="literal">using</code> directive for <code class="literal">NationalParks.Data</code>.</li><li class="listitem">In <code class="literal">SetNavData()</code>, remove the <code class="literal">Parks</code> collection argument, corresponding private variable, and then update the navigation logic in <code class="literal">MasterViewController</code> and <code class="literal">DetailViewController</code> so that no <code class="literal">Parks</code> collection is passed in.</li><li class="listitem">Remove the <code class="literal">SaveParks()</code> method.</li><li class="listitem">In <code class="literal">DoneClicked()</code>, replace the logic that adds the park to the collection and saves <a class="indexterm" id="id465"/>the collection with a call to <code class="literal">NationalParksData.Instance.Save()</code>, as follows:<div><pre class="programlisting">private void DoneClicked (object sender, EventArgs e)
{
    ToPark ();
    NationalParksData.Instance.Save (_park);
    NavigationController.PopViewControllerAnimated (true);
}</pre></div></li><li class="listitem">In <code class="literal">DeleteClicked()</code>, replace the logic that removes the park from the collection and saves the collection with a call to <code class="literal">NationalParks.Instance.Delete()</code>, as follows:<div><pre class="programlisting">partial void DeleteClicked (UIButton sender)
{
    NationalParksData.Instance.Delete(_park);
   NavigationController.PopToRootViewController(true);
}</pre></div></li><li class="listitem">Compile <a class="indexterm" id="id466"/>and run the app. As <a class="indexterm" id="id467"/>with <code class="literal">NationalParks.Droid</code>, you <a class="indexterm" id="id468"/>should see no noticeable behavior changes.</li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec51"/>Portable Class Libraries</h1></div></div></div><p>
<strong>Portable Class Libraries</strong> (<strong>PCL</strong>) are libraries that conform to a Microsoft standard and can be shared <a class="indexterm" id="id469"/>in a binary format across many different platforms such as Windows 7 desktop, Windows 8 desktop, Windows 8 phone, Xbox 360, and Mono. The big advantage with a PCL is that you can share a single binary for all these platforms and avoid distributing source code. However, there are some significant challenges.</p><p>One issue we face straightaway is the fact that our code uses APIs that are not supported across all the platforms; specifically <code class="literal">File.Exists()</code>, <code class="literal">File.ReadAllText()</code>, and <code class="literal">File.WriteAllText()</code>. It seems surprising, but most of <code class="literal">System.IO</code> is not common across all of the .NET profiles; so, the file I/O logic can be difficult to deal with within the shared code. In our case, there are only three methods and we can easily abstract this logic away from the shared code by creating an IO interface. Each platform that uses our shared solution will be responsible for providing an implementation of the IO interface.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec64"/>Creating NationalParks.PortableData</h2></div></div></div><p>The <a class="indexterm" id="id470"/>first step is to <a class="indexterm" id="id471"/>create the Portable Class Library to house our shared solution. To create <code class="literal">NationalParks.PortableData</code>, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add a new Portable Class Library project to the <code class="literal">NationalParks</code> solution. The project template can be found under <strong>C#</strong> | <strong>Portable Library</strong>.</li><li class="listitem">Remove <code class="literal">MyClass.cs</code> from the newly created project.</li><li class="listitem">Copy <code class="literal">NationalPark.cs</code> and <code class="literal">NationalParksData.cs</code> from the <code class="literal">NationalParks.Data</code> project to <code class="literal">NationalParks.PortableData</code>.</li><li class="listitem">Add a reference to the Json.NET Portable Class Library.</li><li class="listitem">Create <a class="indexterm" id="id472"/>the <code class="literal">IFileHandler</code> interface and add three methods that abstract the three IO methods we need. It will be best to make the read and write methods asynchronous returning <code class="literal">Task&lt;&gt;</code>, because many of the platforms only support asynchronous IO. This will simplify implementing the interface on these platforms. The following code demonstrates the required action:<div><pre class="programlisting">public interface IFileHandler
{
    bool FileExists (string filename);
    Task&lt;string&gt; ReadAllText (string filename);
    Task WriteAllText (string filename, string content);
}</pre></div></li><li class="listitem">Add a public <code class="literal">IFileHandler</code> property to <code class="literal">NationalParksData</code> and change all the logic <a class="indexterm" id="id473"/>to use this property rather than using <code class="literal">System.IO.File</code>, as follows:<div><pre class="programlisting">public IFileHandler FileHandler { get; set; }
. . .
public async Task Load()
{
  if (FileHandler.FileExists (GetFilename())) {
    string serializedParks =
      await FileHandler.ReadAllText (GetFilename());
  Parks = JsonConvert.DeserializeObject
          &lt;List&lt;NationalPark&gt;&gt; (serializedParks);
  }
  . . .
}
. . .
public Task Save(NationalPark park)
{
  . . .
  return FileHandler.WriteAllText (
    GetFilename (), serializedParks);
}
public Task Delete(NationalPark park)
{
  . . .
  return FileHandler.WriteAllText (
    GetFilename (), serializedParks);
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec65"/>Implementing IFileHandler</h2></div></div></div><p>We <a class="indexterm" id="id474"/>now need to create an <a class="indexterm" id="id475"/>implementation of <code class="literal">IFileHandler</code> that can be used by both our projects. We will share the file handler implementation using the file linking method from the previous sections.</p><p>To implement <code class="literal">IFileHandler</code>, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">In the <code class="literal">NationalParks</code> solution, create a new <code class="literal">Library</code> project named <code class="literal">NationalParks.IO</code> and set the <strong>Target framework</strong> option to <strong>Mono/.NET 4.5</strong>. This will serve as a shared project for our file handler implementation.</li><li class="listitem">Remove the <code class="literal">MyClass.cs file</code> created by default and add a reference to <code class="literal">NationalParks.PortableData</code>. This will give us access to the <code class="literal">IFileHandler</code> interface we intend to implement.</li><li class="listitem">Create a class named <code class="literal">FileHandler</code> in <code class="literal">NationalParks.IO</code>. Add a <code class="literal">using</code> directive for the <code class="literal">NationalParks.PortableData</code> namespace and specify that the class implements the <code class="literal">IFileHandler</code> interface.</li><li class="listitem">Use the <strong>Implement</strong> interface menu item under <strong>Refactor</strong> to create stub implementations for each method on the interface.</li><li class="listitem">Implement each of the stub methods. The following code demonstrates the required action:<div><pre class="programlisting">#region IFileHandler implementation
public bool FileExists (string filename)
{
    return File.Exists (filename);
}
public async Task&lt;string&gt; ReadAllText (string filename)
{
    using (StreamReader reader =
        File.OpenText(filename)) {
        return await reader.ReadToEndAsync();
    }
}
public async Task WriteAllText (string filename,
    string content)
{
    using (StreamWriter writer =
        File.CreateText (filename)) {
        await writer.WriteAsync (content);
    }
}
#endregion</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec66"/>Updating NationalParks.Droid to use PCL</h2></div></div></div><p>Now, it's <a class="indexterm" id="id476"/>time to update <code class="literal">NationalParks.Droid</code> in order to use our new PCL.</p><p>To <a class="indexterm" id="id477"/>update <code class="literal">NationalParks.Droid</code> in order to use <code class="literal">NationalParks.PortableData</code>, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">In the <code class="literal">NationalParks.Droid</code> project, remove the <code class="literal">NationalParks.Data</code> folder, create a new folder named <code class="literal">NationalParks.IO</code>, and add a reference to <code class="literal">NationalParks.PortableData</code>.</li><li class="listitem">In the <code class="literal">NationalParks.IO</code> folder, add <strong>Link</strong> to the <code class="literal">FileHandler</code> class.</li><li class="listitem">In <code class="literal">MainActivity.cs</code>, add a <code class="literal">using</code> clause for <code class="literal">NationalParks.IO</code> and <code class="literal">NationalParks.PortableData</code>.</li><li class="listitem">In <code class="literal">MainActivity.OnCreate()</code>, initialize the <code class="literal">FileHandler</code> property with an instance of <code class="literal">FileHandler</code>, place an <code class="literal">await</code> instance on the call to <code class="literal">Load()</code>, and move the assignment of <code class="literal">NationalParksAdapter</code> before the call to <code class="literal">Load()</code>, as shown in the following code snippet:<div><pre class="programlisting">_adapter = new NationalParksAdapter (this);
NationalParksData.Instance.FileHandler =
    new FileHandler ();
NationalParksData.Instance.DataDir =
  System.Environment.GetFolderPath (
      System.Environment.SpecialFolder.MyDocuments);
await NationalParksData.Instance.Load ();</pre></div></li><li class="listitem">Now that we are loading data asynchronously, the <code class="literal">OnPause()</code> method will likely be called before the asynchronous return of <code class="literal">OnCreate()</code>. Thus we need to add a null check for the logic in <code class="literal">OnPause()</code> that calls <code class="literal">NotifyDataSetChanged()</code>, as follows:<div><pre class="programlisting">protected override void OnResume ()
{
   basse.OnResume ();
   if (_adapter != null)
       _adapter.NotifyDataSetChanged ();
}</pre></div></li><li class="listitem">In <a class="indexterm" id="id478"/><code class="literal">NationalParksAdapter.cs</code>, <code class="literal">DetailActivity.cs</code>, and <code class="literal">EditActivity.cs</code>, add a <code class="literal">using</code> clause for <code class="literal">NationalParks.PortableData</code>, and remove the <code class="literal">using</code> directive for <code class="literal">NationalParks.Data</code>.</li><li class="listitem">Compile <a class="indexterm" id="id479"/>and run the app.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec67"/>Updating NationalParks.iOS to use PCL</h2></div></div></div><p>Now, it's <a class="indexterm" id="id480"/>time to update <code class="literal">NationalParks.IOS</code>. For the most part, we go through essentially the same steps.</p><p>To <a class="indexterm" id="id481"/>update <code class="literal">NationalParks.iOS</code> in order to use <code class="literal">NationalParks.PortableData</code>, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">In the <code class="literal">NationalParks.Droid</code> project, remove the <code class="literal">NationalParks.Data</code> folder, create a new folder named <code class="literal">NationalParks.IO</code>, and add a reference to <code class="literal">NationalParks.PortableData</code>.</li><li class="listitem">In the <code class="literal">NationalParks.IO</code> folder, add <strong>Link</strong> to the <code class="literal">FileHandler</code> class.</li><li class="listitem">In <code class="literal">MasterViewController.cs</code>, add a <code class="literal">using</code> clause for <code class="literal">NationalParks.IO</code> and <code class="literal">NationalParks.PortableData</code>, and remove the <code class="literal">using</code> directive for <code class="literal">NationalParks.Data</code>.</li><li class="listitem">In <code class="literal">MasterViewController.ViewDidLoad()</code>, initialize the <code class="literal">FileHandler</code> property with an instance of <code class="literal">FileHandler</code>, place an <code class="literal">await</code> instance on the call to <code class="literal">Load()</code>, and place a call to <code class="literal">TableView.ReloadData()</code> after the assignment of the data source, as shown in the following code snippet:<div><pre class="programlisting">NationalParksData.Instance.FileHandler =
    new FileHandler ();
NationalParksData.Instance.DataDir = 
    Environment.CurrentDirectory;
await NationalParksData.Instance.Load ();
TableView.Source = dataSource = new DataSource (this);
TableView.ReloadData ();</pre></div></li><li class="listitem">In <a class="indexterm" id="id482"/><code class="literal">DetailViewController.cs</code> and <code class="literal">EditViewController.cs</code>, replace the <code class="literal">using</code> directive for <code class="literal">NationalParks.Data</code> with <code class="literal">NationalParks.PortableData</code>.</li><li class="listitem">Compile <a class="indexterm" id="id483"/>and run the app.</li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec52"/>The pros and cons of the code-sharing techniques</h1></div></div></div><p>Now that <a class="indexterm" id="id484"/>we have some experience with two practical methods for <a class="indexterm" id="id485"/>sharing code across Xamarin.iOS and Xamarin.Android apps, let's look at some pros and cons. The following table summarizes some of the pros and cons of each approach:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom">
<p>Pros</p>
</th><th style="text-align: left" valign="bottom">
<p>Cons</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>File linking</p>
</td><td style="text-align: left" valign="top">
<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">This allows for a broader use of .NET APIs, assuming that these APIs are supported by all the platforms that will use the shared code. If you are only targeting Xamarin.iOS and Xamarin.Android, this works pretty well.</li></ul></div>
</td><td style="text-align: left" valign="top">
<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">This requires source code to be shared.</li><li class="listitem" style="list-style-type: disc">These API dependency issues might not be known until shared code has been compiled for each target platform.</li></ul></div>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Portable Class Library</p>
</td><td style="text-align: left" valign="top">
<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">This ensures platform API compatibility.</li><li class="listitem" style="list-style-type: disc">This allows for distribution of binary code.</li></ul></div>
</td><td style="text-align: left" valign="top">
<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">This limits the namespaces and APIs available for use in your code.</li></ul></div>
</td></tr></tbody></table></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec53"/>Summary</h1></div></div></div><p>In this chapter, we reviewed two practical approaches to share code across Xamarin projects as well as other .NET solutions. In the next chapter, we will investigate MvvmCross, a framework that simplifies implementing the Model-View-ViewModel design pattern, increasing the amount of shared code across platforms.</p></div></body></html>