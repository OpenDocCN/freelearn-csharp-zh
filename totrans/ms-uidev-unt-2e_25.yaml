- en: '20'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The New Input System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity’s `Update()` method to determine if a device received an input. This usually
    results in multiple if-else branches within your `Update()` method that control
    what happens for each input received.
  prefs: []
  type: TYPE_NORMAL
- en: The Input System divorces the handling of individual input devices from code
    by using an event-based programming methodology. Instead of having to create reference
    to each of your input devices within your code, you create code that reacts to
    specific actions. The Input System then controls which Interaction from which
    Input devices trigger these actions.
  prefs: []
  type: TYPE_NORMAL
- en: This separation of input handling and code allows you to make more customizable
    controls, more easily handle different Input Devices, and more easily handle controls
    from different consoles that have extremely different control schemes. Additionally,
    the modularity of the Input System allows you to easily copy your control schemes
    to other projects, since the information is all stored on an asset.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is meant to be an introduction to the Input System and will give
    you an overview of the key concepts so that you can start using the Input System
    within your projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I will discuss the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to install the Input System
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The differences in polling vs subscribing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic elements involved with the Input System
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write code that uses the Input System’s to control your game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to convert a project that uses the old Input System (the Input Manager)
    to one that uses the new Input System
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two different ways to connect your Input System to your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we begin looking at how to work with the Input System, it needs to be
    imported into your project. Let’s look at how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the asset files and codes of this chapter here: [https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2020](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2020)'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Input System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Input System is no longer in preview and is officially part of Unity. However,
    it does not come pre-packaged in unity and must be installed. You can install
    the Input System into your Project via the Package Manager, by completing the
    following steps.
  prefs: []
  type: TYPE_NORMAL
- en: Select **Unity Registry** from the dropdown menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 20.1: Changing the Package filter in the Package Manager](img/Figure_20.01_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.1: Changing the Package filter in the Package Manager'
  prefs: []
  type: TYPE_NORMAL
- en: Search for the **Input System** in the list and select **Install**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 20.2: Finding the Input System in the Package Manger](img/Figure_20.02_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.2: Finding the Input System in the Package Manger'
  prefs: []
  type: TYPE_NORMAL
- en: You will see the following pop up which you must agree to in order to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.3: A Warning about changing input systems](img/Figure_20.03_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.3: A Warning about changing input systems'
  prefs: []
  type: TYPE_NORMAL
- en: The warning is indicating that any code you wrote using the old Input System
    will no longer function. This is a destructive action and may break your game.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I recommend you create a new project to explore the Input System as installing
    it may be destructive to your project. It will cause all code written using the
    Input Manager to cease functioning. Don’t install it in a pre-existing project
    until you are comfortable doing so.
  prefs: []
  type: TYPE_NORMAL
- en: Once you reopen your project, you may want to return to the Package Manager
    and install the various Samples provided by Unity with the Package. I recommend
    you install the Simple Demo and UI vs Game Input.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is a new Input System, it does use a new methodology to access inputs
    than the old Input System. Let’s first discuss the differences in these methodologies
    before we begin looking at the various elements of the Input System.
  prefs: []
  type: TYPE_NORMAL
- en: Polling vs subscribing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed the Input Manager in [*Chapter 8*](B18327_08.xhtml#_idTextAnchor147)
    and up until recently, it was the only way to track inputs from devices in a Unity-built
    game. When using the Input Manager, you assign specific Axes to different input
    actions. You then write a C# script that constantly checks to see if that action
    is performed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.4: C# script watching for specific inputs defined by the Input
    Manager](img/Figure_20.04_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.4: C# script watching for specific inputs defined by the Input Manager'
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, your code would look something like the following pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This technique of requesting information at a regular interval, is called **polling**.
    You can use the polling pattern for accessing information from the Input System
    in a similar way that you could with the Input Manager. However, to make your
    code more modular, most of your code when using the Input System will use a **publisher-subscriber**
    (**pub-sub**) pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following analogy: you really enjoy content from a specific YouTube
    content creator. You check their channel every day to see if they have released
    new content. However, you find this cumbersome and instead decide to subscribe
    to their channel. Now the YouTube channel will alert you whenever new content
    is posted, saving you the work. Imagine how much work you save yourself from if
    you had hundreds of YouTube channels you wanted to be updated on by subscribing
    to their channels instead of constantly checking in on them.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s tie the analogy to coding. Instead of your C# script having to constantly
    check in on the various inputs in the `Update()` method, you can instead **subscribe**
    to specific events defined by the **Input System**. In more technical speak, you
    will write event subscriber methods that listen for specific events raised by
    the Input System.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.5: C# script listening for specific events defined by the New Input
    System](img/Figure_20.05_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.5: C# script listening for specific events defined by the New Input
    System'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, when using the New Input System, your code may look something like the
    following pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The Input System will determine which events to call based on inputs you specify
    and your code will subscribe to those events, performing the appropriate functions
    whenever those events happen.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do you tell the Input System which events to call based on which input?
    And what types of events can it call from those inputs? You do this through the
    use of Actions, Interactions, and Input Binding. Let’s explore these concepts
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Input System elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Input Manager, you list various Axes and define what buttons can trigger
    these axes. In the Input System, you define a set of **Actions** and describe
    what **Interactions** the various **Controls** of the **Input Device** can trigger
    those Actions through **Input Bindings**.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you could create the Input Binding that binds the Space Bar on
    a keyboard to a jump Action through a pressed Interaction, where the Input device
    would be the keyboard and the Controls would be all the keys on the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.6: An example of an Input Binding](img/Figure_20.06_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.6: An example of an Input Binding'
  prefs: []
  type: TYPE_NORMAL
- en: You can create these sets of **Actions** within what is known as an **Action
    Map**. Action Maps contain a list of Actions. The Actions contain the information
    about the Input Bindings. The general idea is to create Action Maps that contain
    groups of actions based on their purpose for example all character control Actions
    may go in one Action Map and all UI Actions may go in a separate one.
  prefs: []
  type: TYPE_NORMAL
- en: You can view your Action Maps, Actions, Bindings, and Interactions in the Action
    Editor. For example, here is the `Player` and `UI`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.7: The Action Editor](img/Figure_20.07_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.7: The Action Editor'
  prefs: []
  type: TYPE_NORMAL
- en: Within the `Player` Action Map, you can see the `Jump` Action, with the `Space
    [Keyboard]` Binding, and the `Press` Interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start creating your Actions and Action Maps, right click within an `Assets`
    folder and select `Inputs` within your `Assets` folder. When you do so, you should
    get something that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.8: An Action Asset’s Inspector and icon representation](img/Figure_20.08_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.8: An Action Asset’s Inspector and icon representation'
  prefs: []
  type: TYPE_NORMAL
- en: You can either double click on the asset you just created or select **Edit asset**
    from its Inspector to view the Action Editor. The Action Editor will contain your
    list of Action Maps and Actions while displaying each of the Action’s properties.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.9: The Action Editor of a newly created Action Asset](img/Figure_20.09_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.9: The Action Editor of a newly created Action Asset'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the **+** sign in the **Action Maps** section will create a new Action
    Map.
  prefs: []
  type: TYPE_NORMAL
- en: A new Action Map will automatically come with a **New action**, which you can
    rename.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.10: An Action Map with its New action](img/Figure_20.10_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.10: An Action Map with its New action'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting **<No Binding>** will allow you to create an Input Binding.
  prefs: []
  type: TYPE_NORMAL
- en: I will cover an example of how to select Binding and Interactions in the Examples
    section at the end of this chapter, but for now, let’s look at how you can hook
    these Actions to your code.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting Actions to code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple ways to work with the Input System’s Actions in your code.
    In this section, I will give a general overview of the most important topics that
    should allow you to get started working with the Input System.
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect your Actions to your code, you will need to import the `InputSystem`
    with the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two ways in which I will discuss connecting Actions to your Code:'
  prefs: []
  type: TYPE_NORMAL
- en: Referencing the Action Asset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `PlayerInput` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about alternate ways you can connect Actions to your code,
    see the following Unity documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/Packages/com.unity.inputsystem@1.7/manual/Workflows.xhtml](https://docs.unity3d.com/Packages/com.unity.inputsystem@1.7/manual/Workflows.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can reference the Action Asset creating a variable of type `InputActionsAsset`
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can then assign the value of `actions` in the Inspector.
  prefs: []
  type: TYPE_NORMAL
- en: 'And to reference the specific Action within a `InputActionAsset`, you could
    create a variable of type `InputAction`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You could then assign it by finding the specific Action Map and Action within
    the Action Asset, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you find the reference to the Action Asset, you will need to enable and
    disable the appropriate Action Maps. For Example, if you had an Action Map named
    `Player`, you could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have a reference to the `InputActionAsset`, you can have your methods
    subscribe to the various callbacks of the Action. Each Action has the following
    callbacks that you can subscribe to:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Performed`: The Action’s Interaction is complete'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Started`: The Action’s Interaction has started'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Waiting`: The Action is enabled and waiting for an Input to cause trigger
    an Interaction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Canceled`: The Action’s Interaction has been canceled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Disabled`: The Action cannot receive any input as it is disabled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, for example, you could subscribe to an Action named `Jump` on an Action
    Map named `Player` that is triggered by a button press with something like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wish to poll the Actions rather than subscribe to the callback events,
    you use the `ReadValue<TValue>()` method like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you’re not a big fan of writing code, you can instead use the `PlayerInput`
    component. The `PlayerInput` component will allow you to specify which methods
    in your C# scripts are called by the various Actions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.11: The default Player Input component](img/Figure_20.11_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.11: The default Player Input component'
  prefs: []
  type: TYPE_NORMAL
- en: Using this method vs directly referencing the Actions in your code is mostly
    up to preference. It takes less code, but it takes more Inspector work. As a programmer
    by trade, I personally prefer the method that references the Actions in code.
    I find it easier to debug, more customizable, and quicker to edit when there are
    multiple objects using Actions. However, when I am working on a project that has
    designers making changes in the Inspector, who don’t want to work in code, using
    the `PlayerInput` component is a good solution as it allows them to do things
    without me. You can also use a combination and it’s all based on your needs and
    preferences.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about the various ways you can access Actions with your code,
    see the following documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/Packages/com.unity.inputsystem@1.7/manual/Workflow-ActionsAsset.xhtml](https://docs.unity3d.com/Packages/com.unity.inputsystem@1.7/manual/Workflow-ActionsAsset.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a general idea of how the Unity Input System works, let’s look
    at some examples of how to work with it.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve reviewed the basics of getting started with the Input System,
    let’s look at some examples of how to implement it. We’ll look at one very basic
    example of a character controller. We’ll start with an example that uses the old
    Input Manager and then adjust it to use the Input System.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This is a super basic character controller. It is simplified to make the process
    of converting it to the Input System easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: The example we will use is just a cat that jumps and moves around.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.12: The character controller example using the old Input System](img/Figure_20.12_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.12: The character controller example using the old Input System'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you begin these examples, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new 2D Unity Project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `Chapter 20` `– Example 1 - Start` Package provided by the book’s
    source code using `Chapter 20` `– Example 1` to get a feel of how the cat moves
    around. It’s nothing fancy or particularly impressive, but the cat will jump with
    the space bar and move back and forth with the arrow keys and *A*- *D* keys.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `InputManagerBasicCharacterController.cs` class and review the code.
    The key section of code is the `Update()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice the use of `Input.GetAxis("Horizontal")` and `Input.GetButtonDown` **("Jump")**
    . These are defined within the Input Manager which you can find in **Edit** |
    **Project Settings** | **Input Manager**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that you’ve played the game. Install the Input System Package and restart
    when requested. See the *Installing the Input System* section for steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you try to play the game now, you will see the following error in your console.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is because when we installed the Input System, the project stopped accepting
    inputs that use `UnityEngine.Input`. The cat will no longer move in response to
    our key presses.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ok, now that we have our project started and set up, we can convert that code
    to something that can be used by the Input System! Let’s start by setting up our
    Actions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating basic character controller Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start adjusting our code, we first have to set up our Action Map and
    Actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up your basic character controller Actions, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder called `Inputs` within your `Assets` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click within the folder and select **Create** | **Input Actions**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the new Action Asset to `CatActions`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click `CatActions.inputActions` to open the Action Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **Auto-Save** box so that any changes you make will automatically
    save.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 20.13: Selecting Auto-Save](img/Figure_20.13_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.13: Selecting Auto-Save'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to add an Action Map that will hold all the Actions for our character.
    Create a new Action Map by selecting the plus sign and then naming the Action
    Map `Player`. You should now see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 20.14: The Player Action Map](img/Figure_20.14_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.14: The Player Action Map'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the `Jump` action by renaming `New action` to `Jump`. You can do
    so by double-clicking on the words **New action**. Notice that the **Action Type**
    is set to **Button**. This means the Jump Action will be triggered by button-like
    inputs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 20.15: The Jump Action’s properties](img/Figure_20.15_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.15: The Jump Action’s properties'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the arrow next to the `Jump` Action to view all of its bindings. You
    should see **<****No Binding>.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 20.16: The Jump Action’s bindings](img/Figure_20.16_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.16: The Jump Action’s bindings'
  prefs: []
  type: TYPE_NORMAL
- en: Click on `Space`, then select **Space [Keyboard]**. This will bind the spacebar
    on the keyboard to this Action. Notice it automatically names the binding for
    you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let’s tell this binding what Interaction it can accept. Select the plus
    sign next to **Interactions** and select **Press** from the dropdown. Your Player
    Action Map should now look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 20.17: The Press Interaction on the Space [Keyboard] binding](img/Figure_20.17_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.17: The Press Interaction on the Space [Keyboard] binding'
  prefs: []
  type: TYPE_NORMAL
- en: Now we want to add the Action that will be bound to the keys that were previously
    referenced by `"Horizontal"` in the Input Manager. Select the plus sign next to
    `Move`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its **Action Type** to **Value** and its **Control Type** to **Vector2**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we need to add the key bindings. Select the plus sign next to the `Move`
    Action and you’ll notice, since we set `Move` as a different Action Type than
    `Jump`, it has different **Binding Options**. Select **Add Up\Down\Left\Right
    Composite**. You should now see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 20.18: The 2D vector bindings](img/Figure_20.18_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.18: The 2D vector bindings'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the **Up** and **Down** Bindings as well as the one marked **<No Binding>**,
    because we do not need them. You can do this by right-clicking on them and selecting
    **Delete**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Left Arrow` in the **Path** to find **Left** **Arrow [Keyboard]**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select `Right Arrow` in the **Path** to find **Right Arrow [Keyboard]**. You
    should now have the following Actions and Bindings.![Figure 20.19: The Left and
    Right Bindings](img/Figure_20.19_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 20.19: The Left and Right Bindings'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have now bound our arrow keys to the move action.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we need to bind the *A* and *D* keys. Duplicate the **Left: Left Arrow
    [Keyboard]** and **Right: Right Arrow [Keyboard]** bindings by right clicking
    them and selecting **Duplicate**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the duplicate `a keyboard` into the **Path** to find **A [Keyboard]**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the duplicate `d keyboard` into the **Path** to find **D [Keyboard]**.
    You should now see the following Actions and Bindings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 20.20: All the necessary Actions and Bindings](img/Figure_20.20._B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.20: All the necessary Actions and Bindings'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’re done hooking up our Actions, we can start using them with our
    code! I’ll show you two ways to do this: with the `PlayerInput` Component and
    by referencing the Action in our script.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic character controller with the PlayerInput Component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Switching our code to use Actions and the `PlayerInput` component, requires
    a bit of code adjustment and some Inspector work.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Actions with the `PlayerInput` Component, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: To preserve the previous example, I am going to duplicate the scene and call
    it `Chapter 20` `– Example 2`; duplicate the `InputManagerBasicCharacterController.cs`
    script; and rename the duplicate to `PlayerInputBasicCharacterController.cs.`
    If you’d rather just work in the same scene with the same script, you can skip
    this step. However, if you do want to do this, make sure to also change the name
    of the script in the class definition and add the script as a component to the
    `Cat` in your new scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s start by adjusting the script. We’ll be removing the code within the `Update()`
    method that checks for the Input Axes and instead use public methods that can
    be hooked up in the Inspector. Comment out all the code within the `Update()`
    method. Don’t delete it, b/c we’ll cut and paste some of it to other methods later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following statement to the top of your script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new method called `OnJump()`. This will be the method that is called
    when the `Jump` Action is triggered. It should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We want our `OnJump()` method to perform similarly to the following statement
    we have commented out in our `Update()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Cut and paste it into the `OnJump()` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Remove `&& Input.GetButtonDown("Jump")` from the `if` statement. Your `OnJump()`
    method should now appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let’s hook this method up in the Inspector. Select your `Cat` from the
    Hierarchy and add the `PlayerInput` Component. Your Cat’s Inspector should have
    the following components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 20.21: Some of the components on Cat](img/Figure_20.21._B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.21: Some of the components on Cat'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s add our Actions to the `CatActions` from the Project folder into
    the **Actions** slot. Your component should now look as follows:![Figure 20.22:
    Assigning CatActions to the PlayerInput component](img/Figure_20.22._B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 20.22: Assigning CatActions to the PlayerInput component'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice it already found our **Player** Action Map and added it as the **Default
    Map**. If we had more Action Maps, there would be others in the dropdown we could
    choose from.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: From the **Behavior** dropdown, select **Invoke Unity Events**. This will add
    an **Events** setting that can be expanded to reveal a list of **Player** Events.
    Expanding **Player** will show the two Actions we have defined within the Player
    Map along with some other useful Actions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 20.23: The Various Player Action Events](img/Figure_20.23._B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.23: The Various Player Action Events'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can hook up our `OnJump()` method to the `Cat` into the Object slot, and
    then selecting **PlayerInputBasicCharacterController** | **OnJump**. Your **Jump**
    Event should now appear as follows:![Figure 20.24: The Player Jump Event calling
    our OnJump method](img/Figure_20.24._B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 20.24: The Player Jump Event calling our OnJump method'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Play the game and you should see the cat jump when you press the spacebar.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let’s hook up the Move Action. Return to your code and create the following
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following variable declaration to your code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we got the `movement` variable from the Input Axis, we used the following
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will get the value of the Move Action whenever the `OnMove()` method is
    called.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Return to your `Update()` method and uncomment the remaining code. Your `Update()`
    method should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Delete the following line that uses the old Input System.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Edit the remaining line to use the `moveVector` instead of the movement float.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remove the `movement` float variable declaration since we no longer need it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Return to your Inspector and add the `OnMove()` method to the `Cat` into the
    Object slot, and then selecting **PlayerInputBasicCharacterController** | **OnMove**.
    Your Move Event should now appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 20.25: The Player Move Event calling our OnMove method](img/Figure_20.25._B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.25: The Player Move Event calling our OnMove method'
  prefs: []
  type: TYPE_NORMAL
- en: Play the game and your cat should now be able to move and jump!
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I’m not a fan of using the `PlayerInput` component. Since I am a
    programmer by trade, I prefer to spend most of my time in my code editor rather
    than the Unity Editor. I find debugging code that is hooked up in the inspector
    difficult to debug. When I do use this functionality, I try to make life easier
    for my future self (or my other programming coworkers) by adding comments to the
    code that states what components call what methods. This can make debugging and
    understanding the way the code works a little easier. Using a code editor like
    Jetbrains Rider can relieve some of this stress, as it will indicate where code
    is hooked up in the Inspector, but it does not always show all necessary information
    and you can’t count on your coworkers also having the Rider IDE. If you have a
    similar preference, I will show you in the next example how to do this in a code-centric
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic character controller by referencing Actions in your code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To redo our previous example so that it references the Actions in code, complete
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: To preserve the previous example, I am going to duplicate the scene and call
    it `Chapter 20` `– Example 3`; duplicate the `PlayerInputBasicCharacterController.cs`
    script; and rename the duplicate to `ActionReferenceBasicCharacterController.cs`.
    If you’d rather just work in the same scene with the same script, you can skip
    this step. However, if you do want to do this, make sure to also change the name
    of the script in the class definition and add the script as a component to the
    `Cat` in your new scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the `Cat`’s Inspector. Notice if you try to play the game now, the cat
    will not move or jump, since we removed the component that tied the inputs to
    our code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `ActionReferenceBasicCharacterController.cs` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Comment out the `OnMove()` method. We will not be calling this via an Event
    in the Inspector, so we do not need the method. However, we will write code similar
    to it, so I’ll comment it out for now so I can copy and paste it into the correct
    place later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first thing we need to do is get a reference to the Action Asset that holds
    all of our Actions. Create the following variable declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can go ahead and hook this up in the Inspector by dragging the `CatActions`
    asset into the **Actions** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to the script. Add an empty `OnEnable()` method and `OnDisable()` method
    to your script. We’ll add some code to them momentarily.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I prefer to put the `OnEnable()` method right under the `Awake()` method since
    it executes after it and the `OnDisable()` method at the bottom of the script
    since it will execute after all of our other methods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since we are referencing our Actions via code, we will need to enable and disable
    our Action Map. Add the following boldened lines of code to your `OnEnable()`
    and `OnDisable()` methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let’s hook up our Jump Action. We will accomplish this by subscribing to
    the Jump Action’s `performed` event. Add the following code to your `OnEnable()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should be enough to get the `OnJump()` method we already wrote working
    with your Action Map. Play the game and you can now see the cat jump when you
    press the space bar.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'While not entirely necessary for this example, I prefer to make a habit of
    always unsubscribing from any events I subscribe to in `OnDisable()`. Making a
    habit of doing it will save me from problems in the future when it is necessary.
    So, add the following line of code to the top of your `OneDisable()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let’s hook up our Move Action. To do this, we can create a reference to
    the `InputAction` that represents the Move Action to make it easily accessible
    via code. Add the following variable declaration to the top of your code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let’s initialize it. Add the following line of code to your `OnEnable()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Instead of subscribing to the Move Action, we’ll poll it in our `Update()` method.
    Cut and paste the following code from within your commented out `OnMove()` method
    to the top of your `Update()` method. You can delete the `OnMove()` method now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will get an error on the `context` variable. It was a parameter for the
    `OnMove()` method and does not exist within the `Update()` method. Instead of
    reading the value of `context`, we will read the value of `playerMoveAction`.
    Replace `context` with `playerMoveAction` so that your `Update()` method appears
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And that should be sufficient to get our cat moving with Actions and without
    the `PlayerInput` component. Play the game and watch the cat move around and jump
    when you press the appropriate keys.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: I know that setting our specific project up to use the Input System rather than
    using the Input Manager was a lot more work and may not seem worth it. And for
    this tiny example, that is probably true. However, if we wanted to create a cross
    platform version of this project that accepted inputs from multiple types of devices,
    adding new Bindings to an Action within an Action Map is significantly less work
    than adding in a new line of code for each possible input configuration we want
    to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to use the New Input System to collect input
    for your game. This allows us to make an easily customizable input system that
    can make controlling our game via various input devices significantly easier in
    the long run. It may take a bit if set work to set up, but it can save you a lot
    of effort in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: And so, we come to an end of the book! I have no more User Interface knowledge
    to impart to you.
  prefs: []
  type: TYPE_NORMAL
