- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Other Interactable UI Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most popular interactable UI components are Buttons. However, there are
    multiple types of interactable UI elements other than buttons. If you think of
    an online form you’ve filled out recently, you’ve probably interacted with buttons,
    text fields, and possibly a radio button or checkbox. While technically all of
    these interactable items can be developed with UI Buttons, UI Text, and some custom
    code, you don’t have to build them yourself! Unity has included, within the uGUI
    system, multiple commonly used interactable UI items both as GameObjects that
    you can edit and as components that you can add to pre-existing GameObjects.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will review all the other pre-built UI items that come with the
    uGUI system. After having reviewed the chapters on buttons and text, most of these
    objects’ properties will be familiar to you, but each interactable item has a
    few properties exclusive to that UI item type, so we’ll focus on those properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using UI Toggles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using UI Sliders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using UI Dropdowns and Dropdown – TextMeshPros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using UI Input Fields and Input Field – TextMeshPros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a dropdown menu with images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: All the examples shown in this section can be found within the Unity project
    provided in the code bundle. They can be found within the scene labeled **Chapter13**.
  prefs: []
  type: TYPE_NORMAL
- en: Each example image has a caption stating the example number within the scene.
  prefs: []
  type: TYPE_NORMAL
- en: In the scene, each example is on its own Canvas, and some of the Canvases are
    deactivated. To view an example on a deactivated Canvas, simply select the checkbox
    next to the Canvas’ name in the **Inspector**. Each Canvas is also given its own
    Event System. This will cause errors if you have more than one Canvas activated
    at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter here: [https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2013](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2013)'
  prefs: []
  type: TYPE_NORMAL
- en: Using UI Toggle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **UI Toggle** object is an interactable checkbox with a label. To create
    a UI Toggle, select **+** | **UI** | **Toggle**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1: UI Toggle GameObject and children](img/Figure_13.01_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: UI Toggle GameObject and children'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, a UI Toggle has two children: a `Background` and a `Label`. The
    `Background` also has a child, a `Checkmark`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Background` child is a UI Image that represents the “box” in which the
    `Checkmark` UI Image appears. The `Label` is a UI Text object.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to change the appearance of the box and checkmark, you change the
    source images of the Image components on the `Background` and `Checkmark` children,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Toggle component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The parent Toggle object has a **Toggle** component. The Toggle component looks
    very similar to the Button component and has many of the same properties. As you’ll
    see in this chapter, the first few properties of all interactable UI objects are
    the same. The properties at the bottom of the component are the ones that are
    exclusive to the UI Toggle object (*Figure 13**.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2: The Toggle component unique properties](img/Figure_13.02_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: The Toggle component unique properties'
  prefs: []
  type: TYPE_NORMAL
- en: The **Is On** property determines whether the Toggle is checked or not when
    it is initialized in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: The **Toggle Transition** property determines what happens when the toggle transitions
    between on and off or checked and not checked. The two options are **None** and
    **Fade**. The **None** transition will instantaneously toggle between the checkmark
    Image being visible and not visible while the **Fade** transition will have the
    checkmark Image fade in and out.
  prefs: []
  type: TYPE_NORMAL
- en: The **Graphic** property assigns the **Image** component that will display the
    checkmark. The Checkmark child’s Image component is automatically assigned to
    this property, but you can change it if you so desire.
  prefs: []
  type: TYPE_NORMAL
- en: The last property, **Group**, assigns the **Toggle Group** component that will
    define which Toggle Group the Toggle belongs to (if any).
  prefs: []
  type: TYPE_NORMAL
- en: The **Toggle** component’s default Event is the On Value Changed Event, as seen
    in the **On Value Changed (****Boolean)** section.
  prefs: []
  type: TYPE_NORMAL
- en: Toggle default event – On Value Changed (Boolean)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Toggle** component’s default event is the **On Value Changed** Event,
    as seen in the **On Value Changed (Boolean)** section of the Toggle component.
    This event will trigger whenever the toggle is selected or deselected. It can
    accept a Boolean argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a public function has a Boolean parameter, it will appear twice within
    the function’s dropdown list of **On Value Changed (Boolean)** events: once within
    a **Static Parameter** list and again within the **Dynamic bool** list, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3: The static and dynamic versions of the ToggleWithParameter method](img/Figure_13.03_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.3: The static and dynamic versions of the ToggleWithParameter method'
  prefs: []
  type: TYPE_NORMAL
- en: If the function is selected from the `ToggleWithParameter()` function will be
    false (since the checkbox is deselected).
  prefs: []
  type: TYPE_NORMAL
- en: If you want to pass the `.isOn` value of the Toggle to the script, the function
    must be chosen from the **Dynamic bool** (not **Static Parameters**) list in the
    function dropdown of the event.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how **On Value Changed (Boolean)** events work, let’s see how
    the following two functions respond when called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following events are added to a Toggle in the Chapter13 scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4: Events on the Toggle Event Example in the Chapter13 scene](img/Figure_13.04_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.4: Events on the Toggle Event Example in the Chapter13 scene'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the **Toggle** within the scene is deselected, the following will print
    in the **Console**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When the **Toggle** is selected, the following will print in the **Console**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Since the function called from the first event does not have a parameter, it
    will always execute when the value of the Toggle changes, regardless of what the
    value of the Toggle is when executed.
  prefs: []
  type: TYPE_NORMAL
- en: The second event will always print the value of `False`, because the function
    has a parameter and, since the event was chosen from the `False`. So, the value
    `False` is always sent to the function.
  prefs: []
  type: TYPE_NORMAL
- en: The third event’s function was chosen from the `.isOn` value to which the Toggle
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: Toggle Group component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Toggle Group** component allows you to have many UI Toggles that work
    together, where only one can be selected or *on* at a time. When Toggles are in
    the same Toggle Group, selecting one Toggle will turn *off* all others. For the
    Toggle Group to work properly at the start, you should either set all the Toggles
    within the Toggle group’s **Is On** property to **False** or set only a single
    Toggle’s **Is On** property to **True**.
  prefs: []
  type: TYPE_NORMAL
- en: The **Toggle Group** component does not create a renderable UI object, so attaching
    it to an empty GameObject will not create any visible element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the **Toggle Group** component is attached to a GameObject, the GameObject
    it is attached to must be dragged into the **Group** property of each of the Toggles
    that will be contained within the group:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5: The Toggle Group component properties](img/Figure_13.05_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.5: The Toggle Group component properties'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is only one property on the **Toggle Group** component: **Allow Switch
    Off**. The **Allow Switch Off** property allows the Toggles to be turned off if
    they are selected when already in the on state. Remember that the Toggle Group
    component forces at most one Toggle on at a time. So, the **Allow Switch Off**
    property being turned off forces there to be at least one Toggle selected at all
    times.'
  prefs: []
  type: TYPE_NORMAL
- en: My suggestion when using this component is to use an empty GameObject that acts
    as the parent for all the Toggles you wish to group together. This empty GameObject
    will then contain the Toggle Group component (as demonstrated in the **Toggle
    Group Example** in the Chapter13 scene). The object containing the Toggle Group
    component must then be assigned to the **Group** property on the **Toggle** component
    of each of the Toggle children.
  prefs: []
  type: TYPE_NORMAL
- en: UI Slider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The UI Slider object allows the user to drag a handle along a path. The position
    on the path corresponds to a range of values.
  prefs: []
  type: TYPE_NORMAL
- en: To create a UI Slider, select `Background`, a `Fill Area`, and a `Handle Slide
    Area`. The Fill Area also has a child, Fill, and the Handle Slide Area has a child,
    Handle.
  prefs: []
  type: TYPE_NORMAL
- en: The Background child is a UI Image that represents the full area that the Slider’s
    Handle can traverse. In the default Slider example, this is the darker gray background
    area that gets filled.
  prefs: []
  type: TYPE_NORMAL
- en: The Fill Area child is an empty GameObject. Its main purpose is to ensure that
    its child, the Fill, is correctly aligned. The Fill is a UI Image that stretches
    across the Fill Area based on the Slider’s value. In the default Slider example,
    this is the light gray area that trails behind the handle and fills in the Background.
  prefs: []
  type: TYPE_NORMAL
- en: The Handle Slide Area child is also an empty GameObject. Its purpose is to ensure
    that its child, the Handle, is correctly positioned and aligned. The Handle is
    also a UI Image. The Handle represents the interactable area of the Slider.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to change the appearance of the Slider, you change the **Source
    Image** of the **Image** components on the Background, Fill, and Handle children.
  prefs: []
  type: TYPE_NORMAL
- en: Slider component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The parent Slider object has a **Slider** component. It has all the properties
    common to the interactable UI objects along with a few that are exclusive to Sliders,
    as highlighted in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6: The unique properties of the Slider component](img/Figure_13.06_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.6: The unique properties of the Slider component'
  prefs: []
  type: TYPE_NORMAL
- en: The **Fill Rect** property assigns the Rect Transform of the object that displays
    the Image of the filled area. By default, this is the Fill GameObject’s Transform
    component. You’ll note that on the Rect Transform component of the Fill, a message
    stating **Some values driven by Slider** is displayed. This indicates that the
    values are changed based on the **Slider** component. While playing the scene,
    if you move the Handle of the Slider, you will not see the Rect Transform properties
    of the Fill update. However, if you make the Scene view visible while moving the
    Handle in the **Game** view, you will see the Rect Transform area of the Fill
    change as you affect the slider.
  prefs: []
  type: TYPE_NORMAL
- en: The **Handle Rect** property assigns the Rect Transform of the object that displays
    the handle’s image. By default, the Rect Transform of Handle is assigned to this
    property. You’ll note that the Rect Transform component on the Handle GameObject
    also has the **Some values driven by Slider** message since the position of the
    Handle is affected by the Slider.
  prefs: []
  type: TYPE_NORMAL
- en: The range of values that the Slider represents is determined by the **Min Value**
    and **Max Value** properties. You can assign any value to the **Min Value** and
    **Max Value** properties, even negative numbers. While the **Inspector** allows
    you to define the **Min Value** as a number larger than the **Max Value**, the
    Slider will not work properly if you do so.
  prefs: []
  type: TYPE_NORMAL
- en: The **Direction** property allows you to select the orientation of the Slider.
    The available options are **Left To Right**, **Right To Left**, **Bottom To Top**,
    and **Top to Bottom**. The order of the positions in each direction represents
    the first position (or **Min Value**) and then the last position (or **Max Value**)
    of the Slider’s value range.
  prefs: []
  type: TYPE_NORMAL
- en: If the **Whole Numbers** property is selected, the range of values the Slider
    can represent will be restricted to integer (non-decimal) values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As I am a math teacher, I feel the need to point this out. In math, the term
    Whole Numbers represents all non-negative Integers (0 through infinity). Here,
    in the Slider component, the term Whole Numbers represents all Integers, even
    negative ones. So, if you’re a math nerd like me, don’t let this imply to you
    that the Slider cannot hold negative values if the **Whole Numbers** property
    is selected.
  prefs: []
  type: TYPE_NORMAL
- en: The **Value** property is the value of the Slider. The position of the Slider’s
    Handle is tied to this property. The slider in the **Inspector** next to the **Value**
    property is a one-to-one representation of the Slider in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Slider default event – On Value Changed (Single)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Slider component’s default event is the On Value Changed event, as seen
    in the **On Value Changed (Single)** section of the Slider component. This event
    will trigger whenever the Slider’s Handle is moved. It can accept a float argument.
  prefs: []
  type: TYPE_NORMAL
- en: If you want the Slider’s value to be sent as an argument to a function that
    has a parameter, you must select the function from the Dynamic float list (similar
    to selecting functions from the Toggle’s Dynamic bool list).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following functions and screenshot represent a Slider example found in
    the Chapter7Text scene that triggers events that call functions with and without
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, the third option shows the function chosen from
    the **Dynamic float** list and will send the value of the **Value** property as
    an argument to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7: Events on Slider Example in the Chapter13 Scene](img/Figure_13.07_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.7: Events on Slider Example in the Chapter13 Scene'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that if the **Whole Numbers** property is selected and
    the Slider can only hold integer values, the functions called by this event will
    receive those integers as float values.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve reviewed how to use Sliders, let’s review how to use the two
    types of Dropdowns.
  prefs: []
  type: TYPE_NORMAL
- en: UI Dropdown and Dropdown – TextMeshPro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two Dropdown UI objects available, the UI Dropdown object packaged
    in Unity and the Dropdown—TextMeshPro object. Both the Dropdown objects allow
    the user to select from a list of options. The list becomes visible when the Dropdown
    is clicked on. Once an object is selected from the list, the list will collapse,
    making the chosen option visible within the Dropdown (if desired).
  prefs: []
  type: TYPE_NORMAL
- en: The two Dropdown options are pretty much identical in the way they work. The
    only difference between the two is the UI Dropdown uses UI Text objects to display
    text while the Dropdown—TextMeshPro uses Text - TextMeshPro objects. Due to this,
    I will discuss the two objects at the same time in this section. Additionally,
    because the two objects are identical in function, you will need to use Dropdown—TextMeshPro
    over the UI Dropdown if you want to include “fancy” text.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a UI Dropdown, select **+** | **UI** | **Dropdown**. To create a
    Dropdown—TextMeshPro, select **+** | **UI** | **Dropdown - TextMeshPro**. As you
    can see in the following screenshot (*Figure 13**.8*), the two Dropdown objects
    have identical parent/child object relationships and names. By default, the Dropdown
    objects have three children: a Label, an Arrow, and a Template. The Template child
    is disabled by default (hence, it appears grayed out in the Hierarchy) and has
    multiple children.'
  prefs: []
  type: TYPE_NORMAL
- en: The Template child and all of its children are discussed in the *Dropdown Template*
    section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8: The Hierarchy of the two types of dropdowns](img/Figure_13.08_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.8: The Hierarchy of the two types of dropdowns'
  prefs: []
  type: TYPE_NORMAL
- en: In the following paragraphs, I will discuss all Text objects as if they are
    UI Text objects. However, remember that the Dropdown—TextMeshPro uses TextMeshPro
    - Text objects.
  prefs: []
  type: TYPE_NORMAL
- en: The Label child is a UI Text object. By default, it displays the text within
    the Dropdown object that represents the selected option. As the player changes
    the selected option, the **Text** property of the **Text** component of Label
    changes to the appropriate option. To change the properties of the text that displays
    within the boxed area of the Dropdown, change the properties of the **Text** component
    on the Label. When new text replaces the text within the Label, it will automatically
    display based on the properties set by the Text component of the Label.
  prefs: []
  type: TYPE_NORMAL
- en: The Arrow child is a UI Image. Its only function is to hold the image for the
    arrow that (by default) appears at the right of the Dropdown. This arrow doesn’t
    actually do anything and is simply an image. It doesn’t accept inputs or change
    with the properties of the Dropdown component.
  prefs: []
  type: TYPE_NORMAL
- en: The background image of the Dropdown is on the main Dropdown parent object and
    not on a child named Background. Therefore, if you want to change the appearance
    of the Dropdown’s background and Arrow, you change the **Source Images** of the
    Image components on the Dropdown parent and Arrow child, respectively. The image
    of the Dropdown only affects the rectangle that can be selected to display the
    dropdown menu. The background to the menu that expands outward when the player
    interacts with the dropdown is handled by the Template (discussed in the following
    *Dropdown* *Template* section).
  prefs: []
  type: TYPE_NORMAL
- en: Dropdown Template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we discuss the various properties of the Dropdown component, let’s look
    more closely at Dropdown’s **Template**.
  prefs: []
  type: TYPE_NORMAL
- en: The child of Dropdown named Template allows you to set the properties of the
    “items” that will appear as options in the dropdown menu. It also allows you to
    set the properties of the background of the menu and the Scrollbar that will appear
    if the list expands past the viewable area of the dropdown menu.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the Template child is disabled by default. Enabling the Template
    (by selecting the checkbox in its **Inspector**) will display the Template in
    the scene.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9: Enabling the Template GameObject of the Dropdown](img/Figure_13.09_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.9: Enabling the Template GameObject of the Dropdown'
  prefs: []
  type: TYPE_NORMAL
- en: You can leave this permanently enabled in your Editor because once you enter
    **Play** mode, it will hide as it is supposed to.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look closely at the parent/child relationships of the Template within
    the **Hierarchy**, you’ll note that it is simply a UI Scroll View object with
    one Scrollbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10: The UI Scroll View with One Scrollbar within the Dropdown](img/Figure_13.10_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.10: The UI Scroll View with One Scrollbar within the Dropdown'
  prefs: []
  type: TYPE_NORMAL
- en: 'Viewing the **Inspector** of the Template GameObject, shows that it, in fact,
    is just a UI Scroll View object, as it has a **Scroll Rect** component attached
    to it with no **Horizontal** **Scrollbar** assigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.11: The Scroll Rect component of the Template](img/Figure_13.11_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.11: The Scroll Rect component of the Template'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Content** of the Template Scroll View object has a single child named
    **Item**. **Item** has three children: **Item Background**, **Item Checkmark**,
    and **Item Label**. If you look at the **Inspector** of **Item**, you’ll see that
    it is just a UI Toggle and has the same children and properties as the UI Toggles
    discussed at the beginning of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: So, all `Template` is a Scroll View with a single Scrollbar and with a single
    Toggle as its Content! It looks way more complicated initially, but after you
    break down what the individual pieces are, you›ll realize that it›s just a combination
    of a few of the UI items we have already discussed!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.12: Breakdown of the Template’s children](img/Figure_13.12_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.12: Breakdown of the Template’s children'
  prefs: []
  type: TYPE_NORMAL
- en: When working with the Dropdown Template, if you want to change the visual properties
    and the settings, just remember the breakdown shown in the preceding figure, and
    the prospect of editing it will seem a lot less daunting.
  prefs: []
  type: TYPE_NORMAL
- en: Every item option you set to appear within the Dropdown will follow the exact
    same visual properties of those you set for the Item Toggle.
  prefs: []
  type: TYPE_NORMAL
- en: The Dropdown component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve broken down the Template, we can look at the properties of the
    **Dropdown** component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parent Dropdown object has a **Dropdown** (or Dropdown - TextMeshPro) component.
    It has all the properties common to the other interactable UI objects, along with
    a few that are exclusive to Dropdowns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.13: The difference between the two Dropdown components](img/Figure_13.13_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.13: The difference between the two Dropdown components'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding image, the properties of the UI Dropdown and
    Dropdown - TextMeshPro are nearly identical. There are only two main differences.
    First, UI Dropdown objects use UI Text objects, while Dropdown - TextMeshPro objects
    use Text - TextMeshPro objects. Second, Dropdown - TextMeshPro has a **Placeholder**
    property.
  prefs: []
  type: TYPE_NORMAL
- en: The Dropdown component is actually super powerful. It handles all interactions
    with the Dropdown menu and will switch text displays, open and close the dropdown,
    and move around the checkbox within the dropdown. It even adds a scrollbar and
    handle to allow the dropdown menu to have a really long list. The only thing that
    must be coded by you is how to interpret the property the player selects.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s review the various properties of the two Dropdown objects.
  prefs: []
  type: TYPE_NORMAL
- en: Caption properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two properties related to the caption or the option that is currently
    selected (*Figure 13**.3*).
  prefs: []
  type: TYPE_NORMAL
- en: The `None (Text)`.
  prefs: []
  type: TYPE_NORMAL
- en: The **Caption Image** property holds the Image component of the GameObject that
    will display the currently selected option’s image. Nothing is assigned to this
    property by default and, you will note that the **Dropdown** does not have a child
    that can hold the Image. To have an image display with the text, you will have
    to create a UI Image and assign it to the **Caption Image** property. It is best
    that the UI Image you create is created as a child of the Dropdown.
  prefs: []
  type: TYPE_NORMAL
- en: Template properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are three properties related to assigning the template’s properties to
    all possible options to display in the dropdown list.
  prefs: []
  type: TYPE_NORMAL
- en: The **Template** property references the Rect Transform of the template. As
    stated previously, the template defines the way each option within the dropdown
    list will look as well as how the dropdown holder will look. By default, this
    property is assigned to the child Template object.
  prefs: []
  type: TYPE_NORMAL
- en: The **Item Text** property references the **Text** component of the GameObject
    that holds the text of the item template. By default, the **Text** component on
    the Item Label (child of the Item) is assigned to this property.
  prefs: []
  type: TYPE_NORMAL
- en: The **Item Image** property references the **Image** component of the GameObject
    that holds the image of the item template. By default, this property is unassigned,
    similar to the **Caption Image**. Just as with the **Caption Image**, to use this
    property, a UI Image will need to be created and assigned to this property. If
    you create one, ensure that you add it as a child of **Item** within the Template
    child to avoid confusion.
  prefs: []
  type: TYPE_NORMAL
- en: Option properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Value** property represents which option is currently selected. The options
    are in a list, and the number in the **Value** property represents the currently
    selected option’s index within the list. Since the options are represented by
    their indices, the first option has a **Value** of 0 (not 1).
  prefs: []
  type: TYPE_NORMAL
- en: The **Options** property lists out all the options within the **Dropdown** menu.
    Within the list, each option has a text string and sprite (optional). All strings
    and sprites within this list will automatically swap into the correct component
    properties of the children of Dropdown, based on the properties of the **Dropdown**
    component. So, you will not have to write any code to ensure that these items
    display appropriately when the player interacts with the Dropdown.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the **Options** list contains three options. However, you can add
    or subtract options by selecting the plus and minus sign at the bottom of the
    list. You can also rearrange the options within the list by dragging and dropping
    the options’ handles (two horizontal lines). Note that rearranging the options
    in the list will change their indices within the list and then change the **Value**
    they send to the **Dropdown** component.
  prefs: []
  type: TYPE_NORMAL
- en: Dropdown default event – On Value Changed (Int32)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Dropdown component handles all interactions with the Dropdown menu itself.
    The only thing that has to be coded by you is how to interpret the option the
    player selected.
  prefs: []
  type: TYPE_NORMAL
- en: The Dropdown component’s default event is the **On Value Changed** Event, as
    seen in the **On Value Changed (Int32)** section of the **Dropdown** component.
    This event will trigger whenever a new option is selected by the player. It accepts
    an integer as an argument and, as with the other events discussed in this chapter,
    you can choose to pass no argument, a static argument, or a dynamic argument.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to send the index of the option selected (or the value of the **Value**
    property) to a function, you›d send it to a function with a Int32 parameter from
    the **Dynamic int** list. Refer to the *Creating a dropdown menu with images*
    example at the end of the text for an implementation of this.
  prefs: []
  type: TYPE_NORMAL
- en: The next interactable UI component we’ll review is the UI Input Field.
  prefs: []
  type: TYPE_NORMAL
- en: UI Input Field
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The UI Input Field provides a space in which the player can enter text.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a UI Input Field, select **+** | **UI** | **Input Field**. By default,
    the InputField GameObject has two children: a Placeholder and a Text object.'
  prefs: []
  type: TYPE_NORMAL
- en: The Placeholder child is a UI Text object that represents the text displayed
    before the player has input any text. Once the player begins entering text, the
    Text component on the Placeholder GameObject deactivates, making the text no longer
    visible. By default, the text displayed by the Placeholder is **Enter text…**,
    but the text being displayed as well as its properties are easily changed by affecting
    the properties on the **Text** component of the Placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: The Text child is a UI Text object that displays the text the player inputs.
    Setting the properties on the Text object’s **Text** component will change the
    display of the text entered by the player.
  prefs: []
  type: TYPE_NORMAL
- en: InputField contains an **Image** component. If you want to change the appearance
    of the input box, change the **Source Image** of the **Image** component on the
    InputField.
  prefs: []
  type: TYPE_NORMAL
- en: Input Field component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The parent InputField object has an **Input Field** component. It has all the
    properties common to the interactable UI objects along with a few that are exclusive
    to Input Fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.14: The unique properties of the Input Field component](img/Figure_13.14_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.14: The unique properties of the Input Field component'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the various properties of the UI Input Field.
  prefs: []
  type: TYPE_NORMAL
- en: Properties of entered text and onscreen keyboards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many of the properties within the **Input Field** component affect the text
    that displays within the Input Field. Due to some of the properties having a lot
    of options and information pertaining to them, I will discuss them slightly out
    of order.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that to change the visual style of the entered text, you need to change
    the properties of the **Text** component on the Text GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: The **Text** Component property references the Text component of the GameObject
    that will display the player’s entered text. By default, this is the **Text**
    component of the Text child.
  prefs: []
  type: TYPE_NORMAL
- en: The **Text** property is the text currently entered into the Input Field. When
    you are attempting to retrieve the data from the Input Field, you want to get
    the information from this property and not from the **Text** component on the
    Text GameObject. The Text component on the Text GameObject will only store what
    is currently being displayed. So, if the text is displayed as asterisks because
    it’s a password or has scrolled, the full and correct text will not be stored
    in the **Text** component of the Text GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: The `0` allows unlimited text entry.
  prefs: []
  type: TYPE_NORMAL
- en: The **Placeholder** property references the **Text** component of the GameObject
    that displays the text when the player has either not entered anything or has
    cleared all entered text. By default, this is the **Text** component of the **Placeholder**
    child.
  prefs: []
  type: TYPE_NORMAL
- en: The **Hide Mobile Input** property allows you to override the default mobile
    keyboard that pops up when a text **Input Field** is selected. You will select
    this option if you have your own keyboard that you want the player to use. Currently,
    this only works for iOS devices.
  prefs: []
  type: TYPE_NORMAL
- en: If you wanted to use your own keyboard on an Android device, your best bet would
    be to create your own custom input field script. The script would show a keyboard
    when the input box is selected and then change the text within the box based on
    the custom keyboard key presses.
  prefs: []
  type: TYPE_NORMAL
- en: The **Read Only** property makes the text within the **Input Field** static
    and uneditable by the player. The player can still select the text to copy and
    paste it when this property is activated.
  prefs: []
  type: TYPE_NORMAL
- en: When the **Read Only** property is selected, the text displayed by the Input
    Field can still be edited via code by accessing the **Text** property on the Input
    Field component. However, changing the **Text** property on the **Text** component
    of the Text GameObject, will not change the displayed text.
  prefs: []
  type: TYPE_NORMAL
- en: Content Types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The **Content Type** property determines the types of characters that will be
    accepted by the Input Field. On devices that display keyboards on screen, it also
    affects the keyboard that is displayed by the device when the input field is selected.
    If the desired keyboard is not available, the default keyboard will be displayed.
    For example, if the device does not have a numbers-only keyboard, it will display
    the default keyboard. For more detailed explanations of each keyboard and character
    validations that come with these Content Types, refer to the *Keyboard Types*
    and *Character Validation* *Options* sections.
  prefs: []
  type: TYPE_NORMAL
- en: The possible options are **Standard**, **Autocorrected**, **Integer Number**,
    **Decimal Number**, **Alphanumeric**, **Name**, **Email Address**, **Password**,
    **Pin**, and **Custom**.
  prefs: []
  type: TYPE_NORMAL
- en: The **Standard** option allows any character to be entered. Note, however, that
    characters not available for the entered text’s font will not display.
  prefs: []
  type: TYPE_NORMAL
- en: The **Autocorrected** option works like the **Standard** option, but on devices
    with onscreen keyboards (particularly touchscreen keyboards), it allows the device’s
    autocorrect functionality to automatically override words based on its own autocorrecting
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: The **Integer Number** option allows only integer values (positive and negative
    numbers without decimals). The player will be restricted from entering more than
    one negative symbol. The **Decimal Number** option works similarly, except that
    it also accepts decimal points. The player will be restricted from entering more
    than one decimal point. On devices with onscreen keyboards (particularly mobile
    devices), the numeric keyboard will appear rather than the standard keyboard with
    these two options.
  prefs: []
  type: TYPE_NORMAL
- en: The **Alphanumeric** option only allows letters (uppercase and lowercase) along
    with numbers and input. Mathematical symbols and punctuation, including negative
    numbers and decimal points (periods), are not accepted.
  prefs: []
  type: TYPE_NORMAL
- en: The **Name** option will automatically capitalize each new word entered within
    the field. The player has the option to lowercase the first letter of a word by
    deleting the letter and re-entering it in lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: The **Email Address** option will allow the player to enter an email address.
    It will also restrict the player from entering more than one @ symbol or two consecutive
    periods (dots/decimals).
  prefs: []
  type: TYPE_NORMAL
- en: The **Password** option allows letters, numbers, spaces, and symbols entered
    in the field. When the player enters text into a **Password** Input Field, the
    entered text will be hidden from view and displayed as asterisks (*****).
  prefs: []
  type: TYPE_NORMAL
- en: The **Pin** option allows only integer numbers (no decimals) to be entered.
    Negative numbers are accepted. The text entered by the player in a field with
    the **Pin Content Type** will be hidden in the same way the **Password** option
    hides the player input. On an onscreen keyboard device, the numeric keyboard will
    be displayed with the **Pin** option.
  prefs: []
  type: TYPE_NORMAL
- en: The final option, **Custom**, gives you the most control of the type of input.
    When selected, new properties appear in the **Inspector** allowing you to select
    the **Line Type**, **Input Type**, **Keyboard Type**, and **Character Validation**.
  prefs: []
  type: TYPE_NORMAL
- en: Line Types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The **Line Type** option is available with the **Standard**, **Autocorrect**,
    and **Custom** options for **Content Type**. There are three **Line Type** options:
    **Single Line**, **Multi Line Submit**, and **Multi Line New Line.** All other
    **Content Types** are automatically restricted to **Single Line** types. If the
    player is allowed to enter more text than the Input Field’s visible area can display
    (meaning the **Character Limit** property does not restrict it to the visible
    space), the text will scroll based on the **Line** **Type** selected.'
  prefs: []
  type: TYPE_NORMAL
- en: The **Single Line** option only allows the entered text to be displayed on one
    line. If the text exceeds the visible horizontal space, the text will scroll horizontally.
    If the player hits the *Enter* key, the Input Field acts as if the text has been
    submitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Multi Line Submit** and **Multi Line New Line** options allow the text
    to overflow vertically if it exceeds the visible horizontal space and scroll vertically
    if the text exceeds the visible vertical space. The difference between the two
    options is what happens when the *Enter* key is hit: **Multi Line Submit** will
    submit the text and **Multi Line New Line** will start a new line.'
  prefs: []
  type: TYPE_NORMAL
- en: Input Types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When the **Custom Content Type** is selected, you have the option to select
    from three Input Types: **Standard**, **Autocorrect**, and **Password**.'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting these various **Input Types** does not change the keyboard or provide
    any validation, like the similarly named **Content Types**. For example, the **Password
    Input Type** will accept the *Enter* key as a new line with **Multi Line New Line**
    and display it as an asterisk in the field but accept it as a new line in the
    actual data stored in the **Text** property.
  prefs: []
  type: TYPE_NORMAL
- en: The **Standard** option does not put any special circumstances on the type of
    input.
  prefs: []
  type: TYPE_NORMAL
- en: The **Autocorrect** option applies to platforms with onscreen keyboards that
    have built-in autocorrect functionality. This option allows the device’s autocorrect
    to change the text as it sees fit.
  prefs: []
  type: TYPE_NORMAL
- en: The **Password** option will display the text as asterisks.
  prefs: []
  type: TYPE_NORMAL
- en: Keyboard Types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the **Custom Content Type** is selected, you have the option to select
    **Keyboard Types**. On devices with onscreen keyboards, this property allows you
    to select which keyboard will display when the Input Field is selected.
  prefs: []
  type: TYPE_NORMAL
- en: The possible options are **Default**, **ASCII Capable**, **Numbers And Punctuation**,
    **URL**, **Number Pad**, **Phone Pad**, **Name Phone Pad**, **Email Address**,
    **Social**, **Search**, **Decimal Pad**, and **One** **Time Code**.
  prefs: []
  type: TYPE_NORMAL
- en: If the keyboard selected is not available on the target device, the device’s
    default keyboard will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The **Default** option displays the device’s default (letters) keyboard. On
    most devices, this keyboard only displays letters, the *Space* key, *Backspace*
    key, and *Return* (*Enter*) key. When this option is selected, the player will
    have the ability to switch to the keyboard with numbers and punctuation keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the iOS English default keyboard and numbers and punctuation keyboard
    can easily be switched between, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.15: The iOS English default keyboard and numbers and punctuation
    keyboard](img/Figure_13.15_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.15: The iOS English default keyboard and numbers and punctuation
    keyboard'
  prefs: []
  type: TYPE_NORMAL
- en: The **ASCII Capable** option displays the device’s keyboard with standard ASCII
    keys. This option is available to restrict the keyboard to those of English and
    similar language keyboards. This keyboard is also a letters keyboard, and the
    option to switch to the numbers and punctuation keyboard is available. For example,
    the iOS ASCII keyboard is shown in the preceding diagram, as it is the same as
    the default English keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: The **Numbers And Punctuation** option opens the device’s numbers and punctuation
    keyboard with the option to switch to the “letters” keyboard. For example, the
    iOS numbers and punctuation keyboard is shown in the preceding diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **URL Keyboard** option brings up the device’s URL keyboard. This keyboard
    has a period (**.**) key, forward-slash (**/**) key, and **.com** key in place
    of the **Space** Key. For example, the following image shows the iOS URL keyboard
    and its numbers/punctuation form. Note that the URL keyboard’s numbers/punctuation
    form is not the same as the numbers and punctuation form that accompanies the
    default/ASCII keyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.16: The iOS URL keyboard and its numbers/punctuation form](img/Figure_13.16_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.16: The iOS URL keyboard and its numbers/punctuation form'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Number Pad** option displays the device’s keyboard with numbers (**0**-**9**)
    and (usually) a **Backspace** key. This keyboard is used for PINs, so it does
    not allow alternate characters. For example, the following image shows the iOS
    number pad keyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.17: The number pad keyboard](img/Figure_13.17_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.17: The number pad keyboard'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Phone Pad** option displays the device’s keyboard with the same keys
    as the number pad keyboard but also includes keys for the asterisk and hash sign
    (pound sign). For example, the following image shows the iOS phone pad keyboard
    and its symbol display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.18: The iOS phone pad keyboard and its symbol display](img/Figure_13.18_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.18: The iOS phone pad keyboard and its symbol display'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Name Phone Pad** option displays the device’s “letters” keyboard and
    can switch to the phone pad keyboard. For example, the following image shows the
    iOS name phone pad keyboard’s two views:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.19: The iOS name phone pad keyboard’s two views](img/Figure_13.19_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.19: The iOS name phone pad keyboard’s two views'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Email Address** option shows the device’s email keyboard. The email keyboard
    prominently displays the **@** key and the period (**.**) key as well as other
    common email address symbols. For example, the following image shows the iOS email
    keyboard and its numbers/punctuation form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.20: The iOS email keyboard and its numbers/punctuation form](img/Figure_13.20_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.20: The iOS email keyboard and its numbers/punctuation form'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Social Keyboard** option displays the device’s social keyboard. This
    keyboard prominently displays common social networking keys such as the **@**
    key and the **#** key. For example, the following image shows the iOS “Twitter”
    keyboard and its numbers/punctuation form. On the iOS device, this keyboard is
    specifically called the *Twitter keyboard*, but it displays on other social networking
    apps such as Instagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.21: The iOS Twitter keyboard](img/Figure_13.21_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.21: The iOS Twitter keyboard'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Search** option displays the web search keyboard. This keyboard prominently
    displays the space and period keys. For example, the following image shows the
    iOS web search keyboard and its numbers/punctuation form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.22: The iOS web search keyboard and its numbers/punctuation form](img/Figure_13.22_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.22: The iOS web search keyboard and its numbers/punctuation form'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can view a list of all the keyboard types available on iOS at [https://developer.apple.com/documentation/uikit/uikeyboardtype](https://developer.apple.com/documentation/uikit/uikeyboardtype).
  prefs: []
  type: TYPE_NORMAL
- en: You can view a list of all input types (not just keyboard, but they are included
    in the list) available on Android at [https://developer.android.com/reference/android/widget/TextView.xhtml#attr_android:inputType](https://developer.android.com/reference/android/widget/TextView.xhtml#attr_android:inputType).
  prefs: []
  type: TYPE_NORMAL
- en: Character Validation options
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the **Custom Content Type** is selected, you have the option to select
    which type of **Character Validation** you would like to use. This option restricts
    the type of characters that can be entered in the Input Field. If the player attempts
    to enter a character that does not meet the restrictions, no character will be
    inserted in the Input Field.
  prefs: []
  type: TYPE_NORMAL
- en: The possible options are **None**, **Integer**, **Decimal**, **URL**, **Alphanumeric**,
    **Name**, and **Email Address**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Character Validation** only checks each individual character being entered
    to see whether it is allowed within the field. It does not check the entire string
    to see whether the string itself is valid. For example, if **Email Address** is
    selected, it will not check whether it is actually in the format of an email address.
    That type of validation will have to be accomplished via code.'
  prefs: []
  type: TYPE_NORMAL
- en: The **None** option does not perform any character validations, allowing any
    character to be entered into the Input Field with any formatting.
  prefs: []
  type: TYPE_NORMAL
- en: The `0` through `9` and the dash (negative symbol). The input is further restricted
    to allowing the negative symbol only as the first character entered.
  prefs: []
  type: TYPE_NORMAL
- en: The **Decimal** option has the same restriction as the **Integer** option, but
    it also allows a single decimal point to be entered.
  prefs: []
  type: TYPE_NORMAL
- en: The **Alphanumeric** option only allows English letters (a through z) and the
    digits 0 through 9\. Capital and lowercase letters are permitted; the negative
    symbol and decimal point are not accepted.
  prefs: []
  type: TYPE_NORMAL
- en: The **Name** option allows characters typically found in names and provides
    formatting. It allows letters, spaces, and an apostrophe (‘). It also enforces
    capitalization of the first character in the string and every character that comes
    after a space. A space cannot follow an apostrophe, and a space cannot follow
    another space. Only one apostrophe is allowed in the string. The letters are not
    restricted to just a-z as with the **Alphanumeric** option. Any Unicode letter
    is permitted.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For a list of all allowable Unicode letters, check out the remarks on the **Char.IsLetter**
    method in .NET at [https://msdn.microsoft.com/en-us/library/system.char.isletter(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.char.isletter(v=vs.110).aspx).
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Email Address** option allows characters that are allowed within an email
    address and enforces a few formatting rules. It is significantly less restrictive
    in the types of characters that can be entered than the other validation options.
    The following characters are allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: Lowercase and capital English letters (a through z)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digits 0-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following punctuation marks and special symbols:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Symbol name** | **Character** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| at sign | @ |'
  prefs: []
  type: TYPE_TB
- en: '| dot/period | . |'
  prefs: []
  type: TYPE_TB
- en: '| question mark | ? |'
  prefs: []
  type: TYPE_TB
- en: '| exclamation point | ! |'
  prefs: []
  type: TYPE_TB
- en: '| hyphen | - |'
  prefs: []
  type: TYPE_TB
- en: '| underscore | _ |'
  prefs: []
  type: TYPE_TB
- en: '| apostrophe | ‘ |'
  prefs: []
  type: TYPE_TB
- en: '| backtick | ` |'
  prefs: []
  type: TYPE_TB
- en: '| tilde | ~ |'
  prefs: []
  type: TYPE_TB
- en: '| open and close braces | { and } |'
  prefs: []
  type: TYPE_TB
- en: '| vertical bar | &#124; |'
  prefs: []
  type: TYPE_TB
- en: '| caret | ^ |'
  prefs: []
  type: TYPE_TB
- en: '| asterisk | * |'
  prefs: []
  type: TYPE_TB
- en: '| plus sign | + |'
  prefs: []
  type: TYPE_TB
- en: '| equal sign | + |'
  prefs: []
  type: TYPE_TB
- en: '| forward slash | / |'
  prefs: []
  type: TYPE_TB
- en: '| hash sign/pound sign | # |'
  prefs: []
  type: TYPE_TB
- en: '| dollar sign | $ |'
  prefs: []
  type: TYPE_TB
- en: '| percent | % |'
  prefs: []
  type: TYPE_TB
- en: '| ampersand | & |'
  prefs: []
  type: TYPE_TB
- en: 'Table 13.1: Permitted special characters'
  prefs: []
  type: TYPE_NORMAL
- en: Spaces are not allowed, only one *@* symbol is allowed in the string, and a
    dot cannot follow another dot.
  prefs: []
  type: TYPE_NORMAL
- en: Even though a dot as the first character of an email address is not valid, the
    **Email Address Character Validation** option does not restrict it from being
    the first character entered in the Input Field.
  prefs: []
  type: TYPE_NORMAL
- en: Properties of the caret and selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `InputField Input Caret`. When the Input Field is selected, the caret becomes
    visible.
  prefs: []
  type: TYPE_NORMAL
- en: The properties discussed in this section affect the look of the caret as well
    as the look of text if it is selected (or highlighted) using the caret.
  prefs: []
  type: TYPE_NORMAL
- en: The `0.85`.
  prefs: []
  type: TYPE_NORMAL
- en: The `1`.
  prefs: []
  type: TYPE_NORMAL
- en: When the **Custom Caret Color** property is selected, a secondary property,
    **Caret Color**, becomes available. You then have the option to change the color
    of the caret. Unless **Custom Caret Color** is selected and the **Caret Color**
    is changed, the caret will be a dark grey color.
  prefs: []
  type: TYPE_NORMAL
- en: When the caret is dragged across characters within the Input Field, the characters
    will be selected (or highlighted). The **Selection Color** property determines
    the color of the selected text.
  prefs: []
  type: TYPE_NORMAL
- en: Input field default events – On Value Changed (String) and On End Edit (String)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Input Field component has two default events. The first default event is
    the **On Value Changed** Event, as seen in the **On Value Changed (String)** section
    of the Input Field component. This event will trigger whenever the text within
    the Input Field is changed. It accepts a string as an argument, and its use of
    the argument works in the same way as the **On Value Changed** events from UI
    components discussed earlier in this chapter. If you want to pass a parameter
    to the function, you can select the function from either the **Static Parameters**
    list or from the **Dynamic string** list, depending on how or if you want an argument
    passed to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.23: On Value Changed Events on Input Field Example in the Chapter13
    scene](img/Figure_13.23_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.23: On Value Changed Events on Input Field Example in the Chapter13
    scene'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to constantly check what the player is entering in the Input Field,
    you would use the third setup shown in the preceding image, which selects a function
    with a parameter from the **Dynamic** **string** list.
  prefs: []
  type: TYPE_NORMAL
- en: The second default event is the On End Edit event, as seen in the **On End Edit
    (String)** section of the Input Field component. This event fires whenever the
    player completes editing the text. This completion is confirmed by the player
    either clicking outside of the Input Field (so that the Input is no longer selected)
    or by submitting the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'It accepts a string as an argument. As with the other events discussed in this
    chapter, you can choose to pass no argument, a static argument, or a dynamic argument.
    The following screenshot shows the setup for all three options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.24: On End Edit Events on Input Field Example in the Chapter13
    Scene](img/Figure_13.24_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.24: On End Edit Events on Input Field Example in the Chapter13 Scene'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to have the On End Edit event called when the *Enter* key is hit,
    use either the **Single Line** or **Multi Line Submit** options for the **Line
    Type**.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve reviewed the UI Input Field, let’s review its counterpart, the
    Input Field – TextMeshPro.
  prefs: []
  type: TYPE_NORMAL
- en: Input Field - TextMeshPro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Input Field - TextMeshPro is very similar to the UI Input Field. When added
    to the scene, you’ll see it looks nearly identical, except that the placeholder
    text has a different font. The UI Input Field uses an Arial font by default, while
    the Input Field - TextMeshPro uses Liberation Sans.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a UI Input Field, select **+** | **UI** | **Input Field - TextMeshPro**.
    By default, Input Field - TextMeshPro GameObject has a child named Text Area,
    which has two children: a Placeholder and a Text object. You will observe that
    it is slightly different in setup than the UI Input Field.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Text Area GameObject contains a Rect Transform component and a Rect Mask
    2D component. The Text Area ensures that the text does not appear outside of a
    specified area, as shown by the highlighted area in the following image. If you
    wanted to change the size of this area, you would change the properties on the
    Rect Transform component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.25: The Text Area of the InputField - TextMeshPro](img/Figure_13.25_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.25: The Text Area of the InputField - TextMeshPro'
  prefs: []
  type: TYPE_NORMAL
- en: The Placeholder and Text children are simply Text - TextMeshPro objects. You
    can find more information about the Text - TextMeshPro objects in [*Chapter 10*](B18327_10.xhtml#_idTextAnchor236).
  prefs: []
  type: TYPE_NORMAL
- en: An Input Field - TextMeshPro GameObject contains an Image component. If you
    want to change the appearance of the input box, change the **Source Image** of
    the **Image** component on the InputField (TMP) parent.
  prefs: []
  type: TYPE_NORMAL
- en: TextMeshPro - Input Field component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The parent InputField (TMP) object has a **TextMeshPro – Input Field** component.
    It has all the properties common to the interactable UI objects, many of the same
    properties of the standard UI Input Field, and a few that are exclusive to Input
    Field - TextMeshPros. This section will not discuss the properties that Input
    Field - TextMeshPros share with UI Input Fields since they were discussed in the
    previous section, and we will only discuss those that are exclusive to it. You
    can see the properties in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.26: The TextMeshPro – Input Field component](img/Figure_13.26_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.26: The TextMeshPro – Input Field component'
  prefs: []
  type: TYPE_NORMAL
- en: The **Text Viewport** property is set to the Rect Transform of the area in which
    the entered text should be visible. The Rect Transform of Text Area child is assigned
    to this property, by default. As stated earlier, the Text Area child has a Rect
    Mask 2D component that stops text from becoming visible outside of the area defined
    by the Rect Transform component of the Text Area.
  prefs: []
  type: TYPE_NORMAL
- en: The **Text Component** property is set to the Text Mesh Pro UGUI component of
    the object in which the entered text should display. The TextMeshPro - Text object
    assigned to this property will determine the font and display settings of the
    entered text. The Text Mesh Pro UGUI component of the Text child is assigned to
    this property, by default.
  prefs: []
  type: TYPE_NORMAL
- en: The **Text Input Box** group can be expanded to display a large text input area.
    The **Text Input Box** property works the same way as the **Text** property on
    the Input Field component of UI Input Field objects. The text entered by the user
    will be stored here and can be accessed by code. This will store the actual text
    entered and not the formatted text. For example, if the text has been formatted
    to appear as asterisks (as with **Pin** and **Password Content Types**), the actual
    pin or password will be stored here rather than a string of asterisks.
  prefs: []
  type: TYPE_NORMAL
- en: Input Field settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Font Asset** property determines the font of the various texts displayed
    within the Input Field - TextMeshPro, and the **Point Size** property determines
    the size of the text. You’ll note that the Placeholder and Text children also
    have the **Font Asset** and **Point Size** properties on their Text Mesh Pro UGUI
    components. Changing the **Font Asset** and **Point Size** properties on the Input
    Field - TextMeshPro parent will also change the corresponding properties on the
    child objects.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the properties in this group are the ones included within the UI
    Input Field.
  prefs: []
  type: TYPE_NORMAL
- en: Control settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the **OnFocus - Select All** property is selected, when the Input Field -
    TextMeshPro is selected, all the text within the field will be highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: If the **Reset On DeActivation** property is selected, the caret will reset
    to the default position at the front of the text.
  prefs: []
  type: TYPE_NORMAL
- en: If the **Restore on ESC Key** property is selected, the text will reset back
    to the default when the *esc* key is hit. The default will be either an empty
    string or whatever is entered in the **Text Input Box** when the scene starts.
  prefs: []
  type: TYPE_NORMAL
- en: The **Rich Text** property means that any rich text tags to be accepted, and
    the **Allow Rich Text Editing** property allows the user to enter rich text tags
    within the field.
  prefs: []
  type: TYPE_NORMAL
- en: Input Field - TextMeshPro default events – On Select (String) and On Deselect
    (String)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Input Field - TextMeshPro has four default events: the **On Value Changed**
    Event, the **On End Edit** Event, the **On Select** Event, and the **On Deselect**
    Event, as shown in the **On Value Changed (String)**, **On End Edit (String)**,
    **On Select (String)**, and **On Deselect (****String)** sections.'
  prefs: []
  type: TYPE_NORMAL
- en: The first two events, the **On Value Changed** Event and the **On End Edit**
    Event are the same as those presented in the UI Input Field.
  prefs: []
  type: TYPE_NORMAL
- en: The third event is the **On Select** Event. This event fires whenever the Input
    Field - TextMeshPro is selected. The fourth event is the **On Deselect** Event.
    As you would expect, the event fires whenever the Input Field - TextMeshPro is
    deselected. It works similarly to the **On End Edit** event, except that it does
    not fire when the text is submitted.
  prefs: []
  type: TYPE_NORMAL
- en: As with the other events discussed in this chapter, you can choose to pass no
    argument, a static argument, or a dynamic argument to the **On Select** and **On**
    **Deselect** events.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve reviewed the various interactable components of the uGUI, let’s
    look at some examples of how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has so many new items in it that I could spend the rest of this
    book just showing you examples! Sadly, I can’t do that, so I will show you examples
    that I hope will be the most useful. Let’s begin.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dropdown menu with images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s continue working on our scene and create a dropdown menu that will allow
    us to swap our player character between a cat and a dog. The final version will
    appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.27: The final version of the Paused Menu dropdown](img/Figure_13.27_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.27: The final version of the Paused Menu dropdown'
  prefs: []
  type: TYPE_NORMAL
- en: Changing our selection will then change the image of the character that appears
    at the top of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The spritesheet containing the dog image is an asset that I’ve modified from
    free art assets found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://opengameart.org/content/cat-dog-free-sprites](https://opengameart.org/content/cat-dog-free-sprites)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the same asset that provided us with the cat sprites.
  prefs: []
  type: TYPE_NORMAL
- en: When you want to see your UI Dropdown menu in play mode, you have to press *P*
    to bring up the `Pause Panel`. This can be kind of annoying when you just want
    to quickly check the layout. You can disable the automatic hiding of the `Pause
    Panel` momentarily by disabling the `ShowHidePanels.cs` script on the `Main Camera`.
    Just remember to turn it back on when you are done!
  prefs: []
  type: TYPE_NORMAL
- en: Laying out the dropdown with caption and item images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a UI Dropdown menu like the one shown in the previous image, complete
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate the `dogSprites.png` image provided in the source files of the text and
    bring it in to the `Assets/Sprites` folder of your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Slice the spritesheet by setting its **Sprite Mode** to **Multiple** and utilizing
    **Automatic** slicing. When you perform the **Automatic** slice, set the **Pivot**
    to **Bottom**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let’s add a UI Dropdown to our `Pause Panel`. Right-click on the `Pause
    Panel` in the `Dropdown` upward in the `Pause Banner`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Adjust the size and position of the **Dropdown** by setting its Rect Transform
    properties, as follows:![Figure 13.28: The Rect Transform of the Dropdown](img/Figure_13.28_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 13.28: The Rect Transform of the Dropdown'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Your Dropdown should now appear as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.29: The current state of the Dropdown](img/Figure_13.29_B18327.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 13.29: The current state of the Dropdown'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To change the Dropdown background, we need to change the `uiElements_12` subsprite
    into the `Arrow`. You can adjust the properties of `Arrow` to change its look
    and general position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Give the `Arrow` the `uiElements_132` sprite and adjust the Rect Transform,
    as illustrated:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.30: The Rect Transform of the Arrow](img/Figure_13.30_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.30: The Rect Transform of the Arrow'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Typing **132** in the search bar of the Project view is a quick way to find
    the **uiElements_132** image.
  prefs: []
  type: TYPE_NORMAL
- en: While the Dropdown component has a variable for a caption, the UI Dropdown template
    does not come prebuilt with one. So, we have to manually add one in ourselves.
    Right-click on `Dropdown` in the `Label`. Rename it `Caption`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Give `Caption` the `catSprites_0` sprite and adjust its Rect Transform, as
    follows:![Figure 13.31: The Rect Transform of the Caption](img/Figure_13.31_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 13.31: The Rect Transform of the Caption'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We’ve set it to the image of the cat so that we can see whether it is displaying
    properly but remember that it will automatically change to the appropriate sprite
    based on the selection.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, select `Label` and adjust its **Rect Transform** and **Text** components
    as shown:![Figure 13.32: The Rect Transform of the Label](img/Figure_13.32_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 13.32: The Rect Transform of the Label'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you try to adjust the **Text**, it will revert to Option A, since this is
    driven by the Dropdown component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have our caption set up the way we want it, let’s work on the Template.
    Enable the `Template` object so that you can see it in the scene and expand it
    in the `Scrollbar`, so we can leave it as it is. It will show up in the Scene
    view but will not be visible in Play mode, because its **Visibility** is set to
    **Auto Hide And Expand Viewport** in the Scroll Rect component of Template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To change the background of the window that drops down, change the `Template`
    to `uiElements_11`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Item` child shows the general format to all options that will be listed
    in our Dropdown. Any changes we make to it will be automatically applied to all
    options when the Dropdown script populates them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Item` and change its Rect Transform `50`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.33: The Rect Transform and Hierarchy of the Item](img/Figure_13.33_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.33: The Rect Transform and Hierarchy of the Item'
  prefs: []
  type: TYPE_NORMAL
- en: '`Content` needs to fully encapsulate the `Item`. So, change its Rect Transform
    `52`. Ensure that `0`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you played the game, the `Content` from `0` to something else. This is actually
    supposed to happen (`option A` is being set behind the caption), but it’s annoying
    when you are trying to lay out your `Item`, because you won’t be able to see your
    `Item`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Therefore, after playing, change `0` so that you can continue editing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Just as we had to add a child Image to `Dropdown` so we could have a caption
    image, we also have to add a child Image to `Item`, so we can have an image display
    in the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on `Item` in the `Image`. Rename it `Item Image` and move it between
    `Item Checkmark` and `Item Label` in the **Hierarchy**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Give `Item Image` the `catSprites_0` sprite and adjust its Rect Transform,
    as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.34: The Rect Transform and Hierarchy of the Item Image](img/Figure_13.34_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.34: The Rect Transform and Hierarchy of the Item Image'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select `Item Label` and adjust its **Rect Transform** and **Text** components,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.35: The Rect Transform of the Item Label](img/Figure_13.35_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.35: The Rect Transform of the Item Label'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to do to `Item` is to remove the white background. Select `Item
    Background` and change the `0`. Your Dropdown menu should now look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.36: The current state of the dropdown](img/Figure_13.36_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.36: The current state of the dropdown'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have set up our Dropdown visually, we need to set up the properties
    of the Dropdown component. If you play the game, you will see that our Dropdown
    doesn’t have the correct options yet. You can’t tell from playing it, but **Caption
    Image** and **Item Image** also aren’t hooked up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.37: The current state of the dropdown when pressing Play](img/Figure_13.37_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.37: The current state of the dropdown when pressing Play'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s update the Dropdown component on `Dropdown`. Drag the `Caption` child
    from the Hierarchy into the `Item Image` into the `Caption` into **Caption Image**,
    the image of the cat will disappear from the scene. Don’t worry! It will come
    back. It’s updating to the image of **Option A**, which is set to nothing right
    now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last thing we need to set up is the set of options that will display in
    the menu that drops down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We only need two options, so select `Option A` to `Cat` and the text `Option
    B` to `Dog`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Drag `catSprites_0` into the sprite slot under `Cat` and `dogSprites_0` into
    the sprite slot under `Dog`. Your Dropdown component properties should appear,
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.38: The properties of the Dropdown component](img/Figure_13.38_B18327.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 13.38: The properties of the Dropdown component'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you play the game, you will see that the dropdown now shows the appropriate
    list of options and the caption image and text update based on your selection:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.39: The final visual set up of the dropdown options](img/Figure_13.39_B18327.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 13.39: The final visual set up of the dropdown options'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the information from the dropdown selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that our Dropdown looks the way we want it and is functioning properly,
    we can access the player’s selection with code. We’ll use the player’s selection
    to update the player character image in the top-left corner of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'To swap the player character image with the selection from the Dropdown, complete
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new C# script in your `Assets/Scripts` folder named `PlayerCharacterSwap.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For us to access UI variable types, add the `UnityEngine.UI` namespace to the
    top of the script with the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We only need two variables, one to represent the Image that will be swapped
    with the selection from the **Dropdown** menu and one to represent the **Dropdown**
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We’ll attach this script to the Dropdown object, so we don’t have to make the
    variable referencing it public. Add the following variable declarations after
    the namespace declarations:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the `dropDown` variable in an `Awake()` method with the Dropdown
    component attached to the object this script will be attached to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The default event on the Dropdown component is the **On Value Changed** event,
    and it accepts an integer argument. Create a public function that accepts an integer
    parameter with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `DropDownSelection` method will get the integer value of the `selectionIndex`
    parameter within our script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following two lines to your `DropDownSelection` function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first line will find the text on the option at the specified index in the
    options list and print it to the console.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The second line will find the sprite on the option at the specified index in
    the options list and change the sprite on the `characterImage` to that sprite.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We’re now done with the script and can hook it up in the Unity Editor. Drag
    the `PlayerCharacterSwap.cs` script onto `Dropdown` to attach it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember, the `dropDown` variable is not public, because we expected to attach
    this script as a component to the `Dropdown`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The public variable `characterImage` needs to be assigned in the Inspector.
    Drag the `Character Image` from the **Left Panel** | **Character Holder** | **Character**)
    to the **Character Image** slot on the **Player Character** **Swap** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we need to call the **DropDownSelection** function on the **PlayerCharacterSwap.cs**
    script from the **On Value Changed** event on the Dropdown component. Select the
    plus sign (**+**) in the **On Value Changed (Int32)** event list to add a new
    **On Value Changed** event. Drag **Dropdown** from the **Heirarchy** into the
    object slot and select the **DropDownSelection** function from the **Dynamic int**
    list of the **PlayerCharacterSwap** script. The **On Value Changed (Int32)** event
    list should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.40: The On Value Changed (Int32) property](img/Figure_13.40_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.40: The On Value Changed (Int32) property'
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s it! Now play the game and watch the player character’s image swap with
    the image selected from the Dropdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.41: The final version of the scene](img/Figure_13.41_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.41: The final version of the scene'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 13**.41* shows the final version of the scene of the game.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Who knew there were so many different types of interactable UI objects? Having
    templates for these different UI objects is incredibly helpful. Technically, they
    can all be built *by hand* with Buttons, Images, and Text, but that would take
    a lot of effort you don’t have to worry about because Unity has done it for you.
    In this chapter, we reviewed how to use the common UI elements: Toggle, Slider,
    Dropdown, and Input Field.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will cover using animations within the UI!
  prefs: []
  type: TYPE_NORMAL
