- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Packaging and Deployment
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包和部署
- en: Now that we have completed the development and testing of our application, it
    is time to release it to the world! We will need to package and deploy it in order
    to distribute it to (millions of) users worldwide.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了应用程序的开发和测试，是时候将其发布到世界上了！我们需要打包和部署它，以便将其分发到（数百万）全球用户。
- en: Each platform (such as Windows, macOS, and Linux) has its own approach to distributing
    applications. Since .NET 8 is cross-platform, we can distribute Bookmarkr to even
    more users, no matter what platform they are using.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 每个平台（如 Windows、macOS 和 Linux）都有自己的应用程序分发方法。由于 .NET 8 是跨平台的，我们可以将 Bookmarkr 分发给更多用户，无论他们使用什么平台。
- en: However, before we package and distribute the application, it is important that
    we test it on every target platform.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们打包和分发应用程序之前，确保我们在每个目标平台上对其进行测试是很重要的。
- en: 'In this chapter, we will explore different packaging and deployment techniques
    that will help us achieve this goal. More specifically, we will do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨不同的打包和部署技术，这些技术将帮助我们实现这一目标。具体来说，我们将做以下几件事：
- en: Explore the different options when it comes to packaging and distributing a
    CLI application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索打包和分发 CLI 应用程序的不同选项
- en: Learn how to package and distribute a cross-platform CLI application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何打包和分发跨平台 CLI 应用程序
- en: Learn how to deploy that CLI application to multiple platforms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何将 CLI 应用程序部署到多个平台
- en: Learn how to manage versions of a distributed application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何管理分布式应用程序的版本
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found in the GitHub repository accompanying
    this book, [https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter11](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter11).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书配套的 GitHub 仓库中找到，[https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter11](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter11)。
- en: A bit of terminology
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些术语
- en: 'Throughout this chapter, you will come across the terms “packaging,” “distribution,”
    and “deployment.” For those of you who are not familiar with these terms, here
    is a brief definition of each:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将遇到“打包”、“分发”和“部署”这些术语。对于那些不熟悉这些术语的人来说，以下是每个术语的简要定义：
- en: '**Packaging**: Packaging refers to the process of preparing the application
    for release. This includes bundling all necessary files, libraries, and resources
    into a single unit that can be easily installed or executed by our users. Effective
    packaging ensures that the application is compatible with various environments
    and simplifies the installation process. It often involves creating installers
    or archives that streamline the deployment of the application.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打包**：打包是指为发布准备应用程序的过程。这包括将所有必要的文件、库和资源捆绑成一个单元，以便我们的用户可以轻松安装或执行。有效的打包确保应用程序与各种环境兼容，并简化了安装过程。这通常涉及创建安装程序或存档，以简化应用程序的部署。'
- en: '`apt-get` repositories). The goal of distribution is to make the application
    accessible to its intended audience while ensuring that it reaches them in a secure
    and efficient manner.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (`apt-get` 仓库）。分发的目标是使应用程序对其目标受众可访问，同时确保以安全高效的方式到达他们。
- en: '**Deployment**: Deployment is the mechanism by which the distributed application
    is installed and made operational on the user’s computer. This can involve configuring
    settings, integrating with existing systems, and ensuring that all components
    work appropriately. Deployment can be done manually or can be automated through
    various tools and scripts. The aim is to allow users to access and utilize the
    application effectively.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署**：部署是通过在用户的计算机上安装和使分布式应用程序运行的操作机制。这可能涉及配置设置、与现有系统集成以及确保所有组件适当工作。部署可以是手动进行的，也可以通过各种工具和脚本自动化。目标是使用户能够有效地访问和使用应用程序。'
- en: 'As you may have figured out, making an application (including a CLI application)
    available to a user is a three-step process that can be summarized by this diagram:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想，使应用程序（包括 CLI 应用程序）可供用户使用是一个三步过程，可以用以下图表来概括：
- en: '![Figure 11.1 – The process of making an application available to users](img/B22400_11_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – 使应用程序可供用户使用的流程](img/B22400_11_01.jpg)'
- en: Figure 11.1 – The process of making an application available to users
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 使应用程序可供用户使用的流程
- en: Now that we understand the terminology, let’s start by exploring the available
    options when it comes to the packaging, distribution, and deployment of a CLI
    application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了术语，让我们首先探讨在打包、分发和部署 CLI 应用程序时可供选择的各种选项。
- en: Packaging and distribution options for CLI applications
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CLI 应用程序的打包和分发选项
- en: When it comes to packaging a CLI application, several methods exist, and choosing
    the most appropriate one depends on the way we intend to distribute it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到打包 CLI 应用程序时，存在几种方法，选择最合适的方法取决于我们打算如何分发它。
- en: 'The most common options are as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的选项如下：
- en: '**MSI installer**: This option allows for a more traditional installation experience
    and can be achieved using tools such as WiX or Visual Studio Installer Projects.
    Keep in mind that this option only works for Windows. Hence, if we intend to distribute
    our CLI application to multiple platforms, this option may not be the best one.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MSI 安装程序**：此选项允许您获得更传统的安装体验，可以使用 WiX 或 Visual Studio 安装程序项目等工具实现。请注意，此选项仅适用于
    Windows。因此，如果我们打算将我们的 CLI 应用程序分发到多个平台，此选项可能不是最佳选择。'
- en: '`dotnet tool install` command. Since our CLI application is built using a version
    of .NET that is cross-platform, we can distribute it as a .NET tool to various
    platforms. The downside of this approach is in the installation mechanism: it
    requires the .NET CLI. This is great if our audience is developers or IT professionals
    but not that appropriate otherwise. We should only consider this approach if our
    CLI application is a developer or IT administrator tool, which is not the case
    with our bookmark management application.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet tool install` 命令。由于我们的 CLI 应用程序是使用跨平台版本的 .NET 构建的，我们可以将其作为 .NET 工具分发到各种平台。这种方法的缺点在于安装机制：它需要
    .NET CLI。如果我们的受众是开发人员或 IT 专业人员，这很好，但如果不合适，则不太适用。我们只有在 CLI 应用程序是开发人员或 IT 管理员工具的情况下才应考虑这种方法，而我们的书签管理应用程序并非如此。'
- en: '**Docker container**: This is also a great option for multiplatform distribution.
    A noticeable advantage of a Docker container is that it has a lower footprint
    on the local machine since no local installation is performed and limited access
    to the system is required. A Docker container is a self-contained file. However,
    as with the .NET tool option, this option mainly targets developers or IT administrators
    since users need to have knowledge of using Docker in order to deploy our application.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 容器**：这也是多平台分发的绝佳选择。Docker 容器的一个明显优势是它在本地机器上的占用空间更小，因为不需要进行本地安装，并且对系统的访问有限。Docker
    容器是一个自包含的文件。然而，与 .NET 工具选项一样，此选项主要针对开发人员或 IT 管理员，因为用户需要了解如何使用 Docker 才能部署我们的应用程序。'
- en: '`apt-get` package manager, while macOS provides Homebrew and Windows provides
    WinGet. These options are great since users of each platform are familiar with
    them no matter their technical knowledge. This means that these distribution mechanisms
    don’t just target developers and IT administrators but everyone! Once again, since
    our CLI application is built with cross-platform technology (.NET), we can use
    the same code and package it for distribution on each of these platforms.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apt-get` 软件包管理器，macOS 提供了 Homebrew，Windows 提供了 WinGet。这些选项很棒，因为每个平台的用户都熟悉它们，无论他们的技术知识如何。这意味着这些分发机制不仅针对开发人员和
    IT 管理员，而且针对所有人！再次强调，由于我们的 CLI 应用程序是用跨平台技术 (.NET) 构建的，我们可以使用相同的代码并将它打包以在每个这些平台上分发。'
- en: 'As you can see, several packaging and distribution options are provided to
    us, and you can use whichever best suits your situation. In this chapter, we will
    explore the last three packaging and distribution options: .NET tool, Docker container,
    and WinGet (as a platform-specific packaging option).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们提供了多种打包和分发选项，您可以使用最适合您情况的选项。在本章中，我们将探讨最后三个打包和分发选项：.NET 工具、Docker 容器和
    WinGet（作为特定平台的打包选项）。
- en: Let’s get started!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Packaging and distributing a CLI application
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包和分发 CLI 应用程序
- en: In this section, we will explore the subtleties of packaging and distributing
    our application, Bookmarkr, using three different options. We will take this opportunity
    to explain when each approach is most appropriate.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨使用三种不同的选项打包和分发我们的应用程序，Bookmarkr 的细微差别。我们将借此机会解释每种方法何时最合适。
- en: 'Option #1 – as a .NET tool'
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '选项 #1 – 作为 .NET 工具'
- en: By packaging and distributing our application as a .NET tool, our users will
    be able to install it using the .NET CLI. It is, however, important that users
    ensure they have the appropriate .NET version installed to avoid version mismatches,
    which may cause unexpected behaviors in the application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们的应用程序作为 .NET 工具打包和分发，我们的用户将能够使用 .NET CLI 安装它。然而，重要的是用户要确保他们已安装适当的 .NET
    版本，以避免版本不匹配，这可能导致应用程序中出现意外的行为。
- en: Step 1 – packaging
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 1 步 – 打包
- en: 'The first step is to modify the `.csproj` file to add properties that indicate
    that it should be packaged as a tool. These properties should be added to the
    `<``PropertyGroup>` section:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是修改 `.csproj` 文件，添加表示它应被打包为工具的属性。这些属性应添加到 `<PropertyGroup>` 部分：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s explain what we have just added here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释我们刚刚添加的内容：
- en: '`PackageId`: This represents the unique identifier for our package.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PackageId`: 这代表我们包的唯一标识符。'
- en: '`Version`: This indicates the version of our package. We will need to change
    this value when we need to package a newer version.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Version`: 这表示我们包的版本。当我们需要打包新版本时，我们需要更改此值。'
- en: '`Authors`: This represents the author (or the list of authors) of a package.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Authors`: 这代表包的作者（或作者列表）。'
- en: '`Description`: This provides a brief description of what the application does.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Description`: 这提供了应用程序的简要描述。'
- en: '`PackAsTool`: Set to `true`, this indicates that the application should be
    packaged as a .NET tool.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PackAsTool`: 设置为 `true`，表示应用程序应被打包为 .NET 工具。'
- en: '`ToolCommandName`: This is the name of the command users will type into their
    terminal to execute our application.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ToolCommandName`: 这是用户将在他们的终端中输入以执行我们的应用程序的命令名称。'
- en: '`PackageOutputPath`: Since a .NET tool is packaged as a NuGet package, an `.nupkg`
    file is then generated. This property indicates where this file will be generated.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PackageOutputPath`: 由于 .NET 工具被打包为 NuGet 包，因此将生成一个 `.nupkg` 文件。此属性表示此文件将在何处生成。'
- en: '`PackageLicenseExpression`: I chose to provide the code as an MIT license since
    it is a permissive license that allows for the reuse of the code in any project
    as long as the original copyright notice and license are included in all copies
    or substantial portions of the software.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PackageLicenseExpression`: 我选择提供 MIT 许可的代码，因为它是一种允许在任何项目中重用代码的许可，只要在所有副本或软件的实质性部分中包含原始版权声明和许可即可。'
- en: '`PackageReadmeFile`: This points to a Markdown file in which we explain the
    purpose of the application, how to get started using it, and a link to its documentation,
    among other things. The content of this Markdown file will be displayed on the
    package page on the NuGet site for the user to read. You will find that file in
    the code repository.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PackageReadmeFile`: 这指向一个 Markdown 文件，其中我们解释了应用程序的目的、如何开始使用它以及指向其文档的链接等。此
    Markdown 文件的内容将在 NuGet 网站上的包页面上显示供用户阅读。您将在代码存储库中找到该文件。'
- en: '`Copyright`: This presents the copyright details of the application.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Copyright`: 这展示了应用程序的版权详情。'
- en: '`PackageProjectUrl`: This points to the home page of the project’s website.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PackageProjectUrl`: 这指向项目网站的首页。'
- en: '`RepositoryUrl`: This points to the repository where the application’s code
    resides.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RepositoryUrl`: 这指向应用程序代码所在的存储库。'
- en: '`PackageTags`: This presents a semicolon-delimited list of keywords that can
    be used when searching for packages.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PackageTags`: 这展示了一个分号分隔的关键词列表，可以在搜索包时使用。'
- en: 'To specify the location and how to treat the `README.md` file, we need to add
    the following XML code to the `.``csproj` file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指定 `README.md` 文件的位置和如何处理它，我们需要将以下 XML 代码添加到 `.csproj` 文件中：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The second step is to package the application. This is achieved by running
    this command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是打包应用程序。这是通过运行以下命令来实现的：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Remember that it will be generated at the location indicated by the value of
    the `PackageOutputPath` property.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，它将在 `PackageOutputPath` 属性的值所指示的位置生成。
- en: Our package is now ready for distribution.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的包现在已准备好分发。
- en: Step 2 – distribution
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 2 步 – 分发
- en: The most common way to distribute a .NET tool is to provide it through the NuGet
    site, located at [https://www.nuget.org](https://www.nuget.org).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 分发 .NET 工具最常见的方式是通过位于 [https://www.nuget.org](https://www.nuget.org) 的 NuGet
    网站。
- en: 'So, let’s head to the NuGet site and click on the **Sign in** link in the top-right
    corner of the page:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们前往 NuGet 网站，并点击页面右上角的 **Sign in** 链接：
- en: '![Figure 11.2 – Signing in to the NuGet site](img/B22400_11_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – 登录到 NuGet 网站](img/B22400_11_02.jpg)'
- en: Figure 11.2 – Signing in to the NuGet site
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 登录到 NuGet 网站
- en: 'I will be signing in with my personal account and granting the required permissions
    to the NuGet site, as shown here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用我的个人账户登录并授予 NuGet 网站所需的权限，如下所示：
- en: '![Figure 11.3 – Granting required permissions to the NuGet site](img/B22400_11_03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 授予 NuGet 网站所需的权限](img/B22400_11_03.jpg)'
- en: Figure 11.3 – Granting required permissions to the NuGet site
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 授予 NuGet 网站所需的权限
- en: 'Since this is the first time I have signed in with this account, the NuGet
    site asks me to provide a username:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是我第一次使用此账户登录，NuGet 网站要求我提供一个用户名：
- en: '![Figure 11.4 – Choosing a username for the NuGet site](img/B22400_11_04.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – 为 NuGet 网站选择用户名](img/B22400_11_04.jpg)'
- en: Figure 11.4 – Choosing a username for the NuGet site
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 为 NuGet 网站选择用户名
- en: 'And that’s it! As a publisher of NuGet packages, I am now all set, and I can
    start uploading my packages:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！作为 NuGet 包的发布者，我现在已经设置完毕，可以开始上传我的包：
- en: '![Figure 11.5 – All set as a NuGet package publisher](img/B22400_11_05.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – 作为 NuGet 包发布者已设置完毕](img/B22400_11_05.jpg)'
- en: Figure 11.5 – All set as a NuGet package publisher
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 作为 NuGet 包发布者已设置完毕
- en: Let’s now upload our package!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来上传我们的包！
- en: 'All we need to do is to click on `.nupkg` file we generated earlier. The package
    is then analyzed and the validation results are presented:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是点击我们之前生成的 `.nupkg` 文件。然后包将被分析，并显示验证结果：
- en: '![Figure 11.6 – Uploading a package to the NuGet website](img/B22400_11_06.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6 – 上传包到 NuGet 网站](img/B22400_11_06.jpg)'
- en: Figure 11.6 – Uploading a package to the NuGet website
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – 上传包到 NuGet 网站
- en: Since our package is valid, we can submit it by clicking the **Submit** button
    at the bottom of the page.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的包是有效的，我们可以通过点击页面底部的 **提交** 按钮来提交它。
- en: 'Once uploaded, it usually takes around 15 minutes (but can sometimes take up
    to an hour) for the package to be validated and indexed before it appears in search
    results:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 上传后，通常需要大约 15 分钟（但有时可能需要长达一小时）的时间来验证和索引包，然后它才会出现在搜索结果中：
- en: '![Figure 11.7 – Package awaiting validation and indexing](img/B22400_11_07.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7 – 等待验证和索引的包](img/B22400_11_07.jpg)'
- en: Figure 11.7 – Package awaiting validation and indexing
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – 等待验证和索引的包
- en: 'Once the package validation and indexing have been completed, it will appear
    on the NuGet website just as any other NuGet package:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦包验证和索引完成，它将像任何其他 NuGet 包一样出现在 NuGet 网站上：
- en: '![Figure 11.8 – Bookmarkr is available on the NuGet website!](img/B22400_11_08.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.8 – Bookmarkr 可在 NuGet 网站上找到！](img/B22400_11_08.jpg)'
- en: Figure 11.8 – Bookmarkr is available on the NuGet website!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 – Bookmarkr 可在 NuGet 网站上找到！
- en: Now that our application can be found by users, let’s see how it can be deployed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序可以被用户找到，让我们看看它是如何被部署的。
- en: Step 3 – deployment
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 3 步 – 部署
- en: 'A user can deploy (that is, install) our application on their machine very
    easily by typing this command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过输入以下命令非常容易地在他们的机器上部署（即安装）我们的应用程序：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After the installation is complete, the user can execute our application by
    typing this command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，用户可以通过输入以下命令来执行我们的应用程序：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And that’s it! We’ve packaged, distributed, and deployed Bookmarkr as a .NET
    tool.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们已经打包、分发和部署了 Bookmarkr 作为 .NET 工具。
- en: Let’s now see how we can deliver Bookmarkr to our users as a Docker container.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何将 Bookmarkr 作为 Docker 容器交付给我们的用户。
- en: 'Option #2 – as a Docker container'
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '选项 #2 – 作为 Docker 容器'
- en: Packaging and distributing our application as a Docker container allows our
    users to install and use our application by reducing the footprint of the application
    on their environment (i.e., operating system and data).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的应用程序打包并作为 Docker 容器分发，允许用户通过减少应用程序在他们的环境（即操作系统和数据）中的占用，来安装和使用我们的应用程序。
- en: Step 1 – packaging
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 1 步 – 打包
- en: If you are familiar with containers, you may already know that in order to create
    a container image, a Dockerfile is required.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉容器，你可能已经知道，为了创建容器镜像，需要一个 Dockerfile。
- en: 'A Dockerfile is a file with no extension that should be located at the root
    of the project directory. For our application, its content is the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 是一个没有扩展名的文件，应该位于项目目录的根目录。对于我们的应用程序，其内容如下：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In essence, this file instructs Docker to build and publish the application
    (the first six lines of it), and then to build a container image out of the published
    application (the remaining five lines).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，此文件指示 Docker 构建并发布应用程序（其前六行），然后从发布的应用程序构建容器镜像（剩余的五行）。
- en: Before we run the command to actually build the image, we need to ensure that
    both Docker Desktop and **Windows Subsystem for Linux** (**WSL**) are installed
    and running. Note that Docker Desktop requires administrator privileges on the
    local machine.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行实际构建镜像的命令之前，我们需要确保Docker Desktop和**Windows子系统（WSL**）都已安装并正在运行。请注意，Docker
    Desktop需要在本地机器上具有管理员权限。
- en: 'Docker Desktop can be installed using the following command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令安装Docker Desktop：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'WSL can be installed using the following command (Windows needs to be rebooted
    after WSL is installed):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令安装WSL（安装WSL后，Windows需要重启）：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The command for building a Docker image is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Docker镜像的命令如下：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `-t bookmarkr` parameter is used to tag the Docker image to be generated
    with a name and an optional version number (more on that later).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`-t bookmarkr`参数用于标记要生成的Docker镜像，并带有名称和可选版本号（稍后会有更多介绍）。'
- en: The last dot character is neither a typo nor is it optional. It refers to what
    we call the **build context**. More specifically, it instructs Docker where to
    look for the Dockerfile, which, in this case, is the current directory.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个点字符既不是打字错误也不是可选的。它指的是我们所说的**构建上下文**。更具体地说，它指示Docker在哪里查找Dockerfile，在这种情况下，是当前目录。
- en: 'The operation should take about five minutes, and once it is complete, the
    Docker image will be created, and it can be retrieved by typing the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作大约需要五分钟，一旦完成，Docker镜像将被创建，可以通过输入以下内容来检索：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the container image has been generated on our local machine. We should,
    however, distribute it through a location that everyone can easily find.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，容器镜像已经在我们的本地机器上生成。然而，我们应该通过一个每个人都可以轻松找到的位置来分发它。
- en: Step 2 – distribution
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步 – 分发
- en: The most common way to distribute Docker images is through Docker Hub.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 分发Docker镜像最常见的方式是通过Docker Hub。
- en: To do that, we need to head to the Docker Hub portal, located at [https://hub.docker.com](https://hub.docker.com).
    If you don’t already have a Docker Hub account, you can create one from there.
    I already have such an account, and my username is `theAzurian`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要前往位于[https://hub.docker.com](https://hub.docker.com)的Docker Hub门户。如果您还没有Docker
    Hub账户，您可以从那里创建一个。我已经有一个这样的账户，我的用户名是`theAzurian`。
- en: So, let’s follow the steps to push our local Docker image to Docker Hub.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们按照步骤将我们的本地Docker镜像推送到Docker Hub。
- en: 'First, let’s log in to our Docker Hub account using this command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用以下命令登录到我们的Docker Hub账户：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I’m passing my `-p` parameter. This PAT was created through the Docker Hub portal.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在传递我的`-p`参数。这个PAT是通过Docker Hub门户创建的。
- en: 'Next, we need to tag the image to include the Docker Hub username of its author,
    the name of the application, and its version, such as the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要标记镜像以包含其作者的Docker Hub用户名、应用程序的名称及其版本，例如以下内容：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we need to push the tagged image to Docker Hub using this command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要使用以下命令将标记的镜像推送到Docker Hub：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can ensure that the image has effectively been pushed to Docker Hub by heading
    to the portal and looking for it in our Docker Hub profile:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过前往门户并在我们的Docker Hub个人资料中查找它来确保镜像已成功推送到Docker Hub：
- en: '![Figure 11.9 – Bookmarkr is available in the Docker Hub portal!](img/B22400_11_09.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图11.9 – Bookmarkr可在Docker Hub门户中找到！](img/B22400_11_09.jpg)'
- en: Figure 11.9 – Bookmarkr is available in the Docker Hub portal!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 – Bookmarkr可在Docker Hub门户中找到！
- en: 'We can also perform a search for it in the Docker Hub portal:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在Docker Hub门户中搜索它：
- en: '![Figure 11.10 – Searching for Bookmarkr in the Docker Hub portal](img/B22400_11_10.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图11.10 – 在Docker Hub门户中搜索Bookmarkr](img/B22400_11_10.jpg)'
- en: Figure 11.10 – Searching for Bookmarkr in the Docker Hub portal
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 – 在Docker Hub门户中搜索Bookmarkr
- en: Our application can now be found by our users. Let’s see how it can be deployed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在可以被我们的用户找到。让我们看看它是如何部署的。
- en: Step 3 – deployment
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步 – 部署
- en: In order for a user to run Docker on a Windows machine, they also need to have
    both Docker Desktop and WSL installed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让用户在Windows机器上运行Docker，他们还需要安装Docker Desktop和WSL。
- en: 'Docker Desktop can be installed using the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令安装Docker Desktop：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'WSL can be installed using the following command (Windows needs to be rebooted
    after WSL is installed):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令安装WSL（安装WSL后，Windows需要重启）：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, our user can obtain the application from Docker Hub by typing this command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的用户可以通过输入以下命令从Docker Hub获取应用程序：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'They can execute it by typing this command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 他们可以通过输入以下命令来执行它：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Bookmarkr can then be run on the user’s computer as a Docker container:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Bookmarkr 可以作为 Docker 容器在用户的计算机上运行：
- en: '![Figure 11.11 – Bookmarkr running as a Docker container](img/B22400_11_11.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.11 – Bookmarkr 作为 Docker 容器运行](img/B22400_11_11.jpg)'
- en: Figure 11.11 – Bookmarkr running as a Docker container
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11 – Bookmarkr 作为 Docker 容器运行
- en: And that’s it! We packaged, distributed, and deployed Bookmarkr as a Docker
    container.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们已经将 Bookmarkr 打包、分发和部署为 Docker 容器。
- en: Let’s now see how we can deliver Bookmarkr to our users as a WinGet package.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何将 Bookmarkr 作为 WinGet 包提供给我们的用户。
- en: 'Option #3 – as a WinGet package'
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '选项 #3 – 作为 WinGet 包'
- en: By packaging and distributing our application as a WinGet package, we allow
    our users to install it as any other application they have installed using WinGet,
    Microsoft’s package manager.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们的应用程序打包和分发为 WinGet 包，我们允许我们的用户像使用 WinGet 安装的任何其他应用程序一样安装它，Microsoft 的包管理器。
- en: Packaging
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打包
- en: To package a .NET CLI application for distribution through WinGet (the official
    Windows package manager), we first need to create a manifest file.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 .NET CLI 应用程序打包以通过 WinGet（官方 Windows 包管理器）分发，我们首先需要创建一个清单文件。
- en: Although it is possible to manually create and submit the manifest to the WinGet
    package repository on GitHub ([https://github.com/microsoft/winget-pkgs](https://github.com/microsoft/winget-pkgs)),
    the easiest way to do so is using the `WingetCreate` CLI.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以在 GitHub 的 WinGet 包存储库（[https://github.com/microsoft/winget-pkgs](https://github.com/microsoft/winget-pkgs)）上手动创建和提交清单，但最简单的方法是使用
    `WingetCreate` CLI。
- en: 'Let’s first install it using this command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先使用这个命令来安装它：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Before we create the new manifest, we first need to build our CLI application
    as a self-contained .NET application using this command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建新的清单之前，我们首先需要使用此命令将我们的 CLI 应用程序构建为一个自包含的 .NET 应用程序：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s take a closer look at this command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这个命令：
- en: '`-c Release`: Since this is a production-ready version of the application,
    we want to publish it using the Release configuration to ensure that it is optimized
    for performance.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-c Release`: 由于这是一个生产就绪版本的应用程序，我们希望使用 Release 配置来发布它，以确保其性能优化。'
- en: '`-r win-x64`: Since WinGet is the package manager for Windows (and Windows
    only), we specify the target runtime to be the 64-bit version of Windows.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-r win-x64`: 由于 WinGet 是 Windows（仅限 Windows）的包管理器，我们指定目标运行时为 Windows 的 64
    位版本。'
- en: '`-p:selfcontained=true`: A self-contained application already includes the
    .NET runtime, so the user’s machine doesn’t need to have it installed. The application
    will then carry everything it needs to run, including the runtime, libraries,
    and dependencies.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p:selfcontained=true`: 一个自包含的应用程序已经包含了 .NET 运行时，因此用户的机器不需要安装它。应用程序将携带运行所需的所有内容，包括运行时、库和依赖项。'
- en: '`-p:IncludeNativeLibrariesForSelfExtract=true`: This ensures that platform-specific
    libraries, along with unmanaged native libraries, are included in the published
    application. This is useful if we use some specific Serilog sinks and for the
    SQLite library.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p:IncludeNativeLibrariesForSelfExtract=true`: 这确保了平台特定的库，以及非托管的本机库，都包含在发布的应用程序中。如果我们使用一些特定的
    Serilog 沉淀物或 SQLite 库，这很有用。'
- en: '`-p:PublishSingleFile=true`: This instructs .NET to bundle everything (including
    the application code, the .NET runtime, and the dependencies) into a single executable
    file. While this makes it more convenient for distribution (because we are distributing
    a single file), it results in a file that is larger in size than framework-dependent
    publishing.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p:PublishSingleFile=true`: 这指示 .NET 将所有内容（包括应用程序代码、.NET 运行时和依赖项）打包成一个单独的可执行文件。虽然这使得分发更加方便（因为我们只分发一个文件），但生成的文件大小比框架依赖的发布文件要大。'
- en: The application will be generated in the `bin\Release\net8.0\win-x64\publish`
    directory.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将在 `bin\Release\net8.0\win-x64\publish` 目录中生成。
- en: Next, we will upload it to a location that should be accessible to the WinGet
    tool. It is common to pick a remote, publicly accessible, read-only location.
    I decided to use an Azure Storage account. Hence, the location of the executable
    will be [https://bookmarkr.blob.core.windows.net/releases/1.0.0/](https://bookmarkr.blob.core.windows.net/releases/1.0.0/).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将将其上传到一个 WinGet 工具可以访问的位置。通常会选择一个远程的、公开可访问的、只读位置。我决定使用 Azure 存储账户。因此，可执行文件的位置将是
    [https://bookmarkr.blob.core.windows.net/releases/1.0.0/](https://bookmarkr.blob.core.windows.net/releases/1.0.0/)。
- en: About GitHub releases
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 GitHub 发布
- en: If your application is built as an open source project on GitHub, you will likely
    make your executable versions available as releases. However, releases on GitHub
    follow certain guidelines that go way beyond the scope of this book. If this is
    a topic you are interested in, I recommend that you explore these guidelines by
    visiting [https://github.com/github/docs/blob/main/content/repositories/releasing-projects-on-github/about-releases.md](https://github.com/github/docs/blob/main/content/repositories/releasing-projects-on-github/about-releases.md).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序是在GitHub上作为开源项目构建的，您可能会将可执行版本作为发布版提供。然而，GitHub上的发布遵循某些指南，这些指南远远超出了本书的范围。如果您对此主题感兴趣，我建议您通过访问[https://github.com/github/docs/blob/main/content/repositories/releasing-projects-on-github/about-releases.md](https://github.com/github/docs/blob/main/content/repositories/releasing-projects-on-github/about-releases.md)来探索这些指南。
- en: 'Let’s now create our manifest files! We can do so using this command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在创建我们的清单文件！我们可以使用以下命令来完成：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The tool will ask a series of questions required to generate the manifest files.
    Here is an example of what it looks like:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 工具将询问生成清单文件所需的一系列问题。以下是一个示例：
- en: '![Figure 11.12 – Generating the WinGet manifest files](img/B22400_11_12.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图11.12 – 生成WinGet清单文件](img/B22400_11_12.jpg)'
- en: Figure 11.12 – Generating the WinGet manifest files
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12 – 生成WinGet清单文件
- en: 'There will be three files generated:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成三个文件：
- en: '**Version manifest (theAzurian.bookmarkr.yaml)**: Contains metadata about the
    specific version of the application being packaged.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本清单（theAzurian.bookmarkr.yaml）**：包含有关正在打包的应用程序特定版本的元数据。'
- en: '**Installer manifest (theAzurian.bookmarkr.installer.yaml)**: Details the installation
    specifics of the application.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安装程序清单（theAzurian.bookmarkr.installer.yaml）**：详细说明应用程序的安装细节。'
- en: '**Default locale manifest (theAzurian.bookmarkr.locale.en-CA.yaml)**: Defines
    localization settings for the application. It ensures that users receive a version
    of the application that is appropriately localized, enhancing user experience
    by presenting information in their preferred language.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认区域设置清单（theAzurian.bookmarkr.locale.en-CA.yaml）**：定义应用程序的区域设置。它确保用户接收到的应用程序版本是适当本地化的，通过以他们首选的语言呈现信息来增强用户体验。'
- en: 'I personally like to keep these files inside my Visual Studio project, inside
    the following folder structure that I create at the root of the project:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人喜欢将这些文件保存在我的Visual Studio项目中，在项目根目录下创建的以下文件夹结构中：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So, in our case, this folder structure will look like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的情况下，这个文件夹结构将看起来像这样：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Before we submit our manifest to the WinGet team, it is recommended that we
    test it locally to ensure that it works as expected. This is important as submitting
    our package could lead to a delay during the WinGet approval process if the manifest
    contains issues.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将清单提交给WinGet团队之前，建议我们在本地进行测试以确保其按预期工作。这很重要，因为如果清单中存在问题，提交我们的包可能会导致WinGet审批过程中的延迟。
- en: 'To do this, we first need to activate the ability to install applications from
    local manifests. This can be done by executing the following command in a terminal
    running as administrator:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们首先需要激活从本地清单安装应用程序的能力。这可以通过在以管理员身份运行的终端中执行以下命令来完成：
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we run this command, providing the path to the `manifests.json` file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们运行以下命令，提供`manifests.json`文件的路径：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As we can see, the application is installed and runs as expected:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，应用程序已安装并按预期运行：
- en: '![Figure 11.13 – Testing the WinGet package locally before submission](img/B22400_11_13.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图11.13 – 在提交前在本地测试WinGet包](img/B22400_11_13.jpg)'
- en: Figure 11.13 – Testing the WinGet package locally before submission
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13 – 在提交前在本地测试WinGet包
- en: We are now ready to submit our manifest to the WinGet team!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已准备好将我们的清单提交给WinGet团队！
- en: Submitting our manifest to the WinGet package repository requires us to generate
    a PAT for our GitHub account. We can do this using the `wingetcreate token` command,
    or we can skip this step and, when submitting the manifest, `wingetcreate` will
    prompt us to authenticate to our GitHub account. Let’s do it this way!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的清单提交到WinGet包存储库需要我们为我们的GitHub账户生成一个PAT。我们可以使用`wingetcreate token`命令来完成此操作，或者我们可以跳过此步骤，当提交清单时，`wingetcreate`将提示我们验证我们的GitHub账户。让我们这样操作吧！
- en: 'Let’s run the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行以下命令：
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will open the browser and take us to the GitHub sign-in page. We will
    have to log on to our account. Once done, we will need to provide the required
    authorization:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开浏览器并带我们到GitHub登录页面。我们将需要登录到我们的账户。一旦完成，我们需要提供所需的授权：
- en: '![Figure 11.14 – Authorizing WingetCreate for our GitHub account](img/B22400_11_14.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图11.14 – 授权WingetCreate对我们的GitHub账户](img/B22400_11_14.jpg)'
- en: Figure 11.14 – Authorizing WingetCreate for our GitHub account
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14 – 授权WingetCreate对我们的GitHub账户
- en: It will then take us to the Pull Request page where we can follow its progress.
    After about 30 minutes, the pull request is completed, and the package is available
    for our users to install.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它将带我们到拉取请求页面，我们可以跟踪其进度。大约30分钟后，拉取请求完成，该软件包可供我们的用户安装。
- en: 'Users can then install Bookmarkr using WinGet by typing this command:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过输入以下命令使用WinGet安装Bookmarkr：
- en: '[PRE25]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: And voilà! We have packaged, distributed, and deployed Bookmarkr as a WinGet
    package.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经将Bookmarkr打包、分发和部署为一个WinGet软件包。
- en: So, we have seen three different approaches to packaging, distributing, and
    deploying our application. But how do we manage multiple versions of that application?
    That’s what we are going to explore in the next section.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到了三种不同的打包、分发和部署我们应用程序的方法。但我们是怎样管理该应用程序的多个版本的呢？这就是我们将在下一节中要探讨的内容。
- en: Managing versions of the application
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理应用程序的版本
- en: All the options that we presented earlier provide version management mechanisms.
    Version management is as important as the packaging and distribution mechanism
    that we select.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提出的所有选项都提供了版本管理机制。版本管理与我们选择的打包和分发机制一样重要。
- en: As our application evolves and new features are added, modified, or removed,
    we want to offer a way for our users to consume these updates at their convenience.
    That is where versioning comes into play.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用程序发展和新功能的添加、修改或删除，我们希望为用户提供一种方便地消费这些更新的方式。这就是版本控制发挥作用的地方。
- en: Currently, only a single version of our application is distributed. We can hence
    install it by either omitting its version number or explicitly indicating it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只分发我们应用程序的一个版本。因此，我们可以通过省略其版本号或明确指出它来安装它。
- en: But what if we update the application? How can we distribute the new version?
    And what if the new version introduces a bug and we need to roll back to the previous
    version?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们更新了应用程序呢？我们如何分发新版本？而且如果新版本引入了错误，我们需要回滚到先前的版本怎么办？
- en: Let’s explore how we can achieve this for each of the distribution methods that
    we covered earlier.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索我们如何实现我们之前涵盖的每种分发方法。
- en: Semantic versioning primer
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语义版本控制入门
- en: Before we dive into managing different versions of an application, let us start
    by introducing **semantic versioning**.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨管理应用程序的不同版本之前，让我们首先介绍**语义版本控制**。
- en: If you are familiar with this approach to versioning applications, you know
    that it is probably the most common and widely adopted approach in the industry.
    If you haven’t heard about it before, let me give you a quick introduction. If
    you want to go deeper in your exploration of semantic versioning, I recommend
    that you visit its official website at [https://semver.org](https://semver.org).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉这种应用程序版本控制方法，你知道这可能是行业中最常见和最广泛采用的方法。如果你之前没有听说过它，让我给你做一个简要的介绍。如果你想更深入地探索语义版本控制，我建议你访问其官方网站[https://semver.org](https://semver.org)。
- en: 'In essence, semantic versioning expresses a version number using this format:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，语义版本控制使用以下格式来表示版本号：
- en: '[PRE26]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, we have the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有以下内容：
- en: '**Major**: Indicates that this version of the application contains breaking
    changes that are incompatible with the previous major version'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主要**：表示此版本的应用程序包含与之前主要版本不兼容的破坏性更改。'
- en: '**Minor**: Indicates that this version of the application only adds new functionalities
    that are backward compatible with the previous versions of the same major version'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**次要**：表示此版本的应用程序仅添加与之前相同主版本的先前版本向后兼容的新功能。'
- en: '**Patch**: Indicates that this version of the application contains bug fixes
    that are backward compatible with the previous versions of the same major version'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**补丁**：表示此版本的应用程序包含与之前相同主版本的先前版本向后兼容的错误修复。'
- en: Each part is represented as a number that is incremented with each new version.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分都表示为一个数字，每次新版本发布时都会递增。
- en: Now that we understand semantic versioning, let’s use it to manage different
    versions of our application.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了语义版本控制，让我们用它来管理我们应用程序的不同版本。
- en: Managing versions of a .NET tool
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理一个.NET工具的版本
- en: 'If you ran the version of Bookmarkr that we provided as a .NET tool, you will
    certainly have noticed that it returns the following error message:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行了我们提供的作为 .NET 工具的 Bookmarkr 版本，你肯定会注意到它返回以下错误信息：
- en: '![Figure 11.15 – Bookmarkr as a .NET tool fails to execute](img/B22400_11_15.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.15 – 将 Bookmarkr 作为 .NET 工具执行失败](img/B22400_11_15.jpg)'
- en: Figure 11.15 – Bookmarkr as a .NET tool fails to execute
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.15 – 将 Bookmarkr 作为 .NET 工具执行失败
- en: Let’s then fix the problem and distribute a new version.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们修复问题并分发新版本。
- en: The error comes from the fact that the `appsettings.json` file is not being
    made part of the package when the `dotnet pack` command is executed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 错误来自 `appsettings.json` 文件在执行 `dotnet pack` 命令时没有被包含在包中。
- en: 'Fortunately, fixing this problem is straightforward. Locate the following entry
    in the `.``csproj` file:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，修复这个问题很简单。在 `.csproj` 文件中找到以下条目：
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Replace it with the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下内容替换它：
- en: '[PRE28]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, since the new version we are about to package and distribute only provides
    a bug fix, we shall increment the patch number, so the version number looks like
    the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们即将打包和分发的这个新版本只提供错误修复，我们将增加补丁号，因此版本号看起来如下：
- en: '[PRE29]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We can now package and distribute the new version by following the same steps
    that we described earlier.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过遵循我们之前描述的相同步骤来打包和分发新版本。
- en: 'However, before we distribute it, it is recommended to test it locally using
    the following command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在分发之前，建议使用以下命令在本地进行测试：
- en: '[PRE30]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `--add-source` parameter allows us to specify a location from which the
    package will be deployed. Here, I am specifying the path where the NuGet package
    was generated on my local machine.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`--add-source` 参数允许我们指定一个位置，从该位置部署包。在这里，我指定了在本地机器上生成的 NuGet 包的路径。'
- en: After ensuring that this new version works successfully on the local machine,
    we can proceed with pushing it to the NuGet website.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在确保这个新版本在本地机器上成功运行后，我们可以继续将其推送到 NuGet 网站。
- en: 'Users can get a specific version of the tool by providing its version number
    as a parameter. In this case, this could be achieved by typing this command:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过提供版本号作为参数来获取工具的特定版本。在这种情况下，可以通过输入此命令来实现：
- en: '[PRE31]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Or, they can simply type the following command to get the latest version:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，他们可以简单地输入以下命令以获取最新版本：
- en: '[PRE32]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Once this command is executed, the previous version of the tool will be replaced
    by the new one.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行此命令，工具的旧版本将被新版本替换。
- en: 'By running the new version of the application, we can now see that the error
    is resolved:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行应用程序的新版本，我们现在可以看到错误已被解决：
- en: '![Figure 11.16 – Bookmarkr as a .NET tool running successfully](img/B22400_11_16.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.16 – 将 Bookmarkr 作为 .NET 工具成功运行](img/B22400_11_16.jpg)'
- en: Figure 11.16 – Bookmarkr as a .NET tool running successfully
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.16 – 将 Bookmarkr 作为 .NET 工具成功运行
- en: And that’s it! We now know how to manage versions of a .NET tool.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们现在知道如何管理 .NET 工具的版本。
- en: Let’s see how we manage versions of a Docker container.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们是如何管理 Docker 容器的版本的。
- en: Managing versions of a Docker container
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理 Docker 容器的版本
- en: As you may have noticed, when we pushed the Docker image to Docker Hub, we tagged
    it with a version number. Hence, if we want to distribute a new version, we can
    tag the new image with a different version number.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所注意到的，当我们把 Docker 镜像推送到 Docker Hub 时，我们用版本号进行了标记。因此，如果我们想分发新版本，我们可以用不同的版本号标记新镜像。
- en: However, if you are familiar with Docker, you may know about working with containers
    without providing their version number or using the `latest` tag.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你熟悉 Docker，你可能知道可以在不提供版本号或使用 `latest` 标签的情况下与容器一起工作。
- en: When distributing multiple versions of a container, it is important to indicate
    which one of these is the latest version, by tagging that version using the `latest`
    tag.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当分发多个容器版本时，通过使用 `latest` 标签标记该版本，指明这些版本中的哪一个是最新的，这是很重要的。
- en: 'So, let’s assume that we are distributing a new version of Bookmarkr and that
    we want to indicate that this new version is the latest one. We can achieve this
    as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们假设我们正在分发 Bookmarkr 的新版本，并且我们想要表明这个新版本是最新版本。我们可以这样做：
- en: '[PRE33]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let’s explain these commands:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释这些命令：
- en: The first one creates a new Docker image that is tagged with version 2.0.0
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个创建了一个带有版本 2.0.0 标签的新 Docker 镜像
- en: The second one tags version 2.0.0 as the latest version
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个将版本 2.0.0 标记为最新版本
- en: The third command pushes the image tagged with version 2.0.0 to Docker Hub
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个命令将带有版本 2.0.0 标签的镜像推送到 Docker Hub
- en: The fourth one pushes the image tagged with the latest version to Docker Hub
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四步将标记为最新版本的镜像推送到Docker Hub
- en: The fact that we push the same image using two different tags allows our users
    to get it (using the `docker pull` command) with or without specifying its version
    number. Hence, as we keep updating the application and pushing new Docker images,
    we will tag the newest version with the `latest` tag. Should that version contain
    a bug, we can direct our users to a previous version by tagging it with the `latest`
    tag.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用两个不同的标签推送相同的镜像的事实允许我们的用户（使用`docker pull`命令）指定或不指定其版本号来获取它。因此，随着我们不断更新应用程序并推送新的Docker镜像，我们将使用`latest`标签标记最新版本。如果该版本包含错误，我们可以通过使用`latest`标签将用户引导到之前的版本。
- en: 'If we head to the Docker Hub portal, we will see that the new version has been
    successfully pushed. Notice that there are two versions of the same image: one
    with version number 2.0.0 as a tag, and the other with the `latest` tag.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们访问Docker Hub门户，我们将看到新版本已成功推送。注意，有同一镜像的两个版本：一个以版本号2.0.0作为标签，另一个以`latest`标签。
- en: '![Figure 11.17 – New version of the Docker image pushed to Docker Hub](img/B22400_11_17.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图11.17 – 推送到Docker Hub的Docker镜像的新版本](img/B22400_11_17.jpg)'
- en: Figure 11.17 – New version of the Docker image pushed to Docker Hub
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17 – 推送到Docker Hub的Docker镜像的新版本
- en: 'On the user’s side, they can get a specific version by explicitly mentioning
    its tag, as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户端，他们可以通过明确提及其标签来获取特定版本，如下所示：
- en: '[PRE34]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Or, they can get the latest version (i.e., the version tagged as `latest`)
    by omitting the tag, as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，他们可以通过省略标签来获取最新版本（即标记为`latest`的版本），如下所示：
- en: '[PRE35]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The user will then see this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将看到以下内容：
- en: '![Figure 11.18 – Running the new version of the Docker container](img/B22400_11_18.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图11.18 – 运行Docker容器的最新版本](img/B22400_11_18.jpg)'
- en: Figure 11.18 – Running the new version of the Docker container
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.18 – 运行Docker容器的最新版本
- en: And that’s it! We now know how to manage versions of a Docker image.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们现在知道如何管理Docker镜像的版本。
- en: Let’s see how we manage versions of a WinGet package.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们是如何管理WinGet包的版本的。
- en: Managing versions of a WinGet package
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理WinGet包的版本
- en: In order to submit a new version of the application, following an update to
    the application’s code or functionalities, we first need to update the version
    number in the `.csproj` file (the `<``Version>` element).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提交应用程序的新版本，在更新应用程序的代码或功能之后，我们首先需要更新`.csproj`文件中的版本号（`<Version>`元素）。
- en: 'Next, we need to publish the application again using the same command we saw
    earlier:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用之前看到的相同命令再次发布应用程序：
- en: '[PRE36]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We then need to upload the resulting binaries to our distribution location,
    which is our Azure Storage account, keeping in mind that we should create a new
    directory for the new version. The path will then look like this for version 1.0.3:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将生成的二进制文件上传到我们的分发位置，即我们的Azure存储账户，同时要注意我们应该为新版本创建一个新的目录。对于版本1.0.3，路径将如下所示：
- en: '[PRE37]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The next step is to update the manifest using this command:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用此命令更新清单：
- en: '[PRE38]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The new manifest is then generated and is ready for submission.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 新的清单已生成并准备好提交。
- en: 'However, as we previously learned, it is always good practice to test the new
    version locally before submitting it. To do that, we will execute the same command
    as we did previously:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们之前学到的，在提交之前在本地测试新版本始终是一个好习惯。为此，我们将执行之前相同的命令：
- en: '[PRE39]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once the tests are successful, we submit the new version using this command:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦测试成功，我们使用以下命令提交新版本：
- en: '[PRE40]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The remaining steps are similar to those we followed when submitting the initial
    version of the application.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余步骤与我们提交应用程序初始版本时遵循的步骤类似。
- en: 'Once the new version has been approved and added to the WinGet package repository,
    users can find it and install it. They can install the latest version using this
    command:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦新版本被批准并添加到WinGet包仓库中，用户就可以找到它并安装它。他们可以使用以下命令安装最新版本：
- en: '[PRE41]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Or, they can install a specific version by passing the desired version number
    as a parameter to the command, as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，他们可以通过将期望的版本号作为参数传递给命令来安装特定版本，如下所示：
- en: '[PRE42]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![Figure 11.19 – The updated version of Bookmarkr is available in WinGet](img/B22400_11_19.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图11.19 – Bookmarkr的更新版本在WinGet中可用](img/B22400_11_19.jpg)'
- en: Figure 11.19 – The updated version of Bookmarkr is available in WinGet
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.19 – Bookmarkr的更新版本在WinGet中可用
- en: And that’s it! This is how we manage multiple versions of a WinGet package.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！这就是我们管理WinGet包多个版本的方法。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to package and deploy Bookmarkr onto different
    platforms in order to distribute it to users all around the world, no matter their
    platform of choice, be it Windows, Linux, or macOS.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何打包和部署 Bookmarkr 到不同的平台，以便向全球各地的用户分发，无论他们选择哪个平台，无论是 Windows、Linux
    还是 macOS。
- en: This is quite a milestone we achieved, from the inception of the idea of our
    CLI application all the way to getting it into the hands of millions of users
    worldwide. Let’s take a moment to celebrate this achievement and be proud of ourselves.
    Congratulations! 🎉
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们取得的一个相当大的里程碑，从我们的 CLI 应用程序想法的诞生，到将其推广到全球数百万用户手中。让我们花点时间庆祝这个成就，为自己感到自豪。恭喜！🎉
- en: However, some users are telling us that the application is sometimes slow. We
    haven’t experienced these performance issues since we are running on fast and
    powerful computers, but that is not the case with all our users. Although we could
    simply specify the minimum requirements to run Bookmarkr, we don’t want to limit
    the number of users that can benefit from and be able to use it. So, we have decided
    to see whether there is something we can do.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些用户告诉我们，应用程序有时运行缓慢。我们并没有经历过这些性能问题，因为我们运行在快速且强大的计算机上，但并非所有用户都是如此。尽管我们可以简单地指定运行
    Bookmarkr 的最低要求，但我们不想限制能够从中受益和使用它的用户数量。因此，我们决定看看我们是否可以做一些事情。
- en: In the next chapter, we will explore different techniques that will allow us
    to optimize the performance of our application.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨不同的技术，这些技术将使我们能够优化应用程序的性能。
- en: Your turn!
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮到你了！
- en: Following along with the provided code is a great way to learn through practice.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随提供的代码进行实践是学习的好方法。
- en: An even better way is by challenging yourself to complete tasks. Hence, I challenge
    you to improve the Bookmarkr application by adding the following features.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是通过挑战自己完成任务。因此，我挑战你通过添加以下功能来改进 Bookmarkr 应用程序。
- en: 'Task #1 – allowing Linux users to install Bookmarkr using apt-get'
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '任务 #1 – 允许 Linux 用户使用 apt-get 安装 Bookmarkr'
- en: Currently, Bookmarkr can be deployed to Windows using WinGet. However, this
    doesn’t work on Linux, where Linux users typically use `apt-get` for deploying
    applications. You are thus challenged to distribute Bookmarkr as an `apt-get`
    package so Linux users can also enjoy using it.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Bookmarkr 可以使用 WinGet 在 Windows 上部署。然而，这在 Linux 上不起作用，Linux 用户通常使用 `apt-get`
    部署应用程序。因此，你被挑战将 Bookmarkr 作为 `apt-get` 软件包进行分发，以便 Linux 用户也能享受使用它。
- en: 'Task #2 – allowing macOS users to install Bookmarkr using Homebrew'
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '任务 #2 – 允许 macOS 用户使用 Homebrew 安装 Bookmarkr'
- en: 'The same applies to macOS users: they typically install their applications
    using the `brew` command. You are thus challenged to distribute Bookmarkr as a
    Homebrew formula.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 macOS 用户来说，情况也是如此：他们通常使用 `brew` 命令安装应用程序。因此，你被挑战将 Bookmarkr 作为 Homebrew 公式进行分发。
- en: 'Part 5: Advanced Techniques and Best Practices'
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 部分：高级技术和最佳实践
- en: In this part, you will explore crucial aspects of CLI application development
    that enhance performance, security, and functionality. You'll delve into performance
    optimization and tuning techniques, learning how to profile your CLI applications,
    identify bottlenecks, and implement efficient algorithms and data structures.
    This includes strategies like caching, load balancing, and code refactoring to
    improve execution speed and resource utilization. Next, you'll focus on security
    considerations specific to CLI applications, covering best practices and protection
    against common vulnerabilities. You'll learn how to implement strong authentication
    mechanisms, use encryption for sensitive data, and follow the principle of least
    privilege in your CLI tools. Finally, you'll explore additional resources and
    libraries that will allow you to dive deeper into the various concepts and techniques
    presented in this book.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分，你将探索 CLI 应用程序开发的关键方面，这些方面可以增强性能、安全性和功能性。你将深入了解性能优化和调整技术，学习如何分析你的 CLI 应用程序，识别瓶颈，并实现高效的算法和数据结构。这包括缓存、负载均衡和代码重构等策略，以提高执行速度和资源利用率。接下来，你将专注于
    CLI 应用程序特有的安全考虑，涵盖最佳实践和防范常见漏洞。你将学习如何实现强大的身份验证机制，为敏感数据使用加密，并在你的 CLI 工具中遵循最小权限原则。最后，你将探索额外的资源和库，这将使你能够深入了解本书中提出的各种概念和技术。
- en: 'This part has the following chapters:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 12*](B22400_12.xhtml#_idTextAnchor205)*, Performance Optimization
    and Tuning*'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 12 章*](B22400_12.xhtml#_idTextAnchor205)*，性能优化和调整*'
- en: '[*Chapter 13*](B22400_13.xhtml#_idTextAnchor220)*, Security Considerations
    for CLI Applications*'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B22400_13.xhtml#_idTextAnchor220)*，CLI应用程序的安全考虑*'
- en: '[*Chapter 14*](B22400_14.xhtml#_idTextAnchor236)*, Additional Resources and
    Libraries*'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B22400_14.xhtml#_idTextAnchor236)*，附加资源和库*'
