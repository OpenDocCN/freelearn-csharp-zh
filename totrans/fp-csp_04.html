<html><head></head><body>
		<div><h1 id="_idParaDest-96" class="chapter-number"><a id="_idTextAnchor158"/>4</h1>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor159"/>Honest Functions, Null, and Option</h1>
			<p>In this chapter, we discuss the art and science of honest functions, the intricacies of null, and the C# tools tailored to address them. But before we dive deep, let’s lay out the roadmap:</p>
			<ul>
				<li>Understanding honest functions</li>
				<li>The problems with hidden nulls</li>
				<li>Embracing honesty with nullable reference types</li>
				<li>Beyond null: Option</li>
				<li>Real-world scenarios</li>
			</ul>
			<p>As you navigate through this chapter, be on the lookout for practical advice and evidence-backed guidelines. Come with a curious mind, and by the end, you’ll possess the know-how to write more transparent and resilient C# code.</p>
			<p>Just as we did in our previous chapters, let’s assess where you stand. Here, there are three tasks for you. If you’re unsure about tackling them, dive into this chapter right away. But, if you feel confident in your skills, perhaps you might skim through and jump to the sections that challenge you the most. Ready? Let’s go!</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor160"/>Task 1 – Refactor for honest return types</h1>
			<p>Here’s a function<a id="_idIndexMarker180"/> in Steve’s tower defense game that retrieves a tower based on its ID. Refactor it to return an honest type indicating potential nullability:</p>
			<pre class="source-code">
public Tower GetTower(int towerId)
{
     var tower = _gameState.GetTowerById(towerId);
     return tower;
}</pre>			<h1 id="_idParaDest-99"><a id="_idTextAnchor161"/>Task 2 – Guard against null inputs</h1>
			<p>Refactor the following <a id="_idIndexMarker181"/>function to guard against null inputs using preconditions and throw appropriate exceptions if the precondition isn’t met:</p>
			<pre class="source-code">
public void UpgradeTower(TowerUpgradeInfo upgradeInfo)
{
     _gameState.UpgradeTower(upgradeInfo);
}</pre>			<h1 id="_idParaDest-100"><a id="_idTextAnchor162"/>Task 3 – Pattern matching with nullable types</h1>
			<p>Given the following<a id="_idIndexMarker182"/> classes, write a method that receives an enemy and returns a string with its description using pattern matching:</p>
			<pre class="source-code">
public abstract class Enemy {}
public class GroundEnemy : Enemy
{
     public int Speed { get; set; }
     public int Armor { get; set; }
}
public class FlyingEnemy : Enemy
{
     public int Altitude { get; set; }
     public int DodgeChance { get; set; }
}
public class BossEnemy : Enemy
{
     public int Health { get; set; }
     public string SpecialAbility { get; set; }
}
public string GetEnemyDetails(Enemy? enemy)
{
     // Your code here
}</pre>			<p>Again, if you are sure you know the right answers to all three tasks, you can skip this chapter. Of course, you <a id="_idIndexMarker183"/>can always come back if you have any questions. Now let’s discuss honest functions and their benefits.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor163"/>Honest functions – definition and understanding</h1>
			<p>A few days after his <a id="_idIndexMarker184"/>conversation with Julia about pure functions and side effects, Steve was eager to learn more. He called Julia to ask what he should study next.</p>
			<p>Julia: <em class="italic">Let’s talk about honest functions, </em><code>null</code><em class="italic">, and </em><code>Option</code><em class="italic"> types,’ she suggested. ‘These concepts are crucial for writing clear, </em><em class="italic">predictable code.</em></p>
			<p>Steve: <em class="italic">Sounds great! But what exactly are </em><em class="italic">honest functions?</em></p>
			<p>Julia: <em class="italic">An honest function provides a clear, unambiguous contract between the function and its callers, resulting in code that’s more robust, less prone to bugs, and easier to </em><em class="italic">reason about.</em></p>
			<p>So what exactly is an honest function?</p>
			<p>In the simplest terms, an honest function is one where its type signature fully and accurately describes its behavior. If a function claims that it will take an integer and return another integer, then that’s precisely what it will do. There are no hidden gotchas, no exceptions thrown out of the blue, and no subtle changes to global or static state that aren’t reflected in the function’s signature.</p>
			<p>Consider the following C# function:</p>
			<pre class="source-code">
public static int Divide(int numerator, int denominator)
{
    return numerator / denominator;
}</pre>			<p>At first glance, this function seems to fulfill its promise. It takes two integers and returns their quotient. However, what happens when we pass zero as the denominator? <code>DivideByZeroException</code> is thrown. The function was not entirely honest with us; its signature did not warn us about this potential pitfall. An honest version of this function would explicitly signal the potential for failure in its signature.</p>
			<p>So, how does this <a id="_idIndexMarker185"/>concept of honesty tie into the broader context of functional programming and the software development industry? In functional programming, functions are the building blocks of your code. The more clearly and honestly these functions describe their behavior, the easier it is to build larger, more complex programs. Each function serves as a reliable component that behaves just as its signature describes, allowing developers to confidently compose and reuse these functions.</p>
			<p>As Julia explained honest functions, Steve’s eyes lit up with understanding.</p>
			<p>Steve: <em class="italic">So it’s like when I tell my teammates I’ll deliver a feature by Friday, I should actually </em><em class="italic">do it?</em></p>
			<p>Julia: <em class="italic">Exactly! In programming, our functions should be just </em><em class="italic">as reliable.</em></p>
			<p>Now, let’s dive deeper into the benefits of using honest functions:</p>
			<ul>
				<li><strong class="bold">Improved readability</strong>: Honest<a id="_idIndexMarker186"/> functions make the code more straightforward to read and understand. There’s no need to dive into the implementation to grasp what the function is doing. The function’s signature is a contract that accurately describes its behavior.</li>
				<li><strong class="bold">Enhanced predictability</strong>: With honest functions, surprises are drastically minimized. The function’s behavior is precisely what is described in the signature, leading to fewer unexpected bugs and exceptions at runtime.</li>
				<li><strong class="bold">Increased reliability</strong>: By minimizing surprises and explicitly handling potential error scenarios, honest functions result in a more robust code base that can withstand the rigors <a id="_idIndexMarker187"/>of real-world usage.</li>
			</ul>
			<p>Consider a code base where every function is honest. Any developer, familiar or not with the code, could look at a function signature and know immediately what it does, what it needs, and what it might return, including any potential error conditions. It’s like having a well-documented code base without the need for verbose documentation. That’s the power and<a id="_idIndexMarker188"/> promise of honest functions.</p>
			<p>In the following sections, we’ll explore how to implement honest functions in C# and how to deal with potential dishonesty, such as nulls or exceptions. Fasten your seatbelts, because our journey into the world of honest and dishonest functions is just beginning!</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor164"/>The problems with hidden nulls</h1>
			<p>Steve recalled a <a id="_idIndexMarker189"/>recent bug in his tower defense game.</p>
			<p>Steve: <em class="italic">I think I’ve run into this problem. My game crashed when trying to upgrade a tower that </em><em class="italic">didn’t exist.</em></p>
			<p>Julia: <em class="italic">That’s a classic example, let’s look at how we can prevent that using what we’re </em><em class="italic">learning today.</em></p>
			<p>Have you ever felt confused trying to figure out why your program stopped working? Most times, the problem comes from a well-known <code>NullReferenceException</code>. This section looks at the tricky connection between C# and null, pointing out the problems many developers face.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor165"/>A quick look back – C# and null</h2>
			<p>To understand<a id="_idIndexMarker190"/> our current problem, let’s look back a bit. Tony Hoare, an important <a id="_idIndexMarker191"/>computer expert, called the null reference a “huge mistake.” The idea was to provide developers with a tool to show when a value was missing. At first, it seemed like a good plan, but it ended up causing many problems and mistakes in languages – C# included.</p>
			<p>When C# was introduced, it used this idea from older programming methods, letting developers use null to show something was missing. But over time, this simple choice caused a lot of<a id="_idIndexMarker192"/> errors <a id="_idIndexMarker193"/>and mix-ups.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor166"/>Common mistakes and the troubling NullReferenceException</h2>
			<p>All C# developers, whether new or experienced, have come across <code>NullReferenceException</code>. This error <a id="_idIndexMarker194"/>happens when you try to use something that isn’t there.</p>
			<p>Think about a program that gets user information. You might expect to always find a user:</p>
			<pre class="source-code">
var user = FindUserById(userId);
var fullName = $"{user.FirstName} {user.LastName}";</pre>			<p>Oops! If <code>FindUserById</code> can’t find a user, the second line will give <code>NullReferenceException</code>, which, if not caught, will terminate the whole execution of the thread. This mistake happens because we thought a user would always be there. This shows how hidden nulls can cause unexpected problems in our code.</p>
			<p>Many programs are much bigger than this example, which makes these kinds of mistakes hard to find and fix. These hidden problems can stay hidden for a long time, causing errors when you least expect them.</p>
			<p>Hidden nulls can be thought of as unseen traps. They can catch out both new and experienced programmers. Plus, they go against the main idea of functional programming, which values clear and expected outcomes.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor167"/>Not all bad – the value of null</h2>
			<p>It’s easy to blame null for <a id="_idIndexMarker195"/>these problems. But the real issue is how it’s used. Null can be helpful if used in a clear way to show something is missing. The problem comes when its use is unclear, leading to many potential errors.</p>
			<p>The journey of C# with null has had its ups and downs. But, as we’ll learn in the next sections, C# now has multiple ways to handle null, making our code clearer and more straightforward. And one of these ways is to use nullable reference types.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor168"/>Embracing honesty with nullable reference types</h1>
			<p>Handling null in C# has <a id="_idIndexMarker196"/>always been quite a challenge. Many software developers (me included) advocate doing a check for <code>NullReferenceException</code>s as a mandatory task in a code review checklist. In most cases, it is really easy to check for possible null values just by looking at the pull request, even without an IDE. Recently, we received help when Microsoft introduced nullable reference types. So, now, the compiler will join us in the search of possible disasters caused by null.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor169"/>What are nullable reference types?</h2>
			<p>In the simplest terms, <strong class="bold">Nullable Reference Types</strong> (or <strong class="bold">NRTs</strong> for short) are a feature in C# that allows <a id="_idIndexMarker197"/>developers to clearly indicate whether a reference type can be null or not. With this, C# gives us a tool to make our intentions clear right from the start. Think of it as a signpost, guiding other developers (and even our future selves) about what to expect from our code.</p>
			<p>Without NRTs, every reference type in C# could potentially be <code>null</code>. This would create a guessing game. Is this variable going to have a value or is it going to be <code>null</code>? Now, with NRTs, we don’t have to guess anymore. The code itself tells the story.</p>
			<p>Let’s look at a basic example to grasp the concept:</p>
			<pre class="source-code">
string notNullable = "Hello, World!";
string? nullable = null;</pre>			<p>In the preceding snippet, the <code>notNullable</code> variable is a regular string that can’t be assigned <code>null</code> (if you try, the compiler will warn you). On the other hand, since C# 8.0, nullable is explicitly marked with <code>?</code>, indicating that it can be <code>null</code>.</p>
			<p>In some cases, you might want to assign <code>null</code> to a variable that is not marked as nullable. In this case, to suppress warnings, you can use the <code>!</code> sign to let the compiler know that you are aware of what you are doing and everything is going according to plan:</p>
			<pre class="source-code">
string notNullable = "Hello, World!";
notNullable = null!;</pre>			<p>One of the biggest advantages of NRTs is that the C# compiler will warn you if you’re potentially doing something risky with null values. It’s like having a friendly guide always looking over your shoulder, ensuring you don’t fall into the common traps of null misuse.</p>
			<p>For instance, if you try to<a id="_idIndexMarker198"/> access properties or methods on a nullable reference without checking for <code>null</code>, the compiler will give you a heads-up.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor170"/>Transitioning to NRTs</h2>
			<p>For those with <a id="_idIndexMarker199"/>existing C# projects, you might be wondering: <em class="italic">Will my project be littered with warnings if I enable NRTs?</em> The answer is no. By default, NRTs are turned off. You can opt into this feature, file by file, allowing for a smooth transition.</p>
			<p>NRTs are a good answer to the long-standing challenge posed by null references. By making the potential presence of null explicit in our code, we take a giant leap toward clarity, safety, and functional honesty. In the end, embracing NRTs not only makes our code more resilient but also ensures that our intentions, as developers, are transparent.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor171"/>Enabling nullable reference types</h2>
			<p>To enable NRTs, we<a id="_idIndexMarker200"/> need to tell the C# compiler that we’re ready for its guidance. This is done using a simple directive: <code>#</code><code>nullable enable</code>.</p>
			<p>Place this at the start of your <code>.</code><code>cs</code> file:</p>
			<pre class="source-code">
#nullable enable</pre>			<p>From this point onward in the file, the compiler creates a specific nullable context and assumes that all reference types are non-nullable by default. If you want a type to be nullable, you’ll have to mark it explicitly with <code>?</code>.</p>
			<p>With NRTs enabled, the C# compiler becomes your safety net, pointing out potential issues with nulls in your code. Whenever you try to assign null to a reference type without the <code>?</code> marker or when you attempt to access a potentially null variable without checking it, the compiler will warn you.</p>
			<p>Here’s an example:</p>
			<pre class="source-code">
string name = null; // This will trigger a warning
string? maybeName = null; // This is okay</pre>			<h2 id="_idParaDest-110"><a id="_idTextAnchor172"/>Disabling nullable reference types</h2>
			<p>While transitioning <a id="_idIndexMarker201"/>a project to use NRTs, there may be sections of your code where you’d prefer to delay the transition. You can turn off NRTs for those specific sections using the <code>#nullable </code><code>disable</code> directive:</p>
			<pre class="source-code">
#nullable disable</pre>			<p>This tells the compiler to revert to the old behavior, treating all reference types as potentially nullable.</p>
			<p>You might wonder why C# chose to use directives for this feature. The reason is flexibility. By using directives, developers can gradually introduce NRTs into their projects, one file or even one section of code at a time. This phased approach makes it easier to adapt existing projects.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor173"/>Warnings and annotations options</h2>
			<p>Speaking of a phased approach, there<a id="_idIndexMarker202"/> are two more options to set our nullable contexts: <code>warnings</code> and <code>annotations</code>. You can use them by writing the following:</p>
			<pre class="source-code">
#nullable enable warnings</pre>			<p>Or, you can write this:</p>
			<pre class="source-code">
#nullable enable annotations</pre>			<p>The main purpose of these<a id="_idIndexMarker203"/> options is to ease the migration of your existing code from a fully disabled null context to a fully enabled one. In short, we want to start with the <code>warnings</code> option in order to get dereference warnings. When all warnings are fixed, we can switch to <code>annotations</code>. This option will not give us any warnings, but it will start to treat our variables as non-nullable unless declared with the <code>?</code> mark.</p>
			<p>To get more information about these options and nullable context in generated files, and to find out more about three nullabilities – oblivious, nullable, and non-nullable, I recommend you read the article <em class="italic">Nullable reference types</em> (<a href="https://learn.microsoft.com/en-us/dotnet/csharp/nullable-references">https://learn.microsoft.com/en-us/dotnet/csharp/nullable-references</a>). You might also want to read the article “Update a codebase with nullable reference types to improve null <a id="_idIndexMarker204"/>diagnostic warnings” (<a href="https://learn.microsoft.com/en-us/dotnet/csharp/nullable-migration-strategies">https://learn.microsoft.com/en-us/dotnet/csharp/nullable-migration-strategies</a>).</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor174"/>The bigger picture – project-wide settings</h2>
			<p>While directives are<a id="_idIndexMarker205"/> great for granular control, you can also enable NRTs for an entire project. In the project settings, or directly in the <code>.csproj</code> file, set the <code>&lt;Nullable&gt;</code> element to enable:</p>
			<pre class="source-code">
&lt;PropertyGroup&gt;
    &lt;Nullable&gt;enable&lt;/Nullable&gt;
&lt;/PropertyGroup&gt;</pre>			<p>This setting treats every file in the project as if it started with the <code>#nullable enable</code> directive. When you turn on a nullable context for the whole project, you might want to keep some parts of the code from generating warnings, but use the project-wide nullable context after it. In that case, you can use the <code>restore</code> option:</p>
			<pre class="source-code">
#nullable enable
// The section of the code where nullable reference types are enabled.
#nullable restore</pre>			<p>Enabling nullable reference types is like turning on a light in a previously dim room. It reveals potential pitfalls and ensures that we write safer, clearer code. With the tools C# provides, we have both granular and broad control over this feature, making the transition to a more transparent coding style both manageable and rewarding.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor175"/>Returning with intention</h1>
			<p>In the realm of functional<a id="_idIndexMarker206"/> programming, a function’s primary aim is to be transparent. By transparent, we mean that the function should not just do what its name implies, but also, its return type should offer a clear contract of what to expect. Let’s dive deep into crafting honest return types in C#.</p>
			<p>A seasoned developer knows that a function’s name or signature alone might not depict the entire story. Consider the following:</p>
			<pre class="source-code">
UserProfile GetUserProfile(int userId);</pre>			<p>On the surface, this function seems to promise that it’ll fetch a user profile given a user ID. However, questions linger. What if the user doesn’t exist? What if there’s an error retrieving the profile?</p>
			<p>Now consider an alternative:</p>
			<pre class="source-code">
UserProfile? GetUserProfile(int userId);</pre>			<p>By simply<a id="_idIndexMarker207"/> introducing <code>?</code> to the return type, the function becomes more transparent about its intention. It suggests: <em class="italic">I’ll try to fetch a user profile for this ID. But there’s a possibility you might get </em><em class="italic">a null</em>.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor176"/>The distinction between UserProfile and UserProfile?</h2>
			<p>While the distinction<a id="_idIndexMarker208"/> might seem minute, the implications are vast:</p>
			<ul>
				<li><code>UserProfile?</code>, you immediately know there’s a possibility of not getting a user profile.</li>
				<li><strong class="bold">Defensive coding</strong>: Knowing the return can be null, you’ll naturally write safer code to handle such cases.</li>
				<li><strong class="bold">Error handling</strong>: Instead of exceptions or error codes to signify missing data, a nullable return type provides a clear, type-safe way to express the possibility of absence.</li>
			</ul>
			<p>Let’s see this in practice:</p>
			<pre class="source-code">
var userProfile = GetUserProfile(userId);
if (userProfile is null)
{
    // Handle the scenario when the profile is not available
}
else
{
    // Proceed with the user profile data
}</pre>			<p>As you can see, with the help of NRTs, we can understand code more clearly and process its results <a id="_idIndexMarker209"/>correctly. And all we did to achieve it was just tweaking the method’s signature a little bit.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor177"/>Honoring a function’s contract</h2>
			<p>An honest function goes <a id="_idIndexMarker210"/>beyond just indicating potential null returns. It creates a mindset of “return with intention.” When returning with intention, you’re not merely returning data; you’re communicating a state.</p>
			<p>Consider the following examples.</p>
			<p><code>null</code> checks and avoids potential <code>NullReferenceException</code>s:</p>
			<pre class="source-code">
List&lt;Order&gt; GetOrdersForUser(int userId)
{
    return ordersRepository.FindByUserId(userId) ?? new List&lt;Order&gt;();
}</pre>			<p><strong class="bold">Fetching data</strong>: When retrieving data that might not exist, instead of exceptions, a nullable type paints a clearer picture:</p>
			<pre class="source-code">
Product? FindProductById(int productId)
{
    return productsRepository.GetById(productId);
}</pre>			<p>Transparent return types result in fewer surprises and more robust code. By clearly communicating what a function can return, you do the following:</p>
			<ul>
				<li><strong class="bold">Reduce errors</strong>: Because developers will handle scenarios they might have overlooked otherwise</li>
				<li><strong class="bold">Promote clarity</strong>: Developers spend less time digging into function implementations, relying on return types to guide behavior</li>
				<li><strong class="bold">Foster trust</strong>: A clear contract ensures that the function lives up to its promise, creating a sense of reliability in the code base</li>
			</ul>
			<p>As we continue to explore honest functions, always remember: your functions are both performers and communicators. Let them not just do their task, but also communicate their intent and potential <a id="_idIndexMarker211"/>outcomes transparently. In doing so, you build resilient systems, create clear contracts, and encourage a safer, more predictable coding environment.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor178"/>Demanding honesty from function inputs</h1>
			<p>A truly robust system <a id="_idIndexMarker212"/>is not just about what you return; it’s also about what you accept. Guarding your functions against potentially misleading or harmful inputs is paramount in creating predictable, error-resistant applications.</p>
			<p>Consider this common scenario: You have a function that expects a certain type of input. However, when a <code>null</code> value sneaks its way in, your function breaks down, leading to the infamous <code>NullReferenceException</code>. To mitigate this, C# provides a way to demand honesty from function inputs using nullable reference types.</p>
			<p>Let’s say you define a function as follows:</p>
			<pre class="source-code">
public void UpdateUserProfile(UserProfile profile)
{
    // Some operations on profile
}</pre>			<p>The intention is clear: the function expects <code>UserProfile</code>. However, what’s stopping a developer from passing in <code>null</code>?</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor179"/>Nullable reference types to the rescue</h2>
			<p>As we discussed<a id="_idIndexMarker213"/> earlier, with C# 8.0, nullable reference<a id="_idIndexMarker214"/> types add another layer of protection. By turning on nullable reference types using <code>#nullable enable</code>, the compiler becomes your guardian:</p>
			<pre class="source-code">
#nullable enable
public void UpdateUserProfile(UserProfile profile)
{
    // Some operations on profile
}</pre>			<p>Now, if any developer tries to pass a nullable <code>UserProfile</code> to the function, the compiler will raise a warning. This nudges developers in the right direction and prevents potential runtime errors.</p>
			<p>However, warnings do not guarantee that <code>null</code> will not be used, so let’s look at another approach. Here, we defend the method with the simplest guard in a straightforward null check:</p>
			<pre class="source-code">
public void UpdateUserProfile(UserProfile profile)
{
    if (profile is null)
    {
        throw new ArgumentNullException(nameof(profile), "Profile cannot be null!");
    }
    // Some operations on profile
}</pre>			<p>This check ensures that if the function is ever provided <code>null</code>, it’ll immediately halt execution and provide a clear reason.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor180"/>Using preconditions and contracts</h2>
			<p>Contracts and<a id="_idIndexMarker215"/> preconditions take the idea of guarding to a new level. By defining a set of rules that must hold true before a function can proceed, you’re making the function’s expectations explicit.</p>
			<p>Consider the CodeContracts (<a href="https://github.com/Microsoft/CodeContracts">https://github.com/Microsoft/CodeContracts</a>) library provided by Microsoft. With this, you can ensure your function’s preconditions with a more expressive syntax:</p>
			<pre class="source-code">
public void UpdateUserProfile(UserProfile profile)
{
    Contract.Requires&lt;ArgumentNullException&gt;(profile != null, "Profile cannot be null!");
    // Some operations on profile
}</pre>			<p>This code is much more concise, however, it guards our method from <code>null</code> values in the same way.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor181"/>Using built-in checks</h2>
			<p>In C# 6.0, we <a id="_idIndexMarker216"/>received a new way to guard against null values – <code>ArgumentNullException.ThrowIfNull</code>:</p>
			<pre class="source-code">
public void UpdateUserProfile(UserProfile profile)
{
    ArgumentNullException.ThrowIfNull(profile);
    // Some operations on profile
}</pre>			<p>Now, this code looks even cleaner and easier to read. Also, a more enhanced method for strings appeared in C# 7.0: <code>ArgumentException.ThrowIfNullOrEmpty</code>. It not only checks for null but also ensures that the string is not empty:</p>
			<pre class="source-code">
public void UpdateUserEmail(long userId, string email)
{
    ArgumentException.ThrowIfNullOrEmpty(email);
    // Updating the email after finding the user by ID
}</pre>			<h2 id="_idParaDest-120"><a id="_idTextAnchor182"/>The power of explicit non-null inputs</h2>
			<p>By demanding non-null <a id="_idIndexMarker217"/>arguments, you do the following:</p>
			<ul>
				<li><strong class="bold">Improve predictability</strong>: Functions behave as expected since rogue nulls don’t derail them</li>
				<li><strong class="bold">Boost developer confidence</strong>: With clear contracts, developers can invoke functions without second-guessing</li>
				<li><strong class="bold">Reduce debugging time</strong>: Catching potential issues at compile time is always faster than runtime debugging</li>
			</ul>
			<p>In order to write good functional code, ensuring clarity in what you accept is just as crucial as being transparent in what you return. By demanding honesty from function inputs, you’re laying a solid foundation for code that’s both reliable and resilient.</p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor183"/>Pattern matching and nullable types</h1>
			<p>Pattern matching is <a id="_idIndexMarker218"/>a powerful tool in the C# arsenal, serving as a mechanism to make the code not only more expressive but also clearer and safer. When combined with nullable types, pattern matching helps us guard our code against potential pitfalls.</p>
			<p>Pattern matching, introduced in C# 7.0 and enhanced in subsequent versions, is a feature that allows you to test a value against a pattern, providing a way to extract information from the value when it conforms to the pattern.</p>
			<p>Consider the classic <code>switch</code> statement, evolved with pattern matching:</p>
			<pre class="source-code">
object tower = GetRandomTower();
switch (tower)
{
    case ArcherTower a:
        Console.WriteLine($"It's an Archer Tower with a range of {a.Range}!");
        break;
    case CannonTower c:
        Console.WriteLine($"It's a Cannon Tower with an explosion radius of {c.ExplosionRadius}!");
        break;
    default:
        throw new Exception("Unknown tower type!");
        break;
}</pre>			<p>Here, <code>ArcherTower</code> and <code>CannonTower</code> are types. If <code>tower</code> is of type <code>ArcherTower</code>, it not only enters the respective case block but also casts it to the <code>ArcherTower</code> type, allowing <a id="_idIndexMarker219"/>you to access its properties directly.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor184"/>Pattern matching with nullable types</h2>
			<p>Pattern matching<a id="_idIndexMarker220"/> truly shines when dealing with nullable types. Let’s consider a situation where we fetch a user profile:</p>
			<pre class="source-code">
UserProfile? profile = GetUserProfile(userId);</pre>			<p>How do we handle this potential null in a type-safe, clear manner? Enter pattern matching.</p>
			<h3>Using the “is” pattern</h3>
			<p>Ideally, our code should <a id="_idIndexMarker221"/>be easy to read, and what could be easier than using plain English? The “is” pattern is designed to assist with that:</p>
			<pre class="source-code">
if (profile is null)
{
    Console.WriteLine("Profile not found.");
}
else
{
    Console.WriteLine($"Welcome, {profile.Name}!");
}</pre>			<p>This immediately makes the code more readable, drawing a clear distinction between the scenarios.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor185"/>Switch expressions with property patterns</h2>
			<p>Introduced<a id="_idIndexMarker222"/> in C# 8.0, the <code>switch</code> expression paired with property patterns provides an even more concise way to handle complex conditions:</p>
			<pre class="source-code">
public class Book
{
    public bool IsPublished { get; set; }
    public bool IsDraft { get; set; }
}
string bookStatus = book switch
{
    null =&gt; "No book found",
    { IsPublished: true, IsDraft: false } =&gt; "Published Book",
    { IsPublished: false, IsDraft: true } =&gt; "Draft Book",
    { IsPublished: false, IsDraft: false } =&gt; "Unpublished Book",
    _ =&gt; "Unknown book status"
};</pre>			<p>Here, not only do we check for null, but we also examine specific properties of the <code>Book</code> object, making<a id="_idIndexMarker223"/> decisions based on their values.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor186"/>Ensuring clarity with nullable types</h2>
			<p>The amalgamation of pattern<a id="_idIndexMarker224"/> matching and nullable types ensures the following:</p>
			<ul>
				<li><strong class="bold">Safety</strong>: By handling potential nulls explicitly, you reduce the risk of runtime errors</li>
				<li><strong class="bold">Expressiveness</strong>: Patterns allow you to condense complex conditional logic into concise, readable constructs</li>
				<li><strong class="bold">Readability</strong>: Clear distinctions between different conditions and outcomes enable developers to understand the flow effortlessly</li>
			</ul>
			<p>Pattern matching, when combined with nullable types, is a formidable tool for any C# developer. It not only streamlines code but also strengthens it, allowing you to write applications that are more resilient to unexpected scenarios. Use it and your code will be both a joy to write and a model of reliability.</p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor187"/>The null object pattern</h1>
			<p>The null object pattern<a id="_idIndexMarker225"/> is a design pattern that provides an object as a surrogate for the lack of an object of a given interface. Essentially, it provides default behavior in the absence of meaningful data or behavior. This pattern is particularly useful in scenarios where you’d expect an object but don’t have one, and don’t want to <a id="_idIndexMarker226"/>constantly check for <code>null</code>.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor188"/>The problem with null checks</h2>
			<p>Imagine you’re developing<a id="_idIndexMarker227"/> a system where you have a series of operations to perform on a <code>User</code> object. Now, not every user might be initialized in the system, which often leads to this:</p>
			<pre class="source-code">
if (user != null)
{
    user.PerformOperation();
}</pre>			<p>This might seem innocent for a single check. But when your code base is littered with such null checks, the code becomes verbose and less readable. The proliferation of null checks can also obscure the primary business logic, making the code base harder to maintain and understand.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor189"/>The null object solution</h2>
			<p>The null object pattern <a id="_idIndexMarker228"/>provides an elegant solution to this problem. Instead of using a null reference to convey the absence of an object, you create an object that implements the expected interface but does nothing – a “null object.”</p>
			<p>Here’s an example:</p>
			<pre class="source-code">
public interface IUser
{
    void PerformOperation();
}
public class User : IUser
{
    public void PerformOperation()
    {
        // Actual implementation here
    }
}
public class NullUser : IUser
{
    public void PerformOperation()
    {
        // Do nothing: this is a null object
    }
}</pre>			<p>In situations where a user isn’t available, instead of returning <code>null</code>, you’d return an instance of <code>NullUser</code>.</p>
			<p>Now, when you want to<a id="_idIndexMarker229"/> perform an operation, you can confidently do so without checking for <code>null</code>:</p>
			<pre class="source-code">
user.PerformOperation();</pre>			<p>Regardless of whether <code>user</code> is <code>RealUser</code> or <code>NullUser</code>, the code won’t throw <code>Null</code><strong class="source-inline">
</strong><code>ReferenceException</code>.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor190"/>Advantages</h2>
			<p>Implementing the<a id="_idIndexMarker230"/> null object pattern offers several key advantages:</p>
			<ul>
				<li><strong class="bold">Reduction of conditional statements</strong>: You can decrease the number of explicit null checks, leading to cleaner and more readable code.</li>
				<li><strong class="bold">Safety</strong>: The risk of null reference exceptions gets drastically reduced.</li>
				<li><strong class="bold">Polymorphism</strong>: By treating the null object the same as other objects, you can leverage the power of polymorphism, which can simplify and clarify the code.</li>
				<li><strong class="bold">Clarity in intent</strong>: Null objects can have meaningful names, making it clear when a “do-nothing” or <a id="_idIndexMarker231"/>default behavior is intentional</li>
			</ul>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor191"/>Limitations and considerations</h2>
			<p>While the null object<a id="_idIndexMarker232"/> pattern has its benefits, it’s not always the best solution:</p>
			<ul>
				<li><strong class="bold">Overhead</strong>: For very large systems or deeply nested structures, introducing null objects everywhere can add overhead</li>
				<li><strong class="bold">Complexity</strong>: If the interface or base class changes frequently, maintaining a corresponding null object can become tedious</li>
				<li><strong class="bold">Obscured errors</strong>: If you’re not careful, using null objects can potentially mask problems in the system, since they provide default behavior that might hide issues that would have otherwise been exposed by a null reference</li>
			</ul>
			<p>The null object pattern is a powerful tool in the arsenal of a C# developer. It’s not a one-size-fits-all solution, but when applied judiciously, it can greatly improve code clarity and robustness. Like all design patterns, understanding when and where to apply it is crucial. So don’t hurry to use it everywhere, and let’s look at a more functional approach – the <code>Option</code> type.</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor192"/>Beyond null – using Option</h1>
			<p><code>Nullable&lt;T&gt;</code>, which is <a id="_idIndexMarker233"/>embedded in C#, is a great tool to work with <code>null</code> values, but there is a better and more straightforward construct for the handling of null values. <code>Option</code> is a type that provides more expressive tools for conveying the presence or absence of a value, serving as a richer alternative to nullable types.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor193"/>A brief introduction to Option</h2>
			<p>At its core, the <code>Option</code> type can be thought of as a container that may or may not contain a value. Typically, it’s<a id="_idIndexMarker234"/> represented as either <code>Some</code> (which wraps a value) or <code>None</code> (indicating the absence of a value).</p>
			<p>Usually, the implementation of <code>Option</code> looks like this:</p>
			<pre class="source-code">
public struct Option&lt;T&gt;
{
     private readonly bool _isSome;
     private readonly T _value;
     public static Option&lt;T&gt; None =&gt; default;
     public static Option&lt;T&gt; Some(T value) =&gt; new Option&lt;T&gt;(value);
     Option(T value)
     {
          _value = value;
          _isSome = _value is not null;
     }
     public bool IsSome(out T value)
     {
          value = _value;
          return _isSome;
     }
}</pre>			<p>While C# doesn’t have a built-in <code>Option</code> type, you can use the one above or use a library such as LanguageExt (<a href="https://github.com/louthy/language-ext">https://github.com/louthy/language-ext</a>), which provides this functionality.</p>
			<p>Now, let’s look at how we can leverage the <code>Option</code> type:</p>
			<pre class="source-code">
public Option&lt;UserProfile&gt; GetUserProfile(int userId)
{
    var user = database.FindUserById(userId);
    return new Option&lt;UserProfile&gt;(user);
}</pre>			<p>Another way <a id="_idIndexMarker235"/>to use <code>Option</code> is to write the following:</p>
			<pre class="source-code">
public Option&lt;UserProfile&gt; GetUserProfile(int userId)
{
    var user = database.FindUserById(userId);
    return user is not null
   ? Option&lt;UserProfile&gt;.Some(user)
   : Option&lt;UserProfile&gt;.None;
}</pre>			<p>This code is more straightforward, however, the code before it is more concise.</p>
			<p>Now, when calling this function, we can handle the result in a more expressive manner:</p>
			<pre class="source-code">
var profileOption = GetUserProfile(userId);
UserProfile profile;
if (!profileOption.IsSome(out profile))
{
     // Handle the scenario when the profile is not available
}
// Continue with profile operations</pre>			<p>This approach makes the handling of potential missing values explicit and clear.</p>
			<p>As Steve delved into <code>Option</code> types, he thought “This reminds me of how we handle power-ups in our <a id="_idIndexMarker236"/>games, sometimes they’re there, sometimes they’re not.”</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor194"/>Advantages of the Option type over nullable types</h2>
			<p>When it comes to <a id="_idIndexMarker237"/>handling values that might be absent, opting for the <code>Option</code> type presents distinct advantages in your code:</p>
			<ul>
				<li><code>Some</code> and <code>None</code> constructs makes the code’s intention unmistakable. There’s a clear distinction between having a value and lacking one.</li>
				<li><code>Option</code> type forces you to handle both <code>Some</code> and <code>None</code> scenarios, reducing potential oversights in your code.</li>
				<li> <code>Option</code> types often work together with other functional methods, enabling powerful and concise transformations.</li>
			</ul>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor195"/>The interplay of Option and nullable types</h2>
			<p>It’s worth noting that <a id="_idIndexMarker238"/>while the <code>Option</code> type provides a robust mechanism for managing optional values, it doesn’t entirely replace nullable types. Instead, consider them as tools in your toolbox, each with its strengths:</p>
			<ul>
				<li>Use nullable reference types when working with native C# constructs or when interfacing with libraries/frameworks expecting them</li>
				<li>Adopt the <code>Option</code> type in scenarios requiring richer functional operations or when building libraries with a functional flavor</li>
			</ul>
			<p>The <code>Option</code> type brings a taste of pure functional programming to the C# world, offering a sophisticated toolset for handling optional values. By integrating these constructs into your applications, you elevate the clarity, robustness, and expressiveness of your code. While the learning curve might be steeper than with nullable types, the <a id="_idIndexMarker239"/>rewards in terms of code quality and resilience are well worth the effort.</p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor196"/>Practical scenarios – handling nulls effectively</h1>
			<p>As you must have <a id="_idIndexMarker240"/>already seen, dealing with nulls isn’t just a theoretical concern; it’s a daily challenge. By examining real-world scenarios, we can better appreciate the need for clear strategies in managing nulls and ensuring robust, reliable applications.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor197"/>Case study – managing YouTube videos</h2>
			<p><strong class="bold">Scenario</strong>: A system<a id="_idIndexMarker241"/> retrieves video details from a database. Not every video ID queried will have a corresponding video entry.</p>
			<p><strong class="bold">Traditional approach</strong>:</p>
			<pre class="source-code">
public Video GetVideoDetails(int videoId)
{
    var video = database.FindVideoById(videoId);
    if (video == null)
    {
        throw new VideoNotFoundException($"Video with ID {videoId} not found.");
    }
    return video;
}</pre>			<p><strong class="bold">Option approach</strong>:</p>
			<pre class="source-code">
public Option&lt;Video&gt; GetVideoDetails(int videoId)
{
    var video = database.GetVideoById(videoId);
    return new Option&lt;Video&gt;(video);
}</pre>			<p>By returning <code>Video?</code>, we’re signaling the potential absence of a video explicitly. Calling functions can then use <a id="_idIndexMarker242"/>pattern matching or direct null checks to handle the absence gracefully.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor198"/>Case study – managing different video types</h2>
			<p><strong class="bold">Scenario</strong>: As YouTube<a id="_idIndexMarker243"/> started supporting various video formats and sources (e.g., live streams, 360-degree videos, standard uploads), the backend systems had to correctly identify and process each video type. With the platform’s increasing complexity and new video formats being introduced, using traditional if-else statements to handle these became cumbersome and less maintainable. Pattern matching emerged as an efficient solution to this challenge.</p>
			<p><strong class="bold">Traditional approach</strong>:</p>
			<pre class="source-code">
public string GetVideoDetails(Video video)
{
    if (video is LiveStream)
    {
        var liveStream = video as LiveStream;
        return $"Live Stream titled '{liveStream.Title}' is currently {liveStream.Status}.";
    }
    else if (video is Video360)
    {
        var video360 = video as Video360;
        return $"360-Degree Video titled '{video360.Title}' with a resolution of {video360.Resolution}.";
    }
    // ... and so on for other video types
    else
    {
        return "Unknown video type.";
    }
}</pre>			<p><strong class="bold">Pattern </strong><strong class="bold">matching approach</strong>:</p>
			<pre class="source-code">
public string GetVideoDetails(Video video)
{
    return video switch
    {
        LiveStream l =&gt; $"Live Stream titled '{l.Title}' is currently {l.Status}.",
        Video360 v =&gt; $"360-Degree Video titled '{v.Title}' with a resolution of {v.Resolution}.",
        StandardUpload s =&gt; $"Standard video titled '{s.Title}' uploaded on {s.UploadDate}.",
        _ =&gt; "Unknown video type."
    };
}</pre>			<p>Pattern matching provided a more elegant, concise, and readable approach to handling different video types. As YouTube introduces new video formats or features, they can be seamlessly integrated <a id="_idIndexMarker244"/>into the <code>GetVideoDetails</code> function. This modern approach reduces potential errors, simplifies the code, and enhances maintainability.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor199"/>Case study – working with non-existing objects</h2>
			<p><strong class="bold">Scenario</strong>: As YouTube <a id="_idIndexMarker245"/>expanded globally, it was increasingly common to encounter incomplete or missing data due to various reasons, such as network hiccups, data migration issues, or regional content restrictions. Using traditional null checks became increasingly cumbersome, leading to scattered logic throughout the code base. The null object pattern offered a systematic approach to provide a default object instead of a null reference.</p>
			<p><strong class="bold">Traditional approach</strong>:</p>
			<pre class="source-code">
public Video GetVideo(int videoId)
{
    var video = database.FindVideoById(videoId);
    if (video == null)
    {
        throw new VideoNotFoundException($"Video with ID {videoId} not found.");
    }
    return video;
}</pre>			<p>And when displaying <a id="_idIndexMarker246"/>the video:</p>
			<pre class="source-code">
var video = GetVideo(videoId);
if(video != null)
{
    Display(video);
}
else
{
    ShowError("Video not found");
}</pre>			<p><strong class="bold">Null object </strong><strong class="bold">pattern approach</strong>:</p>
			<p>First, create a default object for videos:</p>
			<pre class="source-code">
public class NullVideo : Video
{
    public override string Title =&gt; "Video not available";
    public override string Description =&gt; "This video is currently not available.";
    // Other default properties or methods...
}</pre>			<p>Then modify the fetching method:</p>
			<pre class="source-code">
public Video GetVideo(int videoId)
{
    return database.FindVideoById(videoId) ?? new NullVideo();
}</pre>			<p>Then display the video:</p>
			<pre class="source-code">
var video = GetVideo(someId);
Display(video); // No special null handling here</pre>			<p>By adopting the null object pattern, YouTube’s Video Management System managed to encapsulate the behavior associated with null or missing data within the default “null object,” leading to <a id="_idIndexMarker247"/>more unified and predictable system behavior. It removed numerous null checks scattered throughout the code base, reducing the chances of null reference exc<a id="_idTextAnchor200"/>eptions, and enhancing the system’s robustness and maintainability.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor201"/>The impact of handling nulls in real-world scenarios</h2>
			<p>In real-life situations, how <a id="_idIndexMarker248"/>we deal with null values in our code can have a big impact. Let’s explore how handling nulls can make a difference:</p>
			<ul>
				<li><code>NullReferenceException</code></li>
				<li><strong class="bold">Clearer intention</strong>: Using tools such as nullable reference types and pattern matching, our code more transparently communicates potential outcomes</li>
				<li><strong class="bold">Developer confidence</strong>: When the system’s behavior is predictable, developers can integrate and extend it with greater confidence</li>
			</ul>
			<p>In real-world scenarios, the unknowns and uncertainties are plentiful. By incorporating clear and transparent handling of potential nulls, we ensure that our applications are both resilient and maintainable. Whether you’re managing video data, processing forms, or integrating with third-party services, a deliberate approach to null management can make all the<a id="_idIndexMarker249"/> difference.</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor202"/>The reality of honesty in C# – why there will never be truly honest functions</h1>
			<p>C# is a multi-paradigm<a id="_idIndexMarker250"/> language, offering a lot of features, each designed with various considerations in mind. As we venture into the topic of “honest functions,” we must also acknowledge that C#’s design, while powerful, has some trade-offs.</p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor203"/>The compromises of the C# language design</h1>
			<p>C#’s design involves certain <a id="_idIndexMarker251"/>trade-offs. Let’s examine them and understand their impact:</p>
			<ul>
				<li><strong class="bold">Historical baggage</strong>: C# has evolved over the years, adding new features while ensuring backward compatibility. This means that older, less “honest” ways of doing things will always remain a part of the language.</li>
				<li><strong class="bold">Performance versus safety</strong>: Offering both low-level performance-oriented features and high-level safety features is not easy. Sometimes, the requirements of performance might lead developers away from purely “honest” constructs.</li>
				<li><strong class="bold">Broad audience</strong>: C# is designed for a vast range of developers, from those writing system-level code to high-level enterprise applications. As a result, the language can’t be too opinionated in favor of any single paradigm, including functional programming.</li>
				<li><code>OutOfMemoryException</code>, for example. Although, we might think that if we are the creators of our code it will do as we wish, don’t forget that the <strong class="bold">Common Language Runtime</strong> (<strong class="bold">CLR</strong>) is the<a id="_idIndexMarker252"/> true master here and it can interfere with our intentions.</li>
			</ul>
			<p>C# offers a rich variety of features, enabling developers to craft solutions across different paradigms. In our pursuit of honesty and clarity, we should recognize and respect the trade-offs intrinsic to the language’s design. Additionally, we need to remember that our <a id="_idIndexMarker253"/>code does not run in an ideal world and that the environment also impacts the way our programs work.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor204"/>Practical tips and best practices</h1>
			<p>As we navigate the nuances of functional programming in C# and its approach to handling nulls, some practical strategies emerge. These strategies ensure that our applications remain robust while benefiting from t<a id="_idTextAnchor205"/>he enhanced clarity and predictability that functional paradigms provide.</p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor206"/>Strategies for migrating existing code bases to adopt nullable reference types and Option</h2>
			<p>Let’s consider <a id="_idIndexMarker254"/>strategies for migrating your existing code bases to adopt nullable reference types and <code>Option</code>:</p>
			<ul>
				<li><code>#nullable </code><code>enable</code> directive:<pre class="source-code">
#nullable enable
// The section of the code where nullable reference types are enabled.
#nullable restore</pre></li>				<li><strong class="bold">Use of analysis tools</strong>: Tools such as Roslyn analyzers (<a href="https://docs.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview">https://docs.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview</a>) can help identify potential nullability issues in code.</li>
				<li><code>Option</code> type, ensure you understand the implications of the calling code. Functio<a id="_idTextAnchor207"/>ns may return different types, requiring adjustments to the calling logic.</li>
			</ul>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor208"/>Common pitfalls and how to navigate them</h2>
			<p>Let’s take a closer <a id="_idIndexMarker255"/>look at common pitfalls and discover how to effectively navigate them:</p>
			<ul>
				<li><strong class="bold">Assuming non-null values prematurely</strong>: Even with nullable reference types enabled, always validate inputs, especially if they come from external sources:<pre class="source-code">
public void ProcessData(string? data)
{
    if (data is null)
    {
        throw new ArgumentNullException(nameof(data));
    }
    // Rest of the processing...
}</pre></li>				<li><code>Option</code> type is powerful, it might not be suitable for every scenario. For simple cases where nullability is self-explanatory, nullable reference types might be more appropriate.</li>
				<li><strong class="bold">Forgetting legacy code</strong>: Older parts of the code base may not adhere to new paradigms. When integra<a id="_idTextAnchor209"/>ting new and old code, be cautious of potential mismatches in expectations.</li>
			</ul>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor210"/>Testing strategies for null and Option handling</h2>
			<p>Let’s talk about how to <a id="_idIndexMarker256"/>test your code when it deals with null and <code>Option</code> in a functional programming way. It’s important to test that your code works correctly, and now we’ll explore how to do that:</p>
			<ul>
				<li><strong class="bold">Unit testing with null values</strong>: Ensure unit tests cover scenarios where null values are passed to functions. This helps catch potential null-related issues before they reach production:<pre class="source-code">
[Test]
public void GetUser_NullInput_ThrowsException()
{
    // arrange part of the test
    // act &amp; assert
    Assert.Throws&lt;ArgumentNullException&gt;(() =&gt; sut.GetUser(null));
}</pre></li>				<li><code>Option</code> types, tests should cover <a id="_idIndexMarker257"/>both <code>Some</code> and <code>None</code> scenarios to ensure all code paths are verified:<pre class="source-code">
[Test]
public void GetUser_PresetUserId_ReturnsProfile()
{
    // arrange part of the test
    // act
    var result = sut.GetUser(123);
    // assert
    User user;
    if (!result.IsSome(out user))
    {
        Assert.Fail("Expected a user profile.");
    }
    // The rest of the assertions
}</pre></li>				<li><strong class="bold">Integration testing</strong>: Beyond unit tests, integration tests should be employed to validate interactions between different components, especially when dealing with databases, APIs, or other external systems that might return unexpected null values.</li>
			</ul>
			<p>Learning about functional programming in C# might not be an easy thing, but you have already started this <a id="_idIndexMarker258"/>venture and continued it right up to the current lines. You are doing great, so keep it up, and let’s reinforce the knowledge you’ve acquired with our traditional three exercises.</p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor211"/>Exercises</h1>
			<p>Now that Steve has learned about honest functions, null, and Option types, Julia has prepared some challenges to help him apply these concepts to his tower defense game. Let’s see if you can help Steve solve them!</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor212"/>Exercise 1</h2>
			<p>Steve’s game needs to fetch tower information reliably. Refactor this function to use an honest return type that clearly indicates when a tower might not be found:</p>
			<pre class="source-code">
public Tower GetTowerByPosition(Vector2 position)
{
     var tower = _gameMap.FindTowerAt(position);
     return tower;
}</pre>			<h2 id="_idParaDest-147"><a id="_idTextAnchor213"/>Exercise 2</h2>
			<p>In the game players can apply power-ups to towers. Refactor this function to ensure it handles null inputs gracefully:</p>
			<pre class="source-code">
public void ApplyPowerUp(Tower tower, PowerUp powerUp)
{
     tower.ApplyPowerUp(powerUp);
     _gameState.UpdateTower(tower);
}</pre>			<h2 id="_idParaDest-148"><a id="_idTextAnchor214"/>Exercise 3</h2>
			<p>Steve wants to provide players with detailed information about the enemies they’re facing. Using the enemy classes from his game, implement a function that generates descriptive strings for each enemy type:</p>
			<pre class="source-code">
public abstract class Enemy {}
public class Goblin : Enemy
{
     public int Strength { get; set; }
     public bool HasWeapon { get; set; }
}
public class Dragon : Enemy
{
     public int FireBreathDamage { get; set; }
     public int WingSpan { get; set; }
}
public class Wizard : Enemy
{
     public string[] Spells { get; set; }
     public int MagicPower { get; set; }
}
public string DescribeEnemy(Enemy? enemy)
{
     // Your implementation here
}</pre>			<h1 id="_idParaDest-149"><a id="_idTextAnchor215"/>Solutions</h1>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor216"/>Exercise 1</h2>
			<p>Incorporate the <code>Option</code> return type to signify that a user may or may not be found:</p>
			<pre class="source-code">
public Option&lt;Tower&gt; GetTowerByPosition(Vector2 position)
{
     var tower = _gameMap.FindTowerAt(position);
     return Option&lt;Tower&gt;.Some(tower);
}</pre>			<h2 id="_idParaDest-151"><a id="_idTextAnchor217"/>Exercise 2</h2>
			<p>Utilize a built-in check for null inputs that will throw an exception if the user profile is <code>null</code>:</p>
			<pre class="source-code">
public void ApplyPowerUp(Tower? tower, PowerUp? powerUp)
{
     ArgumentNullException.ThrowIfNull(tower, nameof(tower));
     ArgumentNullException.ThrowIfNull(powerUp, nameof(powerUp));
     tower.ApplyPowerUp(powerUp);
     _gameState.UpdateTower(tower);
}</pre>			<h2 id="_idParaDest-152"><a id="_idTextAnchor218"/>Exercise 3</h2>
			<p>Employ pattern matching to address potential null values elegantly:</p>
			<pre class="source-code">
public string DescribeEnemy(Enemy? enemy)
{
     return enemy switch
     {
                  Goblin g =&gt; $"A goblin with {g.Strength} strength, {(g.HasWeapon ? "armed" : "unarmed")}.",
                  Dragon d =&gt; $"A dragon with {d.FireBreathDamage} fire breath damage and a {d.WingSpan}m wingspan.",
                  Wizard w =&gt; $"A wizard with {w.MagicPower} magic power, knowing {w.Spells.Length} spells.",
                  null =&gt; "No enemy in sight.",
                  _ =&gt; "An unknown enemy approaches!"
     };
}</pre>			<p>These exercises and their solutions provide an applied understanding of the concepts covered, guiding you toward a functional and robust approach to handling nulls and honest functions in C#. Keep experimenting, keep iterating, and always lean into the principles of functional programming to craft clearer, more resilient C# code.</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor219"/>Summary</h1>
			<p>As our journey through honest functions and the intricacies of null handling in C# draws to a close, let’s reflect on our discoveries and look to the future.</p>
			<p>We have traversed the history and implications of <code>null</code> in C#. We’ve understood its nuances, its dangers, and its power. By now, the infamous <code>NullReferenceException</code> should be less of a nemesis and more of an old acquaintance you nod at from across the room, acknowledging its presence but never letting it disrupt your day.</p>
			<p>Honest functions – or functions that explicitly state their intentions, inputs, and outputs – represent a paradigm shift toward predictability, clarity, and resilience. Embracing honesty in functions is not merely about avoiding pitfalls but about embracing a philosophy of transparency. In doing so, we create code that other developers can trust, understand, and build upon.</p>
			<p>We’ve dived deep into the realms of nullable reference types and pattern matching and even touched upon the null object pattern and the <code>Option</code> type, all of which present us with powerful tools to express our intentions with precision and grace.</p>
			<p>Yet, as with all tools, it’s essential to remember that their strength lies in their appropriate application. The world of C# is vast, and while functional programming principles offer much value, they are but one aspect of a rich tapestry. It’s up to you, the developer, to discern when to employ these concepts and when to lean into other paradigms. As we add a functional paradigm to our habitual way of coding, it may cause different errors and we’d better be ready to work with them. That’s why I invite you to read the next chapter, about error handling.</p>
		</div>
	

		<div><h1 id="_idParaDest-154" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor220"/>Part 2:Advanced Functional Techniques</h1>
			<p>Building on the foundations established in Part I, we now delve into more advanced functional programming techniques. We’ll start by exploring functional approaches to error handling, moving beyond traditional try-catch blocks to more elegant solutions. Next, we’ll cover higher-order functions and delegates, unlocking the power of functions as first-class citizens. The section concludes with an in-depth look at functors and monads, advanced concepts that provide powerful tools for managing complexity in your code.</p>
			<p>This part has the following chapters:</p>
			<ul>
				<li><a href="B21069_05.xhtml#_idTextAnchor221"><em class="italic">Chapter 5</em></a><em class="italic">, Error Handling</em></li>
				<li><a href="B21069_06.xhtml#_idTextAnchor270"><em class="italic">Chapter 6</em></a><em class="italic">, Higher-Order Functions and Delegates</em></li>
				<li><a href="B21069_07.xhtml#_idTextAnchor332"><em class="italic">Chapter 7</em></a><em class="italic">, Functors and Monads</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</body></html>