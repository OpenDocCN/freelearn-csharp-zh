- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two chapters, we looked at controls – the widgets that ask for
    and display data – but widgets need to be positioned on the page, with a process
    called the layout. Layout is the difference between an ugly app and a professional-looking
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several layout controls available to you, which we will cover in
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Vertical and horizontal stack layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Grid`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scrolling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flex layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I am not a designer
  prefs: []
  type: TYPE_NORMAL
- en: For a page to look professional, a designer must work with the developer, specifying
    not only where to put the controls but also the font size, font, margins, and
    so on. I am not a designer, and the pages we’ll create are for illustration purposes
    only; they will not be pretty.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for this chapter can be found in the GitHub repository under
    this branch: [https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/Layouts](https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/Layouts)'
  prefs: []
  type: TYPE_NORMAL
- en: Stack layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Stack layouts allow you to stack one control on top of another or next to one
    another. They come in three flavors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`StackLayout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VerticalStackLayout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HorizontalStackLayout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first of these is for backward compatibility with `Xamarin.Forms` and is
    effectively deprecated; the other two are far more performant.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve seen `VerticalStackLayout` and `HorizontalStackLayout` at work already.
    As the name indicates, `VerticalStackLayout` places one control *on top of* another,
    while `HorizontalStackLayout` places them side by side. Using `margins` (the space
    between objects) and `padding` (the space around an object), you can tweak a nice
    enough layout with just these controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, on the `LoginPage` page, we start with a `VerticalStackLayout` object,
    which will contain everything below it until the closing `</VerticalStackLayout>`
    tag. Immediately, we declare a `HorizontalStackLayout` object, which contains
    a `Label` (acting as a prompt) and an `Entry` (gathering the name from the user).
  prefs: []
  type: TYPE_NORMAL
- en: Below `HorizontalStackLayout` is a second `HorizontalStackLayout` and below
    that is a `BoxView`. In short, `VerticalStackLayout` continues to stack views
    on top of each other.
  prefs: []
  type: TYPE_NORMAL
- en: While this is fine for a very simple layout, it has its limitations. Working
    with `VerticalStackLayout` and `HorizontalStackLayout` on complicated layouts
    becomes difficult after a short while.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the most powerful layout of them all: `Grid`.'
  prefs: []
  type: TYPE_NORMAL
- en: Grid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nothing comes close to `Grid` for flexibility, although its basic use is dead
    simple. A grid consists of rows and columns. You define the size of each and then
    fill in the resulting boxes.
  prefs: []
  type: TYPE_NORMAL
- en: By default, all the columns are the same width, and all the rows are the same
    height. Rows and columns are identified (by default) by their offset starting
    at column 0, row 0\. You can leave out the 0 (it is the default value) but I advise
    against doing so for readability. (This is the same reason I mark private methods
    and classes with the `private` keyword.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We can recreate the `LoginPage` page using `Grid`. Let’s look at the first
    approximation in full (I’ve left out the resources section, as it is unchanged):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing to add is the frames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'With that in place, we can add the three buttons and then close `Grid` and
    `VerticalStackLayout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[1] We’ll put `Grid` inside a `VerticalStackLayout` so that we can add the
    `ProgressBar` below the grid (adding it to `VerticalStackLayout`’s `Children`
    collection, which will have only two members: `Grid` and `ProgressBar`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] We declare `Grid` with the keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] We declare three columns of equal size (`*,*,*`).'
  prefs: []
  type: TYPE_NORMAL
- en: “Some have stars upon thars” – Dr. Seuss
  prefs: []
  type: TYPE_NORMAL
- en: 'Stars don’t make much difference when they are all the same size, but if, for
    example, we wanted the first to be twice as big as the others, we would write
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ColumnDefinitions="2*,*,*"`'
  prefs: []
  type: TYPE_NORMAL
- en: In that case, the column would be divided into four equal parts and the first
    column would get two of them and the other columns one each. The result is that
    the first column would be twice as wide as the others.
  prefs: []
  type: TYPE_NORMAL
- en: '[4] Similarly, we declare five rows of equal size.'
  prefs: []
  type: TYPE_NORMAL
- en: '[5] We place the Label inside column 0.'
  prefs: []
  type: TYPE_NORMAL
- en: '[6] We place the Label inside row 0.'
  prefs: []
  type: TYPE_NORMAL
- en: '[7] The horizontal option is with respect to the column the control is in.'
  prefs: []
  type: TYPE_NORMAL
- en: '[8] The vertical option is with respect to the row the control is in.'
  prefs: []
  type: TYPE_NORMAL
- en: '[9] A control can span across more than one column. In this case, the entry
    begins at column 1 and runs for a column span of 2 (that is, it occupies both
    column 1 and 2).'
  prefs: []
  type: TYPE_NORMAL
- en: '[10] Notice that we don’t need a `HorizontalStackLayout` because the position
    of the prompt with respect to the entry is determined by what columns they are
    in and their horizontal options (for example, start, center, or end).'
  prefs: []
  type: TYPE_NORMAL
- en: '[11] `BoxView` wants to stretch across the entire grid and so starts at column
    0 and has a column span of 3.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that nothing else needs to change. I manipulated the margins and vertical
    options to get the *pixel-perfect* alignment I was looking for, but other than
    that, the XAML remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: One other thing to note is that we have an opportunity to factor out the vertical
    and horizontal options and the margins into the styles.
  prefs: []
  type: TYPE_NORMAL
- en: The result of converting the `StackLayout` into this grid is shown in *Figure
    6**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – First grid layout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.1_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – First grid layout
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `ProgressBar` is still shown. It is added to `VerticalStackLayout`
    in the code-behind as it was previously.
  prefs: []
  type: TYPE_NORMAL
- en: Sizing rows and columns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`RowHeight` and `ColumnWidth` can be defined in one of three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '*absolute*: A value in DIUs'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*auto*: Auto-sized based on the cell contents'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Stars*: As shown earlier, with proportional allocation'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Currently, the top of the `Grid` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We could have used `auto` to say that each control will take up the amount
    of room it needs on each row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let’s also set the height of the frames to `150`. `auto` allocates enough room
    for the newly enlarged frames, as illustrated in *Figure 6**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Using auto-sizing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.2_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – Using auto-sizing
  prefs: []
  type: TYPE_NORMAL
- en: Best practice – minimize use of auto
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft recommends minimizing the use of `auto` as it is less performant (the
    layout engine has to perform additional calculations). That being said, at times,
    it is very useful, especially when the size of the object will be determined at
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could rewrite the rows shown before as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The calculation now would be to find the actual size of the three `auto` rows
    and add `50` Device-Independent Units, for the fifth row. Then, we take what is
    left in the grid size, and divide it equally between the first and second rows.
    The result is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Combining stars, absolute, and auto'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.3_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – Combining stars, absolute, and auto
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, by mixing and matching, you can create an awful-looking UI.
    On the other hand, given to a designer, these three options (`absolute`, stars,
    and `auto`) can be used to create beautiful UIs with precise control over sizing.
  prefs: []
  type: TYPE_NORMAL
- en: Named rows and columns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding code, we referred to each row and column by its zero-based
    offset. Thus, the frames were in `Grid.row[3]` in `Grid.column[0]` and `Grid.column[1]`.
    With large grids, this can become confusing and difficult to manage.
  prefs: []
  type: TYPE_NORMAL
- en: In C#, .NET MAUI offers you the option of naming your rows and columns using
    an enumeration. To see this, let’s create an alternative login page, entirely
    in C#, and then take a look at it.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll simplify the page slightly, taking out `BoxView` and `Frame`, to keep
    our focus on the manipulation of the rows and columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to define enumerations, which will serve as the names of
    our rows and columns, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: What you use for these names is entirely up to you; typically, you’ll use something
    that describes what goes into those rows and columns. Thus, here, my first row
    will hold `Username`, my second row will hold `Password`, and my third row will
    hold our three `Buttons`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the columns are named after the type of buttons. That makes it difficult
    (or confusing) to use those columns with these rows. We’ll solve that by falling
    back to using offsets on those rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the complete class, which I named `LoginCS.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[1] The work is done in the constructor'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] As in the XAML, we start with `VerticalStackLayout`'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] `Grid` is a child of `VerticalStackLayout`'
  prefs: []
  type: TYPE_NORMAL
- en: '[4] We define the first row to use the enumerated name and the sizing of `auto`'
  prefs: []
  type: TYPE_NORMAL
- en: '[5] We define the first column to use the enumerated column name and the sizing
    of a *star* (equivalent to 1 `*`)'
  prefs: []
  type: TYPE_NORMAL
- en: '[6] Notice that while the row name is meaningful and I therefore use it, the
    column name would not be meaningful and so I just use the offset'
  prefs: []
  type: TYPE_NORMAL
- en: '[7] Here, both the row name and the column name are meaningful, and it is much
    easier to figure out what is going on by using these names rather than the offsets'
  prefs: []
  type: TYPE_NORMAL
- en: There is no doubt that `.Row(Row.Buttons).Column(Column.Create)` is much easier
    to understand than `Row[4].Column[1]`.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use this page, don’t forget to point to your new page, `LoginCS.cs`,
    in `AppShell.xaml`.
  prefs: []
  type: TYPE_NORMAL
- en: Oops
  prefs: []
  type: TYPE_NORMAL
- en: The `Submit` button will crash the program as the `Submit` command in `LoginViewModel`
    is looking for `LoginPage.LoginProgressBar`. We could fix this, but the goal here
    was to show that you can re-write `LoginPage` in C#.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll stay with the original `LoginPage.xaml` for the rest of this book, as
    that is more complete.
  prefs: []
  type: TYPE_NORMAL
- en: ScrollView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, you will have more data to show than can fit on the page. This is especially
    frequent when working with lists, but can also be true for a form. The `ScrollView`
    control wraps around your other controls and allows them to be scrolled.
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw the use of `ScrollView` in `PreferencesPage`, where we wrapped `VerticalStackLayout`
    in a `ScrollView` control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The number of preferences was just more than would show on a phone screen all
    at once. You can see the scroll effect a bit more if you add some more preferences
    to `PreferenceService`.
  prefs: []
  type: TYPE_NORMAL
- en: FlexLayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`FlexLayout` is similar to `VerticalStackLayout` and `HorizontalStackLayout`
    with one crucial distinction: if you are using one of the stack layouts and the
    items extend past the end of the page (and you don’t use `ScrollView`), anything
    that doesn’t fit won’t be rendered.'
  prefs: []
  type: TYPE_NORMAL
- en: FlexLayout – seem familiar?
  prefs: []
  type: TYPE_NORMAL
- en: '`FlexLayout` might be familiar if you’ve worked with CSS. `FlexLayout` is very
    similar to the Flexible Box Layout and, in fact, was based on the CSS module.'
  prefs: []
  type: TYPE_NORMAL
- en: You can see the effect of `FlexLayout` by removing `ScrollView` from `PreferencesPage`.
    All of the remaining preferences are inaccessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `FlexLayout`, the items are wrapped to the next row or column. You define
    which by setting the direction in `FlexLayout`. The possible directions are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Row`: Stacks children horizontally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Row-reverse`: Stacks horizontally in reverse order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Column`: Stacks children vertically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Column-reverse`: Stacks vertically in reverse order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remove `VerticalStackLayout` and replace it with `FlexLayout`. Set the direction
    to `Row`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 6**.4* shows the result. It is ugly but it conveys what is happening.
    The excess items are wrapped horizontally.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Mangling your screen with FlexLayout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.4_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – Mangling your screen with FlexLayout
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see whether we can come up with a better, less ugly example.
  prefs: []
  type: TYPE_NORMAL
- en: Wrap
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the properties of `FlexLayout` is `Wrap`, which defaults to *no-wrap*.
    Most of the time, however, you will want it to wrap, and you will end up with
    this wonderful syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Wrap = "``Wrap"`'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll return to the `Login` page and, just before the end, we’ll add a `HorizontalStackLayout`
    containing four buttons that won’t quite fit, as shown in *Figure 6**.5*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – The buttons don’t fit in the row'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.5_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – The buttons don’t fit in the row
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we’ll replace `HorizontalStackLayout` with `FlexLayout` with `Wrap` set
    to `Wrap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`FlexLayout` *sees* that the fourth button won’t fit and wraps it to the next
    row, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – FlexLayout wraps the buttons'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.6_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6 – FlexLayout wraps the buttons
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI has added a `BindableLayout` object, which, frankly, I don’t find
    terribly useful.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the principal layouts used in designing .NET MAUI
    apps. The most powerful and flexible of these is `Grid`, although `HorizontalStackLayout`
    and `VerticalStackLayout` are often used for somewhat simpler layouts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will examine how to move from page to page and how to
    send data as we move. We will look at the Shell and at routing, the essential
    aspects of page navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the three ways you can define the width of a column in a grid?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a grid’s column definition looks like this – `(2*, auto, *, 100)` – how will
    the space be divided?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If a `Button` object is defined like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What do we know about its position?
  prefs: []
  type: TYPE_NORMAL
- en: What is the advantage of `Grid` over using `VerticalStackLayout` and `HorizontalStackLayout`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is `BindableLayout` less useful than, for example, `CollectionView`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You try it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a page that looks like a standard four-function calculator. Use the
    layout shown in *Figure 6**.7*. Extra credit: implement the functionality and
    display the result in a `Label`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Four-function calculator](img/Figure_6.7_B19723.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – Four-function calculator
  prefs: []
  type: TYPE_NORMAL
- en: Part 2 – Intermediate Topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the basics under our belt, we’ll go on to look at a number of intermediate
    topics, including how you navigate from one page to the next and how you store
    data, both for a user’s preferences and in a relational database. We’ll end with
    the most important topic – creating unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19723_07.xhtml#_idTextAnchor129), *Understanding Navigation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B19723_08.xhtml#_idTextAnchor144), *Storing and Retrieving Data*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B19723_09.xhtml#_idTextAnchor160), *Unit Testing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
