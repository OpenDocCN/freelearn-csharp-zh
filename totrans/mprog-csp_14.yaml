- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aspect-Oriented Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout the book, you should have noticed a theme: automation. This means
    writing code that makes your code easier, more maintainable, and takes away repetitive
    work. In [*Chapter 13*](B19418_13.xhtml#_idTextAnchor206), *Applying Cross-Cutting
    Concerns*, we talked about code that could be created for a specific concern and
    be automatically applied. In this chapter, we will take this concept to the next
    level and dive into a formalization that is designed for this purpose; **aspect-oriented**
    **programming** (**AOP**).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is AOP?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should have a solid understanding of AOP and
    how it can be used in C# to create more modular, maintainable, and scalable applications.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code specific to the chapter can be found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter14](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter14))
    and it builds on top of the **Fundamentals** code that is found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals)).
  prefs: []
  type: TYPE_NORMAL
- en: What is AOP?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In traditional programming, developers write code to implement the desired behavior
    of their applications. This code is organized into functions, classes, and modules
    that implement specific functionalities. However, many applications require additional
    functionality that spans multiple parts of the codebase, such as logging, error
    handling, and security. These functionalities, often referred to as cross-cutting
    concerns, can be difficult to manage and maintain when scattered throughout the
    codebase.
  prefs: []
  type: TYPE_NORMAL
- en: AOP is a programming paradigm that aims to address this problem by separating
    cross-cutting concerns from the rest of the code. In AOP, developers define aspects,
    which encapsulate the behavior of cross-cutting concerns, and apply them to specific
    parts of the codebase using join points and pointcuts.
  prefs: []
  type: TYPE_NORMAL
- en: AOP is very well suited in combination with other programming paradigms, such
    as **object-oriented programming** (**OOP**) and **functional programming** (**FP**),
    to create more modular, maintainable, and scalable applications. AOP has become
    increasingly popular in recent years, and there are many AOP frameworks available
    for various programming languages and platforms.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore how AOP can be used in C# to address cross-cutting
    concerns and improve code maintainability and reusability. We will cover the key
    concepts of AOP, such as aspects, pointcuts, and join points, and show how they
    can be applied to specific use cases, such as security and logging. We will do
    so using a framework called Castle Windsor ([https://www.castleproject.org/projects/windsor/](https://www.castleproject.org/projects/windsor/)),
    and show how you use it to implement AOP in your C# applications.
  prefs: []
  type: TYPE_NORMAL
- en: Aspects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In AOP, an aspect is a modular unit of behavior that can be selectively applied
    to different parts of a program. An aspect is essentially a set of instructions
    that describe how to modify the behavior of a program in a particular way.
  prefs: []
  type: TYPE_NORMAL
- en: Aspects are used to address cross-cutting concerns, which are concerns that
    span multiple parts of a program and cannot be encapsulated in a single module
    or class. Examples of cross-cutting concerns include logging, security, caching,
    and error handling.
  prefs: []
  type: TYPE_NORMAL
- en: An aspect can be thought of as a reusable, modular piece of code that can be
    applied to multiple parts of a program. Aspects can be designed to be composable
    so that different aspects can be combined to achieve more complex behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Aspects are typically implemented as classes or modules that define the behavior
    to be added to the program. In AOP frameworks such as Castle Windsor, aspects
    are often implemented as interceptors, which are classes that intercept calls
    to methods or properties and modify their behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Pointcuts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pointcuts are the mechanism used in AOP to specify the places in the code where
    an aspect should be applied. A pointcut is a set of join points, which are specific
    locations in the code where the aspect can be applied.
  prefs: []
  type: TYPE_NORMAL
- en: A join point is a point in the execution of a program where an aspect can be
    applied. Examples of join points include method calls, method executions, field
    accesses, and exception handlers.
  prefs: []
  type: TYPE_NORMAL
- en: To define a pointcut, you need to specify the join points that the pointcut
    includes. This can be done using a variety of criteria, such as method name, method
    signature, class name, or annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Join points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In AOP, join points are specific points in the execution of a program where
    an aspect can be applied. Join points represent specific events, or method calls
    in the program, that can be intercepted by an aspect. For example, a join point
    could be a method call, field access, or an exception being thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Join points are defined using pointcuts, which specify the criteria for selecting
    the join points where an aspect should be applied. Pointcuts can be defined using
    various criteria, such as method signatures, class names, or annotations. For
    example, a pointcut could select all methods that have a specific attribute or
    all methods in a specific namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Once a pointcut has been defined, it can be used to apply an aspect to the selected
    join points. Aspects can modify the behavior of the join points they intercept
    by adding, modifying, or removing functionality. For example, an aspect could
    add logging or caching functionality to a method call or validate user input before
    allowing it to be processed.
  prefs: []
  type: TYPE_NORMAL
- en: Join points are an essential concept in AOP, as they allow aspects to be applied
    selectively to specific parts of the codebase rather than having to modify the
    entire codebase to implement cross-cutting concerns. Join points also enable the
    modularization of cross-cutting concerns, making them easier to manage and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some common examples of join points in C# include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Method calls**: These are join points that intercept method calls, either
    before the method is called (using a before advice) or after the method is called
    (using an after advice)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Field access**: These are join points that intercept read or write access
    to a field, either before the field is accessed (using a before advice) or after
    the field is accessed (using an after advice)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exception handling**: Join points that intercept the throwing of an exception,
    allowing the aspect to handle the exception or modify its behavior'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram summarizes **Aspect**, **Pointcuts**, and **Join Points**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19418_14_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – AOP terminology visualization
  prefs: []
  type: TYPE_NORMAL
- en: With the terminology in place, we should now be ready to take a first dive into
    AOP and use it in some canonical examples.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging is often cited as the canonical example of how AOP can be used to improve
    the modularity and maintainability of software. Logging is a common cross-cutting
    concern, meaning that it affects multiple parts of a software system and cannot
    be easily encapsulated within a single module or class.
  prefs: []
  type: TYPE_NORMAL
- en: AOP provides a way to encapsulate the logging behavior and apply it consistently
    throughout the system without the need to modify each module or class individually.
    This allows developers to focus on the core functionality of their modules while
    still providing a consistent and coherent way to log system behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explore the role of logging in software systems and
    how AOP can be used to implement logging behavior in a modular and maintainable
    way. We will look at the benefits and drawbacks of different logging approaches
    and how AOP can help to address some of the challenges associated with logging
    in complex software systems.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a logging sample
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by creating a new project for the chapter. Create a folder called
    **Chapter14**, change into this folder in your command line and create a new console
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For this chapter, as discussed, we will use a framework called Castle Windsor.
    It’s one of many frameworks coming out of **The Castle Project**, which you can
    read more about it here ([http://www.castleproject.org/](http://www.castleproject.org/)).
    Castle Windsor is an **Inversion of Control** (**IoC**), a container that provides
    extensive capabilities performing AOP.
  prefs: []
  type: TYPE_NORMAL
- en: To make all the AOP magic possible, Castle Windsor is built on top of a project
    called Castle Core, which provides a convenient way to create dynamic runtime
    proxy objects, as we did in [*Chapter 6*](B19418_06.xhtml#_idTextAnchor098), *Dynamic
    Proxy Generation*. This could be a natural step up from having to do everything
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: It is all open source, and the concrete framework you will be using here is
    the **Windsor** part and can be found on GitHub ([https://github.com/castleproject/Windsor](https://github.com/castleproject/Windsor)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the package to dependency of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To get started with the Windsor container, you can simply replace the content
    of **Program.cs** with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The code creates an instance of **WindsorContainer** and instructs it to install
    any implementations of **IWindsorInstaller** from the running application. An
    installer is a way to configure the container. They are discovered in the **.Install()**
    call, and you can have multiple installers for specific use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to create **DefaultInstaller** that will set up a default behavior
    for the container. Add a file called **DefaultInstaller.cs** and make it look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The code implements the **IWindsorInstaller** interface and implements the **Install()**
    method. Within it, the code instructs **container** to register all classes from
    the application by associating it with a service represented by what is referred
    to as **DefaultInterfaces**. This means that it will establish a convention as
    we did in [*Chapter 10*](B19418_10.xhtml#_idTextAnchor162), *Convention over Configuration*,
    that says any class with a matching interface with a name prefixed by **I** will
    be bound together (**IFoo** -> **Foo**). Finally, it tells it that the lifestyle
    should be transient. Castle Windsor has a default life cycle of singleton, which
    could be dangerous and have undesired side effects, so my recommendation is to
    stay with transient as default and then override it when needed.
  prefs: []
  type: TYPE_NORMAL
- en: An installer is just a tool to help you structure your code and help you with
    keeping things focused on a single responsibility and enable a more cohesive codebase.
    You can, in fact, work directly with the container right after instantiating it,
    as we will see later. Some things make sense to do right away, while others should
    be separated.
  prefs: []
  type: TYPE_NORMAL
- en: '**Console.WriteLine()** is not optimal for logging, so let’s use the Microsoft
    logger instead.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Microsoft logger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By writing to the console using **Console.WriteLine()**, you don’t get any structure
    to your logging. Log messages just become text, and the format is what you put
    into it. You often also want a different output for your local development than
    in production. Using a structured logging approach captures any values used in
    a log statement that could then be forwarded to a centralized log database, indexing
    them and making them searchable. There are many such tools out there, a[nd I recommend
    looking](https://datalust.co/seq) at Seq ([https://datalust.co/seq](https://datalust.co/seq)),
    which provides a tool that is free for local development.
  prefs: []
  type: TYPE_NORMAL
- en: For this sample, we will use a library from Microsoft for structured logging.
    It is the same one used by Microsoft for everything they build. It provides extension
    points and can also be used with other popular logg[ing libraries, such](https://serilog.net)
    as Serilog ([https://serilog.net](https://serilog.net)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding package references to the core logging package and also to
    the **Console** output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then in the **Program.cs** file, add the following code at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The code creates **LoggerFactory** and configures it to output to the console.
    It then goes on to register the **ILoggerFactory** interface with the concrete
    instance you just configured into the Windsor IoC container. Any constructors
    with a dependency to **ILoggerFactory** will now get this instance. **ILoggerFactory**
    provides a way to create concrete **ILogger** instances, which is what will be
    used for logging.
  prefs: []
  type: TYPE_NORMAL
- en: In ASP.NET Core, **ILoggerFactory** is being used internally in some cases to
    create logger instances. While in other cases, constructors have a dependency
    to **ILogger** and, even more specifically, on the generic **ILogger<>** version.
    The generic version of **ILogger** allows you to get a scoped logger that is for
    your specific type. In the log output, you’ll see the source of the log messages,
    which is important metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s configure the IoC container to support both of these scenarios. In the
    **Program.cs** file, add the following code at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The code starts by using reflection to get the **CreateLogger<>()** extension
    method from **LoggerFactoryExtensions**. This is because **ILoggerFactory** only
    has a non-typed way of creating a logger, and the generic one is an extension
    method. Next, the code registers the untyped non-generic **ILogger** with the
    container using a factory method that will create the instance dynamically when
    asked. It then leverages the container to get **ILoggerFactory** and then creates
    a logger by giving it the type **Ilogger** is being injected into. Since the default
    behavior of Windsor is to make everything a singleton, we explicitly configure
    **Ilogger** to be transient. This way, we get different logger instances for the
    types using it. Otherwise, you would be sharing the same logger across all types.
    Lastly, the code configures the generic **ILogger<>** using a factory method that
    uses the **CreateLogger<>()** extension method from **LoggerFactoryExtensions**
    by creating a generic method for the requested type and its generic type argument.
  prefs: []
  type: TYPE_NORMAL
- en: With the basic logging infrastructure in place, we’re now ready to apply cross-cutting
    logging.
  prefs: []
  type: TYPE_NORMAL
- en: Interceptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Castle Windsor, there is the concept of interceptors. They represent how
    you can implement the actual aspect and perform the cross-cutting operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create one for handling logging for all method calls. In the root of
    **Chapter14**, add a file called **LoggingInterceptor.cs** and make it look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The code sets up an implementation of **IInterceptor** from Castle Windsor.
    In the **Intercept()** method, the code calls the **Proceed()** method on the
    invocation object, which will perform the actual call it is intercepting. Before
    and after this call is where we can do our cross-cutting operations.
  prefs: []
  type: TYPE_NORMAL
- en: With .NET 6, Microsoft introduced an approach to logging that helps you become
    even more structured by encapsulating log messages into its own code file. This
    helps you with the maintenance of log messages and makes it easier for those scenarios
    when you want to output the same log message for different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called **LoggingInterceptorLogMessages.cs** and add the following
    code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The code sets up a static partial class with extension methods for each log
    statement and leverages **[LoggerMessage]** to configure the log message, its
    severity, a unique identifier within the file or globally, and optionally, an
    event name. Since all the methods are also partial and do not have any implementations,
    the C# compiler will generate the necessary code for this.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: I find it to be good practice to make logger messages like this internal, for
    both the class and the methods. That way, you isolate them for their module and
    do not run the risk of making them an extension method that will show up as IntelliSense
    in your editor globally across different projects. Normally you should also use
    the generic **ILogger<>** as the type to extend for the extension method makes
    it specific to your concrete type. But since the log messages we have here are
    cross-cutting, we don’t know the type they will be used in.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the log messages in place for what we want to log, we can modify **LoggingInterceptor**
    to do the logging. Open the **LoggingInterceptor** file and change it to look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The code gets changed to take **ILoggerFactory** as a dependency in the constructor.
    In the **Intercept()** method, you now use the logger factory to create a logger
    for the target type. It then uses structured logging calling **BeforeInvocation()**
    and **AfterInvocation()** and passing the name of the method being invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Just seeing the method being invoked in your logs by name might not be enough
    information. The **IInvocation** type has details about the parameters being passed,
    and you could be logging them as well. The only thing to keep in mind would be
    to redact values that are sensitive, such as **General Data Protection Regulation**
    (**GDPR**)-related information or security information. Luckily, if you follow
    the advice in [*Chapter 4*](B19418_04.xhtml#_idTextAnchor059), *Reasoning about
    Types Using Reflection*, and use the **ConceptAs<>** encapsulation for types,
    you could easily identify the types you need to redact and automatically do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the interceptor in place, the next step is to hook it up to Castle Windsor.
    Open the **DefaultInstaller.cs** file and change it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The only change made to the installer is the registration of **LoggingInterceptor**.
    Castle Windsor does not know how to resolve concrete types automatically, so we
    register it manually. The second addition is to configure the registration for
    the default convention to include **LoggingInterceptor**.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have all the infrastructure in place, you need something to test
    it with. Let’s create a user service for registering users, not focusing on implementing
    it, just something to test the interceptor with.
  prefs: []
  type: TYPE_NORMAL
- en: Trying out the interceptor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a file called **IUsersService.cs** in the root of **Chapter14** and
    make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The interface holds a single method for registering a user.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the interface, you’ll need an implementation. Add a file called **UsersService.cs**
    and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The code represents an implementation of **IUsersService**. It takes **ILogger<UsersService>**
    as a dependency so that we can log from within it. For the **Register()** method,
    it only logs it, creates a new **Guid**, and returns this as a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a sample in place, you now need to get an instance of it and see that
    the interceptor works. Open the **Program.cs** file and add the following to the
    very end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The code asks the Castle Windsor container for an instance of **IUsersService**
    and then calls the **Register()** method. We put in **Console.ReadLine()** due
    to the use of async; if we didn’t, it would exit without any of the log messages
    being printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now run this using **dotnet run** or your preferred approach in your
    editor, and you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The calling code has no concept of the interceptor; it is configured once and
    will be weaved into the running code automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the implementation of the **Intercept()** method in **LoggingInterceptor**
    is a bit naïve. It should support errors, and it also needs to support asynchronous
    method calls properly. Open the **LoggingInterceptor.cs** file and change the
    **Intercept()** method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The code wraps the **Proceed()** call in **try {} catch {}** to be able to log
    the error, but rethrows it as the logging shouldn’t swallow the exception; it
    should bubble up to the original caller. For handling asynchronous calls, it looks
    at **ReturnValue** of the **invocation** instance if it is a **Task**. If it is
    a task, it will continue, and get notified when it is completed. Tasks can have
    a faulty state, which would be if the call results in an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C++, multiple inheritances provide a powerful way to combine behaviors from
    multiple base classes. However, this can lead to complexity and the diamond problem.
    Mixins provide a simpler alternative to multiple inheritances that avoids these
    issues and are particularly useful for implementing cross-cutting concerns in
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: In the .NET **common language runtime** (**CLR**), however, multiple inheritance
    is not supported, as it uses a single inheritance model. This means that there
    is no built-in mechanism for combining behaviors from multiple classes. Mixins
    can be used to achieve this, providing a way to add functionality to a class without
    needing to modify its inheritance hierarchy. In this section, we’ll explore what
    mixins are, how they work, and why you might want to use them in your C# applications
    to overcome the limitations of the .NET CLR’s single inheritance model.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key features of Castle Core is its support for dynamic proxies, which
    allow you to intercept method calls and add behavior at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Castle Windsor’s approach to mixins builds on this support for dynamic proxies
    to provide a way to compose behavior from multiple sources into a single object.
    Mixins allow you to define a set of behaviors as independent components, which
    can be combined with the behavior of another object to create a new object with
    the combined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In Castle Windsor, mixins are implemented using a combination of dynamic proxies
    and an interception. When you register a component with mixins, Castle Windsor
    creates a dynamic proxy object that intercepts method calls to the component and
    delegates them to the mixins. The mixins can then modify the behavior of the component
    by adding new functionality or modifying the behavior of existing methods.
  prefs: []
  type: TYPE_NORMAL
- en: To register a component with mixins in Castle Windsor, you typically define
    one or more interfaces that represent the mixins and register them as separate
    components with the container. You then register the component to which you want
    to add the mixins to and specify the mixins as dependencies. When the component
    is resolved from the container, Castle Windsor creates a dynamic proxy object
    that implements the component interface and the mixin interfaces and delegates
    method calls to the appropriate objects.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing it up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **UserService** you created earlier could be a candidate for mixins. In
    a system, you typically need a way to authenticate users and a way to ask whether
    they are authorized to perform an action. Obviously, .NET provides building blocks
    and great support for both authentication and authorization, but let’s say you
    want your abstraction on top of what .NET provides for specific use where you
    need to be able to authenticate a user by its username and password and then be
    able to ask whether the user is authorized to perform an action.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the folder for the **Chapter14** code, add a file called **IAuthenticator.cs**
    and put the following into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The **IAuthenticator** interface defines a method for performing authentication
    with a username and a password. It would typically return **true** if it could
    successfully authenticate the user and **false** if not.
  prefs: []
  type: TYPE_NORMAL
- en: 'An implementation of **IAuthenticator** can be put in a file called **Authenticator.cs**,
    which looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The code implements the **IAuthenticator** interface, and for demo purposes,
    it only returns **true**. Since we won’t be building anything specifically and
    are just demonstrating the power of mixins, this is OK for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the authorization part, you’re going to need another interface. Add a file
    called **IAuthorizer.cs** and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Checking for authorization is done by giving it a username and an action. The
    method will then return **true** if the user is authorized to perform the action
    and **false** if not.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the authorizer, you’ll also need an implementation, so create a file called
    **Authorizer.cs** and put the following into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As with the **Authenticator** implementation, it will just return **true** for
    demonstration purposes. This is where you’d have your logic for checking whether
    the user is authorized for a specific action.
  prefs: []
  type: TYPE_NORMAL
- en: The **IAuthenticator** and **IAuthorizer**, with their respective implementations,
    are separate, and they’re also separate from **IUsersService**. This is great
    as they represent different aspects of working with a user. They serve specific
    responsibilities of the system, and it’s logical to keep them separate, which
    leads to a more maintainable codebase.
  prefs: []
  type: TYPE_NORMAL
- en: However, it might be desirable to be able to access them all as one at runtime.
    This is where mixins come in and can make it look as if it is one implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to do so, you need to configure Castle Windsor correctly. Open the
    **DefaultInstaller.cs** file and at the top of the **Install()** method, add the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The code adds explicit container registrations for the **IAuthenticator** and
    **IAuthorizer** services. The reason for adding this explicitly is that we have
    to add an explicit registration for **IUsersService**, and this has to happen
    prior to the automatic registrations that are already set up in **DefaultInstaller**.
    If you were to register **IUsersService** after the automatic registrations, you
    would get an exception saying there are duplicate registrations.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the mixin, you’re going to need another explicit registration. Add the
    following code right after the **IAuthenticator** and **IAuthorize** registrations
    and before the automatic registrations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The registration for **IUsersService** is slightly different from what you’ve
    done before. First, it instructs Castle Windsor that **IUsersService** is implemented
    by **UsersService**, then it instructs it to implement some additional interfaces:
    **IAuthorizer** and **IAuthenticator**. The additional interfaces are then instructed
    to be implemented using the **.Mixins()** call that tells it that they’re implemented
    by their respective **Authorizer** and **Authenticator** components. Since this
    is an explicit registration, the automatic one will not kick in, and **LoggingInterceptor**
    you previously hooked up won’t kick in for this. For it to do so, you need to
    add an explicit **.Interceptors<>()** call for the interceptor. Lastly, you set
    the lifestyle to be transient.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run this with the debugger attached, you can investigate what has happened
    to **UserService**. In the **Program.cs** file, you can put a breakpoint right
    after you call **container.Resolve<IUserService>()**. Run the debugger to this
    point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19418_14_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – The debug breakpoint
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Debug** console (immediate window) of your editor/**integrated development
    environment** (**IDE**), you should be able to write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this should be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19418_14_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.3 – The implemented interfaces
  prefs: []
  type: TYPE_NORMAL
- en: 'To prove the calls are going to the mixins, you can add the following to the
    **Program.cs** file before **Console.ReadLine();**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The code assumes that **UserService** also implements the **IAuthenticator**
    and **IAuthorizer** interfaces and uses casting to get to them and calls the **Authenticate()**
    and **IsAuthorized()** methods, respectively. It then prints out the results of
    these.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run your application now, you should see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The downside to this approach is that it is not clear in the contract of **IUsersService**
    that it will also implement the **IAuthenticator** and **IAuthorizer** interfaces.
    However, this can be overcome by different techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'One approach is to have an interface that represents the composition without
    an implementation, for instance, something such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The **IUsersServiceComposition** interface is just for composition; it shouldn’t
    have any direct members on it as the goal is to combine implementations of **IUsersService**,
    **IAuthenticator**, and **IAuthorizer**. We can then leverage the underlying **ProxyGenerator**
    in the Castle **DynamicProxy** library to create a proxy that represents this
    with the implementations in the different components.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **DefaultInstaller.cs** file, you can now create a new type of registration
    for the new **IUsersServiceComposition** interface. At the end of the method,
    you can add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The code sets up a registration that uses a method to create the instance. With
    the **UsingFactoryMethod()** instruction, you’re giving Castle Windsor a method
    that will be called when it needs to resolve the instance. The factory method
    uses **ProxyGenerator** from the Castle **DynamicProxy** and adds the different
    mixins for the **IAuthorizer** and **IAuthenticator** interfaces by using the
    container to provide an instance of these. For **IUsersService**, we have to create
    an instance of it ourselves for this sample, providing the logger that uses the
    container to get an instance. The reason for this is that you already have a registration
    for **IUsersService** that adds mixins for the **IAuthorizer** and **IAuthenticator**
    interfaces, which would throw an exception when creating a proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the mixins are configured, the code creates a class proxy with a target
    based on the **object** type and tells it that it should implement the **IUsersServiceComposition**
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: With all that, you now get an instance that implements all the interfaces and
    delegates the implementation of them to the mixed-in instances. Kind of neat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using **IUserServiceComposition** is now much more intuitive and very clear
    for the consumer, as you don’t have to know what other interfaces it might implement.
    Open up the **Program.cs** file and add the following code before **Console.ReadLine()**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the program should now give you a result similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Mixins provide a powerful way to add behavior to an object by combining it
    with behavior from other objects. Some of the benefits of using mixins include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Composition**: Mixins allow you to compose complex behavior from simple,
    reusable components. This makes it easier to maintain and modify your code over
    time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Separation of concerns**: Mixins enable you to separate the concerns of an
    object by breaking it down into smaller, more focused pieces of functionality.
    This makes it easier to understand and reason about your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusability**: Mixins allow you to reuse behavior across multiple objects,
    which reduces code duplication and makes it easier to maintain and modify your
    code over time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility**: Mixins provide a flexible way to modify the behavior of an
    object by allowing you to selectively apply behavior as needed. This gives you
    greater control over the behavior of your code and makes it easier to customize
    for specific use cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testability**: Mixins allow you to test individual pieces of functionality
    in isolation, which makes it easier to write tests and ensure the correctness
    of your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixins are often used in conjunction with techniques such as pointcuts, which
    allow you to apply behavior to specific points in your code. Pointcuts provide
    a way to selectively apply mixins to specific parts of your code, which gives
    you even greater flexibility and control over the behavior of your code.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, mixins are a powerful tool for adding behavior to objects in a flexible,
    maintainable, and reusable way. When used in conjunction with pointcuts and other
    AOP techniques, they provide a powerful way to customize the behavior of your
    code and achieve greater modularity, flexibility, and testability.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authorization is a critical concern for many software systems, as it is important
    to ensure that users and applications only have access to the resources and functionality
    that they are authorized to use. AOP can be a powerful tool for implementing authorization
    behavior, as it allows developers to encapsulate authorization logic and apply
    it consistently throughout the system.
  prefs: []
  type: TYPE_NORMAL
- en: One approach to implementing authorization with AOP is to use join points to
    filter down to specific namespaces in C# code. Join points are points in the code
    where an aspect can be applied, such as method calls, field accesses, or object
    creation. By using join points to filter down specific namespaces, developers
    can apply authorization logic only to the relevant parts of the system, reducing
    the risk of errors or inconsistencies.
  prefs: []
  type: TYPE_NORMAL
- en: In AOP, a pointcut is a specific location in the source code where an aspect
    should be applied. In other words, it’s a way to define the set of join points
    (i.e., specific points in a program’s execution flow) where an aspect should be
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: Pointcuts are often defined using a combination of different criteria, such
    as method names, method signatures, class names, package names, annotations, and
    more. The criteria used to define a pointcut are typically expressed using a syntax
    known as a “pointcut expression” or “pointcut language.”
  prefs: []
  type: TYPE_NORMAL
- en: The pointcut language used may vary depending on the AOP framework being used.
    For example, in C#, with the help of libraries such as PostSharp, you can define
    pointcuts using a combination of attribute annotations and method signatures.
  prefs: []
  type: TYPE_NORMAL
- en: Once a pointcut is defined, it can be used to “weave” one or more aspects into
    the code at the specified join points. This means that the aspect’s behavior is
    inserted into the code at the specified join points without requiring any modification
    to the original source code.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, pointcuts provide a powerful way to apply cross-cutting concerns, such
    as logging, caching, or security, to specific parts of a program’s execution flow.
  prefs: []
  type: TYPE_NORMAL
- en: Using pointcuts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With interceptors, you might not want them applied to everything. This could
    especially be true for authorization. You could have parts of your application
    that do not require authorization, such as infrastructure, and possibly also concrete
    parts that are open to all users. With Castle Windsor, we can create pointcuts
    by leveraging selectors for the interceptors. This is a way to provide the actual
    interceptors to be applied dynamically based on type and method information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a service for adding to-do items to a list, represented with an
    **ITodoService** interface. Create a folder called **Todo** in the root of the
    **Chapter14** project, add a file called **ITodoService.cs**, and add the following
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The interface only exposes a simple **Add()** method for adding an item in
    the form of a string. Its implementation should be added to a file called **TodoService.cs**
    within the **Todo** folder and look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Since we’re not focused on building something that creates a **todo** item in
    a datastore, we just print what is added in the implementation. This is just to
    prove how you can leverage interceptors and selectors to filter what calls are
    made.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing you will need is an interceptor that checks whether the user
    is authorized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file called **AuthorizationInterceptor.cs** to the root of the **Chapter14**
    project and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The code implements the Castle **DynamicProxy** **IInterceptor** interface,
    and the constructor has a dependency on the **IUsersServiceComposition** service
    you created for the mixins section. The **Intercept()** method leverages the composed
    user service to check whether the user is authorized. If the user is authorized,
    it lets the invocation carry on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: The user is hardcoded to **jane@doe.io**, you would obviously need to get the
    currently logged-in user in a production system. Also, the implementation does
    not do anything if it’s not authorized. One approach could be to throw **UnauthorizedException()**
    and let that bubble up.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the actual pointcut that will be filtering down which interceptors to apply
    when, you must implement the **IinterceptorSelector** interface found in Castle
    **DynamicProxy**. Add a file in the root of the project called **InterceptorSelector.cs**
    and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The **SelectInterceptors()** method gets called with the target type and the
    method being called, and you’re given the configured interceptors. You can, at
    this stage, decide which interceptors should be applied to the method call. The
    code makes this decision by looking at the namespace of the type and anything
    that starts with **Chapter14.Todo** should have all interceptors, while anything
    else gets all interceptors except **AuthorizationInterceptor**.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the interceptor and the selector in place, you will have to register them
    both in the Castle Windsor container and hook them up for use in existing registrations.
    Open the **DefaultInstaller.cs** file and add the following to the top of the
    **Install()** method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The code registers both **InterceptorSelector** and **AuthorizationInterceptor**
    with the container, making them possible to be injected into services needing
    it. In the **Install()** method, there are two places where you’ve already added
    **LoggingInterceptor**; in both these places, we want to add the new **AuthorizationInterceptor**
    and also a statement telling Castle Windsor to use the new **InterceptorSelector**
    to select the correct interceptors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines add the interceptor and selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'For reference, the block that configures **IUsersService** needs these two
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And the second block that needs the two lines is generally, by convention,
    the automatic hookup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that everything is registered, it’s time to try it out. Open the **Program.cs**
    file and add the following before **Console.ReadLine()**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'By running your application now, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, you should be allowed to buy the milk. Let’s alter the authorizer
    to not permit this. Open the **Authorizer.cs** file and return **false** instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the program again should produce a different result with the **Adding
    ''Buy milk'' to the todo list** output being removed. You’ll still see that the
    method invocation from the logger happens, but the actual invocation is filtered
    out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Windsor Castle provides a flexible and powerful pointcut mechanism, based on
    Castle **DynamicProxy**, that allows you to select join points based on the metadata
    found on the type and method. For example, you can create pointcuts based on the
    following criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return type of the method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parameters of the method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The presence of attributes on the type or method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The accessibility of the method (e.g., public, private, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By combining multiple criteria, you can create complex pointcuts that match
    very specific sets of join points. For example, you could create a pointcut that
    matches all public methods with a specific attribute or all non-public methods
    with a specific name.
  prefs: []
  type: TYPE_NORMAL
- en: Pointcuts are a powerful mechanism for filtering calls and applying aspects
    only to specific parts of the code. By using pointcuts, you can avoid the overhead
    of applying aspects to every single method call and, instead, selectively apply
    aspects only where they are needed. This can result in faster and more efficient
    code, with better separation of concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, pointcuts are a key feature of AOP, and Windsor Castle provides a rich
    and flexible pointcut mechanism that can be used to create complex and powerful
    aspect-based solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we’ve used Castle Windsor throughout, there are other tools, frameworks,
    or libr[aries that could al](https://autofac.org)so be used, such as PostSharp
    ([https://www.postsharp.net](https://www.postsharp.net)), Autofac ([https://autofac.org](https://autofac.org)),
    or just use the underlying Castle Core **DynamicProxy** to achieve the same without
    buying into a full-blown framework. You could be hand-rolling this yourself using
    reflection emit as well.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, AOP and Castle Windsor provide a powerful mechanism for separating
    concerns in your code and making them more modular and reusable. By selectively
    applying aspects to specific parts of your code, you can achieve a high degree
    of flexibility and control over the behavior of your application.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 13*](B19418_13.xhtml#_idTextAnchor206), *Applying Cross-Cutting
    Concerns*, we discussed the importance of reducing risk in your codebase, which
    is perhaps the most critical use case. Since security is the most vulnerable aspect
    of our software, it is essential to adopt a zero-trust mindset when it comes to
    this and take all necessary steps to prevent security vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Moving onto the next chapter, we will dive into the power of the C# compiler,
    also known as Roslyn. With Roslyn, you get a whole new set of metadata to play
    with and new capabilities for metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: Part 4:Compiler Magic Using Roslyn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will get a glimpse into the C# compiler’s capabilities and
    the different extension points it provides through the .NET Compiler SDK. It dives
    into how the compiler has become an ecosystem and how you can do metaprogramming
    on a compile-time level rather than just the runtime. This part concludes the
    book with an overview of what the book has covered, thoughts on when to use what,
    and some closing words.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B19418_15.xhtml#_idTextAnchor250), *Roslyn Compiler Extensions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 16*](B19418_16.xhtml#_idTextAnchor272), *Generating Code*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 17*](B19418_17.xhtml#_idTextAnchor299), *Static Code Analysis*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 18*](B19418_18.xhtml#_idTextAnchor323), *Caveats and Final Words*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
