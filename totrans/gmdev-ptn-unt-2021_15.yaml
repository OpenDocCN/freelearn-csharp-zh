- en: Implementing a Level Editor with Spatial Partition
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空间分区实现关卡编辑器
- en: In this chapter, we will explore the concept of spatial partitioning. Unlike
    in previous chapters, the main subject is not traditionally defined as a software
    design pattern but more as a process and a technique. But because it offers us
    a reusable and structured approach to solving recurrent game-programming problems,
    we will treat it as a design pattern in the context of this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章，我们将探讨空间分区概念。与前面的章节不同，主要主题不是传统上定义为软件设计模式，而更多是一个过程和技术。但由于它为我们提供了一种可重用和结构化的方法来解决重复出现的游戏编程问题，我们将将其视为本章中的设计模式。
- en: 'The approach we are going to take in this chapter is different from previous
    chapters for the following specific reasons:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将采取的方法与前面的章节不同，原因如下：
- en: We are taking a hands-off approach; in other words, we will not attempt to implement
    a code example but will instead review some code segments.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将采取一种放手的态度；换句话说，我们不会尝试实现代码示例，而是将审查一些代码片段。
- en: We will not try to stay faithful to any academic definition but will instead
    use the general concept of spatial partitioning to build a level editor for our
    racing game.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不会试图忠实于任何学术定义，而是将使用空间分区的通用概念来构建我们的赛车游戏关卡编辑器。
- en: The simplest definition of spatial partitioning is a process that offers an
    efficient way of locating objects by collating them in a data structure ordered
    by their positions. The level editor we are implementing in this chapter will
    be built with a stack data structure, and the type of object we will keep in a
    specific order on a stack is a race track segment. These individual segments of
    the race track will be spawned or deleted in a particular order, depending on
    their relation to the player's position on the map.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 空间分区的最简单定义是一个过程，它通过将对象按其位置在数据结构中整理，提供了一种高效定位对象的方法。本章中我们正在实现的关卡编辑器将使用栈数据结构构建，我们将保持特定顺序的栈中的对象类型是赛道段。这些赛道段将根据它们与玩家在地图上的位置的关系以特定的顺序生成或删除。
- en: All of this might sound very abstract, but it's pretty easy to achieve this
    with the Unity **application programming interface** (**API**), as we will see
    in this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可能听起来非常抽象，但使用Unity **应用程序编程接口**（**API**）实现这一点相当简单，正如我们将在本章中看到的那样。
- en: The system we are implementing in this chapter is too elaborate to boil down
    into a skeleton code example. So, unlike in previous chapters, the code presented
    is not meant to be reproduced or used as a template. We instead recommend reviewing
    a complete code example of the level editor in the `/FPP` folder of the Git project.
    The link can be found in the *Technical requirements* section of this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们正在实施的系统过于复杂，无法简化为一个骨架代码示例。因此，与前面的章节不同，这里展示的代码并不是为了复制或用作模板。我们反而建议您查看Git项目`/FPP`文件夹中的完整代码示例，该链接可在本章的*技术要求*部分找到。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章，我们将涵盖以下主题：
- en: Understanding the Spatial Partition pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解空间分区模式
- en: Designing a level editor
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计关卡编辑器
- en: Implementing a level editor
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现关卡编辑器
- en: Reviewing alternative solutions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查替代解决方案
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will also be using the following specific Unity engine API features:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用以下特定的Unity引擎API功能：
- en: Stack
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈
- en: ScriptableObjects
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可脚本化对象
- en: If unfamiliar with these concepts, please review [Chapter 3](c71c8dd0-2787-43e0-a140-d9cc4ab41ff9.xhtml), *A
    Short Primer to Programming in Unity*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不熟悉这些概念，请参阅[第3章](c71c8dd0-2787-43e0-a140-d9cc4ab41ff9.xhtml)，《Unity编程简明指南》。
- en: The code files of this chapter can be found on GitHub at the following link: [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter13](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter13).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到，链接如下：[https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter13](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter13)。
- en: A Stack is a linear data structure with two primary operations: **Push**,which
    adds an element on top of the stack, and **Pop**,which removesthe most recent
    element from the top.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一种线性数据结构，具有两个主要操作：**Push**，在栈顶添加一个元素，和**Pop**，从栈顶移除最近添加的元素。
- en: Understanding the Spatial Partition pattern
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解空间分区模式
- en: The Spatial Partition pattern name comes from the process known as space partitioning,
    which plays an integral part in computer graphics and is often used in ray-tracing
    rendering implementations. The process is utilized to organize objects in virtual
    scenes by storing them in a space-partitioning data structure such as a **binary
    space partitioning** (**BSP**) tree; this makes it faster to perform geometry
    queries on a large set of **three-dimensional** (**3D**) objects. In this chapter,
    we will use the general concept of spatial partitioning without being faithful
    to how it's usually implemented in computer graphics.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 空间划分模式的名字来源于称为空间划分的过程，它在计算机图形学中起着至关重要的作用，并且常用于光线追踪渲染实现中。这个过程通过将对象存储在空间划分数据结构（如
    **二叉空间划分**（**BSP**）树）中来组织虚拟场景中的对象；这使得对大量 **三维**（**3D**）对象进行几何查询更快。在本章中，我们将使用空间划分的一般概念，而不必忠实于它在计算机图形学中通常的实现方式。
- en: 'A very high-level and conceptual way of visualizing spatial partitioning is
    with the following diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下图表以非常高级和概念化的方式可视化空间划分：
- en: '![](img/338d48b6-7ba3-4d14-849b-a358f2c5816e.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/338d48b6-7ba3-4d14-849b-a358f2c5816e.png)'
- en: Figure 13.1 – A diagram that illustrates spatial partitioning on a map
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 一个说明地图上空间划分的图表
- en: The first example represents the position of enemies on the map without any
    partitioning. If we want to quickly look up the location of enemies in relation
    to the player, it could be challenging to do this efficiently. Of course, we could
    use ray casts to calculate the distance between entities, but this could become
    inefficient as the number of enemies grows.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子表示地图上没有进行任何划分的敌人位置。如果我们想快速查找玩家相对于敌人的位置，这可能是一个挑战。当然，我们可以使用射线投射来计算实体之间的距离，但随着敌人数量的增加，这可能会变得低效。
- en: The next part of the diagram shows that if we partition the map, we can now
    easily visualize the clusters of enemies in relation to the player's location.
    In code, we could now quickly look up which enemy is the closest to the player
    and where there's the largest cluster of them, and because we don't need the exact
    position of each enemy but just their general geographical relation to the player,
    just knowing which approximate cell of the grid they are in is good enough.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图表的下一部分显示，如果我们划分地图，现在我们可以轻松地可视化敌人相对于玩家位置的集群。在代码中，我们现在可以快速查找哪个敌人离玩家最近，以及它们最大的集群在哪里，因为我们不需要每个敌人的确切位置，只需要它们与玩家的一般地理关系，知道它们在网格的哪个近似单元格中就足够了。
- en: '**BSP** is a 3D programming technique that recursively subdivides space into
    convex pairs using a series of hyperplanes. The method is implemented with a binary-tree
    data structure. John Carmack has famously used BSP to develop games such as *Doom*
    and *Quake*.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**BSP** 是一种 3D 编程技术，它通过一系列超平面递归地将空间划分为凸对。该方法使用二叉树数据结构实现。约翰·卡马克（John Carmack）曾著名地使用
    BSP 开发过如 *Doom* 和 *Quake* 等游戏。'
- en: When to use the Spatial Partition pattern
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用空间划分模式
- en: 3D programming is beyond the scope of this book, yet the most important takeaway
    of the description of spatial partitioning is that it offers a solution to organizing
    a large set of objects in a scene in an optimal manner. Therefore, if you find
    yourself needing a quick way to query an extensive collection of objects in a
    scene while keeping track of their spatial relations, keep in mind the principles
    of spatial partitioning.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 3D 编程超出了本书的范围，但空间划分描述的最重要收获是它提供了一种以最佳方式组织场景中大量对象的方法。因此，如果你发现自己需要一种快速查询场景中大量对象的同时跟踪它们的空间关系的方法，请记住空间划分的原则。
- en: In the next section, we will review the overall design of the level editor and
    examine its technical requirements.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将回顾关卡编辑器的整体设计并检查其技术要求。
- en: Designing a level editor
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计关卡编辑器
- en: When working on a multi-disciplinary game development team, the responsibilities
    of a game programmer are not limited to implementing cool game mechanics and features.
    We are often tasked with building asset-integration pipelines and editing tools.
    The most common tool we might need to implement early on in a production cycle
    is a custom level editor for the level designers on our team.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当在一个多学科游戏开发团队工作时，游戏程序员的职责不仅限于实现酷炫的游戏机制和功能。我们经常被要求构建资产集成管道和编辑工具。在制作周期早期，我们可能需要实现的最常见工具是为我们团队的水平设计师定制的自定义关卡编辑器。
- en: Before writing a single line of code, we need to keep in mind that our game
    has no randomness integrated into its core game systems. It's a game of skill
    in which players have the primary goal of reaching the top of the leaderboard
    by memorizing each track's intricacies and getting to the finish line as fast
    as possible.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何代码之前，我们需要记住，我们的游戏在核心游戏系统中没有集成随机性。这是一个技能游戏，玩家的主要目标是通过记住每条赛道的复杂性并尽可能快地到达终点线来达到排行榜的顶端。
- en: Thus, based on these core design pillars, we can't use a solution such as procedural
    generation maps that spawn random obstacles based on specific rules and constraints. Consequently,
    the level designers in our team will have to design the layout of each race track
    by hand.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基于这些核心设计支柱，我们不能使用像基于特定规则和约束生成随机障碍的程序生成地图这样的解决方案。因此，我们团队的水平设计师将不得不手动设计每条赛道的布局。
- en: 'And this brings us to our most significant challenge: in our game, a bike travels
    through a 3D world in a straight line at very high speeds. If we wish to have
    a race that lasts more than a dozen seconds, we will need a massive amount of
    assets in the memory, and our designers will have to deal with editing massive
    levels in the editor.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这把我们带到了我们最大的挑战：在我们的游戏中，一辆自行车以非常高的速度在3D世界中直线行驶。如果我们希望比赛持续超过十几秒，我们将在内存中需要大量的资产，并且我们的设计师将不得不在编辑器中处理编辑大量水平的工作。
- en: This approach is neither efficient during the editing phase nor at runtime.
    So, instead of managing a single race track as one entity, we will divide it into
    segments, and each segment will be editable individually and then assembled in
    a specific order to form a single track.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在编辑阶段和运行时都不高效。因此，我们不会将整个赛道作为一个单一实体来管理，而是将其划分为段，每个段可以单独编辑，然后按照特定的顺序组装成一个单一的赛道。
- en: 'The following diagram illustrates this high-level concept:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图示说明了这个高级概念：
- en: '![](img/980dd515-a76d-4ebc-8bd0-00021cb4eb36.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/980dd515-a76d-4ebc-8bd0-00021cb4eb36.png)'
- en: Figure 13.2 – A diagram of the sequencing of track segments
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – 赛道段顺序图
- en: 'We gain two key benefits from this system, outlined as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个系统中，我们获得了两个关键的好处，如下所述：
- en: Our level designers can author new tracks by creating new segments and sequencing
    them in various layouts.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的水平设计师可以通过创建新的段并在各种布局中编排它们来创建新的赛道。
- en: We don't need to load the entire content of the race track into memory, just
    to spawn the segments we need at the right moment in relation to the player's
    current position.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不需要将整个赛道内容加载到内存中，只需在玩家当前位置的适当时刻生成所需的段。
- en: 'The next diagram illustrates how the track controller uses a stack data structure
    to manage which track to unload and which ones to spawn in relation to the current
    position of the player:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图示说明了赛道控制器如何使用堆栈数据结构来管理根据玩家当前位置卸载哪些赛道以及生成哪些赛道：
- en: '![](img/969c0861-9eee-44f6-8d25-12481ba438e6.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/969c0861-9eee-44f6-8d25-12481ba438e6.png)'
- en: Figure 13.3 – A diagram of the segment stack
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 段堆叠图
- en: 'There are two distinct characteristics of our game that we must keep in mind
    while implementing this system, outlined as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施此系统时，我们必须牢记我们游戏中的两个显著特点，如下所述：
- en: The bike never moves from its initial position. It's the track segments that
    move toward the player. Therefore, the sense of speed and movement is simulated
    and provides a visual illusion.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自行车始终保持在初始位置不动。是赛道段向玩家移动。因此，速度和移动的感觉是通过模拟来实现的，并提供了视觉错觉。
- en: The player can only see forward. There are no rear-view windows or look-back
    cameras. This camera-view limitation means we can unload track segments immediately
    after they are behind the player's field of view.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家只能看到前方。没有后视窗或回望摄像头。这种摄像机视角的限制意味着我们可以在赛道段位于玩家视野之后立即卸载它们。
- en: In summary, with a single system, we have resolved two potential core issues
    for our project. Foremost, we are establishing a level design pipeline, and lastly,
    we have a mechanism to load our levels dynamically with a degree of optimization
    embedded in the design.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，通过一个单一的系统，我们解决了我们项目中的两个潜在的核心问题。首先，我们正在建立一个水平设计流程，最后，我们有一个机制可以动态加载我们的水平，并在设计中嵌入一定的优化。
- en: I was inspired by miniature electric-toy slot cars when designing the racing
    game we are building in this book. One unique aspect of this toy is that you can
    assemble individual track segments in various configurations. It was sometimes
    more fun thinking of new and unique track layouts than actually racing the toy
    cars.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计本书中构建的赛车游戏时，我受到了微型电动玩具赛车的启发。这个玩具的一个独特之处在于你可以以各种配置组装单个轨道段。有时思考新的独特轨道布局比实际驾驶玩具车更有趣。
- en: Implementing a level editor
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现关卡编辑器
- en: In this section, we will review some code that will implement the core components
    of our level editor. Unlike in previous chapters, we will not try to make this
    code runnable or testable. Instead, we will review the implementations to understand
    how we use the general idea of spatial partitioning to build a functional level
    editor for designers while optimizing the way we load levels at runtime.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾一些代码，这些代码将实现我们关卡编辑器的核心组件。与前面的章节不同，我们不会尝试使这段代码可运行或可测试。相反，我们将回顾实现，以了解我们如何使用空间划分的一般思想来为设计师构建一个功能性的关卡编辑器，同时优化我们在运行时加载关卡的方式。
- en: The code presented in the next section is to be reviewed but not compiled, as
    it's not a complete self-contained example.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分中展示的代码将进行审查，但不会编译，因为它不是一个完整的自包含示例。
- en: Steps for implementing a level editor
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现关卡编辑器的步骤
- en: 'To start, we are going to write a `ScriptableObject` class named `Track`, as
    follows:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将编写一个名为`Track`的`ScriptableObject`类，如下所示：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With this `ScriptableObject` class, our level designers will be able to design
    new variations of race tracks by adding segments into a list and then sequencing
    them in a specific order. Each track asset will be fed to the `TrackController` class,
    which will spawn each segment automatically and in the order that the designers
    sequenced them.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个`ScriptableObject`类，我们的关卡设计师将能够通过将段添加到列表中并按特定顺序排列它们来设计新的赛道变体。每个赛道资产都将被送入`TrackController`类，该类将自动按设计师的顺序生成每个段。
- en: For the player, this process is seamless as it runs in the background, and segments
    are spawned before they are in the camera's field of view. So, from the point
    of view of the player, it looks like the whole level is loaded.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于玩家来说，这个过程是无缝的，因为它在后台运行，段在它们进入摄像机的视野之前就已经生成。因此，从玩家的角度来看，整个关卡看起来就像已经加载完毕。
- en: 'Next up is the `TrackController` class. In it, we are going to implement the
    segment-loading mechanism, but because it''s an extensive class, we are going
    to divide it up and look at it in sections, as follows:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`TrackController`类。在其中，我们将实现段加载机制，但由于它是一个庞大的类，我们将将其拆分并分部分查看，如下所示：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The first section is just the initialization code and is self-explanatory,
    but the following region of the code gets more interesting:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分仅仅是初始化代码，是自我解释的，但代码的后续部分则更有趣：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As we can see, in the `Update()` loop, we are moving the track parent object
    toward the player to simulate movement. And in the `InitTrack()` method, we instantiate
    a track `GameObject`, which will act as the container of the track segments. But
    there''s one significant line of code in the function that''s a critical component
    to our segment-loading mechanism, and this is illustrated here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在`Update()`循环中，我们将轨道父对象移动到玩家附近以模拟移动。在`InitTrack()`方法中，我们实例化一个轨道`GameObject`，它将作为轨道段的容器。但函数中有一行重要的代码是段加载机制的关键组成部分，这里进行了说明：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: On this line, we are injecting the list of segments into a new Stack container.
    As mentioned at the beginning of the chapter, an essential part of the spatial-partitioning
    technique is the organization *of environment objects in a data structure* so
    that they are easier to query.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行，我们将段列表注入到一个新的栈容器中。正如本章开头所提到的，空间划分技术的一个关键部分是将环境对象组织在数据结构中，以便更容易查询。
- en: 'In the next code snippet, we are going to see how we use the Stack data structure
    to load segments in the correct order:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码片段中，我们将看到我们如何使用栈数据结构按正确顺序加载段：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `LoadSegment()` private method is at the heart of the system. It accepts
    as a parameter a specific amount of segments. This value will determine the number
    of segments that it will load when called. If there are enough segments remaining
    on the stack, it pops one from the top and initializes it behind the previously
    loaded segment. It continues this circular process until it has loaded the expected
    amount.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadSegment()`私有方法是系统的核心。它接受一个特定数量的段落作为参数。这个值将决定在调用时它将加载多少个段落。如果有足够的段落剩余在堆栈上，它就会从顶部弹出一个并初始化它，位于之前加载的段落后面。它继续这个循环过程，直到加载了预期的数量。'
- en: 'You might be asking yourself: *How do we destroy segments that have passed
    behind the player?* There are many ways we can calculate or detect if one entity
    is behind another, but for our context, we are going to use a twofold solution.
    Every segment prefab has an entity called a segment marker loaded at its edge;
    this is composed of two pillars and an invisible trigger.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问自己：*我们如何销毁玩家后面的段落？* 我们有多种方法可以计算或检测一个实体是否在另一个实体后面，但就我们的上下文而言，我们将使用一种双重解决方案。每个段落预制体在其边缘加载了一个名为段落标记的实体；这由两个柱子和一个不可见的触发器组成。
- en: 'Once the bike goes through the trigger, the segment marker deletes its parent
    `GameObject`, as we can see here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦自行车通过触发器，段落标记就会删除其父`GameObject`，正如我们在这里看到的：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When an entity with the `BikeController` component exits a segment marker's
    trigger, it requests the destruction of its parent `GameObject`, which in this
    case would be a `Segment` entity.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当具有`BikeController`组件的实体从一个段落标记的触发器中退出时，它请求销毁其父`GameObject`，在这种情况下将是一个`Segment`实体。
- en: When an entity with the `BikeController` component exits a segment marker's
    trigger, it requests the destruction of its parent `GameObject`, which would be
    a `Segment` entity in this context.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当具有`BikeController`组件的实体从一个段落标记的触发器中退出时，它请求销毁其父`GameObject`，在这种情况下将是一个`Segment`实体。
- en: 'As seen in the `LoadSegment()` method from the `TrackController` class, every
    time we pop a new segment from the top of the stack, we attach to it a script
    as a component named `Segment`, as seen here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如`TrackController`类的`LoadSegment()`方法所示，每次我们从堆栈顶部弹出一个新的段落时，我们都会将其附加到一个名为`Segment`的脚本组件上，正如我们在这里看到的：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Because we are passing the current instance of the `TrackController` class
    to its `trackController` parameter, the `Segment` object can call back the `TrackController` class
    and request the loading of the following sequence of segments just before it gets
    destroyed, as we can see here:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将`TrackController`类的当前实例传递给其`trackController`参数，所以`Segment`对象可以回调`TrackController`类，并在它被销毁之前请求加载下一个段落序列，正如我们在这里看到的：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This approach creates a circular mechanism that loads and unloads a controlled
    amount of segments automatically at specific intervals. With this approach, we
    are managing the number of spawned entities in the scene at a given time. In theory,
    this will result in a more consistent frame rate.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法创建了一个循环机制，在特定间隔自动加载和卸载一定数量的段落。使用这种方法，我们管理在给定时间内场景中生成的实体数量。理论上，这将导致更一致的帧率。
- en: Another benefit of this approach, which is more gameplay-related, is that the
    segment markers can act as landmarks for a checkpoint system. Checkpoints are
    often used in time-limit racing game modes in which a player must reach several
    points on the track within a specific timeframe.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的另一个好处，它与游戏玩法更相关，是段落标记可以作为检查点系统的地标。检查点通常用于有时间限制的赛车游戏模式中，玩家必须在特定时间内到达赛道上的几个点。
- en: An excellent example of a checkpoint-based racing game is *Rad Racer* from 1987.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基于检查点的赛车游戏的优秀例子是1987年的*Rad Racer*。
- en: Using the level editor
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用关卡编辑器
- en: 'You can play with the level editor by opening up the `/FPP` folder in the Git
    repository and then do the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在Git仓库中打开`/FPP`文件夹来玩关卡编辑器，然后执行以下操作：
- en: Under the `/Scenes/Gyms` folder, you should find a scene named `Segment`. In
    this scene, you will be able to edit and create new segment prefabs.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`/Scenes/Gyms`文件夹下，你应该找到一个名为`Segment`的场景。在这个场景中，你可以编辑和创建新的段落预制体。
- en: Under the **Assets-> Create-> Track** menu, you have an option to create new
    track assets.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**`Assets-> Create-> Track`**菜单下，你可以选择创建新的轨道资产。
- en: And finally, you can modify and attach new tracks to the `TrackController` classby
    opening the `Track`scene under the **`Scenes/Main` **folder.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，你可以通过在**`Scenes/Main`**文件夹下打开`Track`场景来修改和附加新的轨道到`TrackController`类。
- en: Feel free to improve the code and, more importantly, have fun!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 随意改进代码，更重要的是，享受乐趣！
- en: Reviewing the level-editor implementation
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审查关卡编辑器实现
- en: 'The implementations in this chapter are simplified versions of the code of
    a more complex system, but if you take the time to review an advanced version
    of the level editor in the `/FPP` folder of the Git project, we will see some
    improvements, such as the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的实现是更复杂系统代码的简化版本，但如果您花时间审查 Git 项目 `/FPP` 文件夹中的高级版本关卡编辑器，我们会看到一些改进，例如以下内容：
- en: '**Segments**: There''s an authoring pipeline for segments that uses ScriptableObjects.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**段**：有一个用于段落的创作流程，它使用 ScriptableObjects。'
- en: '**Object pooling**: The `TrackController` class is using an object pool to
    optimize the loading time of individual segments.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象池**：`TrackController` 类正在使用对象池来优化单个段加载时间。'
- en: I didn't include these optimizations in the chapter to keep the code examples
    short and simple, for educational purposes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有在章节中包含这些优化，以保持代码示例简短和简单，出于教育目的。
- en: Reviewing alternative solutions
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查替代方案
- en: In an actual production context, and if time permits, I would build our game's
    level editor differently. I would instead design a top-down track editor that
    would allow the level designers to draw rails and drag and drop obstacles on them.
    The designers would then be able to save their work in a serialized format.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的生产环境中，如果时间允许，我会以不同的方式构建我们的游戏关卡编辑器。我会设计一个自上而下的轨道编辑器，允许关卡设计师绘制轨道并在其上拖放障碍物。设计师随后可以将他们的作品以序列化格式保存。
- en: Then, using spatial-partitioning principles, the tracks would be automatically
    divided into segments by the `TrackController` class and put into an object pool.
    This approach would automate the process of generating individual segments while
    optimizing the spawning process.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用空间分区原理，`TrackController` 类会自动将轨道分成若干段，并将它们放入对象池中。这种方法将自动化生成单个段的过程，同时优化生成过程。
- en: Consequently, the designers would not have to author individual segments as
    prefabs, and they could design new tracks while visualizing the entire layout
    in an editor.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，设计师无需作为预制件编写单个段，他们可以在编辑器中可视化整个布局的同时设计新的轨道。
- en: When I'm building tools and setting up integration pipelines, my end goal is
    always automation. I always try to automate myself out of a job so that I don't
    waste time on manual tasks.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我构建工具和设置集成管道时，我的最终目标始终是自动化。我总是试图通过自动化来摆脱工作，这样我就不会浪费时间在手动任务上。
- en: Summary
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a hands-off approach and reviewed how to build a basic
    level editor while using the broad ideas of the Spatial Partition pattern. Our
    goal wasn't to be faithful to standard definitions of the pattern. Instead, we
    use it as a starting point to build our system. I encourage you to take the time
    to review the code in the `/FPP` folder and refactor it to make it better.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们采取了放手的态度，审查了如何使用空间分区模式的大致思想构建基本关卡编辑器。我们的目标不是忠实于模式的标准化定义。相反，我们将其作为构建我们系统的起点。我鼓励您花时间审查
    `/FPP` 文件夹中的代码，并将其重构以使其更好。
- en: In the next chapter, we will review some alternative patterns that are good
    to know but have general use cases. Therefore, compared to the previous chapters,
    the use cases will have a broader scope without being specific to a game mechanic
    or system. The first pattern that we will tackle is the Adapter pattern. As its
    name implies, we will use it to integrate an adapter between two incompatible
    systems.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将审查一些值得了解但具有通用用例的替代模式。因此，与前面的章节相比，用例将具有更广泛的范围，而不仅仅是针对游戏机制或系统。我们将首先解决适配器模式。正如其名称所暗示的，我们将使用它来在两个不兼容的系统之间集成适配器。
