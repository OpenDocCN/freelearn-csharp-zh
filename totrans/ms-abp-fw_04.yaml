- en: '*Chapter 3*: Step-By-Step Application Development'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 3 章*：逐步应用程序开发'
- en: This chapter introduces the fundamentals of ABP Framework by building an example
    application. The example application is used to manage products on a typical **CRUD**
    page (note that a CRUD page is used to **Create**, **Read** (view), **Update**,
    and **Delete** entities).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过构建一个示例应用程序来介绍 ABP 框架的基本知识。示例应用程序用于在典型的 **CRUD** 页面上管理产品（请注意，CRUD 页面用于 **创建**、**读取**（查看）、**更新**和**删除**实体）。
- en: The example presented in this chapter is more advanced than a simple CRUD page.
    It implements many aspects of application development with production quality.
    By the end of this chapter, you will understand the basics, and you will be ready
    to start development with ABP Framework.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中提供的示例比简单的 CRUD 页面更高级。它实现了应用开发中的许多方面，具有生产质量。到本章结束时，您将了解基础知识，并准备好使用 ABP 框架开始开发。
- en: 'I will proceed, step by step, in the order of building a real-world project.
    This chapter consists of the following topics; each represents a step in this
    process:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我将按照构建真实世界项目的顺序逐步进行。本章包括以下主题；每个主题代表此过程中的一个步骤：
- en: Creating the solution
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建解决方案
- en: Defining the domain objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义领域对象
- en: '**Entity Framework** (**EF**) Core and database mappings'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Entity Framework** (**EF**) Core 和数据库映射'
- en: Listing the product data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出产品数据
- en: Creating products
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建产品
- en: Editing products
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑产品
- en: Deleting products
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除产品
- en: User Interface (UI) and Database Preference
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用户界面（UI）和数据库偏好
- en: I prefer **Razor Pages (MVC)** as the UI framework and **EF Core** as the database
    provider. We will cover other UI frameworks and database providers in separate
    chapters.
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我更喜欢 **Razor Pages (MVC**) 作为 UI 框架和 **EF Core** 作为数据库提供者。我们将在单独的章节中介绍其他 UI
    框架和数据库提供者。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We will be building an application, so you need to have .NET runtime, ABP CLI,
    and an IDE/editor installed to build ASP.NET Core projects.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个应用程序，因此您需要安装 .NET 运行时、ABP CLI 以及一个 IDE/编辑器来构建 ASP.NET Core 项目。
- en: Please refer to [*Chapter 2*](B17287_02_Epub_AM.xhtml#_idTextAnchor026), *Getting
    Started with ABP Framework*, to learn how to prepare your development environment,
    as well as create and run the solution.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 [*第 2 章*](B17287_02_Epub_AM.xhtml#_idTextAnchor026)，*使用 ABP 框架入门*，了解如何准备您的开发环境，以及创建和运行解决方案。
- en: You can download the source code of the final application from the GitHub repository
    at [https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 GitHub 仓库 [https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework)
    下载最终应用程序的源代码。
- en: Creating the solution
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建解决方案
- en: 'The first step is to create a solution for the product management application.
    If you''ve created the *ProductManagement* solution in [*Chapter 2*](B17287_02_Epub_AM.xhtml#_idTextAnchor026),
    *Getting Started with ABP Framework*, you can use it. Otherwise, create an empty
    folder in your computer, open a command-line terminal in this folder, and run
    the following **ABP CLI** command to create a new web application:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是为产品管理应用程序创建一个解决方案。如果您在 [*第 2 章*](B17287_02_Epub_AM.xhtml#_idTextAnchor026)
    中创建了 *ProductManagement* 解决方案，*使用 ABP 框架入门*，您可以使用它。否则，在您的计算机中创建一个空文件夹，在此文件夹中打开一个命令行终端，并运行以下
    **ABP CLI** 命令以创建一个新的 Web 应用程序：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Open the solution in your favorite IDE, create the database, and run the web
    project. If you have problems with running the solution, please refer to the previous
    chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在您最喜欢的 IDE 中打开解决方案，创建数据库，并运行 Web 项目。如果您在运行解决方案时遇到问题，请参阅上一章。
- en: Now we have a running solution. We can start the development by defining the
    domain objects of the solution.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个正在运行的解决方案。我们可以通过定义解决方案的领域对象来开始开发。
- en: Defining the domain objects
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义领域对象
- en: 'In this section, you will learn how to define entities with ABP Framework.
    The domain is simple for this application. We have **Product** and **Category**
    entities and a **ProductStockState** enum, as shown in *Figure 3.1*:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何使用 ABP 框架定义实体。对于此应用程序，领域很简单。我们有 **Product** 和 **Category** 实体以及一个
    **ProductStockState** 枚举，如图 *3.1* 所示：
- en: '![Figure 3.1 – An example product management domain'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.1 – 一个示例产品管理领域'
- en: '](img/Figure_3.1_B17287.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.1_B17287.jpg)'
- en: Figure 3.1 – An example product management domain
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 一个示例产品管理领域
- en: 'Entities are defined in the *Domain Layer* of the solution, and the domain
    layer is split into two projects within the solution:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 实体在解决方案的 *领域层* 中定义，领域层在解决方案中分为两个项目：
- en: '**ProductManagement.Domain** is used to define your entities, value objects,
    domain services, repository interfaces, and other core domain-related classes.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ProductManagement.Domain**用于定义你的实体、值对象、领域服务、存储库接口以及其他核心领域相关的类。'
- en: '**ProductManagement.Domain.Shared** is used to define some primitive shared
    types. The types defined in this project are available to all other layers. Typically,
    we define enums and some constants here.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ProductManagement.Domain.Shared**用于定义一些原始的共享类型。在此项目中定义的类型对所有其他层都是可用的。通常，我们在这里定义枚举和一些常量。'
- en: So, we can start by creating the `Category` and `Product` entities and the `ProductStockState`
    enum.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以从创建`Category`和`Product`实体以及`ProductStockState`枚举开始。
- en: Category
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Category
- en: 'The `Category` entity is used to categorize the products. Create a *Categories*
    folder inside the *ProductManagement.Domain* project and a `Category` class inside
    it:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Category`实体用于对产品进行分类。在`ProductManagement.Domain`项目内创建一个*Categories*文件夹，并在其中创建一个`Category`类：'
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`Category` is a class is derived from `AuditedAggregateRoot<Guid>`. Here, `Guid`
    is the primary key (`Id`) type of the entity. You can use any type of primary
    key (such as `int`, `long`, or `string`) as long as your database management system
    supports it.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Category`是一个从`AuditedAggregateRoot<Guid>`派生的类。在这里，`Guid`是实体的主键（`Id`）类型。只要你的数据库管理系统支持，你可以使用任何类型的键（如`int`、`long`或`string`）。'
- en: '`AggregateRoot` is a special type of entity that is used to create the root
    entity type of an aggregate. An aggregate is a **Domain-Driven Design** (**DDD**)
    concept that we will discuss in greater detail in the upcoming chapters. For now,
    consider that we inherit the main entities from this class.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`AggregateRoot`是一种特殊类型的实体，用于创建聚合的根实体类型。聚合是**领域驱动设计**（**DDD**）的一个概念，我们将在接下来的章节中详细讨论。现在，请考虑我们从这个类继承主要实体。'
- en: 'The `AuditedAggregateRoot` class adds some more properties to the `AggregateRoot`
    class: `CreationTime` as `DateTime`, `CreatorId` as `Guid`, `LastModificationTime`
    as `DateTime`, and `LastModifierId` as `Guid`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuditedAggregateRoot`类向`AggregateRoot`类添加了一些额外的属性：`CreationTime`作为`DateTime`，`CreatorId`作为`Guid`，`LastModificationTime`作为`DateTime`，以及`LastModifierId`作为`Guid`。'
- en: ABP automatically sets these properties. For example, when you insert an entity
    into the database, `CreationTime` is set to the current time, and `CreatorId`
    is automatically set to the `Id` property of the current user.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ABP会自动设置这些属性。例如，当你将实体插入数据库时，`CreationTime`会被设置为当前时间，而`CreatorId`会自动设置为当前用户的`Id`属性。
- en: The audit logging system and the base `Audited` classes will be covered in [*Chapter
    8*](B17287_08_Epub_AM.xhtml#_idTextAnchor249), *Using the Features and Services
    of ABP*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 审计日志系统和基础`Audited`类将在[*第8章*](B17287_08_Epub_AM.xhtml#_idTextAnchor249)中介绍，*使用ABP的功能和服务*。
- en: About Rich Domain Models
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 关于丰富的领域模型
- en: In this chapter, I keep the entities simple, with public getters and setters.
    If you want to create rich domain models and apply DDD principles and other best
    practices, we will discuss them in upcoming chapters.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我保持了实体的简单性，具有公共的获取器和设置器。如果你想创建丰富的领域模型并应用DDD原则和其他最佳实践，我们将在接下来的章节中讨论它们。
- en: ProductStockState
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ProductStockState
- en: '`ProductStockState` is a simple enum to set and track the availability of the
    product in stock.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductStockState`是一个简单的枚举，用于设置和跟踪库存中产品的可用性。'
- en: 'Create a *Products* folder inside the *ProductManagement.Domain.Shared* project
    and a `ProductStockState` enum inside it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ProductManagement.Domain.Shared`项目内创建一个*Products*文件夹，并在其中创建一个`ProductStockState`枚举：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We define this `enum` in the `ProductManagement.Domain.Shared` project since
    we will reuse it in the **Data Transfer Objects** (**DTOs**) and the UI layer.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`ProductManagement.Domain.Shared`项目中定义这个`enum`，因为我们将在**数据传输对象**（**DTOs**）和UI层中重用它。
- en: Product
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Product
- en: 'The `Product` class represents a real product. I intentionally added different
    types of properties to show their usages. Create a *Products* folder inside the
    *ProductManagement.Domain* project and a `Product` class inside it:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Product`类代表一个真实的产品。我故意添加了不同类型的属性来展示它们的用法。在`ProductManagement.Domain`项目内创建一个*Products*文件夹，并在其中创建一个`Product`类：'
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This time, I inherited from `FullAuditedAggregateRoot`, which adds `IsDeleted`
    as `bool`, `DeletionTime` as `DateTime`, and `DeleterId` as `Guid` properties
    in addition to the `AuditedAggregateRoot` class used for the `Category` class.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我继承了`FullAuditedAggregateRoot`，它除了`AuditedAggregateRoot`类用于`Category`类外，还添加了`IsDeleted`作为`bool`，`DeletionTime`作为`DateTime`，以及`DeleterId`作为`Guid`属性。
- en: '`FullAuditedAggregateRoot` implements the `ISoftDelete` interface, which makes
    the entity **Soft-Delete**. That means it is never deleted from the database but
    just *marked as deleted*. ABP automatically handles all the Soft-Delete logic.
    You delete the entity as you normally do, but it is not actually deleted. The
    next time you query, deleted entities are automatically filtered, and you don''t
    get them in the query result unless you intentionally request them. We will return
    to that feature in the *Using the data filtering system* section of [*Chapter
    8*](B17287_08_Epub_AM.xhtml#_idTextAnchor249), *Using the Features and Services
    of ABP*.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`FullAuditedAggregateRoot` 实现了 `ISoftDelete` 接口，这使得实体可以进行 **软删除**。这意味着它不会被从数据库中删除，而是仅仅
    *标记为已删除*。ABP 自动处理所有软删除逻辑。您像平常一样删除实体，但实际上它并没有被删除。下次查询时，已删除的实体将自动过滤，除非您故意请求它们，否则您不会在查询结果中看到它们。我们将在
    [*第 8 章*](B17287_08_Epub_AM.xhtml#_idTextAnchor249)，*使用 ABP 的功能和服务* 的 *使用数据过滤系统*
    部分中回到这个功能。'
- en: About the Navigation Properties
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 关于导航属性
- en: In this example, `Product.Category` is a navigation property for the `Category`
    entity. If you use MongoDB or want to implement DDD truly, you should not add
    navigation properties to other aggregates. However, for relational databases,
    it works perfectly and provides flexibility to our code. We will discuss alternative
    approaches in [*Chapter 10*](B17287_10_Epub_AM.xhtml#_idTextAnchor316), *DDD –
    The Domain Layer*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Product.Category` 是 `Category` 实体的导航属性。如果您使用 MongoDB 或想真正实现 DDD，您不应向其他聚合添加导航属性。然而，对于关系数据库，它工作得非常好，并为我们的代码提供了灵活性。我们将在
    [*第 10 章*](B17287_10_Epub_AM.xhtml#_idTextAnchor316)，*DDD – 领域层* 中讨论替代方法。
- en: 'The new files in the solution should look like *Figure 3.2*:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案中的新文件应类似于 *图 3.2*：
- en: '![Figure 3.2 – Adding domain objects to the solution'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.2 – 将领域对象添加到解决方案中'
- en: '](img/Figure_3.2_B17287.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.2_B17287.jpg)'
- en: Figure 3.2 – Adding domain objects to the solution
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 将领域对象添加到解决方案中
- en: We've created the domain objects. In addition, we will create a few `const`
    values to be used later in the application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了领域对象。此外，我们还将创建一些 `const` 值，以便在应用程序的后续部分使用。
- en: Constants
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量
- en: We need to define constant values for the properties of the entities. We will
    then use them in the input validation and database mapping phase.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为实体的属性定义常量值。然后，我们将在输入验证和数据库映射阶段使用它们。
- en: 'First, create a *Categories* folder inside the *ProductManagement.Domain.Shared*
    project and add a `CategoryConsts` class inside it:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 *ProductManagement.Domain.Shared* 项目的内部创建一个 *Categories* 文件夹，并在其中添加一个 `CategoryConsts`
    类：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the `MaxNameLength` value will be used to implement the constraint for
    the `Name` property of a `Category` instance.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`MaxNameLength` 值将被用于实现 `Category` 实例的 `Name` 属性的约束。
- en: 'Then, create a `ProductConsts` class inside the *Products* folder of the *ProductManagement.Domain.Shared*
    project:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 *ProductManagement.Domain.Shared* 项目的 *Products* 文件夹内创建一个 `ProductConsts`
    类：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `MaxNameLength` value will be used to implement the constraint for a `Product`
    instance's `Name` property.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`MaxNameLength` 值将被用于实现 `Product` 实例的 `Name` 属性的约束。'
- en: 'The *ProductManagement.Domain.Shared* project should look similar to *Figure
    3.3*:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*ProductManagement.Domain.Shared* 项目应类似于 *图 3.3*：'
- en: '![Figure 3.3 – Adding constant classes'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.3 – 添加常量类'
- en: '](img/Figure_3.3_B17287.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.3_B17287.jpg)'
- en: Figure 3.3 – Adding constant classes
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 添加常量类
- en: Now that the domain layer has been completed, we can now configure the database
    mappings for EF Core.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在领域层已经完成，我们现在可以配置 EF Core 的数据库映射。
- en: EF Core and database mappings
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EF Core 和数据库映射
- en: We are using **EF Core** in this application. EF Core is an **Object-Relational
    Mapping** (**ORM**) provider provided by Microsoft. ORMs provide abstractions
    to make you feel like you are working with objects in your application code rather
    than the database tables. We will cover ABP's EF Core integration in [*Chapter
    6*](B17287_06_Epub_AM.xhtml#_idTextAnchor177), *Working with the Data Access Infrastructure*.
    However, for now, let's focus on how we can use it practically.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们使用 **EF Core**。EF Core 是由 Microsoft 提供的一个 **对象关系映射** (**ORM**) 提供商。ORM
    提供了抽象，使您感觉像是在应用程序代码中操作对象，而不是数据库表。我们将在 [*第 6 章*](B17287_06_Epub_AM.xhtml#_idTextAnchor177)，*使用数据访问基础设施*
    中介绍 ABP 的 EF Core 集成。然而，现在让我们专注于如何实际使用它。
- en: First, we will add entities to the `DbContext` class and define the mappings
    between entities and database tables. Then, we will use EF Core's **Code First
    Migration** approach to build the necessary code that creates the database tables.
    Following this, we will look at ABP's **Data Seeding** system to insert some initial
    data into the database. Finally, we will apply the migrations and seed data to
    the database to prepare it for the application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将向`DbContext`类添加实体并定义实体与数据库表之间的映射。然后，我们将使用EF Core的**代码优先迁移**方法来构建创建数据库表的必要代码。在此之后，我们将查看ABP的**数据初始化**系统，以将一些初始数据插入数据库。最后，我们将应用迁移和种子数据到数据库中，为应用程序做准备。
- en: First, let's start by defining the `DbSet` properties for the entities.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从定义实体的`DbSet`属性开始。
- en: Adding entities to the DbContext class
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将实体添加到`DbContext`类中
- en: EF's `DbContext` class is the main class that is used to define mappings between
    entities and database tables. Additionally, it is used to access the database
    and perform database operations for the related entities.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: EF的`DbContext`类是用于定义实体与数据库表之间映射的主要类。此外，它还用于访问数据库并为相关实体执行数据库操作。
- en: 'Open the `ProductManagementDbContext` class in the *ProductManagement.EntityFrameworkCore*
    project, and add the following `DbSet` properties inside it (you will need to
    import the namespaces of the `Product` and `Category` objects):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在*ProductManagement.EntityFrameworkCore*项目中打开`ProductManagementDbContext`类，并在其中添加以下`DbSet`属性（您需要导入`Product`和`Category`对象的命名空间）：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Adding a `DbSet` property for an entity relates the entity with the `DbContext`
    class. Then, we can use that `DbContext` class to perform database operations
    for the entity. EF Core can make most of the mapping using conventions based on
    the property names and types. If you want to customize the default mapping configuration
    or perform additional configurations, you have two options: **Data Annotations**
    (attributes) and **Fluent API**.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为实体添加`DbSet`属性将实体与`DbContext`类相关联。然后，我们可以使用该`DbContext`类来对实体执行数据库操作。EF Core可以通过基于属性名称和类型的约定来执行大部分映射。如果您想自定义默认映射配置或执行其他配置，您有两个选项：**数据注解**（属性）和**流畅式API**。
- en: In the data annotation approach, you add attributes, such as `[Required]` and
    `[StringLength]`, to your entity properties. It is very practical and easy to
    use. It also makes it easier to understand when you read the source code of your
    entity.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据注解方法中，您将`[Required]`和`[StringLength]`等属性添加到实体属性中。它非常实用且易于使用。它还使阅读实体源代码时更容易理解。
- en: One problem with the data annotation attributes is that they are limited (compared
    to the Fluent API) and make your domain layer dependant on the EF Core NuGet package
    when you need to use EF Core's custom attributes, such as `[Index]` and `[Owned]`.
    If that's not a problem for you, you can use the data annotation attributes and
    combine them with the Fluent API where they are not sufficient.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 数据注解属性的一个问题是它们有限制（与流畅式API相比），并且当您需要使用EF Core的自定义属性，如`[Index]`和`[Owned]`时，会使您的领域层依赖于EF
    Core的NuGet包。如果您不介意这个问题，您可以使用数据注解属性，并在它们不足够的地方结合使用流畅式API。
- en: In this chapter, I will prefer the Fluent API approach, which keeps the entity
    cleaner and places all the ORM logic inside the infrastructure layer.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将优先选择流畅式API方法，这种方法可以使实体更加简洁，并将所有ORM逻辑放置在基础设施层中。
- en: Mapping entities to the database tables
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将实体映射到数据库表
- en: 'The `ProductManagementDbContext` class (in the *ProductManagement.EntityFrameworkCore*
    project) contains an `OnModelCreating` method to configure mappings of the entities
    to the database tables. When you first create your solution, this method looks
    like the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductManagementDbContext`类（在*ProductManagement.EntityFrameworkCore*项目中）包含一个`OnModelCreating`方法来配置实体到数据库表的映射。当您首次创建解决方案时，此方法看起来如下：'
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following code after the preceding comment:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的注释之后添加以下代码：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code part defines the `Category` and `Product` mapping configurations.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码部分定义了`Category`和`Product`的映射配置。
- en: About Namespaces
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 关于命名空间
- en: You might need to add `using` statements for the namespaces of the `Product`
    class, the `Category` class, and any other classes used in the code. If you have
    trouble, you can always refer to the source code in the GitHub repository that
    I've shared in the *Technical requirements* section of this chapter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要为`Product`类、`Category`类以及代码中使用的任何其他类的命名空间添加`using`语句。如果您遇到麻烦，您始终可以参考本章*技术要求*部分中我分享的GitHub仓库中的源代码。
- en: The `Category` entity is mapped to the *Categories* database table. We use `CategoryConsts.MaxNameLength`
    that was defined before to set the maximum length of the `Name` field in the database.
    The `Name` field is also a *required* property. Finally, we define a *unique*
    database index for the `Name` property because it helps search categories by the
    `Name` field.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Category`实体映射到*Categories*数据库表。我们使用之前定义的`CategoryConsts.MaxNameLength`来设置数据库中`Name`字段的最大长度。`Name`字段也是一个*必需*属性。最后，我们为`Name`属性定义了一个*唯一*数据库索引，因为它有助于通过`Name`字段搜索类别。'
- en: The `Product` mapping is similar to the `Category` mapping. Additionally, it
    defines a relationship between the `Category` entity and the `Product` entity;
    a `Product` entity belongs to a `Category` entity, while a `Category` entity can
    have many related `Product` entities.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Product`映射类似于`Category`映射。此外，它定义了`Category`实体和`Product`实体之间的关系；一个`Product`实体属于一个`Category`实体，而一个`Category`实体可以拥有多个相关的`Product`实体。'
- en: EF Core Fluent Mapping
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core流畅映射
- en: You can refer to the EF Core documentation to learn about all the details and
    other options for the Fluent Mapping API.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考EF Core文档来了解关于Fluent Mapping API的所有细节和其他选项。
- en: The mapping configuration is complete. It is time to create a database migration
    to update the database schema for the newly added entities.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 映射配置已完成。现在是时候创建一个数据库迁移来更新新添加实体的数据库架构了。
- en: The Add-Migration command
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Add-Migration命令
- en: When you create a new entity or make changes to an existing entity, you should
    also create or alter the related table in the database. EF Core's **Code First
    Migration** system is a perfect way to keep the database schema aligned with the
    application code. Typically, you generate migrations and apply them to the database.
    A migration is an incremental schema change for the database. When you update
    the database, all the migrations are applied since the last update, and the database
    becomes aligned with the application code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建一个新的实体或修改现有的实体时，您还应该在数据库中创建或修改相关的表。EF Core的**Code First Migration**系统是保持数据库架构与应用程序代码一致的理想方式。通常，您会生成迁移并将它们应用到数据库中。迁移是数据库的增量架构更改。当您更新数据库时，所有自上次更新以来的迁移都会被应用，数据库就会与应用程序代码保持一致。
- en: There are two ways to generate a new migration.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以生成新的迁移。
- en: With Visual Studio
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Visual Studio
- en: 'If you are using Visual Studio, open **Package Manager Console (PMC)** from
    the **View** | **Other Windows** | **Package Manager Console** menu:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Visual Studio，请从**视图** | **其他窗口** | **包管理控制台**菜单打开**包管理控制台（PMC）**：
- en: '![Figure 3.4 – Package Manager Console'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.4 – 包管理控制台'
- en: '](img/Figure_3.4_B17287.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.4_B17287.jpg]'
- en: Figure 3.4 – Package Manager Console
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 包管理控制台
- en: Select the *ProductManagement.EntityFrameworkCore* project as the **Default
    project** type. Ensure that the *ProductManagement.Web* project is selected as
    the startup project. You can right-click on the *ProductManagement.Web* project
    and click on the **Set as Startup Project** action.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将*ProductManagement.EntityFrameworkCore*项目作为**默认项目**类型选择。确保*ProductManagement.Web*项目被选为启动项目。您可以在*ProductManagement.Web*项目上右键单击，然后单击**设置为启动项目**操作。
- en: 'Now, you can type the following command into the PMC to add a new migration
    class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在PMC中输入以下命令以添加一个新的迁移类：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output of this command should be similar to *Figure 3.5*:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的输出应类似于*图3.5*：
- en: '![Figure 3.5 – Output of the Add-Migration command'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.5 – Add-Migration命令的输出'
- en: '](img/Figure_3.5_B17287.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.5_B17287.jpg]'
- en: Figure 3.5 – Output of the Add-Migration command
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – Add-Migration命令的输出
- en: If you get an error such as *No DbContext was found in assembly…*, be sure that
    you've set the **Default project** type to the *ProductManagement.EntityFrameworkCore*
    project.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到诸如*在程序集...中没有找到DbContext*之类的错误，请确保您已将**默认项目**类型设置为*ProductManagement.EntityFrameworkCore*项目。
- en: If everything goes well, a new migration class should be added inside the *Migrations*
    folder of the *ProductManagement.EntityFrameworkCore* project.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，新的迁移类应该被添加到*ProductManagement.EntityFrameworkCore*项目的*Migrations*文件夹中。
- en: In the command line
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在命令行中
- en: 'If you are not using Visual Studio, you can use the EF Core command-line tools.
    If you haven''t installed it yet, execute the following command in a command-line
    terminal:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用Visual Studio，你可以使用EF Core命令行工具。如果你还没有安装它，请在命令行终端中执行以下命令：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, open a command-line terminal in the root directory of the *ProductManagement.EntityFrameworkCore*
    project, and type in the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`ProductManagement.EntityFrameworkCore`项目的根目录下打开一个命令行终端，并输入以下命令：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A new migration class should be added inside the *Migrations* folder of the
    *ProductManagement.EntityFrameworkCore* project.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 应在`ProductManagement.EntityFrameworkCore`项目的`Migrations`文件夹内添加一个新的迁移类。
- en: Before applying the newly created migration to the database, I want to mention
    the data seeding feature of ABP Framework.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用新创建的迁移到数据库之前，我想提及ABP框架的数据初始化功能。
- en: Seeding data
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化数据
- en: The data seeding system is used to add some initial data when you migrate the
    database. For example, the identity module creates an admin user in the database
    with all permissions granted to log in to the application.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 数据初始化系统用于在迁移数据库时添加一些初始数据。例如，身份模块在数据库中创建了一个拥有所有权限的admin用户，以便登录应用程序。
- en: While data seeding is not essential in our scenario, I want to add some example
    categories and products to the database to make it easier to develop and test
    the application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，数据初始化不是必需的，但我想要在数据库中添加一些示例类别和产品，以便更容易地进行开发和测试。
- en: About the EF Core Data Seeding
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 关于EF Core数据初始化
- en: This section uses ABP's data seed system, while EF Core has its own data seeding
    feature. The ABP data seed system allows you to inject runtime services and implement
    advanced logic in your data seed code, and it is suitable for development, test,
    and production environments. However, for simpler development and test scenarios,
    you can use EF Core's data seeding system. Please check the official documentation
    at [https://docs.microsoft.com/en-us/ef/core/modeling/data-seeding](https://docs.microsoft.com/en-us/ef/core/modeling/data-seeding).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本节使用ABP的数据初始化系统，而EF Core有自己的数据初始化功能。ABP数据初始化系统允许你在数据初始化代码中注入运行时服务并实现高级逻辑，适用于开发、测试和生产环境。然而，对于更简单的开发测试场景，你可以使用EF
    Core的数据初始化系统。请查阅官方文档[https://docs.microsoft.com/en-us/ef/core/modeling/data-seeding](https://docs.microsoft.com/en-us/ef/core/modeling/data-seeding)。
- en: 'Create a `ProductManagementDataSeedContributor` class in the *Data* folder
    of the *ProductManagement.Domain* project:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ProductManagement.Domain`项目的`Data`文件夹中创建一个`ProductManagementDataSeedContributor`类：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This class implements the `IDataSeedContributor` interface. ABP automatically
    discovers and calls its `SeedAsync` method when you want to seed the database.
    You can implement constructor injection and use any service in your class (such
    as the repositories in this example).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类实现了`IDataSeedContributor`接口。当你想要初始化数据库时，ABP会自动发现并调用它的`SeedAsync`方法。你可以在类中实现构造函数注入并使用任何服务（例如，本例中的存储库）。
- en: 'Then, write the following code inside the `SeedAsync` method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`SeedAsync`方法内部编写以下代码：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We've created two categories with three products and inserted them into the
    database. This class is executed whenever you run the *DbMigrator* application
    (please refer to the following section). Additionally, we checked `if (await _categoryRepository.CountAsync()
    > 0)` to prevent us from inserting the same data in every run.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了两个类别，并添加了三个产品到数据库中。这个类在每次运行`DbMigrator`应用程序时都会执行（请参阅以下章节）。此外，我们检查了`if
    (await _categoryRepository.CountAsync() > 0)`以防止每次运行时插入相同的数据。
- en: We are now ready to migrate the database, which will update the database schema
    and seed the initial data.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好迁移数据库，这将更新数据库架构并初始化初始数据。
- en: Migrating the database
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迁移数据库
- en: The ABP application startup template includes a *DbMigrator* console application
    that is pretty useful in development and production environments. When you run
    it, all pending migrations are applied in the database, and the data seeder classes
    are executed. It supports multi-tenant, multi-database scenarios, which is not
    possible if you use the standard `Update-Database` command. This application can
    be deployed and executed in the production environment, typically, as a stage
    of your **Continuous Deployment** (**CD**) pipeline. Separating the migration
    from the main application is a good approach, as the main application doesn't
    require permission to alter the database schema in such cases. Also, you can get
    rid of any concurrency issues you might have if you apply migrations in your main
    application and run multiple instances of the application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 应用程序启动模板包括一个非常有用的 *DbMigrator* 控制台应用程序，它在开发和生产环境中都很有用。当您运行它时，所有挂起的迁移都会在数据库中应用，并且会执行数据生成器类。它支持多租户、多数据库场景，如果您使用标准的
    `Update-Database` 命令，这是不可能的。此应用程序可以在生产环境中部署和执行，通常作为您 **持续部署** (**CD**) 管道的一部分。将迁移与主应用程序分离是一种很好的方法，因为在这种情况下主应用程序不需要更改数据库模式的权限。此外，如果您在主应用程序中应用迁移并运行多个应用程序实例，您还可以消除任何并发问题。
- en: Run the *ProductManagement.DbMigrator* application to migrate the database (that
    is, set it as the startup project, and hit *Ctrl* + *F5*). Once the application
    exits, you can check the database to see that the *Categories* and *Products*
    tables have the initial data inserted (if you are using Visual Studio, you can
    use **SQL Server Object Explorer** to connect to **LocalDB** and explore the databases).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 *ProductManagement.DbMigrator* 应用程序以迁移数据库（即将其设置为启动项目，然后按 *Ctrl* + *F5*）。一旦应用程序退出，您就可以检查数据库以查看
    *Categories* 和 *Products* 表已插入初始数据（如果您使用的是 Visual Studio，您可以使用 **SQL Server Object
    Explorer** 连接到 **LocalDB** 并探索数据库）。
- en: The EF Core configuration is complete, and the database is ready for development.
    We will continue by showing the product data on the UI.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 配置已完成，数据库已准备好开发。我们将继续在 UI 上显示产品数据。
- en: Listing the product data
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出产品数据
- en: I prefer to develop the application functionality feature by feature. This section
    will explain how to show a list of the products in a data table on the UI.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢按功能特性开发应用程序功能。本节将解释如何在 UI 上以数据表的形式显示产品列表。
- en: We will begin by defining a `ProductDto`, for the `Product` entity. Then, we
    will create an application service method that returns a list of products to the
    presentation layer. Additionally, we will learn how to map the `Product` entity
    to `ProductDto` automatically.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义一个 `ProductDto`，用于 `Product` 实体。然后，我们将创建一个应用程序服务方法，该方法将产品列表返回到表示层。此外，我们还将学习如何自动将
    `Product` 实体映射到 `ProductDto`。
- en: Before creating the UI, I will show you how to write an **Automated Test** for
    the application service. In this way, we will be sure that the application service
    is working properly before starting the UI development.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 UI 之前，我将向您展示如何为应用程序服务编写 **自动化测试**。这样，我们就可以在开始 UI 开发之前确保应用程序服务正常工作。
- en: Throughout the development, we will explore some benefits of ABP Framework,
    such as the automatic API controller and dynamic JavaScript Proxy systems.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个开发过程中，我们将探讨 ABP 框架的一些好处，例如自动 API 控制器和动态 JavaScript 代理系统。
- en: Finally, we will create a new page, add a data table inside it, get a list of
    the products from the server, and show it on the UI.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个新页面，在其中添加一个数据表，从服务器获取产品列表，并在 UI 上显示。
- en: In the next section, we will begin by creating a `ProductDto` class.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将首先创建一个 `ProductDto` 类。
- en: The ProductDto class
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ProductDto 类
- en: DTOs are used to transfer data between the application and presentation layers.
    It is best practice to return DTOs to the presentation (UI) layer instead of the
    entities. DTOs allow you to expose data in a controlled way and abstract your
    entities from the presentation layer. Directly exposing entities to the presentation
    layer might cause serialization and security problems, too. We will discuss the
    benefits of using DTOs in [*Chapter 11*](B17287_11_Epub_AM.xhtml#_idTextAnchor340),
    *DDD – The Application Layer*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: DTOs 用于在应用程序和表示层之间传输数据。最佳实践是将 DTOs 返回到表示层（UI），而不是实体。DTOs 允许您以受控的方式公开数据，并将实体从表示层抽象出来。直接将实体公开给表示层也可能导致序列化和安全问题。我们将在
    [*第 11 章*](B17287_11_Epub_AM.xhtml#_idTextAnchor340) 中讨论使用 DTOs 的好处，*领域驱动设计 –
    应用层*。
- en: 'DTOs are defined in the *Application.Contracts* project to make them available
    within the UI layer. So, we start by creating a `ProductDto` class inside the
    *Products* folder of the *ProductManagement.Application.Contracts* project:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: DTOs在*Application.Contracts*项目中定义，以便在UI层中使用。因此，我们首先在*ProductManagement.Application.Contracts*项目的*Products*文件夹中创建一个`ProductDto`类：
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `ProductDto` class is a similar class to the `Product` entity with the
    following differences:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductDto`类与`Product`实体类似，但有以下区别：'
- en: It is derived from `AuditedEntityDto<Guid>`, which defines the `Id`, `CreationTime`,
    `CreatorId`, `LastModificationTime`, and `LastModifierId` properties (we don't
    need to delete auditing properties, such as `DeletionTime`, since the deleted
    entities are not read from the database).
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它从`AuditedEntityDto<Guid>`派生，该类定义了`Id`、`CreationTime`、`CreatorId`、`LastModificationTime`和`LastModifierId`属性（我们不需要删除审计属性，如`DeletionTime`，因为已删除的实体不会从数据库中读取）。
- en: Instead of adding a navigation property to the `Category` entity, we used a
    `string` `CategoryName` property, which is enough to show on the UI.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们没有在`Category`实体中添加导航属性，而是使用了一个`string`类型的`CategoryName`属性，这对于在UI上显示是足够的。
- en: We will use the `ProductDto` class to return a list of products from the `IProductAppService`
    interface.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`ProductDto`类从`IProductAppService`接口返回产品列表。
- en: IProductAppService
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IProductAppService
- en: '**Application Services** implement the use cases of an application. The UI
    uses them to perform business logic on user interactions. Typically, an application
    service method gets and returns DTOs.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用服务**实现了应用程序的使用案例。用户界面使用它们来执行用户交互的业务逻辑。通常，应用程序服务方法获取并返回DTOs。'
- en: Application Services versus API Controllers
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务与API控制器比较
- en: You could compare application services with API controllers in an ASP.NET Core
    MVC application. While they have similarities for some use cases, application
    services are plain classes that better fit into DDD. They don't depend on a particular
    UI technology. In addition, ABP can automatically expose your application services
    as HTTP APIs, as we will discover in the *Auto API Controllers and the Swagger
    UI* section of this chapter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在ASP.NET Core MVC应用程序中将应用服务与API控制器进行比较。虽然它们在某些用例中具有相似性，但应用服务是更适合DDD的纯类。它们不依赖于特定的UI技术。此外，ABP可以自动将你的应用服务作为HTTP
    API公开，正如我们在本章的*自动API控制器和Swagger UI*部分中所将发现的。
- en: 'We define interfaces for application services in the *Application.Contracts*
    project of the solution. Create an `IProductAppService` interface inside the *Products*
    folder of the *ProductManagement.Application.Contracts* project:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在解决方案的*Application.Contracts*项目中定义应用服务的接口。在*ProductManagement.Application.Contracts*项目的*Products*文件夹中创建一个`IProductAppService`接口：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can see some predefined ABP types in the preceding code block:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在前面的代码块中看到一些预定义的ABP类型：
- en: '`IProductAppService` is derived from the `IApplicationService` interface. In
    this way, ABP can recognize the application services.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IProductAppService`是从`IApplicationService`接口派生的。通过这种方式，ABP可以识别应用服务。'
- en: The `GetListAsync` method gets `PagedAndSortedResultRequestDto`, which is a
    standard DTO class of ABP Framework that defines the `MaxResultCount` (int), `SkipCount`
    (int), and `Sorting` (string) properties.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetListAsync`方法获取`PagedAndSortedResultRequestDto`，这是ABP框架的一个标准DTO类，它定义了`MaxResultCount`（整型）、`SkipCount`（整型）和`Sorting`（字符串）属性。'
- en: The `GetListAsync` method returns `PagedResultDto<ProductDto>`, which contains
    a `TotalCount` (long) property and an `Items` collection of `ProductDto` objects.
    That is a convenient way of returning paged results with ABP Framework.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetListAsync`方法返回`PagedResultDto<ProductDto>`，它包含一个`TotalCount`（长整型）属性和一个`Items`集合，其中包含`ProductDto`对象。这是使用ABP框架返回分页结果的一种便捷方式。'
- en: You could use your own DTOs instead of these predefined DTO types. However,
    they are pretty helpful when you want to standardize some common patterns and
    use the same naming everywhere.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用自己的DTOs而不是这些预定义的DTO类型。然而，当你在标准化某些常见模式并希望到处使用相同的命名时，它们非常有用。
- en: Asynchronous Methods
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 异步方法
- en: It is a best practice to define all the application service methods as asynchronous.
    If you define synchronous application service methods, in some cases, certain
    ABP features (such as Unit of Work) might not work as expected.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有应用服务方法定义为异步是一种最佳实践。如果你定义了同步的应用服务方法，在某些情况下，某些ABP功能（如工作单元）可能无法按预期工作。
- en: Now, we can implement the `IProductAppService` interface to perform the use
    case.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现`IProductAppService`接口以执行用例。
- en: ProductAppService
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ProductAppService
- en: 'Create a `ProductAppService` class inside the *Products* folder of the *ProductManagement.Application*
    project:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *ProductManagement.Application* 项目的 *Products* 文件夹中创建一个 `ProductAppService`
    类：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `ProductAppService` class is derived from `ProductManagementAppService`,
    which was defined in the startup template, and can be used as the base class for
    your application services. It implements the `IProductAppService` interface that
    was previously defined. It injects the `IRepository<Product, Guid>` service. This
    is called a **Default Repository**. A repository is a collection-like interface
    that allows you to perform operations on the database. ABP automatically provides
    default repository implementations for all aggregate root entities.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductAppService` 类继承自 `ProductManagementAppService`，该类在启动模板中定义，可以用作应用程序服务的基类。它实现了之前定义的
    `IProductAppService` 接口。它注入了 `IRepository<Product, Guid>` 服务。这被称为 **默认仓储**。仓储是一个类似集合的接口，允许你在数据库上执行操作。ABP
    自动为所有聚合根实体提供默认仓储实现。'
- en: 'We can implement the `GetListAsync` method, as shown in the following code
    block:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现 `GetListAsync` 方法，如下面的代码块所示：
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, `_productRepository.WithDetailsAsync` returns an `IQueryable<Product>`
    object by including the categories (the `WithDetailsAsync` method is similar to
    EF Core's `Include` extension method, which loads the related data into the query).
    We can use the standard `Skip`, `Take`, and `OrderBy` on the queryable object.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`_productRepository.WithDetailsAsync` 通过包含类别（`WithDetailsAsync` 方法类似于 EF
    Core 的 `Include` 扩展方法，它将相关数据加载到查询中）返回一个 `IQueryable<Product>` 对象。我们可以在查询对象上使用标准的
    `Skip`、`Take` 和 `OrderBy`。
- en: The `AsyncExecuter` service (which is pre-injected in the base class) is used
    to execute the `IQueryable` object to perform a database query asynchronously.
    This makes it possible to use the async LINQ extension methods without depending
    on the EF Core package in the application layer.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncExecuter` 服务（在基类中预先注入）用于执行 `IQueryable` 对象以异步执行数据库查询。这使得可以在应用层不依赖于 EF
    Core 包的情况下使用异步 LINQ 扩展方法。'
- en: Finally, we are using the `ObjectMapper` service (pre-injected in the base class)
    to map a list of `Product` (entity) objects to a `ProductDto` (DTO) object list.
    In the next section, we will explain how the object mapping is configured.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `ObjectMapper` 服务（在基类中预先注入）将 `Product`（实体）对象列表映射到 `ProductDto`（DTO）对象列表。在下一节中，我们将解释对象映射是如何配置的。
- en: Repositories and Async Query Execution
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 仓储和异步查询执行
- en: We will explore `IRepository` and `AsyncExecuter` in greater detail in [*Chapter
    6*](B17287_06_Epub_AM.xhtml#_idTextAnchor177), *Working with the Data Access Infrastructure*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第 6 章*](B17287_06_Epub_AM.xhtml#_idTextAnchor177)，*与数据访问基础设施一起工作* 中更详细地探讨
    `IRepository` 和 `AsyncExecuter`。
- en: Object to object mapping
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象到对象映射
- en: '`ObjectMapper` (the `IObjectMapper` service) automates type conversions and
    uses the **AutoMapper** library by default. It requires you to define the mapping
    before using it. The startup template contains a profile class that you can create
    the mappings inside.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObjectMapper`（`IObjectMapper` 服务）自动化类型转换，并默认使用 **AutoMapper** 库。它要求你在使用之前定义映射。启动模板包含一个配置类，你可以在其中创建映射。'
- en: 'Open the `ProductManagementApplicationAutoMapperProfile` class in the *ProductManagement.Application*
    project, and change it to the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *ProductManagement.Application* 项目的 `ProductManagementApplicationAutoMapperProfile`
    类中打开，并将其更改为以下内容：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, `CreateMap` defines the mapping. Then, you can automatically convert `Product`
    objects into `ProductDto` objects where you need them.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`CreateMap` 定义了映射。然后，你可以在需要的地方自动将 `Product` 对象转换为 `ProductDto` 对象。
- en: One of the interesting AutoMapper features is `Product` class has a `Category`
    property, and the `Category` class has a `Name` property. So, if you want to access
    the category name of a product, you should use the `Product.Category.Name` expression.
    However, `ProductDto` has a direct `CategoryName` property that can be accessed
    using the `ProductDto.CategoryName` expression. AutoMapper automatically maps
    these expressions by flattening `Category.Name` into `CategoryName`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: AutoMapper 的一个有趣特性是 `Product` 类有一个 `Category` 属性，而 `Category` 类有一个 `Name` 属性。所以，如果你想访问产品的类别名称，你应该使用
    `Product.Category.Name` 表达式。然而，`ProductDto` 有一个直接的 `CategoryName` 属性，可以使用 `ProductDto.CategoryName`
    表达式访问。AutoMapper 自动通过将 `Category.Name` 展平到 `CategoryName` 来映射这些表达式。
- en: The application layer is complete. Before starting the UI, I want to show you
    how to write automated tests for the application layer.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层已完成。在开始 UI 之前，我想向你展示如何为应用层编写自动化测试。
- en: Testing the ProductAppService class
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 ProductAppService 类
- en: The startup template comes with the test infrastructure properly configured
    using the **xUnit**, **Shouldly**, and **NSubstitute** libraries. It uses the
    *SQLite in-memory* database to mock the database. A separate database is created
    for each test. It is seeded and destroyed at the end of the test. In this way,
    tests do not affect each other, and your real database remains untouched.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 启动模板附带使用 **xUnit**、**Shouldly** 和 **NSubstitute** 库正确配置的测试基础设施。它使用 *SQLite 内存数据库*
    来模拟数据库。为每个测试创建一个单独的数据库。测试结束时，数据库将被初始化和销毁。这样，测试不会相互影响，并且你的真实数据库保持不变。
- en: '[*Chapter 17*](B17287_17_Epub_AM.xhtml#_idTextAnchor476), *Building Automated
    Tests*, will explore all the details of testing. However, here, I want to show
    you how you can easily write some automated test code for the `GetListAsync` method
    of the `ProductAppService` class. It is good to write the test code for the application
    services before using them on the UI.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第 17 章*](B17287_17_Epub_AM.xhtml#_idTextAnchor476)，*构建自动化测试* 将探讨测试的所有细节。然而，在这里，我想向你展示如何轻松编写
    `ProductAppService` 类的 `GetListAsync` 方法的自动化测试代码。在 UI 上使用之前编写应用程序服务的测试代码是很好的。'
- en: 'Create a *Products* folder in the *ProductManagement.Application.Tests* project,
    and create a `ProductAppService_Tests` class inside it:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *ProductManagement.Application.Tests* 项目中创建一个 *Products* 文件夹，并在其中创建一个 `ProductAppService_Tests`
    类：
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This class inherits from the `ProductManagementApplicationTestBase` class (which
    is included in your solution) that integrates ABP Framework and other infrastructure
    libraries and makes it possible to write our tests. Instead of constructor injection
    (which is not possible in tests), we use the `GetRequiredService` method to resolve
    dependencies in the test code.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此类继承自 `ProductManagementApplicationTestBase` 类（包含在你的解决方案中），该类集成了 ABP 框架和其他基础设施库，使我们能够编写测试。由于测试中不可能使用构造函数注入，我们使用
    `GetRequiredService` 方法在测试代码中解析依赖项。
- en: 'Now, we can write the first test method. Add the following method inside the
    `ProductAppService_Tests` class:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写第一个测试方法。在 `ProductAppService_Tests` 类中添加以下方法：
- en: '[PRE20]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This method calls the `GetListAsync` method and checks whether the result is
    correct. If you open the **Test Explorer** window (under the **View** | **Test
    Explorer** menu in Visual Studio), you can see the test method that we''ve added.
    **Test Explorer** is used for showing and running the tests in the solution:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法调用 `GetListAsync` 方法并检查结果是否正确。如果你打开 **测试资源管理器** 窗口（在 Visual Studio 的 **视图**
    | **测试资源管理器** 菜单下），你可以看到我们添加的测试方法。**测试资源管理器** 用于显示和运行解决方案中的测试：
- en: '![Figure 3.6 – The Test Explorer window'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.6 – 测试资源管理器窗口'
- en: '](img/Figure_3.6_B17287.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.6_B17287.jpg)'
- en: Figure 3.6 – The Test Explorer window
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 测试资源管理器窗口
- en: Run the test to check whether it is working as expected. If the `GetListAsync`
    method works properly, you will see a green icon on the left-hand side of the
    test method name, as shown in *Figure 3.6*. Unit and integration tests will be
    covered in [*Chapter 17*](B17287_17_Epub_AM.xhtml#_idTextAnchor476), *Building
    Automated Tests*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以检查它是否按预期工作。如果 `GetListAsync` 方法工作正常，你将在测试方法名称的左侧看到绿色图标，如图 *图 3.6* 所示。单元测试和集成测试将在
    [*第 17 章*](B17287_17_Epub_AM.xhtml#_idTextAnchor476)，*构建自动化测试* 中介绍。
- en: Auto API Controllers and the Swagger UI
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动 API 控制器和 Swagger UI
- en: '**Swagger** is a popular tool in which to explore and test HTTP APIs. It comes
    preinstalled with the startup template.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swagger** 是一个流行的工具，用于探索和测试 HTTP API。它随启动模板预安装。'
- en: 'Run the *ProductManagement.Web* project to start the web application (set it
    as the startup project if not done so already, and hit *Ctrl* + *F5*). Once the
    application starts, enter the `/swagger` URL, as shown in *Figure 3.7*:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 *ProductManagement.Web* 项目以启动 Web 应用程序（如果尚未设置，请将其设置为启动项目，然后按 *Ctrl* + *F5*）。一旦应用程序启动，输入如图
    *图 3.7* 所示的 `/swagger` URL：
- en: '![Figure 3.7 – The Swagger UI'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.7 – Swagger UI'
- en: '](img/Figure_3.7_B17287.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.7_B17287.jpg)'
- en: Figure 3.7 – The Swagger UI
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – Swagger UI
- en: 'You will see a lot of API endpoints coming from the modules installed in the
    application. If you scroll down, you will see a **Product** endpoint, too. You
    can test it to get the list of products:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到来自应用程序中安装的模块的大量 API 端点。如果你向下滚动，你将看到一个 **产品** 端点。你可以测试它以获取产品列表：
- en: '![Figure 3.8 – The Product endpoint'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.8 – 产品端点'
- en: '](img/Figure_3.8_B17287.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.8_B17287.jpg)'
- en: Figure 3.8 – The Product endpoint
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 产品端点
- en: We haven't created a *ProductController* endpoint yet. So, how is this endpoint
    available here? This is known as the **Auto API Controller** feature of ABP Framework.
    It automatically exposes your application services as HTTP APIs based on naming
    conventions and configurations. Typically, we don't write the controllers manually.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有创建 *ProductController* 端点。那么这个端点是如何在这里可用的呢？这被称为 ABP 框架的 **Auto API 控制器**
    功能。它根据命名约定和配置自动将您的应用程序服务公开为 HTTP API。通常，我们不手动编写控制器。
- en: The Auto API Controller feature will be covered in [*Chapter 14*](B17287_14_Epub_AM.xhtml#_idTextAnchor429),
    *Building HTTP APIs and Real-Time Services*, in detail.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Auto API 控制器功能将在 [*第 14 章*](B17287_14_Epub_AM.xhtml#_idTextAnchor429)，*构建 HTTP
    API 和实时服务*中详细介绍。
- en: So, we have the HTTP API to get the list of products. The next step is to consume
    this API from the client code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有 HTTP API 来获取产品列表。下一步是从客户端代码中消费这个 API。
- en: Dynamic JavaScript proxies
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态 JavaScript 代理
- en: Typically, you call the HTTP API endpoints from your JavaScript code. ABP dynamically
    creates client-side proxies for all HTTP APIs. Then, you can use these dynamic
    JavaScript functions to consume your APIs from the client application.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您从 JavaScript 代码中调用 HTTP API 端点。ABP 动态为所有 HTTP API 创建客户端代理。然后，您可以使用这些动态 JavaScript
    函数从客户端应用程序中消费您的 API。
- en: Run the *ProductManagement.Web* project again, and open the **Developer Console**
    of the browser while you are on the application's landing page. The developer
    console is available in any modern browser and is typically opened using the *F12*
    shortcut key (on Windows). It is used to explore, trace, and debug the application
    by developers.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行 *ProductManagement.Web* 项目，并在您位于应用程序的着陆页时打开浏览器的 **开发者控制台**。开发者控制台在任何现代浏览器中都是可用的，通常使用
    *F12* 快捷键（在 Windows 上）打开。它用于通过开发者探索、跟踪和调试应用程序。
- en: 'Open the **Console** tab, and type in the following JavaScript code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 **控制台** 选项卡，并输入以下 JavaScript 代码：
- en: '[PRE21]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once you execute this code, a request is made to the server, and the returning
    result is logged in the **Console** tab, as shown in *Figure 3.9*:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您执行此代码，就会向服务器发出请求，并将返回的结果记录在 **控制台** 选项卡中，如图 *3.9* 所示：
- en: '![Figure 3.9 – Using the dynamic JavaScript proxies'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.9 – 使用动态 JavaScript 代理'
- en: '](img/Figure_3.9_B17287.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.9_B17287.jpg)'
- en: Figure 3.9 – Using the dynamic JavaScript proxies
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 使用动态 JavaScript 代理
- en: We can see that the product list is logged in the **Console** tab. That means
    we can easily consume server-side APIs from JavaScript code without having to
    deal with the low-level details.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到产品列表已记录在 **控制台** 选项卡中。这意味着我们可以轻松地从 JavaScript 代码中消费服务器端 API，而无需处理底层细节。
- en: If you are wondering where that `getList` JavaScript is defined, you can check
    the `/Abp/ServiceProxyScript` endpoint in your application to see the JavaScript
    proxy functions dynamically created by ABP Framework.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道那个 `getList` JavaScript 定义在哪里，您可以在应用程序中的 `/Abp/ServiceProxyScript` 端点查看
    ABP 框架动态创建的 JavaScript 代理函数。
- en: In the next section, we will create a **Razor Page** to show the table of products
    on the UI.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将创建一个 **Razor 页面**来在 UI 上显示产品表。
- en: Creating a products page
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建产品页面
- en: Razor Pages is the recommended way of creating a UI in the ASP.NET Core MVC
    framework.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Razor Pages 是在 ASP.NET Core MVC 框架中创建 UI 的推荐方式。
- en: 'First, create a *Products* folder under the *Pages* folder of the *ProductManagement.Web*
    project. Then, add a new, empty razor page by right-clicking on the *Products*
    folder and then selecting `Index.cshtml`. *Figure 3.10* shows the location of
    the page that we''ve added:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 *ProductManagement.Web* 项目的 *Pages* 文件夹下创建一个 *Products* 文件夹。然后，通过右键单击 *Products*
    文件夹并选择 `Index.cshtml` 来添加一个新的空 razor 页面。*图 3.10* 显示了我们添加的页面位置：
- en: '![Figure 3.10 – Creating a Razor Page'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.10 – 创建 Razor 页面'
- en: '](img/Figure_3.10_B17287.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.10_B17287.jpg)'
- en: Figure 3.10 – Creating a Razor Page
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 创建 Razor 页面
- en: 'Edit the `Index.cshtml` content, as shown in the following code block:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `Index.cshtml` 内容，如下面的代码块所示：
- en: '[PRE22]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, I've just placed an `h1` element as the page header. When we create a
    page, typically, we want to add an item to the main menu to open this page.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我刚刚放置了一个`h1`元素作为页面标题。当我们创建一个页面时，通常，我们希望向主菜单添加一个项目以打开此页面。
- en: Adding a new menu item
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加新的菜单项
- en: ABP provides a dynamic and modular menu system. Every module can add items to
    the main menu.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 提供了一个动态和模块化的菜单系统。每个模块都可以向主菜单添加项目。
- en: 'Open the `ProductManagementMenuContributor` class in the *Menus* folder of
    the *ProductManagement.Web* project, and add the following code at the end of
    the `ConfigureMainMenuAsync` method:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 *ProductManagement.Web* 项目的 *Menus* 文件夹中的 `ProductManagementMenuContributor`
    类，并在 `ConfigureMainMenuAsync` 方法的末尾添加以下代码：
- en: '[PRE23]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This code adds a *Product Management* main menu item with the *Products* menu
    item inside it. It uses localization keys (with the `l["…"]` syntax) that we should
    define. Open the `en.json` file in the *Localization/ProductManagement* folder
    of the *ProductManagement.Domain.Shared* project, and add the following entries
    to the end of the `texts` section:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码添加了一个包含 *产品* 菜单项的 *产品管理* 主菜单项。它使用我们应定义的本地化键（使用 `l["…"]` 语法）。打开 *ProductManagement.Domain.Shared*
    项目的 *Localization/ProductManagement* 文件夹中的 `en.json` 文件，并在 `texts` 部分的末尾添加以下条目：
- en: '[PRE24]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Localization keys are arbitrary, which means you can use any string value as
    the localization key. I prefer to use the `Menu:` prefix for the localization
    keys of menu items, such as `Menu:Products`, in this example. We will return to
    the topic of localization in [*Chapter 8*](B17287_08_Epub_AM.xhtml#_idTextAnchor249),
    *Using the Features and Services of ABP*.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化键是任意的，这意味着你可以使用任何字符串值作为本地化键。我更喜欢使用 `Menu:` 前缀作为菜单项的本地化键，例如本例中的 `Menu:Products`。我们将在
    [*第 8 章*](B17287_08_Epub_AM.xhtml#_idTextAnchor249)，*使用 ABP 的功能和服务* 中回到本地化的话题。
- en: 'Now, you can rerun the application and open the *Products* page using the new
    *Product Management* menu item, as shown in *Figure 3.11*:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以重新运行应用程序，并使用新的 *产品管理* 菜单项打开 *产品* 页面，如图 3.11 所示：
- en: '![Figure 3.11 – The Products page'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.11 – 产品页面'
- en: '](img/Figure_3.11_B17287.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.11_B17287.jpg)'
- en: Figure 3.11 – The Products page
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – 产品页面
- en: So, we've created a page and can open the page using the menu element. We are
    ready to create a data table to show the list of products.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经创建了一个页面，并且可以使用菜单元素打开该页面。我们现在准备好创建一个数据表来显示产品列表。
- en: Creating the products data table
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建产品数据表
- en: We will create a data table to show the list of products with paging and sorting.
    The ABP startup template comes with the **Datatables.net** JavaScript library
    preinstalled and configured. It is a flexible and feature-rich library to show
    tabular data.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个数据表来显示带有分页和排序的产品列表。ABP 启动模板预安装并配置了 **Datatables.net** JavaScript 库。这是一个灵活且功能丰富的库，用于显示表格数据。
- en: 'Open the `Index.cshtml` page (in the *Pages/Products* folder), and change its
    contents to the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 *Pages/Products* 文件夹中的 `Index.cshtml` 页面，并将其内容更改为以下内容：
- en: '[PRE25]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, `abp-script` is an ABP tag helper for adding script files to the page
    with automatic bundling, minification, and versioning support. `abp-card` is another
    tag helper to render a card component in a type-safe and easy way (it renders
    a Bootstrap card).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`abp-script` 是一个 ABP 标签助手，用于向页面添加带有自动捆绑、压缩和版本支持功能的脚本文件。`abp-card` 是另一个标签助手，以类型安全和简单的方式渲染卡片组件（它渲染一个
    Bootstrap 卡片）。
- en: We could use the standard HTML tags. However, ABP tag helpers dramatically simplify
    UI creation in MVC/Razor Page applications. Additionally, they prevent errors
    with the help of IntelliSense and compile-time type checking. We will investigate
    tag helpers in [*Chapter 12*](B17287_12_Epub_AM.xhtml#_idTextAnchor356), *Working
    with MVC/Razor Pages*.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用标准的 HTML 标签。然而，ABP 标签助手极大地简化了 MVC/Razor Page 应用程序中的 UI 创建。此外，它们通过 IntelliSense
    和编译时类型检查来防止错误。我们将在 [*第 12 章*](B17287_12_Epub_AM.xhtml#_idTextAnchor356)，*使用 MVC/Razor
    Pages* 中研究标签助手。
- en: 'Create a new JavaScript file, named `Index.cshtml.js` (you might prefer a different
    naming style, such as `index.js`; that''s fine, as long as you use the same file
    name in the `abp-script` tag), under the *Pages/Products* folder with the following
    content:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Pages/Products* 文件夹下创建一个新的 JavaScript 文件，命名为 `Index.cshtml.js`（你可能更喜欢不同的命名风格，例如
    `index.js`；这没关系，只要你在 `abp-script` 标签中使用相同的文件名即可），内容如下：
- en: '[PRE26]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ABP allows you to reuse the localization texts in your JavaScript code. In this
    way, you can define them on the server side and use them on both sides. `abp.localization.getResource`
    returns a function to localize the values.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 允许你在 JavaScript 代码中重用本地化文本。这样，你可以在服务器端定义它们，并在两边使用。`abp.localization.getResource`
    返回一个用于本地化值的函数。
- en: 'ABP simplifies the data table''s library configuration and provides built-in
    integrations:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 简化了数据表库的配置，并提供了内置集成：
- en: '`abp.libs.datatables.normalizeConfiguration` is a helper function defined by
    ABP Framework. It simplifies the data table''s configuration by providing conventional
    default values for missing options.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abp.libs.datatables.normalizeConfiguration` 是 ABP 框架定义的辅助函数。它通过为缺失的选项提供常规默认值来简化数据表的配置。'
- en: '`abp.libs.datatables.createAjax` is another helper function that adapts ABP''s
    dynamic JavaScript client proxies to the data table''s parameter format.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abp.libs.datatables.createAjax` 是另一个辅助函数，它将 ABP 的动态 JavaScript 客户端代理适配到数据表的参数格式。'
- en: '`productManagement.products.product.getList` is the dynamic JavaScript proxy
    function introduced earlier.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`productManagement.products.product.getList` 是之前介绍过的动态 JavaScript 代理函数。'
- en: 'Define the columns of the data table inside the `columnDefs` array:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `columnDefs` 数组内部定义数据表的列：
- en: '[PRE27]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Typically, a column definition has a `title` field (display name) and a `data`
    field. The data field matches the property names in the `ProductDto` class, formatted
    as **camelCase** (a naming style in which the first letter of each word is capitalized,
    except for the first word; it is commonly used in the JavaScript language).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，列定义有一个 `title` 字段（显示名称）和一个 `data` 字段。数据字段与 `ProductDto` 类中的属性名称匹配，格式为 **camelCase**（一种命名风格，其中每个单词的首字母大写，除了第一个单词；它通常用于
    JavaScript 语言中）。
- en: The `render` option can be used to finely control how to show the column data.
    We are providing a function to customize the rendering of the stock state column.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `render` 选项来精细控制如何显示列数据。我们提供了一个函数来自定义库存状态列的渲染。
- en: 'On this page, we''ve used some localization keys. We should define them in
    the localization resource. Open the `en.json` file in the *Localization/ProductManagement*
    folder of the *ProductManagement.Domain.Shared* project, and add the following
    entries at the end of the `texts` section:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个页面上，我们使用了一些本地化键。我们应该在本地化资源中定义它们。打开 *ProductManagement.Domain.Shared* 项目的
    *Localization/ProductManagement* 文件夹中的 `en.json` 文件，并在 `texts` 部分的末尾添加以下条目：
- en: '[PRE28]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can run the web application again to see the product data table in action:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以再次运行 Web 应用程序以查看产品数据表的实际效果：
- en: '![Figure 3.12 – The Products data table'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.12 – 产品数据表](img/Figure_3.12_B17287.jpg)'
- en: '](img/Figure_3.12_B17287.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.12 – The Products data table](img/Figure_3.12_B17287.jpg)'
- en: Figure 3.12 – The Products data table
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – 产品数据表
- en: We've created a fully working page that lists the products with paging and sorting
    support. In the next sections, we will add functionality to create, edit, and
    delete the products.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个完全工作的页面，该页面列出了具有分页和排序支持的产品。在接下来的章节中，我们将添加创建、编辑和删除产品的功能。
- en: Creating products
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建产品
- en: In this section, we will create the necessary functionality to add a new product.
    A product should have a category. So, we should select a category while adding
    a new product. We will define new application service methods to get categories
    and create products. In the UI section, we will use ABP's dynamic form feature
    to automatically generate the product creation form, based on a C# class.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建添加新产品的必要功能。一个产品应该有一个类别。因此，在添加新产品时，我们应该选择一个类别。我们将定义新的应用程序服务方法来获取类别和创建产品。在
    UI 部分，我们将使用 ABP 的动态表单功能自动生成基于 C# 类的产品创建表单。
- en: Application service contracts
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序服务合约
- en: 'Let''s start by adding two new methods to the `IProductAppService` interface:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向 `IProductAppService` 接口添加两个新方法开始：
- en: '[PRE29]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We will use the `GetCategoriesAsync` method to show a drop-down list of categories
    on product creation. We've introduced two new DTOs, and we should define them.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `GetCategoriesAsync` 方法在创建产品时显示类别下拉列表。我们已经介绍了两个新的 DTO，我们应该定义它们。
- en: '`CreateUpdateProductDto` is used to create and update products (we will reuse
    it in the *Editing products* section). Define it in the *Products* folder of the
    *ProductManagement.Application.Contracts* project:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateUpdateProductDto` 用于创建和更新产品（我们将在 *编辑产品* 部分重用它）。在 *ProductManagement.Application.Contracts*
    项目的 *Products* 文件夹中定义它：'
- en: '[PRE30]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, define a `CategoryLookupDto` class in the *Categories* folder of the
    *ProductManagement.Application.Contracts* project:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 *ProductManagement.Application.Contracts* 项目的 *Categories* 文件夹中定义一个 `CategoryLookupDto`
    类：
- en: '[PRE31]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We've created the contracts, so now we can implement the contracts in the application
    layer.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了合约，现在我们可以在应用程序层实现这些合约。
- en: Application service implementation
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序服务实现
- en: 'Implement the `CreateAsync` and `GetCategoriesAsync` methods in `ProductAppService`
    (in the *ProductManagement.Application* project), as shown in the following code
    block:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ProductAppService`（在 *ProductManagement.Application* 项目中）中实现 `CreateAsync`
    和 `GetCategoriesAsync` 方法，如下面的代码块所示：
- en: '[PRE32]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, `_categoryRepository` is a type of `IRepository<Category, Guid>` service.
    You inject it just as you did for `_productRepository` earlier. I think the method
    implementations are pretty simple, and there is no need for additional explanation.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`_categoryRepository` 是一种 `IRepository<Category, Guid>` 服务类型。你就像之前对 `_productRepository`
    所做的那样注入它。我认为方法实现相当简单，不需要额外的解释。
- en: 'We''ve used object mapping in two places, and now we have to define the mapping
    configuration. Open the `ProductManagementApplicationAutoMapperProfile.cs` file
    in the *ProductManagement.Application* project, and add the following code:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在两个地方使用了对象映射，现在我们必须定义映射配置。打开 `ProductManagement.Application` 项目中的 `ProductManagementApplicationAutoMapperProfile.cs`
    文件，并添加以下代码：
- en: '[PRE33]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This code sets up the AutoMapper configuration for the object mapping.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码设置了对象映射的 AutoMapper 配置。
- en: Automated Tests
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试
- en: I will not show any more automated tests in this chapter; however, I have added
    them to the solution. You can check the source code in the GitHub repository.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在本章中展示更多的自动化测试；然而，我已经将它们添加到解决方案中。你可以检查 GitHub 仓库中的源代码。
- en: Now, we can go and consume these methods from the UI layer.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以去 UI 层调用这些方法。
- en: UI
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UI
- en: 'Create a new `CreateProductModal.cshtml` Razor Page under the *Pages/Products*
    folder of the *ProductManagement.Web* project. Open the `CreateProductModal.cshtml.cs`
    file, and change the `CreateProductModalModel` class using the following code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ProductManagement.Web` 项目的 `Pages/Products` 文件夹下创建一个新的 `CreateProductModal.cshtml`
    Razor 页面。打开 `CreateProductModal.cshtml.cs` 文件，并使用以下代码更改 `CreateProductModalModel`
    类：
- en: '[PRE34]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, `ProductManagementPageModel` is a base class defined in the startup template.
    You can inherit it to create `PageModel` classes. `Categories` will be used to
    show a list of the categories in a drop-down list. `[BindProperty]` is a standard
    ASP.NET Core attribute to bind the post data to the `Product` property on an HTTP
    Post request. We are injecting the `IProductAppService` interface to use the methods
    defined earlier.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ProductManagementPageModel` 是在启动模板中定义的一个基类。你可以继承它来创建 `PageModel` 类。`Categories`
    将用于在下拉列表中显示类别列表。`[BindProperty]` 是一个标准的 ASP.NET Core 属性，用于将请求数据绑定到 HTTP Post 请求上的
    `Product` 属性。我们注入了 `IProductAppService` 接口来使用之前定义的方法。
- en: 'We''ve already used `CreateEditProductViewModel`, so we need to define it.
    Define it in the same folder as `CreateProductModal.cshtml`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了 `CreateEditProductViewModel`，因此需要定义它。在 `CreateProductModal.cshtml` 文件所在的同一文件夹中定义它：
- en: '[PRE35]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`SelectItems` tells us that the `CategoryId` property will be selected from
    the `Categories` list. We will reuse this class in the edit modal dialog. That''s
    why I named it `CreateEditProductViewModel`.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectItems` 告诉我们 `CategoryId` 属性将从 `Categories` 列表中选择。我们将在这个编辑模态对话框中重用这个类。这就是为什么我将其命名为
    `CreateEditProductViewModel`。'
- en: DTOs versus ViewModels
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: DTO 与 ViewModel 的比较
- en: It might seem unnecessary to define the view model (`CreateEditProductViewModel`)
    since it is very similar to the DTO (`CreateUpdateProductDto`). However, it has
    just a few more attributes. These attributes can be easily added to the DTO, and
    we can reuse the DTO on the view side. It is up to your design decision, and you
    can do it. However, I think it is better practice to separate each concern, considering
    these classes have different purposes and evolve in different directions over
    time. For example, the `[SelectItems("Categories")]` attribute refers to the Razor
    Page model, and it has no meaning in the application layer.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它与 DTO (`CreateUpdateProductDto`) 非常相似，因此定义视图模型 (`CreateEditProductViewModel`)
    可能看起来是不必要的。然而，它只是多了几个属性。这些属性可以轻松地添加到 DTO 中，并且我们可以在视图端重用 DTO。这取决于你的设计决策，你可以这样做。然而，考虑到这些类具有不同的目的，并且随着时间的推移会向不同的方向发展，我认为将每个关注点分开是更好的实践。例如，`[SelectItems("Categories")]`
    属性指的是 Razor 页面模型，在应用层没有意义。
- en: 'Now, we can implement the `OnGetAsync` method in the `CreateProductModalModel`
    class:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `CreateProductModalModel` 类中实现 `OnGetAsync` 方法：
- en: '[PRE36]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We are creating the `Product` class with default values, then filling the `Categories`
    list using the product application service. `Clock` is a service provided by ABP
    Framework to get the current time without dealing with time zones and Local/UTC
    times. We use it instead of `DateTime.Now`. This will be explained in [*Chapter
    8*](B17287_08_Epub_AM.xhtml#_idTextAnchor249), *Using the Features and Services
    of ABP*.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用默认值创建 `Product` 类，然后使用产品应用服务填充 `Categories` 列表。`Clock` 是 ABP 框架提供的一个服务，用于获取当前时间，无需处理时区以及本地/UTC
    时间。我们用它代替 `DateTime.Now`。这将在 [*第 8 章*](B17287_08_Epub_AM.xhtml#_idTextAnchor249)，*使用
    ABP 的功能和服务* 中解释。
- en: 'We can implement `OnPostAsync`, as shown in the following code block:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像下面这样实现 `OnPostAsync`：
- en: '[PRE37]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Since we are mapping `CreateEditProductViewModel` to `CreateProductDto`, we
    need to define the mapping configuration. Open the `ProductManagementWebAutoMapperProfile`
    class in the *ProductManagement.Web* project, and change the content using the
    following code block:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将 `CreateEditProductViewModel` 映射到 `CreateProductDto`，我们需要定义映射配置。在 *ProductManagement.Web*
    项目中打开 `ProductManagementWebAutoMapperProfile` 类，并使用以下代码块更改内容：
- en: '[PRE38]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This class defines the object mappings for the AutoMapper library.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 此类定义了 AutoMapper 库的对象映射。
- en: We've completed the C# side of the product creation UI.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了产品创建 UI 的 C# 代码部分。
- en: 'Now we can start to build the UI markup and JavaScript code. To do this, open
    the `CreateProductModal.cshtml` file, and change the content as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始构建 UI 标记和 JavaScript 代码。为此，打开 `CreateProductModal.cshtml` 文件，并按如下方式更改内容：
- en: '[PRE39]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, `abp-dynamic-form` automatically creates the form elements based on the
    C# model class. `abp-form-content` is where the form elements are rendered. `abp-modal`
    is used to create a modal dialog.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`abp-dynamic-form` 会根据 C# 模型类自动创建表单元素。`abp-form-content` 是表单元素渲染的地方。`abp-modal`
    用于创建模态对话框。
- en: You can use the standard Bootstrap HTML elements and ASP.NET Core's bindings
    to create form elements. However, ABP's Bootstrap and dynamic form tag helpers
    simplify the UI code a lot. We will cover ABP tag helpers in [*Chapter 12*](B17287_12_Epub_AM.xhtml#_idTextAnchor356),
    *Working with MVC/Razor Pages*.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用标准的 Bootstrap HTML 元素和 ASP.NET Core 的绑定来创建表单元素。然而，ABP 的 Bootstrap 和动态表单标签助手大大简化了
    UI 代码。我们将在 [*第 12 章*](B17287_12_Epub_AM.xhtml#_idTextAnchor356)，*使用 MVC/Razor
    Pages* 中介绍 ABP 标签助手。
- en: 'We''ve completed the product creation modal code. Now, we will add a `Index.cshtml`
    file in the *Pages/Products* folder, and change the `abp-card-header` section
    as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了产品创建模态代码。现在，我们将在 *Pages/Products* 文件夹中添加一个 `Index.cshtml` 文件，并按如下方式更改
    `abp-card-header` 部分：
- en: '[PRE40]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: I've added 2 columns where each column has a `size-md="_6"` attribute (that
    is half of the 12-column Bootstrap grid). Then, I placed a button on the right-hand
    side by keeping the card title on the left-hand side.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加了 2 列，每列都有一个 `size-md="_6"` 属性（即 12 列 Bootstrap 网格的一半）。然后，我在左侧保留卡片标题的同时，在右侧放置了一个按钮。
- en: 'Following this, I added the following code to the end of the `Index.cshtml.js`
    file (right before the final `});` code part):'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我在 `Index.cshtml.js` 文件的末尾添加了以下代码（在最后的 `});` 代码部分之前）：
- en: '[PRE41]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`abp.ModalManager` is used to manage modal dialogs on the client side. Internally,
    it uses Twitter Bootstrap''s standard modal component but abstracts many details
    by providing a simple API. `createModal.onResult()` is a callback that is called
    when the modal is saved. `createModal.open();` is used to open the modal dialog.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`abp.ModalManager` 用于在客户端管理模态对话框。内部，它使用 Twitter Bootstrap 的标准模态组件，但通过提供简单的
    API 抽象了许多细节。`createModal.onResult()` 是当模态框保存时被调用的回调。`createModal.open();` 用于打开模态对话框。'
- en: 'Finally, we need to define some localization texts in the `en.json` file in
    the *Localization/ProductManagement* folder of the *ProductManagement.Domain.Shared*
    project:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在 *ProductManagement.Domain.Shared* 项目的 *Localization/ProductManagement*
    文件夹中的 `en.json` 文件中定义一些本地化文本：
- en: '[PRE42]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can run the web application again and try to create a new product:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以再次运行 Web 应用程序并尝试创建一个新的产品：
- en: '![Figure 3.13 – The New Product modal'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.13 – 新产品模态框'
- en: '](img/Figure_3.13_B17287.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.13_B17287.jpg)'
- en: Figure 3.13 – The New Product modal
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 – 新产品模态框
- en: ABP has automatically created the form fields based on the C# class model. Localization
    and validation also work automatically by reading the attributes and using the
    conventions. Try to leave the name field empty and save the modal to see an example
    of the validation error mesage. We will cover the validation and localization
    topics in more detail in [*Chapter 12*](B17287_12_Epub_AM.xhtml#_idTextAnchor356),
    *Working with MVC/Razor Pages*.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 已经根据 C# 类模型自动创建了表单字段。本地化和验证也会通过读取属性和使用约定自动完成。尝试留空名称字段并保存模态框，以查看验证错误消息的示例。我们将在
    [*第 12 章*](B17287_12_Epub_AM.xhtml#_idTextAnchor356)，*使用 MVC/Razor Pages* 中更详细地介绍验证和本地化。
- en: We can now create products on the UI. Now, let's see how to edit products.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在 UI 上创建产品。现在，让我们看看如何编辑产品。
- en: Editing products
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑产品
- en: Editing a product is similar to adding a new product. This time, we need to
    get the product to edit and prepare the edit form.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑产品与添加新产品类似。这次，我们需要获取要编辑的产品并准备编辑表单。
- en: Application service contracts
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序服务合约
- en: 'Let''s start by defining two new methods for the `IProductAppService` interface:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为 `IProductAppService` 接口定义两个新方法开始：
- en: '[PRE43]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The first method will be used to obtain the product data by ID. We are reusing
    `CreateUpdateProductDto` (which was defined earlier) in the `UpdateAsync` method.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法将用于通过 ID 获取产品数据。我们在 `UpdateAsync` 方法中重用了之前定义的 `CreateUpdateProductDto`。
- en: We haven't introduced a new DTO, so we can go straight to the implementation.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有引入新的 DTO，因此我们可以直接进入实现。
- en: Application service implementation
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用服务实现
- en: 'Implementing these new methods is pretty simple. Add the following methods
    to the `ProductAppService` class:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这些新方法相当简单。将以下方法添加到 `ProductAppService` 类中：
- en: '[PRE44]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `GetAsync` method uses `productRepository.GetAsync` to get the product from
    the database and returns it by mapping it to a `ProductDto` object. The `UpdateAsync`
    method gets the product and maps the given input properties to the product's properties.
    In this way, we overwrite the product properties with new values.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetAsync` 方法使用 `productRepository.GetAsync` 从数据库中获取产品，并将其映射到 `ProductDto`
    对象后返回。`UpdateAsync` 方法获取产品并将给定的输入属性映射到产品的属性。这样，我们就用新值覆盖了产品属性。'
- en: For this example, we don't need to call `_productRepository.UpdateAsync` because
    EF Core has a change tracking system. ABP's **Unit of Work** system automatically
    saves the changes at the end of the request if it doesn't throw an exception.
    We will cover the Unit of Work system in [*Chapter 6*](B17287_06_Epub_AM.xhtml#_idTextAnchor177),
    *Working with the Data Access Infrastructure*.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们不需要调用 `_productRepository.UpdateAsync`，因为 EF Core 有一个更改跟踪系统。ABP 的 **工作单元**
    系统在请求结束时自动保存更改（如果没有抛出异常）。我们将在 [*第 6 章*](B17287_06_Epub_AM.xhtml#_idTextAnchor177)，*与数据访问基础设施一起工作*
    中介绍工作单元系统。
- en: The application layer is now complete. In the next section, we'll create a product
    editing UI.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层现在已完成。在下一节中，我们将创建产品编辑用户界面。
- en: UI
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户界面
- en: 'Create a new `EditProductModal.cshtml` Razor Page under the *Pages/Products*
    folder of the *ProductManagement.Web* project. Open `EditProductModal.cshtml.cs`,
    and change the content using the following code:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *ProductManagement.Web* 项目的 *Pages/Products* 文件夹下创建一个新的 `EditProductModal.cshtml`
    Razor 页面。打开 `EditProductModal.cshtml.cs`，并使用以下代码更改内容：
- en: '[PRE45]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `Id` property will be a hidden field in the form. It should also support
    an HTTP GET request since a GET request opens this modal, and we need the product's
    ID to prepare the edit form. The `Product` and `Categories` properties are similar
    to the create modal. We are also injecting the `IProductAppService` interface
    into the constructor.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`Id` 属性将在表单中作为一个隐藏字段。它也应该支持 HTTP GET 请求，因为 GET 请求打开这个模态，我们需要产品的 ID 来准备编辑表单。`Product`
    和 `Categories` 属性与创建模态类似。我们还在构造函数中注入了 `IProductAppService` 接口。'
- en: 'We can implement the `OnGetAsync` method, as shown in the following code block:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像以下代码块所示实现 `OnGetAsync` 方法：
- en: '[PRE46]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: First, we are getting the product (`ProductDto`) to edit. We are converting
    it into `CreateEditProductViewModel`, which is then used on the UI to create the
    edit form. Then, we are getting the categories to select on the form, as we did
    earlier for the creation form.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们正在获取要编辑的产品（`ProductDto`）。我们将其转换为 `CreateEditProductViewModel`，然后在 UI 中用于创建编辑表单。然后，我们获取表单上要选择的类别，就像我们之前为创建表单所做的那样。
- en: 'We''ve mapped `ProductDto` to `CreateEditProductViewModel`, so now we need
    to define the mapping configuration in the `ProductManagementWebAutoMapperProfile`
    class (in the *ProductManagement.Web* project) just like we''ve done previously:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将 `ProductDto` 映射到 `CreateEditProductViewModel`，因此现在我们需要在 `ProductManagementWebAutoMapperProfile`
    类（在 *ProductManagement.Web* 项目中）中定义映射配置，就像我们之前做的那样：
- en: '[PRE47]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `OnPostAsync` method is simple; we call the `UpdateAsync` method by converting
    `CreateEditProductViewModel` into `CreateUpdateProductDto`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnPostAsync` 方法很简单；我们通过将 `CreateEditProductViewModel` 转换为 `CreateUpdateProductDto`
    来调用 `UpdateAsync` 方法：'
- en: '[PRE48]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now we can switch to `EditProductModal.cshtml`, and change its content as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以切换到 `EditProductModal.cshtml`，并按照以下方式更改其内容：
- en: '[PRE49]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This page is very similar to `CreateProductModal.cshtml`. I just added the `Id`
    field to the form (as a hidden input) to store the `Id` property of the product
    being edited.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面与 `CreateProductModal.cshtml` 非常相似。我只是向表单中添加了一个 `Id` 字段（作为一个隐藏输入），用于存储正在编辑的产品
    `Id` 属性。
- en: 'Finally, we can add an `Index.cshtml.js` file, and add a new `ModalManager`
    object on top of the `dataTable` initialization code:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以添加一个 `Index.cshtml.js` 文件，并在 `dataTable` 初始化代码上方添加一个新的 `ModalManager`
    对象：
- en: '[PRE50]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, add a new column definition as the first item in the `columnDefs` array
    within the `dataTable` initialization code:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `dataTable` 初始化代码中的 `columnDefs` 数组的第一项添加一个新的列定义：
- en: '[PRE51]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This code adds a new `rowAction` is a special option provided by ABP Framework.
    It is used to add one or more actions for a row in the table.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码添加了一个新的 `rowAction`，这是 ABP 框架提供的一个特殊选项。它用于在表格的某一行添加一个或多个操作。
- en: 'Finally, add the following code after the `dataTable` initialization code:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `dataTable` 初始化代码之后添加以下代码：
- en: '[PRE52]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This code refreshes the data table after saving a product edit dialog, so we
    can see the latest data on the table. The final UI looks similar to *Figure 3.14*:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在保存产品编辑对话框后刷新数据表，这样我们可以在表格上看到最新的数据。最终的 UI 看起来类似于 *图 3.14*：
- en: '![Figure 3.14 – Editing an existing product'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.14 – 编辑现有产品'
- en: '](img/Figure_3.14_B17287.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.14_B17287.jpg)'
- en: Figure 3.14 – Editing an existing product
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14 – 编辑现有产品
- en: We can now see the products, create new products, and edit existing ones. The
    final section will add a new action to delete an existing product.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到产品，创建新产品，以及编辑现有产品。最后一节将添加一个新操作来删除现有产品。
- en: Deleting products
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除产品
- en: 'Deleting a product is pretty simple compared to the create or edit actions
    since, in this case, we don''t need to build a form. First, add a new method to
    the `IProductAppService` interface:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 与创建或编辑操作相比，删除产品操作相当简单，因为在这种情况下，我们不需要构建表单。首先，向 `IProductAppService` 接口添加一个新方法：
- en: '[PRE53]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, implement it in the `ProductAppService` class:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `ProductAppService` 类中实现它：
- en: '[PRE54]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can now add a new action to the product data table. Open `Index.cshtml.js`,
    and add the following definition just after the `rowAction.items` array):'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以向产品数据表添加一个新操作。打开 `Index.cshtml.js`，并在 `rowAction.items` 数组之后添加以下定义）：
- en: '[PRE55]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, `confirmMessage` is a function that is used to get a confirmation from
    the user before executing the action. The `productManagement.products.product.delete`
    function is dynamically created by ABP Framework, as explained earlier. In this
    way, you can directly call server-side methods in your JavaScript code. We are
    just passing the current record's ID. It returns a promise so that we can register
    a callback to the `then` function. Finally, we use `abp.notify.info` to send a
    notification to inform the user, then refresh the data table.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`confirmMessage` 是一个在执行操作之前从用户那里获取确认的函数。`productManagement.products.product.delete`
    函数是由 ABP 框架动态创建的，如前所述。这样，你可以在 JavaScript 代码中直接调用服务器端方法。我们只是传递当前记录的 ID。它返回一个承诺，这样我们就可以将回调注册到
    `then` 函数。最后，我们使用 `abp.notify.info` 向用户发送通知，然后刷新数据表。
- en: 'We''ve used some localization texts, so we need to add the following lines
    to the localization file (the `en.json` file in the *Localization/ProductManagement*
    folder of the *ProductManagement.Domain.Shared* project):'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一些本地化文本，因此需要将以下行添加到本地化文件中（位于 *ProductManagement.Domain.Shared* 项目的 *Localization/ProductManagement*
    文件夹中的 `en.json` 文件）：
- en: '[PRE56]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'You can run the web project again to see the result:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以再次运行 Web 项目以查看结果：
- en: '![Figure 3.15 – The Delete action'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.15 – 删除操作'
- en: '](img/Figure_3.15_B17287.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.15_B17287.jpg)'
- en: Figure 3.15 – The Delete action
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15 – 删除操作
- en: 'The **Edit** button automatically turns into an **Action** drop-down button
    since we now have two actions. When you click on the **Delete** action, you get
    a confirmation message to delete the product:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在有两个操作，**编辑**按钮自动变成了**操作**下拉按钮。当你点击**删除**操作时，你会看到一个确认消息来删除产品：
- en: '![Figure 3.16 – The delete confirmation message'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.16 – 删除确认消息'
- en: '](img/Figure_3.16_B17287.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.16_B17287.jpg)'
- en: Figure 3.16 – The delete confirmation message
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16 – 删除确认消息
- en: If you click on the **Yes** button, you will see a notification on the page,
    and the data table will be refreshed.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击**是**按钮，你将在页面上看到一个通知，数据表将被刷新。
- en: Implementing product deletion was pretty simple. ABP's built-in features helped
    us by implementing common patterns such as client-to-server communication, confirmation
    dialogs, and UI notifications.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 实现产品删除功能相当简单。ABP 内置的功能通过实现常见的模式，如客户端到服务器的通信、确认对话框和 UI 通知，帮助我们完成了这一功能。
- en: Notice that the `Product` entity has been inherited from the `FullAuditedAggregateRoot`
    class that made it Soft-Delete. Check the database after deleting a product. You
    will see that it was not really deleted, but the `IsDeleted` field is set to `true`.
    Setting `IsDeleted` to `true` makes the product entity soft-deleted (that is,
    deleted logically but not physically). The next time you query products, deleted
    products are automatically filtered and not included in the query result. That's
    done by the data filtering system of ABP Framework and will be covered in [*Chapter
    6*](B17287_06_Epub_AM.xhtml#_idTextAnchor177), *Working with the Data Access Infrastructure*.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Product`实体是从`FullAuditedAggregateRoot`类继承的，这使得它支持软删除。在删除一个产品后检查数据库。你会发现它并没有真正被删除，而是`IsDeleted`字段被设置为`true`。将`IsDeleted`设置为`true`使得产品实体软删除（即逻辑上删除但物理上未删除）。下次你查询产品时，已删除的产品将自动过滤，不包括在查询结果中。这是通过ABP框架的数据过滤系统完成的，将在[*第6章*](B17287_06_Epub_AM.xhtml#_idTextAnchor177)中介绍，*与数据访问基础设施一起工作*。
- en: Summary
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created a fully working CRUD page. We went through all layers
    of the application and have seen the fundamental approaches of ABP-based application
    development.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个完全工作的CRUD页面。我们走过了应用程序的所有层，并看到了基于ABP的应用程序开发的根本方法。
- en: You were introduced to many different concepts, such as entities, repositories,
    database mapping and migrations, automated tests, API controllers, dynamic JavaScript
    proxies, object to object mapping, Soft-Delete, and more. If you're building a
    serious software solution, you will use all of them, with ABP or not. ABP is a
    full-stack application framework that helps you implement these concepts with
    best practices. It provides the necessary infrastructure to make your daily development
    easier.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经接触到了许多不同的概念，例如实体、存储库、数据库映射和迁移、自动化测试、API控制器、动态JavaScript代理、对象到对象映射、软删除等。如果你正在构建一个严肃的软件解决方案，你将使用所有这些，无论是否使用ABP。ABP是一个全栈应用程序框架，它帮助你以最佳实践实现这些概念。它提供了必要的基础设施，使你的日常开发更加容易。
- en: You might not understand all of the details at this point. That's not a problem
    because the purpose of the remaining chapters is to deep dive into these concepts
    and show their details and different use cases.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能现在无法理解所有细节。这不是问题，因为剩余章节的目的是深入探讨这些概念，并展示它们的细节和不同的用例。
- en: This example application was relatively simple. It doesn't contain any important
    business logic because I've introduced many concepts and tried to keep the application
    simple to focus on these concepts rather than business complexities. I've ignored
    authorization in this example. Authorization will be explained in [*Chapter 7*](B17287_07_Epub_AM.xhtml#_idTextAnchor213),
    *Exploring Cross-Cutting Concerns*.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例应用程序相对简单。它不包含任何重要的业务逻辑，因为我在其中引入了许多概念，并试图保持应用程序简单，以便专注于这些概念而不是业务复杂性。在这个示例中，我忽略了授权。授权将在[*第7章*](B17287_07_Epub_AM.xhtml#_idTextAnchor213)中解释，*探索横切关注点*。
- en: Demonstrating an example application with real-world complexity is not easy
    in a book. However, I've prepared a complete reference application with real-world
    qualities and complexities for the readers of this book. The reference application
    is open source and available on GitHub. Additionally, it is a live application,
    so you can try it directly.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在书中展示具有真实世界复杂性的示例应用程序并不容易。然而，我为本书的读者准备了一个具有真实世界质量和复杂性的完整参考应用程序。这个参考应用程序是开源的，可在GitHub上找到。此外，它是一个实时应用程序，所以你可以直接尝试它。
- en: The next chapter will introduce that reference application and show the reference
    solution's functionalities, layers, and code structure. The remaining chapters
    frequently refer to the source code of that application.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍这个参考应用程序，并展示参考解决方案的功能、层和代码结构。剩余章节经常引用该应用程序的源代码。
