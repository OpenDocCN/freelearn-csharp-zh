<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
<head>
    <title>13. Reactive Programming Using RxJS</title>
    <link href="epub.css" rel="stylesheet" type="text/css"/>
    <link href="68851547a55f.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content">
      <div class="chapter" title="Chapter&#160;13.&#160;Reactive Programming Using RxJS">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch13"></a>Chapter&#160;13.&#160;Reactive Programming Using RxJS</h1>
            </div>
          </div>
        </div>
        <p>In the previous chapter, we saw how .NET <span class="strong"><strong>Reactive Extensions</strong></span> (<span class="strong"><strong>Rx</strong></span>) aided natural programming in terms of composability, scalability, and responsiveness. We saw how streams enable natural state management with respect to time. Some of the constructs were&#160;dealt with in detail as well. More importantly, we saw how reactive constructs could be integrated seamlessly into the MVVM pattern, in terms of achieving data synchronization between View and Model via the View Model layer. Now, in this chapter, we will take a deep dive into the <span class="strong"><strong>Reactive Extensions for JavaScript</strong></span> (<span class="strong"><strong>RxJS</strong></span>) library, and look at how to&#160;write asynchronous and event-driven programs using observable collections. We will also take a detailed look at some interesting use cases, and their implementations with RxJS, to clearly understand how the RxJS library is leveraged to create concurrent and responsive applications. This will cover the reactive spectrum of web and Windows programming and, by the end of this chapter, you will be in a position to appreciate the possibilities of JavaScript and confidently leverage RxJS by having a jump start at it. This chapter includes the following:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">A refresher on JavaScript execution context</li>
            <li class="listitem" style="list-style-type: disc">An analogy of RxJS with YieldJS (a custom JS framework created by the authors)</li>
            <li class="listitem" style="list-style-type: disc">A detailed outline on RxJS foundations and formalisms</li>
            <li class="listitem" style="list-style-type: disc">Detailed code samples that demonstrate RxJS in action</li>
          </ul>
        </div>
        <div class="section" title="The JS world">
          <div class="titlepage">
            <div>
              <div>
                <h1 class="title"><a id="ch13lvl1sec93"></a>The JS world</h1>
              </div>
            </div>
          </div>
          <p>It is important to recap one's understanding of some of the JavaScript world's state of affairs. The most important aspect is that the language is single-threaded and, given this, the only option left for developers to write asynchronous code is by using callbacks, promises, and events. As a developer, you should be comfortable with the functional programming aspects of JS (in addition to its innate dynamic nature), including closures, higher-order functions, anonymous functions, and extension methods (augmenting types). We also cannot discount the advancements that have been made&#160;in the language core itself, with Node.js now becoming a preferred backend for serious scalability involving async I/O. Let's have a quick peek into these core concepts before we dive into RxJS.</p>
          <p>As we all know (we presume you do), functions are objects in JavaScript, and they are first-class citizens, which makes JS a functional programming language as well (although it is formally classified as a dynamic language). We already discussed and saw in <a class="link" href="dn-dsnptn_ch10.html" title="Chapter&#160;10.&#160;Pattern Implementation Using Object/Functional Programming">Chapter 10</a>, <span class="emphasis"><em>Pattern Implementation Using Object/Functional Programming</em></span> (that too, in depth), how higher-order functions, along with closures, enable you to compose programs naturally, now that we have been thinning the OOP wall for some time (at least from Chapter 10 onwards). Well, we don't intend to imply that JS is an exception.</p>
          <div class="note" title="Note" style="">
            <div class="inner">
              <h3 class="title"><a id="note55"></a>Note</h3>
              <p>JS supports OOP through prototypal inheritance compared to classic inheritance in C#. This is important to understand how types can be augmented (analogous to our extension methods in C#).</p>
            </div>
          </div>
          <p>Let's look at a higher-order function, which leverages callback (yet another function, which typically gets called for notification and continuation purposes):</p>
          <pre class="programlisting">    function onComplete(message) { 
      console.log(message); 
    } 
 
    function doSomething(onComplete) { 
      //Do what is needed here and then trigger onComplete 
      onComplete("Complete!"); 
    } 
 
    doSomething(onComplete); 
</pre>
          <div class="note" title="Note" style="">
            <div class="inner">
              <h3 class="title"><a id="note56"></a>Note</h3>
              <p>In the preceding code snippet, the callback (<code class="literal">onComplete</code>) is passed as an attribute to a function (<code class="literal">doSomething</code>), thus making it (<code class="literal">doSomething</code>) a higher-order function.</p>
            </div>
          </div>
          <p>Now let's look at a Closure in action:</p>
          <pre class="programlisting">    function add(x) { 
      return function (y) { 
        return x + y; 
      }; 
    }; 
 
    var addTen = add(10); 
    console.log(addTen(5));     //Returns 15 
    console.log(add(2)(3));     //Returns 5 
</pre>
          <p>In the preceding code, <code class="literal">add</code> is a higher-order function (as it can be assigned to a variable), and <code class="literal">x</code> becomes a closure (lexical closure) within this function (irrespective of any nested/sub functions within). The results presented as comments against the respective statements speak for themselves. Also, see how anonymous functions (in this case, the inner function within the <code class="literal">add</code> function) are so natural in the JS realm. If you remember (from <a class="link" href="dn-dsnptn_ch09.html" title="Chapter&#160;9.&#160;Functional Programming Techniques for Better State Management">Chapter 9</a>, <span class="emphasis"><em>Functional Programming Techniques for Better State Management</em></span>), this also touches upon currying (an important concept in the functional programming world, which we've already dealt with in detail), a formalism that breaks any function with arity greater than one into a series of function evaluations (each accepting one argument at a time).</p>
          <p>Another important concept to understand is augmenting types in JS. This provides an amazing way to impart capabilities to a type (just like the way we use extension methods in C#). Let's quickly look at the power of this, using the following example in terms of dynamically adding error-handling capability to functions (ones that don't have it) at runtime. Ever thought of that?</p>
          <pre class="programlisting">    Function.prototype.throws = function () { 
      var slice = Array.prototype.slice, 
        args = slice.apply(arguments), 
          errorMessage = args[0], 
            fn = this; 
      return function () { 
        try { 
<span class="strong"><strong>          return fn.apply(null, args.slice(1));</strong></span> 
        } 
        catch (e) { 
          console.log(errorMessage); 
          //Do what is needed apart from logging 
        } 
      } (); 
    }; 
</pre>
          <p>This preceding&#160;code essentially augments a function object by adding the <code class="literal">throws</code> method to its prototype object (the base object). It deftly leverages some nifty features in the JS language (including array slicing, <code class="literal">arguments</code> object, function context capture using closure, and the <code class="literal">apply</code> method used for function evaluation). We suggest you look it up in case you are unable to follow the code. The candidate function, which deliberately throws an exception and one that should gracefully exit function evaluation is as follows:</p>
          <pre class="programlisting">    function errorSimulator(a, b) { 
      console.log(a, b); 
      return (parseInt(RxJS,10));//This statement forces an error! 
    } 
</pre>
          <p>The following code (line 1) can be used in place of direct function evaluation (line 2), where the program throws a runtime error (ReferenceError: RxJS is not&#160;defined) and breaks execution. What is important to note is the preservation of arity for these functions despite using the decorator. This is where you will understand the relevance of the arguments object and the <code class="literal">apply</code> method. Here, our decorator assumes the semantics - that of issuing the first argument with the error message followed by the function arguments in the exact same order! You can easily achieve this with a find and replace in your code file, can't you?</p>
          <pre class="programlisting">    errorSimulator.throws("I have you!", 2, 0);  // line 1
    errorSimulator(2, 0);                        // line 2</pre>
          <p>We guess that now you've got a handle on how things work in the JS world. It's important to know these as we move forward to explore reactive programming using RxJS.</p>
          <p>To try out the code samples in this chapter, please ensure you have <span class="strong"><strong>Node.js</strong></span> set up and RxJS dependencies installed through <code class="literal">npm</code>, as follows:</p>
          <pre class="programlisting"><span class="strong"><strong>    npm install rx</strong></span> 
    rx@4.1.0 node_modules\rx 
</pre>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Rx foundations">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch13lvl1sec94"></a>Rx foundations</h1>
            </div>
          </div>
        </div>
        <p>Although it may sound repetitive, it is so important to understand the foundations of Rx and the key design patterns that govern Rx. Being a book on patterns and idioms, it would be really gratifying to know if any interested reader would benefit from understanding the underpinnings of these keys concepts as they are realized in the host language (JS in this case) directly or via libraries.</p>
        <p>The two key design patterns based on which Rx works are the <span class="strong"><strong>observer</strong></span> and <span class="strong"><strong>iterator</strong></span> patterns. Let's have a quick look at how these patterns are implemented, and then speculate or peek at a possible implementation of RxJS. This way of learning would really help in forming a deeper understanding of the core concepts. And not to hide the fact that the authors themselves have attempted to create a JS library (code-named <code class="literal">YieldJS</code> on GitHub at <a class="ulink" href="http://shinexavier.github.io/YieldJS/">http://shinexavier.github.io/YieldJS/</a>), which gives the rudimentary capability of RxJS despite being a pull-based implementation. However,&#160;one thing to keep in mind is that this library was never intended to be created as an RxJS clone, but to bring in the <span class="strong"><strong>yield</strong></span> (from the C# world) capability to JS prior to ES 6.0.</p>
        <div class="note" title="Note" style="">
          <div class="inner">
            <h3 class="title"><a id="note57"></a>Note</h3>
            <p>The strategy was very straightforward, since the language ES 5.0 didn't have inherent support for <span class="strong"><strong>yield</strong></span> where you would want a generator object, which would continuously yield the next computed value and at the same time provide an option for forward iteration.</p>
          </div>
        </div>
        <p>The preceding statement is very powerful with respect to the fact that this library would impart the following capabilities to a generator function in JS:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">Augmenting the generator function object to have forward iteration capability</li>
            <li class="listitem" style="list-style-type: disc">Accepting a series (unlimited) of iterator methods, which act as continuation methods to the core yielded elements</li>
            <li class="listitem" style="list-style-type: disc">Yielding the next valid result based on the continuous and sequenced (the very order in which it is specified during iteration) iterator function evaluations</li>
            <li class="listitem" style="list-style-type: disc">Supporting lazy evaluation by yielding the computed value only when requested</li>
          </ul>
        </div>
        <p>What do you think the authors had in mind when they set on this task of creating this library? In case you are still wondering, it was a novel attempt to create LINQ capability for sequences created by any generator object (functions, in our case) in JS. A subset of the library implementation is depicted in the following code, as this helps reason about a possible implementation of RxJS:</p>
        <pre class="programlisting">    Function.prototype.getGenerator = function (setCount) { 
      "use strict"; 
      var fnGen = this, 
      numberOfElements = setCount, 
      slice = Array.prototype.slice, 
      gen = {}, 
      fnContexts = [], 
      yieldIndex = -1, 
      getFunctionContext = function (fnIndex, input) { 
        var fnContext = fnContexts[fnIndex]; 
        if (fnContext === undefined) { 
<span class="strong"><strong>          fnContext = { </strong></span>
<span class="strong"><strong>"index": 0, </strong></span>
<span class="strong"><strong>"current": input, </strong></span>
<span class="strong"><strong>"outList": []</strong></span>
<span class="strong"><strong>    
          };</strong></span> 
          fnContexts[fnIndex] = fnContext; 
        } else { 
          fnContext.current = input; 
          fnContext.index += 1; 
        } 
        return fnContext; 
      }, 
      isYieldEmpty = function () { 
        return ((yieldIndex + 1) === numberOfElements); 
      }, 
      moveNext = function () { 
        var args = arguments, 
        yieldedResult = null, 
        core = function () { 
          var i, 
          result = null, 
          fn = null, 
          fnCtxt = null; 
          yieldIndex += 1; 
          result = fnGen.apply(null, []); 
          if (args.length &gt; 0) { 
            for (i = 0; i &lt; args.length; i += 1) { 
              fn = args[i]; 
              fnCtxt = getFunctionContext(i, result); 
<span class="strong"><strong>              result = fn.call(null, fnCtxt);</strong></span> 
              if (result === null) { 
                break; 
              } else { 
                fnCtxt.outList.push(result); 
              } 
            } 
            if (result !== null) { 
              gen.current = result; 
            } 
          } else { 
            gen.current = result; 
          } 
          return result; 
        }; 
        while ((yieldedResult === null) &amp;&amp; (!isYieldEmpty())) { 
          //Recursive call to find the next non-null value 
<span class="strong"><strong>          yieldedResult = core();</strong></span> 
        } 
        return (yieldedResult !== null) ? true : false; 
      }; 
<span class="strong"><strong>      gen.current = null;</strong></span>
<span class="strong"><strong>  gen.moveNext = moveNext;</strong></span> 
      return gen; 
    }; 
</pre>
        <p>As highlighted in the preceding code, the key to this implementation is the state object <code class="literal">fnContext</code>, which holds information regarding every function (provided during iteration) and its evaluation details. This is critical for the continuation needed during iteration.</p>
        <p>As you can see, the generator would be a method, <code class="literal">getGenerator(numberOfElements)</code>, which augments any generator function (by accepting the number of elements to be generated) and has the following interfaces:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Properties</strong></span>:

<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">current</code>: Yields the current element during the course of a generation.</li>
</ul>
</div></li>
            <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Methods</strong></span>:

<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">moveNext</code>: Attempts to generate the next element based on the generator function, increments the iteration pointer, and returns <code class="literal">true</code> if successful. If unsuccessful (primarily because the iteration pointer points to the last element returned by the generator function based on the number of elements specified), it returns <code class="literal">false</code>.</li>
</ul>
</div></li>
          </ul>
        </div>
        <p>From a usage standpoint, take a look at the following generic sequence generator:</p>
        <pre class="programlisting">    function sequence(z) { 
      "use strict"; 
<span class="strong"><strong>      var y = 0;</strong></span> 
      return function () { 
        y += z; 
        return y; 
      }; 
    } 
</pre>
        <p>As you can see, this accepts a seed incremental value during sequence initialization, and returns the actual function (anonymous), which can be invoked multiple times to generate the seed sequences. Another critical thing would be the accumulator (<code class="literal">y</code> in our case), which holds the previous item in our sequence because of its closure property. Now, let's see our generator in action:</p>
        <pre class="programlisting">    var a = sequence(1).getGenerator(10);
    //For generating the first 10     
    elements (1 through 10) 
    while (a.moveNext() { 
      console.log(a.current); 
    } 
</pre>
        <p>Now, if you really look carefully, the preceding code snippet has the basic framework for creating a reactive library in terms of manipulating sequences (upon generation) to suit your needs. This is done using the iterator methods, which sort of become your LINQ operators. What really enables this are the context objects, which get created for each of the iterator functions. You will understand this when we look at some of the iterator methods shown next (ideally, the end users are just expected to write the sequence generator, and this library of iterator methods can be used for manipulating sequences in real time). Plus, the moment you understand how the context object provided during function evaluation can be used to write more iterator methods, it becomes all the more exciting and the possibilities seem endless. The context object provides the following attributes for creating various useful iterator functions:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc"><code class="literal">index</code>: Gives the index of the current element in the iteration context</li>
            <li class="listitem" style="list-style-type: disc"><code class="literal">current</code>: Gives the current element in the iteration context</li>
            <li class="listitem" style="list-style-type: disc"><code class="literal">outList</code>: Gives the cumulative output collection/array till that point of iteration</li>
          </ul>
        </div>
        <p>The usage is as follows:</p>
        <pre class="programlisting">    function square(context) { 
      "use strict"; 
      return (context.current * context.current); 
    } 
</pre>
        <p>This is a very standard use of transform operators, where the <code class="literal">current</code> element in the sequence is retrieved and manipulated (squared in this case):</p>
        <pre class="programlisting">    function unique(context) { 
      "use strict"; 
      return (context.outList.indexOf(context.current) &lt; 0) ?       
      context.current : null; 
    } 
</pre>
        <p>In the preceding code, you clearly see how the <code class="literal">outList</code> property is leveraged for generating unique sequences! Typically, this property becomes very handy for implementing aggregation operators:</p>
        <pre class="programlisting">    function filter(condition) { 
      "use strict"; 
      return function (context) { 
        return condition(context.current) ? context.current : null; 
      }; 
    } 
 
    function even(val) { 
      "use strict"; 
      return (val % 2 === 0); 
    } 
</pre>
        <p>Here is an interesting scenario, where a predicate function (<code class="literal">even</code>) is used in conjunction with an iterator function (<code class="literal">filter</code>) to filter those elements in the sequence that satisfy a certain condition:</p>
        <pre class="programlisting">    function skip(count) { 
      "use strict"; 
      return function (context) { 
        return ((context.index % (count + 1)) === 0) ? context.current      
        : null; 
      }; 
    } 
</pre>
        <p>And finally, here you see how the <code class="literal">index</code> property is leveraged for skipping certain elements in the sequence!</p>
        <p>Now, to see the entire thing in action, look at the following example usage:</p>
        <pre class="programlisting">    var a = sequence(1).getGenerator(10); 
<span class="strong"><strong>    while(a.moveNext(skip(1), square)) {</strong></span> 
      console.log(a.current);    //Yields 1, 9, 25, 49, 81 
    } 
</pre>
        <p>Do you get the connection now? Do you see how the two iterator methods (a filter and a transformation operator in this case) are composed elegantly in a declarative manner? One that would chain these operators during an iteration as an element in the sequence is generated. This is reactive (except that, with the iteration, you pull as opposed to the conventional push)! Don't you get it? All we need is a callback to be passed to our generator object, which would get notified any time a new element in the sequence is generated! We will leave that entirely to any interested reader (depending on whether you like to be an API producer or a consumer) to toy around with this implementation (you are free to fork it on GitHub), or directly jump to RxJS and start benefiting from it. Either way, by now, we feel you are ready and have the foundation to lock horns with RxJS!
</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="RxJS formalism">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch13lvl1sec95"></a>RxJS formalism</h1>
            </div>
          </div>
        </div>
        <p>Now, unlike YieldJS, RxJS is push-based. Here,&#160;the subscribers would automatically receive new values from the publisher. A subscriber or listener is denoted by the <code class="literal">observer</code> object, and the publisher (that pushes/publishes new values) is denoted by the <code class="literal">Observable</code> object. Just like the way we specified iterator methods (our future operators) to compose our generated sequences, we can efficiently do the same (transform, filter, and so on) for all the elements in the observable sequence.</p>
        <div class="section" title="Observables and observers">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch13lvl2sec56"></a>Observables and observers</h2>
              </div>
            </div>
          </div>
          <p>The generator becomes our observable, and the callback function, which would be interested in these sequences, becomes the observer. Having said this, creating <code class="literal">Observables</code> is pretty straightforward, as we saw in the earlier chapter with reactive extensions for .NET. The following code bares it all:</p>
          <pre class="programlisting">    var client = Rx.Observable.create(function (observer) { 
      observer.onNext('On Your Mark'); 
      observer.onNext('Get Set'); 
      observer.onNext('GO'); 
      observer.onCompleted(); 
    }); 
 
    client.subscribe( 
<span class="strong"><strong>      function onNext(x) { console.log('Next: ' + x); },
</strong></span>
<span class="strong"><strong>      function onError(err) { console.log('Error: ' + err); },
</strong></span>
<span class="strong"><strong>      function onCompleted() { console.log('Completed'); }</strong></span> 
    ); 
</pre>
          <p>The client in the preceding code is the <code class="literal">observer</code>, which has the three important callbacks (highlighted), namely, <code class="literal">OnNext</code>, <code class="literal">OnError</code>, and <code class="literal">OnCompleted</code>.</p>
          <p>As expected, this faithfully prints the following on the console:</p>
          <pre class="programlisting"><span class="strong"><strong>Next: On Your Mark</strong></span>
<span class="strong"><strong>Next: Get Set</strong></span>
<span class="strong"><strong>Next: GO</strong></span>
<span class="strong"><strong>Completed</strong></span>
</pre>
          <p>Now let's look at some key bridges offered by RxJS when it comes to working with core language constructs.</p>
        </div>
        <div class="section" title="Observables from arrays">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch13lvl2sec57"></a>Observables from arrays</h2>
              </div>
            </div>
          </div>
          <p>Let's see how observables can be created from arrays using RxJS:</p>
          <pre class="programlisting">    Rx.Observable 
<span class="strong"><strong>    .from(['On Your Mark', 'Get Set', 'GO'])</strong></span> 
    .subscribe( 
      function (x) { console.log('Next: ' + x); }, 
      function (err) { console.log('Error:', err); }, 
      function () { console.log('Completed'); } 
    ); 
</pre>
          <p>As highlighted in the preceding code, you can see that the <code class="literal">from</code> operator does the trick here, and you get the same results as earlier!</p>
        </div>
        <div class="section" title="Observables from events">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch13lvl2sec58"></a>Observables from events</h2>
              </div>
            </div>
          </div>
          <p>Similarly, we can create observables from events using the <code class="literal">fromEvent</code> operator. The following is an observable, which displays the mouse pointer coordinates whenever the mouse crosses diagonally across the window. Since we need the DOM elements (document and window) here, we will use the <span class="strong"><strong>JSbin</strong></span> playground for running this code:</p>
          <pre class="programlisting">    var allMoves = Rx.Observable.fromEvent(document, 'mousemove') 
    allMoves.subscribe(function (e) { 
<span class="strong"><strong>      console.log(e.clientX, e.clientY);</strong></span>  
    }); 
 
    var movesCrossingDiagonal = allMoves.filter(function (e) { 
      return e.clientX === e.clientY; 
    }); 
    movesCrossingDiagonal.subscribe(function (e) { 
<span class="strong"><strong>      console.log('Crossed the diagonal:', e.clientX, e.clientY);</strong></span> 
    }); 
</pre>
          <p>If you observe the preceding code, you'll see that <code class="literal">allMoves</code> is the primary observable sequence, and then we derive the next <code class="literal">movesCrossingDiagonal</code> sequence from <code class="literal">allMoves</code>. All these sequences are immutable, and we just subscribe (the two subscribers are highlighted in code) to those that are of interest. We also see the use of the <code class="literal">filter</code> operator. See the following equivalent code executed in the JSbin editor:</p>
          <p>
</p>
          <div class="mediaobject">
            <img src="graphics/B05691_13_01.jpg" alt="Observables from events"/>
          </div>
          <p>
</p>
          <p>In the HTML code given in the preceding screenshot, you can see the Rx library included (you could simply do this in JSbin by using the <span class="strong"><strong>Add library</strong></span> option shown in the web editor):</p>
          <p>
</p>
          <div class="mediaobject">
            <img src="graphics/B05691_13_02.jpg" alt="Observables from events"/>
          </div>
          <p>
</p>
          <p>You will get these results, as seen in the preceding screenshot, the moment you move your mouse in the output window (not shown in this screenshot on account of brevity).</p>
        </div>
        <div class="section" title="Observables from callbacks">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch13lvl2sec59"></a>Observables from callbacks</h2>
              </div>
            </div>
          </div>
          <p>Creating observables from callbacks is indispensable when it comes to asynchronous and event-driven programming, and it truly completes the final dimension of possibilities that observables have to offer:</p>
          <pre class="programlisting">    // Load Node.js Filesystem module 
    var fs = require('fs'); 
    // Create an Observable from the watch method 
<span class="strong"><strong>    var source = Rx.Observable.fromCallback(fs.watch)('./tmp', {  
    encoding: 'buffer' });</strong></span> 
    // Create an Observer 
    var fsClient = Rx.Observer.create( 
      function (changes) { 
        console.log('Next: ', changes); 
      }, 
      function (err) { 
        console.log('Error: ', err); 
      }, 
      function () { 
        console.log('Completed'); 
      } 
    ); 
    var subscription = source.subscribe(fsClient); 
</pre>
          <p>Now, let's presume you have a file named&#160;<code class="literal">alas.tmp</code> within the <code class="literal">tmp</code> folder, and you modify its contents and save it. The observer would immediately get notified of this change, as shown here:</p>
          <pre class="programlisting"><span class="strong"><strong>Next:  [ 'change', 'alas.tmp' ]</strong></span>
<span class="strong"><strong>Completed</strong></span>
</pre>
          <p>Now, this preceding code, as you can see, helps you with subscribing to a file system watcher (directory watcher in this case). There's a shortcoming though! Can you spot that before we address this in the coming sections?</p>
        </div>
        <div class="section" title="Observable pipeline">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch13lvl2sec60"></a>Observable pipeline</h2>
              </div>
            </div>
          </div>
          <p>Remember the operator chaining we did with YieldJS a while ago? Well that's precisely what an <code class="literal">Observable</code> pipeline is. And if you remember how we trickled the state across the chaining operations (as opposed to maintaining it outside), you are in good hands. RxJS offers the same, as the <code class="literal">Observable</code> pipeline is self-contained and the state flows from one chained operator to another:</p>
          <pre class="programlisting">    Rx.Observable 
    .from([1, 2, 3, 4, 5, 6, 7, 8]) 
    .skip(4) 
    .map(function (val) { return val * val; }) 
    .subscribe(function (value) { 
      console.log('Next : ', value); 
    }); 
</pre>
          <p>This preceding code yields the following:</p>
          <pre class="programlisting"><span class="strong"><strong>Next : 25</strong></span>
<span class="strong"><strong>Next : 36</strong></span>
<span class="strong"><strong>Next : 49</strong></span>
<span class="strong"><strong>Next : 64</strong></span>
</pre>
          <p>Another thing to note is that this pipeline is highly efficient in terms of evaluations (or, we say, the various steps in an algorithm). In place of conventionally having three iterations/passes (per operator), we can do this operator chaining in just one iteration for all the three operators. We saw how this is clearly achieved in YieldJS. Additionally, you get the benefit of lazy evaluations as well! Be sure to check out other operators that may become handy for your day-to-day development.</p>
        </div>
        <div class="section" title="Subject et al.">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch13lvl2sec61"></a>Subject et al.</h2>
              </div>
            </div>
          </div>
          <p>As we saw in the previous chapter, we have subjects (those that implement both <code class="literal">Observer</code> and <code class="literal">Observable</code> types) within RxJS as well. This makes it a powerful mediator (a proxy object to be precise) between a source and downstream subscribers/observers:</p>
          <pre class="programlisting"><span class="strong"><strong>    var subject = new Rx.Subject();</strong></span> 
    var source = Rx.Observable 
    .interval(1000) 
    .take(3); 
    source.subscribe(subject); 
    //Observer #1 
    var client1 = subject.subscribe( 
      function (changes) { 
        console.log('Client1 Next: ', changes); 
      }, 
      function (err) { 
        console.log('Client1 Error: ', err); 
      }, 
      function () { 
        console.log('Client1 Completed!'); 
      } 
    ); 
    //Observer #2 
    var client2 = subject.subscribe( 
      function (changes) { 
        console.log('Client2 Next: ', changes); 
      }, 
      function (err) { 
        console.log('Client2 Error: ', err); 
      }, 
      function () { 
        console.log('Client2 Completed!'); 
      } 
    ); 
    subject.onNext(5); 
    subject.onNext(15); 
    subject.onNext(20); 
    setTimeout(function () { 
      subject.onCompleted(); 
      client1.dispose(); 
      client2.dispose(); 
    }, 5000); 
</pre>
          <p>The following output is seen upon execution of the preceding code:</p>
          <pre class="programlisting"><span class="strong"><strong>Client1 Next: 15</strong></span>
<span class="strong"><strong>Client2 Next: 15</strong></span>
<span class="strong"><strong>Client1 Next: 20</strong></span>
<span class="strong"><strong>Client2 Next: 20</strong></span>
<span class="strong"><strong>Client1 Next: 0</strong></span>
<span class="strong"><strong>Client2 Next: 0</strong></span>
<span class="strong"><strong>Client1 Next: 1</strong></span>
<span class="strong"><strong>Client2 Next: 1</strong></span>
<span class="strong"><strong>Client1 Next: 2</strong></span>
<span class="strong"><strong>Client2 Next: 2</strong></span>
<span class="strong"><strong>Client1 Completed!</strong></span>
<span class="strong"><strong>Client2 Completed!</strong></span>
</pre>
          <p>These are some of the specialized subjects which one could leverage based on their intent of usage:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist">
              <li class="listitem" style="list-style-type: disc"><code class="literal">AsyncSubject</code>: Represents the result of an asynchronous action. It can be used like a <code class="literal">promise</code> object in JS. It caches and returns only the last value, thus making it ideal for use in asynchronous operations, including AJAX calls, file I/O, and so on.</li>
              <li class="listitem" style="list-style-type: disc"><code class="literal">BehaviorSubject</code>: This mandates a starting value, making it ideal for initializing with placeholder values during any asynchronous operation, including AJAX calls, file I/O, and so on.</li>
              <li class="listitem" style="list-style-type: disc"><code class="literal">ReplaySubject</code>: Caches values (based on the buffer size specified) and re-emits those to subscribers irrespective of the time they subscribe to it.</li>
            </ul>
          </div>
        </div>
        <div class="section" title="Schedulers">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch13lvl2sec62"></a>Schedulers</h2>
              </div>
            </div>
          </div>
          <p>As we saw earlier, schedulers are powerful tools to manage and handle concurrency. You have a lot more control in terms of the concurrency models you choose for notifications and subscriptions. You have the following three basic schedulers at your disposal:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist">
              <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Immediate</strong></span>: This is de-facto for most of the operators, and is synchronous in nature</li>
              <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Default</strong></span>: This is asynchronous in nature, and leverages the event loop (using <code class="literal">nextTick</code> in the case of Node.js), <code class="literal">setTimeout</code>, and so on, behind the scenes</li>
              <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Current t</strong></span><span class="strong"><strong>hread</strong></span>: This, again, is synchronous in nature, except that in the case of recursive operators (such as&#160;<code class="literal">repeat</code>), it enqueues executions</li>
            </ul>
          </div>
          <p>And we have two handy operators to help us here:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist">
              <li class="listitem" style="list-style-type: disc">
                <code class="literal">observeOn</code>
              </li>
              <li class="listitem" style="list-style-type: disc">
                <code class="literal">subscribeOn</code>
              </li>
            </ul>
          </div>
          <p>Both these return observable instances, but give fine-grained control on concurrency by taking in the scheduler as an attribute.</p>
          <p>Please do check out the RxJS references for a deeper understanding of these (as coverage of these needs a chapter on its own, and that is not the true intent of this book). Now that we have looked at some of the core formalisms in RxJS, let's try to explore the world of RxJS with more examples.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="RxJS samples">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch13lvl1sec96"></a>RxJS samples</h1>
            </div>
          </div>
        </div>
        <p>How can we even proceed without seeing our spell checker in action on a web page? For this, we need an ASP.NET Web API that provides the suggestions. We will reuse our earlier&#160;<code class="literal">NorvigSpellCheckerModel</code> class as-is for this:</p>
        <pre class="programlisting">    using System; 
    using System.Collections.Generic; 
    using System.Linq; 
    using System.Net; 
    using System.Net.Http; 
    using System.Web.Http; 
<span class="strong"><strong>    using SpellChecker;</strong></span> 
 
    namespace MvcApplication1.Controllers 
    { 
<span class="strong"><strong>      public class SearchContext</strong></span> 
      { 
        public string Lookup { get; set; } 
        public int Count { get; set; } 
      } 
      public class ValuesController : ApiController 
      { 
        ISpellCheckerModel _spellChecker =      
        NorvigSpellCheckerModel.Instance; 
        // GET api/values 
        public IEnumerable&lt;string&gt; Get([FromUri] SearchContext      
        context) 
        { 
<span class="strong"><strong>          return _spellChecker.SpellCheck(context.Lookup,        
          context.Count);</strong></span> 
        } 
      } 
    } 
</pre>
        <p>In this preceding code, a <code class="literal">SearchContext</code> class has been created to pass in values for the get API! Also, a small change has been made to the <code class="literal">Global.asax.cs</code> file to accommodate JSONP responses (highlighted in the following code):</p>
        <pre class="programlisting">    protected void Application_Start() 
    { 
      AreaRegistration.RegisterAllAreas(); 
      WebApiConfig.Register(GlobalConfiguration.Configuration); 
      FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters); 
      RouteConfig.RegisterRoutes(RouteTable.Routes); 
      BundleConfig.RegisterBundles(BundleTable.Bundles); 
<span class="strong"><strong>      GlobalConfiguration.Configuration.Formatters.Insert(0, new    
      JsonpMediaTypeFormatter());</strong></span> 
    } 
</pre>
        <p>The following utility class, which helps you with formatting needs, is needed:</p>
        <pre class="programlisting">    public class JsonpMediaTypeFormatter : JsonMediaTypeFormatter 
    { 
      private string callbackQueryParameter; 
 
      public JsonpMediaTypeFormatter() 
      { 
        SupportedMediaTypes.Add(DefaultMediaType); 
        SupportedMediaTypes.Add(new      
        MediaTypeHeaderValue("text/javascript"));    
        MediaTypeMappings.Add(new UriPathExtensionMapping("jsonp",       
        DefaultMediaType)); 
      } 
 
      public string CallbackQueryParameter 
      { 
        get { return callbackQueryParameter ?? "callback"; } 
        set { callbackQueryParameter = value; } 
      } 
 
      public override Task WriteToStreamAsync(Type type, object value,    
      Stream stream, HttpContent content, TransportContext     
      transportContext) 
      { 
        string callback; 
 
        if (IsJsonpRequest(out callback)) 
        { 
          return Task.Factory.StartNew(() =&gt; 
          { 
            var writer = new StreamWriter(stream); 
            writer.Write(callback + "("); 
            writer.Flush(); 
 
            base.WriteToStreamAsync(type, value, stream, content,          
            transportContext).Wait(); 
 
            writer.Write(")"); 
            writer.Flush(); 
          }); 
        } 
        else{ 
          return base.WriteToStreamAsync(type, value, stream, content,        
          transportContext); 
        } 
      } 
 
      private bool IsJsonpRequest(out string callback) 
      { 
        callback = null; 
 
        if (HttpContext.Current.Request.HttpMethod != "GET") 
        return false; 
 
        callback = HttpContext.Current.Request.QueryString       
        [CallbackQueryParameter]; 
 
        return !string.IsNullOrEmpty(callback); 
      } 
    } 
</pre>
        <p>Now let's see how we can make a responsive frontend using RxJS:</p>
        <pre class="programlisting">    &lt;h3&gt;RxJS Samples:&lt;/h3&gt; 
    &lt;ol class="round"&gt; 
      &lt;li class="one"&gt; 
    &lt;h5&gt;Spell Checker&lt;/h5&gt; 
    &lt;script type="text/javascript" src="~/Scripts/rx.lite.js"&gt;   
    &lt;/script&gt;
    &lt;script type="text/javascript" src="~/Scripts/rx.dom.js"&gt;
    &lt;/script&gt;</pre>
        <p>As indicated here, you would need the following two JS files:</p>
        <pre class="programlisting">    &lt;script type="text/javascript"&gt; 
      var textInput; 
      var throttledInput; 
      var suggestions; 
      var resultList; 
</pre>
        <p>The following&#160;function (<code class="literal">initialize</code>) is called as soon as the DOM is loaded:</p>
        <pre class="programlisting">    function initialize() {
      textInput = document.querySelector('#textInput');
      console.log(textInput);
      throttledInput = Rx.DOM.keyup(textInput)
        .do(function (msg) {
          console.log(msg.key);
        })
        .pluck('target', 'value')
        .filter(function (text) {
          return text.length &gt; 3;
        })
        .debounce(500)
        .distinctUntilChanged();
      suggestions = throttledInput.flatMapLatest(SpellChecker); 
</pre>
        <p>&#160;In the preceding code, we do some throttling, and do not overload the server with requests, by doing the following:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">Transforming keyup DOM events into observable sequences</li>
            <li class="listitem" style="list-style-type: disc">Focusing on the value entered (the <code class="literal">pluck</code> operator here serves this purpose)</li>
            <li class="listitem" style="list-style-type: disc">Looking up search items which have more than three characters (using the <code class="literal">filter</code> operator)</li>
            <li class="listitem" style="list-style-type: disc">Slowing down user input with a timeout of 500 milliseconds (using the <code class="literal">debounce</code> operator)</li>
            <li class="listitem" style="list-style-type: disc">Restricting lookup for distinct values in the input stream (using the <code class="literal">distinctUntilChanged</code> operator):</li>
          </ul>
        </div>
        <pre class="programlisting">    resultList = document.getElementById('results'); 
<span class="strong"><strong>    suggestions.subscribe(</strong></span> 
      function (data) { 
        var results = data.response; 
        clearSelector(resultList); 
        for (var i = 0; i &lt; results.length; i++) { 
          resultList.appendChild(createLineItem(results[i])); 
        } 
      }, 
      function (e) { 
        clearSelector(resultList); 
        resultList.appendChild(createLineItem('Error: ' + e)); 
      } 
    ); 
  } 
</pre>
        <p>This function issues the search against the web API, and gets back an observable:</p>
        <pre class="programlisting">    function SpellChecker(term) { 
      var url = 'http://localhost:18679/api/values/?Lookup=' 
      + encodeURIComponent(term) +    
      '&amp;Count=5&amp;format=json&amp;callback=JSONPCallback';
<span class="strong"><strong>      return Rx.DOM.jsonpRequest(url);</strong></span> 
    } 
</pre>
        <p>The <code class="literal">clearSelector</code> and <code class="literal">createLineItem</code> functions are helper functions for DOM manipulations, which facilitate display:</p>
        <pre class="programlisting">    function clearSelector(element) { 
      while (element.firstChild) { 
        element.removeChild(element.firstChild); 
      } 
    } 
 
    function createLineItem(text) { 
      var li = document.createElement('li'); 
      li.innerHTML = text; 
      return li; 
    } 
 
<span class="strong"><strong>    Rx.DOM.ready().subscribe(initialize);</strong></span> 
    &lt;/script&gt; 
      &lt;input id="textInput" type="text"/&gt; 
      &lt;ul id="results"&gt;&lt;/ul&gt; 
      &lt;/li&gt; 
    &lt;/ol&gt; 
</pre>
        <p>A sample output is shown in the following screenshot:</p>
        <p>
</p>
        <div class="mediaobject">
          <img src="graphics/B05691_13_03.jpg" alt="RxJS samples"/>
        </div>
        <p>
</p>
        <p>So, by now we have seen how to subscribe to observable sequences (both keyboard events and AJAX calls/responses).</p>
        <p>The next sample we will deal with is a logical extension of what we discussed earlier. Remember we asked if you could spot a shortcoming in the file watcher sample that we discussed under observable from callbacks?</p>
        <div class="section" title="Real-time file watcher">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch13lvl2sec63"></a>Real-time file watcher</h2>
              </div>
            </div>
          </div>
          <p>The earlier version would terminate the observable sequence upon detecting the first change, thus impairing its ability to continuously detect changes. The solution to this fix is shown as follows:</p>
          <pre class="programlisting">    var Rx = require('rx'); 
    // Load Node.js Filesystem module 
    var fs = require('fs'); 
 
<span class="strong"><strong>    var disposable = Rx.Scheduler.default.scheduleRecursive(</strong></span> 
      0, 
      function (i, recurse) { 
        // Create an Observable from the watch method 
        var source = Rx.Observable
        .fromCallback(fs.watch)('./tmp', { encoding: 'buffer' }); 
        var subscription = source.subscribe( 
        function (changes) { 
          console.log('Next: ', i, changes); 
        }, 
        function (err) { 
          console.log('Error: ', err); 
        }, 
        function () { 
          console.log('Completed'); 
          ++i; 
<span class="strong"><strong>          recurse(i);</strong></span> 
        }); 
      } 
    ); 
</pre>
          <div class="note" title="Note" style="">
            <div class="inner">
              <h3 class="title"><a id="note58"></a>Note</h3>
              <p>As you can see in the highlighted code, the fix to the earlier problem is recursive scheduling (using the <code class="literal">sceduleRecursive</code> operator) upon sequence completion (indicated using <code class="literal">onCompleted</code>) during an event detection by the file system watcher component.</p>
            </div>
          </div>
          <p>The following result indicates that our fix works:</p>
          <pre class="programlisting"><span class="strong"><strong>Next: 0 [ 'change', 'alas.tmp' ]</strong></span>
<span class="strong"><strong>Completed</strong></span>
<span class="strong"><strong>Next: 1 [ 'change', 'alas2.tmp' ]</strong></span>
<span class="strong"><strong>Completed</strong></span>
<span class="strong"><strong>Next: 2 [ 'change', 'anotherfile.tmp' ]</strong></span>
<span class="strong"><strong>Completed</strong></span>
</pre>
        </div>
        <div class="section" title="Change galore">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch13lvl2sec64"></a>Change galore</h2>
              </div>
            </div>
          </div>
          <p>This sample has a wider implication in various domains, especially logistics. The solution involves finding all the change sets for an amount with a given set of currency denominations:</p>
          <pre class="programlisting">    // -------------------------Load RxJS module
    var Rx = require('rx');
    var calculateChange = function (denominations, amount) {
      'use strict';
      var changeSets = 0;
      <span class="strong"><strong>var subject = new Rx.Subject();</strong></span>
      var changeSetClient = subject
          .do
          (
              function (denominationSet) {
                  console.log(
                      'Processing Denominations: ', 
                      denominationSet);
              }
           )
           <span class="strong"><strong>.observeOn(Rx.Scheduler.default)
           .subscribe</strong></span>
           (
               function (denominationSet) {
                   printChangeSet(denominationSet);
               },
               function (err) {
                   console.log('Processing Error: ', err);
               },
               function () {
                   console.log('Processing Completed!');
                   changeSetClient.dispose();&#160; //Disposal
                   subject.dispose();&#160; &#160;&#160;&#160;    &#160;//Disposal
              &#160;}
           );</pre>
          <p>As you can see in the preceding code, here we have a global function (in order to clearly set a boundary on the global scope), which accepts the denominations (in an array) and the amount as two independent attributes. Now, what is important here is the strategy we employed to make the computation (or steps in the algorithm) asynchronous. For this, we used the default scheduler (<code class="literal">Rx.Scheduler.default</code>), which never blocks the event loop. In case you noticed, the resource cleanups are done in the <code class="literal">onCompleted</code> event:</p>
          <pre class="programlisting">    //This function prints the applicable denomination sets
    var <span class="strong"><strong>printChangeSet</strong></span> = function (denominationSet) { 
      var matchFactors = [], 
        <span class="strong"><strong>findCombinationSet</strong></span> = function (denominationIndex,
          cumilativeSum) { 
          var transientSum = 0, 
              i = 1, 
              denomination = denominationSet[denominationIndex], 
                factorCount = denominationSet.length; 
          while (transientSum &lt;= amount) { 
              //Pretty Printing 
              matchFactors[denominationIndex] = i.toString()
              + " x " + denomination.toString() + "c"; 
              transientSum = cumilativeSum + (denomination * i); 
              if ((denominationIndex + 1) === factorCount) { 
                  if (transientSum === amount) { 
                      changeSets += 1; 
                      console.log(
                        changeSets + ". " + matchFactors); 
                  } 
              } else { 
<span class="strong"><strong>                     findCombinationSet(denominationIndex + 1,
                       transientSum);</strong></span> 
              
                } 
                i += 1;
                //---------------------Pretty Printing END
          }
        };
     <span class="strong"><strong> findCombinationSet(0, 0);
</strong></span>    };</pre>
          <p>The <code class="literal">printChangeSet</code> function again creates a local scope, and further employs the <code class="literal">findCombinationSet</code> function to shortlist the applicable <code class="literal">changeSets</code> out of the possible currency combinations (based on the available denominations). Another important thing to note here is the tail call optimization done for the recursion involving the <code class="literal">findCombinationSet</code> function (see highlighted code) by passing accumulated transient sums, thereby eliminating call-stack growth:</p>
          <pre class="programlisting">    // This function computes the possible denomination sets 
    var generateChangeSets = function () { 
      var bitcount = denominations.length, 
        mask = Math.pow(2, bitcount), 
          i = 1, 
          j = 0, 
          k = 1, 
          denominationSet = null, 
          denominationSum = 0; 
      while (i &lt; mask) { 
        j = 0; 
        denominationSet = []; 
        denominationSum = 0; 
        while (j &lt; bitcount) { 
          if ((i &amp; (k &lt;&lt; j)) &gt; 0) { 
            denominationSet.push(denominations[j]); 
            denominationSum += denominations[j]; 
          } 
          j += 1; 
        } 
        if (denominationSum &lt;= amount) { 
<span class="strong"><strong>          subject.onNext(denominationSet);</strong></span> 
        } 
        i += 1; 
      } 
<span class="strong"><strong>      subject.onCompleted();</strong></span> 
    }; 
    generateChangeSets(); 
  }; 
</pre>
          <p>In case you are wondering about this <code class="literal">generateChangeSets</code> function, you guessed it right. This is the JS equivalent of the C# subset generation code we saw in <a class="link" href="dn-dsnptn_ch09.html" title="Chapter&#160;9.&#160;Functional Programming Techniques for Better State Management">Chapter 9</a>, <span class="emphasis"><em>Functional Programming Techniques for Better State Management</em></span>. So, by now you would have got a hang on the algorithm employed here, which can be explained as follows:</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Generate all possible subsets (possibly denomination combinations).</li>
              <li class="listitem">Try to determine possible counts per denomination.</li>
              <li class="listitem">If step 2 is successful, do pretty printing, as shown in the following output for <code class="literal">calculateChange([1, 5, 10, 25], 25)</code>:</li>
            </ol>
          </div>
          <pre class="programlisting"><span class="strong"><strong>changeSetClient Processing Denominations: [ 1 ]</strong></span>
<span class="strong"><strong>changeSetClient Processing Denominations: [ 5 ]</strong></span>
<span class="strong"><strong>changeSetClient Processing Denominations: [ 1, 5 ]</strong></span>
<span class="strong"><strong>changeSetClient Processing Denominations: [ 10 ]</strong></span>
<span class="strong"><strong>changeSetClient Processing Denominations: [ 1, 10 ]</strong></span>
<span class="strong"><strong>changeSetClient Processing Denominations: [ 5, 10 ]</strong></span>
<span class="strong"><strong>changeSetClient Processing Denominations: [ 1, 5, 10 ]</strong></span>
<span class="strong"><strong>changeSetClient Processing Denominations: [ 25 ]</strong></span>
<span class="strong"><strong>1. 25 x 1c</strong></span>
<span class="strong"><strong>2. 5 x 5c</strong></span>
<span class="strong"><strong>3. 5 x 1c,4 x 5c</strong></span>
<span class="strong"><strong>4. 10 x 1c,3 x 5c</strong></span>
<span class="strong"><strong>5. 15 x 1c,2 x 5c</strong></span>
<span class="strong"><strong>6. 20 x 1c,1 x 5c</strong></span>
<span class="strong"><strong>7. 5 x 1c,2 x 10c</strong></span>
<span class="strong"><strong>8. 15 x 1c,1 x 10c</strong></span>
<span class="strong"><strong>9. 1 x 5c,2 x 10c</strong></span>
<span class="strong"><strong>10. 3 x 5c,1 x 10c</strong></span>
<span class="strong"><strong>11. 5 x 1c,2 x 5c,1 x 10c</strong></span>
<span class="strong"><strong>12. 10 x 1c,1 x 5c,1 x 10c</strong></span>
<span class="strong"><strong>13. 1 x 25c</strong></span>
<span class="strong"><strong>changeSetClient Processing Completed!</strong></span>
</pre>
          <p>In case you didn't notice, the console logs appear first before the results are printed, clearly indicating that step 2 and beyond are asynchronous!
</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Summary">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch13lvl1sec97"></a>Summary</h1>
            </div>
          </div>
        </div>
        <p>By now you must have understood how reactive programming is employed for modeling solutions the way the world exists. The principle has been applied for various mainstream programming languages, as thought leaders such as Erik Meijer found this too natural to express and compose. And we got lucky in this discovery process. We believe, as developers, you must have have started appreciating the world of functional and reactive programming beyond OOP. In the next chapter, we will be specifying, in brief, some important topics which could not be covered in the book, such as polyglot programming, <span class="strong"><strong>domain specific languages</strong></span> (<span class="strong"><strong>DSLs</strong></span>), ontology, and AntiPatterns.</p>
      </div>
    </div>
</body>
</html>