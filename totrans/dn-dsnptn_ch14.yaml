- en: Chapter 14. A Road Ahead
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It has been a whirlwind journey on various topics through our book. If you
    have reached this point, you might have come across some new concepts, or might
    have had a fresh look at some things that you already knew. Broadly speaking,
    the theme of this book can be divided into the following four sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Putting patterns into perspective (Chapter 1 and 2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GoF in action (Chapter 3 through 7)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object/functional programming (Chapter 8 to 10)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Functional) reactive programming (Chapter 11, 12, and 13)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Patterns are an interesting topic, and they have helped software developers
    to address complex business problems by providing proven and time-tested solutions.
    It has also improved communication between developers and their stakeholders.
    By learning patterns, as a developer, you get distilled knowledge and experience
    of those master programmers who cataloged these patterns. But there are some more
    topics that you should know in your journey as a developer or an architect. The
    authors of this book consider the following four topics of great interest to a
    professional (as a continuation of the topics covered in this book):'
  prefs: []
  type: TYPE_NORMAL
- en: Polyglot programming and design (multi paradigm programming)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain-specific languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ontology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AntiPatterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polyglot programming and design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modern applications are complex to develop as they might have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Service layer with a database for persistence ( SQL or NoSQL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The UI code has to be responsive and calibrated for different form factor devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The frontend code is mostly based on some kind of **Single Page Architecture**
    (**SPA**) architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some cases, there can be desktop and mobile native frontends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A developer who has been hired for such a project should have the following
    skills:'
  prefs: []
  type: TYPE_NORMAL
- en: Java, C#, PHP, Ruby, or Grails for writing service layers (skills in one or
    more)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For writing UI code, they should be familiar with CSS libraries and JavaScript
    (e.JQuery)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For web-based responsive frontend, TypeScript/JavaScript using Angular, ReactJs,
    or any other JavaScript-based framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For writing desktop applications, the choices are C#, C++, Objective C/C++,
    Python, or Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For mobile application development (native), choices are C#, Java, or Objective
    C/Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bottom line here is that one should be comfortable with at least more than
    half a dozen programming languages to be in a position to work with modern projects.
    If you add skills in PowerShell, Bash shell, JSP/HTML/template engines, XML, JSON,
    and so on, we are indeed living in a world where a person has to be really conversant
    in as many languages as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Let us trace the evolution of this state of affairs by quickly chronicling the
    history of development under the PC platform. The programming landscape has changed
    quite a lot in the last decade. When the GoF pattern book was written, programming
    languages such as Java and C# had not been born. The dominant object-oriented
    programming language in those days, for all practical purpose was C++. Even for
    C++, the ANSI standards were not ratified (it happened only in 1998). Other than
    C++, languages such as Delphi (Object Pascal),Visual Basic, PowerBuilder, and
    various xBase dialects (Clipper, FoxPro, and the like) were widely used by programmers
    of that era. Platforms such as Microsoft Windows were just evolving. Various flavors
    of UNIX and MS-DOS were the primary platforms (even GNU Linux had not reached
    a critical mass in those times!).
  prefs: []
  type: TYPE_NORMAL
- en: Even in the early years of programming, it was realized that one cannot build
    solutions using a single programing language. We need to mix and match programming
    languages that are apt for the context. At one point in time, most numerical libraries
    were written in Fortran, and those libraries were interfaced with the C language
    for writing systems, which are numerically intensive. In the early years of programming,
    people used to write code in a high-level language, and interface their code with
    routines written in C and assembler. Thus, a programmer needs to know a high-level
    language, C programing language, and the syntax of the assembly language of the
    environment in which the program was developed and deployed. The process of developing
    a large system using different programming languages for writing different subsystems
    and composing them to create a larger system is called polyglot programming. Designing
    such systems, where there is a multitude of programming languages and technology
    stacks, is called polyglot design. To design such a system, developers should
    be able to think in a language-and-platform-agnostic manner.
  prefs: []
  type: TYPE_NORMAL
- en: The movement towards polyglot programming started in the early years of programming
    on the IBM PC platform. Polyglot programming was mostly an affair of interfacing
    routines written in the C programming language to a high-level language chosen
    for writing the system.
  prefs: []
  type: TYPE_NORMAL
- en: Polyglot programming with C/C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When people programmed in various languages other than C/C++, there were options
    available for interfacing with C/C++, code packaged as DLLs or `.so` in Windows
    and Unix/Linux, respectively. In MS-DOS, all xBase languages offered an interface
    mechanism to interact with the native code written in C/C++ and Assembler/. In
    the Microsoft Windows platform, Visual Basic offered a mechanism to call routines
    written in C/C++/. Using this mechanism, people consumed a vast amount of Windows
    API functions provided by Microsoft. People began to program Windows using Visual
    Basic and Visual C++. The visual development environments such as Delphi and PowerBuilder
    also provided similar mechanisms to consume code written in C/C++. This can be
    considered as the beginning of programming systems using multiple languages, and
    is nowadays called Polyglot programming.
  prefs: []
  type: TYPE_NORMAL
- en: With the advent of the Java programming language, the promise of platform-neutral
    programming became a buzzword in the Industry. The **write once, run everywhere**
    (**WORE**) mantra came to the fore, and it did not prevent the implementers of
    Java to give a mechanism to interact with native code written in C/C++. The interface
    was called **Java Native Interface** (**JNI**). Using this mechanism, people wrote
    wrappers around technologies such as Direct3D and OpenGL to create libraries like
    Java 3D. The popular computer vision system, OpenCV, is interfaced with Java software
    using JNI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The .NET platform was unveiled in the year 2001, and it gave two interfaces
    to interface with the native code. The first one was PInvoke, a mechanism to interface
    with Win2/Win64 calls exported out of DLLs. Microsoft also gave a mechanism to
    call C++-based COM components called COM interoperability. They named it COM callable
    wrapper. To demonstrate the use of P/Invoke, here is a small C/C++ code snippet
    (compiled into a DLL) interfaced with C# code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can compile the preceding code using the Visual C++ compiler or MinGW compiler
    (GCC under Windows ) to create a DLL. We have used the MinGW 32-bit compiler to
    generate the Win32 DLL. The DLL can be interfaced with C# code written using Visual
    Studio or Mono compiler under Windows. If you know how to build a shared library
    (`.so`) under Mac OS X or GNU Linux, we can run the code on those platforms as
    well. The C# code can be used to invoke the DLL written previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The polyglot web programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **World Wide Web** (**WWW**) reached critical mass roughly in the year 1995,
    and the programming landscape changed all of a sudden. People who learned to program
    desktop systems using Windows API and X/Windows API found themselves in a position
    of great difficulty, forced to grapple with the complexities of the **Common Gateway
    Interface** (**CGI**), NSAPI, and ISAPI programming model to generate dynamic
    web pages. The languages of choice were Perl and TCL for CGI, and C/C++ for NSAPI/ISAPI.
  prefs: []
  type: TYPE_NORMAL
- en: The situation continued for some time, and it all changed all of a sudden when
    Microsoft brought out **Active Server Pages** (**ASP**) for creating dynamic web
    pages. Soon, Sun Microsystems came up with Java Servlet API. The Servlet API was
    a low-level API like C++-based ISAPI, and Sun soon brought out **JavaServer Pages**
    (**JSP**), a technology that embedded Java code inside markups. The JSPs were
    converted to Servlet code on the fly using the Java Compiler system available
    on the executing machine. There were technologies such as ColdFusion, which leveraged
    custom markups to write extensible applications, and had the capacity to interact
    with code written in Java. The Web programming model mandated people to learn
    C++, Java, Visual Basic, and ASP to write dynamic web pages. On the Microsoft
    platform, people began to write VBScript code interspersed with calls to COM/ActiveX
    objects written in C++ and Visual Basic. In fact, the emergence of web-based application
    delivery forced programmers to become a true polyglot.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript evolution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The emergence of JavaScript was another thing that forced developers to learn
    yet another language to add a bit of interactivity to their web pages. In those
    times, people were mostly comfortable with statically typed languages, and found
    JavaScript to be a weird language. JavaScript remained in relative obscurity for
    a long time, until someone found out a clever way to mix JavaScript with IE ActiveX
    plugin. In the early years of the twenty-first century, people began to write
    user interfaces by embedding browser controls inside a desktop container, and
    used JavaScript as a glue language to interact with the ActiveX controls embedded
    in those pages. JavaScript picked up momentum, and people began to consider it
    as a first class programming language after the advent of Google's V8 engine and
    the Node.js platform. Another shot in the arm was the support for functional style
    programming using the JavaScript language, and the emergence of libraries such
    as JQuery, Angular, ReactJS, and the like. In the last decade, knowledge of the
    JavaScript programming language became essential for all programmers, whether
    they wrote server code or client code. JavaScript is another language that programmers
    were forced to learn.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic/scripting languages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The emergence of Perl, Python, PHP, Ruby, TCL, and Groovy for writing command
    line, GUI, and web applications forced developers to master some of them in their
    day-to-day job. PERL is still widely used for writing CGI applications, automation
    scripts, and even GUI applications (Perl/TK) all across the world. The Python
    programming language is the de-facto programming language for writing (or at least
    learning) machine learning programs because of the libraries available in that
    language, and they are widely used for writing web applications with some MVC
    frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Both Ruby on Rails and Groovy and Grails ushered in a rapid development lifecycle
    era to make their penetration in the start-up ecosystem. PHP is the most popular
    web development system in the world, and it is especially suited for writing front-facing
    applications. The sheer number of content management systems available with the
    platform is another attraction. Architecting solutions with PHP for front-facing
    pages, Java for Service logic, and Silverlight for frontend (for interactive parts)
    became popular in some circles! The popularity of the REST paradigm has made writing
    the server-side logic to be in whatever language one chooses to. As long as the
    URI is consistent, the routing system makes sure that it resolves the correct
    handler logic to get executed.
  prefs: []
  type: TYPE_NORMAL
- en: Emergence of functional programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned in the first chapter, Herb Sutter's seminal article titled, *The
    Free Lunch Is Over*, rekindled interest in functional programming, which was mostly
    relegated to academic circles. The FP model was well suited for exploiting the
    many-core processing world. The stateless computation model of the FP helps to
    scale an application from a single core to dozens of cores without any additional
    programming effort. The emergence of Scala, F#, Clojure, Haskell (in some niche
    areas), and so on, and the availability of them in the JVM and CLR world made
    them a viable choice for writing some applications. In the Microsoft world, people
    began to write code in C# and F#, to bundle the code inside the same system. Learning
    a functional language (one or more) became absolutely essential for modern-day
    programmers. Another excuse to become a polyglot!
  prefs: []
  type: TYPE_NORMAL
- en: Mobile revolution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some competence in mobile application development is necessary for every software
    developer in the world. Apple's iOS, Google's Android, and Microsoft's Windows
    Phone are the leading platforms in this arena. Unfortunately, native application
    development languages in these platforms are Objective C/Swift (iOS), Java (Android),
    and C# (Windows Phone). A .NET developer has to learn Java, Objective C, or Swift
    to write native applications for these platforms. If you want to avoid this, you
    might have to use hybrid application development with JavaScript as a programming
    language. Anyway, you need to be a Polyglot!
  prefs: []
  type: TYPE_NORMAL
- en: A quick note on polyglot persistence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a long time, the **Relational database management systems** (**RDBMSs**)
    became the backbone of every business application ever developed. The Oracle Server,
    Microsoft SQL Server, MYSQL, and Postgres systems were the de-facto choice for
    persisting data. The emergence of the NoSQL movement gave us different types of
    databases suitable for distributed programs, which should scale well. They are
    listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Columnar databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key/value databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Document databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NoSQL is a vast and varied topic, and the reader is expected to search Google
    to understand it, as a fair treatment of it warrants many books. So, a modern
    web-based application might store data in various persistence technologies available,
    based on the application context. A typical use case could be any one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An RDBMS for storing transactional data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A key/value database for storing master data (for faster lookup)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A graph database for storing relationship between entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A columnar database for data that is part of analytical queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By choosing the appropriate backend technologies, the application can ensure
    throughput and scalability for large-scale applications development. The process
    of using different persistence technologies in an application is called **polyglot
    persistence**. A developer should be really familiar with this paradigm along
    with polyglot programming.
  prefs: []
  type: TYPE_NORMAL
- en: How to become a polyglot programmer?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From a programming paradigm perspective, there are only three types of programming
    languages in this world, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Functional languages (based on lambda calculus)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logic languages (based on predicate logic)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imperative languages (based on Turing machines)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be a contemporary developer, one needs to master a couple of languages from
    each family. To be competent in FP, the language options available are F#, Clojure,
    and Scala. The logic programming languages are Prolog and Datalog. Learning them
    will help on improving design skills, especially in building hierarchical data
    structures. The type inference algorithm available with F#, Scala, and C# uses
    the unification algorithm, which forms the backbone of the Prolog language. Thus,
    understanding the Prolog machine model helps you to appreciate and exploit the
    rich type systems available with the modern programming languages. Most of the
    popular languages are imperative in nature, and mastering a couple of object/functional
    languages (such as C#, Java 8, and Scala) really helps. Once you learn a representative
    language from each of the aforementioned families, you have made the cognitive
    leap to understanding every programming language ever created or going to be created
    in the near future!
  prefs: []
  type: TYPE_NORMAL
- en: Domain-specific languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A language developed for expressing solutions to problems that are specific
    to a domain such as finance, payroll, electronic circuit design, parser generators,
    input validations, and so on is called a **domain-specific language** (**DSL**).
    Two common examples that are familiar to most programmers are **Structured Query
    Language** (**SQL**) and **regular expression** (**RE**). If we were to write
    imperative code for retrieving data from a database, it would have been a difficult
    task and error prone. SQL gives you a declarative language to achieve the same
    objective, and it has solid mathematical foundations. While searching strings,
    RE helps us to give complicated patterns to match against a string. It helps to
    avoid writing tedious logic for searching complicated string matches.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a concrete example of a DSL, which is quite popular in the .NET and Java
    world, we are pasting here a specification given to the **ANTLR** tool to write
    a very simple arithmetic evaluator. The tool generates a lexical analyzer and
    parser automatically from this specification. Please consult the ANTLR documentation
    to understand the semantics of the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The ANTLR tool will generate a lexical analyzer, a parser module, and even a
    tree walker to process the expression. We can write parsers for C#, Java, and
    even C/C++ using this tool. In the Unix and the Windows native programming world,
    the tool Lex (GNU Flex) and Yacc (GNU Bison) is used for the same purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'As another case in point, authors worked in a DSL project, which evaluated
    a spreadsheet for consistency. A code snippet from the turing complete DSL generated
    for the project is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet was parsed using a hand-coded recursive descent parser,
    and an **abstract syntax tree** (**AST**) was generated. The tree was traversed
    in a depth-first manner to generate a .NET IL code to generate a .NET assembly
    (DLL). The resulting assembly was consumed as if the logic were written in C#!
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Extensible Stylesheet Language** (**XSL**) is another domain-specific
    language, which is very much familiar to most programmers. A small XSL snippet
    is given here for the sake of completeness, and readers are expected to master
    this language for generating sites with variant layouts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The other popular DSLs are VHDL and Verilog (Digital Hardware Description Language),
    CSS, and template languages available with different technology stacks, JBoss
    Drools, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing and designing one''s own DSL is a very vast topic, which cannot be
    covered in a short chapter. Some things that one needs to take care of are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing an object model, which mimics domain concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a linguistic abstraction and associated key words for arriving at
    language elements and rules for composing elements to form compound elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping language elements to the object model created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deciding whether the DSL should be internal or external?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deciding whether the DSL should be turing complete or not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The topic is well covered by Debasish Ghosh and Martin Fowler/Rebecca Parsons
    in their wonderful books. Please consult the following books for a thorough understanding
    of the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '*DSLs in Action* by Debashish Ghosh ( Manning)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Domain-Specific Languages* by Martin Fowler and Rebecca Parsons (Addison Wesley
    Martin Fowler signature series)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ontology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In software engineering parlance, Ontology is the art, craft, and science of
    describing entities (types), attributes (properties), and relationships that exist
    in a particular domain of discourse. It can also be considered as a model for
    describing entities, attributes, their relationship, and even standard behavior.
    An ontology really helps to come up with a ubiquitous language (as in **Domain-Driven
    Design** (**DDD**)), where all stakeholders agree, and which eases communication.
    It avoids confusion while developing multi-domain software systems. An ontology
    defines and represents the basic terms and relations that exist in a software
    engineering context.
  prefs: []
  type: TYPE_NORMAL
- en: 'From an information processing perspective, the following points are to be
    noted:'
  prefs: []
  type: TYPE_NORMAL
- en: The propositional and predicate logic gives the rules of inference and formal
    structures to encode facts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ontology defines and helps to represent entities, their attributes, and
    the relationship between the entities in an unambiguous manner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The computation helps to implement ontologies on a computer-it helps us go beyond
    the philosophical ontology (first two steps)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To write non-trivial knowledge processing systems, a software engineer should
    acquire skills in defining and interpreting ontologies. He should also be able
    to encode the ontology and its associated rules on a computer to create working
    computation models of the ontology in question. In software engineering, a well-defined
    ontology helps in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Sharing knowledge between stakeholders about problem/solutions domain using
    a common terminology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering the ontology to create models and meta models for application development
    (projections of an ontology)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computation using the elements defined in the ontology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are different ways by which we can encode an ontology. All of them share
    common elements, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes, types, or concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relations, roles, or properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formal rules or axioms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The W3C Semantic Web has created an XML-based language called **Web Ontology
    Language** (**OWL**) for describing ontologies in a structured manner. The OWL
    embeds **Resource Description Format** (**RDF**) tags to define standard ontologies.
    A transportation ontology from an IBM site goes as follows. These OWL markups
    specify that there are three classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This section was written to kindle interest in ontology for readers of this
    book. The DDD is a topic very closely related to ontology, and people who have
    written object-oriented systems can relate to them very fast. To get into the
    ontology-based software development method, we would like to recommend a wonderful
    book written by John Sowa, titled, *Knowledge Representation: Logical, Philosophical
    and Computational Foundations*. Chapter 2 of that book deals with ontology as
    applied to software engineering. Also learn about the semantic web initiative
    by the W3C, by visiting their site.'
  prefs: []
  type: TYPE_NORMAL
- en: AntiPatterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An AntiPattern is a solution to a problem that seems to produce gain initially,
    but turns out to be counterproductive eventually. As patterns are named solutions,
    it might not be fit for certain kind of scenarios, and end up being an AntiPattern.
    The context in which we apply patterns is very important. AntiPatterns occur in
    various scenarios of a software development life cycle. They are broadly classified
    into these three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Software development AntiPatterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architectural AntiPatterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Management (process) AntiPatterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*AntiPatterns: Refactoring Software, Architectures, and Projects in Crisis*
    by William J. Brown, Raphael C. Malveau, Hays W. McCormick III, and Thomas J.
    Mowbray is a seminal work on the AntiPattern.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of kick-starting the discussion, we would like to cover some of
    the AntiPatterns that are ubiquitous and to which the readers of this book might
    be able to relate in their context:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Blob AntiPattern**: This often happens when people from a procedural
    programming language background design object-oriented systems. They create a
    big class, which contains most of the logic, and the associated classes are just
    containers of data. This AntiPattern results in making a class take a lion''s
    share of the responsibility, while the other classes execute trivial logic. The
    solution is to refactor the class and distribute responsibilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Lave Flow AntiPattern**: This is also called dead code, and is often
    found in systems that started out as POC, and incrementally morphed into a production
    system. In this transformation, a lot of code is not used or never reached.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional Decomposition AntiPattern**: An AntiPattern that emerges in scenarios
    where primary designers of systems come from procedural languages such as C or
    Fortran, and try to fit their time-tested techniques to an OOP paradigm. Even
    after twenty years of OOP becoming mainstream, this is a recurring pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Poltergeist (aka Gypsy)**: In the OOP context, sometimes, developers
    create classes that have a short life cycle to kick-start the processing by core
    classes, which have long duration. This can be eliminated by refactoring the code
    to include the logic of these ghost classes to the hierarchy of classes created
    for the solution of the problem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Golden Hammer**: This AntiPattern emerges in the context where the primary
    designers of the system might have a favorite technology, technique, or methodology
    while solving problems. The old adage, *For a person with hammer, everything appears
    to be a nail* clearly summarizes this mindset. The favorite tool is unleashed
    in a context where it might fit remotely. As anecdotal evidence, one of the author
    knows a person who will try to solve every problem through SNMP, where an ordinary
    TCP/IP program would have done the job.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Dead End**: This often happens where a team might have leveraged a custom
    control written by an ISV to speed up the development process. While in production,
    the vendor might go bankrupt, or the product might not be supported by the company
    that acquired the vendor. By this time, the code base could get coupled with the
    custom control in question. Writing an isolation layer with interfaces meant for
    the same could avert this problem. The authors have come across dozens of such
    systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resume-Driven Design**: The majority of developers, especially in the software
    services industry across the world, put their resume in front of the problem they
    are trying to solve. The presence or absence of certain buzzword technologies
    determines their compensation, and they use the latest technologies for situations
    where it is not warranted. This is so common that it is very easy to detect, as
    some simple scenarios will contain all the technologies currently in the hype
    cycle. One of the authors found himself in a situation where the code base happened
    to have an m framework, NoSQL database (a text file would have done the trick),
    a plugin architecture based on Microsoft **Managed Extensibility Framework** (**MEF**),
    a messaging system, and a cache manager for a system that would have taken thirty
    lines of a transaction-script like code. The current trend of converting projects
    that are running in production well to Angular 2/Typescript is another case of
    resume-driven design.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spaghetti Code**: This is an emergent phenomena in most systems, even in
    systems that were well defined initially. There was a mistaken notion that Spaghetti
    code was found only in procedural programming code base and COBOL. In OOP systems,
    as the system evolves and initial developers move away, the new developers who
    might not have much clue about the whole system, might end up writing code in
    a spaghetti style. Recently, authors found a Silverlight application, which used
    the MVVM pattern, and that had more spaghetti style code than a mainframe COBOL
    program!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cut and Paste Programming**: This often happens in large systems where a
    new developer who is given a tight deadline tries to leverage code written elsewhere
    to speed up his development time. The developer cuts and pastes a large block
    of code that implements similar functionality, and makes the necessary changes.
    In the process, some residual code gets executed unnecessarily in the new content.
    One of the authors, who worked with a large electronic CAD software, found performance
    issues in the code as the developers resorted to the *Cut and Paste* model development,
    leading to some nested loops running unnecessarily. Because of the Spaghetti code
    acquired over a period of time, it happened at multiple places.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The StovePipe System**: In most enterprises, because of the evolutionary
    nature of application development, software systems are integrated in an ad hoc
    manner. Some software might use resource tier integration (using relational databases),
    some might use transaction scripts (using a batch job engine) , point-to-point
    integration using REST/SOAP services, and applications run on multiple technology
    stacks through multiple messaging systems based on JMS and MSMQ protocol. Due
    to mergers and acquisitions, and lack of unified enterprise strategy, the whole
    scenario becomes a maintenance nightmare. By having an enterprise integration
    strategy and internal standards, we can reduce the complexity of integration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other popular AntiPatterns are Vendor Lock-in, Design by Committee, Warm
    Bodies, Architecture by Implication, Intellectual Violence, Analysis Paralysis,
    Smoke and Mirrors, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: AntiPatterns are a topic that is as important as the patterns. While patterns
    give you time-trusted named solutions to common problems, AntiPatterns and their
    solutions avoid pitfalls in your software engineering life cycle. This topic warrants
    a book of its own. We have just given some brief descriptions here.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chapter dealt with some pointers for the readers to further their study
    of software engineering techniques. The topics covered include polyglot programming,
    DSL, ontology, and AntiPatterns. We could only mention these topics briefly, as
    these topics require multiple books to do justice to them. There is indeed good
    material available on these topics in the form of YouTube videos, white papers,
    and books. Also try to understand more about various pattern catalogs mentioned
    in the first chapter of this book to have a solid foundation for architecting
    future systems.
  prefs: []
  type: TYPE_NORMAL
