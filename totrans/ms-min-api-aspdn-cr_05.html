<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer044">
<h1 class="chapter-number" id="_idParaDest-67"><a id="_idTextAnchor068"/>5</h1>
<h1 id="_idParaDest-68"><a id="_idTextAnchor069"/>Using Logging to Identify Errors</h1>
<p>In this chapter, we will begin to learn about the logging tools that .NET provides us with. A logger is one of the tools that developers must use to debug an application or understand its failure in production. The log library has been built into ASP.NET with several features enabled by design. The purpose of this chapter is to delve into the things we take for granted and add more information as we go.</p>
<p>The themes we will touch on in this chapter are as follows:</p>
<ul>
<li>Exploring logging in .NET</li>
<li>Leveraging the logging framework</li>
<li>Storing a structured log with Serilog</li>
</ul>
<h1 id="_idParaDest-69"><a id="_idTextAnchor070"/>Technical requirements</h1>
<p>As reported in the previous chapters, it will be necessary to have the .NET 6 development framework.</p>
<p>There are no special requirements in this chapter for beginning to test the examples described.</p>
<p>All the code samples in this chapter can be found in the GitHub repository for this book at <a href="https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter05">https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter05</a>.</p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor071"/>Exploring logging in .NET</h1>
<p><strong class="bold">ASP.NET Core</strong> templates <a id="_idIndexMarker217"/>create <a id="_idIndexMarker218"/>a <strong class="bold">WebApplicationBuilder</strong> and a <strong class="bold">WebApplication</strong>, which<a id="_idIndexMarker219"/> provide <a id="_idIndexMarker220"/>a simplified way to configure and run <a id="_idIndexMarker221"/>web applications without a startup class. </p>
<p>As mentioned previously, with .NET 6, the <strong class="source-inline">Startup.cs</strong> file is eliminated in favor of the existing <strong class="source-inline">Program.cs</strong> file. All startup configurations are placed in this file, and in the<a id="_idIndexMarker222"/> case of <strong class="bold">minimal APIs</strong>, endpoint implementations are also placed.</p>
<p>What we have just described is the starting point of every .NET application and its various configurations.</p>
<p>Logging into an<a id="_idIndexMarker223"/> application means tracking the evidence in different points of the code to check whether it is running as expected. The purpose <a id="_idIndexMarker224"/>of logging is to track over time all the conditions that led to an unexpected result or event in the application. Logging in an application can be useful both during development and while the application is in production.</p>
<p>However, for logging, as many as four providers are added for tracking application information:</p>
<ul>
<li><strong class="bold">Console</strong>: The Console provider <a id="_idIndexMarker225"/>logs output to the console. This log is unusable in production because the console of a web application is usually not visible. This kind of log is useful during development to make logging fast when you are running your app under Kestrel on your desktop machine in the app console window.</li>
<li><strong class="bold">Debug</strong>: The Debug provider <a id="_idIndexMarker226"/>writes log output by using the <strong class="source-inline">System.Diagnostics.Debug</strong> class. When we develop, we are used to seeing this section in the <em class="italic">Visual Studio</em> output window.</li>
</ul>
<p>Under the Linux operating system, information is tracked depending on the distribution in the following locations: <strong class="source-inline">/var/log/message</strong> and <strong class="source-inline">/var/log/syslog</strong>.</p>
<ul>
<li><strong class="bold">EventSource</strong>: On Windows, this <a id="_idIndexMarker227"/>information can be viewed in the <strong class="bold">EventTracing</strong> window. </li>
<li><strong class="bold">EventLog</strong> (only when running on Windows): This<a id="_idIndexMarker228"/> information is displayed in the native Windows window, so you can only see it if you run the application on the Windows operating system.</li>
</ul>
<p class="callout-heading">A new feature in the latest .NET release</p>
<p class="callout">New logging providers have been added in the latest versions of .NET. However, these providers are not enabled within the framework.</p>
<p class="callout">Use these extensions to enable new <a id="_idIndexMarker229"/>logging scenarios: <strong class="source-inline">AddSystemdConsole</strong>, <strong class="source-inline">AddJsonConsole</strong>, and <strong class="source-inline">AddSimpleConsole</strong>.</p>
<p>You can find <a id="_idIndexMarker230"/>more details on how to configure the log and what the basic ASP.NET settings are at this link: <a href="https://docs.microsoft.com/aspnet/core/fundamentals/host/generic-host">https://docs.microsoft.com/aspnet/core/fundamentals/host/generic-host</a>.</p>
<p>We’ve started to see what <a id="_idIndexMarker231"/>the framework gives us; now we need to understand how to leverage it within our applications. Before proceeding, we need to understand what a logging layer is. It is a fundamental concept that will help us break down information into different layers and<a id="_idIndexMarker232"/> enable them as needed:</p>
<div>
<div class="IMG---Figure" id="_idContainer038">
<img alt="Table 5.1 – Log levels " height="1225" src="image/B17902_Table1.jpg" width="1646"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.1 – Log levels</p>
<p><em class="italic">Table 5.1</em> shows the most verbose levels down to the least verbose level.</p>
<p>To learn more, you <a id="_idIndexMarker233"/>can read the article titled <em class="italic">Logging in .NET Core and ASP.NET Core</em>, which explains the logging process in detail here:<a href="https://docs.microsoft.com/aspnet/core/fundamentals/logging/"> https://docs.microsoft.com/aspnet/core/fundamentals/logging</a>/.</p>
<p>If we<a id="_idIndexMarker234"/> select <a id="_idIndexMarker235"/>our log level as <strong class="source-inline">Information</strong>, everything at this level will be tracked down to the <strong class="source-inline">Critical</strong> level, skipping <strong class="source-inline">Debug</strong> and <strong class="source-inline">Trace</strong>.</p>
<p>We’ve seen how to take advantage of the log layers; now, let’s move on to writing a single statement that will log information and can allow us to insert valuable content into the tracking system.</p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor072"/>Configuring logging</h2>
<p>To start using the <a id="_idIndexMarker236"/>logging component, you need to know a couple of pieces of information to start tracking data. Each logger object (<strong class="source-inline">ILogger&lt;T&gt;</strong>) must have an associated category. The log category allows you to segment the tracking layer with a high definition. For example, if we want to track everything that happens in a certain class or in an ASP.NET controller, without having to rewrite all our code, we need to enable the category or categories of our interest.</p>
<p>A category is a <strong class="source-inline">T</strong> class. Nothing could be simpler. You can reuse typed objects of the class where the log method is injected. For example, if we’re implementing <strong class="source-inline">MyService</strong>, and we want to track everything that happens in the service with the same category, we just need to request an <strong class="source-inline">ILogger&lt;MyService&gt;</strong> object instance from the dependency injection engine.</p>
<p>Once the log categories are defined, we need to call the <strong class="source-inline">ILogger&lt;T&gt;</strong> object and take advantage of the object’s public methods. In the previous section, we looked at the log layers. Each log layer has its own method for tracking information. For example, <strong class="source-inline">LogDebug</strong> is the method specified to track information with a <strong class="source-inline">Debug</strong> layer.</p>
<p>Let’s now look at an example. I created a record in the <strong class="source-inline">Program.cs</strong> file: </p>
<pre class="source-code">
internal record CategoryFiltered();</pre>
<p>This record is used to define a particular category of logs that I want to track only when necessary. To do this, it is advisable to define a class or a record as an end in itself and enable the necessary trace level.</p>
<p>A record that is defined in the <strong class="source-inline">Program.cs</strong> file has no namespace; we must remember this when we define the <strong class="source-inline">appsettings</strong> file with all the necessary information.</p>
<p>If the log category is within a namespace, we must consider the full name of the class. In this case, it is <strong class="source-inline">LoggingSamples.Categories.MyCategoryAlert</strong>:</p>
<pre class="source-code">
namespace LoggingSamples.Categories
{
    public class MyCategoryAlert
    {
    }
}</pre>
<p>If we do not specify the category, as in the following example, the selected log level is the default: </p>
<pre class="source-code">
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      <strong class="bold">"CategoryFiltered": "Information",</strong>
<strong class="bold">      "LoggingSamples.Categories.MyCategoryAlert": "Debug"</strong>
    }
  }</pre>
<p>Anything that<a id="_idIndexMarker237"/> comprises infrastructure logs, such as Microsoft logs, stays in special categories such as <strong class="source-inline">Microsoft.AspNetCore</strong> or <strong class="source-inline">Microsoft.EntityFrameworkCore</strong>.</p>
<p>The full list of Microsoft log categories can be found at the following link:</p>
<p><a href="https://docs.microsoft.com/aspnet/core/fundamentals/logging/#aspnet-core-and-ef-core-categories">https://docs.microsoft.com/aspnet/core/fundamentals/logging/#aspnet-core-and-ef-core-categories</a></p>
<p>Sometimes, we need to define certain log levels depending on the tracking provider. For example, during development, we want to see all the information in the log console, but we only want to see errors in the log file. </p>
<p>To do this, we don’t need to change the configuration code but just define its level for each provider. The following is an example that shows how everything that is tracked in the Microsoft categories is shown from the <strong class="source-inline">Information</strong> layer to the ones below it:</p>
<pre class="source-code">
{
  "Logging": {      // Default, all providers.
    "LogLevel": {
      "Microsoft": "Warning"
    },
    <strong class="bold">"Console"</strong>: { // Console provider.
      "LogLevel": {
        "Microsoft": "Information"
      }
    }
  }
}</pre>
<p>Now that we’ve<a id="_idIndexMarker238"/> figured out how to enable logging and how to filter the various categories, all that’s left is to apply this information to a minimal API.</p>
<p>In the following code, we inject two <strong class="source-inline">ILogger</strong> instances with different categories. This is not a common practice, but we did it to make the example more concrete and show how the logger works: </p>
<pre class="source-code">
app.MapGet("/first-log", (ILogger&lt;CategoryFiltered&gt; loggerCategory, ILogger&lt;MyCategoryAlert&gt; loggerAlertCategory) =&gt;
{
    loggerCategory.LogInformation("I'm information 
      {MyName}", "My Name Information");
    loggerAlertCategory.LogInformation("I'm information
      {MyName}", "Alert Information");
    return Results.Ok();
})
.WithName("GetFirstLog");</pre>
<p>In the preceding snippet, we inject two instances of the logger with different categories; each category tracks a single piece of information. The information is written according to a template that we will describe shortly. The effect of this example is that based on the level, we can show or disable the information displayed for a single category, without changing the code.</p>
<p>We started filtering the logo by levels and categories. Now, we want to show you how to define a template that will allow us to define a message and make it dynamic in some of its parts.</p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor073"/>Customizing log message</h2>
<p>The message <a id="_idIndexMarker239"/>field that is asked by the log methods is a simple string object that we can enrich and serialize through the logging frameworks in proper structures. The message is therefore essential to identify malfunctions and errors, and inserting objects in it can significantly help us to identify the problem:</p>
<pre class="source-code">
string apples = "apples";
string pears = "pears";
string bananas = "bananas";
logger.LogInformation("My fruit box has: {pears}, {bananas}, {apples}", apples, pears, bananas);</pre>
<p>The message template contains placeholders that interpolate content into the textual message.</p>
<p>In addition to the text, it is necessary to pass the arguments to replace the placeholders. Therefore, the order of the parameters is valid but not the name of the placeholders for the substitution.</p>
<p>The result then considers the positional parameters and not the placeholder names:</p>
<pre class="source-code">
My fruit box has: apples, pears, bananas</pre>
<p>Now you know how to customize log messages. Next, let us learn about infrastructure logging, which is essential while working in more complex scenarios.</p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor074"/>Infrastructure logging</h2>
<p>In this section, we <a id="_idIndexMarker240"/>want to tell you about a little-known and little-used theme within <a id="_idIndexMarker241"/>ASP.NET applications: the <strong class="bold">W3C log</strong>. </p>
<p>This log is a standard that is used by all web servers, not only <strong class="bold">Internet Information Services</strong> (<strong class="bold">IIS</strong>). It <a id="_idIndexMarker242"/>also works on NGINX and many other web servers and can be used on Linux, too. It is also used to trace various requests. However, the log cannot understand what happened inside the call.</p>
<p>Thus, this feature focuses on the infrastructure, that is, how many calls are made and to which endpoint.</p>
<p>In this section, we <a id="_idIndexMarker243"/>will see how to enable tracking, which, by default, is stored on a file. The functionality takes a little time to find but enables more complex scenarios<a id="_idIndexMarker244"/> that must be managed with appropriate practices and tools, such as <strong class="bold">OpenTelemetry</strong>.</p>
<p class="callout-heading">OpenTelemetry</p>
<p class="callout">OpenTelemetry is a collection of tools, APIs, and SDKs. We use it to instrument, generate, collect, and export telemetry data (metrics, logs, and traces) to help analyze software performance and <a id="_idIndexMarker245"/>behavior. You can learn more at the OpenTelemetry official website: <a href="https://opentelemetry.io/">https://opentelemetry.io/</a>.</p>
<p>To configure W3C logging, you need to register the <strong class="source-inline">AddW3CLogging</strong> method and configure all available options. </p>
<p>To enable logging, you only need to add <strong class="source-inline">UseW3CLogging</strong>. </p>
<p>The writing of the log does not change; the two methods enable the scenario just described and start writing data to the W3C log standard:</p>
<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddW3CLogging(logging =&gt;
{
    logging.LoggingFields = W3CLoggingFields.All;
});
var app = builder.Build();
app.UseW3CLogging();
app.MapGet("/first-w3c-log", (IWebHostEnvironment webHostEnvironment) =&gt;
{
    return Results.Ok(new { PathToWrite = 
      webHostEnvironment.ContentRootPath });
})
.WithName("GetW3CLog");</pre>
<p>We report the header of the file that is created (the headers of the information will be tracked later):</p>
<pre class="source-code">
#Version: 1.0
#Start-Date: 2022-01-03 10:34:15
#Fields: date time c-ip cs-username s-computername s-ip s-port cs-method cs-uri-stem cs-uri-query sc-status time-taken cs-version cs-host cs(User-Agent) cs(Cookie) cs(Referer)</pre>
<p>We’ve seen <a id="_idIndexMarker246"/>how to track information about the infrastructure hosting our application; now, we want to increase log performance with new features in .NET 6 that help us set up standard log messages and avoid errors.</p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor075"/>Source generators</h2>
<p>One of the <a id="_idIndexMarker247"/>novelties of .NET 6 is the source generators; they are performance optimization tools that generate executable code at compile time. The creation of <a id="_idIndexMarker248"/>executable code at compile time, therefore, generates an increase in performance. During the execution phase of the program, all structures are comparable to code written by the programmer before compilation.</p>
<p>String interpolation using <strong class="source-inline">$””</strong> is generally great, and it makes for much more readable code than <strong class="source-inline">string.Format()</strong>, but you should almost <em class="italic">never</em> use it when writing log messages:</p>
<pre class="source-code">
logger.LogInformation($"I'm {person.Name}-{person.Surname}")</pre>
<p>The output of this method to the Console will be the same when using string interpolation or structural logging, but there are several problems:</p>
<ul>
<li>You lose the <em class="italic">structured</em> logs and you won’t be able to filter by the format values or archive the log message in the custom field of NoSQL products.</li>
<li>Similarly, you no longer have a constant <em class="italic">message template</em> to find all identical logs.</li>
<li>The serialization of the person is done ahead of time before the string is passed into <strong class="source-inline">LogInformation</strong>.</li>
<li>The serialization is done even though the log filter is not enabled. To avoid processing the log, it is necessary to check whether the layer is active, which would make the code much less readable.</li>
</ul>
<p>Let us say<a id="_idIndexMarker249"/> you decide to update the log message to include <strong class="source-inline">Age</strong> to clarify why the log is being written:</p>
<pre class="source-code">
logger.LogInformation("I'm {Name}-{Surname} with {Age}", person.Name, person.Surname);</pre>
<p>In the previous <a id="_idIndexMarker250"/>code snippet, I added <strong class="source-inline">Age</strong> in the message template but not in the method signature. At compile time, there is no compile-time error, but when this line is executed, an exception is thrown due to the lack of a third parameter.</p>
<p><strong class="source-inline">LoggerMessage</strong> in .NET 6 comes to our rescue, automatically generating the code to log the necessary data. The methods will require the correct number of parameters and the text will be formatted in a standard way.</p>
<p>To use the <strong class="source-inline">LoggerMessage</strong> syntax, you can take advantage of a partial class or a static class. Inside the class, it will be possible to define the method or methods with all the various log cases:</p>
<pre class="source-code">
public partial class LogGenerator
    {
        private readonly ILogger&lt;LogGeneratorCategory&gt; 
          _logger;
        public LogGenerator(ILogger&lt;LogGeneratorCategory&gt;
          logger)
        {
            _logger = logger;
        }
        [LoggerMessage(
            EventId = 100,
            EventName = "Start",
            Level = LogLevel.Debug,
            Message = "Start Endpoint: {endpointName} with
              data {dataIn}")]
        public partial void StartEndpointSignal(string 
          endpointName, object dataIn);
        [LoggerMessage(
           EventId = 101,
           EventName = "StartFiltered",
           Message = "Log level filtered: {endpointName} 
             with data {dataIn}")]
        public partial void LogLevelFilteredAtRuntime(
          LogLevel, string endpointName, object dataIn);
    }
    public class LogGeneratorCategory { }</pre>
<p>In the previous<a id="_idIndexMarker251"/> example, we created a partial class, injected the logger and its category, and implemented two methods. The methods are used in the <a id="_idIndexMarker252"/>following code: </p>
<pre class="source-code">
app.MapPost("/start-log", (PostData data, LogGenerator logGenerator) =&gt;
{
    logGenerator.StartEndpointSignal("start-log", data);
    logGenerator.LogLevelFilteredAtRuntime(LogLevel.Trace,
      "start-log", data);
})
.WithName("StartLog");
internal record PostData(DateTime Date, string Name);</pre>
<p>Notice how in the<a id="_idIndexMarker253"/> second method, we also have the possibility to define the log level at runtime.</p>
<p>Behind the scenes, the <strong class="source-inline">[LoggerMessage]</strong> source generator generates the <strong class="source-inline">LoggerMessage.Define()</strong> code to optimize your method call. The following output shows the generated code:</p>
<pre class="source-code">
[global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "6.0.5.2210")]
        public partial void LogLevelFilteredAtRuntime(
          global::Microsoft.Extensions.Logging.LogLevel 
          logLevel, global::System.String endpointName,
          global::System.Object dataIn)
        {
            if (_logger.IsEnabled(logLevel))
            {
                _logger.Log(
                    logLevel,
                    new global::Microsoft.Extensions.
                     Logging.EventId(101, "StartFiltered"),
                    new __LogLevelFilteredAtRuntimeStruct(
                      endpointName, dataIn),
                    null,
                      __LogLevelFilteredAtRuntimeStruct.
                          Format);
            }
        }</pre>
<p>In this section, you<a id="_idIndexMarker254"/> have learned about some logging providers, different log levels, how to configure them, what parts of the message template to <a id="_idIndexMarker255"/>modify, enabling logging, and the benefits of source generators. In the next section, we will focus more on logging providers.</p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor076"/>Leveraging the logging framework</h1>
<p>The logging framework, as<a id="_idIndexMarker256"/> mentioned at the beginning of the chapter, already has by design a series of providers that do not require adding any additional packages. Now, let us explore how to work with these providers and how to build custom ones. We will analyze only the Console log provider because it has all the sufficient elements to replicate the same reasoning on other log providers.</p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor077"/>Console log</h2>
<p>The <strong class="source-inline">Console</strong> log <a id="_idIndexMarker257"/>provider is the most used one because, during<a id="_idIndexMarker258"/> the development, it gives us a lot of information and collects all the application errors.</p>
<p>Since .NET 6, this provider has been joined by the <strong class="source-inline">AddJsonConsole</strong> provider, which, besides tracing the errors like the console, serializes them in a JSON object readable by the human eye.</p>
<p>In the following example, we show how to configure the <strong class="source-inline">JsonConsole</strong> provider and also add indentation when writing the JSON payload:</p>
<pre class="source-code">
builder.Logging.AddJsonConsole(options =&gt;
        options.JsonWriterOptions = new JsonWriterOptions()
        {
            Indented = true
        });</pre>
<p>As we’ve seen in the previous examples, we’re going to track the information with the message template:</p>
<pre class="source-code">
app.MapGet("/first-log", (ILogger&lt;CategoryFiltered&gt; loggerCategory, ILogger&lt;MyCategoryAlert&gt; loggerAlertCategory) =&gt;
{
    loggerCategory.LogInformation("I'm information 
      {MyName}", "My Name Information");
    loggerCategory.LogDebug("I'm debug {MyName}",
      "My Name Debug");
    loggerCategory.LogInformation("I'm debug {Data}", 
      new PayloadData("CategoryRoot", "Debug"));
    loggerAlertCategory.LogInformation("I'm information 
      {MyName}", "Alert Information");
    loggerAlertCategory.LogDebug("I'm debug {MyName}",
      "Alert Debug");
    var p = new PayloadData("AlertCategory", "Debug");
    loggerAlertCategory.LogDebug("I'm debug {Data}", p);
    return Results.Ok();
})
.WithName("GetFirstLog");</pre>
<p>Finally, an <a id="_idIndexMarker259"/>important note: the <strong class="source-inline">Console</strong> and <strong class="source-inline">JsonConsole</strong> providers <a id="_idIndexMarker260"/>do not serialize objects passed via the message template but only write the class name.</p>
<pre class="source-code">
var p = new PayloadData("AlertCategory", "Debug");
loggerAlertCategory.LogDebug("I'm debug {Data}", p);</pre>
<p>This is <a id="_idIndexMarker261"/>definitely a limitation of providers. Thus, we suggest using structured logging <a id="_idIndexMarker262"/>tools such<a id="_idIndexMarker263"/> as <strong class="bold">NLog</strong>, <strong class="bold">log4net</strong>, and <strong class="bold">Serilog</strong>, which we will talk about shortly.</p>
<p>We present <a id="_idIndexMarker264"/>the outputs of the previous lines with the two providers <a id="_idIndexMarker265"/>just described: </p>
<div>
<div class="IMG---Figure" id="_idContainer039">
<img alt="Figure 5.1 – AddJsonConsole output " height="1220" src="image/Figure_5.1_B17902.jpg" width="710"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – AddJsonConsole output</p>
<p><em class="italic">Figure 5.1</em> shows the log formatted as JSON, with several additional details compared to the traditional<a id="_idIndexMarker266"/> console log.</p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<img alt="Figure 5.2 – Default logging provider Console output " height="510" src="image/Figure_5.2_B17902.jpg" width="999"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Default logging provider Console output</p>
<p><em class="italic">Figure 5.2</em> shows<a id="_idIndexMarker267"/> the default logging provider Console output. </p>
<p>Given the default providers, we want to show you how you can create a custom one that fits the needs of your application.</p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor078"/>Creating a custom provider</h2>
<p>The logging framework designed by Microsoft <a id="_idIndexMarker268"/>can be customized<a id="_idIndexMarker269"/> with little effort. Thus, let us learn how to create a <strong class="bold">custom provider</strong>. </p>
<p>Why create a custom provider? Well, put simply, to not have dependencies with logging libraries and to better manage the performance of the application. Finally, it also encapsulates some custom logic of your specific scenario and makes your code more manageable and readable.</p>
<p>In the following example, we have simplified the usage scenario to show you the minimum components needed to create a working logging provider for profit.</p>
<p>One of the <a id="_idIndexMarker270"/>fundamental parts of a provider is the ability to configure its behavior. Let us create a class that can <a id="_idIndexMarker271"/>be customized at application startup or retrieve information from <strong class="source-inline">appsettings</strong>.</p>
<p>In our example, we define a fixed <strong class="source-inline">EventId</strong> to verify a daily rolling file logic and a path of where to write the file:</p>
<pre class="source-code">
public class FileLoggerConfiguration
{
        public int EventId { get; set; }
        public string PathFolderName { get; set; } = 
          "logs";
        public bool IsRollingFile { get; set; }
}</pre>
<p>The custom provider we are writing will be responsible for writing the log information to a text file. We achieve this by implementing the log class, which we call <strong class="source-inline">FileLogger</strong>, which implements the <strong class="source-inline">ILogger</strong> interface.</p>
<p>In the class logic, all we do is implement the log method and check which file to put the information in.</p>
<p>We put the directory verification in the next file, but it’s more correct to put all the control logic in this method. We also need to make sure that the log method does not throw exceptions at the application level. The logger should never affect the stability of the application:</p>
<pre class="source-code">
    public class FileLogger : ILogger
    {
        private readonly string name;
        private readonly Func&lt;FileLoggerConfiguration&gt; 
          getCurrentConfig;
        public FileLogger(string name,
          Func&lt;FileLoggerConfiguration&gt; getCurrentConfig)
        {
            this.name = name;
            this.getCurrentConfig = getCurrentConfig;
        }
        public IDisposable BeginScope&lt;TState&gt;(TState state)
          =&gt; default!;
        public bool IsEnabled(LogLevel logLevel) =&gt; true;
        public void Log&lt;TState&gt;(LogLevel logLevel, EventId
          , TState state, Exception? exception, 
          Func&lt;TState, Exception?, string&gt; formatter)
        {
            if (!IsEnabled(logLevel))
            {
                return;
            }
            var config = getCurrentConfig();
            if (config.EventId == 0 || config.EventId ==
                eventId.Id)
            {
                string line = $"{name} - {formatter(state,
                  exception)}";
                string fileName = config.IsRollingFile ? 
                  RollingFileName : FullFileName;
                string fullPath = Path.Combine(
                  config.PathFolderName, fileName);
                File.AppendAllLines(fullPath, new[] { line });
            }
        }
        private static string RollingFileName =&gt; 
          $"log-{DateTime.UtcNow:yyyy-MM-dd}.txt";
        private const string FullFileName = "logs.txt";
    }</pre>
<p>Now, we need<a id="_idIndexMarker272"/> to implement the <strong class="source-inline">ILoggerProvider</strong> interface, which is intended to create one or more instances of the logger <a id="_idIndexMarker273"/>class just discussed.</p>
<p>In this class, we check the directory we mentioned in the previous paragraph, but we also check whether the settings in the <strong class="source-inline">appsettings</strong> file change, via <strong class="source-inline">IOptionsMonitor&lt;T&gt;</strong>:</p>
<pre class="source-code">
public class FileLoggerProvider : ILoggerProvider
{
    private readonly IDisposable onChangeToken;
    private FileLoggerConfiguration currentConfig;
    private readonly ConcurrentDictionary&lt;string,
      FileLogger&gt; _loggers = new();
    public FileLoggerProvider(
      IOptionsMonitor&lt;FileLoggerConfiguration&gt; config)
    {
        currentConfig = config.CurrentValue;
        CheckDirectory();
        onChangeToken = config.OnChange(updateConfig =&gt;
        {
            currentConfig = updateConfig;
            CheckDirectory();
        });
    }
    public ILogger CreateLogger(string categoryName)
    {
        return _loggers.GetOrAdd(categoryName, name =&gt; new 
          FileLogger(name, () =&gt; currentConfig));
    }
    public void Dispose()
    {
        _loggers.Clear();
        onChangeToken.Dispose();
    }
    private void CheckDirectory()
    {
        if (!Directory.Exists(currentConfig.PathFolderName))
            Directory.CreateDirectory(currentConfig.
            PathFolderName);
    }
}</pre>
<p>Finally, to simplify<a id="_idIndexMarker274"/> its use and configuration <a id="_idIndexMarker275"/>during the application startup phase, we also define an extension method for registering the various classes just mentioned.</p>
<p>The <strong class="source-inline">AddFile</strong> method will register <strong class="source-inline">ILoggerProvider</strong> and couple it to its configuration (very simple as an example, but it encapsulates several aspects of configuring and using a custom provider):</p>
<pre class="source-code">
public static class FileLoggerExtensions
    {
        public static ILoggingBuilder AddFile(
        this ILoggingBuilder builder)
        {
            builder.AddConfiguration();
           builder.Services.TryAddEnumerable(
             ServiceDescriptor.Singleton&lt;ILoggerProvider,
             FileLoggerProvider&gt;());
            LoggerProviderOptions.RegisterProviderOptions&lt;
              FileLoggerConfiguration, FileLoggerProvider&gt;
              (builder.Services);
            return builder;
        }
        public static ILoggingBuilder AddFile(
            this ILoggingBuilder builder,
            Action&lt;FileLoggerConfiguration&gt; configure)
        {
            builder.AddFile();
            builder.Services.Configure(configure);
            return builder;
        }
    }</pre>
<p>We record <a id="_idIndexMarker276"/>everything seen in the <strong class="source-inline">Program.cs</strong> file <a id="_idIndexMarker277"/>with the <strong class="source-inline">AddFile</strong> extension as shown:</p>
<pre class="source-code">
builder.Logging.AddFile(configuration =&gt;
{
    configuration.PathFolderName = Path.Combine(
      builder.Environment.ContentRootPath, "logs");
    configuration.IsRollingFile = true;
});</pre>
<p>The output is shown in <em class="italic">Figure 5.3</em>, where we can see both Microsoft log categories in the first five lines (this is the classic application startup information):</p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<img alt="Figure 5.3 – File log provider output " height="449" src="image/Figure_5.3_B17902.jpg" width="1488"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – File log provider output</p>
<p>Then, the <a id="_idIndexMarker278"/>handler of the minimal APIs that we reported in the previous sections is called. As you can see, no exception data or data passed to the logger is serialized.</p>
<p>To add this<a id="_idIndexMarker279"/> functionality as well, it is necessary to rewrite <strong class="source-inline">ILogger formatter</strong> and support serialization of the object. This will give you everything you need to have in a useful logging framework for production scenarios.</p>
<p>We’ve seen how to configure the log and how to customize the provider object to create a structured log to send to a service or storage. </p>
<p>In the next section, we want to describe the Azure Application Insights service, which is very useful for both logging and application monitoring.</p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor079"/>Application Insights </h2>
<p>In addition<a id="_idIndexMarker280"/> to the already seen providers, one of<a id="_idIndexMarker281"/> the most used ones is <strong class="bold">Azure Application Insights</strong>. This provider allows you to send every single log event in the Azure service. In order to insert the provider into our project, all we would have to do is install the following NuGet package:</p>
<pre class="source-code">
&lt;PackageReference Include="Microsoft.ApplicationInsights.AspNetCore" Version="2.20.0" /&gt;</pre>
<p>Registering the provider is very easy. </p>
<p>We first register <a id="_idIndexMarker282"/>the Application Insights framework, <strong class="source-inline">AddApplicationInsightsTelemetry</strong>, and then register its extension on the <strong class="source-inline">AddApplicationInsights</strong> logging framework.</p>
<p>In the NuGet package previously described, the one for logging the component to the logging framework is also present as a reference:</p>
<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddApplicationInsightsTelemetry();
builder.Logging.AddApplicationInsights();</pre>
<p>To register the<a id="_idIndexMarker283"/> instrumentation key, which is the key that is issued after registering the service on Azure, you will need to pass this information to the registration method. We can avoid hardcoding this information by placing it in the <strong class="source-inline">appsettings.json</strong> file using the following format: </p>
<pre class="source-code">
"ApplicationInsights": {
    "InstrumentationKey": "your-key"
  },</pre>
<p>This process is also described in the documentation (<a href="https://docs.microsoft.com/it-it/azure/azure-monitor/app/asp-net-core#enable-application-insights-server-side-telemetry-no-visual-studio">https://docs.microsoft.com/it-it/azure/azure-monitor/app/asp-net-core#enable-application-insights-server-side-telemetry-no-visual-studio</a>).</p>
<p>By launching the method already discussed in the previous sections, we have all the information hooked into Application Insights.</p>
<p>Application Insights groups the logs under a particular trace. A trace is a call to an API, so everything that happens in that call is logically grouped together. This feature takes advantage of the <strong class="source-inline">WebServer</strong> information and, in particular, <strong class="source-inline">TraceParentId</strong> issued by the W3C standard for each call.</p>
<p>In this way, Application Insights can bind calls between various minimal APIs, should we be in a microservice application or with multiple services collaborating with each other.</p>
<div>
<div class="IMG---Figure" id="_idContainer042">
<img alt="Figure 5.4 – Application Insights with a standard log provider " height="960" src="image/Figure_5.4_B17902.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – Application Insights with a standard log provider</p>
<p>We notice how the default<a id="_idIndexMarker284"/> formatter of the logging framework <a id="_idIndexMarker285"/>does not serialize the <strong class="source-inline">PayloadData</strong> object but only writes the text of the object.</p>
<p>In the applications that we will bring into production, it will be necessary to also trace the serialization of the objects. Understanding the state of the object on time is fundamental to analyzing the errors that occurred during a particular call while running queries in the database or reading the data read from the same.</p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor080"/>Storing a structured log with Serilog</h1>
<p>As we just <a id="_idIndexMarker286"/>discussed, tracking <a id="_idIndexMarker287"/>structured <a id="_idIndexMarker288"/>objects in the log helps us tremendously in understanding errors. </p>
<p>We, therefore, suggest one of the many logging frameworks: <strong class="bold">Serilog</strong>.</p>
<p>Serilog is a comprehensive library that has <a id="_idIndexMarker289"/>many <strong class="bold">sinks</strong> already written that allow you to store log data and search it later.</p>
<p>Serilog is a logging library that allows you to track information on multiple data sources. In Serilog, these sources are called sinks, and they allow you to write structured data inside the log applying a serialization of the data passed to the logging system. </p>
<p>Let’s see how to <a id="_idIndexMarker290"/>get started using Serilog for a minimal API application. Let’s install these NuGet packages. Our goal will be to track the same information we’ve been <a id="_idIndexMarker291"/>using so far, specifically <strong class="source-inline">Console</strong> and <strong class="source-inline">ApplicationInsights</strong>: </p>
<pre class="source-code">
&lt;PackageReference Include="Microsoft.ApplicationInsights.AspNetCore" Version="2.20.0" /&gt;
&lt;PackageReference Include="Serilog.AspNetCore" Version="4.1.0" /&gt;
&lt;PackageReference Include="Serilog.Settings.Configuration" Version="3.3.0" /&gt;
&lt;PackageReference Include="Serilog.Sinks.ApplicationInsights" Version="3.1.0" /&gt;</pre>
<p>The first package is the one needed for the <strong class="source-inline">ApplicationInsights</strong> SDK in the application. The second package allows us to register Serilog in the ASP.NET pipeline and to be able to exploit Serilog. The third package allows us to configure the framework in the <strong class="source-inline">appsettings</strong> file and not have to rewrite the application to change a parameter or code. Finally, we have the package to add the <strong class="source-inline">ApplicationInsights</strong> sink.</p>
<p>In the <strong class="source-inline">appsettings</strong> file, we create a new <strong class="source-inline">Serilog</strong> section, in which we should register the various sinks in the <strong class="source-inline">Using</strong> section. We register the log level, the sinks, the enrichers that enrich the information for each event, and the properties, such as the application name:</p>
<pre class="source-code">
"Serilog": {
    "Using": [ "Serilog.Sinks.Console",
      "Serilog.Sinks.ApplicationInsights" ],
    "MinimumLevel": "Verbose",
    "WriteTo": [
      { "Name": "Console" },
      {
        "Name": "ApplicationInsights",
        "Args": {
          "restrictedToMinimumLevel": "Information",
          "telemetryConverter": "Serilog.Sinks.
           ApplicationInsights.Sinks.ApplicationInsights.
           TelemetryConverters.TraceTelemetryConverter, 
           Serilog.Sinks.ApplicationInsights"
        }
      }
    ],
    "Enrich": [ "FromLogContext"],   
    "Properties": {
      "Application": "MinimalApi.Packt"
    }
  }</pre>
<p>Now, we just <a id="_idIndexMarker292"/>have <a id="_idIndexMarker293"/>to register <strong class="source-inline">Serilog</strong> in the ASP.NET pipeline: </p>
<pre class="source-code">
using Microsoft.ApplicationInsights.Extensibility;
using Serilog;
var builder = WebApplication.CreateBuilder(args);
builder.Logging.AddSerilog();
builder.Services.AddApplicationInsightsTelemetry();
var app = builder.Build();
Log.Logger = new LoggerConfiguration()
.WriteTo.ApplicationInsights(app.Services.GetRequiredService&lt;TelemetryConfiguration&gt;(), TelemetryConverter.Traces)
.CreateLogger();</pre>
<p>With the <strong class="source-inline">builder.Logging.AddSerilog()</strong> statement, we register Serilog with the logging framework<a id="_idIndexMarker294"/> to which all logged events will be passed with the usual <strong class="source-inline">ILogger</strong> interface. Since the framework needs to register the <strong class="source-inline">TelemetryConfiguration</strong> class to register <strong class="source-inline">ApplicationInsights</strong>, we are forced to hook the configuration to the static <strong class="source-inline">Logger</strong> object of Serilog. This is all because<a id="_idIndexMarker295"/> Serilog will turn the information from the Microsoft logging framework over to the Serilog framework and add all the necessary information.</p>
<p>The usage is very similar to the previous one, but this time, we add an <strong class="source-inline">@</strong> (at) to the message template that will tell Serilog to serialize the sent object.</p>
<p>With this very simple <strong class="source-inline">{@Person}</strong> wording, we will be able to achieve the goal of serializing the object and sending it to the <strong class="source-inline">ApplicationInsights</strong> service:</p>
<pre class="source-code">
app.MapGet("/serilog", (ILogger&lt;CategoryFiltered&gt; loggerCategory) =&gt;
{
    loggerCategory.LogInformation("I'm {@Person}", new
      Person("Andrea", "Tosato", new DateTime(1986, 11, 
      9)));
    return Results.Ok();
})
.WithName("GetFirstLog");
internal record Person(string Name, string Surname, DateTime Birthdate);</pre>
<p>Finally, we have to find the <a id="_idIndexMarker296"/>complete data, serialized with the <a id="_idIndexMarker297"/>JSON format, in the Application Insights service.</p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<img alt="Figure 5.5 – Application Insights with structured data " height="1136" src="image/Figure_5.5_B17902.jpg" width="1659"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – Application Insights with structured data</p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor081"/>Summary</h1>
<p>In this chapter, we have seen several logging aspects of the implementation of minimal APIs. </p>
<p>We started to appreciate the ASP.NET churned logging framework, and we understood how to configure and customize it. We focused on how to define a message template and how to avoid errors with the source generator. </p>
<p>We saw how to use the new provider to serialize logs with the JSON format and create a custom provider. These elements turned out to be very important for mastering the logging tool and customizing it to your liking. </p>
<p>Not only was the application log mentioned but also the infrastructure log, which together with Application Insights becomes a key element to monitoring your application. Finally, we understood that there are ready-made tools, such as Serilog, that help us to have ready-to-use functionalities with a few steps thanks to some packages installed by NuGet.</p>
<p>In the next chapter, we will present the mechanisms for validating an input object to the API. This is a fundamental feature to return a correct error to the calls and discard inaccurate requests or those promoted by illicit activities such as spam and attacks, aimed at generating load on our servers.</p>
</div>
</div></body></html>