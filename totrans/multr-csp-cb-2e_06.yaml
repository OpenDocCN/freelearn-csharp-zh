- en: Chapter 6. Using Concurrent Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。使用并发集合
- en: 'In this chapter, we will look through the different data structures for concurrent
    programming included in the .NET Framework base class library. You will learn
    the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将查看 .NET Framework 基类库中包含的用于并发编程的不同数据结构。你将学习以下食谱：
- en: Using `ConcurrentDictionary`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ConcurrentDictionary`
- en: Implementing asynchronous processing using `ConcurrentQueue`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ConcurrentQueue` 实现异步处理
- en: Changing the asynchronous processing order with `ConcurrentStack`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ConcurrentStack` 改变异步处理顺序
- en: Creating a scalable crawler with `ConcurrentBag`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ConcurrentBag` 创建可扩展的爬虫
- en: Generalizing asynchronous processing with `BlockingCollection`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `BlockingCollection` 泛化异步处理
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Programming requires understanding and knowledge of basic data structures and
    algorithms. To choose the best-suited data structure for a concurrent situation,
    a programmer has to know about many things, such as algorithm time, space complexity,
    and the big O notation. In different, well-known scenarios, we always know which
    data structures are more efficient.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 编程需要理解和掌握基本数据结构和算法。为了选择最适合并发情况的数据结构，程序员必须了解许多事情，例如算法的时间复杂度、空间复杂度和大O符号。在不同的、众所周知的情况下，我们总是知道哪些数据结构更有效。
- en: For concurrent computations, we need to have appropriate data structures. These
    data structures have to be scalable, avoid locks when possible, and at the same
    time provide thread-safe access. .NET Framework, since version 4, has the `System.Collections.Concurrent`
    namespace with several data structures in it. In this chapter, we will cover several
    data structures and show you very simple examples of how to use them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于并发计算，我们需要有适当的数据结构。这些数据结构必须是可扩展的，尽可能避免使用锁，并且同时提供线程安全访问。自版本 4 以来，.NET Framework
    中的 `System.Collections.Concurrent` 命名空间包含几个数据结构。在本章中，我们将介绍几个数据结构，并展示如何使用它们的非常简单的示例。
- en: Let's start with `ConcurrentQueue`. This collection uses atomic **Compare and
    Swap** (**CAS**) operations, which allow us to safely exchange values of two variables,
    and `SpinWait` to ensure thread safety. It implements a **First In, First Out**
    (**FIFO**) collection, which means that the items go out of the queue in the same
    order in which they were added to the queue. To add an item to a queue, you call
    the `Enqueue` method. The `TryDequeue` method tries to take the first item from
    the queue, and the `TryPeek` method tries to get the first item without removing
    it from the queue.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `ConcurrentQueue` 开始。这个集合使用原子的 **比较和交换** (**CAS**) 操作，这允许我们安全地交换两个变量的值，并使用
    `SpinWait` 来确保线程安全。它实现了一个 **先进先出** (**FIFO**) 集合，这意味着项目从队列中退出的顺序与它们被添加到队列中的顺序相同。要将项目添加到队列中，你调用
    `Enqueue` 方法。`TryDequeue` 方法尝试从队列中取出第一个项目，而 `TryPeek` 方法尝试获取第一个项目而不从队列中移除它。
- en: The `ConcurrentStack` collection is also implemented without using any locks
    and only with CAS operations. This is the **Last In, First Out** (**LIFO**) collection,
    which means that the most recently added item will be returned first. To add items,
    you can use the `Push` and `PushRange` methods; to retrieve, you use `TryPop`
    and `TryPopRange`, and to inspect, you can use the `TryPeek` method.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentStack` 集合也是在不使用任何锁的情况下，仅通过 CAS 操作实现的。这是一个 **后进先出** (**LIFO**) 集合，这意味着最近添加的项目将首先被返回。要添加项目，你可以使用
    `Push` 和 `PushRange` 方法；要检索，你使用 `TryPop` 和 `TryPopRange`，要检查，你可以使用 `TryPeek` 方法。'
- en: The `ConcurrentBag` collection is an unordered collection that supports duplicate
    items. It is optimized for a scenario where multiple threads partition their work
    in such a way that each thread produces and consumes its own tasks, dealing with
    other threads' tasks very rarely (in which case, it uses locks). You add items
    to a bag using the `Add` method; you inspect with `TryPeek`, and take items from
    a bag with the `TryTake` method.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentBag` 集合是一个无序集合，支持重复项。它针对的场景是多个线程以这种方式划分他们的工作，即每个线程产生并消费自己的任务，很少处理其他线程的任务（在这种情况下，它使用锁）。你使用
    `Add` 方法向袋子中添加项目；使用 `TryPeek` 检查，使用 `TryTake` 方法从袋子中取出项目。'
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Avoid using the `Count` property on the collections mentioned. They are implemented
    using linked lists, and therefore, `Count` is an `O(N)` operation. If you need
    to check whether the collection is empty, use the `IsEmpty` property, which is
    an `O(1)` operation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在提到的集合上使用 `Count` 属性。它们使用链表实现，因此 `Count` 是一个 `O(N)` 操作。如果你需要检查集合是否为空，请使用 `IsEmpty`
    属性，这是一个 `O(1)` 操作。
- en: '`ConcurrentDictionary` is a thread-safe dictionary collection implementation.
    It is lock-free for read operations. However, it requires locking for write operations.
    The concurrent dictionary uses multiple locks, implementing a fine-grained locking
    model over the dictionary buckets. The number of locks could be defined using
    a constructor with the `concurrencyLevel` parameter, which means that an estimated
    number of threads will update the dictionary concurrently.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentDictionary` 是一个线程安全的字典集合实现。它在读取操作上是无锁的。然而，它需要锁定进行写入操作。并发字典使用多个锁，在字典桶上实现了一个细粒度锁定模型。锁的数量可以通过带有
    `concurrencyLevel` 参数的构造函数来定义，这意味着预计将有多个线程并发更新字典。'
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Since a concurrent dictionary uses locking, there are a number of operations
    that require acquiring all the locks inside the dictionary. These operations are:
    `Count`, `IsEmpty`, `Keys`, `Values`, `CopyTo`, and `ToArray`. Avoid using these
    operations without need.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于并发字典使用锁定，因此有许多操作需要获取字典内部的所有锁。这些操作包括：`Count`、`IsEmpty`、`Keys`、`Values`、`CopyTo`
    和 `ToArray`。避免在没有需要的情况下使用这些操作。
- en: '`BlockingCollection` is an advanced wrapper over the `IProducerConsumerCollection`
    generic interface implementation. It has many features that are more advanced
    and is very useful for implementing pipeline scenarios when you have some steps
    that use the results from processing the previous steps. The `BlockingCollection`
    class supports features such as blocking, bounding inner collections capacity,
    canceling collection operations, and retrieving values from multiple blocking
    collections.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlockingCollection` 是对 `IProducerConsumerCollection` 泛型接口实现的先进包装。它具有许多更高级的功能，并且在实现具有一些步骤使用前一步骤处理结果的管道场景时非常有用。`BlockingCollection`
    类支持诸如阻塞、限制内部集合容量、取消集合操作和从多个阻塞集合中检索值等功能。'
- en: The concurrent algorithms can be very complicated, and covering all the concurrent
    collections—whether more or less advanced—would require writing a separate book.
    Here, we illustrate only the simplest examples of using concurrent collections.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 并发算法可能非常复杂，要涵盖所有并发集合——无论是更高级还是不那么高级的——都需要编写一本单独的书。在这里，我们仅展示了使用并发集合的最简单示例。
- en: Using ConcurrentDictionary
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ConcurrentDictionary
- en: This recipe shows you a very simple scenario, comparing the performance of a
    usual dictionary collection with the concurrent dictionary in a single-threaded
    environment.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了在一个单线程环境中，比较常规字典集合与并发字典性能的一个非常简单的场景。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter6\Recipe1`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个配方，你需要 Visual Studio 2015。没有其他先决条件。这个配方的源代码可以在 `BookSamples\Chapter6\Recipe1`
    中找到。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To understand the difference between the performance of a usual dictionary
    collection and the concurrent dictionary, perform the following steps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解常规字典集合与并发字典性能之间的差异，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加以下 `using` 指令：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下方添加以下代码片段：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内添加以下代码片段：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run the program.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the program starts, we create two collections. One of them is a standard
    dictionary collection, and the other is a new concurrent dictionary. Then, we
    start adding to them, using a standard dictionary with a lock and measuring the
    time it takes for one million iterations to complete. Then, we measure the `ConcurrentDictionary`
    collection's performance in the same scenario, and we finally compare the performance
    of retrieving values from both collections.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序启动时，我们创建了两个集合。其中一个是标准字典集合，另一个是新创建的并发字典。然后，我们开始向它们添加内容，使用带有锁的标准字典，并测量一百万次迭代完成所需的时间。然后，我们在相同场景下测量
    `ConcurrentDictionary` 集合的性能，并最终比较从两个集合中检索值的性能。
- en: In this very simple scenario, we find that `ConcurrentDictionary` is significantly
    slower on write operations than a usual dictionary with a lock but is faster on
    retrieval operations. Therefore, if we need many thread-safe reads from a dictionary,
    the `ConcurrentDictionary` collection is the best choice.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个非常简单的场景中，我们发现`ConcurrentDictionary`在写入操作上比带有锁的普通字典要慢得多，但在检索操作上要快。因此，如果我们需要从字典中进行许多线程安全的读取，`ConcurrentDictionary`集合是最好的选择。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you need just read-only multithreaded access to the dictionary, it may not
    be necessary to perform thread-safe reads. In this scenario, it is much better
    to use just a regular dictionary or the `ReadOnlyDictionary` collections.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要对字典进行只读的多线程访问，可能没有必要执行线程安全的读取。在这种情况下，使用普通的字典或`ReadOnlyDictionary`集合会更好。
- en: The `ConcurrentDictionary` collection is implemented using the **fine-grained
    locking** technique, and this allows it to scale better on multiple writes than
    using a regular dictionary with a lock (which is called **coarse-grained locking**).
    As we saw in this example, when we use just one thread, a concurrent dictionary
    is much slower, but when we scale this up to five-six threads (if we have enough
    CPU cores that could run them simultaneously), the concurrent dictionary will
    actually perform better.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentDictionary`集合使用**细粒度锁定**技术实现，这允许它在多个写入操作上比使用带有锁的普通字典（称为**粗粒度锁定**）有更好的扩展性。正如我们在本例中所看到的，当我们只使用一个线程时，并发字典要慢得多，但当我们将其扩展到五到六个线程（如果我们有足够的CPU核心可以同时运行它们），并发字典实际上会表现得更好。'
- en: Implementing asynchronous processing using ConcurrentQueue
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`ConcurrentQueue`实现异步处理
- en: This recipe will show you an example of creating a set of tasks to be processed
    asynchronously by multiple workers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将向你展示创建一组由多个工作者异步处理的任务的示例。
- en: Getting ready
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter6\Recipe2`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个配方，你需要Visual Studio 2015。没有其他先决条件。这个配方的源代码可以在`BookSamples\Chapter6\Recipe2`中找到。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To understand the working of creating a set of tasks to be processed asynchronously
    by multiple workers, perform the following steps:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解创建一组由多个工作者异步处理的任务的工作原理，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE3]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE4]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内添加以下代码片段：
- en: '[PRE5]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run the program.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the program runs, we create a queue of tasks with an instance of the `ConcurrentQueue`
    collection. Then, we create a cancelation token, which will be used to stop work
    after we are done posting tasks to the queue. Next, we start a separate worker
    thread that will post tasks to the tasks queue. This part produces a workload
    for our asynchronous processing.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，我们使用`ConcurrentQueue`集合的实例创建一个任务队列。然后，我们创建一个取消令牌，在将任务发布到队列后，我们将使用它来停止工作。接下来，我们启动一个单独的工作线程，该线程将任务发布到任务队列。这一部分为我们的异步处理产生工作负载。
- en: Now, let's define a task-consuming part of the program. We create four workers
    that will wait a random time, get a task from the task queue, process it, and
    repeat the whole process until we signal the cancelation token. Finally, we start
    the task-producing thread, wait for its completion, and then signal the consumers
    that we've finished work with the cancelation token. The last step will be to
    wait for all our consumers to complete, to finish processing all tasks.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义程序的任务消费部分。我们创建四个工作者，它们将等待随机的时间，从任务队列中获取任务，处理它，然后重复整个过程，直到我们发出取消令牌的信号。最后，我们启动任务生成线程，等待其完成，然后使用取消令牌通知消费者我们已经完成工作。最后一步将是等待所有消费者完成，以完成所有任务的处理。
- en: We see that we have tasks being processed from start to end, but it is possible
    that a later task will be processed before an earlier one because we have four
    workers running independently and the task processing time is not constant. We
    see that the access to the queue is thread-safe; no work item was taken twice.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到任务从开始到结束都在被处理，但后来任务可能会在早期任务之前被处理，因为我们有四个独立运行的工作者，并且任务处理时间不是恒定的。我们看到对队列的访问是线程安全的；没有工作项被取两次。
- en: Changing asynchronous processing order with ConcurrentStack
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ConcurrentStack 改变异步处理顺序
- en: This recipe is a slight modification of the previous one. We will, once again,
    create a set of tasks to be processed asynchronously by multiple workers, but
    this time, we implement it with `ConcurrentStack` and see the differences.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是对上一个配方的一点点修改。我们再次创建一组要由多个工作者异步处理的任务，但这次我们使用 `ConcurrentStack` 来实现，并观察其中的差异。
- en: Getting ready
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter6\Recipe3`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个配方，你需要 Visual Studio 2015。没有其他先决条件。这个配方的源代码可以在 `BookSamples\Chapter6\Recipe3`
    中找到。
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand the processing of a set of tasks implemented with `ConcurrentStack`,
    perform the following steps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解使用 `ConcurrentStack` 实现的一组任务的处理过程，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加以下 `using` 指令：
- en: '[PRE6]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下方添加以下代码片段：
- en: '[PRE7]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内部添加以下代码片段：
- en: '[PRE8]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the program.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the program runs, we now create an instance of the `ConcurrentStack` collection.
    The rest is almost like in the previous recipe, except instead of using the `Push`
    and `TryPop` methods on the concurrent stack, we use `Enqueue` and `TryDequeue`
    on a concurrent queue.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，我们现在创建一个 `ConcurrentStack` 集合的实例。其余部分几乎与之前的配方相同，只是不再使用并发栈上的 `Push` 和
    `TryPop` 方法，而是在并发队列上使用 `Enqueue` 和 `TryDequeue`。
- en: We now see that the task processing order has been changed. The stack is a LIFO
    collection, and workers process the latter tasks first. In case of a concurrent
    queue, tasks were processed in almost the same order in which they were added.
    This means that by depending on the number of workers, we will surely process
    the task that was created first in a given time frame. In the case of a stack,
    the tasks that were created earlier will have lower priority and may be not processed
    until a producer stops giving more tasks to the stack. This behavior is very specific
    and it is much better to use a queue in this scenario.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到任务处理顺序已经改变。栈是一个后进先出（LIFO）集合，工作者首先处理后面的任务。在并发队列的情况下，任务的处理顺序几乎与它们被添加的顺序相同。这意味着，根据工作者的数量，我们肯定会在给定的时间框架内处理最早创建的任务。在栈的情况下，较早创建的任务优先级较低，可能直到生产者停止向栈提供更多任务之前都不会被处理。这种行为非常特定，在这种情况下使用队列会更好。
- en: Creating a scalable crawler with ConcurrentBag
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ConcurrentBag 创建可扩展的爬虫
- en: This recipe shows you how to scale workload between a number of independent
    workers that both produce work and process it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了如何在不同数量的独立工作者之间扩展工作负载，这些工作者既生产工作又处理工作。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter6\Recipe4`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个配方，你需要 Visual Studio 2015。没有其他先决条件。这个配方的源代码可以在 `BookSamples\Chapter6\Recipe4`
    中找到。
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps demonstrate how to scale workload between a number of independent
    workers that both produce work and process it:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤演示了如何在多个既生产工作又处理工作的独立工作者之间扩展工作负载：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加以下 `using` 指令：
- en: '[PRE9]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下方添加以下代码片段：
- en: '[PRE10]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内部添加以下代码片段：
- en: '[PRE11]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run the program.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The program simulates web page indexing with multiple web crawlers. A web crawler
    is a program that opens a web page by its address, indexes the content, tries
    to visit all the links that this page contains, and indexes these linked pages
    as well. At the beginning, we define a dictionary containing different web-page
    URLs. This dictionary simulates web pages containing links to other pages. The
    implementation is very naive; it does not care about indexing the already visited
    pages, but it is simple and allows us to focus on the concurrent workload.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序通过多个网络爬虫模拟网页索引。网络爬虫是一个通过地址打开网页、索引内容、尝试访问该页面包含的所有链接，并将这些链接页面也进行索引的程序。一开始，我们定义一个包含不同网页URL的字典。这个字典模拟包含指向其他页面链接的网页。实现非常简单；它不考虑索引已访问的页面，但简单且使我们能够专注于并发工作负载。
- en: Then, we create a concurrent bag, containing crawling tasks. We create four
    crawlers and provide a different site root URL to each of them. Then, we wait
    for all crawlers to compete. Now, each crawler starts to index the site URL it
    was given. We simulate the network I/O process by waiting for some random amount
    of time; then, if the page contains more URLs, the crawler posts more crawling
    tasks to the bag. Then, it checks whether there are any tasks left to crawl in
    the bag. If not, the crawler is complete.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个包含爬虫任务的并发袋。我们创建四个爬虫，并为每个爬虫提供一个不同的站点根URL。然后，我们等待所有爬虫完成。现在，每个爬虫开始索引分配给它的站点URL。我们通过等待一些随机的时间来模拟网络I/O过程；然后，如果页面包含更多URL，爬虫会将更多爬虫任务发布到袋中。然后，它检查袋中是否还有待爬取的任务。如果没有，爬虫就完成了。
- en: If we check the output below the first four lines, which are root URLs, we will
    see that usually, which were root URLs, we will see that usually a task posted
    by the crawler number *N* is processed by the same crawler. However, the later
    lines will be different. This happens because internally, `ConcurrentBag` is optimized
    for exactly this scenario where there are multiple threads that both add items
    and remove them. This is achieved by letting each thread work with its own local
    queue of items, and thus, we do not need any locks while this queue is occupied.
    Only when we have no items left in the local queue will we perform some locking
    and try to *steal* the work from another thread's local queue. This behavior helps
    to distribute the work between all workers and avoid locking.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查位于前四行（根URL）下面的输出，通常我们会看到，由爬虫编号*N*发布的任务通常由同一个爬虫处理。然而，后面的行会有所不同。这是因为内部，`ConcurrentBag`针对的就是这种场景，即有多个线程既添加项目又移除项目。这是通过让每个线程使用自己的本地项目队列来实现的，因此，当这个队列被占用时，我们不需要任何锁。只有当我们本地队列中没有项目时，我们才会执行一些锁定操作，并尝试从另一个线程的本地队列中“窃取”工作。这种行为有助于在所有工作者之间分配工作，并避免锁定。
- en: Generalizing asynchronous processing with BlockingCollection
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用BlockingCollection泛化异步处理
- en: This recipe will describe how to use `BlockingCollection` to simplify implementation
    of workload asynchronous processing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将描述如何使用`BlockingCollection`简化工作负载异步处理的实现。
- en: Getting ready
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2015\. No other prerequisites
    are required. The source code for this recipe can be found at `BookSamples\Chapter6\Recipe5`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个食谱，你需要Visual Studio 2015。不需要其他先决条件。本食谱的源代码可以在`BookSamples\Chapter6\Recipe5`中找到。
- en: How to do it...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To understand how `BlockingCollection` simplifies the implementation of workload
    asynchronous processing, perform the following steps:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解`BlockingCollection`如何简化工作负载异步处理的实现，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE12]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE13]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE14]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Run the program.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Here, we take exactly the first scenario, but now, we use a `BlockingCollection`
    class that provides many useful benefits. First of all, we are able to change
    the way the tasks are stored inside the blocking collection. By default, it uses
    a `ConcurrentQueue` container, but we are able to use any collection that implements
    the `IProducerConsumerCollection` generic interface. To illustrate this, we run
    the program twice, using `ConcurrentStack` as the underlying collection the second
    time.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正好采用第一种场景，但现在，我们使用一个提供许多有用功能的`BlockingCollection`类。首先，我们能够改变任务在阻塞集合中存储的方式。默认情况下，它使用`ConcurrentQueue`容器，但我们能够使用任何实现了`IProducerConsumerCollection`泛型接口的集合。为了说明这一点，我们运行程序两次，第二次使用`ConcurrentStack`作为底层集合。
- en: Workers get work items by iterating the `GetConsumingEnumerable` method call
    result on a blocking collection. If there are no items inside the collection,
    the iterator will just block the worker thread until an item is posted to the
    collection. The cycle ends when the producer calls the `CompleteAdding` method
    on the collection. It signals that the work is done.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者通过迭代阻塞集合上`GetConsumingEnumerable`方法调用的结果来获取工作项。如果集合中没有项，迭代器将仅阻塞工作线程，直到有项被发布到集合中。当生产者调用集合上的`CompleteAdding`方法时，循环结束。这表示工作已完成。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is very easy to make a mistake and just iterate `BlockingCollection` as it
    implements `IEnumerable` itself. Do not forget to use `GetConsumingEnumerable`,
    or else, you will just iterate a "snapshot" of a collection and get completely
    unexpected program behavior.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易犯错，直接迭代`BlockingCollection`，因为它本身实现了`IEnumerable`接口。不要忘记使用`GetConsumingEnumerable`，否则，你将仅迭代集合的“快照”，并得到完全意外的程序行为。
- en: The workload producer inserts the tasks into `BlockingCollection` and then calls
    the `CompleteAdding` method, which causes all the workers to get completed. Now,
    in the program output, we see two result sequences illustrating the difference
    between the concurrent queue and stack collections.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 工作负载生产者将任务插入`BlockingCollection`，然后调用`CompleteAdding`方法，这将导致所有工作线程完成。现在，在程序输出中，我们看到两个结果序列，说明了并发队列和堆栈集合之间的差异。
