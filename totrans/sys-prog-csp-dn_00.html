<html><head></head><body>
		<div id="_idContainer005">
			<h1 id="_idParaDest-5"><a id="_idTextAnchor004"/>Preface</h1>
			<p>Most people think of <strong class="bold">graphical user interface</strong> (<strong class="bold">GUI</strong>) applications when they think of software. Software is the code that the user interacts with. But these days, that’s not true anymore. All modern applications, web servers, web applications, and mobile solutions mostly rely on hidden, unseen system software. This is the software that is built for other software. It is dormant until needed, then it does its job and goes back to sleep. These programs are the unsung heroes of our ecosystem, doing the work in the background. At the same time, GUI systems stand in the limelight. However, do not underestimate these hard-working systems: they must be extremely fast, reliable, and safe. Therefore, they are essential to good working systems and are hard to write. This book teaches you all you need to know to write <span class="No-Break">these applications.</span></p>
			<h1 id="_idParaDest-6"><a id="_idTextAnchor005"/>Who this book is for</h1>
			<p>People writing systems software are not junior developers. Ideally, you have a couple of years of experience developing software with C# and .NET. I will not explain what a variable is or how a while-loop differs from a for-loop. You know how to use NuGet. If I ask you to switch from Debug to Release mode in Visual Studio, you know what I am asking you <span class="No-Break">to do.</span></p>
			<p>But I do not expect you to know what instructions a CPU uses. I will explain those when we reach that point in the book. So there is no need to be on that low level <span class="No-Break">just yet.</span></p>
			<p>This book is for people who want to write system software. System software is software that is usually not visible to the regular user. However, it is essential to the good working of the complete software ecosystem running on <span class="No-Break">your systems.</span></p>
			<p>This means that you must have a passion for programs that run fast and are stable. This also means that the software we write is not the easiest to maintain: readability often decreases as performance increases. This is not for the faint-hearted: writing this kind of software is hard-core development. But if you are curious about how your programs really work deep inside the heart of the machine, this is the book <span class="No-Break">for you.</span></p>
			<p>The lessons learned here can, of course, be applied to all sorts of projects. Performance and stability can benefit all programs. So, if you are ready to take your C# and .NET skills to the next level, <span class="No-Break">follow along!</span></p>
			<h1 id="_idParaDest-7"><a id="_idTextAnchor006"/>What this book covers</h1>
			<p><em class="italic">Overview of Systems Programming</em> sets the stage and explains what systems programming is <span class="No-Break">all about.</span></p>
			<p><a href="B20924_02.xhtml#_idTextAnchor026"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">The One with the Low-Level Secrets</em>, dives into the low-level APIs, the BCL and CLR, and how to use <span class="No-Break">Win32 APIs.</span></p>
			<p><a href="B20924_03.xhtml#_idTextAnchor042"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">The One Where Speed Matters</em>, examines how to make your software perform as fast <span class="No-Break">as possible.</span></p>
			<p><a href="B20924_04.xhtml#_idTextAnchor077"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">The One with the Memory Games</em>, talks about memory handling, the garbage collector, and how to be as memory efficient <span class="No-Break">as possible.</span></p>
			<p><a href="B20924_05.xhtml#_idTextAnchor087"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">The One with the Thread Tangles</em>, looks at threads and <span class="No-Break">asynchronous programming.</span></p>
			<p><a href="B20924_06.xhtml#_idTextAnchor111"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">The One with the Filesystem Chronicles </em>, teaches input/output, file handling, encryption, and compression <span class="No-Break">of files.</span></p>
			<p><a href="B20924_07.xhtml#_idTextAnchor140"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">The One Where Processes Whisper</em>, talks about how to make programs communicate on one machine or over <span class="No-Break">a network.</span></p>
			<p><a href="B20924_08.xhtml#_idTextAnchor159"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">The One with the Operating System Tango</em>, dives into the operating system’s services and how to <span class="No-Break">use them.</span></p>
			<p><a href="B20924_09.xhtml#_idTextAnchor181"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">The One with the Network Navigation</em>, discusses everything we need to know about networking in your application, both as a server and <span class="No-Break">a client.</span></p>
			<p><a href="B20924_10.xhtml#_idTextAnchor208"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">The One with the Hardware Handshakes</em>, deals with connecting to outside hardware and communicating with <span class="No-Break">other devices.</span></p>
			<p><a href="B20924_11.xhtml#_idTextAnchor222"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">The One with the Systems Check-Ups</em>, talks about logging and monitoring <span class="No-Break">your software.</span></p>
			<p><a href="B20924_12.xhtml#_idTextAnchor237"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <em class="italic">The One with the Debugging Dances</em>, is all about debugging <span class="No-Break">your software.</span></p>
			<p><a href="B20924_13.xhtml#_idTextAnchor260"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, <em class="italic">The One with the Security Safeguards</em>, talks about the security of <span class="No-Break">your software.</span></p>
			<p><a href="B20924_14.xhtml#_idTextAnchor283"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>, <em class="italic">The One with the Deployment Dramas</em>, teaches you how to deploy your software to the <span class="No-Break">production machines.</span></p>
			<p><a href="B20924_15.xhtml#_idTextAnchor303"><span class="No-Break"><em class="italic">Chapter 14</em></span></a>, <em class="italic">The One with the Linux Leaps</em>, discusses the operating system that most of our software will run <span class="No-Break">on: Linux.</span></p>
			<h1 id="_idParaDest-8"><a id="_idTextAnchor007"/>To get the most out of this book</h1>
			<p>I use Visual Studio 2022 as the main software development tool in this book. It is advisable for you to have a working knowledge of this, including creating console applications, class libraries, and worker services. You do not need to know what a Worker Service is as long as you can create a <span class="No-Break">default one.</span></p>
			<p>Each chapter might have software that you may want to try out. You’ll find the details explained in the <em class="italic">Technical requirements</em> section of the <span class="No-Break">concerned chapter.</span></p>
			<table class="No-Table-Style" id="table001">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Software/hardware covered in </strong><span class="No-Break"><strong class="bold">the book</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Operating </strong><span class="No-Break"><strong class="bold">system requirements</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Visual Studio</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Windows 10 <span class="No-Break">or 11</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p><strong class="bold">If you are using the digital version of this book, we advise you to type the code yourself or access the code from the book’s GitHub repository (a link is available in the next section). Doing so will help you avoid any potential errors related to the copying and pasting </strong><span class="No-Break"><strong class="bold">of code.</strong></span></p>
			<h1 id="_idParaDest-9"><a id="_idTextAnchor008"/>Download the example code files</h1>
			<p>You can download the example code files for this book from GitHub at <a href="https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET">https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET</a>. If there’s an update to the code, it will be updated in the <span class="No-Break">GitHub repository.</span></p>
			<p>We also have other code bundles from our rich catalog of books and videos available at <a href="https://github.com/PacktPublishing/">https://github.com/PacktPublishing/</a>. Check <span class="No-Break">them out!</span></p>
			<h1 id="_idParaDest-10"><a id="_idTextAnchor009"/>Conventions used</h1>
			<p>There are a number of text conventions used throughout <span class="No-Break">this book.</span></p>
			<p><strong class="source-inline">Code in text</strong>: Indicates code words in text, database table names, folder names, filenames, file extensions, pathnames, dummy URLs, user input, and Twitter handles. Here is an example: “ One of them is the <strong class="source-inline">Share</strong> option. We have set it to <span class="No-Break"><strong class="source-inline">FileShare.Delete</strong></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline">"</strong></span></p>
			<p>A block of code is set <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
using var serialPort = new SerialPort(
    "COM3",
    9600,
    Parity.None,
    8,
    StopBits.One);
serialPort.Open();
try
{
    serialPort.Write([42],0, 1);
}
finally
{
    serialPort.Close();
}</pre>			<p>Any command-line input or output is written <span class="No-Break">as follows:</span></p>
			<pre class="console">
docker tag image13workerfordocker:dev localhost:5000/image13workerfordocker:dev</pre>			<p><strong class="bold">Bold</strong>: Indicates a new term, an important word, or words that you see onscreen. For instance, words in menus or dialog boxes appear in <strong class="bold">bold</strong>. Here is an example: “<strong class="bold">Compact object representations</strong>: Sometimes, you can save some memory by smartly combining data into other <span class="No-Break">data structures”.</span></p>
			<p class="callout-heading">Tips or important notes</p>
			<p class="callout">Appear like this.</p>
			<h1 id="_idParaDest-11"><a id="_idTextAnchor010"/>Get in touch</h1>
			<p>Feedback from our readers is <span class="No-Break">always welcome.</span></p>
			<p><strong class="bold">General feedback</strong>: If you have questions about any aspect of this book, email us at <a href="mailto:customercare@packtpub.com">customercare@packtpub.com</a> and mention the book title in the subject of <span class="No-Break">your message.</span></p>
			<p><strong class="bold">Errata</strong>: Although we have taken every care to ensure the accuracy of our content, mistakes do happen. If you have found a mistake in this book, we would be grateful if you would report this to us. Please visit <a href="http://www.packtpub.com/support/errata">www.packtpub.com/support/errata</a> and fill in <span class="No-Break">the form.</span></p>
			<p><strong class="bold">Piracy</strong>: If you come across any illegal copies of our works in any form on the internet, we would be grateful if you would provide us with the location address or website name. Please contact us at <a href="mailto:copyright@packt.com">copyright@packt.com</a> with a link to <span class="No-Break">the material.</span></p>
			<p><strong class="bold">If you are interested in becoming an author</strong>: If there is a topic that you have expertise in and you are interested in either writing or contributing to a book, please <span class="No-Break">visit </span><a href="http://authors.packtpub.com"><span class="No-Break">authors.packtpub.com</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-12"><a id="_idTextAnchor011"/>Share Your Thoughts</h1>
			<p>Once you’ve read <em class="italic">Systems Programming with C# and .NET</em>, we’d love to hear your thoughts! Please <a href="https://packt.link/r/1-835-08268-8">click here to go straight to the Amazon review page</a> for this book and share <span class="No-Break">your feedback.</span></p>
			<p>Your review is important to us and the tech community and will help us make sure we’re delivering excellent <span class="No-Break">quality content.</span></p>
			<h1 id="_idParaDest-13"><a id="_idTextAnchor012"/>Download a free PDF copy of this book</h1>
			<p>Thanks for purchasing <span class="No-Break">this book!</span></p>
			<p>Do you like to read on the go but are unable to carry your print <span class="No-Break">books everywhere?</span></p>
			<p>Is your eBook purchase not compatible with the device of <span class="No-Break">your choice?</span></p>
			<p>Don’t worry, now with every Packt book you get a DRM-free PDF version of that book at <span class="No-Break">no cost.</span></p>
			<p>Read anywhere, any place, on any device. Search, copy, and paste code from your favorite technical books directly into <span class="No-Break">your application.</span></p>
			<p>The perks don’t stop there, you can get exclusive access to discounts, newsletters, and great free content in your <span class="No-Break">inbox daily</span></p>
			<p>Follow these simple steps to get <span class="No-Break">the benefits:</span></p>
			<ol>
				<li>Scan the QR code or visit the <span class="No-Break">link below</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer004">
					<img alt="Download a free PDF copy of this book&#13;&#10;" src="image/B20924_QR_Free_PDF.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><a href="https://packt.link/free-ebook/978-1-83508-268-3">https://packt.link/free-ebook/978-1-83508-268-3</a></p>
			<ol>
				<li value="2">Submit your proof <span class="No-Break">of purchase</span></li>
				<li>That’s it! We’ll send your free PDF and other benefits to your <span class="No-Break">email directly</span></li>
			</ol>
		</div>
	

		<div id="_idContainer012">
			<h1 id="_idParaDest-14"><a id="_idTextAnchor013"/>Overview of  Systems Programming</h1>
			<p>So, you want to learn about <strong class="bold">systems programming</strong> in .NET, using C#. At least, I assume you want to learn that; you probably read the title of this book and decided that this was a good match. Maybe you have dived into systems programming a bit and want to get better at it. Or, perhaps you haven’t touched that subject and want to start. Or, maybe you picked the wrong book. If the latter is the case, I hope you still have your receipt so you can return this book and get something else. For all <span class="No-Break">others: welcome!</span></p>
			<h1 id="_idParaDest-15"><a id="_idTextAnchor014"/>Let’s define systems programming</h1>
			<p>Before we go<a id="_idIndexMarker000"/> into the nitty gritty details of systems programming, we need to set the stage. We need to have a common understanding of a couple of things. For instance, what does the term “systems programming” even mean? What is it for? Who is <span class="No-Break">it for?</span></p>
			<p>Let me get started with <span class="No-Break">a definition.</span></p>
			<p><em class="italic">Systems programming is the programming of systems</em>. That might technically be correct, but I don’t think it helps us <span class="No-Break">move forward.</span></p>
			<p>Let us break it down: what is <span class="No-Break">a </span><span class="No-Break"><em class="italic">system</em></span><span class="No-Break">?</span></p>
			<p>That one is easy. We have <a id="_idIndexMarker001"/>been building systems for ages, so we understand what we mean by <span class="No-Break">a </span><span class="No-Break"><strong class="bold">system</strong></span><span class="No-Break">.</span></p>
			<p>Let me show you <span class="No-Break">one definition:</span></p>
			<p><em class="italic">A system is a set or arrangement of things that are related or connected so as to form a unity or organic whole. It is a collection of components or parts that interact with each other to function. This term is used in various fields such as physics, biology, computer science, and business management, each with slightly </em><span class="No-Break"><em class="italic">different connotations.</em></span></p>
			<p>Great. But this definition is a bit broad. We might want to focus on computer science or software development. No <a id="_idIndexMarker002"/>problem; there are several definitions to choose from <span class="No-Break">as well:</span></p>
			<p><em class="italic">A system is a collection of software components that interact to perform a specific function or set </em><span class="No-Break"><em class="italic">of functions</em></span><span class="No-Break">.</span></p>
			<p>That is a lot better. If we dive into this a bit further, we can distinguish between different groups <span class="No-Break">of systems:</span></p>
			<ul>
				<li><strong class="bold">Software systems</strong>: This is <a id="_idIndexMarker003"/>an integrated set of software components that work together to carry out a specific function or set of functions. Those <a id="_idIndexMarker004"/>components can be a database server, micro-services, and a frontend. Those components form the complete system, such as a CRM system, source control repository system, and others <span class="No-Break">like that.</span></li>
				<li><strong class="bold">Operating systems (OSs)</strong>: You <a id="_idIndexMarker005"/>probably know what an OS is. I think you have seen that term so often that there is a fair chance you didn’t even <a id="_idIndexMarker006"/>realize it is a system. But it most definitely is an OS that contains many parts and components, such as drivers, tools, helpers, and logs. Together, they deliver a system you as a user can use to run your software on, independently of <span class="No-Break">the hardware.</span></li>
				<li><strong class="bold">Distributed systems</strong>: We often<a id="_idIndexMarker007"/> refer to loosely connected components on a network as a distributed system. Each part is isolated from the others, but they must collaborate to achieve something worthwhile. For <a id="_idIndexMarker008"/>example, Azure DevOps runs on many different servers in the Azure cloud. All the components run potentially on different servers and machines, and these components can even be running in different parts of the world. However, they work together to form a complete solution for the <span class="No-Break">end user.</span></li>
				<li><strong class="bold">Embedded systems</strong>: An <a id="_idIndexMarker009"/>embedded system is usually a combination <a id="_idIndexMarker010"/>of hardware and software. The components are tightly coupled with each other. Developers usually write the software to match specific specifications so it uses the hardware best. Think, for instance, about the systems in your car. If you have a reasonably recent car, you undoubtedly have an entertainment system on board. The word “system” in “entertainment system” is a bit of a giveaway: it consists of many distinct components. There is very likely a device that can collect electromagnetic waves from the air (we call that a radio). That device is connected to some software that interprets those waves and turns them into an electrical signal to feed the speakers. Next to that, a component shows you, as the user, what you are listening to. I am sure you can find a lot of other systems in your car and probably in your TV, your phone, or <span class="No-Break">your refrigerator.</span></li>
			</ul>
			<p>There are many more examples, but I hope you see that a system always consists of individual components that are not useful on their own but, when combined, deliver a solution to <span class="No-Break">a problem.</span></p>
			<p>But hold on. We are not <span class="No-Break">done yet.</span></p>
			<p>Given these definitions and examples, you might think that the art of systems programming is just the programming of these systems, and you would not be wrong. But that is, in general, not what systems programming means. It most certainly is not what I mean <span class="No-Break">by that.</span></p>
			<p>Very, very roughly, we can divide software into <span class="No-Break">two types:</span></p>
			<ul>
				<li><strong class="bold">User-facing software</strong>: This is <a id="_idIndexMarker011"/>software written to be used by people. It has a <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) with buttons, lists, labels, and more. People interact with the software by using various means of <span class="No-Break">input modalities.</span></li>
				<li><strong class="bold">Software-facing software</strong>: This is <a id="_idIndexMarker012"/>software designed to be used by other software. There are no UIs since we have no users. We could say other components are the users, but when I say users, I mean people. Software-facing software interacts with other components through APIs, RPC (Remote Procedure Calls) calls, file transfer, and many other ways. No humans are involved <span class="No-Break">in this.</span></li>
			</ul>
			<p>It is the second type we are most interested in here in this book – software meant to be used by <span class="No-Break">other software.</span></p>
			<h2 id="_idParaDest-16"><a id="_idTextAnchor015"/>When is a system user-facing and when is it not?</h2>
			<p>It is not always clear <a id="_idIndexMarker013"/>when people are the primary users of some code or when other processes are. We could be very rigorous and say that anything with a UI is user-oriented; anything else is systems-oriented. That will make life easier for us if we want a clear definition. However, in the real world, the boundaries tend <span class="No-Break">to blur.</span></p>
			<p>Let me give you an example. Have a look at this Visual <span class="No-Break">Studio Solution:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer006">
					<img alt="Figure ﻿﻿0.1: Solution Explorer with the Calculator project" src="image/B20924_01_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 0.1: Solution Explorer with the Calculator project</p>
			<p>We have a very, very simple solution here. It has a main program called <strong class="source-inline">MyAwesomeCalculator</strong> that contains the main code. This is the entry point of our app, using the console as the UI. All logic is in the <strong class="source-inline">MathFunctions</strong> class library. This is where the <span class="No-Break">magic happens.</span></p>
			<p>If we go back to our <a id="_idIndexMarker014"/>definition of Systems programming, we could say that writing the <strong class="source-inline">MathFunctions</strong> class library is part of Systems programming. After all, no user will ever interact with the classes and interfaces in that library. It is the code in <strong class="source-inline">MyAwesomeCalculator</strong> that actually <span class="No-Break">uses it.</span></p>
			<p>Great! This means writing the <strong class="source-inline">MathFunctions</strong> library is systems programming! Well, not so fast. We might come to another conclusion if we look at the sequence diagram that explains the flow. <span class="No-Break"><em class="italic">Figure 0</em></span><em class="italic">.2</em> shows this <span class="No-Break">sequence diagram.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer007">
					<img alt="Figure ﻿﻿0.2: Sequence diagram for our calculations" src="image/B20924_01_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 0.2: Sequence diagram for our calculations</p>
			<p>As you can see in <span class="No-Break"><em class="italic">Figure 0</em></span><em class="italic">.2</em>, the user initiates an operation: they want to add up two numbers. They enter it in the UI of the <strong class="source-inline">Main</strong> class. The <strong class="source-inline">Main</strong> class then instantiates an instance of the <strong class="source-inline">Adder</strong> class. After that creation, the <strong class="source-inline">Main</strong> class calls the <strong class="source-inline">AddUp(a,b)</strong> method. The result is passed back to the <strong class="source-inline">Main</strong> class and shown to the user. After all this, we could discard the <span class="No-Break"><strong class="source-inline">Adder</strong></span><span class="No-Break"> instance.</span></p>
			<p>Great. Where<a id="_idIndexMarker015"/> are the boundaries? If we look at it this way, we could say that the code in <strong class="source-inline">Adder</strong> and, thus, in the <strong class="source-inline">MathFunctions</strong> library is immediately tied to user actions. So, it is user-facing code instead of <span class="No-Break">systems-facing code.</span></p>
			<p>I still like to use the question of who is using the code to determine what kind of software we are writing. But apparently, this is not enough. We need to go a <span class="No-Break">bit deeper.</span></p>
			<p>The code in <strong class="source-inline">MyAwesomeCalculator</strong> and <strong class="source-inline">MathFunctions</strong> are in separate assemblies. The user interacts with one assembly; the other is accessed through code only. But they can still be seen as one. If we run the application, the runtime creates <strong class="source-inline">AppDomain</strong> <span class="No-Break">for us.</span></p>
			<p><strong class="source-inline">AppDomain</strong> in .NET is <a id="_idIndexMarker016"/>different than <strong class="source-inline">AppDomain</strong> in .NET Framework. The latter had more ways to isolate code from each other. That was nice, but it was a typical Windows feature. That did not translate well to other platforms. So, to make .NET applications run on other platforms, they needed to redesign this. This results in <strong class="source-inline">AppDomain</strong> being less restrictive than it used to be. Still, <strong class="source-inline">AppDomain</strong> remains a logical boundary between different processes. Code runs in one app domain and cannot access other app <span class="No-Break">domains directly.</span></p>
			<p>Here, we have another clue: our <strong class="source-inline">MyAwesomeCalculator</strong> app and the associated <strong class="source-inline">MathFunctions</strong> assembly all run in the same <strong class="source-inline">AppDomain</strong>. To the OS, they are one. Since we decided that actual people use the <strong class="source-inline">Main</strong> method, the same applies to all other pieces of code in that <span class="No-Break">particular </span><span class="No-Break"><strong class="source-inline">AppDomain</strong></span><span class="No-Break">.</span></p>
			<p>Let’s rewrite our solution a bit. See the <span class="No-Break">following screenshot.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer008">
					<img alt="Figure ﻿﻿0.3: Our solution with a worker process" src="image/B20924_01_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 0.3: Our solution with a worker process</p>
			<p>We removed the <a id="_idIndexMarker017"/>class library with the code that did all the work. Instead, we created a new project. That project is a <strong class="bold">worker process</strong>. Technically, I should have kept that class library and referenced that, but I wanted to keep <span class="No-Break">things simple.</span></p>
			<p>A <a id="_idIndexMarker018"/>worker process is a <a id="_idIndexMarker019"/>background process that runs all the time (not technically true, but for now, this is true enough). It just sits there doing nothing. Then, suddenly, something of interest happens, and it comes to life, does its job, and goes to idle <span class="No-Break">mode again.</span></p>
			<p>As shown in <span class="No-Break"><em class="italic">Figure 0</em></span><em class="italic">.4</em>, the sequence diagram in this case is also <span class="No-Break">slightly different.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer009">
					<img alt="Figure ﻿﻿0.4: Sequence diagram for the new revised architecture" src="image/B20924_01_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 0.4: Sequence diagram for the new revised architecture</p>
			<p><strong class="source-inline">MyAwesomeCalculator</strong> and the <strong class="source-inline">MathFunctionServices</strong> worker are now independent of each other. They each run in their own <strong class="source-inline">AppDomain</strong>. When the user wants to perform the calculation, they enter this in the UI, which invokes the service. The <strong class="source-inline">Worker</strong> class picks up the command, creates an instance of the <strong class="source-inline">Adder</strong> class, calls the <strong class="source-inline">AddUp</strong> method, and then calls the <strong class="source-inline">MyAwesomeCalculator</strong> again with <span class="No-Break">the results.</span></p>
			<p>As you can see, the calls between all classes are synchronous (designated by a line with a solid arrowhead) except for the call between <strong class="source-inline">Main</strong> and <strong class="source-inline">Worker</strong>. That is asynchronous (designated by a line and an <span class="No-Break">open arrowhead).</span></p>
			<p>That makes sense; the<a id="_idIndexMarker020"/> calculator cannot know whether the command has arrived or the service is listening. It just does a fire-and-forget, crosses its digital fingers, and hopes for <span class="No-Break">the best.</span></p>
			<p>This is more like it. This is genuinely writing software used by other software (I am talking about <strong class="source-inline">MathFunctionServices</strong> here, <span class="No-Break">not </span><span class="No-Break"><strong class="source-inline">MyAwesomeCalculator</strong></span><span class="No-Break">).</span></p>
			<p>I have not shown you how the code in <strong class="source-inline">Main</strong> calls <strong class="source-inline">Worker</strong> and how the result flows back from <strong class="source-inline">Worker</strong> to <strong class="source-inline">Main</strong>. After all, they are in separate app domains. So, they cannot share memory, right? That is correct. I did not show you that. But do not worry. I have a couple of chapters dedicated <span class="No-Break">to this.</span></p>
			<p>It is important to realize that <strong class="source-inline">MathFunctionServices</strong> does not have a UI in the ordinary sense of the word. No user ever touches this code. It lies there, dormant, until its services are required. If we compare that to the first example, we see the differences. That first example had all code loaded on the user’s demand, and it somehow all responded to the <span class="No-Break">users’ actions.</span></p>
			<h2 id="_idParaDest-17"><a id="_idTextAnchor016"/>A better definition</h2>
			<p>So, if we combine all of this, we can determine that systems programming is the art of writing components that can perform a function or a set of functions but interact only with <span class="No-Break">other components.</span></p>
			<p>That is what this book is all about. We will learn how to write software that is to be consumed by other software. That is a whole other way of looking at software, requirements, design considerations, and more compared to software meant <span class="No-Break">for humans.</span></p>
			<p>Writing software for<a id="_idIndexMarker021"/> software means other ways of thinking about communications, performance, memory usage, security, and so on. All those topics are covered here in this book. Now, you might say: “But wait a minute. Software written for users should also keep performance in mind!” You are right, but software communicating with software has <span class="No-Break">unique needs.</span></p>
			<p>Later chapters show how you can achieve the desired performance and explain why this is important. Let us agree that a component, potentially called thousands of times per second, could use more thought about performance than a screen with a button that a user might click once an hour. I am exaggerating here, but I am sure you get <span class="No-Break">the point.</span></p>
			<p>The same applies <a id="_idIndexMarker022"/>to memory consumption. I believe we should always write all software with memory consumption in mind. However, a component that gets used frequently by many other systems tends to be much more vulnerable to issues with memory than other <span class="No-Break">software programs.</span></p>
			<p>Performance and memory pressure are essential when we think about writing embedded systems. Embedded software usually runs on very limited hardware, so we have to try and take advantage of every trick in the book to get it running as fast as possible and using as little memory <span class="No-Break">as possible.</span></p>
			<p>As promised, we will spend much time looking at ways to communicate with these types <span class="No-Break">of software.</span></p>
			<p>To me, Systems programming is the purest form of software development. It is all about algorithms, tweaks, and trying out every trick in the book to get the most out of it. systems programming is the major league of software development. When you have this covered, all other software you write will also benefit from your newfound knowledge. What you learn when writing systems software will become second nature, and you will improve your overall software writing skills. Does this sound exciting? Then, let’s <span class="No-Break">get started!</span></p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Using C# and .NET in systems programming</h1>
			<p>We already run into a problem. You most likely are a C# developer. Maybe you are a VB.Net developer. But no matter what language, you are a .NET developer. After all, that is what this book <span class="No-Break">is about.</span></p>
			<p>Traditionally, Systems programming <a id="_idIndexMarker023"/>is done in Assembly, C, and C++. Systems programming has always been the realm of hardcore developers who know the <a id="_idIndexMarker024"/>systems they are working on inside out. In the early 50s of the last century, people wrote systems software using switches. A switch in the up position meant a 1, and a switch in the down position meant a 0. These early computers had 8, 16, or even more switches that pointed to the memory address to read or write. Then, 8 switches represented all the bits in a byte for that memory address. Above these switches, there were little lights (no, not LEDS: that invention happened later). Those little lights, if illuminated, meant a 1 in that byte (and a 0 if not illuminated). That way, you could read the contents of that <span class="No-Break">memory address.</span></p>
			<p>Do not worry; that <a id="_idIndexMarker025"/>kind of low-level programming is not <a id="_idIndexMarker026"/>the topic of this book. If you are interested, there are good remakes of the original Altair 8800 that started a company called Microsoft. You can program that computer in this way: use the switches and lights on the front panel to enter your software. That is how Bill Gates and Paul Allen wrote their first software. But we have other tools at <span class="No-Break">our disposal.</span></p>
			<p>Since systems software relies on efficient, fast, and memory-aware code, people often use programming languages close to the metal. That usually means using language such as machine code – such as the switches I mentioned earlier. Assembly language is another language used, especially in the seventies and eighties of the last century. C and later C++ are other examples of languages that can take advantage of the specifics of the hardware. Most parts of Windows, for instance, are written <span class="No-Break">in C.</span></p>
			<p>However, systems developers do not restrict themselves to low-level languages only. Let me give you <span class="No-Break">an example.</span></p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Higher-level languages for systems programming</h2>
			<p>In 1965, IBM published a manual called <em class="italic">PL/I Language Specifications. C28-6571</em>. This relatively <a id="_idIndexMarker027"/>obscure title is a fascinating read: it outlines the specifications of the <strong class="bold">PL/I programming language</strong>. <strong class="bold">PL/I</strong>, a sort of abbreviation<a id="_idIndexMarker028"/> for <strong class="bold">Programming Language One</strong>, is a <a id="_idIndexMarker029"/>higher-level programming language. It contains block structures to allow for recursion, many different datatypes, exception handling, and many other features we take for granted today. It truly was a high-level language. However, they used it to write parts of the early OSs inside IBM. Remember, this was in the sixties when every microsecond counted. Machines were extremely slow compared to modern systems, so they had to utilize every trick in the book to make things work. Yet, a high-level language was considered appropriate. That means there is no reason not to use a high-level language today, especially considering memory profilers’ compiler techniques <span class="No-Break">and advantages.</span></p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Kernel mode and user mode</h2>
			<p>OSs and drivers are usually not built using .NET. The reason for this is that drivers and most parts of the OS run in <span class="No-Break">kernel mode.</span></p>
			<p>The CPU in your computer can run in two modes: <strong class="bold">kernel</strong> or <strong class="bold">system mode and user mode</strong>. User mode is where most <a id="_idIndexMarker030"/>of the applications run. The CPU shields the applications from using other memory or process spaces. The CPU protects the applications by placing them in a sandbox. That is precisely what you would want: it would be very undesirable for a program to snoop around in another application’s memory. The processor handles this level <span class="No-Break">of security.</span></p>
			<p>Kernel mode, however, does <a id="_idIndexMarker031"/>not have those limitations. Software running in kernel mode is less restricted, controlled, and trusted. That makes sense: parts of an OS should be able to run in all parts of the system, including in the space of <span class="No-Break">other applications.</span></p>
			<p>However, to run in kernel, the <a id="_idIndexMarker032"/>compiled code needs to have certain flags set, and the layout of the binaries should be very specific. That is the problem we face. Our C# code relies heavily on the .NET Runtime, and that runtime is not built to be used in Kernel mode. So, even if we could compile our code so that the OS would accept it, it still would not work due to the app not loading <span class="No-Break">the runtime.</span></p>
			<p>There are ways around this. There are ways to pre-compile and include the runtime classes in your binary. Then, you can modify that binary to run in kernel mode. However, the results may vary, and the whole thing would be unreliable. Unreliable code is the exact opposite of what a device driver or OS part should be, so we will not get into this in this book. It’s a hack, not a standard way <span class="No-Break">of working.</span></p>
			<p>Although this book does not deal with kernel-mode apps, I want to give you some insight. Especially since systems programming is usually programming “close to the metal,” so to speak, we are interacting with systems that are running in <span class="No-Break">kernel mode.</span></p>
			<p>Kernel mode is a mode in the CPU. A system can request the CPU to turn on kernel mode. If the code requesting it has the proper privileges, the CPU will do so, thus unlocking parts of the memory previously unavailable. The code does what it needs to do, and then the CPU returns to user mode. Since the code is still in memory doing all sorts of things, it is quite wrong to say an app is a kernel or user-mode app. Some apps can switch the CPU into that state, but the app is almost always running in mixed mode: most of the time, it is in user mode, sometimes kernel mode. Oh, and when I say CPU, I mean <strong class="bold">logical CPU</strong>. This <a id="_idIndexMarker033"/>toggling happens on that level, not on the chip itself (but it can also <span class="No-Break">do that).</span></p>
			<p>I have Adobe Creative Cloud installed on my machine. We all know Photoshop, Illustrator, and Premiere, but these apps are meant to be accessed through the Creative Cloud app. This app monitors the system and launches any app you need when you need it. It also updates the background and keeps track of your fonts, files, colors, and other things <span class="No-Break">like that.</span></p>
			<p>Whenever you read something like “runs in the background,” you might expect some systems programming going on, and indeed, <span class="No-Break">there is.</span></p>
			<p>For example, I get this image if I start <strong class="bold">Performance Monitor</strong> on my system and add the <strong class="source-inline">% Privileged Time</strong> and <strong class="source-inline">% User Time</strong> counters for the Adobe Desktop <span class="No-Break">Service process.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer010">
					<img alt="Figure ﻿﻿0.5: Performance ﻿Monitor showing kernel and user times" src="image/B20924_01_05.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 0.5: Performance Monitor showing kernel and user times</p>
			<p>The red line in <span class="No-Break"><em class="italic">Figure 0</em></span><em class="italic">.5</em> shows how much time the Adobe Desktop Service spends in user time. The green line, however, shows how long the service is running in privileged time, and privileged time is just a fancy term for <span class="No-Break">kernel time.</span></p>
			<p>As you can see, this app is doing much work in the kernel time. Although I have to admit, I have no clue what it is doing there, but I am sure it is all for a <span class="No-Break">good reason.</span></p>
			<p>We will encounter kernel mode later in other chapters but we will not build apps that run <span class="No-Break">in it.</span></p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Why use .NET?</h2>
			<p>So, we established <a id="_idIndexMarker034"/>that we cannot build an OS or a device driver in .NET. That might lead to the question: “Can we use .NET for systems programming?” The answer is a big yes. Otherwise, this would have been a very thin and <span class="No-Break">short book.</span></p>
			<p>Shall we have a look at our recently discovered definition of systems programming? “Writing software used by other software, as a part of a bigger system that works together to achieve a certain goal.” I have shortened the definition, but it is all <span class="No-Break">about this.</span></p>
			<p>Looking at it this way, we can use .NET to write that software. Better yet: I bet .NET is one of the best choices to <span class="No-Break">do so.</span></p>
			<p>.NET offers many advantages over plain C or even C++ (not the managed kind of C++, that is <span class="No-Break">still .NET.)</span></p>
			<p>Back in the day, when we used .NET-Framework-based applications, it would have been a bad idea to use that for systems programming. However, with the introduction of the latest versions of .NET, many disadvantages have been taken care of. With many disadvantages out of the way, .NET-based systems are a viable choice for these kinds <span class="No-Break">of systems.</span></p>
			<p>C and C++ still are excellent languages for low-level systems code. However, C# and .NET Core have their <a id="_idIndexMarker035"/>advantages <span class="No-Break">as well.</span></p>
			<p>This table lays out <span class="No-Break">the differences.</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Topic</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">C# and .</strong><span class="No-Break"><strong class="bold">net core</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">C/C++</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Performance</span></p>
						</td>
						<td class="No-Table-Style">
							<p>.NET Core has improved performance compared to .NET Framework, but there may still be overhead due to its runtime. This won’t be an issue for most applications, but it could matter for highly <span class="No-Break">performance-critical systems.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">C/C++ provides direct control over hardware and, with careful optimization, can yield superior performance in </span><span class="No-Break" lang="en-US" xml:lang="en-US">performance-critical systems.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Memory management</span></p>
						</td>
						<td class="No-Table-Style">
							<p>.NET Core still provides automatic garbage collection, reducing the chance of memory leaks, but it gives less control to the developer. This is more suitable for <span class="No-Break">application-level programming.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>C/C++ gives developers direct control over memory allocation and deallocation, making it more suitable for systems programming that requires fine-grained <span class="No-Break">memory management.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>System-level <span class="No-Break">programming</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Some system-level programming tasks may still be more difficult in .NET Core due to its higher-level abstractions and <span class="No-Break">safety features.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>C/C++ is often used for system-level programming because it allows for direct hardware access and low-level system calls, which are essential for kernel development, device drivers, and <span class="No-Break">so on.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Portability</span></p>
						</td>
						<td class="No-Table-Style">
							<p>.NET Core applications can run on multiple platforms without recompilation, but you must install the .NET Runtime on the target machine. This is an improvement over .<span class="No-Break">NET Framework.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>C and C++ code can be compiled and run on virtually any system but often requires careful management of <span class="No-Break">platform-specific differences.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Runtime requirement</span></p>
						</td>
						<td class="No-Table-Style">
							<p>.NET Core applications still require the .NET Core Runtime to be installed on the target machine. This can limit its use on systems with <span class="No-Break">limited resources.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>C and C++ applications compile down to machine code and don’t require a separate runtime. This can be beneficial for system-level applications or when working with <span class="No-Break">resource-constrained systems.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Direct control</span></p>
						</td>
						<td class="No-Table-Style">
							<p>C# and .NET Core still provide many abstractions that can increase productivity, but these abstractions can limit direct control over the system and how <span class="No-Break">code runs.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>C/C++ provides more direct control over the system, allowing for finely tuned optimizations and precise control over how your <span class="No-Break">code runs.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Community <span class="No-Break">and support</span></p>
						</td>
						<td class="No-Table-Style">
							<p>.NET Core and C# have a growing community and plenty of support resources, including for <span class="No-Break">cross-platform development.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>C/C++ has a large, established community, many open-source projects, and a vast amount of existing <span class="No-Break">system-level code.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 0.1: Comparison of C# and C/C++</p>
			<p>As you can see, both <a id="_idIndexMarker036"/>options have advantages and disadvantages. However, most of the disadvantages of .NET Core can be removed using clever tricks and smart programming. Those are the topics of the rest of <span class="No-Break">this book.</span></p>
			<p>C# is a very mature and well-designed language. The capabilities far exceed what developers had when they used C to build, for example, the <span class="No-Break">Unix OS.</span></p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>What is .NET anyway?</h2>
			<p>.NET Core is the <a id="_idIndexMarker037"/>next version of the over two decades old framework that was meant to help developers get their work <span class="No-Break">done quickly.</span></p>
			<p>It all started <a id="_idIndexMarker038"/>with .NET Framework 1 back in 2002. Microsoft presented it as the end-all solution to many issues developers were facing. Fun fact: the project had the internal code name Project 42. You get bonus points if you know why they chose <span class="No-Break">that name.</span></p>
			<p>In the years following the introduction, we have seen many different functions of .NET Framework. Microsoft released the last version of .NET Framework on April <span class="No-Break">18, 2019.</span></p>
			<p>Before that, Microsoft realized they needed to support other platforms as well. They wanted .NET to be available everywhere, including Linux, Macintosh, and most mobile devices. That meant they had to make fundamental changes to the runtime and the framework. Instead of having different runtime versions for each platform, they decided to have a unified version. That became .NET Core. Microsoft released this in <span class="No-Break">June 2016.</span></p>
			<p>.NET Standard was a set of specifications. The specifications told all developers which features of the runtime were available in which version of the runtime. Most developers did not understand the purpose of .NET Standard and assumed it was yet another version of the runtime. But once they got the idea behind this, it made a lot of sense. If you need a specific API, look it up in the documentation, see what version of .NET Standard it was supported, and then check whether your desired runtime supported that version of .<span class="No-Break">NET Standard.</span></p>
			<p>An example might be helpful here. Let’s say you build an app that does some fancy drawing on the screen. You have worked with <strong class="source-inline">System.Drawing.Bitmap</strong> before, so you want to use that again. However, your new app should be running on .NET Core. Can you reuse your code? If you look up the documentation of the <strong class="source-inline">System.Drawing.Bitmap</strong> class, you see <span class="No-Break">the following:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table002">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Product</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Versions</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>.<span class="No-Break">NET framework</span></p>
						</td>
						<td class="No-Table-Style">
							<p>1.1, 2.0, 3.0, 3.5, 4.0, 4.5, 4.5.1, 4.5.2, 4.6, 4.6.1, 4.6.2, 4.7, 4.7.1, 4.7.2, <span class="No-Break">4.8, 4.8.1</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>. NET <span class="No-Break">platform extensions</span></p>
						</td>
						<td class="No-Table-Style">
							<p>2.1, 2.2, 3.0, 3.1, 5, 6, <span class="No-Break">7, 8</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Windows desktop</span></p>
						</td>
						<td class="No-Table-Style">
							<p>3.0, 3.1, 5, 6, <span class="No-Break">7, 8</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 0.2: Support for System.Drawing.Bitmap</p>
			<p>Darn. This <a id="_idIndexMarker039"/>class is not part of .NET Standard. It is not available in all runtimes out there. You need to find another way to draw <span class="No-Break">your images.</span></p>
			<p>Your app also communicates with the outside world. It uses the <strong class="source-inline">HttpClient</strong> class, found in the <strong class="source-inline">System.Net.Http</strong> namespace. Can you move that to other platforms? Again, we need to look up the documentation of that class. There, we see <span class="No-Break">this table:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table003">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Product</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Versions</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>.<span class="No-Break">NET</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Core 1.0, core 1.1, core 2.0, core 2.1, core 2.2, core 3.0, core 3.1, 5, 6, <span class="No-Break">7, 8</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>.<span class="No-Break">NET framework</span></p>
						</td>
						<td class="No-Table-Style">
							<p>4.5, 4.5.1, 4.5.2, 4.6, 4.6.1, 4.6.2, 4.7, 4.7.1, 4.7.2, <span class="No-Break">4.8, 4.8.1</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>.<span class="No-Break">NET standard</span></p>
						</td>
						<td class="No-Table-Style">
							<p>1.1, 1.2, 1.3, 1.4, 1.6, <span class="No-Break">2.0, 2.1</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Uwp</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">10.0</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Xamarin.ios</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">10.8</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Xamarin.mac</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">3.0</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 0.3: Support for Sstem.Net.Http.HttpClient</p>
			<p>Now, that is more like it. <strong class="source-inline">HttpClient</strong> is part of the .NET Standard specification, which means that all runtimes that support the mentioned versions of .NET Standard implement this class. You are good <span class="No-Break">to go!</span></p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>.NET, .NET Framework, .NET Standard – what is all this?</h2>
			<p><em class="italic">Table 0.3 </em>shows .NET Framework, .NET Standard, and .NET but not .NET Core. We do see .NET, though. What<a id="_idIndexMarker040"/> is this <span class="No-Break">all about?</span></p>
			<p>.NET Core was introduced<a id="_idIndexMarker041"/> to sit next to .NET Framework. Microsoft intended for .NET Framework to support Windows devices. However, as I explained, Microsoft later decided to support other devices, OSs, and other hardware architectures; hence the introduction of .NET Core. Then, they realized that this complicated things a lot. People <a id="_idIndexMarker042"/>lost track of what they could use and where they could use it. The solution to this was the introduction of the .NET Standard specifications, but that only worsened things – even the people who were not confused initially lost track of what was <span class="No-Break">going on.</span></p>
			<p>The version numbering was an issue as well. We have .NET Framework version 4.8.1 that matched .NET Standard 2.1. .NET Core 3.1 also supported .NET Standard 2.1. Many people had no idea what was happening. They could not understand why a .NET (Core) version of 3.0 was newer than .<span class="No-Break">NET 4.5.</span></p>
			<p>Microsoft saw <a id="_idIndexMarker043"/>this problem as well. They also had internal issues: they had to backport a lot of the code in the libraries so it would be available everywhere. To eliminate this mess once and for all, they announced that .NET Framework 4.8 would be the last version. .NET Core 3.1 would be the last version. From now on, it was all unified in something called .NET. Then, to prevent issues with the numbering, .NET started with the <span class="No-Break">number 5.</span></p>
			<p>They also made it easier to track <a id="_idIndexMarker044"/>when new versions would come out. Every single<a id="_idIndexMarker045"/> year, there will be a new version of .NET. So far, the odd numbers are under <strong class="bold">Long Term Support</strong> (<strong class="bold">LTS</strong>); the even numbers are under <a id="_idIndexMarker046"/>Standard Term Support (<strong class="bold">STS</strong>). STS is 18 months, and LTS is <span class="No-Break">3 years.</span></p>
			<p>.NET 5 was an STS version, and since it was released in November 2020, the support ended in May 2022. .NET 6 was an LTS version. Released in November 2021, support ends November 2024. .NET 7 is again an STS, released in November 2022, with an end of life in <span class="No-Break">May 2024.</span></p>
			<p>By the time of writing this book, the preview versions of .NET 8 are out, and that will be an <span class="No-Break">LTS version.</span></p>
			<p>This is what I use in <span class="No-Break">this book.</span></p>
			<p>Now, the versioning is clear. The release cycle is understood. We can finally let that go. We can focus on building cool stuff instead of worrying <span class="No-Break">about versions.</span></p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Programming languages – a choice to make</h2>
			<p>We are <a id="_idIndexMarker047"/>not done yet. We have figured out which version of the runtime we need. But the runtime is just that: a runtime. A set of libraries that we can use. Those libraries have a lot of tools and pre-built classes available, so we do not have to write that. That is awesome. However, we still have to write some code ourselves. We do that in a programming language, and then link to the libraries, compile the code, and have a binary we can deploy <span class="No-Break">and run.</span></p>
			<p class="callout-heading">What language should we use?</p>
			<p class="callout">Microsoft offers us three choices. Others have made their own .NET-compatible languages, but we ignore them. These days, the main languages to write .NET code are C#, F#, and <span class="No-Break">Visual Basic.</span></p>
			<p>F# is a language used for functional programming. This is a different approach to programming than most people are used to, but the financial domain and data-intensive systems use it <span class="No-Break">a lot.</span></p>
			<p>Visual Basic is an excellent language for people just getting started in development. Back in the nineties, at the end of the last century, it was one of the few options people had to build GUI systems rapidly. When .NET came along, Microsoft quickly ported Visual Basic to support this framework, so developers did not have as steep a learning curve. However, usage of Visual Basic is dwindling now that Microsoft stopped co-evolving it <span class="No-Break">with C#.</span></p>
			<p>C# is the language we use in <span class="No-Break">this book.</span></p>
			<p>Although not coupled with the available runtime, Microsoft seems to release a new version of the language around the same time they release a new version of .NET. Version 11 of the language came out in November 2022. Version 12 of C# is now in preview when writing <span class="No-Break">this book.</span></p>
			<p>Each new version of the language has improvements, but many are syntactic. That means that if you cannot use the latest language version, you can still use all the features in the runtime. They are officially decoupled. Sometimes, it is just a bit more <span class="No-Break">typing work.</span></p>
			<p>The .NET Runtime is an excellent foundation for building all sorts of systems. The ecosystem surrounding .NET is very extensive. Next, a huge group of people contributes to the framework daily. It is hard to think of a task that cannot be performed with .NET or one of the thousands of NuGet <span class="No-Break">packages available.</span></p>
			<p>Again, real Kernel <a id="_idIndexMarker048"/>mode systems, such as device drivers, are best built with non-managed languages. However, for all other purposes, .NET and C# are an <span class="No-Break">excellent choice.</span></p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>Now what?</h1>
			<p>Congratulations! You have made the first steps towards becoming a systems programmer. You now know what systems programming is and how it differs from the usual day-to-day programming you might be used <span class="No-Break">to doing.</span></p>
			<p>You know about the background of programming and the challenges our predecessors faced, and you know why .NET is such an awesome tool to build systems <span class="No-Break">software in.</span></p>
			<p>We are ready to take the next step. We will dive into the nitty-gritty details. However, before we do that, we will need to talk about APIs and .NET Framework, its upsides, and its downsides. So, <span class="No-Break">let’s go!</span></p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor025"/>Setting up your development environment</h1>
			<p>I asked you to <a id="_idIndexMarker049"/>follow along. I requested that you open up your development environment and do what I do. However, to do that, you need to set up the right kind of development environment so that you can actually do what <span class="No-Break">I do.</span></p>
			<p>Let me help you <span class="No-Break">with that.</span></p>
			<p>I use <strong class="bold">Visual Studio 2022 Enterprise</strong>. There<a id="_idIndexMarker050"/> is no particular reason I use the Enterprise version besides having that on my machine. There are two other versions: The Professional and the free Community edition. All three versions are fine for the things we want to do. However, the Enterprise edition does have some debugging tools we might need when discussing debugging. When that time comes, I will pinpoint the differences and show you other ways of achieving <span class="No-Break">your goals.</span></p>
			<p>Alternatives such as JetBrains Rider and Visual Studio Code also work, but you might have to do more work yourself when we go into performance tuning and debugging. Again, I will tell you about these when we <span class="No-Break">get there.</span></p>
			<p>I have limited <a id="_idIndexMarker051"/>experience with Rider, so I cannot tell you precisely what you need to do, but I am sure that when you are an experienced developer, you can translate what I am showing you into the tools you know <span class="No-Break">and love.</span></p>
			<p>Use what you have and what you know. I am cool <span class="No-Break">with that.</span></p>
			<p>If you decide to go with Visual Studio, which I highly recommend, you should use version 2022 instead of 2019. The latest versions of .NET and C# offer a lot related to performance tuning and memory optimizations. Those versions are only available in the 2022 version of Visual Studio. So, make sure you have that one on <span class="No-Break">your device.</span></p>
			<p>Next to that, we will be doing a lot of console stuff. That means using PowerShell: gone are the days of <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">cmd.exe</strong></span><span class="No-Break">.</span></p>
			<p>I highly recommend downloading Windows Terminal. With Terminal, you can have all sorts of consoles. We will use PowerShell most of the time, but when we talk about Linux, we will use the WSL feature to use our machines as <span class="No-Break">Linux machines.</span></p>
			<p>Downloading and installing Terminal is a breeze: you can find it on the <span class="No-Break">Microsoft Store.</span></p>
			<p>Make sure to install Windows Subsystem for Linux as well. Instructions on how to do that are all over the internet; I will not repeat <span class="No-Break">that here.</span></p>
			<p>Once you have installed all of your favorite tools, you can select any one of them in your Terminal. Mine looks <span class="No-Break">like this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer011">
					<img alt="Figure ﻿﻿0.6: Windows Terminal with different shells" src="image/B20924_01_06.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 0.6: Windows Terminal with different shells</p>
			<p>As you can see, I have <strong class="bold">PowerShell</strong>, <strong class="bold">Command Prompt</strong>, <strong class="bold">Ubuntu</strong>, <strong class="bold">Azure Cloud Shell</strong>, and some more installed. Selecting one of them is a matter <span class="No-Break">of clicking.</span></p>
			<p>Switching between Linux and Windows has never <span class="No-Break">been easier!</span></p>
			<p>Another tool we will be using<a id="_idIndexMarker052"/> later on is <strong class="bold">WinDbg</strong>. WinDbg is an extremely powerful external debugger. It can give you a lot of information about the processes you are interested in. It runs standalone, so you do not have to attach Visual Studio to the process. There are versions available for both X86 and ARM, so it is usable on many devices. You can find WinDbg on the Microsoft website at <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/">https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/</a>. Download and install that. WinDbg might become one of your latest <span class="No-Break">best friends.</span></p>
			<p>Next, you might want to<a id="_idIndexMarker053"/> install <strong class="bold">PerfView</strong>. It is a free and open-source performance monitoring tool from Microsoft, specially built for analyzing performance on .<span class="No-Break">NET applications.</span></p>
			<p>You can find the source code at <a href="https://github.com/Microsoft/perfview">https://github.com/Microsoft/perfview</a>. You can download the sources and build the tool yourself or grab one of the pre-build versions. Those are also on that same site. I would suggest building yourself and looking through the source code: there are some terrific examples of how to build software like this. I do not intend to describe how the tool works internally, but I will use it when <span class="No-Break">discussing performance.</span></p>
			<p>Now, all you need is a cup of your favorite beverage, and we are good <span class="No-Break">to go!</span></p>
		</div>
	</body></html>