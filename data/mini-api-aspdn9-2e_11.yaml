- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Utilizing Asynchronous Programming for Scalability
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用异步编程实现可伸缩性
- en: Whenever we execute a function, we expect a result, but what happens between
    the request and the outputted result?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们执行一个函数时，我们都期望得到一个结果，但请求和输出结果之间发生了什么？
- en: Imagine you’re in town, and you have a bunch of errands to run, but you’re also
    hungry and need to eat lunch. You walk into a pizza shop, situated within a shopping
    mall. The shop cooks fresh pizza to order. It takes around fifteen minutes for
    the pizza to be prepped and then cooked. You can wait around in the shop until
    the pizza is done, but you need to go to the bank, which has a branch across the
    road. The pizza store owner is a friend of yours and agrees to text you when your
    pizza is ready to pick up. You have an opportunity to get something else done
    while your pizza is cooking; that’s a much better use of your time.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在镇上，有一堆任务要完成，但你也很饿，需要吃午餐。你走进一个位于购物中心内的披萨店。这家店会根据订单现做披萨。披萨的准备和烹饪大约需要十五分钟。你可以等在店里直到披萨做好，但你还需要去银行，银行在马路对面。披萨店的老板是你的朋友，并同意在你披萨准备好取时给你发短信。在你披萨烹饪的时候，你可以有机会完成其他事情；这是对时间更好的利用。
- en: This is a simple analogy for an **asynchronous** function. The act of walking
    into the pizza shop is the function starting, and you running over to the bank
    while it is cooking is the function running. When your phone beeps with a text
    to say the pizza is ready, that is the function returning its output.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个对**异步**函数的简单类比。走进披萨店是函数的开始，你在它烹饪的时候跑向银行是函数的运行。当你的手机响起，收到披萨准备好的短信时，这是函数返回其输出的时刻。
- en: This example demonstrates the benefits of an asynchronous function, which allows
    for the execution of other tasks while waiting for a specific operation to complete.
    Cooking your pizza doesn’t block your overall goal, which is to run your errands.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了异步函数的好处，它允许在等待特定操作完成的同时执行其他任务。烹饪你的披萨不会阻塞你整体的目标，即完成你的任务。
- en: If the pizza shop owner was a lot less friendly and demanded that you wait in
    the shop until the pizza was done, that would be an example of a **synchronous**
    operation, the opposite of asynchronous. Synchronous operations block the progression
    of your overall goal (running your errands) until the current operation is complete.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果披萨店的老板不那么友好，要求你等到披萨做好才能离开，那么这就是一个**同步**操作的例子，与异步操作相反。同步操作会阻塞你整体目标的进展（完成你的任务）直到当前操作完成。
- en: Where possible, we want to reap the benefits of asynchronous programming for
    operations that are executing as part of minimal APIs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，我们希望从异步编程中获取操作执行作为最小API一部分的好处。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding and implementing asynchronous patterns in a minimal API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最小API中理解和实现异步模式
- en: Common pitfalls and challenges
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见陷阱和挑战
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter is available in the GitHub repository at: [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9)
    . Visual Studio with the .NET 9 SDK is required to run the code.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在GitHub仓库中找到：[https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9)
    。运行代码需要Visual Studio和.NET 9 SDK。
- en: Understanding and implementing asynchronous patterns in a minimal API
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在最小API中理解和实现异步模式
- en: The opening pizza analogy is hopefully a good, high-level illustration of the
    difference between asynchronous and synchronous programming. Asynchronous programming
    is significant in minimal APIs because it provides a lot of flexibility for managing
    the conversations between client and server. It is particularly beneficial to
    long-running operations, where the overall performance of a request would be compromised
    by operations running in a linear fashion, with each operation blocking the other.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 开篇的披萨类比可能是一个很好的、高级的说明，展示了异步编程和同步编程之间的区别。异步编程在最小API中非常重要，因为它为管理客户端和服务器之间的对话提供了很多灵活性。对于长时间运行的操作尤其有益，因为如果操作以线性方式运行，每个操作都会阻塞其他操作，这会损害请求的整体性能。
- en: Asynchronous programming also provides scalability benefits, allowing APIs to
    cope with high demand. This is achieved by ensuring that threads are not blocked.
    Operations in an asynchronous endpoint can register callbacks to ensure that the
    execution thread can continue running other tasks until that callback is resolved.
    This brings with it other resource benefits such as better management of the thread
    pool, lower CPU consumption, and decreased memory footprint. All of these things
    are crucial for minimal APIs, which are designed to be as straightforward and
    efficient as possible.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程还提供了可扩展性优势，使API能够应对高需求。这是通过确保线程不被阻塞来实现的。异步端点的操作可以注册回调，以确保执行线程可以在回调解决之前继续运行其他任务。这带来了其他资源优势，如更好的线程池管理、降低CPU消耗和减少内存占用。所有这些对于最小化API至关重要，因为它们旨在尽可能简单和高效。
- en: Task-based asynchronous pattern
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于任务的异步模式
- en: '.NET has seen the use of several different asynchronous programming patterns
    on its journey from .NET Framework to .NET core. In the .NET Framework days, the
    **Task-based Asynchronous Pattern** ( **TAP** ) was the preferred method for managing
    asynchronous execution. Introduced in the Task Parallel Library in .NET 4, it
    uses **Task** and **Task<T>** to represent asynchronous operations and to provide
    a way to handle their results or exceptions. The explicit implementation of the
    TAP is now obsolete in .NET 9, but the example is effective at demonstrating asynchronous
    operations. If we were to use it in a minimal API, it would be situated in the
    body of an endpoint, with the establishment of a **Task<T>** , which would execute
    a long-running task. We would then start the **Task** while at the same time telling
    it what logic it should call back to once it has finished. We can see this in
    this example, which runs a task to grab data from another API and then continues
    by checking the result before returning a response to the client:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: .NET在其从.NET Framework到.NET core的演变过程中，看到了多种不同的异步编程模式的使用。在.NET Framework时代，**基于任务的异步模式**（**TAP**）是管理异步执行的首选方法。它是在.NET
    4的Task Parallel Library中引入的，使用**Task**和**Task<T>**来表示异步操作，并提供了一种处理它们的结果或异常的方法。现在在.NET
    9中，TAP的显式实现已经过时，但这个例子有效地演示了异步操作。如果我们在一个最小化API中使用它，它将位于端点体中，建立一个**Task<T>**，这将执行一个长时间运行的任务。然后我们会启动**Task**，同时告诉它一旦完成应该调用什么逻辑。我们可以在以下示例中看到这一点，该示例运行一个任务从另一个API获取数据，然后继续检查结果，在向客户端返回响应之前继续：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: While this code can demonstrate asynchronous execution in an API endpoint, it
    could be a lot more readable. Fortunately, back in .NET Framework 4.5 and .NET
    5, the **async/await** keywords were introduced.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码可以在API端点中演示异步执行，但它可以读起来更加清晰。幸运的是，在.NET Framework 4.5和.NET 5中，引入了**async/await**关键字。
- en: TAP with async/await
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于async/await的TAP
- en: The **async/await** keywords made asynchronous programming more accessible by
    allowing us to write asynchronous code that resembles synchronous code. This went
    a long way toward making asynchronous code more readable and therefore understandable.
    In a minimal API, where we’re aiming to be economical with the real estate in
    our IDE, this is very valuable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**async/await** 关键字通过允许我们编写类似于同步代码的异步代码，使得异步编程更加易于访问。这大大提高了异步代码的可读性，因此也更容易理解。在一个最小化API中，我们旨在在IDE中节省空间，这一点非常有价值。'
- en: 'This is what the endpoint from the last example looks like when using **async/await**
    instead of using the original Task-based syntax:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用**async/await**而不是使用原始基于Task的语法时，上一个示例中的端点看起来像什么：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It’s hopefully clear to see that the section of code in the second example,
    which starts the asynchronous call to the other API, is much cleaner and shorter
    than its counterpart in the first example.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 希望很明显，第二个示例中启动对其他API的异步调用的代码部分，比第一个示例中的对应部分更加简洁和简短。
- en: In minimal APIs, we don’t need to do much to make an API endpoint compatible
    with **async/await** . Notice how, in the second example that uses **async/await**
    , the endpoint has the **async** keyword preceding the lambda expression defined
    after the route. This, like in regular .NET functions and methods, allows for
    the use of the **await** keyword in the body of the function. Without the **async**
    keyword, **await** is not supported.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在最小API中，我们不需要做太多就能使API端点与**async/await**兼容。注意，在第二个使用**async/await**的示例中，端点在路由之后定义的lambda表达式之前有**async**关键字。这，就像在常规.NET函数和方法中一样，允许在函数体中使用**await**关键字。如果没有**async**关键字，**await**是不支持的。
- en: The first example did not use the **async** keyword, but it was ultimately still
    able to create an asynchronous operation. This may look like a contradiction until
    we consider that as well as **async** , **await** is notably absent from the first
    example. So, it’s important to remember that the **async** keyword is not a pre-requisite
    for any asynchronous code in a minimal API, but it allows for the use of **await**
    , and therefore a simpler implementation of asynchronous operations that resemble
    synchronous ones.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例没有使用**async**关键字，但最终仍然能够创建一个异步操作。这看起来可能像是一种矛盾，直到我们考虑到，除了**async**之外，**await**在第一个示例中也明显缺失。因此，重要的是要记住，在最小API中，**async**关键字不是任何异步代码的先决条件，但它允许使用**await**，因此可以更简单地实现类似于同步的异步操作。
- en: By using **async/await** , we can implement the TAP in a streamlined fashion.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用**async/await**，我们可以以简化的方式实现TAP。
- en: Asynchronous processing pattern
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步处理模式
- en: There is another well defined pattern that achieved asynchronous execution known
    as the **Asynchronous** **Processing Pattern** .
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一个定义良好的模式，称为**异步处理模式**，实现了异步执行。
- en: Sometimes referred to as **deferred processing** , this pattern can be somewhat
    complex compared to the TAP, but the principle is the same. The flow of control
    is returned to the consumer of the function while other long-running operations
    are completed. However, in this pattern, the consumer of the function is not the
    API application’s main thread, but the client making the request to the API endpoint.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有时被称为**延迟处理**，与TAP相比，这种模式可能相对复杂，但原理是相同的。控制流返回到函数的消费者，同时其他长时间运行的操作完成。然而，在这个模式中，函数的消费者不是API应用程序的主线程，而是向API端点发出请求的客户端。
- en: '*Figure 1* *.1* demonstrates execution via deferred processing:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1* *.1* 通过延迟处理展示了执行过程：'
- en: '![Figure 11.1: Deferred processing spanning two client requests](img/B20968_11_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1：跨越两个客户端请求的延迟处理](img/B20968_11_01.jpg)'
- en: 'Figure 11.1: Deferred processing spanning two client requests'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1：跨越两个客户端请求的延迟处理
- en: We can turn the current example into a version that uses deferred processing
    relatively easily. First, we would need to make an endpoint that starts execution
    of the long-running task, but then immediately acknowledges the caller by returning
    a status code. However, a status code on its own will not suffice. We must return
    a callback URL for the client. This URL will route to another endpoint, which
    will check to see whether our long-running operation has completed. If it has,
    it will retrieve the relevant data before returning it to the client as a response.
    If the operation has not been completed, it will still respond to the client,
    indicating that the operation is still running.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以相对容易地将当前示例转换为使用延迟处理的版本。首先，我们需要创建一个端点，该端点开始执行长时间运行的任务，然后立即通过返回状态码来确认调用者。然而，仅状态码本身是不够的。我们必须返回一个客户端的回调URL。此URL将路由到另一个端点，该端点将检查我们的长时间运行操作是否已完成。如果已完成，它将检索相关数据，然后将其作为响应返回给客户端。如果操作尚未完成，它仍然会响应客户端，表明操作仍在运行。
- en: 'Let’s start by creating the first endpoint, which will acknowledge the client’s
    request for the long-running operation to start. We’ll also create a dictionary
    to hold responses waiting to be collected by clients via callbacks:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建第一个端点开始，该端点将确认客户端请求开始长时间运行操作。我们还将创建一个字典来存储等待客户端通过回调收集的响应：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The dictionary has been added as a **ConcurrentDictionary** because it is thread-safe,
    meaning that .NET will automatically manage scenarios where it is accessed by
    multiple concurrent threads. An example would be if there are multiple requests
    to the API.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字典是线程安全的，意味着.NET将自动管理多个并发线程访问的场景，因此已将其添加为**ConcurrentDictionary**。例如，如果有多个请求到API。
- en: 'Next, inside the body of the **POST** endpoint, we generate a **GUID** to represent
    the pending request, as well as a string version of the **GUID** that can be referenced
    in the callback response:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在**POST**端点的主体内部，我们生成一个**GUID**来表示挂起的请求，以及一个可以在回调响应中引用的**GUID**字符串版本：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'All that remains now is to start the long-running task, before returning the
    **GUID** to the client so that they can use it in the callback request to see
    whether their result is ready for retrieval:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只剩下启动长运行任务，在将**GUID**返回给客户端之前，以便他们可以在回调请求中使用它来查看他们的结果是否已准备好检索：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that the client has a unique identifier in the form of the returned **GUID**
    , it can be used in a second request to get the result.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在客户端已经通过返回的**GUID**获得了唯一标识符，它可以在第二次请求中使用以获取结果。
- en: 'Let’s create a **GET** endpoint for this purpose. The endpoint will be a lot
    simpler than the first. It will simply attempt to find an entry in the dictionary
    that has a key matching the passed-in **GUID** parameter. If the dictionary contains
    the requested key-value pair, the original long-running operation is completed.
    Otherwise, it must still be running or was never initiated. The **GET** endpoint
    must handle both of these scenarios:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为此目的创建一个**GET**端点。该端点将比第一个端点简单得多。它将简单地尝试在字典中找到一个与传入的**GUID**参数匹配的键。如果字典包含请求的键值对，则原始的长运行操作完成。否则，它可能仍在运行或从未启动。**GET**端点必须处理这两种情况：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Go ahead and try calling these two endpoints, one after the other. If you request
    the second endpoint within less than ten seconds of the first one, you should
    get a **404 NOTFOUND** result with the **Result not found or not yet completed**
    message and then get the expected **GUID** result after ten seconds. This will
    have demonstrated deferred processing in a simple way.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，尝试依次调用这两个端点。如果你在第一个端点之后不到十秒内请求第二个端点，你应该得到一个带有**Result not found or not yet
    completed**消息的**404 NOTFOUND**结果，然后在十秒后得到预期的**GUID**结果。这将以简单的方式演示了延迟处理。
- en: To expand your practice of this execution pattern, you should attempt more elaborate
    use cases, such as running complicated mathematical calculations or making database
    or network requests in the background.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展你对这种执行模式的实践，你应该尝试更复杂的使用案例，例如在后台运行复杂的数学计算或进行数据库或网络请求。
- en: Common pitfalls and challenges
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见陷阱和挑战
- en: 'Asynchronous programming brings with it a series of pitfalls and challenges.
    Let’s go through some examples of things that you should be vigilant about when
    writing asynchronous code in a minimal API:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程带来了一系列的陷阱和挑战。让我们看看在最小API中编写异步代码时应警惕的一些示例：
- en: '**Deadlocks** : A deadlock occurs when concurrent operations cannot complete
    due to blocking. In a minimal API, this can be seen when the main thread is blocked.
    In the following example, the use of **Task.Run** can cause a deadlock because
    it blocks the main thread:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**死锁**：当并发操作由于阻塞而无法完成时，会发生死锁。在最小API中，这可以在主线程被阻塞时看到。在以下示例中，使用**Task.Run**可能导致死锁，因为它阻塞了主线程：'
- en: '[PRE6]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The way to avoid deadlocks would simply be to use **await** when running the
    task, to ensure that the call does not block the main thread:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 避免死锁的简单方法是在运行任务时使用**await**，以确保调用不会阻塞主线程：
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Resource Management** : Where possible, minimal API code that manages resources
    such as database connections or file handles should be disposed of appropriately
    in an asynchronous context.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源管理**：在可能的情况下，管理数据库连接或文件句柄等资源的最小API代码应在异步上下文中适当地释放。'
- en: 'Any resource that implements **IDisposable** can make use of a **using** statement
    to automatically dispose of the resource when no longer in use. However, when
    writing asynchronous code for resources, try to use **IDisposableAsync** where
    available. This means you use **await** in conjunction with a **using** statement:'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 任何实现**IDisposable**的资源都可以使用**using**语句在不再使用时自动释放资源。然而，当为资源编写异步代码时，尽量使用可用的**IDisposableAsync**。这意味着你将与**using**语句结合使用**await**：
- en: '[PRE8]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Race conditions** : A race condition is the result of multiple threads accessing
    and modifying shared data concurrently. For example, if you have a static field
    in your minimal API, and an endpoint that accesses it for modification, you must
    remember that requests can execute concurrently, with multiple clients potentially
    running the endpoint logic at the same time. This would cause the static field
    in your API to become inconsistent and therefore inaccurate. You must ensure that
    each operation against shared data is *atomic* – a single operation must complete
    before another occurs:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**竞态条件**：竞态条件是多个线程同时访问和修改共享数据的结果。例如，如果你在你的最小API中有一个静态字段，并且有一个访问它进行修改的端点，你必须记住请求可以并发执行，多个客户端可能同时运行端点逻辑。这会导致你的API中的静态字段变得不一致，因此不准确。你必须确保对共享数据的每个操作都是*原子性*的——一个操作必须完成，然后另一个操作才能发生：'
- en: '[PRE9]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, multiple requests to **IncrementCounter** can lead to an inconsistent
    state of **_counter** .
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，对**IncrementCounter**的多个请求可能导致**_counter**的不一致状态。
- en: 'The solution to this problem is to use a synchronization mechanism to manage
    the state of a shared value. The most common synchronization mechanism is **lock**
    , which uses an **object** to block execution against a particular value while
    a thread is accessing it. This means *locking* it from access by other threads,
    forcing them to wait their turn:'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是使用同步机制来管理共享值的状态。最常用的同步机制是**锁**，它使用一个**对象**来阻止线程在访问特定值时执行。这意味着*锁定*它，防止其他线程访问，迫使它们等待轮到它们：
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This example shows the establishment and execution of a **lock** to ensure that
    **_counter** is updated by one thread at a time, eliminating the possibility of
    race conditions occurring within the API.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个例子展示了如何建立和执行一个**锁**，以确保**_counter**一次只由一个线程更新，从而消除在API内部发生竞态条件的可能性。
- en: Asynchronous programming can add a new layer of complexity to any minimal API
    project, but we’ve demonstrated in this chapter that with careful attention, it
    can be a powerful tool in optimizing API efficiency. Let’s recap the areas covered
    in this chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程可以为任何最小API项目增加一个新的复杂层，但我们已经在本章中证明，通过仔细的关注，它可以是一个优化API效率的强大工具。让我们回顾一下本章涵盖的内容。
- en: Summary
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We opened this chapter with the pizza store analogy. We introduced asynchronous
    programming by likening it to a takeout food order that you don’t simply wait
    for, but instead continue your ongoing tasks until the pizza is ready for you
    to collect.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以披萨店类比作为本章的开端。我们通过将其比作一个外卖食品订单来介绍异步编程，你不必简单地等待，而是继续你的正在进行中的任务，直到披萨准备好让你取走。
- en: We then laid the foundations for understanding how asynchronous code can benefit
    a minimal API, with its optimal use of hardware resources and scope for application
    scalability.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后为理解异步代码如何使最小API受益奠定了基础，它通过最佳使用硬件资源和应用可扩展性的范围。
- en: We explored some common asynchronous programming patterns, namely the TAP and
    deferred execution patterns, with examples of how the use of **async/await** can
    make asynchronous code more readable by making it look more like synchronous code.
    We explored how Deferred Execution can make an API asynchronous at the client
    level, allowing the client to receive an acknowledgment that their request has
    been received, along with a unique identifier for them to reference, stretching
    the overall end-to-end execution across multiple API requests.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了常见的异步编程模式，即TAP和延迟执行模式，以及如何使用**async/await**使异步代码更易于阅读，使其看起来更像同步代码的示例。我们探讨了延迟执行如何使API在客户端级别异步，允许客户端收到确认，表明他们的请求已被接收，并附带一个唯一的标识符供他们参考，从而将整体端到端执行扩展到多个API请求。
- en: Finally, we addressed the common challenges asynchronous programming presents,
    particularly in minimal APIs, with three common examples. The first was deadlocks,
    in which execution can no longer be continued on a global scale due to contention
    between multiple threads or operations. Next was poor resource management, in
    which the code does not account for the asynchronous context when disposing of
    connections to external resources. Lastly, we looked at race conditions, the classic
    example of multiple operations competing to update the state of a shared value
    or resource, causing inconsistent behavior and the creation of inaccurate data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过三个常见的例子解决了异步编程带来的常见挑战，尤其是在最小化API中。第一个是死锁，由于多个线程或操作之间的竞争，全局执行无法继续。接下来是资源管理不善，代码在释放对外部资源连接时没有考虑到异步上下文。最后，我们探讨了竞争条件，这是多个操作竞争更新共享值或资源状态的经典例子，导致行为不一致和数据的准确性不准确。
- en: No software developer can easily escape the need to manage asynchronous execution,
    especially in a .NET minimal API. Thus, practicing vigilance, combined with good
    testing and the profiling techniques learned earlier in the book, can go a long
    way to making the experience as painless as possible.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 没有软件开发者能够轻易逃避管理异步执行的需求，尤其是在.NET最小化API中。因此，保持警惕，结合书中早期学到的良好测试和性能分析技术，可以在尽可能减少痛苦的情况下使体验达到最佳。
- en: Next, we will explore a critical method for optimizing the performance of any
    minimal API – caching.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨优化任何最小化API性能的关键方法——缓存。
