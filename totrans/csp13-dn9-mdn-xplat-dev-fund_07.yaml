- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packaging and Distributing .NET Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about how C# keywords are related to .NET types and the relationship
    between namespaces and assemblies. You’ll become familiar with how to package
    and publish your .NET apps and libraries for cross-platform use.
  prefs: []
  type: TYPE_NORMAL
- en: There are several online sections for this chapter, and you will find links
    to them all at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In an online-only section, *Decompiling .NET assemblies*, we cover how to decompile
    .NET assemblies for learning purposes and why you cannot prevent others from decompiling
    your code. In another online-only section, *Porting from .NET Framework to modern
    .NET*, you can learn how to use legacy .NET Framework libraries in .NET libraries
    and how it is possible to port legacy .NET Framework code bases to modern .NET.
    Finally, in a third online-only section, *Creating source generators*, you will
    learn how to create source generators that can dynamically add source code to
    your projects—a very powerful feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The road to .NET 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding .NET components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing your applications for deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native ahead-of-time compilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging your libraries for NuGet distribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with preview features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The road to .NET 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part of the book is about the functionality in the **Base Class Library**
    (**BCL**) APIs provided by .NET and how to reuse functionality across all the
    different .NET platforms, using .NET Standard.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Standard-compatible frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From .NET Core 2.0 onward, the support for a minimum of .NET Standard 2.0 is
    important because it provides many of the APIs that were missing from the first
    version of .NET Core. The 15 years’ worth of libraries and applications that .NET
    Framework developers had available to them that are relevant for modern development
    have now been migrated to .NET, and they can run cross-platform on macOS and Linux
    variants, as well as on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: '.NET Standard 2.1 added about 3,000 new APIs. Some of those APIs need runtime
    changes that would break backward compatibility. To summarize:'
  prefs: []
  type: TYPE_NORMAL
- en: .NET Framework 4.8 only implements .NET Standard 2.0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Core 3.0, Xamarin, Mono, and Unity implement .NET Standard 2.1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET 5 removed the need for .NET Standard because all project types can now
    target a single version of .NET. The same applies to .NET 6 and later. Each version
    from .NET 5 onward is backward compatible with previous versions. This means a
    class library that targets .NET 5 can be used by any .NET 5 or later projects
    of any type. Now that .NET versions have been released with full support for mobile
    and desktop apps built using .NET MAUI, the need for .NET Standard has been further
    reduced.
  prefs: []
  type: TYPE_NORMAL
- en: Since you might still need to create class libraries for legacy .NET Framework
    projects or legacy Xamarin mobile apps, there is still a need to create .NET Standard
    2.0 class libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Officially, you must also use a .NET Standard 2.0 class library to create a
    source generator even though it’s a rather modern feature of .NET.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize the progress that .NET has made since the first version of .NET
    Core in 2016, I have compared the major .NET Core and modern .NET versions with
    the equivalent .NET Framework versions in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**.NET Core 1.x**: Much smaller API compared to .NET Framework 4.6.1, which
    was the current version in March 2016.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.NET Core 2.x**: Reached API parity with .NET Framework 4.7.1 for modern
    APIs because they both implement .NET Standard 2.0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.NET Core 3.x**: Larger API compared to .NET Framework for modern APIs because
    .NET Framework 4.8 does not implement .NET Standard 2.1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.NET 5**: Even larger API compared to .NET Framework 4.8 for modern APIs,
    with much-improved performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.NET 6**: Continued improvements to performance and expanded APIs, with optional
    support for mobile apps in .NET MAUI, which was added in May 2022.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.NET 7**: Final unification with support for mobile apps, with .NET MAUI
    available as an optional workload. This book does not cover .NET MAUI development.
    Packt has multiple books that specialize in .NET MAUI, and you can find them by
    searching their website.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.NET 8**: Continued to improve the platform and should be used for all new
    development if you need long-term support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.NET 9**: Continues to improve the platform, especially with performance,
    and should be used if you are comfortable with standard-term support. You can
    see the .NET 9 release notes for each preview at the following link: [https://github.com/dotnet/core/discussions/9234](https://github.com/dotnet/core/discussions/9234).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can read more details in the GitHub repository at the following link: [https://github.com/markjprice/cs13net9/blob/main/docs/ch07-features.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch07-features.md).'
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: A useful way to compare two versions of .NET is the APIs
    of the .NET website. For example, you can compare what’s new in .NET 9 compared
    to .NET 8 at the following link: [https://apisof.net/catalog?diff=net8.0-vs-net9.0](https://apisof.net/catalog?diff=net8.0-vs-net9.0).'
  prefs: []
  type: TYPE_NORMAL
- en: Checking your .NET SDKs for updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Microsoft introduced a command with .NET 6 to check the versions of .NET SDKs
    and runtimes that you have installed, and it warns you if any need updating. For
    example, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see results, including the status of available updates, as shown in
    the following partial output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: To maintain support from Microsoft, you must keep your .NET
    SDKs and .NET runtimes up to date with the latest patches.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A related third-party tool is `dotnet-outdated`, which allows you to quickly
    report on any outdated NuGet packages in your .NET projects. You can learn more
    about it at the following link: [https://github.com/dotnet-outdated/dotnet-outdated](https://github.com/dotnet-outdated/dotnet-outdated).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding .NET components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '.NET is made up of several pieces, which are shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Language compilers**: These turn your source code, written with languages
    such as C#, F#, and Visual Basic, into **intermediate language** (**IL**) code
    stored in assemblies. With C# 6 and later, Microsoft switched to an open-source
    rewritten compiler known as **Roslyn**, which is also used by Visual Basic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Common Language Runtime** (**CLR**): This runtime loads assemblies, compiles
    the IL code stored in them into native code instructions for your computer’s CPU,
    and executes the code within an environment that manages resources, such as threads
    and memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Base Class Libraries** (**BCL**): These are prebuilt assemblies of types
    packaged and distributed using NuGet to perform common tasks when building applications.
    You can use them to quickly build anything you want, rather like combining LEGO™
    pieces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemblies, NuGet packages, and namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An **assembly** is where a type is stored in the filesystem. Assemblies are
    a mechanism for deploying code. For example, the `System.Data.dll` assembly contains
    types to manage data. To use types in other assemblies, they must be referenced.
    Assemblies can be static (pre-created) or dynamic (generated at runtime). Dynamic
    assemblies are an advanced feature that we will not cover in this book. Assemblies
    can be compiled into a single file as a DLL (class library) or an EXE (console
    app).
  prefs: []
  type: TYPE_NORMAL
- en: Assemblies are distributed as **NuGet packages**, which are files that are downloadable
    from public online feeds and can contain multiple assemblies and other resources.
    You will also hear about **project SDKs**, **workloads**, and **platforms**, which
    are combinations of NuGet packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft’s NuGet feed is found here: [https://www.nuget.org/](https://www.nuget.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: What is a namespace?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A namespace is the address of a type. Namespaces are a mechanism to uniquely
    identify a type by requiring a full address, rather than just a short name. In
    the real world, *Bob of 34 Sycamore Street* is different from *Bob of 12 Willow
    Drive*.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET, the `IActionFilter` interface of the `System.Web.Mvc` namespace is
    different from the `IActionFilter` interface of the `System.Web.Http.Filters`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Dependent assemblies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If an assembly is compiled as a class library and provides types for other assemblies
    to use, then it has the file extension `.dll` (**dynamic link library**), and
    it cannot be executed standalone.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, if an assembly is compiled as an application, then it has the file
    extension `.exe` (**executable**) and can be executed standalone. Before .NET
    Core 3, console apps were compiled to `.dll` files and had to be executed by the
    `dotnet run` command or a host executable.
  prefs: []
  type: TYPE_NORMAL
- en: Any assembly can reference one or more class library assemblies as dependencies,
    but you cannot have circular references. So assembly *B* cannot reference assembly
    *A* if assembly *A* already references assembly *B*. The compiler will warn you
    if you attempt to add a dependency reference that would cause a circular reference.
    Circular references are often a warning sign of poor code design. If you are sure
    that you need a circular reference, then use an interface to solve it.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft .NET project SDKs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, console applications have a dependency reference on the Microsoft
    .NET project SDK. This platform contains thousands of types in NuGet packages
    that almost all applications would need, such as the `System.Int32` and `System.String`
    types.
  prefs: []
  type: TYPE_NORMAL
- en: When using .NET, you reference the dependency assemblies, NuGet packages, and
    platforms that your application needs in a project file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore the relationship between assemblies and namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to create a new project, as defined in the following
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console App** / `console`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `AssembliesAndNamespaces`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `Chapter07`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open `AssembliesAndNamespaces.csproj`, and note that it is a typical project
    file for a .NET application, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the `<PropertyGroup>` section, add a new `<ItemGroup>` section to statically
    import `System.Console` for all C# files, using the implicit usings .NET SDK feature,
    as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: PropertyGroup element
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `PropertyGroup` element is used to define configuration properties that
    control the build process. These properties can include anything, from the output
    path of the compiled binaries to versioning information. Each property within
    a `PropertyGroup` is defined as a simple name-value pair, as shown in the following
    markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OutputType` specifies the type of output, such as an executable (`Exe`) or
    a library (`Library`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TargetFramework` specifies the target framework for the project, for example,
    `net9.0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RootNamespace` sets the default namespace for the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ItemGroup element
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ItemGroup` element is used to define collections of items that are included
    in the build process. Items can be source files, references to other assemblies,
    package references, and other resources.
  prefs: []
  type: TYPE_NORMAL
- en: You often want to define multiple `ItemGroup` elements for different purposes.
    They will all be merged at build time. For example, you might have one `ItemGroup`
    for all your project references and a separate `ItemGroup` for all your package
    references.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ItemGroup` element can have a `Label` attribute so that you can document
    what each section should be used for, as shown in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Label and Condition attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Both `PropertyGroup` and `ItemGroup` can have a `Label` attribute that can
    be used to document the purpose of the element, and a `Condition` attribute that
    can be used to define when they apply. For example, a typical condition might
    be when building a `DEBUG` release, as shown in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Warning!** `PropertyGroup` and `ItemGroup` elements are both at the same
    level within a root `Project` element. Do not nest `ItemGroup` elements within
    `PropertyGroup` elements, or vice versa!'
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces and types in assemblies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many common .NET types are in the `System.Runtime.dll` assembly. There is not
    always a one-to-one mapping between assemblies and namespaces. A single assembly
    can contain many namespaces, and a namespace can be defined in many assemblies.
    You can see the relationship between some assemblies and the namespaces that they
    supply types for in *Table 7.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Assembly** | **Example namespaces** | **Example types** |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Runtime.dll` | `System`, `System.Collections`, `System.Collections.Generic`
    | `Int32`, `String`, `IEnumerable<T>` |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Console.dll` | `System` | `Console` |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Threading.dll` | `System.Threading` | `Interlocked`, `Monitor`, `Mutex`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Xml.XDocument.dll` | `System.Xml.Linq` | `XDocument`, `XElement`,
    `XNode` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 7.1: Examples of assemblies and their namespaces'
  prefs: []
  type: TYPE_NORMAL
- en: NuGet packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET is split into a set of packages, distributed using a Microsoft-supported
    package management technology named NuGet. Each of these packages represents a
    single assembly of the same name. For example, the `System.Collections` package
    contains the `System.Collections.dll` assembly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the benefits of packages:'
  prefs: []
  type: TYPE_NORMAL
- en: Packages can be easily distributed on public feeds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages can be reused.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages can ship on their own schedule.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages can be tested independently of other packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages can support different OSes and CPUs by including multiple versions
    of the same assembly, built for different OSes and CPUs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages can have dependencies specific to only one library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apps are smaller because unreferenced packages aren’t part of the distribution.
    *Table 7.2* lists some of the more important packages and their important types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Package** | **Important types** |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Runtime` | `Object`, `String`, `Int32`, `Array` |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Collections` | `List<T>`, `Dictionary<TKey, TValue>` |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Net.Http` | `HttpClient`, `HttpResponseMessage` |'
  prefs: []
  type: TYPE_TB
- en: '| `System.IO.FileSystem` | `File`, `Directory` |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Reflection` | `Assembly`, `TypeInfo`, `MethodInfo` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 7.2: Some important packages and their important types'
  prefs: []
  type: TYPE_NORMAL
- en: Package sources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Package sources are locations where NuGet can look for packages, such as [https://www.nuget.org](https://www.nuget.org),
    local directories, or other package repositories. The `nuget.config` file allows
    you to specify, prioritize, and configure these sources, as well as other related
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `nuget.config` file uses XML to define package sources, as shown in the
    following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<packageSources>`: This section lists all the sources NuGet will use to look
    for packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<add key="sourceName" value="sourceUrl"/>`: Each `<add>` element defines a
    package source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NuGet can use multiple `nuget.config` files located in different directories.
    The settings are applied in a specific order, with the most specific settings
    taking precedence:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Project directory: `nuget.config` in the project directory.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Solution directory: `nuget.config` in the solution directory.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'User directory: `nuget.config` in the user’s profile directory—for example,
    `%AppData%\nuget\nuget.config` on Windows.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Machine-wide configuration: `nuget.config` in the machine-wide settings—for
    example, `%ProgramFiles(x86)%\nuget\config` on Windows.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: NuGet merges these configurations, with settings from more specific files overriding
    those from less specific files.
  prefs: []
  type: TYPE_NORMAL
- en: If no `nuget.config` file is found, NuGet uses the default package source, which
    is usually the official NuGet.org repository. This means that, by default, tools
    like Visual Studio, `dotnet`, and `nuget.exe` will look for packages on NuGet.org
    unless otherwise configured.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a two-way relationship between frameworks and packages. Packages define
    the APIs, while frameworks group packages. A framework without any packages would
    not define any APIs.
  prefs: []
  type: TYPE_NORMAL
- en: '.NET packages each support a set of frameworks. For example, the `System.IO.FileSystem`
    package version 4.3.0 supports the following frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: .NET Standard, version 1.3 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Framework, version 4.6 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Six Mono and Xamarin platforms (for example, Xamarin.iOS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**More Information**: You can read the details at the following link: [https://www.nuget.org/packages/System.IO.FileSystem/#supportedframeworks-body-tab](https://www.nuget.org/packages/System.IO.FileSystem/#supportedframeworks-body-tab).'
  prefs: []
  type: TYPE_NORMAL
- en: Importing a namespace to use a type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore how namespaces are related to assemblies and types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `AssembliesAndNamespaces` project, in `Program.cs`, delete the existing
    statements, and then enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Recent versions of code editors will often automatically add a namespace import
    statement to fix the problem I want you to see. Please delete the `using` statement
    that your code editor writes for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the project and note the compiler error message, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `XDocument` type is not recognized because we have not told the compiler
    what the namespace of the type is. Although this project already has a reference
    to the assembly that contains the type, we also need to either prefix the type
    name with its namespace (for example, `System.Xml.Linq.XDocument`) or import the
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Click inside the `XDocument` class name. Your code editor displays a light bulb,
    showing that it recognizes the type and can automatically fix the problem for
    you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the light bulb, and select `using System.Xml.Linq;` from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will *import the namespace* by adding a `using` statement to the top of
    the file. Once a namespace is imported at the top of a code file, all the types
    within the namespace are available for use in that code file by just typing their
    name, without the type name needing to be fully qualified by prefixing it with
    its namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'I like to add a comment after importing a namespace to remind me why I need
    to import it, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you do not comment on your namespaces, you or other developers will not know
    why they are imported and might delete them, breaking the code. Conversely, they
    might never delete imported namespaces “just in case” they are needed, potentially
    cluttering the code unnecessarily. This is why most modern code editors have features
    to remove unused namespaces. This technique also subconsciously trains you, while
    you are learning, to remember which namespace you need to import to use a particular
    type or extension method.
  prefs: []
  type: TYPE_NORMAL
- en: Relating C# keywords to .NET types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the common questions I get from new C# programmers is, “What is the difference
    between `string` with a lowercase s and `String` with an uppercase S?”
  prefs: []
  type: TYPE_NORMAL
- en: 'The short answer is easy: none. The long answer is that all C# keywords that
    represent types like `string` or `int` are aliases for a .NET type in a class
    library assembly.'
  prefs: []
  type: TYPE_NORMAL
- en: When you use the `string` keyword, the compiler recognizes it as a `System.String`
    type. When you use the `int` type, the compiler recognizes it as a `System.Int32`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see this in action with some code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, declare two variables to hold `string` values, one using lowercase
    `string` and one using uppercase `String`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the `AssembliesAndNamespaces` project, and note that `string` and `String`
    both work and literally mean the same thing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `AssembliesAndNamespaces.csproj`, add an entry to prevent the `System` namespace
    from being globally imported, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, and the **Error List** or **PROBLEMS** window, note the compiler
    error message, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the top of `Program.cs`, import the `System` namespace with a `using` statement
    that will fix the error, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: When you have a choice, use the C# keyword instead of the
    actual type because the keywords do not need a namespace to be imported.'
  prefs: []
  type: TYPE_NORMAL
- en: Mapping C# aliases to .NET types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Table 7.3* shows the 18 C# type keywords along with their actual .NET types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Keyword** | **.NET type** |  | **Keyword** | **.NET type** |'
  prefs: []
  type: TYPE_TB
- en: '| `string` | `System.String` |  | `char` | `System.Char` |'
  prefs: []
  type: TYPE_TB
- en: '| `sbyte` | `System.SByte` |  | `byte` | `System.Byte` |'
  prefs: []
  type: TYPE_TB
- en: '| `short` | `System.Int16` |  | `ushort` | `System.UInt16` |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | `System.Int32` |  | `uint` | `System.UInt32` |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | `System.Int64` |  | `ulong` | `System.UInt64` |'
  prefs: []
  type: TYPE_TB
- en: '| `nint` | `System.IntPtr` |  | `nuint` | `System.UIntPtr` |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | `System.Single` |  | `double` | `System.Double` |'
  prefs: []
  type: TYPE_TB
- en: '| `decimal` | `System.Decimal` |  | `bool` | `System.Boolean` |'
  prefs: []
  type: TYPE_TB
- en: '| `object` | `System.Object` |  | `dynamic` | `System.Dynamic.DynamicObject`
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 7.3: C# type keywords and their actual .NET types'
  prefs: []
  type: TYPE_NORMAL
- en: Other .NET programming language compilers can do the same thing. For example,
    the Visual Basic .NET language has a type named `Integer`, which is its alias
    for `System.Int32`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding native-sized integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C# 9 introduced the `nint` and `nuint` keyword aliases for **native-sized integers**,
    meaning that the storage size for the integer value is platform-specific. They
    store a 32-bit integer in a 32-bit process and `sizeof()` returns 4 bytes; they
    store a 64-bit integer in a 64-bit process and `sizeof()` returns 8 bytes. The
    aliases represent pointers to the integer value in memory, which is why their
    .NET names are `IntPtr` and `UIntPtr`. The actual storage type will be either
    `System.Int32` or `System.Int64`, depending on the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a 64-bit process, the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'produces this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Revealing the location of a type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most code editors provide built-in documentation for .NET types. Let’s start
    by making sure that you have the expected experience with Visual Studio by checking
    that you have the relevant option set correctly, and then explore:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Visual Studio, then make sure you have disabled the Source
    Link feature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Tools** | **Options**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the search box, enter `navigation to source`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Advanced** in the **Text Editor** | **C#** section.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Clear the **Enable navigation to Source Link and Embedded sources** checkbox,
    and then click **OK**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on `XDocument` and choose **Go to Definition**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to the top of the code file, expand the collapsed region, and note
    that the assembly filename is `System.Xml.XDocument.dll` but the class is in the
    `System.Xml.Linq` namespace, as shown in the following code and *Figure 7.1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![](img/B22322_07_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Assembly and namespace that contains the XDocument type'
  prefs: []
  type: TYPE_NORMAL
- en: Close the **XDocument [from metadata]** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click inside `string` or `String` and choose **Go to Definition**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the top of the code file, expand the collapsed region, and note
    that the assembly filename is `System.Runtime.dll` but the class is in the `System`
    namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your code editor is technically lying to you. If you remember when we wrote
    code in *Chapter 2*, *Speaking C#*, when we revealed the extent of the C# vocabulary,
    we discovered that the `System.Runtime.dll` assembly contains zero types.
  prefs: []
  type: TYPE_NORMAL
- en: What the `System.Runtime.dll` assembly does contain are type-forwarders. These
    are special types that appear to exist in an assembly but are implemented elsewhere.
    In this case, they are implemented deep inside the .NET runtime using highly optimized
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might want to use a type-forwarder if you refactor a type to move it from
    its original assembly to a different one. Without defining a type-forwarder, any
    projects that reference the original assembly will not find the type in it, and
    a runtime exception will be thrown. You can read more about this contrived example
    at the following link: [https://learn.microsoft.com/en-us/dotnet/standard/assembly/type-forwarding](https://learn.microsoft.com/en-us/dotnet/standard/assembly/type-forwarding).'
  prefs: []
  type: TYPE_NORMAL
- en: Sharing code with legacy platforms using .NET Standard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before .NET Standard, there were **Portable Class Libraries** (**PCLs**). With
    PCLs, you could create a library of code and explicitly specify which platforms
    you want the library to support, such as Xamarin, Silverlight, and Windows 8\.
    Your library could then use the intersection of APIs that are supported by the
    specified platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft realized that this was unsustainable, so they created .NET Standard—a
    single API that all future .NET platforms would support. There are older versions
    of .NET Standard, but .NET Standard 2.0 was an attempt to unify all important
    recent .NET platforms. .NET Standard 2.1 was released in late 2019, but only .NET
    Core 3.0 and that year’s version of Xamarin support its new features. For the
    rest of this book, I will use the term .NET Standard to mean .NET Standard 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Standard is like HTML5 in that they are both standards that a platform
    should support. Just as Google’s Chrome browser and Microsoft’s Edge browser implement
    the HTML5 standard, .NET Core, .NET Framework, and Xamarin all implement .NET
    Standard. If you want to create a library of types that will work across variants
    of legacy .NET, you can do so most easily with .NET Standard.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Since many of the API additions in .NET Standard 2.1 required
    runtime changes, and .NET Framework is Microsoft’s legacy platform, which needs
    to remain as unchanged as possible, .NET Framework 4.8 remained on .NET Standard
    2.0 rather than implementing .NET Standard 2.1\. If you need to support .NET Framework
    customers, then you should create class libraries on .NET Standard 2.0, even though
    it is not the latest and does not support all the recent language and BCL new
    features.'
  prefs: []
  type: TYPE_NORMAL
- en: Your choice of which .NET Standard version to target comes down to a balance
    between maximizing platform support and available functionality. An older version
    supports more platforms but has a smaller set of APIs. A newer version supports
    fewer platforms but has a larger set of APIs. Generally, you should choose the
    lowest version that supports all the APIs that you need.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding defaults for class libraries with different SDKs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using the `dotnet` SDK tool to create a class library, it might be useful
    to know which target framework will be used by default, as shown in *Table 7.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SDK** | **Default target framework for new class libraries** |'
  prefs: []
  type: TYPE_TB
- en: '| .NET Core 3.1 | `netstandard2.0` |'
  prefs: []
  type: TYPE_TB
- en: '| .NET 6 | `net6.0` |'
  prefs: []
  type: TYPE_TB
- en: '| .NET 7 | `net7.0` |'
  prefs: []
  type: TYPE_TB
- en: '| .NET 8 | `net8.0` |'
  prefs: []
  type: TYPE_TB
- en: '| .NET 9 | `net9.0` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 7.4: .NET SDKs and their default target framework for new class libraries'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, just because a class library targets a specific version of .NET by
    default, it does not mean that you cannot change it after creating a class library
    project using the default template.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can manually set the target framework to a value that supports the projects
    that need to reference that library, as shown in *Table 7.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class library target framework** | **Can be used by projects that target
    the following** |'
  prefs: []
  type: TYPE_TB
- en: '| `netstandard2.0` | .NET Framework 4.6.1 or later, .NET Core 2 or later, .NET
    5 or later, Mono 5.4 or later, Xamarin.Android 8 or later, and Xamarin.iOS 10.14
    or later |'
  prefs: []
  type: TYPE_TB
- en: '| `netstandard2.1` | .NET Core 3 or later, .NET 5 or later, Mono 6.4 or later,
    Xamarin.Android 10 or later, and Xamarin.iOS 12.16 or later |'
  prefs: []
  type: TYPE_TB
- en: '| `net6.0` | .NET 6 or later |'
  prefs: []
  type: TYPE_TB
- en: '| `net7.0` | .NET 7 or later |'
  prefs: []
  type: TYPE_TB
- en: '| `net8.0` | .NET 8 or later |'
  prefs: []
  type: TYPE_TB
- en: '| `net9.0` | .NET 9 or later |'
  prefs: []
  type: TYPE_TB
- en: 'Table 7.5: Class library target frameworks and the projects that can use them'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Always check the target framework of a class library, and
    then manually change it to something more appropriate if necessary. Make a conscious
    decision about what it should be rather than accepting the default.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a .NET Standard class library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a class library using .NET Standard 2.0 so that it can be used
    across all important .NET legacy platforms and cross-platform on Windows, macOS,
    and Linux OSes, while also having access to a wide set of .NET APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to add a new **Class Library** / `classlib`
    project, named `SharedLibrary`, that targets .NET Standard 2.0 for the `Chapter07`
    solution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you use Visual Studio, when prompted for the **Target Framework**, select
    **.NET Standard 2.0**, and then configure the startup project for the solution
    to the current selection.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you use VS Code, include a switch to target .NET Standard 2.0, as shown
    in the following command:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: If you need to create types that use new features in .NET
    9, as well as types that only use .NET Standard 2.0 features, then you can create
    two separate class libraries: one targeting .NET Standard 2.0 and one targeting
    .NET 0.'
  prefs: []
  type: TYPE_NORMAL
- en: Build the `SharedLibrary` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An alternative to manually creating two class libraries is to create one that
    supports **multi-targeting**. If you would like me to add a section about multi-targeting
    to the next edition, please let me know. You can read about multi-targeting here:
    [https://learn.microsoft.com/en-us/dotnet/standard/library-guidance/cross-platform-targeting#multi-targeting](https://learn.microsoft.com/en-us/dotnet/standard/library-guidance/cross-platform-targeting#multi-targeting).'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the .NET SDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, executing `dotnet` commands uses the highest version of the .NET
    SDK installed. There may be times when you want to control which SDK is used.
  prefs: []
  type: TYPE_NORMAL
- en: For example, once .NET 10 becomes available in preview, starting in February
    2025, or the final version becomes available in November 2025, you might install
    it. But you would probably want your experience to match the book steps, which
    use the .NET 9 SDK. But once you install a .NET 10 SDK, it will be used by default.
  prefs: []
  type: TYPE_NORMAL
- en: You can control the .NET SDK used by default by using a `global.json` file,
    which contains the version to use. The `dotnet` command searches the current folder
    and then each ancestor folder in turn for a `global.json` file, seeing if it should
    use a different .NET SDK version.
  prefs: []
  type: TYPE_NORMAL
- en: 'You do not need to complete the following steps, but if you want to try and
    do not already have .NET 8 SDK installed, then you can install it from the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://dotnet.microsoft.com/download/dotnet/8.0](https://dotnet.microsoft.com/download/dotnet/8.0)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a subdirectory/folder in the `Chapter07` folder named `ControlSDK`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On Windows, start **Command Prompt** or **Windows Terminal**. On macOS, start
    **Terminal**. If you are using VS Code, then you can use the integrated terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `ControlSDK` folder, at the command prompt or terminal, enter a command
    to list the installed .NET SDKs, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the results and the version number of the latest .NET 8 SDK installed,
    as shown highlighted in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `global.json` file that forces the use of the latest .NET 8 SDK that
    you have installed (which might be later than mine), as shown in the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use your preferred code editor to open the `global.json` file and review its
    contents, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For example, to open it with VS Code, enter the command `code global.json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ControlSDK` folder, at the command prompt or terminal, enter a command
    to create a class library project, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you do not have the .NET 8 SDK installed, then you will see an error, as
    shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you do have the .NET 8 SDK installed, then a class library project will
    be created that targets .NET 8 by default, as shown highlighted in the following
    markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Mixing SDKs and framework targets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many organizations decide to target a long-term support version of .NET to get
    up to three years of support from Microsoft. Doing this does not mean you lose
    the benefits of improvements to the C# language during the lifetime of the .NET
    runtime that you need to target.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily continue to target the .NET 9 runtime while installing and using
    future C# compilers, as shown in *Figure 7.2* and illustrated in the following
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**November 2024**: Install .NET SDK 9.0.100, and use it to build projects that
    target .NET 9 and use the C# 13 compiler by default. Every month, update to .NET
    9 SDK patches on the development computer and update to .NET 9 runtime patches
    on any deployment computers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**February 2025**: Optionally, install .NET SDK 10 Preview 1 to explore the
    new C# 14 language and .NET 10 library features. Note that you won’t be able to
    use new library features while targeting .NET 9\. Previews are released monthly
    between February and October each year. Read the monthly announcements to find
    out about the new features in that preview at the following link: [https://github.com/dotnet/Announcements/issues](https://github.com/dotnet/Announcements/issues).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**November 2025**: Install .NET SDK 10.0.100, and use it to build projects
    that continue to target .NET 9 and use the C# 14 compiler for its new features.
    You will use a fully supported SDK and fully supported runtime.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**February 2026**: Optionally, install .NET 11 previews to explore new C# 15
    language and .NET 11 library features. Start planning for any new library and
    ASP.NET Core features in .NET 10 and .NET 11 that can be applied to your .NET
    9 projects when you are ready to migrate.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**November 2026**: Install .NET 11.0.100 SDK, and use it to build projects
    that target .NET 10 and use the C# 15 compiler.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_07_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Targeting .NET 8 for long-term support while using the latest C#
    compilers'
  prefs: []
  type: TYPE_NORMAL
- en: When deciding to install a .NET SDK, remember that the latest is used by default
    to build any .NET projects. Once you’ve installed a .NET 9 SDK preview, it will
    be used by default for all projects, unless you force the use of an older, fully
    supported SDK version like 8.0.100 or a later patch.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing your code for deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you write a novel and you want other people to read it, you must publish
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Most developers write code for other developers to use in their own projects,
    or for users to run as an app. To do so, you must publish your code as packaged
    class libraries or executable applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three ways to publish and deploy a .NET application. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Framework-dependent deployment** (**FDD**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Framework-dependent executable** (**FDE**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Self-contained**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you choose to deploy your application and its package dependencies, but not
    .NET itself, then you rely on .NET already being on the target computer. This
    works well for web applications deployed to a server because .NET and lots of
    other web applications are likely already on the server.
  prefs: []
  type: TYPE_NORMAL
- en: FDD means you deploy a DLL that must be executed by the `dotnet` command-line
    tool. FDE means you deploy an EXE that can be run directly from the command line.
    Both require the appropriate version of the .NET runtime to be installed on a
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you want to be able to give someone a USB stick containing your application,
    built for their OS, and know that it can execute on their computer. You would
    want to perform a self-contained deployment. While the size of the deployment
    files will be larger, you’ll know that it will work.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a console app to publish
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore how to publish a console app:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `DotNetEverywhere` to the `Chapter07` solution. Make sure you target .NET
    9.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the project file to statically import the `System.Console` class into
    all C# files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements, and then add a statement to
    output a message, saying that the console app can run everywhere, and some information
    about the OS, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `DotNetEverywhere` project, and note the results when run on Windows
    11, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `DotNetEverywhere.csproj`, add the **runtime identifiers** (**RIDs**) to
    target three OSes inside the `<PropertyGroup>` element, as shown highlighted in
    the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `win-x64` RID value means Windows on an x64-compatible CPU. Use the `win-arm64`
    RID value to deploy to a Windows ARM device.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `osx-arm64` RID value means macOS on Apple Silicon.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `linux-x64` RID value means most desktop distributions of Linux, like Ubuntu,
    CentOS, Debian, or Fedora on an x64-compatible CPU. Use `linux-arm` for Raspbian
    or Raspberry Pi OS 32-bit. Use `linux-arm64` for a Raspberry Pi running Ubuntu
    64-bit.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can check the latest allowed RID values at the following link: [https://learn.microsoft.com/en-us/dotnet/core/rid-catalog#known-rids](https://learn.microsoft.com/en-us/dotnet/core/rid-catalog#known-rids).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** There are two elements that you can use to specify runtime identifiers.
    Use `<RuntimeIdentifier>` if you only need to specify one. Use `<RuntimeIdentifiers>`
    if you need to specify multiple, as we did in the preceding example. If you use
    the wrong one, then the compiler will give an error, and it can be difficult to
    understand why with only one character difference!'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding dotnet commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you install the .NET SDK, it includes a **command-line interface** (**CLI**)
    named `dotnet`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The .NET CLI has commands that work on the current folder to create a new project,
    using templates:'
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, start **Command Prompt** or **Windows Terminal**. On macOS, start
    **Terminal**. If you prefer to use Visual Studio or VS Code, then you can use
    the integrated terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the `dotnet new list` (or `dotnet new -l` or `dotnet new --list` with
    older SDKs) command to list your currently installed templates, the most common
    of which are shown in *Table 7.6*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Template Name** | **Short Name** | **Language** |'
  prefs: []
  type: TYPE_TB
- en: '| `.NET MAUI App` | `maui` | C# |'
  prefs: []
  type: TYPE_TB
- en: '| `.NET MAUI Blazor App` | `maui-blazor` | C# |'
  prefs: []
  type: TYPE_TB
- en: '| `ASP.NET Core Empty` | `web` | C# and F# |'
  prefs: []
  type: TYPE_TB
- en: '| `ASP.NET Core gRPC Service` | `grpc` | C# |'
  prefs: []
  type: TYPE_TB
- en: '| `ASP.NET Core Web API` | `webapi` | C# and F# |'
  prefs: []
  type: TYPE_TB
- en: '| `ASP.NET Core Web API (native AOT)` | `webapiaot` | C# |'
  prefs: []
  type: TYPE_TB
- en: '| `ASP.NET Core Web App (Model-View-Controller)` | `mvc` | C# and F# |'
  prefs: []
  type: TYPE_TB
- en: '| `Blazor Web App` | `blazor` | C# |'
  prefs: []
  type: TYPE_TB
- en: '| `Class Library` | `classlib` | C#, F#, and VB |'
  prefs: []
  type: TYPE_TB
- en: '| `Console App` | `console` | C#, F#, and VB |'
  prefs: []
  type: TYPE_TB
- en: '| `EditorConfig File` | `editorconfig` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `global.json File` | `globaljson` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `Solution File` | `sln` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `xUnit Test Project` | `xunit` |  |'
  prefs: []
  type: TYPE_TB
- en: 'Table 7.6: Project template full and short names'
  prefs: []
  type: TYPE_NORMAL
- en: '.NET MAUI projects are not supported for Linux. The team has said they have
    left that work to the open source community. If you need to create a truly cross-platform
    graphical app, then take a look at Avalonia at the following link: [https://avaloniaui.net/](https://avaloniaui.net/).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting information about .NET and its environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is useful to see what .NET SDKs and runtimes are currently installed, alongside
    information about the OS, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the results, as shown in the following partial output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Managing projects using the dotnet CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The .NET CLI has the following commands that work on the project in the current
    folder, enabling you to manage the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dotnet help`: This shows the command-line help.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet new`: This creates a new .NET project or file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet tool`: This installs or manages tools that extend the .NET experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet workload`: This manages optional workloads like .NET MAUI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet restore`: This downloads dependencies for the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet build`: This builds, aka compiles, a .NET project. A new switch introduced
    with .NET 8 is `--tl` (meaning terminal logger), which provides a modern output.
    For example, it provides real-time information about what the build is doing.
    You can learn more at the following link: [https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-build#options](https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-build#options).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet build-server`: This interacts with servers started by a build.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet msbuild`: This runs MS Build Engine commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet clean`: This removes the temporary outputs from a build.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet test`: This builds and then runs unit tests for the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet run`: This builds and then runs the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet pack`: This creates a NuGet package for the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet publish`: This builds and then publishes the project, either with dependencies
    or as a self-contained application. In .NET 7 and earlier, this published the
    `Debug` configuration by default. In .NET 8 and later, it now publishes the `Release`
    configuration by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet add`: This adds a reference to a package or class library to the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet remove`: This removes a reference to a package or class library from
    the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet list`: This lists the package or class library references for the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet package search`: This allows you to search one or more package sources
    for packages that match a search term. The command format is `dotnet package search
    [search term] [options]`. You can learn more at the following link: [https://devblogs.microsoft.com/nuget/announcing-nuget-6-9/#support-for-dotnet-search-command](https://devblogs.microsoft.com/nuget/announcing-nuget-6-9/#support-for-dotnet-search-command).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing a self-contained app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you have seen some example `dotnet` tool commands, we can publish
    our cross-platform console app:'
  prefs: []
  type: TYPE_NORMAL
- en: At the command prompt or terminal, make sure that you are in the `DotNetEverywhere`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter a command to build and publish the self-contained release version of
    the console application for Windows, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The publishing process can take a while, so be patient.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note that the build engine restores any needed packages, compiles the project
    source code into an assembly DLL, and creates a `publish` folder, as shown in
    the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following commands to build and publish the release versions for
    the macOS and Linux variants, as shown in the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: You could automate these commands by using a scripting language
    like PowerShell and execute the script file on any OS, using the cross-platform
    PowerShell Core. I have done this for you at the following link: [https://github.com/markjprice/cs13net9/tree/main/scripts/publish-scripts](https://github.com/markjprice/cs13net9/tree/main/scripts/publish-scripts).'
  prefs: []
  type: TYPE_NORMAL
- en: Open Windows **File Explorer** or a macOS **Finder** window, navigate to `DotNetEverywhere\bin\Release\net9.0`,
    and note the output folders for the five OSes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `win-x64` folder, open the `publish` folder, and note all the supporting
    assemblies, like `Microsoft.CSharp.dll`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the `DotNetEverywhere` executable file, and note that it is 154 KB,
    as shown in *Figure 7.3*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_07_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: The DotNetEverywhere executable file for Windows 64-bit'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are on Windows with an x64-compatible chip, then double-click to execute
    the program and note the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I executed the program on my Surface Laptop 7, so I targeted and built for the
    `win-arm64` architecture. The preceding output shows the results on my computer.
  prefs: []
  type: TYPE_NORMAL
- en: Press any key to close the console app and its window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the total size of the `publish` folder and all its files is 68.3 MB.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `osx-arm64` folder, select the `publish` folder, note all the supporting
    assemblies, and then select the `DotNetEverywhere` executable file. Note that
    the executable is 125 KB and the `publish` folder is about 73.9 MB. There is no
    `.exe` file extension for published applications on macOS, so the filename will
    not have an extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you copy any of those `publish` folders to the appropriate **operating system**
    (**OS**), the console app will run; this is because it is a self-contained, deployable
    .NET application. For example, here it is on macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This example used a console app, but you could just as easily create an ASP.NET
    Core website or web service, or a Windows Forms or WPF app. Of course, you can
    only deploy Windows desktop apps to Windows computers, not Linux or macOS.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing a single-file app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you know that .NET is already installed on the computer on which you want
    to run your app, then you can use the extra flags when you publish your app for
    release to say that it does not need to be self-contained and that you want to
    publish it as a single file (if possible), as shown in the following command (which
    must be entered on a single line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate two files: `DotNetEverywhere.exe` and `DotNetEverywhere.pdb`.
    The `.exe` file is the executable. The `.pdb` file is a **program debug database**
    file that stores debugging information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer the `.pdb` file to be embedded in the `.exe` file (for example,
    to ensure that it is deployed with its assembly), then add a `<DebugType>` element
    to the `<PropertyGroup>` element in your `.csproj` file and set it to `embedded`,
    as shown highlighted in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If you cannot assume that .NET is already installed on a computer, then although
    Linux also only generates the two files, expect the following additional files
    for Windows: `coreclr.dll`, `clrjit.dll`, `clrcompression.dll`, and `mscordaccore.dll`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example for Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the command prompt or terminal, in the `DotNetEverywhere` folder, enter
    the command to build the self-contained release version of the console app for
    Windows, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Navigate to the `DotNetEverywhere\bin\Release\net9.0\win-x64\publish` folder
    and select the `DotNetEverywhere` executable file. Note that the executable is
    now 62.6 MB, and there is also a `.pdb` file that is 11 KB. The sizes of these
    files on your system will vary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reducing the size of apps using app trimming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the problems with deploying a .NET app as a self-contained app is that
    the .NET libraries take up a lot of space. One of the biggest needs is to reduce
    the size of Blazor WebAssembly components because all the .NET libraries need
    to be downloaded to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, you can reduce this size by not packaging unused assemblies with your
    deployments. Introduced with .NET Core 3, the app trimming system can identify
    the assemblies needed by your code and remove those that are not needed. This
    was known as `copyused` trim mode.
  prefs: []
  type: TYPE_NORMAL
- en: With .NET 5, the trimming went further by removing individual types, and even
    members, like methods from within an assembly if they are not used. For example,
    with a **Hello World** console app, the `System.Console.dll` assembly is trimmed
    from 61.5 KB to 31.5 KB. This was known as `link` trim mode, but it was not enabled
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: With .NET 6, Microsoft added annotations to their libraries to indicate how
    they can be safely trimmed, so the trimming of types and members was made the
    default.
  prefs: []
  type: TYPE_NORMAL
- en: With .NET 7, Microsoft renamed `link` to `full` and `copyused` to `partial`.
  prefs: []
  type: TYPE_NORMAL
- en: The catch is how well the trimming identifies unused assemblies, types, and
    members. If your code is dynamic, perhaps using reflection, then it might not
    work correctly, so Microsoft also allows manual control.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to enable type-level and member-level, aka `full`, trimming.
    Since this level of trimming is the default with .NET 6 or later, all we need
    to do is enable trimming without setting a trim level or mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first way is to add an element to the project file, as shown in the following
    markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The second way is to add a flag when publishing, as shown highlighted in the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: There are two ways to enable assembly-level, aka `partial`, trimming.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first way is to add two elements to the project file, as shown in the following
    markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The second way is to add two flags when publishing, as shown highlighted in
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Controlling where build artifacts are created
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Traditionally, each project has its own `bin` and `obj` subfolders where temporary
    files are created during the build process. When you publish, the files are created
    in the `bin` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might prefer to put all these temporary files and folders somewhere else.
    Introduced with .NET 8 is the ability to control where build artifacts are created.
    Let’s see how:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the command prompt or terminal for the `Chapter07` folder, enter the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the success message, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We could have created this file in the `cs13net9` folder, and it would then
    affect all projects in all chapters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `Chapter07` folder, open the `Directory.Build.props` file, as shown
    in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build any project or the whole solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Chapter07` folder, note that there is now an `artifacts` folder that
    contains subfolders for any recently built projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can delete this file, or rename it to something like `Directory.Build.props.disabled`
    so that it does not affect the rest of this chapter by building these artifacts
    in a folder that you do not expect based on default behavior. This is optional
    but recommended.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Warning!** If you leave this build configuration enabled, then remember that
    your build artifacts are now created in this new folder structure.'
  prefs: []
  type: TYPE_NORMAL
- en: Native ahead-of-time compilation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Native AOT produces assemblies that are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Self-contained**, meaning they can run on systems that do not have the .NET
    runtime installed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ahead-of-time (AOT) compiled for native code**, meaning a faster startup
    time and a potentially smaller memory footprint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native AOT compiles IL code to native code at the time of writing, rather than
    at runtime using the **Just in Time (JIT)** compiler. But native AOT assemblies
    must target a specific runtime environment like Windows x64 or Linux Arm.
  prefs: []
  type: TYPE_NORMAL
- en: Since native AOT happens at publish time, you should remember that while you
    are debugging and working live on a project in your code editor, it still uses
    the runtime JIT compiler, not native AOT, even if you have AOT enabled in the
    project!
  prefs: []
  type: TYPE_NORMAL
- en: However, some features that are incompatible with native AOT will be disabled
    or throw exceptions, and a source analyzer is enabled to show warnings about potential
    code incompatibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of native AOT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Native AOT has limitations that apply to projects that enable it, some of which
    are shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: No dynamic loading of assemblies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No runtime code generation, for example, using `System.Reflection.Emit`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It requires trimming, which has its own limitations, as we covered in the previous
    section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The projects must be self-contained, so they must embed any libraries they call,
    which increases their size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although your own assemblies might not use the features listed above, major
    parts of .NET itself do. For example, ASP.NET Core MVC (including web API services
    that use controllers) and EF Core do runtime code generation to implement their
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET teams are hard at work making as much of .NET compatible with native
    AOT as possible, as soon as possible. But .NET 9 only includes basic support for
    ASP.NET Core if you use Minimal APIs, and no support for EF Core.
  prefs: []
  type: TYPE_NORMAL
- en: My guess is that .NET 10 will include support for ASP.NET Core MVC and some
    parts of EF Core, but it could take until .NET 11 or .NET 12 before we can all
    confidently use most of .NET and know we can build our assemblies with native
    AOT to gain the benefits.
  prefs: []
  type: TYPE_NORMAL
- en: The native AOT publishing process includes code analyzers to warn you if you
    use any features that are not supported, but not all packages have been annotated
    to work well with these yet.
  prefs: []
  type: TYPE_NORMAL
- en: The most common annotation used to indicate that a type or member does not support
    AOT is the `[RequiresDynamicCode]` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: You can learn more about AOT warnings at the following
    link: [https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/fixing-warnings](https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/fixing-warnings).'
  prefs: []
  type: TYPE_NORMAL
- en: Reflection and native AOT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reflection is frequently used for runtime inspection of type `metadata`, dynamic
    invocation of members, and code generation.
  prefs: []
  type: TYPE_NORMAL
- en: Native AOT does allow some reflection features, but the trimming performed during
    the native AOT compilation process cannot statically determine when a type has
    members that might be only accessed via reflection. These members would be removed
    by AOT, which would then cause a runtime exception.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Developers must annotate their types with `[DynamicallyAccessedMembers]`
    to indicate a member that is only dynamically accessed via reflection and should,
    therefore, be left untrimmed.'
  prefs: []
  type: TYPE_NORMAL
- en: Requirements for native AOT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are additional requirements for different OSes:'
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, you must install the Visual Studio **Desktop development with C++**
    workload with all default components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On Linux, you must install the compiler toolchain and developer packages for
    libraries that the .NET runtime depends on. For example, for Ubuntu 18.04 or later:
    `sudo apt-get install clang zlib1g-dev`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Warning!** Cross-platform native AOT publishing is not supported. This means
    that you must run the publish action on the OS that you will deploy to. For example,
    you cannot publish a native AOT project on Linux to later run on Windows, and
    vice versa.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling native AOT for a project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To enable native AOT publishing in a project, add the `<PublishAot>` element
    to the project file, as shown highlighted in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Building a native AOT project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s see a practical example using the new AOT option for a console app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the solution named `Chapter07`, add a native AOT-compatible console app
    project, as defined in the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console App** / `console --aot`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `Chapter07`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `AotConsole`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Do not use top-level statements: Cleared'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enable native AOT publish: Selected'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If your code editor does not yet provide the option for AOT, create a traditional
    console app, and then you will need to manually enable AOT, as shown in step 2,
    or use the `dotnet` CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the project file, note that native AOT publishing is enabled, as well as
    invariant globalization, as shown highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Explicitly setting invariant globalization to `true` is new in the **Console
    App** project template with .NET 8\. It is designed to make a console app non-culture-specific
    so that it can be deployed anywhere in the world and have the same behavior. If
    you set this property to `false`, or if the element is missing, then the console
    app will default to the culture of the current computer it is hosted on. You can
    read more about invariant globalization mode at the following link: [https://github.com/dotnet/runtime/blob/main/docs/design/features/globalization-invariant-mode.md](https://github.com/dotnet/runtime/blob/main/docs/design/features/globalization-invariant-mode.md).'
  prefs: []
  type: TYPE_NORMAL
- en: Modify the project file to statically import the `System.Console` class in all
    C# files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete any existing statements, and then add statements to
    output the current culture and OS version, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app project and note that the culture is invariant, as shown
    in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Warning!** Actually, the console app is not AOT-compiled; it is still currently
    JIT-compiled because we have not yet published it.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Publishing a native AOT project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A console app that functions correctly during development when the code is untrimmed
    and JIT-compiled could still fail once you publish it using native AOT, as the
    code is then trimmed and JIT-compiled, and therefore, it is different code with
    different behavior. You should, therefore, perform a publish action before assuming
    your project will work.
  prefs: []
  type: TYPE_NORMAL
- en: If your project does not produce any AOT warnings at publish time, you can then
    be confident that your service will work after publishing for AOT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s publish our console app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the command prompt or terminal for the `AotConsole` project, publish the
    console app using native AOT, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the message about generating native code, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Start **File Explorer**, open the `bin\Release\net9.0\win-x64\publish` folder,
    and note that the `AotConsole.exe` file is about 1.2 MB. The `AotConsole.pdb`
    file is only needed for debugging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `AotConsole.exe` and note that the console app has the same behavior
    as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, import namespaces to work with dynamic code assemblies, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, create a dynamic assembly builder, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the command prompt or terminal for the `AotConsole` project, publish the
    console app using native AOT, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the warning about calling the `DefineDynamicAssembly` method, which the
    .NET team has decorated with the `[RequiresDynamicCode]` attribute, as shown in
    the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Comment out the statement that we cannot use in an AOT project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**More Information**: You can learn more about native AOT at the following
    link: [https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/](https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/).'
  prefs: []
  type: TYPE_NORMAL
- en: Packaging your libraries for NuGet distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we learn how to create and package our own libraries, we will review
    how a project can use an existing package.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing a NuGet package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say that you want to add a package created by a third-party developer,
    for example, `Newtonsoft.Json`, a popular package for working with the **JavaScript
    Object Notation** (**JSON**) serialization format:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `AssembliesAndNamespaces` project, add a reference to the `Newtonsoft.Json`
    NuGet package, either using the GUI for Visual Studio or the `dotnet add package`
    command using the CLI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the April release of C# Dev Kit, you can now manage your NuGet packages
    directly from VS Code using some commands in the command palette, as described
    at the following link: [https://devblogs.microsoft.com/nuget/announcing-nuget-commands-in-c-dev-kit/](https://devblogs.microsoft.com/nuget/announcing-nuget-commands-in-c-dev-kit/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `AssembliesAndNamespaces.csproj` file and note that a package reference
    has been added, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you have a more recent version of the `Newtonsoft.Json` package, then it
    has been updated since this chapter was written.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To consistently restore packages and write reliable code, it’s important that
    you **fix dependencies**. Fixing dependencies means you are using the same family
    of packages released for a specific version of .NET, for example, SQLite for .NET
    9, as shown highlighted in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: To fix dependencies, every package should have a single version with no additional
    qualifiers. Additional qualifiers include betas (`beta1`), release candidates
    (`rc4`), and wildcards (`*`).
  prefs: []
  type: TYPE_NORMAL
- en: Wildcards allow future versions to be automatically referenced and used because
    they always represent the most recent release. Wildcards are, therefore, dangerous
    because they could result in the use of future incompatible packages that break
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be worth the risk while writing a book where new preview versions
    are released every month and you do not want to keep updating the preview package
    references, as I did during 2024, and as shown in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'To also automatically use the release candidates that arrive in September and
    October each year, you can make the pattern even more flexible, as shown in the
    following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: If you use the `dotnet add package` command or Visual Studio’s **Manage NuGet
    Packages**, then it will by default use the latest specific version of a package.
    But if you copy and paste configuration from a blog article or manually add a
    reference yourself, you might include wildcard qualifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following dependencies are examples of NuGet package references that are
    *not* fixed and, therefore, should be avoided unless you know the implications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: Microsoft guarantees that if you fix your dependencies to
    what ships with a specific version of .NET, for example, `9.0.0`, those packages
    will all work together. Almost always fix your dependencies, especially in production
    deployments.'
  prefs: []
  type: TYPE_NORMAL
- en: Packaging a library for NuGet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s package the `SharedLibrary` project that you created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `SharedLibrary` project, note that the class library targets .NET Standard
    2.0 and, therefore, by default, uses the C# 7.3 compiler. Explicitly specify the
    C# 12 compiler, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `SharedLibrary` project, rename the `Class1.cs` file `StringExtensions.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify its contents to provide some useful extension methods to validate various
    text values, using regular expressions, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will learn how to write regular expressions in *Chapter 8*, *Working with
    Common .NET Types*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `SharedLibrary.csproj`, modify its contents, as shown highlighted in the
    following markup, and note the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PackageId` must be globally unique, so you must use a different value if you
    want to publish this NuGet package to the [https://www.nuget.org/](https://www.nuget.org/)
    public feed for others to reference and download.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PackageLicenseExpression` must be a value from [https://spdx.org/licenses/](https://spdx.org/licenses/),
    or you could specify a custom license.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Warning!** If you rely on IntelliSense to edit the file, then it could mislead
    you to use deprecated tag names. For example, `<PackageIconUrl>` is deprecated
    in favor of `<PackageIcon>`. Sometimes, you cannot trust automated tools to help
    you correctly! The recommended tag names are documented in the **MSBuild Property**
    column in the table found at the following link: [https://learn.microsoft.com/en-us/nuget/reference/msbuild-targets#pack-target](https://learn.microsoft.com/en-us/nuget/reference/msbuild-targets#pack-target).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'All the other elements are self-explanatory:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`<None>` represents a file that does not participate in the build process.
    `Pack="true"` means the file will be included in the NuGet package created in
    the specified package path location. You can learn more at the following link:
    [https://learn.microsoft.com/en-us/nuget/reference/msbuild-targets#packing-an-icon-image-file](https://learn.microsoft.com/en-us/nuget/reference/msbuild-targets#packing-an-icon-image-file).'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Good Practice**: Configuration property values that are `true` or `false`
    values cannot have any whitespace.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the icon file and save it in the `SharedLibrary` project folder from
    the following link: [https://github.com/markjprice/cs13net9/blob/main/code/Chapter07/SharedLibrary/packt-csdotnet-sharedlibrary.png](https://github.com/markjprice/cs13net9/blob/main/code/Chapter07/SharedLibrary/packt-csdotnet-sharedlibrary.png).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `SharedLibrary` project folder, create a file named `readme.md`, with
    some basic information about the package, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the release assembly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, select **Release** in the toolbar, and then navigate to **Build**
    | **Build SharedLibrary**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In VS Code, in **Terminal**, enter `dotnet build -c Release`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we had not set `<GeneratePackageOnBuild>` to `true` in the project file,
    then we would have had to create a NuGet package manually using the following
    additional steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio, navigate to **Build** | **Pack SharedLibrary**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In VS Code, in **Terminal**, enter `dotnet pack -c Release`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing a package to a public NuGet feed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want everyone to be able to download and use your NuGet package, then
    you must upload it to a public NuGet feed like Microsoft’s:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start your favorite browser and navigate to the following link: [https://www.nuget.org/packages/manage/upload](https://www.nuget.org/packages/manage/upload).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will need to sign up for, and then sign in with, a Microsoft account at
    [https://www.nuget.org/](https://www.nuget.org/) if you want to upload a NuGet
    package for other developers to reference as a dependency package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Browse...** button and select the `.nupkg` file that was created
    by generating the NuGet package. The folder path should be `cs13net9\Chapter07\SharedLibrary\bin\Release`
    and the file is named `Packt.CSdotnet.SharedLibrary.9.0.0.nupkg`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the information you entered in the `SharedLibrary.csproj` file has
    been correctly filled in, and then click **Submit**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Wait a few seconds, and then you will see a success message, showing that your
    package has been uploaded, as shown in *Figure 7.4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_07_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: A NuGet package upload message'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: If you get an error, then review the project file for mistakes,
    or read more information about the `PackageReference` format at [https://learn.microsoft.com/en-us/nuget/reference/msbuild-targets](https://learn.microsoft.com/en-us/nuget/reference/msbuild-targets).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **Frameworks** tab, and note that because we targeted .NET Standard
    2.0, our class library can be used by every .NET platform, as shown in *Figure
    7.5*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_07_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: .NET Standard 2.0 class library package can be used by all .NET
    platforms'
  prefs: []
  type: TYPE_NORMAL
- en: Publishing a package to a private NuGet feed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Organizations can host their own private NuGet feeds. This can be a handy way
    for many developer teams to share work. You can read more at the following link:
    [https://learn.microsoft.com/en-us/nuget/hosting-packages/overview](https://learn.microsoft.com/en-us/nuget/hosting-packages/overview).'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring NuGet packages with a tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A handy tool named **NuGet Package Explorer**, for opening and reviewing more
    details about a NuGet package, was created by Uno Platform. As well as being a
    website, it can be installed as a cross-platform app. Let’s see what it can do:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start your favorite browser and navigate to the following link: [https://nuget.info](https://nuget.info).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the search box, enter `Packt.CSdotnet.SharedLibrary`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the package **v9.0.0** published by **Mark J Price**, and then click
    the **Open** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Contents** section, expand the `lib` folder and the `netstandard2.0`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select `SharedLibrary.dll`, and note the details, as shown in *Figure 7.6*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_07_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: Exploring my package using NuGet Package Explorer from Uno Platform'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use this tool locally in the future, click the **Install** button
    in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Not all browsers support installing web apps like this. I recommend Chrome for
    testing and development.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your class library package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will now test your uploaded package by referencing it in the `AssembliesAndNamespaces`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `AssembliesAndNamespaces` project, add a reference to your (or my) package,
    as shown highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the `AssembliesAndNamespaces` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Program.cs`, import the `Packt.Shared` namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, prompt the user to enter some `string` values, and then validate
    them using the extension methods in the package, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `AssembliesAndNamespaces` project, enter some values as prompted, and
    view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Working with preview features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is a challenge for Microsoft to deliver some new features that have cross-cutting
    effects across many parts of .NET, like the runtime, language compilers, and API
    libraries. It is the classic chicken and egg problem. What do you do first?
  prefs: []
  type: TYPE_NORMAL
- en: From a practical perspective, it means that although Microsoft might have completed
    most of the work needed for a feature, the whole thing might not be ready until
    very late in their now annual cycle of .NET releases, which is too late for proper
    testing in “the wild.”
  prefs: []
  type: TYPE_NORMAL
- en: So from .NET 6 onward, Microsoft will include preview features in **general
    availability** (**GA**) releases. Developers can opt into these preview features
    and provide Microsoft with feedback. In a later GA release, they can be enabled
    for everyone.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that this topic is about *preview features*. This is
    different from a preview version of .NET or Visual Studio. Microsoft releases
    preview versions of Visual Studio and .NET while developing them to get feedback
    from developers, and then they do a final GA release. With GA, the feature is
    available for everyone. Before GA, the only way to get the new functionality was
    to install a preview version. *Preview features* are different because they are
    installed with GA releases and must be optionally enabled.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when Microsoft released .NET SDK 6.0.200 in February 2022, it included
    the C# 11 compiler as a preview feature. This meant that .NET 6 developers could
    optionally set the language version to `preview` and then start exploring C# 11
    features, like raw string literals and the `required` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Once .NET SDK 7.0.100 was released in November 2022, any .NET 6 developer who
    wanted to continue to use the C# 11 compiler would then need to use the .NET 7
    SDK for their .NET 6 projects and set the target framework to `net6.0`, with a
    `<LangVersion>` set to `11`. This way, they use the supported .NET 7 SDK with
    the supported C# 11 compiler to build .NET 6 projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In November 2025, Microsoft is likely to release .NET 10 SDK with a C# 14 compiler.
    You can then install and use the .NET 10 SDK to gain the benefits of whatever
    new features are available in C# 14, while still targeting .NET 9, as shown highlighted
    in the following `Project` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: Preview features are not supported in production code. Preview
    features are likely to have breaking changes before the final release. Enable
    preview features at your own risk. Switch to a GA-release future SDK like .NET
    11 to use new compiler features, while still targeting older but longer-supported
    versions of .NET like .NET 8 or 10.'
  prefs: []
  type: TYPE_NORMAL
- en: Requiring preview features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `[RequiresPreviewFeatures]` attribute is used to indicate assemblies, types,
    or members that use, and, therefore, require warnings about, preview features.
    A code analyzer can scan for this attribute and then generate warnings if needed.
    If your code does not use any preview features, you will not see any warnings.
    If your code does use any preview features, then you will see warnings. Your code
    should also be decorated with this attribute to warn other developers that your
    code uses preview features.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling preview features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `Project` file, add an element to enable preview features and an element
    to enable preview language features, as shown highlighted in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Method interceptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An interceptor is a method that substitutes a call to an interceptable method
    with a call to itself. This is an advanced feature most commonly used in source
    generators. If you are interested, then I might add a section about them to the
    ninth edition.
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: You can learn more about interceptors at the following
    link: [https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12#interceptors](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12#interceptors).'
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and researching the topics of this chapter further.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 7.1 – Online material
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Online material can be extra content written by me for this book, or it can
    be references to content created by Microsoft or third parties.
  prefs: []
  type: TYPE_NORMAL
- en: Experimental MSBuild editor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MSBuild is an essential component of the .NET development experience, yet it
    can be difficult for both new and experienced developers to navigate. To help
    developers better understand their project files and utilize advanced features
    that require direct project file editing, the Microsoft team is introducing an
    experimental MSBuild editor. This new editor offers a deeper understanding of
    MSBuild files beyond what the current XML schema provides.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to try out the extension, search for **MSBuild Editor** in the Visual
    Studio Extension Manager. Currently, the extension is only available for Visual
    Studio, but efforts are underway to port it to VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about the new MSBuild editor experience at the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/visualstudio/experimental-msbuild-editor/](https://devblogs.microsoft.com/visualstudio/experimental-msbuild-editor/)'
  prefs: []
  type: TYPE_NORMAL
- en: Improving performance in .NET
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microsoft has made significant improvements to .NET performance in the past
    few years. You should review the blog posts written by Stephen Toub to learn what
    the team changed and why. His posts are famously long, detailed, and brilliant!
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the posts about the improvements at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core/)
    - 25 pages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-2-1/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-2-1/)
    - 20 pages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-3-0/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-3-0/)
    - 41 pages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5/)
    - 43 pages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/)
    - 100 pages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/dotnet/performance_improvements_in_net_7/](https://devblogs.microsoft.com/dotnet/performance_improvements_in_net_7/)
    - 156 pages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/)
    - 218 pages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-9/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-9/)
    - 307 pages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decompiling .NET assemblies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To learn about decompiling .NET assemblies, you can read the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch07-decompiling.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch07-decompiling.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Porting from .NET Framework to modern .NET
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are interested in porting legacy projects from .NET Framework to modern
    .NET, then I have written an online-only section at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch07-porting.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch07-porting.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 7.2 – Practice exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Practice exercises to dive deeper into the topics of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating source generators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are interested in creating source generators, then I have written an
    online-only section at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch07-source-generators.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch07-source-generators.md)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find examples of source generators at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/amis92/csharp-source-generators](https://github.com/amis92/csharp-source-generators)'
  prefs: []
  type: TYPE_NORMAL
- en: Explore PowerShell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PowerShell is Microsoft’s scripting language for automating tasks on every OS.
    Microsoft recommends VS Code with the PowerShell extension to write PowerShell
    scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since PowerShell is its own extensive language, there is not enough space in
    this book to cover it. You can learn about some key concepts from a Microsoft
    training module at the following link: [https://learn.microsoft.com/en-us/training/modules/introduction-to-powershell/](https://learn.microsoft.com/en-us/training/modules/introduction-to-powershell/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read the official documentation at the following link: [https://learn.microsoft.com/en-us/powershell/](https://learn.microsoft.com/en-us/powershell/).'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 7.3 – Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between a namespace and an assembly?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you reference another project in a `.csproj` file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the benefit of a tool like ILSpy?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which .NET type does the C# `float` alias represent?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the `<PropertyGroup>` and `<ItemGroup>` elements used for in a .NET
    project file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between framework-dependent and self-contained deployments
    of .NET applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a RID?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `dotnet pack` and `dotnet publish` commands?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you control the sources that a build process uses to download NuGet
    packages?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some limitations of using AOT compilation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 7.4 – Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more details about the topics
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-7---packaging-and-distributing-net-types](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-7---packaging-and-distributing-net-types)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we:'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewed the journey of .NET for BCL functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explored the relationship between assemblies and namespaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saw options to publish an app for distribution to multiple OSes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learned how to publish to native AOT for faster startup and a smaller memory
    footprint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaged and distributed a class library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learned how to activate preview features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about some common BCL types that are included
    with modern .NET.
  prefs: []
  type: TYPE_NORMAL
