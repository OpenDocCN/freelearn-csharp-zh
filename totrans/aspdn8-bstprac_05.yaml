- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optimizing Data Access with Entity Framework Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before Entity Framework was introduced in 2008, developers used **ActiveX Data
    Objects** (**ADOs**) and **Object Linking and Embedding Database** (**OLE DB**)
    to access their data for applications. Since its introduction, Entity Framework
    has evolved over the years into a high-performance bridge between **object-oriented**
    (**OO**) systems and relational databases. It enables developers to use **Language
    Integrated Query** (**LINQ**) syntax to perform complex queries using C#. However,
    some LINQ statements can be overwhelming for new developers. Since this is one
    of the most discussed topics when it comes to data access, we’ll cover various
    standards and implementations when using Entity Framework Core.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will be similar to [*Chapter 2*](B19493_02.xhtml#_idTextAnchor031),
    *CI/CD – Building Quality Software with Software*, where we will review patterns
    for implementing Entity Framework Core to access data but also look at some common
    uses of Entity Framework Core in the industry.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Entity Framework Core Implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common Entity Framework Core Practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Theme Park Example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you’ve finished reading this chapter, you’ll have a better understanding
    of the various design patterns and approaches you can use with Entity Framework
    Core and the various standards involved; we will end the chapter by applying these
    standards to a theme park example.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started by examining the various Entity Framework Core common implementations
    used by many developers.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I recommend using your favorite editor to view the GitHub repository. Our recommendations
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio (preferably 2022 or newer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JetBrains Rider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The editor we’ll be using is Visual Studio Enterprise 2022, but any version
    (Community or Professional) will work with the code.
  prefs: []
  type: TYPE_NORMAL
- en: We will also be using **SQL Server Management Studio** (**SSMS**) for our example
    at the end of the chapter. However, if you feel you don’t need to download another
    tool, you can view SQL Server data through Visual Studio 2022 as well without
    installing SSMS.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading SQL Server Developer Edition
  prefs: []
  type: TYPE_NORMAL
- en: To run a local copy of SQL Server, download the Developer edition of SQL Server
    from [https://www.microsoft.com/en-us/sql-server/sql-server-downloads](https://www.microsoft.com/en-us/sql-server/sql-server-downloads).
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter is located in Packt Publishing’s GitHub repository,
    which you can navigate to here: [https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices](https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices).'
  prefs: []
  type: TYPE_NORMAL
- en: Entity Framework Core Implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the years, developers have used Entity Framework Core in various ways.
    Some were exceptionally **creative**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll discuss the following architectural approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: Repository/Unit of Work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extension Methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While these implementations are based on real-world experiences, they are merely
    observations, and, as mentioned in [*Chapter 1*](B19493_01.xhtml#_idTextAnchor014),
    the decision will fall on teams and/or community members as to the right approach
    for the application and trade-offs incurred.
  prefs: []
  type: TYPE_NORMAL
- en: Repository/Unit of Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While this implementation has already caused some friction among developers,
    it’s a common pattern seen with early adopters of ASP.NET Entity Framework applications
    (including me). However, it’s been said by community members it’s not an efficient
    way to use Entity Framework architecturally because of the duplication of repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Out of the box, the `DbContext` follows a **repository** and **unit of work**
    design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The repository design pattern is a class that manages objects between the business
    domain and the mapping of properties from the database using lists and single
    domain objects.
  prefs: []
  type: TYPE_NORMAL
- en: Repositories are self-contained in the `DbContext`, which is considered a Unit
    of Work design pattern. A unit of work pattern manages a list of objects (as repositories
    do) using a `ChangeTracker` to track changes in a transaction-like state and organizes
    how each change should be saved and how to resolve concurrency problems.
  prefs: []
  type: TYPE_NORMAL
- en: In Entity Framework, repositories are represented as `DbSet` instances in the
    `DbContext` where the `DbContext` is the unit of work itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example. We have a database called `ThemePark` and it contains
    two tables: attractions and locations. We’ve also created a `ThemeParkDbContext`
    class to manage our entities. If you’ve worked with Entity Framework at any time,
    you’ve likely encountered the repository design pattern implemented in a similar
    fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What is wrong with this implementation? While this does separate the business
    rules from the data access, it’s an unnecessary layer for applications when a
    repository layer already exists in the `DbContext`.
  prefs: []
  type: TYPE_NORMAL
- en: One of the jokes I love from the developer community is, “*What are the two
    hardest problems in computer science? Cache invalidation, naming things, and*
    *off-by-one errors.*”
  prefs: []
  type: TYPE_NORMAL
- en: Consider this a case of naming things wrong. What if we changed the name to
    `Service`, like so?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Why `Service`? The repository pattern is already contained in the `DbContext`
    as a `DbSet<Attraction>`. The service uses the repository pattern to retrieve
    the data and perform additional updates before returning the data. Changing the
    class name from `Repository` to `Service` signifies we don’t need a repository
    pattern on top of an already existing repository. When creating a service for
    individual repositories (`DbSet` instances), this provides multiple benefits,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DbContext`. Add `.Include()` on the `DbContext` to retrieve related entities.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DbContext` instance through the constructor, allowing for multiple approaches
    to accessing data including LINQ statements, stored procedures, or even call raw
    SQL.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Additional processing**—When calling a data access service, there are times
    when the data requires more massaging before returning the results. While this
    is temporarily acceptable in this service, it may require refactoring to the appropriate
    business entity or processing through another class.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The benefits seen through this approach could easily pivot the already existing
    repository naming convention to a service moniker.
  prefs: []
  type: TYPE_NORMAL
- en: The Specification Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developers are always looking to reuse existing code and make it as flexible
    as possible for maintenance purposes; update a line of code and it could change
    the retrieval of data required.
  prefs: []
  type: TYPE_NORMAL
- en: The specification pattern is solving the problem of attaching requirements to
    an object with the rise of **Test-Driven Development** (**TDD**) making it easier
    to understand the results retrieved through a query. It uses a base class to retrieve
    data as either a list or a single entity while writing the least amount of code.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When creating a specification class, you need two classes: one for processing
    the request and the specification for what you need. The specification class is
    built exactly as the class implies: it defines the filter for a single entity
    or list of entities, sorting and grouping, and inclusion of various related entities.
    Everything you can do with a LINQ query can be defined in the specification class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample specification’s contract (interface) could have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of a `Specification` class would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned at the start of this section, the properties in the class represent
    all of the different aspects of retrieving data: filtering, including, sorting,
    and grouping.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the specification defined, we need a way to build our query based
    on a specification. In this case, we’ll create a `SpecificationBuilder<T>` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, our `SpecificationBuilder` class creates a LINQ
    query to retrieve the data. Since everything is self-contained and completely
    independent of itself, the class was marked as static.
  prefs: []
  type: TYPE_NORMAL
- en: 'With every specification class, we need a way to retrieve the data. We’ll make
    the class abstract and call it `BaseSpecificationService<TEntity>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `BaseSpecificationService` is what we’ll use to create
    our specific data needs. We require a specification property and a way to retrieve
    the query based on that specification.
  prefs: []
  type: TYPE_NORMAL
- en: With the specification pattern, the names of your classes are the specifications
    of the data required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at another example with a simple `Product` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need a list of all products below `$5.00`, a specification class would
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This code creates the specification and uses it to retrieve the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code would generate a list of products of less than 5 dollars.
  prefs: []
  type: TYPE_NORMAL
- en: While this is a simple example, there are more extensive libraries dedicated
    to this type of Entity Framework design pattern, such as Steve Smith’s specification
    library located at [https://specification.ardalis.com](https://specification.ardalis.com).
  prefs: []
  type: TYPE_NORMAL
- en: Extension Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we revisit the repository/unit of work method, the association between specific
    business logic and the data should be relatively close to `DbContext`. Instead
    of creating service classes while passing `DbContext` in, why not just attach
    your data access to the actual `DbSet` instance itself as an `IQueryable` extension
    method?
  prefs: []
  type: TYPE_NORMAL
- en: The ability to add specific calls to a `DbContext` or `DbSet` instance is extremely
    attractive because they can be placed anywhere in your project.
  prefs: []
  type: TYPE_NORMAL
- en: The extension method approach does require a bit of discipline where specific
    entities are concerned. For example, if you created a product entity, your `IQueryable`
    extension methods should return only products and not order entities. Mixing order
    extension methods with product extension methods is usually frowned upon.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Extension methods allow your code to be more direct when accessing data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we can attach extension methods to interfaces, let’s define a simple
    interface for our `ThemeParkDbContext` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With our theme park idea, we built `AttractionExtensions` and `LocationExtensions`
    files for data access, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Our `AttractionExtensions` file has only two methods, `GetAttractions()` and
    `GetAttraction()`, which we attach to the `ThemeParkDbContext` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `LocationExtensions` file is small and compact as well, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we reviewed some of the more common Entity Framework Core design
    patterns used in real-world applications such as the repository and unit of work
    patterns, the specification pattern, and the extension methods approach to accessing
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'While these are common in the .NET community, there are other patterns available
    for Entity Framework Core allowing even easier access to your data, but they do
    have drawbacks. Let’s look at these more closely:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DbContext` instance would exist for each partitioned feature in the application;
    for example, one `DbContext` instance for the `Books` and `BookAuthors` tables
    and another `DbContext` instance for the `Orders` and `Books` tables. One drawback
    is possible state conflicts across multiple `DbContext` instances (*NOT* recommended).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DbContext` instance as a conduit while making direct calls to stored procedures
    without using LINQ. One drawback occurs when changes are made to a stored procedure
    and the mapping code doesn’t reflect the results returned, causing an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we’ll be covering some common practices when using Entity
    Framework Core in real-world applications.
  prefs: []
  type: TYPE_NORMAL
- en: Common Entity Framework Core Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though Entity Framework patterns provide additional structure to your code,
    there are also common practices to keep in mind when building applications with
    Entity Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll review some of the more common uses of Entity Framework
    and their benefits: how `async`/`await` can make your application more scalable,
    logging your queries to optimize SQL output, creating resource files to hold seed
    data for tables, learning about deferred execution, speeding up access with a
    read-only method called `.AsNoTracking()`, leveraging the database where it makes
    sense, and using AutoMapper to map source objects to destination objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Confirming Your Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re using the database-first approach (where you have an existing database
    to work with) to generate your models, confirm that all of your indexes, relationships,
    identity fields, and foreign keys represent your model accordingly before using
    `Scaffold-DbContext`. The `Scaffold-Database` command creates your `DbContext`
    instance based on an existing database. The command takes everything into account
    when creating the `DbContext` instance.
  prefs: []
  type: TYPE_NORMAL
- en: If your relationships aren’t correct, this will cause problems with navigation
    properties on your model when accessing them through your `DbContext` instance.
    Essentially, your navigation properties will be empty.
  prefs: []
  type: TYPE_NORMAL
- en: Using Async/Await
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For I/O-bound activities, such as database operations, it makes sense to use
    `async`/`await` for creating scalable applications. While it may not be apparent
    when running the web application on a developer machine, the true benefits of
    using `async`/`await` appear when you have hundreds of people hitting the website
    at once.
  prefs: []
  type: TYPE_NORMAL
- en: The reason to use `async`/`await` is to avoid blocking thread requests. When
    a request comes into a web server, the .NET Framework maintains a pool of threads
    to process those incoming requests. For each request, a thread is taken from the
    pool and used to process the request synchronously. While the thread is being
    used, nothing can use it until the process is completed (“blocking thread”). Once
    the process completes, the thread is released and returned to the thread pool
    for the next request.
  prefs: []
  type: TYPE_NORMAL
- en: When you use `async`/`await`, you aren’t taking a thread from the thread pool.
    Anything in between `async` and `await` doesn’t use a thread, which means you’re
    saving memory in the long run and allowing your application to perform better.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to making Entity Framework Core calls, it’s best to use `async`/`await`
    for performance reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Logging Your Queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most `OptionsBuilder` class specifically for logging to help solve this issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'For simple logging using Entity Framework, place a `.LogTo()` method into your
    `DbContext` instance’s `onConfiguring()` method, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `.LogTo()` method takes either an action or a func on where to send the
    log data. In this snippet, we are simply logging to the debug window.
  prefs: []
  type: TYPE_NORMAL
- en: Simple logging to the debug window is the easiest to implement because it’s
    a simple `Console.Write()` method and doesn’t require any third-party packages,
    but there are other types of logging available that are just as easy to plug into
    Entity Framework Core.
  prefs: []
  type: TYPE_NORMAL
- en: Additional logging options
  prefs: []
  type: TYPE_NORMAL
- en: 'For additional logging methods in Entity Framework Core, navigate to the following
    URL: [https://learn.microsoft.com/en-us/ef/core/logging-events-diagnostics/](https://learn.microsoft.com/en-us/ef/core/logging-events-diagnostics/).'
  prefs: []
  type: TYPE_NORMAL
- en: Using Resources for Large Seed Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need initial seed data with fewer than 20 records for your tables, it’s
    easy to just hand-code the records on the fly in your `DbContext` instance using
    `.HasData()`.
  prefs: []
  type: TYPE_NORMAL
- en: But what if you have a table requiring hundreds of records seeded on the initial
    load? Hand-typing records can be painful using code.
  prefs: []
  type: TYPE_NORMAL
- en: One hidden gem in .NET is the use of resource files for storing simple strings
    (normally used for localization/translation), but it can also be used for populating
    seed data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use our `Attraction`/`Location` table example and show the steps for
    creating seed data in a resource file:'
  prefs: []
  type: TYPE_NORMAL
- en: Open SQL Server Management Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirm the seeded records are created the way you want them in each table (`Attraction`
    and `Location`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Perform a `SELECT` operation with the JSON clause added to the end, as shown
    in the following SQL snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Click on the result, and a new result pane will open with your JSON. The JSON
    will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Copy the JSON returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open Visual Studio and add a resource file through Visual Studio. The following
    screenshot illustrates the process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Creating a resource file called SeedResource.resx in Visual
    Studio](img/Figure_5.01_B19493.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Creating a resource file called SeedResource.resx in Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: 'Your resource file will automatically open. For our example, we’ll create the
    resource with the following parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AttractionRecords`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Value**: <Paste your JSON here>'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Comment**: (These are optional, but added to identify for other devs)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Access Modifier**: Change this to **Internal**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your resource record should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – A sample record in the Resources.resx file containing JSON for
    the Attraction table](img/Figure_5.02_B19493.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – A sample record in the Resources.resx file containing JSON for
    the Attraction table
  prefs: []
  type: TYPE_NORMAL
- en: Save your resource file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open your `AttractionConfiguration` class and locate your `.HasData()` attraction
    in your `DbContext` instance and replace it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save and compile your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you require a large amount of seed data, it’s better to create resource files
    with JSON data instead of hand-coding all of the records into code. Finding long
    pages of large JSON strings in a `DbContext` configuration may seem jarring to
    some developers.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Deferred Execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deferred execution when making Entity Framework calls means the LINQ query is
    delayed until the realized value is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: While this will return the correct list of items, it’s not as performant as
    it could be. With the `.ToList()` method added after the Products `DbSet` instance,
    the entire `Products` table is loaded, and *then* the `.Where()` method is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better approach to this call is shown in this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will also return the correct list of products. However, the SQL query generated
    will contain a `WHERE` clause as well to filter out and return the correct list
    of records. The difference here is the first query will return *all* of the records
    from the `Products` table and then filter out the resulting product list using
    the `.Where()` LINQ method. Remember—LINQ can also work with arrays.
  prefs: []
  type: TYPE_NORMAL
- en: With the second query, a `WHERE` clause is created when the `.ToList()` method
    is encountered, and a subset of records is returned and “materialized” into entities,
    making this query extremely faster.
  prefs: []
  type: TYPE_NORMAL
- en: Deferred execution means you are building the query and not executing it immediately.
    When you are finished building your query and want the results, end your LINQ
    query with a `.ToList()` method. If you are looking for one entity, end your LINQ
    query with a `.Single()`, `.SingleOrDefault()`, `.First()`, or `.``FirstOrDefault()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Read-Only State with .AsNoTracking()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When retrieving data using LINQ, the `DbContext` instance has something called
    a `ChangeTracker`, which is updated when an entity’s state changes. This requires
    overhead—a small amount of overhead, but overhead, nonetheless.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using `DbSet` in a read-only situation, use the `.AsNoTracking()`
    method at the beginning of a LINQ statement to make Entity Framework Core aware
    it doesn’t need to track the state of models returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following LINQ query will retrieve an `Attraction` object
    without updating the `ChangeTracker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the previous snippet, we place the `.AsNoTracking()` method right after the
    `DbSet` instance, letting Entity Framework Core know not to track anything.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging the Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it’s tempting to create everything in Entity Framework, there are times
    when it’s better to let the database perform data-heavy operations.
  prefs: []
  type: TYPE_NORMAL
- en: With one project, I was writing large LINQ queries in code to retrieve entities
    into memory. Then, I continued to write code to calculate a count of items, sum
    up totals, and finally relate all types of child entities to the main collection
    of entities.
  prefs: []
  type: TYPE_NORMAL
- en: I realized I could achieve all of this using a stored procedure and bypass Entity
    Framework altogether. A stored procedure took care of these details, and Entity
    Framework Core simply retrieved the results.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it makes sense to let the database do the heavy lifting of calculating
    data and provide the results to the application since that’s its job.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding the Manual Property Mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When sending entities to render on the client, it’s best to create **Data Transfer
    Objects** (**DTOs**). You only want to send the minimal amount of data relevant
    to the currently displayed web page.
  prefs: []
  type: TYPE_NORMAL
- en: However, it gets tiring writing manual left-to-right property assignments. One
    recommendation is to use AutoMapper.
  prefs: []
  type: TYPE_NORMAL
- en: 'AutoMapper enables the automation of mapping properties from one source object
    to a destination object. In the following example, we are taking an `Attraction`
    object and copying the properties over to a new `AttractionDto` object. AutoMapper
    handles the heavy lifting for us by matching properties and copying the data over
    to the destination object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`AutoMapper` is very flexible, fills a specific need, has been downloaded from
    NuGet over 400,000 times, and is used by over 100,000 developers in the industry.'
  prefs: []
  type: TYPE_NORMAL
- en: AutoMapper Library
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous functionality only scratches the surface of what AutoMapper is
    capable of doing for developers. To understand the full potential of AutoMapper,
    visit the fully documented website at the following URL: [https://docs.automapper.org/](https://docs.automapper.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about the common uses of Entity Framework Core in
    the industry. We learned it’s best to confirm your database before creating your
    database-first `DbContext` instance, along with leveraging the capabilities of
    your database instead of hand-coding everything, and about how to perform read-only
    queries with `.AsNoTracking()`, why it’s best to use `async`/`await`, and why
    understanding deferred execution is important when writing LINQ queries. Finally,
    we examined how to log your queries, how to seed your tables using resource files,
    and avoiding manual left-to-right property mapping by using AutoMapper.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll take a simple Entity Framework application and apply
    all of our standards, and even learn some new techniques as well.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Theme Park Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is so much to digest when it comes to Entity Framework Core and all of
    its features. There are entire books on Entity Framework Core; this chapter will
    only scratch the surface.
  prefs: []
  type: TYPE_NORMAL
- en: Entity Framework Core Recommendation
  prefs: []
  type: TYPE_NORMAL
- en: For a deeper dive into Entity Framework Core, I would recommend Mastering Entity
    Framework Core 2.0 at [https://www.packtpub.com/product/mastering-entity-framework-core-20/9781788294133](https://www.packtpub.com/product/mastering-entity-framework-core-20/9781788294133).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll update a small ASP.NET application that uses Entity Framework
    Core with all of the standards we discussed in the previous section, with a few
    additional techniques to help understand Entity Framework Core even better.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we’ll use our previous `DbContext` instance with `Attractions`
    and `Locations` tables and create a database with SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Web Application
  prefs: []
  type: TYPE_NORMAL
- en: The application used for this section is found on the Packt Publishing GitHub
    repository under `Ch5/EFApplication`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll keep our data access simple. We’ll use the services approach, accepting
    a `DbContext` instance to retrieve our data and create our database from our `DbContext`
    model in SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our application to work, we need to create our database in SQL Server. Since
    we already have our `DbContext` instance created (using the model-first approach),
    we can use Entity Framework Core migrations to build our tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create your local version of the database, type the following into the Package
    Manager Console (navigate to this via **View** | **Other Windows** | **Package**
    **Manager Console**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once you hit *Enter*, Entity Framework Core will locate the `DbContext` instance,
    read the configuration file (`appsettings.json`), and use the connection string
    to create our database and tables with seed data in it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an Asynchronous Read-Only Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our first matter at hand is to apply `async`/`await` to the correct services
    so that we can scale the application later. If you are working with an existing
    ASP.NET application with Entity Framework and want to use `async`/`await` methods,
    it’s best to start with the database. If you are creating a “greenfield” project
    (meaning from scratch), use `async`/`await` methods right away to save yourself
    headaches later.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `AttractionService` and `LocationService` classes, we can convert all
    LINQ calls as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We convert them into the following with `async`/`await`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, since we’re not creating, updating, or deleting data, we can safely say
    this is a read-only query. So, we can apply a `.AsNoTracking()` method to the
    query, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned before, the `.AsNoTracking()` method will reduce the Entity Framework
    overhead since we aren’t tracking the model’s state but are simply populating
    the model.
  prefs: []
  type: TYPE_NORMAL
- en: Including Child Entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we query our attractions, we also want the attraction’s location. How do
    we include the location (stored in a separate table) in our query?
  prefs: []
  type: TYPE_NORMAL
- en: 'As we call the `GetAttractionsAsync()` method, we place a `.Include()` method
    to retrieve the related entity. Our new `GetAttractionsAsync()` method is modified
    to match the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `.Include()` method relies heavily on the database relationships you created
    when building your model. I’ll refer you back to the “confirming your model” best
    practice we previously discussed. Entity Framework Core uses the model’s relationships
    to load related entities.
  prefs: []
  type: TYPE_NORMAL
- en: Extending your Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our `Location` model, we need a way to know how many attractions are available
    at a location; we need a new property called `AttractionCount`.
  prefs: []
  type: TYPE_NORMAL
- en: While this is a simple property added to the `Location` class, there are multiple
    decisions to be made here.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create a new file under the `Partials` folder with the same class
    name, `Location`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, something may look strange. Even though the file
    is located in the `Partials` folder, *the partial namespace has to be the same
    namespace as the entities’ primary model* for the partial to work. .NET projects
    typically follow the convention of namespaces matching folder structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run our application, we should experience a problem with our `Location`
    model as it currently stands, as represented here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – The error message when you create a property on an Entity Framework
    object](img/Figure_5.03_B19493.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – The error message when you create a property on an Entity Framework
    object
  prefs: []
  type: TYPE_NORMAL
- en: What Entity Framework Core is telling us is there isn’t an `AttractionCount`
    field in the table and it can’t populate the property since it doesn’t exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have three options here, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Place a `[NotMapped]` attribute on the property so that it doesn’t try to populate
    the property and count our attractions by hand.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a SQL Server function to calculate a calculated property called `AttractionCount`
    and return it so that it can populate our extra property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Automatically count the number of attractions already in the model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s focus on implementing *option 3* as a quick hit for success.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we do need a `[NotMapped]` attribute so that Entity Framework Core doesn’t
    try to load it, we’ll change the property into an `expression-bodied` property.
    We could make this an auto property ( `{get;set;}`), but we’re only using this
    as a `get` property, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind this is assuming you have a foreign-key relationship in your SQL
    Server instance created to load the attractions when a location is loaded. If
    you don’t have a `.Include()` method, your attraction count will be 0.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to create databases using the model-first approach,
    how to add an asynchronous, read-only mode using the `.AsNoTracking()` method
    so the state isn’t attached to the objects, how to include child entities when
    retrieving a parent model, and finally, how to extend your model using a partial
    class and attaching a `[NotMapped]` attribute to properties, letting Entity Framework
    know whether it should map a field to the property.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about three different Entity Framework Core patterns
    including Repository and Unit of Work, Specification, and Extension Methods and
    how to implement each one into your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we examined some of the standards in the industry, such as confirming
    your model, adding `async`/`await` to your LINQ calls, implementing logging, using
    resource files for seeding data, and understanding deferred execution.
  prefs: []
  type: TYPE_NORMAL
- en: We also reviewed how to perform read-only queries and how to leverage the database
    by letting it perform data-intensive procedures.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we applied these standards to an existing application with a way to
    create our database using the model-first approach, then examined how to add an
    asynchronous, read-only mode using the `.AsNoTracking()` method so that state
    isn’t attached to objects, how to include child entities when retrieving a parent
    model, and finally, how to extend your model while letting Entity Framework know
    which properties to populate and which properties to ignore.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll learn about UI standards with MVC, Razor Pages, ViewComponents,
    HTMLHelpers, and Task Runners.
  prefs: []
  type: TYPE_NORMAL
