["```cs\n  Properties \n  {\n    _Color (\"Color\", Color) = (1,1,1,1)\n  }\n```", "```cs\nvoid surf (Input IN, inout SurfaceOutputStandard o) \n{\n  o.Albedo = _Color.rgb; \n}\n```", "```cs\nShader \"CookbookShaders/Chapter03/SimpleDiffuse\" {\n  Properties \n  {\n    _Color (\"Color\", Color) = (1,1,1,1)\n  }\n  SubShader \n  {\n    Tags { \"RenderType\"=\"Opaque\" }\n    LOD 200\n\n    CGPROGRAM\n    // Physically based Standard lighting model, and enable shadows on all light types\n    #pragma surface surf Standard fullforwardshadows\n\n    // Use shader model 3.0 target, to get nicer looking lighting\n    #pragma target 3.0\n\n    struct Input \n    {\n      float2 uv_MainTex;\n    };\n\n    fixed4 _Color;\n\n    void surf (Input IN, inout SurfaceOutputStandard o) \n    {\n      o.Albedo = _Color.rgb; \n    }\n\n    ENDCG\n  }\n  FallBack \"Diffuse\"\n}\n```", "```cs\no.Alpha = _Color.a; \n```", "```cs\no.Albedo = _Color.rgb; \n```", "```cs\no.Albedo.r = _Color.r; \no.Albedo.g = _Color.g; \no.Albedo.b = _Color.b; \n```", "```cs\no.Albedo = _Color.rgb; \n```", "```cs\no.Albedo = 0; // Black =(0,0,0) \no.Albedo = 1; // White =(1,1,1) \n```", "```cs\no.Albedo.rg = _Color.rg; \n```", "```cs\nfloat4x4 matrix; \n// ... \nfloat first = matrix._m00; \nfloat last = matrix._m33; \n```", "```cs\nfloat4 diagonal = matrix._m00_m11_m22_m33; \n```", "```cs\nfloat4 firstRow = matrix[0]; \n// Equivalent to \nfloat4 firstRow = matrix._m00_m01_m02_m03; \n```", "```cs\nShader \"CookbookShaders/Chapter03/TexturedShader\" {\n```", "```cs\n_MainTex (\"Albedo (RGB)\", 2D) = \"white\" {} \n```", "```cs\nsampler2D _MainTex; \n```", "```cs\nstruct Input { \n  float2 uv_MainTex; \n}; \n```", "```cs\nfixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; \n```", "```cs\nProperties {\n  _Color (\"Color\", Color) = (1,1,1,1)\n  _MainTex (\"Albedo (RGB)\", 2D) = \"white\" {}\n  _ScrollXSpeed (\"X Scroll Speed\", Range(0,10)) = 2 \n  _ScrollYSpeed (\"Y Scroll Speed\", Range(0,10)) = 2 \n}\n```", "```cs\nProperties\n{\n    _propertyName(\"Name in Inspector\", Type) = value\n}\n```", "```cs\nfixed _ScrollXSpeed; \nfixed _ScrollYSpeed; \nsampler2D _MainTex; \n```", "```cs\nvoid surf (Input IN, inout SurfaceOutputStandard o) {\n    // Create a separate variable to store our UVs \n    // before we pass them to the tex2D() function \n    fixed2 scrolledUV = IN.uv_MainTex; \n\n    // Create variables that store the individual x and y \n    // components for the UV's scaled by time \n    fixed xScrollValue = _ScrollXSpeed * _Time; \n    fixed yScrollValue = _ScrollYSpeed * _Time; \n\n    // Apply the final UV offset \n    scrolledUV += fixed2(xScrollValue, yScrollValue); \n\n    // Apply textures and tint \n    half4 c = tex2D(_MainTex, scrolledUV); \n    o.Albedo = c.rgb * _Color; \n    o.Alpha = c.a; \n}\n```", "```cs\nstruct Input \n{ \n  float2 uv_MainTex; \n} \n```", "```cs\n// Create variables that store the individual x and y  \n// components for the uv's scaled by time \nfixed xScrollValue = _ScrollXSpeed * _Time; \nfixed yScrollValue = _ScrollYSpeed * _Time; \n```", "```cs\nscrolledUV += fixed2(xScrollValue, yScrollValue); \nhalf4 c = tex2D (_MainTex, scrolledUV); \n```", "```cs\nProperties \n{ \n  _MainTint (\"Diffuse Tint\", Color) = (0,1,0,1) \n  _NormalTex (\"Normal Map\", 2D) = \"bump\" {} \n} \n```", "```cs\n    CGPROGRAM\n    // Physically based Standard lighting model, and enable shadows \n    // on all light types\n    #pragma surface surf Standard fullforwardshadows\n\n    // Use shader model 3.0 target, to get nicer looking lighting\n    #pragma target 3.0\n\n    // Link the property to the CG program \n    sampler2D _NormalTex; \n    float4 _MainTint; \n```", "```cs\n// Make sure you get the UVs for the texture in the struct \nstruct Input \n{ \n  float2 uv_NormalTex; \n} \n```", "```cs\nvoid surf (Input IN, inout SurfaceOutputStandard o) {\n  // Use the tint provided as the base color for the material\n  o.Albedo = _MainTint;\n\n  // Get the normal data out of the normal map texture \n  // using the UnpackNormal function \n  float3 normalMap = UnpackNormal(tex2D(_NormalTex, \n    IN.uv_NormalTex)); \n\n  // Apply the new normal to the lighting model \n  o.Normal = normalMap.rgb; \n}\n```", "```cs\n_NormalMapIntensity(\"Normal intensity\", Range(0,3)) = 1 \n```", "```cs\n// Link the property to the CG program \nsampler2D _NormalTex; \nfloat4 _MainTint; \nfloat _NormalMapIntensity;\n```", "```cs\nvoid surf (Input IN, inout SurfaceOutputStandard o) {\n  // Use the tint provided as the base color for the material\n  o.Albedo = _MainTint;\n\n  // Get the normal data out of the normal map texture \n  // using the UnpackNormal function \n  float3 normalMap = UnpackNormal(tex2D(_NormalTex, \n    IN.uv_NormalTex)); \n\n normalMap.x *= _NormalMapIntensity; \n normalMap.y *= _NormalMapIntensity; \n\n // Apply the new normal to the lighting model \n o.Normal = normalize(normalMap.rgb); \n}\n```", "```cs\nTags \n{ \n  \"Queue\" = \"Transparent\" \n  \"IgnoreProjector\" = \"True\" \n  \"RenderType\" = \"Transparent\" \n} \n```", "```cs\n    LOD 200\n\n    // Do not show back\n    Cull Back\n\n    CGPROGRAM\n    // Physically based Standard lighting model, and enable shadows on all light types\n    #pragma surface surf Standard alpha:fade \n```", "```cs\n#pragma surface surf Standard alpha:fade \n```", "```cs\nvoid surf(Input IN, inout SurfaceOutputStandard o) \n{ \n  float4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color; \n  o.Albedo = c.rgb; \n  o.Alpha = c.a; \n} \n```", "```cs\n_DotProduct(\"Rim effect\", Range(-1,1)) = 0.25 \n```", "```cs\nfloat _DotProduct; \n```", "```cs\nTags \n{ \n  \"Queue\" = \"Transparent\" \n  \"IgnoreProjector\" = \"True\" \n  \"RenderType\" = \"Transparent\" \n} \n```", "```cs\n#pragma surface surf Lambert alpha:fade nolighting \n```", "```cs\nstruct Input \n{ \n  float2 uv_MainTex; \n  float3 worldNormal; \n  float3 viewDir; \n}; \n```", "```cs\nvoid surf(Input IN, inout SurfaceOutput o) \n{ \n  float4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color; \n  o.Albedo = c.rgb; \n\n  float border = 1 - (abs(dot(IN.viewDir, \n     IN.worldNormal))); \n  float alpha = (border * (1 - _DotProduct) + _DotProduct); \n  o.Alpha = c.a * alpha; \n} \n```", "```cs\nfloat alpha = (border * (1 - _DotProduct) + _DotProduct); \n```", "```cs\nProperties \n{ \n _MainTint (\"Diffuse Tint\", Color) = (1,1,1,1) \n\n//Add the properties below so we can input all of our \n   textures \n  _ColorA (\"Terrain Color A\", Color) = (1,1,1,1) \n  _ColorB (\"Terrain Color B\", Color) = (1,1,1,1) \n  _RTexture (\"Red Channel Texture\", 2D) = \"\"{} \n  _GTexture (\"Green Channel Texture\", 2D) = \"\"{} \n  _BTexture (\"Blue Channel Texture\", 2D) = \"\"{} \n  _ATexture (\"Alpha Channel Texture\", 2D) = \"\"{} \n  _BlendTex (\"Blend Texture\", 2D) = \"\"{} \n} \n```", "```cs\nCGPROGRAM \n#pragma surface surf Lambert \n\n// Use shader model 3.5 target, to support enough textures\n#pragma target 3.5\nfloat4 _MainTint; \nfloat4 _ColorA; \nfloat4 _ColorB; \nsampler2D _RTexture; \nsampler2D _GTexture; \nsampler2D _BTexture; \nsampler2D _BlendTex; \nsampler2D _ATexture; \n```", "```cs\nstruct Input  \n{ \n  float2 uv_RTexture; \n  float2 uv_GTexture; \n  float2 uv_BTexture; \n  float2 uv_ATexture; \n  float2 uv_BlendTex; \n}; \n```", "```cs\n  void surf (Input IN, inout SurfaceOutput o) {\n    //Get the pixel data from the blend texture \n    //we need a float 4 here because the texture \n    //will return R,G,B,and A or X,Y,Z, and W \n    float4 blendData = tex2D(_BlendTex, IN.uv_BlendTex); \n\n    //Get the data from the textures we want to blend \n    float4 rTexData = tex2D(_RTexture, IN.uv_RTexture); \n    float4 gTexData = tex2D(_GTexture, IN.uv_GTexture); \n    float4 bTexData = tex2D(_BTexture, IN.uv_BTexture); \n    float4 aTexData = tex2D(_ATexture, IN.uv_ATexture); \n```", "```cs\n//No we need to construct a new RGBA value and add all  \n//the different blended texture back together \nfloat4 finalColor; \nfinalColor = lerp(rTexData, gTexData, blendData.g); \nfinalColor = lerp(finalColor, bTexData, blendData.b); \nfinalColor = lerp(finalColor, aTexData, blendData.a);\nfinalColor.a = 1.0;\n```", "```cs\n  //Add on our terrain tinting colors \n  float4 terrainLayers = lerp(_ColorA, _ColorB, blendData.r); \n  finalColor *= terrainLayers; \n  finalColor = saturate(finalColor); \n\n  o.Albedo = finalColor.rgb * _MainTint.rgb; \n  o.Alpha = finalColor.a;\n}\n```", "```cs\n_Center(\"Center\", Vector) = (200,0,200,0) \n_Radius(\"Radius\", Float) = 100 \n_RadiusColor(\"Radius Color\", Color) = (1,0,0,1) \n_RadiusWidth(\"Radius Width\", Float) = 10\n```", "```cs\nfloat3 _Center; \nfloat _Radius; \nfixed4 _RadiusColor; \nfloat _RadiusWidth; \n```", "```cs\nstruct Input \n{ \n  float2 uv_MainTex; // The UV of the terrain texture \n  float3 worldPos;   // The in-world position \n}; \n```", "```cs\nvoid surf(Input IN, inout SurfaceOutputStandard o) \n{\n  // Get the distance between the center of the \n  // place we wish to draw from and the input's \n  // world position\n  float d = distance(_Center, IN.worldPos);\n\n  // If the distance is larger than the radius and\n  // it is less than our radius + width change the color\n  if ((d > _Radius) && (d < (_Radius + _RadiusWidth)))\n  {\n    o.Albedo = _RadiusColor;\n  }\n  // Otherwise, use the normal color\n  else\n  {\n    o.Albedo = tex2D(_MainTex, IN.uv_MainTex).rgb;\n  }\n}\n```", "```cs\n[ExecuteInEditMode]\npublic class SetRadiusProperties : MonoBehaviour\n```", "```cs\npublic Material radiusMaterial; \npublic float radius = 1; \npublic Color color = Color.white; \n```", "```cs\nif(radiusMaterial != null)\n{\n    radiusMaterial.SetVector(\"_Center\", transform.position);\n    radiusMaterial.SetFloat(\"_Radius\", radius);\n    radiusMaterial.SetColor(\"_RadiusColor\", color);\n}\n```"]