["```cs\ndocker run -d\n    --restart unless-stopped\n    --name seq\n    -e ACCEPT_EULA=Y\n    -v c:\\data:/data\n    -p 80:80\n    -p 5341:5341\n    datalust/seq:latest\n```", "```cs\ndocker run -d\n    --name prom\n    -p 9090:9090\n    -v c:\\data\\prometheus.yml:/etc/prometheus/prometheus.yml\n    prom/prometheus\n```", "```cs\nusing Microsoft.Extensions.Logging;\nILoggerFactory loggerFactory = LoggerFactory.Create(builder =>\n{\n    builder.SetMinimumLevel(LogLevel.Information);\n});\nvar logger = loggerFactory.CreateLogger<Program>();\nlogger.LogInformation(\"This is some information\");\n```", "```cs\nvar loggerFactory = LoggerFactory.Create(builder =>\n{\n    builder.AddConsole();\n    builder.SetMinimumLevel(LogLevel.Information);\n});\n```", "```cs\nlogger.Log(LogLevel.Critical, \"This is a critical message\");\n```", "```cs\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\"\n    }\n  }\n}\n```", "```cs\nvar configurationBuilder = new ConfigurationBuilder()\n    .AddJsonFile(\n        path: \"appsettings.json\",\n        optional:true,\n        reloadOnChange:true);\nvar configuration = configurationBuilder.Build();\nvar configurationSection=\n    configuration.GetSection(\"Logging\");\n```", "```cs\nvar loggerFactory = LoggerFactory.Create(builder =>\n{\n    builder.AddConsole();\n    builder.AddConfiguration(configurationSection);\n});\n```", "```cs\nwhile (true)\n{\n    logger.LogTrace(\"This is a trace\");\n    logger.LogDebug(\"This is debug\");\n    logger.LogInformation(\"This is information\");\n    logger.LogWarning(\"This is warning\");\n    logger.LogError(\"This is an error\");\n    logger.LogCritical(\"This is a critical message\");\n    await Task.Delay(1000);\n}\n```", "```cs\nvar initEventId = new EventId(1, \"Initialization\");\nvar shutdownEventId = new EventId(2, \"Shutdown\");\nvar fileReadingEventId = new EventId(3, \"File Reading\");\n```", "```cs\nlogger.LogInformation(initializationEventId, \"Application started\");\nlogger.LogInformation(shutdownEventId, \"Application shutting down\");\nlogger.LogError(fileReadingEventId, \"File not found\");\n```", "```cs\nvar logger = loggerFactory.CreateLogger<Program>();\n```", "```cs\nvar printLogger = loggerFactory.CreateLogger<Printer>();\n```", "```cs\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<nlog xmlns=http://www.nlog-project.org/schemas/NLog.xsd\n      xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance\n      >\n  <targets>\n    <target\n      name=\"logfile\"\n      xsi:type=\"File\"\n      fileName=\"${basedir}/logs/logfile.txt\"\n      layout=\"${date:format=HH\\:mm\\:ss} ${logger} ${uppercase:${level}} ${message}\" />\n    <target\n      name=\"logconsole\"\n      xsi:type=\"Console\" />\n  </targets>\n  <rules>\n    <logger name=\"*\"\n            minlevel=\"Info\"\n            writeTo=\"logfile,logconsole\" />\n  </rules>\n</nlog>\n```", "```cs\nusing NLog;\nLogManager.Configuration =\n    new XmlLoggingConfiguration(\n        \"NLog.config\"\n    );\ntry\n{\n    Logger logger = LogManager.GetCurrentClassLogger();\n    logger.Trace(\"This is a trace message\");\n    logger.Debug(\"This is a debug message\");\n    logger.Info(\"Application started\");\n    logger.Warn(\"This is a warning message\");\n    logger.Error(\"This is an error message\");\n    logger.Fatal(\"This is a fatal error message\");\n}finally{\n    LogManager.Shutdown();\n}\n```", "```cs\nvar otherLogger  = LogManager.GetLogger(\"OtherLogger\");\n```", "```cs\n<target\n  name=\"logcolorconsole\"\n  xsi:type=\"ColoredConsole\"\n  header=\"Logfile for run ${longdate)\"\n  footer=\"-----------\"\n  layout=\"${date:format=HH\\:mm\\:ss} ${logger}\n${uppercase:${level}} ${message}\" />\n```", "```cs\n<rules>\n  <logger name=\"*\"\n          minlevel=\"Info\"\n          writeTo=\"logcolorconsole\" />\n</rules>\n```", "```cs\n<rules>\n  <logger name=\"*\"\n          minlevel=\"Trace\"\n          writeTo=\"logfile\" />\n  <logger name=\"Program\"\n          minLevel=\"Warn\"\n          writeTo=\"logcolorconsole\" />\n  <logger name=\"OtherLogger\"\n          minLevel=\"Info\"\n          writeTo=\"logconsole\" />\n</rules>\n```", "```cs\n<target\n  name=\"asyncWrapper\"\n  xsi:type=\"AsyncWrapper\">\n  <target\n    name=\"logfile\"\n    xsi:type=\"File\"\n    fileName=\"${basedir}/logs/logfile.txt\"\n    layout=\"${date:format=HH\\:mm\\:ss} ${logger} ${uppercase:${level}} ${message}\" />\n  </target>\n```", "```cs\n<nlog xmlns=http://www.nlog-project.org/schemas/NLog.xsd\n      xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance\n      autoReload=\"true\"\n      internalLogFile=\"${basedir}/logs/internallog.txt\"\n      internalLogLevel=\"Trace\"\n      >\n```", "```cs\nusing Serilog;\nvar logger = new LoggerConfiguration()\n    .MinimumLevel.Debug()\n    .WriteTo.Console()\n    .WriteTo.File(path:\n        \"logs\\\\log.txt\",\n        rollingInterval: RollingInterval.Day)\n    .CreateLogger();\ntry\n{\n    logger.Verbose(\"This is verbose\");\n    logger.Debug(\"This is debug\");\n    logger.Information(\"This is information\");\n    logger.Warning(\"This is warning\");\n    logger.Error(\"This is error\");\n    logger.Fatal(\"This is fatal\");\n}\nfinally\n{\n    await Log.CloseAndFlushAsync();\n}\n```", "```cs\nvar logger = new LoggerConfiguration()\n    .MinimumLevel.Debug()\n    .WriteTo.Console(new JsonFormatter())\n    .WriteTo.File(\n        new JsonFormatter(),\n        \"logs\\\\log.txt\",\n        rollingInterval: RollingInterval.Day)\n    .CreateLogger();\n```", "```cs\nlogger.Information(\n    \"The user with userId {userId} logged in at {loggedInTime}\",\n    42,\n    DateTime.UtcNow.TimeOfDay);\n```", "```cs\n{\n    \"Timestamp\": \"2024-04-20T11:47:31.5139218+02:00\",\n    \"Level\": \"Information\",\n    \"MessageTemplate\": \"The user with userId {userId} logged in at {loggedInTime}\",\n    \"Properties\": {\n        \"userId\": 42,\n        \"loggedInTime\": \"09:47:31.5125828\"\n    }\n}\n```", "```cs\nvar logger = new LoggerConfiguration()\n    .MinimumLevel.Verbose()\n    .WriteTo.Console(new JsonFormatter())\n    .WriteTo.File(\n        new JsonFormatter(),\n        \"logs\\\\log.json\",\n        rollingInterval: RollingInterval.Day)\n    .WriteTo.Seq(\"http://localhost:5341\")\n    .CreateLogger();\n```", "```cs\nusing System.Diagnostics;\nusing ExtensionLibrary;\n#pragma warning disable CA1416\nvar counter = 0;\nvar cpuCounter = new PerformanceCounter(\"Processor\", \"% Processor Time\", \"_Total\");\nwhile (true)\n{\n    if (counter++ == 10)\n        // Start a method on a background thread\n        Task.Run(() =>\n        {\n            Parallel.For(0, Environment.ProcessorCount, j =>\n            {\n                for (var i = 0; i < 100000000; i++)\n                {\n                    var result = Math.Exp(Math.Sqrt(Math.PI));\n                }\n            });\n            counter = 0;\n        });\n    var cpuUsage = cpuCounter.NextValue();\n    var message = $\"CPU Usage: {cpuUsage}%\";\n    var color = cpuUsage > 10 ? ConsoleColor.Red : ConsoleColor.Green;\n    message.Dump(color);\n    await Task.Delay(200);\n}\n```", "```cs\nglobal:\n  scrape_interval: 5s\n  evaluation_interval: 5s\nscrape_configs:\n  - job_name: 'c# worker'\n    static_configs:\n      - targets: ['host.docker.internal:1234']\n```", "```cs\nGauge memoryGauge =\n    Metrics.CreateGauge(\n        \"app_memory_usage_bytes\",\n        \"Memory Usage of the application in bytes.\");\nvar server =\n    new MetricServer(\n        hostname:\"127.0.0.1\",\n        port: 1234);\nserver.Start();\n```", "```cs\nstatic void UpdateMemoryGauge(Gauge memoryGauge)\n{\n    var memoryUsage = GC.GetTotalMemory(forceFullCollection: false);\n    memoryGauge.Set(memoryUsage);\n}\n```", "```cs\nvar counter = 0;\nList<byte[]> buffer = [];\nRandom rnd = new Random();\nwhile (true)\n{\n    if (counter++ % 5 == 0)\n        AllocateMemoryBlock(rnd, buffer);\n    if (counter == 20)\n    {\n        ClearMemory(buffer);\n        counter = 0;\n    }\n    UpdateMemoryGauge(memoryGauge);\n    await Task.Delay(1000);\n}\n```", "```cs\nstatic void AllocateMemoryBlock(Random random, List<byte[]> bytesList)\n{\n    var memoryToAllocate =\n        random.Next(50000000, 200000000);\n    var dummyBlock =\n        new byte[memoryToAllocate];\n    bytesList.Add(dummyBlock);\n    \"Memory block added\".Dump(ConsoleColor.Blue);\n}\n```", "```cs\nstatic void ClearMemory(List<byte[]> list)\n{\n    list.Clear();\n    GC.Collect();\n    \"Memory block cleared\".Dump(ConsoleColor.Green);\n}\n```"]