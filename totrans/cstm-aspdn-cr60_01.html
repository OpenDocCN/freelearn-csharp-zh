<html><head></head><body>
		<div><h1 id="_idParaDest-19"><em class="italic"><a id="_idTextAnchor019"/>Chapter 1</em>: Customizing Logging</h1>
			<p>In this chapter, the first in this book about customizing <strong class="bold">ASP.NET</strong> <strong class="bold">Core</strong>, you will see how to customize <strong class="bold">logging</strong>. The default logging only writes to the console or the debug window. This is quite good for the majority of cases, but sometimes you need to log to a sink, such as a file or a database. Or, perhaps you want to extend the logger with additional information. In these cases, you need to know how to change the default logging. </p>
			<p>In this chapter, we will be covering the following topics:</p>
			<ul>
				<li>Configuring logging</li>
				<li>Creating a custom logger</li>
				<li>Plugging in an existing third-party logger provider</li>
			</ul>
			<p>The topics in this chapter refer to the <a id="_idIndexMarker000"/>hosting layer of the ASP.NET Core architecture:</p>
			<div><div><img src="img/Figure_1.1_B17996.jpg" alt="Figure 1.1 – The ASP.NET Core architecture"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – The ASP.NET Core architecture</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor020"/>Technical requirements</h1>
			<p>To follow the descriptions in this chapter, you will need to create an ASP.NET Core MVC application. To do this, open your console, shell, or Bash terminal, and change to your working directory. Then, use the following command to create a new MVC application:</p>
			<pre>dotnet new mvc -n LoggingSample -o LoggingSample</pre>
			<p>Now, open the project in <strong class="bold">Microsoft</strong> <strong class="bold">Visual Studio</strong> by double-clicking the project file, or in Visual Studio Code, by typing the following command in the already-open console:</p>
			<pre>cd LoggingSample
code .</pre>
			<p>All of the code samples in this chapter can be found in the <strong class="bold">GitHub</strong> repository for this book at <a href="https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter01">https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter01</a>.</p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor021"/><a id="_idTextAnchor022"/>Configuring logging</h1>
			<p>In previous <a id="_idIndexMarker001"/>versions of ASP.NET Core (that is, before version 2.0), logging was configured in <code>Startup.cs</code>. As a reminder, since version 2.0, the <code>Startup.cs</code> file has been simplified, and a lot of configurations have been moved to the default <code>WebHostBuilder</code>, which is called in <code>Program.cs</code>. Also, logging was moved to the default <code>WebHostBuilder</code>.</p>
			<p>In ASP.NET Core 3.1 and later versions, the <code>Program.cs</code> file gets more generic, and <code>IHostBuilder</code> will be created first. <code>IHostBuilder</code> is pretty useful for bootstrapping an application without all of the ASP.NET web stuff. We'll learn a lot more about <code>IHostBuilder</code> later on in this book. With this <code>IHostBuilder</code>, we create <code>IWebHostBuilder</code> to configure ASP.NET Core. In ASP.NET Core 3.1 and later versions, we get <code>IWebHostBuilder</code> with the <code>webBuilder</code> variable:</p>
			<pre>public class Program
{
    public static void Main(string[] args)
    {
        CreateHostBuilder(args).Build().Run();
    }
    public static IHostBuilder CreateHostBuilder(
      string[]args) =&gt;
        Host.CreateDefaultBuilder(args)
            .ConfigureWebHostDefaults(webBuilder =&gt;
            {
                webBuilder.UseStartup&lt;Startup&gt;();
            });
}</pre>
			<p>In ASP.NET Core 6.0, Microsoft <a id="_idIndexMarker002"/>introduced the <code>Startup</code> file and adds all of the configurations to the <code>Program.cs</code> file instead. Let's see what this looks like:</p>
			<pre>var builder = WebApplication.CreateBuilder(args);
// Add services to the container.
builder.Services.AddControllersWithViews();
var app = builder.Build();
// The rest of the file isn't relevant for this chapter</pre>
			<p>In ASP.NET Core, you are able to override and customize almost everything. This includes logging. <code>IWebHostBuilder</code> has a lot of extension methods that allow us to override the default behavior of different features. To override the default settings for logging, we need to use the <code>ConfigureLogging</code> method. The following code snippet shows almost exactly the same logging as was configured inside the <code>ConfigureWebHostDefaults()</code> method:</p>
			<pre>Host.CreateDefaultBuilder(args)
    .ConfigureWebHostDefaults(webBuilder =&gt;
    {
        webBuilder
            .ConfigureLogging((hostingContext, logging) =&gt;
            {
                logging.AddConfiguration(
                  hostingContext.Configuration.GetSection(
                    "Logging"));
                logging.AddConsole();
                logging.AddDebug();
            })
            .UseStartup&lt;Startup&gt;();</pre>
			<p>Using the <a id="_idIndexMarker004"/>minimal API approach, we don't need the <code>ConfigureLogging</code> method anymore, and we can use the <code>Logging</code> property of <code>WebApplicationBuilder</code> directly:</p>
			<pre>builder.Logging.AddConfiguration(builder.Configuration.GetSection("Logging"));
builder.Logging.AddConsole();
builder.Logging.AddDebug();</pre>
			<p>Now that we've seen how to configure logging, let's look at building a custom logg<a id="_idTextAnchor023"/><a id="_idTextAnchor024"/>er.</p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor025"/>Creating a custom logger</h1>
			<p>To demonstrate a <a id="_idIndexMarker005"/>custom logger, let's use a small, simple logger I created that is able to colorize log entries with a specific log level in the console. This logger is called <code>ColoredConsoleLogger</code>, and it will be created and added using <code>LoggerProvider</code>, which we also need to write for ourselves. To specify the color and the log level to colorize, we need to add a configuration class. </p>
			<p>In the next snippets, all three parts (<code>Logger</code>, <code>LoggerProvider</code>, and <code>Configuration</code>) are shown:</p>
			<ol>
				<li>Let's create the configuration class of our logger in a new file called <code>CustomLogger.cs</code> in the same folder as the <code>Program.cs</code> file. Add the following using statement at<a id="_idIndexMarker006"/> the top of the file:<pre>namespace LoggingSample;</pre><p>We will call it <code>ColoredConsoleLoggerConfiguration</code>. This class contains three properties to define – <code>LogLevel</code>, <code>EventId</code>, and <code>Color</code> – that can be set:</p><pre>public class ColoredConsoleLoggerConfiguration
{
    public LogLevel LogLevel { get; set; } = 
      LogLevel.Warning;
    public int EventId { get; set; } = 0;
    public ConsoleColor Color { get; set; } = 
      ConsoleColor.Yellow;
}</pre></li>
				<li>Next, we need a provider to retrieve the configuration and create the actual logger instance:<pre>public class ColoredConsoleLoggerProvider : ILoggerProvider
{
    private readonly ColoredConsoleLoggerConfiguration
      _config;
    private readonly ConcurrentDictionary&lt;string,
      ColoredConsoleLogger&gt; _loggers =
        new ConcurrentDictionary&lt;string,
           ColoredConsoleLogger&gt;();
    public ColoredConsoleLoggerProvider
      (ColoredConsoleLoggerConfiguration config)
    {
        _config = config;
    }
    public ILogger CreateLogger(string categoryName)
    {
        return _loggers.GetOrAdd(categoryName, name =&gt;
            new ColoredConsoleLogger(name, _config));
    }
    public void Dispose()
    {
        _loggers.Clear();
    }
}</pre><p>Don't forget<a id="_idIndexMarker007"/> to add a <code>using</code> statement for <code>System.Collections.Concurrent</code>.</p></li>
				<li>The third class is the actual logger we want to use:<pre>public class ColoredConsoleLogger : ILogger
{
    private static object _lock = new Object();
    private readonly string _name;
    private readonly ColoredConsoleLoggerConfiguration 
      _config;
    public ColoredConsoleLogger(
        string name,
        ColoredConsoleLoggerConfiguration config)
    {
        _name = name;
        _config = config;
    }
    public IDisposable BeginScope&lt;TState&gt;(TState 
      state)
    {
        return null;
    }
    public bool IsEnabled(LogLevel logLevel)
    {
        return logLevel == _config.LogLevel;
    }
    public void Log&lt;TState&gt;(
        LogLevel logLevel,
        EventId eventId,
        TState state,
        Exception exception,
        Func&lt;TState, Exception, string&gt; formatter)
    {
        if (!IsEnabled(logLevel))
        {
            return;
        }
        lock (_lock)
        {
            if (_config.EventId == 0 ||
                _config.EventId == eventId.Id)
            {
                var color = Console.ForegroundColor;
                Console.ForegroundColor = 
                  _config.Color;
                Console.Write($"{logLevel} - ");
                Console.Write($"{eventId.Id} - {_name}
                              - ");
                Console.Write($"{formatter(state,
                                 exception)}\n");
                Console.ForegroundColor = color;
            }
        }
    }
}</pre><p>We now need to lock the actual console output – this is because we will encounter some race conditions where incorrect log entries get colored with the wrong color, as the console itself is not really thread-safe.</p></li>
				<li>After<a id="_idIndexMarker008"/> this is done, we can start to plug in the new logger to the configuration in <code>Program.cs</code>:<pre>builder.Logging.ClearProviders();
var config = new ColoredConsoleLoggerConfiguration
{
    LogLevel = LogLevel.Information,
    Color = ConsoleColor.Red
};
builder.Logging.AddProvider(new 
    ColoredConsoleLoggerProvider(config));</pre></li>
			</ol>
			<p>You might need to add a using statement to the <code>LoggerSample</code> namespace.</p>
			<p>If you don't want to use the existing loggers, you can clear all the logger providers added previously. Then, we call <code>AddProvider</code> to add a new instance of our <code>ColoredConsoleLoggerProvider</code> class with the specific settings. We could also add some more instances of the provider with different settings.</p>
			<p>This shows how you could handle the log levels in a different way. You could use this approach to send emails regarding hard errors or to log debug messages to a different log sink from regular informational messages, and much more.</p>
			<p><em class="italic">Figure 1.2</em> shows <a id="_idIndexMarker009"/>the colored output of the previously created custom logger:</p>
			<div><div><img src="img/Figure_1.2_B17996.jpg" alt="Figure 1.2 – A screenshot of the custom logger"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – A screenshot of the custom logger</p>
			<p>In many cases, it doesn't make sense to write a custom logger, as many good third-party loggers are already available, such as <code>ELMAH</code>, <code>log4net</code>, and <code>NLog</code>. In the next section, we will see how to use <code>NLog</code> in ASP.NE<a id="_idTextAnchor026"/><a id="_idTextAnchor027"/>T Core.</p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor028"/>Plugging in an existing third-party logger provider</h1>
			<p><code>NLog</code> was<a id="_idIndexMarker010"/> one of the very first available<a id="_idIndexMarker011"/> as a <code>NLog</code> also already provides a logger provider to easily plug into ASP.NET Core.</p>
			<p>You will<a id="_idIndexMarker013"/> find <code>NLog</code> via <code>NLog</code> is not yet explicitly available for ASP.NET Core 6.0, it will still work with version 6.0:</p>
			<ol>
				<li value="1">We need to add an <code>NLog.Config</code> file that defines two different sinks to log all standard messages in a single log file and custom messages only in another file. Since this file is too long to print, you can view it or download it directly from GitHub: <a href="https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/blob/main/Chapter01/LoggingSample6.0/NLog.Config">https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/blob/main/Chapter01/LoggingSample6.0/NLog.Config</a></li>
				<li>We then need to add the <code>NLog</code> ASP.NET Core package from NuGet:<pre><strong class="bold">dotnet add package NLog.Web.AspNetCore</strong></pre><p class="callout-heading">Important Note</p><p class="callout">Be sure that you are in the project directory before you execute the preceding command!</p></li>
				<li>Now, you <a id="_idIndexMarker014"/>only need to clear all the other providers in the <code>ConfigureLogging</code> method in <code>Program.cs</code> and to use <code>NLog</code> with <code>IWebHostBuilder</code> using the <code>UseNLog()</code> method:<pre>Host.CreateDefaultBuilder(args)
    .ConfigureWebHostDefaults(webBuilder =&gt;
    {
        webBuilder
            .ConfigureLogging((hostingContext,
              logging) =&gt;
            {
                logging.ClearProviders();
                logging.SetMinimumLevel(
                  LogLevel.Trace);
            })
            .UseNLog()
            .UseStartup&lt;Startup&gt;();
    });</pre><p>Using the <a id="_idIndexMarker015"/>minimal API, it looks much simpler:</p><pre>using NLog.Web;
var builder = WebApplication.CreateBuilder(args);
builder.Logging.ClearProviders();
builder.Logging.SetMinimumLevel(LogLevel.Trace);
builder.WebHost.UseNLog();</pre><p>Here, you can add as many logger providers as you require.</p></li>
			</ol>
			<p>That covers using an existing third-party logger. Let's now recap what we've covered in <a id="_idTextAnchor029"/>this chapter.</p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor030"/>Summary</h1>
			<p>The good thing about hiding the basic configuration of an application is that it allows you to clean up the newly scaffolded projects and to keep the actual start as simple as possible. The developer is able to focus on the actual features. However, the more the application grows, the more important logging becomes. The default logging configuration is easy and it works like a charm, but in production, you need a persisted log to see errors from the past. Therefore, you need to add a custom logging configuration or a more flexible third-party logger, such as <code>NLog</code> or <code>log4net</code>.</p>
			<p>You will learn more about how to configure ASP.NET Core 6.0 in the next chapter.</p>
		</div>
	</body></html>