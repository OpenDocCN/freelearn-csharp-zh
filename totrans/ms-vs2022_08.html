<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-132">
    <a id="_idTextAnchor132">
    </a>
    
     8
    
   </h1>
   <h1 id="_idParaDest-133">
    <a id="_idTextAnchor133">
    </a>
    
     Advanced Cloud Integration and Services
    
   </h1>
   <p>
    
     In this chapter, we will delve into the advanced realm of cloud integration and services, highlighting how Visual Studio 2022 serves as a powerful tool to develop and manage cloud-based applications.
    
    
     In today’s digital ecosystem, cloud computing has become a cornerstone, enabling scalable, resilient, and highly available applications.
    
    
     To stay ahead, developers must not only build robust applications but also seamlessly integrate them with various
    
    
     
      cloud platforms.
     
    
   </p>
   <p>
    
     Throughout this chapter, we’ll learn how to harness the power of various cloud services, streamline our development workflows, and ensure that our applications are optimized for cloud environments.
    
    
     Whether it’s deploying serverless functions on Azure, integrating Google Cloud services, or leveraging the extensive tools provided by AWS, this chapter will equip you with the knowledge and skills needed to excel in advanced
    
    
     
      cloud development.
     
    
   </p>
   <p>
    
     Key topics covered in this chapter include
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Exploring .
     
     
      
       NET Aspire
      
     
    </li>
    <li>
     
      Exploring Azure Functions development in Visual
     
     
      
       Studio 2022
      
     
    </li>
    <li>
     
      Exploring Google Cloud Tools for
     
     
      
       Visual Studio
      
     
    </li>
    <li>
     
      Exploring the
     
     
      
       AWS Toolkit
      
     
    </li>
   </ul>
   <p>
    
     Let’s begin our journey toward mastering cloud integration and building cutting-edge cloud-based
    
    
     
      applications together.
     
    
   </p>
   <h1 id="_idParaDest-134">
    <a id="_idTextAnchor134">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     While writing this chapter, I used the following version of
    
    
     
      Visual Studio:
     
    
   </p>
   <ul>
    <li>
     
      Visual Studio Enterprise 2022
     
     
      
       Version
      
     
     
      
       17.12.0
      
     
    </li>
    <li>
     
      
       Preview 1.0
      
     
    </li>
   </ul>
   <p>
    
     For an optimal experience, consider having
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      An
     
     
      
       Azure subscription
      
     
    </li>
    <li>
     
      A Google Cloud
     
     
      
       Platform subscription
      
     
    </li>
    <li>
     
      An
     
     
      
       AWS
      
     
     
      
       subscription
      
     
    </li>
   </ul>
   <p>
    
     The code files for this chapter can be found
    
    
     
      at
     
    
    <a href="https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch08">
     
      
       https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch08
      
     
    </a>
   </p>
   <h1 id="_idParaDest-135">
    <a id="_idTextAnchor135">
    </a>
    
     Exploring .NET Aspire
    
   </h1>
   <p>
    
     In
    
    <a id="_idIndexMarker518">
    </a>
    
     November 2023, as part of .NET 8, Microsoft introduced .NET Aspire.
    
    
     The motivation of Microsoft is to make .NET one of the most productive platforms for building cloud-native applications.
    
    
     This technology seamlessly integrates with popular containerization platforms such as Docker and Kubernetes, facilitating the management of applications and their deployment in cloud-native environments.
    
    
     In this section, we will explore what .NET Aspire is and how Visual Studio guides us through its
    
    
     
      development process.
     
    
   </p>
   <p>
    
     .NET Aspire represents a sophisticated suite of tools engineered to facilitate the construction of observable, robust, and scalable applications tailored for cloud environments.
    
    
     Designed with a focus on cloud-specific requirements, this cohesive framework seeks to ease the process of developing cloud-native solutions by offering a coherent array of utilities and methodologies.
    
    
     Central aspects of .NET Aspire encompass
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       A cloud-specific framework
      
     </strong>
     
      : Tailored to address the unique hurdles encountered
     
     <a id="_idIndexMarker519">
     </a>
     
      during cloud application development, .NET Aspire underscores the importance of being easily observable, ready for deployment, and capable of operating across
     
     
      
       distributed systems.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Component-based design
      
     </strong>
     
      : Presented as a series of NuGet packages, these components
     
     <a id="_idIndexMarker520">
     </a>
     
      cater to distinct needs within cloud computing, allowing developers to incorporate only those elements essential for their projects.
     
     
      This modular structure not only enhances adaptability but also
     
     
      
       boosts productivity.
      
     
    </li>
    <li>
     <strong class="bold">
      
       A streamlined development workflow
      
     </strong>
     
      : By introducing a uniform set of tools and
     
     <a id="_idIndexMarker521">
     </a>
     
      practices, .NET Aspire simplifies the assembly of .NET applications suited for the cloud.
     
     
      It features pre-configured modules for databases such as Redis and PostgreSQL, thereby easing their integration
     
     
      
       into projects.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Enhanced developer tools
      
     </strong>
     
      : The toolkit enriches the development life cycle through
     
     <a id="_idIndexMarker522">
     </a>
     
      project templates and integrations with Visual Studio and the .NET CLI, making the initiation and administration of applications
     
     
      
       more straightforward.
      
     
    </li>
   </ul>
   <p>
    
     .NET Aspire
    
    <a id="_idIndexMarker523">
    </a>
    
     allows us to manage the organization and linkage of different parts of an application, making the assembly of interconnected services and the identification of available resources less cumbersome.
    
    
     It provides standardized components by delivering NuGet packages that resolve common issues associated with cloud deployments, offering predefined setups for tasks such as monitoring, diagnostics, and
    
    
     
      data transmission.
     
    
   </p>
   <p>
    
     By introducing well-structured project templates to enhance the organization of applications and expedite the setup phase, and featuring pivotal projects such as Application Host and Default Services, .NET Aspire caters to professionals looking to construct applications that are scalable, fault-tolerant, and maintainable within
    
    
     
      cloud infrastructures.
     
    
   </p>
   <p>
    
     Its dedication to cloud-centric development positions it as a significant asset within the .NET community, empowering developers to harness the full potential of cloud technologies for their
    
    
     
      software solutions.
     
    
   </p>
   <p>
    
     Let’s explore what Visual Studio has prepared for us regarding .NET Aspire.
    
    
     To do this, we will create a new project with the
    
    <strong class="bold">
     
      .NET Aspire Starter Application
     
    </strong>
    
     template.
    
    
     For this example, we will name
    
    
     
      it
     
    
    
     <strong class="source-inline">
      
       SampleAspireProject
      
     </strong>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 8.1 – The .NET Aspire Starter Application ﻿template" src="img/B22218_08_1.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.1 – The .NET Aspire Starter Application template
    
   </p>
   <p>
    
     When you create a new project, Visual Studio will open an
    
    <strong class="bold">
     
      Overview
     
    </strong>
    
     page, providing links to Microsoft documentation about building and deploying our app and
    
    
     
      service discovery:
     
    
   </p>
   <div><div><img alt="Figure 8.2 – The Aspire Overview page" src="img/B22218_08_2.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.2 – The Aspire Overview page
    
   </p>
   <p>
    
     On the
    
    <a id="_idIndexMarker524">
    </a>
    
     same page, we can find more tabs; the second one is
    
    <strong class="bold">
     
      Connected Services
     
    </strong>
    
     .
    
    
     By clicking on this option, we can access two options that allow us to add service dependencies and
    
    
     
      service references.
     
    
   </p>
   <div><div><img alt="Figure 8.3 – Connected Services" src="img/B22218_08_3.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.3 – Connected Services
    
   </p>
   <p>
    
     Upon clicking the
    
    <strong class="bold">
     
      Add a service dependency
     
    </strong>
    
     link, a window opens up that allows us to select an Azure service to add to
    
    
     
      our solution.
     
    
   </p>
   <div><div><img alt="Figure 8.4 – Adding a dependency" src="img/B22218_08_4.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.4 – Adding a dependency
    
   </p>
   <p>
    
     Note that
    
    <a id="_idIndexMarker525">
    </a>
    
     to be able to complete the process of adding a dependency, we need a valid
    
    
     
      Azure subscription.
     
    
   </p>
   <p>
    
     Go back to the
    
    <strong class="bold">
     
      Connected Service
     
    </strong>
    
     , and click on the
    
    <strong class="bold">
     
      Add a service reference
     
    </strong>
    
     link.
    
    
     This will give us access to a window that enables us to select between three API specifications –
    
    <strong class="bold">
     
      OpenAPI
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      gRPC
     
    </strong>
    
     , and
    
    <strong class="bold">
     
      WCF
     
    </strong>
    
     <strong class="bold">
      
       Web Service
      
     </strong>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 8.5 – Adding a service reference" src="img/B22218_08_5.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.5 – Adding a service reference
    
   </p>
   <p>
    
     The
    
    <a id="_idIndexMarker526">
    </a>
    
     template we have used sets up four projects for
    
    
     
      our solution:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       ApiService
      
     </strong>
     
      : ASP.NET Core minimal APIs, serving as the backend
     
     
      
       logic layer
      
     
    </li>
    <li>
     <strong class="bold">
      
       AppHost
      
     </strong>
     
      : This is the project that hosts the configuration of
     
     
      
       our solution
      
     
    </li>
    <li>
     <strong class="bold">
      
       ServiceDefaults
      
     </strong>
     
      : Represents the shared project that contains default configurations and potential objects used across multiple services in
     
     
      
       the solutions
      
     
    </li>
    <li>
     <strong class="bold">
      
       Web
      
     </strong>
     
      : This Blazor project is dedicated to
     
     
      
       frontend development.
      
     
    </li>
   </ul>
   <div><div><img alt="Figure 8.6 – Starter application components" src="img/B22218_08_6.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.6 – Starter application components
    
   </p>
   <p>
    
     The
    
    <strong class="bold">
     
      AppHost
     
    </strong>
    
     project
    
    <a id="_idIndexMarker527">
    </a>
    
     is set as the starring project by default.
    
    
     So, when we launch the solution, the .NET Aspire template opens the
    
    <strong class="bold">
     
      SampleAspireApp
     
    </strong>
    
     <strong class="bold">
      
       dashboard
      
     </strong>
    
    
     
      window.
     
    
   </p>
   <div><div><img alt="Figure 8.7 – The .NET Aspire dashboard" src="img/B22218_08_7.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.7 – The .NET Aspire dashboard
    
   </p>
   <p>
    
     The dashboard provides crucial information about our solution through different metrics, such as logs, traces, and environment configuration.
    
    
     In the
    
    <strong class="bold">
     
      Resources
     
    </strong>
    
     panel, we can access each endpoint of our solution.
    
    
     In this template project, we retrieve
    
    <strong class="bold">
     
      apiservice
     
    </strong>
    
     and
    
    <strong class="bold">
     
      webfrontend
     
    </strong>
    
     in
    
    
     
      the dashboard.
     
    
   </p>
   <p>
    
     After the local development of our cloud-native solution, we can directly publish it to our Azure platform.
    
    
     Note that we need an Azure Developer CLI installed.
    
    
     To create a publish profile, we can reopen the
    
    <strong class="bold">
     
      Overview
     
    </strong>
    
     window from the top bar menu (
    
    <strong class="bold">
     
      Project
     
    </strong>
    
     |
    
    
     <strong class="bold">
      
       Overview
      
     </strong>
    
    
     
      ).
     
    
   </p>
   <div><div><img alt="Figure 8.8 – Publish profiles" src="img/B22218_08_8.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.8 – Publish profiles
    
   </p>
   <p>
    
     By using
    
    <a id="_idIndexMarker528">
    </a>
    
     Visual Studio through .NET Aspire, we have  set up a cloud-native application ready to be deployed.
    
    
     In the next section, we will explore Azure Functions development in
    
    
     
      Visual Studio.
     
    
   </p>
   <h1 id="_idParaDest-136">
    <a id="_idTextAnchor136">
    </a>
    
     Exploring Azure Functions development in Visual Studio
    
   </h1>
   <p>
    
     Visual Studio
    
    <a id="_idIndexMarker529">
    </a>
    
     provides several built-in templates for the Azure platform.
    
    
     As Azure Functions is the most popular cloud-native feature of Microsoft, we will focus on it in
    
    
     
      this section.
     
    
   </p>
   <p>
    
     Put simply, Azure Functions
    
    <a id="_idIndexMarker530">
    </a>
    
     is a serverless computing service offered by Microsoft Azure that allows developers to run small pieces of code without worrying about the
    
    
     
      underlying infrastructure.
     
    
   </p>
   <p>
    
     Azure Functions is designed to respond to events from a variety of sources, including HTTP requests, timers, database changes, and many other Azure services.
    
    
     This event-driven model enables us to build applications that react to real-time data changes, automate tasks, and integrate with other
    
    
     
      systems seamlessly.
     
    
   </p>
   <p>
    
     First, we need to ensure that the Azure development workload is installed on our Visual Studio instance by navigating to the Visual
    
    
     
      Studio Installer.
     
    
   </p>
   <div><div><img alt="Figure 8.9 – An Azure development workload" src="img/B22218_08_9.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.9 – An Azure development workload
    
   </p>
   <p>
    
     Once
    
    <a id="_idIndexMarker531">
    </a>
    
     the workload is installed, we
    
    <a id="_idIndexMarker532">
    </a>
    
     can start by creating a new Azure Functions project, and for this example, we will name
    
    
     
      it
     
    
    
     <strong class="source-inline">
      
       SampleAzureFunction
      
     </strong>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 8.10 – An Azure Function project" src="img/B22218_08_10.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.10 – An Azure Function project
    
   </p>
   <p>
    
     For the next step, Visual Studio will lead us to an
    
    <strong class="bold">
     
      Additional information
     
    </strong>
    
     window, where we are asked to configure the worker, trigger, and authorization
    
    
     
      to use.
     
    
   </p>
   <div><div><img alt="Figure 8.11 – Choosing an Azure Functions trigger" src="img/B22218_08_11.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.11 – Choosing an Azure Functions trigger
    
   </p>
   <p>
    
     Let’s
    
    <a id="_idIndexMarker533">
    </a>
    
     explore
    
    <a id="_idIndexMarker534">
    </a>
    
     and understand the different trigger options offered by
    
    
     
      Azure Functions:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Http trigger
      
     </strong>
     
      : Allows you to create an HTTP endpoint that can be called to execute the function.
     
     
      This is useful for creating
     
     
      
       RESTful APIs.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Http trigger with OpenAPI
      
     </strong>
     
      : Similar to the HTTP trigger but includes built-in support for OpenAPI (formerly Swagger), making it easier to design and
     
     
      
       document APIs.
      
     
    </li>
    <li>
     <strong class="bold">
      
       IoT Hub trigger
      
     </strong>
     
      : Enables functions to respond to events sent to an IoT Hub event stream.
     
     
      Useful for processing telemetry data from
     
     
      
       IoT devices.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Kafka output
      
     </strong>
     
      : Writes a message to a Kafka topic.
     
     
      This is used when you want to publish messages to a Kafka topic from an
     
     
      
       Azure Functions.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Kafka trigger
      
     </strong>
     
      : Consumes messages from a Kafka topic.
     
     
      This is useful for processing incoming messages from Kafka topics within an
     
     
      
       Azure Function.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Queue trigger
      
     </strong>
     
      : Executes a function whenever a new message is added to an Azure Queue Storage queue.
     
     
      Ideal for processing
     
     
      
       queued tasks.
      
     
    </li>
    <li>
     <strong class="bold">
      
       RabbitMQ trigger
      
     </strong>
     
      : Consumes messages from a RabbitMQ queue.
     
     
      This is useful for integrating with
     
     
      
       RabbitMQ-based applications.
      
     
    </li>
    <li>
     <strong class="bold">
      
       SendGrid
      
     </strong>
     
      : Allows
     
     <a id="_idIndexMarker535">
     </a>
     
      you to send emails
     
     <a id="_idIndexMarker536">
     </a>
     
      directly from an Azure Function using SendGrid’s email service.
     
     
      This is particularly useful for sending notifications or alerts
     
     
      
       via email.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Service Bus Queue trigger
      
     </strong>
     
      : Responds to messages from a Service Bus queue.
     
     
      This is ideal for processing
     
     
      
       messages asynchronously.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Service Bus Topic trigger
      
     </strong>
     
      : Responds to messages published to a Service Bus topic.
     
     
      This is useful for implementing
     
     
      
       pub/sub patterns.
      
     
    </li>
    <li>
     <strong class="bold">
      
       SignalR
      
     </strong>
     
      : Enables running real-time messaging web apps in a serverless environment.
     
     
      It’s great for scenarios requiring real-time updates
     
     
      
       to clients.
      
     
    </li>
    <li>
     <strong class="bold">
      
       SQL input binding
      
     </strong>
     
      : Retrieves data from a SQL database and passes it to a function’s input parameters.
     
     
      This is useful for querying databases and processing
     
     
      
       the results.
      
     
    </li>
    <li>
     <strong class="bold">
      
       SQL output binding
      
     </strong>
     
      : Writes data to a SQL database.
     
     
      This is useful for updating databases based on a function’s
     
     
      
       execution logic.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Timer trigger
      
     </strong>
     
      : Runs a function on a schedule, such as every minute, hour, or day.
     
     
      This is perfect for periodic tasks such as backups
     
     
      
       or reports.
      
     
    </li>
   </ul>
   <p>
    
     Once we have chosen the function type, we have to select the level of authorization to rule our Azure Function.
    
    
     The three types are
    
    
     
      as follows:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Function
      
     </strong>
     
      : This level restricts access to only those users who have been granted specific permissions to invoke a function.
     
     
      It’s typically used when we want to control access to our function more granularly than what’s provided by the other
     
     
      
       two levels.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Anonymous
      
     </strong>
     
      : This level allows any client (authenticated or not) to call a function without needing to provide credentials.
     
     
      It’s useful for public APIs or functions that don’t
     
     
      
       require authentication.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Admin
      
     </strong>
     
      : This level grants full administrative privileges to the function, allowing it to perform actions on behalf of the caller as if they were logged in as an administrator.
     
     
      It should be used cautiously due to its
     
     
      
       broad permissions.
      
     
    </li>
   </ul>
   <p>
    
     Once we
    
    <a id="_idIndexMarker537">
    </a>
    
     are
    
    <a id="_idIndexMarker538">
    </a>
    
     all set, we can develop the logic of our function, and to respond to our stakeholders, the next step is to publish it to our
    
    
     
      Azure subscription:
     
    
   </p>
   <ol>
    <li>
     
      Right-click on the project in
     
     <strong class="bold">
      
       Solution Explorer
      
     </strong>
     
      and
     
     
      
       select
      
     
     
      <strong class="bold">
       
        Publish
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Then, choose
     
     <strong class="bold">
      
       Azure
      
     </strong>
     
      as the target and click
     
     <strong class="bold">
      
       Next
      
     </strong>
     
      .
     
     
      Finally, select
     
     <strong class="bold">
      
       Azure Function App (Windows)
      
     </strong>
     
      for the
     
     
      
       specific target.
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.12 – Publishing a specific target" src="img/B22218_08_12.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.12 – Publishing a specific target
    
   </p>
   <ol>
    <li value="3">
     
      Then, we
     
     <a id="_idIndexMarker539">
     </a>
     
      need to choose a unique name for our function app to ensure that it doesn’t duplicate any existing
     
     
      
       names globally.
      
     
    </li>
    <li>
     
      Next, we’ll
     
     <a id="_idIndexMarker540">
     </a>
     
      select our Azure subscription from the available options.
     
     
      We can either pick an existing resource group or create a new one.
     
     
      For the plan type, we’ll opt for the
     
     <strong class="bold">
      
       Consumption
      
     </strong>
     
      plan to guarantee cost-effective execution based on
     
     
      
       actual usage.
      
     
    </li>
    <li>
     
      We will choose a region that is geographically close to our users or services for better performance.
     
     
      If required, we will set up a general-purpose storage account.
     
     
      We’ll also enable
     
     <strong class="bold">
      
       Application Insights
      
     </strong>
     
      to monitor and diagnose our
     
     
      
       function app.
      
     
    </li>
    <li>
     
      During deployment, we need to make sure to select the
     
     <strong class="bold">
      
       Run from package
      
     </strong>
     
      option.
     
     
      This allows our function app to execute directly from the deployment package, enhancing performance and simplifying the deployment process.
     
     
      After reviewing all our settings, we’ll click
     
     <strong class="bold">
      
       Publish
      
     </strong>
     
      to begin the deployment.
     
     
      A success message will appear once the deployment is
     
     
      
       completed successfully.
      
     
    </li>
    <li>
     
      Finally, we will go to the Azure portal and navigate to our function app to ensure that it is running correctly.
     
     
      Through the portal, we can monitor logs, test endpoints, and manage
     
     
      
       our function.
      
     
    </li>
   </ol>
   <p>
    
     As Azure is
    
    <a id="_idIndexMarker541">
    </a>
    
     part
    
    <a id="_idIndexMarker542">
    </a>
    
     of the Microsoft ecosystem, other cloud platforms can be used in our overall enterprise solution.
    
    
     Next, let’s begin to explore how we can enhance our Google Cloud Platform development with
    
    
     
      Visual Studio.
     
    
   </p>
   <h1 id="_idParaDest-137">
    <a id="_idTextAnchor137">
    </a>
    
     Exploring Google Cloud Tools for Visual Studio 2022
    
   </h1>
   <p>
    <strong class="bold">
     
      Google Cloud Platform
     
    </strong>
    
     (
    
    <strong class="bold">
     
      GCP
     
    </strong>
    
     ) is a
    
    <a id="_idIndexMarker543">
    </a>
    
     public cloud computing
    
    <a id="_idIndexMarker544">
    </a>
    
     service developed
    
    <a id="_idIndexMarker545">
    </a>
    
     by Google, offering a variety of cloud-based solutions.
    
    
     Just like other cloud platforms, these include services for computing, storage, networking, big data, machine learning, and
    
    <a id="_idIndexMarker546">
    </a>
    
     the
    
    <strong class="bold">
     
      Internet of Things
     
    </strong>
    
     (
    
    <strong class="bold">
     
      IoT
     
    </strong>
    
     ).
    
    
     GCP allows us and businesses to create and deploy applications and services using Google’s robust infrastructure, benefiting from the scalability, flexibility, and security of Google’s worldwide network.
    
    
     In this section, we will explore the GCP extension for Visual
    
    
     
      Studio 2022.
     
    
   </p>
   <p>
    
     First, we need to install the extension by going to
    
    <strong class="bold">
     
      Extension Manager
     
    </strong>
    
     through the top-bar menu (
    
    <strong class="bold">
     
      Extension
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Manage extensions…
     
    </strong>
    
     ) and searching for
    
    <strong class="source-inline">
     
      Google
     
    </strong>
    
     <strong class="source-inline">
      
       Cloud Tools
      
     </strong>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 8.13 – Extension Manager | Google Cloud Tools" src="img/B22218_08_13.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.13 – Extension Manager | Google Cloud Tools
    
   </p>
   <p>
    
     As with
    
    <a id="_idIndexMarker547">
    </a>
    
     each installation of new Visual Studio
    
    <a id="_idIndexMarker548">
    </a>
    
     extensions, we need to close our instance after we have clicked on the
    
    <strong class="bold">
     
      Install
     
    </strong>
    
     button to launch the beginning of
    
    
     
      the modification.
     
    
   </p>
   <p>
    
     Since we have installed the Google Cloud Tools extension, we can connect to our Google account to deploy our project to App Engine.
    
    
     We achieve that by launching Google Cloud Explorer through the top-bar menu (
    
    <strong class="bold">
     
      Tools
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Google Cloud Tools
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Show Google
     
    </strong>
    
     <strong class="bold">
      
       Cloud Explorer
      
     </strong>
    
    
     
      ):
     
    
   </p>
   <div><div><img alt="Figure 8.14 – Show Google Cloud Explorer" src="img/B22218_08_14.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.14 – Show Google Cloud Explorer
    
   </p>
   <p>
    
     That opens up a new window to enter the information for our valid
    
    
     
      Google account.
     
    
   </p>
   <div><div><img alt="Figure 8.15 – Add a new account" src="img/B22218_08_15.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.15 – Add a new account
    
   </p>
   <p>
    
     We now
    
    <a id="_idIndexMarker549">
    </a>
    
     have an integrated deployment
    
    <a id="_idIndexMarker550">
    </a>
    
     assistant within the extension that deploys your application to the following
    
    
     
      compatible targets:
     
    
   </p>
   <ul>
    <li>
     
      Compute Engine for
     
     
      
       ASP.NET applications
      
     
    </li>
    <li>
     
      Flexible App Engine and Google Kubernetes Engine for ASP.NET
     
     
      
       Core applications
      
     
    </li>
   </ul>
   <p>
    
     The deployment assistant automatically detects compatible targets for our project and guides us through the
    
    
     
      deployment process.
     
    
   </p>
   <p>
    
     The deployment assistant can be called by selecting
    
    <strong class="bold">
     
      Tools
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Google Cloud Tools
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Publish [PROJECT-NAME] to Google Cloud
     
    </strong>
    
     , or by right-clicking on the project node in
    
    <strong class="bold">
     
      Solution Explorer
     
    </strong>
    
     and clicking on
    
    <strong class="bold">
     
      Publish [PROJECT-NAME]
     
    </strong>
    
     <strong class="bold">
      
       to Google
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Note that the
    
    <strong class="bold">
     
      Publish [PROJECT-NAME] to Google Cloud
     
    </strong>
    
     menu item will only be enabled if the start-up project of the solution is compatible with
    
    
     
      Google Cloud.
     
    
   </p>
   <p>
    
     The
    
    <a id="_idIndexMarker551">
    </a>
    
     deployment assistant displays the
    
    <a id="_idIndexMarker552">
    </a>
    
     deployment targets on Google Cloud that are compatible with the
    
    
     
      selected project.
     
    
   </p>
   <p>
    
     If we wish to change the project, we can open Cloud Explorer by clicking on
    
    <strong class="bold">
     
      Tools
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Google Cloud Tools
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Open Cloud Explorer
     
    </strong>
    
     and select the project we want
    
    
     
      to deploy.
     
    
   </p>
   <div><div><img alt="Figure 8.16 – Choosing a product to publish" src="img/B22218_08_16.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.16 – Choosing a product to publish
    
   </p>
   <p>
    
     Note that ASP.NET 4.x applications only run on Windows VMs on Compute Engine.
    
    
     To deploy our ASP.NET 4.x application on Compute Engine, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Open the deployment assistant by clicking on
     
     <strong class="bold">
      
       Tools
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Google Cloud Tools
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Publish [PROJECT-NAME] to
      
     </strong>
     
      <strong class="bold">
       
        Google Cloud
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Select
     
     
      <strong class="bold">
       
        Compute Engine
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Select the
     
     <strong class="bold">
      
       Windows VM
      
     </strong>
     
      instance and deployment credentials.
     
     
      The
     
     <strong class="bold">
      
       Windows VM
      
     </strong>
     
      must run
     
     <strong class="bold">
      
       Internet Information Services
      
     </strong>
     
      (
     
     <strong class="bold">
      
       IIS
      
     </strong>
     
      )and
     
     <a id="_idIndexMarker553">
     </a>
     
      be able to run ASP.NET 4.x applications, such as a VM ASP.NET created by the
     
     
      
       deployment manager.
      
     
    </li>
    <li>
     
      Select the credentials for deployment.
     
     
      To create Windows credentials, click on
     
     
      <strong class="bold">
       
        Manage Credentials
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Click on
     
     <strong class="bold">
      
       Publish
      
     </strong>
     
      to create our application and deploy it to the
     
     
      
       selected VM.
      
     
    </li>
   </ol>
   <p>
    
     The
    
    <a id="_idIndexMarker554">
    </a>
    
     deployment progress is displayed in the
    
    <a id="_idIndexMarker555">
    </a>
    
     Visual Studio output window, and a progress indicator is shown in the system tray status bar of
    
    
     
      Visual Studio.
     
    
   </p>
   <p>
    
     The
    
    <a id="_idIndexMarker556">
    </a>
    
     Deployment of ASP.NET Core  applications can be run in a Docker container so that your application can be deployed in the flexible App Engine and
    
    <strong class="bold">
     
      Google Kubernetes Engine
     
    </strong>
    
     (
    
    
     <strong class="bold">
      
       GKE
      
     </strong>
    
    
     
      ) environments.
     
    
   </p>
   <p>
    
     To deploy to the flexible environment, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Open the deployment assistant by clicking on
     
     <strong class="bold">
      
       Tools
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Google Cloud Tools
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Publish [PROJECT-NAME] to
      
     </strong>
     
      <strong class="bold">
       
        Google Cloud
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Select
     
     <strong class="bold">
      
       App Engine Flex
      
     </strong>
     
      to deploy the app to
     
     
      
       App Engine.
      
     
    </li>
    <li>
     
      Enter the name of our application’s version and traffic
     
     
      
       management choice.
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.17 – Publishing AspNetCore to App Engine" src="img/B22218_08_17.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.17 – Publishing AspNetCore to App Engine
    
   </p>
   <p class="list-inset">
    
     The
    
    <a id="_idIndexMarker557">
    </a>
    
     default version name is
    
    <a id="_idIndexMarker558">
    </a>
    
     based on the current system time.
    
    
     We can specify another name.
    
    
     Note that, if we specify an existing version name, the previous version will be overwritten.
    
    
     The
    
    <strong class="bold">
     
      Promoting version
     
    </strong>
    
     checkbox allows us to choose whether this application version should receive 100% of the traffic.
    
    
     If this box is checked, the new application will receive all the traffic immediately
    
    
     
      after deployment.
     
    
   </p>
   <ol>
    <li value="4">
     
      Click on
     
     <strong class="bold">
      
       Publish
      
     </strong>
     
      to create your application and deploy it to the flexible App
     
     
      
       Engine environment.
      
     
    </li>
   </ol>
   <p>
    
     And there we go – our application is deployed, and the progress is displayed in the Visual Studio
    
    
     
      output window.
     
    
   </p>
   <p>
    
     To deploy to
    
    <strong class="bold">
     
      GKE
     
    </strong>
    
     , follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Open the deployment assistant by clicking on
     
     <strong class="bold">
      
       Tools
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Google Cloud Tools
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Publish [PROJECT-NAME] to
      
     </strong>
     
      <strong class="bold">
       
        Google Cloud
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Select
     
     <strong class="bold">
      
       Container Engine
      
     </strong>
     
      to deploy
     
     
      
       our app.
      
     
    </li>
    <li>
     
      Select a
     
     <a id="_idIndexMarker559">
     </a>
     
      cluster for deployment, and enter the deployment name of your application, its version, and the
     
     <a id="_idIndexMarker560">
     </a>
     
      number of
     
     
      
       replicated instances.
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.18 – Publishing AspNetCore to Kubernetes Engine" src="img/B22218_08_18.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.18 – Publishing AspNetCore to Kubernetes Engine
    
   </p>
   <p class="list-inset">
    
     Note the three checkboxes allowing us to fine-tune
    
    
     
      our service:
     
    
   </p>
   <ul>
    <li>
     
      The
     
     <strong class="bold">
      
       Expose a service
      
     </strong>
     
      option refers to the ability to make our application accessible
     
     <a id="_idIndexMarker561">
     </a>
     
      from outside the Kubernetes cluster.
     
     
      Essentially, it creates a Kubernetes service that exposes our application to
     
     
      
       external traffic.
      
     
    </li>
    <li>
     
      The
     
     <strong class="bold">
      
       Make service public
      
     </strong>
     
      option is closely related to
     
     <strong class="bold">
      
       Expose a service
      
     </strong>
     
      and specifically refers to making the exposed service publicly accessible on the internet.
     
     
      When
     
     <a id="_idIndexMarker562">
     </a>
     
      we choose to expose our application as a service and make it public, GKE assigns a public IP address to your service, allowing external clients to
     
     
      
       access it.
      
     
    </li>
    <li>
     
      Selecting
     
     <strong class="bold">
      
       Open site after publishing
      
     </strong>
     
      will automatically open a web browser window pointing to the URL of our newly
     
     
      
       deployed application.
      
     
    </li>
   </ul>
   <p class="list-inset">
    
     To create a cluster, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li class="upper-roman">
     
      Click on
     
     <strong class="bold">
      
       Create new cluster
      
     </strong>
     
      .
     
     
      We will be redirected to the cluster creation page in the Google
     
     
      
       Cloud console.
      
     
    </li>
    <li class="upper-roman">
     
      To display the cluster in Visual Studio, click on
     
     
      <strong class="bold">
       
        Refresh clusters
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <p class="list-inset">
    
     The deployment name is used when creating the Kubernetes deployment or, if selected, the name of the Kubernetes service that will run our application on the cluster.
    
    
     We can modify the name to make it
    
    
     
      more descriptive.
     
    
   </p>
   <p class="list-inset">
    
     Note that if we use a name that already exists, the old deployment will be updated instead of creating a new one.
    
    
     The default version name is based on the current system time.
    
    
     We can specify
    
    
     
      another name.
     
    
   </p>
   <p class="list-inset">
    
     We can choose to expose a Kubernetes service on the internet.
    
    
     By exposing a public service on the internet, we get a public IP address that we can use to access our service outside of
    
    
     
      our cluster.
     
    
   </p>
   <ol>
    <li value="4">
     
      Click
     
     
      
       on
      
     
     
      <strong class="bold">
       
        Publish
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <p>
    
     And there we go – our application is containerized in a Docker image and deployed within our container.
    
    
     If
    
    <a id="_idIndexMarker563">
    </a>
    
     our application is an exposed service, Visual Studio will wait for the service’s IP
    
    <a id="_idIndexMarker564">
    </a>
    
     address to
    
    
     
      become available.
     
    
   </p>
   <p>
    
     Now that we have seen how easy it is to deploy our applications to Google Cloud Platform gracefully with Google Cloud Tools, we will move on to the cloud platform of Amazon through the AWS Toolkit in the
    
    
     
      next section.
     
    
   </p>
   <h1 id="_idParaDest-138">
    <a id="_idTextAnchor138">
    </a>
    
     Exploring the AWS Toolkit
    
   </h1>
   <p>
    
     The
    
    <a id="_idIndexMarker565">
    </a>
    
     AWS Toolkit for Visual Studio is an extension designed to enhance the development experience for creating, testing, and deploying .NET applications on
    
    <strong class="bold">
     
      WS
     
    </strong>
    
     .
    
    
     In this section, we will explore how this extension simplifies working with AWS services within
    
    
     
      Visual Studio.
     
    
   </p>
   <p>
    
     First, we need to install the extension by going to
    
    <strong class="bold">
     
      Extension Manager
     
    </strong>
    
     through the top-bar menu (
    
    <strong class="bold">
     
      Extension
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Manage extensions…
     
    </strong>
    
     ) and searching for
    
    <strong class="source-inline">
     
      AWS Toolkit with
     
    </strong>
    
     <strong class="source-inline">
      
       Amazon Q
      
     </strong>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 8.19 – AWS Toolkit with Amazon Q" src="img/B22218_08_19.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.19 – AWS Toolkit with Amazon Q
    
   </p>
   <p>
    
     As with each installation of new Visual Studio extensions, we need to close our instance after we have clicked on the
    
    <strong class="bold">
     
      Install
     
    </strong>
    
     button to launch the begin
    
    
     
      the modification.
     
    
   </p>
   <p>
    
     Key AWS services
    
    <a id="_idIndexMarker566">
    </a>
    
     that are integrated through the toolkit include
    
    <strong class="bold">
     
      Amazon Simple Storage Service
     
    </strong>
    
     (
    
    <strong class="bold">
     
      S3
     
    </strong>
    
     ),
    
    <strong class="bold">
     
      Amazone Elastic Compute Cloud
     
    </strong>
    
     (
    
    <strong class="bold">
     
      EC2
     
    </strong>
    
     ), AWS Elastic Beanstalk, and
    
    
     
      Amazon DynamoDB.
     
    
   </p>
   <p>
    
     Once the extension
    
    <a id="_idIndexMarker567">
    </a>
    
     is installed, we can start to configure it through the top-bar menu –
    
    <strong class="bold">
     
      Extensions
     
    </strong>
    
     |
    
    <strong class="bold">
     
      AWS Toolkit
     
    </strong>
    
     |
    
    
     <strong class="bold">
      
       Getting Started
      
     </strong>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 8.20 – AWS Toolkit | Getting Started" src="img/B22218_08_20.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.20 – AWS Toolkit | Getting Started
    
   </p>
   <p>
    
     That will
    
    <a id="_idIndexMarker568">
    </a>
    
     allow us to connect to our AWS subscription to set up both of the
    
    <a id="_idIndexMarker569">
    </a>
    
     main features of the
    
    
     
      AWS Toolkit:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       AWS Explorer
      
     </strong>
     
      : A
     
     <a id="_idIndexMarker570">
     </a>
     
      central hub for navigating through AWS services, monitoring storage, and managing resources directly from
     
     
      
       Visual Studio.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Amazon Q
      
     </strong>
     
      : Represents
     
     <a id="_idIndexMarker571">
     </a>
     
      a comprehensive suite of AI-powered tools designed to facilitate better decision-making, increase productivity, and streamline operations across various domains within an organization, leveraging the power of generative AI and deep integration with
     
     
      
       AWS services.
      
     
    </li>
   </ul>
   <div><div><img alt="Figure 8.21 – AWS Getting Started" src="img/B22218_08_21.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.21 – AWS Getting Started
    
   </p>
   <p>
    
     AWS Explorer is
    
    <a id="_idIndexMarker572">
    </a>
    
     designed to provide us with a seamless way to
    
    <a id="_idIndexMarker573">
    </a>
    
     interact with various AWS services directly from our development environment.
    
    
     It acts as a bridge between the local development environment and the cloud, allowing us to perform tasks such as
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Creating and managing AWS resources
      
     </strong>
     
      : It allows us to easily create new instances on Amazon EC2, manage storage buckets in Amazon S3, and configure settings without leaving Visual Studio.
     
     
      We can now retrieve four project templates about AWS by adding a new project to
     
     
      
       our solution.
      
     
    </li>
   </ul>
   <div><div><img alt="Figure 8.22 – An AWS project template" src="img/B22218_08_22.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.22 – An AWS project template
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Deploying applications
      
     </strong>
     
      : With support for AWS Lambda, we can deploy functions and applications to our
     
     
      
       AWS subscription.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Monitoring and management
      
     </strong>
     
      : Through integration with AWS CloudFormation, we can manage infrastructure as code, ensuring consistency, repeatability, and version control over our
     
     
      
       AWS deployments.
      
     
    </li>
   </ul>
   <p>
    
     Let’s consider a scenario
    
    <a id="_idIndexMarker574">
    </a>
    
     where we want to deploy a simple serverless function using AWS Lambda with this toolset.
    
    
     Here’s how we might
    
    
     
      do it:
     
    
   </p>
   <ol>
    <li>
     <strong class="bold">
      
       Write the function locally
      
     </strong>
     
      : First, we write a.NET Core function locally, testing it thoroughly to ensure that it works
     
     
      
       as expected.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Configure the deployment settings
      
     </strong>
     
      : Using AWS Explorer, we configure the deployment settings, including selecting the appropriate runtime (.NET Core), setting up any necessary environment variables, and specifying the IAM role that will execute
     
     
      
       the function.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Deploy the function
      
     </strong>
     
      : With just a few clicks or commands, we deploy the function to AWS Lambda.
     
     
      The AWS Explorer handles the packaging of the function code, uploading it to AWS, and configuring the necessary triggers or
     
     
      
       event sources.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Monitor and manage
      
     </strong>
     
      : Post-deployment, we can use the AWS Explorer to monitor the function’s performance, view logs, and make updates or changes as needed, all from within our
     
     
      
       development environment.
      
     
    </li>
   </ol>
   <p>
    
     This example illustrates
    
    <a id="_idIndexMarker575">
    </a>
    
     how the AWS Explorer integrates with AWS services to simplify the development life cycle for .NET Core applications on AWS, providing a unified interface to create, deploy, and manage
    
    
     
      cloud resources.
     
    
   </p>
   <h1 id="_idParaDest-139">
    <a id="_idTextAnchor139">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we explored the advanced aspects of cloud integration and services using Visual Studio 2022.
    
    
     Emphasizing the importance of cloud computing in modern application development, we provided a detailed guide on leveraging Visual Studio’s powerful tools and extensions to build and manage cloud-based applications directly through
    
    
     
      the IDE.
     
    
   </p>
   <p>
    
     As we conclude this chapter, we mark the end of the second part of our journey in mastering core development skills.
    
    
     From advanced web development to multi-platform, machine learning, and now the advanced cloud, we have covered how Visual Studio enhances our
    
    
     
      cutting-edge development.
     
    
   </p>
   <p>
    
     In the upcoming chapter, we’ll continue to expand our horizons, delving into the world of DevOps, starting by handling advanced Git Workflow directly within
    
    
     
      Visual Studio.
     
    
   </p>
  </div>
 

  <div><h1 id="_idParaDest-140" lang="en-US" xml:lang="en-US">
    <a id="_idTextAnchor140">
    </a>
    
     Part 3: Streamlining Collaborative Development with DevOps Practices
    
   </h1>
   <p>
    
     In this third part, we focus on how Visual Studio streamlines modern DevOps workflows.
    
    
     You’ll explore how Visual Studio simplifies advanced Git workflows, automates continuous integration with GitHub Actions, and facilitates seamless collaboration through Azure DevOps.
    
    
     Additionally, you’ll leverage Visual Studio’s container tools for Docker, empowering you to optimize development, testing, and deployment within a unified
    
    
     
      DevOps environment.
     
    
   </p>
   <p>
    
     This part has the
    
    
     
      following chapters:
     
    
   </p>
   <ul>
    <li>
     <a href="B22218_09.xhtml#_idTextAnchor141">
      <em class="italic">
       
        Chapter 9
       
      </em>
     </a>
     
      ,
     
     <em class="italic">
      
       Handling Advanced Git Workflows
      
     </em>
    </li>
    <li>
     <a href="B22218_10.xhtml#_idTextAnchor152">
      <em class="italic">
       
        Chapter 10
       
      </em>
     </a>
     
      ,
     
     <em class="italic">
      
       Continuous Integration with GitHub Actions
      
     </em>
    </li>
    <li>
     <a href="B22218_11.xhtml#_idTextAnchor159">
      <em class="italic">
       
        Chapter 11
       
      </em>
     </a>
     
      ,
     
     <em class="italic">
      
       Collaborative Development with Azure DevOps
      
     </em>
    </li>
    <li>
     <a href="B22218_12.xhtml#_idTextAnchor169">
      <em class="italic">
       
        Chapter 12
       
      </em>
     </a>
     
      ,
     
     <em class="italic">
      
       Visual Studio Container Tools for Docker
      
     </em>
    </li>
   </ul>
  </div>
  <div><div></div>
  </div>
 </body></html>