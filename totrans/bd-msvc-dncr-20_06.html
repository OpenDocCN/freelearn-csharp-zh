<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Securing Microservices</h1>
                </header>
            
            <article>
                
<p><span class="md-line md-end-block md-focus"><span class="md-expand">Security is one of the most important cross-cutting concerns for web applications. Unfortunately, data breaches of well-known sites seem commonplace these days. Taking this into account, information and application security has become critical to web applications. For the same reason, secure applications should no longer be an afterthought. Security is everyone's responsibility in an organization.</span></span></p>
<p><span>Monolithic applications have less surface area when compared to microservices, however, microservices are distributed systems by nature. Also, in principle, microservices are isolated from each other; hence, well-implemented microservices are more secure as compared to monolithic applications. A monolith has different attack vectors compared to microservices. The microservice architecture style forces us to think differently in the context of security. However, let me tell you upfront, microservice security is a complex domain to understand and implement.</span></p>
<p><span class="md-line md-end-block"><span>Before we dive </span></span><span>deep </span><span>into microservice security, let's understand our approach toward it. We will be focusing more on how authentication and authorization (collectively referred to as</span> <strong>auth</strong><span> in the chapter henceforth) work and the options available within the .NET ecosystem.</span></p>
<p><span>We will explore Azure API management and its suitability as an API gateway</span> for .<span>NET-based microservice environments; we'll also see how Azure API management can help us protect microservices through its security features. Then, we'll briefly touch base with different, peripheral aspects that have </span><em>defense in depth</em><span> mechanisms for microservice security. We will also discuss the following topic</span>s:</p>
<ul>
<li>Why are form authentication and older techniques not sufficient?</li>
<li>Authentication and the available options, including OpenID and Azure Active Directory</li>
<li>Introducing OAuth 2.0</li>
<li>Introducing Azure API management as an API gateway</li>
<li>Using Azure API management for security</li>
<li>Interservice communication security approaches</li>
<li>Container security and other peripheral security aspects</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Security in monolithic applications</h1>
                </header>
            
            <article>
                
<p><span class="md-line md-end-block"><span>To understand microservice security, let's step back and recall how we used to secure .NET monolithic applications. This will help us better grasp why a microservice's auth mechanism needs to be different.</span></span></p>
<p><span class="md-line md-end-block"><span>The critical mechanism to secure applications has always been auth. Authentication verifies the</span> <span class=""><em>identity</em></span> <span>of a user. Authorization manages what a user can or cannot access, also known as</span> <span class=""><em>permissions</em></span><span>. Encryption, well, that's the mechanism that helps you protect data as it passes between the client and server. We're not going to discuss encryption too much though, just ensure the data that goes over the wire is encrypted everywhere. This can be achieved through the use of the HTTPS protocol.</span></span></p>
<p><span class="md-line md-end-block"><span>The following diagram depicts the flow of a typical auth mechanism in .NET monoliths:</span></span></p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="294" src="assets/32f49f3e-6ee8-46b2-bab1-522df1864c8b.png" width="527"/></div>
<p><span class="md-line md-end-block"><span>In the preceding diagram, we can see that the user enters his or her username and password typically through a web browser. Then, this request hits some thin layer in a web application that is responsible for auth. This layer or component connects to the user credential store, typically an SQL server in the case of a .NET application. The auth layer verifies user-supplied credentials against the username and password stored in the credential store.</span></span></p>
<p><span class="md-line md-end-block"><span>Once the user credentials are verified for the session, a session cookie gets created in the browser. Unless the user has a valid session cookie, he cannot access the app. Typically, a session cookie is sent with every request. Within these kinds of monolithic applications, modules can freely interact with each other since they are in the same process and have in-memory access. This means trust is implicit within those application modules so they do not need separate validation and verification of requests while talking to each other.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Security in microservices</h1>
                </header>
            
            <article>
                
<p><span class="md-line md-end-block"><span>Now let's look at the case of microservices. By nature, microservices are distributed systems. There is not a single instance of an application; rather, there are several distinct applications that coordinate with each other in harmony to produce the desired output.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why won't a traditional .NET auth mechanism work?</h1>
                </header>
            
            <article>
                
<p><span class="md-line md-end-block"><span>One of the possible approaches for microservice security might be this: we mimic the same behavior as that of the auth layer in a monolith. This could be depicted as follows:</span></span></p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="233" src="assets/9605f3e4-dac1-41d9-ac5a-f72ffbd955ae.png" width="575"/></div>
<p><span class="md-line md-end-block"><span>In this approach, we distributed the auth layer and provided it to all the microservices. Since each one is a different application, it will need its own auth mechanism. This inherently means that the user credential store is also different for every microservice. This raises so many questions, such as how do we keep the auth in sync across all services? How can we validate inter-service communication, or do we skip it? We do not have satisfactory answers to these questions. Hence, this approach does not make sense and just increases complexity. With this approach, we cannot even be sure whether it will work in the real world.</span></span></p>
<p><span class="md-line md-end-block">There is one more factor we need to take into account for modern applications. In the microservice world, we need to support native mobile apps and other non-standard form factor devices as well as IoT applications. With the significant proliferation of native mobile applications, the microservice architecture also needs to support secure communication between those clients and microservices. This is different from the traditional web browser-based user interface. On mobile platforms, a web browser is not part of any native mobile app. This means cookie-based or session-based authentication is not possible. So microservices need to support this kind of interoperability between client applications. This was never a concern for .NET monolithic applications.</span></p>
<p><span class="md-line md-end-block"><span>In the case of traditional authentication, the browser is responsible for sending the cookie upon each request. But we're not using the browser for a native mobile app. In fact, we're neither using ASPX pages, nor the form's authentication module. For an iOS client or Android, it's something different altogether. What's more, we are also trying to restrict unauthorized access to our API. In the preceding example, we'd be securing the client, be it an MVC app or a Windows phone app, and not the microservice. Moreover, all these mobile client devices are not part of the trust subsystem. For every request, we cannot trust that the mobile user is indeed the owner; the communication channel is not secured either. So any request coming from them cannot be trusted at all.</span></span></p>
<p><span class="md-line md-end-block"><span>But apart from these problems, there's another more conceptual problem we have. Why should the application be responsible for authenticating users and authorization? Shouldn't this be separated out?</span></span></p>
<p><span class="md-line md-end-block"><span>One more solution to this is using the SAML protocol, but again, this is based on SOAP and XML, so not really a good fit for microservices. The complexity of the implementation of SAML is also high.</span></span></p>
<p><span class="md-line md-end-block"><span>Therefore, it is evident from the preceding discussion that we need a token-based solution. The solution for microservices' auth comes in the form of OpenID Connect and OAuth 2.0. OpenID Connect is the standard for authentication and OAuth 2.0 is the specification for the authorization. However, this authorization is delegated by nature.</span></span></p>
<p><span class="md-line md-end-block"><span>We will see this in detail in further sections. But before that, let's take a detour and look at JSON Web Tokens and see why they are significant with respect to microservice security.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JSON Web Tokens</h1>
                </header>
            
            <article>
                
<p><span class="md-line md-end-block"><span><strong>JSON Web Tokens</strong> (<strong>JWT</strong>) is pronounced <em>JOT</em>. It </span></span><span class="md-line md-end-block"><span>is a well-defined JSON schema or format to describe the tokens involved in a data exchange process. JWTs are described in <em>RFC 7519</em>.</span></span></p>
<p><span class="md-line md-end-block"><span>JWTs are not tied to either OpenID Connect or OAuth 2.0. This means they can be used independently, irrespective of OAuth 2.0 or OpenID Connect. OpenID Connect mandates the use of a JWT for all the tokens that are exchanged in the process. In OAuth 2.0, the use of JWTs isn't mandated, more a kind of implementation format. Moreover, the .NET framework has built-in support for JWT.</span></span></p>
<p><span class="md-line md-end-block"><span>The purpose of a JWT-based security token is to produce a data structure that contains information about the issuer and the recipient along with a description of the sender's identity. Therefore, tokens should be protected over the wire so they cannot be tampered with. To do so, tokens are signed with symmetric or asymmetric keys. This means when a receiver trusts the issuer of the token, it can also trust the information inside it.</span></span></p>
<p><span class="md-line md-end-block"><span>Here is an example of a JWT:</span></span></p>
<div class="CodeMirror cm-s-inner CodeMirror-wrap">
<div class="CodeMirror-scroll">
<div class="CodeMirror-sizer">
<div>
<div class="CodeMirror-lines">
<div>
<div class="CodeMirror-code">
<div class="CodeMirror-activeline">
<pre><span>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span></pre></div>
</div>
</div>
</div>
</div>
</div>
<p>This is the encoded form of a JWT. If we see the same token in decoded form, it has three components: header, payload, and signature; they are all separated by a period (.). The preceding example token can be decoded as follows:</p>
</div>
</div>
<pre><span class="md-line md-end-block"><span class=""><strong><span>Header</span></strong></span><span>: </span></span>{"alg": "HS256", "type": "JWT"}<br/><span class="md-line md-end-block"><span class=""><strong><span>Payload</span></strong></span><span>: </span></span>{"sub": "1234567890","name": "John Doe","admin": true}<br/><span class="md-line md-end-block"><span class=""><strong><span>Signature</span></strong></span><span>:H</span></span>MACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload),secret)</pre>
<p>NET v.4.5.1 and onward has built-in support for generating and consuming JWTs. You can install JWT support in any .NET application using the package manager console with the following command:</p>
<pre><strong>Install-Package System.IdentityModel.Tokens.Jwt</strong></pre>
<div class="packt_infobox">Visit <a href="https://jwt.io/">https://jwt.io/</a>, where you can view and decode JWTs very easily. Moreover, you can add it as part of the Chrome debugger as well, which is quite handy.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is OAuth 2.0?</h1>
                </header>
            
            <article>
                
<p><span class="md-line md-end-block"><span>Okay, you might not know what OAuth 2.0 is, but you will have surely used it for several websites. </span></span><span class="md-line md-end-block"><span>Nowadays, many websites allow you to log in with your username and password for Facebook, Twitter, or Google accounts. Go to your favorite website, for example, the </span><span><a href="http://www.stackoverflow.com">www.stackoverflow.com</a></span> <span>login page. There is a login button that says you can sign in with your Google account, for example. When you click on the <span class="packt_screen">Google</span> button, it takes you to Google's login page along with some of the permissions mentioned. Here you provide your Google username and password and click on the <span class="packt_screen">Allow</span> button to grant permissions to your favorite site. Then, Google redirects you to Stack Overflow and you are logged in with appropriate permissions in Stack Overflow. This is merely the end user experience for OAuth 2.0 and OpenID Connect.</span></span></p>
<p><span class="md-line md-end-block"><span>OAuth 2.0 can be best described as a series of specification-turned-authorization frameworks. <em>RFC 6749</em> defines OAuth as follows:</span></span></p>
<div class="packt_quote"><span class="md-line md-end-block"><span>"The OAuth 2.0 authorization framework enables a third-party application to obtain limited access to an HTTP service, either on behalf of a resource owner by orchestrating an approval interaction between the resource owner and the HTTP service, or by allowing the third-party application to obtain access on its own behalf."</span></span></div>
<p><span class="md-line md-end-block"><span>OAuth 2.0 handles authorization on the web, in native mobile applications, and all headless server applications (these are nothing more than microservice instances in our context). You must be wondering why we are discussing authorization first instead of authentication. The reason is that OAuth 2.0 is a delegated authorization framework. This means, to complete the authorization flow, it relies on an authentication mechanism.</span></span></p>
<p><span class="md-line md-end-block"><span>Now let's see some terminology associated with it.</span></span></p>
<p><span class="md-line md-end-block"><span>OAuth 2.0 roles describe the involved parties in the authorization process:</span></span></p>
<ul>
<li>Resource: The entity that is getting protected from unintended access and usage. This is nothing more than a microservice in our case.</li>
<li>Resource owner: Resource owner is a person or entity who owns the specified resource. When a person owns a resource, he or she is an end user.</li>
<li>Client: Client is the term used to refer to all kinds of client applications. This refers to any application trying to access the protected resource. In a microservices' context, the applications involved are single page applications, web user interface clients, and native mobile applications, or even a microservice that is trying to access another microservice downstream.</li>
<li>Authorization server: This is the server that hosts the secure token service and issues tokens to the client after successfully authenticating the resource owner and obtaining permissions from the resource owner or on their behalf.</li>
</ul>
<ol start="4"/>
<p><span class="md-line md-end-block"><span>You may have noticed that OAuth does differentiate between end users and applications used by an end user. This is a bit odd but makes perfect sense since it is also generally viewed as saying, <em>I am authorizing this app to perform these actions on my behalf</em></span></span>.</p>
<p><span class="md-line md-end-block"><span>The following diagram depicts how these roles interact with each other in the general flow of authorization in the OAuth framework:</span></span></p>
<div class="CDPAlignCenter CDPAlign"><img height="442" src="assets/e58404a3-3107-4236-ba49-b9e8dda72c70.png" width="591"/></div>
<p><span class="md-line md-end-block"><span>In <em>step 6</em>, illustrated in the preceding diagram, the client passes the authorization grant to the authorization server. This step is not as simple as it looks. Authorization grants are of different types. The grant types represent four, different possible use cases for getting access tokens in OAuth 2.0. If you choose the wrong grant type, you might be compromising security:</span></span></p>
<ul>
<li><span class="md-line md-end-block"><span class="">Authorization code</span><span>: This is the typical OAuth grant used by server-side web applications, the one you would use in your ASP.NET apps.</span></span></li>
<li><span class="md-line md-end-block"><span class="md-line md-end-block"><span class="">Implicit</span><span>: Authenticating with a server returns an access token to the browser, which can then be used to access resources. This is useful for single page applications where communication cannot be private.</span></span></span></li>
<li><span class="md-line md-end-block"><span class="">Resource owner password credentials</span><span>: This requires the user to directly enter their username and password in the application. It is useful when you are developing a first-party application to authenticate with your own servers. For example, a mobile app might use a resource owner grant to authenticate with your own servers.</span></span></li>
<li><span class="md-line md-end-block"><span class="">Client credentials</span><span>: This is typically used when the client is acting on its own behalf (the client is also the resource owner) or is requesting access to protected resources based on an authorization previously arranged with the authorization server.</span></span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is OpenID Connect?</h1>
                </header>
            
            <article>
                
<p><span class="md-line md-end-block"><span>OpenID Connect 1.0 is a simple identity layer on top of the OAuth 2.0 protocol. OpenID Connect is all about authentication. It allows clients to verify end users based on the authentication performed by an authorization server. It is also used to obtain basic profile information about the end user in an interoperable and REST-like manner.</span></span></p>
<p><span class="md-line md-end-block"><span>So OpenID Connect allows clients of all types—web-based, mobile, and JavaScript—to request and receive information about authenticated sessions and end users. We know that OAuth 2.0 defines access tokens. Well, OpenID Connect defines a standardized identity token (commonly referred to as <strong>ID token</strong>). The identity token is sent to the application so the application can validate who the user is. It defines an endpoint to get identity information for that user, such as their name or email address. That's the user info endpoint.</span></span></p>
<p><span class="md-line md-end-block"><span>It's built on top of OAuth 2.0, so the flows are the same. It can be used with the authorization code grant and implicit grant. It's not possible with the client credentials grant, as the client credentials grant is for server-to-server communication.</span></span></p>
<p><span class="md-line md-end-block"><span>There's no end user involved in the process so there's no end user identity either. Likewise, it doesn't make sense for the resource owner path of usage or process. Now how does that work? Well, instead of only requesting an access token, we'll request an additional ID token from the <strong>security token service</strong></span></span> (<span class="md-line md-end-block"><span><strong>STS</strong></span></span>) <span class="md-line md-end-block"><span>that implements the OpenID Connect specification. The client receives an ID token, and usually, also an access token. To get more information for the authenticated user, the client can then send a request to the user info endpoint with the access token; this user info endpoint will then return the claims about the new user.</span></span></p>
<p><span class="md-line md-end-block"><span>OpenID supports authorization code flow and implicit flow. It also adds some more additional protocols, which are discovery and dynamic registration.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Azure Active Directory</h1>
                </header>
            
            <article>
                
<p><span class="md-line md-end-block"><span>There are multiple providers for OAuth 2.0 and OpenID Connect 1.0 specifications. <strong>Azure Active Directory</strong></span></span> (<span class="md-line md-end-block"><span><strong>Azure AD</strong></span></span>) <span class="md-line md-end-block"><span>is one of them. Azure AD provides organizations with enterprise-grade identity management for cloud applications. Azure AD integration will give your users a streamlined sign-in experience, and it will help your application conform to the IT policy. Azure AD provides advanced security features, such as multifactor authentication, and scales really well with application growth. It is used in all Microsoft Azure Cloud products, including Office 365, and processes more than a billion sign-ins per day.</span></span></p>
<p><span class="md-line md-end-block"><span>One more interesting aspect of traditional .NET environments is that they can integrate their organizational Windows Server Active Directory with Azure AD really well. This can be done with the Azure AD sync tool or the new capability of pass-through authentication. So, organizational IT compliances will still be managed.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Microservice Auth example with OpenID Connect, OAuth 2.0, and Azure AD</h1>
                </header>
            
            <article>
                
<p><span class="md-line md-end-block"><span>Now we are well-equipped with all the prerequisite knowledge to start coding. Let's try and build a <kbd>ToDoList</kbd> application. We are going to secure <kbd>TodoListService</kbd>, which represents one of our microservices. In the solution, the <kbd>ToDoList</kbd> microservice is represented by the <kbd>TodoListService</kbd> project and <kbd>ToDoListWebApp</kbd> represents the server-side web application. It will be easier to follow if you open up the Visual Studio solution named <kbd>OpenIdOAuthAzureAD.sln</kbd> provided with this chapter. This example uses the client credentials grant.</span></span></p>
<p><span class="md-line md-end-block"><span>Note that, due to the ever-changing nature of Azure portal and the corresponding Azure services UI, it is advisable that you use the Azure Service management API and automate some of the registration tasks about to follow. However, for learning purposes and largely for encouraging developers who are new to Azure or might be trying Azure AD for the first time, we are going to follow the Azure portal user interface.</span></span></p>
<p><span class="md-line md-end-block"><span class="">Here are the prerequisites:</span></span></p>
<ul class="ol-list">
<li>Visual Studio 2017 Update 3</li>
<li>An Azure subscription (if you don't have this, you can use the free trial account for this demo)</li>
<li><span class="md-line md-end-block"><span>Azure AD tenant (single-tenant): You can also work with your Azure account's own default directory, which should be different from that of the Microsoft organization</span></span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Registration of TodoListService and TodoListWebApp with Azure AD tenant</h1>
                </header>
            
            <article>
                
<p><span>Now let's look at how to register <kbd>TodoListService</kbd>.</span></p>
<p>In this step, we will add <kbd>TodoListService</kbd> with Azure AD tenant. To achieve this, log in to the Azure management portal, then do the following:</p>
<ol>
<li><span class="md-line md-end-block">Click on <span class="packt_screen">App registrations</span>. Click on the <span class="packt_screen">Add</span> button. It will open the <span class="packt_screen">Create</span> pane, as depicted here:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/64a8579c-88d4-4915-ba87-4fa8380a541c.png"/></div>
<ol start="2">
<li>Provide all the mandatory details as displayed in the preceding screenshot and click on the <span class="packt_screen">C</span><span class="packt_screen">reate</span> button at the bottom of the <span class="packt_screen">Create</span> pane. While we are providing a sign-on URL, make sure that you are providing it for your app. In our case, <kbd>TodoListService</kbd> is a microservice, so we won't have a special sign-in URL. Hence, we have to provide the default URL or just the hostname of our microservice. Here we are going to run the service from our machine, so the localhost URL will be sufficient. You can find the sign-in URL once you right-click on project URL under <kbd>TodoListService</kbd> project and navigate to <span class="packt_screen">Web</span>, as shown in the following diagram:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="245" src="assets/c17fcbdb-a832-45a4-a51a-0be9d55c28c7.png" width="418"/></div>
<div class="packt_tip">A sign-in URL in Azure portal should have the trailing <kbd>/</kbd>; otherwise, you may face an error, even if you execute all the steps correctly.</div>
<ol start="3">
<li>If you deploy your service with the Microsoft Azure App Service plan, you will get a URL that is similar to <kbd>https://todolistservice-xyz.azurewebsites.net/</kbd>. You can later change the sign-on URL if you deploy the service on Azure.</li>
<li><span class="md-line md-end-block"><span>Once you click on the <span class="packt_screen">Create</span> button, Azure will add the application to your Azure AD Tenant. However, there are still a few more details that need to be completed for finishing the registration of TodoListService. So navigate to <span class="packt_screen">App Registration</span></span></span> | <span class="md-line md-end-block"><span class="md-line md-end-block"><span class="md-line md-end-block"><span><span class="packt_screen">TodoListService</span> | <span class="packt_screen">Properties</span>. You will notice that there are a few more additional properties, such as <span class="packt_screen">App ID URL</span>, which has been provided now.</span></span></span></span></li>
</ol>
<ol start="5">
<li><span class="md-line md-end-block"><span>For the <span class="packt_screen">App ID URL</span>, enter </span></span><a href="https://%5BYour_Tenant_Name%5D/TodoListService"><kbd>https://[Your_Tenant_Name]/TodoListService</kbd></a><span class="md-line md-end-block"><span>, replacing <kbd>[Your_Tenant_Name]</kbd></span><span> with the name of your Azure AD tenant. Click on <span class="packt_screen">OK</span> to complete the registration. The final configuration should look like this: </span></span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/084b7590-c707-4eb9-a75c-898ae12cf8b9.png"/></div>
<p><span>Now we move on to the registration of <span class="packt_screen">TodoListWebApp:</span></span></p>
<ol start="1">
<li><span class="md-line md-end-block"><span>First, we register <span class="packt_screen">TodoListWebApp</span>. This is necessary since we are going to use OpenID Connect to connect to this browser-based web application. So we need to establish the trust between the end user, that is, us and <span class="packt_screen">TodoListWebApp</span>.</span></span></li>
<li><span class="md-line md-end-block"><span>Click on <span class="packt_screen">App registrations</span>. Click on the <span class="packt_screen">Add</span> button. It will open up the <span class="packt_screen">Create</span> pane, as depicted in the following screenshot. Fill in the sign-in URL as </span></span><kbd>https://localhost:44322/</kbd>.</li>
</ol>
<p> </p>
<ol start="3">
<li>Once again, as in the <span class="packt_screen">TodoListService </span> registration, we will be able to view most of the additional properties once we create the web app. So, the final properties configuration will look like this:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="518" src="assets/4a21493b-5c13-4e8c-b04b-cb687e1f607b.png" width="730"/></div>
<ol start="4">
<li>A setting to note here is the logout URL: we set it as <kbd>https://localhost:44322/Account/EndSession</kbd>.<br/>
This is because after ending the session, Azure AD will redirect the user to this URL. For the <span class="packt_screen">App ID URL</span>, enter <kbd>https://[Your_AD_Tenant_Name]/TodoListWebApp</kbd>, replacing [<kbd>Your_AD_Tenant_Name</kbd>] with the name of your Azure AD tenant. Click on <span class="packt_screen">OK</span> to complete the registration. </li>
</ol>
<p> </p>
<ol start="5">
<li>Now we need to set up permissions between <span class="packt_screen">TodoListWebApp</span> so that it can call our microservice: <span class="packt_screen">TodoListService</span>. So, navigate to <span class="packt_screen">App Registration</span> | <span class="packt_screen">TodoListWebApp</span> | <span class="packt_screen">Required Permissions</span> again and click on <span class="packt_screen">Add</span>. Now click on <span class="packt_screen">1 Select an API</span>. This navigation is displayed in the following screenshot. You need to key in <span class="packt_screen">ToDoListService</span> for it to show up in the API pane:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/46044531-310c-4a25-aa0d-29b222d2bf12.png"/></div>
<ol start="6">
<li>Now you will be able to view the <span class="packt_screen">Enable Access</span> pane, where you have to tick for <span class="packt_screen">Access</span> <span class="packt_screen">TodoListService</span> <span class="packt_screen">Permissions</span> under the <span class="packt_screen">Delegated Permissions</span>, and <span class="packt_screen">Done</span> under the <span class="packt_screen">Add API</span> access pane. This will save the permissions.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generation of AppKey for TodoListWebApp</h1>
                </header>
            
            <article>
                
<p><span class="md-line md-end-block"><span>Another important step for registration is adding </span><kbd><span>client_secret</span></kbd></span>,<span class="md-line md-end-block"><span> which is necessary to establish trust between Azure AD and <span class="packt_screen">TodoListWebApp</span>. This <kbd>client_secret</kbd> is generated only once and configured in the web application. To generate this key, navigate to <span class="packt_screen">App Registrations | </span><span class="packt_screen">TodoListWebApp |</span> <span class="packt_screen"><span class="packt_screen">K</span>eys</span>. Then, add the description as <kbd>AppKey</kbd> and click on <span class="packt_screen">Save</span>. Once the key is saved, the value of the key is autogenerated by Azure and will be displayed next to the description. This key is displayed only once, so you have to</span></span> immediately <span class="md-line md-end-block"><span>copy it and save it for later use. We will be keeping this key in the <kbd>web.config</kbd> file of <span class="packt_screen">TodoListWebApp</span> in this case.</span></span></p>
<p>The key stored will be displayed on the Azure portal as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a983ea10-4845-4d3d-809f-d39af7965390.png"/></div>
<div class="packt_infobox"><span class="md-line md-end-block"><span>For production-grade applications, it is a bad idea to keep <kbd>client_Secret</kbd> and all such critical key values in <kbd>web.config</kbd>. It is good practice to keep them encrypted and isolated from applications. For such purposes, in production-grade applications, you can use Azure key-vault (</span><span><a href="https://azure.microsoft.com/en-us/services/key-vault/">https://azure.microsoft.com/en-us/services/key-vault/</a></span><span>) to keep all your keys protected. Another advantage of a key vault is that you can manage the keys according to the environment, such as dev-test-staging and production.</span></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring Visual Studio solution projects</h1>
                </header>
            
            <article>
                
<p><span>First, we look at how to configure this with the</span> <kbd>TodoListService</kbd> <span>project.</span></p>
<p><span class="md-line md-end-block"><span>Open the <kbd>web.config</kbd> file and replace the following keys:</span></span></p>
<ol>
<li><span class="md-line md-end-block"><span>Search for the <kbd>ida:Tenant</kbd> </span><span>key. Replace its value with your AD tenant name, for example, <kbd>contoso.onmicrosoft.com</kbd></span><span>. This will also be part of any of the application's <span class="packt_screen">APP ID URL</span>.</span></span></li>
<li><span class="md-line md-end-block"><span>Replace the <kbd>ida:Audience </kbd></span></span> <span class="md-line md-end-block"><span>key. Replace its value with <kbd>https://[Your_AD_Tenant_Name]/TodoListService</kbd></span></span>.<span class="md-line md-end-block"><span><br/></span> <span>Replace <kbd>[Your_AD_Tenant_Name]</kbd></span><span> with the name of your Azure AD tenant.</span></span></li>
</ol>
<p><span>Now let's see how to configure this with the</span> <kbd>TodoListWebApp</kbd> <span>project.</span></p>
<p><span class="md-line md-end-block"><span>Open the <kbd>web.config</kbd> file and find and replace the following keys with the provided values:</span></span></p>
<ol>
<li><span class="md-line md-end-block"><span>Replace </span></span><kbd>todo:TodoListResourceid</kbd> <span class="md-line md-end-block"><span>with </span></span><kbd>https://[Your_Tenant_Name]/TodoListService</kbd>.</li>
<li><span class="md-line md-end-block"><span>Replace <kbd>todo:TodoListBaseAddress</kbd></span></span> <span class="md-line md-end-block"><span>with </span></span><kbd>https://localhost:44321/</kbd>.</li>
<li><span class="md-line md-end-block"><span>Replace </span></span><kbd>ida:ClientId</kbd> <span class="md-line md-end-block"><span>with the application ID of <span class="packt_screen">ToDoListWebApp</span>. You can get it by navigating to <span class="packt_screen">App Registration</span> | <span class="packt_screen">TodoListWebApp</span>.</span></span></li>
<li><span class="md-line md-end-block"><span>Replace </span></span><kbd>ida:AppKey</kbd> <span class="md-line md-end-block"><span>with </span></span><kbd>client_secret</kbd> <span class="md-line md-end-block"><span>that we generated in step 2 of the process of registering <span class="packt_screen">TodoListWebApp</span>.</span><span> If you missed noting this key, you need to delete the previous key and generate a new key.</span></span></li>
<li><span class="md-line md-end-block"><span>Replace </span></span><kbd>ida:Tenant</kbd> <span class="md-line md-end-block"><span>with your AD tenant name, for example, </span></span><kbd>contoso.onmicrosoft.com</kbd>.</li>
<li><span class="md-line md-end-block"><span>Replace </span></span><kbd>ida:RedirectUri</kbd> <span class="md-line md-end-block"><span>with the URL you want the application to redirect to when the user signs out of TodoListWebApp. In our case, the default is </span></span><kbd>https://localhost:44322/</kbd> <span class="md-line md-end-block"><span>since we want the user to navigate to the home page of the application.</span></span></li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generate client certificates on IIS Express</h1>
                </header>
            
            <article>
                
<p><span class="md-line md-end-block"><span>Now <kbd>TodoListService</kbd> and <kbd>TodoListWebApp</kbd> will talk over a secure channel. To establish a secure channel, <kbd>ToDoListWebApp</kbd> needs to trust the client certificate. Both services are hosted on the same machine and run on IIS Express.</span></span></p>
<p><span class="md-line md-end-block"><span>To configure your computer to trust the IIS Express SSL certificate, open the <span class="packt_screen">PowerShell</span> command window as an administrator. </span></span><span class="md-line md-end-block"><span>Query your personal certificate store to find the thumbprint of the certificate for </span></span><kbd>CN=localhost</kbd>:</p>
<div class="CodeMirror cm-s-inner CodeMirror-wrap">
<div class="CodeMirror-scroll">
<div class="CodeMirror-sizer">
<div class="CodeMirror-lines">
<div class="CodeMirror-code">
<div class="CodeMirror-activeline">
<pre><span>PS C:windowssystem32&gt; dir Cert:LocalMachineMy<br/>Directory: Microsoft.PowerShell.SecurityCertificate::LocalMachineMy<br/></span>Thumbprint Subject<br/>---------- -------<br/>C24798908DA71693C1053F42A462327543B38042 CN=localhost</pre></div>
</div>
</div>
</div>
<p>Next, add the certificate to the trusted root store:</p>
</div>
</div>
<div class="CodeMirror cm-s-inner CodeMirror-wrap">
<div class="CodeMirror-scroll">
<div class="CodeMirror-sizer">
<div class="CodeMirror-lines">
<div class="CodeMirror-code">
<div class="CodeMirror-activeline">
<pre><span>PS C:windowssystem32&gt; $cert </span>= (get-item cert:LocalMachineMyC24798908DA71693C1053F42A462327543B38042)<span><br/></span>PS C:windowssystem32&gt; $store = (get-item cert:LocalmachineRoot)<br/>PS C:windowssystem32&gt; $store.Open("ReadWrite")<br/>PS C:windowssystem32&gt; $store.Add($cert)<br/>PS C:windowssystem32&gt; $store.Close()</pre></div>
</div>
</div>
</div>
</div>
</div>
<p>The preceding set of instructions will add a client certificate to the local machine's certificate store.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running both the applications</h1>
                </header>
            
            <article>
                
<p><span class="md-line md-end-block"><span>We are done with all those tedious configuration screens and replacing of keys. Excited? But before you hit <em>F5</em>, set <kbd>ToDoListService</kbd> and <kbd>ToDoListWebApp</kbd> as startup projects. Once this is done, we can safely run our application and be greeted with the landing page of our application. If you click on the <span class="packt_screen">Sign-in</span> button, you will be redirected to <a href="http://login.microsoftonline.com">login.microsoftonline.com</a>; this </span><span>represents the Azure AD login. Once you are able to log in, you will see the landing page as follows:</span></span></p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="374" src="assets/e29198da-d86b-4acc-a219-c9565624f490.png" width="727"/></div>
<p>You can observe network traffic and URL redirection when you log in to the application to study a detailed exchange of ID tokens and get an access token. If you explore the application through the <span class="packt_screen">ToDoList</span> menu, you will be able to access the <span class="packt_screen">ToDoList</span> screen as well as add items to <span class="packt_screen">ToDoList</span>. This is where our <kbd>TodoListService</kbd> microservice is getting called, as well as getting authorization permissions from the <kbd>TodoWebApp</kbd> web application. If you explore the profile menu, you will see the ID token return along with your first name, last name, and email ID, which shows OpenID Connect in action.</p>
<p><span class="md-line md-end-block"><span>If you want to explore the code in detail, <kbd>TodoListController.cs</kbd> in the <span class="packt_screen">TodoListService</span> project, <kbd>Startup.Auth.cs</kbd>, and <kbd>TodoListController.cs</kbd> contain interesting bits of code along with explanatory comments.</span></span></p>
<p><span class="md-line md-end-block"><span>In this example, we used OAuth and OpenID Connect to secure a browser-based user interface, a web application, and a microservice. Things might be different if we have an API gateway between the user interface web app and microservice. In this case, we need to establish trust between the web app and API gateway. Also, we have to pass the ID token and access token from the web app to the API gateway. This, in turn, passes the tokens to the microservice. However, it is not feasible to cover the discussion and implementation in this chapter's scope.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Azure API management as an API gateway</h1>
                </header>
            
            <article>
                
<p><span class="md-line md-end-block"><span>Another important pattern in microservices' implementation is <strong>Backends For Frontends</strong></span></span> (<span class="md-line md-end-block"><span><strong>BFF</strong></span></span>)<span class="md-line md-end-block"><span>. This pattern was introduced and made popular by Sam Newman. The actual implementation of the BFF pattern is done by introducing the API gateway between various types of clients and microservices.</span></span></p>
<p><span class="md-line md-end-block"><span>This is depicted in the following diagram:</span></span></p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="450" src="assets/d10acc55-d9a0-4d01-806d-95039ad04cfc.png" width="587"/></div>
<p><span class="md-line md-end-block"><span>Azure API Management (henceforth referred to as <strong>Azure APIM</strong> or just <strong>APIM</strong> ) is just the right fit, and it can act as an API gateway in .NET-based microservice implementation. Since Azure APIM is one of the cloud services, it is ultra-scalable and can be integrated well within the Azure ecosystem. In the current chapter, we will focus on the following features of Azure APIM.</span></span></p>
<p><span class="md-line md-end-block"><span>Azure APIM is logically divided into three parts:</span></span></p>
<ul>
<li><span class="md-line md-end-block"><span class="">API gateway</span><span>: API gateway is merely a proxy between client applications and services. It is responsible for the following functionalities; these are mainly used by various applications to talk to microservices:</span></span><br/>
<ul>
<li><span class="md-line md-end-block"><span>Accepts API calls and routes them to your backends</span></span></li>
<li><span class="md-line md-end-block"><span>Verifies API keys, JWTs, and certificates</span></span></li>
<li><span class="md-line md-end-block"><span>Supports auth through Azure AD and OAuth 2.0 access token</span></span></li>
<li><span class="md-line md-end-block"><span>Enforces usage quotas and rate limits</span></span></li>
<li><span class="md-line md-end-block"><span>Transforms your API on the fly without code modifications</span></span></li>
<li><span class="md-line md-end-block"><span>Caches backend responses where set up</span></span></li>
<li><span class="md-line md-end-block"><span>Logs call metadata for analytics purposes</span></span></li>
</ul>
</li>
<li><span class="md-line md-end-block"><span class="">Publisher portal</span><span>: This is the administrative interface to organize and publish an API program. It is mainly used by microservice developers to make microservices/APIs available to API consumers or client applications. Through this, API developers can:</span></span><br/>
<ul>
<li><span class="md-line md-end-block"><span>Define or import API schema</span></span></li>
<li><span class="md-line md-end-block"><span>Package APIs into products</span></span></li>
<li><span class="md-line md-end-block"><span>Set up policies such as quotas or transformations on the APIs</span></span></li>
<li><span class="md-line md-end-block"><span>Get insights from analytics</span></span></li>
<li><span class="md-line md-end-block"><span>Manage users</span></span></li>
</ul>
</li>
<li><span class="md-line md-end-block"><span class="">Developer portal</span><span>: This serves as the main web presence for API consumers where they can do the following:</span></span><br/>
<ul>
<li><span class="md-line md-end-block"><span>Read the API documentation</span></span></li>
<li><span class="md-line md-end-block"><span>Try out an API via the interactive console</span></span></li>
<li><span class="md-line md-end-block"><span>Create an account and subscribe to it to get the API keys</span></span></li>
<li><span class="md-line md-end-block"><span>Access analytics on their own usage</span></span></li>
</ul>
</li>
</ul>
<p><span class="md-line md-end-block"><span>Azure APIM comes with an easy-to-follow user interface and good documentation. Azure API management also comes with its REST API, hence all the capabilities of the Azure APIM portal, which you see can see, can be programmatically achieved by Azure REST API endpoint available for Azure APIM.</span></span></p>
<p><span class="md-line md-end-block"><span>Now, let's quickly look at some security-related concepts in Azure APIM and how they can be used in microservices:</span></span></p>
<ul>
<li><span class="md-line md-end-block"><span class=""> Products</span>: Products are <span>merely</span> a collection of APIs. They also contain usage quota and terms of use.</span></li>
<li><span class="md-line md-end-block"><span class="">Policies</span><span>: Policies are dynamic security features of API management. They allow the publisher to change the behavior of the API through configuration. Policies are a collection of statements that are executed sequentially upon the request or response of an API. API management is fundamentally a proxy that is sitting between our microservices hosted in Azure and client applications. By virtue of the fact that it is an intermediate layer, it is able to provide additional services. These additional services are defined in a declarative XML-based syntax called <strong>policies</strong>. Azure APIM allows various policies. In fact, you can compose your own custom policies by combining the existing ones. A few of the important policies are as follows:</span></span></li>
<li><span class="md-line md-end-block"><span class="">Access restriction policies</span></span>:<br/>
<ul>
<li><span class="md-line md-end-block"><span>Check the HTTP header: This policy checks whether a specific HTTP header or its value exists in every request received by Azure APIM.</span></span></li>
<li><span class="md-line md-end-block"><span>Limit call rate by subscription: This policy provides allow or deny access to the microservice based on the number of times the specific service has been called on a per subscription basis.</span></span></li>
<li><span class="md-line md-end-block"><span>Restrict caller IPs: This policy refers to white-boxing of IP addresses so only known IPs can access the services.</span></span></li>
<li><span class="md-line md-end-block"><span>Set usage quota by subscription: This policy allows a number of calls. It allows you to enforce a renewable or lifetime call volume and/or bandwidth quota on a per subscription basis.</span></span></li>
<li><span class="md-line md-end-block"><span class="md-line md-end-block"><span>Validate JWT: This policy validates the JWT token parameter that is used for auth in applications.</span></span></span></li>
</ul>
</li>
</ul>
<ul>
<li><span class="md-line md-end-block"><span class="">Authentication policies</span></span>:<br/>
<ul class="ul-list">
<li><span class="md-line md-end-block"><span>Authenticate with basic : This policy helps apply basic authentication over the incoming request.</span></span></li>
<li><span class="md-line md-end-block"><span class="md-line md-end-block"><span>Authenticate with client certificate: This policy helps carry out authentication of a service that is behind the API gateway, using client certificates.</span></span></span></li>
</ul>
</li>
<li><span class="md-line md-end-block"><span class="">Cross domain policies</span></span>:<br/>
<ul class="ul-list">
<li><span class="md-line md-end-block"><span>Allow cross-domain calls: This policy enables us to make CORS requests through Azure APIM.</span></span></li>
<li><span class="md-line md-end-block"><span>CORS : This adds CORS support to an endpoint or a microservice to allow cross-domain calls from browser-based web applications.</span></span></li>
<li>JSONP: The JSONP policy adds <strong>JSON padding</strong> (<strong>JSONP</strong>) support to an endpoint or entire microservice to allow cross-domain calls from Java Script web applications.</li>
</ul>
</li>
<li><span class="md-line md-end-block"><span class="">Transformation policies</span></span>:<br/>
<ul class="ul-list">
<li><span class="md-line md-end-block"><span>Mask URLs in content: This policy masks URLs in response; it does so via Azure APIM.</span></span></li>
<li class=""><span class="md-line md-end-block"><span class="">Set backend service: This policy alters the behavior of the backend service of an incoming request.</span></span></li>
</ul>
</li>
</ul>
<p style="padding-left: 120px"><span class="md-line md-end-block"><span>Another great thing about policies is they can be applied for inbound and outbound requests. </span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rate limit and quota policy example</h1>
                </header>
            
            <article>
                
<p>In the preceding section, we <span>saw</span> what <span>is meant by a policy. Now let's see an example. The following is one of the quota policies applied for an endpoint:</span></p>
<div class="CodeMirror cm-s-inner CodeMirror-wrap">
<div class="CodeMirror-scroll">
<div class="CodeMirror-sizer">
<div class="CodeMirror-lines">
<div class="CodeMirror-code">
<div class="CodeMirror-activeline">
<pre style="padding-left: 60px"><span><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">policies</span><span class="cm-tag cm-bracket">&gt;<br/></span></span>  &lt;<span class="cm-tag">inbound</span><span class="cm-tag cm-bracket">&gt;<br/></span>    <span class="cm-comment">&lt;!-- Change the quota to immediately see the effect--&gt;<br/></span>    <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">rate-limit</span> <span class="cm-attribute">calls</span>=<span class="cm-string">"100"</span> <span class="cm-attribute">renewal-period</span>=<span class="cm-string">"60"</span><span class="cm-tag cm-bracket">&gt;<br/></span>    <span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">rate-limit</span><span class="cm-tag cm-bracket">&gt;<br/></span>    <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">quota</span> <span class="cm-attribute">calls</span>=<span class="cm-string">"200"</span> <span class="cm-attribute">renewal-period</span>=<span class="cm-string">"604800"</span><span class="cm-tag cm-bracket">&gt;<br/></span>    <span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">quota</span><span class="cm-tag cm-bracket">&gt;<br/></span>    <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">base</span> <span class="cm-tag cm-bracket">/&gt;<br/></span>  &lt;/<span class="cm-tag">inbound</span><span class="cm-tag cm-bracket">&gt;<br/></span>  &lt;<span class="cm-tag">outbound</span><span class="cm-tag cm-bracket">&gt;<br/></span>    <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">base</span><span class="cm-tag cm-bracket">/&gt;<br/></span>  <span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">outbound</span><span class="cm-tag cm-bracket">&gt;<br/></span>&lt;/<span class="cm-tag">policies</span><span class="cm-tag cm-bracket">&gt;</span></pre></div>
</div>
</div>
</div>
<p>In this example, we are limiting incoming requests (inbound) from a single user. So, an API user can only make <kbd>100</kbd> calls within <kbd>60</kbd> seconds. If they try to make more calls within that duration, the user will get an error with status code <kbd>429</kbd>, which basically states <em>Rate limit is exceeded</em>. Also, we are assigning the quota limit of <kbd>200</kbd> calls in a year for the same user. This kind of throttling behavior is a great way to protect microservices from unwanted requests and even DOS attacks.</p>
</div>
</div>
<p><span class="md-line md-end-block"><span>Azure APIM also supports Auth with OAuth 2.0 and OpenID Connect. Inside the publisher portal, you can easily see OAuth and OpenID Connect tabs to configure the providers.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Container security</h1>
                </header>
            
            <article>
                
<p><span class="md-line md-end-block"><span>Docker is a big part of the containerization of applications used in the industry. With the widespread usage of containers, it is evident that we need to have effective security measures around containers. If we take a look at the internal architecture of containers, they are quite close to the host operating system kernel.</span></span></p>
<p><span class="md-line md-end-block"><span>Docker applies the principle of least privilege to provide isolation and reduce the attack surface. Despite the advances, the following points will help you understand the security measures you can take for containers:</span></span></p>
<ul>
<li><span class="md-line md-end-block"><span>Ensure all the container images used for microservices are signed and originate from a trusted registry</span></span></li>
<li><span class="md-line md-end-block"><span>Harden the host environment, the daemon process, and images</span></span></li>
<li><span class="md-line md-end-block"><span class="">Follow the principle of least privilege and do not elevate access to access devices</span></span></li>
<li><span class="md-line md-end-block"><span>Use control groups in Linux to keep tabs on resources, such as memory, I/O, and CPU</span></span></li>
<li><span class="md-line md-end-block"><span>Even though containers live for a very short duration, logging all of the container activity is advisable and important to understand for post analysis</span></span></li>
<li><span class="md-line md-end-block"><span class="md-line md-end-block"><span>If possible, integrate the container scanning process with tools, such as Aqua (</span><span><a href="http://www.aquasec.com">http://www.aquasec.com</a></span><span>) or Twistlock (</span><span><a href="https://www.twistlock.com">https://www.twistlock.com</a></span><span>)</span></span></span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other security best practices</h1>
                </header>
            
            <article>
                
<p><span class="md-line md-end-block"><span class="">The microservice architectural style is new, although some of the security practices around the infrastructure and writing secure code are still applicable. In this section, let's discuss some of these practices:</span></span></p>
<ul>
<li><span class="md-line md-end-block"><span class="">Standardization of libraries and frameworks:</span> <span>There should be a process to introduce new libraries and frameworks or tools in the development process. This will ease out patching in case any vulnerability is found; it will also minimize the risks introduced by ad hoc implementation of libraries or tools around development.</span></span></li>
<li><span class="md-line md-end-block"><span class="">Regular vulnerability identification and mitigation</span><span>: Using the industry standard vulnerability scanner to scan the source code and binaries should be a regular part of development. The findings and observations should be addressed as equally as functional defects.</span></span></li>
<li><span class="md-line md-end-block"><span class="">Third-party audits and pen testing:</span> <span>External audits and penetration testing exercises are immensely valuable. There should be a regular practice of conducting such exercises. This is quite essential in applications where mission critical or sensitive data is handled.</span></span></li>
<li><span class="md-line md-end-block"><span class="">Logging and monitoring</span><span>: Logging is quite a useful technique for detecting and recovering from attacks. Having the capability of aggregating logs from different systems is essential in the case of microservices. Tools such as Riverbed, AppDynamics, and Splunk are quite useful in this space.</span></span></li>
<li><span class="md-line md-end-block"><span class="">Firewalls</span><span class="">: Having one or more firewall at network boundaries is always beneficial. Firewall rules should be properly configured.</span></span></li>
<li><span class="md-line md-end-block"><span class="md-line md-end-block"><span class="md-line md-end-block"><span class="">Network segregation</span><span class="">: Network partitioning is constrained and limited in the case of monoliths. However, with microservices, we need to logically create different network segments and subnets. Segmentation based on microservices' interaction patterns can be very effective to keep and develop additional security measures.</span></span></span></span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p><span class="md-line md-end-block"><span class="">The microservice architectural style, being distributed by design, gives us better options to protect valuable business-critical systems. Traditional .NET-based authentication and authorization techniques are not sufficient and cannot be applied to the microservice world. We also saw why secure token-based approaches, such as OAuth 2.0 and OpenID Connect 1.0, are becoming concrete standards for microservice authorization and authentication. If you want to have more general information related to security, do visit <strong>Open Web Application Security Project</strong></span></span> (<span class="md-line md-end-block"><span class=""><strong>OWASP</strong></span></span>) <span class="md-line md-end-block"><span class="">at</span> <a href="http://www.owasp.org"><span>http://www.owasp.org</span></a> <span>and Microsoft Security development life cycle at </span><span><a href="https://www.microsoft.com/en-us/sdl/">https://www.microsoft.com/en-us/sdl/</a></span><span>. Azure AD can support OAuth 2.0 and OpenID Connect 1.0 very well. Azure API Management can also act as an API gateway in microservices' implementation and also provide nifty security features, such as policies.</span></span></p>
<p><span class="md-line md-end-block"><span class="">Azure AD and Azure API management provide quite a few powerful features to monitor and log the requests received. This will be quite useful, not only for security but also for tracing and troubleshooting scenarios. We will see logging, monitoring, and the overall instrumentation around troubleshooting of microservices in the next chapter.</span></span></p>


            </article>

            
        </section>
    </body></html>