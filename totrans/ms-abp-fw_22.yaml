- en: '*Chapter 17*: Building Automated Tests'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第17章*：构建自动化测试'
- en: Building automated tests is an essential `GetRegistrationOrNull` practice to
    create maintainable software solutions and is a fast and repeatable way of validating
    the software. ABP Framework and the ABP startup solution template are designed
    with testability in mind. We've already seen an example of writing a simple integration
    test with ABP Framework in [*Chapter 3*](B17287_03_Epub_AM.xhtml#_idTextAnchor044),
    *Step-By-Step Application Development*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 构建自动化测试是创建可维护的软件解决方案的必要`GetRegistrationOrNull`实践，并且是一种快速且可重复的验证软件的方法。ABP框架和ABP启动解决方案模板都是考虑到可测试性而设计的。我们已经在[*第3章*](B17287_03_Epub_AM.xhtml#_idTextAnchor044)，“逐步应用开发”中看到了使用ABP框架编写简单集成测试的例子。
- en: In this chapter, you will understand the ABP test infrastructure and build unit
    and integration tests for your ABP-based solutions. You will learn about data
    seeding for tests, mocking the database, and testing different kinds of objects.
    You will also learn the basics of automated tests such as assertions, mocking
    and replacing services, and dealing with exceptions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解ABP测试基础设施，并为基于ABP的解决方案构建单元和集成测试。你将学习测试的数据初始化、模拟数据库、测试不同类型的对象。你还将学习自动化测试的基础，如断言、模拟和替换服务，以及处理异常。
- en: 'Here is a list of the main topics covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章涵盖的主要主题列表：
- en: Understanding the ABP test infrastructure
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解ABP测试基础设施
- en: Building unit tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建单元测试
- en: Building integration tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建集成测试
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: If you want to follow the examples in this chapter, you need to have an IDE/editor
    that supports ASP.NET Core development.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想遵循本章中的示例，你需要有一个支持ASP.NET Core开发的IDE/编辑器。
- en: The examples in this chapter are mostly based on the EventHub solution I introduced
    in [*Chapter 4*](B17287_04_Epub_AM.xhtml#_idTextAnchor130), *Understanding the
    Reference Solution*. Please refer to that chapter to learn how to download the
    source code of the EventHub solution.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例大多基于我在[*第4章*](B17287_04_Epub_AM.xhtml#_idTextAnchor130)，“理解参考解决方案”中介绍的EventHub解决方案。请参考该章节以了解如何下载EventHub解决方案的源代码。
- en: Understanding the ABP test infrastructure
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解ABP测试基础设施
- en: ABP's startup solution template includes preconfigured test projects to build
    unit and integration tests for your solution. While you can write your tests without
    understanding the complete structure, I think it is worth exploring this so that
    you can understand how it works and customize it when you need it. We'll start
    by exploring the `test` projects.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ABP的启动解决方案模板包括预配置的测试项目，用于为你的解决方案构建单元和集成测试。虽然你可以在不理解完整结构的情况下编写测试，但我认为探索这一点是值得的，这样你可以了解它是如何工作的，并在需要时进行自定义。我们将从探索`test`项目开始。
- en: Exploring the test projects
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索测试项目
- en: 'The following screenshot shows the `test` projects that get created when you
    create a new ABP solution:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了创建新的ABP解决方案时创建的`test`项目：
- en: '![Figure 17.1 – Test projects in the ABP startup solution'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 17.1 – ABP启动解决方案中的测试项目]'
- en: '](img/Figure_17.01_B17287.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_17.01_B17287.jpg]'
- en: Figure 17.1 – Test projects in the ABP startup solution
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.1 – ABP启动解决方案中的测试项目
- en: 'The preceding screenshot shows the `test` projects for a solution named `ProductManagement`,
    with the MVC/Razor Pages UI and the `test` project list may be slightly different
    if you use a different UI or database provider, but the fundamental logic is the
    same. The following list explains the projects in general:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了名为`ProductManagement`的解决方案的`test`项目，如果你使用不同的UI或数据库提供者，`test`项目列表可能会有所不同，但基本逻辑是相同的。以下列表对项目进行了概括说明：
- en: '`ProductManagement.HttpApi.Client.ConsoleTestApp`: A very simple console application
    to manually test the HTTP API endpoints of your application. So, this is not a
    part of our automated test infrastructure, and you can ignore it for this chapter.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductManagement.HttpApi.Client.ConsoleTestApp`：一个用于手动测试应用程序HTTP API端点的非常简单的控制台应用程序。因此，这并不是我们自动化测试基础设施的一部分，你可以在本章中忽略它。'
- en: '`ProductManagement.TestBase`: A project that is shared by the other test projects.
    It has references to the base test libraries and includes data seeding and some
    other base configuration code. It doesn''t contain any test class normally.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductManagement.TestBase`：一个由其他测试项目共享的项目。它引用了基础测试库，包括数据初始化和一些其他基础配置代码。通常不包含任何测试类。'
- en: '`ProductManagement.EntityFrameworkCore.Tests`: You can build tests for EF Core
    integration code in this project, such as your custom repositories. This project
    also configures a SQLite in-memory database for your tests.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductManagement.EntityFrameworkCore.Tests`：您可以在该项目中构建EF Core集成代码的测试，例如您的自定义仓储。该项目还为您测试配置了一个SQLite内存数据库。'
- en: '`ProductManagement.Domain.Tests`: Use this project to build tests for your
    domain layer.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductManagement.Domain.Tests`：使用此项目构建您的领域层的测试。'
- en: '`ProductManagement.Application.Tests`: Use this project to build tests for
    your application layer.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductManagement.Application.Tests`：使用此项目构建您的应用层的测试。'
- en: '`ProductManagement.Web.Tests`: Use this project to build tests for your MVC/Razor
    Pages UI.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductManagement.Web.Tests`：使用此项目构建您的MVC/Razor Pages UI的测试。'
- en: The solution uses some libraries as the test infrastructure, as explained in
    the next section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 该解决方案使用一些库作为测试基础设施，如下一节所述。
- en: Exploring the test libraries
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索测试库
- en: 'The `ProductManagement.TestBase` project has reference to the following NuGet
    packages:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductManagement.TestBase`项目引用了以下NuGet包：'
- en: '`xunit`: xUnit is one of the most popular test frameworks for .NET.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xunit`：xUnit是.NET中最受欢迎的测试框架之一。'
- en: '`Shouldly`: A library to write the assertion code in an easy and readable format.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Shouldly`：一个用于以简单和可读的格式编写断言代码的库。'
- en: '`NSubstitute`: A library to mock objects in unit tests.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSubstitute`：一个用于单元测试中模拟对象的库。'
- en: '`Volo.Abp.TestBase`: ABP''s package to easily create ABP-integrated test classes.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Volo.Abp.TestBase`：ABP的包，用于轻松创建ABP集成测试类。'
- en: We will see how to use the basics of these libraries in the *Building unit tests*
    and *Building integration tests* sections. Before starting to write our tests,
    let's see how we can run the tests.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*构建单元测试*和*构建集成测试*部分中看到如何使用这些库的基本功能。在我们开始编写测试之前，让我们看看如何运行测试。
- en: Running the tests
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'In this section, I will show two ways of running the tests. The first way is
    to use an IDE that supports running test execution. I will use Visual Studio as
    an example. You can open the **Test Explorer** window from the **Test** | **Test
    Explorer** item on the main menu:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将展示两种运行测试的方法。第一种方法是使用支持运行测试执行的开发环境。我将使用Visual Studio作为示例。您可以从主菜单的**测试**
    | **测试资源管理器**项打开**测试资源管理器**窗口：
- en: '![Figure 17.2 – Test Explorer in Visual Studio'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.2 – Visual Studio中的测试资源管理器'
- en: '](img/Figure_17.02_B17287.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.02_B17287.jpg)'
- en: Figure 17.2 – Test Explorer in Visual Studio
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.2 – Visual Studio中的测试资源管理器
- en: '`ProductManagement` application built in [*Chapter 3*](B17287_03_Epub_AM.xhtml#_idTextAnchor044),
    *Step-By-Step Application Development*, and the source code can be found at [https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B17287_03_Epub_AM.xhtml#_idTextAnchor044)中构建的`ProductManagement`应用程序，*逐步应用开发*，源代码可以在[https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework)找到。
- en: 'Visual Studio runs the tests one by one by default, and thus it takes a long
    time to run all the tests. You can click the down arrow icon near the cog icon
    in **Text Explorer** and select the **Run Tests In Parallel** option (see *Figure
    17.3*) to run the tests in parallel so that it takes significantly less time to
    run them all:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio默认逐个运行测试，因此运行所有测试需要很长时间。您可以通过点击**文本探索器**中齿轮图标附近的向下箭头图标，选择**并行运行测试**选项（见*图17.3*）来并行运行测试，这样运行所有测试的时间将显著减少：
- en: '![Figure 17.3 – Running tests in parallel in Visual Studio'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.3 – 在Visual Studio中并行运行测试'
- en: '](img/Figure_17.03_B17287.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.03_B17287.jpg)'
- en: Figure 17.3 – Running tests in parallel in Visual Studio
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.3 – 在Visual Studio中并行运行测试
- en: ABP Framework and the startup solution template have been designed to support
    running tests in parallel so that tests don't affect each other.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ABP框架和启动解决方案模板已被设计为支持并行运行测试，这样测试不会相互影响。
- en: An alternative way to run tests is to use the `dotnet test` command in the root
    directory of your solution. It automatically discovers and runs all the tests
    and reports the test result in the command-line terminal. This command exits with
    a `0` (success) return code if all the tests succeed; otherwise, if any test fails,
    it exits with a `1` return code. This command is especially useful if you build
    a **continuous integration** (**CI**) pipeline where you automatically run the
    tests.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试的另一种方法是使用解决方案根目录中的 `dotnet test` 命令。它自动发现并运行所有测试，并在命令行终端中报告测试结果。如果所有测试都成功，则此命令以
    `0`（成功）返回代码退出；如果任何测试失败，则它以 `1` 返回代码退出。此命令在构建 **持续集成**（**CI**）管道时特别有用，其中可以自动运行测试。
- en: You've learned the test structure of the ABP startup solution and have run the
    automated tests. Now, we can start to build our tests.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学习了 ABP 启动解决方案的测试结构并运行了自动化测试。现在，我们可以开始构建我们的测试。
- en: Building unit tests
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建单元测试
- en: In this section, we will see different types of unit tests. We will begin by
    testing a static class, then we will write tests for a class with no dependencies.
    We will continue with a class with dependent services and learn how to mock these
    dependencies to unit test that class. We will learn the basics of writing automated
    test code with examples.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到不同类型的单元测试。我们将从测试一个静态类开始，然后为没有依赖关系的类编写测试。我们将继续测试具有依赖服务的类，并学习如何模拟这些依赖以对那个类进行单元测试。我们将通过示例学习编写自动化测试代码的基础。
- en: Let's begin with the simplest case—testing static classes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的情况开始——测试静态类。
- en: Testing static classes
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试静态类
- en: 'A static class with no state and external dependencies is the easiest class
    to test. `EventUrlHelper` is a static class (in the `EventHub.Domain` project
    of the EventHub solution) and is used to convert an event''s title to a proper
    URL part. The following test class (in the `EventHub.Domain.Tests` project of
    the EventHub solution) tests the `EventUrlHelper` class:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 没有状态和外部依赖的静态类是最容易测试的类。`EventUrlHelper` 是一个静态类（位于 EventHub 解决方案的 `EventHub.Domain`
    项目中），用于将事件标题转换为合适的 URL 部分。以下测试类（位于 EventHub 解决方案的 `EventHub.Domain.Tests` 项目中）测试了
    `EventUrlHelper` 类：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first rule is that the test class should be `public`. Otherwise, you can't
    see it in `[Fact]` attribute is defined by the `xUnit` library. Any public method
    with the `[Fact]` attribute is considered a test case and is automatically discovered
    by `Should_Convert_Url_To_Kebab_Case`, and only test the functionality related
    to `kebab-case`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条规则是测试类应该是 `public` 的。否则，你无法在由 `xUnit` 库定义的 `[Fact]` 属性中看到它。任何带有 `[Fact]`
    属性的公共方法都被视为测试用例，并由 `Should_Convert_Url_To_Kebab_Case` 自动发现，并且只测试与 `kebab-case`
    相关的功能性。
- en: The test code in this example is very simple. We call the static `EventUrlHelper.ConvertTitleToUrlPart`
    method with a sample title value, then compare the result with the value we expect
    it to be. The `Assert` class is defined by `xUnit`, with many methods to define
    our expectations. The test case succeeds only if the given values are equal. Otherwise,
    we see a red icon for the test case in **Test Explorer** with an error message
    indicating what's wrong with the test.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中的测试代码非常简单。我们调用静态 `EventUrlHelper.ConvertTitleToUrlPart` 方法，并使用一个示例标题值，然后比较结果与我们期望的值。`Assert`
    类由 `xUnit` 定义，具有许多方法来定义我们的期望。只有当给定的值相等时，测试用例才成功。否则，我们在 **Test Explorer** 中看到测试用例的红色图标，并显示一个错误消息，指出测试的问题。
- en: 'You can right-click on a specific test in **Test Explorer** to run it and see
    the result, as depicted in the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 **Test Explorer** 中的特定测试上右键单击以运行它并查看结果，如下面的截图所示：
- en: '![Figure 17.4 – Running a specific test in Test Explorer in Visual Studio'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 17.4 – 在 Visual Studio 的 Test Explorer 中运行特定测试'
- en: '](img/Figure_17.04_B17287.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 17.4 – 在 Visual Studio 的 Test Explorer 中运行特定测试'
- en: Figure 17.4 – Running a specific test in Test Explorer in Visual Studio
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.4 – 在 Visual Studio 的 Test Explorer 中运行特定测试
- en: 'Another common `xUnit` attribute is `[Theory]`, which provides parameters to
    a test method and tests it for each parameter set. Assuming that we want to run
    the test with different event URLs, we can rewrite the test method, as shown in
    the following code block:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的 `xUnit` 属性是 `[Theory]`，它为测试方法提供参数，并对每个参数集进行测试。假设我们想要使用不同的活动 URL 运行测试，我们可以重写测试方法，如下面的代码块所示：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`xUnit` runs this test method for each `[InlineData]` set separately and passes
    the `title` and `url` parameters as the given data. If you look at **Test Explorer**
    again, you will see these three test cases there:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`xUnit`为每个`[InlineData]`集合单独运行此测试方法，并将`title`和`url`参数作为给定数据传递。如果您再次查看**Test
    Explorer**，您将看到这三个测试案例在那里：'
- en: '![Figure 17.5 – Using the [Theory] attribute for unit tests'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 17.5 – Using the [Theory] attribute for unit tests'
- en: '](img/Figure_17.05_B17287.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_17.05_B17287.jpg]'
- en: Figure 17.5 – Using the [Theory] attribute for unit tests
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.5 – 使用[Theory]属性进行单元测试
- en: I also used the `Shouldly` library for the assertion in this example. The `result.ShouldBe(url)`
    expression is simpler to write and read than the `Assert.Equal(url, result)` expression.
    The `Shouldly` library works with extension methods such as that, and I will use
    it in future examples.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我还在这个例子中使用了`Shouldly`库进行断言。`result.ShouldBe(url)`表达式比`Assert.Equal(url, result)`表达式更容易编写和阅读。`Shouldly`库与这样的扩展方法一起工作，我将在未来的示例中使用它。
- en: Testing static classes (with no state and external dependencies) was easy. We've
    also learned some `xUnit` and `Shouldly` features. The next section continues
    with testing simple classes without a service dependency.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 测试无状态和外部依赖的静态类（类）很容易。我们还学习了一些`xUnit`和`Shouldly`功能。下一节将继续测试没有服务依赖的简单类。
- en: Testing classes with no dependencies
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试无依赖关系的类
- en: Some classes, such as entities, may have no dependency on other services. Testing
    these classes is relatively easy since we don't need to prepare the dependencies
    to make the class work properly.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一些类，如实体，可能没有对其他服务的依赖。测试这些类相对容易，因为我们不需要准备依赖来使类正常工作。
- en: 'The following test method tests the `Event` class''s constructor:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试方法测试`Event`类的构造函数：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this example, I''ve passed a valid list of parameters so that it doesn''t
    throw an exception, and the test succeeds. The following example tests for an
    exception case:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我传递了一个有效的参数列表，这样它就不会抛出异常，测试成功。以下示例测试异常情况：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I intentionally passed the end time as 2 days earlier than the start time. I
    am expecting the constructor to throw a `BusinessException` exception by using
    the `Assert.Throws<T>` method. If the code block inside the `Throws` method throws
    an exception of type `BusinessException`, then the test passes; otherwise, the
    test will fail. I am also checking the error code with the `ShouldBe` extension
    method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意将结束时间设置为比开始时间早2天。我期望构造函数通过使用`Assert.Throws<T>`方法抛出`BusinessException`异常。如果`Throws`方法内部的代码块抛出`BusinessException`类型的异常，则测试通过；否则，测试将失败。我还使用`ShouldBe`扩展方法检查错误代码。
- en: 'Let''s write a method that tests another method of the `Event` class. The following
    example creates a valid `Event` object, then changes its start and end times,
    and finally checks whether the times were changed:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个测试`Event`类另一个方法的函数。以下示例创建了一个有效的`Event`对象，然后更改其开始和结束时间，并最终检查时间是否已更改：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This example fully implements the common **Arrange-Act-Assert** (**AAA**) test
    pattern, detailed as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例完全实现了常见的**Arrange-Act-Assert**（**AAA**）测试模式，详细说明如下：
- en: The *Arrange* part prepares the objects we need to work on.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Arrange*部分准备我们需要工作的对象。'
- en: The *Act* part executes the actual code we want to test.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Act*部分执行我们想要测试的实际代码。'
- en: The *Assert* part checks whether the expectations are met.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Assert*部分检查期望是否得到满足。'
- en: I suggest separating your test method's body with these comment lines to make
    what you are testing and asserting explicit. In this example, we used the `SetTime`
    method of the `Event` class to change the event times. The `SetTime` method also
    publishes a local event, so I checked it too in the *Assert* part.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议使用这些注释行分隔测试方法的主体，以使您正在测试和断言的内容明确。在这个例子中，我们使用了`Event`类的`SetTime`方法来更改事件时间。`SetTime`方法还发布了一个本地事件，因此我在*Assert*部分也检查了它。
- en: As you see in the examples, if the class we want to test has no external dependencies,
    we can simply create an instance and execute the methods on it. In the next section,
    we will see how to deal with external dependencies.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在示例中看到的，如果我们想要测试的类没有外部依赖，我们可以简单地创建一个实例并在其上执行方法。在下一节中，我们将看到如何处理外部依赖。
- en: Testing classes with dependencies
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试具有依赖关系的类
- en: Most services have dependencies on other services. We use the **dependency injection**
    (**DI**) system to take these dependencies into the service's constructor. The
    purpose of unit testing is to test a class as isolated from other classes because
    unit tests should generally have only one reason to fail. We should somehow exclude
    the dependencies while testing the target class. In this way, our test is affected
    by the changes in the target class but not affected by changes in other classes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数服务都依赖于其他服务。我们使用**依赖注入**（**DI**）系统将这些依赖项注入到服务的构造函数中。单元测试的目的是测试一个类尽可能独立于其他类，因为单元测试通常只有一个失败的理由。我们应该在测试目标类时排除这些依赖项。这样，我们的测试会受到目标类变化的影响，但不会受到其他类变化的影响。
- en: Mocking is a technique used in unit testing to replace a target class's dependencies
    with fake implementations so that the test isn't affected by the target class's
    dependencies.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟是单元测试中用来用假实现替换目标类依赖项的技术，这样测试就不会受到目标类依赖项的影响。
- en: I will test the `IsPastEvent` method of the `EventRegistrationManager` class
    as an example. The `IsPastEvent` method gets an event.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我将以`EventRegistrationManager`类的`IsPastEvent`方法为例进行测试。`IsPastEvent`方法获取一个事件。
- en: '`EventRegistrationManager` is a domain service and takes three external services
    in its constructor, as shown in the following simplified code block:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventRegistrationManager`是一个领域服务，并在其构造函数中接受三个外部服务，如下面的简化代码块所示：'
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We should pass instances of these three external services to be able to create
    an `EventRegistrationManager` object. The following code block shows how I''ve
    written a test method for the `IsPastEvent` method of that class:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该传递这三个外部服务的实例，以便能够创建一个`EventRegistrationManager`对象。下面的代码块显示了我是如何为该类的`IsPastEvent`方法编写测试方法的：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The test code starts by creating a fake `IClock` object using the `Substitute.For<T>`
    utility method of the `NSubstitute` library. The `clock.Now.Returns(DateTime.Now)`
    statement configures the fake object so that it returns `DateTime.Now` whenever
    the `clock.Now` property is called. We do that since the `IsPastEvent` method
    will call the `clock.Now` property. That means we should know the internal implementation
    details of the unit-tested method to test it properly.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码首先使用`NSubstitute`库的`Substitute.For<T>`实用方法创建了一个假的`IClock`对象。`clock.Now.Returns(DateTime.Now)`语句配置了假对象，使其在调用`clock.Now`属性时返回`DateTime.Now`。我们这样做是因为`IsPastEvent`方法将调用`clock.Now`属性。这意味着我们应该了解单元测试方法的内部实现细节，以便正确测试它。
- en: Since I know that the `IsPastEvent` method won't use the `IEventRegistrationRepository`
    and `IGuidGenerator` services, I can pass them as `null` in the constructor of
    the `EventRegistrationManager` class.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我知道`IsPastEvent`方法不会使用`IEventRegistrationRepository`和`IGuidGenerator`服务，我可以在`EventRegistrationManager`类的构造函数中将它们传递为`null`。
- en: Finally, I've called the `IsPastEvent` method of the `EventRegistrationManager`
    class with an example event and checked the result.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我使用一个示例事件调用了`EventRegistrationManager`类的`IsPastEvent`方法并检查了结果。
- en: 'Let''s see a more complex example. This time, we are testing the `RegisterAsync`
    method of the `EventRegistrationManager` class. The code is illustrated in the
    following snippet:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个更复杂的例子。这次，我们正在测试`EventRegistrationManager`类的`RegisterAsync`方法。代码如下所示：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, I've created an `Event` object and an `IdentityUser` object because the
    `RegisterAsync` method gets these parameters. Then, I've mocked the `EventRegistrationManager`
    dependencies. Since the `RegisterAsync` method uses all the dependencies, I had
    to mock them all. See how I configured the fake repository to return `false` when
    the `ExistsAsync` method is called. The `RegisterAsync` method uses the `ExistsAsync`
    method to check whether there is already a registration with the same event and
    user.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我创建了一个`Event`对象和一个`IdentityUser`对象，因为`RegisterAsync`方法需要这些参数。然后，我模拟了`EventRegistrationManager`的依赖项。由于`RegisterAsync`方法使用了所有依赖项，我不得不模拟它们所有。看看我是如何配置假仓库在调用`ExistsAsync`方法时返回`false`的。`RegisterAsync`方法使用`ExistsAsync`方法来检查是否已经存在具有相同事件和用户的注册。
- en: After executing the `RegisterAsync` method, I should somehow check whether the
    registration is complete. I can use the `Received` method of `NSubstitute` to
    check whether the repository's `InsertAsync` method is called with an `EventRegistration`
    object with the specified event and **user identifiers** (**UIDs**).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`RegisterAsync`方法后，我应该以某种方式检查注册是否完成。我可以使用`NSubstitute`的`Received`方法来检查仓库的`InsertAsync`方法是否被调用，并带有指定的事件和**用户标识符**（**UIDs**）的`EventRegistration`对象。
- en: 'In this section, I''ve covered the basics of unit testing. Unit tests have
    two main advantages compared to integration tests, as outlined here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我已经介绍了单元测试的基础知识。与集成测试相比，单元测试有两个主要优势，如下所述：
- en: They run fast because only the tested class really works. All others are mocked
    and typically have no execution cost.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们运行速度快，因为只有被测试的类真正工作。所有其他类都是模拟的，通常没有执行成本。
- en: They make it easier to investigate problems. If a class doesn't work properly,
    only the tests working on that class fail, so you can easily find the problem's
    source.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们使问题调查变得更容易。如果一个类工作不正常，只有针对该类的测试会失败，因此你可以轻松地找到问题的根源。
- en: However, writing and maintaining unit tests is hard when your classes have dependencies.
    Unit tests also can't tell much about whether your class will properly work at
    runtime integrated with other services. That brings us to integration tests.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你的类有依赖关系时，编写和维护单元测试是困难的。单元测试也无法充分说明你的类在与其他服务集成运行时是否能够正常工作。这引出了集成测试的概念。
- en: Building integration tests
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建集成测试
- en: In this section, we will see how to build automated tests for your services
    as integrated into ABP Framework and other infrastructure components. We will
    start by understanding ABP integration, how the database is used in integration
    tests, and how to create initial test data. Then, we will write example tests
    for repositories, domain, and application services. Let's start with ABP integration.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何为集成到ABP框架和其他基础设施组件的服务构建自动化测试。我们将从理解ABP集成开始，了解集成测试中数据库的使用方式，以及如何创建初始测试数据。然后，我们将编写存储库、领域和应用程序服务的示例测试。让我们从ABP集成开始。
- en: Understanding ABP integration
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解ABP集成
- en: 'ABP provides the `Volo.Abp.TestBase` NuGet package, which includes the `AbpIntegratedTest<TStartupModule>`
    base class for our integration tests. We can inherit from that class to write
    tests as completely integrated to ABP Framework. The following example shows the
    main parts of such a test class:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ABP提供了`Volo.Abp.TestBase` NuGet包，其中包含用于集成测试的`AbpIntegratedTest<TStartupModule>`基类。我们可以从该类继承以编写与ABP框架完全集成的测试。以下示例显示了此类测试的主要部分：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this example, I''ve inherited from the `AbpIntegratedTest<MyTestModule>`
    class, where `MyTestModule` is my startup module class. `MyTestModule` should
    depend on `AbpTestBaseModule`, as shown in the following example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我继承了`AbpIntegratedTest<MyTestModule>`类，其中`MyTestModule`是我的启动模块类。`MyTestModule`应该依赖于`AbpTestBaseModule`，如下面的示例所示：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the constructor of `SampleTestClass`, I've resolved an example service using
    the `GetRequiredService` method and assigned it to a class field. We could resolve
    a service from the DI system since all the infrastructure is available, just like
    at runtime. I don't need to care about the dependencies of the service. Finally,
    I called a method of the example service in my test method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SampleTestClass`的构造函数中，我使用`GetRequiredService`方法解析了一个示例服务，并将其分配给一个类字段。由于所有基础设施都可用，我们可以从DI系统中解析服务，就像在运行时一样。我不需要关心服务的依赖关系。最后，我在测试方法中调用了示例服务的方法。
- en: While writing integration tests is that simple, test projects in the startup
    template have a little more. Check the `EventHubTestBaseModule` class (in the
    `EventHub.TestBase` project of the EventHub solution). You will see that it is
    disabling background jobs and authorization, seeding some test data, and doing
    other configurations.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然编写集成测试如此简单，但启动模板中的测试项目还有一些额外的内容。检查`EventHubTestBaseModule`类（位于EventHub解决方案的`EventHub.TestBase`项目中）。你会看到它禁用了后台作业和授权，播种了一些测试数据，并进行了其他配置。
- en: We've learned the basics of integrating with ABP in our test classes. In the
    next section, you will learn how to deal with the database in tests.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在测试类中学习了与ABP集成的基础知识。在下一节中，你将学习如何处理测试中的数据库。
- en: Mocking the database
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟数据库
- en: The database is one of the most fundamental aspects when you are building integration
    tests. Assume that you are using SQL Server in your solution. Using a real SQL
    Server database has some fundamental problems; your tests affect each other since
    they will work on the same database. A test's change in the database may break
    subsequent tests. You may not run tests in parallel. Test execution speed will
    be slow since your application will communicate to SQL Server as an external process.
    No need to mention that SQL Server should be installed and available in your test
    environment.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库是构建集成测试时最基本的部分之一。假设你在你的解决方案中使用SQL Server。使用真实的SQL Server数据库有一些基本问题；由于它们将在同一个数据库上工作，因此测试会相互影响。数据库中的测试更改可能会破坏后续的测试。你可能无法并行运行测试。由于你的应用程序将作为外部进程与SQL
    Server通信，因此测试执行速度会较慢。无需提及SQL Server应该在测试环境中安装并可用。
- en: EF Core provides an in-memory database option, but it is very limited. For example,
    it has no transaction support and cannot execute SQL commands. So, I don't suggest
    using it at all.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core提供了一个内存数据库选项，但它非常有限。例如，它不支持事务，并且无法执行SQL命令。因此，我建议根本不要使用它。
- en: The ABP startup template has been configured to use SQLite in-memory database
    for EF Core (it also uses an in-memory database for MongoDB using the `Mongo2Go`
    library). SQLite is a real relational database management system and will be sufficient
    for most of the applications.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ABP启动模板已经配置为使用SQLite内存数据库进行EF Core（它还使用`Mongo2Go`库为MongoDB提供内存数据库）。SQLite是一个真正的关系型数据库管理系统，对于大多数应用程序来说将足够使用。
- en: Check the `EventHubEntityFrameworkCoreTestModule` class (in the `EventHub.EntityFrameworkCore.Tests`
    project of the EventHub solution) to see the SQLite setup. It creates a separate
    in-memory SQLite database for each test case, creates tables inside the database,
    and seeds the test data. In this way, every test method starts with the same initial
    state and doesn't affect other tests. We will see seeding the test data in the
    next section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`EventHubEntityFrameworkCoreTestModule`类（位于EventHub解决方案的`EventHub.EntityFrameworkCore.Tests`项目中），以查看SQLite的设置。它为每个测试用例创建一个单独的内存SQLite数据库，在数据库中创建表，并初始化测试数据。这样，每个测试方法都以相同的初始状态开始，并且不会影响其他测试。我们将在下一节中看到测试数据的初始化。
- en: Seeding the test data
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化测试数据
- en: Writing tests against an empty database is not so practical. Assume that you
    want to query events in the database or want to test whether the event registration
    code works. You first need to insert some entities into the database. It can be
    tedious to prepare the database for each test. Instead, we can create some initial
    entities in the database that are available for each test.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在空数据库上编写测试并不那么实用。假设你想要查询数据库中的事件或者想要测试事件注册代码是否工作。你首先需要将一些实体插入到数据库中。为每个测试准备数据库可能会很繁琐。相反，我们可以在数据库中创建一些初始实体，这些实体对每个测试都是可用的。
- en: The ABP startup solution template uses ABP's data seeding system to fill some
    initial data into the database. See the `EventHubTestDataSeedContributor` class
    (in the `EventHub.TestBase` project of the EventHub solution). It creates some
    users, organizations, and events in the database, so we can directly write tests
    assuming that the initial data exists.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ABP启动解决方案模板使用ABP的数据初始化系统将一些初始数据填充到数据库中。查看EventHub解决方案的`EventHub.TestBase`项目中的`EventHubTestDataSeedContributor`类。它在数据库中创建了一些用户、组织和事件，因此我们可以直接编写假设初始数据存在的测试。
- en: We've talked about ABP's integration test infrastructure, mocking and seeding
    the database. Now, we can write some integration tests, starting from the repositories.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了ABP的集成测试基础设施，包括数据库的模拟和初始化。现在，我们可以从存储库开始编写一些集成测试。
- en: Testing repositories
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试存储库
- en: 'Let''s see the `EventRegistrationRepository_Tests` class (in the `EventHub.Domain.Tests`
    project of the EventHub solution) as an example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以EventHub解决方案的`EventHub.Domain.Tests`项目中的`EventRegistrationRepository_Tests`类为例：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This class inherits the `EventHubDomainTestBase` class, which is indirectly
    inherited from the `AbpIntegratedTest<T>` class we've explored in the *Understanding
    the ABP integration* section. So, in the constructor, we could resolve the `IEventRegistrationRepository`
    and `EventHubTestData` services from the DI system. You can investigate the `EventHubTestData`
    class yourself (in the `EventHub.TestBase` project of the EventHub solution).
    It basically stores the `Id` values of the entities that are initially seeded
    into the database to reach them in the tests.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此类继承自 `EventHubDomainTestBase` 类，该类间接继承自我们在 *Understanding the ABP integration*
    部分中探讨的 `AbpIntegratedTest<T>` 类。因此，在构造函数中，我们可以从 DI 系统解析 `IEventRegistrationRepository`
    和 `EventHubTestData` 服务。你可以自己调查 `EventHubTestData` 类（在 EventHub 解决方案的 `EventHub.TestBase`
    项目中）。它基本上存储了最初种入数据库的实体的 `Id` 值，以便在测试中访问它们。
- en: 'Let''s see the first test method of the `EventRegistrationRepository_Tests`
    class. Here it is:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `EventRegistrationRepository_Tests` 类的第一个测试方法。如下所示：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This test simply executes the `ExistsAsync` method and checks the result to
    be `false`. It should return `false` because we know the user `John` has not registered
    to the given event. We know that because we''ve written the initial data in the
    database (see the *Seeding the test data* section). Let''s write another test,
    as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试简单地执行 `ExistsAsync` 方法并检查结果为 `false`。它应该返回 `false`，因为我们知道用户 `John` 没有注册给定的活动。我们知道这一点是因为我们在数据库中编写了初始数据（见
    *Seeding the test data* 部分）。让我们再写一个测试，如下所示：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This time, we are creating the registration record in the database, so we expect
    the same `ExistsAsync` call to return `true`. In this way, we can prepare the
    database for a particular test to get the expected result.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们在数据库中创建注册记录，因此我们期望相同的 `ExistsAsync` 调用返回 `true`。这样，我们可以为特定的测试准备数据库以获得预期的结果。
- en: 'ABP''s repositories provide the `GetQueryableAsync` method, so we can directly
    use `queryable` in tests):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 的存储库提供了 `GetQueryableAsync` 方法，因此我们可以在测试中直接使用 `queryable`）：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This method queries the same registration using the `Where` and `FirstOrDefaultAsync`
    LINQ extension methods. If you try to run this test, you will see it throws an
    exception (of type `ObjectDisposedException`) because the `GetQueryableAsync`
    method requires an active `WithUnitOfWorkAsync` method to execute code in a UoW,
    so we can fix the test code as shown in the following code block:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用 `Where` 和 `FirstOrDefaultAsync` LINQ 扩展方法查询相同的注册。如果你尝试运行此测试，你会看到它抛出一个异常（类型为
    `ObjectDisposedException`），因为 `GetQueryableAsync` 方法需要一个活动的 `WithUnitOfWorkAsync`
    方法来在 UoW 中执行代码，因此我们可以像以下代码块中所示的那样修复测试代码：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can see the source code of the `WithUnitOfWorkAsync` method. It just uses
    `IUnitOfWorkManager` to create a UoW scope.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到 `WithUnitOfWorkAsync` 方法的源代码。它只是使用 `IUnitOfWorkManager` 创建 UoW 范围。
- en: We've created some test methods for repositories. You can test any service (that
    was registered to the DI system) in the same way. I will show some example tests
    for domain and application services in the next two sections.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为存储库创建了一些测试方法。你可以以相同的方式测试任何服务（已注册到 DI 系统）。我将在下一节展示一些领域服务和应用服务的示例测试。
- en: Testing domain services
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试领域服务
- en: 'Testing domain services is similar to testing repositories since you should
    also care about the UoW for domain services. The following code block shows an
    example test case from the `EventManager_Tests` class (in the `EventHub.Domain.Tests`
    project of the EventHub solution):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 测试领域服务与测试存储库类似，因为你也应该关心领域服务的 UoW。以下代码块显示了来自 `EventManager_Tests` 类（在 EventHub
    解决方案的 `EventHub.Domain.Tests` 项目中）的示例测试用例：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The test's purpose is to increase the capacity of an event using the `EventManager`
    domain service and see whether it works. It uses the `WithUnitOfWorkAsync` method
    to call the `SetCapacityAsync` method because the `SetCapacityAsync` method internally
    executes the `CountAsync` LINQ extension method and requires an active UoW. If
    you don't want to check the domain service's internals in every case, I suggest
    always starting a UoW while using domain services or repositories in your tests.
    After the UoW, I've re-queried the same event from the database to check whether
    the capacity has been updated.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的目的是使用 `EventManager` 领域服务增加活动的容量，并查看它是否工作。它使用 `WithUnitOfWorkAsync` 方法调用
    `SetCapacityAsync` 方法，因为 `SetCapacityAsync` 方法内部执行 `CountAsync` LINQ 扩展方法，需要一个活动的
    UoW。如果你不想在每种情况下都检查领域服务的内部，我建议在测试中使用领域服务或存储库时始终启动 UoW。在 UoW 之后，我重新从数据库查询了相同的活动以检查容量是否已更新。
- en: You can explore the `EventManager_Tests` class and other test classes inside
    the `EventHub.Domain.Tests` project for all details and more complex test cases.
    In the next section, I will show testing application services.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以探索`EventManager_Tests`类和其他在`EventHub.Domain.Tests`项目中的测试类，以获取所有详细信息以及更复杂的测试用例。在下一节中，我将展示测试应用服务。
- en: Testing application services
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试应用服务
- en: In this section, we will examine one more test, written for the `EventRegistrationAppService`
    class (defined in the `EventHub.Application` project of the EventHub solution).
    `EventRegistrationAppService_Tests` (defined in the `EventHub.Application.Tests`
    project of the EventHub solution) is the test class that contains tests for that
    application service. You can explore the class inside the solution. Here, I will
    show it partially to explain how it works.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查一个针对`EventRegistrationAppService`类（在EventHub解决方案的`EventHub.Application`项目中定义）的测试。`EventRegistrationAppService_Tests`（在EventHub解决方案的`EventHub.Application.Tests`项目中定义）是包含该应用服务测试的测试类。你可以在解决方案中探索这个类。在这里，我将部分展示它以解释其工作原理。
- en: 'Let''s start with the test method for registering an event by the current user.
    You can see this here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从当前用户注册事件的测试方法开始。你可以在这里看到它：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The first line sets the current user to the admin user, which is needed because
    the `EventRegistrationAppService.RegisterAsync` method works for the current user.
    Let''s see how the `Login` method was implemented, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将当前用户设置为管理员用户，这是必需的，因为`EventRegistrationAppService.RegisterAsync`方法适用于当前用户。让我们看看`Login`方法的实现，如下所示：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It configures the `_currentUser` object to return the given `userId` value
    when we use its `Id` property. As you may guess, `_currentUser` is a mock (fake)
    object of type `ICurrentUser`. The mock object is configured in the `AfterAddApplication`
    method, as illustrated in the following code snippet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 它配置了`_currentUser`对象，当使用其`Id`属性时返回给定的`userId`值。正如你可能猜到的，`_currentUser`是类型为`ICurrentUser`的模拟（伪造）对象。模拟对象在`AfterAddApplication`方法中配置，如下面的代码片段所示：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This method overrides the `AfterAddApplication` method of the `AbpIntegratedTest<T>`
    base class. We can override this method to make a last touch to the DI configuration
    before the initialization phase completes. Here, I've created a mock object using
    the `NSubstitute` library and added the object as a singleton service (remember
    that the last registered class/object is used for a service). In this way, I can
    change its value, and all the services using `ICurrentUser` are affected.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法覆盖了`AbpIntegratedTest<T>`基类的`AfterAddApplication`方法。我们可以覆盖此方法，在初始化阶段完成之前对DI配置进行最后的调整。在这里，我使用`NSubstitute`库创建了一个模拟对象，并将其作为单例服务（记住，最后注册的类/对象用于服务）。这样，我可以更改其值，并且所有使用`ICurrentUser`的服务都会受到影响。
- en: 'After setting the current user, the test method calls the `EventRegistrationAppService.RegisterAsync`
    method as you normally do. Finally, I checked the database to see whether a registration
    record was saved. The `GetRegistrationOrNull` method''s implementation is shown
    in the following code block:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 设置当前用户后，测试方法会像通常一样调用`EventRegistrationAppService.RegisterAsync`方法。最后，我检查了数据库以查看是否保存了注册记录。`GetRegistrationOrNull`方法的实现如下所示：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: I've used `WithUnitOfWorkAsync` here again because the `FirstOrDefaultAsync`
    method requires an active UoW.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里再次使用了`WithUnitOfWorkAsync`，因为`FirstOrDefaultAsync`方法需要一个活动的UoW。
- en: As we've seen in the examples, writing integration tests is easy and mostly
    straightforward with ABP Framework. We rarely need to mock services and deal with
    the dependencies of the service we are targeting for the test.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在示例中看到的，使用ABP框架编写集成测试既简单又直接。我们很少需要模拟服务并处理我们针对测试的目标服务的依赖关系。
- en: Integration tests run slower than unit tests, but they allow you to test the
    integration between components and additionally test database queries in a way
    you can't with unit tests. I suggest going balanced and pragmatic—build both unit
    and integration tests for your solutions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试的运行速度比单元测试慢，但它们允许你测试组件之间的集成，并且可以以你无法使用单元测试的方式测试数据库查询。我建议平衡且实际——为你的解决方案构建单元测试和集成测试。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Preparing tests is an essential practice for building any kind of software solution.
    As we've seen in this chapter, ABP provides the fundamental infrastructure to
    help you write tests for your applications.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 准备测试是构建任何类型软件解决方案的基本实践。正如我们在本章中看到的，ABP提供了基本的基础设施来帮助你为你的应用程序编写测试。
- en: We have explored unit and integration testing with ABP Framework with examples.
    I've selected examples from the EventHub solution. That solution also contains
    more complex tests, and I suggest you explore them.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过示例探索了使用 ABP 框架的单元和集成测试。我从 EventHub 解决方案中选择了示例。该解决方案还包含更复杂的测试，我建议您探索它们。
- en: By now, you should be writing automated tests to cover your server-side code.
    You've seen how the ABP startup solution is structured and how the database was
    mocked. You've learned how to deal with exceptions, UoWs, data seeding, object
    mocking, and other common test patterns.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，您应该已经开始编写自动化测试来覆盖您的服务器端代码。您已经看到了 ABP 启动解决方案的结构以及数据库是如何被模拟的。您已经学习了如何处理异常、UoWs、数据初始化、对象模拟和其他常见的测试模式。
- en: This was the last chapter of the book. If you've read so far and followed the
    examples, you've learned the fundamentals, features, and best practices of using
    ABP Framework. You are more than ready to build your ABP based solutions to realize
    your software ideas.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的最后一章。如果您已经读到这儿，并跟随了示例，您已经学到了使用 ABP 框架的基础知识、特性和最佳实践。您已经准备好构建基于 ABP 的解决方案来实现您的软件想法。
- en: You can refer to this book on your development journey, and also check ABP Framework's
    documentation on [https://docs.abp.io](https://docs.abp.io) whenever you need
    more details and up-to-date information.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在开发过程中参考这本书，并在需要更多详细信息和最新信息时查看 ABP 框架的文档：[https://docs.abp.io](https://docs.abp.io)。
- en: 'Lastly, feel free to create issues on ABP Framework''s GitHub repository if
    you have any problem: [https://github.com/abpframework/abp](https://github.com/abpframework/abp).
    I will continue to be one of the active contributors of this great project and
    try to answer your questions.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您有任何问题，请随意在 ABP 框架的 GitHub 仓库中创建问题：[https://github.com/abpframework/abp](https://github.com/abpframework/abp)。我将继续成为这个伟大项目的活跃贡献者，并尝试回答您的问题。
- en: I am Halil İbrahim Kalkan, author of Mastering ABP Framework. I really hope
    you enjoyed reading this book and found it useful for increasing your productivity
    and efficiency in ABP Framework.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我是 Halil İbrahim Kalkan，ABP 框架精通一书的作者。我真心希望您喜欢阅读这本书，并发现它对提高您在 ABP 框架中的生产力和效率有所帮助。
- en: It would really help me (and other potential readers!) if you could leave a
    review on Amazon sharing your thoughts on Mastering ABP Framework here.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您能在亚马逊上留下对《ABP 框架精通》的评价，分享您的想法，这将对我（以及其他潜在读者！）非常有帮助。
- en: 'Go to the link below or scan the QR code to leave your review:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 前往以下链接或扫描二维码留下您的评价：
- en: '[https://packt.link/r/1801079242](https://packt.link/r/1801079242)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/r/1801079242](https://packt.link/r/1801079242)'
- en: '![](img/QR_Code.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code.jpg)'
- en: Your review will help me to understand what’s worked well in this book, and
    what could be improved upon for future editions, so it really is appreciated.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您的评价将帮助我了解这本书中哪些地方做得好，以及未来版本中哪些地方可以改进，所以这真的非常感谢。
- en: Best Wishes,
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 祝好运，
- en: '![](img/Author_signature.jpg)![](img/Author_photo.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![作者签名](img/Author_signature.jpg)![作者照片](img/Author_photo.jpg)'
- en: Halil İbrahim Kalkan
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Halil İbrahim Kalkan
