- en: Projections and Queries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投影和查询
- en: 'In [Chapter 9](6f50ee65-024a-4c46-89c8-343183b05b8f.xhtml), *CQRS - The Read
    Side*, we changed our application to use events as the consistent aggregate storage.
    Instead of updating a snapshot of the state after handling a command, we can add
    new events to the stream that represents a single aggregate. We can then do a
    *left fold* on those events to reconstruct the aggregate state each time we load
    it again, before handling another command. In two lines of pseudo code, the essence
    of Event Sourcing can be represented as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](6f50ee65-024a-4c46-89c8-343183b05b8f.xhtml)，*CQRS - 读取侧*中，我们将应用程序改为使用事件作为一致的聚合存储。在处理命令后，我们不再更新状态快照，而是可以向表示单个聚合的事件流中添加新事件。然后，每次再次加载时，我们都可以对这些事件进行*左折叠*以重建聚合状态，在处理另一个命令之前。以下是用两行伪代码表示事件源本质的示例：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `history` is what we load from the aggregate stream, `when` is the `AggregateRoot.When`
    method and `Handle` is one of the methods in the application service.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`history`是从聚合流中加载的内容，`when`是`AggregateRoot.When`方法，而`Handle`是应用程序服务中的方法之一。
- en: But, as I mentioned before, I removed all read models and the code associated
    with queries from the project for [Chapter 9](6f50ee65-024a-4c46-89c8-343183b05b8f.xhtml),
    *CQRS - The Read Side*. That's because queries in an event sourced system are
    done differently. In this chapter, we are going to look at exactly that. By the
    end of the chapter, we'll have the working solution that we already implemented
    in [Chapter 10](75bc64ae-a642-42b2-a44a-05ae0cb2b750.xhtml), *Event Sourcing*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如我之前提到的，为了[第9章](6f50ee65-024a-4c46-89c8-343183b05b8f.xhtml)，*CQRS - 读取侧*，我从项目中移除了所有读取模型和与查询相关的代码。这是因为事件源系统中的查询是不同的。在本章中，我们将详细探讨这一点。到本章结束时，我们将拥有已经在[第10章](75bc64ae-a642-42b2-a44a-05ae0cb2b750.xhtml)，*事件源*中实现的工作解决方案。
- en: 'Throughout this chapter we are going to discuss the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: The issue of querying event streams
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询事件流的问题
- en: What are projections?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投影是什么？
- en: Projecting events to a document database
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将事件投影到文档数据库
- en: Projecting events to a relational database
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将事件投影到关系数据库
- en: Eventual consistency
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终一致性
- en: Events and queries
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件和查询
- en: One thing that I've heard many times when talking about event sourcing with
    developers who are new to this technique, is the claim that event sourcing is
    not suitable for reporting. Let's first define what reporting is. Normally, we
    think of it as the ability to retrieve the system state from the database on demand,
    using filters and grouping, with minimal latency. Relational databases are quite
    good for this purpose since this was the main reason that relational databases
    were invented in the first place. If you are old enough, you might remember a
    short period of hype around object databases (**ODBMSes**, short for** object-oriented
    database management system**) in the mid-1990s. What could be better than storing
    entire objects to a database, without taking care of the impedance mismatch? In
    a world that is largely dominated by different kinds of **relational database
    management systems** (**RDBMS**), it is hard to digest the fact that the first
    object database for **Massachusetts General Hospital Utility Multi-Programming
    System **(**MUMPS** or **M**), was created back in 1966\. However, the first prototype
    of a relational database, System R by IBM, was only in the works from 1974, and
    the first generally-available RDBMS was created by Oracle, which was released
    in 1979\. Exactly the same year, the M database by InterSystems came to light.
    Then, for decades, InterSystems became a major vendor of object databases and
    released Caché by the end of the 1990s, which was still based on many design ideas
    of MUMPS.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当与对事件源技术不太熟悉的开发者讨论事件源时，我多次听到的一个说法是事件源不适合用于报告。让我们首先定义一下什么是报告。通常，我们认为它是在需要时从数据库中检索系统状态的能力，使用过滤和分组，以最小的延迟。关系数据库非常适合这个目的，这也是关系数据库最初被发明的主要原因。如果你年纪足够大，你可能还记得20世纪90年代中期围绕对象数据库（**ODBMSes**，即**面向对象数据库管理系统**）的短暂炒作。还有什么比将整个对象存储到数据库中更好，而不必担心阻抗不匹配呢？在一个主要由各种**关系数据库管理系统**（**RDBMS**）主导的世界里，很难接受第一个用于**马萨诸塞州总医院多编程系统**（**MUMPS**或**M**）的对象数据库是在1966年创建的事实。然而，IBM的System
    R关系数据库的第一个原型直到1974年才开始工作，而第一个通用的RDBMS是由Oracle创建的，于1979年发布。正是在同一年，InterSystems的M数据库问世。然后，在接下来的几十年里，InterSystems成为对象数据库的主要供应商，并在20世纪90年代末发布了Caché，它仍然基于MUMPS的许多设计理念。
- en: So, why haven't object databases dominated the world by now? There are a number
    of opinions about this, but one thing we can be certain about is that object databases
    weren't optimized to query substantial amounts of data. Indexes in such databases
    were either automatic or client-based, and couldn't possibly cope with larger
    datasets. Object databases handle writes perfectly well, but weren't really able
    to perform efficient queries. That said, I have to admit that I am not an expert
    in object databases and the opinion here could just be speculation. Of course,
    another obvious reason is that in the 20^(th) century, disk space was a real issue.
    Third-level normalization of relational databases definitely helped to save precious
    space. Notice that the renaissance of document databases, which entertain similar
    ideas to object databases by storing the entire object graph as a single document,
    was only possible due to increasing computing power and cheaper storage when data
    duplication stopped being an issue.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么对象数据库至今没有主导世界呢？对此有许多观点，但我们可以肯定的是，对象数据库并没有针对查询大量数据进行优化。这类数据库中的索引要么是自动的，要么是基于客户端的，无法应对更大的数据集。对象数据库处理写操作非常出色，但并不真正能够执行高效的查询。尽管如此，我必须承认，我并不是对象数据库的专家，这里的观点可能只是推测。当然，另一个明显的理由是，在20世纪，磁盘空间确实是一个大问题。关系数据库的第三范式肯定有助于节省宝贵的空间。请注意，文档数据库的复兴，它通过将整个对象图存储为单个文档来承载与对象数据库类似的思想，只有在数据重复不再是问题时，才因为计算能力的提升和存储成本的降低而成为可能。
- en: The main reason for CQRS gaining momentum was the urge to handle reads and writes
    separately due to severe differences in optimization techniques for those much
    more distinct operations. For a third-level normalized relational database, writes
    are easy and reads are hard. Such a database schema can hardly cope with a significant
    transactional load, maintaining the ability to respond to complex queries at the
    same time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS获得动力的主要原因是因为由于读写操作优化技术的严重差异，迫切需要分别处理读和写。对于第三范式的关系数据库，写操作容易而读操作困难。这样的数据库模式几乎无法应对重大的事务负载，同时保持对复杂查询的响应能力。
- en: The same issue also applies to systems that use events as the source of truth,
    by storing business-defined events in an append-only fashion. In such systems,
    as we discussed in [Chapter 10](75bc64ae-a642-42b2-a44a-05ae0cb2b750.xhtml), *Event
    Sourcing*, we don't have direct access to the system state. In order to get the
    current state of any object in the system, we must read all events from a stream
    that represents that particular object, and apply all events from that stream
    to an empty object to allow the events flow through the logic of state transitions.
    Basically, the object is being reborn every time we read it. Now, imagine that
    we need to run a query over a few thousand, or hundreds of thousands of such objects.
    This would mean that we probably need to load the whole system in memory before
    we can ask it for any information that spans across a dataset that contains more
    than one object. Such a system would certainly never work.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的问题也适用于那些将事件作为真相来源的系统，通过以追加方式存储业务定义的事件。在这样的系统中，正如我们在[第10章](75bc64ae-a642-42b2-a44a-05ae0cb2b750.xhtml)“事件溯源”中讨论的那样，我们无法直接访问系统状态。为了获取系统中任何对象的状态，我们必须读取表示该特定对象的流中的所有事件，并将该流中的所有事件应用到空对象上，以便事件能够通过状态转换的逻辑流动。基本上，每次我们读取对象时，它就像是在重生。现在，想象一下，如果我们需要查询几千个或几十万个这样的对象。这意味着我们可能需要在询问任何跨越包含多个对象的数据库集的信息之前，将整个系统加载到内存中。这样的系统肯定无法正常工作。
- en: This is why CQRS is something that you can find in nearly every event-sourced
    system. Of course, there are systems that people call event-sourced, which continuously
    update the system state in an alternative database, for example, a relational
    database, at the same time as system-produced events. Sometimes, this happens
    in memory, or in one transaction if events are stored in the same database as
    the system state snapshot. In such a system, you usually find that events are,
    in fact, barely used for anything. Instead of loading an object from events, the
    application service would just get the latest object state from the snapshot database.
    It is a bit of a stretch to say that events are the source of truth in a system
    like this, as we won't be looking at this kind of scenario. At the same time,
    the techniques that you'll learn from this chapter might sound very similar to
    this, and I will do my best to explain the core differences.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么CQRS几乎可以在每个事件源系统中找到。当然，有些人称之为事件源的系统，它们在更新系统状态的同时，在另一个数据库（例如关系数据库）中持续更新系统状态，同时生成系统事件。有时，这发生在内存中，或者如果事件存储在系统状态快照相同的数据库中，则在一个事务中。在这样的系统中，你通常会发现在实际上几乎不使用事件。应用程序服务不会从事件中加载对象，而是直接从快照数据库中获取最新的对象状态。在这样一个系统中说事件是真相的来源有点牵强，因为我们不会查看这种场景。同时，你将从本章中学到的技术听起来可能非常相似，我会尽力解释核心差异。
- en: Building read models from events
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从事件构建读取模型
- en: We are already familiar with read models from [Chapter 10](75bc64ae-a642-42b2-a44a-05ae0cb2b750.xhtml), *Event
    Sourcing*. We understand that the read-write model is common for many systems
    that we build, and sometimes it is beneficial to use different models to persist
    the system state and to retrieve data that we need to show on the screen or give
    away to other parties using the API. For event-sourced systems, we must use different
    models because, as previously discussed, event streams aren't optimized to retrieve
    the current state of the system and apply filters on it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从[第10章](75bc64ae-a642-42b2-a44a-05ae0cb2b750.xhtml)中熟悉了读取模型，即*事件溯源*。我们了解到，读取-写入模型对于许多我们构建的系统来说是常见的，有时使用不同的模型来持久化系统状态和检索我们需要在屏幕上显示或通过API提供给其他方的数据是有益的。对于事件源系统，我们必须使用不同的模型，因为，如前所述，事件流并没有针对检索系统当前状态并对其应用过滤器进行优化。
- en: Therefore, we will need to create read models for our system somewhere else;
    for instance, in data storage that supports such queries with ease. Here, we are
    free to choose what we use. We could use a document database, a relational database,
    maybe even a filesystem, or a combination of all of the aforementioned methods.
    However, how can we build such read models? Well, we already defined that the
    state of our system is derived from all those events we store when any state transition
    occurs. This could give us the idea that we also need to use events to build read
    models. We will be using projections to derive the state of our read models from
    the stream of events that our system produces.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将在其他地方创建我们的系统读取模型；例如，在支持此类查询的数据存储中。在这里，我们可以自由选择使用什么。我们可以使用文档数据库、关系数据库，甚至文件系统，或者上述所有方法的组合。然而，我们如何构建这样的读取模型呢？好吧，我们已经定义了我们的系统状态是从我们存储的所有事件中派生出来的。这可能会给我们这样的想法，即我们还需要使用事件来构建读取模型。我们将使用投影从我们的系统产生的事件流中推导出读取模型的状态。
- en: Projections
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投影
- en: In relational algebra, a projection is a unary operation, written as ![](img/929a4a4e-9f8c-46b6-9052-8804f1cac8d7.png),where ![](img/b8bae4f3-c984-4bc1-8aba-ba97b40022bb.png) is
    a tuple, and ![](img/b4fa0694-a2da-4d7b-af93-6e1156ca60c5.png) are the attribute
    names for ![](img/b8daf2af-6577-41b7-a925-ddc45814b701.png). When such an operation
    is executed, it returns a set that only includes the specified attributes, and
    all other attributes are discarded.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系代数中，投影是一个一元运算，表示为 ![](img/929a4a4e-9f8c-46b6-9052-8804f1cac8d7.png)，其中 ![](img/b8bae4f3-c984-4bc1-8aba-ba97b40022bb.png) 是一个元组，而 ![](img/b4fa0694-a2da-4d7b-af93-6e1156ca60c5.png) 是 ![](img/b8daf2af-6577-41b7-a925-ddc45814b701.png) 的属性名。当执行此运算时，它返回一个只包含指定属性的集合，并丢弃所有其他属性。
- en: 'If this sounds too complicated, we can explicitly represent a projection as
    a SQL query. Consider a `People` table with the following structure and data:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来太复杂，我们可以将投影明确表示为SQL查询。考虑一个具有以下结构和数据的`People`表：
- en: '| **Id** | **FirstName** | **LastName** | **City** | **Country** |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **Id** | **FirstName** | **LastName** | **City** | **Country** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `1` | `John` | `Smith` | `Bristol` | `United Kingdom` |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `John` | `Smith` | `Bristol` | `United Kingdom` |'
- en: '| `2` | `Jorrit` | `Bramsma` | `Eindhoven` | `The Netherlands` |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `2` | `Jorrit` | `Bramsma` | `Eindhoven` | `The Netherlands` |'
- en: '| `3` | `Jan Tore` | `Rosendal` | `Alta` | `Norway` |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `3` | `Jan Tore` | `Rosendal` | `Alta` | `Norway` |'
- en: 'If we execute the `SELECT FirstName, LastName FROM People` query, we effectively
    execute a projection. We specify two attributes to be included in the result set—`FirstName`
    and `LastName`, so that we get a result as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行`SELECT FirstName, LastName FROM People`查询，我们实际上执行了一个投影。我们指定了要包含在结果集中的两个属性——`FirstName`和`LastName`，因此我们得到以下结果：
- en: '| FirstName | LastName |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 首名 | 姓氏 |'
- en: '| --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `John` | `Smith` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `John` | `Smith` |'
- en: '| `Jorrit` | `Bramsma` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `Jorrit` | `Bramsma` |'
- en: '| `Jan Tore` | `Rosendal` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `Jan Tore` | `Rosendal` |'
- en: All other attributes are discarded. Notice that we don't include any filtering
    in the query. Filtering is called **selection** and indeed, in most of the cases,
    a SQL query combines both projection and selection to produce a concise set of
    data that we are interested in. You will have already noticed that we used projections
    in [Chapter 10](75bc64ae-a642-42b2-a44a-05ae0cb2b750.xhtml), *Event Sourcing*, when
    we were retrieving a subset of attributes from a larger dataset of the whole system
    state, to be used for queries.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他属性都被丢弃。请注意，我们在查询中不包括任何过滤。过滤被称为**选择**，确实，在大多数情况下，SQL查询结合了投影和选择，以生成我们感兴趣的一组简洁数据。您可能已经注意到，我们在[第10章](75bc64ae-a642-42b2-a44a-05ae0cb2b750.xhtml)“事件溯源”中使用了投影，当我们从整个系统状态的大数据集中检索属性子集以用于查询时。
- en: The process of building a piece of state from events is also called a **projection**,
    although we can't say that it operates on a single set where we choose a number
    of attributes that we want to project. However, we will need to project a subset
    of the whole event stream. Our read models also need to be updated as quickly
    as possible, but we only commit events to the store. It implies that we need to
    read all of these events as soon as they are committed, and project them. Usually,
    this is done either by polling the Event Store or by using a real-time subscription
    if the store supports it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从事件构建状态片段的过程也被称为**投影**，尽管我们无法说它在一个单集中操作，在那里我们选择要投影的属性数量。然而，我们需要投影整个事件流的一个子集。我们的读取模型也需要尽可能快地更新，但我们只提交事件到存储。这意味着我们需要在事件提交后立即读取所有这些事件并将它们投影。通常，这是通过轮询事件存储或使用存储支持的实时订阅来完成的。
- en: 'The process of building the read models from events using subscriptions and
    projections can be illustrated by the following diagram:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用订阅和投影从事件构建读取模型的过程可以用以下图表来说明：
- en: '![](img/6b7f33f2-e35b-4960-8eb1-12f3df79a60c.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b7f33f2-e35b-4960-8eb1-12f3df79a60c.png)'
- en: The command to read-model flow
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 读取模型的命令流
- en: When we execute a command, our aggregate is fully loaded from the aggregate
    stream by the application service. The aggregate then generates a new event (or
    several events) that represent the state transitions of the aggregate. Those events
    are committed to the store, so the store appends them to the end of the aggregate
    stream. A subscription receives these events and updates its read models.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行一个命令时，应用服务会从聚合流中完全加载我们的聚合。然后，聚合生成一个新的事件（或多个事件），代表聚合的状态转换。这些事件被提交到存储中，因此存储将它们追加到聚合流的末尾。订阅会接收这些事件并更新其读取模型。
- en: 'This was the code from our aggregate class:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们聚合类的代码：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we update the state of our `UserProfile` aggregate with each new event.
    Now, it is time to make a confession—this is also a projection. In this code,
    we project events that the `When` method receives to update the properties of
    our `UserProfile` object. There's nothing more to say about projections and I
    can conclude the chapter!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过每个新事件更新我们的`UserProfile`聚合的状态。现在，是时候坦白一下了——这同样也是一个投影。在这段代码中，我们将`When`方法接收的事件投影到更新我们的`UserProfile`对象的属性。关于投影，没有更多要说的，我可以结束这一章了！
- en: Jokes aside, we still have work to do. First of all, we need to find out how
    our read-model projections will receive new events.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 开个玩笑，我们还有很多工作要做。首先，我们需要弄清楚我们的读取模型投影将如何接收新事件。
- en: Subscriptions
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅
- en: Imagine our users are looking at a screen where they see the user interface
    for our marketplace. We already know how to let people execute operations. When
    a user does something, we send a `POST` or `PUT` request to the API. In turn,
    the API controller calls the application service and the command gets executed.
    The result of this would be either a `200 OK` response for a completed command
    or an error if something goes wrong. However, unlike a single-database system,
    where the data that we query is the same data on which we execute our commands,
    for an event-sourced application, this is not the case. Our read model is most
    probably located in a different database. This fact makes all of our queries eventually
    consistent. We will discuss this topic later in this book when we explore more
    advanced topics around event sourcing.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们的用户正在查看一个屏幕，他们可以看到我们市场的用户界面。我们已经知道如何让人们执行操作。当用户做某事时，我们向 API 发送 `POST`
    或 `PUT` 请求。然后，API 控制器调用应用程序服务，并执行命令。结果可能是对完成命令的 `200 OK` 响应，或者如果出现问题，则返回错误。然而，与单数据库系统不同，在那里我们查询的数据是我们执行命令的数据，对于事件源应用程序来说，情况并非如此。我们的读取模型很可能位于不同的数据库中。这个事实使得我们所有的查询最终都是一致的。我们将在本书的后续章节中讨论这个主题，当我们探索更多关于事件源的高级主题时。
- en: For now, we need to understand that our goal will be to minimize the time gap
    between the moment when an event is appended to the stream and the moment the
    read model gets updated. During the time between these two operations, the data
    that we show to the user is stale. Stale doesn't mean inconsistent, it is just
    not exactly up to date, and after a small delay, the query will eventually return
    more actual data. Mind the gap!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要理解我们的目标将是最小化事件附加到流和读取模型更新之间的时间间隔。在这两个操作之间，我们向用户展示的数据是过时的。过时并不意味着不一致，它只是不是完全最新的，经过一小段时间的延迟后，查询最终会返回更多实际数据。注意差距！
- en: To minimize the time gap, we need to ensure that our projections receive new
    events in real time. Event Store can help here since it has a very nice subscriptions
    feature. There are two types of subscriptions in the Event Store—catch-up and
    persistent subscriptions, also known as **competing consumers**. The main difference
    is the **checkpoint** ownership. One more term for me to throw on you in this
    chapter!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最小化时间间隔，我们需要确保我们的投影能够实时接收新事件。Event Store 可以在这里提供帮助，因为它有一个非常不错的订阅功能。在 Event
    Store 中有两种类型的订阅——追赶订阅和持久订阅，也称为**竞争消费者**。主要区别是**检查点**的所有权。在这一章中，我还要向你介绍一个新术语！
- en: A checkpoint is a specific position in the stream. As the projection has processed
    one event, it can store the checkpoint, so if the projection gets restarted, it
    will know where to start the processing and not project all events from the beginning
    of life. The concept of checkpoints is well-known in all systems that deal with
    real-time event processing, such as Kafka or Azure Event Hub.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 检查点是在流中的特定位置。当投影处理了一个事件后，它可以存储检查点，所以如果投影被重新启动，它将知道从哪里开始处理，而不是从生命的开始就投影所有事件。检查点的概念在所有处理实时事件处理的系统中都是众所周知的，例如
    Kafka 或 Azure Event Hub。
- en: If you decide to use some other product to store your events, you need to find
    out if it is possible to make real-time, or almost real-time subscriptions to
    the store and what you can use as the checkpoint. For example, you can use a SQL
    Server table to store events and use the auto-increment primary identity as the
    stream position. Then, you can continuously poll this table for new events and
    by doing that you will have a working subscription.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定使用其他产品来存储你的事件，你需要弄清楚是否可以对该存储进行实时或几乎实时的订阅，以及你可以使用什么作为检查点。例如，你可以使用 SQL Server
    表来存储事件，并使用自动增长的唯一主键作为流位置。然后，你可以持续轮询这个表以获取新事件，通过这样做，你将拥有一个工作的订阅。
- en: Checkpoints are unique to read models. I cited the code of the preceding `UserProfile.When`
    method and mentioned that it does what projections do as well. While that's true,
    for an aggregate instance, the `When` method is executed for all events of a single
    aggregate when we read the aggregate stream from the store before executing a
    command. Again, we read all the events from a single stream and call the `When`
    method for each event we get from the store. It's not hard. Projections, however,
    update their models continuously.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 检查点是读取模型独有的。我引用了前面`UserProfile.When`方法的代码，并提到它也执行投影的工作。虽然这是真的，但对于聚合实例，当我们从存储中读取聚合流并在执行命令之前读取聚合流时，`When`方法会为单个聚合的所有事件执行。再次强调，我们读取单个流中的所有事件，并为从存储中获取的每个事件调用`When`方法。这并不难。然而，投影会持续更新它们的模型。
- en: 'We could not allow ourselves to read all events from the whole store for each
    update, as this would defeat the purpose of having read models. Let''s have a
    look at how read models listen to new events that come to the store:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能允许自己在每次更新时都从整个存储中读取所有事件，因为这会违背拥有读取模型的目的。让我们看看读取模型是如何监听存储中到来新事件的：
- en: '![](img/90f192d0-af21-4b74-ae42-25a48d76f9de.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/90f192d0-af21-4b74-ae42-25a48d76f9de.png)'
- en: The read model is updated by new events
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 读取模型通过新事件进行更新
- en: For example, if our **"My Ads"** **projection** gets an `AdRenamed` event and
    starts updating its read model, something happens—something such as a network
    failure, a database failure, or someone powering off the machine where the projection
    was running. Somehow, after the issue is fixed, the projection itself needs to
    figure out which position it needs to start reading events to continue updating
    its read model. For the case I just described, we need to keep the number **3** somewhere
    after we successfully projected the `AdPublished` event. So, when our service
    restarts and the projection kicks in, it needs to start reading event number **4**,
    ignoring everything that happened before. By storing this number, we are establishing
    a checkpoint. Our projection takes responsibility for keeping its own checkpoint
    somewhere. The checkpoint is only updated when a new event has been successfully
    projected, so we guarantee that each event is projected at least once.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们的**“我的广告”****投影**接收到一个`AdRenamed`事件并开始更新其读取模型，会发生一些事情——比如网络故障、数据库故障，或者有人关闭了运行投影的机器的电源。在问题解决后，投影本身需要找出它需要从哪个位置开始读取事件以继续更新其读取模型。对于我刚才描述的情况，我们需要在成功投影`AdPublished`事件后，将数字**3**保存在某个地方。因此，当我们的服务重新启动并且投影启动时，它需要从事件编号**4**开始读取，忽略之前发生的一切。通过存储这个数字，我们正在建立一个检查点。我们的投影负责将其自己的检查点保存在某个地方。只有当新事件成功投影后，检查点才会更新，所以我们保证每个事件至少被投影一次。
- en: There are two ways to store the checkpoint—via a client-based checkpoint or
    a server-based checkpoint. We can logically conclude that a client-based checkpoint
    is maintained and stored by the client (subscription), and when using a server-based
    variant, the Event Store is responsible for this instead.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 存储检查点有两种方式——通过基于客户端的检查点或基于服务器的检查点。我们可以逻辑上得出结论，基于客户端的检查点由客户端（订阅）维护和存储，而在使用基于服务器的变体时，事件存储负责这项工作。
- en: In Apache Kafka, the term *offset* is used for the same concept and, by default,
    the offset is maintained by the server.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在Apache Kafka中，术语*偏移量*用于相同的概念，并且默认情况下，偏移量由服务器维护。
- en: A server-based checkpoint feature enables us to run multiple instances of the
    event consumer (a projection, in our case) and each consumer will get a portion
    of events. This concept is widely known in the messaging world. All message brokers
    support a similar pattern, which is called **competing consumers**. This pattern
    allows us to scale the process of handling messages (or events) easily, but the
    main issue here is that the order in which messages are processed cannot be guaranteed
    for competing consumers. That's easy to explain. Message-processing time cannot
    be fully predictable, as some glitches always happen in the network, and even
    on the machine where processes share computing and disk resources with other processes.
    As a result, the time needed to process one message can vary between different
    consumers, and even between identical messages for the same consumers. If we have
    multiple consumers that compete for messages, we will almost certainly get into
    a situation where one consumer has finished processing an event, *E[n]*, while
    another consumer is still busy processing the *E*[*n+1*] event. The free consumer
    then starts processing the E[n+2] event before the processing of the *E*[*n+1*] event
    has even finished. Clearly, there is no ordering guarantee here. For projections,
    processing events in order are absolutely crucial. If two renames are executed
    one after another, we want the second update to be applied to the read model after
    the first one, with no exceptions. It is, however, not necessary to use competing
    consumers when using server-maintained checkpoints. If you have one single subscriber
    for the persistent subscription, it will receive events in order.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 基于服务器的检查点功能使我们能够运行多个事件消费者（在我们的例子中是投影）的实例，每个消费者都将获得事件的一部分。这个概念在消息传递世界中广为人知。所有消息代理都支持类似的模式，这被称为**竞争消费者**。这种模式允许我们轻松扩展处理消息（或事件）的过程，但这里的主要问题是无法保证竞争消费者处理消息的顺序。这很容易解释。消息处理时间无法完全预测，因为网络中总是会发生一些故障，甚至在与其他进程共享计算和磁盘资源的机器上。因此，处理一条消息所需的时间在不同消费者之间可能会有所不同，甚至在相同消费者对相同消息的处理中也是如此。如果我们有多个竞争消息的消费者，我们几乎肯定会遇到一种情况，其中一个消费者已经完成处理事件E[n]，而另一个消费者仍在忙于处理事件E[n+1]。然后，空闲的消费者在处理E[n+1]事件甚至尚未完成之前就开始处理E[n+2]事件。显然，这里没有顺序保证。对于投影来说，按顺序处理事件至关重要。如果连续执行两次重命名，我们希望第二个更新在第一个更新之后应用于读取模型，没有任何例外。然而，在使用服务器维护的检查点时，没有必要使用竞争消费者。如果您只有一个持久订阅的单一订阅者，它将按顺序接收事件。
- en: When the client maintains their own checkpoint, things become easier and harder
    at the same time. If we control the checkpoint, we can easily reset or move it.
    For projections, this means that we can easily rebuild the read model by resetting
    the checkpoint and removing the existing data. This process is called **replay**
    and it is, in fact, one of the most powerful features of event sourcing. The harder
    part is that we need to store the checkpoint somewhere and update it every time
    the projection processes a new event. The best practice here is that the checkpoint
    is stored in the same place (that is, the database) as the read model itself.
    Remember about replay? If we kill the database where our read model is stored,
    the checkpoint will be gone at once; and, if we run the projection again, it will
    start processing events from the zero position and eventually, the read model
    will be rebuilt from the ground up!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端维护自己的检查点时，事情变得既容易又困难。如果我们控制检查点，我们可以轻松地重置或移动它。对于投影，这意味着我们可以通过重置检查点并删除现有数据来轻松重建读取模型。这个过程被称为**重放**，实际上，这是事件源中最强大的功能之一。更困难的部分是我们需要将检查点存储在某个地方，并且每次投影处理新事件时都要更新它。这里的最佳实践是将检查点存储在与读取模型本身相同的地方（即，数据库）。记住关于重放的事情吗？如果我们杀死了存储我们的读取模型的数据库，检查点将立即消失；如果我们再次运行投影，它将从头开始处理事件，最终，读取模型将从零开始重建！
- en: So, in this book, we will use real-time subscriptions with checkpoints that
    are maintained by the client. In Event Store, such subscriptions are called **catch-up
    subscriptions**. Why catch-up? It's easy to guess. Remember replay? No, I am not
    repeating myself. In case we want or need to rebuild the read model and kill both
    its data and its checkpoint, the projection will subscribe to the stream of events,
    starting with the zero position. Until it processes all historical events, it
    will not be consuming any new events. Only when the projection eventually catches
    up with the end of the stream, will we be able to switch it to process new events
    in real time. Event Store does this automatically and that's why we call it a
    catch-up subscription. Using this type of subscription allows us to add new projections
    and build new read models, even for a system that is in production for quite some
    time and has a lot of events. Our new projection will catch-up on all those historical
    events, switch to real-time processing, and, from that moment on, our new read
    model will be usable.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这本书中，我们将使用由客户端维护的实时订阅和检查点。在事件存储中，这种订阅被称为**追赶订阅**。为什么叫追赶订阅？很容易猜到。还记得重放吗？不，我不是在重复自己。如果我们想要或需要重建读取模型并删除其数据和检查点，投影将订阅事件流，从零位置开始。直到它处理完所有历史事件，它将不会消费任何新事件。只有当投影最终赶上流末尾时，我们才能将其切换到实时处理新事件。事件存储会自动完成这项工作，这就是为什么我们称之为追赶订阅。使用这种类型的订阅，我们可以为已经运行了一段时间并且有很多事件的系统添加新的投影和构建新的读取模型。我们的新投影将赶上所有这些历史事件，切换到实时处理，从那时起，我们的新读取模型将可用。
- en: Implementing projections
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现投影
- en: Now it is time to start writing some code. We will use the final code of [Chapter
    9](6f50ee65-024a-4c46-89c8-343183b05b8f.xhtml), *CQRS - The Read Side**,* as the
    starting point. The final code for this chapter is located in the GitHub repository,
    in the `Chapter11` folder.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始编写一些代码了。我们将使用[第9章](6f50ee65-024a-4c46-89c8-343183b05b8f.xhtml)的最终代码，*CQRS
    - 读取侧*作为起点。这一章的最终代码位于GitHub仓库的`Chapter11`文件夹中。
- en: We will go step by step and start by implementing one subscription just to see
    how subscriptions work in the Event Store. Then, we will create a few real read
    models using both RavenDB and PostgreSQL.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一步一步来，首先实现一个订阅，以便了解在事件存储中订阅是如何工作的。然后，我们将使用 RavenDB 和 PostgreSQL 创建几个真实的读取模型。
- en: Catch-up subscriptions
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 追赶订阅
- en: In fact, to start making projections, we don't need any databases. I will show
    you a simple trick that allows you to go on with the initial development quickly,
    without any thoughts about the database engine that will be used to store read
    models. Very often, we don't really know what real life will bring us, and the
    database engine that we might have planned to use at the start might not be even
    suitable for the job we want to do. During the early stages of any project, the
    number of events we are working with is not significant, unless we want to put
    some synthetic tests on the system, or we are working with a high-frequency event-processing
    system. In our case, we deal with a rather simple classified ads website, so we
    don't expect a lot of events in the development environment and even in the system
    that we'd like to show to product owners and QA.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，要开始制作投影，我们不需要任何数据库。我将向您展示一个简单的技巧，它允许您快速进行初始开发，而不必考虑将用于存储读取模型的数据库引擎。我们往往真的不知道现实生活会带来什么，我们最初计划使用的数据库引擎可能甚至不适合我们想要完成的任务。在任何项目的早期阶段，我们处理的事件数量并不大，除非我们想在系统中进行一些合成测试，或者我们正在处理一个高频事件处理系统。在我们的情况下，我们处理的是一个相当简单的分类广告网站，所以我们不期望在开发环境中以及我们希望向产品所有者和QA展示的系统中有很多事件。
- en: What can we do to keep things really simple? Well, if the source of truth for
    our system is in the Event Store, why do we need to persist read models somewhere?
    It would be perfectly fine to keep them in memory and rebuild each time our application
    starts. That's exactly what we are going to do.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能做些什么来使事情保持非常简单？嗯，如果我们的系统的事实来源在事件存储中，为什么我们需要在某个地方持久化读取模型？将它们保存在内存中并在每次应用程序启动时重建是完全可行的。这正是我们打算做的。
- en: 'First, I want to use the code for [Chapter 9](6f50ee65-024a-4c46-89c8-343183b05b8f.xhtml),
    *CQRS - The Read Side**,* as the starting point. Remember, it has no queries and
    no read models. To bring these things in, I copy some code files from [Chapter
    10](75bc64ae-a642-42b2-a44a-05ae0cb2b750.xhtml), *Event Sourcing,* and make minimal
    changes to minimize the work. So, I take only read models and queries from the
    `ClassifiedAd` folder of the main application project. Then, I remove some queries
    from the `Queries` file, because I only want to implement one to begin with. My
    new `Queries` class now looks like the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我想使用[第9章](6f50ee65-024a-4c46-89c8-343183b05b8f.xhtml)，*CQRS - 读取侧*的代码作为起点。记住，它没有查询和读取模型。为了引入这些内容，我从[第10章](75bc64ae-a642-42b2-a44a-05ae0cb2b750.xhtml)，*事件溯源*中复制了一些代码文件，并进行了最小修改以减少工作量。因此，我只从主应用程序项目的`ClassifiedAd`文件夹中提取读取模型和查询。然后，我从`Queries`文件中删除了一些查询，因为我最初只想实现一个。我的新`Queries`类现在看起来如下所示：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can see that I don't use any database connection here. Instead, the extension
    method is applied to a simple `IEnumerable`, so this implies that I will be using
    a collection of items in memory.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，我这里没有使用任何数据库连接。相反，扩展方法被应用于一个简单的`IEnumerable`，这意味着我将使用内存中的项目集合。
- en: 'Then, I also need to remove API endpoints that won''t be used and keep only
    one of them. Also, I need to replace the database connection with `IEnumerable`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我还需要移除不会使用的API端点，只保留其中一个。此外，我需要将数据库连接替换为`IEnumerable`：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notice that the `Get` method is not `async` anymore, because operations on
    collections are synchronous. Definitely, when we introduce some proper persistence,
    we would need to bring `async` back. Because of this change, I also need to change
    the `RequestHandler.HandleQuery` method so it will accept `Action` instead of
    `Func`, because we don''t need to return `Task` for now:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`Get`方法不再`async`了，因为集合上的操作是同步的。当然，当我们引入适当的持久化时，我们需要将`async`重新引入。由于这个变化，我还需要更改`RequestHandler.HandleQuery`方法，使其接受`Action`而不是`Func`，因为我们现在不需要返回`Task`：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'From [Chapter 9](6f50ee65-024a-4c46-89c8-343183b05b8f.xhtml), *CQRS - The Read
    Side**,* we have the `EsAggregateStore` class. It has some code that helps us
    to deserialize a resolved event that comes from the Event Store. We also need
    to do the same operation in our projection. Therefore, I take this code out to
    an extension method for the `ResolvedEvent` class, so that we can use the same
    code in projections:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第9章](6f50ee65-024a-4c46-89c8-343183b05b8f.xhtml)，*CQRS - 读取侧*，我们有`EsAggregateStore`类。它有一些代码帮助我们反序列化来自事件存储的已解析事件。我们还需要在我们的投影中执行相同的操作。因此，我将这段代码提取到一个扩展方法中，用于`ResolvedEvent`类，这样我们就可以在投影中使用相同的代码：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you remember, we keep the **fully qualified class name** (**FQCN**) of the
    event class in the event metadata, and `EventDeserialzier` uses it to get our
    domain event back. I also remove this code from `EsAggregateStore` to avoid duplication,
    so the `Load` method will look as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所记，我们在事件元数据中保留事件类的**完全限定类名**（**FQCN**），`EventDeserialzier`使用它来获取我们的领域事件。我还从`EsAggregateStore`中移除了这段代码，以避免重复，因此`Load`方法将如下所示：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, let's do the actual subscription. It will live in a new class that I'll
    place in the `infrastructure` folder. It will be handling a single read model,
    so it is not generic in any way and doesn't really belong there. However, this
    solution is not permanent and we will make it better a bit later.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进行实际的订阅。它将存在于一个新类中，我将将其放置在`infrastructure`文件夹中。它将处理单个读取模型，因此它不是通用的，实际上也不应该放在那里。然而，这个解决方案不是永久的，我们稍后会对其进行改进。
- en: 'For this class, I need an instance of `IEventStoreConnection`, so that I can
    create a subscription to it. I also need a reference to the read models collection,
    so I can put items in it and change the properties of the existing items. The
    class will have two simple methods—`Start` and `Stop`. The `Start` method creates
    a new subscription. Events will immediately start coming in, so the connection
    must be started before I can subscribe to it. Here is the code for the `Start`
    method:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个类，我需要一个`IEventStoreConnection`的实例，这样我才能创建对其的订阅。我还需要对读取模型集合的引用，这样我就可以在其中放置项目并更改现有项目的属性。该类将有两个简单的方法——`Start`和`Stop`。`Start`方法创建一个新的订阅。事件将立即开始到来，因此我必须先启动连接才能订阅它。以下是`Start`方法的代码：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There are some hard coded values here, which we will be reading from the application
    configuration later. The important line is where we subscribe. The method that
    I use is `SubscribeToAllFrom`. This method creates a subscription that will get
    all events that are persisted in the Event Store. The first parameter is where
    the subscription starts. Since our read model is not persisted and we will be
    rebuilding it from scratch every time the application starts, we must read it
    from the very beginning because that's why the parameter is getting `Position.Start`.
    The last parameter is a delegate, which will be called for each event that we
    receive from the subscription; we'll get back to it shortly.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些硬编码的值，我们稍后将从应用程序配置中读取。重要的行是我们订阅的地方。我使用的方法是`SubscribeToAllFrom`。这个方法创建了一个订阅，将获取所有保存在事件存储中的事件。第一个参数是订阅的起始位置。由于我们的读取模型没有持久化，并且每次应用程序启动时我们都会从头开始重建它，我们必须从开始读取，因为这就是为什么参数是`Position.Start`。最后一个参数是一个委托，它将为每个我们从订阅中接收的事件被调用；我们稍后会回到它。
- en: 'The `Stop` method is very simple, it just stops the subscription, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stop`方法非常简单，它只是停止订阅，如下所示：'
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, let's create some code for the `EventAppeared` method. There, we will be
    building our read model, and, as I previously mentioned, the code will be handling
    the same domain events that we are handling in the `When` method of our aggregates,
    in a very similar fashion.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为`EventAppeared`方法编写一些代码。在那里，我们将构建我们的读取模型，正如我之前提到的，代码将以非常相似的方式处理我们在聚合体的`When`方法中处理的相同领域事件。
- en: 'Before we can use advanced pattern-matching, we need to get the domain event
    from the `ResolvedEvent` class instance that our `EventAppeared` receives as a
    parameter. Here is the beginning of this method:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用高级模式匹配之前，我们需要从`ResolvedEvent`类实例中获取领域事件，这个实例是`EventAppeared`方法接收的参数。以下是这个方法的开头部分：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first line will get the domain event, then we use pattern-matching to make
    necessary changes in the read model. The first case will create a new read model
    for each new classified ad, and the second case will update the title.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将获取领域事件，然后我们使用模式匹配在读取模型中进行必要的更改。第一种情况将为每个新的分类广告创建一个新的读取模型，第二种情况将更新标题。
- en: This code is fine, but it won't work, because, as I mentioned before, when we
    subscribe using `SubscribeToAllFrom`, we will get all the events. These events
    are coming from the `$all` stream. But the Event Store uses events for its own
    internal operations, so we will also get many events of that kind. Luckily, we
    can easily identify events that we don't need by the value of the `resolvedEvent.Event.EventType`
    property. All technical events that have the `stat` event type start with the
    dollar (`$`) sign, so we can filter them out.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是好的，但不会工作，因为我之前提到，当我们使用`SubscribeToAllFrom`进行订阅时，我们将获取所有事件。这些事件来自`$all`流。但事件存储使用事件进行其内部操作，因此我们也会收到很多这种类型的事件。幸运的是，我们可以通过`resolvedEvent.Event.EventType`属性的值轻松识别我们不需要的事件。所有具有`stat`事件类型的技术事件都以美元符号（`$`）开头，因此我们可以过滤掉它们。
- en: One last thing to note for this class is that I use the `UpdateItem` method
    to simplify updates for existing items.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个类来说，还有一个需要注意的最后一点，我使用`UpdateItem`方法来简化现有项目的更新。
- en: 'Here is the full code for the `EsSubscription` class:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`EsSubscription`类的完整代码：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Ideally, we'd need to wrap the deserialization call in a `try`-`catch` block,
    because we might get some events that we don't know about and it will cause our
    projection to break ungracefully. But again, we'll be making lots of changes in
    the code later on. Let's move on to the wiring part and try things out.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们需要将反序列化调用包裹在`try`-`catch`块中，因为我们可能会遇到一些我们不知道的事件，这会导致我们的投影不优雅地中断。但同样，我们稍后会在代码中做出很多更改。让我们继续到连接部分，尝试一下。
- en: 'We must ensure that our subscription starts after the Event Store connection
    do indeed connect to the store. Right now, this operation happens in the `HostedService`
    class. Since it only handles the Event Store connection business, I will rename
    it to the `EventStoreService`. I also add the `EsSubscription` instance to its
    constructor, so we can start a subscription as soon as we connect. Here, you can
    see how this class looks after all those changes:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保我们的订阅在事件存储连接确实连接到存储之后开始。目前，这个操作发生在`HostedService`类中。由于它只处理事件存储连接业务，我将它重命名为`EventStoreService`。我还向其构造函数添加了`EsSubscription`实例，这样我们就可以在连接后立即开始订阅。在这里，你可以看到这个类在所有这些更改之后的样子：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the `Startup` class, I need to change the registrations and also create
    our fake storage instance (remember, that''s just a collection). So, I change
    the code that registers the hosted service and add a couple of lines to that block
    of the `Startup.ConfigureServices` method:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Startup`类中，我需要更改注册并创建我们的模拟存储实例（记住，那只是一个集合）。所以我更改了注册托管服务的代码，并在`Startup.ConfigureServices`方法的那个代码块中添加了几行：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We need to register the items collection, because our query API controller needs
    it to be injected by the service provider, as a constructor parameter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要注册项目集合，因为我们的查询API控制器需要服务提供者通过构造函数参数将其注入。
- en: 'One thing that we haven''t done in [Chapter 9](6f50ee65-024a-4c46-89c8-343183b05b8f.xhtml),
    *CQRS - The Read Side**,* is that despite us using Serilog for all of the logging,
    it was never initialized in the chapter code. We had nothing to log then really,
    but now it will be interesting to look at what we can log. So, I added a couple
    of lines at the beginning of the `Program.Main` method:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](6f50ee65-024a-4c46-89c8-343183b05b8f.xhtml)，*CQRS - 读取侧*中，我们还没有做的事情是，尽管我们使用了Serilog进行所有日志记录，但在章节代码中它从未被初始化。那时我们实际上没有什么可以记录的，但现在看看我们能记录什么将会很有趣。所以，我在`Program.Main`方法的开始处添加了几行代码：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Well, this is it. Now, if you have the same `docker-compose` running since
    [Chapter 9](6f50ee65-024a-4c46-89c8-343183b05b8f.xhtml), *CQRS - The Read Side**, *and
    have some data in it (you should have it if you followed along with the code of
    [Chapter 9](6f50ee65-024a-4c46-89c8-343183b05b8f.xhtml), *CQRS - The Read Side*),
    you can run the application and it will produce a kind of debug, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，就是这样。现在，如果你从[第9章](6f50ee65-024a-4c46-89c8-343183b05b8f.xhtml)，*CQRS - 读取侧*开始运行相同的`docker-compose`，并且其中有一些数据（如果你按照[第9章](6f50ee65-024a-4c46-89c8-343183b05b8f.xhtml)，*CQRS
    - 读取侧*的代码进行操作，你应该有这些数据），你可以运行应用程序，它将产生一种调试信息，如下所示：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you were working with [Chapter 10](75bc64ae-a642-42b2-a44a-05ae0cb2b750.xhtml), *Event
    Sourcing*, code for a while and the Event Store was running for many days, you
    might notice some delay between events that belong to different classified ads.
    This is simply because all of those technical events are being continuously produced
    by Event Store and we get all of them. We ignore these events but we still need
    to read them, get to the application, check the name, and so on. This takes time.
    On the preceding debug output, you can see the delay of about 30 seconds, which
    means I let Event Store run 24/7 on my machine and it took me a while to work
    in [Chapter 9](6f50ee65-024a-4c46-89c8-343183b05b8f.xhtml), *CQRS - The Read Side*!
    We don't really want to have this delay and luckily, Event Store sets a small
    **time-to-live** (**TTL**) value on these technical events. This means that, in
    theory, most of them should be deleted. However, events that are marked for deletion,
    aren't being cleaned up until we execute a scavenge operation. That's because
    removing events in real time would have a significant performance impact. Scavenging
    can be started from the Event Store UI by going to Admin, where you can press
    the Scavenge button at the top-right corner of the screen. After I scavenged my
    local store, the delay decreased to six seconds. But make no mistake, this happens
    once only when you start the application. All new events will be projected instantly.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经与[第10章](75bc64ae-a642-42b2-a44a-05ae0cb2b750.xhtml)，*事件溯源*相关的代码一起工作了一段时间，并且事件存储已经运行了好多天，你可能会注意到属于不同分类广告的事件之间存在一些延迟。这仅仅是因为所有这些技术事件都是由事件存储持续产生的，我们接收到了所有这些事件。我们忽略这些事件，但我们仍然需要读取它们，到达应用程序，检查名称等等。这需要时间。在先前的调试输出中，你可以看到大约30秒的延迟，这意味着我让事件存储在我的机器上24/7运行，我在[第9章](6f50ee65-024a-4c46-89c8-343183b05b8f.xhtml)，*CQRS
    - 读取侧*上花费了一些时间！我们并不真的希望有这种延迟，幸运的是，事件存储为这些技术事件设置了一个小的**生存时间**（**TTL**）值。这意味着理论上，大多数应该被删除。然而，标记为删除的事件，直到我们执行清理操作之前都不会被清理。这是因为实时删除事件会对性能产生重大影响。可以通过访问管理员界面并按屏幕右上角的清理按钮来从事件存储UI启动清理。在我清理了我的本地存储之后，延迟减少到了六秒。但不要误会，这只会发生一次，当你启动应用程序时。所有新的事件都将立即投影。
- en: 'Now, we can test our `GET` query endpoint to see if the projection actually
    worked. I will use the classified ad that I previously created when working on
    [Chapter 9](6f50ee65-024a-4c46-89c8-343183b05b8f.xhtml), *CQRS - The Read Side*.
    Here is the query result in Swagger:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以测试我们的`GET`查询端点，看看投影是否真正起作用。我将使用我在[第9章](6f50ee65-024a-4c46-89c8-343183b05b8f.xhtml)，*CQRS
    - 读取侧*工作时创建的分类广告。以下是Swagger中的查询结果：
- en: '![](img/5d977e9d-e006-4456-bb0f-c156e74f3d60.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5d977e9d-e006-4456-bb0f-c156e74f3d60.png)'
- en: The query retrieves data from the real model
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 查询从真实模型检索数据
- en: The first projection worked! However, we can see that we only projected the
    classified ad events, and therefore, the seller's display name is empty. We will
    be fixing it shortly.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个投影成功了！然而，我们可以看到，我们只投影了分类广告事件，因此卖家的显示名称为空。我们将很快修复这个问题。
- en: Cross-aggregate projections
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨聚合投影
- en: When people start doing event sourcing, one mistake that often happens is that
    developers try to get into the comfort zone of the persisted state of their aggregates
    as soon as they can. So, many interpret read models as a way to keep the aggregate
    state accessible in a query able store. I have done the same thing in the past,
    so you can trust me on that. For the purpose of keeping an aggregate state in
    some database, I used a nice feature of Event Store—internal projections. You
    can check the list of available internal projections by visiting the Projections
    page of the Event Store web UI. One of those projections is `$by-category`, which
    links all events to special category streams. For example, `$ce-ClassifiedAd`
    will contain all events for the `ClassifiedAd` aggregate. You can inspect it yourself
    by visiting `http://localhost:2113/web/index.html#/streams/$ce-ClassifiedAd`.
    and check the stream content (you need to ensure that `$by-category` projection
    is running). By creating a subscription for this stream you can, for example,
    build an aggregate snapshot. However, snapshots are not read models and normally
    should not be used as real models.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们开始尝试事件溯源时，经常会犯的一个错误是开发者尽可能快地试图进入他们聚合持久状态的舒适区。因此，许多人将读取模型视为在可查询存储中保持聚合状态可访问的一种方式。我过去也做过同样的事情，所以你可以相信我。为了在某个数据库中保持聚合状态，我使用了事件存储的一个不错特性——内部投影。你可以通过访问事件存储Web
    UI的投影页面来查看可用的内部投影列表。其中之一是`$by-category`，它将所有事件链接到特殊的类别流中。例如，`$ce-ClassifiedAd`将包含`ClassifiedAd`聚合的所有事件。你可以通过访问`http://localhost:2113/web/index.html#/streams/$ce-ClassifiedAd`来自行检查它（你需要确保`$by-category`投影正在运行）。通过为这个流创建一个订阅，例如，你可以构建一个聚合快照。然而，快照不是读取模型，通常不应作为真实模型使用。
- en: Read models always serve a certain purpose. As we were looking at CQRS in [Chapter
    9](6f50ee65-024a-4c46-89c8-343183b05b8f.xhtml), *CQRS - The Read Side**, *we were
    designing read models to answer specific queries. Often, we need some information
    on the screen, and therefore, we make a read model to get all the required information
    using one single query. Without CQRS, we might need to call several queries that
    would retrieve the state of several different types of entities from repositories,
    and combine the information at the API backend to one single response DTO. This
    is a common strategy when we use a **Backend For Frontend** (**BFF**) approach.
    With CQRS, however, we are free to choose what information to query, as soon as
    the query only works with entities from a single database. We will look into more
    complex scenarios when our system becomes a composition of multiple autonomous
    subsystems when we go through the topics of bounded contexts and microservices.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 读取模型总是服务于某个目的。当我们查看第9章[《CQRS - 读取侧》](6f50ee65-024a-4c46-89c8-343183b05b8f.xhtml)中的CQRS时，我们正在设计读取模型来回答特定的查询。通常，我们需要屏幕上的某些信息，因此我们创建一个读取模型，通过一个单一的查询获取所有所需的信息。没有CQRS，我们可能需要调用几个查询，这些查询会从存储库检索几种不同类型的实体的状态，并在API后端将信息组合成一个单一的响应DTO。当我们使用**后端为前端**（**BFF**）方法时，这是一种常见的策略。然而，有了CQRS，我们可以自由选择查询哪些信息，只要查询只与单个数据库中的实体一起工作。当我们讨论边界上下文和微服务主题时，我们将探讨系统成为多个自主子系统组合的更复杂场景。
- en: Projecting events from two aggregates
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从两个聚合中投影事件
- en: Now, let's think about creating read models that are similar to what we had
    in [Chapter 10](75bc64ae-a642-42b2-a44a-05ae0cb2b750.xhtml), *Event Sourcing*.
    We have already started with one of them and as you have seen in the preceding
    Swagger screenshot, the seller name is empty in the response we get. That's because
    the only events we're handling in our projection are the `ClassifiedAd` events.
    However, our store contains all events for the whole application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑创建类似于我们在第10章[《事件溯源》](75bc64ae-a642-42b2-a44a-05ae0cb2b750.xhtml)中拥有的读取模型。我们已经开始了其中之一，正如你在前面的Swagger截图中所看到的，我们得到的响应中的卖家名称为空。这是因为我们处理投影中的唯一事件是`ClassifiedAd`事件。然而，我们的存储包含整个应用程序的所有事件。
- en: Since we use the `SubscribeFromAllFrom` method of the `IEventStoreConnection`
    interface, our projection will receive all events. We currently filter our system
    events, so we should get everything else, including events for the `UserProfile`
    aggregate. It seems simple to add one more `case` to the pattern-matching switch
    and handle the `UserDisplayNameUpdated` event to set the `ReadModels` property
    correctly. That seems legit, so when the owner updates their display name, our
    read model will get updated too.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用`IEventStoreConnection`接口的`SubscribeFromAllFrom`方法，我们的投影将接收所有事件。我们目前过滤我们的系统事件，因此我们应该得到所有其他事件，包括`UserProfile`聚合的事件。在模式匹配开关中添加一个额外的`case`来处理`UserDisplayNameUpdated`事件并正确设置`ReadModels`属性似乎很简单。这似乎是合理的，所以当所有者更新他们的显示名称时，我们的读取模型也会得到更新。
- en: 'One issue here is that we cannot give the `UpdateItem` method any ID. When
    the user updates their display name, this action is not associated with any classified
    ad. This means that we need to run a query and update all ads where the owner
    ID is the ID of the user who changed the name. This task is not hard, so we can
    add one more method, called `UpdateMultipleItems`, and give it a query and an
    operation to execute on each item that is returned by the query:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个问题是我们不能给`UpdateItem`方法任何ID。当用户更新他们的显示名称时，这个动作与任何分类广告都没有关联。这意味着我们需要运行一个查询并更新所有所有者ID是更改名称的用户ID的广告。这项任务并不难，因此我们可以添加一个名为`UpdateMultipleItems`的额外方法，并给它一个查询和一个操作，该操作将对查询返回的每个项目执行：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can specify the action easily, but what should be the query? Our read model
    doesn't contain the owner ID! Well, we can easily fix this by adding an additional
    property to the read model, called `SellerId`, which we will assign from `OwnerId`.
    There is no way in our system to change the ad owner, so it is safe to do this
    assignment only when the ad is created.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松指定操作，但查询应该是什么？我们的读取模型不包含所有者ID！嗯，我们可以通过向读取模型添加一个额外的属性来轻松解决这个问题，称为`SellerId`，我们将从`OwnerId`分配它。在我们的系统中没有更改广告所有者的方法，所以只有在广告创建时进行此分配是安全的。
- en: 'The new code for the projection will be as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 投影的新代码将如下所示：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Of course, one thing to remember is how efficient the query will be on real
    storage. Since we are using a simple in-memory list, it is not an issue. In reality,
    one person would not have millions of classified ads, so the same query would
    work too, but we also need to remember that RavenDB only supports a limited number
    of operations per session, so an advanced technique might be needed if we expect
    to update thousands of items by this query.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有一件事要记住的是查询在真实存储中的效率。由于我们使用的是简单的内存列表，这不是一个问题。在现实中，一个人不会有数百万个分类广告，所以相同的查询也会起作用，但我们还需要记住，RavenDB只支持每个会话有限的操作数，所以如果预期通过此查询更新数千个项目，可能需要使用高级技术。
- en: Do you see another issue there? Of course, users don't really update their names
    that often. I don't actually remember changing my name since I was born. I do
    update some of my countless profiles on a number of online services that I use,
    but usually, I do this only once, especially when it comes to the name change.
    For our classified ad, the chance that the owner will update their name after
    the ad has been created and before it is removed is close to zero. So, what can
    we do?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你在那里看到另一个问题吗？当然，用户并不经常更新他们的名字。我实际上不记得自从我出生以来改变过我的名字。我确实更新了我使用的一些在线服务的无数个个人资料，但通常我只做一次，尤其是在更改名字的时候。对于我们的分类广告，所有者在广告创建后和删除前更新名字的可能性几乎为零。那么，我们能做什么呢？
- en: Multiple projections per subscription
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个订阅多个投影
- en: First, it seems that we need to build another projection that will handle events
    for the `UserProfile` aggregate and build a simple read model from them. We can
    use the same storage and keep everything in memory for now. Since we will have
    two projections, it makes sense to separate things and let our subscription handle
    multiple projections.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，似乎我们需要构建另一个投影来处理`UserProfile`聚合的事件，并从它们构建一个简单的读取模型。我们可以使用相同的存储，并暂时将所有内容保存在内存中。由于我们将有两个投影，因此将事物分开并让我们的订阅处理多个投影是有意义的。
- en: 'Since we will have one subscription that can handle multiple projections, we
    can rename our `EsSubscription` class to `ProjectionsManager`. It will need to
    accept projections as parameters and it is better to keep them in separate classes,
    so we need a simple interface. We can call it `IProjection` and place the file
    in the `Marketplace.Framework` project, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将有一个可以处理多个投影的订阅，我们可以将我们的`EsSubscription`类重命名为`ProjectionsManager`。它需要接受投影作为参数，并且最好将它们保存在单独的类中，因此我们需要一个简单的接口。我们可以称它为`IProjection`并将文件放置在`Marketplace.Framework`项目中，如下所示：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we need to move the pattern-matching code to a new implementation of
    this interface. It is better to group projections together, so I created a folder
    in the `Marketplace` project, called `Projections`, and added a new `ClassifiedAdDetailsProjection` class
    there. After that, I moved the code from the `EsSubscription.EventAppeared` method
    to this new class:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将模式匹配代码移动到这个接口的新实现中。将投影分组在一起会更好，因此我在`Marketplace`项目中创建了一个名为`Projections`的新文件夹，并在其中添加了一个新的`ClassifiedAdDetailsProjection`类。之后，我将代码从`EsSubscription.EventAppeared`方法移动到这个新类中：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We also need a new projection that will build a read model for user details,
    so I created another implementation of the `IProjection` interface and called
    it `UserDetailsProjection`. It makes sense to also move the `ReadModels.cs` files
    to the `Projections` folder to keep things together. Here is the user details
    projection code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个新的投影来构建用户详情的读取模型，因此我创建了`IProjection`接口的另一个实现，并将其命名为`UserDetailsProjection`。将`ReadModels.cs`文件移动到`Projections`文件夹中也是有意义的，以保持事物的一致性。以下是用户详情投影代码：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Of course, we need to add a new read model class to the `ReadModels.cs` file,
    as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要在`ReadModels.cs`文件中添加一个新的读取模型类，如下所示：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we need to finalize the projections manager so that it can accept multiple
    projections and call each of them when a new event appears. We want to be prepared
    for the future use of a real persistence store, so I want to keep all methods
    async, except `UpdateItem` and `UpdateItems`, which I can change later, as these
    are implementation details of individual projection classes. Here is the new `ProjectionManager`
    class code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要最终确定投影管理器，以便它可以接受多个投影，并在出现新事件时调用每个投影。我们希望为将来使用真实的持久化存储做好准备，因此我想保持所有方法都是异步的，除了`UpdateItem`和`UpdateItems`，这些我可以稍后更改，因为这些都是单个投影类实现的细节。以下是新的`ProjectionManager`类代码：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: I want to keep logging all events that we project to see what is going on. In
    the last line of the `EventAppeared` method, you can see that we are collecting
    all of the tasks that project events for each projection and we want all these
    tasks to complete.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我想记录所有我们投影的事件，以了解发生了什么。在`EventAppeared`方法的最后一行，你可以看到我们正在收集为每个投影收集事件的任务，我们希望所有这些任务都完成。
- en: 'Next, we fix compilation errors in the `EventStoreService` class, so it uses
    `ProjectionManager`, instead of the removed (or renamed) `EsSubscription` class:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们修复`EventStoreService`类中的编译错误，使其使用`ProjectionManager`，而不是已删除（或重命名）的`EsSubscription`类：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The final thing before we can start the app is to wire things up in `Startup`.
    We need one more collection, this time of the `ReadModels.UserDetails`, so we
    can use it in controllers and give it to the `UserDetailsProjection` constructor
    as a parameter:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以启动应用程序之前，最后一件事是在`Startup`中连接这些组件。我们需要一个额外的集合，这次是`ReadModels.UserDetails`的集合，这样我们就可以在控制器中使用它，并将其作为参数传递给`UserDetailsProjection`构造函数：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This was some work, but now everything is done, I can finally press *F5* and
    see what happens. Well, nothing spectacular really; I only see the same events
    for an ad being projected again, but at least this part works as before. We see
    nothing new because I was cheating and created an ad without having any users
    in the system. Now I need to go back and create this user.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一项工作，但现在一切都完成了，我最终可以按下*F5*并看看会发生什么。好吧，实际上并没有什么特别之处；我只看到了广告被投影的相同事件，但至少这部分工作如预期一样。我们没有看到任何新内容，因为我作弊了，创建了一个没有用户的广告。现在我需要回去创建这个用户。
- en: Event links and special streams
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件链接和特殊流
- en: 'Assuming that we keep running `docker-compose` from [Chapter 10](75bc64ae-a642-42b2-a44a-05ae0cb2b750.xhtml),
    *Event Sourcing*, I can look up the owner ID of the only ad we have in the Event
    Store stream. The value I used there is `8dd8c5c6-6edb-4e42-ac9e-a232ea445b76`,
    so I can use the Swagger API for user profiles and create the following user:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们继续从[第10章](75bc64ae-a642-42b2-a44a-05ae0cb2b750.xhtml)，“事件溯源”，我可以查找事件存储流中我们拥有的唯一广告的所有者ID。我在那里使用的值是`8dd8c5c6-6edb-4e42-ac9e-a232ea445b76`，因此我可以使用用户配置文件的Swagger
    API创建以下用户：
- en: '![](img/601ac523-3710-4bd9-81f0-199401128e98.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/601ac523-3710-4bd9-81f0-199401128e98.png)'
- en: Creating a new user via the UserProfile API
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过UserProfile API创建新用户
- en: 'I got a `200 OK` response and now I see more lines in the log, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我得到了一个`200 OK`响应，现在我在日志中看到了更多的行，如下所示：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Well, the new projection works, but why has this single event been projected
    four times? The mystery can be easily solved by looking at the `$all` stream that
    we used for our subscription:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，新的投影是有效的，但为什么这个单一事件被投影了四次呢？通过查看我们用于订阅的`$all`流，这个谜团可以轻易解决：
- en: '![](img/a1582758-b15e-4fe9-afc0-f9b2cc8955e3.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a1582758-b15e-4fe9-afc0-f9b2cc8955e3.png)'
- en: Content of the $all stream
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`$all`流的内容'
- en: Here, you can see that several events were added to it. If we ignore system
    events, those of `0@$ce-UserProfile`, `0@$et-UserRegistered`, and so on look suspicious.
    These are linked events that were placed to different special streams by internal
    standard projections of Event Store. These internal projections are very helpful.
    For example, if you look at the `$ce-UserProfile` stream, you will find all events
    that were saved for all instances of the `UserProfile` aggregate. These `$ce`
    streams are known as category streams. Another stream type is the event type.
    For example, `$et-UserRegistered` contains all events of type `UserRegistered`
    from all other streams in the store.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到添加了几个事件。如果我们忽略系统事件，那些看起来可疑的`0@$ce-UserProfile`、`0@$et-UserRegistered`等事件是链接事件，这些事件是通过事件存储的内部标准投影放置到不同的特殊流中的。这些内部投影非常有帮助。例如，如果你查看`$ce-UserProfile`流，你会找到为`UserProfile`聚合的所有实例保存的所有事件。这些`$ce`流被称为类别流。另一种流类型是事件类型。例如，`$et-UserRegistered`包含来自存储中所有其他流的所有`UserRegistered`类型的事件。
- en: 'However, we are subscribing to the `$all` stream and we don''t need to get
    copies of a single event that is being linked to all those special streams. We
    could, of course, disable standard projections by going to the Projection tab
    of the Event Store UI and clicking the Stop all button, but that is not really
    a good way. Someone could come to our store later on and enable these projections
    again. But remember, these are linked events. We have a helpful parameter for
    the catch-up subscription, which is called `resolveLinkTos`, and we set it to
    `true`. Let''s change it to `false` and see what happens. Here is the new code
    from the `ProjectionManager` class:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们正在订阅`$all`流，我们不需要获取与所有那些特殊流链接的单个事件的副本。当然，我们可以通过访问事件存储UI的投影选项卡并点击停止所有按钮来禁用标准投影，但这并不是一个好的方法。有人可能会在以后来到我们的存储并重新启用这些投影。但请记住，这些是链接事件。我们有一个对追赶订阅有帮助的参数，称为`resolveLinkTos`，我们将其设置为`true`。让我们将其更改为`false`并看看会发生什么。以下是`ProjectionManager`类的新代码：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If I run the application now, the input is much different:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我现在运行应用程序，输入就大不相同：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It appears that events for the `ClassifiedAd` aggregate were also projected
    multiple times before, for the same reason. Now the log makes much more sense,
    and each event is only projected once, as expected.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来，`ClassifiedAd`聚合的事件之前也因为同样的原因被多次投影。现在日志变得更加合理，每个事件都只被投影了一次，正如预期的那样。
- en: Enriching read models
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 丰富读取模型
- en: At this moment, we have a collection that contains a single object of type `ReadModels.UserDetails`
    in memory. This object represents a single user, so we can find out what display
    name the user has if we have the user ID. This is helpful, but how can we use
    it to show the full details of our classified ad? There are two ways of doing
    this, considering that we are within a single-application boundary and use the
    same store (currently in memory) for all read models.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在此刻，我们有一个包含内存中单个`ReadModels.UserDetails`类型对象的集合。这个对象代表一个单一用户，因此如果我们有用户ID，我们可以找出用户有什么显示名称。这很有帮助，但如何使用它来展示我们分类广告的完整详情呢？考虑到我们处于单个应用程序边界内，并且为所有读取模型使用相同的存储（目前是在内存中），有两种方法可以做到这一点。
- en: 'When developers start to deal with data that is spread across multiple data
    sources, the most obvious method that comes to their mind is to aggregate data
    on the edge. One of the most popular techniques is to build BFF. When the frontend
    needs to get some aggregated data, it sends one request to a single API endpoint
    at the backend, and the API itself calls different data sources and merges the
    data. This process can be illustrated by the following diagram:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者开始处理分散在多个数据源中的数据时，他们脑海中首先想到的最明显的方法是在边缘聚合数据。最受欢迎的技术之一是构建bff。当前端需要获取一些聚合数据时，它向后端的单个API端点发送一个请求，API本身调用不同的数据源并合并数据。这个过程可以用以下图表来表示：
- en: '![](img/b36c5123-5e9a-4204-8903-d9872201f1e1.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b36c5123-5e9a-4204-8903-d9872201f1e1.png)'
- en: The BFF pattern
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: BFF模式
- en: In the simplest scenario, we can just do one database call with some sort of
    join, since we have the knowledge about keys for both data elements that we need
    to query. In more complex situations, we might find ourselves dealing with remote
    calls to microservices that own the data we need and do the join in memory. There
    are quite a few concerns about this approach. When we start using remote calls,
    we expose our API endpoint to potential failures of any of the services it needs
    to call and all sorts of networking issues that might happen. Another important
    aspect is that we have to do the join each time the BFF API endpoint is called.
    If this particular set of data is being used frequently, we will get into a situation
    where we need to make potentially expensive joins, instead of using the power
    of read models to retrieve a preprocessed set of denormalized data that is targeted
    in that particular use case.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的场景中，我们可以通过某种类型的连接进行一个数据库调用，因为我们对我们需要查询的两个数据元素的键有知识。在更复杂的情况下，我们可能会发现自己正在处理对拥有所需数据的微服务的远程调用，并在内存中进行连接。关于这种方法有一些担忧。当我们开始使用远程调用时，我们暴露了我们的API端点，使其容易受到它需要调用的任何服务的潜在失败以及可能发生的所有网络问题的影响。另一个重要方面是，我们必须在每次调用bff
    API端点时执行连接。如果这个特定的数据集被频繁使用，我们将陷入需要执行可能昂贵的连接的情况，而不是使用读取模型的力量来检索针对特定用例的预处理的去规范化数据集。
- en: There are a few ways to get more data in the read model than it receives in
    events that the projection receives.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取模型中获取比投影接收的事件更多的数据有几种方法。
- en: If we have the necessary data that our read model needs, in the same aggregate,
    we can add properties to the event that aren't necessary to convey the state transition.
    For example, if we need to build a read model that will contain a list of ads
    for one user (`MyClassifiedAds`), we would need to include the owner ID to all
    events that the projection would need to handle, such as `ClassifiedAdTitleChanged`
    or `ClassifiedAdTextUpdated`. This method is sometimes referred to as using **fat
    events**, which is the opposite of **slim events** that contain the minimal amount
    of data that is necessary to explain what happened. But this method won't work
    for a cross-aggregate read model, so it is not an option that we need to explore
    now.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们拥有读取模型所需的所有必要数据，在同一聚合中，我们可以向事件添加一些不需要传达状态转换的属性。例如，如果我们需要构建一个包含一个用户广告列表的读取模型（`MyClassifiedAds`），我们就需要包括所有投影需要处理的事件的所有者ID，例如`ClassifiedAdTitleChanged`或`ClassifiedAdTextUpdated`。这种方法有时被称为使用**胖事件**，这与包含解释所发生事情所需的最小数据量的**瘦事件**相反。但是，这种方法对于跨聚合的读取模型不起作用，因此我们现在不需要探索这个选项。
- en: We are going to implement two other methods that will allow us to get the data
    from other sources—querying from a projection and event up casting.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现另外两种方法，这将使我们能够从其他来源获取数据——从投影查询和事件上溯。
- en: Querying from a projection
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从投影查询
- en: 'Currently, our main problem is that we don''t have the name of the owner when
    our projection receives the `ClassifiedAdCreated` event. All other events for
    the classified ad aggregate don''t have any effect on the owner, since the owner
    cannot be changed. We already handle the `UserDisplayNameUpdated` event in our
    projection, so we get the updated name if the ad owner decides to do such an update.
    To get the data we need, we will reach out to the `UserDetails` read model, using
    `OwnerId` from the event. The process would look like the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们面临的主要问题是我们无法在投影接收到 `ClassifiedAdCreated` 事件时获取所有者的名称。对于分类广告聚合的所有其他事件，所有者都没有任何影响，因为所有者无法更改。我们已经在投影中处理了
    `UserDisplayNameUpdated` 事件，所以如果广告所有者决定进行此类更新，我们将获取更新的名称。为了获取所需的数据，我们将通过使用事件中的
    `OwnerId` 来联系 `UserDetails` 读取模型。这个过程看起来如下：
- en: '![](img/193c9247-24db-43e1-bbb1-742e5302807b.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/193c9247-24db-43e1-bbb1-742e5302807b.png)'
- en: Enriching projections from another read model
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个读取模型增强投影
- en: Let's change our projection code to do this query. First of all, we don't have
    any knowledge about the other read model in the `ClassifiedAdDetailsProjection`
    class. This doesn't matter for now, as regardless of whether the data is stored
    in memory or in some database, we still need to get hold of it. A trivial way
    would be to give our projection a reference to the `UserDetails` storage and execute
    the query directly. But this approach, although very simple to implement, creates
    coupling between read models and projections. When such coupling is introduced,
    any future change will be harder to implement and testing will always be a challenge,
    since we always need to make sure that all storages are prepopulated with all
    the data we need.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改我们的投影代码以执行此查询。首先，我们对 `ClassifiedAdDetailsProjection` 类中的其他读取模型没有任何了解。现在这并不重要，因为无论数据是存储在内存中还是某些数据库中，我们仍然需要获取它。一种简单的方法是给我们的投影一个对
    `UserDetails` 存储的引用并直接执行查询。但这种方法，虽然实现起来非常简单，却在读取模型和投影之间创建了耦合。当引入这种耦合时，未来的任何更改都将更加困难，测试也将始终是一个挑战，因为我们始终需要确保所有存储都预先填充了我们所需的所有数据。
- en: 'A much more elegant and clean way is to give our projection an explicit way
    to retrieve `DisplayName` of a user for a given `UserId`. The easiest way to do
    this is by providing a delegate function so that we can add it as a parameter
    to the projection constructor:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更加优雅和简洁的方法是给我们的投影提供一个明确的方式来检索给定 `UserId` 的用户的 `DisplayName`。最简单的方法是提供一个委托函数，这样我们就可以将其作为参数添加到投影构造函数中：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we can use this function to get the additional data we need for the read
    model, by adding the call to this function in the first `case` in the `ClassifiedAdDetailsProjection.Project`
    method:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这个函数来获取读取模型所需的额外数据，通过在 `ClassifiedAdDetailsProjection.Project` 方法的第一个
    `case` 中添加对这个函数的调用来实现：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The last thing that we need to do is to complete the wiring, since the `Startup`
    class doesn''t compile anymore. We need to change the projection constructor call
    to the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是完成布线，因为 `Startup` 类现在无法编译了。我们需要将投影构造函数的调用更改为以下内容：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'That''s all we needed to do, and now I can start the application and query
    the same endpoint as before to get the enriched result:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的所有操作，现在我可以启动应用程序并查询之前相同的端点以获取增强的结果：
- en: '![](img/ca953811-a9c1-4e4d-b938-d1e0489f6098.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca953811-a9c1-4e4d-b938-d1e0489f6098.png)'
- en: The query result shows all the data we need
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 查询结果显示了我们所需的所有数据
- en: You can see that the `sellersDisplayName` property in the response is correctly
    set to the value we want.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，响应中的 `sellersDisplayName` 属性被正确地设置为我们要的值。
- en: There are quite a few aspects that need to be taken care of when using queries
    in projections, mainly to ensure reliability. The main goal of such work is to
    ensure that projections never fail. When the data that you need to query is located
    in the same storage as the read model that you are updating, the speed of processing
    and reliability of the query should be on an acceptable level. You might still
    want to apply a retry policy on the whole projection to mitigate issues of transient
    networking failures and similar situations. However, you should really not try
    querying external data sources to get additional data. We will discuss how to
    solve situations like this when we talk about integration aspects.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在投影中使用查询时，需要考虑很多方面，主要是确保可靠性。这项工作的主要目标是确保投影永远不会失败。当你需要查询的数据位于你正在更新的读取模型相同的存储中时，查询的处理速度和可靠性应该在一个可接受的水平。你可能仍然希望在整个投影上应用重试策略来减轻暂时性网络故障等问题。然而，你真的不应该尝试查询外部数据源以获取额外数据。当我们讨论集成方面时，我们将讨论如何解决这种情况。
- en: Upcasting events
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升事件
- en: The most complex way to get more data into the read model is by using **event
    upcasting**. Basically, to implement this, we need to create a separate subscription
    to the Event Store that receives the slim event, gets the additional data from
    somewhere else, produces a new event with more data, and publishes it to a special
    stream. This stream could never be the aggregate stream since the new event is
    only needed to build a read model. We could choose a special name for the stream,
    such as `ClassifiedAd-Upcast`. Since the read model projection listens to the
    `$all` stream, it will receive and process these events as well. This method is
    only useful when the additional data is needed for different read models, so we
    can update all of them using one enriched event, hence we need to query for additional
    data only once.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 将更多数据输入到读取模型的最复杂方式是通过使用**事件提升**。基本上，要实现这一点，我们需要创建一个对事件存储的单独订阅，该订阅接收精简事件，从其他地方获取额外数据，生成一个包含更多数据的新事件，并将其发布到一个特殊的流中。这个流永远不能是聚合流，因为新的事件只需要用来构建读取模型。我们可以为这个流选择一个特殊名称，例如`ClassifiedAd-Upcast`。由于读取模型投影监听`$all`流，它也会接收并处理这些事件。这种方法仅在需要为不同的读取模型提供额外数据时才有用，因此我们可以使用一个富集事件来更新所有这些模型，因此我们只需要查询一次额外数据。
- en: We don't have many read models, but I can still demonstrate this approach on
    a single `ClassifiedAdDetails` event. Let's assume we need to include the owner's
    photo in the read model as soon as the ad gets published, so we can enrich the
    `ClassifiedAdPublished` event.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有很多读取模型，但我仍然可以在单个`ClassifiedAdDetails`事件上演示这种方法。假设我们需要在广告发布时立即将所有者照片包含到读取模型中，这样我们就可以丰富`ClassifiedAdPublished`事件。
- en: 'First, I need to add `SellersPhotoUrl` to the read model itself; it will be
    just a string, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我需要将`SellersPhotoUrl`添加到读取模型本身；它将只是一个字符串，如下所示：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We also need to get the owner ID to the up caster, otherwise, it doesn''t know
    which user it needs to ask for the photo. Here, we can use the fat event method
    and add the `OwnerId` property to our `ClassifiedAdPublished` event. After I''ve
    added the property, I need to change the `Publish` method of the `ClassifiedAd`
    aggregate, so it will populate this property from the aggregate state:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将所有者ID传递给提升器，否则它不知道需要询问哪个用户的照片。在这里，我们可以使用胖事件方法，并将`OwnerId`属性添加到我们的`ClassifiedAdPublished`事件中。在我添加属性后，我需要更改`ClassifiedAd`聚合的`Publish`方法，使其从聚合状态中填充这个属性：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'I also need to have the up casted event as a class, so I add it as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我还需要将提升事件作为一个类，所以我按照以下方式添加它：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We were saving events to the Event Store before and the code is located in
    the `EsAggregateStore` class. Now, we need this code again, so that we can create
    a useful extension to the `IEventStoreConnection` interface to make saving events
    more convenient:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前将事件保存到事件存储中，代码位于`EsAggregateStore`类中。现在，我们需要这段代码，以便我们可以创建一个有用的`IEventStoreConnection`接口扩展，使保存事件更加方便：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Since this code is copied from the `EsAggregateStore` class, it would make sense
    to use this method there as well, and you can see the changed code in the GitHub repository.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这段代码是从`EsAggregateStore`类复制的，所以在那里使用这个方法也是有意义的，你可以在GitHub仓库中看到更改后的代码。
- en: 'Next, I need to create a new projection. I can call it `ClassifiedAdUpcasters`
    and put it to the `Projections` folder of the main project. The class needs to
    implement `IProjection` so that I can feed our `ProjectionManager` with it. In
    the `Project` method, I need to handle a single event; but for future use, I can
    still use the `switch` statement although it also has one `case`. In this `case`,
    I need to emit a new event to the upcasting stream, so I''d need to take `IEventStoreConnection`
    as a dependency. The code for the new class is shown as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我需要创建一个新的投影。我可以将其命名为`ClassifiedAdUpcasters`并将其放入主项目的`Projections`文件夹中。这个类需要实现`IProjection`接口，这样我就可以将它们喂给我们的`ProjectionManager`。在`Project`方法中，我需要处理单个事件；但为了未来的使用，我仍然可以使用`switch`语句，尽管它也有一个`case`。在这个`case`中，我需要向提升流发出一个新事件，因此我需要将`IEventStoreConnection`作为依赖项。新类的代码如下所示：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see in the code, I need to get a function that will allow the projection
    to get the user photo URL from somewhere. As soon as this projection received
    the `ClassifiedAdPublished` event, it will query the photo URL and emit a new,
    enriching event to the `UpcastedClassifiedAds` stream.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码所示，我需要一个函数，它将允许投影从某处获取用户照片URL。一旦这个投影接收到`ClassifiedAdPublished`事件，它将查询照片URL并向`UpcastedClassifiedAds`流发出一个新的事件。
- en: 'We also need to project the upcasted event in the `ClassifiedAdDetails` projection,
    so I add one more `case` to the `Project` method:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`ClassifiedAdDetails`投影中投影提升事件，因此我在`Project`方法中添加了一个额外的`case`：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The last thing is the wiring, where I need to add this new projection to the
    projection manager, so it will include it in the subscription processing. So,
    I need to change the `Startup.cs` file, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是连接，我需要将这个新投影添加到投影管理器中，以便它将在订阅处理中包含它。因此，我需要更改`Startup.cs`文件，如下所示：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, you can see that I use `esConnection`, which has been instantiated before
    for the aggregate store, and the function to query the user photo URL from the `UserDetails`
    read model.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我使用了`esConnection`，它之前已经被实例化用于聚合存储，以及从`UserDetails`读取模型中查询用户照片URL的函数。
- en: 'When everything is done, I can run the application again. In Swagger, I use
    the user profile command API to add the photo URL to the user, then use the classified
    ad command API to first request the ad to be published, and then publish it. Once
    I complete these operations via the API, I can go back to the query API and get
    the new details. The new result includes the photo URL, as expected:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切完成后，我可以再次运行应用程序。在Swagger中，我使用用户配置文件命令API将照片URL添加到用户，然后使用分类广告命令API首先请求发布广告，然后发布它。一旦我通过API完成这些操作，我就可以回到查询API并获取新的详细信息。新的结果包括预期的照片URL：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can also look to the Event Store UI and check the content of the upcasted
    events stream by going to `http://localhost:2113/web/index.html#/streams/UpcastedClassifiedAdEvents`.
    The stream shows one event, and when I click on it, I see the following content:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以查看事件存储UI，通过访问`http://localhost:2113/web/index.html#/streams/UpcastedClassifiedAdEvents`来检查提升事件流的内
    容。该流显示一个事件，当我点击它时，我看到以下内容：
- en: '![](img/a19f1b02-924b-4c64-a714-b245c243e6b7.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a19f1b02-924b-4c64-a714-b245c243e6b7.png)'
- en: The consent of the upcasted event
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 提升事件的同意
- en: Be aware that since we keep everything in memory, and our projections start
    from the very beginning of the `$all` stream each time the application starts,
    the up caster will handle the event again and will produce as many upcasted events
    as the number of times you run the application. The only way to avoid this is,
    of course, to store the stream position after we process each event. When we stop
    and start the application, we read the stored position and only start processing
    new events. We will dive into this in the next section.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于我们一切都在内存中，并且我们的投影每次应用程序启动时都从`$all`流的最开始处开始，因此提升器将再次处理事件，并且会产生与运行应用程序次数一样多的提升事件。当然，避免这种情况的唯一方法是在我们处理每个事件后存储流位置。当我们停止并启动应用程序时，我们读取存储的位置，然后只开始处理新事件。我们将在下一节中深入探讨这一点。
- en: Persistent storage
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化存储
- en: By now, we already have a few projections that build some useful read models
    that we can potentially use for the UI of our application. However, these read
    models aren't persistent and when we stop the app, everything disappears. Of course,
    read models are quickly rebuilt when we start the app again, and although it is
    a perfectly fine way to build read models at the beginning of the development
    cycle, this won't work for a production system. In addition, if we use upcasting,
    we will emit up cast events each time the app starts, since the upcasting subscription
    will process all events again. So, it is now time to persist our read models to
    a database.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有了一些投影，它们构建了一些有用的读取模型，我们可能可以用它们来构建应用程序的UI。然而，这些读取模型不是持久的，当我们停止应用程序时，一切都会消失。当然，当我们再次启动应用程序时，读取模型会迅速重建，尽管这是在开发周期开始时构建读取模型的完美方式，但这在生产系统中是不可行的。此外，如果我们使用上推，每次应用程序启动时都会发出上推事件，因为上推订阅将再次处理所有事件。因此，现在是时候将我们的读取模型持久化到数据库中。
- en: Checkpoints
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查点
- en: As we have seen before, our application reprocesses all events in all projections
    when we start it. That's because we give `Position.Start` as the initial position
    when we create a subscription in the `ProjectionManager` code. Since we want to
    store our read models in the database, we also need to start giving the subscription
    an actual position after processing events. This means that we also need to keep
    the position persisted somewhere. In different systems, such a position can be
    called differently. In event log systems, such as Kafka or Azure Event Hub, the
    term **offset** is used. Event Store uses the term **checkpoint** and this is
    what we are going to use in this book.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，当启动我们的应用程序时，它会重新处理所有投影中的所有事件。这是因为我们在创建`ProjectionManager`代码中的订阅时，将`Position.Start`作为初始位置。由于我们希望将我们的读取模型存储在数据库中，我们还需要在处理事件后开始给订阅一个实际的位置。这意味着我们还需要将位置持久化到某个地方。在不同的系统中，这样的位置可能有不同的叫法。在事件日志系统中，如Kafka或Azure
    Event Hub，使用的是**偏移量**这个术语。Event Store使用的是**检查点**，这正是本书将要使用的。
- en: Ideally, we would keep the checkpoint in the same database as the read models
    for that subscription. For some database engines, it is even possible to wrap
    all read model updates and checkpoint updates into a single transaction, and that
    might be desirable. Using this method definitely makes the projection-handling
    code more complex, since a single transaction needs to pass through to all projections
    and to the checkpoint store.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们会将检查点存储在与该订阅的读取模型相同的数据库中。对于某些数据库引擎，甚至可以将所有读取模型更新和检查点更新封装在一个单一的事务中，这可能是有益的。使用这种方法无疑会使投影处理代码更加复杂，因为单个事务需要传递到所有投影和检查点存储。
- en: 'We will be using RavenDB, and although it supports some sort of multi-document
    transactions, we won''t be doing this to keep the code simpler. So, the first
    thing I need to do is to define an interface for the checkpoint store. For this,
    I add an `ICheckpointStore` file to the `Marketplace.Framework` project. The code
    is very simple; we only need a couple of methods, as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用RavenDB，尽管它支持某种多文档事务，但我们不会这样做以保持代码的简洁性。因此，我需要做的第一件事是定义检查点存储的接口。为此，我在`Marketplace.Framework`项目中添加了一个`ICheckpointStore`文件。代码非常简单；我们只需要几个方法，如下所示：
- en: '[PRE38]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, `Position` is the `struct` defined in the Event Store API, and we might
    want to try to avoid putting infrastructural dependencies in this project, but
    it will work for now.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Position`是在Event Store API中定义的`struct`，我们可能想要尽量避免在这个项目中放置基础设施依赖，但暂时它是可行的。
- en: 'We also need a document for RavenDB where the checkpoint will be stored. It
    needs to have an `Id` field of type string and the actual position:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个RavenDB文档，其中将存储检查点。它需要一个字符串类型的`Id`字段和实际的位置：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we need to implement this interface. Since I plan to store everything
    in RavenDB, it would be logical to call the implementation, `RavenDbCheckpointStore`.
    I add this class to the `Marketplace` project in the `Infrastructure` folder:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现这个接口。由于我计划将所有内容存储在RavenDB中，因此将实现命名为`RavenDbCheckpointStore`是合理的。我将这个类添加到`Infrastructure`文件夹中的`Marketplace`项目中：
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Although the code is a bit long, it is not very complex. We need to give a session
    factory as a parameter for this class. We also need some sort of an identifier,
    in case we have multiple subscriptions. This `checkpointName` string will be used
    as the `Checkpoint` document ID.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码有点长，但并不复杂。我们需要给这个类提供一个会话工厂作为参数。我们还需要某种标识符，以防我们有多达多个订阅。这个`checkpointName`字符串将被用作`Checkpoint`文档ID。
- en: In `GetCheckpoint`, we try to load the document, and if it doesn't exist, the
    method returns `Position.Start`, so that we can subscribe to the very beginning.
    It replicates the no-checkpoint situation and, in case you need to rebuild all
    read models from the ground up, you just need to remove this document, along with
    all documents for read models.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GetCheckpoint`方法中，我们尝试加载文档，如果它不存在，则该方法返回`Position.Start`，这样我们就可以订阅到最开始的位置。它复制了没有检查点的情况，如果你需要从头开始重建所有读取模型，你只需要删除这个文档以及所有读取模型的文档。
- en: When we save the checkpoint, we must try loading one to see if it exists. If
    it does, we update it with the new position, otherwise, we store a new document.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们保存检查点时，我们必须尝试加载一个来看看它是否存在。如果存在，我们使用新的位置更新它，否则，我们存储一个新的文档。
- en: 'The next thing is, of course, our `ProjectionManager`. It needs to be able
    to work with the checkpoint store. We don''t need it to know about RavenDB since
    it is only needed for projections and the checkpoint store. But it needs to call
    the checkpoint store when making a subscription and to save the position after
    projecting each event. So, we need to add the `ICheckpointStore` parameter and
    call the two methods that this interface has, as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来当然是我们的`ProjectionManager`。它需要能够与检查点存储一起工作。我们不需要它了解RavenDb，因为它只需要用于投影和检查点存储。但是，在订阅时需要调用检查点存储，并在每个事件投影后保存位置。因此，我们需要添加`ICheckpointStore`参数并调用该接口的两个方法，如下所示：
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Persisting read models
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化读取模型
- en: Since we need RavenDb anyway, I used some code from [Chapter 10](75bc64ae-a642-42b2-a44a-05ae0cb2b750.xhtml), *Event
    Sourcing,* but made it a little more advanced. I moved the initialization of the
    document store to a separate method in the `Startup` class. The method will use
    the `appsettings.json` configuration section instead of hard coded values. It
    will also create the database if it doesn't exist, so we don't need to create
    it manually. It is not important for the content of this chapter to know how the
    database is configured, you can check the code snippet of the book to see how
    it is done. Check the settings file there as well, to see the configuration structure.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无论如何都需要 RavenDb，所以我从[第10章](75bc64ae-a642-42b2-a44a-05ae0cb2b750.xhtml)的代码中使用了部分代码，*事件溯源*，但使其变得更加高级。我将文档存储的初始化移动到了`Startup`类的一个单独的方法中。该方法将使用`appsettings.json`配置部分而不是硬编码的值。如果数据库不存在，它还会创建数据库，因此我们不需要手动创建它。对于本章的内容来说，了解数据库是如何配置的并不重要，你可以查看书籍中的代码片段来了解它是如何实现的。同时也要查看那里的设置文件，以了解配置结构。
- en: 'After these changes are made, I need to change the `Startup.ConfigureServices`
    method, so it calls the store initialization method. We need to have a document
    session factory and also register `IAsyncDocumentSession` in the services collection
    since we''ll need it in the query API controller. Here are some of the changes
    in the registration:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这些更改后，我需要更改`Startup.ConfigureServices`方法，使其调用存储初始化方法。我们需要有一个文档会话工厂，并在服务集合中注册`IAsyncDocumentSession`，因为我们将在查询API控制器中使用它。以下是注册中的一些更改：
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To make things simpler for individual projections, since they all will be using
    RavenDB for now, I created a simple base abstract class called `RavenDbProjecion`.
    It accepts the session factory for its constructor and contains a helpful method
    to execute updates on read model documents and that''s why the class is a generic
    class, so we will use the read model class type as a generic parameter:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使单个投影更简单，因为它们现在都将使用RavenDb，我创建了一个简单的基抽象类，称为`RavenDbProjection`。它接受会话工厂作为其构造函数的参数，并包含一个有用的方法来执行读取模型文档的更新，这就是为什么这个类是一个泛型类，我们将使用读取模型类类型作为泛型参数：
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You have already seen `UpdateItem` and `UpdateMultipleItems`, which were implemented
    inside projection classes. Since the code is very similar, I was able to isolate
    it in the abstract class. I also made these methods private and made three methods
    with simpler signatures: `Create`, `UpdatedOne`, and `UpdateWhere`. Notice also
    the `UsingSession` method.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了 `UpdateItem` 和 `UpdateMultipleItems`，这些是在投影类内部实现的。由于代码非常相似，我能够将其隔离在抽象类中。我还将这些方法设为私有，并创建了三个具有更简单签名的三个方法：`Create`、`UpdatedOne`
    和 `UpdateWhere`。注意还有 `UsingSession` 方法。
- en: Since we are using the session factory, it will be our responsibility to dispose
    of it after use. To avoid the endless noise of the `using` statement in the projection
    code, we will be calling the `UsingSession` method that will do it for us. It
    also persists all changes that are done by the delegate that it calls before disposing
    of the session.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用会话工厂，因此在使用后我们将负责释放它。为了避免在投影代码中 `using` 语句的无限噪音，我们将调用 `UsingSession` 方法，它将为我们完成这项工作。它还持久化在会话释放之前由它调用的委托所做的所有更改。
- en: In order to save read models as documents to RavenDB, we must comply with the
    database engine conventions to make our life simpler. Therefore, we must change
    all identity properties to have the `Id` name and the type string (now we have
    `Guid`). In all places where type mismatches, I changed usages of `Guid` fields
    by calling `ToString()`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将读取模型作为文档保存到 RavenDB，我们必须遵守数据库引擎约定，以使我们的生活更简单。因此，我们必须将所有标识属性更改为具有 `Id` 名称和字符串类型（现在我们有
    `Guid`）。在所有类型不匹配的地方，我通过调用 `ToString()` 改变了 `Guid` 字段的用法。
- en: 'Now we are ready to convert the simplest projection to use RavenDB, and this
    will be the `UserDetailsProjection`. I changed it to inherit from the `RavenDbProjection`
    abstract class, so the helper method can go away. We need a constructor since
    it is required by the base class, but overall, the code is now smaller. The only
    real change was that I used those new helper methods to make the code simpler.
    Here is the new code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好将最简单的投影转换为使用 RavenDB，这将是我们所说的 `UserDetailsProjection`。我将它更改为从 `RavenDbProjection`
    抽象类继承，这样辅助方法就可以消失了。由于基类需要，我们需要一个构造函数，但总体上，代码现在更小了。唯一的真正改变是，我使用了那些新的辅助方法来简化代码。以下是新的代码：
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Our second projection is more serious, so we need to make more changes, but
    still, the difference is not huge. We need to give it the session factory too,
    since it is required for the `RavenDbProjection` base class. An important change
    is that, since we can imagine the user display name query to be asynchronous,
    we need to change the delegate signature to return `Task<string>` instead of a string.
    All other changes are related to implementing updates by calling the `Update`
    and `UpdateWhere` methods of the base class. One thing to notice, in addition
    to this, is related to the asynchronous query of the user profile, so when we
    call the query, we need to await the call. Here is the full code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个投影更为严重，因此我们需要进行更多更改，但差异并不大。我们需要给它会话工厂，因为它是 `RavenDbProjection` 基类所必需的。一个重要的改变是，由于我们可以想象用户显示名查询是异步的，我们需要将委托签名更改为返回
    `Task<string>` 而不是字符串。所有其他更改都与通过调用基类的 `Update` 和 `UpdateWhere` 方法实现更新有关。需要注意的是，除了这个之外，还与用户资料的异步查询有关，因此当我们调用查询时，我们需要等待调用。以下是完整的代码：
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The last projection is our up caster. Since it doesn''t use RavenDB, there
    is no need to inherit it from the base class. The only change I needed to make
    there is to change the query delegate so that it will return `Task<string>`, and
    the query call needs to be awaited:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个投影是我们的提升器。由于它不使用 RavenDB，因此没有必要从基类继承。我需要做的唯一改变是更改查询委托，使其返回 `Task<string>`，并且查询调用需要等待：
- en: '[PRE46]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: I won't be putting the full class code here, since the changes are minimal.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里放置完整的班级代码，因为更改很小。
- en: 'One thing to take care of is, of course, to create those queries in the `UserDetails`
    read model, since we won''t be going to a simple `List`. To make the code a little
    simpler, I created a small class called `Queries` in the `ReadModels.UserDetails`
    namespace, with one method that will obtain the profile for a single user:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一件事是，当然是在 `UserDetails` 读取模型中创建这些查询，因为我们不会简单地使用 `List`。为了使代码更简单，我在 `ReadModels.UserDetails`
    命名空间中创建了一个名为 `Queries` 的小类，其中有一个方法可以获取单个用户的资料：
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is an extension method not to the session object itself, but to a session
    factory, since we must dispose of the session after calling this query. This will
    be different for controllers, since there, the service collection will give us
    a session as a transient dependency.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种扩展方法，不是针对会话对象本身，而是针对会话工厂，因为我们必须在调用此查询之后销毁会话。对于控制器来说，情况将不同，因为在那里，服务集合将给我们一个会话作为临时依赖项。
- en: Wrapping up
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: All we need to do now is some wiring and make some small changes in the query
    API controller.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要做的只是进行一些连接和修改查询API控制器的一些小改动。
- en: 'First, the `EventStoreService` class needs to await the call to `projectionManager.Start()`,
    since this method is now `async`. Then, we need to fix the query API controller,
    by making changes to the `Queries` extensions class to use the document session:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`EventStoreService`类需要等待对`projectionManager.Start()`的调用，因为这个方法现在是异步的。然后，我们需要通过修改`Queries`扩展类以使用文档会话来修复查询API控制器。
- en: '[PRE48]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Since the query is now asynchronous, we need to prepare our `RequestHandler.HandleQuery` so
    that it can await the query, and also return `Task<IActionResult>` so the controller
    can be `async` as well:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由于查询现在是异步的，我们需要准备`RequestHandler.HandleQuery`以便它可以等待查询，并且返回`Task<IActionResult>`以便控制器也可以是异步的：
- en: '[PRE49]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The last change for the API will be to fix the controller itself so that it
    can get the session injected as a dependency and become `async`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: API的最后更改将是修复控制器本身，以便它可以注入会话作为依赖项并成为异步的：
- en: '[PRE50]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The final thing to fix is the `Startup` class. I already mentioned the RavenDB
    initialization and the preceding registration code. We only need to make a few
    necessary changes to register our projection manager and all projections. Remember
    that we changed the query delegates to be async, so there are quite a few changes
    in the following lines of code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要修复的是`Startup`类。我已经提到了RavenDB的初始化和前面的注册代码。我们只需要对注册我们的投影管理器和所有投影做一些必要的更改。记住，我们已经将查询委托改为异步，所以接下来的代码行中有相当多的更改：
- en: '[PRE51]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: First, we added the checkpoint store parameter. Then, we added the session factory
    as a parameter to two projections that use RavenDB. Finally, both queries became
    async and used the same session factory combined with our new query extension.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加了检查点存储参数。然后，我们将会话工厂作为参数添加到两个使用RavenDB的投影中。最后，两个查询都变为异步，并使用相同的会话工厂结合我们新的查询扩展。
- en: All is done, and it is now time to run the application and see what happens.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 所有工作都已完成，现在是时候运行应用程序并看看会发生什么。
- en: After I pressed *F5*, I saw messages in the log that the same events as we saw
    earlier are being projected. This is expected, since we started from scratch again.
    Now I can call the query API again to see that the result is just as I expected
    it to be. If I start the application again, it produces no logs from projections,
    since now we persisted the checkpoint and started the subscription from where
    we stopped. So, unless we start making new operations, we won't get new events.
    Our application will be processing all updates in real time from now on.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在我按下*F5*后，我在日志中看到了消息，显示与我们之前看到相同的相同事件正在被投影。这是预期的，因为我们是从头开始的。现在我可以再次调用查询API，看看结果是否正如我所预期的那样。如果我现在重新启动应用程序，它不会从投影中产生任何日志，因为我们现在已经持久化了检查点并从我们停止的地方开始订阅。所以，除非我们开始执行新的操作，否则我们不会得到新的事件。从现在开始，我们的应用程序将实时处理所有更新。
- en: 'Let''s see what have we got in the database. When I open the RavenDB Studio
    UI by going to `http://localhost:8080`, I see that the `Marketplace_Chapter11`
    database is present, so I can click on it and check the content. In the database,
    I found three documents in different collections, as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看数据库中有什么。当我通过访问`http://localhost:8080`打开RavenDB Studio UI时，我看到`Marketplace_Chapter11`数据库存在，因此我可以点击它并检查内容。在数据库中，我找到了不同集合中的三个文档，如下所示：
- en: '![](img/a0260f40-d945-4f8d-abb5-84a8743616a4.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a0260f40-d945-4f8d-abb5-84a8743616a4.png)'
- en: Three collections in RavenDB
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在RavenDB中有三个集合
- en: 'Two of these documents are our read models and one document is the checkpoint.
    Let''s see what the `ClassifiedAdDetails` document contains. As expected, we got
    all the information that we were projecting from our events:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 其中两份文档是我们的读取模型，另一份文档是检查点。让我们看看`ClassifiedAdDetails`文档包含什么。正如预期的那样，我们得到了从我们的事件中投影的所有信息：
- en: '![](img/3d67244b-2d5b-4b9b-8f1f-ac692e3300a4.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3d67244b-2d5b-4b9b-8f1f-ac692e3300a4.png)'
- en: The read model as a RavenDB document
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 读取模型作为RavenDB文档
- en: 'Now we can check what the checkpoint document contains. It has the ID of our
    checkpoint name and the JSON content is something like the following (you might
    have different values):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以检查检查点文档包含的内容。它包含我们的检查点名称的ID，JSON内容类似于以下内容（您可能有不同的值）：
- en: '[PRE52]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: By this point, we have all read models properly stored in the database, so we
    can build more queries from it, just like we did in [Chapter 9](6f50ee65-024a-4c46-89c8-343183b05b8f.xhtml),
    *CQRS - The Read Side*.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已将所有读取模型正确存储在数据库中，因此我们可以从中构建更多查询，就像我们在[第9章](6f50ee65-024a-4c46-89c8-343183b05b8f.xhtml)，《CQRS
    - 读取侧》中所做的那样。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took CQRS to a whole new level and learned how to query
    data that we initially stored as streams of events. Since event streams are hard
    to query on demand, we need to build snapshots of data that we can show to our
    users. The power of event-sourced read models is that we can build virtually an
    unlimited number of use case-specific read models, with very precise sets of data.
    We could avoid things such as joins across object collections or tables, or even
    between remote services. We can remove all read models at once and rebuild them
    from scratch, using only events. If we somehow created our projection in a way
    that it showed the wrong data on screen, then we can quickly catch the bug and
    fix the read models by removing and rebuilding them.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将CQRS提升到了一个新的高度，并学习了如何查询最初存储为事件流的数据库数据。由于事件流难以按需查询，我们需要构建可以展示给用户的数据快照。事件源读取模型的力量在于我们可以构建几乎无限数量的针对特定用例的读取模型，并具有非常精确的数据集。我们可以避免诸如在对象集合或表之间进行连接，或者在远程服务之间进行连接等问题。我们可以一次性移除所有读取模型，并从零开始重建它们，仅使用事件。如果我们以某种方式创建了一个投影，它显示屏幕上的数据错误，那么我们可以快速捕捉到错误，并通过移除和重建读取模型来修复读取模型。
- en: Of course, everything has its trade-offs. Sometimes, we can't receive all the
    data that we need for a read model from the event that we project. However, we
    went through several techniques to avoid this limitation.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，任何事物都有其权衡。有时，我们无法从投影的事件中获取读取模型所需的所有数据。然而，我们已经讨论了多种避免这种限制的技术。
- en: Still, we should remember that when the system grows, the number of events grows
    too, and building a new read model or rebuilding the one that existed before,
    but had a bug that we needed to fix and then build all records in the database
    again, may take a very long time. For systems with billions of events, it can
    take days or even weeks. There are ways to improve performance for projections,
    which I will mention later when we discuss the advanced topics of event sourcing.
    However, remember, by default, events are projected sequentially and the order
    is very important. So, the usual techniques that we apply in the messaging world,
    such as competing consumers for horizontal scaling, aren't directly applicable
    for projections. It is possible, however, to partition projections by splitting
    the `$all` stream into several streams by a given property. Event Store projections
    that are written in JavaScript and run directly on the server can be used for
    that purpose.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们应该记住，当系统增长时，事件的数量也会增长，构建一个新的读取模型或重建之前存在错误且需要修复的读取模型，然后再次在数据库中构建所有记录，可能需要非常长的时间。对于拥有数十亿事件的大型系统，这可能需要几天甚至几周的时间。有方法可以提高投影的性能，我将在讨论事件源的高级主题时提到这些方法。然而，请记住，默认情况下，事件是按顺序投影的，顺序非常重要。因此，我们在消息世界中应用的常规技术，如用于水平扩展的竞争消费者，并不直接适用于投影。然而，通过将`$all`流根据给定的属性分割成几个流，可以分区投影。用JavaScript编写并直接在服务器上运行的Event
    Store投影可用于此目的。
- en: While we have gone through some quite advanced topics already, the last few
    chapters have been very technical. In [Chapter 13](https://www.packtpub.com/sites/default/files/downloads/Splitting_the_System.pdf),
    *Splitting the System,* we return to the concepts of **Domain-Driven Design** (**DDD**),
    and will discuss the most important idea of DDD—that no complex system in the
    problem space can be implemented as a single system in the solution space. We
    will go on to the topic of bounded context and context mapping.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经讨论了一些相当高级的主题，但最后几章内容非常技术性。在[第13章](https://www.packtpub.com/sites/default/files/downloads/Splitting_the_System.pdf)，《系统拆分》中，我们回到了**领域驱动设计**（**DDD**）的概念，并将讨论DDD最重要的思想——在问题空间中，没有复杂的系统可以作为一个解决方案空间中的单一系统来实现。我们将继续讨论边界上下文和上下文映射。
