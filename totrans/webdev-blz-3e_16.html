<html><head></head><body>
<div><h1 class="chapterNumber">16</h1>
<h1 class="chapterTitle" id="_idParaDest-253">Going Deeper into WebAssembly</h1>
<p class="normal">In this chapter, we will go deeper into technologies that are only relevant for Blazor <strong class="keyWord">WebAssembly</strong>.</p>
<p class="normal">Most things in Blazor can be applied to Blazor Server and Blazor WebAssembly. Still, since Blazor WebAssembly runs inside the web browser, we can do some things to optimize the code and use other libraries that we can’t use server-side.</p>
<p class="normal">We will also look at some common problems and how to solve them.</p>
<p class="normal">In this chapter, we will cover the following:</p>
<ul>
<li class="bulletList">Exploring the WebAssembly template</li>
<li class="bulletList">.NET WebAssembly build tools</li>
<li class="bulletList">AOT compilation</li>
<li class="bulletList">WebAssembly <strong class="keyWord">Single Instruction, Multiple Data</strong> (<strong class="keyWord">SIMD</strong>)</li>
<li class="bulletList">Trimming</li>
<li class="bulletList">Lazy loading</li>
<li class="bulletList">Progressive web apps</li>
<li class="bulletList">Native dependencies</li>
<li class="bulletList">Common problems</li>
</ul>
<p class="normal">Some parts of this chapter are a great opportunity to follow along, while other parts are for reference so that you can find the right information when you need it.</p>
<h1 class="heading-1" id="_idParaDest-254">Technical requirements</h1>
<p class="normal">This chapter is a reference chapter and is not connected with the book’s other chapters. You can find the source code for this chapter’s result at <a href="https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter16">https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter16</a>.</p>
<h1 class="heading-1" id="_idParaDest-255">Exploring the WebAssembly template</h1>
<p class="normal">The WebAssembly template<a id="_idIndexMarker593"/> looks slightly different from the templates we looked at in <em class="chapterRef">Chapter 2</em>, Creating Your First Blazor App. In the Blazor Web App template, our entry point is the <code class="inlineCode">app.razor</code> file. It contains the HTML tags we need to get started. The WebAssembly template had an <code class="inlineCode">Index.html</code> file. Let’s create a project so we can take a look:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Create a new project and use the <code class="inlineCode">Blazor WebAssembly Standalone App</code> template.</li>
<li class="numberedList">Name the project <code class="inlineCode">BlazorWebAssembly</code>.</li>
<li class="numberedList">Leave the defaults as is and press <strong class="screenText">Create</strong>.</li>
</ol>
<p class="normal">First, in the <code class="inlineCode">wwwroot</code> folder, we have a <code class="inlineCode">Index.html</code> that has all the CSS, JavaScript, and so on. This is the same content as the <code class="inlineCode">App.razor</code> file in the Blazor Web App template. We have an <code class="inlineCode">app.razor</code> file in the WebAssembly project as well, but that contains the same things as the <code class="inlineCode">Routes.razor</code> file. So it is a bit confusing if we work with both templates.</p>
<p class="normal">Let’s take a look at each file but only focus on the things that are specific to WebAssembly. In <code class="inlineCode">Index.html</code>, we have some interesting code:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;div id="app"&gt;
    &lt;svg class="loading-progress"&gt;
        &lt;circle r="40%" cx="50%" cy="50%" /&gt;
        &lt;circle r="40%" cx="50%" cy="50%" /&gt;
    &lt;/svg&gt;
    &lt;div class="loading-progress-text"&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p class="normal">This is a <code class="inlineCode">div</code>, and the content is a progress bar showing the WebAssembly loading progress. In the <code class="inlineCode">css/app.css</code> file, we have this:</p>
<pre class="programlisting code"><code class="hljs-code">.loading-progress circle:last-child {
    stroke: #1b6ec2;
    stroke-dasharray: calc(3.141 * var(--blazor-load-percentage, 0%) * 0.8), 500%;
    transition: stroke-dasharray 0.05s ease-in-out;
}
.loading-progress-text:after {
    content: var(--blazor-load-percentage-text, "Loading");
}
</code></pre>
<p class="normal">These are just some of the CSS classes for the loading progress, but what is interesting is that Blazor will give us two CSS values, <code class="inlineCode">--blazor-load-percentage-text</code> and <code class="inlineCode">--blazor-load-percentage</code>. This gives us some indication of how much time is left when loading our WebAssembly app. This is a great way to customize our progress indicator. The content of the <code class="inlineCode">div</code> will be replaced by the WebAssembly app once it has loaded.</p>
<p class="normal">If we take a look at <code class="inlineCode">Program.cs</code>, it contains <a id="_idIndexMarker594"/>a bit more now when we are running WebAssembly standalone:</p>
<pre class="programlisting code"><code class="hljs-code">var builder = WebAssemblyHostBuilder.CreateDefault(args);
builder.RootComponents.Add&lt;App&gt;("#app");
builder.RootComponents.Add&lt;HeadOutlet&gt;("head::after");
builder.Services.AddScoped(sp =&gt; new HttpClient { BaseAddress = new Uri(builder.HostEnvironment.BaseAddress) });
await builder.Build().RunAsync();
</code></pre>
<p class="normal">Here, we set up our WebAssembly project and tell .NET that we want to render the <code class="inlineCode">app.razor</code> component in the <code class="inlineCode">HTML</code> tag with the <code class="inlineCode">id</code> app. We also tell .NET to render the <code class="inlineCode">HeadOutlet</code> as the last child of the <code class="inlineCode">head</code> tag.</p>
<p class="normal">Run the project and explore it for a bit. The components inside of the project are the same as the ones we have already looked at in <em class="chapterRef">Chapter 4</em>, <em class="italic">Understanding Basic Blazor Components</em>, so there is nothing new going on there.</p>
<p class="normal">When we start the project the first time, it takes a couple of seconds to load our app. This is when everything is downloaded and started. The next time our users visit our site, much of the files will be cached and we won’t need to download them again.</p>
<h1 class="heading-1" id="_idParaDest-256">.NET WebAssembly build tools</h1>
<p class="normal">When it comes to the more “advanced” scenarios, we need additional tooling installed. There are two ways of installing the tools. </p>
<p class="normal">We can select the <strong class="keyWord">.NET WebAssembly Build Tools</strong> option when <a id="_idIndexMarker595"/>installing Visual Studio (or add them using the Visual Studio installer) or run the following command in a command prompt (as administrator):</p>
<pre class="programlisting con"><code class="hljs-con">dotnet workload install wasm-tools
</code></pre>
<p class="normal">The .NET WebAssembly build tools are based<a id="_idIndexMarker596"/> on <strong class="keyWord">Emscripten</strong>, a compiler toolchain for the web platform.</p>
<h1 class="heading-1" id="_idParaDest-257">AOT compilation</h1>
<p class="normal">By default, the only thing that is running as WebAssembly in a Blazor WebAssembly app is the runtime. Everything else is ordinary .NET assemblies running on the browser using a .NET <strong class="keyWord">Intermediate Language</strong> (<strong class="keyWord">IL</strong>) interpreter<a id="_idIndexMarker597"/> implemented in WebAssembly.</p>
<p class="normal">I was not too fond of that when I started playing around with Blazor; it felt wasteful to run everything using IL instead of something the browser would understand natively. Then, I thought the browser was running the same code as I would on the server. The same code in the browser! That is pretty amazing!</p>
<p class="normal">However, we have the <a id="_idIndexMarker598"/>option to compile directly to WebAssembly; this is called <strong class="keyWord">ahead-of-time </strong>(<strong class="keyWord">AOT</strong>) compilation. It has a downside: the app download size will increase, but it will run and load faster.</p>
<p class="normal">An AOT-compiled app is generally twice the size of an IL-compiled app. AOT will take the .NET code and compile that directly into WebAssembly.</p>
<p class="normal">AOT does not trim managed assemblies, and more code is needed to represent high-level .NET IL instructions when using native WebAssembly. That is why the size is much larger, and it is also less compressible over HTTP.</p>
<p class="normal">AOT is not for everyone; most apps running without AOT will work fine. However, for CPU-intensive apps, there is a lot to gain by using AOT.</p>
<p class="normal">My ZX Spectrum emulator is one of those apps; it runs many iterations per second, and the performance gain by running AOT for these apps is remarkable.</p>
<p class="normal">To compile our Blazor WebAssembly project using AOT, we add the following property in the <code class="inlineCode">csproj</code> file:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;PropertyGroup&gt;
  &lt;RunAOTCompilation&gt;true&lt;/RunAOTCompilation&gt;
&lt;/PropertyGroup&gt;
</code></pre>
<p class="normal">AOT compilation is only performed when the app is published. It can take a long time to compile (seven minutes for the ZX Spectrum emulator), so it is pretty nice that we don’t have to wait for that every time we compile our application.</p>
<p class="normal">However, running in<a id="_idIndexMarker599"/> release mode may be a problem, so if you want to do a quick test in release mode, temporarily disable the preceding setting.</p>
<p class="normal">Don’t forget to enable it again; I have some experience in that area.</p>
<h1 class="heading-1" id="_idParaDest-258">WebAssembly Single Instruction, Multiple Data (SIMD)</h1>
<p class="normal">One <a id="_idIndexMarker600"/>of the new features in .NET7 is SIMD, a type of parallel processing recently added to WebAssembly.</p>
<p class="normal">SIMD is a type of computer architecture that allows a CPU to perform the same operation on multiple data points simultaneously, improving the performance of certain kinds of tasks. SIMD instructions are often used to perform vector arithmetic, in which a single instruction is applied to multiple elements of a vector simultaneously. SIMD can be beneficial for tasks such as image and video processing, where large amounts of data need to be processed quickly.</p>
<p class="normal">SIMD is enabled by default. To disable SIMD, we need to disable it in the project file like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;PropertyGroup&gt;
  &lt;WasmEnableSIMD&gt;false&lt;/WasmEnableSIMD&gt;
&lt;/PropertyGroup&gt;
</code></pre>
<p class="normal">We need to use AOT compilation for SIMD to work.</p>
<p class="normal">This is beyond the scope of this book, but I wanted to mention it in case this is what you need for your project.</p>
<h1 class="heading-1" id="_idParaDest-259">Trimming</h1>
<p class="normal">By default, when publishing a Blazor WebAssembly app, trimming<a id="_idIndexMarker601"/> will be performed. It will remove unnecessary things and, by doing so, reduce the size of the app.</p>
<p class="normal">If our application uses reflection, the trimmer may have problems identifying what can and cannot be removed.</p>
<p class="normal">For most applications, the trimming is automatic and will work. To read more about trimming options, you can look here: <a href="https://learn.microsoft.com/en-us/dotnet/core/deploying/trimming/trimming-options?pivots=dotnet-8-0">https://learn.microsoft.com/en-us/dotnet/core/deploying/trimming/trimming-options?pivots=dotnet-8-0</a>.</p>
<h1 class="heading-1" id="_idParaDest-260">Lazy loading</h1>
<p class="normal">When working with Blazor <a id="_idIndexMarker602"/>WebAssembly, one of the challenges is download size. Even though it’s not a big problem, in my opinion, we can do some things to handle the download and loading time. We will get back to this in the <em class="italic">Common problems</em> section later in this chapter.</p>
<p class="normal">When navigating to a Blazor WebAssembly application, all the DLLs for our application and the DLLs from .NET Framework are downloaded. It takes a bit of time to get everything started up. We can load some DLLs when needed by using<strong class="keyWord"> lazy loading</strong> to solve this.</p>
<p class="normal">Let’s say that our application is massive where it has a reporting part. Reporting is perhaps not used every day and not used by everyone, and it would make sense to remove that part from the initial download and only load it when we need to.</p>
<p class="normal">To make that happen, the part we want to lazy load must be in a separate project/DLL. In the <code class="inlineCode">csproj</code> file of the Blazor WebAssembly client project, add a reference to the DLL by adding the following code:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;ItemGroup&gt;
  &lt;BlazorWebAssemblyLazyLoad Include="{ASSEMBLY NAME}.dll" /&gt;
&lt;/ItemGroup&gt;
</code>
LazyAssemblyLoader</code>.</pre>
<p class="normal">The <code class="inlineCode">LazyAssemblyLoader</code> service will make a JS interop call to download the assembly and load it into the runtime.</p>
<p class="normal">We make sure to download the <a id="_idIndexMarker603"/>necessary assemblies/DLLs in the router (<code class="inlineCode">App.razor</code>) so we make sure they are downloaded before we navigate to the component that is using them:</p>
<pre class="programlisting code"><code class="hljs-code">@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.WebAssembly.Services
@using Microsoft.Extensions.Logging
@inject LazyAssemblyLoader AssemblyLoader
@inject ILogger&lt;App&gt; Logger
&lt;Router AppAssembly="@typeof(App).Assembly" 
    OnNavigateAsync="@OnNavigateAsync"&gt;
    ...
&lt;/Router&gt;
@code {
    private async Task OnNavigateAsync(NavigationContext args)
    {
        try
           {
               if (args.Path == "{PATH}")
               {
                   var assemblies = await AssemblyLoader.LoadAssembliesAsync(
                       new[] { {LIST OF ASSEMBLIES} });
               }
           }
           catch (Exception ex)
           {
               Logger.LogError("Error: {Message}", ex.Message);
           }
    }
}
</code></pre>
<p class="normal">We need to inject <code class="inlineCode">LazyAssemblyLoader</code>; it is registered as a singleton by default in a Blazor WebAssembly project.</p>
<p class="normal">You need to set up an <code class="inlineCode">OnNavigateAsync</code> event, and in that method, check the path and make sure to load the assemblies we need.</p>
<p class="normal">This event can also be used for routable components by doing something similar to this:</p>
<pre class="programlisting code"><code class="hljs-code">@using System.Reflection
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.WebAssembly.Services
@using Microsoft.Extensions.Logging
@inject LazyAssemblyLoader AssemblyLoader
@inject ILogger&lt;App&gt; Logger
&lt;Router AppAssembly="@typeof(App).Assembly" 
    AdditionalAssemblies="@lazyLoadedAssemblies" 
    OnNavigateAsync="@OnNavigateAsync"&gt;
    ...
&lt;/Router&gt;
@code {
    private List&lt;Assembly&gt; lazyLoadedAssemblies = new();
    private async Task OnNavigateAsync(NavigationContext args)
    {
        try
           {
               if (args.Path == "{PATH}")
               {
                   var assemblies = await AssemblyLoader.LoadAssembliesAsync(
                       new[] { {LIST OF ASSEMBLIES} });
                   lazyLoadedAssemblies.AddRange(assemblies);
               }
           }
           catch (Exception ex)
           {
               Logger.LogError("Error: {Message}", ex.Message);
           }
    }
}
</code>
"/fetchdata"</code>. The <code class="inlineCode">{LIST OF ASSEMBLIES}</code>, which contains a list of assemblies we wish to load, can be <code class="inlineCode">"sample.dll"</code>.</pre>
<p class="normal">This makes it possible not to <a id="_idIndexMarker604"/>load the admin interface for the users who don’t have access to it, for example. We can of course trigger the downloading of additional assemblies when it makes sense to do so (and not wait for a user to hit a specific part of the application and then download the assemblies).</p>
<h1 class="heading-1" id="_idParaDest-261">Progressive web apps</h1>
<p class="normal">Both Blazor Server and Blazor <a id="_idIndexMarker605"/>WebAssembly can create <strong class="keyWord">Progressive Web Apps</strong> (<strong class="keyWord">PWAs</strong>), but it is much more common for Blazor WebAssembly. PWAs make it possible to download our web app and run it as an app on our phone or computer. They will make it possible to add nice-looking icons and launch our website in a web browser without a URL input field, so it will feel more like an app.</p>
<p class="normal">When creating our project, we select <strong class="screenText">Progressive Web App</strong>. By doing that, we will get some configuration and JavaScript to set everything up.</p>
<p class="normal">PWAs are beyond the scope of this book, but there are great resources to get us started. You can find more information<a id="_idIndexMarker606"/> here: <a href="https://learn.microsoft.com/en-us/aspnet/core/blazor/progressive-web-app?view=aspnetcore-8.0&amp;tabs=visual-studio">https://learn.microsoft.com/en-us/aspnet/core/blazor/progressive-web-app?view=aspnetcore-8.0&amp;tabs=visual-studio</a>.</p>
<h1 class="heading-1" id="_idParaDest-262">Native dependencies</h1>
<p class="normal">Since we are running<a id="_idIndexMarker607"/> WebAssembly, we can use WebAssembly assemblies written in other languages in our project. This means that we can use any native dependencies right inside our project.</p>
<p class="normal">One way is to add C files right into our project. In the <code class="inlineCode">Chapter16</code> folder in the repository, you will find an example.</p>
<p class="normal">I have added a file called <code class="inlineCode">Test.c</code> with the following content:</p>
<pre class="programlisting code"><code class="hljs-code">int fact(int n)
{
    if (n == 0) return 1;
    return n * fact(n - 1);
}
</code></pre>
<p class="normal">In the project file, I have added a reference to that file:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;ItemGroup&gt;
    &lt;NativeFileReference Include="Test.c" /&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p class="normal">In <code class="inlineCode">Home.razor</code>, I have added the following code:</p>
<pre class="programlisting code"><code class="hljs-code">@page "/"
@using System.Runtime.InteropServices
&lt;PageTitle&gt;Native C&lt;/PageTitle&gt;
&lt;h1&gt;Native C Test&lt;/h1&gt;
&lt;p&gt;
    @@fact(3) result: @fact(3)
&lt;/p&gt;
@code {
    [DllImport("Test")]
    static extern int fact(int n);
}
</code></pre>
<p class="normal">In our C# project, we<a id="_idIndexMarker608"/> now have a C file that we can call from our Blazor project. It is compiled into WebAssembly, and then we can reference that WebAssembly file (which happens automatically). We can take this even further by using a library that is using a C++ library. Skia is an open-source graphics engine written in C++.</p>
<p class="normal">Read more here: <a href="https://github.com/mono/SkiaSharp">https://github.com/mono/SkiaSharp</a>. We can add that library to a Blazor WebAssembly app by adding the NuGet package <code class="inlineCode">SkiaSharp.Views.Blazor</code>.</p>
<p class="normal">In the <code class="inlineCode">Chapter16</code> folder in the repository, you can explore a project called <code class="inlineCode">SkiaSharpDemo</code>.</p>
<p class="normal">In the <code class="inlineCode">Home.razor</code> file, I have added the following code:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;SKCanvasView OnPaintSurface="@OnPaintSurface" /&gt;
@code {
    private void OnPaintSurface(SKPaintSurfaceEventArgs e)
    {
        var canvas = e.Surface.Canvas;
        canvas.Clear(SKColors.White);
        using var paint = new SKPaint
        {
            Color = SKColors.Black,
            IsAntialias = true,
            TextSize = 24
        };
        canvas.DrawText("Raccoons are awesome!", 0, 24, paint);
    }
}
</code></pre>
<p class="normal">The page will draw <code class="inlineCode">"Raccoons are awesome"</code> on the canvas.</p>
<p class="normal">In this case, we are using a C# library that is using a C++ library.</p>
<p class="normal">We can even refer to libraries that have already been built with Emscripten directly by adding <strong class="keyWord">object files</strong> (<code class="inlineCode">.o</code>), <strong class="keyWord">archive files</strong> (<code class="inlineCode">.a</code>), <strong class="keyWord">bitcode</strong> (<code class="inlineCode">.bc</code>), and <strong class="keyWord">standalone WebAssembly modules</strong> (<code class="inlineCode">.wasm</code>). If we find a library written in another language, we could compile that to WebAssembly and then <a id="_idIndexMarker609"/>use it from our Blazor application. This opens up so many doors!</p>
<p class="normal">Next, we will look at some common problems I have encountered.</p>
<h1 class="heading-1" id="_idParaDest-263">Common problems</h1>
<p class="normal">Let’s dive into this one right from the start.</p>
<p class="normal">The most common comments regarding Blazor WebAssembly are download size and load time. A small project is around 1 MB in size, but I believe the problem is the loading time and not the download size/time since everything is cached and, in most parts of the world, we have access to high-speed internet.</p>
<p class="normal">There are a couple of solutions to this problem.</p>
<h2 class="heading-2" id="_idParaDest-264">Progress indicators</h2>
<p class="normal">When it comes to <strong class="keyWord"><a id="_idIndexMarker610"/></strong><strong class="keyWord">User Experience</strong> (<strong class="keyWord">UX</strong>), we can give the users a perceived sense of speed.</p>
<p class="normal">The default Blazor WebAssembly template has a loading progress indicator, which gives the users something to look at instead of a blank page. It is built so that it is easy to customize using CSS variables. We can use the <code class="inlineCode">--blazor-load-percentage</code> and <code class="inlineCode">--blazor-load-percentage-text</code> variables to customize and create our progress bar.</p>
<p class="normal">It doesn’t even have to indicate what is happening; Dragons Mania Legends has comments like “Sewing mini Vikings,” which is obviously not what is going on. So depending on the application we are building, showing something is more important than showing nothing.</p>
<h2 class="heading-2" id="_idParaDest-265">Prerendering on the server</h2>
<p class="normal">In previous versions of Blazor, we had to do some magic ourselves to make <a id="_idIndexMarker611"/>prerendering work. But with the new Blazor Web App template, we get this out of the box. Up until now, we have talked about features in Blazor WebAssembly using the Blazor WebAssembly Standalone template; in this section, we are using the Blazor Web App template. The better solution is to run it as <code class="inlineCode">InteractiveAuto</code>; that way, we get the power of fast loading on the server, and then get WebAssembly without the wait. </p>
<p class="normal">This is a great and simple way to add SEO to our site.</p>
<p class="normal">There is one problem: it will load data when rendering on the server, and then again when the WebAssembly loads.</p>
<p class="normal">There is a way to work around that, which we will take a look at next.</p>
<h2 class="heading-2" id="_idParaDest-266">Preloading and persisting the state</h2>
<p class="normal">We don’t want our <a id="_idIndexMarker612"/>component to call the database twice if we can avoid it.</p>
<p class="normal">If you run the <code class="inlineCode">BlazorPrerender</code> example and go to the <strong class="keyWord">Weather</strong> page, you should be able to see it load twice <a id="_idIndexMarker613"/>since the data is random and generated every time we request it.</p>
<p class="normal">This is the same behavior you see when using <code class="inlineCode">InteractiveServer, InteractiveWebAssembly, and InteractiveAuto</code>. The page first gets rendered on the server. Then, SignalR or WebAssembly gets hooked up and loads the page again.</p>
<p class="normal">The source for this example is the <code class="inlineCode">BlazorPrerender</code> project.</p>
<p class="normal">We used this technique when we passed information about the logged-in user to WebAssembly.</p>
<p class="normal">In previous versions of Blazor, we had to add a component called <code class="inlineCode">persist-component-state</code>, but this component is added by default in .NET 8. This component will render the saved state of the component when it renders on the server, and, when SignalR or WebAssembly takes over, the state is already there.</p>
<p class="normal">In the Client project and in the component where we want to have the persistence (<code class="inlineCode">Weather.razor</code> in the sample), we inject a <code class="inlineCode">PersistanceComponentState</code> and also make the component implement <code class="inlineCode">Idisposable</code>:</p>
<pre class="programlisting code"><code class="hljs-code">@inject PersistentComponentState ApplicationState
@implements IDisposable
</code></pre>
<p class="normal">We add a <code class="inlineCode">PersistingComponentStateSubscription</code> component, which saves the data to the application state:</p>
<pre class="programlisting code"><code class="hljs-code">private PersistingComponentStateSubscription _subscription;
</code></pre>
<p class="normal">In <code class="inlineCode">OnInitializedAsync</code>, we register to listen to run code when the component wants to persist the data:</p>
<pre class="programlisting code"><code class="hljs-code">_subscription = ApplicationState.RegisterOnPersisting(PersistState);
</code></pre>
<p class="normal">When we load the data, we <a id="_idIndexMarker614"/>make sure first to check the application state. If the data is <a id="_idIndexMarker615"/>not available, we can continue and make an <code class="inlineCode">HTTP</code> request:</p>
<pre class="programlisting code"><code class="hljs-code">if (ApplicationState.TryTakeFromJson&lt;WeatherForecast[]&gt;("weatherdata", out var stored))
{
    forecasts = stored;
}
else
{
    await Task.Delay(500);
    var startDate = DateOnly.FromDateTime(DateTime.Now);
    var summaries = new[] { "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Balmy", "Hot", "Sweltering", "Scorching" };
    forecasts = Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast
        {
            Date = startDate.AddDays(index),
            TemperatureC = Random.Shared.Next(-20, 55),
            Summary = summaries[Random.Shared.Next(summaries.Length)]
        }).ToArray();
}
</code></pre>
<p class="normal">It refers to a method that will persist the data in the application state:</p>
<pre class="programlisting code"><code class="hljs-code">private Task PersistState()
{
    ApplicationState.PersistAsJson("weatherdata", forecasts);
    return Task.CompletedTask;
}
public void Dispose()
{
    _subscription.Dispose();
}
</code></pre>
<p class="normal">The server will first render the content, and when the server is done, it will respond with the whole page, including a <code class="inlineCode">Base64</code>-encoded JSON string with data that looks something like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;!--Blazor:{"type":"server","prerenderId":"d0b382c5fa7d4b65a8002157a8b6a1 a2","key":{"locationHash":"F2AAEE86A5A9C5406A2EF4551C02A263059448AC:0","formattedComponentKey":""},"sequence":0,"descriptor":"CfDJ8EzYgDK6\u002BdZLqM2gwGUPDtNbwNLH7VoJxc6/d6CZ4gHE0LtdIMqSoBfSh8OHGynUVW5DKNVBSG4cZBgETzOixExgSkzmqvPY7I58TMjl4XliAJ ae5d2fmVTS7\u002ByDOooQOqVN41jgj\u002BthTcmHEkBng1MukO5/28AsARyCKVXGxlw3cu9ohFo6b38BprF63EPjo7zQqNYRQT2k xkxn9TiFzTga//RyoyQKIwvEkb044SW\u002Bj9tHP1bBt3B8rpE5EATAvbtKEu7yjwUFGb3xsDHvJ6jGAtQOKOXQhKoWM5pp8 z0RMKkxMfeyuQUubu7i48qPSPvvWCnoym79o64FsTlataWG9JeO8V1X9ihTQppyw/
jkc0RHp9Si49UgCVlEuPWMXTjVSVj7gBizQRc7eT0t2v30NwpBrYHvQS0t\u002BgssPyT\u002BTQWCfEcEc7iMboA/oCSqcAJRTWCcGbWroCIKchU1mdTJj48vAuMKKu5tw6Yqo61V\u002BM4wTR7XJ1ffk0KCQ7lKCqNr2ffNRz1RxjbQX8oVU4s="}--&gt;
</code></pre>
<p class="normal">Since everything we put into the application state is stored as JSON, it is important not to include any sensitive data that we were not thinking of displaying. This is, of course, true for all calls since we are sending data with JSON.</p>
<p class="normal">We can<a id="_idIndexMarker616"/> also use <code class="inlineCode">PersistentComponentState</code> on <code class="inlineCode">InteractiveServer, InteractiveWebAssembly, and </code><code class="inlineCode"><a id="_idIndexMarker617"/></code><code class="inlineCode">InteractiveAuto</code>. I usually turn off prerendering on my websites, but this is great to use if your site needs SEO, for example. </p>
<p class="normal">Now, we know a couple of common problems and how to solve them.</p>
<h1 class="heading-1" id="_idParaDest-267">Summary</h1>
<p class="normal">In this chapter, we looked at some of the Blazor WebAssembly-specific things in Blazor. For the most part, we can reuse components in both Blazor Server and Blazor WebAssembly, and we can speed up WebAssembly by using what we learned in this chapter.</p>
<p class="normal">We also looked at native dependencies, opening up the possibilities to reuse other libraries and mixing languages. If our application doesn’t need to support both scenarios, we can use WebAssembly to the fullest.</p>
<p class="normal">In the next chapter, we will examine <em class="italic">source generators</em>.</p>
</div>
</body></html>