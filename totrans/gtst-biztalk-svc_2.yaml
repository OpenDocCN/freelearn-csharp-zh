- en: Chapter 2. Messages and Transforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 1](ch01.html "Chapter 1. Hello BizTalk Services"), *Hello BizTalk
    Services*, we discussed the basics of **BizTalk Services** and the central concept
    of a bridge providing the vehicle for receiving and sending data via endpoint
    adapters (sources and destinations) through its built-in pipeline. In this chapter,
    we''ll discuss messaging aspects, focusing on one particular aspect of messaging:
    transformation, or mapping. One of the most common aspects of integration is the
    need to turn one message format into another; what we referred to as structural
    impedance in [Chapter 1](ch01.html "Chapter 1. Hello BizTalk Services"), *Hello
    BizTalk Services*. It''s the bread and butter of any integrator''s toolbox, and
    BizTalk Services provides a brand new, modern mapping engine with graphical tooling
    to build sophisticated and powerful transforms. In this chapter, we''ll look at
    BizTalk Service''s mapping and transformation capabilities in detail and the flexibility
    it provides. To summarize, this chapter will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Why transformation and mapping is important
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping capabilities in BizTalk Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding mapping operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'BizTalk Services'' job is to let you connect this to that. What this and that
    actually are may not always be clear, well defined, or standardized into some
    internationally recognized protocol. A mapping capability is therefore crucial—a
    way to convert this into that. On many occasions, mapping requirements may be
    complex; the need to fundamentally change the shape or structure of a message,
    for example, or the need to replace data values from the source message with something
    that makes sense to the receiver. We can break this down into two classes of problems:
    one that needs to address the structure of a message, transformation; and one
    that needs to address its content, transcoding or translating it. The two types
    of mapping, transformation and translation, are both possible with BizTalk Services,
    as we''ll see in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: The mapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we''re being deliberately vague, and with good reason. Often, mapping
    requirements are not well known and change as more is discovered about the nuances
    of the messaging formats involved and their variations. It often surprises people
    familiar with dealing with XML-based messages that describing their validity simply
    in terms of schema by using XML Schema Definition ([http://www.w3.org/XML/Schema](http://www.w3.org/XML/Schema))
    can turn out to be more complicated than it first appears. This is unfortunately
    sometimes to do with the different productions or instances of XML messages that
    can be created or produced by a single schema, often unintentionally. XSD is sometimes
    not precise enough, and integration is therefore often messy, requiring good tools
    to make things fit, while the purity of standards and specifications doesn''t
    go far enough to avoid ambiguity in implementation. This is a theme we''ll come
    back to many times during this book: to be successful, any integration technology
    must be flexible to bend to the problem at hand, to fit into that, to not be changed,
    to adapt, to transform, and to integrate. Mapping is one tool in the box, and
    is a very important one to meet these requirements. As such, it deserves a chapter
    all to itself.'
  prefs: []
  type: TYPE_NORMAL
- en: The map designer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take a look at the following screenshot. This shows the new graphical mapping
    designer that is accessible from Visual Studio 2012\. For those familiar with
    **BizTalk Server**, don't be fooled. While it may have a similar look and feel
    to the BizTalk Server mapper, this tool has significant differences; the overriding
    design aesthetic was to make common mapping tasks as simple as possible, and as
    such, the mapper has undergone a significant overhaul.
  prefs: []
  type: TYPE_NORMAL
- en: '![The map designer](img/7401EN_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Graphical mapping designer
  prefs: []
  type: TYPE_NORMAL
- en: Schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: However, we're getting ahead of ourselves. In order to map one message format
    or structure to another, to translate its contents for example, we first need
    to understand the messages themselves. Fundamental to this is schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'BizTalk Services differentiates between two types of messages: XML and non-XML.
    All XML message formats are expressed using XSD, and all non-XML message formats
    are expressed using XSD. So, XSD is important! The purpose of this book is not
    to provide a primer in XSD; we''ll refer to other references if you need some
    background on the technologies we mention. Instead, we''ll provide just enough
    to show how BizTalk Services uses such technologies so that the less familiar
    can still understand what is going on.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you're probably wondering how any message formats you can think up can
    be defined in XSD. Let's look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: An example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's expand on the example we looked at in [Chapter 1](ch01.html "Chapter 1. Hello
    BizTalk Services"), *Hello BizTalk Services*. If you recall, this example received
    a file via SFTP and routed it to a Service Bus endpoint. Now we'll add a map to
    the solution. The map will transform the incoming message into a different format
    expected by the recipient. However, as noted previously, if we're to turn one
    message format into another, we need to define the schema of the target message
    first in order for us to be able to map to it.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, right-click on the project, navigate to **Add** | **New Item**,
    select **Schema** from the list of items, and provide the name `OrderUS.xsd`.
    Click on **Add** to create the schema and add it to the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The schema designer will now be open. As you did in [Chapter 1](ch01.html "Chapter 1. Hello
    BizTalk Services"), *Hello BizTalk Services*, add nodes to the schema to build
    it up, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example](img/7401EN_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Changing the Order schema
  prefs: []
  type: TYPE_NORMAL
- en: Now, right-click on the project and navigate to **Add** | **New Item**. Select
    **Map** from the list of items and provide the name `FFtoUS.trfm`. Click on **Add**
    to create the map and add it to the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The map designer will now open; the first task is to set the schemas. As a
    map''s job is to convert one format to another, a minimum of two schemas are required:
    the input and the output.'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Open Source Schema** link, expand the tree, select `OrderFF.xsd`,
    and click on **OK**. Now click on the **Open Destination Schema** link, select
    the `OrderUS.xsd` schema, and click on **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The designer will now look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example](img/7401EN_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Selecting schema with the designer
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to map one format to another. We do this by connecting the nodes
    together, usually working from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: Join the `OrderId` node on the left-hand side to the `OrderNumber` node on the
    right-hand side by clicking and holding the left mouse button while dragging across
    to the right-hand side and releasing the button when the pointer is over the target
    field.
  prefs: []
  type: TYPE_NORMAL
- en: Now notice that the customer information is different in the target schema and
    the source; only the element names are different, but the structure is the same.
    The mapper provides a shortcut for mapping fields quickly to avoid having to connect
    them one by one. To do this, click and hold the left mouse button down on the
    parent `Customer` node in the left-hand side source schema and drag across to
    the target's `CustomerDetails` node. The context menu shown in the next screenshot
    will pop up. Here, we are presented with a number of options as shown in the following
    screenshot. Select **Link by Structure** and notice that all the nodes are connected
    together automatically even though their names differ. This is because this option
    connects fields in the order they appear, regardless of the node names, and is
    useful when the structure of both schemas is the same. You can use the same approach
    for mapping where the field names match too (**Link by Name**) or select **Simple
    Link** which will simply connect the top-level nodes together. This technique
    is very useful when mapping a large number of fields.
  prefs: []
  type: TYPE_NORMAL
- en: '![An example](img/7401EN_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Linking options
  prefs: []
  type: TYPE_NORMAL
- en: Mapping operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can proceed like this for as many nodes as we like, connecting them individually
    or in groups. However, we often need to do more than just map one node's value
    to another. For this, we can turn to mapping operations. For those acquainted
    with BizTalk Server, you will be familiar with **functoids**; the concept is similar
    in BizTalk Services. However, despite the similarities, there are many differences
    in how they are realized. One of the primary goals of the product group is to
    simplify common tasks, such as looping, which were often difficult or time consuming
    to achieve previously. This is where we will now focus our attention.
  prefs: []
  type: TYPE_NORMAL
- en: 'BizTalk Services provides a total of 37 mapping operations that are functionally
    grouped into categories in the toolbox. There isn''t room here to cover every
    mapping operation, so we''ll focus on some of the most useful. For a complete
    reference, check the MSDN documentation at [http://msdn.microsoft.com/en-us/library/windowsazure/hh689870.aspx](http://msdn.microsoft.com/en-us/library/windowsazure/hh689870.aspx).
    The idea is that all mapping operations are configured and connected in the same
    way; so, once you''ve learnt the operations available, it becomes a straightforward
    case of using a combination of them to get the mapping job done. The mapping operation
    categories are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Category** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| String operations | Manipulate node values as strings such as concatenation,
    trimming, and substring operations |'
  prefs: []
  type: TYPE_TB
- en: '| Loop operations | Operations to loop round repeating nodes in source |'
  prefs: []
  type: TYPE_TB
- en: '| Expressions | Arithmetic and logical expressions to perform calculations
    or decisions |'
  prefs: []
  type: TYPE_TB
- en: '| List operations | Processing for lists of items that can be created from
    node content in a conditional way for further processing |'
  prefs: []
  type: TYPE_TB
- en: '| Cumulative operations | Operations to accumulate values such as sums, counts,
    and averages |'
  prefs: []
  type: TYPE_TB
- en: '| Date and time operations | Manipulate date and time values |'
  prefs: []
  type: TYPE_TB
- en: '| Miscellaneous operations | Various operations for retrieving context properties,
    formatting numbers, and incorporating C# in your maps |'
  prefs: []
  type: TYPE_TB
- en: A very common type of transformation is flattening. This is where a number of
    repeating items (usually a list) needs to be consolidated (or flattened) into
    a single value, often with some calculation applied (for example, a summation).
    BizTalk Services provides several mapping operations to achieve this in a straightforward
    way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following XML and you can see that the `<Product>` element
    repeats, that is, there can be more than one product specified. Let''s say we
    want to calculate the sum of all the product prices (`Price`) multiplied by the
    quantity (`Qty`) ordered to work out the total value of the order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The final result, the total value of the order, then needs to be mapped to a
    single field in the target schema. We can use mapping operations to easily achieve
    this. The key to using mapping operations successfully is to break down the requirements
    and select the most appropriate mapping operations to achieve the goal. As my
    explanation has already hinted at, there are several parts to this problem. The
    first of these is to realize that we need to keep a running total of each of the
    `Qty * Price` field calculations—one for each `Product` element. Let's deal with
    that first.
  prefs: []
  type: TYPE_NORMAL
- en: BizTalk Services provides a set of list-based mapping operations that allow
    the creation of a temporary list to store items and manipulate the items in the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: First drag a **Create List** mapping operation onto the design surface. Perhaps
    the first obvious change to a BizTalk Server developer is that mapping operations
    in BizTalk Services provide nesting. This is the key to simplifying complex tasks
    as this nesting behavior provides a natural way to group and organize the mapping
    task required.
  prefs: []
  type: TYPE_NORMAL
- en: The **Create List** operation will be used to hold the temporary results from
    our calculations. We will push each product's total to the list and then calculate
    the sum of these list item values later. Double-click on **Create List** to configure
    it. In the dialog, type a **Member Name**, say `total`, and select **Number**
    from the dropdown for the **Member Type**, as shown in the following screenshot.
    This is a variable that will be used to store the value of our calculations. Click
    on **OK** to close the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: '![Mapping operations](img/7401EN_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuring the Create List operation
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to loop round all the `Product` elements. To do this, drag
    a **ForEach** mapping operation and drop it inside the **Create List** operation.
    Notice how we can place additional operations inside this operation too. This
    is where we'll put the calculation of each line item's total.
  prefs: []
  type: TYPE_NORMAL
- en: Now wire up the `Product` node in the left-hand schema to the **ForEach** operation.
    This tells the operation to loop round each `Product` node within `Products`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag an **Arithmetic Expression** operation across to the designer and drop
    it in the **ForEach** operation. Now wire up the `Qty` and `Price` fields to this
    operation. These will be our input parameters; the nodes from the input message
    we want to use the data from. Taking each node in turn, drag a connection onto
    the **Arithmetic Expression** operation on the canvas. Now double-click on the
    new **Arithmetic Expression** to configure it. Here we can specify a calculation
    based on the fields that are connected to the operation, in this case `Qty` and
    `Price`. Enter the expression shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mapping operations](img/7401EN_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuring the Arithmetic Expression operation
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to store this result; to do this, we''ll add it to the outer list
    operation. Drag an **Add Item to List** operation and drop it to the right of
    the **Arithmetic Expression** operation, within the **ForEach** operation. Then,
    connect the **Arithmetic Expression** operation to the **Add Item to List** operation
    by dragging a line from one to the other. Double-click on the **Add Item to List**
    operation to configure it. The dialog should be pre-populated already, so we can
    just click on **OK** to save the settings. The map should now look as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mapping operations](img/7401EN_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Partially-completed map
  prefs: []
  type: TYPE_NORMAL
- en: OK, the first part of the task is done; we are calculating the total value for
    each product. We now need to add these totals together to obtain the grand total
    for the order. This is very straightforward. Drag a **Select Entries** mapping
    operation and drop it to the right of the **Create List** operation. Connect the
    **Create List** operation to **Select Entries**. Double-click on **Select Entries**
    to open it, check the **Selected** checkbox next to `total`, and click on **OK**
    as shown in the following screenshot. Here, we are specifying what variables we
    want to extract from the list we've created. As we only have one in this case,
    the choice is easy.
  prefs: []
  type: TYPE_NORMAL
- en: '![Mapping operations](img/7401EN_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuration of the Select Entries operation
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, drag a **Cumulative Sum** operation and drop it to the right of the
    **Select Entries** operation. Connect the **Select Entries** operation to the
    **Cumulative Sum** operation. Now connect the **Cumulative Sum** operation to
    the `TotalValue` field in the target schema. Double-click on the **Cumulative
    Sum** operation you just added and enter `item.total` in the expression textbox,
    as shown in the following screenshot. Here, we are specifying our total variable
    from the list entries passed from the **Select Entries** operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mapping operations](img/7401EN_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuration of the Cumulative Sum operation
  prefs: []
  type: TYPE_NORMAL
- en: 'The completed map should look the same as the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mapping operations](img/7401EN_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Map with looping and calculated node
  prefs: []
  type: TYPE_NORMAL
- en: We're nearly there with our map. Let's tackle the `ShippingAddress` node. Notice
    that there are more fields on the left-hand side than the right. We're therefore
    going to consolidate these by concatenating some of them. There are a few ways
    to do this; we could use the **String Concatenate** mapping operation, for example,
    that can take any number of inputs and produce a concatenated single string as
    output.
  prefs: []
  type: TYPE_NORMAL
- en: However, let's look at something a little more interesting. When there isn't
    an operation that meets your need, you can turn to the **CSharp Scripting** operation.
    As its name implies, this operation allows you to include C# in its configuration,
    giving you the full power of the .NET framework to be able to implement whatever
    mapping functionality you need.
  prefs: []
  type: TYPE_NORMAL
- en: Drag a **CSharp Scripting** operation to the mapping design surface and drop
    it somewhere below the **Create List** operation. Connect the `Number`, `Street`,
    `City`, `State`, and `Country` nodes to it. As you've probably realized by now,
    this is the way operations can work on specific data items, and the same is true
    for the scripting operation. By connecting these items to it, they become available
    to the scripts we write. Double-click on the **CSharp Scripting** operation to
    open its configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the dialog, notice that there is a **Script Text** multiline textbox. Here,
    we can define a function in C# that will take the nodes as input parameters and
    return a value. In this simple case, you can see from the next screenshot that
    I am just concatenating the input parameters with some formatting and returning
    the result back to the map. Enter the following code to do the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that the names of the input nodes to the scripting operation must match
    the argument names in the code. If the names differ, the map won't compile. Once
    we've saved this by clicking on **OK**, we can connect the operation to the target
    schema's `Address` node.
  prefs: []
  type: TYPE_NORMAL
- en: '![Mapping operations](img/7401EN_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using C# with mapping
  prefs: []
  type: TYPE_NORMAL
- en: There are only a few fields left to map now. Simply connect `Recipient` to `FullName`
    and `PostCode` to `Zip`. The final operation we'll look at to complete this map
    is the **DateTime Reformat** operation. Drag this onto the design surface above
    the **Create List** operation. Connect the `OrderDate` node from both schemas
    to this operation, then double-click on the **DateTime Reformat** operation to
    configure it. This operation is useful when dealing with date formatting requirements
    that differ between sender and receiver. The nice thing about this operation is
    that it doesn't only support a fixed set of date and time formats, but you can
    enter your own as well. For the **Input Format** field, enter `d/M/yyyy` in the
    **Format** field. Note that this is not one of the provided options in the dropdown,
    so you'll need to enter it in the textbox, as shown in the following screenshot.
    Also, make sure that the letter `M` is capitalized, as is shown. Then, select
    **M/d/yyyy** for the **Output Format** field. This will interpret the input date
    in day/month/year format, for example, `2/9/2013`, and change to month/day/year
    format for the output, for example, `9/2/2013`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Mapping operations](img/7401EN_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Formatting dates
  prefs: []
  type: TYPE_NORMAL
- en: 'The map is now complete. It should look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mapping operations](img/7401EN_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The completed map
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Phew! This may seem quite complex, but it's really quite simple once you break
    it down. The next step is to test the map and see if it looks like it's producing
    the right results. Testing is built right into Visual Studio, so there's no need
    to compile and deploy the solution to Windows Azure in order to see if it works.
    This is important as creating anything other than trivial maps is a very iterative
    process. It's made easier by building up the functionality in the map gradually
    and examining the test results along the way. This way, any mistakes are much
    more obvious and easily corrected.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test a map, we need some input. This is most easily generated in Visual
    Studio itself. Right-click on the `OrderFF.xsd` schema in the **Solution Explorer**
    window and select **Generate Instance**. Open the file that''s created and edit
    the values to match the one shown in the following code (don''t forget, you can
    just download the source for this example from the website):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The **Generate Instance** action creates an XML-format message by default—which
    is what you need for the map itself. However, this schema is a flat file schema,
    and if we want to generate a message to pass into the bridge, we need to generate
    a message in this format. In the schema properties, there is a property called
    **Generate Instance Output Type** that can be set to **Native** instead of **XML**.
    When **Native** is selected, the schema will create a test message according to
    its type, flat file or XML. The following screenshot shows the results of setting
    this to **Native** when compared with the `OrderFF.xsd` schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing](img/7401EN_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Generate Instance: Native'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a test message, we can assign it to the map to try it. Click on
    the `FFtoUS.trfm` map in the **Solution Explorer** window; in the **Properties**
    window, enter the path to the file in the **Test Map Input File** property. Now
    right-click on the map and select **Test Map**. With any luck, you should see
    something similar to the following snippet in the output window. This means that
    the map execution worked!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the file from the **File** menu by navigating to **Open** | **File** and
    browsing to the to the file location in the preceding output (in this case: `C:\Users\Jon\AppData\Local\Temp\tmp3817.xml`).
    If you did everything right, it should look the same as the following XML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice how different this XML document is from the one you used as input and
    you can hopefully start to appreciate the power of the BizTalk Services mapper.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a bridge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A map is no good on its own though. We need to be able to use it in an integration
    solution. It should hopefully come as no surprise that the way we do this is by
    configuring a bridge. The next screenshot shows part of the bridge configuration.
    This configuration represents the pipeline of processing that can be configured.
    There are multiple stages to this pipeline, as mentioned in [Chapter 1](ch01.html
    "Chapter 1. Hello BizTalk Services"), *Hello BizTalk Services*. In the middle
    of the pipeline, there is a **Transform** stage; it is here that we can specify
    a map to execute.
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring a bridge](img/7401EN_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuring a bridge with a map
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the `MessageFlowItinerary.bcs` file in the **Solution Explorer**
    window to open it. In the designer, open the `OrderProcessing` bridge configuration
    by double-clicking on it. Click on the **Transform** stage and look at the **Properties**
    window. Here, we can choose a map by clicking on the ellipsis (**…**) next to
    the **Maps** property to open up the configured maps. This will show us all the
    maps the solution contains.
  prefs: []
  type: TYPE_NORMAL
- en: We can select the map that we created earlier by checking the **Selected** checkbox
    next to it, as shown in the following screenshot. Clicking on **OK** will return
    to the bridge configuration, which should now show the selected map, `FFtoUS`,
    in the **Transform** stage.
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring a bridge](img/7401EN_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Select map dialog
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The solution is now ready. Build and deploy as before, and once deployed, point
    your browser to `https://<yourdeployment>/default/OrderProcessingBridge` and you
    should see a 401 HTTP error code stating that a manage claim is required for this
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you will use two tools provided as a part of the BizTalk Services SDK.
    These are MessageSender and MessagerReceiver which you can download from the following
    links. These tools allow you to send messages to and receive messages from the
    bridge you created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://code.msdn.microsoft.com/windowsazure/Windows-Azure-BizTalk-EAI-e01a5b64](http://code.msdn.microsoft.com/windowsazure/Windows-Azure-BizTalk-EAI-e01a5b64)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://code.msdn.microsoft.com/windowsazure/Windows-Azure-BizTalk-EAI-af9bc99f](http://code.msdn.microsoft.com/windowsazure/Windows-Azure-BizTalk-EAI-af9bc99f)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unzip both solutions and open the MessageReceiver sample in Visual Studio 2012
    and build it. Run it from the command prompt by typing the following and pressing
    the *Enter* key.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, `<path>` is the path to the exe from the build output
    of Visual Studio, `ServiceBusNS` is the namespace where the relay is running and
    `USAddressRelay` is the endpoint information configured in the bridge configuration.
    Note that you will also need to replace the `<issuerkey>` value with your own
    subscription details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open the MessageSender sample (downloaded from the previous link) in Visual
    Studio 2012 and build it. Run it as shown in the following code to send a message
    to the bridge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `BizTalkSvcACS` is the ACS namespace of the BizTalk Service
    deployment. As before, `owner` and `issuerkey` are the ACS credentials of that
    namespace, and `instance.xml` is the `OrderFF.xsd` instance in XML format.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that output is observed in the MessageReceiver sample of the relay. Examine
    the output message and notice how the map has transformed it.
  prefs: []
  type: TYPE_NORMAL
- en: More on mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've covered a lot of ground so far, but there is much more to mapping in BizTalk
    Services besides the other 27 operations we've not used here. There are two other
    groups of operations that deserve some discussion.
  prefs: []
  type: TYPE_NORMAL
- en: The first of these is the **Get Context Property** mapping operation. This provides
    an often-asked-for feature in BizTalk Server—the ability to retrieve properties
    from the message context and include them in a map. The way this works is by configuring
    it, specifying the property name to retrieve it, and then connecting it to a target
    node; no input nodes are required. We haven't covered context properties in detail
    yet, but for now, remember that they are a set of name/value pairs that hold contextual
    information about the current message flow; for example, the transport details
    (for example, a filename) of the message received, or even properties of the message
    itself that have been extracted. If you're wondering how you can test this from
    within Visual Studio as we did earlier, the team has thought of this too. A property,
    **Context Property Test Data**, is provided on the map and allows you to specify
    the test name/value properties to execute the map with. The dialog is shown in
    the following screenshot. The ability to use context properties in BizTalk Services
    maps is a very welcome addition. This dialog can also be shown when the map is
    tested to change the values used.
  prefs: []
  type: TYPE_NORMAL
- en: '![More on mapping](img/7401EN_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Select map dialog
  prefs: []
  type: TYPE_NORMAL
- en: The second area of improvement is in expression operations. For example, an
    **If-Then-Else** **Expression** operation is provided. This greatly simplifies
    the common requirement of testing a condition; if it evaluates to true, one path
    is taken, otherwise another. In BizTalk Server, this was complex to achieve, requiring
    a lot of functoids. This highlights the effort that the product group has put
    in here to simplify common tasks, as I mentioned at the beginning of this chapter.
    The same goes for other logical operations such as the **Logical** **Expression**.
    Here, an expression can be provided that evaluates to true or false. Again, for
    those familiar with BizTalk Server, this operation replaces a large number of
    functoids with just one that is simple to configure and use.
  prefs: []
  type: TYPE_NORMAL
- en: 'One issue that was starting to become obvious, referring to the map in the
    earlier screenshot, is complexity. The mapper provides the concept of pages to
    allow the splitting up of operations and links on different pages. You can add
    a new page by right-clicking on the area next to the tab at the bottom of the
    designer, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![More on mapping](img/7401EN_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Working with pages
  prefs: []
  type: TYPE_NORMAL
- en: Splitting the map up into different pages is a trade-off between readability
    and complexity. Ideally, you would see as much detail as is clearly readable in
    a single page to avoid having to jump between different pages all the time. With
    complex maps that perhaps have thousands of links and operations, this isn't possible;
    adding pages can greatly reduce complexity and improve clarity, especially for
    those left to maintain the solution.
  prefs: []
  type: TYPE_NORMAL
- en: One final point is that, as you may have already noticed, the new BizTalk Services
    mapper is not based on the Extensible Stylesheet Language and XSLT (as the BizTalk
    Server one was). However, it is still possible to include XSLT (1.0 only) in a
    map, which is useful when you have an existing transformation in XSLT that you
    wish to reuse. The XSLT property is accessed by clicking on the designer grid
    and opening the **XSLT** property in the **Properties** window. On the subject
    of reuse, another useful tool provided with BizTalk Services is the BizTalk Server
    map converter. This will convert a BizTalk Server `.btm` map file to the BizTalk
    Services mapping format, saving time when you have existing maps that you wish
    to reuse and avoiding the need to start from scratch. Because of the differences
    in functionality between the two, it cannot perform a 100 percent conversion,
    but is a great time-saver nevertheless.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with failure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One very important point a developer must consider is how to deal with failures
    that occur. In integration solutions, failure is particularly important as it
    can be hard to isolate and diagnose. On a map, it is possible to configure what
    action to take should a particular operation fail, usually due to bad data provided
    to it. The **Settings** button at the top of the designer displays the dialog,
    as shown in the following screenshot, when clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Here, each operation (or group of operations in some cases) can be set to either
    **Fail Map** on an error occurrence or continue and output a null value. This
    is very useful; we'll look at error handling in much more detail in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Dealing with failure](img/7401EN_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting runtime properties
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at the mapping features of BizTalk Services.
    You've seen how to create maps, use many of the powerful operations provided,
    and test them. While we haven't been able to cover every operation, many are self-explanatory
    and easy to understand; after all, the whole point of the mapper is to make the
    job of format and content conversion easier. We urge you to experiment on your
    own and see what you can come up with.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at the different types of bridges BizTalk Services
    provides, starting with EDI.
  prefs: []
  type: TYPE_NORMAL
