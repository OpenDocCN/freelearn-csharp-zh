- en: Chapter 2. Inventory GUIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 库存 GUI
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating a simple 2D mini-game – SpaceGirl
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的 2D 小游戏 – SpaceGirl
- en: Displaying single object pickups with carrying and not-carrying text
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示带有携带和不携带文本的单个物品拾取
- en: Displaying single object pickups with carrying and not-carrying icons
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示带有携带和不携带图标的单个物品拾取
- en: Displaying multiple pickups of the same object with text totals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以文本总数的形式显示相同对象的多个拾取
- en: Displaying multiple pickups of the same object with multiple status icons
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以多个状态图标显示相同对象的多个拾取
- en: Revealing icons for multiple object pickups by changing the size of a tiled
    image
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过改变瓦片图像的大小来揭示多个对象拾取的图标
- en: Displaying multiple pickups of different objects as a list of text via a dynamic
    List<> of PickUp objects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过动态的 List<> 的 PickUp 对象以文本列表的形式显示不同对象的多个拾取
- en: Displaying multiple pickups of different objects as text totals via a dynamic
    Dictionary<> of PickUp objects and "enum" pickup types
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过动态的 PickUp 对象的 Dictionary<> 和 "enum" 拾取类型，以文本总数的形式显示不同对象的多个拾取
- en: Generalizing multiple icon displays using UI Grid Layout Groups (with scrollbars!)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 UI 网格布局组（带滚动条！）泛化多个图标显示
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Many games involve the player collecting items or choosing from a selection
    of items. Examples could be collecting keys to open doors, collecting ammo for
    weapons, choosing from a collection of spells to cast, and so on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 许多游戏涉及玩家收集物品或从物品选择中做出选择。例如，收集钥匙打开门，收集武器弹药，从一系列法术中选择施法，等等。
- en: The recipes in this chapter offer a range of solutions for displaying to the
    player whether they are carrying an item or not, if they are allowed more than
    one of an item, and how many they have.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的食谱提供了一系列解决方案，用于向玩家显示他们是否携带了物品，是否允许携带多个物品，以及他们有多少个。
- en: The big picture
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整体情况
- en: 'The two parts of software design for implementing inventories relate to, first,
    how we choose to represent the data about inventory items (that is, the data types
    and structures to store the data) and, secondly, how we choose to display information
    about inventory items to the player (the UI: User Interface).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 实现库存的软件设计的两部分与以下两个方面相关，首先是我们如何选择表示库存物品数据的方式（即存储数据的类型和结构），其次是我们如何选择向玩家显示库存物品信息的方式（UI：用户界面）。
- en: Also, whilst not strictly inventory items, player properties such as lives left,
    health, or time remaining can also be designed around the same concepts that we
    present in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，虽然不是严格的库存物品，但玩家的属性，如剩余生命值、健康值或剩余时间，也可以围绕本章中提出的相同概念进行设计。
- en: 'We need to first think about the nature of different inventory items for any
    particular game:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要首先考虑任何特定游戏中不同库存物品的性质：
- en: 'Single items:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个物品：
- en: 'Example(s): the only key for a level, our suit of magic armor'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：一个级别的唯一钥匙，我们的魔法盔甲套装
- en: 'Data type: bool (true/false)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型：bool（真/假）
- en: 'UI: nothing (if not carried) or text/image to show being carried'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI：如果没有携带，则无内容或显示携带的文本/图像
- en: Or perhaps text saying "no key"/"key", or two images, one showing an empty key
    outline and the second showing a full color key
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者可能是“没有钥匙”/“钥匙”的文本，或者两个图像，一个显示空钥匙轮廓，另一个显示全色钥匙
- en: If we wish to highlight to the player that there is an option to be carrying
    this item
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们希望向玩家突出显示有携带此物品的选项
- en: 'Continuous item:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续物品：
- en: 'Example(s): time left, health, shield strength'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：剩余时间，健康值，护盾强度
- en: 'Data type: float (for example, 0.00–1.00) or integer scale (for example, 0%
    .. 100%)'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型：float（例如，0.00–1.00）或整数比例（例如，0% .. 100%）
- en: 'UI: text number or image progress bar/pie chart'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI：文本数字或图像进度条/饼图
- en: Two or more of same item
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同物品的两个或更多个
- en: 'Example(s): lives left, or number of arrows or bullets left'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：剩余生命值，或剩余箭矢或子弹的数量
- en: 'Data type: int (whole numbers)'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型：int（整数）
- en: 'UI: text count or images'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI：文本计数或图像
- en: Collection of related items
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关物品的集合
- en: 'Example(s): keys of different colors to open correspondingly colored doors,
    potions of different strength with different titles'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：不同颜色的钥匙打开相应颜色的门，不同强度的药水具有不同的名称
- en: 'Data structure: a struct or class for the general item type (for example, class
    `Key` (color/cost/doorOpenTagString), stored as an array or List<>'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据结构：用于通用物品类型的结构体或类（例如，`Key` 类（颜色/成本/门打开标签字符串），存储为数组或 List<> 类型
- en: 'UI: text list or list/grid arrangement of icons'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI：文本列表或图标列表/网格排列
- en: Collection of different items
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同物品的集合
- en: 'Example(s): keys, potions, weapons, tools—all in the same inventory system'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：键、药水、武器、工具—all在同一个库存系统中
- en: 'Data structure: List<> or Dictionary<> or array of objects, which can be instances
    of different class for each item type'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据结构：List<>或Dictionary<>或对象数组，每个项目类型可以是不同类的实例
- en: Each of the above representations and UI display methods are illustrated by
    the recipes in this chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的每种表示和UI显示方法都由本章中的食谱进行说明。
- en: Creating a simple 2D mini-game – SpaceGirl
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的2D迷你游戏 – SpaceGirl
- en: This recipe presents the steps to create the 2DSpaceGirl mini-game, on which
    all the recipes of this chapter are based.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱展示了创建2DSpaceGirl迷你游戏的步骤，本章的所有食谱都是基于此。
- en: Getting ready
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared the images you need in a folder named `Sprites`
    in the `1362_02_01` folder. We have also provided the completed game as a Unity
    package in this folder named `Simple2DGame_SpaceGirl`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们在`1362_02_01`文件夹中名为`Sprites`的文件夹中准备了您需要的图像。我们还在这个文件夹中提供了一个名为`Simple2DGame_SpaceGirl`的Unity包，其中包含了完成的游戏。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create the simple 2D mini-game *Space Girl* follow these steps:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建简单的2D迷你游戏*Space Girl*，请按照以下步骤操作：
- en: Create a new, empty 2D project.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空2D项目。
- en: Import supplied folder `Sprites` into your project.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将提供的文件夹`Sprites`导入到您的项目中。
- en: Convert each sprite image to be of type **Sprite (2D and UI)**. To do this,
    select the sprite in the **Project** panel, then, in the **Inspector**, change
    choose **Sprite (2D and UI)** from the drop-down menu **Texture Type**, and click
    on the **Apply** button, as shown in the following screenshot:![How to do it...](img/1362OT_02_54.jpg)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个精灵图像转换为**精灵（2D和UI）**类型。为此，在**项目**面板中选择精灵，然后在**检查器**中，从下拉菜单**纹理类型**中选择**精灵（2D和UI）**，并点击**应用**按钮，如图所示：![如何操作...](img/1362OT_02_54.jpg)
- en: 'Set the Unity Player screen size to 800 x 600: choose the **Edit** | **Project
    Settings** | **Player** menu, then for option **Resolution and Presentation**
    uncheck `Default is Full Screen,` and set the width to `800` and height to `600`,
    as shown in the following screenshot:![How to do it...](img/1362OT_02_03.jpg)'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Unity Player屏幕大小设置为800 x 600：选择**编辑** | **项目设置** | **玩家**菜单，然后对于选项**分辨率和显示**取消勾选`默认为全屏`，并将宽度设置为`800`，高度设置为`600`，如图所示：![如何操作...](img/1362OT_02_03.jpg)
- en: Select the **Game** panel; if not already chosen, then choose **Standalone (800
    x 600)** from the drop-down menu, as shown in the following screenshot:![How to
    do it...](img/1362OT_02_02.jpg)
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**游戏**面板；如果尚未选择，则从下拉菜单中选择**独立（800 x 600）**，如图所示：![如何操作...](img/1362OT_02_02.jpg)
- en: Display the **Tags & Layers** properties for the current Unity project. Choose
    menu **Edit** | **Project Settings** | **Tags and Layers**. Alternatively, if
    you are already editing a GameObject, then you can select the **Add Layer…** menu
    from the **Layer** drop-down menu at the top of the **Inspector** panel, as shown
    in the following screenshot:![How to do it...](img/1362OT_02_51.jpg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示当前Unity项目的**标签和层**属性。选择菜单**编辑** | **项目设置** | **标签和层**。或者，如果您已经在编辑一个GameObject，那么您可以从**检查器**面板顶部的**层**下拉菜单中选择**添加层…**菜单，如图所示：![如何操作...](img/1362OT_02_51.jpg)
- en: The **Inspector** should now being displaying the **Tags & Layers** properties
    for the current Unity project. Use the expand/contract triangle tools to contract
    **Tags** and **Layers**, and to expand **Sorting Layers**.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在**检查器**应该正在显示当前Unity项目的**标签和层**属性。使用展开/收缩三角形工具收缩**标签**和**层**，并展开**排序层**。
- en: 'Use the plus sign **+** button to add two new sorting layers, as shown in the
    following screenshot: first, add one named **Background**, and next, add one named
    **Foreground**. The sequence is important, since Unity will draw items in layers
    further down this list on top of items earlier in the list.![How to do it...](img/1362OT_02_52.jpg)'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用加号**+**按钮添加两个新的排序层，如图所示：首先，添加一个名为**背景**的层，然后添加一个名为**前景**的层。顺序很重要，因为Unity将在列表中较后的层上绘制项目，覆盖列表中较早的项目。![如何操作...](img/1362OT_02_52.jpg)
- en: Drag the sprite `background-blue` from the **Project** panel (folder `Sprites`)
    into either the **Game** or **Hierarchy** panel to create a GameObject for the
    current scene.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将精灵`background-blue`从**项目**面板（文件夹`Sprites`）拖动到**游戏**或**层次结构**面板中，以创建当前场景的GameObject。
- en: Set the **Sorting Layer** of GameObject `background-blue` to **Background**
    (in the **Sprite Renderer** component).
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将GameObject `background-blue`的**排序层**设置为**背景**（在**精灵渲染器**组件中）。
- en: Drag sprite `star` from the **Project** panel (folder `Sprites`) into either
    the **Game** or **Hierarchy** panel to create a GameObject for the current scene.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**面板（文件夹**精灵**）中将精灵`star`拖动到**游戏**或**层次**面板中，为当前场景创建一个GameObject。
- en: In the **Inspector** panel, add a new tag **Star** by selecting the **Add Tag…**
    option from the **Tag** drop-down menu at the top of the **Inspector** panel,
    as shown in the following screenshot:![How to do it...](img/1362OT_02_04.jpg)
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中，通过选择**检查器**面板顶部的**标签**下拉菜单中的**添加标签…**选项，添加一个新的标签**Star**，如图所示：![如何操作…](img/1362OT_02_04.jpg)
- en: Apply the **Star** tag to GameObject `star` in the **Hierarchy** scene.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Star**标签应用到**层次**场景中的GameObject `star`。
- en: Set the **Sorting Layer** of GameObject `star` to **Foreground** (in the **Sprite
    Renderer** component).
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将GameObject `star`的**排序层**设置为**前景**（在**精灵渲染器**组件中）。
- en: Add to GameObject `star` a Box Collider 2D (**Add Component** | **Physics 2D**
    | **Box Collider 2D**) and check its `Is Trigger`, as shown in the following screenshot:![How
    to do it...](img/1362OT_02_08.jpg)
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向GameObject `star`添加一个Box Collider 2D（**添加组件** | **物理2D** | **盒子碰撞器2D**）并勾选其`Is
    Trigger`，如图所示：![如何操作…](img/1362OT_02_08.jpg)
- en: Drag sprite `girl1` from the **Project** panel (folder `Sprites`) into either
    the **Game** or **Hierarchy** panel to create a GameObject for the player's character
    in the current scene. Rename this GameObject `player-SpaceGirl`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**面板（文件夹**精灵**）中将精灵`girl1`拖动到**游戏**或**层次**面板中，为当前场景中的玩家角色创建一个GameObject。将此GameObject重命名为`player-SpaceGirl`。
- en: Set the **Sorting Layer** of GameObject `player-SpaceGirl` to **Foreground**
    (in the **Sprite Renderer** component).
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将GameObject `player-SpaceGirl`的**排序层**设置为**前景**（在**精灵渲染器**组件中）。
- en: Add to GameObject `player-SpaceGirl` a Box Collider 2D (**Add Component** |
    **Physics 2D** | **Box Collider 2D**).
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向GameObject `player-SpaceGirl`添加一个Box Collider 2D（**添加组件** | **物理2D** | **盒子碰撞器2D**）。
- en: Add to GameObject `player-SpaceGirl` a RigidBody 2D (**Add Component** | **Physics
    2D** | **Rigid Body 2D**). Set its **Gravity Scale** to zero (so it isn't falling
    down the screen due to simulated gravity), as shown in the following screenshot:![How
    to do it...](img/1362OT_02_31.jpg)
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向GameObject `player-SpaceGirl`添加一个RigidBody 2D（**添加组件** | **物理2D** | **刚体2D**）。将其**重力缩放**设置为零（这样它就不会因为模拟重力而掉落屏幕），如图所示：![如何操作…](img/1362OT_02_31.jpg)
- en: Create a new folder for your scripts named `Scripts`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的脚本创建一个新的文件夹，命名为`Scripts`。
- en: 'Create the following C# Script `PlayerMove` (in folder `Scripts`) and add an
    instance as a component to GameObject `player-SpaceGirl` in the **Hierarchy**:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下C#脚本`PlayerMove`（在文件夹`Scripts`中），并将其作为一个组件添加到**层次**中的GameObject `player-SpaceGirl`：
- en: '[PRE0]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Save the scene (name it **Main Scene** and save it into a new folder named `Scenes`).
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景（命名为**主场景**并将其保存到一个名为`Scenes`的新文件夹中）。
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: You have created a player character in the scene, with its movement scripted
    component `PlayerMove`. You have also created a star GameObject (a pickup), tagged
    `Star` and with a 2D box collider that will trigger a collision when the player's
    character hits it. When you run the game, the `player-SpaceGirl` character should
    move around using the *W A S D*, arrow keys, or joystick. Currently, nothing will
    happen if the `player-SpaceGirl` character hits a star since that has yet to be
    scripted.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在场景中创建了一个玩家角色，并为其运动脚本组件`PlayerMove`进行了脚本编写。你还创建了一个星星GameObject（一个拾取物），标记为`Star`，并具有一个2D盒子碰撞器，当玩家角色碰到它时将触发碰撞。当你运行游戏时，`player-SpaceGirl`角色应该使用*W
    A S D*，箭头键或摇杆移动。目前，如果`player-SpaceGirl`角色碰到星星，由于尚未编写脚本，所以不会发生任何操作。
- en: You have added a background (GameObject `background-blue`) to the scene, which
    will be behind everything since it is in the rearmost sorting layer **Background**.
    Items you want to appear in front of this background (the player's character and
    the star so far) are placed on sorting layer **Foreground**. Learn more about
    Unity tags and layers at [http://docs.unity3d.com/Manual/class-TagManager.html](http://docs.unity3d.com/Manual/class-TagManager.html).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经为场景添加了一个背景（GameObject `background-blue`），由于它位于最远的排序层**背景**，所以它将位于所有内容的后面。你希望出现在这个背景之前（玩家角色和到目前为止的星星）的项目放置在**前景**排序层。了解更多关于Unity标签和层的信息，请访问[http://docs.unity3d.com/Manual/class-TagManager.html](http://docs.unity3d.com/Manual/class-TagManager.html)。
- en: Displaying single object pickups with carrying and not-carrying text
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示带有携带和不携带文本的单个对象拾取
- en: Often the simplest inventory situation is to display text to tell players if
    they are carrying a single item (or not).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，最简单的库存情况是显示文本来告诉玩家他们是否携带一个物品（或不是）。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This recipe assumes that you are starting with the project `Simple2Dgame_SpaceGirl`
    setup from the first recipe in this chapter. So, either make a copy of that project
    or do the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方假设您是从本章的第一个配方中设置的`Simple2Dgame_SpaceGirl`项目开始的。因此，要么复制该项目，要么执行以下操作：
- en: Create a new, empty 2D project.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空2D项目。
- en: Import the `Simple2Dgame_SpaceGirl` package.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`Simple2Dgame_SpaceGirl`包。
- en: Open scene **Scene1** (in the `Scenes` folder).
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开场景**Scene1**（在`Scenes`文件夹中）。
- en: Set the Unity Player screen size to 800 x 600 (see the previous recipe for how
    to do this) and select this resolution in the **Game** panel the drop-down menu.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Unity玩家屏幕大小设置为800 x 600（参见之前的配方了解如何操作）并在**游戏**面板的下拉菜单中选择此分辨率。
- en: Convert each sprite image to be of type **Sprite (2D and UI)**. In the **Inspector,**
    choose **Sprite (2D and UI)** from drop-down menu **Texture Type**, and click
    on the **Apply** button.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个精灵图像转换为**Sprite（2D和UI）**类型。在**检查器**中，从下拉菜单**纹理类型**中选择**Sprite（2D和UI）**，并点击**应用**按钮。
- en: For this recipe, we have prepared the font you need in a folder named `Fonts`
    in the `1362_02_02` folder.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们在`1362_02_02`文件夹中的`Fonts`文件夹中准备了您需要的字体。
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To display text to inform the user about the status of carrying a single object
    pickup, follow these steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示文本以通知用户携带单个拾取物品的状态，请按照以下步骤操作：
- en: Start with a new copy of mini-game `Simple2Dgame_SpaceGirl`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从mini游戏`Simple2Dgame_SpaceGirl`的新副本开始。
- en: 'Add a UI **Text** object (**Create** | **UI** | **Text**). Rename it `Text-carrying-star`.
    Change its text to `Carrying star: false`.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '添加一个UI **文本**对象（**创建** | **UI** | **文本**）。重命名为`Text-carrying-star`。将其文本更改为`Carrying
    star: false`。'
- en: Import the provided `Fonts` folder into your project.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将提供的`Fonts`文件夹导入到您的项目中。
- en: In the **Inspector** panel, set the font of `Text-carrying-star` to **Xolonium-Bold**
    (folder `Fonts`), and set its color to yellow. Center the text horizontally and
    vertically, and set its **Height** to `50`, and set the **Font Size** to `32`,
    as shown in the following screenshot:![How to do it...](img/1362OT_02_05.jpg)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中，将`Text-carrying-star`的字体设置为**Xolonium-Bold**（文件夹`Fonts`），并将其颜色设置为黄色。水平垂直居中文本，并将**高度**设置为`50`，将**字体大小**设置为`32`，如图下所示：![如何操作...](img/1362OT_02_05.jpg)
- en: In its **Rect Transform** component, set its **Height** to `50`, as shown in
    the next screenshot:![How to do it...](img/1362OT_02_53.jpg)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其**矩形变换**组件中，将其**高度**设置为`50`，如图下所示：![如何操作...](img/1362OT_02_53.jpg)
- en: Edit its **Rect Transform**, and while holding down *SHIFT* and *ALT* (to set
    pivot and position), choose the top-stretch box, as shown in the following screenshot:![How
    to do it...](img/1362OT_02_06.jpg)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑其**矩形变换**，在按住*SHIFT*和*ALT*（以设置枢轴和位置）的同时，选择顶部扩展框，如图下所示：![如何操作...](img/1362OT_02_06.jpg)
- en: Your text should now be positioned at the middle top of the **Game** panel,
    and its width should stretch to match that of the whole panel, as shown in the
    next screenshot:![How to do it...](img/1362OT_02_07.jpg)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的文本现在应位于**游戏**面板的中间顶部，其宽度应扩展以匹配整个面板，如图下所示：![如何操作...](img/1362OT_02_07.jpg)
- en: 'Add the following C# Script `Player` to GameObject `player-SpaceGirl` in the
    **Hierarchy**:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下C#脚本`Player`添加到**层次结构**中的GameObject `player-SpaceGirl`：
- en: '[PRE1]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From the **Hierarchy** view, select the GameObject `player-SpaceGirl`. Then,
    from the **Inspector**, access the **Player (Script)** component and populate
    the **Star Text** public field with UI **Text** object `Text-carrying-star`, as
    shown in the following screenshot:![How to do it...](img/1362OT_02_10.jpg)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**视图中选择GameObject `player-SpaceGirl`。然后，从**检查器**中访问**玩家（脚本）**组件，并将**星文**公共字段填充为UI
    **文本**对象`Text-carrying-star`，如图下所示：![如何操作...](img/1362OT_02_10.jpg)
- en: When you play the scene, after moving the character into the star, the star
    should disappear, and the onscreen UI **Text** message should change to **Carrying
    star :-)** , as shown in the following screenshot:![How to do it...](img/1362OT_02_09.jpg)
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您播放场景时，在将角色移动到星星后，星星应该消失，屏幕上的UI **文本**消息应更改为**Carrying star :-)**，如图下所示：![如何操作...](img/1362OT_02_09.jpg)
- en: How it works...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Text` variable `starText` is a reference to the UI **Text** object `Text-carrying-star`.
    The `bool` variable `carryingStar` represents whether or not the player is carrying
    the star at any point in time; it is initialized to false.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Text`变量`starText`是对UI **文本**对象`Text-carrying-star`的引用。`bool`变量`carryingStar`表示玩家在任何时候是否携带星星；它被初始化为false。'
- en: The `UpdateStarText()` method copies the contents of the `starMessage` string
    to the text property of `starText`. The default value of this string tells the
    user that the player is not carrying the star, but an `if` statement tests the
    value of `carryingKey`, and, if that is true, then the message is changed to inform
    the player that they are carrying the star.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateStarText()`方法将`starMessage`字符串的内容复制到`starText`的文本属性中。此字符串的默认值告诉用户玩家没有携带星星，但一个`if`语句测试`carryingKey`的值，如果为真，则消息会更改以告知玩家他们正在携带星星。'
- en: Each time the player's character collides with any object that has its **Is
    Trigger** set to `true`, an `OnTriggerEnter2D()` event message is sent to both
    objects involved in the collision. The `OnTriggerEnter2D()` message is passed
    a parameter that is the `Collider2D` component inside the object just collided
    with.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每当玩家的角色与任何将其**Is Trigger**设置为`true`的对象发生碰撞时，都会向参与碰撞的两个对象发送一个`OnTriggerEnter2D()`事件消息。`OnTriggerEnter2D()`消息传递一个参数，即刚刚碰撞的对象内部的`Collider2D`组件。
- en: 'Our player''s `OnTriggerEnter2D()` method tests the `tag` string of the object
    collided with to see if it has the value **Star**. Since the GameObject **star**
    we created has its trigger set, and has the tag **Star**, the `if` statement inside
    this method will detect a collision with **star** and complete three actions:
    it sets the Boolean variable `carryingStar` to `true`, it calls the method `UpdateStarText()`,
    and it destroys the GameObject it has just collided with (in this case, **star**).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的玩家的`OnTriggerEnter2D()`方法测试与对象碰撞的`tag`字符串，以查看它是否有值**Star**。由于我们创建的GameObject
    **star**具有触发器设置，并且具有标签**Star**，因此此方法内部的`if`语句将检测与**star**的碰撞并完成三个动作：它将布尔变量`carryingStar`设置为`true`，它调用`UpdateStarText()`方法，并且它销毁它刚刚碰撞的GameObject（在这种情况下，**star**）。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'NOTE: Boolean variables are often referred to as **flags.**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 'NOTE: 布尔变量通常被称为**标志**。'
- en: The use of a bool (true/false) variable to represent whether some feature of
    the game state is true or false is very common. Programmers often refer to these
    variables as flags. So, programmers might refer to the `carryingStar` variable
    as the star-carrying flag.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用布尔（true/false）变量来表示游戏状态的一些功能是真是假是非常常见的。程序员通常将这些变量称为标志。因此，程序员可能会将`carryingStar`变量称为携带星标志。
- en: When the scene begins, via the `Start()`method, we call the `UpdateStarText()`method;
    this ensures that we are not relying on text typed into the UI **Text** object
    `Text-carrying-star` at design time, but that the UI seen by the user is always
    set by our run-time methods. This avoids problems where the words to be displayed
    to the user are changed in code and not in the **Inspector** panel—which leads
    to a mismatch between the onscreen text when the scene first runs and after it
    has been updated from a script.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当场景开始时，通过`Start()`方法，我们调用`UpdateStarText()`方法；这确保我们不是依赖于设计时输入到UI **Text**对象`Text-carrying-star`中的文本，而是用户看到的UI总是由我们的运行时方法设置的。这避免了问题，即要显示给用户的单词在代码中更改，而不是在**Inspector**面板中更改——这导致场景首次运行时和从脚本更新后屏幕文本不匹配。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A golden rule in Unity game design is to **avoid duplicating content in more
    than one place**, and, therefore, we avoid having to maintain two or more copies
    of the same content. Each duplicate is an opportunity for maintenance issues when
    some, but not all, copies of a value are changed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity游戏设计中，一个黄金法则是在多个地方避免重复内容，因此我们避免需要维护两个或更多相同内容的副本。每个重复的内容都是当某些但不是所有副本的值发生变化时，维护问题的一个机会。
- en: Maximizing use of prefabs is another example of this principle in action. This
    is also know as the DRY principal - Do Not Repeat Yourself.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最大化使用预制件是这一原则在行动中的另一个例子。这也被称为DRY原则 - 不要重复自己。
- en: There's more...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Some details you don''t want to miss:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一些你不希望错过的细节：
- en: The separation of view logic
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视图逻辑的分离
- en: A game design pattern (best practice approach) called the **Model-View-Controller**
    pattern (**MVC**) is to separate the code that updates the UI from the code that
    changes player and game variables such as score and inventory item lists. Although
    this recipe has only one variable and one method to update the UI, well structured
    game architectures scale up to cope with more complex games, so it is often worth
    the effort of a little more code and an extra script class, even at this game-beginning
    stage, if we want our final game architecture to be well structured and maintainable.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一种称为**模型-视图-控制器**模式（**MVC**）的游戏设计模式（最佳实践方法）旨在将更新UI的代码与更改玩家和游戏变量（如得分和库存物品列表）的代码分离。尽管这个方法只有一个变量和一个更新UI的方法，但结构良好的游戏架构可以扩展以应对更复杂的游戏，因此在这个游戏开始阶段，如果我们要确保最终的游戏架构结构良好且易于维护，那么多写一些代码和额外的脚本类通常是值得的。
- en: 'To implement the separation of view pattern for this recipe, we need to do
    the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个方法的视图模式分离，我们需要做以下几步：
- en: 'Add the following C# Script `PlayerInventoryDisplay` to GameObject `player-SpaceGirl`
    in the **Hierarchy**:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下C#脚本`PlayerInventoryDisplay`添加到**层次结构**中的GameObject `player-SpaceGirl`：
- en: '[PRE2]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: From the **Hierarchy** view, select the GameObject `player-SpaceGirl`. Then,
    from the **Inspector**, access the `PlayerInventoryDisplay` **(Script)** component
    and populate the **Score Text** public field with the UI **Text** object `Text-carrying-star`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**视图中选择GameObject `player-SpaceGirl`。然后，从**检查器**中访问`PlayerInventoryDisplay`
    **（脚本）**组件，并将**得分文本**公共字段填充为UI **Text**对象`Text-carrying-star`。
- en: 'Remove the existing C# Script component `Player` and replace it with this C#
    Script `PlayerInventory` containing the following (simplified) code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除现有的C#脚本组件`Player`，并用包含以下（简化）代码的C#脚本`PlayerInventory`替换它：
- en: '[PRE3]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As can be seen, the `PlayerInventory` script class no longer has to maintain
    a link to the UI **Text** or worry about changing the text property of that UI
    component—all that work is now the responsibility of the `PlayerInventoryDisplay`
    script. When the Player instance component detects a collision with the star,
    after changing the `carryingStar` bool flag's value to `true`, it just calls the
    `OnChangeCarryingStar()`method of the `PlayerInventoryDisplay` component.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，脚本类`PlayerInventory`不再需要维护与UI **Text**的链接或担心更改该UI组件的文本属性——所有这些工作现在都是脚本`PlayerInventoryDisplay`的责任。当玩家实例组件检测到与星星的碰撞后，在将`carryingStar`布尔标志的值更改为`true`后，它只需调用`PlayerInventoryDisplay`组件的`OnChangeCarryingStar()`方法。
- en: The result is that the code for the script class `PlayerInventory` concentrates
    on the player collision and status variables, while the code for the script class
    `PlayerInventoryDisplay` handles the communication to the user. Another advantage
    of this design pattern is that the method in which the information is communicated
    to the user via the UI can be changed (for example, from text to an icon), without
    any change to the code in script class `Player`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，脚本类`PlayerInventory`的代码专注于玩家的碰撞和状态变量，而脚本类`PlayerInventoryDisplay`的代码处理与用户的通信。这种设计模式的另一个优点是，通过UI将信息传达给用户的方法可以更改（例如，从文本到图标），而无需对脚本类`Player`中的代码进行任何更改。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: There is no difference in the experience of the player, and all the changes
    are to improve the architectural structure of our game code.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：玩家的体验没有差异，所有更改都是为了改善我们游戏代码的架构结构。
- en: Displaying single object pickups with carrying and not-carrying icons
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示携带和不携带图标的单个对象拾取
- en: Graphic icons are an effective way to inform the player that they are carrying
    an item. In this recipe, if no star is being carried, a grey-filled icon in a
    blocked-off circle is displayed; then, after the star has been picked up, a yellow-filled
    icon is displayed, as shown in the following screenshot.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图形图标是通知玩家他们携带物品的有效方式。在这个方法中，如果没有携带星星，则显示一个灰色填充的图标在封闭的圆圈中；然后，在捡起星星后，显示一个黄色填充的图标，如以下截图所示。
- en: '![Displaying single object pickups with carrying and not-carrying icons](img/1362OT_02_14.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![显示携带和不携带图标的单个对象拾取](img/1362OT_02_14.jpg)'
- en: In many cases, icons are clearer (they don't require reading and thinking about)
    and can also be smaller onscreen than text messages for indicating player status
    and inventory items.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，图标比文本消息更清晰（它们不需要阅读和思考），并且在表示玩家状态和库存物品时，屏幕上的图标也可以更小。
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: This recipe assumes that you are starting with the project `Simple2Dgame_SpaceGirl`
    setup from the first recipe in this chapter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方假设您是从本章第一道菜谱中设置的`Simple2Dgame_SpaceGirl`项目开始的。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To toggle carrying and not-carrying icons for a single object pickup, follow
    these steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要切换单个对象拾取的携带和不携带图标，请按照以下步骤操作：
- en: Start with a new copy of the mini-game `Simple2Dgame_SpaceGirl`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Simple2Dgame_SpaceGirl`迷你游戏的新副本开始。
- en: In the **Hierarchy** panel, add a new UI **Image** object (**Create** | **UI**
    | **Image**). Rename it `Image-star-icon`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**面板中，添加一个新的UI**图像**对象（**创建** | **UI** | **图像**）。将其重命名为`Image-star-icon`。
- en: Select `Image-star-icon` in the **Hierarchy** panel.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**面板中选择`Image-star-icon`。
- en: From the **Project** panel, drag the sprite **icon_nostar_100** (folder `Sprites`)
    into the **Source Image** field in the **Inspector** (in the **Image (Script)**
    component).
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**面板中，将精灵**icon_nostar_100**（文件夹`Sprites`）拖动到**检查器**（在**图像（脚本）**组件）中的**源图像**字段。
- en: Click on the **Set Native Size** button for the **Image** component. This will
    resize the UI **Image** to fit the physical pixel width and height of sprite file
    **icon_nostar_100**, as shown in the following screenshot:![How to do it...](img/1362OT_02_11.jpg)
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**设置原生大小**按钮为**图像**组件。这将调整UI**图像**的大小以适应精灵文件**icon_nostar_100**的物理像素宽度和高度，如图下所示：![如何操作...](img/1362OT_02_11.jpg)
- en: Now, we will position our icon at the **top** and **left** of the **Game** panel.
    Edit the UI **Image's Rect Transform** component, and while holding down *SHIFT*
    and *ALT* (to set pivot and position), choose the top-left box. The UI **Image**
    should now be positioned at the top left of the **Game** panel, as shown in the
    following screenshot:![How to do it...](img/1362OT_02_12.jpg)
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将图标放置在**游戏**面板的**顶部**和**左侧**。编辑UI**图像的矩形变换**组件，在按住*SHIFT*和*ALT*（以设置枢轴和位置）的同时，选择左上角的框。UI**图像**现在应位于**游戏**面板的左上角，如图下所示：![如何操作...](img/1362OT_02_12.jpg)
- en: 'Add the following C# Script `Player` to GameObject `player-SpaceGirl` in the
    **Hierarchy**:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下C#脚本`Player`添加到**层次**中的GameObject `player-SpaceGirl`：
- en: '[PRE4]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: From the **Hierarchy** view, select the GameObject `player-SpaceGirl`. Then,
    from the **Inspector**, access the **Player (Script)** component and populate
    the **Star Image** public field with UI **Image** object `Image-star-icon`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次**视图中选择GameObject `player-SpaceGirl`。然后，从**检查器**中访问**Player（脚本）**组件，并将**星图像**公共字段填充为UI**图像**对象`Image-star-icon`。
- en: Now, populate the **Icon Star** public field from the **Project** panel with
    sprite `icon_star_100` and populate the **Icon No Star** public field from the
    **Project** panel with sprite `icon_nostar_100`, as shown in the following screenshot:![How
    to do it...](img/1362OT_02_13.jpg)
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从**项目**面板中用精灵`icon_star_100`填充**图标星**公共字段，并从**项目**面板中用精灵`icon_nostar_100`填充**图标无星**公共字段，如图下所示：![如何操作...](img/1362OT_02_13.jpg)
- en: Now when you play the scene, you should see the no star icon (a grey-filled
    icon in a blocked-off circle) at the top left until you pick up the star, at which
    point it will change to show the carrying star icon (yellow-filled star).
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在当你播放场景时，你应该看到无星图标（一个在封闭圆圈中的灰色填充图标）在左上角，直到你捡起星星，此时它将变为携带星星图标（黄色填充的星星）。
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Image` variable `starImage` is a reference to the UI **Image** object `Image-star-icon`.
    `Sprite` variables `iconStar` and `iconNoStar` are references to the `Sprite`
    files in the **Project** panel—the sprites to tell the player whether or not a
    star is being carried. The `bool` variable `carryingStar` represents internally
    as program data whether or not the player is carrying the star at any point in
    time; it is initialized to `false`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Image`变量`starImage`是对UI**图像**对象`Image-star-icon`的引用。`Sprite`变量`iconStar`和`iconNoStar`是对**项目**面板中`Sprite`文件的引用——这些精灵用来告诉玩家是否正在携带星星。`bool`变量`carryingStar`表示程序数据中玩家在任何时间点是否携带星星；它被初始化为`false`。'
- en: Much of the logic for this recipe is the same as the previous one. Each time
    the `UpdateStarImage()`method is called, it sets the UI **Image** to the sprite
    that corresponds to the value of bool variable `carryingsStar`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方的许多逻辑与上一个配方相同。每次调用`UpdateStarImage()`方法时，它都会将UI**图像**设置为与bool变量`carryingsStar`的值相对应的精灵。
- en: Displaying multiple pickups of the same object with text totals
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示相同对象的多个拾取与文本总数
- en: When several items of the same type have been picked up, often the simplest
    way to convey what is being carried to the user is to display a text message showing
    the numeric total of each item type being carried, as shown in the following screenshot.
    In this recipe, the total number of stars collected is displayed using a UI **Text**
    object.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当收集到多个同类型的物品时，通常向用户传达所携带物品的最简单方法是通过显示一个文本消息，显示每种物品类型的数量总和，如下面的截图所示。在这个菜谱中，使用UI
    **文本**对象显示了收集到的星星总数。
- en: '![Displaying multiple pickups of the same object with text totals](img/1362OT_02_15.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![显示具有文本总数的多个相同对象的截图](img/1362OT_02_15.jpg)'
- en: Getting ready
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you are starting with project `Simple2Dgame_SpaceGirl` setup
    from the first recipe in this chapter. The font you need can be found in folder
    `1362_02_02`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱假设您是从本章的第一个菜谱中设置的`Simple2Dgame_SpaceGirl`项目开始的。所需的字体可以在文件夹`1362_02_02`中找到。
- en: How to do it...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To display inventory total text for multiple pickups of same type of object,
    follow these steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示同一类型对象的多个拾取的库存总数文本，请按照以下步骤操作：
- en: Start with a new copy of the mini-game `Simple2Dgame_SpaceGirl`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从迷你游戏`Simple2Dgame_SpaceGirl`的新副本开始。
- en: Add a UI **Text** object (**Create** | **UI** | **Text**). Rename it `Text-carrying-star`.
    Change its text to **stars = 0**.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个UI **文本**对象（**创建** | **UI** | **文本**）。重命名为`Text-carrying-star`。将其文本更改为**stars
    = 0**。
- en: Import the provided `Fonts` folder into your project.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将提供的`Fonts`文件夹导入到您的项目中。
- en: In the **Inspector** panel, set the font of `Text-carrying-star` to **Xolonium-Bold**
    (folder `Fonts`) and set its color to yellow. Center the text horizontally and
    vertically, and set its **Font Size** to `32`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中，将`Text-carrying-star`的字体设置为**Xolonium-Bold**（文件夹`Fonts`），并将其颜色设置为黄色。水平垂直居中文本，并将**字体大小**设置为`32`。
- en: In its **Rect Transform** component, set its **Height** to `50`. Edit its **Rect
    Transform**, and while holding down *SHIFT* and *ALT* (to set pivot and position),
    choose the top-stretch box. Your text should now be positioned at the middle top
    of the **Game** panel, and its width should stretch to match that of the whole
    panel.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其**矩形变换**组件中，将**高度**设置为`50`。编辑其**矩形变换**，在按住*SHIFT*和*ALT*（以设置枢轴和位置）的同时，选择顶部拉伸框。现在，您的文本应位于**游戏**面板的中间顶部，其宽度应扩展以匹配整个面板的宽度。
- en: 'Add the following C# Script `Player` to GameObject `player-SpaceGirl` in the
    **Hierarchy**:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下C#脚本`Player`添加到**层次结构**中的GameObject `player-SpaceGirl`：
- en: '[PRE5]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: From the **Hierarchy** view, select the GameObject `player-SpaceGirl`. Then,
    from the **Inspector**, access the **Player (Script)** component and populate
    the **Star Text** public field with UI **Text** object `Text-carrying-star`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**视图中选择GameObject `player-SpaceGirl`。然后，从**检查器**中访问**Player (Script)**组件，并将UI
    **文本**对象`Text-carrying-star`填充到**星文**公共字段中。
- en: Select the GameObject `star` in the **Hierarchy** panel and make three more
    copies of this GameObject.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中选择GameObject `star`，并复制此GameObject三次。
- en: Note
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: Use keyboard shortcut *CTRL* + *D* (Windows) or *CMD* + *D* (Mac) to
    quickly duplicate GameObjects.'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：使用键盘快捷键*CTRL* + *D*（Windows）或*CMD* + *D*（Mac）快速复制GameObject。
- en: Move these new GameObject to different parts of the screen.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些新GameObject移动到屏幕的不同部分。
- en: Play the game—each time you pick up a star, the total should be displayed in
    the form **stars = 2**.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始游戏——每次捡起星星时，总数应以**stars = 2**的形式显示。
- en: How it works...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `Text` variable `starText` is a reference to the UI **Text** object `Text-carrying-star`.
    The `int` variable `totalStars` represents how many stars have been collected
    so far; it is initialized to zero.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`Text`变量`starText`是对UI **文本**对象`Text-carrying-star`的引用。`int`变量`totalStars`表示到目前为止收集了多少星星；它初始化为零。'
- en: In the `OnTriggerEnter2D()` method, the `totalStars` counter is incremented
    by 1 each time the player's character hits an object tagged **Star**. The collided
    star GameObject is destroyed and a call is made to the `UpdateStarText()`method.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnTriggerEnter2D()`方法中，每当玩家的角色击中一个标记为**Star**的对象时，`totalStars`计数器增加1。碰撞的星星GameObject被销毁，并调用`UpdateStarText()`方法。
- en: The `UpdateStarText()` method updates the text content of UI **Text** object
    `Text-carrying-star` with text string `stars =` concatenated with the integer
    value inside variable `totalStars` to display the updated total number of stars
    to the user.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateStarText()`方法通过将文本字符串`stars =`与变量`totalStars`内部的整数值连接起来，更新UI **文本**对象`Text-carrying-star`的文本内容，向用户显示更新的星星总数。'
- en: Displaying multiple pickups of the same object with multiple status icons
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示具有多个状态图标的多重拾取同一物体
- en: If there is a small, fixed total number of an item to be collected rather than
    text totals, an alternative effective UI approach is to display placeholder icons
    (empty or greyed out pictures) to show the user how many of the item remain to
    be collected, and each time an item is picked up, a placeholder icon is replaced
    by a full color collected icon.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要收集的物品数量是一个小的、固定的总数而不是文本总数，那么一个有效的替代 UI 方法是显示占位符图标（空或灰色图片）来显示用户还有多少个物品需要收集，并且每次拾取一个物品时，占位符图标将被一个全色的收集图标所替换。
- en: In this recipe, we use grey-filled star icons as the placeholders and yellow-filled
    star icons to indicate each collected star, as shown in the following screenshot.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们使用灰色填充的五角星图标作为占位符，并使用黄色填充的五角星图标来指示每个收集到的星星，如下截图所示。
- en: Since our UI code is getting a little more complicated, this recipe will implement
    the MVC design pattern to separate the view code from the core player logic (as
    introduced at the end of recipe *Displaying single object pickups with carrying
    and not-carrying text*).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的 UI 代码变得越来越复杂，本食谱将实现 MVC 设计模式来分离视图代码和核心玩家逻辑（如 *Displaying single object
    pickups with carrying and not-carrying text* 食谱末尾所述）。
- en: '![Displaying multiple pickups of the same object with multiple status icons](img/1362OT_02_16.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![显示具有多个状态图标的多重拾取同一物体](img/1362OT_02_16.jpg)'
- en: Getting ready
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes that you are starting with the project `Simple2Dgame_SpaceGirl`
    setup from the first recipe in this chapter.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱假设您是从本章第一道食谱中设置的 `Simple2Dgame_SpaceGirl` 项目开始的。
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To display multiple inventory icons for multiple pickups of same type of object,
    follow these steps:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示同一类型物体的多重拾取的多个库存图标，请按照以下步骤操作：
- en: Start with a new copy of the mini-game `Simple2Dgame_SpaceGirl`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个新的 `Simple2Dgame_SpaceGirl` 小游戏副本开始。
- en: 'Add the following C# Script `Player` to GameObject `player-SpaceGirl` in the
    **Hierarchy**:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 C# 脚本 `Player` 添加到 **层次结构** 中的 `player-SpaceGirl` GameObject：
- en: '[PRE6]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Select GameObject `star` in the **Hierarchy** panel and make three more copies
    of this GameObject (Windows *CTRL* + *D* / Mac *CMD* + *D*).
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次结构** 面板中选择 GameObject `star`，并复制三次此 GameObject（Windows *CTRL* + *D* /
    Mac *CMD* + *D*）。
- en: Move these new GameObject to different parts of the screen.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些新的 GameObject 移动到屏幕的不同部分。
- en: Add the following C# Script `PlayerInventoryDisplay` to the GameObject `player-SpaceGirl`
    in the **Hierarchy:**
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 C# 脚本 `PlayerInventoryDisplay` 添加到 `player-SpaceGirl` GameObject 中，在 **层次结构**
    中：
- en: '[PRE7]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Select the **Canvas** in the **Hierarchy** panel and add a new UI Image object
    (**Create** | **UI** | **Image**). Rename it `Image-star0`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次结构** 面板中选择 **Canvas**，并添加一个新的 UI Image 对象（**创建** | **UI** | **Image**）。将其重命名为
    `Image-star0`。
- en: Select `Image-star0` in the **Hierarchy** panel.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次结构** 面板中选择 `Image-star0`。
- en: From the **Project** panel, drag the sprite `icon_star_grey_100` (folder `Sprites`)
    into the **Source Image** field in the **Inspector** for the **Image** component.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **项目** 面板中，将精灵 `icon_star_grey_100`（文件夹 `Sprites`）拖动到 **检查器** 中 **Image**
    组件的 **源图像** 字段。
- en: Click on the **Set Native Size** button for this for the **Image** component.
    This will resize the UI **Image** to fit the physical pixel width and height of
    sprite file `icon_star_grey_100`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **设置原生大小** 按钮以调整 **Image** 组件的大小。这将使 UI **Image** 的大小与精灵文件 `icon_star_grey_100`
    的物理像素宽度和高度相匹配。
- en: Now we will position our icon at the **top** and **left** of the **Game** panel.
    Edit the UI **Image's Rect Transform** component, and while holding down *SHIFT*
    and *ALT* (to set pivot and position), choose the top-left box. The UI **Image**
    should now be positioned at the top left of the **Game** panel.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将图标放置在 **游戏** 面板的 **顶部** 和 **左侧**。编辑 UI **Image 的 Rect Transform** 组件，在按住
    *SHIFT* 和 *ALT*（以设置枢轴和位置）的同时，选择左上角的框。UI **Image** 应该现在位于 **游戏** 面板的左上角。
- en: Make three more copies of `Image-star0` in the **Hierarchy** panel, naming them
    `Image-star1`, `Image-star2`, and `Image-star3`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次结构** 面板中复制三次 `Image-star0`，分别命名为 `Image-star1`、`Image-star2` 和 `Image-star3`。
- en: In the **Inspector** panel, change the **Pos X** position (in the **Rect Transform**
    component) of `Image-star1` to `100`, of `Image-star2` to `200`, and of `Image-star3`
    to `100`, as shown in the following screenshot:![How to do it...](img/1362OT_02_17.jpg)
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **检查器** 面板中，将 `Image-star1` 的 **Pos X** 位置（在 **Rect Transform** 组件中）更改为 `100`，`Image-star2`
    更改为 `200`，`Image-star3` 更改为 `100`，如下截图所示：![如何操作...](img/1362OT_02_17.jpg)
- en: From the **Hierarchy** view, select the GameObject `player-SpaceGirl`. Then,
    from the **Inspector**, access the **Player Inventory Display (Script)** component
    and set the **Size** property of public field **Star Playholders** to `4`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次**视图中，选择GameObject `player-SpaceGirl`。然后，从**检查器**中，访问**玩家库存显示（脚本）**组件，并将公共字段**星形占位符**的**大小**属性设置为`4`。
- en: Next, populate the **Element 0/1/2/3** array values of public field **Star Playholders**
    with UI **Image** objects `Image-star0/1/2/3`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，用UI **Image**对象`Image-star0/1/2/3`填充公共字段**星形占位符**的**元素0/1/2/3**数组值。
- en: Now, populate the **Icon Star Yellow** and **Icon Star Grey** public fields
    from the **Project** panel with sprite `icon_star_100` and `icon_star_grey_100`,
    as shown in the following screenshot:![How to do it...](img/1362OT_02_18.jpg)
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从**项目**面板中用精灵`icon_star_100`和`icon_star_grey_100`填充**图标星黄色**和**图标星灰色**公共字段，如图下截图所示：![如何做...](img/1362OT_02_18.jpg)
- en: Now, when you play the scene, you should see the sequence of four grey placeholder
    star icons initially, and each time you collide with a star, the next icon at
    the top should turn yellow.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当你播放场景时，你应该最初看到四个灰色的占位符星形图标，每次你撞击到一个星形时，顶部的下一个图标应该变为黄色。
- en: How it works...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Four UI **Image** objects `Image-star0/1/2/3` have been created at the top of
    the screen, initialized with the grey placeholder icon. The grey and yellow icon
    sprite files have been resized to be 100 x 100 pixels, making their arrangement
    horizontal positioning at design time easier, since their positions are (0,0),
    (100, 0), (200, 0), and (300,0). In a more complicated game screen, or one where
    real estate is precious, the actual size of the icons would probably be smaller
    and whatever the game graphic designer decides.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕顶部创建了四个UI **Image**对象`Image-star0/1/2/3`，初始化为灰色占位符图标。灰色和黄色图标精灵文件已调整大小为100
    x 100像素，这使得在设计时更容易进行水平定位，因为它们的坐标是（0,0），（100, 0），（200, 0），和（300,0）。在一个更复杂的游戏屏幕，或者一个空间宝贵的屏幕中，实际的图标大小可能会更小，具体取决于游戏图形设计师的决定。
- en: The `int` variable `totalStars` represents how many stars have been collected
    so far; it is initialized to zero. The `PlayerInventoryDisplay` variable `playerInventory`
    is a reference to the scripted component that manages our inventory display—this
    variable is set when the scene begins to run in the `Start()` method.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`int`变量`totalStars`代表到目前为止收集了多少颗星星；它被初始化为零。`PlayerInventoryDisplay`变量`playerInventory`是管理我们的库存显示的脚本组件的引用——此变量在场景开始运行时的`Start()`方法中被设置。'
- en: In the `OnTriggerEnter2D()`method, the `totalStars` counter is incremented by
    1 each time the player's character hits an object tagged **Star**. As well as
    destroying the hit GameObject, the `OnChangeStarTotal(…)` method of the `PlayerInventoryDisplay`
    component is called, passing the new star total integer.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnTriggerEnter2D()`方法中，每当玩家的角色撞击带有标签**Star**的对象时，`totalStars`计数器增加1。除了销毁被击中的GameObject外，`PlayerInventoryDisplay`组件的`OnChangeStarTotal(…)`方法也被调用，传递新的星星总数整数。
- en: The `OnChangeStarTotal(…)`method of script class `PlayerInventoryDisplay` has
    references to the four UI **Images**, and loops through each item in the array
    of Image references, setting the given number of Images to yellow, and the remaining
    to grey. This method is public, allowing it to be called from an instance of script
    class `Player`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本类`PlayerInventoryDisplay`的`OnChangeStarTotal(…)`方法引用了四个UI **Images**，并遍历图像引用数组中的每个项目，将指定的图像设置为黄色，其余设置为灰色。此方法是公开的，允许从脚本类`Player`的实例中调用它。
- en: As can be seen, the code in script class `Player` is still quite straightforward
    since we have moved all of the inventory UI logic to its own class, `PlayerInventory`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如所见，脚本类`Player`中的代码仍然相当简单，因为我们已经将所有库存UI逻辑移动到了它自己的类，`PlayerInventory`。
- en: Revealing icons for multiple object pickups by changing the size of a tiled
    image
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过改变瓦片图像的大小来揭示多个对象拾取的图标
- en: Another approach that could be taken to show increasing numbers of images is
    to make use of tiled images. The same visual effect as in the previous recipe
    can also be achieved by making use of a tiled grey star image of width 400 (showing
    four copies of the grey star icon), behind a tiled yellow star image, whose width
    is 100 times the number of stars collected. We'll adapt the previous recipe to
    illustrate this technique.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可以用来显示增加的图像数量的方法是使用瓦片图像。通过使用宽度为400的瓦片灰色星形图像（显示四个灰色星形图标），在瓦片黄色星形图像后面，其宽度是收集的星星数量的100倍，也可以实现与上一个配方中相同的视觉效果。我们将调整前面的配方来展示这种技术。
- en: Getting ready
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe follows on from the previous recipe in this chapter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方基于本章前面的配方。
- en: How to do it...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To display grey and yellow star icons for multiple object pickups using tiled
    images, follow these steps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用平铺图像显示多个对象拾取的灰色和黄色星星图标，请按照以下步骤操作：
- en: Make a copy of your work for the previous recipe.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为前面的配方复制你的工作。
- en: In the **Hierarchy** panel, remove the four Image-star0/1/2/3 UI **Images**
    in the **Canvas**.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中，从**画布**中移除四个Image-star0/1/2/3 UI **图像**。
- en: Select the **Canvas** in the **Hierarchy** panel and add a new UI **Image**
    object (**Create** | **UI** | **Image**). Rename it `Image-stars-grey`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中选择**画布**，并添加一个新的UI **图像**对象（**创建** | **UI** | **图像**）。将其重命名为`Image-stars-grey`。
- en: Select `Image-stars-grey` in the **Hierarchy** panel.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中选择`Image-stars-grey`。
- en: From the **Project** panel, drag sprite `icon_star_grey_100` (folder `Sprites`)
    into the **Source Image** field in the **Inspector** (in the **Image (Script)**
    component).
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**面板中，将精灵`icon_star_grey_100`（文件夹`Sprites`）拖动到**检查器**（在**图像（脚本）**组件中）的**源图像**字段。
- en: Click on the **Set Native Size** button for this for the **Image** component.
    This will resize the UI **Image** to fit the physical pixel width and height of
    sprite file **star_empty_icon.**
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**设置原始大小**按钮以调整**图像**组件的大小。这将使UI **图像**的大小与精灵文件**star_empty_icon**的物理像素宽度和高度相匹配。
- en: Now we will position our icon at the **top** and **left** of the **Game** panel.
    Edit the UI **Image's Rect Transform** component, and while holding down *SHIFT*
    and *ALT* (to set pivot and position), choose the top-left box. The UI **Image**
    should now be positioned at the top left of the **Game** panel.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将图标放置在**游戏**面板的**顶部**和**左侧**。编辑UI **图像**的**矩形变换**组件，在按住*SHIFT*和*ALT*（以设置枢轴和位置）的同时，选择左上角框。现在UI
    **图像**应位于**游戏**面板的左上角。
- en: In the **Inspector** panel, change the **Width** (in the **Rect Transform**
    component) of `Image-stars-grey` to 400\. Also, set the **Image Type** (in the
    **Image (Script)** component) to **Tiled**, as shown in the following screenshot:![How
    to do it...](img/1362OT_02_19.jpg)
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中，将`Image-stars-grey`的**宽度**（在**矩形变换**组件中）更改为400。同时，将**图像类型**（在**图像（脚本）**组件中）设置为**平铺**，如图所示：![如何操作...](img/1362OT_02_19.jpg)
- en: Make a copy of `Image-stars-grey` in the **Hierarchy** panel, naming the copy
    `Image-stars-yellow`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中复制`Image-stars-grey`，并将其副本命名为`Image-stars-yellow`。
- en: With `Image-stars-yellow` selected in **Hierarchy** panel, from the **Project**
    panel, drag the sprite `icon_star_100` (folder `Sprites`) into the **Source Image**
    field in the **Inspector** (in the **Image (Script)** component).
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中选择`Image-stars-yellow`，从**项目**面板中，将精灵`icon_star_100`（文件夹`Sprites`）拖动到**检查器**（在**图像（脚本）**组件中）的**源图像**字段。
- en: Set the width of `Image-stars-yellow` to 0 (in the **Rect Transform** component).
    So, now we have the yellow stars tiled image above the grey tiled image, but since
    its width is zero, we don't see any of the yellow stars yet.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Image-stars-yellow`的宽度设置为0（在**矩形变换**组件中）。因此，现在我们有了位于灰色平铺图像之上的黄色星星平铺图像，但由于其宽度为零，我们目前看不到任何黄色星星。
- en: 'Replace the existing C# Script `PlayerInventoryDisplay` with the following
    code:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换现有的C#脚本`PlayerInventoryDisplay`：
- en: '[PRE8]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: From the **Hierarchy** view, select the GameObject `player-SpaceGirl`. Then,
    from the **Inspector**, access the **Player Inventory Display (Script)** component
    and populate the **Icons Stars Yellow** public field with UI **Image** object
    `Image-stars-yellow`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**视图中选择GameObject `player-SpaceGirl`。然后，从**检查器**中访问**玩家库存显示（脚本）**组件，并将公共字段**图标星星黄色**填充为UI
    **图像**对象`Image-stars-yellow`。
- en: How it works...
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: UI **Image** `Image-stars-grey` is a tiled image, wide enough (400px) for grey
    sprite **icon_star_grey_100** to be shown four times. UI **Image** `Image-stars-yellow`
    is a tiled image, above the grey one, initially with width set to zero, so no
    yellow stars can be seen.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: UI **图像** `Image-stars-grey`是一个平铺图像，宽度足够（400px），可以显示灰色精灵**icon_star_grey_100**四次。UI
    **图像** `Image-stars-yellow`是一个平铺图像，位于灰色图像之上，初始宽度设置为零，因此看不到任何黄色星星。
- en: Each time a star is picked up, a call is made to the `OnChangeStarTotal(…)`method
    of the script class `PlayerInventoryDisplay` , passing the new integer number
    of stars collected. By multiplying this by the width of the yellow sprite image
    (100px), we get the correct width to set for UI **Image** `Image-stars-yellow`
    so that the corresponding number of yellow stars will now be seen by the user.
    Any stars that remain to be collected will still be seen as the grey stars that
    are not yet covered up.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 每次拾取一颗星星时，都会调用脚本类`PlayerInventoryDisplay`的`OnChangeStarTotal(…)`方法，传递收集到的新的整数星星数量。通过将这个数乘以黄色精灵图像的宽度（100px），我们得到设置UI
    **Image** `Image-stars-yellow`的正确宽度，以便用户现在可以看到相应数量的黄色星星。任何尚未收集的星星仍然以灰色星星的形式显示，这些星星尚未被覆盖。
- en: The actual task of changing the width of UI **Image** `Image-stars-yellow` is
    completed by calling the `SetSizeWithCurrentAnchors(…)` method. The first parameter
    is the axis, so we pass constant `RectTransform.Axis.Horizontal` so that it will
    be the width that is changed. The second parameter is the new size for that axis—so
    we pass a value that is 100 times the number of stars collected so far (variable
    `newWidth`).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，通过调用`SetSizeWithCurrentAnchors(…)`方法来更改UI **Image** `Image-stars-yellow`的宽度。第一个参数是轴，因此我们传递常量`RectTransform.Axis.Horizontal`，以便它将更改宽度。第二个参数是那个轴的新大小——因此我们传递一个值，它是迄今为止收集的星星数量的100倍（变量`newWidth`）。
- en: Displaying multiple pickups of different objects as a list of text via a dynamic
    List<> of PickUp objects
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过动态**List<>**的PickUp对象以文本列表的形式显示不同对象的多个拾取器
- en: When working with different kinds of pickups, one approach is to use a C# **List**
    to maintain a flexible-length data structure of the items currently in the inventory.
    In this recipe, we will show you how, each time an item is picked up, a new object
    is added to such a **List** collection. An iteration through the **List** is how
    the text display of items is generated each time the inventory changes. We introduce
    a very simple `PickUp` script class, demonstrating how information about a pickup
    can be stored in a scripted component, extracted upon collision, and stored in
    our **List**.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当与不同类型的拾取器一起工作时，一种方法是在C# **List**中使用，以维护当前库存中项目的一个灵活长度的数据结构。在这个菜谱中，我们将向您展示，每次拾取一个项目时，都会向这样的**List**集合中添加一个新的对象。通过遍历**List**，每次库存更改时都会生成物品的文本显示。我们引入一个非常简单的`PickUp`脚本类，演示如何将拾取的信息存储在脚本组件中，在碰撞时提取，并存储在我们的**List**中。
- en: '![Displaying multiple pickups of different objects as a list of text via a
    dynamic List<> of PickUp objects](img/1362OT_02_36.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![通过动态**List<>**的PickUp对象以文本列表的形式显示不同对象的多个拾取器](img/1362OT_02_36.jpg)'
- en: Getting ready
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes that you are starting with the project `Simple2Dgame_SpaceGirl`
    setup from the first recipe in this chapter. The font you need can be found in
    the `1362_02_02` folder.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱假设您是从本章第一道菜谱中设置的`Simple2Dgame_SpaceGirl`项目开始的。您需要的字体可以在`1362_02_02`文件夹中找到。
- en: How to do it...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To display inventory total text for multiple pickups of different object types,
    follow these steps:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示多个不同类型拾取器的库存总数文本，请按照以下步骤操作：
- en: Start with a new copy of the mini-game `Simple2Dgame_SpaceGirl`.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Simple2Dgame_SpaceGirl`迷你游戏的副本开始。
- en: Edit the tags, changing tag **Star** to **Pickup**. Ensure that the `star` GameObject
    now has the tag **Pickup**.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑标签，将标签**星**更改为**拾取**。确保`star` GameObject现在具有标签**拾取**。
- en: 'Add the following C# Script `PickUp` to GameObject `star` in the **Hierarchy**:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下C#脚本`PickUp`添加到**层次结构**中的GameObject `star`：
- en: '[PRE9]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the **Inspector**, change the description property of component **Pick Up
    (Script)** of GameObject `star` to the text `star`, as shown in the following
    screenshot:![How to do it...](img/1362OT_02_37.jpg)
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，将GameObject `star`的组件**拾取（脚本）**的描述属性更改为文本`star`，如图所示：![如何操作...](img/1362OT_02_37.jpg)
- en: Select the GameObject `star` in the **Hierarchy** panel and make a copy of this
    GameObject, renaming the copy `heart`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中选择GameObject `star`，并复制此GameObject，将其重命名为`heart`。
- en: In the **Inspector,** change the description property of component **Pick Up
    (Script)** of GameObject `heart` to the text `heart`. Also, drag from the **Project**
    panel (folder `Sprites`) image **healthheart** into the Sprite property of GameObject
    `heart`. The player should now see the heart image on screen for this pickup item.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，将GameObject `heart`的组件**拾取（脚本）**的描述属性更改为文本`heart`。然后，从**项目**面板（文件夹`Sprites`）中将图像**healthheart**拖动到GameObject
    `heart`的Sprite属性中。现在，玩家应该能在屏幕上看到这个拾取物品的心形图像。
- en: Select the GameObject `star` in the **Hierarchy** panel and make a copy of this
    GameObject, renaming the copy `key`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Hierarchy** 面板中选择 GameObject `star`，并复制此 GameObject，将其重命名为 `key`。
- en: In the **Inspector,** change the description property of component **Pick Up
    (Script)** of GameObject `key` to the text `key.` Also, drag from the **Project**
    panel (folder **Sprites**) image **icon_key_green_100** into the **Sprite** property
    of GameObject `key`. The player should now see the key image on screen for this
    pickup item.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Inspector** 中，将 GameObject `key` 的组件 **Pick Up (Script)** 的描述属性更改为文本 `key.`。也将从
    **Project** 面板（文件夹 **Sprites**）中的图像 **icon_key_green_100** 拖动到 GameObject `key`
    的 **Sprite** 属性中。现在玩家应该在屏幕上看到这个拾取物品的钥匙图像。
- en: Make another one or two copies of each pickup GameObject and arrange them around
    the screen, so there are two or three each of star, heart, and key pickup GameObjects.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个拾取 GameObject 制作一个或两个副本，并将它们排列在屏幕周围，以便星形、心形和钥匙拾取 GameObject 各有两个或三个。
- en: 'Add the following C# Script `Player` to GameObject `player-SpaceGirl` in the
    **Hierarchy**:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 C# 脚本 `Player` 添加到 **Hierarchy** 中的 GameObject `player-SpaceGirl`：
- en: '[PRE10]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Add a UI **Text** object (**Create** | **UI** | **Text**). Rename it `Text-inventory-list`.
    Change its text to **the quick brown fox jumped over the lazy dog the quick brown
    fox jumped over the lazy dog**, or another long list of nonsense words, to test
    the overflow settings you change in the next step.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 UI **Text** 对象（**Create** | **UI** | **Text**）。将其重命名为 `Text-inventory-list`。将其文本更改为
    **the quick brown fox jumped over the lazy dog the quick brown fox jumped over
    the lazy dog**，或另一个长列表的胡言乱语，以测试您在下一步中更改的溢出设置。
- en: In the **Text (Script)** component, ensure that **Horizontal Overflow** is set
    to **Wrap**, and set **Vertical Overflow** to **Overflow**—this will ensure that
    the text will wrap onto a second or third line (if needed) and not be hidden if
    there are lots of pickups.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Text (Script)** 组件中，确保 **Horizontal Overflow** 设置为 **Wrap**，并将 **Vertical
    Overflow** 设置为 **Overflow**——这将确保文本将换行到第二行或第三行（如果需要），并且当有很多拾取物时不会被隐藏。
- en: In the **Inspector** panel, set its font to **Xolonium-Bold** (folder `Fonts`)
    and set its color to yellow. For the **Alignment** property, center the text horizontally
    and ensure that the text is top aligned vertically, and set the **Font Size**
    to 28 and choose a yellow text **Color**.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Inspector** 面板中，将其字体设置为 **Xolonium-Bold**（文件夹 `Fonts`），并将颜色设置为黄色。对于 **Alignment**
    属性，水平居中文本，并确保文本垂直对齐，将 **Font Size** 设置为 28 并选择黄色文本 **Color**。
- en: Edit its **Rect Transform** and set its **Height** to `50`. Then, while holding
    down *SHIFT* and *ALT* (to set pivot and position), choose the top-stretch box.
    The text should now be positioned at the middle top of the **Game** panel, and
    its width should stretch to match that of the whole panel.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑其 **Rect Transform** 并将其 **Height** 设置为 `50`。然后，在按住 *SHIFT* 和 *ALT*（以设置轴点和位置）的同时，选择顶部拉伸框。现在文本应位于
    **Game** 面板的中间顶部，其宽度应拉伸以匹配整个面板。
- en: Your text should now appear at the top of the game panel.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的文本现在应出现在游戏面板的顶部。
- en: 'Add the following C# Script `PlayerInventoryDisplay` to GameObject `player-SpaceGirl`
    in the **Hierarchy**:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 C# 脚本 `PlayerInventoryDisplay` 添加到 **Hierarchy** 中的 GameObject `player-SpaceGirl`：
- en: '[PRE11]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: From the **Hierarchy** view, select the GameObject `player-SpaceGirl`. Then,
    from the **Inspector**, access the **Player Inventory Display (Script)** component
    and populate the **Inventory Text** public field with the UI **Text** object `Text-inventory-list`.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Hierarchy** 视图中选择 GameObject `player-SpaceGirl`。然后，从 **Inspector** 中访问 **Player
    Inventory Display (Script)** 组件，并将 **Inventory Text** 公共字段填充为 UI **Text** 对象 `Text-inventory-list`。
- en: 'Play the game—each time you pick up a star or key or heart, the updated list
    of what you are carrying should be displayed in the form **carrying: [key] [heart]**.'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '开始游戏——每次拾取星星、钥匙或心形时，您所携带的更新列表应以 **carrying: [key] [heart]** 的形式显示。'
- en: How it works...
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the script class `Player`, the variable `inventory` is a C# **List<>**. This
    is a flexible data structure, which can be sorted, searched, and dynamically (at
    run time, when the game is being played) have items added to and removed from
    it. The `<PickUp>` in pointy brackets means that variable `inventory` will contain
    a list of `PickUp` objects. For this recipe, our `PickUp` class just has a single
    field, a string description, but we'll add more sophisticated data items in `PickUp`
    classes in later recipes.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本类 `Player` 中，变量 `inventory` 是一个 C# **List<>**。这是一个灵活的数据结构，可以进行排序、搜索，并在游戏运行时动态（在游戏进行时）向其中添加和删除项目。尖括号中的
    `<PickUp>` 表示变量 `inventory` 将包含 `PickUp` 对象的列表。对于这个配方，我们的 `PickUp` 类只有一个字段，即一个字符串描述，但我们在后面的配方中将在
    `PickUp` 类中添加更复杂的数据项。
- en: When the scene starts, the `Start()` method of script class `Player` gets a
    reference to the `PlayerInventoryDisplay` scripted component and also initializes
    variable `inventory` to be a new, empty C# List of `PickUp` objects. When the
    `OnColliderEnter2D(…)` method detects collisions with items tagged `Pickup`, the
    `PickUp` object component of the item hit is added to our `inventory` list. A
    call is also made to the `OnChangeInventory(…)` method of `playerInventoryDisplay`
    to update out inventory display to the player, passing the updated `inventory`
    **List** as a parameter.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当场景开始时，脚本类 `Player` 的 `Start()` 方法获取 `PlayerInventoryDisplay` 脚本组件的引用，并将变量 `inventory`
    初始化为一个新的空 C# `PickUp` 对象列表。当 `OnColliderEnter2D(…)` 方法检测到与标记为 `Pickup` 的项目发生碰撞时，被击中的项目的
    `PickUp` 对象组件将被添加到我们的 `inventory` 列表中。同时还会调用 `playerInventoryDisplay` 的 `OnChangeInventory(…)`
    方法来更新玩家的库存显示，并将更新的 `inventory` **List** 作为参数传递。
- en: The script class `playerInventoryDisplay` has a public variable, linked to the
    UI **Text** object `Text-inventory-list`. The `OnChangeInventory(…)` method first
    sets the UI text to empty, and then loops through the inventory list, building
    up a string of each items description in square brackets ([key], [heart], and
    so on). If there were no items in the list, then the string is set to the text
    `(empty inventory)`. Finally, the text property of the UI **Text** object `Text-inventory-list`
    is set to the value of this string representation of what is inside variable `inventory`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本类 `playerInventoryDisplay` 有一个公共变量，与 UI **Text** 对象 `Text-inventory-list`
    相关联。`OnChangeInventory(…)` 方法首先将 UI 文本设置为空，然后遍历库存列表，构建一个包含每个项目描述的字符串（[key]，[heart]，等等）。如果没有项目在列表中，则字符串设置为文本
    `(empty inventory)`。最后，将 UI **Text** 对象 `Text-inventory-list` 的文本属性设置为变量 `inventory`
    内部表示的字符串值。
- en: There's more...
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Some details you don''t want to miss:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 一些你不希望错过的细节：
- en: Order items in the inventory list alphabetically
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按字母顺序排列库存列表中的项目
- en: It would be nice to alphabetically sort the words in the `inventory` list—both
    for neatness and consistency (so, in a game, if we pick up a key and a heart,
    it will look the same regardless of which order), but also so that items of the
    same type will be listed together, so we can easily see how many of each item
    we are carrying.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果能按字母顺序对 `inventory` 列表中的单词进行排序那就太好了——这不仅为了整洁和一致性（因此，在游戏中，如果我们捡起一个钥匙和一个心形，无论顺序如何，看起来都一样），而且还因为相同类型的物品将一起列出，这样我们可以轻松地看到我们携带了多少每种物品。
- en: '![Order items in the inventory list alphabetically](img/1362OT_02_38.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![按字母顺序排列库存列表中的项目](img/1362OT_02_38.jpg)'
- en: 'To implement the alphabetic sorting of the items in the `inventory` list, we
    need to do the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 `inventory` 列表中项目的字母排序，我们需要做以下几步：
- en: 'Add the following C# code to the beginning of method `OnChangeInventory(...)`
    in the script class `PlayerInventoryDisplay`:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 C# 代码添加到脚本类 `PlayerInventoryDisplay` 中 `OnChangeInventory(...)` 方法的开头：
- en: '[PRE12]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You should now see all the items listed in alphabetic sequence. This C# code
    takes advantage of the `List.Sort(…)` method, a feature of collections whereby
    each item can be compared to the next, and they are swapped if in the wrong order
    (if the `CompareTo(…)` methods returns false).
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在应该能看到所有项目按字母顺序列出。这段 C# 代码利用了 `List.Sort(…)` 方法，这是集合的一个特性，其中每个项目都可以与下一个项目进行比较，如果顺序错误（如果
    `CompareTo(…)` 方法返回 false），则它们会被交换。
- en: Displaying multiple pickups of different objects as text totals via a dynamic
    Dictionary<> of PickUp objects and "enum" pickup types
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过动态字典<>显示不同对象的多个拾取项作为文本总计，字典包含 `PickUp` 对象和 "enum" 拾取类型
- en: While the previous recipe worked fine, any old text might have been typed into
    the description for a pickup or perhaps mistyped (**star**, **Sstar**, **starr**,
    and so on). A much better way of restricting game properties to one of a predefined
    (enumerated) list of possible values is to use C# enums. As well as removing the
    chance of mistyping a string, it also means that we can write code to appropriately
    deal with the predefined set of possible values. In this recipe, we will improve
    our general purpose `PickUp` class by introducing three possible pickup types
    (Star, Heart, and Key), and write inventory display code that counts the number
    of each type of pickup being carried and displays these totals via a UI **Text**
    object on screen. We also switch from using a **List** to using a **Dictionary**,
    since the Dictionary data structure is designed specifically for key-value pairs,
    perfect for associating a numeric total with an enumerated pickup type.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管之前的菜谱工作得很好，但描述中可能已经输入了任何旧文本，或者可能是误输入（**star**、**Sstar**、**starr**等等）。一个更好的方法是将游戏属性限制为预定义（枚举）列表中的可能值之一，是使用
    C# 枚举。除了消除输入字符串错误的机会外，这也意味着我们可以编写代码来适当地处理预定义的可能值集合。在这个菜谱中，我们将通过引入三种可能的拾取类型（星、心形和钥匙）来改进我们的通用
    `PickUp` 类，并编写库存显示代码，该代码计算携带的每种类型拾取的数量，并通过屏幕上的 UI **Text** 对象显示这些总数。我们还从使用 **List**
    切换到使用 **Dictionary**，因为 Dictionary 数据结构是专门为键值对设计的，非常适合将数值总数与枚举拾取类型关联起来。
- en: '![Displaying multiple pickups of different objects as text totals via a dynamic
    Dictionary<> of PickUp objects and "enum" pickup types](img/1362OT_02_39.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![通过动态的 PickUp 对象和 "enum" 拾取类型的 Dictionary<> 显示不同对象的多个拾取作为文本总数](img/1362OT_02_39.jpg)'
- en: Getting ready
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe follows on from the previous recipe in this chapter.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱是本章中之前菜谱的延续。
- en: How to do it...
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To display multiple pickups of different objects as text totals via a dynamic
    `Dictionary`, follow these steps:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过动态的 `Dictionary` 显示不同对象的多个拾取作为文本总数，请按照以下步骤操作：
- en: Make a copy of your work for the previous recipe.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制你之前菜谱的工作。
- en: 'Replace the content of script class `PickUp` with the following code:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本类 `PickUp` 的内容替换为以下代码：
- en: '[PRE13]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Replace the content of script class `Player` with the following code:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本类 `Player` 的内容替换为以下代码：
- en: '[PRE14]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Replace the content of script class `PlayerInventoryDisplay` with the following
    code:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本类 `PlayerInventoryDisplay` 的内容替换为以下代码：
- en: '[PRE15]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the following C# Script `InventoryManager` to the GameObject `player-SpaceGirl`
    in the **Hierarchy**:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 C# 脚本 `InventoryManager` 添加到 **Hierarchy** 中的 `player-SpaceGirl` GameObject：
- en: '[PRE16]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the **Hierarchy** (or **Scene**) panel, select each pickup GameObject in
    turn, and choose from the drop-down menu its corresponding **Type** in the **Inspector**
    panel. As you can see, public variables that are of an `enum` type are automatically
    restricted to the set of possible values as a combo-box drop-down menu in the
    **Inspector** panel.![How to do it...](img/1362OT_02_40.jpg)
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Hierarchy**（或 **Scene**）面板中，依次选择每个拾取 GameObject，并在 **Inspector** 面板中的下拉菜单中选择其对应的
    **Type**。正如你所看到的，公共变量如果是 `enum` 类型，它们会自动限制为可能的值集合，作为 **Inspector** 面板中的组合框下拉菜单。![如何做...](img/1362OT_02_40.jpg)
- en: Play the game. First, you should see a message on screen stating the inventory
    is empty, and then as you pick up one or more items of each pickup type, you'll
    see text totals of each type you have collected.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩游戏。首先，你应该在屏幕上看到一个消息，说明库存为空，然后当你拾取每种类型的单个或多个物品时，你会看到你收集的每种类型的文本总数。
- en: How it works...
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Each pickup GameObject in the scene has a scripted component of class `PickUp`.
    The `PickUp` object for each `Pickup` GameObject has a single property, a pickup
    type, which has to be one of the enumerated set of `Star, Key, Heart`. The `Player`
    script class gets a reference to the `InventoryManager` component via its `Start()`
    method, and each time the player's character collides with a pickup GameObject,
    it calls the `Add(…)` method of the inventory manager, passing the `PickUp` object
    of the object collided with.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 场景中的每个拾取 GameObject 都有一个名为 `PickUp` 类的脚本组件。每个 `PickUp` GameObject 的 `PickUp`
    对象有一个单一属性，即拾取类型，它必须是 `Star`、`Key`、`Heart` 等枚举集合中的一个。`Player` 脚本类通过其 `Start()`
    方法获取对 `InventoryManager` 组件的引用，并且每当玩家的角色与拾取 GameObject 发生碰撞时，它都会调用库存管理器的 `Add(…)`
    方法，并将碰撞对象的 `PickUp` 对象传递给它。
- en: 'In this recipe, the inventory being carried by the player is being represented
    by a C# `Dictionary`. In this case, we have in script class `InventoryManager`
    a dictionary of key-value pairs, where the key is one of the possible `PickUp.PickUpType`
    enumerated values, and the value is an integer total of how many of that type
    of pickup is being carried. Each `InventoryItemTotal` object has just two properties:
    a `PickUp` type and an integer total. This extra layer of the `InventoryManager`
    has been added between script class `Player` and `PlayerInventoryDisplay` to both
    separate the `Player` behavior from how the inventory is internally stored and
    to prevent the `Player` script class from becoming too large and attempting to
    handle too many different responsibilities.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，玩家携带的库存由 C# 的 `Dictionary` 表示。在这种情况下，我们在脚本类 `InventoryManager` 中有一个键值对字典，其中键是可能的
    `PickUp.PickUpType` 枚举值之一，而值是携带该类型拾取物的整数总数。每个 `InventoryItemTotal` 对象只有两个属性：一个
    `PickUp` 类型和一个整数总数。在脚本类 `Player` 和 `PlayerInventoryDisplay` 之间添加了 `InventoryManager`
    的这一额外层，目的是为了将 `Player` 的行为与库存的内部存储方式分开，并防止 `Player` 脚本类变得过大，试图处理过多的不同职责。
- en: C# dictionaries provide a `TryGetValue(…)` method, which receives parameters
    of a key and is passed a reference to a variable the same data type as the value
    for the `Dictionary`. When the `Add(…)` method of the inventory manager is called,
    the type of the `PickUp` object is tested to see if a total for this type is already
    in `Dictionary items`. If an item total is found inside the `Dictionary` for the
    given type, then the value for this item in the `Dictionary` is incremented. If
    no entry is found for the given type, then a new element is added to the `Dictionary`
    with a total of 1.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: C# 字典提供了一个 `TryGetValue(…)` 方法，它接收键的参数，并传递一个与 `Dictionary` 的值相同数据类型的变量的引用。当调用库存管理器的
    `Add(…)` 方法时，会测试 `PickUp` 对象的类型，以查看是否在 `Dictionary items` 中已经存在该类型的总数。如果找到给定类型的项总数在
    `Dictionary` 中，则该项目的 `Dictionary` 中的值会增加。如果没有找到给定类型的条目，则会在 `Dictionary` 中添加一个新的元素，其总数为
    1。
- en: The last action of the `Add(…)` method is to call the `OnChangeInventory(…)`
    method of the `PlayerInventoryDisplay` scripted component of the player's GameObject
    to update the text totals displayed on screen. This method in `PlayerInventoryDisplay`
    iterates through the `Dictionary`, building up a string of the type names and
    totals, and then updates the text property of the UI Text object with the string
    showing the inventory totals to the player.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add(…)` 方法的最后一个动作是调用玩家 GameObject 的 `PlayerInventoryDisplay` 脚本组件的 `OnChangeInventory(…)`
    方法，以更新屏幕上显示的文本总数。在 `PlayerInventoryDisplay` 中，此方法遍历 `Dictionary`，构建类型名称和总数的字符串，然后更新
    UI Text 对象的文本属性，向玩家显示库存总数。'
- en: Learn more about using C# lists and dictionaries in Unity in the Unity Technologies
    tutorial at [https://unity3d.com/learn/tutorials/modules/intermediate/scripting/lists-and-dictionaries](https://unity3d.com/learn/tutorials/modules/intermediate/scripting/lists-and-dictionaries).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity Technologies 的教程中了解更多关于在 Unity 中使用 C# 列表和字典的信息，请访问 [https://unity3d.com/learn/tutorials/modules/intermediate/scripting/lists-and-dictionaries](https://unity3d.com/learn/tutorials/modules/intermediate/scripting/lists-and-dictionaries)。
- en: Generalizing multiple icon displays using UI Grid Layout Groups (with scrollbars!)
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 UI Grid Layout Groups 通用多个图标显示（带滚动条！）
- en: The recipes in this chapter up to this point have been hand-crafted for each
    situation. While this is fine, more general and automated approaches to inventory
    UIs can sometimes save time and effort but still achieve visual and usability
    results of equal quality. In the next recipe, we will begin to explore a more
    engineered approach to inventory UIs by exploiting the automated sizing and layouts
    offered by Unity 5's Grid Layout Group component.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章中的菜谱都是为每种情况手工制作的。虽然这样做是可以的，但更通用和自动化的库存 UI 方法有时可以节省时间和精力，同时仍然达到相同质量和可用性的视觉效果。在下一道菜谱中，我们将开始探索一种更工程化的库存
    UI 方法，通过利用 Unity 5 的 Grid Layout Group 组件提供的自动尺寸和布局。
- en: '![Generalizing multiple icon displays using UI Grid Layout Groups (with scrollbars!)](img/1362OT_02_20.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![使用 UI Grid Layout Groups 通用多个图标显示（带滚动条！）](img/1362OT_02_20.jpg)'
- en: Getting ready
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes that you are starting with the project `Simple2Dgame_SpaceGirl`
    setup from the first recipe in this chapter. The font you need can be found in
    the `1362_02_02` folder.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱假设您是从本章第一道菜谱中设置的 `Simple2Dgame_SpaceGirl` 项目开始的。所需的字体可以在 `1362_02_02` 文件夹中找到。
- en: How to do it...
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To display grey and yellow star icons for multiple object pickups using UI
    grid layout groups, follow these steps:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用UI网格布局组显示灰色和黄色星形图标以表示多个对象拾取，请按照以下步骤操作：
- en: Start with a new copy of the mini-game `Simple2Dgame_SpaceGirl`.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个新的`Simple2Dgame_SpaceGirl`迷你游戏副本开始。
- en: In the **Hierarchy** panel, create a UI Panel `Panel–background` (**Create**
    | **UI** | **Panel**).
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**面板中，创建一个UI面板`Panel–background`（**创建** | **UI** | **面板**）。
- en: Let's now position `Panel–background` at the **top** of the **Game** panel,
    stretching the horizontal width of the canvas. Edit the UI **Image's Rect Transform**
    component, and while holding down *SHIFT* and *ALT* (to set pivot and position),
    choose the top-stretch box.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将`Panel–background`放置在**游戏**面板的**顶部**，拉伸画布的水平宽度。编辑UI **图像的矩形变换**组件，在按住*SHIFT*和*ALT*（以设置支点和位置）的同时，选择顶部拉伸框。
- en: The panel will still be taking up the whole game window. So, now in the **Inspector**
    panel, change the **Height** (in the **Rect Transform** component) of `Panel–background`
    to 100, as shown in the following screenshot:![How to do it...](img/1362OT_02_21.jpg)
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 面板仍然会占据整个游戏窗口。因此，现在在**检查器**面板中，将`Panel–background`的**高度**（在**矩形变换**组件中）更改为100，如图所示：![如何操作...](img/1362OT_02_21.jpg)
- en: Add a UI **Text** object (**Create** | **UI** | **Text**), rename it `Text-inventory`,
    and change its text to **Inventory**.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个UI **文本**对象（**创建** | **UI** | **文本**），将其重命名为`Text-inventory`，并将其文本更改为**库存**。
- en: In the **Hierarchy** panel, child this UI Text object to panel `Panel–background`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**面板中，将此UI文本对象作为子对象添加到面板`Panel–background`中。
- en: In the **Inspector** panel, also set the font of `Text-inventory` to **Xolonium-Bold**
    (the `Fonts` folder). Center the text horizontally, top align the text vertically,
    set its **Height** to `50`, and set the **Font Size** to `23`.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中，还将`Text-inventory`的字体设置为**Xolonium-Bold**（在`Fonts`文件夹中）。水平居中文本，垂直顶部对齐文本，将其**高度**设置为`50`，并将**字体大小**设置为`23`。
- en: Edit the **Rect Transform** of `Text-inventory`, and while holding down *SHIFT*
    and *ALT* (to set pivot and position), choose the top-stretch box. The text should
    now be positioned at the middle top of the **UI Panel** `Panel–background` and
    its width should stretch to match that of the whole panel.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`Text-inventory`的**矩形变换**，在按住*SHIFT*和*ALT*（以设置支点和位置）的同时，选择顶部拉伸框。现在文本应位于**UI面板**`Panel–background`的中间顶部，并且其宽度应拉伸以匹配整个面板的宽度。
- en: Select the **Canvas** in the **Hierarchy** panel and add a new UI Panel object
    (**Create** | **UI** | **Image**). Rename it `Panel-slot-grid`.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**面板中选择**画布**，并添加一个新的UI面板对象（**创建** | **UI** | **图像**）。将其重命名为`Panel-slot-grid`。
- en: Position `Panel-slot-grid` at the **top** of the **Game** panel, stretching
    the horizontal width of the canvas. Edit the UI **Image's Rect Transform** component,
    and while holding down *SHIFT* and *ALT* (to set pivot and position), choose the
    top-stretch box.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Panel-slot-grid`放置在**游戏**面板的**顶部**，拉伸画布的水平宽度。编辑UI **图像的矩形变换**组件，在按住*SHIFT*和*ALT*（以设置支点和位置）的同时，选择顶部拉伸框。
- en: In the **Inspector** panel, change the **Height** (in the **Rect Transform**
    component) of `Panel-slot-grid` to `80` and set its **Top** to `20` (so it is
    below UI **Text** GameObject `Text-inventory`).
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中，将`Panel-slot-grid`的**高度**（在**矩形变换**组件中）更改为`80`，并设置其**顶部**为`20`（这样它就在UI
    **文本**游戏对象`Text-inventory`下方）。
- en: With the panel `Panel-slot-grid` selected in the **Hierarchy** panel, add a
    grid layout group component (**Add Component** | **Layout** | **Grid Layout Group**).
    Set **Cell Size** to `70` x `70` and **Spacing** to `5` x `5`. Also, set the **Child
    Alignment** to **Middle Center** (so our icons will have even spacing at the far
    left and right), as shown in the following screenshot:![How to do it...](img/1362OT_02_22.jpg)
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**面板中选择`Panel-slot-grid`面板，添加一个网格布局组组件（**添加组件** | **布局** | **网格布局组**）。将**单元格大小**设置为`70`
    x `70`，将**间距**设置为`5` x `5`。同时，将**子对齐**设置为**居中**（这样我们的图标在左侧和右侧将有均匀的间距），如图所示：![如何操作...](img/1362OT_02_22.jpg)
- en: With the panel `Panel-slot-grid` selected in the **Hierarchy** panel, add a
    mask (script) component (**Add Component** | **UI** | **Mask**). Uncheck the option
    **Show Mask Graphic**. Having this mask component means that any overflow of our
    grid will NOT be seen by the user—only content within the image area of the panel
    `Panel-slot-grid` will ever be visible.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**面板中选择`Panel-slot-grid`面板，添加一个遮罩（脚本）组件（**添加组件** | **UI** | **遮罩**）。取消勾选**显示遮罩图形**选项。拥有这个遮罩组件意味着用户将看不到我们网格的任何溢出部分——只有面板`Panel-slot-grid`的图像区域内的内容才会可见。
- en: Add to your **Canvas** a UI **Image** object (**Create** | **UI** | **Image**).
    Rename it `Image-slot`.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的**Canvas**中添加一个UI **Image** 对象（**创建** | **UI** | **Image**）。将其重命名为`Image-slot`。
- en: In the **Hierarchy** panel, child UI **Image** object `Image-slot` to panel
    `Panel–slot-grid`.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中，将子UI **Image** 对象`Image-slot`添加到面板`Panel–slot-grid`。
- en: Set the **Source Image** of `Image-slot` to the Unity provided **Knob** (circle)
    image, as shown in the following screenshot:![How to do it...](img/1362OT_02_23.jpg)
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Image-slot`的**源图像**设置为Unity提供的**旋钮**（圆形）图像，如图所示：![如何操作...](img/1362OT_02_23.jpg)
- en: Since `Image-slot` is the only UI object inside `Panel-slot-grid,` it will be
    displayed (sized 70 x 70) in center in that panel, as shown in the following screenshot:![How
    to do it...](img/1362OT_02_24.jpg)
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`Image-slot`是`Panel-slot-grid`内部唯一的UI对象，它将在该面板中居中显示（尺寸为70 x 70），如图所示：![如何操作...](img/1362OT_02_24.jpg)
- en: Each image slot will have a yellow star child image and a grey star child image.
    Let's create those now.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个图像槽位将有一个黄色星形子图像和一个灰色星形子图像。现在让我们创建这些图像。
- en: Add to your **Canvas** a UI **Image** object (**Create | UI | Image**). Rename
    it `Image-star-yellow`.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的**Canvas**中添加一个UI **Image** 对象（**创建 | UI | Image**）。将其重命名为`Image-star-yellow`。
- en: In the **Hierarchy** panel, child UI **Image** object `Image-star-yellow` to
    image `Image–slot`.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中，将子UI **Image** 对象`Image-star-yellow`添加到图像`Image–slot`。
- en: Set the **Source Image** of `Image-star-yellow` to the `icon_star_100` image
    (in folder `Sprites`).
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Image-star-yellow`的**源图像**设置为`icon_star_100`图像（在`Sprites`文件夹中）。
- en: Now we will set our yellow star icon image to fully fill its parent `Image-slot`
    by stretching horizontally and vertically. Edit the UI **Image's Rect Transform**
    component, and while holding down *SHIFT* and *ALT* (to set pivot and position),
    choose the bottom right option to fully **stretch** horizontally and vertically.
    The UI **Image** `Image-star-yellow` should now be visible in the middle of the
    `Image-slot` circular **Knob** image, as shown in the following screenshot:![How
    to do it...](img/1362OT_02_25.jpg)
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将设置黄色星形图标图像以完全填充其父`Image-slot`，通过水平和垂直拉伸。编辑UI **Image的Rect Transform**组件，并在按住*SHIFT*和*ALT*（以设置枢轴和位置）的同时，选择底部右侧选项以完全**拉伸**。UI
    **Image** `Image-star-yellow`现在应该位于`Image-slot`圆形**旋钮**图像的中间，如图所示：![如何操作...](img/1362OT_02_25.jpg)
- en: Duplicate `Image-star-yellow` in the **Hierarchy** panel, naming the copy `Image-star-grey`.
    This new GameObject should also be a child of `Image-slot`.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中复制`Image-star-yellow`，将其命名为`Image-star-grey`。这个新的GameObject也应该成为`Image-slot`的子项。
- en: 'Change the **Source Image** of `Image-star-grey` to the `icon_star_grey_100`
    image (in folder `Sprites`). At any time, our inventory slot can now display nothing,
    a yellow star icon, or a grey star icon, depending on whether `Image-star-yellow`
    and `Image-star-grey` are enabled or not: we''ll control this through the inventory
    display code later in this recipe.'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Image-star-grey`的**源图像**更改为`icon_star_grey_100`图像（在`Sprites`文件夹中）。在任何时候，我们的库存槽位都可以显示无内容、黄色星形图标或灰色星形图标，具体取决于`Image-star-yellow`和`Image-star-grey`是否启用：我们将在本食谱后面的库存显示代码中控制这一点。
- en: 'In the **Hierarchy** panel, ensure that `Image-slot` is selected, and add the
    C# Script `PickupUI` with the following code:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中，确保已选择`Image-slot`，并添加以下代码的C#脚本`PickupUI`：
- en: '[PRE17]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With the GameObject `Image-slot` selected in the **Hierarchy** panel, drag each
    of its two children `Image-star-yellow` and `Image-star-grey` into their corresponding
    **Inspector** panel **Pickup UI** slots **Star Yellow** and **Star Grey**, as
    shown in the following screenshot:![How to do it...](img/1362OT_02_27.jpg)
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中选择GameObject `Image-slot`，将其两个子项`Image-star-yellow`和`Image-star-grey`拖动到相应的**检查器**面板**拾取UI**槽位**星黄色**和**星灰色**，如图所示：![如何操作...](img/1362OT_02_27.jpg)
- en: In the **Hierarchy** panel, make nine duplicates of `Image-slot` in the **Hierarchy**
    panel; they should automatically be named `Image-slot 1 .. 9`. See the following
    screenshot to ensure the Hierarchy of your Canvas is correct—the parenting of
    `Image-slot` as a child of `Image-slot-grid`, and the parenting of `Image-star-yellow`
    and `Image-star-grey` as children of each `Image-slot` is very important.![How
    to do it...](img/1362OT_02_26.jpg)
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中，复制`Image-slot`九次；它们应该自动命名为`Image-slot 1 .. 9`。查看以下截图以确保您的Canvas层次结构正确——`Image-slot`作为`Image-slot-grid`的子项，以及`Image-star-yellow`和`Image-star-grey`作为每个`Image-slot`的子项的父子关系非常重要。![如何操作...](img/1362OT_02_26.jpg)
- en: 'In the **Hierarchy** panel, ensure that `player-SpaceGirl` is selected, and
    add the C# script `Player` with the following code:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**面板中，确保选择`player-SpaceGirl`，并添加以下代码的C#脚本`Player`：
- en: '[PRE18]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the **Hierarchy** panel, ensure that `player-SpaceGirl` is selected, and
    add the C# script `PlayerInventoryModel` with the following code:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**面板中，确保选择`player-SpaceGirl`，并添加以下代码的C#脚本`PlayerInventoryModel`：
- en: '[PRE19]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the **Hierarchy** panel, ensure that `player-SpaceGirl` is selected, and
    add the C# script `PlayerInventoryDisplay` with the following code:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**面板中，确保选择`player-SpaceGirl`，并添加以下代码的C#脚本`PlayerInventoryDisplay`：
- en: '[PRE20]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With GameObject `player-SpaceGirl` selected in the **Hierarchy** panel, drag
    the ten `Image-slot` GameObjects into their corresponding locations in the **Player
    Inventory Display (Script)** component array **Slots**, in the **Inspector** panel,
    as shown in the following screenshot:![How to do it...](img/1362OT_02_28.jpg)
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**面板中选中GameObject `player-SpaceGirl`后，将十个`Image-slot` GameObjects拖动到**玩家库存显示（脚本）**组件数组**槽位**中，在**检查器**面板中，如图所示：![如何操作...](img/1362OT_02_28.jpg)
- en: Save the scene and play the game. As you pick up stars, you should see more
    of the grey stars change to yellow in the inventory display.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景并开始游戏。当你收集星星时，你应该会看到库存显示中更多的灰色星星变为黄色。
- en: How it works...
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We have created a simple panel (`Panel-background`) and text at the top of the
    game canvas—showing a greyish background rectangle and text "Inventory". We created
    a small panel inside this area (`Panel-slot-grid`), with a grid layout group component,
    which automatically sizes and lays out the 10 `Image-slot` GameObjects we created
    with the knob (circle) source image. By adding a mask component to `Panel-slot-grid`,
    we ensure that no content will overflow outside of the rectangle of the source
    image for this panel.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在游戏画布的顶部创建了一个简单的面板（`Panel-background`）和文本——“库存”。在这个区域内部（`Panel-slot-grid`）创建了一个小面板，其中包含一个网格布局组件，它会自动调整大小并排列我们使用旋钮（圆形）源图像创建的10个`Image-slot`
    GameObjects。通过向`Panel-slot-grid`添加一个遮罩组件，我们确保内容不会超出该面板源图像的矩形范围。
- en: Each of the 10 `Image-slot` GameObjects that are children of `Panel-slot-grid`
    contains a yellow star image and a grey star image. Also, each `Image-slot` GameObjects
    has a script component `PickupUI`. The `PickupUI` script offers three public methods,
    which will show just the yellow star image, just the grey star image, or neither
    (so, an empty knob circle image will be seen).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`Panel-slot-grid`的10个`Image-slot` GameObjects子项中每个都包含一个黄色星星图像和一个灰色星星图像。此外，每个`Image-slot`
    GameObjects都有一个脚本组件`PickupUI`。`PickupUI`脚本提供了三个公共方法，可以显示仅黄色星星图像、仅灰色星星图像或两者都不显示（因此，将看到一个空旋钮圆形图像）。'
- en: Our player's character GameObject `player-SpaceGirl` has a very simple basic
    `Player` script—this just detected collisions with objects tagged `Star`, and
    when this happens, it removes the star GameObject collided with and calls the
    `AddStar()` method to its `playerInventoryModel` scripted component. The `PlayerInventoryModel`
    C# script class maintains a running integer total of the number of stars added
    to the inventory. Each time the `AddStar()` method is called, it increments (adds
    1) to this total, and then calls the `OnChangeStarTotal(…)` method of scripted
    component `playerInventoryDisplay`. Also, when the scene starts, an initial call
    is made to the `OnChangeStarTotal(…)` method so that the UI display for the inventory
    is set up to show that we are initially carrying no stars.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们玩家的角色GameObject `player-SpaceGirl`有一个非常简单的`Player`脚本——这个脚本仅检测与标记为`Star`的对象的碰撞，当发生碰撞时，它会移除与之碰撞的星星GameObject，并调用其`playerInventoryModel`脚本组件的`AddStar()`方法。`PlayerInventoryModel`
    C#脚本类维护一个累计整数，记录添加到库存中的星星数量。每次调用`AddStar()`方法时，它会增加（加1）这个总数，然后调用脚本组件`playerInventoryDisplay`的`OnChangeStarTotal(…)`方法。此外，当场景开始时，会调用`OnChangeStarTotal(…)`方法，以便设置UI显示以显示我们最初没有携带任何星星。
- en: 'The C# script class `PlayerInventoryDisplay` has two properties: one is a constant
    integer defining the number of slots in our inventory, which for this game we
    set to 10, and the other variable is an array of references to `PickupUI` scripted
    components—each of these is a reference to the scripted component in each of the
    10 `Image-slot` GameObjects in our `Panel-slot-grid`. When the `OnChangeStarTotal(…)`
    method is passed the number of stars we are carrying, it loops through each of
    the 10 slots. While the current slot is less than our star total, a yellow star
    is displayed, by the calling of the `DisplayYellow()` method of the current slot
    (`PickupUI` scripted component). Once the loop counter is equal to or larger than
    our star total, then all remaining slots are made to display a grey star via the
    calling of method `DisplayGrey()`.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: C#脚本类`PlayerInventoryDisplay`有两个属性：一个是定义我们库存中槽位数量的常量整数，对于这个游戏，我们将其设置为10，另一个是变量是一个指向`PickupUI`脚本组件的引用数组——这些中的每一个都是指向我们`Panel-slot-grid`中的10个`Image-slot`
    GameObject中的脚本组件的引用。当`OnChangeStarTotal(…)`方法传递我们携带的星星数量时，它遍历这10个槽位。当当前槽位小于我们的星星总数时，通过调用当前槽位的`DisplayYellow()`方法（`PickupUI`脚本组件）显示一个黄色星星。一旦循环计数器等于或大于我们的星星总数，那么所有剩余的槽位都通过调用方法`DisplayGrey()`显示为灰色星星。
- en: This recipe is an example of the **low coupling** of the MVC design pattern.
    We have designed our code to not rely or make too many assumptions about other
    parts of the game so that the chances of a change in some other part of our game
    breaking our inventory display code are much smaller. The display (view) is separated
    from the logical representation of what we are carrying (model), and changes to
    the model are made by public methods called from the player (controller).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是MVC设计模式**低耦合**的一个例子。我们设计我们的代码不依赖于或对游戏的其它部分做出太多假设，这样其他部分游戏中的变化破坏我们的库存显示代码的可能性就小得多。显示（视图）与我们所携带的逻辑表示（模型）是分离的，对模型的更改是通过玩家（控制器）调用的公共方法来实现的。
- en: Note
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: It might seem that we could make our code simpler by assuming that slots
    are always displaying grey (no star) and just changing one slot to yellow each
    time a yellow star is picked up. But this would lead to problems if something
    happens in the game (for example, hitting a black hole or being shot by an alien)
    that makes us drop one or more stars. C# script class `PlayerInventoryDisplay`
    makes no assumptions about which slots may or may not have been displayed grey
    or yellow or empty previously—each time it is called, it ensures that an appropriate
    number of yellow stars are displayed, and all other slots are displayed with grey
    stars.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：看起来我们可能可以通过假设槽位总是显示灰色（没有星星）并且每次捡到黄色星星时只改变一个槽位为黄色来使我们的代码更简单。但如果游戏中发生某些情况（例如，撞到黑洞或被外星人射击）导致我们掉落一个或多个星星，这就会导致问题。C#脚本类`PlayerInventoryDisplay`对哪些槽位可能或可能没有以前显示为灰色、黄色或空没有做出任何假设——每次调用它时，它都会确保显示适当数量的黄色星星，并且所有其他槽位都显示为灰色星星。
- en: There's more...
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Some details you don''t want to miss:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 一些你不希望错过的细节：
- en: Add a horizontal scrollbar to the inventory slot display
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将水平滚动条添加到库存槽位显示中
- en: We can see 10 inventory slots now—but what if there are many more? One solution
    is to add a scroll bar so that the user can scroll left and right, viewing 10
    at a time, as shown in the following screenshot. Let's add a horizontal scroll
    bar to our game. This can be achieved without any C# code changes, all through
    the Unity 5 UI system.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到10个库存槽位——但如果有很多更多呢？一个解决方案是添加一个滚动条，这样用户就可以左右滚动，每次查看10个，如下面的截图所示。让我们在我们的游戏中添加一个水平滚动条。这可以通过不进行任何C#代码更改，完全通过Unity
    5 UI系统来实现。
- en: '![Add a horizontal scrollbar to the inventory slot display](img/1362OT_02_35.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![将水平滚动条添加到库存槽位显示](img/1362OT_02_35.jpg)'
- en: 'To implement a horizontal scrollbar for our inventory display, we need to do
    the following:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现库存显示的水平滚动条，我们需要做以下几步：
- en: Increase the height of `Panel-background` to 130 pixels.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Panel-background`的高度增加到130像素。
- en: In the **Inspector** panel, set the **Child Alignment** property of component
    **Grid Layout Group (Script)** of `Panel-slot-grid` to Upper Left. Then, move
    this panel to the right a little so that the 10 inventory icons are centered on
    screen.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中，将`Panel-slot-grid`组件的**Child Alignment**属性设置为**Upper Left**。然后，将此面板稍微向右移动，以便10个库存图标在屏幕上居中。
- en: In the **Hierarchy** panel, duplicate Image-slot 9 three more times so that
    there are now 13 inventory icons in `Panel-slot-grid`.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中，将Image-slot 9复制三次，现在`Panel-slot-grid`中有13个库存图标。
- en: In the **Scene** panel, drag the right-hand edge of panel `Panel-slot-grid`
    to make it wide enough so that all 13 inventory icons fit horizontally—of course
    the last three will be off screen, as shown in the following screenshot:![Add
    a horizontal scrollbar to the inventory slot display](img/1362OT_02_33.jpg)
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**场景**面板中，将`Panel-slot-grid`面板的右侧边缘拖动，使其足够宽，以便所有13个库存图标都能水平放置——当然，最后三个将超出屏幕，如图所示：![向库存槽位显示添加水平滚动条](img/1362OT_02_33.jpg)
- en: Add a UI **Panel** to the **Canvas** and name it `Panel-scroll-container`, and
    tint it red by setting the **Color** property of its **Image (Script)** component
    to red.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**画布**上添加一个UI **面板**，命名为`Panel-scroll-container`，并通过将其**图像（脚本）**组件的**颜色**属性设置为红色来着色。
- en: Size and position `Panel-scroll-container` so that it is just behind our `Panel-slot-grid`.
    So, you should now see a red rectangle behind the 10 inventory circle slots.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整`Panel-scroll-container`的大小和位置，使其刚好位于我们的`Panel-slot-grid`之后。因此，你现在应该看到10个库存圆圈槽位后面的红色矩形。
- en: In the **Hierarchy** panel, drag `Panel-slot-grid` so that it is now childed
    to `Panel-scroll-container`.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中，将`Panel-slot-grid`拖动，使其成为`Panel-scroll-container`的子项。
- en: Add a UI **Mask** to `Panel-scroll-container` so now you should only be able
    to see the 10 inventory icons that fit within the rectangle of this red-tinted
    panel.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`Panel-scroll-container`添加一个UI **遮罩**，现在你应该只能看到这个红色着色面板内的10个库存图标。
- en: Note
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: You may wish to temporarily set this mask component as inactive so that
    you can see and work on the unseen parts of `Panel-slot-grid` if required.'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：你可能希望暂时将此遮罩组件设置为非活动状态，以便在需要时可以看到并处理`Panel-slot-grid`的未显示部分。
- en: Add a UI **Scrollbar** to the **Canvas** and name it `Scrollbar-horizontal`.
    Move it to be just below the 10 inventory icons, and resize it to be the same
    width as the red-tinted `Panel-scroll-container`, as shown in the following screenshot:![Add
    a horizontal scrollbar to the inventory slot display](img/1362OT_02_32.jpg)
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**画布**上添加一个UI **滚动条**，命名为`Scrollbar-horizontal`。将其移动到10个库存图标下方，并调整大小以与着色为红色的`Panel-scroll-container`具有相同的宽度，如图所示：![向库存槽位显示添加水平滚动条](img/1362OT_02_32.jpg)
- en: Add a UI **Scroll Rect** component to `Panel-scroll-container`.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将UI **滚动矩形**组件添加到`Panel-scroll-container`。
- en: In the **Inspector** panel, drag `Scrolbar-horizontal` to the Horizontal Scrollbar
    property of the **Scroll Rect** component of `Panel-scroll-container`.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中，将`Scrolbar-horizontal`拖动到`Panel-scroll-container`组件的水平滚动条属性。
- en: In the **Inspector** panel, drag `Panel-slot-grid` to the Content property of
    the **Scroll Rect** component of `Panel-scroll-container`, as shown in the following
    screenshot:![Add a horizontal scrollbar to the inventory slot display](img/1362OT_02_34.jpg)
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中，将`Panel-slot-grid`拖动到`Panel-scroll-container`组件的内容属性，如图所示：![向库存槽位显示添加水平滚动条](img/1362OT_02_34.jpg)
- en: Now, ensure the **mask** component of `Panel-scroll-container` is set as active
    so that we don't see the overflow of `Panel-slot-grid` and uncheck this **mask**
    components option to **Show Mask Graphic** (so that we don't see the red rectangle
    any more).
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，确保`Panel-scroll-container`的**遮罩**组件设置为活动状态，这样我们就不会看到`Panel-slot-grid`的溢出部分，并取消选中此**遮罩**组件的**显示遮罩图形**选项（这样我们就不会再看到红色矩形）。
- en: You should now have a working scrollable inventory system. Note that the last
    three new icons will just be empty circles, since the inventory display script
    does not have references to, or attempt to make, any changes to these extra three
    slots; so the script code would need to be changed to reflect every additional
    slot we add to `Panel-slot-grid`.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该有一个可工作的可滚动库存系统。请注意，最后三个新图标将只是空圆圈，因为库存显示脚本没有对这些额外三个槽位进行引用或尝试进行更改；因此，需要更改脚本代码以反映我们添加到`Panel-slot-grid`的每个额外槽位。
- en: The automation of PlayerInventoryDisplay getting references to all the slots
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动化PlayerInventoryDisplay获取所有槽位的引用
- en: There was a lot of dragging slots from the **Hierarchy** panel into the array
    for the scripted component `PlayerInventoryDisplay`. This takes a bit of work
    (and mistakes might be made when dragging items in the wrong order or the same
    item twice). Also, if we change the number of slots, then we may have to do this
    all over again or try to remember to drag more slots if we increase the number,
    and so on. A better way of doing things is to make the first task of the script
    class `PlayerInventoryDisplay` when the scene begins to create each of these `Image-slot`
    GameObjects as a child of `Panel-slot-grid` and populate the array at the same
    time.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 从 **Hierarchy** 面板中将槽位拖动到脚本组件 `PlayerInventoryDisplay` 的数组中，这个过程需要一些工作（如果在错误顺序或重复拖动相同的项目时，可能会出错）。此外，如果我们更改槽位数量，我们可能需要重新做所有这些工作，或者如果我们增加数量，记得拖动更多槽位，等等。更好的方法是，在场景开始时，脚本类
    `PlayerInventoryDisplay` 的第一个任务是创建每个 `Image-slot` GameObject 作为 `Panel-slot-grid`
    的子对象，并同时在数组中填充。
- en: 'To implement the automated population of our scripted array of PickupUI objects
    for this recipe, we need to do the following:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现此配方中脚本数组 `PickupUI` 对象的自动化填充，我们需要执行以下操作：
- en: Create a new folder named `Prefabs`. In this folder, create a new empty prefab
    named `starUI`.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Prefabs` 的新文件夹。在这个文件夹中，创建一个名为 `starUI` 的新空预制件。
- en: From the **Hierarchy** panel**,** drag the GameObject `Image-slot` into your
    new empty prefab named `starUI`. This prefab should now turn blue, showing it
    is populated.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Hierarchy** 面板中，将 GameObject `Image-slot` 拖动到您新创建的空预制件 `starUI` 中。现在，这个预制件应该变成蓝色，表示它已被填充。
- en: In the **Hierarchy** panel**,** delete GameObject `Image-slot` and all its copies
    `Image-slot 1 – 9`.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Hierarchy** 面板中，删除 GameObject `Image-slot` 及其所有副本 `Image-slot 1 – 9`。
- en: 'Replace C# Script `PlayerInventoryDisplay` in GameObject `player-SpaceGirl`
    with the following code:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 GameObject `player-SpaceGirl` 中的 C# 脚本 `PlayerInventoryDisplay` 替换为以下代码：
- en: '[PRE21]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With GameObject `player-SpaceGirl` selected in the **Hierarchy** panel, drag
    the GameObject `Panel-slot-grid` into **Player Inventory Display (Script)** variable
    **Slot grid**, in the **Inspector** panel.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Hierarchy** 面板中选择 GameObject `player-SpaceGirl`，将 GameObject `Panel-slot-grid`
    拖动到 **Inspector** 面板中的 **Player Inventory Display (Script)** 变量的 **Slot grid**。
- en: With GameObject `player-SpaceGirl` selected in the **Hierarchy** panel, drag
    from the **Project** panel prefab `starUI` into **Player Inventory Display (Script)**
    variable **Star Slot Prefab**, in the **Inspector** panel, as shown in the following
    screenshot:![The automation of PlayerInventoryDisplay getting references to all
    the slots](img/1362OT_02_29.jpg)
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Hierarchy** 面板中选择 GameObject `player-SpaceGirl`，从 **Project** 面板的预制件 `starUI`
    拖动到 **Inspector** 面板中的 **Player Inventory Display (Script)** 变量的 **Star Slot Prefab**，如图所示：![PlayerInventoryDisplay
    获取所有槽位的自动化](img/1362OT_02_29.jpg)
- en: The public array has been made private and no longer needs to be populated through
    manual drag-and-drop. When you run the game, it will play just the same as before,
    with the population of the array of images in our inventory grid panel now automated.
    The `Awake()` method creates new instances of the prefab (as many as defined by
    constant `NUM_INVENTORY_SLOTS`) and immediately childed them to `Panel-slot-grid`.
    Since we have a grid layout group component, their placement is automatically
    neat and tidy in our panel.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 公共数组已被改为私有，不再需要通过手动拖放来填充。当你运行游戏时，它将和以前一样运行，现在我们的库存网格面板中的图像数组填充现在是自动化的。`Awake()`
    方法创建预制件的新实例（根据常量 `NUM_INVENTORY_SLOTS` 定义的数量），并立即将其作为子对象附加到 `Panel-slot-grid`。由于我们有一个网格布局组组件，它们在我们的面板中的放置将自动整齐有序。
- en: Tip
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Note: The scale property of the transform component of GameObjects is reset
    when a GameObject changes its parent (to maintain relative child size to parent
    size). So, it is a good idea to always reset the local scale of GameObjects to
    (1,1,1) immediately after they have been childed to another GameObject. We do
    this in the `for`-loop to `starSlotGO` immediately following the `SetParent(…)`
    statement.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当 GameObject 改变其父对象时，其变换组件的缩放属性会被重置（以保持相对子对象大小与父对象大小之间的比例）。因此，在 GameObject
    成为另一个 GameObject 的子对象后，立即将其局部缩放重置为 (1,1,1) 是一个好主意。我们在 `SetParent(…)` 语句之后的 `for`
    循环中这样做。
- en: Note that we use the `Awake() method` for creating the instances of the prefab
    in `PlayerInventoryDispay` so that we know this will be executed before the `Start()`
    method in `PlayerInventoryModel`—since no `Start()` method is executed until all
    `Awake()` methods for all GameObjects in the scene have been completed.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用`Awake()方法`在`PlayerInventoryDispay`中创建预制实例，这样我们就可以知道这将在`PlayerInventoryModel`中的`Start()`方法之前执行——因为只有在场景中所有GameObject的`Awake()`方法都完成后才会执行`Start()`方法——由于没有执行`Start()`方法。
- en: Automatically changing the grid cell size based on the number of slots in inventory
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 根据库存中的槽位数量自动更改网格单元格大小
- en: Consider a situation where we wish to change the number of slots. Another alternative
    to using scrollbars is to change the cell size in the **Grid Layout Group** component.
    We can automate this through code so that the cell size is changed to ensure that
    `NUM_INVENTORY_SLOTS` will fit along the width of our panel at the top of the
    canvas.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一种情况，我们希望更改槽位数量。另一种不使用滚动条的方法是更改**网格布局组**组件中的单元格大小。我们可以通过代码来自动化这个过程，以确保`NUM_INVENTORY_SLOTS`将适合画布顶部面板的宽度。
- en: 'To implement the automated resizing of the **Grid Layout Group** cell size
    for this recipe, we need to do the following:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现此菜谱中**网格布局组**单元格大小的自动调整，我们需要执行以下操作：
- en: 'Add the following method `Start()` to the C# Script `PlayerInventoryDisplay`
    in GameObject `player-SpaceGirl` with the following code:'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`player-SpaceGirl`的`PlayerInventoryDisplay`GameObject中的C#脚本`PlayerInventoryDisplay`中添加以下`Start()`方法：
- en: '[PRE22]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![Automatically changing the grid cell size based on the number of slots in
    inventory](img/1362OT_02_30.jpg)'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![根据库存中的槽位数量自动更改网格单元格大小](img/1362OT_02_30.jpg)'
- en: We write our code in the `Start()` method, rather than adding to code in the
    `Awake()` method, to ensure that the **RectTransform** of GameObject `Panel-slot-grid`
    has finished sizing (in this recipe, it stretches based on the width of the **Game**
    panel). While we can't know the sequence in which **Hierarchy** GameObjects are
    created when a scene begins, we can rely on the Unity behavior that every GameObject
    sends the `Awake()`message, and only after all corresponding `Awake()` methods
    have finished executing all objects, and then sends the `Start()` message. So,
    any code in the `Start()` method can safely assume that every GameObject has been
    initialized.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Start()`方法中编写代码，而不是在`Awake()`方法中添加代码，以确保GameObject `Panel-slot-grid`的**RectTransform**已经完成尺寸调整（在这个菜谱中，它根据**游戏**面板的宽度拉伸）。虽然我们无法知道场景开始时**层次结构**GameObject的创建顺序，但我们可以依赖Unity的行为，即每个GameObject都会发送`Awake()`消息，并且只有当所有相应的`Awake()`方法都执行完毕后，才会发送`Start()`消息。因此，`Start()`方法中的任何代码都可以安全地假设每个GameObject都已初始化。
- en: The above screenshot shows the value of `NUM_INVENTORY_SLOTS` having been changed
    to 15, and the cell size, having been corresponding, changed, so that all 15 now
    fit horizontally in our panel. Note that the spacing between cells is subtracted
    from the calculated available with divided by the number of slots (`xCellSize
    -= gridLayoutGroup.spacing.x`) since that spacing is needed between each item
    displayed as well.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示了`NUM_INVENTORY_SLOTS`的值已更改为15，并且单元格大小相应地更改，以便所有15个单元格现在都水平地适合我们的面板。请注意，单元格之间的间距从计算出的可用宽度中减去，因为每个显示的项目之间也需要这个间距（`xCellSize
    -= gridLayoutGroup.spacing.x`）。
- en: Add some help methods to the Rect Transform script class
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向Rect Transform脚本类添加一些帮助方法
- en: 'If we wish to further change, say, the `RectTransform` properties using code,
    we can add extension methods by creating a file containing special static methods
    and using the special "this" keyword. See the following code that adds `SetWidth(…)`,
    `SetHeight(…)`, and `SetSize(…)` methods to the `RectTransform` scripted component:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望进一步使用代码更改，例如`RectTransform`属性，我们可以通过创建包含特殊静态方法的文件并使用特殊的“this”关键字来添加扩展方法。以下代码向`RectTransform`脚本组件添加了`SetWidth(…)`,
    `SetHeight(…)`, 和 `SetSize(…)`方法：
- en: '[PRE23]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Unity C# allows us to add these extensions methods by declaring `static void`
    methods whose first argument is in the form this `<ClassName> <var>`. The method
    can then be called as a built-in method defined in the original class.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: Unity C#允许我们通过声明`static void`方法来添加这些扩展方法，其中第一个参数的形式为`this `<ClassName> <var>`。然后，该方法可以作为在原始类中定义的内置方法调用。
- en: All we would need to do is create a new C# script class file `RectTransformExtensions`
    in the folder **Scripts** in the **Project** panel, containing the above code.
    In fact, you can find a whole set of useful extra `RectTransform` methods (on
    which the above is an extract) created by OrbcreationBV, and it is available online
    at [http://www.orbcreation.com/orbcreation/page.orb?1099](http://www.orbcreation.com/orbcreation/page.orb?1099).
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的所有事情就是在**项目**面板中的**脚本**文件夹中创建一个新的C#脚本类文件`RectTransformExtensions`，包含上述代码。实际上，你可以找到由OrbcreationBV创建的整个有用的额外`RectTransform`方法集（上述代码只是其中的一部分），并且这些方法在网上[http://www.orbcreation.com/orbcreation/page.orb?1099](http://www.orbcreation.com/orbcreation/page.orb?1099)可用。
- en: Conclusion
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, we introduced recipes demonstrating a range of C# data representations
    for inventory items and a range of Unity UI interface components to display the
    status and contents of player inventories at run time.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了各种C#数据表示方法，用于表示库存物品，以及一系列Unity UI界面组件，用于在运行时显示玩家库存的状态和内容。
- en: 'Inventory UI needs good quality graphical assets for a high quality result.
    Some sources of assets that you might wish to explore include the following sites:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 库存用户界面需要高质量的图形资源以获得高质量的结果。以下是一些你可能希望探索的资源来源网站：
- en: 'The graphics for our SpaceGirl mini game are from the Space Cute art by Daniel
    Cook; he generously publishes lots of 2D art for game developers to use:'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们SpaceGirl迷你游戏的图形来自Daniel Cook的Space Cute艺术作品；他慷慨地发布了大量2D艺术作品，供游戏开发者使用：
- en: '[http://www.lostgarden.com/](http://www.lostgarden.com/)'
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.lostgarden.com/](http://www.lostgarden.com/)'
- en: '[http://www.lostgarden.com/search?q=planet+cute](http://www.lostgarden.com/search?q=planet+cute)'
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.lostgarden.com/search?q=planet+cute](http://www.lostgarden.com/search?q=planet+cute)'
- en: 'Sethbyrd—lots of fun 2D graphics:'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sethbyrd——许多有趣的2D图形：
- en: '[http://www.sethbyrd.com/](http://www.sethbyrd.com/)'
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.sethbyrd.com/](http://www.sethbyrd.com/)'
- en: 'Royalty-free art for 2D games:'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于2D游戏的免版税艺术作品：
- en: '[http://www.gameart2d.com/freebies.html](http://www.gameart2d.com/freebies.html)'
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.gameart2d.com/freebies.html](http://www.gameart2d.com/freebies.html)'
