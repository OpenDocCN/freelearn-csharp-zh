<html><head></head><body>
  <div id="_idContainer800" class="Basic-Text-Frame">
    <h1 class="chapterNumber">15</h1>
    <h1 id="_idParaDest-184" class="chapterTitle">User Interface Design</h1>
    <p class="normal">Everything that is shown on the screen and transmitted through the speakers of a computer is a form of communication. In previous chapters, we used 3D models to let the user know that they are in a base in the middle of the mountains, and we reinforced that idea with the appropriate sound and music. But for our game, we need to communicate other information, such as the amount of life the player has left and the current score, and sometimes, it is difficult to express these things using the in-game graphics (there are some successful cases that manage to do this, such as <em class="italic">Dead Space</em>, but let’s keep things simple).</p>
    <p class="normal">In order to transmit this information, we need to add another layer of graphics on top of our scene, which is usually <a id="_idIndexMarker973"/>called the <strong class="keyWord">User Interface</strong> (<strong class="keyWord">UI</strong>). This will contain different visual elements, such as text fields, bars, and buttons, to prepare the user to make an informed decision based on things such as fleeing to a safe place when their life is low.</p>
    <p class="normal">In this chapter, we will visit the following topics: </p>
    <ul>
      <li class="bulletList">Understanding the Canvas and RectTransform</li>
      <li class="bulletList">Canvas object types</li>
      <li class="bulletList">Creating a responsive UI</li>
    </ul>
    <p class="normal">By the end of this chapter, you will be able to use the Unity UI system to create interfaces capable of informing the user about the state of the game and allowing them to take action by pressing buttons. Let’s start by discussing the basic concepts of the Unity UI system—the Canvas and RectTransform.</p>
    <h1 id="_idParaDest-185" class="heading-1">Understanding the Canvas and RectTransform</h1>
    <p class="normal">We are only going to focus on the in-game UI to communicate different information to the player using the Unity GUI system (or uGUI). At the time of writing this book, a new GUI system <a id="_idIndexMarker974"/>called UI Toolkit has been released, but uGUI will still be here for a while, given UI Toolkit will be used mostly in new projects, and is still perfectly capable of handling all types of UI. We will explore UI Toolkit in the next chapter.</p>
    <p class="normal">If you are going to work with Unity UI, you first need to understand its two main concepts—the <strong class="keyWord">Canvas</strong> and <strong class="keyWord">RectTransform</strong>. The <strong class="keyWord">Canvas</strong> is the <a id="_idIndexMarker975"/>master object that will <a id="_idIndexMarker976"/>contain and render our UI, and <strong class="keyWord">RectTransform</strong> is the feature in charge of positioning and adapting each UI element on our screen.</p>
    <p class="normal">In this section, we will be:</p>
    <ul>
      <li class="bulletList">Creating a UI with the Canvas</li>
      <li class="bulletList">Positioning elements with RectTransform</li>
    </ul>
    <p class="normal">Let’s start by using the Canvas component to create our UI.</p>
    <h2 id="_idParaDest-186" class="heading-2">Creating a UI with the Canvas</h2>
    <p class="normal">In Unity UI, each image, text, and element you see in the UI is a GameObject with a set of proper <a id="_idIndexMarker977"/>components, but in order for them to work, they must be a child of a master GameObject with the Canvas component. This <a id="_idIndexMarker978"/>component is responsible for triggering the UI generation and drawing iterations over each child object. We can configure this component to specify exactly how that process works and adapt it to different possible requirements. </p>
    <p class="normal">To start, you can simply create a canvas with the <strong class="screenText">GameObject</strong> | <strong class="screenText">UI</strong> | <strong class="screenText">Canvas</strong> option. After doing that, you will see a rectangle in the scene, which represents the user screen, so you can put elements inside it and preview where they will be located relative to the user’s monitor.</p>
    <p class="normal">You are probably wondering two things here. First, “<em class="italic">Why is the rectangle in the middle of the scene? I want it to always be on the screen!</em>” Don’t worry because that will be exactly the case. When you edit the UI, you will see it as part of the level, as an object inside it, but when you play the game, it will be always projected over the screen, on top of every object. Also, you may be wondering why the rectangle is huge, and that’s because one pixel of the screen map corresponds to one meter on the scene when using the default <strong class="screenText">Canvas</strong> <strong class="screenText">Render Mode</strong>, the one called <strong class="screenText">Screen Space - Overlay</strong>. There are other modes, but discussing them is outside of the scope of this chapter. </p>
    <p class="normal">Again, don’t worry about that; you will see all your UI elements in their proper size and position on the user’s screen when you see the game in the <strong class="screenText">Game</strong> view. Consider setting the <strong class="screenText">Game</strong> view size prior <a id="_idIndexMarker979"/>to editing it in the <strong class="screenText">Scene</strong> view given <a id="_idIndexMarker980"/>that the <strong class="screenText">Scene</strong> view will follow the <strong class="screenText">Game</strong> view dimensions. You can do that by clicking the dropdown saying <strong class="screenText">Free Aspect</strong> at the top part of the <strong class="screenText">Game</strong> panel and selecting the desired resolution or aspect ratio, <strong class="screenText">16:9 Aspect</strong> being the most used option:</p>
    <figure class="mediaobject"><img src="../Images/B18585_15_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.1: A default image UI element—a white box</p>
    <p class="normal">Before adding elements to our UI, it’s worth noting that when you created the UI, a second object was created alongside the Canvas, called <strong class="screenText">EventSystem</strong>. This object is not necessary to render a UI but is necessary if you want the UI to be interactable, which means including actions such as clicking buttons, introducing text in fields, or navigating the UI with the joystick. The <strong class="screenText">EventSystem</strong> component is responsible for sampling the user input, such as with a keyboard, mouse, or joystick, and sending that data to the UI to react accordingly. We can change the exact buttons to interact with the UI, but the defaults are OK for now, so just know that you need this object if you want to interact with the UI. If for some reason you delete the object, you can recreate it again in <strong class="screenText">GameObject </strong>|<strong class="screenText"> UI </strong>|<strong class="screenText"> Event System</strong>.</p>
    <p class="normal">Now that we have the base objects to create our UI, let’s add elements to it.</p>
    <h2 id="_idParaDest-187" class="heading-2">Positioning elements with RectTransform</h2>
    <p class="normal">In Unity UI, each <a id="_idIndexMarker981"/>image, text, and element you see in the UI is a GameObject with a set of proper components according to its usage, but you will see that most of them have one component in common—<strong class="screenText">RectTransform</strong>. Each piece of the UI is essentially a rectangle filled with text or images and has different behavior, so it is important to understand how the <strong class="screenText">RectTransform</strong> component works and how to edit it.</p>
    <p class="normal">In order to experiment with this component, let’s create and edit the position of a simple <a id="_idIndexMarker982"/>white box element for the UI as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Go to <strong class="screenText">GameObject | UI | Image</strong>. After that, you will see that a new GameObject is created within the <strong class="screenText">Canvas</strong> element. Unity will take care of setting any new UI element as a child of the Canvas; outside it, the element will not be visible:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.2: A default image UI element—a white box</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Click on the 2D button in the top bar of the <strong class="screenText">Scene</strong> view. This will just change the perspective of the Scene view to one that is better suited to edit the UI (and also 2D games):</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.3: The 2D button location</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Double-click on the Canvas in the <strong class="screenText">Hierarchy</strong> window to make the UI fit entirely in the Scene view. This will allow us to edit the UI clearly. You can also navigate the UI using the mouse scroll wheel to zoom, and click and drag the scroll wheel to pan the camera.</li>
      <li class="numberedList">Enable the <strong class="screenText">RectTransform</strong> tool, which is the fifth button in the top-left part of the Unity Editor (or press the <em class="italic">T</em> key). This will enable the rectangle gizmo, which allows you to move, rotate, and scale 2D elements without the issues the regular 3D transform gizmos can cause:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.4: The rectangle gizmo button</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Using the <a id="_idIndexMarker983"/>rectangle gizmo, drag the object to move it, use the blue dots to change its size, or locate the mouse in a position near the blue dots until the cursor becomes a curved arrow to rotate it. Consider that resizing the object using this gizmo is not the same as scaling the object, but more on that in a moment:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.5: The rectangle gizmo for editing 2D elements</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">In the <strong class="screenText">Inspector</strong> window, notice that after changing the size of the UI element, the <strong class="screenText">Rect Transform</strong> setting’s <strong class="screenText">Scale</strong> property is still at <code class="inlineCode">1</code>, <code class="inlineCode">1</code>, <code class="inlineCode">1</code>, but you can see how the <strong class="screenText">Width</strong> and <strong class="screenText">Height</strong> properties changed. <strong class="screenText">RectTransform</strong> is essentially a classic transform but with <strong class="screenText">Width</strong> and <strong class="screenText">Height</strong> added (among other properties to explore later). You can set the exact values you want here expressed in pixels:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.6: The Rect Transform properties</p>
    <p class="normal">Now that <a id="_idIndexMarker984"/>we know the very basics of how to position any UI object, let’s explore the different types of elements you can add to the Canvas.</p>
    <h1 id="_idParaDest-188" class="heading-1">Canvas object types</h1>
    <p class="normal">So far, we have used the simplest Canvas object type—a white box—but there are plenty of <a id="_idIndexMarker985"/>other object types we can use, such as images, buttons, and text. All of them use <strong class="screenText">RectTransform</strong> to define their display area, but each one has its own concepts and configurations to understand.</p>
    <p class="normal">In this section, we will explore the following Canvas object concepts:</p>
    <ul>
      <li class="bulletList">Integrating assets for the UI</li>
      <li class="bulletList">Creating UI controls</li>
    </ul>
    <p class="normal">Let’s first start exploring how we can integrate images and fonts to use in our Canvas so that we can integrate them in our UI using the <strong class="screenText">Images</strong> and <strong class="screenText">Text</strong> UI object types.</p>
    <h2 id="_idParaDest-189" class="heading-2">Integrating assets for the UI</h2>
    <p class="normal">Before <a id="_idIndexMarker986"/>making our UI use nice graphics assets, we need to integrate them properly into Unity. In the following screenshot, you will find the UI design we propose for our game:</p>
    <figure class="mediaobject"><img src="../Images/B18585_15_07.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.7: UI design</p>
    <p class="normal">On top <a id="_idIndexMarker987"/>of that, we will add a <strong class="screenText">Pause</strong> menu, which will be activated when the user presses <em class="italic">Esc</em>. It will look like the following screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B18585_15_08.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.8: The Pause menu design</p>
    <p class="normal">Based on these designs, we can determine that we will need the following assets:</p>
    <ul>
      <li class="bulletList">The hero’s avatar image</li>
      <li class="bulletList">A health bar image</li>
      <li class="bulletList">A <strong class="screenText">Pause</strong> menu background image</li>
      <li class="bulletList">A <strong class="screenText">Pause</strong> menu button image</li>
      <li class="bulletList">Font for the text</li>
    </ul>
    <p class="normal">As always, we can find the required assets on the internet or in the Asset Store. In my case, I will use a mixture of both. Let’s start with the simplest one—the avatar. Take the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Download the avatar you want from the internet, like an image with a face of a character.</li>
      <li class="numberedList">Add it to your project, either by dragging it to the Project window or by using the <strong class="screenText">Assets | Import New Asset</strong> option. Add it to a <code class="inlineCode">Sprites</code> folder.</li>
      <li class="numberedList">Select the texture, and in the Inspector window, set the <strong class="screenText">Texture Type</strong> setting to <strong class="screenText">Sprite (2D and UI)</strong>. All textures are prepared to be used in 3D by default. This option prepares our texture to be used in 2D contexts, like the UI and also 2D games.</li>
    </ol>
    <p class="normal">For the <a id="_idIndexMarker988"/>bars, buttons, and the window background, I will use Asset Store to look for a UI pack. In my case, I found the package in the following screenshot a good one to start my UI. As usual, remember that this exact package might not be available right now. In that case, remember to look for another similar package, or pick the sprites from the GitHub repo:</p>
    <figure class="mediaobject"><img src="../Images/B18585_15_09.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.9: Selected UI pack</p>
    <p class="normal">At first, the package contains lots of images configured the same way, as sprites, but we can further modify the import settings to achieve advanced behavior, which we will need for the buttons. The button asset comes with a fixed size, but what happens if you need a bigger button? One option is to use other button assets with different sizes, but this will lead to a lot of repetitions of the buttons and other assets, such as different-sized backgrounds for different windows, which will unnecessarily consume RAM. </p>
    <p class="normal">Another option is to use the <strong class="screenText">9-slices </strong>method, which consists of splitting an image so that the corners are separated from the other parts. This allows Unity to stretch the middle parts of the image to fit different sizes, keeping the corners at their original size, which, when combined with an image prepared for the 9-slices technique, can be used to create almost any size you need.</p>
    <p class="normal">In <em class="italic">Figure 15.10</em>, you can see a shape with nine slices in the bottom-left corner, and at the bottom-right corner of the same diagram, you can see the shape is stretched but keeps its <a id="_idIndexMarker989"/>corners at their original size. The top-right corner shows the shape stretched without slices. You can see how the non-sliced version is distorted:</p>
    <figure class="mediaobject"><img src="../Images/B18585_15_10.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.10: Sliced versus non-sliced image stretching</p>
    <p class="normal">In this case, we can apply the nine slices to the button and the panel background images to use them in different parts of our game. In order to do this, do the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Open <strong class="screenText">Package Manager</strong> using the <strong class="screenText">Window | Package Manager</strong> option. </li>
      <li class="numberedList">Verify that <strong class="screenText">Package Manager</strong> is showing all the packages by setting the dropdown to the right of the <strong class="screenText">+</strong> button in the top-left part of the window to <strong class="screenText">Unity Registry</strong> as usual.</li>
      <li class="numberedList">Install the <strong class="screenText">2D Sprite</strong> package to enable the sprite editing tools (if it is not already installed).</li>
      <li class="numberedList">Select the button sprite in the <strong class="screenText">Project</strong> window and click on the <strong class="screenText">Sprite Editor</strong> button in the <strong class="screenText">Inspector</strong> window:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_11.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.11: The Sprite Editor button in the Inspector window</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">In the <strong class="screenText">Sprite Editor</strong> window, locate and drag the green dots at the edges of the image to move the slice rulers. Try to ensure that the slices are not located <a id="_idIndexMarker990"/>in the middle of the edges of the button. One thing to notice is that in our case, we will work with three slices instead of nine because our button won’t be stretched vertically. If you don’t see the dots, try clicking the image to make them appear.</li>
      <li class="numberedList">Notice that after dragging the green dots, the <strong class="screenText">Border</strong> properties (<strong class="screenText">L</strong>, <strong class="screenText">T</strong>, <strong class="screenText">R</strong>, and <strong class="screenText">B</strong>, which are left, top, right, and bottom, respectively) in the bottom-right corner changed. Those are the exact values you set by moving the green dots. Feel free to change them to more round numbers to allow the 9 slices to work evenly. In our case, Left and Right became a round 60, and top and bottom 50.</li>
      <li class="numberedList">Click on the <strong class="screenText">Apply</strong> button in the top-right corner of the window and close it:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_12.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.12: Nine slices in the Sprite Editor window</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">Repeat <em class="italic">steps 4</em> to <em class="italic">6</em> for the <strong class="screenText">Background</strong> panel image. In my case, you can see in <em class="italic">Figure 15.13</em> that this background is not completely prepared with nine slices in <a id="_idIndexMarker991"/>mind because all the middle areas of the image can be made smaller to save memory. </li>
    </ol>
    <p class="numberedList">When displaying this image with a smaller width, the 9-slicing method will stretch the middle part and will look the same, so essentially is wasted memory:</p>
    <figure class="mediaobject"><img src="../Images/B18585_15_13.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.13: Nine slices in the Sprite Editor window</p>
    <p class="normal">Now that we have prepared our sprites, we can find a font to customize the text of our UI. Before discussing how to import fonts, it is worth mentioning that we will be using <strong class="keyWord">TextMesh Pro</strong>, a Unity <a id="_idIndexMarker992"/>package (already included in the project) that provides a text rendering solution much better than the old text component. If you never used that component before, you shouldn’t worry about this detail.</p>
    <p class="normal">You must <a id="_idIndexMarker993"/>get fonts in the <code class="inlineCode">.ttf</code> or <code class="inlineCode">.otf</code> formats and import them to Unity. You can find lots of good, free font websites on the internet. I am used to working with the classic <a href="https://DaFont.com"><span class="url">DaFont.com</span></a> site, but there are plenty of other sites that you can use. In my case, I will work with the <code class="inlineCode">Militech</code> font:</p>
    <figure class="mediaobject"><img src="../Images/B18585_15_14.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.14: My chosen font from DaFont.com to use in the project</p>
    <p class="normal">If the font download comes with more than one file, you can just drag them all into Unity and then use the one that you like the most. Also, as usual, try to put the font inside a folder called <code class="inlineCode">Fonts</code>. Now, these files’ format is not compatible with TextMesh Pro, our text rendering solution, so we must convert it using the <strong class="screenText">Font Asset Creator</strong> window, as depicted in the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Go to <strong class="screenText">Window | Text Mesh Pro | Font Asset Creator</strong>.</li>
      <li class="numberedList">If this is the first time you have used Text Mesh Pro in your project, a window will appear. You must click the option <strong class="screenText">Import TMP Essentials</strong> and wait for the import process to finish: </li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_15.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.15: TextMesh Pro first run initialization</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Close the <strong class="screenText">TMP Importer </strong>window.</li>
      <li class="numberedList">In <strong class="screenText">Font Asset Creator</strong>, drag your font from the <strong class="screenText">Project</strong> view to the <strong class="screenText">Source Font File</strong>, or select it by clicking the <strong class="screenText">Target</strong> button at the right (the circle with the point at the center).</li>
      <li class="numberedList">Click the <strong class="screenText">Generate Font Atlas</strong> button and wait a moment:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_16.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.16: Converting font assets to TextMesh Pro</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Click <a id="_idIndexMarker994"/>the <strong class="screenText">Save</strong> button and save the converted font in the <strong class="screenText">TextMesh Pro | Resources | Fonts &amp; Materials</strong> folder. Saving here is important so don’t forget to pick the proper folder:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_17.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.17: Saving the converted font in the proper folder (Mac)</p>
    <p class="normal">Now that we have all the required assets to create our UI, let’s explore the different types of components to create all the required UI elements.</p>
    <h2 id="_idParaDest-190" class="heading-2">Creating UI controls</h2>
    <p class="normal">Almost every <a id="_idIndexMarker995"/>single part of the UI will be a combination of images and texts configured cleverly. In this section, we will explore how to create images, text, and buttons, starting with images. We have already an image in our UI—the white rectangle we created previously. If you select it and look at the <strong class="screenText">Inspector</strong> window, you will notice that it has an <strong class="screenText">Image</strong> component, like the one in the following screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B18585_15_18.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.18: The Image component’s Inspector window</p>
    <p class="normal">Let’s start exploring the settings of this component, starting with our hero’s avatar:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Using the rectangle gizmo, move the white rectangle to the top-left part of the UI:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_19.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.19: The white rectangle located at the top-left part of the UI</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">In the <strong class="screenText">Inspector</strong> window, click on the circle to the right of the <strong class="screenText">Source Image</strong> property and pick the downloaded hero avatar sprite:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_20.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.20: Setting the sprite of our Image component</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">We need to correct the aspect ratio of the image to prevent distortion. One way to <a id="_idIndexMarker996"/>do this is to click the <strong class="screenText">Set Native Size</strong> button at the bottom of the <strong class="screenText">Image</strong> component to make the image use the same size as the original sprite. However, by doing this, the image can become too big, so you can reduce the image size by pressing <em class="italic">Shift</em> to modify both the <strong class="screenText">Width</strong> and <strong class="screenText">Height</strong> values. Another option is to check the <strong class="screenText">Preserve Aspect</strong> checkbox to make sure the image fits the rectangle without stretching. In my case, I will use both:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_21.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.21: The Preserve Aspect and Set Native Size image options</p>
    <p class="normal">Now, let’s create the life bars by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create another <strong class="screenText">Image</strong> component using the <strong class="screenText">GameObject</strong> | <strong class="screenText">UI</strong> | <strong class="screenText">Image</strong> option.</li>
      <li class="numberedList">Set the <strong class="screenText">Source Image</strong> property to the life bar image you downloaded:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_22.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.22: The avatar and life bar</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Set the <strong class="screenText">Image Type</strong> property to <strong class="screenText">Filled</strong>.</li>
      <li class="numberedList">Set the <strong class="screenText">Fill Method</strong> property to <strong class="screenText">Horizontal</strong>.</li>
      <li class="numberedList">Drag the <strong class="screenText">Fill Amount</strong> slider to see how the bar is cut according to the value of the slider. We will change that value via scripting later in <em class="chapterRef">Chapter 18</em>, <em class="italic">Optimization with Profiler, Frame Debugger, and Memory Profiler</em>:<p class="packt_figref"><img src="../Images/B18585_15_23.png" alt=""/></p>
        <p class="packt_figref">Figure 15.23: The Fill Amount slider, cutting the image width by 73% of its size</p>
      </li>
      <li class="numberedList">In my <a id="_idIndexMarker997"/>case, the bar image also comes with a bar frame, creating another image, setting the sprite, and positioning it on top of the life bar to frame it. Bear in mind that the order the objects appear in the <strong class="screenText">Hierarchy</strong> window determines the order in which they will be drawn. So, in my case, I need to be sure the frame GameObject is below the health bar image. Also, consider the bar frame image is not sliced, so there’s no need to use the <strong class="screenText">Sliced</strong> <strong class="screenText">Image</strong> <strong class="screenText">Type</strong> in this case. Feel free to try slicing it and see the results:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_24.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.24: Putting one image on top of the other to create a frame effect</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">Repeat <em class="italic">steps 1</em> to <em class="italic">6</em> to create the base bar at the bottom, or just copy and paste the bar and the frame and locate it at the bottom of the screen:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_25.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.25: The Player’s and Player’s Base health bars</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">Click on the <strong class="screenText">+</strong> button in the <strong class="screenText">Project</strong> window and select the <strong class="screenText">Sprites</strong> | <strong class="screenText">Square</strong> option. This will create a simple squared sprite with a 4x4 resolution.</li>
      <li class="numberedList">Set the <a id="_idIndexMarker998"/>sprite as the base bar of the Player’s Base health bar instead of the downloaded bar sprite. This time, we will be using a plain-white image for the bar because in my case, the original one is red, and tinting the color of a red image to green is not possible. However, a white image can be easily tinted. Take into account the detail of the original bar—for example, the little shadow in my original bar won’t be present here.</li>
      <li class="numberedList">Select the base health bar and set the <strong class="screenText">Color</strong> property to green:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_26.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.26: A bar with a squared sprite and green tint</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="11">One optional step would be to convert the bar frame image into a nine-slices image to allow us to change the original width to fit the screen.</li>
    </ol>
    <p class="normal">Now, let’s add the text fields for the <strong class="screenText">Score</strong>, <strong class="screenText">Bullets</strong>, <strong class="screenText">Remaining Waves</strong>, and <strong class="screenText">Remaining Enemies</strong> labels by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a text label using the <strong class="screenText">GameObject</strong> | <strong class="screenText">UI</strong> | <strong class="screenText">Text - Text Mesh Pro</strong> option (avoid the one that only says <strong class="screenText">Text</strong>). This will be the <strong class="screenText">Score</strong> label.</li>
      <li class="numberedList">Position the label at the top-right part of the screen.</li>
      <li class="numberedList">In the <strong class="screenText">Inspector</strong> window, set the <strong class="screenText">Text Input</strong> property to <code class="inlineCode">Score: 0</code>.</li>
      <li class="numberedList">Set the <strong class="screenText">Font Size</strong> property to <code class="inlineCode">20</code>.</li>
      <li class="numberedList">Apply <a id="_idIndexMarker999"/>the converted font by clicking on the circle to the right of the <strong class="screenText">Font Asset</strong> property and selecting the desired font.</li>
      <li class="numberedList">In the <strong class="screenText">Alignment</strong> property, select the <strong class="screenText">Horizontal Right Align</strong> icon (third button from the first row) and the <strong class="screenText">Vertical Center Align</strong> icon (second button from the second row):</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_27.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.27: The settings for a text label</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">Repeat <em class="italic">steps 1</em> to <em class="italic">6 </em>to create the other three labels (or just copy and paste the score three times). For the <strong class="screenText">Remaining Waves</strong> label, you can use the left alignment option to better match the original design:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_28.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.28: All the labels for our UI</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">Set the color of all the labels to white as our scene will be mainly dark.</li>
    </ol>
    <p class="normal">Now that <a id="_idIndexMarker1000"/>we have completed the original UI design, we can create the <strong class="screenText">Pause</strong> menu: </p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create an <strong class="screenText">Image</strong> component for the menu’s background (<strong class="screenText">GameObject</strong> | <strong class="screenText">UI</strong> | <strong class="screenText">Image</strong>).</li>
      <li class="numberedList">Set the <strong class="screenText">Background</strong> panel sprite with the nine slices we made earlier.</li>
      <li class="numberedList">Set the <strong class="screenText">Image Type</strong> property to <strong class="screenText">Sliced</strong> if it is not already. This mode will apply the 9-slice scaling method to prevent the corners from stretching.</li>
      <li class="numberedList">There’s a chance that the image will stretch the corners anyway, which happens because sometimes the corners are quite big compared to the <strong class="screenText">RectTransform</strong> setting’s <strong class="screenText">Size</strong> property that you are using, so Unity has no option other than to do that. In this scenario, the correct solution is to have an artist that creates assets tailored to your game, but sometimes we don’t have that option. This time, we can just increase the <strong class="screenText">Pixels Per Unit</strong> value of the sprite file, which will reduce the scale of the original image while preserving its resolution. In the following two screenshots, you can see the background image with a <strong class="screenText">Pixels Per Unit</strong> value of <code class="inlineCode">100</code> and again with <code class="inlineCode">700</code>. Remember to only do this for the nine-slices or tiled-image types, or if you don’t have an artist to adjust it for you:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_29.png" alt=""/> </figure>
    <p class="packt_figref">Figure 15.29: On top, a large nine-slices image in a small RectTransform component, small enough to shrink the corners, and on the bottom, the same image with Pixels Per Unit set to 700</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Create a <strong class="screenText">TextMesh Pro</strong> text field, position it where you want the <strong class="screenText">Pause</strong> label to be <a id="_idIndexMarker1001"/>in your diagram, set it to display the <strong class="screenText">Pause</strong> text, and set the font. Remember that you can change the text color with the <strong class="screenText">Color</strong> property.</li>
      <li class="numberedList">Drag the text field onto the background image. The parenting system in <strong class="screenText">Canvas</strong> works the same—if you move the parent, the children will move with it. The idea is that if we disable the panel, it will also disable the buttons and all its content:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_30.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.30: The Pause label</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">Create two buttons by going to <strong class="screenText">GameObject</strong> | <strong class="screenText">UI</strong> | <strong class="screenText">Button - Text Mesh Pro</strong> (avoid using the one that only says <strong class="screenText">Button</strong>). Position them where you want them on the background image.</li>
      <li class="numberedList">Set them as children of the <strong class="screenText">Pause</strong> background image by dragging them in the <strong class="screenText">Hierarchy</strong> window.</li>
      <li class="numberedList">Select <a id="_idIndexMarker1002"/>the buttons and set the <strong class="screenText">Source Image</strong> property of their <strong class="screenText">Image</strong> components to use the button sprite that we downloaded earlier. Remember our <strong class="screenText">Pixels Per Unit</strong> fix from <em class="italic">step 4</em> in this list if you have the same problem as before.</li>
      <li class="numberedList">You will notice that the button is essentially an image with a child <strong class="screenText">TextMesh Pro</strong> text object. Change the font of each button and the text in each button to <code class="inlineCode">Resume</code> and <code class="inlineCode">Quit</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_31.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.31: The Pause menu implementation</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="11">Remember that you can hide the panel by unchecking the checkbox to the right of the name of the object in the top part of the <strong class="screenText">Inspector</strong> window:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_32.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.32: Disabling a GameObject</p>
    <p class="normal">In this <a id="_idIndexMarker1003"/>section, we discussed how to import images and fonts to be integrated through the <strong class="screenText">Image</strong>, <strong class="screenText">Text</strong>, and <strong class="screenText">Button</strong> components to create a rich and informative UI. Having done that, let’s discuss how to make them adapt to different devices.</p>
    <h1 id="_idParaDest-191" class="heading-1">Creating a responsive UI</h1>
    <p class="normal">Nowadays, it is almost impossible to design a UI in a single resolution, and our target audience <a id="_idIndexMarker1004"/>display devices can vary a lot. A PC has a variety of different kinds of monitors with different resolutions (such as 1080p and 4k) and aspect ratios (such as 16:9, 16:10, and ultra-wide), and the same goes for mobile devices. We need to prepare our UI to adapt to the most common displays, and Unity UI has the tools needed to do so.</p>
    <p class="normal">In this section, we will explore the following UI responsiveness concepts:</p>
    <ul>
      <li class="bulletList">Adapting object positions</li>
      <li class="bulletList">Adapting object sizes</li>
    </ul>
    <p class="normal">We are going to explore how the UI elements can adapt their position and size to different screen sizes using advanced features of the <strong class="screenText">Canvas</strong> and <strong class="screenText">RectTransform</strong> components, such as <strong class="screenText">Anchors</strong> and <strong class="screenText">Scalers</strong>.</p>
    <h2 id="_idParaDest-192" class="heading-2">Adapting object positions</h2>
    <p class="normal">Right now, if we play our game, we will see how the UI fits nicely onto our screen. But if for some <a id="_idIndexMarker1005"/>reason we change the <strong class="screenText">Game</strong> view size, we will see how objects start to disappear from the screen. In the following screenshots, you can see different-sized game windows and how the UI looks nice in one but bad in the others:</p>
    <figure class="mediaobject"> <img src="../Images/B18585_15_33.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.33: The same UI but on different screen sizes</p>
    <p class="normal">The problem is that we created the UI using whatever resolution we had in the editor, but as soon as we change it slightly, the UI keeps its design for the previous resolution. Also, if you look closely, you will notice that the UI is always centered, such as in the second image, where the UI is cropped at its sides, or in the third image, where extra space is visible along the borders of the screen. This happens because every single element in the UI has its own <strong class="keyWord">Anchor</strong>, a little cross you can see when you select an object, such as the one in the following screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B18585_15_34.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.34: An Anchor cross in the bottom-right part of the screen belonging to the hero avatar in the top-left part of the screen</p>
    <p class="normal">The <em class="italic">x</em> and <em class="italic">y</em> position of the object is measured as a distance to that Anchor, and the Anchor has <a id="_idIndexMarker1006"/>a position relative to the screen, with its default position being at the center of the screen. This means that on an <em class="italic">800 x 600</em> screen, the Anchor will be placed at the <em class="italic">400 x 300</em> position, and on a <em class="italic">1920 x 1080</em> screen, the Anchor will be located at the <em class="italic">960 x 540</em> position. If the <em class="italic">x</em> and <em class="italic">y</em> position of the element (the one in <strong class="screenText">RectTransform</strong>) is <strong class="screenText">0</strong>, the object will always be at a distance of 0 from the center. In the middle screenshot of the previous three examples, the hero avatar falls outside of the screen because its distance from the center is greater than half the screen, and the current distance was calculated based on the previous bigger screen size. So, what we can do about that? Move the Anchor!</p>
    <p class="normal">By setting a relative position, we can position the Anchor at different parts of our screen and make that part of the screen our reference position. In the case of our hero avatar, we can place the Anchor in the top-left corner of the screen to guarantee that our avatar will be at a fixed distance from that corner. </p>
    <p class="normal">We can do that by following these steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Select your player avatar.</li>
      <li class="numberedList">Expand the <strong class="screenText">RectTranform</strong> component in the <strong class="screenText">Inspector</strong>, if not expanded yet, in a way that you can see its properties. This will reveal the <strong class="screenText">Anchors</strong> in the <strong class="screenText">Scene</strong> view.</li>
      <li class="numberedList">Drag the Anchor cross with your mouse to the top-left part of the screen. If for some reason the Anchor breaks into pieces when you drag it, undo the change (press <em class="italic">Ctrl</em> + <em class="italic">Z</em>, or <em class="italic">Command</em> + <em class="italic">Z</em> on Mac) and try to drag it by clicking in the center. We will break the Anchor later. Check the avatar image <strong class="screenText">RectTransform</strong> component to verify that the <strong class="screenText">Anchors</strong> property <strong class="screenText">Min</strong> and <strong class="screenText">Max</strong> sub-properties have the same values as in <em class="italic">Figure 15.35</em>, meaning the object has correctly configured the Anchors to be in the top-left part of the screen:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_35.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.35: An image with an Anchor in the top-left part of the screen</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Put the <a id="_idIndexMarker1007"/>Anchor of the <strong class="screenText">Health Bar</strong> object and its frame in the same position. We want the bar to always be at the same distance from that corner so that it will move alongside the hero avatar if the screen size changes.</li>
      <li class="numberedList">Place the Anchor in the bottom-center part of the screen for the <strong class="screenText">Boss Bar</strong> object so that it will always be centered. Later, we will deal with adjusting its size.</li>
      <li class="numberedList">Put the <strong class="screenText">Remaining Waves</strong> label in the bottom-left corner, and <strong class="screenText">Remaining Enemies</strong> in the bottom-right corner:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_36.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.36: The Anchors for the life bar and the labels</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">Put the <strong class="screenText">Score</strong> and <strong class="screenText">Bullets</strong> Anchors in the top-right corner:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_37.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.37: The Anchors for the Score and Bullets labels</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">Select any <a id="_idIndexMarker1008"/>element and drag the sides of the Canvas rectangle with your mouse to preview how the elements will adapt to their positions. Take into account that you must select any object that is a direct child of the Canvas; the text within the buttons won’t have that option:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_38.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.38: Previewing the Canvas resizing</p>
    <p class="normal">Now that our UI elements have adapted to their positions, let’s consider scenarios where the object size must adapt as well. </p>
    <h2 id="_idParaDest-193" class="heading-2">Adapting object sizes</h2>
    <p class="normal">The first <a id="_idIndexMarker1009"/>thing to consider when dealing with different aspect ratios is that our screen elements may not only move from their original design position (which we fixed in the previous section) but also, they may not fit into the original design. In our UI, we have the case of the health bar, where the bar clearly doesn’t adapt to the screen width when we previewed it on a wider screen. We can fix this by breaking our Anchors.</p>
    <p class="normal">When we break our Anchors, the position and size of our object are calculated as a distance relative to the different Anchor parts. If we split the Anchor horizontally, instead of having an <strong class="screenText">X</strong> and <strong class="screenText">Width</strong> property, we will have a <strong class="screenText">Left</strong> and <strong class="screenText">Right</strong> property, representing the distance to the left and right Anchor. We can use this in the following way:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Select the <a id="_idIndexMarker1010"/>health bar and drag the left part of the Anchor all the way to the left part of the screen, and the right part to the right part of the screen.</li>
      <li class="numberedList">Do the same for the health bar frame:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_39.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.39: The splitter Anchor in the health bar </p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Check the <strong class="screenText">Rect Transform</strong> setting’s <strong class="screenText">Left</strong> and <strong class="screenText">Right</strong> properties in the <strong class="screenText">Inspector</strong> window, which represent the current distance to their respective Anchors. If you want, you can add a specific value, especially if your health bars are displaying outside the screen:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_40.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.40: The Left and Right properties of a split anchor</p>
    <p class="normal">This way, the object will always be at a fixed distance of a relative position to the screen—in this case, the sides of the screen. If you are working with a child object, as is the case with the <strong class="screenText">Text</strong> and <strong class="screenText">Image</strong> components of the buttons, the Anchors are relative to the parent. If you pay attention to the Anchors of the text, they are not only split horizontally but also vertically. This allows the text to adapt its position to the size of the button, so you won’t have to change it manually:</p>
    <figure class="mediaobject"><img src="../Images/B18585_15_41.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.41: The split Anchors of the text of the button</p>
    <p class="normal">Now, this solution is not suitable for all scenarios. Let’s consider a case where the hero avatar is displayed in higher resolution than what it was designed for. Even if the avatar is correctly placed, it will be displayed smaller because the screen has more pixels per inch than screens with lower resolutions and the same physical size. You consider using split Anchors, but the width and height Anchors could be scaled differently in different aspect ratio screens, so the original image becomes distorted. Instead, we can use the <strong class="screenText">Canvas Scaler</strong> component.</p>
    <p class="normal">The <strong class="screenText">Canvas Scaler</strong> component <a id="_idIndexMarker1011"/>defines what one pixel means in our scenario. If our UI design resolution is 1080p, but we see it in a 4k display (which is twice the resolution of 1080p), we can scale the UI so that a pixel becomes 2, adapting its <a id="_idIndexMarker1012"/>size to keep the same proportional size as the original design. Basically, the idea is that if the screen is bigger, our elements should also be bigger.</p>
    <p class="normal">We can use this component by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Select the <strong class="screenText">Canvas</strong> object and locate the <strong class="screenText">Canvas Scaler</strong> component in the <strong class="screenText">Inspector</strong> window.</li>
      <li class="numberedList">Set the <strong class="screenText">UI Scale Mode</strong> property to <strong class="screenText">Scale with Screen Size</strong>.</li>
      <li class="numberedList">If working with an artist, set the reference resolution to the resolution in which the artist created the UI, keeping in mind that it must be the highest target device resolution (this isn’t the case for us). In our case, we are not sure which resolution the artist of the downloaded assets had in mind, so we can put <em class="italic">1920 x 1080</em>, which is the full HD resolution size and is very common nowadays.</li>
      <li class="numberedList">Set the <strong class="screenText">Match</strong> property to <strong class="screenText">Height</strong>. The idea of this property is that it sets which side of the resolution will be considered when carrying out the scaling calculation. In our case, if we are playing the game in 1080p resolution, 1 UI pixel equals 1 real screen pixel. However, if we are playing in 720p resolution, 1 UI pixel will be 0.6 real pixels, so the elements will be smaller on smaller resolution screens, keeping the correct size. We didn’t choose a <strong class="screenText">Width</strong> value in this case because we can have extreme widths in screens, such as ultra-wide, and if we picked that option, those screens would scale the UI unnecessarily. Another option is to set this value to <code class="inlineCode">0.5</code> to consider the two values, but on a PC, this doesn’t make too much sense. On a mobile device, you should choose this based on the orientation of the game, setting the height for landscape mode and the width for portrait mode. </li>
      <li class="numberedList">Try previewing a wider and higher screen and see how this setting works:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_42.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.42: Canvas Scaler with the correct settings for standard PC games</p>
    <p class="normal">You will find <a id="_idIndexMarker1013"/>that your UI will be smaller than your original design, which is because we should have set these properties before. Right now, the only fix is to resize everything again. Take this into account the next time you try this exercise; we only followed this order for learning purposes.</p>
    <p class="normal">With this knowledge, you are now ready to start scripting the UI to reflect what’s happening in the game.</p>
    <h1 id="_idParaDest-194" class="heading-1">Scripting the UI</h1>
    <p class="normal">We previously created a UI layout with elements such as bars, text, and buttons, but so far, they are static. We <a id="_idIndexMarker1014"/>need to make them adapt to the game’s actual state. In this section, we are going to discuss the following UI scripting concepts:</p>
    <ul>
      <li class="bulletList">Showing information in the UI</li>
      <li class="bulletList">Programming the Pause menu</li>
    </ul>
    <p class="normal">We will start by seeing how to display information on our UI using scripts that modify the text and images that are displayed with Canvas elements. After that, we will create the<strong class="screenText"> Pause</strong> functionality, which will be used throughout the UI.</p>
    <h2 id="_idParaDest-195" class="heading-2">Showing information in the UI</h2>
    <p class="normal">As discussed earlier, we will <a id="_idIndexMarker1015"/>use the UI to display information to the user to allow them to make informed decisions, so let’s start by seeing how we can make the player’s health bar react to the amount of life they have left in the <code class="inlineCode">Life</code> script we created earlier:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Add a new script called <strong class="screenText">Life Bar</strong> to the <strong class="screenText">HealthBar</strong> Canvas child object, which is the UI <code class="inlineCode">Image</code> component we created earlier to represent the life bar:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_43.png" alt=""/></figure>
    <figure class="mediaobject">Figure 15.43: The Life Bar component in the player’s HealthBar Canvas</figure>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">In the <code class="inlineCode">LifeBar</code>, the script adds a <code class="inlineCode">Life</code> type field. This way, our script will ask the editor which <code class="inlineCode">Life</code> component we will be monitoring. Save the script:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_44.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.44: Editor-configurable reference to a Life component</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">In the <a id="_idIndexMarker1016"/>editor, drag the <code class="inlineCode">Player</code> GameObject from the <strong class="screenText">Hierarchy</strong> window to the <code class="inlineCode">targetLife</code> property to make the life bar reference the player’s life, and remember to have the <code class="inlineCode">HealthBar</code> object selected before dragging <strong class="screenText">Player</strong>. This way, we are telling our <strong class="screenText">LifeBar</strong> script which Life component to check to see how much life the player has remaining. Something interesting here is that the enemies have the same Life component, so we can easily use this component to create life bars for every other object that has a life in our game:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_45.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.45: Dragging Player to reference its Life component</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Add the <code class="inlineCode">using UnityEngine.UI;</code> line right after the <code class="inlineCode">using</code> statements in the first few lines of the script. This will tell C# that we will be interacting with the UI scripts:<p class="packt_figref"><img src="../Images/B18585_15_46.png" alt=""/></p>
        <p class="packt_figref">Figure 15.46: All the using statements in our script. We are not going to use them all but let’s keep them for now</p>
      </li>
      <li class="numberedList">Create a <code class="inlineCode">private</code> field (without the <code class="inlineCode">public</code> keyword) of the <code class="inlineCode">Image</code> type. We will save <a id="_idIndexMarker1017"/>the reference to the component here in a moment:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_47.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.47: Private reference to an image</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Using <code class="inlineCode">GetComponent</code> in <code class="inlineCode">Awake</code>, access the reference to the <code class="inlineCode">Image</code> component in our GameObject (<code class="inlineCode">HealthBar</code>) and save it in the <code class="inlineCode">image</code> field. As usual, the idea is to get this reference just once and save it for later use in the <code class="inlineCode">Update</code> function. Of course, this will always work when you put this component in an object with an <code class="inlineCode">Image</code> component. If not, the other option would be to create a public field of the <code class="inlineCode">Image</code> type and drag the image component into it:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_48.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.48: Saving the reference to the Image component in this object</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">Create an <code class="inlineCode">Update</code> event function in the <code class="inlineCode">LifeBar</code> script. We will use this to constantly update the life bar according to the player’s life. </li>
      <li class="numberedList">In the <code class="inlineCode">Update</code> event, divide the amount of life by <code class="inlineCode">100</code> to have our current life percentage expressed in the <code class="inlineCode">0</code> to <code class="inlineCode">1</code> range (assuming our maximum life is <code class="inlineCode">100</code>), and set the result in the <code class="inlineCode">fillAmount</code> field of the <code class="inlineCode">Image</code> component as in the following <a id="_idIndexMarker1018"/>screenshot. Remember that <code class="inlineCode">fillAmount</code> expects a value between <code class="inlineCode">0</code> and <code class="inlineCode">1</code>, with <code class="inlineCode">0</code> signaling that the bar is empty and <code class="inlineCode">1</code> signaling that the bar is at its full capacity:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_49.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.49: Updating the fill amount of the LifeBar script’s Image component according to the Life component</p>
    <div class="note">
      <p class="normal">Remember that putting <code class="inlineCode">100</code> within the code is considered hardcoding (it is also known as a <strong class="keyWord">magic number</strong>), meaning later changes on that value would require us to look through the code for that value, which is a complicated task in big projects. That’s why it is considered bad practice. It would be better to have a <strong class="screenText">Maximum Life</strong> field in the <strong class="screenText">Life</strong> component or at least have a constant with this value.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="9">Save the script and in the editor, select the player and play the game. During <strong class="screenText">Play</strong> mode, press <em class="italic">Esc</em> to regain access to the mouse and change the player’s health in the Inspector window to see how the life bar updates accordingly. You can also test this by making the player receive damage somehow, such as by making enemies spawn bullets (more on enemies later):</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_50.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.50: Full LifeBar script</p>
    <div class="note">
      <p class="normal">In the previous chapter, we explored the concept of events to detect changes in the state of other objects. The life bar is another example of using an event as we can change the fill amount of the image when the life actually changes. I challenge you to try to create an event when the life changes and implement this script using the one we looked at in the previous chapter.</p>
    </div>
    <p class="normal">You may be <a id="_idIndexMarker1019"/>thinking that this UI behavior could be directly coded within the <code class="inlineCode">Life</code> component, and that’s completely possible, but the idea here is to create simple scripts with little pressure to keep our code separated. Each script should have just one reason to be modified, and mixing UI behavior and gameplay behavior in a single script would give the script two responsibilities, which results in two possible reasons to change our script. With this approach, we can also set the player’s base life bar at the bottom by just adding the same script to its life bar but dragging the <strong class="screenText">Base Damage </strong>object, which we created in the previous chapter, as the target life this time.</p>
    <p class="normal">Regarding the Visual Scripting version, here is what you need to add to your health bar image GameObject:</p>
    <figure class="mediaobject"><img src="../Images/B18585_15_51.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.51: Full LifeBar Visual Graph</p>
    <p class="normal">First, we added a <code class="inlineCode">targetLife</code> variable of type <code class="inlineCode">GameObject</code> to the <strong class="screenText">Variables</strong> component of our life <a id="_idIndexMarker1020"/>bar image. Then we dragged our <strong class="screenText">Player</strong> GameObject (called <strong class="screenText">Robot</strong> so far) to this variable, in a way the life bar now has a reference to the object from which we want to display its life. Then we added a <strong class="screenText">LifeBar</strong> visual graph; in the <strong class="screenText">Update</strong> node, it calls the <strong class="screenText">Set Fill Amount </strong>node in order to update the fill amount of the <strong class="screenText">Image</strong>. Remember that in this case, just calling the <strong class="screenText">Set Fill Amount</strong> node will understand we are referring to the image component where this visual graph is located, so no need to use <strong class="screenText">GetComponent</strong> here. In order to calculate the fill amount, we get the <strong class="screenText">targetLife</strong> GameObject reference, and, using a second <strong class="screenText">Get Variable</strong> node, we extract the life variable of that object. Finally, we divide that by 100 (we needed to create a <strong class="screenText">Float Literal</strong> node in order to represent the value <strong class="screenText">100</strong>) and pass that to the<strong class="screenText"> Set Fill Amount</strong> node. As usual, you can check the complete version on the GitHub repository.</p>
    <div class="note">
      <p class="normal">The single object responsibility principle we just mentioned is one of the five object-oriented programming principles known as <strong class="keyWord">SOLID</strong>. If you don’t know what SOLID is, I strongly recommend you search for <code class="inlineCode">SOLID programming principles</code> on the internet to improve your programming best practices.</p>
    </div>
    <p class="normal">Now that we <a id="_idIndexMarker1021"/>have sorted out the player’s life bar, let’s make the <code class="inlineCode">Bullets</code> label update according to the player’s remaining bullets. Something to consider here is that our current <code class="inlineCode">PlayerShooting</code> script has unlimited bullets, so let’s change that by following these steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Add a public <code class="inlineCode">int</code> type field to the <code class="inlineCode">PlayerShooting</code> script called <code class="inlineCode">bulletsAmount</code>.</li>
      <li class="numberedList">In the <code class="inlineCode">if</code> statement that checks the pressure of the left mouse button, add a condition to check whether the number of bullets is greater than <code class="inlineCode">0</code>.</li>
      <li class="numberedList">Inside the <code class="inlineCode">if</code> statement, reduce the number of bullets by <code class="inlineCode">1</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_52.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.52: Limiting the number of bullets to shoot</p>
    <p class="normal">In the Visual Scripting version, the modified shooting condition of the <strong class="screenText">PlayerShooting</strong> visual graph will look like this:</p>
    <figure class="mediaobject"><img src="../Images/B18585_15_53.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.53: Shooting only if bullets are available and reducing the number of bullets after shooting</p>
    <p class="normal">As you can see, we simply <a id="_idIndexMarker1022"/>check if the new <strong class="screenText">bullets</strong> variable we added is greater than zero and then use an <strong class="screenText">If</strong> node condition for the execution of the <strong class="screenText">Instantiate</strong> node. Regarding the bullets decrement, it will look like this:</p>
    <figure class="mediaobject"><img src="../Images/B18585_15_54.png" alt="Graphical user interface, text, application, chat or text message  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.54: Decrementing bullet count in the Visual Graph</p>
    <p class="normal">We simply <a id="_idIndexMarker1023"/>subtract one from the bullets variable and set bullets again with this value.</p>
    <p class="normal">Now that we have a field indicating the number of remaining bullets, we can create a script to display that number in the UI by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Add a <code class="inlineCode">PlayerBulletsUI</code> script to the bullet’s <code class="inlineCode">Text</code> GameObject. In my case, I called it <code class="inlineCode">Bullets Label</code>.</li>
      <li class="numberedList">Add the <code class="inlineCode">using TMPro;</code> statement at the beginning of the file, given that we will modify the <code class="inlineCode">Text Mesh Pro</code> component of our label.</li>
      <li class="numberedList">Add a private field of the <code class="inlineCode">TMP_Text</code> type, saving it in the reference to our own <code class="inlineCode">Text</code> component in <code class="inlineCode">Awake</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_55.png" alt="Graphical user interface, text, application, email  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.55: Caching the reference to our own Text component</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Create a <code class="inlineCode">public</code> field of the <code class="inlineCode">PlayerShooting</code> type called <code class="inlineCode">targetShooting</code> and drag <code class="inlineCode">Player</code> to this property in the Editor. As was the case for the <code class="inlineCode">LifeBar</code> component, the idea is that our UI script will access the script that has the <a id="_idIndexMarker1024"/>remaining bullets to update the text, bridging the two scripts (<code class="inlineCode">Text</code> and <code class="inlineCode">PlayerShooting</code>) to keep their responsibilities separated.</li>
      <li class="numberedList">Create an <code class="inlineCode">Update</code> statement and inside it, set the <code class="inlineCode">text</code> field of the text reference (I know, confusing) with a concatenation of <code class="inlineCode">"Bullets: "</code> and the <code class="inlineCode">bulletsAmount</code> field of the <code class="inlineCode">targetShooting</code> reference. This way, we will replace the text of the label according to the current amount of bullets:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_56.png" alt="A picture containing chart  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.56: Updating the bullet’s text label</p>
    <div class="note">
      <p class="normal">Remember that concatenating strings allocates memory, so again, I recommend you to only do this when necessary, using events. Also consider having two separated labels, one for the <code class="inlineCode">"Bullets: "</code> part, and another for just the number of bullets, so you can only change the number label and avoid concatenation and UI text regeneration costs.</p>
    </div>
    <p class="normal">Regarding Visual Scripting, before actually setting the text, we need to add support for TextMeshPro in Visual Scripting. Visual Scripting requires manually specifying which Unity systems <a id="_idIndexMarker1025"/>and packages we are going to use, and as TextMeshPro is not strictly a core Unity feature, so it might not be included by default. We can add support for TextMeshPro in Visual Scripting by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Go to <strong class="screenText">Edit | Project Settings</strong> and select the <strong class="screenText">Visual Scripting</strong> category.</li>
      <li class="numberedList">Expand the <strong class="screenText">Node Library </strong>option using the arrow to its left.</li>
      <li class="numberedList">Check if you have <strong class="screenText">Unity.TextMeshPro</strong> in that list. If you do, feel free to skip these steps.</li>
      <li class="numberedList">Use the <strong class="screenText">+</strong> button at the bottom of the list to add a new library.</li>
      <li class="numberedList">Click where it says <strong class="screenText">(No Assembly)</strong> and search for <strong class="screenText">Unity.TextMeshPro</strong>.</li>
      <li class="numberedList">Click the <strong class="screenText">Regenerate Nodes</strong> button and wait until the regeneration process is done:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_57.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.57: Adding TextMeshPro support to Visual Scripting</p>
    <p class="normal">After setting that, this is what the visual graph to add to the <strong class="screenText">Bullets</strong> text GameObject will look like:</p>
    <figure class="mediaobject"><img src="../Images/B18585_15_58.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.58: Updating the Bullets’ text label in Visual Scripting</p>
    <p class="normal">As usual, we need <a id="_idIndexMarker1026"/>a reference to the <strong class="screenText">Player</strong> to check its bullets, so we created a <code class="inlineCode">targetBullets</code> variable of type <strong class="screenText">GameObject</strong> and dragged the player there. Then we use a <strong class="screenText">Get Variable</strong> node to extract the bullets amount from that reference and concatenate the string <code class="inlineCode">"Bullets: "</code>, using the <strong class="screenText">String Literal</strong> node, with the amount of bullets using the <strong class="screenText">Concat</strong> node. That node will do the same as when we added two strings together using the <strong class="screenText">+</strong> operator in C#. Finally, we use the <strong class="screenText">Set Text (Source Text, Sync Text InputBox)</strong> node to update the text of our text field.</p>
    <p class="normal">If you look at the two scripts, you will find a pattern. You can access the <code class="inlineCode">UI</code> and <code class="inlineCode">Gameplay</code> components and update the <strong class="screenText">UI </strong>component accordingly, and most UI scripts will behave in the same way. Keeping this in mind, I challenge you to create the necessary scripts to make the <strong class="screenText">Score</strong>, <strong class="screenText">Enemies</strong>, and <strong class="screenText">Waves</strong> counters work. Remember to add <code class="inlineCode">using TMPro;</code> to use the <code class="inlineCode">TMP_Text</code> component. After finishing this, you can compare your solution with the one in the following screenshot, starting with <code class="inlineCode">ScoreUI</code>:</p>
    <figure class="mediaobject"><img src="../Images/B18585_15_59.png" alt="Graphical user interface, text, application  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.59: The ScoreUI script</p>
    <p class="normal">Also, we <a id="_idIndexMarker1027"/>need the <code class="inlineCode">WavesUI</code> component:</p>
    <figure class="mediaobject"><img src="../Images/B18585_15_60.png" alt="Graphical user interface, text, application, email  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.60: The WavesUI script</p>
    <p class="normal">Finally, we <a id="_idIndexMarker1028"/>need <code class="inlineCode">EnemiesUI</code>:</p>
    <figure class="mediaobject"><img src="../Images/B18585_15_61.png" alt="Graphical user interface, text, application, email  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.61: The EnemiesUI script</p>
    <p class="normal">Notice how <a id="_idIndexMarker1029"/>we took advantage of the existence of the <strong class="screenText">onChanged</strong> events in the <strong class="screenText">WavesManager</strong> and <strong class="screenText">EnemyManager</strong> scripts to only update the text fields when needed. Observe how we didn’t need to drag a reference to get the values to display, as all these scripts use managers to get that info.</p>
    <p class="normal">Regarding Visual Scripting, we have the <strong class="screenText">ScoreUI </strong>script:</p>
    <figure class="mediaobject"><img src="../Images/B18585_15_62.png" alt="Graphical user interface, text, application, chat or text message  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.62: The ScoreUI visual script</p>
    <p class="normal">Then <a id="_idIndexMarker1030"/>the <strong class="screenText">WavesUI</strong> script:</p>
    <figure class="mediaobject"><img src="../Images/B18585_15_63.png" alt="Graphical user interface, application  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.63: The Waves UI visual script</p>
    <p class="normal">And finally, the <strong class="screenText">EnemiesUI</strong> script:</p>
    <figure class="mediaobject"><img src="../Images/B18585_15_64.png" alt="Graphical user interface, application  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.64: The Enemies UI visual script</p>
    <p class="normal">As you can see, we have <a id="_idIndexMarker1031"/>used the events already coded in the managers to change the UI only when necessary. Also, observe how we used <strong class="screenText">Scene</strong> variables to get the info to display. Now that we have coded the UI labels and bars, let’s code the <code class="inlineCode">Pause</code> menu.</p>
    <h2 id="_idParaDest-196" class="heading-2">Programming the Pause menu</h2>
    <p class="normal">Recall how <a id="_idIndexMarker1032"/>we created a <strong class="screenText">Pause</strong> menu in a previous section. It is currently disabled, so let’s make it work. First, we need to code the <strong class="screenText">Pause</strong> feature, which can be quite complicated. So again, we will use a simple approach for pausing most behaviors, which is stopping the time! Remember that most of our movement scripts use <a id="_idIndexMarker1033"/>time functionality, such as <strong class="keyWord">Delta Time</strong> (the one we discussed in <em class="chapterRef">Chapter 2</em>, <em class="italic">Editing Scenes and Game Objects</em>), as a way to calculate the amount of movement to apply. There is also a way to simulate time going slower or faster, which is by setting <code class="inlineCode">timeScale</code>. This field will affect Unity’s time system’s speed, and we can set it to <code class="inlineCode">0</code> to simulate that time has stopped, which will pause animations, stop particles, and reduce <strong class="screenText">Delta Time </strong>to <code class="inlineCode">0</code>, making our movements stop. So, let’s do it:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a script called <code class="inlineCode">Pause</code> and add it to a new GameObject called <code class="inlineCode">Pause</code>.</li>
      <li class="numberedList">Add the <code class="inlineCode">using UnityEngine.InputSystem;</code> statement at the beginning of the script file to be able to read input.</li>
      <li class="numberedList">In <code class="inlineCode">Update</code>, detect when the <em class="italic">Esc</em> key is pressed. We can add a mapping to our <strong class="screenText">Player Input</strong> asset file and read the input as we did in <em class="chapterRef">Chapter 2</em>, <em class="italic">Editing Scenes and Game Objects</em>, but to learn a new way of using the input system, we will use the <code class="inlineCode">Keyboard.current</code> variable to read directly the state of a key in the <strong class="screenText">Update</strong> method instead of using mapping. Consider that it is always recommended to use input mapping, but let’s do this for learning purposes. You <a id="_idIndexMarker1034"/>can set the <code class="inlineCode">Time.timeScale</code> variable to <code class="inlineCode">0</code> when the <em class="italic">Esc</em> key is pressed, as you can see in the following image:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_65.png" alt="Graphical user interface, text, application, email  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.65: Stopping time to simulate a pause</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Save and test this by playing the game and pressing the <em class="italic">Esc</em> key. You will notice that almost everything will stop, but you can see how the shoot functionality still works. That’s because the <code class="inlineCode">PlayerShooting</code> script is not time-dependent. One solution here could be to simply check whether <code class="inlineCode">Time.timeScale</code> is greater than <code class="inlineCode">0</code> to prevent this:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_66.png" alt="Graphical user interface, text, application  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.66: Checking Pause in the player shooting script</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">The same needs to be done in our <code class="inlineCode">EnemyFSM</code> Shoot method, changing it for this:</li>
    </ol>
    <div class="note">
      <p class="normal">As usual, we have pursued the simplest way here, but there is a better approach. I challenge you to try to create <code class="inlineCode">PauseManager</code> with a Boolean indicating whether the game is paused or not, changing <code class="inlineCode">timeScale</code> in the process.</p>
    </div>
    <p class="normal">Now that <a id="_idIndexMarker1035"/>we have a simple but effective way to pause the game, let’s make the <strong class="screenText">Pause</strong> menu visible to resume the game by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Add a field of the <code class="inlineCode">GameObject</code> type called <code class="inlineCode">pauseMenu</code> in the <code class="inlineCode">Pause</code> script. The idea is to drag the <strong class="screenText">Pause</strong> menu here so that we have a reference to enable and disable it </li>
      <li class="numberedList">In <code class="inlineCode">Awake</code>, add <code class="inlineCode">pauseMenu.SetActive(false);</code> to disable the <strong class="screenText">Pause</strong> menu at the beginning of the game. Even if we disabled the <strong class="screenText">Pause</strong> menu in the editor, we add this just in case we re-enable it by mistake. It must always start disabled.</li>
      <li class="numberedList">Using the same function but passing <code class="inlineCode">true</code> as the first parameter, enable the <strong class="screenText">Pause</strong> menu in the <em class="italic">Esc</em> key pressure check:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_67.png" alt="Graphical user interface, text, application, chat or text message  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.67: Enabling the Pause menu when pressing the Esc key</p>
    <p class="normal">Now, we need to make the <strong class="screenText">Pause</strong> menu buttons work. If you recall, we explored the concept of events, implementing them with <code class="inlineCode">UnityEvents</code> in the different <code class="inlineCode">Managers</code>. Our <strong class="screenText">Pause</strong> menu buttons <a id="_idIndexMarker1036"/>use the same class to implement the <code class="inlineCode">onClick</code> event, which is an event that informs us that a specific button has been pressed. Let’s resume the game when pressing those buttons by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a field of the <code class="inlineCode">Button</code> type in our <code class="inlineCode">Pause</code> script called <code class="inlineCode">resumeButton</code>, and drag <code class="inlineCode">resumeButton</code> to it; this way, our <code class="inlineCode">Pause</code> script has a reference to the button.</li>
      <li class="numberedList">In <code class="inlineCode">Awake</code>, add a listener function called <code class="inlineCode">OnResumePressed</code> to the <code class="inlineCode">onClick</code> event of <code class="inlineCode">resumeButton</code>.</li>
      <li class="numberedList">Make the <code class="inlineCode">OnResumePressed</code> function set <code class="inlineCode">timeScale</code> to <code class="inlineCode">1</code> and disable the <strong class="screenText">Pause</strong> menu, as we did in <code class="inlineCode">Awake</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_68.png" alt="Graphical user interface, text, application, chat or text message  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.68: Unpausing the game</p>
    <p class="normal">If you save <a id="_idIndexMarker1037"/>and test this, you will notice that you cannot click the <strong class="screenText">Resume</strong> button because we disabled the cursor at the beginning of the game, so make sure you re-enable it while in <code class="inlineCode">Pause</code> and disable it when you resume:</p>
    <figure class="mediaobject"><img src="../Images/B18585_15_69.png" alt="Graphical user interface, text, application  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.69: Showing and hiding the cursor while in Pause</p>
    <p class="normal">One final <a id="_idIndexMarker1038"/>thing to consider is that we want to set the time scale to <code class="inlineCode">1</code> again on the <strong class="screenText">OnDestroy</strong> method. This method gets executed when the <strong class="screenText">Pause</strong> object is destroyed, which will happen when we manually destroy the object via scripting, or most importantly in this case, if we change scenes. The idea is to make sure to resume the time system if we change scenes while being in the <strong class="screenText">Pause</strong> menu, so the next scene can play the game properly:</p>
    <figure class="mediaobject"><img src="../Images/B18585_15_70.png" alt="Graphical user interface  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 15.70: Resetting the time scale when leaving the scene</p>
    <p class="normal">Regarding the Visual Scripting version of the <strong class="screenText">Pause</strong> script, consider that we don’t have an equivalent to <code class="inlineCode">Keyboard.current</code>, so we will need to do it using the input mappings. In order to add an input mapping for the <em class="italic">Esc</em> key, do the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Double-click the <strong class="screenText">Player Input</strong> asset to edit it. You can find it by selecting the <strong class="screenText">Player</strong> GameObject, and clicking the box at the right of the <strong class="screenText">Actions</strong> property of the <code class="inlineCode">PlayerInput</code> component in the Inspector.</li>
      <li class="numberedList">Using the <strong class="screenText">+</strong> button in the top-right corner of the <strong class="screenText">Actions</strong> list (the middle list), create a new <strong class="screenText">Action</strong> called <code class="inlineCode">Pause</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_71.png" alt="Graphical user interface, application, table  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.71: Creating a new input mapping</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Click the <code class="inlineCode">&lt;No Binding&gt; </code>item inside the <strong class="screenText">Pause</strong> action we just created (below it).</li>
      <li class="numberedList">In the <strong class="screenText">Path</strong> property in the <strong class="screenText">Binding Properties</strong> section (at the right side of the screen), click the <a id="_idIndexMarker1039"/>empty rectangle at its left, and search and select the <strong class="screenText">Escape [Keyboard]</strong> button:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_15_72.png" alt="Graphical user interface, application  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.72: Adding a key to the mapping</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Click the <strong class="screenText">Save Asset</strong> button in the top-middle part of the screen.</li>
    </ol>
    <p class="normal">Now, you can add the following graph, this time to the <strong class="screenText">Player</strong> GameObject, as we need to read input from it:</p>
    <figure class="mediaobject"><img src="../Images/B18585_15_73.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.73: Pausing when Esc is pressed</p>
    <p class="normal">So far <a id="_idIndexMarker1040"/>nothing new; we detect that <em class="italic">Esc</em> is pressed and, in such a moment, we call <strong class="screenText">Set Time Scale</strong> and specify the <code class="inlineCode">0</code> value. Then we activate the <strong class="screenText">Pause</strong> menu (having a reference through a variable <code class="inlineCode">pauseMenu</code> in the <strong class="screenText">Variables</strong> component), and we enable the cursor. Finally, we set the time scale to <code class="inlineCode">1</code> when the object is destroyed.</p>
    <p class="normal">Regarding the <strong class="screenText">Resume</strong> behavior, the nodes to add to the same <strong class="screenText">Pause</strong> graph will look like this:</p>
    <figure class="mediaobject"><img src="../Images/B18585_15_74.png" alt="Graphical user interface, text, application  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.74: Unpausing when the Resume button is pressed</p>
    <p class="normal">The only new element <a id="_idIndexMarker1041"/>on this graph is the usage of the <strong class="screenText">On Button Click</strong> node. As you might expect, that node is an event, and anything connected to it will execute under the pressure of a button. The way to specify which button we are referring to is through connecting the <strong class="screenText">Button</strong> reference variable to the input pin of <strong class="screenText">On Button Click</strong>. You can see how we created a variable of type <strong class="screenText">Button</strong> called <code class="inlineCode">resumeButton</code> in the <strong class="screenText">Variables</strong> component to do this.</p>
    <p class="normal">Now that you know how to code buttons, I challenge you to code the <code class="inlineCode">Exit</code> button’s behavior. Again, remember to add <code class="inlineCode">using UnityEngine.UI</code>. Also, you will need to call <code class="inlineCode">Application.Quit();</code> to exit the game but take into account that this will do nothing in the editor; we don’t want to close the editor while creating the game. This function only works when you build the game. </p>
    <p class="normal">So, for now, just call it, and if you want to print a message to be sure that the button is working properly, you can; a solution is provided in the following screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B18585_15_75.png" alt="Graphical user interface, text, application, chat or text message  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.75: The Quit button script</p>
    <p class="normal">This solution <a id="_idIndexMarker1042"/>proposes that you add this script directly to the <strong class="screenText">Quit</strong> button GameObject itself so that the script listens to the <code class="inlineCode">onClick</code> event on its <code class="inlineCode">Button</code> sibling component, and in that case, executes the <code class="inlineCode">Quit</code> function. You could also add this behavior to the <code class="inlineCode">Pause</code> script, and while that will work, remember that if a script can be split into two because it does two unrelated tasks, it is always best to split it so that separate behavior is unrelated. Here, the <strong class="screenText">Pause</strong> behavior is not related to the <strong class="screenText">Quit</strong> behavior.</p>
    <p class="normal">Regarding the Visual Scripting version, the graph to add to the <strong class="screenText">Quit</strong> button would look like this:</p>
    <figure class="mediaobject"><img src="../Images/B18585_15_76.png" alt="Graphical user interface, application  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.76: The Quit button visual script</p>
    <p class="normal">Simple, right? As we <a id="_idIndexMarker1043"/>put this in the <code class="inlineCode">Button</code> itself, we don’t even need to specify which button, as it automatically detects that we are referring to ourselves.</p>
    <p class="normal">Now that we have our <strong class="screenText">Pause</strong> system set up using the UI and buttons, let’s continue looking at other visual and auditive ways to make our player aware of what has happened.</p>
    <h1 id="_idParaDest-197" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we introduced the basics of UI, understanding the <strong class="screenText">Canvas</strong> and <strong class="screenText">RectTransform </strong>components to locate objects onscreen and create a UI layout. We also covered different kinds of UI elements, mainly <strong class="screenText">Image</strong> and <strong class="screenText">Text</strong>, to give life to our UI layout and make it appealing to the user. Finally, we discussed how to adapt UI objects to different resolutions and aspect ratios to make our UI adapt to different screen sizes, even though we cannot predict the exact monitor our user will be playing the game on. All of this allows us to create any UI we will need in our game using the Canvas.</p>
    <p class="normal">In the next chapter, we will explore how to create UIs using UI Toolkit instead, another Unity system to create UIs, and compare both the Canvas and UI Toolkit to see where to use which.</p>
    <h1 class="heading-1">Join us on Discord!</h1>
    <p class="normal">Read this book alongside other users, Unity game development experts, and the author himself. </p>
    <p class="normal">Ask questions, provide solutions to other readers, chat with the author via Ask Me Anything sessions, and much more. </p>
    <p class="normal">Scan the QR code or visit the link to join the community.</p>
    <p class="normal"><img src="../Images/Nicolas_QR_Code.png" alt=""/></p>
    <p class="normal"><a href="Chapter_15.xhtml"><span class="url">https://packt.link/handsonunity22</span></a></p>
  </div>
</body></html>