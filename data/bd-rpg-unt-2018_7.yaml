- en: User Interface and System Feedback
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户界面和系统反馈
- en: Have you ever seen the top of an iceberg? Well, so far, that's what we have
    done throughout the previous six chapters. In this chapter, we will keep on improving
    on our game's user interface and feedback system. We will create a heads-up display
    that will be responsible for managing the user interaction with the system menus,
    as well as the system giving feedback to the player.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否见过冰山顶部？到目前为止，这就是我们在前六章中所做的一切。在本章中，我们将继续改进我们游戏的用户界面和反馈系统。我们将创建一个负责管理玩家与系统菜单交互以及系统向玩家提供反馈的抬头显示（HUD）。
- en: 'In this chapter, we will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Designing a heads-up display
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计抬头显示（HUD）
- en: HUD basics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HUD基础
- en: Our design
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的设计
- en: HUD framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HUD框架
- en: Completing our HUD design
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成我们的HUD设计
- en: Character info panel
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色信息面板
- en: Active items panel
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动物品面板
- en: Special items panel
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊物品面板
- en: Integrating the code
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成代码
- en: Enemy stats in the HUD
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HUD中的敌人统计数据
- en: NPC stats user interface
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPC统计数据用户界面
- en: Creating the NPC canvas
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建NPC画布
- en: NPC taking a hit
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPC受到攻击
- en: Enhancing the code
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化代码
- en: Let's get started!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Designing a heads-up display
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计抬头显示（HUD）
- en: Designing a **Heads-Up Display** (**HUD**) is a very challenging task. The HUD
    is the interface through which your players can interact with the virtual world
    and receive feedback from the virtual world environment. As with everything else
    we have designed so far, the HUD design is also heavily related to the type and
    the needs of the game you are trying to make.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 设计**抬头显示（HUD**）是一个非常具有挑战性的任务。HUD是玩家与虚拟世界交互并从虚拟世界环境接收反馈的界面。与迄今为止我们设计的所有其他内容一样，HUD设计也与您试图制作的游戏的类型和需求密切相关。
- en: For instance, a **Real-Time Strategy** (**RTS**) game will have a very different
    type of HUD design to a **First-Person Shooter** (**FPS**) or a **Role-Playing
    Game** (**RPG**). They will have some things in common, but their individual design
    is very distinctive, as well as some of the features and functionality.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，**实时策略（RTS**）游戏将具有与**第一人称射击（FPS**）或**角色扮演游戏（RPG**）非常不同的HUD设计。它们有一些共同点，但它们的设计非常独特，以及一些功能和特性。
- en: We could have a whole book just about the design and development of user interfaces
    and how to approach them in a scientific manner. But that is outside the scope
    of this book, and we are concerned with the theories.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有一整本书专门讲述用户界面设计和开发，以及如何以科学的方式处理它们。但这超出了本书的范围，我们关注的是理论。
- en: HUD basics
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HUD基础
- en: 'Any simple heads-up display will have, at a minimum, a way to display the following
    information:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 任何简单的抬头显示至少应有一种显示以下信息的方式：
- en: Basic information about the player character
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家角色的基本信息
- en: Health
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命值
- en: Mana
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 魔法值
- en: Strength
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 力量
- en: Level
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等级
- en: Current inventory items consumed by the player character
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家角色当前消耗的库存物品
- en: Current weapon used by the player
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家当前使用的武器
- en: Current armor used by the player
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家当前使用的盔甲
- en: Available potions and/or health
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的药水及/或生命值
- en: Feedback from the game environment
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自游戏环境的反馈
- en: Anything useful pertaining to the game
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与游戏相关的任何有用信息
- en: Power ups
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能力提升
- en: Level ups
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等级提升
- en: Let's go ahead and design our HUD. Once again, we will start with a simple framework
    and slowly build on top of it as and when we need to.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始设计我们的HUD。再次强调，我们将从一个简单的框架开始，并在需要时逐步构建。
- en: Our design
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的设计
- en: Taking everything into consideration, let's go ahead and design a HUD that will
    be useful for our game. At the same time, we will keep it simple but useful. We
    should have a HUD that will display the basic player character information in
    a manner that does not block the gameplay, but at the same time gives critical
    information to the player regarding their character's state.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有因素，让我们继续设计一个对我们游戏有用的HUD。同时，我们将保持其简单但实用。我们应该有一个HUD，它将以不干扰游戏玩法的方式显示基本玩家角色信息，同时向玩家提供有关其角色状态的临界信息。
- en: We should also design a way to display the current inventory items the player
    has activated to be used, such as the weapon or the armor. Finally, we should
    also have a simple way for the player to use any health packets and/or potions
    they might have during gameplay.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该设计一种方式来显示玩家当前激活并准备使用的当前库存物品，例如武器或盔甲。最后，我们还应该有一个简单的方法让玩家在游戏过程中使用他们可能拥有的任何健康包和/或药水。
- en: 'The following figure shows a quick sketch of how I want my HUD to look. Again,
    you are free, and in fact, I encourage you, to come up with your own design:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了我想我的HUD看起来是什么样的快速草图。再次提醒，你可以自由发挥，事实上，我鼓励你提出自己的设计：
- en: '![](img/00145.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00145.jpeg)'
- en: I have clearly marked roughly how I would like my HUD to look during gameplay.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经清楚地标出了我希望在游戏过程中我的HUD（抬头显示）看起来大致如何。
- en: Notice that I have kept it simple. In the top-left corner, I have placed the
    immediate information that the player will need to have, such as their health
    and perhaps their strength.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我保持了它的简单性。在左上角，我放置了玩家将需要立即了解的信息，例如他们的健康和可能的力量。
- en: In the bottom-left corner, I have placed a scroll-able panel that will list
    all of the active inventory items that the player may have active on their player
    character, and on the right-hand side of the screen I have three slots that will
    be used for immediate access to things such as health packets and/or potions that
    the player might need to use during their gameplay.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕左下角，我放置了一个可滚动的面板，将列出玩家可能在其角色上激活的所有活动库存物品，而在屏幕的右侧，我有三个槽位，将用于立即访问玩家在游戏过程中可能需要使用的物品，如健康包和/或药水。
- en: HUD framework
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HUD框架
- en: Now that we have an understanding of how we want our UI to look, let's start
    implementing it in Unity. We need to create a new canvas to hold our HUD. To create
    the canvas, right-click in the Hierarchy window and select UI | Canvas. Rename
    the new canvas GameObject  `CanvasHUD`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了我们希望我们的UI（用户界面）看起来是什么样子，让我们开始在Unity中实现它。我们需要创建一个新的画布来容纳我们的HUD。要创建画布，在层次结构窗口中右键单击，选择UI
    | 画布。将新画布GameObject重命名为`CanvasHUD`。
- en: Let's go ahead and put into place all of the different sections for our UI.
    We will need three main panels for each section, as indicated in the following
    screenshot.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续放置我们UI的所有不同部分。每个部分我们需要三个主要面板，如下面的截图所示。
- en: We need a panel to hold the character information in the top-left corner of
    the screen. We will also need a panel to hold the active inventory items in the
    bottom-left corner of the screen, and another panel to hold the special items
    on the right-hand side of the screen.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个面板来在屏幕左上角存放角色信息。我们还需要一个面板来在屏幕左下角存放活动库存物品，以及另一个面板来在屏幕右侧存放特殊物品。
- en: 'Create each panel by right-clicking the Hierarchy window and selecting UI |
    Panel. Make sure the panels are a child of the `CanvasHUD` GameObject. Rename
    each panel accordingly. I have named mine: `PanelCharacterInfo`, `PanelActiveItems`,
    and `PanelSpecialItems`. Take a look at the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在层次结构窗口中右键单击并选择UI | 面板来创建每个面板。确保面板是`CanvasHUD`GameObject的子项。相应地重命名每个面板。我命名为：`PanelCharacterInfo`、`PanelActiveItems`和`PanelSpecialItems`。请看下面的截图：
- en: '![](img/00146.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00146.jpeg)'
- en: Initial HUD outline
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: HUD初始轮廓
- en: The preceding screenshot gives you a feeling of the HUD framework.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图给你一个关于HUD框架的感觉。
- en: Completing our HUD design
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成我们的HUD设计
- en: Now that we have the framework in place, let's go ahead and complete each section
    individually. I would like to start with the `PanelCharacterInfo`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了框架，让我们继续完成每个部分的单独设计。我想从`PanelCharacterInfo`开始。
- en: Character info panel
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色信息面板
- en: From a design point of view, the panel that will contain the visual components
    for the character will be very complex. The panel will be composed of five images.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从设计角度来看，将包含角色视觉组件的面板将非常复杂。面板将由五个图像组成。
- en: The main image will be used to hold an avatar of the character. The other four
    images will be used to display the health and mana of the character. Since these
    values will be displayed in a bar format, we will be using two images per item.
    One of the images will host the border, and the other the representation of the
    actual value.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 主要图像将用于存放角色的头像。其他四个图像将用于显示角色的健康和法力。由于这些值将以条形图格式显示，我们将为每个项目使用两个图像。一个图像将包含边框，另一个将包含实际值的表示。
- en: 'To come up with the images, I will use external tools such as Photoshop; Microsoft
    Expression Design is a good tool for creating frames and so on. Take a look at
    the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制作图像，我将使用外部工具，如Photoshop；Microsoft Expression Design是创建框架等的好工具。请看下面的截图：
- en: '![](img/00147.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00147.jpeg)'
- en: In the preceding screenshot, I have made a nice image portraying the avatar
    of the player character. You should take into consideration the actual size of
    the image you will be placing inside the `PanelCharacterInfo` panel. The image
    size I have generated is 301 × 301 pixels.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我制作了一个很好的图像，描绘了玩家角色的头像。你应该考虑你将放置在`PanelCharacterInfo`面板内的图像的实际大小。我生成的图像大小是301
    × 301像素。
- en: 'To create the graphics for the bars representing the health and the mana for
    our character player, we will actually need to have three images. One image representing
    the negative value for the bar, one image representing the positive value of the
    bar, and the third will be the boarder image for the bar. They will be overlaid
    on top of each other to give the illusion of our graphic bars, as shown in the
    following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建代表角色玩家健康和法力的条形图的图形，我们实际上需要三个图像。一个图像代表条的负值，一个图像代表条的正值，第三个将是条的边框图像。它们将叠加在一起，以产生我们图形条的错觉，如下面的截图所示：
- en: '![](img/00148.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00148.jpeg)'
- en: Health bar graphics
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 健康条图形
- en: Creating the three distinct sprites and overlaying them will give you a good
    illusion of what you are looking for.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 创建三个不同的精灵并将它们叠加，将给你一个很好的错觉，让你找到你想要的效果。
- en: After exporting our images, we need to import them into Unity. Use your file
    system to move your images from their original location to the `Assets` folder
    under your Unity project.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在导出我们的图像后，我们需要将它们导入到Unity中。使用你的文件系统将你的图像从原始位置移动到Unity项目下的`Assets`文件夹。
- en: 'I have placed my textures in the following directory: Assets | RPG_2E | Textures.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我将我的纹理放置在以下目录：Assets | RPG_2E | Textures。
- en: 'Once you have moved them into the desired location within your Unity project,
    you will need to convert the images to sprites. Select all of the images that
    will be used for GUI, and from the Inspector window, change the Texture Type to
    Sprite (2D and UI). Take a look at the following screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将它们移动到你的Unity项目中的期望位置，你将需要将图像转换为精灵。选择所有将被用于GUI的图像，并在检查器窗口中，将纹理类型更改为精灵（2D和UI）。看看下面的截图：
- en: '![](img/00149.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00149.jpeg)'
- en: Image import properties
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图像导入属性
- en: It's time to apply our textures to the actual UI elements we have defined under
    the `PanelCharacterInfo` panel within the `Canvas` object.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将我们的纹理应用到我们在`Canvas`对象下的`PanelCharacterInfo`面板内定义的实际UI元素上了。
- en: 'Note: There are a few steps that need to be performed before we can fully apply
    the UI elements to the HUD.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在我们能够完全将UI元素应用到HUD之前，需要执行几个步骤。
- en: The first thing you should do if you have not done so already is creating three
    new UI image elements under the `PanelCharacterInfo` panel by right-clicking the
    panel and selecting UI | Image.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，你应该首先在`PanelCharacterInfo`面板下创建三个新的UI图像元素，通过右键单击面板并选择UI | 图像。
- en: I have named my three images `imgHealthRebBackground`, `imgHealthGreenBackground`
    and `imgHealthBorder`. The order of the images does matter. You should take a
    note of it when you are designing the UI. Generally speaking, if a UI element
    is lower in the hierarchy, it will be rendered on top of the other elements.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我将我的三个图像命名为`imgHealthRebBackground`、`imgHealthGreenBackground`和`imgHealthBorder`。图像的顺序很重要。在设计UI时你应该注意这一点。一般来说，如果UI元素在层次结构中位置较低，它将渲染在其他元素之上。
- en: 'Take a look at the following screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的截图：
- en: '![](img/00150.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00150.jpeg)'
- en: Health-bar hookup
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 健康条连接
- en: Notice the order of the images representing the health bar. The image that represents
    the green bar will need to be modified using the *Inspector *w*indow*. Select
    it, and change the *Image Type* to Filled, change the *Fill Method* to *Horizontal*
    and the *Fill Origin* to *Left*. We will be using the *Fill Amount* to control
    the visual part of our health bar. Notice that I have set it to `0.77` for demonstration
    purposes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意健康条表示图像的顺序。代表绿色条的图像需要使用*检查器窗口*进行修改。选择它，将*图像类型*更改为填充，将*填充方法*更改为*水平*，将*填充起点*更改为*左端*。我们将使用*填充量*来控制健康条的视觉部分。请注意，我将其设置为`0.77`以供演示。
- en: By default, when the game starts, we will be starting at a *Fill Amount* of
    `1`, which is equivalent to 100 percent for the player character's health. `0.77`
    is equivalent to 77 percent and so on.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当游戏开始时，我们将从`Fill Amount`的`1`开始，这对于玩家角色的健康来说相当于100%。`0.77`相当于77%，依此类推。
- en: We will apply the same technique for our mana bar. Go ahead and create two more
    images, which will represent the two backgrounds for our mana bar.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为法力条应用相同的技巧。继续创建另外两个图像，它们将代表法力条的两个背景。
- en: 'Note: We will be using the same border image for both bars.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们将使用相同的边框图像为两个条。
- en: Again, don't forget you will need to make the appropriate changes to the imported
    textures within Unity. Convert them to Sprite *(2D and UI) Texture Type*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，不要忘记你需要在Unity中导入的纹理中进行适当的更改。将它们转换为Sprite *(2D和UI) 纹理类型*。
- en: 'Create the necessary image UI elements under the panel, and apply the textures
    to the image element within the canvas. You should have something like the following
    screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在面板下创建必要的图像UI元素，并将纹理应用到画布中的图像元素上。你应该有如下截图所示的内容：
- en: '![](img/00151.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00151.jpeg)'
- en: Mana-bar hookup
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 法力条连接
- en: That's all there is to it! Not bad for a person with no artistic background!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部内容！对于一个没有艺术背景的人来说，还不错！
- en: Active inventory items panel
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动库存项目面板
- en: Creating the UI for active inventory items is similar to what we have done in
    [Chapter 6](part0122.html#3KB4K0-7a1ef7ae3ef249cdb149f8344d2e8e79), *Inventory
    System*. The difference is that we will be listing only the items that have been
    consumed by the player character using the inventory system.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 创建活动库存项目的UI与我们在[第6章](part0122.html#3KB4K0-7a1ef7ae3ef249cdb149f8344d2e8e79)，“库存系统”中所做的是类似的。不同之处在于，我们将只列出玩家使用库存系统消耗的项目。
- en: In other words, the Active Inventory Items display is a visual indication of
    the items that have been activated within the inventory. It is important to keep
    in mind that we are more interested in learning the concepts and applying them
    in a simple example that you can expand upon and improve on your own.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，活动库存项目显示是库存中已激活项目的视觉指示。重要的是要记住，我们更感兴趣的是学习概念并将它们应用于一个简单的示例中，你可以在此基础上扩展和改进。
- en: The basic idea is to create a scroll-able panel that will be used to add items
    as needed. We have already seen how to set up the scroll-able view and how to
    configure the UI components to support what we are trying to achieve. I won't
    be getting into the details here again; please refer to [Chapter 6](part0122.html#3KB4K0-7a1ef7ae3ef249cdb149f8344d2e8e79),
    *Inventory System* for the necessary steps if needed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的想法是创建一个可滚动的面板，用于添加所需的项目。我们已经看到了如何设置可滚动视图以及如何配置UI组件以支持我们试图实现的目标。我不会再次深入细节；如果需要，请参考[第6章](part0122.html#3KB4K0-7a1ef7ae3ef249cdb149f8344d2e8e79)，“库存系统”中的必要步骤。
- en: From the *Hierarchy* window right-click on PanelActiveInventoryItems and select
    *UI* | *Scroll View*. Go ahead and remove the `Viewport`*,* `Scrollbar Horizontal`
    and `Scrollbar Vertical` children that have been created with the `Scroll View`
    element.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在*层次结构*窗口中，右键单击PanelActiveInventoryItems，然后选择*UI* | *滚动视图*。继续删除由“滚动视图”元素创建的`Viewport`、`Scrollbar
    Horizontal`和`Scrollbar Vertical`子元素。
- en: 'You just need to make sure that the layout configuration you are applying is
    for horizontal and not vertical, as we did in [Chapter 6](part0122.html#3KB4K0-7a1ef7ae3ef249cdb149f8344d2e8e79),
    *Inventory System*. Take a look at the following screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需确保你应用的布局配置是水平的，而不是垂直的，就像我们在[第6章](part0122.html#3KB4K0-7a1ef7ae3ef249cdb149f8344d2e8e79)，“库存系统”中所做的那样。请查看以下截图：
- en: '![](img/00152.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00152.jpeg)'
- en: Active inventory panel
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 活动库存面板
- en: 'Double-check your anchors and alignments in the UI elements:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在UI元素中检查你的锚点和对齐方式：
- en: '![](img/00153.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00153.jpeg)'
- en: 'And finally, take a look at the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请查看以下截图：
- en: '![](img/00154.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00154.jpeg)'
- en: The three preceding figures illustrate the different parts of the configuration
    for the Active Inventory Items panel. If you are unsure of how to put this together,
    please go back to [Chapter 6](part0122.html#3KB4K0-7a1ef7ae3ef249cdb149f8344d2e8e79),
    *Inventory System*, and read the *Designing a Dynamic Item Viewer* section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个图展示了活动库存项目面板配置的不同部分。如果你不确定如何组合它们，请回到[第6章](part0122.html#3KB4K0-7a1ef7ae3ef249cdb149f8344d2e8e79)，“库存系统”，并阅读*设计动态物品查看器*部分。
- en: Don't forget to make a prefab of the UI element that will be representing your
    active inventory item in the panel.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记制作一个预制体，这个UI元素将代表你在面板中的活动库存项目。
- en: You will also need a script to reference the UI elements designated for your
    items. I have called this script `ActiveInventoryItemUi.cs`, and currently, there
    are two attributes; one is a reference to the `Image` element and the other a
    reference to the `Text` element.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一个脚本来引用为你的物品指定的UI元素。我称这个脚本为`ActiveInventoryItemUi.cs`，目前有两个属性；一个是`Image`元素的引用，另一个是`Text`元素的引用。
- en: 'The listing for the script is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本列表如下：
- en: '[PRE0]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will eventually need to integrate all of these scripts together to make things
    work properly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终需要将这些脚本整合在一起，以确保一切正常工作。
- en: Special items panel
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊物品面板
- en: Now we will look at the design of our last panel. The main difference between
    this panel and the last one we developed is the orientation. Everything else will
    be exactly the same. However, for this panel, our orientation will be vertical
    instead of horizontal.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看我们最后设计的面板。这个面板与最后一个我们开发的面板的主要区别是方向。其他所有内容都将完全相同。然而，对于这个面板，我们的方向将是垂直而不是水平。
- en: 'Here is a screenshot capturing everything at once:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一张捕捉到一切的截图：
- en: '![](img/00155.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00155.jpeg)'
- en: Special items panel
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊物品面板
- en: The procedure to create the panel has already been discussed several times,
    and you should not have any trouble creating it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 创建面板的流程已经被讨论了好几次，你应该不会在创建它时遇到任何麻烦。
- en: I have let you make your own textures and images to apply to the UI elements.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我让你自己制作纹理和图像，以应用于UI元素。
- en: While designing the Special Items panel, I came up with a better idea of how
    to improve the panel UI. You might want to have a static icon representing each
    special item, and have a counter attached to the UI representing how many of each
    item you have. Each time you collect one, it will increase, and each time you
    consume one it will decrease.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计特殊物品面板时，我想出了一个改进面板UI的更好方法。你可能希望有一个静态图标代表每个特殊物品，并且有一个计数器附加到UI上，表示你有多少个这样的物品。每次你收集一个，它就会增加，每次你消耗一个，它就会减少。
- en: 'The following screenshot shows how the current HUD looks based on our design:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了根据我们的设计当前HUD的外观：
- en: '![](img/00156.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00156.jpeg)'
- en: Active inventory and special inventory runtime
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 活动库存和特殊库存运行时
- en: We now need to start thinking about the integration of the HUD user interface
    with the code base we have developed so far.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要开始考虑将HUD用户界面与我们迄今为止开发的代码库整合。
- en: Integrating the code
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码整合
- en: Now that we have our HUD design up and running, we will need to integrate the
    UI elements with the actual code that will be deriving them. There are a few scripts
    that will be created to support the new UI features and a few that will be updated
    to glue everything together.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将HUD设计搭建并运行起来，我们需要将UI元素与实际代码整合，这些代码将生成这些UI元素。将创建几个脚本以支持新的UI功能，还有几个脚本将更新以将一切粘合在一起。
- en: 'The following scripts have been created: `ActiveInventoryItemUi.cs`, `ActiveSpecialItemUi.cs`,
    and `HudElementUi.cs`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本已被创建：`ActiveInventoryItemUi.cs`、`ActiveSpecialItemUi.cs`和`HudElementUi.cs`。
- en: 'The listing of these scripts is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些脚本的列表如下：
- en: '[PRE1]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These scripts will be used on the HUD user interface to give us access to the
    elements. For instance, you will need to attach the `HudElementUi.cs` script to
    the `CanvasHUD` GameObject. Take a look at the following screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些脚本将在HUD用户界面上使用，以给我们访问元素的能力。例如，你需要将`HudElementUi.cs`脚本附加到`CanvasHUD`游戏对象上。请看以下截图：
- en: '![](img/00157.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00157.jpeg)'
- en: HUD canvas
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: HUD画布
- en: The preceding screenshot illustrates how the HUD canvas is configured with the
    `HUDElementsUI.cs` script.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图说明了如何使用`HUDElementsUI.cs`脚本配置HUD画布。
- en: Now let's take a look at the prefabs we have created to represent the UI elements
    to be used for the panels. There are two; I have named them `PanelActiveItem`
    and `PanelSpecialItem`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们创建的预制件，以表示用于面板的UI元素。有两个；我称它们为`PanelActiveItem`和`PanelSpecialItem`。
- en: 'I will discuss `PanelSpecialItem` as it contains everything `PanelActiveItem`
    contains plus an additional script, which is attached to it for event handling.
    Take a look at the following screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我将讨论`PanelSpecialItem`，因为它包含`PanelActiveItem`包含的所有内容，以及一个附加的事件处理脚本。请看以下截图：
- en: '![](img/00158.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00158.jpeg)'
- en: HUD event triggers
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: HUD事件触发
- en: What we have just covered was the implementation of the scripts that are used
    to have access to the proper UI elements within the HUD canvas.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚讨论的是实现用于访问HUD画布中适当UI元素的脚本的实现。
- en: You will notice that for the `PanelSpecialItem` prefab, we have two new and
    very important components that we have attached to it. One is the **Event Trigger**
    within Unity, and the other is the `ActiveSpecialItemUi.cs` script, which is used
    to handle the `PointerClick` event for the special item.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，对于`PanelSpecialItem`预制件，我们为其添加了两个新且非常重要的组件。一个是Unity中的**事件触发器**，另一个是`ActiveSpecialItemUi.cs`脚本，该脚本用于处理特殊物品的`PointerClick`事件。
- en: What this means is that we are basically making the item clickable, and when
    the player clicks on the item, something happens. In this case, it applies the
    special item to the player character.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们基本上使物品可点击，当玩家点击物品时，会发生某些事情。在这种情况下，它将特殊物品应用于玩家角色。
- en: Now we are ready to update the other scripts we have already developed to incorporate
    the HUD functionality. The scripts that will need to be modified are `InventorySystem.cs`
    and `UiController.cs`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好更新我们已开发的脚本以包含HUD功能。需要修改的脚本有`InventorySystem.cs`和`UiController.cs`。
- en: 'The listing of `InventorySystem.cs` is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventorySystem.cs`的列表如下：'
- en: '[PRE2]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The listing for `ClearInventory()` and `AddItem()` is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClearInventory()`和`AddItem()`的列表如下：'
- en: '[PRE3]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`DeleteItem()` will remove a given `InventoryItem` from the list. See the following
    code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeleteItem()`将从列表中删除一个给定的`InventoryItem`。请参阅以下代码：'
- en: '[PRE4]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The listing for `UiController.cs` is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`UiController.cs`的列表如下：'
- en: '[PRE5]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A portion of script is listed as follows. Please refer to the download package
    for the full listing:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出了一个脚本的部分内容。请参考下载包中的完整列表：
- en: '[PRE6]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that you have everything in place, you can go ahead and test run the game
    to make sure everything is working as expected. This is also a good time to test/debug
    your code and your project settings if you have not done so already.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经一切就绪，你可以继续测试运行游戏以确保一切按预期工作。这也是一个很好的时间来测试/调试你的代码和项目设置，如果你还没有这样做的话。
- en: 'I have to make the following point once again: the idea is to grasp the concept.
    We are looking at one way to implement what we want to achieve; you might come
    up with a better method along the way, or decide to do something totally different.
    I encourage that!'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须再次强调以下观点：目的是掌握概念。我们正在查看实现我们想要达到目标的一种方法；你可能在这个过程中想出更好的方法，或者决定做完全不同的事情。我鼓励这样做！
- en: 'Take a look at the following screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的截图：
- en: '![](img/00159.jpeg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00159.jpeg)'
- en: Initial state
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 初始状态
- en: The preceding screenshot illustrates the state of the player character and that
    of the inventory when the level initially loads. I have indicated the critical
    parts that we are testing and will track, to make sure our code works properly.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图展示了玩家角色和库存在关卡最初加载时的状态。我已经指出了我们正在测试和跟踪的关键部分，以确保我们的代码能够正常工作。
- en: In the next figure, the player character has picked up a few of the inventory
    items we have laid on the level. When you bring up the Inventory window and click
    on any one of the categories defined, such as weapons, you will get a listing
    of all the weapons that we have in our inventory, and so forth.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一幅图中，玩家角色已经捡起了一些我们在关卡上放置的库存物品。当你打开库存窗口并点击任何定义的分类，例如武器，你将得到我们库存中所有武器的列表，等等。
- en: 'We have collected one weapon type, one health packet, and a couple of defensive
    items. Note that our Special Items panel is displaying an item. This is the health
    packet we have picked up:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收集了一种武器类型、一个健康包和一些防御物品。请注意，我们的特殊物品面板正在显示一个物品。这是我们捡到的健康包：
- en: '![](img/00160.jpeg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00160.jpeg)'
- en: Special item interaction
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊物品交互
- en: The next screenshot illustrates how the HUD updates itself when the player starts
    to consume some of the inventory items by adding them using the Inventory window
    during gameplay.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张截图展示了当玩家在游戏中通过使用库存窗口添加库存物品开始消耗一些库存物品时，HUD如何更新自己。
- en: 'Notice that we have activated three inventory items: two weapons, named axe2
    and club1, and two armors of type SP04 and SP03 respectively.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经激活了三个库存物品：两把武器，分别命名为axe2和club1，以及两种类型的盔甲SP04和SP03。
- en: 'You can visually see them on the player character as well as the panel holding
    the active inventory items. Pretty cool:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在玩家角色以及持有活动库存物品的面板上直观地看到它们。非常酷：
- en: '![](img/00161.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00161.jpeg)'
- en: Active panel interaction
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 激活面板交互
- en: It's time to go and meet the enemy. We have not discussed much about the interaction
    between the player character and the **non-player characters** (**NPCs**). We
    will do this shortly.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候去见敌人了。我们还没有讨论过玩家角色和非玩家角色（NPC）之间的交互。我们很快就会讨论这个问题。
- en: We have applied some of the inventory items from our inventory to the player
    character, and now we can actually go and face the enemy. We will allow the enemy
    to attack us, to see how our health reduces. Then we will use the health packet
    from our special items panel to increase our health once more.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将一些库存物品从我们的库存中应用到玩家角色上，现在我们可以实际上去面对敌人了。我们将允许敌人攻击我们，以查看我们的健康如何减少。然后我们将使用特殊物品面板中的健康包再次增加我们的健康。
- en: 'The two following screenshots illustrate this scenario:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个截图说明了这个场景：
- en: '![](img/00162.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00162.jpeg)'
- en: 'The following screenshot shows us running away and applying our health packet:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们在逃跑并应用我们的健康包：
- en: '![](img/00163.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00163.jpeg)'
- en: Notice how, when we apply the health packet, it removes itself from the inventory
    system as well as the special items panel.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们应用健康包时，它会从库存系统和特殊物品面板中移除自己。
- en: Enemy stats in the HUD
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在HUD中显示敌人统计数据
- en: We have not really discussed how to handle and manage the statistics and the
    visual representation of the NPC with the player. It is now time to do just that!
    We need to decide what it is that we want to display as information to the player.
    At the moment, let's keep it simple and just display the basic health and strength
    of the enemy.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有真正讨论过如何处理和管理NPC的统计数据及其视觉表示。现在是时候做这件事了！我们需要决定我们想要向玩家显示哪些信息。目前，让我们保持简单，只显示敌人的基本健康和力量。
- en: The question is, what is the best way to display this information? Should we
    display the information based on a distance threshold between the player character
    and the NPC, or should we display it when the player requests it at some time
    during gameplay?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，显示这些信息的最佳方式是什么？我们应该根据玩家角色和NPC之间的距离阈值来显示信息，还是我们应该在玩家在游戏过程中某个时间请求时显示它？
- en: Let's go ahead and take the first scenario. We will display the information
    of the NPC when there is a certain distance between the player character and the
    NPC. We can even make this distance the same as the line of sight we have set
    for the NPC! This is good, because, if they can see us, then they are close enough
    for us to see their stats! Let's get to work!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从第一个场景开始。当玩家角色和NPC之间有一定距离时，我们将显示NPC的信息。我们甚至可以使这个距离与为NPC设置的视线距离相同！这是好事，因为，如果他们能看到我们，那么他们离我们就足够近，我们可以看到他们的统计数据！让我们开始工作！
- en: NPC stats user interface
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NPC统计数据用户界面
- en: We will be using some of the existing textures that we have created for our
    player character, such as the textures for the health bar and strength bar. We
    just need to create a canvas that will be in the world space and attached to the
    NPC character.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们为玩家角色创建的一些现有纹理，例如健康条和力量条的纹理。我们只需要创建一个将在世界空间中并且附加到NPC角色上的画布。
- en: Creating the NPC canvas
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建NPC画布
- en: The main differences between the canvas we will create for the NPC and that
    of the one we have been creating for the player are some of the configurations.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为NPC创建的画布和我们已经为玩家创建的画布之间的主要区别是一些配置。
- en: One of the main differences will be the *Render Mode* of the canvas. The NPC
    canvas will have a *World Space Render Mode*. This will allow us to position the
    canvas as another GameObject within the scene. The next important difference will
    be the *Rect Transform* attributes and, more importantly, the *Scale* and *Rotation*
    attributes.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别之一将是画布的*渲染模式*。NPC画布将具有*世界空间渲染模式*。这将允许我们将画布定位为场景中的另一个GameObject。下一个重要区别将是*矩形变换*属性，更重要的是，*缩放*和*旋转*属性。
- en: 'Take a look at the following screenshot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的截图：
- en: '![](img/00164.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00164.jpeg)'
- en: NPC health bar
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: NPC健康条
- en: To make life easier, all you need to do is create the canvas and change the
    properties of the canvas as shown in the preceding screenshot. For the next step,
    you can copy the whole `PanelCharacterInfo` we developed in the previous sections,
    and paste it as a child of the new canvas. This way, you will not have to recreate
    each UI element one by one, which will save a lot of time. However, you will need
    to change the *Scale* and the Tranform properties on the `PanelCharacterInfo`
    panel—the new one—to arrange it so that it renders above the NPC's head!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化操作，你只需要创建画布并更改画布的属性，如前一张截图所示。对于下一步，你可以复制我们在前几节中开发的整个 `PanelCharacterInfo`，并将其粘贴为新画布的子元素。这样，你就不必逐个重新创建每个
    UI 元素，这将节省大量时间。然而，你需要在 `PanelCharacterInfo` 面板——新面板上更改 *Scale* 和 Transform 属性，以便将其排列在
    NPC 头部上方渲染！
- en: The next step is for us to be able to control the values of the stat bars from
    the code. For this, we will create a new script called `NPCStatUi.cs` and attach
    it to the canvas object we just created for the NPC stats.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是我们能够从代码中控制状态条的值。为此，我们将创建一个新的脚本，命名为 `NPCStatUi.cs`，并将其附加到我们刚刚为 NPC 状态创建的画布对象上。
- en: I have renamed the canvas `CanvasNPCStats`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我已将画布重命名为 `CanvasNPCStats`。
- en: 'The listing of the script is as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的列表如下：
- en: '[PRE7]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The script we just created will only give us a reference to the image elements.
    We still need to be able to have a method to update the values.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的脚本只会给我们提供图像元素的引用。我们仍然需要有一种方法来更新值。
- en: We need to find a way to reference all the NPC characters in a given scene.
    Once that is determined, we will need to set the initial values of the health
    and strength bar. Then, during gameplay, we will need to be able to update each
    NPC's stats according to the state of the game.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要找到一种方法来引用特定场景中的所有 NPC 角色。一旦确定，我们就需要设置健康和力量条的初始值。然后，在游戏过程中，我们需要能够根据游戏状态更新每个
    NPC 的统计数据。
- en: In order for us to identify the NPCs in a given scene, we will use the `Tag`
    element defined in each GameObject. We need to create a new `Tag` element named
    *Enemy*, and every NPC that is of enemy type will need to be tagged as such. This
    is an easy way to do a quick search and get a list of GameObjects based on their
    `Tag` value.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们能够识别特定场景中的 NPC，我们将使用每个 GameObject 中定义的 `Tag` 元素。我们需要创建一个新的 `Tag` 元素，命名为
    *Enemy*，并且所有敌对类型的 NPC 都需要被标记为敌对。这是一种快速搜索并根据它们的 `Tag` 值获取 GameObject 列表的方法。
- en: You should also start thinking about how are you going to dynamically attach
    the NPC stat canvas to the NPC at runtime. At the moment, for testing purposes,
    I will leave it attached to the model. But the question is, where do you actually
    attach it? Well, we have an empty GameObject named *Follow* attached to our model
    prefab. Since this is driven from our player character model, we have embedded
    *Follow* as a placeholder for the main camera during gameplay. For the NPC, we
    will use it to attach the NPC canvas as a child GameObject to the `Follow` GameObject
    in the model hierarchy. You can see these in the preceding screenshots.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该开始考虑如何在运行时动态地将 NPC 状态画布附加到 NPC 上。目前，出于测试目的，我将将其附加到模型上。但问题是，你实际上在哪里附加它？嗯，我们有一个名为
    *Follow* 的空 GameObject 附加到我们的模型预制件上。由于这是由我们的玩家角色模型驱动的，我们在游戏过程中将其嵌入 *Follow* 作为主相机的占位符。对于
    NPC，我们将使用它将 NPC 画布作为子 GameObject 附加到模型层次结构中的 `Follow` GameObject 上。你可以在前一张截图中看到这些。
- en: 'We will use the `NpcAgent.cs` script to initialize the NPC status canvas prefab
    and the appropriate values of the UI elements. This is the best place to place
    the initialization because it will be self-contained. The new listing for the
    script is as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `NpcAgent.cs` 脚本来初始化 NPC 状态画布预制件以及 UI 元素的相关值。这是放置初始化的最佳位置，因为它将是一个自包含的单元。该脚本的最新列表如下：
- en: '[PRE8]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that you will need to assign `canvasNPCStatsAttachment`*,* which will be
    used to store a reference to the GameObject we will attach to the NCP canvas.
    `canvasNPCStatsPrefab` will be used to assign the prefab representing the NPC
    status canvas at design time. If you run the game now, you will have the prefab
    instantiated dynamically and attached to the `Follow` GameObject in the hierarchy
    with the fill values set to `1f`, that is, 100 percent.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你需要分配 `canvasNPCStatsAttachment`*，*，它将用于存储我们将附加到 NPC 画布上的 GameObject 的引用。`canvasNPCStatsPrefab`
    将在设计时用于分配代表 NPC 状态画布的预制件。如果你现在运行游戏，你将有一个预制件被动态实例化并附加到层次结构中的 `Follow` GameObject
    上，填充值设置为 `1f`，即 100%。
- en: NPC taking a hit
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NPC 受击
- en: We need to take a moment and go back to some of the initial scripts and configurations
    we did in earlier chapters, where we defined the player character's *Animator
    Controller* and `BarbarianCharacterController.cs` script.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要花点时间回顾一下我们在早期章节中的一些初始脚本和配置，其中我们定义了玩家角色的*动画控制器*和`BarbarianCharacterController.cs`脚本。
- en: 'Note: Please refer to Chapter 3, *RPG Character Design*, to refresh your memory
    on Animator Controller and Curves.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：请参阅第3章，“RPG角色设计”，以刷新你对动画控制器和曲线的记忆。
- en: 'Open the animator controller we created in [Chapter 3](part0074.html#26I9K0-7a1ef7ae3ef249cdb149f8344d2e8e79),
    *RPG Character Design*, named `BarbarianAnimatorController`. Select the *Parameters*
    tab and create new parameters called *Attack1, Attack2,* and *Attack3* of the `float`
    datatype. Take a look at the following screenshot:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 打开我们在[第3章](part0074.html#26I9K0-7a1ef7ae3ef249cdb149f8344d2e8e79)“RPG角色设计”中创建的动画控制器，命名为`BarbarianAnimatorController`。选择*参数*选项卡，创建名为*Attack1,
    Attack2,*和*Attack3*的新参数，数据类型为`float`。看看下面的截图：
- en: '![](img/00165.jpeg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/00165.jpeg)'
- en: Animator State Machine
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 动画状态机
- en: For a refresher, go back to [Chapter 4](part0094.html#2PKKS0-7a1ef7ae3ef249cdb149f8344d2e8e79), *The
    Game Mechanics*, section *PC and NPC Interaction*, and you will recall how we
    defined and configured the curve to assign the parameter based on the animation.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了复习，请回到[第4章](part0094.html#2PKKS0-7a1ef7ae3ef249cdb149f8344d2e8e79)，“游戏机制”，部分*PC和NPC交互*，你将回想起我们如何定义和配置曲线，根据动画分配参数。
- en: We have defined the curve only for one of the attack animations.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只为其中一个攻击动画定义了曲线。
- en: Once you have configured the parameter on the *Animator Controller* for the
    player character, then we have to update the `BarbarianCharacterController.cs`
    script to trigger an attack based on the parameter value.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你为玩家角色配置了*动画控制器*上的参数，那么我们就需要更新`BarbarianCharacterController.cs`脚本，根据参数值触发攻击。
- en: 'The following listing is a partial listing of the script, displaying just the
    modified portion:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出的是脚本的局部列表，仅显示修改的部分：
- en: '[PRE9]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the code, we check to see if any of the attack modes are active and if so
    we check to see what the curve parameter *Attack1* is at the moment of the animation.
    If we are at `1.0f`, then we call the `GameMaster` object to perform the rest.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们检查是否有任何攻击模式处于活动状态，如果是的话，我们检查动画时刻曲线参数*Attack1*的值。如果我们处于`1.0f`，那么我们调用`GameMaster`对象来执行剩余的操作。
- en: 'Now we need to take a look at a few functions we have defined/modified in the `GameMaster.cs`
    script:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要查看我们在`GameMaster.cs`脚本中定义/修改的几个函数：
- en: '[PRE10]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Some explanation is needed here. So the `OnLevelWasLoaded()` function is called
    each time a new scene is loaded at runtime. This is where we query all GameObjects
    that are tagged `Enemy`. We then store them internally, for further processing
    down the line.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要一些解释。所以，每次在运行时加载新场景时，都会调用`OnLevelWasLoaded()`函数。这是查询所有标记为`Enemy`的GameObject的地方。然后我们将其内部存储，以供后续处理。
- en: For testing purposes and due to the simplicity of the scene, there is only one
    enemy present for testing. I am also setting the `closestNPCEnemy` object to the
    last GameObject tagged `Enemy`. This variable is later used in the `PlayerAttachEnemy()`
    function to set the NPCs `Health` property.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于测试目的和场景的简单性，测试中只有一个敌人。我还将`closestNPCEnemy`对象设置为最后一个标记为`Enemy`的GameObject。这个变量随后在`PlayerAttachEnemy()`函数中使用，以设置NPC的`Health`属性。
- en: When the `PlayerAttackEnemy()` function is called, we get a reference to the
    NPC component of the NPC character and reduce the health based on the attack.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`PlayerAttackEnemy()`函数时，我们获取NPC角色的NPC组件，并根据攻击减少其健康值。
- en: 'Now, this also forces us to update the `BaseCharacter.cs` script. A listing
    of the modification is as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这也迫使我们更新`BaseCharacter.cs`脚本。以下是修改的列表：
- en: '[PRE11]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the `Health` property, we check to see if we are the player, or an NPC. If
    we are the player, we need to use `GameMaster` to update our `Stats` UI, if we
    are going to update our own NPC `Stats` UI.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Health`属性中，我们检查是否是玩家，或者NPC。如果是玩家，我们需要使用`GameMaster`来更新我们的`Stats` UI，如果我们要更新自己的NPC
    `Stats` UI。
- en: 'This means that when you create your player character and/or NPC, you will
    need to make sure you are assigning the data elements properly; see the following
    code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当你创建你的玩家角色和/或NPC时，你需要确保你正确地分配数据元素；请参阅以下代码：
- en: '[PRE12]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code and scripts we have looked at have been used to test the ideas we have
    put forth. The results are positive. You might have noticed that when the player
    character attacks, we do not take into consideration its position relative to
    that of the enemy. We are also automatically assigning the closest NPC character
    in `GameMaster` to eventually be the last element of the query we give each time
    a level loads.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查看的代码和脚本已被用于测试我们提出的思想。结果是积极的。你可能已经注意到，当玩家角色攻击时，我们没有考虑其相对于敌人的位置。我们还在自动将 `GameMaster`
    中最近的NPC角色分配为每次加载关卡时查询的最后一个元素。
- en: Enhancing the code
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化代码
- en: One last code implementation I would like to make before I close out the chapter,
    is to make sure that when we are in attack mode for the player character, the
    hit points will affect the NPC that it is intended for automatically. In other
    words, determine which NPC is closest to us based on our distance and view angle
    toward the NPC.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，我想要实现最后一个代码实现，确保在玩家角色处于攻击模式时，生命值会自动影响目标NPC。换句话说，根据我们对NPC的距离和视角角度确定最近的NPC。
- en: 'We have already created the logic to determine these quantities for the NPC
    character. We now need to implement something similar for the player character.
    Let''s take a look at a partial listing of the code changes we need to make for
    the `BarbarianCharacterMovement.cs` script:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了用于确定NPC角色的这些数量的逻辑。现在我们需要为玩家角色实现类似的功能。让我们看看我们需要对 `BarbarianCharacterMovement.cs`
    脚本进行的代码更改的部分列表：
- en: '[PRE14]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The way we calculate the sight and distance of the enemy NPCs is through **Raycasting**.
    This is done only when we are in attack mode; we check to see if the NPC is in
    front of us and, if so, we set the `ClosestNpcEnemy` object on `GameMaster` and
    set the `enemyInSight` flag, where we then perform the necessary subtraction from
    the health of the NPC.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算敌方NPC的视野和距离的方式是通过 **Raycasting**。这仅在攻击模式下进行；我们检查NPC是否在我们前方，如果是，则在 `GameMaster`
    上设置 `ClosestNpcEnemy` 对象，并设置 `enemyInSight` 标志，然后从NPC的健康值中进行必要的减法操作。
- en: 'Notice that I have also changed the way we compute the impact of the hit based
    on a simple equation, as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我还改变了计算击中影响的简单方程的方式，如下所示：
- en: '![](img/00166.jpeg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/00166.jpeg)'
- en: 'Here, *pc* is the object reference to our player character. The same equation
    is used on the NPC objects. This is just a simple demonstration that the impact
    of the hit point of the player or the NPC is based on the strength and the health
    of the actors in the scene. Take a look at the following screenshot:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*pc* 是我们玩家角色的对象引用。NPC对象也使用相同的方程。这只是一个简单的演示，说明玩家或NPC的伤害影响是基于场景中演员的力量和健康值。请查看以下截图：
- en: '![](img/00167.jpeg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/00167.jpeg)'
- en: Determining if the NPC is in sight
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 确定NPC是否在视野中
- en: The preceding screenshot illustrates how we detect if an NPC is in attack range
    or not.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图说明了我们如何检测NPC是否在攻击范围内。
- en: In turn, you can derive the strength value from the components that the player
    or the NPC has activated throughout the gameplay.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地，你可以从玩家或NPC在游戏过程中激活的组件中推导出力量值。
- en: 'A partial listing of `BaseCharacter.cs` illustrating the `HEALTH` property
    is as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseCharacter.cs` 文件中关于 `HEALTH` 属性的部分列表如下：'
- en: '[PRE15]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There are more code changes and updates; please refer to the associated files
    provided for details.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有更多的代码更改和更新；请参阅提供的关联文件以获取详细信息。
- en: 'During the implementation process, I have modified a few other code locations,
    which are not listed within the book due to physical limitations. Here are the
    scripts that have been modified: `BaseCharacter.cs`, `BarbarianCharacterController.cs`,
    `GameMaster.cs`, `NpcAgent.cs`, `PlayerAgent.cs` and `NpcBarbarianMovement.cs`.
    Take a look at the following screenshot:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现过程中，我修改了一些其他代码位置，但由于篇幅限制，这些内容未在书中列出。以下是已修改的脚本：`BaseCharacter.cs`、`BarbarianCharacterController.cs`、`GameMaster.cs`、`NpcAgent.cs`、`PlayerAgent.cs`
    和 `NpcBarbarianMovement.cs`。请查看以下截图：
- en: '![](img/00168.jpeg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/00168.jpeg)'
- en: GameMaster handling multiple NPCs
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏大师处理多个NPC
- en: You are encouraged to do some research and try different types of mechanics
    and implementation to enhance your skills.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励你进行一些研究，尝试不同的机制和实现方式来提高你的技能。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have expanded on our idea and looked at how to integrate
    all of the major pieces together. The main objective of the chapter was to create
    a heads-up display (HUD) for our game.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们扩展了我们的想法，并探讨了如何将所有主要部分整合在一起。本章的主要目标是创建我们游戏的一个抬头显示（HUD）。
- en: 'We started out with a design concept that was of interest to us, and created
    a layout for our HUD before the actual implementation. Once we concluded how the
    HUD should look, we started building the framework for it. We designed the three
    main sections of the HUD and referred to them as the following: `PanelCharacterInfo`,
    `PanelActiveItems`, and `PanelSpecialItems`.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个对我们感兴趣的设计概念开始，在实现之前为我们的 HUD 创建了一个布局。一旦我们确定了 HUD 应该是什么样子，我们就开始构建它的框架。我们设计了
    HUD 的三个主要部分，并称它们为以下名称：`PanelCharacterInfo`、`PanelActiveItems` 和 `PanelSpecialItems`。
- en: Next, we started to build the UI elements and the code necessary to make the
    panels work with our code. We started with `PanelCharacterInfo`, which represented
    the stats for our character player, that is, a reference to the player's avatar,
    a reference to the health, and a reference to the strength of the character. In
    the process, we had to create or update several of the scripts to work with the
    new UI.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始构建 UI 元素和使面板与我们的代码一起工作的必要代码。我们从 `PanelCharacterInfo` 开始，它代表我们的角色玩家的统计数据，即对玩家头像的引用、对健康的引用和对角色力量的引用。在这个过程中，我们必须创建或更新几个脚本以与新的
    UI 一起工作。
- en: Next, we designed and developed the `PanelActiveItems` panel. The implementation
    and approach to this specific panel was a little more involved. The purpose of
    this panel is to display all of the current active inventory items that the player
    has consumed. We had to make the panel scroll-able since we don't know how many
    items the player will be consuming at any given time. We created the necessary
    prefabs to be placeholders for the inventory items, as well as the scripts that
    make them work together.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设计和开发了 `PanelActiveItems` 面板。这个特定面板的实现和方法是稍微复杂一些。这个面板的目的是显示玩家当前消耗的所有活动库存物品。由于我们不知道玩家在任何给定时间会消耗多少物品，我们必须使面板可滚动。我们创建了必要的预制件作为库存物品的占位符，以及使它们一起工作的脚本。
- en: The design for `PanelSpecialItems` was very similar to that of `PanelActiveItems`,
    with two main differences. First, we had to make sure that the panel was vertical
    instead of horizontal, so we had to make sure that the proper configuration was
    applied. Secondly, the main functionality was different for this panel. The items
    displayed were supposed to be intractable, which meant that we had to create custom
    event handlers, apply the necessary values to the player character, and update
    the whole game state.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`PanelSpecialItems` 的设计非常类似于 `PanelActiveItems`，主要有两个不同点。首先，我们必须确保面板是垂直的而不是水平的，因此我们必须确保应用了正确的配置。其次，这个面板的主要功能与之前不同。显示的物品应该是不可交互的，这意味着我们必须创建自定义事件处理程序，将必要的值应用到玩家角色上，并更新整个游戏状态。'
- en: Once we were satisfied with the design of our HUD, we started building the necessary
    scripts to integrate the UI elements with the `GameMaster` and other scripts.
    This was basically making sure that our UI was always reflecting the state of
    the object that was of interest to us. The health, stamina, and inventory are
    the main items we used to communicate the concepts.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们对 HUD 的设计感到满意，我们就开始编写必要的脚本来将 UI 元素与 `GameMaster` 和其他脚本集成。这基本上是确保我们的 UI 总是反映我们感兴趣的对象的状态。健康、耐力和库存是我们用来传达概念的主要项目。
- en: In the last section of the chapter, we concentrated on the implementation of
    the player's character movement and detection of the NPCs, and how to track the
    hit points between the player character and the NPC, which was not done in previous
    chapters.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们专注于玩家角色移动的实现和 NPC 的检测，以及如何在玩家角色和 NPC 之间跟踪生命值，这在之前的章节中没有完成。
- en: We also had to do some backtracking and make some adjustments to the animation
    controller we had defined for our player character, to have curves defined for
    our attack animation values based on the motion.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须回溯并调整我们为玩家角色定义的动画控制器，为攻击动画值定义基于运动的曲线。
- en: 'During the process, we had to solve the following challenges: How do we know
    if we are in close enough range that we can actually attack and hit the NPC character?
    How are we going to detect which NPC is closer to us? More importantly, how is
    the data going to be passed along from the action of attacking to the actual hit
    on the NPC?'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们必须解决以下挑战：我们如何知道我们是否已经接近到足够近的距离，可以实际攻击并击中NPC角色？我们将如何检测哪个NPC离我们更近？更重要的是，数据将如何从攻击动作传递到NPC实际被击中的情况？
- en: We have done a lot in a short period of time and in a small number of pages.
    Some of the functions have been left for the reader to solve on their own. For
    instance, we have not discussed how to delete an inventory item and so on. I felt
    this to be trivial, and that the reader will be comfortable enough to implement
    the function on their own once they see the bigger scope and how to connect everything
    together.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在短时间内做了很多工作，并且内容紧凑。有些功能留给了读者自己解决。例如，我们没有讨论如何删除库存项目等等。我觉得这些内容很 trivial，而且一旦读者看到了更大的范围以及如何将一切连接起来，他们应该会足够舒适地自己实现这些功能。
- en: With that said, let's move on to the next and final chapter, covering multiplayer!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们继续前进到下一章，最后一章，涵盖多人游戏！
