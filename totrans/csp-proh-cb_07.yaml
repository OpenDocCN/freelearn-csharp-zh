- en: Chapter 7. High Performance Programming Using Parallel and Multithreading in
    C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter takes a look at improving your code''s performance using multithreading
    and parallel programming. In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and aborting a low-priority background thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing maximum thread pool size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating multiple threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locking one thread until the contended resources are available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoking parallel calls to methods using `Parallel.Invoke`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a parallel `foreach` loop to run multiple threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cancelling a parallel `foreach` loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catching errors in parallel `foreach` loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging multiple threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you can find a single-core CPU in a computer today, it will probably mean
    that you are standing in a museum. Every new computer today utilizes the advantages
    of multiple cores. Programmers can take advantage of this extra processing power
    in their own applications. As applications have grown in size and complexity,
    in many cases they actually need to utilize multithreading.
  prefs: []
  type: TYPE_NORMAL
- en: While not every situation is always suited for the implementation of multithreaded
    code logic, it is good to know how to use multithreading to improve the performance
    of your applications. This chapter will take you through the fundamentals of this
    exciting technology in C# programming.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and aborting a low-priority background thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reason we want to have a look at a background thread specifically is because
    by default, all threads created by the main app thread or `Thread` class constructor
    are foreground threads. So, what exactly separates a foreground thread from a
    background thread? Well, background threads are identical to foreground threads
    with the exception that if all foreground threads are terminated, the background
    threads are stopped too. This is useful if you have a process in your application
    that must not stop the application from terminating. In other words, while your
    application is running, the background thread must continue to run.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a simple application that defines the thread created as a background
    thread. It will then suspend, resume, and abort the thread.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new class library by right-clicking on your solution and selecting
    **Add** and then **New Project** from the context menu:![How to do it…](img/B05391_07_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Add New Project** dialog screen, select **Class Library** from the
    installed templates and call your class `Chapter7`:![How to do it…](img/B05391_07_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your new class library will be added to your solution with a default name `Class1.cs,`
    which we renamed to `Recipes.cs` in order to distinguish the code properly. You
    can, however, rename your class to whatever you like if that makes more sense
    to you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To rename your class, simply click on the class name in **Solution Explorer**
    and select **Rename** from the context menu:![How to do it…](img/B05391_07_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visual Studio will ask you to confirm a rename of all references to the code
    element **Class1** in the project. Just click on **Yes**:![How to do it…](img/B05391_07_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following class is added to your `Chapter7` library project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `Recipes` class, add a method called `DoBackgroundTask()` with the
    `public void` modifiers, and add the following console output to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure that you have added the `using` statements for `System.Threading`
    and `static System.Console` to your `using` statements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Inside the console application called `CodeSamples`, added previously, add a
    reference to the `Chapter7` class library by right-clicking on **References**
    under the `CodeSamples` project and selecting **Add Reference** from the context
    menu:![How to do it…](img/B05391_07_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Reference Manager** window, select the `Chapter7` solution by going
    to **Projects** | **Solutions**. This will allow you to use the classes we just
    created in your console application:![How to do it…](img/B05391_07_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `void Main` method, create a new instance of your `Recipes` class and
    add it to a new thread called `backgroundThread`. Define this newly created thread
    to be a background thread and then start it. Finally, set the thread to sleep
    for five seconds. We need to do this because we have created a background thread
    that is set to sleep for three seconds. Background threads do not prohibit foreground
    threads from terminating. Therefore, if the main application thread (which is
    by default a foreground thread) terminates before the background thread completes,
    the application will terminate and also terminate the background thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that you might need to add the `using System.Threading`; directive.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run your console application by pressing *F5*. You will see that we have created
    a background thread with a normal priority:![How to do it…](img/B05391_07_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s modify our thread and set its priority down to low. Add this line of
    code to your console application: `backgroundThread.Priority = ThreadPriority.Lowest;`.
    This line will downgrade the thread priority:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run your console application again. This time, you will see that the thread
    priority has been set to the lowest priority:![How to do it…](img/B05391_07_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go back to your `DoBackgroundTask()` method and add `Thread.CurrentThread.Abort();`
    right before `Thread.Sleep(3000);` is called. This line will prematurely kill
    the background thread. Your code should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you run your console application, you will see that the thread is aborted
    before the `Thread.Sleep` method is called. Aborting a thread in this way, however,
    is generally not recommended:![How to do it…](img/B05391_07_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Being able to create a background thread is a great way to work on a different
    thread from the main thread while not interfering with the process of the main
    application thread. Another added benefit is that the background thread is terminated
    as soon as the main application thread is completed. This process ensures that
    your application will terminate gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing maximum thread pool size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The thread pool in .NET resides in the `System.Threading.ThreadPool` class.
    Generally, there is a lot of discussion around creating your own threads as opposed
    to using the thread pool. Popular thinking dictates that the thread pool should
    be used for brief jobs. This is because the thread pool is limited in size. There
    are many other processes in the system that will use the thread pool. You therefore
    do not want your application to hog all the threads in the thread pool.
  prefs: []
  type: TYPE_NORMAL
- en: The rule is that you can't set the number of maximum worker or completion threads
    to be less than the number of processors on your computer. You are also not allowed
    to set the maximum worker or completion threads to less than the minimum thread
    pool size.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will read the number of processors on the current computer. Then, we will
    get the minimum and maximum allowable thread pool size, generate a random number
    between the minimum and maximum thread pool size, and set the maximum number of
    threads on the thread pool.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new method called `IncreaseThreadPoolSize()` in the `Recipes` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start by adding the code to read the number of processors on the current machine
    using `Environment.ProcessorCount`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will retrieve the maximum and minimum threads available in the thread
    pool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will generate a random number between the maximum and minimum number
    of threads in the thread pool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now need to attempt to set the maximum number of threads in the thread pool
    by calling the `SetMaxThreads` method and setting it to our new random maximum
    value for the worker threads and the completion port threads. Any requests above
    this maximum number will be queued until the thread pool threads become active
    again. If the `SetMaxThreads` method is successful, the method will return true;
    otherwise, it will return `false`. It is a good idea to ensure that the `SetMaxThreads`
    method is successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Worker threads is the maximum number of worker threads in the thread pool, while
    the completion port threads is the maximum number of asynchronous I/O threads
    in the thread pool.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When you have added all the code in the steps listed, your `IncreaseThreadPoolSize()`
    method should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Head on over to your console application and create a new instance of your
    `Recipe` class, and call the `IncreaseThreadPoolSize()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, run your console application and take note of the output:![How to do
    it…](img/B05391_07_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the console application, we can see that the processor count is `8`. The
    minimum number of thread pool threads, therefore, also equals 8\. We then read
    the maximum thread pool size and generate a random number between the minimum
    and maximum numbers. Lastly, we set the maximum thread pool size to our randomly
    generated minimum and maximum.
  prefs: []
  type: TYPE_NORMAL
- en: While this is only a proof of concept and not something one would do in a production
    application (setting the thread pool to a random number), it clearly illustrates
    the ability to set the thread pool to a value specified by the developer.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code in this recipe was compiled for 32 bit. Try changing your application
    to a 64-bit application and run the code again. See the difference 64 bit makes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating multiple threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we need to create multiple threads. Before we can continue, however,
    we need to wait for these threads to complete doing whatever they need to do.
    For this, the use of tasks is best suited.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure that you have added the `using System.Threading.Tasks;` statement
    to the top of your `Recipes` class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new method called `MultipleThreadWait()` in your `Recipes` class.
    Then, create a second method called `RunThread()` with the `private` modifier,
    which takes an integer of seconds to make the thread sleep. This will simulate
    the process of doing some work for a variable amount of time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In reality, you would probably not call the same method. You could, for all
    intents and purposes, call three separate methods. Here, however, for the sake
    of simplicity, we will call the same method with different sleep durations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following code to your `MultipleThreadWait()` method. You will notice
    that we are creating three tasks that then create three threads. We will then
    fire off these three threads and make them sleep for `3`, `5`, and `2` seconds.
    Finally, we will call the `Task.WaitAll` method to wait before continuing the
    execution of the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, in the `RunThread()` method, we will read the current thread ID and then
    make the thread sleep for the amount of milliseconds supplied. This is just the
    integer value for the seconds multiplied by `1000`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you have completed the code, your `Recipes` class should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add a new instance of the `Recipe` class to your console application
    and call the `MultipleThreadWait()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run your console application and view the output produced:![How to do it…](img/B05391_07_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will notice that three threads (`thread 9`, `thread 10`, and `thread 11`)
    are created. These are then paused by making them sleep for various amounts of
    time. After each thread wakes, the code waits for all three threads to complete
    before continuing the execution of the application code.
  prefs: []
  type: TYPE_NORMAL
- en: Locking one thread until the contended resources are available
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are instances where we want to give sole access to a process to a specific
    thread. We can do this using the `lock` keyword. This will execute this process
    in a thread-safe manner. Therefore, when a thread runs the process, it will gain
    exclusive access to the process for the duration of the lock scope. If another
    thread tries to gain access to the process inside the locked code, it will be
    blocked and have to wait its turn until the lock is released.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this example, we will use tasks. Make sure that you have added the `using
    System.Threading.Tasks;` statement to the top of your `Recipes` class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `Recipes` class, add an object called `threadLock` with the `private`
    modifier. Then, add two methods called `LockThreadExample()` and `ContendedResource()`
    that take an integer of seconds to sleep as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: It is considered a best practice to define the object to lock on as private.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add three tasks to the `LockThreadExample()` method. They will create threads
    that try to access the same section of code simultaneously. This code will wait
    until all the threads have completed before terminating the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `ContendedResource()` method, create a lock using the `private` `threadLock`
    object and then make the thread sleep for the amount of seconds passed to the
    method as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Back in the console application, add the following code to instantiate a new
    `Recipes` class and call the `LockThreadExample()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the console application and see the information output to the console window:![How
    to do it…](img/B05391_07_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can see that `thread 11` gained exclusive access to the contended resource.
    At the same time, `thread 11` and `thread 12` tried to access the contended resource
    locked by `thread 11`. This then caused the other two threads to wait until `thread
    11` had completed and released the lock. The result of this is that the code is
    executed in an orderly manner, as can be seen in the console window output. Each
    thread waits its turn until it can access the resource and lock its thread.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking parallel calls to methods using Parallel.Invoke
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Parallel.Invoke` allows us to execute tasks in (you guessed it) parallel.
    Sometimes, you need to perform operations simultaneously and, in so doing, speed
    up processing. You can therefore expect that the total time taken to process the
    tasks is equal to the longest running process. Using `Parallel.Invoke` is quite
    easy.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure that you have added the `using System.Threading.Tasks;` statement
    to the top of your `Recipes` class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start off by creating two methods in the `Recipes` class called `ParallelInvoke()`
    and `PerformSomeTask()`, which take an integer of seconds to sleep as the parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the `ParallelInvoke()` method. This code will call
    `Paralell.Invoke` to run the `PerformSomeTask()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `PerformSomeTask()` method, make the thread sleep for the amount of
    seconds passed to the method as the parameter (converting the seconds to milliseconds
    by multiplying it by `1000`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you have added all the code, your `Recipes` class should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the console application, instantiate a new instance of the `Recipes` class
    and call the `ParallelInvoke()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the console application and look at the output produced in the console window:![How
    to do it…](img/B05391_07_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because we are running all these threads in parallel, we can assume that the
    longest process will denote the total duration of the all the tasks. This means
    that the total duration of the process will be 5 seconds because the longest task
    will take 5 seconds to complete (we set `thread 10` to sleep for a maximum of
    5 seconds).
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the time difference between the start and the end of `Parallel.Invoke`
    is exactly 5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Using a parallel foreach loop to run multiple threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A while ago, during a work retreat (yes, the company I work for is really that
    cool), Graham Rook, who is one of my colleagues, showed me a parallel `foreach`
    loop. It certainly speeds up processing a great deal. But here's the rub. It makes
    no sense using a parallel `foreach` loop if you're dealing with small amounts
    of data or little tasks. The parallel `foreach` loop excels when there is bulk
    processing to do or huge amounts of data to process.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start off by looking at where the parallel `foreach` loop does not perform
    better than the standard `foreach` loop. For this, we will create a small list
    of 500 items and just iterate over the list, writing the items to the console
    window.
  prefs: []
  type: TYPE_NORMAL
- en: For the second example that illustrates the power of the parallel `foreach`
    loop, we will use the same list and create a file for each item in the list. The
    power and benefit of the parallel `foreach` loop will be evident in the second
    example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start off by creating two methods in the `Recipes` class. Call one method `ReadCollectionForEach()`
    and pass it a parameter of `List<string>`. Create a second method called `ReadCollectionParallelForEach()`
    that also accepts a parameter of `List<string>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `ReadCollectionForEach()` method, add a standard `foreach` loop that
    will iterate over the collection of strings passed to it and write the value it
    finds to the console window. Then, clear the console window. Use a timer to keep
    track of the total seconds elapsed during the `foreach` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the second method, called `ReadCollectionParallelForEach()`, do the same.
    However, instead of using a standard `foreach` loop, add a `Parallel.ForEach`
    loop. You will notice that the `Parallel.ForEach` loop looks slightly different.
    The signature of `Parallel.ForEach` requires that you pass it an enumerable data
    source (`List<string> intCollection`) and define an action, which is the delegate
    that is invoked for every iteration (`integer`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you have added all the required code, your `Recipes` class should look
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the console application, create the `List<string>` collection and pass it
    to the two methods created in the `Recipes` class. You will notice that we are
    only creating a collection of 500 items. After the code is completed, return the
    time elapsed in seconds and output it to the console window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run your application. From the output displayed, you will see that the performance
    gain using the `Parallel.ForEach` loop is negligible. In fact, in this case, the
    `Parallel.ForEach` loop only improved performance by 0.4516 percent:![How to do
    it…](img/B05391_07_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s use a different example now. We will create a process-intensive task
    and measure the performance gain that the `Parallel.ForEach` loop will give us.
    Create two methods called `CreateWriteFilesForEach()` and `CreateWriteFilesParallelForEach()`,
    which both take the `List<string>` collection as the parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the `CreateWriteFilesForEach()` method. This code
    starts the timer and executes the standard `foreach` loop on the `List<string>`
    object. It then writes the elapsed time out to the console window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `foreach` loop, add the code to check whether a file exists with
    the specific name created by appending the `integer` value to the filename portion
    of the `filePath` variable. Create the file (ensuring that you use `Dispose` method
    in order not to lock the file when trying to write to it) and write some text
    to the newly created file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add this code to the `CreateWriteFilesParallelForEach()` method, which
    basically performs the same function as the `CreateWriteFilesForEach()` method,
    but uses a `Parallel.ForEach` loop to create and write files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the slightly modified file-creation code inside the `Parallel.ForEach`
    loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you are done, your code needs to look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Heading over to the console application, modify the `List<string>` object slightly
    and increase the count from `500` to `1000`. Then, call the file methods created
    in the `Recipes` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, when you are ready, make sure that you have the `C:\temp\output` directory
    and that there aren't any other files in that directory. Run your application
    and review the output to the console window. This time round, we can see that
    the `Parallel.ForEach` loop has made a huge difference. The performance gain is
    massive and heralds a 60.7074 percent performance increase over the standard `foreach`
    loop:![How to do it…](img/B05391_07_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the examples used in this recipe, it is clear that the use of the parallel
    `foreach` loop should be considered carefully. If you are dealing with relatively
    low volumes of data or non-process intensive transactions, the parallel `foreach`
    loop will not benefit your application's performance much. In some instances,
    the standard `foreach` loop could be much faster than the parallel `foreach` loop.
    If, however, you find your application running into performance issues when processing
    large amounts of data or running processor-intensive tasks, give the parallel
    `foreach` loop a try. It just might surprise you.
  prefs: []
  type: TYPE_NORMAL
- en: Cancelling a parallel foreach loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When dealing with parallel `foreach` loops, the obvious question is how one
    would terminate the loop prematurely based on a certain condition, such as a timeout.
    As it turns out, the parallel `foreach` loop is quite easy to terminate prematurely.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a method that takes a collection of items and loops through this
    collection in a parallel `foreach` loop. It will also be aware of a timeout value
    that, if exceeded, will terminate the loop and exit the method.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start off by creating a new method called `CancelParallelForEach()` in the
    `Recipes` class, which takes two parameters. One is a collection of `List<string>`,
    while the other is an integer specifying a timeout value. When the timeout value
    is exceeded, the `Parallel.ForEach` loop must terminate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `CancelParallelForEach()` method, add a timer to keep track of the
    elapsed time. This will signal the loop that the timeout threshold has been exceeded
    and that the loop needs to exit. Create the `Parallel.ForEach` method, defining
    a state. In each iteration, check the elapsed time against the timeout, and if
    the time is exceeded, break out of the loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the console application, create the `List<string>` object and add `1000`
    items to it. Call the `CancelParallelForEach()` method with a timeout of only
    `5` seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run your console application and review the output results:![How to do it…](img/B05391_07_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can see from the console window output that as soon as the elapsed time
    exceeded the timeout value, the parallel loop was notified to cease the execution
    of iterations beyond the current iteration at the system's earliest convenience.
    Having this kind of control over the `Parallel.ForEach` loop allows developers
    to avoid runaway loops and give the user control to cancel a loop operation by
    clicking on a button, or automatically having the application terminate when the
    timeout value has been reached.
  prefs: []
  type: TYPE_NORMAL
- en: Catching errors in parallel foreach loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With parallel `foreach` loops, developers can wrap the loop in a `try` `catch`
    statement. Care needs to be taken, however, because the `Parallel.ForEach` will
    throw `AggregatedException`, which has the exceptions it encounters over several
    threads rolled into one.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a `List<string>` object that contains a collection of machine
    IP addresses. The `Parallel.ForEach` loop will check the IP addresses to see whether
    the machines on the other end of the given IP are alive. It does this by pinging
    the IP address. The method that performs the `Parallel.ForEach` loop will also
    be given the minimum required alive machines as an integer value. If the minimum
    number of machines alive is not met, an exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `Recipes` class, add a method called `CheckClientMachinesOnline()` that
    takes as parameters a `List<string>` collection of IP addresses and an integer
    that specifies the minimum number of machines required to be online. Add a second
    method called `MachineReturnedPing()` that will receive an IP address to ping.
    For our purpose, we will just return `false` to mimic a dead machine (the ping
    to the IP address timed out):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `CheckClientMachinesOnline()` method, add the `Parallel.ForEach`
    loop and create the `ParallelOptions` variable, which will specify the degree
    of parallelism. Wrap all this code inside a `try` `catch` statement and catch
    `AggregateException`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `Parallel.ForEach` loop, write the code to check whether the machine
    is online by calling the `MachineReturnedPing()` method. In our example, this
    method will always return `false`. You will notice that we are keeping track of
    the offline machine count via the `Interlocked.Increment` method. This is just
    a way of incrementing a variable across the threads of the `Parallel.ForEach`
    loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you have added all the code correctly, your `Recipes` class will look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the console application, create the `List<string>` object to store a collection
    of dummy IP addresses. Instantiate your `Recipes` class and call the `CheckClientMachinesOnline()`
    method, passing the collection of IP addresses and a minimum number of machines
    required to be online to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run your application and review the output in the console window:![How to do
    it…](img/B05391_07_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the console window output, you can see that the minimum number of machines
    required to be online was not achieved. The application then threw an exception
    and caught it from the `Parallel.ForEach` loop. Being able to handle exceptions
    in parallel loops such as this one is essential to maintain the stability of your
    application by being able to handle exceptions as they occur.
  prefs: []
  type: TYPE_NORMAL
- en: We encourage you to play around a little with the `Parallel.ForEach` loop and
    drill into some of the inner methods of the `AggregareException` class to really
    understand it better.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging multiple threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging multiple threads in Visual Studio is tricky, especially since these
    threads are all running at the same time. Luckily, we have a few tools available
    to us as developers to use to get a better understanding of what is happening
    in our multithreaded applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While debugging multithreaded applications, you can access various windows by
    going to **Debug** | **Windows** in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start debugging your multithreaded application after adding a breakpoint somewhere
    in the code. You can access various debugging windows by going to **Debug** |
    **Windows** in Visual Studio:![How to do it…](img/B05391_07_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first window available to you is the **Threads** window. Access it by going
    to **Debug** | **Windows** in Visual Studio or type *Ctrl* + *Alt* + *H*. In here,
    you can right-click on a thread to watch and flag it. If you have given your threads
    names, you will see that name appear in the **Name** column. To give your thread
    a name, you could add the following code to your application, which runs the method
    on a separate thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will also be able to see the currently active thread in the debugger. It
    will be marked with a yellow arrow. Then, there is the managed ID, which is the
    same ID you would have used to create the unique thread name earlier on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The **Location** column displays the current method that the thread is in.
    The **Threads** window allows you to view the stack of the thread by double-clicking
    on the **Location** field. You can also freeze and thaw threads. Freezing stops
    a thread from executing, while thawing allows the frozen thread to continue as
    normal:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/B05391_07_19.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The **Tasks** window can be accessed by going to **Debug** | **Windows** or
    by holding down *Ctrl* + *Shift* + *D* and then pressing *K*. You will notice
    that the thread you flagged earlier in the **Threads** window is also flagged
    here in the **Tasks** window. The status of the task shows the status at that
    moment and can be **Active**, **Deadlocked**, **Waiting**, **Scheduled**, or **Completed**:![How
    to do it…](img/B05391_07_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Parallel Stacks** window can be accessed by going to **Debug** | **Windows**
    in Visual Studio or by holding down *Ctrl* + *Shift* + *D*, and then pressing
    the *S* key. Here, you can see a graphical view of the tasks and threads. You
    can switch between the **Threads** and **Tasks** view by making a selection in
    the dropdown list in the upper-left corner of the **Parallel Stacks** window:![How
    to do it…](img/B05391_07_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Changing the selection to **Tasks** will show you the current tasks in the debug
    session:![How to do it…](img/B05391_07_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next window, and undoubtedly my favorite is the **Parallel Watch** window.
    It is in fact identical to the standard **Watch** window in Visual Studio, but
    this watches values across all threads in your application. You can type in any
    valid C# expression into **Parallel Watch** and see the values as they are at
    that moment in the debug session. As you can see, we have added the `sleepSeconds`
    variable and the name of the thread to the watch:![How to do it…](img/B05391_07_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Being able to use the debugging tools for multithreaded applications effectively
    in Visual Studio makes it much easier to understand the structure of your application
    and helps you identify possible bugs, bottlenecks, and areas of concern.
  prefs: []
  type: TYPE_NORMAL
- en: We encourage you to learn more about the various debugging windows available
    to you.
  prefs: []
  type: TYPE_NORMAL
