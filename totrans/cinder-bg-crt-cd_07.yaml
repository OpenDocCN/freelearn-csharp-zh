- en: Chapter 7. Working with Images – Real-time Postprocessing and Effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we will talk about basic approaches of using built-in Cinder
    classes for applying effects to still and moving images.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the difference between CPU and GPU image processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying basic effects to images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looping through pixels of an image as well as a movie frame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making use of the pixel-level access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Texture, Surface, and Channel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 5](ch05.html "Chapter 5. Making Use of Images – Loading and Displaying"),
    *Making Use of Images – Loading and Displaying*, we already learned how to load
    an image into Cinder. The following is the essence of the code we used there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With this line of code we load pixels from the `image.jpg` image file into
    the GPU memory. `Texture` is meant for storing the image data but not for manipulating
    or displaying it. To show the image on the screen, we use the following line of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Say we want to do some image processing in between the load and draw stages.
    To process images on the GPU (where the image data is stored by the `Texture`
    objects), we would use shaders. Shaders make use of the OpenGL Shading Language
    and we won't go in detail about this now as it is way outside the scope of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: There is another way of processing the image, that is by loading the image on
    the CPU. To make use of the CPU, we have to use the `Surface` class. It is similar
    to the `Texture` class but the main difference is that it stores the image data
    on the CPU. By loading an image on the CPU, we can do the image processing with
    the C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw a surface, we will need to convert it to a `Texture` instance. It is
    possible to convert the `Surface` data to the `Texture` class instances for drawing
    something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: By performing the preceding code, we create a GPU friendly texture for displaying
    it on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: There is a third image datatype in Cinder, the `Channel` class. If the `Surface`
    class is able to hold red, green, blue, and alpha values in separate channels
    within one object, then `Channel` makes use of just one channel (can hold one
    of the channels mentioned) and can be used to store grayscale images.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to create a `Surface` instance from a `Channel` class by adding
    the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line of code makes it is possible to create a high-quality, grayscale
    image as a `Channel` class instance by passing a `Surface` instance to the `Channel`
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Applying the grayscale effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we already discussed one of the basic effects that
    can be applied in almost every image processing software out there, grayscale.
    Let's create a simple application that loads an image and converts it to grayscale
    by using methods we just discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Open up **TinderBox** and make a new application with the name `BasicEffects`.
    Place an image (let's call it `OurImage.png`, I will be using a simple, digitally
    enhanced hand-drawn sketch from my own archives) in the assets directory of the
    project and open the `xcode/BasicEffects.xcodeproj` project file. Windows users
    can open the `vc10\BasicEffects.sln` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `BasicEfectsApp.cpp` in your editor and include a couple of headers that
    we will need later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now declare the variables/objects of type `Texture` and `Surface` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, load an image into the `surface` object and pass it to the `Texture`
    constructor so we can draw it afterwards (this goes in to the `setup()` method
    implementation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally go to the `draw()` method implementation and add the following lines
    of code to draw the texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Before we draw the texture, we need to make sure that it actually exists.
  prefs: []
  type: TYPE_NORMAL
- en: When you compile and run the project our image should appear on the screen.
    If it does not, make sure that the image really exists in our project's `assets`
    directory and that the image filename argument in the `loadAsset("OurImage.png")`
    is correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have made the very basic structure for image processing on the CPU. To make
    the image in grayscale, we will make use of the `Channel` class. First, we will
    include the `Channel.h` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the `setup()` method implementation, where we load the image, create
    a `Channel` instance from the `Surface` instance and construct the texture by
    using the newly created channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and run the project. The following screenshot is a comparison image
    that shows the difference between the result when we use the `Surface` object
    for constructing a texture and `Channel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying the grayscale effect](img/9564_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The image is automatically converted to grayscale once we pass it to the `Channel`
    constructor and we use the result for creating the texture. You should see it
    yourself when you compile and run the program.
  prefs: []
  type: TYPE_NORMAL
- en: Using threshold
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we are going to use some per-pixel manipulation. We will choose one certain
    threshold value between 0 and 255 and compare each channel of each pixel to that
    value. If the value is above the threshold, we will change the channel value to
    maximum (255). If the value is less, we will change it to the minimum (0).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously we were using floating point numbers from 0 to 1 to describe R, G,
    and B channels. When using `Surface` objects and images in general, you might
    want to know that each pixel of each channel of the `Surface (Surface8u)` object
    consists of 8 bits that can hold 256 values from 0 to 255 if not defined otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: As we are dealing with a still image, we have to do this process only once,
    in the `setup()` methodbetween the `surface` and `texture` object initialization.
    We will make use of a really handy helper class, `Surface::Iter`, that will allow
    us to loop seamlessly through lines (rows) and individual pixels of each line.
  prefs: []
  type: TYPE_NORMAL
- en: 'So this is the code that we have to add to the `setup()` method implementation
    between the `surface` and `texture` variable initialization lines as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: First we define the threshold, all the values above that will be changed to
    255 and all the values below or equal will be changed to 0\. Say goodbye to smooth
    gradients. Next we get the area of the image that we will change. To change the
    whole image, we have to get the bounds of the whole surface. We have to get an
    iterator (`iter`) to construct a nice nested loop afterwards. Finally we use the
    iterator to loop through all the lines (rows) and pixels (columns inside the row)
    of the surface and change it's pixels one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t forget to change the `Texture` initialization (you have to use our `Surface`
    instance again instead of `Channel`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that we initialize the texture after we make changes to the pixels of the
    surface. Every time you make changes to the `Surface` object that you will be
    using as a `Texture` afterwards, you have to reinitialize the `texture` variable
    from the changed `Surface` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and run the project, and see what happens! The following screenshot
    shows the comparison between the source image and the one with our threshold filter
    applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using threshold](img/9564_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Try to experiment a bit by changing the threshold value and the way pixel values
    are being changed before we move on to the next part.
  prefs: []
  type: TYPE_NORMAL
- en: Animating effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s make a simple effect animation by using the tricks we just learned and
    the `update()` method. We have to modify the code in the `setup()` method implementation
    so it looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we have to cut and paste all the code except the `surface` initialization
    to the `update()` method implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With that done, compile and run the project, and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Animating effects](img/9564_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot you can see an animation that looks like some kind
    of acid eating and that transforms all the surfaces of the image.
  prefs: []
  type: TYPE_NORMAL
- en: Applying effects to moving images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just saw how to get moving effects, let's try to add effects to a moving
    image.
  prefs: []
  type: TYPE_NORMAL
- en: Before we do that, it is a good idea to make a copy of our project (`BasicEffects`).
    Let's rename the folder of the new project to `BasicEffectsMotion`. Open the project
    file (`xcode/BasicEffects.xcodeproj` on Ma OS X or `vc10\BasicEffects.sln` on
    Windows).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For Windows users, you will have to add `QTMLClient.lib` and `CVClient.lib`
    to **Linker** | **Input** | **Additional Dependencies** in the project properties.
    You will also have to add path to the QuickTime SDK (`C:\QuickTimeSDK-7.3\Libraries`)
    in **Linker** | **General** | **Additional Library Directories** in the project
    properties. You can access project properties from the menu bar by clicking on
    **Project** | **BasicEffects Properties**.
  prefs: []
  type: TYPE_NORMAL
- en: First we need to find a movie file that we can use. [http://vimeo.com/groups/freehd](http://vimeo.com/groups/freehd)
    seems a good place where you can find free video footage. I found one with a footage
    of an industrial site.
  prefs: []
  type: TYPE_NORMAL
- en: 'Place the movie file in the `assets` folder of the project, open the code editor,
    and start with including the `QuickTime.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In case you are using the AppRewrite version of Cinder, you should know that
    QuickTime has been made as a separate block. Blocks are extensions of Cinder that
    you can add to your project when you need a specific extra functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we have to declare some new variables. Since we have a surface and a texture
    already, we just need to declare a variable for the movie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With that done, let''s move to the `setup()` method part and load the movie
    by adding the following highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we have to copy each frame to a surface and transform that surface to
    a texture so we can draw it on the screen. Let''s move to the `update()` method
    implementation to do that, remove all the previous code and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As loading the movie is an asynchronous process, we have to check if there
    is a surface before we pass it to the texture. In the same way we have to check
    if we have a texture before we draw it. Change the `gl::draw` part in the `draw()`
    method to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We need to make sure that the movie is being drawn within the bounds of our
    application window. We make sure of that by passing the result of the `getWindowBounds()`
    function as the second parameter to the `gl::draw()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and run the project now. You should see the movie playing. Now we are
    going to combine this with the effect we made earlier. Find the place in the `update()`
    method between the `surface` and `texture` initialization (I left a comment `//
    add effects here` there). Add the following code there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As you probably must have already guessed, now we have to declare the `addR`,
    `addG`, and `addB` variables and set their initial values as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and run the project. You should see the colors of the movie changing
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying effects to moving images](img/9564_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Experiment with the `addR`, `addG`, and `addB` values to see what kind of different
    effects you are able to get out of this.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned the basic methods of applying effects to still and
    moving images. It is possible to do a lot more by studying the raw image processing
    algorithms and applying them as per-pixel operations. So if you do that and you
    are able to reproduce most of the image effects that one can find in Photoshop
    or Gimp—congratulations! You may also want to bring your knowledge to the next
    level by learning something about shaders and OpenGL Shading Language.
  prefs: []
  type: TYPE_NORMAL
