- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Dictionaries and Sets
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典和集合
- en: This chapter focuses on data structures related to dictionaries and sets. Applying
    these data structures makes it possible **to map keys to values and perform fast
    lookup**, as well as **to make various operations on sets**. To simplify your
    understanding of dictionaries and sets, this chapter contains illustrations and
    code snippets, along with detailed descriptions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍与字典和集合相关的数据结构。应用这些数据结构使得将键映射到值和快速查找成为可能，以及**在集合上执行各种操作**。为了简化你对字典和集合的理解，本章包含插图、代码片段以及详细的描述。
- en: First, you will learn about both non-generic and generic versions of a **dictionary**,
    which is a collection of pairs, each consisting of a key and a value. Then, a
    **sorted variant** of a dictionary will be presented. The remaining part of this
    chapter will show you how to use **hash sets**, together with a **“sorted” set**
    variant. Is it possible to have a “sorted” set? You’ll learn more later in this
    chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将了解**字典**的非泛型和泛型版本，字典是一个由键值对组成的集合。然后，将介绍字典的**排序变体**。本章的其余部分将向你展示如何使用**哈希集合**以及**“排序”集合**变体。是否可以有“排序”集合？你将在本章的后面了解更多。
- en: 'In this chapter, the following topics will be covered:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将涵盖以下主题：
- en: Hash tables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希表
- en: Dictionaries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典
- en: Sorted dictionaries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序字典
- en: Hash sets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希集合
- en: “Sorted” sets
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “排序”集合
- en: Hash tables
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希表
- en: Let’s start with the first data structure, which is a **hash table**, also known
    as a **hash map**. **It allows you to** **map** **keys to particular values**.
    One of the most important assumptions of the hash table is the possibility of
    **a very fast lookup for a** **value** **based on the** **key**, which should
    be the *O(1)* operation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个数据结构开始，即**哈希表**，也称为**哈希映射**。**它允许你**将**键映射到特定的值**。哈希表最重要的假设之一是基于**键**对**值**进行非常快速查找的可能性，这应该是*O(1)*操作。
- en: Imagine a hash table or a dictionary
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个哈希表或字典
- en: If you want to better imagine a hash table or a dictionary, it would be worth
    thinking about a collection containing a lot of data, where it is crucial to quickly
    check whether the dictionary contains a specific key, as well as quickly retrieve
    the value assigned to a given key. So, think about a system that allows you to
    determine which country a specific IP address comes from. As you know, there are
    many possible IP addresses, and your system must quickly obtain information from
    which country the user’s request comes to select the default language version
    of the application. This is how a hash table and dictionary work! You use an IP
    address as a key (for example, 50.50.50.50) and a country code as a value (for
    example, PL). Thus, you can quickly find out from which country the user came
    to you, without manually browsing the entire collection. I come to you from Poland,
    which I cordially invite you to visit! It contains mountains, sea, lakes, and
    cities with a rich history. All this is waiting here for you!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更好地想象哈希表或字典，值得思考一个包含大量数据的集合，其中快速检查字典是否包含特定的键以及快速检索分配给给定键的值至关重要。所以，想象一个系统，它允许你确定一个特定的IP地址来自哪个国家。正如你所知，有许多可能的IP地址，你的系统必须快速获取信息，以确定用户的请求来自哪个国家，从而选择应用程序的默认语言版本。这就是哈希表和字典的工作方式！你使用IP地址作为键（例如，50.50.50.50）和国家代码作为值（例如，PL）。这样，你可以快速找出用户来自哪个国家，而无需手动浏览整个集合。我来自波兰，我诚挚地邀请您来访问！这里有山脉、大海、湖泊和历史悠久的城市。所有这些都在这里等着你！
- en: To achieve a very fast lookup, a **hash function** is used. It takes the key
    to generate an index of a bucket, where the value can be found. For this reason,
    if you need to find a value of the key, you do not need to iterate through all
    the items in the collection since you can just use the hash function to easily
    locate a proper bucket and get the value. As you can see, the role of the hash
    function is critical and ideally, it should generate a unique result for all keys.
    However, the same result may be generated for different keys. Such a situation
    is called a **hash collision** and should be dealt with.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现非常快速的查找，使用了**哈希函数**。它接受键来生成一个桶的索引，其中可以找到值。因此，如果你需要找到键的值，你不需要遍历集合中的所有项，因为你只需使用哈希函数轻松地定位合适的桶并获取值。正如你所看到的，哈希函数的作用至关重要，理想情况下，它应该为所有键生成一个唯一的结果。然而，不同的键可能会生成相同的结果。这种情况称为**哈希冲突**，应该得到处理。
- en: 'A way of mapping keys to particular values is shown in the following diagram:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了将键映射到特定值的方式：
- en: '![Figure 6.1 – Illustration of mapping keys to particular values](img/B18069_06_1.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 将键映射到特定值的说明](img/B18069_06_1.jpg)'
- en: Figure 6.1 – Illustration of mapping keys to particular values
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 将键映射到特定值的说明
- en: Due to the great performance of hash tables, they are frequently used in many
    real-world applications, such as for **associative arrays**, **database indices**,
    and **cache systems**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于哈希表具有出色的性能，它们在许多实际应用中经常被使用，例如用于**关联数组**、**数据库索引**和**缓存系统**。
- en: The topic of implementing hash tables from scratch seems to be quite difficult,
    especially when it comes to using the hash function, handling hash collisions,
    as well as assigning particular keys to buckets. Fortunately, a suitable implementation
    is available while developing applications in the C# language, and its usage is
    very simple.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从头实现哈希表似乎相当困难，尤其是在使用哈希函数、处理哈希冲突以及将特定的键分配给桶时。幸运的是，在用C#语言开发应用程序时，有一个合适的实现，并且它的使用非常简单。
- en: Non-generic and generic versions
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 非泛型和泛型版本
- en: There are two variants of the hash table-related classes, namely non-generic
    (`Hashtable`) and generic (`Dictionary`). The first will be described in this
    section, while the other will be described in the following section. If you can
    use the strongly typed generic version, I strongly recommend using it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与哈希表相关的类有两种变体，即非泛型（`Hashtable`）和泛型（`Dictionary`）。本节将描述第一种，下一节将描述另一种。如果你可以使用强类型泛型版本，我强烈建议使用它。
- en: Let’s take a look at the `Hashtable` class from the `System.Collections` namespace.
    As mentioned previously, it stores a collection of pairs, where each contains
    a key and a value. A pair is represented by the `DictionaryEntry` instance.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`System.Collections`命名空间中的`Hashtable`类。如前所述，它存储了一组键值对，其中每个都包含一个键和一个值。对是由`DictionaryEntry`实例表示的。
- en: 'Here’s some example code that uses the `Hashtable` class:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些使用`Hashtable`类的示例代码：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'string value = foreach loop to iterate through all pairs stored in the collection,
    as presented here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: string value = foreach循环遍历存储在集合中的所有键值对，如下所示：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The variable that’s used in the loop is of the `DictionaryEntry` type. Therefore,
    you can use its `Key` and `Value` properties to access the key and the value,
    respectively.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中使用的变量是`DictionaryEntry`类型。因此，你可以使用它的`Key`和`Value`属性来分别访问键和值。
- en: 'The `Hashtable` class is equipped with a few properties, such as those for
    getting the number of stored elements (`Count`), as well as returning the collection
    of keys and values (`Keys` and `Values`). You can use the following methods:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hashtable`类配备了一些属性，例如获取存储元素的数量（`Count`），以及返回键和值的集合（`Keys`和`Values`）。你可以使用以下方法：'
- en: '`Add`, which adds a new element'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Add`，用于添加新元素'
- en: '`Remove`, which removes an element'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Remove`，用于移除一个元素'
- en: '`Clear`, which removes all elements'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clear`，用于移除所有元素'
- en: '`ContainsKey`, which checks whether the collection contains a given key'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContainsKey`，用于检查集合是否包含指定的键'
- en: '`ContainsValue`, which checks whether the collection contains a given value'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContainsValue`，用于检查集合是否包含指定的值'
- en: What about performance?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 性能方面如何？
- en: A hash table is an efficient data structure. Retrieving a value by a key, checking
    whether the collection contains a given key, and removing an item by a key are
    the *O(1)* operations. As for addition, if the capacity does not need to be increased,
    it is the *O(1)* operation as well. Otherwise, it is the *O(n)* operation, where
    *n* is the number of items.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表是一种高效的数据结构。通过键检索值、检查集合是否包含指定的键以及通过键移除项都是*O(1)*操作。至于添加，如果不需要增加容量，它也是*O(1)*操作。否则，它是*O(n)*操作，其中*n*是项的数量。
- en: With this short introduction, let’s take a look at an example.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的介绍之后，让我们来看一个例子。
- en: Where can you find more information?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你在哪里可以找到更多信息？
- en: You can find content regarding a hash table at [https://learn.microsoft.com/en-us/dotnet/api/system.collections.hashtable](https://learn.microsoft.com/en-us/dotnet/api/system.collections.hashtable).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://learn.microsoft.com/en-us/dotnet/api/system.collections.hashtable](https://learn.microsoft.com/en-us/dotnet/api/system.collections.hashtable)找到有关哈希表的内容。
- en: Example – phone book
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 – 电话簿
- en: 'As an example, let’s say you create an application for a phone book. The `Hashtable`
    class is used to store entries where the person’s name is a key and the phone
    number is a value, as shown here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This program demonstrates how to add elements to the collection, get the number
    of stored items, iterate through all of them, check whether an element with a
    given key exists, as well as how to get a value based on the key.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create a new instance of the `Hashtable` class, as well as initialize
    it with some entries, as shown in the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Console.WriteLine("Phone numbers:");
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: if (phoneBook.Count == 0)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine("Empty list.");
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: foreach (DictionaryEntry entry in phoneBook)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Console.WriteLine($"{entry.Key}: {entry.Value}");'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Console.Write("\nSearch by name: ");'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: string name = Console.ReadLine() ?? string.Empty;
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: if (phoneBook.ContainsKey(name))
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: string number = (string)phoneBook[name]!;
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Console.WriteLine($"Phone number: {number}");'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: else
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine("Does not exist.");
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Phone numbers:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Marcin: 101-202-303'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Aline: 303-404-505'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'John: 202-303-404'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Search by name: Aline'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Phone number: 303-404-505'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Dictionary<string, string> dictionary = new()
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '{ "Key #1", "Value #1" },'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '{ "Key #2", "Value #2" }'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: string value = dictionarystring type is unnecessary because Dictionary is the
    strongly typed version of the hash table-related classes. Therefore, the returned
    value already has the proper type. If an element with the given key does not exist
    in the collection, KeyNotFoundException is thrown. To avoid problems, you can
    either check whether the element exists (by calling ContainsKey) or use the TryGetValue
    method.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add a new element or update a value of the existing one using the indexer:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: foreach (KeyValuePair<string, string> pair in dictionary)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Console.WriteLine($"{pair.Key}: {pair.Value}");'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: foreach ((string k, string v) in dictionary)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Console.WriteLine($"{k}: {v}");'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: BARCODE -------> AREA
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 5901020304050 -> A1
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 5910203040506 -> B5
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 5920304050607 -> C9
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Dictionary<string, string> products = new()
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '{ "5901020304050", "A1" },'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '{ "5910203040506", "B5" },'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '{ "5920304050607", "C9" }'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: products["5930405060708"] = "D7";
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: string key = "5940506070809";
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: if (!products.ContainsKey(key))
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: products.Add(key, "A3");
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: if (!products.TryAdd(key, "B4"))
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine("Cannot add.");
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Console.WriteLine("All products:");
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: if (products.Count == 0) { Console.WriteLine("Empty."); }
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: foreach ((string k, string v) in products)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Console.WriteLine($"{k}: {v}");'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Console.Write("\nSearch by barcode: ");'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: string barcode = Console.ReadLine() ?? string.Empty;
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: if (products.TryGetValue(barcode, out string? location))
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Console.WriteLine($"The product is in: {location}.");'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: else
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine("The product does not exist.");
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Cannot add.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'All products:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '5901020304050: A1'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '5910203040506: B5'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '5920304050607: C9'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '5930405060708: D7'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '5940506070809: A3'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Search by barcode: 5901020304050'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'The product is in: A1.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ID   ->  FIRST NAME | LAST NAME | PHONE NUMBER
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 100  ->  Marcin     | Jamro     | 101-202-303
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 210  ->  John       | Smith     | 202-303-404
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 303  ->  Aline      | Weather   | 303-404-505
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: public record Employee(string FirstName, string LastName,
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: string PhoneNumber);
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Dictionary<int, Employee> employees = new()
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '{ 100, new Employee("Marcin", "Jamro", "101-202-303") },'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '{ 210, new Employee("John", "Smith", "202-303-404") },'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '{ 303, new Employee("Aline", "Weather", "303-404-505") }'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: do
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Console.Write("Enter the identifier: ");'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: string idString = Console.ReadLine() ?? string.Empty;
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: if (!int.TryParse(idString, out int id)) { break; }
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: if (employees.TryGetValue(id, out Employee? Employee))
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine(
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '"Full name: {0} {1}\nPhone number: {2}\n",'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: employee.FirstName,
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: employee.LastName,
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: employee.PhoneNumber);
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: else { Console.WriteLine("Does not exist.\n"); }
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: while (true);
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Enter the identifier: 100'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Full name: Marcin Jamro'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Phone number: 101-202-303'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the identifier: 101'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Does not exist.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: SortedDictionary<string, string> dictionary = new()
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '{ "Key #1", "Value #1" },'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '{ "Key #2", "Value #2" }'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'dictionary.Add("Key #3", "Value #3");'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'dictionary["Key #4"] = "Value #4";'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'string value = dictionary["Key #1"];'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'dictionary.Count), as well as returning the collection of keys and values (Keys
    and Values, respectively). Moreover, you can use the available methods, which
    include the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '`Add`, which adds a new element'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Remove`, which removes an item'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Clear`, which removes all elements'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ContainsKey`, which checks whether the collection contains a particular key'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ContainsValue`, which checks whether the collection contains a given value'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TryGetValue`, which tries to get a value for a given key'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to iterate through all the pairs stored in the collection, you can
    use the `foreach` loop. The variable that’s used in the loop is an instance of
    `KeyValuePair` with `Key` and `Value` properties, allowing you to access the key
    and the value.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: What about performance?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Despite the automatic sorting advantages, the `SortedDictionary` class has some
    performance drawbacks compared to `Dictionary` because retrieval, insertion, and
    removal are the *O(log n)* operations, where *n* is the number of elements in
    the collection, instead of *O(1)*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, `SortedDictionary` is quite similar to `SortedList`, as described
    in [*Chapter 3*](B18069_03.xhtml#_idTextAnchor088), *Arrays and Sorting*. However,
    it differs in memory-related and performance-related results. The retrieval for
    both these classes is the *O(log n)* operation, but insertion and removal for
    unsorted data is *O(log n)* for `SortedDictionary` and *O(n)* for `SortedList`.
    Of course, more memory is necessary for `SortedDictionary` than for `SortedList`.
    As you can see, choosing a proper data structure is not an easy task and you should
    think carefully about the scenarios in which data structures are used and take
    into account both the pros and cons.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: With this short introduction, let’s see the sorted dictionary in action.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Example – encyclopedia
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let’s create a simple encyclopedia where you can add entries
    and show their full content. The encyclopedia can contain millions of entries,
    so it is crucial to provide its users with the possibility of browsing entries
    in the correct order, alphabetically by keys, as well as finding entries quickly.
    For this reason, the sorted dictionary is a good choice.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept of the encyclopedia is shown here:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When the program is launched, it presents a simple menu with two options, namely
    `[A]dd` and `[L]ist`. After pressing *A*, the application asks you to enter the
    key and explanation for the entry. If the provided data is correct, a new entry
    is added to the encyclopedia. If the user presses *L*, data of all entries, sorted
    by keys, is presented in the console. When any other key is pressed, additional
    confirmation is shown and, if confirmed, the program exits.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: First, a new instance of the `SortedDictionary` class is created, which represents
    a collection of pairs with `string`-based keys and `string`-based values. Then,
    the infinite `do-while` loop is used. Within it, the program waits until the user
    presses any key. If it is the *A* key, a key and an explanation of the entry are
    obtained from the values entered by the user. Then, a new entry is added to the
    dictionary using the indexer. Thus, if the entry with the same key already exists,
    it will be updated. In the case of pressing the *L* key, a `foreach` loop is used
    to show all entered entries. When any other key is pressed, another question is
    presented to the user and the program waits for confirmation. If the user presses
    *Y*, you break out of the loop.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the program, you can enter a few entries, as well as present them.
    The result from the console can be similar to what’s shown in the following block:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So far, you’ve learned about three dictionary-related classes, namely `Hashtable`,
    `Dictionary`, and `SortedDictionary`. To make understanding them easier, a few
    examples were presented, together with detailed explanations.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: However, do you know that some other data structures store just keys, without
    values? You will learn about these in the next sections.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Hash sets
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: In many algorithms, it is necessary to perform operations on sets with various
    data. However, what is a **set**? **A set is a collection of distinct objects
    without duplicated elements and without a particular order.** Therefore, you can
    only get to know whether a given element is in the set or not. These sets are
    strictly connected with mathematical models and operations, such as union, intersection,
    subtraction, and symmetric difference. A set can store various data, such as integer
    or string values. Of course, you can also create a set with instances of a user-defined
    class or record, as well as add and remove elements from the set at any time.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a hash set
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: If you want to better visualize a hash set, think for a moment about the game
    of chance, which is popular in many countries and involves selecting a few numbers
    that are then drawn from among many available ones. Depending on how many numbers
    you got from those drawn, you receive a prize. Of course, the chance of matching
    all the drawn numbers is very, very small. Now, you may be wondering where these
    collections are here. I’m in a hurry to answer this! There are three sets here,
    namely a set of all available numbers, a set of randomly drawn numbers, and a
    set of numbers selected by you. Each set cannot contain any duplicates. Of course,
    both the set of randomly drawn numbers and the set of numbers you choose are subsets
    of the set of all available numbers. How can you check how many numbers you have
    chosen correctly? It is very easy! Just perform the “intersection” operation on
    two sets, namely the set of randomly selected numbers and the set of numbers you
    selected, to obtain the result set. Now, all you have to do is keep your fingers
    crossed that the number of elements in this result set matches the number of elements
    in the set of drawn numbers. If that happens, then... you may become very rich
    because you matched all the drawn numbers. If so, congratulations!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更好地可视化哈希集合，不妨想想在许多国家流行的机会游戏，该游戏涉及从许多可用的数字中选择几个数字，然后从这些数字中抽取。根据你从抽取的数字中得到的数量，你将获得奖品。当然，匹配所有抽取数字的机会非常非常小。现在，你可能想知道这些集合在这里。我急于回答这个问题！这里有三个集合，即所有可用数字的集合、随机抽取数字的集合以及你选择的数字的集合。每个集合都不能包含任何重复项。当然，随机抽取数字的集合和你选择的数字的集合都是所有可用数字集合的子集。你如何检查你选择了多少个正确的数字呢？这非常简单！只需对两个集合执行“交集”操作，即随机选择的数字的集合和你选择的数字的集合，以获得结果集。现在，你只需要祈祷这个结果集中的元素数量与抽取数字的集合中的元素数量相匹配。如果那样的话，那么...你可能会变得非常富有，因为你匹配了所有抽取的数字。如果是这样，恭喜你！
- en: 'Two exemplary sets are presented in the following figure:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图中展示了两个示例集合：
- en: '![Figure 6.2 – Illustration of sets with integer and string values](img/B18069_06_2.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 整数和字符串值集合的示意图](img/B18069_06_2.jpg)'
- en: Figure 6.2 – Illustration of sets with integer and string values
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 整数和字符串值集合的示意图
- en: Before seeing sets in action, it is a good idea to remind you of some basic
    operations that can be performed on two sets, named **A** and **B**.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到集合的实际应用之前，提醒您一些可以在两个集合上执行的基本操作是个好主意，这两个集合被命名为**A**和**B**。
- en: 'The **union** (shown on the left of the following figure as **A****∪****B**)
    is **a set with all elements that** **belong to A or B**. The **intersection**
    (presented on the right as **A****∩****B**) **contains only the elements that
    belong to both A** **and B**:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**并集**（如下面的图中左侧所示为**A ∪ B**）是**包含属于A或B的所有元素的集合**。**交集**（如下面的图中右侧所示为**A ∩ B**）**仅包含属于A和B的元素**：'
- en: '![Figure 6.3 – Illustration of set union and intersection](img/B18069_06_3.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 集合并集和交集的示意图](img/B18069_06_3.jpg)'
- en: Figure 6.3 – Illustration of set union and intersection
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 集合并集和交集示意图
- en: 'Another common operation is set **subtraction**. **The result set of A \ B
    contains elements that are the members of A and not the members of B**. In the
    following figure, two examples are shown, namely **A \ B** and **B \** **A**:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的操作是**集合减法**。**集合A \ B的结果集包含属于A但不属于B的元素**。在下面的图中，展示了两个示例，即**A \ B**和**B
    \ A**：
- en: '![Figure 6.4 – Illustration of set subtraction](img/B18069_06_4.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – 集合减法示意图](img/B18069_06_4.jpg)'
- en: Figure 6.4 – Illustration of set subtraction
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 集合减法示意图
- en: 'While performing various operations on sets, it is also worth mentioning the
    **symmetric difference**, shown in the following figure as **A ∆ B**. The final
    set can be interpreted as a union of two sets, namely (**A \ B**) and (**B \ A**).
    Therefore, **it contains elements that belong to only one set, either A or B**.
    The elements that belong to both sets are excluded from the result:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在对集合执行各种操作时，也值得提一下**对称差集**，如下面的图中所示为**A ∆ B**。最终的集合可以解释为两个集合的并集，即（**A \ B**）和（**B
    \ A**）。因此，**它包含仅属于一个集合的元素，要么是A，要么是B**。属于两个集合的元素被排除在结果之外：
- en: '![Figure 6.5 – Illustration of set symmetric difference and the relationships
    between sets](img/B18069_06_5.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5 – 集合对称差集和集合之间的关系示意图](img/B18069_06_5.jpg)'
- en: Figure 6.5 – Illustration of set symmetric difference and the relationships
    between sets
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 集合对称差集和集合之间的关系示意图
- en: Another important topic is the **relationship** between sets. **If every element
    of B belongs to A, this means that B is a** **subset** **of A**. This is shown
    in the preceding diagram, on the right. At the same time, **A is a** **superset**
    **of B**. Moreover, **if B is a subset of A, but B is not equal to A, B is a**
    **proper subset** **of A**, and **A is a** **proper superset****of B**.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的话题是集合之间的**关系**。**如果集合B的每个元素都属于集合A，这意味着B是A的** **子集** **。这在前面的图中右侧所示。同时，**A是B的**
    **超集** **。此外，**如果B是A的子集，但B不等于A，那么B是A的** **真子集** **，而A是B的** **真超集** **。
- en: While developing various kinds of applications in the C# language, you can benefit
    from high-performance operations provided by the `HashSet` class from the `System.Collections.Generic`
    namespace. The class contains a few properties, including `Count`, which returns
    the number of elements in the set.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发C#语言的各类应用时，你可以从`System.Collections.Generic`命名空间中`HashSet`类提供的高性能操作中受益。该类包含一些属性，包括`Count`，它返回集合中元素的数量。
- en: Where can you find more information?
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你在哪里可以找到更多信息？
- en: You can find content regarding a hash set at [https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.hashset-1](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.hashset-1).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.hashset-1](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.hashset-1)找到有关哈希集合的内容。
- en: Moreover, you can use many methods to perform operations of sets. The first
    group of methods makes it possible to modify the current set (on which the method
    is called) to create the union (`UnionWith`), the intersection (`IntersectWith`),
    the subtraction (`ExceptWith`), and the symmetric difference (`SymmetricExceptWith`)
    with the set passed as the parameter.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以使用许多方法来执行集合操作。第一组方法使得可以修改当前集合（方法被调用的集合）以创建与作为参数传递的集合的并集（`UnionWith`）、交集（`IntersectWith`）、差集（`ExceptWith`）和对称差集（`SymmetricExceptWith`）。
- en: You can also check the relationship between two sets, such as checking whether
    the current set (on which the method is called) is a subset (`IsSubsetOf`), a
    superset (`IsSupersetOf`), a proper subset (`IsProperSubsetOf`) or a proper superset
    (`IsProperSupersetOf`) of the set passed as the parameter.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以检查两个集合之间的关系，例如检查当前集合（方法被调用的集合）是否是作为参数传递的集合的子集（`IsSubsetOf`）、超集（`IsSupersetOf`）、真子集（`IsProperSubsetOf`）或真超集（`IsProperSupersetOf`）。
- en: Furthermore, you can verify whether two sets contain the same elements (`SetEquals`)
    or whether two sets have at least one common element (`Overlaps`).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以验证两个集合是否包含相同的元素（`SetEquals`）或者两个集合是否至少有一个共同元素（`Overlaps`）。
- en: Apart from these operations, you can add a new element to the set (`Add`), remove
    a particular element (`Remove`), remove all elements (`Clear`), and check whether
    the given element exists in the set (`Contains`).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些操作之外，你还可以向集合添加新元素（`Add`）、移除特定元素（`Remove`）、移除所有元素（`Clear`）以及检查给定元素是否存在于集合中（`Contains`）。
- en: What about performance?
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 性能如何？
- en: Hash sets make it possible to perform a quick lookup for a given item. Thus,
    checking whether the set contains an item and removing an item are *O(1)* operations.
    As for addition, it is an *O(1)* operation if it does not need to increase the
    internal array. If resizing is necessary, it turns out to be the *O(n)* operation,
    where *n* is the number of items.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希集合使得对给定项的快速查找成为可能。因此，检查集合是否包含项以及删除项的操作是*O(1)*操作。至于添加，如果不需要增加内部数组，它也是一个*O(1)*操作。如果需要调整大小，它将变成*O(n)*操作，其中*n*是项的数量。
- en: With this introduction, try to put what you’ve learned into practice. Now, let’s
    proceed to two examples that show how you can apply hash sets in your applications.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个介绍，尝试将你所学的知识应用到实践中。现在，让我们来看两个示例，展示你如何在应用中应用哈希集合。
- en: Example – coupons
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 – 优惠券
- en: The first example represents a system that checks whether a one-time coupon
    has already been used. If so, a suitable message is presented to the user. Otherwise,
    the system informs the user that the coupon is valid. It is then marked as used
    and cannot be used again. Due to the high number of coupons, it is necessary to
    choose a data structure that allows you to quickly check whether an element exists
    in a collection. For this reason, a hash set has been chosen as a data structure
    for storing identifiers of used coupons.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例表示一个系统，用于检查一次性优惠券是否已被使用。如果是，则向用户显示一条合适的信息。否则，系统通知用户优惠券有效。然后，将其标记为已使用，并且不能再使用。由于优惠券数量众多，需要选择一个允许您快速检查集合中是否存在元素的数结构。因此，选择了哈希集合作为存储已使用优惠券标识符的数据结构。
- en: 'Let’s take a look at the code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码：
- en: '[PRE27]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: First, a new instance of `HashSet` that stores integer values is created. Then,
    the majority of operations are performed within the `do-while` loop. Here, the
    program waits until the user enters the coupon identifier. If it cannot be parsed
    to the integer value, you break out of the loop. Otherwise, you check whether
    the set already contains the coupon identifier (using the `Contains` method).
    If so, the suitable information is presented in the console. If it does not exist,
    you add it to the collection of used coupons (using the `Add` method) and inform
    the user about the result.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建了一个新的`HashSet`实例，用于存储整数值。然后，大多数操作都在`do-while`循环内执行。在这里，程序会等待用户输入优惠券标识符。如果无法将其解析为整数值，则跳出循环。否则，检查集合中是否已包含该优惠券标识符（使用`Contains`方法）。如果是，则在控制台显示合适的信息。如果不存在，则使用`Add`方法将其添加到已使用优惠券的集合中，并通知用户结果。
- en: 'When you break out of the loop, you just need to show the complete list of
    identifiers of the used coupons. You can do so using a `foreach` loop, iterating
    over the set, and writing its elements in the console, as shown in the following
    code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当您跳出循环时，只需显示已使用优惠券的完整标识符列表。您可以使用`foreach`循环遍历集合，并在控制台写入其元素，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, you can launch the application, enter some data, and see how it works:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以启动应用程序，输入一些数据，看看它是如何工作的：
- en: '[PRE29]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is the end of the first example. Let’s proceed to the next one, where you
    will see a more complex solution that uses a hash set.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个示例的结束。让我们继续下一个示例，您将看到一个更复杂的解决方案，它使用哈希集合。
- en: Example – swimming pools
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 – 游泳池
- en: This example presents the system for a SPA center with four swimming pools,
    namely recreation, competition, thermal, and for kids. Each visitor receives a
    special wristband that allows them to enter all the pools. However, it is necessary
    to scan the wristband upon each user entering any pool. Your program uses such
    data to create various statistics.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了拥有四个游泳池的SPA中心的系统，分别是休闲、竞技、温泉和儿童游泳池。每位访客都会收到一条特殊的手环，允许他们进入所有游泳池。然而，每次用户进入任何游泳池时都需要扫描手环。您的程序使用这些数据来创建各种统计信息。
- en: A hash set has been chosen as a data structure for storing unique numbers of
    wristbands that are scanned at the entrance to each swimming pool. Four sets are
    used, one per pool. Moreover, they are grouped in the dictionary to simplify and
    shorten the code, as well as make future modifications easier. To simplify testing
    the application, the initial data is set randomly. Then, you create statistics,
    namely the number of visitors by pool type, the most popular pool, the number
    of people who visited at least one pool, as well as the number of people who visited
    all the pools.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储在每个游泳池入口扫描的独特手环编号，选择了哈希集合作为数据结构。每个游泳池使用一个集合。此外，它们被分组在字典中，以简化并缩短代码，同时使未来的修改更加容易。为了简化应用程序的测试，初始数据被随机设置。然后，创建统计信息，即按游泳池类型统计的游客数量、最受欢迎的游泳池、至少访问过一次游泳池的人数，以及访问过所有游泳池的人数。
- en: 'Let’s start with the `PoolTypeEnum` enumeration, which represents possible
    types of swimming pools:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`PoolTypeEnum`枚举开始，它表示游泳池的可能类型：
- en: '[PRE30]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, open `Program.cs` and add the `random` variable. This will be used to
    fill the hash set with some random values. The line of code is as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开`Program.cs`文件并添加`random`变量。这将用于用一些随机值填充哈希集合。代码行如下：
- en: '[PRE31]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the next part of the code, you create a new instance of `Dictionary`. This
    contains four entries. Each key is of the `PoolTypeEnum` type and each value is
    of the `HashSet<int>` type – that is, a set with integer values. The code is shown
    here:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的下一部分，你创建`Dictionary`的新实例。它包含四个条目。每个键是`PoolTypeEnum`类型，每个值是`HashSet<int>`类型——即一个包含整数值的集合。代码如下所示：
- en: '[PRE32]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After that, you fill the sets with random values, as shown here:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你将集合填充随机的值，如下所示：
- en: '[PRE33]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To do so, you use two loops, namely `for` and `foreach`. The first iterates
    `100` times and simulates `100` wristbands. Within it, there is a `foreach` loop,
    which iterates through all available pool types. For each of them, you randomly
    check whether a visitor entered a particular swimming pool. If so, the identifier
    is added to the proper set.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，你使用两个循环，即`for`和`foreach`。第一个循环`100`次并模拟`100`个手环。在其中，有一个`foreach`循环，它遍历所有可用的游泳池类型。对于每一个，你随机检查访问者是否进入了一个特定的游泳池。如果是，该标识符将被添加到相应的集合中。
- en: 'The remaining code is related to generating various statistics. First, let’s
    present the number of visitors by pool type. Such a task is very easy because
    you just need to iterate through the dictionary, as well as write the pool type
    and the number of elements in the set (using the `Count` property), as shown here:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的代码与生成各种统计信息相关。首先，让我们展示按游泳池类型划分的访问者数量。这样的任务非常简单，因为你只需要遍历字典，以及写出游泳池类型和集合中的元素数量（使用`Count`属性），如下所示：
- en: '[PRE34]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The next part finds the swimming pool with the maximum number of visitors.
    This is done using a few extension methods, namely to order the results by the
    number of elements in the set, in descending order (`OrderByDescending`), to choose
    only a pool type (`Select`), and to take only the first element (`FirstOrDefault`).
    Then, you just present the result. The code for doing this is shown here:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分是找到访问人数最多的游泳池。这是通过使用几个扩展方法来完成的，即按集合中的元素数量降序排序（`OrderByDescending`），仅选择池类型（`Select`），以及仅取第一个元素（`FirstOrDefault`）。然后，你只需展示结果。完成此操作的代码如下所示：
- en: '[PRE35]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, you want to get the number of people who visited at least one pool. You
    perform this task by creating a union of all sets and getting the count of the
    final set. First, you create a new set and fill it with identifiers regarding
    the recreation swimming pool. In the following lines of code, you call the `UnionWith`
    method to create a union with the following three sets:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你想要得到至少访问过至少一个游泳池的人数。你通过创建所有集合的并集并获取最终集合的计数来完成这个任务。首先，你创建一个新的集合，并用关于休闲游泳池的标识符填充它。在下面的代码行中，你调用`UnionWith`方法来创建与以下三个集合的并集：
- en: '[PRE36]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The last statistic is the number of people who visited all pools during one
    visit to the SPA center. You just need to create the intersection of all sets
    and get the count of the final set. To do so, you create a new set and fill it
    with identifiers regarding the recreation swimming pool. Then, you call the `IntersectWith`
    method to create an intersection with the following three sets. Finally, you get
    the number of elements in the set using the `Count` property and present the results,
    as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个统计指标是访问SPA中心时访问所有游泳池的人数。你只需要创建所有集合的交集并获取最终集合的计数。为此，你创建一个新的集合，并用关于休闲游泳池的标识符填充它。然后，你调用`IntersectWith`方法来创建与以下三个集合的交集。最后，你使用`Count`属性获取集合中的元素数量并展示结果，如下所示：
- en: '[PRE37]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'That’s all! When you run the application, you may receive the following result:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 那就结束了！当你运行应用程序时，你可能会得到以下结果：
- en: '[PRE38]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You’ve just completed two examples regarding hash sets. It’s a good idea to
    try to modify the code and add new features on your own to learn more about this
    data structure. In the next section, we’ll look at “sorted” sets.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚完成了关于哈希集合的两个示例。尝试修改代码并添加新功能以学习更多关于这种数据结构的知识是个好主意。在下一节中，我们将查看“排序”集合。
- en: “Sorted” sets
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: “排序”集合
- en: The previously described `HashSet` class can be understood as a dictionary that
    stores only keys, without values. So, if there is the `SortedDictionary` class,
    maybe there is also the `SortedSet` class? There is! However, can a set be “sorted”?
    Why is “sorted” written with quotation marks? The answer turns out to be very
    simple. By definition, a set stores a collection of distinct objects without duplicated
    elements and without a particular order. If a set does not support order, how
    can it be “sorted”? For this reason, **a “sorted” set can be understood as a combination
    of** **HashSet** **and** **SortedList****, not a** **set itself.**
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 之前描述的`HashSet`类可以理解为只存储键而不存储值的字典。所以，如果存在`SortedDictionary`类，也许也存在`SortedSet`类？是的！然而，集合可以“排序”吗？为什么“排序”用引号括起来？答案非常简单。根据定义，集合存储一组不同的对象，没有重复的元素，也没有特定的顺序。如果集合不支持顺序，那么它如何“排序”？因此，**“排序”集合可以理解为**
    **HashSet** **和** **SortedList** **的组合**，而不是**集合本身**。
- en: Imagine a “sorted” set
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个“排序”集合
- en: If you want to better imagine a “sorted” set, recall the previous example related
    to the game of chance. To facilitate manual comparison of results, both the set
    of randomly drawn numbers and the set of numbers selected by you can be “sorted”
    and shown in ascending order. This is where a “sorted” set comes in handy. It’s
    very simple and clear, don’t you think?
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想更好地想象“排序”集合，请回忆与机会游戏相关的先前示例。为了便于手动比较结果，随机抽取的数字集合和您选择的数字集合都可以“排序”并按升序显示。这就是“排序”集合派上用场的地方。它非常简单明了，不是吗？
- en: A “sorted” set can be used if you want to have a `SortedSet` and is available
    in the `System.Collections.Generic` namespace.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要使用`SortedSet`并且它在`System.Collections.Generic`命名空间中可用，则可以使用“排序”集合。
- en: Where can you find more information?
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在哪里找到更多信息？
- en: You can find content regarding a "sorted" set at [https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.sortedset-1](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.sortedset-1).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.sortedset-1](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.sortedset-1)找到有关“排序”集合的内容。
- en: It has a set of methods, similar to those already described in the case of the
    `HashSet` class, including `UnionWith`, `IntersectWith`, `ExceptWith`, `SymmetricExceptWith`,
    `Overlaps`, `IsSubsetOf`, `IsSupersetOf`, `IsProperSubsetOf`, and `IsProperSupersetOf`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一组方法，类似于在`HashSet`类的情况下已经描述的方法，包括`UnionWith`、`IntersectWith`、`ExceptWith`、`SymmetricExceptWith`、`Overlaps`、`IsSubsetOf`、`IsSupersetOf`、`IsProperSubsetOf`和`IsProperSupersetOf`。
- en: It contains additional properties for returning the minimum and maximum values
    (`Min` and `Max`, respectively). It is also worth mentioning the `GetViewBetween`
    method since it returns a `SortedSet` instance with values from the given range.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含额外的属性，用于返回最小和最大值（分别为`Min`和`Max`）。还值得一提的是`GetViewBetween`方法，因为它返回一个包含给定范围内值的`SortedSet`实例。
- en: What about performance?
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 性能如何？
- en: The “sorted” set is an interesting data structure in terms of its performance.
    It is a kind of a trade-off between functionalities and performance. Thus, checking
    whether the collection contains an item as well as removing any item from the
    collection are *O(log n)* operations. For this reason, you should expect worse
    performance results compared to the data structures described earlier.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能方面，“排序”集合是一个有趣的数据结构。它是在功能性和性能之间的一种权衡。因此，检查集合中是否包含一个项目以及从集合中删除任何项目都是*O(log
    n)*操作。因此，您应该预期与前面描述的数据结构相比，性能结果会更差。
- en: Let’s proceed to a simple example to see how to use a “sorted” set in code.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续一个简单的例子，看看如何在代码中使用“排序”集合。
- en: Example – removing duplicates
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 - 删除重复项
- en: As an example, you will create a simple application that removes duplicates
    from the list of names. Of course, the comparison of names should be case-insensitive,
    so it is not allowed to have both `Marcin` and `marcin` in the same collection.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您将创建一个简单的应用程序，用于从姓名列表中删除重复项。当然，姓名的比较应该是大小写不敏感的，因此不允许在同一个集合中同时有`Marcin`和`marcin`。
- en: 'To do this, we can use the following code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们可以使用以下代码：
- en: '[PRE39]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: First, a list of names is created and initialized with nine elements, including
    `Marcin` and `marcin`. Then, a new instance of the `SortedSet` class is created
    and two parameters are passed to the constructor, namely the list of names and
    the case-insensitive comparer. Finally, the collection is iterated through so
    that you can write names in the console.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建并初始化一个包含九个元素的名称列表，包括`Marcin`和`marcin`。然后，创建`SortedSet`类的一个新实例，并将列表和大小写不敏感的比较器作为参数传递给构造函数。最后，遍历集合以便你可以在控制台写入名称。
- en: 'When you run the application, you’ll see the following result:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行应用程序时，你会看到以下结果：
- en: '[PRE40]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Do you know that you can use another variant of the `SortedSet` constructor
    and pass only the first parameter, namely the list, without the comparer? In such
    a case, the default comparer will be used and will be case-sensitive.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道你可以使用`SortedSet`构造函数的另一种变体，并只传递第一个参数，即列表，而不传递比较器吗？在这种情况下，将使用默认的比较器，并且是大小写敏感的。
- en: Congratulations – you’ve just completed the last example shown in this chapter!
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你——你刚刚完成了本章最后展示的示例！
- en: Summary
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter focused on hash tables, dictionaries, and sets. All of these collections
    are interesting data structures that can be used in various scenarios during the
    development of many applications. By presenting such collections with detailed
    descriptions, performance explanations, and examples, you saw that choosing a
    proper data structure is not a trivial task and requires analyzing performance-related
    topics.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了哈希表、字典和集合。所有这些集合都是有趣的数据结构，可以在开发许多应用程序的各种场景中使用。通过详细描述、性能解释和示例，你看到选择合适的数据结构并非易事，需要分析性能相关的话题。
- en: First, you learned how to use two variants of a **hash table**, namely non-generic
    and generic. The huge advantage of these is a very fast lookup for a value based
    on the key, which is the close *O(1)* operation. To achieve this goal, the hash
    function is used. Moreover, the **sorted dictionary** was introduced as an interesting
    solution to solve the problem of unsorted items in the collection and to keep
    keys sorted all the time.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你学习了如何使用两种**哈希表**的变体，即非泛型和泛型。这些的优点是，基于键的值查找非常快，接近*O(1)*操作。为了实现这个目标，使用了哈希函数。此外，**排序字典**被引入作为一种有趣的解决方案，用于解决集合中未排序项的问题，并始终保持键的排序。
- en: Afterward, the high-performance solution to **set operations** was presented.
    A set can be understood as a collection of distinct objects without duplicated
    elements and without a particular order. The class that was shown makes it possible
    to perform various operations on sets, such as union, intersection, subtraction,
    and symmetric difference. Then, the concept of the **“sorted” set** was introduced
    as a sorted collection of distinct objects without duplicated elements.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，介绍了**集合操作**的高性能解决方案。集合可以理解为没有重复元素且没有特定顺序的独立对象的集合。所展示的类使得可以在集合上执行各种操作，例如并集、交集、减法和对称差集。然后，介绍了**“排序”集合**的概念，即没有重复元素的独立对象的排序集合。
- en: Do you want to dive deeper into the topic of data structures and algorithms
    while developing applications in the C# language? If so, proceed to the next chapter,
    where **trees** are presented.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否想在用C#语言开发应用程序的同时，深入探讨数据结构和算法这一主题？如果是的话，请继续阅读下一章，其中将介绍**树**。
- en: '[PRE41]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
