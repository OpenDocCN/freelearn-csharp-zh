<html><head></head><body>
		<div><h1 id="_idParaDest-66" class="chapter-number"><a id="_idTextAnchor095"/>3</h1>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor096"/>Pure Functions and Side Effects</h1>
			<p>Welcome to <a href="B21069_03.xhtml#_idTextAnchor095"><em class="italic">Chapter 3</em></a>! Here, we’ll dive deep into the world of pure functions in C#. This chapter is all about helping you understand the concept of pure functions, their practical application, and how to use them effectively in your code.</p>
			<p>Here’s a quick breakdown of what to expect:</p>
			<ul>
				<li>Understanding pure functions</li>
				<li>Side effects</li>
				<li>Strategies to minimize side effects</li>
				<li>Marking pure functions with the <code>Pure</code> attribute</li>
			</ul>
			<p>As you move through the content, keep an eye out for actionable insights and data-driven recommendations. Approach this chapter with an eagerness to learn; by the end, you’ll have a solid foundation to write efficient and clean C# programs.</p>
			<p>As I recommended in the previous chapter, I propose that you check your level of knowledge and look at the following three tasks. If you have any doubts about how to solve them, it is better to read this chapter right now. And if you are 100% sure that you can solve them with your eyes closed, maybe it will be more beneficial to proceed with the less familiar topics for now. Let’s jump right in!</p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor097"/>Task 1 – Refactoring to a pure function</h1>
			<p>Steve’s tower <a id="_idIndexMarker125"/>defense game calculates damage based on a global difficulty modifier. Refactor this function to make it pure:</p>
			<pre class="source-code">
public double _difficultyModifier = 1.0;
public double CalculateDamage(Tower tower, Enemy enemy)
{
     return tower.BaseDamage * enemy.DamageMultiplier * _difficultyModifier;
}<a id="_idTextAnchor098"/></pre>			<h1 id="_idParaDest-69"><a id="_idTextAnchor099"/>Task 2 – Isolating side effects</h1>
			<p>The game <a id="_idIndexMarker126"/>loads enemy data from a file, processes it, and updates the game state. Refactor this function to isolate its side effects:</p>
			<pre class="source-code">
public void LoadAndProcessEnemyData(string filePath)
{
     string jsonData = File.ReadAllText(filePath);
     List&lt;Enemy&gt; enemies = JsonConvert.DeserializeObject&lt;List&lt;Enemy&gt;&gt;(jsonData);
     foreach (var enemy in enemies)
     {
                  enemy.Health *= GameState.DifficultyLevel;
                  GameState.ActiveEnemies.Add(enemy);
     }
     Console.WriteLine($"Loaded {enemies.Count} enemies");
<a id="_idTextAnchor100"/>}</pre>			<h1 id="_idParaDest-70"><a id="_idTextAnchor101"/>Task 3 – Using a Pure attribute</h1>
			<p>Refactor the <a id="_idIndexMarker127"/>following method by making it a pure function and marking it with the <code>Pure</code> attribute:</p>
			<pre class="source-code">
public string GenerateEnemyCode(string enemyType, int level)
{
     var code = enemyType.Substring(0, 3) + level.ToString();
     return new string(code.OrderBy(c =&gt; c).ToArray());
}</pre>			<p>If these tasks are easy, you might want to consider reading topics that are new to you first. If you have any questions or are not sure about the correct answers, don’t worry – next, we’ll dive into the concept of pure functions and side effects while using the characters from <a id="_idIndexMarker128"/>the previous chapter – Julia and Steve.</p>
			<p>A week later, Julia called Steve and said that if he wanted to continue learning functional programming, he needed to understand the logic of pure functions and side effects.</p>
			<p>Julia: <em class="italic">Pure functions are functions that have deterministic output and no observable side effects – in other words, no actions happen outside the given scope of a function. This makes them predictable and easy to test, as well as key attributes for efficient software development. In C# code, we do this through the use of immutability and keywords such as </em><code>readonly</code><em class="italic">, </em><code>const</code><em class="italic">, and </em><code>static</code><em class="italic">. Also, there is a special attribute for marking </em><em class="italic">pure functions.</em></p>
			<p>Steve: <em class="italic">Wow! This is all very exciting, but I don’t understand any of it. Could you give me something to read </em><em class="italic">about it?</em></p>
			<p>Julia gave him articles and Steve began to re<a id="_idTextAnchor102"/>ad.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor103"/>Understanding pure functions</h1>
			<p>Pure functions <a id="_idIndexMarker129"/>are important in functional programming. They have two main features:</p>
			<ul>
				<li><strong class="bold">Deterministic output</strong>: For <a id="_idIndexMarker130"/>any given input, a pure function will always yield the same output, making its behavior extremely predictable. This characteristic simplifies the process of testing and debugging since the output of the function is always consistent given the same set of inputs.</li>
				<li><strong class="bold">No observable side effects</strong>: A pure function does not influence or is influenced <a id="_idIndexMarker131"/>by an external state. This means it doesn’t modify any external variables or data structures, or even carry out I/O operations. The function’s sole effect is the computation it performs and the result it delivers.</li>
			</ul>
			<p>These two properties make pure functions similar to mathematical functions. A mathematical function, <em class="italic">f(x) = y</em>, produces a result, <em class="italic">y</em>, that relies solely on the input, <em class="italic">x</em>, and doesn’t alter or is altered by anything outside of the function. In programming, a pure function can be seen as a self-contained unit that transforms input into output without any interference from or to the external world.</p>
			<p>By adhering to these properties, pure functions facilitate the creation of code that is more robust, maintainable, and less prone to bugs. Let’s examine these benefits and practical examples of pure functions fu<a id="_idTextAnchor104"/>rther.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor105"/>Examples of pure functions</h2>
			<p>Consider <a id="_idIndexMarker132"/>a function that determines how many books need to be printed to reach a target:</p>
			<pre class="source-code">
public static int BooksNeededToReachTarget(int currentPrintCount, int targetPrintCount)
{
    return targetPrintCount - currentPrintCount;
}</pre>			<p>This function always gives the same result with the same inputs and doesn’t change anything outside of it.</p>
			<p>Another example can be filtering out books of a particular genre:</p>
			<pre class="source-code">
public static List&lt;string&gt; GetTitlesOfGenre(List&lt;Book&gt; books, string genre)
{
    return books.Where(b =&gt; b.Genre == genre).Select(b =&gt; b.Title).ToList();
}</pre>			<p>This function <a id="_idIndexMarker133"/>is also pure. If you give it the same list of books, it will always return the same list of<a id="_idTextAnchor106"/> titles.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor107"/>The benefits of pure functions</h2>
			<p>Pure <a id="_idIndexMarker134"/>functions offer several significant advantages:</p>
			<ul>
				<li><strong class="bold">Predictability and ease of testing</strong>: Due to their deterministic nature, pure functions are highly predictable, making it easy to write unit tests. You always know what output to expect for a specific input, and there’s no need to mock or set up external dependencies for testing.</li>
				<li><strong class="bold">Code reusability and modularity</strong>: Pure functions, when designed to focus on a specific task in line with the single-responsibility principle, become highly reusable. As they don’t depend on external states, you can move these functions without worrying about breaking the code or enhancing its modularity.</li>
				<li><strong class="bold">Ease of debugging and maintenance</strong>: Without shared state or side effects, debugging pure functions is just a breeze. If there’s an issue, it’s usually within the function itself, making it easy to spot and fix. The isolation of pure functions also facilitates maintenance and updates as you can change a function without affecting other parts of y<a id="_idTextAnchor108"/>our code.</li>
			</ul>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor109"/>Comparisons of pure functions and non-pure functions</h2>
			<p>When <a id="_idIndexMarker135"/>analyzing pure functions alongside non-pure <a id="_idIndexMarker136"/>functions, the strengths and weaknesses of each become evident. To illustrate, let’s examine Konstatos’ tower defense mobile game as an example. In this game, different units take different amounts of damage from towers based on their defense against each type of tower. Each unit class can have a dictionary that contains these damage changes:</p>
			<pre class="source-code">
private static Dictionary&lt;TowerType, double&gt; _damageModifiers = new Dictionary&lt;TowerType, double&gt;
{
    {TowerType.Cannon, 0.8},  // Takes 20% less damage from cannon towers
    {TowerType.Laser, 0.9}   // Takes 10% less damage from laser towers
};</pre>			<p>To figure <a id="_idIndexMarker137"/>out the damage a tower does to a unit, the <a id="_idIndexMarker138"/>unit class has a function that looks like this:</p>
			<pre class="source-code">
public double CalculateDamageFromTower(Tower tower)
{
    return tower.BaseDamage * _damageModifiers[tower.Type];
}</pre>			<p>At first, you might think this function is pure. But because it uses the <code>_damageModifiers</code> variable, which can change, the output can also change, even if the input stays the same. This means the function depends on something outside of it, which isn’t good for pure functions. This can lead to mistakes and makes testing and fixing problems harder.</p>
			<p>Here’s how we can make the function pure:</p>
			<pre class="source-code">
public double CalculateDamageFromTower(Tower tower, Dictionary&lt;TowerType, double&gt; damageModifiers)
{
    return tower.BaseDamage * damageModifiers[tower.Type];
}</pre>			<p>Now, by giving <code>damageModifiers</code> directly to the function, it doesn’t depend on anything outside of it. This means that if you give it the same input, you’ll always get the same output.</p>
			<p>You might be wondering if it makes sense to give a dictionary to a function when the function can already see it. That’s a fair point. But doing it this way means the function doesn’t secretly rely on something other than its parameters, which makes our code cleaner and easier to work with.</p>
			<p>Understanding <a id="_idIndexMarker139"/>the distinctions between these <a id="_idIndexMarker140"/>two types of functions and prioritizing the use of pure functions can enhance your code’s quality. As you delve deeper into functional programming in C#, this understanding will prove invaluable. Up next, we’ll discuss side effects in function<a id="_idTextAnchor110"/>al programming.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor111"/>Side effects</h1>
			<p>While working on his tower defense game, Steve noticed some unexpected behavior. Units were <a id="_idIndexMarker141"/>taking inconsistent damage from towers. After some investigation, he realized the damage calculation function relied on a global variable that could change unpredictably - a classic side effect.</p>
			<p>Side effects in programming refer to any application state changes that occur outside the function being executed. These changes could include modifying a global or static variable, changing the original value of function parameters, performing I/O operations, or even throwing an exception. Side effects make the behavior of a function dependent on the context, reducing predictability and potentially <a id="_idTextAnchor112"/>increasing bugs.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor113"/>Common sources of side effects</h2>
			<p>When <a id="_idIndexMarker142"/>writing code, it’s good to know where side effects <a id="_idIndexMarker143"/>might come from. Side effects can make code unpredictable. Let’s break down so<a id="_idTextAnchor114"/>me common sources.</p>
			<h3>Global variables</h3>
			<p>Problem: Using <a id="_idIndexMarker144"/>global variables can lead <a id="_idIndexMarker145"/>to unexpected changes. If a function changes a global variable, it can affect other parts of your program:</p>
			<pre class="source-code">
public static Dictionary&lt;string, int&gt; UserScores = new Dictionary&lt;string, int&gt;();
public static int UpdateUserScore(string userName, int scoreToAdd)
{
    if (UserScores.ContainsKey(userName))
    {
        UserScores[userName] += scoreToAdd;
    }
    else
    {
        UserScores[userName] = scoreToAdd;
    }
    return UserScores[userName];
}</pre>			<p><code>UpdateUserScore</code> changes the <code>UserScores</code> dictionary. Since this dictionary is accessible <a id="_idIndexMarker146"/>everywhere, other functions might also change it. This makes <a id="_idIndexMarker147"/>our function unpredictable.</p>
			<p>Solution: Instead of global variables, it’s better to use function arguments or put the state inside objects. For example, here, as we did before, it is better to pass the dictionary as a parameter to <a id="_idTextAnchor115"/>eliminate the problem.</p>
			<h3>The out and ref parameters</h3>
			<p>Problem: Using <code>out</code> and <code>ref</code> in C# can <a id="_idIndexMarker148"/>change <a id="_idIndexMarker149"/>the original data <a id="_idIndexMarker150"/>that’s <a id="_idIndexMarker151"/>given to a function:</p>
			<pre class="source-code">
public static void UpgradeTower(ref Tower tower, int level)
{
    tower = new Tower();
    tower.Damage = level * 10;
    tower.Hitpoints = level * 150;
}</pre>			<p>The <code>UpgradeTower</code> method not only updates the <code>Damage</code> and <code>Hitpoints</code> values but also <a id="_idIndexMarker152"/>changes the reference so that it no longer points to the original <code>Tower</code> object. Of course, it is almost impossible to see code like this in real life; usually, it isn’t so straightforward and is hidden inside other methods. This code is a simplified <a id="_idIndexMarker153"/>and slightly ugly version <a id="_idIndexMarker154"/>of real code to show you the idea <a id="_idIndexMarker155"/>behind using <code>ref</code> parameters.</p>
			<p>Solution: Instead <a id="_idIndexMarker156"/>of changing the data, it’s a good idea to return a new value. Here, we could rename the method to <code>GetLeveledUpTower</code> <a id="_idTextAnchor116"/>and make it return a new tower.</p>
			<h3>I/O operations</h3>
			<p>Problem: Doing <a id="_idIndexMarker157"/>things such as saving <a id="_idIndexMarker158"/>to a file or a database will change data outside your function:</p>
			<pre class="source-code">
public void SaveGameProgressToFile(string progressData, string filePath)
{
    File.WriteAllText(filePath, progressData);
}</pre>			<p>The <code>SaveGameProgressToFile</code> function saves game progress data to a file. This kind of <a id="_idIndexMarker159"/>action can fail if, for example, there’s no space left on the disk. So, it’s a side effect because it relies on something outside our function.</p>
			<p>Solution: It’s helpful to keep logic separate from actions such as saving data. This makes the code<a id="_idTextAnchor117"/> clearer and easier to understand.</p>
			<h3>Exception handling</h3>
			<p>Problem: Consider <a id="_idIndexMarker160"/>a function that <a id="_idIndexMarker161"/>calculates the damage dealt by a tower:</p>
			<pre class="source-code">
public static double CalculateDamage(Tower tower, Unit unit)
{
    if (tower == null || unit == null)
    {
        throw new ArgumentException("The tower or unit is null.");
    }
    return tower.Damage * unit.DefenseModifier;
}</pre>			<p>The <code>CalculateDamage</code> function throws an exception if the tower or unit is <code>null</code>. Throwing an exception changes the regular flow of our program. If not handled, it can terminate <a id="_idIndexMarker162"/>the application or lead to unexpected behavior.</p>
			<p>Solution: The best way to go here is to use the <code>Either</code> monad. However, before we discuss it, you can use a nullable type called <code>double?</code>:</p>
			<pre class="source-code">
public static double? CalculateDamage(Tower tower, Unit unit)
{
    if (tower == null || unit == null)
    {
        return null;
    }
    return  tower.Damage * unit.DefenseModifier;
}</pre>			<p>With this <code>CalculateDamage</code> method, if the tower or unit is <code>null</code>, the method returns <code>null</code>; otherwise, it calculates the damage and returns it. This way, we avoid the side effect <a id="_idIndexMarker163"/>of breaking the flow with exceptions for common scenarios. However, the code that uses this method must be also modified so that it can handle <a id="_idIndexMarker164"/>the situation when <code>null</code> is returned.</p>
			<p>Knowing how exceptions can be a source of side effects helps in making design choices that keep ou<a id="_idTextAnchor118"/>r C# code clearer and more predictable.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor119"/>Consequences of side effects</h2>
			<p>The presence <a id="_idIndexMarker165"/>of side effects in your code can lead to various issues:</p>
			<ul>
				<li><strong class="bold">Decreased predictability</strong>: Functions with side effects are less predictable because their output can change based on the external state. This decreased predictability makes it harder to understand what a function does just by looking at it.</li>
				<li><strong class="bold">Increased difficulty in testing and debugging</strong>: Functions with side effects are harder to test since they require the correct external state to produce the expected result. Debugging is also more complex because an issue in the function c<a id="_idTextAnchor120"/>ould be due to an external state change.</li>
				<li><strong class="bold">Concurrency issues</strong>: Concurrency problems can arise when multiple threads access and modify shared state simultaneously, leading to unexpected results.</li>
			</ul>
			<p>Although it might not look instantly bad, with time, these consequences tend to snowball, making your project <a id="_idTextAnchor121"/>very expensive to develop and support.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor122"/>Strategies to minimize side effects</h1>
			<p>While side <a id="_idIndexMarker166"/>effects in real-world applications are unavoidable, the key is to control and isolate them to make your code more manageable and predictable. This section focuses on strategies to minimize side effects by using <code>readonl<a id="_idTextAnchor123"/>y</code>, <code>const</code>, <code>static</code>, and immutability in C#.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor124"/>Favor immutability</h2>
			<p>Immutability is a powerful way to minimize side effects. Immutable objects are objects whose state <a id="_idIndexMarker167"/>can’t be changed after they’re created. In C#, strings are a prime example of immutability. Every operation on a string results in a new string, and the original string remains unchanged. This principle can be expanded to other data types:</p>
			<pre class="source-code">
     Book originalBook = new Book("The Clean Coder", "Uncle Bob");
    /* Create a new book instance with the same title but a different author */
    Book updatedBook = originalBook with { Author = "Robert C. Martin" };
    // We can see that both copies exist
    Console.WriteLine(originalBook);
    Console.WriteLine(updatedBook);</pre>			<p>In this code snippet, <code>originalBook</code> is created as an instance of <code>Book</code> with a specific title and author and <code>updatedBook</code> is a new instance of <code>Book</code> that was created using the <code>with</code> expression. The <code>with</code> expression is used to create a new record with some properties modified from an existing record. Here, it creates a new <code>Book</code> value with the same <code>Title</code> value as <code>originalBook</code> but with <code>Author</code> set to <code>"Robert </code><code>C. Martin"</code>.</p>
			<p>This approach maintains immutability because <code>originalBook</code> remains unchanged, and any<a id="_idTextAnchor125"/> “modification” results in a new instance.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor126"/>Use readonly and const</h2>
			<p><code>readonly</code> and <code>const</code> are two keywords in C# that can make your fields and variables unchangeable, thereby reducing the potential for side effects.</p>
			<p><code>const</code> variables <a id="_idIndexMarker168"/>are implicitly static and should be <a id="_idIndexMarker169"/>used when the value is known at compile time and will never change:</p>
			<pre class="source-code">
public const string PublishingHouseName = "Progressive Publishers";</pre>			<p>On the other hand, <code>readonly</code> variables can be either instance-level or static, and their values can be set at runtime (for instance, inside constructors), but not changed afterward:</p>
			<pre class="source-code">
p<a id="_idTextAnchor127"/>ublic readonly string Isbn = GenerateIsbn();</pre>			<h2 id="_idParaDest-81"><a id="_idTextAnchor128"/>Use functional programming principles</h2>
			<p>Functional programming principles are designed to help minimize side effects. Besides pure <a id="_idIndexMarker170"/>functions and immutability, principles such as expressions over statements, the use of higher-order functions, and function composition can also aid in this mission. While we are already acquainted with the former, higher-order functions and function composition will be discussed in later chapters. So, let’s just keep moving – applying these principles can greatly enhance the pre<a id="_idTextAnchor129"/>dictability and maintainability of your code.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor130"/>Encapsulate side effects</h2>
			<p>When side <a id="_idIndexMarker171"/>effects are unavoidable, it’s crucial to isolate them. For instance, if a function must write to a file, that should be its sole responsibility. All other logic should be separated into pure functions as much as possible. This way, the side effects are contained, and the rest of your code remains unaffected:</p>
			<div><div><img src="img/B21069_03_001.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>The idea here is to isolate side effects, making them predictable, visible, and manageable.</p>
			<p>Strategies to <a id="_idIndexMarker172"/>minimize side effects are key to building reliable, efficient, and maintainable software. By implementing these strategies, we inch closer to the functional programming paradigm, harnessing its strengths and benefits.</p>
			<p>Next, we’ll discuss how to <a id="_idTextAnchor131"/>use the <code>Pure</code> attribute to mark pure functions.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor132"/>Marking pure functions with the Pure attribute</h1>
			<p>Understanding the role of pure functions and side effects in our code is crucial for effective <a id="_idIndexMarker173"/>functional programming in C#. But how <a id="_idIndexMarker174"/>do we communicate our intent that a function should be pure? T<a id="_idTextAnchor133"/>his is where the <code>Pure</code> attribute comes into play.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor134"/>Understanding the Pure attribute in C#</h2>
			<p>In C#, the <code>Pure</code> attribute <a id="_idIndexMarker175"/>is defined in the <code>System.Diagnostics.Contracts</code> namespace and serves as a declarative tag to indicate that a method is pure. A pure method is one that, given the same inputs, will always return the same output and does not produce any observable side effects.</p>
			<p>It’s important to note that the <code>Pure</code> attribute is primarily intended for use in code contracts and static checking tools. The runtime and compiler don’t enforce the purity of a method, and this attribute does not change the method’s behavior in any way:</p>
			<pre class="source-code">
[Pure]
public static decimal CalculateRoyalty(decimal bookPrice, decimal royaltyPercent)
{
    return bookPrice * royaltyPercent / 100;
}</pre>			<p>In this <a id="_idIndexMarker176"/>example, we have a function that calculates the royalty amount for a book based on its price and the royalty percentage. It’s a pure function since it always returns the same output for the same i<a id="_idTextAnchor135"/>nput and doesn’t have any observable side effects.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor136"/>The benefits of marking functions as pure</h2>
			<p>Marking <a id="_idIndexMarker177"/>functions as pure using the <code>Pure</code> attribute brings several benefits:</p>
			<ul>
				<li><strong class="bold">Clarity and intention</strong>: By marking a function as pure, you communicate your intention to other developers that this function should remain side-effect-free</li>
				<li><code>Pure</code> attribute to help identify potential issues in your code</li>
				<li><strong class="bold">Optimization opportunities</strong>: While the C# compiler doesn’t currently take advantage of this, in some languages and scenarios, knowing that a function i<a id="_idTextAnchor137"/>s pure can enable additional compiler optimizations</li>
			</ul>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor138"/>Caveats and considerations when using the Pure attribute</h2>
			<p>When <a id="_idIndexMarker178"/>marking functions as pure, keep the following points in mind:</p>
			<ul>
				<li><code>Pure</code> attribute does not enforce purity. You can mark a method as pure, and it can still have side effects. The attribute is more of a communication and analysis tool.</li>
				<li><code>Pure</code> attribute cannot be used with void methods.</li>
				<li><code>Pure</code> attribute has no impact on the method’s runtime behavior. It’s mainly used by ce<a id="_idTextAnchor139"/>rtain static analysis tools, such as code contracts.</li>
			</ul>
			<p>By marking <a id="_idIndexMarker179"/>your functions with the <code>Pure</code> attribute, you make a promise about your function’s behavior, helping others (and tools) understand your code better. However, it’s crucial to remember that the attribute is a tool, not a panacea. The responsibility for ensuring a function’s purity still lies primarily with the developer.</p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor140"/>Exercises</h1>
			<p>To test Steve’s understanding, Julia presented him with three coding challenges related to pure functions and side effects. “These exercises will help solidify the concepts,” she explained. “Give t<a id="_idTextAnchor141"/>hem a try and let me know if you have any questions.”</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor142"/>Exercise 1</h2>
			<p>Steve’s tower defense game calculates damage based on a global difficulty modifier. Refactor this function to make it pure:</p>
			<pre class="source-code">
public static double difficultyModifier = 1.0;
public double CalculateDamage(Tower tower, Enemy enemy)
{
     return tower.BaseDa<a id="_idTextAnchor143"/>mage * enemy.DamageMultiplier * difficultyModifier;
}</pre>			<h2 id="_idParaDest-89"><a id="_idTextAnchor144"/>Exercise 2</h2>
			<p>Steve’s game loads enemy data from a file, processes it, and updates the game state. Refactor this function to isolate its side effects:</p>
			<pre class="source-code">
public void LoadAndProcessEnemyData(string filePath)
{
     string jsonData = File.ReadAllText(filePath);
     List&lt;Enemy&gt; enemies = JsonConvert.DeserializeObject&lt;List&lt;Enemy&gt;&gt;(jsonData);
     foreach (var enemy in enemies)
     {
                  enemy.Health *= GameState.DifficultyLevel;
                  GameState.ActiveEnemies.Add(enemy);
     }
     Co<a id="_idTextAnchor145"/>nsole.WriteLine($"Loaded {enemies.Count} enemies");
}</pre>			<h2 id="_idParaDest-90"><a id="_idTextAnchor146"/>Exercise 3</h2>
			<p>Refactor the following method by making it a pure function and marking it with the <code>Pure</code> attribute:</p>
			<pre class="source-code">
public string GenerateEnemyCode(string enemyType, int level)
{
     var code = enemyType.Substring(0, 3) + level.ToString();
     return new string(code.OrderBy(c =&gt; c).ToArray());
}</pre>			<p>These exercises should help solidify your understanding of the concepts we’ve covered. Keep practicing, keep experimenting, and remember – every line of code you write is a step forward on your journey to mastering functional programming in C#.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor147"/>Solutions</h1>
			<p>Her<a id="_idTextAnchor148"/>e are the solutions to the exercises in this chapter.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor149"/>Exercise 1</h2>
			<p>A pure function should not depend on or modify any state outside its scope. So, instead of relying on the global <code>difficultyModifier</code> value, we should pass it as a parameter:</p>
			<pre class="source-code">
[Pure]
public double CalculateDamage(Tower tower, Enemy enemy, double difficultyModifier)
{
     return tower.BaseDa<a id="_idTextAnchor150"/>mage * enemy.DamageMultiplier * difficultyModifier;
}</pre>			<h2 id="_idParaDest-93"><a id="_idTextAnchor151"/>Exercise 2</h2>
			<p>To isolate side effects, we’ll separate the pure logic from the I/O operations and state mutations:</p>
			<pre class="source-code">
public interface IFileReader
{
     string ReadAllText(string filePath);
}
public interface IEnemyRepository
{
     void AddEnemies(IEnumerable&lt;Enemy&gt; enemies);
}
public interface ILogger
{
     void Log(string message);
}
public class EnemyProcessor
{
     private readonly IFileReader _fileReader;
     private readonly IEnemyRepository _enemyRepository;
     private readonly ILogger _logger;
     public EnemyProcessor(IFileReader fileReader, IEnemyRepository enemyRepository, ILogger logger)
     {
              _fileReader = fileReader;
              _enemyRepository = enemyRepository;
              _logger = logger;
     }
     public void LoadAndProcessEnemyData(string filePath, double difficultyLevel)
     {
              string jsonData = _fileReader.ReadAllText(filePath);
              List&lt;Enemy&gt; enemies = DeserializeEnemies(jsonData);
              List&lt;Enemy&gt; processedEnemies = AdjustEnemyHealth(enemies, difficultyLevel);
              _enemyRepository.AddEnemies(processedEnemies);
              _logger.Log($"Loaded {processedEnemies.Count} enemies");
     }
     [Pure]
     private List&lt;Enemy&gt; DeserializeEnemies(string jsonData)
     {
         return JsonConvert.DeserializeObject&lt;List&lt;Enemy&gt;&gt;(jsonData);
     }
     [Pure]
     private List&lt;Enemy&gt; AdjustEnemyHealth(List&lt;Enemy&gt; enemies, double difficultyLevel)
     {
              return enemies.Select(e =&gt; new Enemy
              {
                       Health = e.Health * difficultyLevel,
                  // Copy ot<a id="_idTextAnchor152"/>her properties...
              }).ToList();
     }
}</pre>			<h2 id="_idParaDest-94"><a id="_idTextAnchor153"/>Exercise 3</h2>
			<p>This one is a bit tricky because the function is already pure. All we need to do is add the <code>Pure</code> attribute to communicate that intention to other developers and analysis tools:</p>
			<pre class="source-code">
[Pure]
public string GenerateEnemyCode(string enemyType, int level)
{
     var code = enemyType.Substring(0, 3) + level.ToString();
     return new string(code.OrderBy(c =&gt; c).ToArray());
}</pre>			<p>These solutions adhere to the principles of functional programming, ensuring<a id="_idTextAnchor154"/> minimized side effects and clarity of code behavior.</p>
			<p>With that, let’s cover some dos and don’ts for <a id="_idTextAnchor155"/>utilizing pure functions and minimizing side effects.</p>
			<p>These are the dos:</p>
			<ul>
				<li>Strive to write more pure functions as they’re predictable and straightforward to understand and test</li>
				<li>Isolate side effects – that is, keep them separate from pure code</li>
				<li>Use <code>readonly</code>, <code>const</code>, and <code>static</code> modifiers to promote immutability and reduce side effects</li>
				<li>Use the <code>Pure</code> attribute to communicate intent, aiding in code analysis and maintainability</li>
			</ul>
			<p>These are the don’ts:</p>
			<ul>
				<li>Overuse global state as it leads to high coupling and increases the risk of side effects.</li>
				<li>Modify inputs inside a function. This alteration can lead to unexpected behavior.</li>
				<li>Forget that the <code>Pure</code> attribute doesn’t enforce purity. It’s a promise that the developer needs to fulfill.</li>
				<li>Ignore the context. Sometime<a id="_idTextAnchor156"/>s, a non-pure function can provide a better solution.</li>
			</ul>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor157"/>Summary</h1>
			<p>Diving into the world of functional programming in C# has been a stimulating journey, and we’re only just getting started. In this chapter, we explored the pivotal concepts of pure functions and side effects and their respective roles in writing cleaner, more predictable, and maintainable code. Let’s reinforce the knowledge we’ve gained and map out the course moving forward.</p>
			<p>Pure functions stand as a beacon of certainty in the unpredictable universe of software. They have a clear-cut contract – the same input always yields the same output, and they remain uninvolved with the state outside their scope. This simplicity makes them predictable, easy to test, and more amenable to parallelization and optimization.</p>
			<p>However, the real world is filled with side effects – reading and writing to a database, calling an API, modifying a global variable – the list goes on. Side effects are inevitable, but when uncontrolled, they can unleash chaos, making the code hard to reason about and test. To mitigate this problem in functional programming, we must wrap pure functions with impure code, thus protecting them from having side effects.</p>
			<p>In the next chapter, we will talk about a new type of function – honest functions. We’ll talk about what are they, how to use them in C#, and what danger nullable references can bring.</p>
		</div>
	</body></html>