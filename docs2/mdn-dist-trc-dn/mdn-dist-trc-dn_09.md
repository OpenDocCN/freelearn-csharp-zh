

# 第九章：最佳实践

在前面的章节中，我们专注于如何收集、丰富、关联和使用单个遥测信号。在本章中，我们将讨论需要收集哪些信息以及如何使用所有可用的信号高效地表示这些信息。我们将首先提供关于如何选择合适的遥测信号的建议，并提出跨信号成本优化策略。最后，我们将探讨 OpenTelemetry 语义约定，并使用它们来创建大多数可观察性供应商支持的统一遥测。

你将学习以下内容：

+   找到适用于您场景的遥测信号

+   通过聚合、采样和详细程度控制遥测成本

+   使用 OpenTelemetry 语义约定报告遥测数据时的常见做法

到本章结束时，你将能够使用现有语义处理常见技术或创建自己的跨信号和跨服务约定。

# 技术要求

本章没有具体要求，也没有相关的代码文件。

# 选择正确的信号

当我们在第六章到第八章讨论单个遥测信号时，我们提供了何时使用每个信号的建议。让我们快速回顾一下：

+   **分布式跟踪**详细描述了单个网络调用和其他有趣的操作。跨度具有因果关系，使我们能够理解分布式系统中的请求流程。

跟踪记录了系统中的请求流程，对于调查延迟分布长尾中的错误或异常至关重要。跟踪提供了关联其他遥测信号的手段。

+   **指标**收集具有低基数属性的聚合数据，并提供对整体系统状态的低分辨率视图。它们有助于优化遥测收集，降低存储成本和查询时间。

+   **事件**提供了关于重要事物单个发生的高度结构化信息。与跨度相比，事件的关键区别在于跨度具有唯一上下文，并描述了持续的东西。

事件具有高基数属性，可以帮助回答关于系统行为和使用的即兴问题。

+   **日志**以人类可读和不太结构化的格式提供操作细节。

当其他信号提供的信息不足时，它们对于调试事物非常有用。此外，日志是唯一支持详细程度的信号。

+   **配置文件**是描述单个进程内单个操作的底层性能数据，有助于优化性能和识别资源瓶颈。

在对特定场景进行仪器化时，我们通常需要信号组合。

例如，为了将可观察性引入网络调用，我们需要跟踪以确保我们可以跟踪服务之间的请求流并关联其他信号。日志是必要的，用于记录异常和警告，描述本地操作，并为复杂的调查提供调试级别的数据。最后，我们可能需要指标来记录非采样测量，优化收集并减少查询时间。

注意

在考虑信号之前，我们应该有一个想法，即我们希望哪些信息可用，我们将如何使用它，我们需要多快多频繁地获取它，我们希望捕获多少细节，我们需要它多长时间，我们负担得起多少，以及停机成本。

这些问题的答案应该塑造我们关于可观察性的决策。

实际上，我们在足够的数据来快速调查问题和可观察性解决方案的成本之间有很多权衡。例如，收集过多的跟踪会给我们提供调查所有类型问题的所有必要细节。它会对性能产生明显的影响，并显著增加可观察性后端成本。结果，跟踪可能会变得非常深入和详细，以至于很难理解问题所在。

在讨论一套良好的遥测信号集时，如果不提及成本，这样的讨论是不可能的。让我们看看我们如何控制它们。

# 用更少的资源获得更多

由于我们通常需要收集关于同一组件的多个信号，我们需要能够根据我们的需求单独调整它们。

关键是减少昂贵但非必要的数据量，可能用更便宜的选择替换，同时保持系统可观察。我们在*第八章*，“编写结构化和关联日志”中看到了如何通过结合热存储和冷存储或更改保留期来实现这一点。在这里，让我们专注于收集方面。

虽然可观察性供应商有不同的定价模式，但它们通常根据数据量对跟踪、日志和事件收费，根据时间序列的数量对指标收费。查询（或 API 调用）也可能收费，并且可能有并发限制。

当然，我们总是可以添加或删除仪器或停止编写日志和事件，但还有一些其他因素会影响收集遥测数据的数量：

+   我们可以通过采样率和添加或删除新属性来控制跟踪量

+   为了控制指标时间序列的数量，我们可以添加或删除资源属性或丢弃维度或仪器

+   我们可以调整单个类别的日志详细程度，或者全局调整，并添加或删除属性

应用程序的需求可能因它们的成熟度、更改的数量、它们可以承受的停机时间以及其他因素而异——让我们通过几个例子来展示它们可以应用的可能的折衷方案。

## 构建新的应用程序

当编写应用程序的第一个版本时，遥测在帮助团队调查问题和加快进度方面可以发挥关键作用。这里有趣的部分是我们不知道需要哪种类型的遥测以及我们将如何使用它。

我们可以利用现有的仪器，使我们能够专注于构建应用程序，并在其发展过程中拥有所有调试手段，同时找到我们之前概述的遥测问题的答案。

在初始阶段，是设计可观察性故事的好时机，并且从最灵活的信号——跟踪、事件和日志开始是有意义的。最初，遥测数据量可能很低，因此以高采样率记录跟踪或仅进行速率限制应该是负担得起的。此外，我们可能还没有严格的 SLA，也不太使用仪表板和警报。

在我们获得一些真实用户之前，指标或事件可能是不必要的，但这是进行实验和熟悉它们的好时机。

即使遥测数据量相当低，我们能够捕获详细的数据，我们也应避免添加过多的遥测数据，并应删除未使用的信号。

## 应用程序的发展

随着我们的应用程序开始获得一些真实用户，快速获取性能数据变得至关重要。到这时，我们对应用程序中需要测量的内容以及如何调试问题（希望不是依赖于冗长的日志）有了更多的了解。

这是优化和调整遥测收集的时间。随着负载的增长，我们通常希望降低跟踪的采样率并减少日志的冗余。

此外，我们可能需要创建警报并构建比在*第七章*中讨论的基于指标的仪表板和警报更高效的仪表板，正如我们在*第七章*中讨论的，*添加自定义指标*。虽然仪器库应该涵盖基础知识，但我们可能需要在之前依赖于跟踪查询的地方添加自定义指标。随着规模的扩大，时间序列的数量仅随着服务实例数量的增加而增加。

在这个阶段，我们可能还决定使用事件和指标收集精确且未采样的使用数据。

应用程序仍在不断变化，我们经常需要调查特定请求的功能性问题并优化来自延迟长尾的请求。因此，跟踪在日常工作中仍然发挥着关键作用。我们可能需要为应用程序的更多层进行仪器化以捕获逻辑操作或添加应用程序特定的上下文。同时，我们可能发现一些自动仪器化过于冗长，可以调整它们以删除不必要的属性或抑制一些跨度。

有时，我们需要捕获配置文件或使用诊断工具来调查低级问题，因此拥有一个持续的性能分析器或在边车中添加 `dotnet-monitor` 可以使这种调查变得容易得多。

如果应用程序（或其某些部分）由于问题越来越少而变得更加稳定，那么删除非必要跟踪并减少稳定服务或端点的采样率是有意义的。基于尾部的采样可以帮助捕获更多失败或长时间请求的跟踪。

当应用程序不再发生变化，除了基本维护之外，更重要的是，如果没有许多问题和调查，那么将跟踪仅限于传入和传出请求，可能将日志转发到较冷的存储，可能是合理的。

## 性能敏感场景

仪器引入了性能开销。在跟踪、指标和日志之间，跟踪是最昂贵的。在仪器化 HTTP 请求时，与调用本身相比，这种开销通常是可以忽略不计的。

但在某些情况下，仪器成本可能过高。例如，当返回缓存响应或对所有服务实例进行速率限制时，记录或跟踪所有此类调用可能会显著影响性能。此外，如果我们为每个请求都记录了跟踪信息，DDOS 攻击或存在错误的客户端可能会破坏我们的可观察性管道，甚至可能影响整个服务。

通过采样，在一定程度上可以减少跟踪开销，这可以保护可观察性管道并在填充属性时减少分配的数量，但无论采样决策如何，都会创建一个新的`Activity`并生成一个新的`SpanId`。

对于热路径添加跟踪应谨慎进行。尽量减少跟踪的数量：仅当相应的请求将由您的应用程序处理时才跟踪传入请求，并且如果出站网络调用非常快或可靠，则避免跟踪这些调用。例如，与 Redis 通信时报告事件而不是跨度是有意义的。

指标是性能最佳的遥测信号，在可能的情况下应优先选择用于热路径。例如，将 Redis 调用持续时间作为具有缓存命中/未命中维度的指标报告，可能比事件更便宜。并且对于跟踪目的，我们可以在现有的当前跨度（例如，代表传入请求的一个跨度）上添加一个命中/未命中标志作为属性。

从性能角度来看，记录异常和错误通常是可行的，因为异常本身就会产生巨大的开销。但在失败风暴的情况下，我们会得到太多的异常，因此限制异常报告是一个好主意。

实现高效、有用但简约的仪器通常需要多次迭代。幸运的是，OpenTelemetry 提供了一套针对常见场景的语义约定，可以帮助实现这一点。让我们看看如何。

# 保持与语义约定的一致性

我们尚未讨论的最重要的问题之一是向遥测信号添加哪些信息才能使其有用——这正是 OpenTelemetry 语义约定发挥作用的地方。

语义约定描述了为特定技术（如 HTTP 或 gRPC 调用、数据库操作、消息场景、无服务器环境、运行时指标、资源属性等）收集哪些信息。

语义约定是 OpenTelemetry 规范的一部分，并已发布在规范存储库[`github.com/open-telemetry/opentelemetry-specification`](https://github.com/open-telemetry/opentelemetry-specification)。它们适用于 OpenTelemetry 项目编写的所有仪器。

注意

在撰写本文时，语义约定处于实验状态。社区正在积极努力进行稳定化，本书中使用的属性可能会被重命名或以其他方式更改。

语义约定的目标是统一特定场景或技术跨语言、运行时和库的遥测收集。例如，所有 HTTP 客户端的跟踪和指标看起来非常相似，这使得可视化或查询 HTTP 遥测或以相同方式诊断任何应用程序中的问题成为可能。让我们看看 HTTP 语义约定，了解它们是如何工作的，并给你一个其他约定看起来如何的印象。

## HTTP 请求的语义约定

这些约定涵盖了入站和出站 HTTP 请求的跟踪和指标。具有`client`类型的 span 描述出站请求，而`server`类型的 span 描述入站请求。仪器为每个尝试创建一个新的 span。

`client` HTTP span 包含描述请求、响应和远程目的地的属性。根据当前版本，最小 HTTP 客户端仪器必须报告以下属性：`http.method`、`http.url`、`net.peer.name`、`net.peer.port`和`http.status_code`。

如果没有收到响应，则`http.status_code`属性不会被填充；相反，span 状态将指示错误并提供一个状态描述，解释发生了什么。如果端口号（`net.peer.port`）是 80 或 443，则可能会跳过该属性。其他属性是必需的，因此所有遵循约定的仪器都必须在所有场景中填充它们。这些属性与 span 开始时间戳、持续时间以及状态相结合，提供了 HTTP 请求的最小必要描述。

除了`http.status_code`之外的所有属性应在 span 开始时间提供——这允许我们根据这些属性做出采样决策。

你可能已经注意到，主机和端口信息在 URL 内部以及通过单独的属性中可用。URL 是一个高基数属性，但主机和端口很可能具有低基数，因此报告所有这些信息允许我们统一仪器代码，并在一个地方报告跟踪和指标。这也使得从跟踪中计算指标并简化查询成为可能。

最小 HTTP 服务器工具报告了 `http.method`、`http.status_code`、`http.scheme`、`http.target`、`net.host.name`、`net.host.port` 和 `http.route` 属性。

由于 HTTP 服务器没有现成的完整 URL，因此工具不会构建它们，而是报告单个 URL 组件。路由信息由 ASP.NET Core 等 HTTP 框架提供，即使在那些框架中，您也可以在中间件中处理请求而不使用路由。报告路由对于指标非常重要，正如我们在*第七章*中看到的，*添加自定义指标*，所以如果您没有现成的路由，您可能需要手动提供一个以区分不同类别的 API 调用。HTTP 客户端和服务器工具通常还会报告推荐属性，例如 `User-Agent` 头部、请求和响应内容长度、HTTP 协议版本和远程 IP 地址。

约定还标准化了属性值类型 - 例如，`http.status_code` 具有整型，简化了查询时的比较。

您可以在 [`opentelemetry.io/docs/reference/specification/trace/semantic_conventions/http`](https://opentelemetry.io/docs/reference/specification/trace/semantic_conventions/http) 找到完整的 HTTP 跟踪约定。

指标基于相同的跟踪属性，包括请求持续时间、内容大小和服务器上的活动请求数量。指标约定可在 [`opentelemetry.io/docs/reference/specification/metrics/semantic_conventions/http-metrics`](https://opentelemetry.io/docs/reference/specification/metrics/semantic_conventions/http-metrics) 找到。

HTTP 语义约定提供了一套很好的默认收集项。您可以在团队、公司、Web 框架之间移动，或者开始使用不同的编程语言，但 OpenTelemetry 工具会在任何地方提供一个共同的基线。

拥有一组可靠的必需属性有助于后端可视化跟踪和服务映射，构建仪表板，并自动化分析和问题检测。

## 一般性考虑

当您需要工具化某些特定的技术或场景，并且没有合适的工具库可用时，请确保还检查是否存在适用的语义约定。遵循它，您将能够利用在可观察性后端之上构建的任何经验，防止来自系统不同部分的信号不一致，并且还可以节省一些设计和完善信号的时间。

但如果您想对应用程序中非常具体的东西进行工具化，比如添加逻辑操作的跨度或添加使用指标，该怎么办呢？让我们看看。

### 跟踪

正如我们在*第六章*中看到的，*跟踪您的代码*，我们可以创建一个新的 `Activity` 实例而不指定任何参数。默认情况下，它以调用方法命名，并具有 `internal` 类型。

OpenTelemetry 建议使用低基数 span 名称。HTTP 客户端 span 名称遵循`HTTP <method>`模式（例如，`HTTP GET`），而 HTTP 服务器 span 名称看起来像`<method> <route>`（例如，`GET /users/{userId}`）。span 名称描述了一类操作，并经常用于对常见 span 进行分组。

另一个重要的属性是 span 类型：它有助于后端可视化并查询跟踪它们。`client` span 代表出站请求——它们的上下文通过网络传播，并成为`server` span 的远程父级。在监控远程调用时，我们通常会为每个尝试创建一个新的 span，以便我们知道尝试花费了多长时间，有多少个尝试，以及退避间隔是多少。

`server` span 是跟踪传入请求的 span；它们要么没有父级，要么有一个远程父级。

OpenTelemetry 还定义了`consumer`和`producer`类型——它们用于请求-响应模式不适用的异步场景。`producer` span 可以是`consumer` span 的父级（或与之相关联），但它通常在相应的`consumer` span 之前结束。

所有其他 span 都是`internal`。例如，为了表示 I/O 操作或本地长时间运行的调用，我们应该使用`internal`类型。在监控客户端库调用或可以进行多个 HTTP 请求的逻辑操作时，将它们描述为`internal` span 是有意义的。

如果一个操作以错误结束，我们应该用 span 状态来反映它，但这可能很棘手。例如，HTTP 语义约定建议在客户端未收到响应、存在太多重定向或状态码在 4xx 或 5xx 范围内时，将状态设置为错误。但对于 HTTP 服务器来说，4xx 响应并不表示错误，应该保持未设置。即使是客户端请求，状态码如 404（未找到）也不一定表示错误，可以用来检查某些资源是否存在。

在记录错误时，状态描述可以用来记录一些可预测的简短信息，例如其异常类型和/或消息。异常遵循它们自己的语义约定——我们曾在*第六章*，“追踪你的代码”中讨论过。它们可能非常大（因为堆栈跟踪），因此我们应该避免记录已处理的异常。

#### 属性

应用特定的上下文或关于操作的详细信息可以记录在属性中。在发明新的属性名称之前，请确保您检查现有的语义约定，看看是否已经定义了类似的内容。例如，您可以使用通用网络属性来描述远程目的地或主机和 RPC 调用。

如果必须创建一个新的属性，请使用由基本拉丁字符组成的简短名称。OpenTelemetry 建议使用命名空间来避免命名冲突（它们由点（`.`）字符分隔）并使用`snake_case`来分隔单词。例如，在`http.status_code`中，`http`是一个命名空间。因此，如果您正在定义一个针对您公司的特定属性，在命名空间中使用公司名称是有意义的。

每个跨度中属性的默认数量限制为 128，但这个限制可以被增加。

在整个系统中保持名称和值类型的一致性可能具有挑战性，因此制定一些注册表以保持它们一致是个好主意。

那么，您会添加哪些信息到属性中呢？任何描述您操作的信息，除了敏感信息或机密信息。对长值要谨慎，避免添加需要序列化或计算的内容——使用详细日志记录这些内容。

避免重复并记录合理的信息集也是一个好主意，将静态属性移动到资源而不是跨度中。

### 指标

在创建仪器时，我们可以提供名称、单位和描述。

仪器名称不区分大小写，由字母数字字符、下划线、点和破折号组成。仪器名称必须简短——最多 63 个字符。

仪器名称的格式与属性名称类似，并支持命名空间——例如，`http.server.active_requests`计数器或`http.server.duration`直方图，分别代表活动 HTTP 请求数量和服务器端请求持续时间。

单位通常遵循 UCUM 标准([`ucum.org/`](https://ucum.org/))，并且在整个系统中保持它们的一致性是很重要的。

属性命名规范在不同信号之间是通用的，通常，指标依赖于跟踪属性的一个子集。指标属性最重要的特征是低基数性，我们在*第七章*中描述了这一点，即*添加* *自定义指标*。

在添加自定义指标之前，请确保检查是否存在现有的仪器库或 OpenTelemetry 语义约定。例如，有一个通用的用于 RPC 请求、进程和系统资源利用率指标、数据库以及其他特定技术的，如 Kafka。

# 摘要

在本章中，我们讨论了遥测收集的建议和推荐。为了描述某些场景或操作，我们通常需要多个信号：跟踪使关联和因果关系成为可能，日志提供由跟踪未涵盖的额外信息，事件收集使用信息，而指标优化了仪器、查询和警报。

根据您应用程序的需求和稳定性，您可以通过调整跟踪上的采样率和使用指标来控制性能数据和使用报告的事件的成本。

OpenTelemetry 语义约定为常见技术和概念提供了配置工具。通过遵循它们，你可以创建具有良好默认值的高质量配置，这些默认值可以根据你的需求进行调整。可观察性后端可以提供它们最好的体验，帮助你可视化、检测异常并执行其他半自动分析。对于专有技术或特定于应用程序的配置，在没有现有约定的场合，遵循通用的 OpenTelemetry 规范和命名模式，并在整个系统中一致地报告遥测数据非常重要。

使用这些工具，你应该准备好使用多个信号来配置高级场景，并在遵循现有实践的同时提供丰富的上下文。在下一章中，我们将应用这些技能来配置 gRPC 流调用，这些调用不受任何现有约定的覆盖。敬请期待。

# 问题

1.  你能否仅使用跟踪来配置一个微小的无状态 RESTful 微服务？

1.  当你在处理每个实例每秒处理数千个请求的应用程序上工作时，你会选择什么样的采样率？

1.  你的应用程序通过 WebSockets 与客户端设备通信。你将如何处理这种通信的配置？
