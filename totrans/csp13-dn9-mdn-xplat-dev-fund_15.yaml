- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building and Consuming Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about learning how to build web services (aka HTTP or **Representational
    State Transfer** (**REST**) services) using ASP.NET Core Minimal APIs. You will
    then learn how to consume web services using HTTP clients, which could be any
    other type of .NET app, including a website or a mobile or desktop app. We will
    create a Blazor WebAssembly client.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter requires the knowledge and skills that you gained in *Chapter 10*,
    *Working with Data Using Entity Framework Core*, and *Chapters 12* to *14*, about
    building websites using ASP.NET Core and Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building web services using ASP.NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a web service for the Northwind database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting and trying out web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming web services using HTTP clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building web services using ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we build a modern web service, we need to cover some background to set
    the context for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding web service acronyms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although HTTP was originally designed to request and respond with HTML and other
    resources for humans to look at, it is also good for building services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Roy Fielding stated in his doctoral dissertation, describing the **REST** architectural
    style, that the HTTP standard would be good for building services because it defines
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: URIs to uniquely identify resources, like `https://localhost:5151/products/23`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods for performing common tasks on those resources, like `GET`, `POST`,
    `PUT`, and `DELETE`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The ability to negotiate the media type of content exchanged in requests and
    responses, such as XML and JSON. Content negotiation happens when the client specifies
    a request header like `Accept: application/xml,*/*;q=0.8`. The default response
    format used by the ASP.NET Core web services is JSON, which means one of the response
    headers would be `Content-Type: application/json; charset=utf-8`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web services** use the HTTP communication standard, so they are sometimes
    called **HTTP services** or **RESTful services**.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding HTTP requests and responses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTP defines standard types of requests and standard codes to indicate a type
    of response. Most of them can be used to implement web services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common type of request is `GET`, to retrieve a resource identified
    by a unique path, with additional options like what media type is acceptable to
    set as a request header, like `Accept`, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Common responses include success and multiple types of failure, as shown in
    *Table 15.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Status code** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `101 Switching Protocols` | The requester has asked the server to switch
    protocols and the server has agreed to do so. For example, it is common to switch
    from HTTP to **WebSockets** (**WS**) for more efficient communication. |'
  prefs: []
  type: TYPE_TB
- en: '| `103 Early Hints` | Used to convey hints that help a client make preparations
    to process the final response. For example, the server might send the following
    response before then sending a normal `200 OK` response for a web page that uses
    a stylesheet and JavaScript file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `200 OK` | The path was correctly formed and the resource was successfully
    found, serialized into an acceptable media type, and then returned in the response
    body. The response headers specify the `Content-Type`, `Content-Length`, and `Content-Encoding`,
    for example, `GZIP`. |'
  prefs: []
  type: TYPE_TB
- en: '| `301 Moved Permanently` | Over time, a web service may change its resource
    model, including the path used to identify an existing resource. The web service
    can indicate the new path by returning this status code and a response header
    named `Location` that has the new path. |'
  prefs: []
  type: TYPE_TB
- en: '| `302 Found` | This is the same as `301`. |'
  prefs: []
  type: TYPE_TB
- en: '| `304 Not Modified` | If the request includes the `If-Modified-Since` header,
    then the web service can respond with this status code. The response body is empty
    because the client should use its cached copy of the resource. |'
  prefs: []
  type: TYPE_TB
- en: '| `307 Temporary Redirect` | The requested resource has been temporarily moved
    to the URL in the `Location` header. The browser should make a new request using
    that URL. For example, this is what happens if you enable `UseHttpsRedirection`
    and a client makes an HTTP request. |'
  prefs: []
  type: TYPE_TB
- en: '| `400 Bad Request` | The request was invalid, for example, it used a path
    for a product using an integer ID where the ID value is missing. |'
  prefs: []
  type: TYPE_TB
- en: '| `401 Unauthorized` | The request was valid and the resource was found, but
    the client did not supply credentials or is not authorized to access that resource.
    Re-authenticating may enable access, for example, by adding or changing the `Authorization`
    request header. |'
  prefs: []
  type: TYPE_TB
- en: '| `403 Forbidden` | The request was valid and the resource was found, but the
    client is not authorized to access that resource. Re-authenticating will not fix
    the issue. |'
  prefs: []
  type: TYPE_TB
- en: '| `404 Not Found` | The request was valid, but the resource was not found.
    The resource may be found if the request is repeated later. To indicate that a
    resource will never be found, return `410 Gone`. |'
  prefs: []
  type: TYPE_TB
- en: '| `406 Not Acceptable` | If the request has an `Accept` header that only lists
    media types that the web service does not support. For example, if the client
    requests JSON but the web service can only return XML. |'
  prefs: []
  type: TYPE_TB
- en: '| `451 Unavailable for Legal Reasons` | A website hosted in the USA might return
    this for requests coming from Europe to avoid having to comply with the **General
    Data Protection Regulation** (**GDPR**). The number was chosen as a reference
    to the novel Fahrenheit 451, in which books are banned and burned. |'
  prefs: []
  type: TYPE_TB
- en: '| `500 Server Error` | The request was valid, but something went wrong on the
    server side while processing the request. Retrying again later might work. |'
  prefs: []
  type: TYPE_TB
- en: '| `503 Service Unavailable` | The web service is busy and cannot handle the
    request. Trying again later might work. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 15.1: Common HTTP status code responses to the GET method'
  prefs: []
  type: TYPE_NORMAL
- en: Other common types of HTTP requests include `POST`, `PUT`, `PATCH`, or `DELETE`,
    which create, modify, or delete resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new resource, you might make a `POST` request with a body that
    contains the new resource, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a new resource or update an existing resource, you might make a `PUT`
    request with a body that contains a whole new version of the existing resource,
    and if the resource does not exist, it is created, or if it does exist, it is
    replaced (sometimes called an **upsert** operation), as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To update an existing resource more efficiently, you might make a `PATCH` request
    with a body that contains an object with only the properties that need changing,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete an existing resource, you might make a `DELETE` request, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As well as the responses shown in the table above for a `GET` request, all
    the types of requests that create, modify, or delete a resource have additional
    possible common responses, as shown in *Table 15.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Status code** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `201 Created` | The new resource was created successfully, the response header
    named `Location` contains its path, and the response body contains the newly created
    resource. Immediately `GET`-ing the resource should return `200`. |'
  prefs: []
  type: TYPE_TB
- en: '| `202 Accepted` | The new resource cannot be created immediately, so the request
    is queued for later processing, and immediately `GET`-ing the resource might return
    `404`. The body can contain a resource that points to some form of status checker
    or an estimate of when the resource will become available. |'
  prefs: []
  type: TYPE_TB
- en: '| `204 No Content` | Commonly used in response to a `DELETE` request since
    returning the resource in the body after deleting it does not usually make sense!
    Sometimes used in response to `POST`, `PUT`, or `PATCH` requests if the client
    does not need to confirm that the request was processed correctly. |'
  prefs: []
  type: TYPE_TB
- en: '| `405 Method Not Allowed` | Returned when the request used a method that is
    not supported. For example, a web service designed to be read-only may explicitly
    disallow `PUT`, `DELETE`, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| `415 Unsupported Media Type` | Returned when the resource in the request
    body uses a media type that the web service cannot handle. For example, if the
    body contains a resource in XML format but the web service can only process JSON.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 15.2: Common HTTP status code responses to other methods like POST and
    PUT'
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core Minimal APIs projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will build a web service that provides a way to work with data in the Northwind
    database using ASP.NET Core so that the data can be used by any client application
    on any platform that can make HTTP requests and receive HTTP responses.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, you use the **ASP.NET Core Web API** / `dotnet new webapi` project
    template. This allows the creation of a web service implemented using either controllers
    or the newer Minimal APIs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** With .NET 6 and .NET 7, the `dotnet new webapi` command creates
    a service implemented using controllers. With .NET 6 and .NET 7, to implement
    the service using Minimal APIs, you need to add the `--use-minimal-apis` switch
    to the command. Using .NET 8 or later, the `dotnet new webapi` command creates
    a service implemented using Minimal APIs. To implement the service using controllers,
    you need to add the `--use-controllers` switch.'
  prefs: []
  type: TYPE_NORMAL
- en: Minimal APIs web service and native AOT compilation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '.NET 8 introduced the **ASP.NET Core Web API (native AOT)** / `dotnet new webapiaot`
    project template, which only uses Minimal APIs and supports native AOT publishing.
    More components of .NET will support AOT over time, as you can read in the following
    quote:'
  prefs: []
  type: TYPE_NORMAL
- en: “We expect to make progress investigating Native AOT support for MVC & Blazor
    in the .NET 9 timeframe, but we don’t expect to deliver production ready Native
    AOT support for .NET 9 given the large amount of work involved.” – Dan Roth
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://github.com/dotnet/aspnetcore/issues/51834#issuecomment-1913300365](https://github.com/dotnet/aspnetcore/issues/51834#issuecomment-1913300365)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Minimal APIs work especially well with **Vertical Slice
    Architecture (VSA)**. A major benefit of Minimal APIs over a controller-based
    Web API is that each Minimal API endpoint only needs to instantiate the **dependency
    injection** (**DI**) services that it needs. With controllers, to execute any
    action method within that controller, all DI services used in any of the action
    methods must be instantiated for every call. This is a waste of time and resources!'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an ASP.NET Core Minimal API project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s go:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to open the `ModernWeb` solution and then add
    a new project, as defined in the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **ASP.NET Core Web API** / `webapi`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `ModernWeb`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `Northwind.WebApi`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are using Visual Studio, then confirm the following defaults have been
    chosen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Authentication type**: None'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configure for HTTPS**: Selected'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enable container support**: Cleared'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enable OpenAPI support**: Selected'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do not use top-level statements**: Cleared'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use controllers**: Cleared'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure to clear the **Use controllers** check box, or your code will look
    very different to what you will see in this book!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using VS Code or Rider, then in the `ModernWeb` directory, at the
    command prompt or terminal, enter the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the `Northwind.WebApi` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the project file, remove the version number for the package that implements
    OpenAPI web service documentation because we are using CPM, as shown in the following
    markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, review the code, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'While reviewing the preceding code, note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The program starts with a similar configuration to any other ASP.NET Core project,
    with a call to `WebApplication.CreateBuilder`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The services collection has an OpenAPI service added. This is used to document
    a web service. In .NET 8 and earlier, the third-party Swashbuckle package was
    used to do this, but with .NET 9 and later, Microsoft has written their own implementation.
    You can read more about this at the following link: [https://github.com/dotnet/aspnetcore/issues/54599](https://github.com/dotnet/aspnetcore/issues/54599).
    By default, OpenAPI document generation creates a document that is compliant with
    v3.0 of the OpenAPI specification: [https://spec.openapis.org/oas/v3.0.0](https://spec.openapis.org/oas/v3.0.0).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During development, the OpenAPI documentation is mapped as endpoints so that
    other developers can use it to create clients easily. By default, the OpenAPI
    endpoint registered via a call to MapOpenApi exposes the document at the [/openapi/{documentName}.json](https://openapi/%7BdocumentName%7D.json)
    endpoint. By default, the `documentName` is `v1`. In the production environment,
    these endpoints are not mapped because they are no longer necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MapGet` call registers a relative path of `/weatherforecast` to respond
    to HTTP `GET` requests, and its implementation uses the shared `Random` object
    to return an array of `WeatherForecast` objects with random temperatures and summaries
    like `Bracing` or `Balmy` for the next five days of weather.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let’s allow the HTTP request to specify how many days ahead the forecast
    should be. At the same time, we will implement good practices by putting the weather
    endpoint implementation in its own code file:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new class file named `Program.Weather.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Weather.cs`, add statements to extend the automatically generated
    `partial` `Program` class by moving (cut and paste the statements) the weather-related
    statements from `Program.cs` and making small adjustments like defining a `GetWeather`
    method with a `days` parameter to control how many weather forecasts to generate,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, modify the `MapGet` call, as shown highlighted in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `MapGet` call, note the route template pattern `{days:int?}` constrains
    the `days` parameter to `int` values. The `?` makes the `days` parameter optional,
    and if missing it will default to `5`.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the web service’s functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we will test the web service’s functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Properties` folder, in `launchSettings.json`, note that by default,
    if you are using Visual Studio, the `https` profile will launch the browser and
    navigate to the `/weatherforecast` relative URL path, as shown highlighted in
    the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the `https` profile, for its `applicationUrl`, change the random port number
    for HTTPS to `5151` and for HTTP to `5150`, as shown highlighted in the following
    markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save changes to all modified files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the `Northwind.WebApi` web service project using the `https` launch profile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On Windows, if you see a **Windows Security Alert** dialog box saying **Windows
    Defender Firewall has blocked some features of this app**, then click the **Allow
    access** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start Chrome, navigate to `https://localhost:5151/`, and note you will get a
    `404` status code response because we have not enabled static files and there
    is not an `index.html`. Remember that this project is not designed for a human
    to view and interact with, so this is expected behavior for a web service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Chrome, show **Developer Tools**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to `https://localhost:5151/weatherforecast` and note the web service
    should return a JSON document with five random weather forecast objects in an
    array, as shown in *Figure 15.1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_15_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.1: A request and response from a weather forecast web service'
  prefs: []
  type: TYPE_NORMAL
- en: Close **Developer Tools**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `https://localhost:5151/weatherforecast/14` and note that the response
    when requesting a two-week weather forecast contains 14 forecasts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Pretty print** checkbox, as shown in *Figure 15.1*, and note that
    recent versions of Chrome can now format JSON responses better for humans to read.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close Chrome and shut down the web server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Route constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To register the `/weatherforecast` route endpoint, we used a route constraint
    to limit acceptable values for the `days` parameter to integers, as shown highlighted
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Route constraints allow us to control matches based on data types and other
    validation. They are summarized in *Table 15.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Constraint** | **Example** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `required` | `{id:required}` | The parameter has been provided. |'
  prefs: []
  type: TYPE_TB
- en: '| `int` and `long` | `{id:int}` | Any integer of the correct size. |'
  prefs: []
  type: TYPE_TB
- en: '| `decimal`, `double`, and `float` | `{unitprice:decimal}` | Any real number
    of the correct size. |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | `{discontinued:bool}` | Case-insensitive match on `true` or `false`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `datetime` | `{hired:datetime}` | An invariant culture date/time. |'
  prefs: []
  type: TYPE_TB
- en: '| `guid` | `{id:guid}` | A GUID value. |'
  prefs: []
  type: TYPE_TB
- en: '| `minlength(n)`, `maxlength(n)`, `length(n)`, and `length(n, m)` | `{title:minlength(5)}`,
    `{title:length(5, 25)}` | The text must have the defined minimum and/or maximum
    length. |'
  prefs: []
  type: TYPE_TB
- en: '| `min(n)`, `max(n)`, and `range(n, m)` | `{age:range(18, 65)}` | The integer
    must be within the defined minimum and/or maximum range. |'
  prefs: []
  type: TYPE_TB
- en: '| `alpha`, `regex` | `{firstname:alpha}`, `{id:regex(^[A-Z]{{5}}$)}` | The
    parameter must match one or more alphabetic characters or the regular expression.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 15.3: Route constraints with examples and descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use colons to separate multiple constraints, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: For regular expressions, `RegexOptions.IgnoreCase | RegexOptions.Compiled |
    RegexOptions.CultureInvariant` is added automatically. Regular expression tokens
    must be escaped (replace `\` with `\\`, `{` with `{{`, and `}` with `}}`) or use
    verbatim string literals.
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: You can create custom route constraints by defining a
    class that implements `IRouteConstraint`. This is beyond the scope of this book,
    but you can read about it at the following link: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing#custom-route-constraints](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing#custom-route-constraints).'
  prefs: []
  type: TYPE_NORMAL
- en: Short-circuit routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When routing matches a request to an endpoint, it lets the rest of the middleware
    pipeline run before invoking the endpoint logic. That takes time, so in ASP.NET
    Core 8 and later, you can invoke the endpoint immediately and return the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'You do this by calling the `ShortCircuit` method on a mapped endpoint route,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can call the `MapShortCircuit` method to respond with a
    `404 Missing Resource` or other status code for resources that don’t need further
    processing, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Improved route tooling in ASP.NET Core 8 and later
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Microsoft has improved the tooling for working with routes for all ASP.NET
    Core 8 and later technologies including Web APIs and Blazor. The features include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Route syntax highlighting**: Different parts of routes are now highlighted
    in your code editor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Autocompletion**: Parameter and route names and route constraints are autocompleted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Route analyzers and fixers**: These address common problems that developers
    have when implementing their routes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can read about them in the blog article *ASP.NET Core Route Tooling Enhancements
    in .NET 8*, found at the following link: [https://devblogs.microsoft.com/dotnet/aspnet-core-route-tooling-dotnet-8/](https://devblogs.microsoft.com/dotnet/aspnet-core-route-tooling-dotnet-8/).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding endpoint route handler return types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An endpoint lambda expression can return .NET types like a single `string` value;
    complex objects defined by a `class`, `record`, or `struct`; or collections of
    complex objects. ASP.NET Core Minimal APIs will serialize them into JSON or plain
    text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following endpoint route handler, which returns a `string` value,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'ASP.NET Core Minimal APIs will return a `200` status code with a `Content-Type:
    text/plain; charset=utf-8` header and the following content in the body: `Hello
    World`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider the following endpoint route handler, which returns an anonymous
    type, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'ASP.NET Core Minimal APIs will return a `200` status code with a `Content-Type:
    application/json; charset=utf-8` header and the following content in the body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: For more control over the response, there are helper methods that return an
    `IResult`, which defines a contract that represents the result of an HTTP endpoint.
    The static `Results` and `TypedResults` classes can be used to create various
    `IResult` objects that represent different types of responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning `TypedResults` rather than `Results` has the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TypedResults` helpers return strongly typed objects, which can improve code
    readability and unit testing and reduce the chance of runtime errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation type automatically provides the response type metadata for
    OpenAPI to describe the endpoint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TypedResults` class has a property named `Empty` that produces an empty
    result response, which when executed will do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TypedResults` class has methods to make it easy to return different responses,
    as shown in *Table 15.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Bytes` | Returns a `200` status code and writes byte-array content to the
    response. |'
  prefs: []
  type: TYPE_TB
- en: '| `Content` | Returns a `200` status code and writes the content string to
    the HTTP response. Has an optional parameter to specify the media type header.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `File` | Returns a `200` status code and writes the specified `Stream` to
    the response. |'
  prefs: []
  type: TYPE_TB
- en: '| `Json` | Returns a `200` status code and serializes the specified data object
    in JSON format to the response. |'
  prefs: []
  type: TYPE_TB
- en: '| `Ok` | Returns a `200` status code and a resource converted into the client’s
    preferred format, like JSON or XML. Commonly used in response to a `GET` request.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Created`, `CreatedAtRoute` | Returns a `201` status code and the path to
    the new resource. Commonly used in response to a `POST` request to create a resource
    that can be created quickly. |'
  prefs: []
  type: TYPE_TB
- en: '| `Accepted`, `AcceptedAtRoute` | Returns a `202` status code to indicate the
    request is being processed but has not been completed. Commonly used in response
    to a `POST`, `PUT`, `PATCH`, or `DELETE` request that triggers a background process
    that takes a long time to complete. |'
  prefs: []
  type: TYPE_TB
- en: '| `Redirect`, `RedirectToRoute` | Returns a `301`, `307`, or `308` status code
    depending on a temporary or permanent redirect `bool` parameter, with the `url`
    to redirect to. |'
  prefs: []
  type: TYPE_TB
- en: '| `Problem` | Produces a `ProblemDetails` response. |'
  prefs: []
  type: TYPE_TB
- en: '| `NoContent` | Returns a `204` status code and an empty response body. Commonly
    used in response to a `PUT`, `PATCH`, or `DELETE` request when the response does
    not need to contain the affected resource. |'
  prefs: []
  type: TYPE_TB
- en: '| `BadRequest` | Returns a `400` status code and an optional message string
    with more details. |'
  prefs: []
  type: TYPE_TB
- en: '| `NotFound` | Returns a `404` status code and automatically populates the
    `ProblemDetails` body (requires a compatibility version of 2.2 or later). |'
  prefs: []
  type: TYPE_TB
- en: 'Table 15.4: TypedResults helper methods that return a response'
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: You can learn more about how to create responses in a
    Minimal APIs web service at the following link: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/responses?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/responses?view=aspnetcore-9.0).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a web service for the Northwind database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will reference the Entity Framework Core entity data model for the Northwind
    database that you created in *Chapter 12*, *Introducing Modern Web Development
    Using .NET*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Northwind.WebApi` project, globally and statically import the `System.Console`
    class, and add a project reference to the Northwind data context class library
    for either SQLite or SQL Server, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the `Northwind.WebApi` project and fix any compile errors in your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, import namespaces for working with the Northwind entity model,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add a statement before the call to `Build` to register the
    `Northwind` database context class (it will use either SQLite or SQL Server depending
    on which database provider you referenced in the project file), as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Registering dependency services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can register dependency services with different lifetimes, as shown in
    the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transient**: These services are created each time they’re requested. Transient
    services should be lightweight and stateless.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scoped**: These services are created once per client request and are disposed
    of. Then, the response is returned to the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Singleton**: These services are usually created the first time they are requested
    and then are shared, although you can provide an instance at the time of registration
    too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduced in .NET 8 is the ability to set a key for a dependency service. This
    allows multiple services to be registered with different keys and then retrieved
    later using that key.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this book, you will use all three types of lifetimes, but we will not need
    to use keyed services.
  prefs: []
  type: TYPE_NORMAL
- en: In-memory, distributed, and hybrid caches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s see an overview of in-memory, distributed, and hybrid caching.
  prefs: []
  type: TYPE_NORMAL
- en: In-memory caching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In-memory caching stores data in the memory of the web server where the application
    is running. This is useful for small to medium-sized applications where the caching
    needs are not too extensive and can be handled by a single server’s memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key points about in-memory caching are shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance**: Fast retrieval since the data is stored locally in RAM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplicity**: Easy to implement and configure within the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Volatility**: Data is lost if the application restarts or the server goes
    down.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: Limited to a single server’s memory; not suitable for large-scale
    applications needing distributed caching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To implement in-memory caching, add the memory cache service to the services
    collection in `Program.cs`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieve the service in an endpoint, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Set data in the cache, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Get data from the cache, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s compare in-memory caching to distributed caching.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed caching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Distributed caching allows caching data across multiple servers, making it suitable
    for large-scale, distributed applications. This ensures data availability and
    consistency across different nodes in a web farm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key points about in-memory caching are shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scalability**: Can handle large datasets and provide caching across multiple
    servers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistence**: Depending on the provider, data can be persisted beyond application
    restarts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Latency**: May have higher latency compared to in-memory caching due to network
    calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Providers**: Common providers include Redis, SQL Server, and NCache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To implement in-memory caching, add it to the services collection in `Program.cs`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieve the service in an endpoint, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Set data in the cache, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Get data from the cache, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: So, in-memory caching is fast and simple but limited to the server’s memory
    and loses data on restart. Distributed caching is scalable and persistent, ideal
    for large applications, with various providers like Redis and SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: Both approaches help improve application performance by reducing the need to
    repeatedly fetch or compute data. The choice between them depends on the application’s
    scale, performance needs, and architecture.
  prefs: []
  type: TYPE_NORMAL
- en: But what if we could get the best of both worlds?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see a new option called hybrid caching.
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid caching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The HybridCache API introduced with ASP.NET Core 9 addresses some limitations
    found in the `IDistributedCache` and `IMemoryCache` APIs. As an abstract class
    with a default implementation, `HybridCache` efficiently manages most tasks related
    to storing and retrieving data from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key points about hybrid caching are shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unified API**: Provides a single interface for both in-process and out-of-process
    caching. `HybridCache` can seamlessly replace any existing `IDistributedCache`
    and `IMemoryCache` usage. It always uses the in-memory cache initially, and when
    an `IDistributedCache` implementation is available, `HybridCache` leverages it
    for secondary caching. This dual-level caching approach combines the speed of
    in-memory caching with the durability of distributed or persistent caching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stampede Protection**: `HybridCache` prevents cache stampedes, which occur
    when a frequently used cache entry is invalidated, causing multiple requests to
    try to repopulate it simultaneously. `HybridCache` merges concurrent operations,
    ensuring all requests for the same response wait for the first request to be completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configurable Serialization**: `HybridCache` allows for configurable serialization
    during service registration, supporting both type-specific and generalized serializers
    via the `WithSerializer` and `WithSerializerFactory` methods, which are chained
    from the `AddHybridCache` call. By default, it manages `string` and `byte[]` internally
    and utilizes `System.Text.Json` for other types. It can be configured to use other
    serializers, such as Protobuf or XML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although HybridCache was introduced with .NET 9, its package targets .NET Standard
    2.0, so it can be used with older versions of .NET, even .NET Framework 4.6.2
    or later.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve learned the concepts and basic implementation options for caching,
    let’s create a data repository for our web service that caches entities to improve
    performance and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Creating data repositories with caching for entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Defining and implementing a data repository to provide CRUD operations is good
    practice. We will create a data repository for the `Customers` table in Northwind.
    There are only 91 customers in this table, so we will cache a copy of the whole
    table in memory to improve scalability and performance when reading customer records.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: In a real web service, you should use a distributed cache
    like Redis, an open-source data structure store that can be used as a high-performance,
    high-availability database, cache, or message broker. You can learn about this
    at the following link: [https://learn.microsoft.com/en-us/aspnet/core/performance/caching/distributed](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/distributed).'
  prefs: []
  type: TYPE_NORMAL
- en: In .NET 9, `HybridCache` was introduced, which automatically switches between
    in-memory and distributed cache types.
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: You can learn more about `HybridCache` at the following
    link: [https://learn.microsoft.com/en-us/aspnet/core/performance/caching/hybrid?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/hybrid?view=aspnetcore-9.0).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will follow a modern good practice and make the repository API asynchronous.
    It will be instantiated by an endpoint using parameter injection, so a new instance
    is created to handle every HTTP request. It will use a singleton instance of `HybridCache`.
    Let’s go:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Northwind.WebApi.csproj` project file, add a package reference for
    hybrid caching, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, import the namespace for working with a hybrid cache, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, before the call to `Build`, in the section for configuring
    services, register the hybrid cache service with a default cache entry duration
    of 60 seconds overall, and 30 seconds for local in-memory caching, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Northwind.WebApi` project, create a folder named `Repositories`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new interface file and a class file to the `Repositories` folder, named
    `ICustomerRepository.cs` and `CustomerRepository.cs`, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `ICustomerRepository.cs`, define an interface with five CRUD methods, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `CustomerRepository.cs`, define a class that will implement the interface
    and uses the hybrid cache (its methods will be implemented over the next few steps,
    so, for now, ignore the errors you will be shown), as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the method that retrieves all customers to always read the latest
    customers from the database, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `Retrieve` method to get the customer from the cache if possible,
    or from the data model, and set it in the cache for next time, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `Create` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `Update` method to update the database, and if successful, update
    the cached customer as well, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `Delete` method to delete the customer from the database, and
    if successful, remove the cached customer as well, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Configuring the customer repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’ve learned the theory, you will put it into practice to configure
    the repository so that it can be called from within a Minimal API endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: You will register a scoped dependency service implementation for the repository
    when the web service starts up, and then use constructor parameter injection to
    get it inside the definition of a new Minimal API endpoint for working with customers.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will have five action methods to perform CRUD operations on customers—two
    `GET` methods (for all customers or one customer), `POST` (create), `PUT` (update),
    and `DELETE`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, import the namespace for working with our customer repository,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add a statement before the call to the `Build` method, which
    will register the `CustomerRepository` for use at runtime as a scoped dependency,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Our repository uses a database context that is registered
    as a scoped dependency. You can only use scoped dependencies inside other scoped
    dependencies, so we cannot register the repository as a singleton. You can read
    more about this at the following link: [https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#scoped](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#scoped).'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Northwind.WebApi` project, add a new class named `Program.Customers.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Customers.cs`, add statements to define two Minimal API endpoint
    route handlers that respond to HTTP `GET` requests for all customers or customers
    within a specified country, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.Customers.cs`, in the `MapCustomers` method, add statements to
    map an endpoint route handler that responds to HTTP `GET` requests for an individual
    customer, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.Customers.cs`, add statements to map an endpoint route handler
    that responds to HTTP `POST` requests to insert a new customer entity, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.Customers.cs`, add statements to map an endpoint route handler
    that responds to HTTP `PUT` requests, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.Customers.cs`, add statements to map an endpoint route handler
    that responds to HTTP `DELETE` requests, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, before the call to `Run`, call the extension method to map
    all the customer endpoint route handlers, as shown highlighted in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save all the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When an HTTP request is received by the service, it will create an instance
    of the `Controller` class, call the appropriate action method, return the response
    in the format preferred by the client, and release the resources used by the controller,
    including the repository and its data context.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying problem details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A feature added in ASP.NET Core 2.1 and later is an implementation of a web
    standard for specifying problem details. If you want to take control, then you
    can create a `ProblemDetails` instance yourself and include additional information.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s simulate a bad request that needs custom data to be returned to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the implementation of the `Delete` endpoint route handler, add
    statements to check if the `id` matches the literal string value `"bad"`, and
    if so, return a custom `ProblemDetails` object, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You will try out this functionality later.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting and trying out web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can easily try out a web service by making HTTP `GET` requests using a browser.
    To try out other HTTP methods, we need a more advanced tool.
  prefs: []
  type: TYPE_NORMAL
- en: Trying out GET requests using a browser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will use Chrome to try out the three implementations of a `GET` request—for
    all customers, for customers in a specified country, and for a single customer
    using their unique customer ID:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the `Northwind.WebApi` web service project using the `https` launch profile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start Chrome, navigate to `https://localhost:5151/customers`, and note the
    JSON document returned, containing all 91 customers in the Northwind database
    (unsorted), as shown in *Figure 15.2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_15_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.2: Customers from the Northwind database as a JSON document'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to `https://localhost:5151/customers/in/Germany` and note the JSON
    document returned, containing only the customers in Germany.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you get an empty array `[]` returned, then make sure you have entered the
    country name using the correct casing, because the database query is case-sensitive.
    For example, compare the results of `uk` and `UK`.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to `https://localhost:5151/customers/alfki` and note the JSON document
    returned containing only the customer named **Alfreds Futterkiste**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unlike country names, we do not need to worry about casing for the customer
    `id` value because, in the customer repository implementation, we normalized the
    `string` value as uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: But how can we try out the other HTTP methods, such as `POST`, `PUT`, and `DELETE`?
    And how can we document our web service so it’s easy for anyone to understand
    how to interact with it?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many tools for testing web services, for example, **Postman**. Although
    Postman is popular, I prefer tools like **HTTP Editor** in Visual Studio or **REST
    Client** in VS Code because they do not hide what is happening. I feel Postman
    is too GUI-y. But I encourage you to explore different tools and find the ones
    that fit your style. You can learn more about Postman at the following link: [https://www.postman.com/](https://www.postman.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: To solve the first problem, we can use the **HTTP Editor** tool built into Visual
    Studio and install a VS Code extension named **REST Client**. Rider has its own
    equivalent. These are tools that allow you to send any type of HTTP request and
    view the response in your code editor.
  prefs: []
  type: TYPE_NORMAL
- en: To solve the second problem, we can use **OpenAPI**, aka **Swagger**, the world’s
    most popular technology for documenting HTTP APIs. But first, let’s see what is
    possible with the code editor HTTP/REST tools.
  prefs: []
  type: TYPE_NORMAL
- en: Making GET requests using HTTP/REST tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by creating a file for making `GET` requests:'
  prefs: []
  type: TYPE_NORMAL
- en: If you have not already installed **REST Client** by Huachao Mao (`humao.rest-client`),
    then install it for VS Code now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your preferred code editor, open the `ModernWeb` solution and then start
    the `Northwind.WebApi` project web service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **File Explorer**, **Finder**, or your favorite Linux file tool, in the `ModernWeb`
    folder, create an `HttpRequests` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `HttpRequests` folder, create a file named `get-customers.http`, and
    open it in your preferred code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `get-customers.http`, modify its contents to contain an HTTP `GET` request
    to retrieve all customers, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Above the HTTP `GET` request, click **Send request**, as shown in *Figure 15.3*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note the response is shown in a new tabbed window.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Visual Studio, then click the **Raw** tab, and note the JSON
    that was returned, as shown in *Figure 15.3*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_15_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.3: Sending an HTTP GET request using Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP Editor in Visual Studio version 17.8 and later is a feature designed to
    add REST client-like capabilities, and its user interface is likely to evolve
    rapidly as it catches up. You can read its official documentation at the following
    link: [https://learn.microsoft.com/en-us/aspnet/core/test/http-files](https://learn.microsoft.com/en-us/aspnet/core/test/http-files).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `get-customers.http`, add more `GET` requests, each separated by three hash
    symbols, to test getting customers in various countries and getting a single customer
    using their ID, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click the **Send Request** link above each request to send it, and confirm you
    get the expected response, like a 404 for a non-existent customer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Making other requests using HTTP/REST tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we will create a file for making other requests like `POST`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `HttpRequests` folder, create a file named `create-customer.http` and
    modify its contents to define a `POST` request to create a new customer, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Send the request and note the response is `201 Created`. Also note in the **Headers**
    section that the **Location** (that is, the URL) of the newly created customer
    is `/customers/ABCXY`, as shown in *Figure 15.4*, and the response included the
    newly created customer in the response body (not shown in the screenshot but you
    can see it in the **Formatted** and **Raw** sections):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_15_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.4: Adding a new customer by POSTing to the web service'
  prefs: []
  type: TYPE_NORMAL
- en: 'I will leave you an optional challenge to create `.http` files that try updating
    a customer (using `PUT`) and deleting a customer (using `DELETE`). Try them on
    customers that do exist as well as customers that do not. Solutions are in the
    GitHub repository for this book at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/tree/main/code/ModernWeb/HttpRequests](https://github.com/markjprice/cs13net9/tree/main/code/ModernWeb/HttpRequests)'
  prefs: []
  type: TYPE_NORMAL
- en: Passing environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get an environment variable in a `.http` script, use `$processenv`, as shown
    in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if you have set an environment variable to store a secret value
    like a password to connect to a SQL Server database that must be kept out of any
    files committed to a GitHub repository, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '**More Information**: You can learn more about using environment variables
    with the REST client at the following link: [https://marketplace.visualstudio.com/items?itemName=humao.rest-client#environments](https://marketplace.visualstudio.com/items?itemName=humao.rest-client#environments).
    You can learn more about using environment variables and Secret Manager with HTTP
    Editor at the following link: [https://devblogs.microsoft.com/visualstudio/safely-use-secrets-in-http-requests-in-visual-studio-2022/](https://devblogs.microsoft.com/visualstudio/safely-use-secrets-in-http-requests-in-visual-studio-2022/).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen a quick and easy way to test our service, which also happens
    to be a great way to learn HTTP, what about external developers? We want it to
    be as easy as possible for them to learn about and then call our service. For
    that purpose, we will use Swagger.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the OpenAPI Specification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **OpenAPI Specification** defines a REST-style contract for your API, detailing
    all its resources and operations in a human- and machine-readable format for easy
    development, discovery, and integration.
  prefs: []
  type: TYPE_NORMAL
- en: Developers can use the OpenAPI Specification for a web service to automatically
    generate strongly typed client-side code in their preferred language or library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s review how OpenAPI is enabled for our web service:'
  prefs: []
  type: TYPE_NORMAL
- en: If the web service is running, shut down the web server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Northwind.WebApi.csproj`, note the package reference for Microsoft’s package
    that implements documentation for OpenAPI that was added by the project template,
    as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, in the section for adding services to the container, note
    the service registered by the project template to use OpenAPI, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By default, the document name is `v1`. Set the document name parameter to `v2`,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the section that configures the HTTP request pipeline, note the statements
    for using OpenAPI when in development mode, as shown highlighted in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Start the `Northwind.WebApi` web service project using the `https` launch profile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start Chrome, navigate to `https://localhost:5151/openapi/v2.json`, and note
    the JSON document returned, as shown in *Figure 15.5*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_15_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.5: OpenAPI JSON documentation for the Northwind web service'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the following about the OpenAPI JSON document:'
  prefs: []
  type: TYPE_NORMAL
- en: It specifies all the relative paths for the service, like `/weatherforecast/{days}`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For parameters like `days`, it specifies their type and default value, like
    `"parameters":[{"name":"days","in":"path","required":true,"schema":{"type":"integer","format":"int32","default":5}}]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two techniques that you can use to add extra information to the generated
    documentation, `WithSummary` and `WithDescription`. These are available as either
    calling extension methods after mapping the endpoint or by decorating the lambda
    expression with attributes, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '**More Information**: You can learn more at the following link: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/openapi?view=aspnetcore-9.0#describe-endpoints](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/openapi?view=aspnetcore-9.0#describe-endpoints).'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling HTTP logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'HTTP logging is an optional middleware component that is useful when testing
    a web service. It logs information about HTTP requests and HTTP responses, including
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Information about the HTTP request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information about the HTTP response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is valuable in web services for auditing and debugging scenarios but beware
    because it can negatively impact performance. You might also log **Personally
    Identifiable Information** (**PII**), which can cause compliance issues in some
    jurisdictions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Log levels can be set to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Error`: Only `Error` level logs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Warning`: `Error` and `Warning` level logs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Information`: `Error`, `Warning`, and `Information` level logs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Verbose`: All level logs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Log levels can be set for the namespace in which the functionality is defined.
    Nested namespaces allow us to control which functionality has logging enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Microsoft`: Include all log types in the `Microsoft` namespace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.AspNetCore`: Include all log types in the `Microsoft.AspNetCore`
    namespace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.AspNetCore.HttpLogging`: Include all log types in the `Microsoft.AspNetCore.HttpLogging`
    namespace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see HTTP logging in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Northwind.WebApi` project, `appsettings.Development.json`, add an entry
    to set the HTTP logging middleware to the `Information` level, as shown highlighted
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Although the `Default` log level might be set to `Information`, more specific
    configurations take priority. For example, any logging systems in the `Microsoft.AspNetCore`
    namespace will use the `Warning` level. By making the change we did, any logging
    systems in the `Microsoft.AspNetCore.` `HttpLogging.HttpLoggingMiddleware` namespace
    will now use `Information`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.cs`, import the namespace for working with HTTP logging, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the services configuration section, before the call to `Build`, add a statement
    to configure HTTP logging, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the HTTP pipeline configuration section, before the call to `app.UseHttpsRedirection`,
    add a statement to add HTTP logging, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Start the `Northwind.WebApi` web service using the `https` launch profile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start Chrome and navigate to `https://localhost:5151/customers`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the command prompt or terminal that shows the output from the web service
    host, note the request and response have been logged, as shown in the following
    partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Close Chrome and shut down the web server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Logging to the Windows-only Event Log
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When configuring logging, you might want to enable logging to the Windows Event
    Log, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: You will see a code analyzer warning, `CA1416`, because enabling Event Log only
    works on Windows. If you run this code on any other OS, then a runtime exception
    would be thrown. To avoid the warning (and runtime error), you should wrap the
    call to `AddEventLog` with an OS check.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import a namespace, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, wrap any calls to `AddEventLog`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Support for logging additional request headers in W3CLogger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'W3CLogger is a middleware that writes logs in the W3C standard format. You
    can:'
  prefs: []
  type: TYPE_NORMAL
- en: Record details of HTTP requests and responses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filter which headers and parts of the request and response messages are logged.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Warning!** W3CLogger can reduce the performance of an app.'
  prefs: []
  type: TYPE_NORMAL
- en: 'W3CLogger is like HTTP logging, so I will not cover details of how to use it
    in this book. You can learn more about W3CLogger at the following link: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/w3c-logger/](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/w3c-logger/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In ASP.NET Core 7 or later, you can specify that you want to log additional
    request headers when using W3CLogger. Call the `AdditionalRequestHeaders` method
    and pass the name of the header you want to log, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: You are now ready to build applications that consume your web service.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming web services using HTTP clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have built and tested our Northwind service, we will learn how to
    call it from any .NET app using the `HttpClient` class and its factory.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding HttpClient
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to consume a web service is to use the `HttpClient` class. However,
    many people use it wrongly because it implements `IDisposable`, and Microsoft’s
    own documentation shows poor usage of it. See the book links in the GitHub repository
    for articles with more discussion of this.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, when a type implements `IDisposable`, you should create it inside a
    `using` statement to ensure that it is disposed of as soon as possible. `HttpClient`
    is different because it is shared, reentrant, and partially thread-safe.
  prefs: []
  type: TYPE_NORMAL
- en: The problem has to do with how the underlying network sockets must be managed.
    The bottom line is that you should use a single instance of it for each HTTP endpoint
    that you consume during the life of your application. This will allow each `HttpClient`
    instance to have defaults set that are appropriate for the endpoint it works with
    while managing the underlying network sockets efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring HTTP clients
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microsoft is aware of the issue of .NET developers misusing `HttpClient`, and
    in ASP.NET Core 2.1, it introduced `HttpClientFactory` to encourage best practices;
    that is the technique we will use.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will create a Northwind Blazor WebAssembly standalone
    project as a client for the Northwind Web API service. Let’s configure an HTTP
    client:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to open the `ModernWeb` solution and then add
    a new project, as defined in the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Blazor WebAssembly Standalone App**/ `blazorwasm`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `ModernWeb`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `Northwind.WebApi.WasmClient`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authentication type**: None'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configure for HTTPS**: Selected'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Progressive Web Application**: Cleared'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Include sample pages**: Selected'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do not use top-level statements**: Cleared'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `Northwind.WebApi.WasmClient.csproj` project file, in the package references,
    remove version attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Properties` folder, in `launchSettings.json`, for the `https` profile,
    for its `applicationUrl`, change the random port number for HTTPS to `5152` and
    for HTTP to `5153`, as shown highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save changes to all modified files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, in the call to the `AddScoped` method, add a statement to
    enable `HttpClientFactory` with a named client to make calls to the Northwind
    Web API service using HTTPS on port `5151` and request JSON as the default response
    format, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Northwind.WebApi` project, in `Program.cs`, at the top of the file
    after the namespace imports, declare a string constant for the name of a CORS
    policy, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, before the call to `Build`, add CORS and configure a policy
    to allow HTTP calls from clients with different port numbers from the web service
    itself, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, after the call to `UseHttpsRedirection`, enable CORS with
    the named policy, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Getting customers as JSON in a Blazor component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can now create a client page that:'
  prefs: []
  type: TYPE_NORMAL
- en: Makes a `GET` request for customers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deserializes the JSON response using convenient extension methods introduced
    with .NET 5 in the `System.Net.Http.Json` assembly and namespace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s go:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Northwind.WebApi.WasmClient.csproj` project file, add a reference to
    the entity models project, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Northwind.WebApi.WasmClient` project, in `_Imports.razor`, import the
    namespace for working with entity models, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Northwind.WebApi.WasmClient` project, in the `Pages` folder, add a new
    file named `Customers.razor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Customers.razor`, inject the HTTP client service, and use it to call the
    Northwind Web API service, fetching all customers, and passing them to a table,
    as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Layout` folder, in `NavMenu.razor`, change the **Weather** menu item
    to show customers instead, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Starting multiple projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to this point, we have only started one project at a time. Now we have two
    projects that need to be started, a web service and a Blazor client website. In
    the step-by-step instructions, I will only tell you to start individual projects
    one at a time, but you should use whatever technique you prefer to start them.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Visual Studio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Visual Studio can start multiple projects manually one by one if the debugger
    is not attached, as described in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In **Solution Explorer**, right-click on the solution or any project and then
    select **Configure Startup Projects…**, or select the solution and navigate to
    **Project** | **Configure Startup Projects…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Solution ‘<name>’ Property Pages** dialog box, select **Current selection**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a project in **Solution Explorer** so that its name becomes bold.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Debug** | **Start Without Debugging** or press *Ctrl* + *F5*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *steps 2* and *3* for as many projects as you need.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you need to debug the projects, then you must start multiple instances of
    Visual Studio. Each instance can start a single project with debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also configure multiple projects to start up at the same time using
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In **Solution Explorer**, right-click the solution or any project and then select
    **Configure Startup Projects…**, or select the solution and navigate to **Project**
    | **Configure Startup Projects…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Solution ‘<name>’ Property Pages** dialog box, select **Multiple startup
    projects**, and for any projects that you want to start, select either **Start**
    or **Start without debugging**, as shown in *Figure 15.6*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_15_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.6: Selecting multiple projects to start up in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: Click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Debug** | **Start Debugging** or **Debug** | **Start Without Debugging**
    or click the equivalent buttons in the toolbar to start all the projects that
    you selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can learn more about multi-project startup using Visual Studio at the following
    link: [https://learn.microsoft.com/en-us/visualstudio/ide/how-to-set-multiple-startup-projects](https://learn.microsoft.com/en-us/visualstudio/ide/how-to-set-multiple-startup-projects).'
  prefs: []
  type: TYPE_NORMAL
- en: If you are using VS Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need to start multiple projects at the command line with `dotnet`, then
    write a script or batch file to execute multiple `dotnet run` commands, or open
    multiple command prompt or terminal windows.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to debug multiple projects using VS Code, then after you’ve started
    the first debug session, you can just launch another session. Once the second
    session is running, the user interface switches to multi-target mode. For example,
    in the **CALL STACK**, you will see both named projects with their own threads,
    and then the debug toolbar shows a drop-down list of sessions with the active
    one selected. Alternatively, you can define compound launch configurations in
    the `launch.json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about multi-target debugging using VS Code at the following
    link: [https://code.visualstudio.com/Docs/editor/debugging#_multitarget-debugging](https://code.visualstudio.com/Docs/editor/debugging#_multitarget-debugging).'
  prefs: []
  type: TYPE_NORMAL
- en: Starting the web service and Blazor client projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we can try out the web service with the Blazor client calling it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the `Northwind.WebApi` project and confirm that the web service is listening
    on ports `5151` and `5150`, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the `Northwind.WebApi.WasmClient` project and confirm that the website
    is listening on ports `5152` and `5153`, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Start Chrome and navigate to `https://localhost:5152/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the home page, in the left navigation menu, click **Customers**, and note
    the list of customers, as shown in *Figure 15.7*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_15_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.7: Customers worldwide fetched from a web service'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the command prompt or terminal for the web service, note that HTTP logging
    shows that a successful request was made for customers, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the address bar, change the path to specify a country like `Germany`, `UK`,
    or `USA`, for example: `customers/UK`. Press *Enter* and note the table updates
    to only show UK customers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close Chrome and shut down the two web servers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring this chapter’s topics with deeper research.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 15.1 – Online material
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Online material could be created by Microsoft or third-parties, or extra content
    for this book.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing advanced features for web services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you would like to learn about web service health checks, OpenAPI analyzers,
    adding security HTTP headers, and enabling HTTP/3 support for `HttpClient`, then
    you can read the optional online-only section at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch15-advanced.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch15-advanced.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Minimal APIs parameter binding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can learn more about how to convert HTTP request data into strongly typed
    parameters for Minimal APIs endpoints at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/parameter-binding](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/parameter-binding)'
  prefs: []
  type: TYPE_NORMAL
- en: Refit client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refit is an automatic type-safe REST library for .NET. It was inspired by Square’s
    Retrofit library, and it turns your REST service into a live interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/reactiveui/refit](https://github.com/reactiveui/refit)'
  prefs: []
  type: TYPE_NORMAL
- en: Web service security using Microsoft Identity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can learn what’s new with Microsoft Identity for authentication and authorization
    at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/dotnet/whats-new-with-identity-in-dotnet-8/](https://devblogs.microsoft.com/dotnet/whats-new-with-identity-in-dotnet-8/)'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 15.2 – Practice exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Practice exercises go deeper into the topics for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and deleting customers with HttpClient
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Extend the `Northwind.WebApi.ClientWasm` project to have pages where a visitor
    can fill in a form to create a new customer, or search for a customer and then
    delete them. The Blazor components should make calls to the Northwind Web API
    web service to create and delete customers.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 15.3 – Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core has multiple project templates for building web services. What
    are they and how do you create them using the CLI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When configuring an HTTP client, how do you specify the format of data that
    you prefer in the response from the web service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why did the ASP.NET Core team replace the Swashbuckle package with their own
    implementation of OpenAPI support?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What must you do to specify what responses should be expected when calling a
    `MapGet` or similar method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List three methods that can be called to return responses with different status
    codes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List four ways that you can test a web service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you not wrap your use of `HttpClient` in a `using` statement to dispose
    of it when you are finished even though it implements the `IDisposable` interface,
    and what should you use instead?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of HTTP/2 and HTTP/3 compared to HTTP/1.1?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you enable clients to detect if your web service is healthy with ASP.NET
    Core 2.2 and later?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the main types of object caching and why is the `HybridCache` introduced
    with .NET 9 the best?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 15.4 – Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links in the following GitHub repository to learn more details about
    the topics covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-15---building-and-consuming-web-services](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-15---building-and-consuming-web-services)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned:'
  prefs: []
  type: TYPE_NORMAL
- en: How to build an ASP.NET Core web service using Minimal APIs that can be called
    by any app on any platform that can make an HTTP request and process an HTTP response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to document web service APIs with OpenAPI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to test web services using a browser, HTTP editor, or REST client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to consume services efficiently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Epilogue*, I will make some suggestions for books to take you deeper
    into C# and .NET.
  prefs: []
  type: TYPE_NORMAL
