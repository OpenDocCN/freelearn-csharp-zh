- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Understanding the Different Domains in Software Solutions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解软件解决方案中的不同领域
- en: 'This chapter is dedicated to a modern software development technique called
    **domain-driven design** (**DDD**), which was first proposed by Eric Evans (see
    *Domain-Driven Design*: [https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20](https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20)).
    While DDD has existed for more than 15 years, it has achieved great success in
    the last few years because of its ability to cope with two important problems.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于一种现代软件开发技术，称为**领域驱动设计**（**DDD**），它最初由埃里克·埃文斯（Eric Evans）提出（参见《领域驱动设计*》：[https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20](https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20)）。虽然DDD已经存在了15多年，但由于其解决两个重要问题的能力，它在过去几年取得了巨大的成功。
- en: The main problem is modeling complex systems that involve several domains of
    knowledge. No single expert has in-depth knowledge of the whole domain; this knowledge
    is instead split among several people. The second problem is that each expert
    speaks a language that is specific to his domain of expertise, so for effective
    communication between the experts and the development team, objects, interfaces,
    and methods must mimic the language of the domain experts. This means that the
    different modules that compose an application must use a different vocabulary
    for each domain of expertise. Consequently, the application must be split into
    modules that reflect the different domains of knowledge, and the interface between
    modules that deal with the different domains of knowledge must be carefully designed
    to carry out the necessary translations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 主要问题是对涉及多个知识领域的复杂系统进行建模。没有哪个专家对整个领域有深入的了解；这种知识被分散在几个人身上。第二个问题是每个专家都使用其专业领域的特定语言，因此为了专家和开发团队之间有效的沟通，对象、接口和方法必须模仿领域专家的语言。这意味着构成应用程序的不同模块必须为每个专业领域使用不同的词汇。因此，应用程序必须分割成反映不同知识领域的模块，并且处理不同知识领域的模块之间的接口必须精心设计，以执行必要的翻译。
- en: DDD copes with this problem by splitting the whole CI/CD cycle into independent
    parts, assigned to different teams. This way, each team can focus on a specific
    domain of knowledge by interacting only with the experts in that domain.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: DDD通过将整个CI/CD周期分割成独立的部分，分配给不同的团队来解决这一问题。这样，每个团队只需与该领域的专家互动，就可以专注于特定的知识领域。
- en: That’s why the evolution of DDD is interleaved with the evolution of microservices
    and DevOps. Thanks to DDD, big projects can be split among several development
    teams, with each team having a different domain of knowledge. There are many reasons
    why a project is split among several teams, with the most common being the team’s
    size and all of its members having different skills and/or being in different
    locations. In fact, experience has proven that teams of more than 6–8 people are
    not effective, and, clearly, different skills and locations prevent tight interaction
    from occurring.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为这个原因，领域驱动设计（DDD）的演变与微服务和DevOps的演变交织在一起。多亏了DDD，大型项目可以被分割成几个开发团队，每个团队拥有不同的知识领域。项目被分割成几个团队的原因有很多，其中最常见的是团队规模以及所有成员拥有不同的技能和/或位于不同的地点。实际上，经验证明，超过6-8人的团队并不有效，显然，不同的技能和地点会阻碍紧密的互动。
- en: In turn, the importance of the two aforementioned problems has grown in the
    last few years. Software systems have always taken up a lot of space inside every
    organization, and they have become more and more complex and geographically distributed.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，上述两个问题的重视程度在过去几年中有所增加。软件系统始终占据每个组织内部的大量空间，并且它们变得越来越复杂和地理上分散。
- en: At the same time, the need for frequent updates has increased so that these
    complex software systems can be adapted to the needs of a quickly changing market.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，对频繁更新的需求也在增加，以便这些复杂的软件系统可以适应快速变化的市场需求。
- en: As a result of the increasing complexity and need for frequent updates in software
    systems, we now face a scenario where it’s common to implement complex software
    systems with associated fast CI/CD cycles that always require more people to evolve
    and maintain them. In turn, this created a need for technologies that were adequate
    for high-complexity domains and for the cooperation of several loosely coupled
    development teams.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由于软件系统日益复杂和频繁更新的需求，我们现在面临一个常见的场景，即使用具有相关快速CI/CD周期的复杂软件系统，这通常需要更多的人来演进和维护它们。反过来，这创造了对适合高复杂度领域和多个松散耦合的开发团队协作的技术需求。
- en: In this chapter, we will analyze the basic principles, advantages, and common
    patterns related to DDD, as well as how to use them in our solutions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将分析与领域驱动设计（DDD）相关的基本原则、优势和常见模式，以及如何在我们的解决方案中使用它们。
- en: 'More specifically, we will cover the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，我们将涵盖以下主题：
- en: What are software domains?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件领域是什么？
- en: Understanding DDD
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解领域驱动设计（DDD）
- en: Common DDD patterns and architectures
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的DDD模式和架构
- en: Let’s get started.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: As you progress through the second part of the book, you might find it enriching
    to revisit this particular chapter. Reflecting on these concepts with a deeper
    understanding can offer new insights and enhance your overall experience. Feel
    free to come back to this chapter as a resource whenever you encounter related
    ideas later on.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你阅读本书的第二部分，你可能会发现回顾这一特定章节是有益的。对这些概念进行更深入的理解可以提供新的见解并增强你的整体体验。当你以后遇到相关想法时，随时可以回到这一章节作为参考资料。
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术需求
- en: This chapter requires the free Visual Studio 2022 Community Edition or better,
    with all the database tools installed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要免费安装所有数据库工具的Visual Studio 2022 Community Edition或更高版本。
- en: 'All the code snippets in this chapter can be found in the GitHub repository
    associated with this book: [https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有的代码片段都可以在本书相关的GitHub仓库中找到：[https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E)。
- en: What are software domains?
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件领域是什么？
- en: As we discussed in *Chapter 2*, *Non-Functional Requirements*, and *Chapter
    3*, *Managing Requirements*, the transfer of knowledge from domain experts to
    the development team plays a fundamental role in software design. Developers try
    to communicate with experts and describe their solutions in a language that domain
    experts and stakeholders can also understand. However, often, the same word has
    a different meaning in various parts of an organization, and what appears to be
    the same conceptual entities have completely different shapes in different contexts.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如同我们在*第二章*，*非功能性需求*，和*第三章*，*需求管理*中讨论的那样，从领域专家到开发团队的知识转移在软件设计中起着根本的作用。开发者试图用领域专家和利益相关者也能理解的语言与专家沟通并描述他们的解决方案。然而，在组织的各个部分，同一个词可能有不同的含义，而在不同的背景下，看似相同的概念实体可能有完全不同的形态。
- en: For instance, in our WWTravelClub use case, the order-payment and package-handling
    subsystems use completely different models for customers. The order-payment subsystem
    characterizes a customer by their payment methods, currency, bank accounts, and
    credit cards, while package-handling is more concerned with the locations that
    have been visited and/or the packages that have been purchased, the user’s preferences,
    and their geographical location. Moreover, while order-payment refers to various
    concepts with a language that we may roughly define as a **bank language**, package-handling
    uses a language that is typical of travel agencies/operators.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的WWTravelClub用例中，订单支付和包裹处理子系统为顾客使用完全不同的模型。订单支付子系统通过支付方式、货币、银行账户和信用卡来表征顾客，而包裹处理则更关注访问过的地点和/或购买过的包裹、用户的偏好以及他们的地理位置。此外，虽然订单支付使用我们可能粗略定义为**银行语言**的语言来指代各种概念，但包裹处理使用的是典型的旅行社/运营商语言。
- en: 'The classic way to cope with these discrepancies is to use a unique abstract
    entity called **customer**, which projects into two different views—the order-payment
    view and the package-handling view. Each projection operation takes some operations
    and some properties from the **customer** abstract entity and changes their names.
    Since domain experts only give us the projected views, our main task as system
    designers is to create a conceptual model that can explain all the views. The
    following diagram shows how different views are handled:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 应对这些差异的经典方式是使用一个独特的抽象实体，称为**客户**，它映射到两个不同的视图——订单-支付视图和包裹处理视图。每个投影操作都会从**客户**抽象实体中提取一些操作和属性，并更改它们的名称。由于领域专家只给我们提供投影视图，因此作为系统设计师，我们的主要任务是创建一个概念模型，可以解释所有这些视图。以下图表显示了如何处理不同的视图：
- en: '![](img/B19820_07_01.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_07_01.png)'
- en: 'Figure 7.1: Creating a unique model'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：创建一个独特的模型
- en: The main advantage of the classic approach is that we have a unique and coherent
    representation of the data of the domain. If this conceptual model is built successfully,
    all the operations will have a formal definition and purpose and the whole abstraction
    will be a rationalization of the way the whole organization should work, possibly
    highlighting and correcting errors and simplifying some procedures.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 经典方法的主要优势是我们有一个独特且一致的数据域表示。如果这个概念模型构建成功，所有操作都将有一个正式的定义和目的，整个抽象将是对整个组织工作方式的合理化，可能突出和纠正错误，并简化一些程序。
- en: However, what are the downsides of this approach?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法的缺点是什么？
- en: The sharp adoption of a new monolithic data model may cause an acceptable impact
    in a small organization when the software is destined for a small part of the
    overall organization, or when the software automates a small enough percentage
    of the data flow. However, if the software becomes the backbone of a complex,
    geographically distributed organization, sharp changes become unacceptable and
    unfeasible. On the one hand, big structured companies need to react quickly to
    market changes, but on the other hand, due to the complexity of their organizations,
    only gradual changes are feasible. Therefore, the changes in their organizations
    and information systems that are needed to adapt to the market must be gradual.
    In turn, a gradual transition is possible only if old data models can coexist
    with new data models, and if each of the various components of the organization
    is allowed to change at its own speed—that is, if each component of the organization
    can evolve independently of the others.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当软件旨在服务于整个组织的一个小部分，或者当软件自动化的数据流比例足够小的时候，新单体数据模型的快速采用在小型组织中可能产生可接受的影响。然而，如果软件成为复杂、地理上分布的组织的主干，那么急剧的变化变得不可接受和不可行。一方面，大型结构化公司需要快速应对市场变化，但另一方面，由于组织复杂性，只有渐进式变化是可行的。因此，为了适应市场，它们组织和信息系统所需的变化必须是渐进的。反过来，只有当旧数据模型可以与新数据模型共存，并且组织的各个组成部分被允许以自己的速度改变——也就是说，如果组织的各个部分可以独立于其他部分发展时，这种渐进式过渡才是可能的。
- en: 'Moreover, as the complexity of a software system grows, several other issues
    make the unique data model of classical architectures hard to maintain:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，随着软件系统复杂性的增加，其他几个问题使得经典架构的独特数据模型难以维护：
- en: '**Coherency issues**: Arriving at a uniquely coherent view of data becomes
    more difficult since we can’t retain the complexity when we break these tasks
    into smaller, loosely coupled tasks.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性问题**：由于我们无法在将这些任务分解成更小、松散耦合的任务时保留复杂性，因此达到唯一一致的数据视图变得更加困难。'
- en: '**Difficulties updating**: As complexity grows, there is a need for frequent
    system changes, but it is quite difficult to update and maintain a unique global
    model. Moreover, bugs/errors that are introduced by changes in small subparts
    of the system may propagate to the whole organization through the uniquely shared
    model.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新困难**：随着复杂性的增加，需要频繁的系统更改，但更新和维护一个独特的全局模型相当困难。此外，由于系统小部分更改引入的bug/错误可能会通过唯一共享的模型传播到整个组织。'
- en: '**Team organization issues**: System modeling must be split among several teams,
    and only loosely coupled tasks can be given to separate teams; if two tasks are
    strongly coupled, they need to be given to the same team.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队组织问题**：系统建模必须在几个团队之间分配，并且只能将松散耦合的任务分配给不同的团队；如果两个任务强耦合，它们需要分配给同一个团队。'
- en: '**Parallelism issues**: As we will discuss in more detail in *Chapter 11*,
    *Applying a Microservice Architecture to Your Enterprise Application*, the need
    to move to a microservice-based architecture often makes the bottleneck of a unique
    database unacceptable.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行性问题**：正如我们将在*第11章*，*将微服务架构应用于您的企业应用程序*中更详细地讨论的那样，转向基于微服务的架构通常使得单一数据库的瓶颈不可接受。'
- en: '**Language issues**: As the system grows, we need to communicate with more
    domain experts, each speaking a different language and each with a different view
    of that data model. Thus, we need to translate our unique model’s properties and
    operations to/from more languages to be able to communicate with them.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言问题**：随着系统的增长，我们需要与更多的领域专家进行沟通，每位专家说不同的语言，并且对数据模型有不同的看法。因此，我们需要将我们独特模型的特点和操作翻译成更多语言，以便与他们沟通。'
- en: As the system grows, it becomes more inefficient to deal with records with hundreds/thousands
    of fields that project in smaller views. Such inefficiencies originate in database
    engines that inefficiently handle big records with several fields (memory fragmentation,
    problems with too many related indices, and so on). However, the main inefficiencies
    take place in **object-relational mappings** (**ORMs**) and business layers that
    are forced to handle these big records in their update operations. In fact, while
    query operations usually require just a few fields that have been retrieved from
    the storage engine, updates and business processing involve the whole entity.
    ORMs are described in detail in *Chapter 13*, *Interacting with Data in C# – Entity
    Framework Core*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 随着系统的增长，处理具有数百/数千个字段且投影到较小视图的记录变得越来越低效。这种低效源于数据库引擎处理具有多个字段的较大记录的方式不高效（内存碎片化、太多相关索引的问题等）。然而，主要的不效率发生在**对象关系映射**（ORMs）和业务层，它们被迫在其更新操作中处理这些大记录。实际上，虽然查询操作通常只需要从存储引擎检索的几个字段，但更新和业务处理涉及整个实体。ORMs在*第13章*，*在C#中使用Entity
    Framework Core与数据交互*中详细描述。
- en: As the traffic in the data storage subsystem grows, we need read and update/write
    parallelism in all the data operations. As we will discover in *Chapter 12*, *Choosing
    Your Data Storage in the Cloud*, while read parallelism is easily achieved with
    data replication, write parallelism requires sharding; that is, splitting database
    records among several distributed databases, and it is difficult to shard a uniquely
    monolithic and tightly connected data model.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数据存储子系统中的流量增长，我们需要在所有数据操作中实现读取和更新/写入并行性。正如我们将在*第12章*，*在云中选择您的数据存储*中发现的那样，虽然读取并行性可以通过数据复制轻松实现，但写入并行性需要分片；也就是说，将数据库记录分布在几个分布式数据库中，而分片一个唯一、紧密连接的数据模型是困难的。
- en: These issues are the reason for DDD’s success in the last few years because
    they were characterized by more complex software systems that became the backbones
    of entire organizations. DDD’s basic principles will be discussed in detail in
    the next section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题是领域驱动设计（DDD）在过去几年中取得成功的原因，因为它们代表了更复杂的软件系统，这些系统成为了整个组织的支柱。DDD的基本原则将在下一节中详细讨论。
- en: Understanding DDD
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解领域驱动设计（DDD）
- en: According to DDD, we should not construct a unique domain model that projects
    into different views in each application subsystem. Instead, the whole application
    domain is split into smaller domains, each with its own data model. These separate
    domains are called **Bounded Contexts**. Each Bounded Context is characterized
    by the language used by the experts and used to name all the domain concepts and
    operations.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 根据DDD，我们不应该构建一个独特的领域模型，该模型在每个应用程序子系统中的不同视图中投影。相反，整个应用程序领域被分割成更小的领域，每个领域都有自己的数据模型。这些独立的领域被称为**边界上下文**。每个边界上下文的特点是专家使用的语言，并用于命名所有领域概念和操作。
- en: Thus, each Bounded Context defines a common language used by both the experts
    and the development team called a **Ubiquitous Language**. Translations are not
    needed anymore, and if the development team uses C# interfaces as bases for its
    code, the domain expert is able to understand and validate them since all the
    operations and properties are expressed in the same language that’s used by the
    expert.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个边界上下文定义了一种由专家和开发团队共同使用的通用语言，称为**通用语言**。不再需要翻译，如果开发团队使用C#接口作为其代码的基础，领域专家能够理解和验证它们，因为所有操作和属性都使用专家使用的相同语言表达。
- en: 'Here, we’re getting rid of a cumbersome unique abstract model, but now we have
    several separate models that we need to relate somehow. DDD proposes that we handle
    all these separate models (that is, all the Bounded Contexts) as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在摒弃一个繁琐的唯一抽象模型，但现在我们有了几个需要以某种方式关联的独立模型。DDD建议我们如下处理所有这些独立模型（即所有边界上下文）：
- en: '**We need to add Bounded Context boundaries whenever the meanings of the language
    terms change**. For instance, in the WWTravelClub use case, order-payment and
    package-handling belong to different Bounded Contexts because they give a different
    meaning to the word **customer**.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每当语言术语的含义发生变化时，我们需要添加边界上下文的边界**。例如，在WWTravelClub用例中，订单-付款和包处理属于不同的边界上下文，因为它们给“客户”这个词赋予了不同的含义。'
- en: '**We need to explicitly represent relations among Bounded Contexts**. Different
    development teams may work on different Bounded Contexts, but each team must have
    a clear picture of the relationship between the Bounded Context it is working
    on and all the other models. For this reason, such relationships are represented
    in a unique document that’s shared with every team.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们需要显式地表示边界上下文之间的关系**。不同的开发团队可能在不同边界上下文中工作，但每个团队都必须对其正在工作的边界上下文与其他所有模型之间的关系有一个清晰的了解。因此，这些关系在一个独特的文档中表示，并与每个团队共享。'
- en: '**We need to keep all the Bounded Contexts aligned with CI**.Meetings are organized
    and simplified system prototypes are built in order to verify that all the Bounded
    Contexts are evolving coherently—that is, that all the Bounded Contexts can be
    integrated into the desired application behavior.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们需要确保所有边界上下文与CI保持一致**。会议被组织和简化系统原型被构建，以便验证所有边界上下文是否协调一致地发展——也就是说，所有边界上下文都可以集成到期望的应用行为中。'
- en: 'The following diagram shows how the WWTravelClub example that we discussed
    in the previous section changes with the adoption of DDD:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图显示了我们在上一节中讨论的WWTravelClub示例在采用DDD后的变化：
- en: '![Diagram, venn diagram  Description automatically generated](img/B19820_07_02.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图，维恩图  描述自动生成](img/B19820_07_02.png)'
- en: 'Figure 7.2: Relationships between DDD-Bounded Contexts'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：DDD边界上下文之间的关系
- en: There is a relationship between the Customer entities of each Bounded Context,
    while the Purchase entity of the package-handling Bounded Context is related to
    the Payments. Identifying entities that map to each other in the various Bounded
    Contexts is the first step of formally defining the interfaces that represent
    all the possible communications among the contexts.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每个边界上下文的客户实体之间存在关系，而包处理边界上下文的购买实体与付款相关。在各个边界上下文中识别映射到彼此的实体是正式定义表示上下文之间所有可能通信的接口的第一步。
- en: For instance, in the previous diagram, since payments are made after purchases,
    we can deduce that the order-payment Bounded Context must have an operation to
    create a payment for a specific customer. In this domain, new customers are created
    if they don’t already exist.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在上一个图中，由于付款是在购买之后进行的，我们可以推断出订单-付款的边界上下文必须有一个为特定客户创建付款的操作。在这个领域，如果新客户不存在，则会创建新客户。
- en: The payment creation operation is triggered immediately after purchase. Since
    several more operations are triggered after an item is purchased, we can implement
    all the communication related to a purchase event with the Publisher/Subscriber
    pattern we explained in *Chapter 6*, *Design Patterns and .NET 8 Implementation*.
    In DDD, these are known as **domain events**. Using events to implement communications
    between Bounded Contexts is very common since it helps keep Bounded Contexts loosely
    coupled.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 付款创建操作是在购买后立即触发的。由于在购买商品后还会触发更多操作，我们可以使用我们在第6章“设计模式和.NET 8实现”中解释的发布/订阅模式来实现与购买事件相关的所有通信。在DDD中，这些被称为**领域事件**。使用事件来实现边界上下文之间的通信非常常见，因为它有助于保持边界上下文松散耦合。
- en: Once an instance of either an event or an operation that’s been defined in the
    Bounded Context’s interface crosses the context boundary, it is immediately translated
    into the Ubiquitous Language of the receiving context. It is important that this
    translation be performed before the input data starts interacting with the other
    domain entities to prevent the Ubiquitous Language of the receiving domain from
    becoming contaminated by extra-contextual terms. An inadequate translation is
    usually evidenced by the domain experts complaining about “strange words.”
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在边界上下文接口中定义的事件或操作的实例跨越了边界，它立即被翻译成接收上下文的通用语言。在输入数据开始与其他领域实体交互之前执行这种翻译是很重要的，以防止接收领域通用语言被额外的上下文术语污染。通常，不充分的翻译会导致领域专家抱怨“奇怪的词语”。
- en: Each Bounded Context implementation must contain a domain model completely expressed
    in terms of the Bounded Context Ubiquitous Language (class and interface names
    and property and method names), with no contamination from other Bounded Contexts’
    Ubiquitous Languages, and without contamination from technical programming stuff.
    This is necessary to ensure good communication with domain experts and to ensure
    that domain rules are translated correctly into code so that they can be easily
    validated by domain experts.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每个边界上下文实现必须包含一个完全用边界上下文通用语言（类和接口名称以及属性和方法名称）表达的领域模型，没有任何其他边界上下文通用语言的污染，也没有技术编程内容的污染。这是确保与领域专家良好沟通并确保将领域规则正确翻译成代码，以便领域专家可以轻松验证的必要条件。
- en: When there is a strong mismatch between the communication language and the target
    Ubiquitous Language, an anti-corruption layer is added to the receiving Bounded
    Context boundary. The only purpose of this anti-corruption layer is to perform
    a language translation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当通信语言与目标通用语言之间存在强烈不匹配时，会在接收边界上下文边界添加一个反腐败层。这个反腐败层的唯一目的是执行语言翻译。
- en: Relationships among Bounded Contexts
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边界上下文之间的关系
- en: The document that contains a representation of all the Bounded Contexts, along
    with the Bounded Contexts’ mutual relationships and interface definitions, is
    called a **context map**. The relationships between contexts contain organizational
    constraints that specify the kind of cooperation required among the teams that
    are working on the different Bounded Contexts. Such relationships don’t constrain
    the Bounded Context interfaces but do affect the way they may evolve during the
    software CI/CD cycle. They represent patterns of team cooperation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 包含所有边界上下文表示、边界上下文相互关系和接口定义的文档称为**上下文图**。上下文之间的关系包含组织约束，指定在不同边界上下文上工作的团队之间所需合作类型。这些关系不约束边界上下文接口，但会影响它们在软件CI/CD周期中的演变方式。它们代表了团队合作模式。
- en: 'The most common patterns are as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的模式如下：
- en: '**Partner**: This is the original pattern suggested by Eric Evans. The idea
    is that the two teams have a mutual dependency on each other for delivery. In
    other words, they decide together the Bounded Context’s mutual communication specifications
    during the software development lifecycle.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合作伙伴**：这是埃里克·埃文斯最初提出的模式。其想法是两个团队在交付上相互依赖。换句话说，他们在软件开发生命周期中共同决定边界上下文的相互通信规范。'
- en: '**Customer/supplier development teams**: In this case, one team acts as a customer
    and another one acts as a supplier. In the preliminary stage, both teams define
    the interface of the customer side of the Bounded Context and some automated acceptance
    tests to validate it. After that, the supplier can work independently.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户/供应商开发团队**：在这种情况下，一个团队充当客户，另一个团队充当供应商。在初步阶段，两个团队定义边界上下文客户侧的接口和一些自动化验收测试来验证它。之后，供应商可以独立工作。'
- en: This pattern works when the customer’s Bounded Context is the only active part
    that invokes the interface methods exposed by the other Bounded Context. This
    is adequate for the interaction between the order-payment and the package-handling
    contexts, where order-payment acts as a supplier since its functions are subordinate
    to the needs of package-handling. When this pattern can be applied, it decouples
    both the implementation and the maintenance of the two Bounded Contexts completely.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当客户的边界上下文是唯一的活动部分，调用其他边界上下文公开的接口方法时，这种模式是有效的。这对于订单-支付和包装处理上下文之间的交互来说是足够的，其中订单-支付作为供应商，因为它的功能从属于包装处理的需求。当这种模式可以应用时，它将两个边界上下文的实现和维护完全解耦。
- en: '**Conformist**: This is similar to the customer/supplier pattern, but in this
    case, the customer side accepts an interface that’s been imposed by the supplier
    side with no preliminary negotiation stage. This pattern offers no advantages
    to the other patterns, but sometimes we are forced into the situation depicted
    by the pattern since either the supplier’s Bounded Context is implemented in a
    preexisting product that can’t be configured/modified too much, or because it
    is a legacy subsystem that we don’t want to modify.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从众者**：这与客户/供应商模式类似，但在此情况下，客户方接受由供应商方强加的接口，而没有初步的谈判阶段。这种模式对其他模式没有提供任何优势，但有时我们被迫处于该模式所描述的情况，因为供应商的边界上下文是在一个无法过多配置/修改的现有产品中实现的，或者因为它是一个我们不希望修改的遗留子系统。'
- en: It is worth pointing out that the separation in Bounded Contexts is only effective
    if the resulting Bounded Contexts are loosely coupled; otherwise, the reduction
    of complexity that’s obtained by breaking a whole system into parts would be overwhelmed
    by the complexity of the coordination and communication processes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，边界上下文的分离只有在结果边界上下文松散耦合时才是有效的；否则，通过将整个系统分解成部分而获得的复杂性降低将被协调和通信过程的复杂性所淹没。
- en: However, if Bounded Contexts are defined with the language criterion—that is,
    Bounded Context boundaries are added whenever the Ubiquitous Language changes—this
    should actually be the case. In fact, different languages may arise as a result
    of a loose interaction between an organization’s subparts since the more each
    subpart has tight interactions inside of it and loose interactions with other
    subparts, the more each subpart ends up defining and using its own internal language,
    which differs from the language used by the other subparts.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果边界上下文是根据语言标准定义的——也就是说，每当通用语言发生变化时，就添加边界上下文边界——这实际上应该是这种情况。事实上，由于组织各个部分的松散交互，可能会出现不同的语言，因为每个部分内部紧密交互的程度越高，与其他部分的松散交互越少，每个部分最终定义和使用的内部语言就越多，这与其他部分使用的语言不同。
- en: 'Moreover, as all human organizations grow just by evolving into loosely coupled
    subparts, similarly, complex software systems may be implemented just as the cooperation
    of loosely coupled submodules: this is the only way humans are able to cope with
    complexity. From this, we can conclude that complex organizations/artificial systems
    can always be decomposed into loosely coupled subparts. We just need to understand
    *how*.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于所有的人类组织只是通过演变成为松散耦合的子部分而成长，同样，复杂的软件系统也可以像松散耦合的子模块的合作一样实现：这是人类能够应对复杂性的唯一方式。从这个意义上说，我们可以得出结论，复杂组织/人工系统总是可以被分解成松散耦合的子部分。我们只需要理解“如何”做到这一点。
- en: Beyond the basic principles we’ve mentioned so far, DDD provides a few basic
    primitives to describe each Bounded Context, as well as some implementation patterns.
    While Bounded Context primitives are an integral part of DDD, the patterns are
    simply useful heuristics we can use in our implementation, so their usage in some
    or all Bounded Contexts is not obligatory once we opt for DDD adoption.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们之前提到的基本原理之外，领域驱动设计（DDD）提供了一些基本原语来描述每个边界上下文，以及一些实现模式。虽然边界上下文原语是DDD的一个组成部分，但这些模式只是我们在实现中可以使用的有用启发式方法，因此，一旦我们选择采用DDD，在某些或所有边界上下文中使用这些模式并不是强制性的。
- en: In the next section, we will describe Bounded Context primitives, while the
    various patterns will be described in the remaining sections of the chapter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将描述边界上下文原语，而各种模式将在本章的剩余部分进行描述。
- en: Entities
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体
- en: DDD entities represent domain objects that have a well-defined identity, as
    well as all the operations that are defined on them. They don’t differ too much
    from the entities of other, more classical approaches.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: DDD实体代表具有明确身份的领域对象，以及定义在其上的所有操作。它们与其他更经典的方法的实体差异不大。
- en: The main difference is that DDD stresses the entities’ object-oriented nature,
    while other approaches use them mainly as **records** whose properties can be
    written/updated without too many constraints.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于，DDD强调实体的面向对象特性，而其他方法主要将它们用作**记录**，其属性可以在没有太多约束的情况下写入/更新。
- en: DDD, on the other hand, forces strong SOLID principles on them to ensure that
    only certain information is encapsulated inside of them and that only certain
    information is accessible from outside of them, to stipulate which operations
    are allowed on them, and to set which business-level validation criteria apply
    to them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，DDD强制实施强SOLID原则，以确保只有某些信息被封装在它们内部，并且只有某些信息可以从外部访问，以规定允许对它们执行的操作，并设置适用于它们的业务级验证标准。
- en: In other words, DDD entities are richer than the entities of record-based approaches.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，DDD实体比基于记录的方法的实体更丰富。
- en: In the record-based approach, operations that manipulate entities are defined
    outside of them in classes that represent business and/or domain operations. In
    DDD, these operations are moved into the entity definitions as their class methods.
    The reason for this is that this approach offers better modularity and keeps related
    chunks of software in the same place so that they can be maintained and tested
    easily.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于记录的方法中，操作实体是在代表业务和/或领域操作的类中定义的，这些操作在实体外部。在DDD中，这些操作被移动到实体定义中，作为它们的类方法。这样做的原因是这种方法提供了更好的模块化，并将相关的软件块保持在同一位置，以便可以轻松维护和测试。
- en: More details on the difference between the record-based approach and the DDD
    approach will be given later on, in the *Repository pattern* subsection of this
    chapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 关于基于记录的方法和DDD方法的区别的更多细节将在本章的*存储库模式*小节中给出。
- en: For the same reason, business validation rules that are specific for each entity
    are moved inside of DDD entities. DDD entity validation rules are business-level
    rules, so they must not be confused with database integrity rules or user-input
    validation rules. They contribute to the way entities represent domain objects
    by encoding the constraints the represented objects must obey.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 同样出于这个原因，针对每个实体的特定业务验证规则被移动到DDD实体内部。DDD实体验证规则是业务级规则，因此它们不应与数据库完整性规则或用户输入验证规则混淆。它们通过编码所表示对象必须遵守的约束，有助于实体表示领域对象。
- en: For instance, it might be obligatory to provide an entity property such as “Shipping
    Address” on a web page (user input validation rule), even though property is not
    obligatory in general (no corresponding business validation rule). In fact, the
    “Shipping Address” property becomes obligatory only if we need to ship something,
    so if the context of the web page is about shipping something, then “Shipping
    Address” must be obligatory as a user input in that specific web page but not
    as a general business rule.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在网页上提供实体属性“送货地址”可能是强制性的（用户输入验证规则），尽管通常属性不是强制性的（没有相应的业务验证规则）。事实上，“送货地址”属性只有在需要发货时才是强制性的，所以如果网页的上下文是关于发货的，那么“送货地址”必须在该特定网页中作为用户输入是强制性的，但不是作为一般业务规则。
- en: User input validation will be discussed in more detail in *Chapter 17*, *Presenting
    ASP.NET Core*, which will show, in practice, how user input validation and business
    validation have different and complementary purposes. While business-level validation
    rules encode domain rules, input validation rules enforce the format of every
    single input (string length, correct email and URL formats, and so on), ensure
    that all the necessary input has been provided, enforce the execution of the chosen
    user machine interaction protocols, and provide fast and immediate feedback that
    drives the user to interact with the system.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入验证将在*第17章*中更详细地讨论，*展示ASP.NET Core*，它将实际展示用户输入验证和业务验证具有不同的和补充的目的。虽然业务级验证规则编码了领域规则，但输入验证规则强制执行每个单个输入的格式（字符串长度、正确的电子邮件和URL格式等），确保提供了所有必要的输入，强制执行所选的用户机器交互协议，并提供快速和即时的反馈，引导用户与系统交互。
- en: It is worth pointing out that not all business validation rules can be encoded
    inside DDD entities. Business rules that are not specific to single DDD entities
    but involve the interaction of several entities must be encoded in the software
    module that handles and coordinates the interaction among entities. We will speak
    more about the software module that coordinates entity interactions later on in
    this chapter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，并非所有业务验证规则都可以编码在DDD实体内部。不特定于单个DDD实体但涉及多个实体交互的业务规则必须编码在处理和协调实体间交互的软件模块中。我们将在本章后面更详细地讨论协调实体交互的软件模块。
- en: The subsection that follows gives more details on entity-level validation rules.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将提供更多关于实体级验证规则的详细信息。
- en: Entity-level validation in .NET
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET中的实体级验证
- en: 'In .NET, business validation can be carried out with one of the following techniques:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，可以使用以下技术之一执行业务验证：
- en: Calling the validation methods in all the class methods that modify the entity.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有修改实体的类方法中调用验证方法。
- en: Hooking the validation methods to all the property setters.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将验证方法连接到所有属性设置器。
- en: Decorating the class and/or its properties with custom validation attributes
    and then invoking the `TryValidateObject` static method of the `System.ComponentModel.DataAnnotations.Validator`
    class on the entity each time it is modified. The .NET `System.ComponentModel.DataAnnotations`
    namespace contains predefined validation attributes (see [https://learn.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-8.0#built-in-attributes](https://learn.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-8.0#built-in-attributes)),
    but the developer can define also custom validation attributes by inheriting from
    the `System.ComponentModel.DataAnnotations.ValidationAttribute` abstract class
    (see [https://makolyte.com/aspnetcore-create-a-custom-model-validation-attribute/](https://makolyte.com/aspnetcore-create-a-custom-model-validation-attribute/)).
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义验证属性装饰类及其属性，并在每次修改实体时调用`System.ComponentModel.DataAnnotations.Validator`类的`TryValidateObject`静态方法。.NET的`System.ComponentModel.DataAnnotations`命名空间包含预定义的验证属性（见[https://learn.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-8.0#built-in-attributes](https://learn.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-8.0#built-in-attributes)），但开发者也可以通过从`System.ComponentModel.DataAnnotations.ValidationAttribute`抽象类继承来定义自定义验证属性（见[https://makolyte.com/aspnetcore-create-a-custom-model-validation-attribute/](https://makolyte.com/aspnetcore-create-a-custom-model-validation-attribute/)）。
- en: More details on validation attributes will be given in *Chapter 17*, *Presenting
    ASP.NET Core*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 关于验证属性的更多细节将在第17章“展示ASP.NET Core”中给出。
- en: Once detected, validation errors must be handled somehow; that is, the current
    operation must be aborted and the error must be reported to an appropriate error
    handler. The simplest way to handle validation errors is by throwing an exception.
    This way, both purposes are easily achieved and we can choose where to intercept
    and handle them. Unfortunately, as we discussed in the *Performance issues that
    need to be considered while programming in C#* section of *Chapter 2*, *Non-Functional
    Requirements*, exceptions imply big performance penalties and must be used to
    deal just with “exceptional circumstances” so, often, different options are considered.
    Handling errors in the normal flow of control would break modularity by spreading
    the code that’s needed to handle the error all over the stack of methods that
    caused the error, with a never-ending set of conditions all over that code. Therefore,
    more sophisticated options are needed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦检测到验证错误，就必须以某种方式处理；也就是说，必须中止当前操作，并将错误报告给适当的错误处理器。处理验证错误的最简单方法是通过抛出异常。这样，两个目的都很容易实现，我们可以选择在哪里拦截和处理它们。不幸的是，正如我们在第2章“非功能性需求”的“在C#编程时需要考虑的性能问题”部分中讨论的那样，异常意味着巨大的性能损失，并且必须仅用于处理“异常情况”，因此，通常需要考虑不同的选项。在正常流程中处理错误会破坏模块化，因为需要在导致错误的整个方法堆栈中传播处理错误所需的代码，并且在整个代码中都有一个无限的条件集。因此，需要更复杂的选择。
- en: A good alternative to exceptions is to notify errors to an error handler that
    is unique for each processing request. For instance, it can be implemented as
    a scoped service in the dependency injection engine. Being scoped, the same service
    instance is returned while each request is being processed so that the handler
    that controls the execution of the whole call stack can inspect possible errors
    when the flow of control returns to it, and can handle them appropriately. Unfortunately,
    this sophisticated technique can’t automatically abort the operation’s execution
    and return immediately to the most adequate controlling handler that is in the
    call stack.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 异常的一个好替代方案是将错误通知给每个处理请求的独特错误处理器。例如，它可以在依赖注入引擎中实现为一个作用域服务。由于作用域，在处理每个请求时返回相同的服务实例，这样控制整个调用堆栈执行的处理器可以在控制流返回时检查可能出现的错误，并适当地处理它们。不幸的是，这种复杂的技巧不能自动中止操作的执行并立即返回到调用堆栈中最合适的控制处理器。
- en: 'This is why exceptions are often used for this scenario, notwithstanding their
    performance issues. The other option is the usage of a **result object** that
    informs the caller of the success of the operation in all method calls. However,
    result objects have their cons: they imply more coupling between the methods involved
    in the call stack, so during software maintenance, each change might require modifications
    in several methods.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么尽管存在性能问题，异常通常用于这种情况。另一种选择是使用**结果对象**，在所有方法调用中通知调用者操作的成功。然而，结果对象有其缺点：它们在调用堆栈中涉及的方法之间引入了更多的耦合，因此在软件维护期间，每次更改可能都需要修改多个方法。
- en: DDD entities in .NET
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET中的DDD实体
- en: 'Since DDD entities must have a well-defined identity, they must have properties
    that act as primary keys. It is common to override the `Object.Equals` method
    of all the DDD entities in such a way that two objects are considered equal whenever
    they have the same primary keys. This is easily achieved by letting all the entities
    inherit from an abstract `Entity` class, as shown in the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于DDD实体必须有一个明确定义的身份，它们必须具有作为主键的属性。通常，所有DDD实体都会覆盖`Object.Equals`方法，使得当两个对象具有相同的主键时，它们被认为是相等的。这可以通过让所有实体继承自一个抽象的`Entity`类来实现，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Note the following things in the code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中注意以下事项：
- en: It is worth implementing an `IEntity<K>` interface that defines all the properties/methods
    of `Entity<K>`. This interface is useful whenever we need to hide data classes
    behind interfaces.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值得实现一个`IEntity<K>`接口，该接口定义了`Entity<K>`的所有属性/方法。当我们需要在接口后面隐藏数据类时，这个接口很有用。
- en: The `IsTransient` predicate returns `true` whenever the entity has been recently
    created and hasn’t been recorded in the permanent storage, so its primary key
    is still undefined.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsTransient`谓词在实体最近被创建且尚未记录在永久存储中时返回`true`，因此其主键仍然是未定义的。'
- en: In .NET, it is good practice that, whenever you override the `Object.Equals`
    method of a class, you also override its `Object.GetHashCode` method so that class
    instances can be efficiently stored in data structures such as dictionaries and
    sets. That’s why the `Entity` class overrides it.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在.NET中，当您覆盖一个类的`Object.Equals`方法时，也覆盖其`Object.GetHashCode`方法是一个好的实践，这样类实例可以高效地存储在字典和集合等数据结构中。这就是为什么`Entity`类覆盖了它。
- en: It is worth pointing out that once we’ve redefined the `Object.Equals` method
    in the `Entity` class, we can also override the `==` and `!=` operators.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值得指出的是，一旦我们在`Entity`类中重新定义了`Object.Equals`方法，我们也可以覆盖`==`和`!=`运算符。
- en: Entities are not the only data ingredient of DDD. Domain modeling also requires
    data with no unique identities. That’s why value objects were conceived.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 实体不是DDD的唯一数据成分。领域建模还要求具有无唯一标识的数据。这就是为什么提出了值对象。
- en: Value objects
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值对象
- en: Value objects, in contrast to entities, represent complex types that can’t be
    encoded with numbers or strings. Therefore, they have no identity and no principal
    keys. They have no operations defined on them and are immutable; that is, once
    they’ve been created, all their fields can be read but cannot be modified. For
    this reason, they are usually encoded with classes whose properties have protected/private
    setters.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与实体不同，值对象代表无法用数字或字符串编码的复杂类型。因此，它们没有标识符和主键。它们上没有定义操作，且是不可变的；也就是说，一旦它们被创建，所有字段都可以读取但不能修改。因此，它们通常使用具有受保护的/私有设置器的属性的类进行编码。
- en: Two value objects are considered equal when all their independent properties
    are equal. Some properties are not independent since they just show data that’s
    been encoded by other properties in a different way, as is the case for the ticks
    of `DateTime` and its representation of the date and time fields.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有独立属性都相等时，两个值对象被认为是相等的。有些属性不是独立的，因为它们只是以其他属性以不同的方式编码的数据的展示，例如`DateTime`的刻度和其日期和时间字段的表示。
- en: 'Value objects are easily implemented with C# 12 `record` types since all `record`
    types automatically override the `Equals` method so that it performs a property-by-property
    comparison. Record types can also be made immutable by adequately defining their
    properties; once immutable objects are initialized, the only way to change their
    values is to create a new instance. Here is an example of how to modify a `record`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有`record`类型自动重写`Equals`方法以执行属性逐个比较，因此值对象可以用C# 12的`record`类型轻松实现。通过适当地定义它们的属性，记录类型也可以被定义为不可变的；一旦不可变对象被初始化，唯一改变其值的方法是创建一个新的实例。以下是如何修改`record`的一个示例：
- en: '[PRE1]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is an example of how to define a `record`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何定义`record`的一个示例：
- en: '[PRE2]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `init` keyword is what makes `record` type properties immutable since it
    means they can only be initialized.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`关键字使得`record`类型属性不可变，因为它意味着它们只能被初始化。'
- en: 'If we pass all the properties in the constructor instead of using initializers,
    the preceding definition can be simplified as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过构造函数传递所有属性而不是使用初始化器，前面的定义可以简化如下：
- en: '[PRE3]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Typical value objects include costs represented as a number and a currency symbol,
    locations represented as longitude and latitude, addresses, and contact information.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的值对象包括以数字和货币符号表示的成本、以经纬度表示的位置、地址和联系信息。
- en: The way both entities and value objects typically interact with data storage
    in .NET applications is explained in *Chapter 13*, *Interacting with Data in C#
    – Entity Framework Core*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 实体和值对象通常在.NET应用程序中与数据存储交互的方式在*第13章*中解释，即*在C#中使用Entity Framework Core与数据交互*。
- en: Aggregates
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚合
- en: So far, we have talked about entities as the **units** that are processed by
    a DDD-based business layer. However, several entities can be manipulated and made
    into single entities. An example of this is a purchase order and all of its items.
    In fact, it makes absolutely no sense to process a single order item independently
    of the order it belongs to. This happens because order items are actually subparts
    of an order, not independent entities.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了实体作为由基于DDD的业务层处理的**单元**。然而，几个实体可以被操作并合并成单个实体。一个例子是采购订单及其所有项目。实际上，独立于所属订单处理单个订单项是完全不合理的。这是因为订单项实际上是订单的子部分，而不是独立的实体。
- en: There is no transaction that may affect a single order item without it affecting
    the order that the item is in. Imagine that two different people in the same company
    are trying to increase the total quantity of cement, but one increases the quantity
    of type-1 cement (item 1) while the other increases the quantity of type-2 cement
    (item 2). If each item is processed as an independent entity, both quantities
    will be increased, which could cause an incoherent purchase order since the total
    quantity of cement would be increased twice.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何交易可以单独影响一个订单项而不影响该订单项所在的订单。想象一下，同一家公司的两个不同的人试图增加水泥的总数量，但一个人增加了1型水泥（项目1）的数量，而另一个人增加了2型水泥（项目2）的数量。如果每个项目都被当作一个独立的实体来处理，这两个数量都会增加，这可能会导致一个不连贯的采购订单，因为水泥的总数量会被增加两次。
- en: On the other hand, if the whole order, along with all its order items, is loaded
    and saved with every single transaction by both people, one of the two will overwrite
    the changes of the other one, so whoever makes the final change will have their
    requirements set.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果整个订单及其所有订单项由两个人在每次交易中一起加载和保存，那么其中一个人将覆盖另一个人的更改，因此最后做出更改的人将设置他们的要求。
- en: A purchase order, along with all its subparts (its order items), is called an
    **aggregate**, while the order entity is called the **root** of the aggregate.
    Aggregates always have roots since they are hierarchies of entities connected
    by **subpart** relationships.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个采购订单及其所有子部分（其订单项）被称为**聚合**，而订单实体被称为聚合的**根**。由于聚合是由子部分关系连接的实体层次结构，因此它们总是有根。
- en: Since each aggregate represents a single complex entity, all the operations
    on it must be exposed by a unique interface. Therefore, the aggregate root usually
    represents the whole aggregate, and all the operations on the aggregate are defined
    as methods of the root entity.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个聚合代表一个单独的复杂实体，因此对其进行的所有操作都必须通过一个唯一的接口来暴露。因此，聚合根通常代表整个聚合，对聚合的所有操作都定义为根实体的方法。
- en: When the aggregate pattern is used, the units of information that are transferred
    between the business layer and the data layer are called aggregates, queries,
    and query results. Thus, aggregates replace single entities.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用聚合模式时，在业务层和数据层之间传输的信息单元被称为聚合、查询和查询结果。因此，聚合取代了单个实体。
- en: In a few words, aggregates are in-memory representations of storage information
    that need to be dealt with as a single object. Being an in-memory representation
    based on an object-oriented paradigm, they take full advantage of all the benefits
    of object-oriented programming.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，聚合是存储信息的内存表示，需要作为一个单一对象来处理。作为一个基于面向对象范式的内存表示，它们充分利用了面向对象编程的所有好处。
- en: Domain events
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 领域事件
- en: Domain events are the main communication ingredient of DDD. While DDD doesn’t
    impose constraints on the way communication among bounded contexts is achieved,
    a communication based on the publisher/subscriber pattern described in *Chapter
    6*, *Design Patterns and .NET 8 Implementation*, maximizes independence among
    bounded contexts. Each bounded context publishes all information that might interest
    other bounded contexts, and interested bounded contexts subscribe. This way, the
    publisher doesn’t need to know about each subscriber and how it works, but just
    publish the result of its job in a general format. More implementation details
    will be given in the *Command handlers and domain events* subsection of this chapter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 领域事件是 DDD 的主要通信成分。虽然 DDD 不对边界上下文之间通信的方式施加约束，但基于第 6 章、*设计模式和 .NET 8 实现* 中描述的发布/订阅模式进行的通信，最大化了边界上下文之间的独立性。每个边界上下文发布所有可能引起其他边界上下文兴趣的信息，感兴趣的边界上下文进行订阅。这样，发布者不需要了解每个订阅者及其工作方式，只需以通用格式发布其工作的结果。更多实现细节将在本章的
    *命令处理器和领域事件* 子节中给出。
- en: Common DDD patterns and architectures
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的 DDD 模式和架构
- en: In this and the sections that follow, we will describe some of the patterns
    and architectures that are commonly used with DDD. Some of them can be adopted
    in all projects, while others can only be used for certain Bounded Contexts.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节和随后的章节中，我们将描述一些与 DDD 常用的模式和架构。其中一些可以在所有项目中采用，而其他一些则只能用于某些边界上下文。
- en: 'Before we begin, we should note that, from a conceptual point of view, the
    functionality of each application can be classified into three groups:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们应该注意，从概念上讲，每个应用程序的功能可以划分为三个组：
- en: Handling the interaction with the user
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理与用户的交互
- en: Performing business-related processing
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行与业务相关的处理
- en: Interacting with the storage engine
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与存储引擎交互
- en: Each of the above groups uses a different language and different technologies.
    The first group uses the language of the target users and user interface technologies,
    the second group uses the language of the domain expert and is focused on application
    domain modeling, and the third group uses both language and technologies related
    to databases.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 上述每个组都使用不同的语言和技术。第一个组使用目标用户的语言和用户界面技术，第二个组使用领域专家的语言，专注于应用领域建模，第三个组则使用与数据库相关的语言和技术。
- en: Each of the architectures we will look at organize these functionalities in
    different ways. We will start with the classic layers architecture since it is
    simpler to understand, and then we will describe the more sophisticated onion
    architecture.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的每个架构都以不同的方式组织这些功能。我们将从经典的分层架构开始，因为它更容易理解，然后我们将描述更复杂的洋葱架构。
- en: Classic layers architecture
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经典分层架构
- en: 'The classic layers architecture organizes the three groups of functionalities
    as three loosely coupled sets of classes/interfaces called **layers**, put one
    after the other:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 经典分层架构将三个功能组组织为三个松散耦合的类/接口集合，称为 **层**，依次排列：
- en: The first layer in the sequence is the one that takes care of user interaction
    and is called the **presentation layer**.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列中的第一层负责用户交互，被称为 **表示层**。
- en: The second layer in the sequence is the one that performs business-related processing
    and is called the **business layer**.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列中的第二层是执行与业务相关的处理的那一层，被称为**业务层**。
- en: The third layer is the one dedicated to database interaction and is called the
    **data layer**.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三层是专门用于数据库交互的层，被称为**数据层**。
- en: 'Each layer can communicate directly just with the layer that precedes it and
    the layer that follows it, as shown in the figure below:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每一层可以直接与其前一层和后一层进行通信，如图下所示：
- en: '![](img/B19820_07_03.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_07_03.png)'
- en: 'Figure 7.3: Classic layers architecture'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：经典层架构
- en: Each layer call can pass data to methods of public objects in the layer that
    follows it and receive the resulting data back.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 每个层调用都可以将数据传递给下一层的公共对象的方法，并接收返回的结果数据。
- en: The presentation layer handles not only graphics but also the whole user-machine
    interaction protocol. During its interaction protocol, the presentation layer
    uses business layer methods either to present data to the user or to update the
    application state.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 表示层不仅处理图形，还处理整个用户-机器交互协议。在其交互协议中，表示层使用业务层方法向用户展示数据或更新应用程序状态。
- en: In turn, the business layer uses data layer methods to retrieve all data it
    needs to prepare the user answer from the data storage and to update the application
    state.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，业务层使用数据层方法从数据存储中检索所有需要准备用户答案的数据，并更新应用程序状态。
- en: Each layer offers a well-defined interface to the layer that precedes it while
    hiding all implementation details.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每一层都向其前一层提供一个定义良好的接口，同时隐藏所有实现细节。
- en: The layer architecture promotes modularity since each layer doesn’t depend on
    how the layers that precede it are implemented, and avoids the possibility of
    the language used by each layer contaminating the language used by the others.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 层架构促进了模块化，因为每一层不依赖于其前一层的实现方式，并避免了每种层使用的语言污染其他层使用的语言的可能性。
- en: However, data exchanged in the classic layer architecture are record-type objects
    with no methods that encode any processing logic, since the whole processing logic
    is contained in the objects and methods that compose the three layers.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在经典层架构中交换的数据是记录类型对象，没有包含任何处理逻辑的方法，因为整个处理逻辑都包含在组成三个层的对象和方法中。
- en: Since record-like objects used by the classic layers architecture are very different
    from DDD domain objects, which are rich objects that encode most of the business
    logic in their methods, the classic layers architecture has a poor match with
    DDD. That’s why an improvement on the classic layers architecture, called the
    onion architecture, has been proposed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于经典层架构中使用的记录类型对象与DDD领域对象非常不同，DDD领域对象是丰富的对象，其方法中包含了大部分业务逻辑，因此经典层架构与DDD不匹配。这就是为什么提出了对经典层架构的改进，称为洋葱架构。
- en: Onion architecture
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 洋葱架构
- en: 'In the onion architecture, layers obey different rules and are defined in a
    slightly different way. There is:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在洋葱架构中，层遵循不同的规则，并以稍微不同的方式定义。有：
- en: An outermost layer that takes care of all interactions with the application
    environment—that is, user interface, test software, and interaction with operating
    system and data storage
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最外层负责处理与应用程序环境的所有交互——即用户界面、测试软件以及与操作系统和数据存储的交互。
- en: An application layer
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用层
- en: A domain layer
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域层
- en: Here, the domain layer is an abstraction of the classical data layer based on
    the Ubiquitous Language. It is where DDD entities and value objects are defined,
    together with abstractions of the operations that retrieve and save them. For
    better modularity, all or some domain layer classes may be made internal and hidden
    behind public interfaces.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，领域层是基于通用语言的经典数据层的抽象。它是定义DDD实体和值对象以及检索和保存它们操作抽象的地方。为了更好的模块化，所有或某些领域层类可以被设置为内部类，并隐藏在公共接口后面。
- en: The application layer, instead, defines operations that use the domain layer
    public interface (public interfaces and public classes) to get DDD entities and
    value objects and manipulate them to implement the application business logic.
    The DDD application layer is called **application services** since it exposes
    its functionalities through an API that is completely independent of the outermost
    layers. This way, for instance, any user interface layer and a test suite both
    call exactly the same methods to interact with the application logic.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，应用层定义了使用领域层公共接口（公共接口和公共类）来获取DDD实体和值对象，并操纵它们以实现应用业务逻辑的操作。由于它通过一个完全独立于最外层的API公开其功能，DDD应用层被称为**应用服务层**。这样，例如，任何用户界面层和测试套件都调用完全相同的方法来与应用逻辑交互。
- en: The outermost layer contains the user interface, the functional test suites
    (if any), and the application interface with the infrastructure that hosts the
    application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最外层包含用户界面、功能测试套件（如果有）以及与托管应用程序的基础设施的应用程序接口。
- en: The infrastructure represents the environment in which the application runs
    and includes the operating system, any devices, filesystem services, cloud services,
    and databases. The infrastructure interface is placed on the outermost level to
    ensure that no other onion layer depends on it. This maximizes both usability
    and modifiability.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施代表了应用程序运行的环境，包括操作系统、任何设备、文件系统服务、云服务和数据库。基础设施接口放置在最外层，以确保没有其他洋葱层依赖于它。这最大化了可用性和可修改性。
- en: The infrastructure layer contains all the drivers needed to adapt the application
    to its environment. Infrastructure resources communicate with the application
    through these drivers, and, in turn, drivers expose the infrastructure resources
    to all application layers through interfaces that are associated with the drivers
    implementing them in the dependency injection engine. This way, adapting the application
    to a different environment just requires changing the drivers.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施层包含适应其环境的所有驱动程序。基础设施资源通过这些驱动程序与应用程序通信，而驱动程序则通过与其相关的接口将基础设施资源暴露给所有应用程序层，这些接口与在依赖注入引擎中实现它们的驱动程序相关联。这样，将应用程序适应不同的环境只需更改驱动程序即可。
- en: 'Here’s a sketch of the onion architecture:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是洋葱架构的草图：
- en: '![](img/B19820_07_04.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_07_04.png)'
- en: 'Figure 7.4: Onion architecture'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：洋葱架构
- en: Each ring is a layer. Inward from the outermost layer are the **application
    services**, and inward from the application services we have the **domain layer**,
    which contains the representation of the entities involved in the Bounded Context
    knowledge.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 每个环代表一个层。从最外层向内是**应用服务层**，从应用服务层向内是**领域层**，它包含了在边界上下文中涉及到的实体的表示。
- en: 'Both the application services and the domain layer can be split into sublayers,
    and all layers/sublayers must conform to the following rule: *Each layer may depend
    only on the inner layers.*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务层和领域层都可以分为子层，并且所有层/子层都必须遵守以下规则：*每一层只能依赖于内部层*。
- en: For instance, the domain layer may be split into **Domain Model** and **Domain
    Services**, where Domain Modelis below Domain Services. The *Domain Model* layer
    contains the classes and interfaces that represent all domain objects, while the
    *Domain Services* layer contains the so-called repositories that are explained
    later on in this chapter in the *Repository pattern* and *Unit of work pattern*
    sections.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，领域层可以分成**领域模型**和**领域服务**，其中领域模型位于领域服务之下。*领域模型*层包含代表所有领域对象的类和接口，而*领域服务*层包含所谓的存储库，这些存储库在本章的*存储库模式*和*工作单元模式*部分中进行了说明。
- en: As we will see later on in this chapter, it is common to interact with the domain
    layer through interfaces that are defined in a separate library and implemented
    in the domain layer. Thus, the domain layer must have a reference to the library
    containing all domain layer interfaces since it must implement those interfaces,
    while the application layer is where each domain layer interface is connected
    with its implementation through a record of the application layer dependency injection
    engine. More specifically, the only data layer objects referenced by the application
    layer are these interface implementations that are only referenced in the dependency
    injection engine.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本章后面看到的那样，通常通过在单独的库中定义并在域层中实现的接口与域层进行交互。因此，域层必须引用包含所有域层接口的库，因为它必须实现这些接口，而应用层则是每个域层接口通过应用层依赖注入引擎的记录与其实现连接的地方。更具体地说，应用层引用的唯一数据层对象是这些仅在依赖注入引擎中引用的接口实现。
- en: Outer layers that implement interfaces defined in the next inner layer are a
    common pattern used in the onion architecture.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 实现下一内层定义的接口的外层是洋葱架构中常用的模式。
- en: Each application layer operation requires the interfaces it needs from the dependency
    engine, uses them to get DDD entities and value objects, manipulates them, and
    possibly saves them through the same interfaces.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用层操作都需要从依赖引擎中获取它需要的接口，使用它们来获取DDD实体和值对象，操作它们，并通过相同的接口可能保存它们。
- en: 'Here is a diagram that shows the relationships among the three layers discussed
    in this section:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个图表，展示了本节中讨论的三个层之间的关系：
- en: '![](img/B19820_07_05.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_07_05.png)'
- en: 'Figure 7.5: Relationships among the layers'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：层之间的关系
- en: Thus, the domain layer contains the representation of the domain objects, the
    methods to use on them, validation constraints, and the domain layer’s relationship
    with various entities. To increase modularity and decoupling, communication among
    entities is usually encoded with events—that is, with the **Publisher/Subscriber
    pattern**. This means entity updates can trigger events that have been hooked
    to business operations, and these events act on other entities.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，域层包含域对象的表示、在它们上使用的函数、验证约束以及域层与各种实体之间的关系。为了增加模块化和解耦，实体之间的通信通常使用事件编码——即使用**发布者/订阅者模式**。这意味着实体更新可以触发已连接到业务操作的事件，并且这些事件作用于其他实体。
- en: This layered architecture allows us to change the whole data layer without affecting
    the domain layer, which only depends on the domain specifications and language
    and doesn’t depend on the technical details of how the data is handled.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分层架构使我们能够在不影响域层的情况下更改整个数据层，域层仅依赖于域规范和语言，而不依赖于数据处理的详细技术细节。
- en: The application layer contains the definitions of all the operations that may
    potentially affect several entities and the definitions of all the queries that
    are needed by the applications. Both business operations and queries use the interfaces
    defined in the domain layer to interact with the data layer.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层包含所有可能影响多个实体的操作定义以及所有应用程序需要的查询定义。业务操作和查询都使用在域层中定义的接口与数据层进行交互。
- en: However, while business operations manipulate and exchange entities with these
    interfaces, queries send query specifications and receive generic **Data Transfer
    Objects** (**DTOs**) from them. In fact, the purpose of queries is just to show
    data to the user, not to act on them; accordingly, query operations don’t need
    whole entities with all their methods, properties, and validation rules, but just
    property tuples.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虽然业务操作通过这些接口操纵和交换实体，但查询向它们发送查询规范并从它们那里接收通用的**数据传输对象**（**DTOs**）。实际上，查询的目的只是向用户展示数据，而不是对它们进行操作；因此，查询操作不需要包含所有方法、属性和验证规则的完整实体，而只需要属性元组。
- en: Business operations are invoked either by other layers (typically the presentation
    layer) or by communication operations.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 业务操作可以通过其他层（通常是表示层）或通过通信操作来调用。
- en: Summing up, the application layer operates on the interfaces defined in the
    domain layer instead of interacting directly with their data layer implementations,
    which means that the application layer is decoupled from the data layer. More
    specifically, data layer objects are only mentioned in the dependency injection
    engine definitions. All the other application layer components refer to the interfaces
    that are defined in the domain layers, and the dependency injection engine injects
    the appropriate implementations.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，应用层在域层定义的接口上操作，而不是直接与它们的数据层实现交互，这意味着应用层与数据层解耦。更具体地说，数据层对象仅在依赖注入引擎定义中提及。所有其他应用层组件都引用在域层中定义的接口，而依赖注入引擎注入适当的实现。
- en: 'The application layer communicates with other application components through
    one or more of the following patterns:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层通过以下一个或多个模式与其他应用组件通信：
- en: '**It exposes business operations and queries on a communication endpoint**,
    such as an HTTP Web API (see *Chapter 15*, *Applying Service-Oriented Architectures
    with .NET*). In this case, the presentation layer may connect to this endpoint
    or to other endpoints that, in turn, take information from this and other endpoints.
    Application components that collect information from several endpoints and expose
    them in a unique endpoint are called **gateways**. They may be either custom or
    general-purpose, such as Ocelot.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它在一个通信端点上公开业务操作和查询**，例如HTTP Web API（见*第15章*，*使用.NET应用服务架构*）。在这种情况下，表示层可以连接到该端点或连接到其他端点，这些端点反过来又从该端点和其他端点获取信息。从多个端点收集信息并在唯一端点公开这些信息的应用组件称为**网关**。它们可以是定制的，也可以是通用目的的，例如Ocelot。'
- en: '**It is referenced as a library by an application that directly implements
    the presentation layer**, such as an ASP.NET Core MVC Web application.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它被应用程序作为库引用，该应用程序直接实现表示层**，例如ASP.NET Core MVC Web应用程序。'
- en: '**It doesn’t expose all the information through endpoints and communicates
    some of the data it processes/creates to other application components that, in
    turn, expose endpoints**. Such communication is often implemented with the Publisher/Subscriber
    pattern to increase modularity.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它不会通过端点公开所有信息，而是将处理/创建的一些数据通信给其他应用组件，而这些组件反过来又公开端点**。这种通信通常使用发布者/订阅者模式来实现，以增加模块化。'
- en: Repository pattern
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仓储模式
- en: 'The repository pattern is an entity-centric approach to the definition of the
    domain layer interfaces: each entity—or better, each aggregate—has its own repository
    interface that defines how to retrieve and create it, and defines all queries
    that involve entities in the aggregate. The implementation of each repository
    interface is called a repository. Repositories are associated with aggregates
    instead of entities, since, as discussed in the *Aggregates* subsection, aggregates
    represent the minimum granularity that makes sense to consider in each data operation.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 仓储模式是一种以实体为中心的方法来定义域层接口：每个实体——或者更好，每个聚合——都有自己的仓储接口，该接口定义了如何检索和创建它，并定义了涉及聚合中实体的所有查询。每个仓储接口的实现称为仓储。由于，如*聚合*子节所述，聚合代表了在每次数据操作中考虑的最小粒度，因此仓储与聚合相关联，而不是与实体相关联。
- en: 'With the repository pattern, each operation has an easy-to-find place where
    it must be defined: the interface of the aggregate the operation works on, or,
    in the case of a query, the aggregate that contains the root entity of the query.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用仓储模式，每个操作都有一个易于找到的地方来定义它：操作所操作的聚合的接口，或者，在查询的情况下，包含查询根实体的聚合。
- en: The repository pattern was initially conceived for the classical layer architecture
    and its record-like objects. Then, it was adapted to work with rich DDD entities/aggregates.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 仓储模式最初是为经典层架构及其记录样式的对象而设计的。然后，它被修改以与丰富的DDD实体/聚合一起工作。
- en: Classical repositories contain all methods needed to handle record-like objects—that
    is, modification, creation and delete methods since record-like objects have no
    modification methods. DDD-adapted repositories, instead, only contain create and
    delete methods since all methods that modify each aggregate are defined as aggregate
    methods. Moreover, applications based on classic repositories and record-like
    objects do not have a unique record-like object that represents each domain aggregate,
    but there are several record-like objects, each containing a different view of
    the overall domain aggregate. Therefore, classic repositories have modification
    methods for several different record-like objects.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 经典存储库包含处理记录对象所需的所有方法——即修改、创建和删除方法，因为记录对象没有修改方法。而适应DDD的存储库则只包含创建和删除方法，因为所有修改每个聚合的方法都被定义为聚合方法。此外，基于经典存储库和记录对象的应用程序没有唯一代表每个领域聚合的记录对象，而是有多个记录对象，每个对象包含对整体领域聚合的不同视图。因此，经典存储库为多个不同的记录对象提供了修改方法。
- en: Both classic and DDD-adapted repositories have methods to retrieve data to be
    returned to the user. In both cases, this data is represented by record-like objects,
    since aggregates are built only when domain entities must be modified or created.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 经典和DDD适应的存储库都有方法检索要返回给用户的数据。在两种情况下，这些数据都由记录对象表示，因为聚合仅在领域实体必须修改或创建时才构建。
- en: The diagram below summarizes the differences between classical and DDD-adapted
    repository patterns.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示总结了经典和DDD适应的存储库模式之间的差异。
- en: '![](img/B19820_07_06.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_07_06.png)'
- en: 'Figure 7.6: Classical and DDD-adapted repository pattern'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：经典和DDD适应的存储库模式
- en: Unit of work pattern
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作单元模式
- en: While it is preferable for transactions to be confined within the boundary of
    a single aggregate design, sometimes application layer transactions might span
    several aggregates and, accordingly, might use several different repository interfaces.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然将事务限制在单个聚合设计边界内是首选的，但有时应用层事务可能跨越多个聚合，因此可能使用多个不同的存储库接口。
- en: 'For instance, buying a travel involves the simultaneous modifications of the
    following entities:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，购买旅行同时涉及以下实体的修改：
- en: Hotel/travel available places
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 酒店/旅行可用场所
- en: Customer shopping basket
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户购物篮
- en: Both operations must be accomplished in a single transaction since either they
    are both successful or they must both fail. Therefore, we need a way to execute
    operations on several entities/aggregates in a single transaction, while keeping
    the methods/code of the involved entities decoupled, according to object-oriented
    programming best practices.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个操作必须在单个事务中完成，因为要么它们都成功，要么它们都必须失败。因此，我们需要一种方式在单个事务中执行对多个实体/聚合的操作，同时根据面向对象编程的最佳实践保持涉及实体的方法/代码解耦。
- en: The **Unit of Work** pattern is a solution that maintains the independence of
    the domain layer from the underlying domain layer implementation. It states that
    each repository interface must also contain a reference to a Unit of Work interface
    that represents the identity of the current transaction. This means that several
    repositories with the same Unit of Work reference belong to the same transaction.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**工作单元**模式是一种解决方案，它保持了领域层与底层领域层实现的独立性。它指出，每个存储库接口还必须包含对工作单元接口的引用，该接口代表当前事务的标识。这意味着具有相同工作单元引用的多个存储库属于同一事务。'
- en: The Unit of Work pattern can be used with both aggregates and record-like entities.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 工作单元模式可以与聚合和记录对象一起使用。
- en: 'Both the repository and the Unit of Work patterns can be implemented by defining
    some seed interfaces:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库和工作单元模式都可以通过定义一些种子接口来实现。
- en: '[PRE4]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All repository interfaces inherit from `IRepository<T>` and bind `T` to the
    aggregate root or entity they are associated with, while Unit of Work simply implements
    `IUnitOfWork`. When `SaveEntitiesAsync()` is called, all pending modifications,
    deletions, and creations done on aggregates or record-like objects are saved in
    a single transaction in the storage engine. If a wider transaction that starts
    when some data is retrieved from the storage engine is needed, it must be started
    and committed/aborted by the application layer handler, which takes care of the
    whole operation with the help of the `IUnitOfWork` `StartAsync`, `CommitAsync`,
    and `RollbackAsync` methods. `IRepository<T>` inherits from an empty `IRepository`
    interface to help automatic repository discovery.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 所有存储库接口都继承自 `IRepository<T>` 并将 `T` 绑定到它们关联的聚合根或实体，而工作单元（Unit of Work）仅实现 `IUnitOfWork`。当调用
    `SaveEntitiesAsync()` 时，所有对聚合或记录类对象进行的挂起修改、删除和创建都在存储引擎中作为一个事务保存。如果需要更广泛的交易，该交易在从存储引擎检索某些数据时启动，必须由应用程序层处理程序启动并提交/回滚，该处理程序通过
    `IUnitOfWork` 的 `StartAsync`、`CommitAsync` 和 `RollbackAsync` 方法负责整个操作。`IRepository<T>`
    从一个空的 `IRepository` 接口继承，以帮助自动存储库发现。
- en: The GitHub repository associated with this book contains a `RepositoryExtensions`
    class whose `AddAllRepositories` `IServiceCollection` extension method automatically
    discovers all the repository implementations contained in an assembly and adds
    them to the dependency injection engine.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书相关的 GitHub 存储库包含一个 `RepositoryExtensions` 类，该类的 `AddAllRepositories` `IServiceCollection`
    扩展方法自动发现一个程序集中包含的所有存储库实现，并将它们添加到依赖注入引擎中。
- en: Classic repository pattern versus DDD aggregates
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 经典存储库模式与 DDD 聚合对比
- en: The DDD patterns discussed so far, such as aggregates and DDD-adapted repositories,
    ensure modularity and modifiability, and, since whole domain aggregates are loaded
    in memory, they also prevent various kinds of bugs due to wrong partial updates.
    However, each addition of new functionality is cumbersome since it usually involves
    a complex modeling activity, the reengineering or creation of whole aggregates,
    and the definition of several classes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止讨论的 DDD 模式，如聚合和 DDD 适配的存储库，确保了模块化和可修改性，并且由于整个领域聚合被加载到内存中，它们还防止了由于错误的局部更新而产生的各种类型的错误。然而，每次添加新功能都相当繁琐，因为它通常涉及复杂建模活动、整个聚合的重构或创建，以及定义几个类。
- en: On the one hand, record-like objects are easier to define and we may define
    different classes for different usages. So, adding a new functionality simply
    requires the definition of an independent repository method, and possibly the
    definition of a new record-like class.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，记录类对象更容易定义，我们可以为不同的用途定义不同的类。因此，添加新的功能只需定义一个独立的存储库方法，可能还需要定义一个新的记录类。
- en: Suppose we need just to maintain travel descriptions and features. It is a very
    simple domain, and we need just to perform CRUD operations—that is, creating and
    deleting travels and modifying their features. In this case, there is no advantage
    in loading the whole aggregates in memory and performing all operations as methods
    of a unique entity class.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只需要维护旅行描述和特性。这是一个非常简单的领域，我们只需要执行 CRUD 操作——即创建和删除旅行以及修改它们的特性。在这种情况下，将整个聚合加载到内存中并作为唯一实体类的方法执行所有操作没有优势。
- en: On the other hand, with the classical repository pattern, we can load just the
    features of the travel we would like to modify, say a marketing-optimized description
    in some web pages, price in other pages where the user is an administrator with
    the power of deciding on prices, and so on. This way each operation uses a different
    object that is specific and optimized for that operation.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用经典的存储库模式，我们可以仅加载要修改的旅行的特性，例如在网页上的营销优化描述、在其他页面上的价格（在这些页面上，用户是具有决定价格权力的管理员）等等。这样，每个操作都使用一个特定且针对该操作优化的不同对象。
- en: Suppose now we are designing a complex resource allocation software for an industrial
    application. All properties of each entity are constrained by complex business
    rules, and also several entities are constrained by several complex business rules.
    Therefore, a partial update of a few properties has consequences that propagate
    to the whole entity and to other connected entities.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们现在正在为工业应用设计一个复杂的资源分配软件。每个实体的所有属性都受复杂业务规则的约束，而且几个实体也受几个复杂业务规则的约束。因此，对少数几个属性的局部更新会产生影响，这些影响会传播到整个实体和其他相关实体。
- en: In this case, each classical repository method would be forced to take into
    account all possible consequences of each property change, resulting in complex
    spaghetti code and in the recoding of the same operations several times in different
    repository methods.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每个经典的仓储方法都不得不考虑每个属性变化的所有可能后果，从而导致复杂的乱糟糟的代码，并在不同的仓储方法中多次重新编码相同的操作。
- en: In this case, a DDD approach performs much better. We load in memory the full
    aggregates involved and let their methods handle the business rule complexity
    with the help of object-oriented best practices. It is enough that each aggregate
    encodes the behavior of the real word object it represents, with no need to care
    about consequences on other entities.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，DDD方法表现得更好。我们将涉及的完整聚合体加载到内存中，并让它们的方法在面向对象最佳实践的辅助下处理业务规则复杂性。每个聚合体只需要编码它所代表的真实世界对象的行为了，无需关心对其他实体的影响。
- en: Summing up, when a Bounded Context is quite simple, meaning a few entities with
    a few interactions among them and a few different update operations, there is
    no doubt that the classic repository pattern is more convenient. On the other
    hand, when there are many entities, or complex entities, and many different update
    operations are added, repositories turn into spaghetti code with several partially
    overlapping methods, code duplication, and no easy-to-understand interaction rules.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，当一个边界上下文非常简单，意味着只有少数实体以及它们之间的一些交互和一些不同的更新操作时，毫无疑问，经典的仓储模式更加方便。另一方面，当存在许多实体或复杂实体，并且添加了许多不同的更新操作时，仓储会变成一团糟的代码，有多个部分重叠的方法、代码重复，以及没有易于理解的交互规则。
- en: A full example showing the DDD-adapted repository pattern is given in the *A
    frontend microservice* section of *Chapter 21, Case Study*, while a full example
    showing the classical repository pattern is given in the *Using client technologies*
    section of the same chapter.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第21章，案例研究*的*一个前端微服务*部分给出了一个展示DDD适配的仓储模式的完整示例，而在同一章节的*使用客户端技术*部分给出了一个展示经典仓储模式的完整示例。
- en: Moreover, as already pointed out, partial updates performed by several record-like
    projections of domain aggregates may cause bugs due to simultaneous modifications
    performed by different users.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如已经指出的那样，由多个记录投影的领域聚合体执行的局部更新可能会由于不同用户同时进行的修改而导致错误。
- en: Therefore, when the probability of similar bugs becomes high because of complex
    update patterns, it is very dangerous to use the classic repository pattern.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当由于复杂的更新模式，类似错误的概率变得很高时，使用经典的仓储模式是非常危险的。
- en: Thus, again, complexity is the main factor that drives us to the usage of DDD
    patterns. Moreover, the need to centralize the triggering of domain events used
    to synchronize Bounded Context data stores (review the previous *Understanding
    domain-driven design* section) forces the loading of whole aggregates in memory,
    and the usage of DDD patterns. Therefore, when a Bounded Context needs to trigger
    several domain events in complex circumstances, we can’t use the simpler classic
    repository pattern.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，再次强调，复杂性是我们使用DDD模式的主要驱动力。此外，需要集中触发用于同步边界上下文数据存储的领域事件（回顾之前的*理解领域驱动设计*部分），这迫使整个聚合体加载到内存中，并使用DDD模式。因此，当一个边界上下文需要在复杂情况下触发多个领域事件时，我们不能使用更简单的经典仓储模式。
- en: Now that we’ve discussed the basic patterns of DDD, we can discuss some more
    advanced DDD patterns. In the next section, we will introduce the CQRS pattern.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了DDD的基本模式，我们可以讨论一些更高级的DDD模式。在下一节中，我们将介绍CQRS模式。
- en: Command Query Responsibility Segregation (CQRS) pattern
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令查询责任分离（CQRS）模式
- en: 'In its general form, the usage of this pattern is quite easy: *use different
    structures to store/update and query data*. Here, the requirements regarding how
    to store and update data differ from the requirements of queries. This means that
    both the domain layer and application services of queries and store/update operations
    must be designed in completely different ways.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在其一般形式中，使用这个模式相当简单：*使用不同的结构来存储/更新和查询数据*。在这里，关于如何存储和更新数据的要求与查询的要求不同。这意味着查询和存储/更新操作的领域层和应用服务必须以完全不同的方式设计。
- en: In the case of DDD, the unit of storage is the aggregate, so additions, deletions,
    and updates involve aggregates. On the other hand, differently from storages/updates,
    queries don’t perform business operations but involve transformations of properties
    that have been taken from several aggregates (projections, sums, averages, and
    so on).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在DDD的情况下，存储的单位是聚合，因此添加、删除和更新涉及聚合。另一方面，与存储/更新不同，查询不执行业务操作，而是涉及从几个聚合（投影、求和、平均值等）中提取的属性的转换。
- en: Therefore, while updates require entities enriched with business logic and constraints
    (methods, validation rules, encapsulated information, and so on), query results
    just need sets of property/value pairs, so DTOs with only public properties and
    no methods work well.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然更新需要包含业务逻辑和约束（方法、验证规则、封装的信息等）的实体，但查询结果只需要属性/值对的集合，因此只有公共属性而没有方法的DTOs工作得很好。
- en: 'In its common form, the pattern can be depicted as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在其常见形式中，该模式可以描述如下：
- en: '![Diagram  Description automatically generated](img/B19820_07_07.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B19820_07_07.png)'
- en: 'Figure 7.7: Command and query processing'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：命令和查询处理
- en: 'Where:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: The middle boxes (Handlers and Repository interfaces) represent operations.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间的框（处理器和存储库接口）代表操作。
- en: The leftmost and rightmost boxes represent data.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最左侧和最右侧的框代表数据。
- en: Arrows simply represent the direction of data.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头简单地表示数据的方向。
- en: The main takeaway from this is that the extraction of query results doesn’t
    need to pass through the construction of entities and aggregates, but the fields
    shown in the query must be extracted from the storage engine and projected into
    ad hoc DTOs.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，查询结果的提取不需要通过实体的构建和聚合，但查询中显示的字段必须从存储引擎中提取并投影到临时的DTOs中。
- en: However, in more complex situations, CQRS may be implemented in a stronger form.
    Namely, we can use different Bounded Contexts to store preprocessed query results.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在更复杂的情况下，CQRS可能以更强的形式实现。具体来说，我们可以使用不同的边界上下文来存储预处理的查询结果。
- en: In fact, the other option would be an aggregator microservice that queries all
    the necessary microservices in order to assemble each query result. However, recursive
    calls to other microservices to build an answer may result in unacceptable response
    times. Moreover, factoring out some preprocessing ensures better usage of the
    available resources.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，另一种选择是一个聚合器微服务，它查询所有必要的微服务以组装每个查询结果。然而，对其他微服务的递归调用以构建答案可能会导致不可接受的响应时间。此外，提取一些预处理确保更好地使用可用资源。
- en: 'This pattern is implemented as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式如下实现：
- en: Query handling is delegated to separated and specialized components.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询处理委托给分离和专业的组件。
- en: Each query-handling component uses a database table for each query it must handle.
    There, it stores all fields to be returned by the query. This means that queries
    are not computed at each request, but precomputed and stored in specific database
    tables. Clearly, queries with child collections need additional tables, one for
    each child collection.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个查询处理组件为其必须处理的每个查询使用一个数据库表。在那里，它存储查询将返回的所有字段。这意味着查询不是在每次请求时计算，而是在特定的数据库表中预先计算并存储。显然，具有子集合的查询需要额外的表，每个子集合一个。
- en: All components that process updates forward all changes to the interested query-handling
    components. Records are versioned so the query-handling components that receive
    the changes can apply them in the right order to their query-handling tables.
    In fact, since communication is asynchronous to improve performance, changes are
    not guaranteed to be received in the same order they were sent.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有处理更新的组件都将所有更改转发给感兴趣的查询处理组件。记录是分版本的，以便接收更改的查询处理组件可以按照正确的顺序将其应用于其查询处理表。实际上，由于通信是异步的以提高性能，更改的接收顺序可能不会与发送顺序相同。
- en: Changes received by each query-handling microservice are cached while they wait
    for the changes to be applied. Whenever a change has a version number that immediately
    follows the last change applied, it is applied to the right query-handling table.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收到的每个查询处理微服务的更改在等待更改应用时被缓存。每当一个更改的版本号紧跟最后一个已应用的更改时，它就被应用到正确的查询处理表中。
- en: It is worth noticing that the software “components” we mentioned above run as
    separate processes on possibly different machines, and are called microservices.
    They will be discussed in detail in *Chapter 11*, *Applying a Microservice Architecture
    to Your Enterprise Application*.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们上面提到的“软件组件”作为独立进程在不同的机器上运行，被称为微服务。它们将在*第11章*，*将微服务架构应用于您的企业应用*中详细讨论。
- en: The usage of this stronger form of the CQRS pattern transforms typical local
    database transactions into complex time-consuming distributed transactions since
    a failure in a single query preprocessor microservice should invalidate the whole
    transaction. As we will discuss in *Chapter 11*, *Applying a Microservice Architecture
    to Your Enterprise Application*, implementing distributed transactions is usually
    unacceptable for performance reasons and sometimes is not supported at all, so
    the common solution is to renounce the idea of a database that is immediately
    consistent overall and to accept that the overall database will eventually be
    consistent after each update.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这种更强大的CQRS模式的使用将典型的本地数据库事务转换为复杂且耗时的分布式事务，因为单个查询预处理微服务中的失败应该使整个事务无效。正如我们将在*第11章*，*将微服务架构应用于您的企业应用*中讨论的那样，出于性能原因，通常不接受实现分布式事务，有时甚至不支持，因此常见的解决方案是放弃数据库立即整体一致性的想法，并接受整体数据库将在每次更新后最终一致。
- en: Transient failures can be solved with retry policies, which we will discuss
    in *Chapter 11*, *Applying a Microservice Architecture to Your Enterprise Application*,
    while permanent failures are handled by performing corrective actions on the already
    committed local transactions instead of pretending to implement an overall globally
    distributed transaction.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过重试策略解决瞬态故障，我们将在*第11章*，*将微服务架构应用于您的企业应用*中讨论这一点，而永久性故障则通过在已提交的本地事务上执行纠正操作来处理，而不是假装实现一个整体的全局分布式事务。
- en: 'At this point, you may be asking the following question:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能会有以下疑问：
- en: '*“Why do we need to keep the original data once we have all the preprocessed
    query results? We will never use it to answer queries!”*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*“为什么我们一旦有了所有预处理的查询结果，还需要保留原始数据？我们永远不会用它来回答查询！”*'
- en: 'Some of the answers to this question are as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的部分答案如下：
- en: They are the source of truth that we may need to recover from failures.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是我们可能需要从失败中恢复的真相来源。
- en: We need them to compute new preprocessed results when we add new queries.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们添加新的查询时，我们需要它们来计算新的预处理结果。
- en: We need them to process new updates. In fact, processing updates usually requires
    that some of the data is retrieved from the database, possibly shown to the user,
    and then modified.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要它们来处理新的更新。实际上，处理更新通常需要从数据库中检索一些数据，可能展示给用户，然后进行修改。
- en: For instance, to modify an item in an existing purchase order, we need the whole
    order so that we can show it to the user and compute the changes so that we can
    forward it to other microservices. Moreover, whenever we modify or add data to
    the storage engine, we must verify the coherence of the overall database (unique
    key constraints, foreign key constraints, and so on).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要修改现有采购订单中的项目，我们需要整个订单，以便我们可以展示给用户并计算更改，以便我们可以将其转发到其他微服务。此外，无论何时我们在存储引擎中修改或添加数据，我们都必须验证整个数据库的一致性（唯一键约束、外键约束等）。
- en: The next subsection is dedicated to an extreme implementation of the CQRS pattern.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将专门讨论CQRS模式的极端实现。
- en: Event sourcing
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件溯源
- en: Event sourcing is a more advanced implementation of the stronger form of CQRS.
    It is useful when the original Bounded Context is a **source of truth**—that is,
    for recovering from failures and for software maintenance. In this case, instead
    of updating data, we simply add events that describe the operation that was performed,
    such as *deleted record Id 15*, *changed the name to John in Id 21*, and so on.
    These events are immediately sent to all the dependent Bounded Contexts, and in
    the case of failures and/or the addition of new queries, all we have to do is
    reprocess some of them. For performance reasons, together with the events representing
    all changes, the current state is also maintained; otherwise, each time it is
    needed, it will need to be recomputed, replaying all events. Moreover, usually,
    the full state is cached after, say, every *N* changes. This way, if there is
    a crash or any kind of failure, only a few events must be replayed.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源是CQRS更强形式的一种更高级的实现。当原始的边界上下文是**真相来源**——即用于从故障中恢复和进行软件维护时，它非常有用。在这种情况下，我们不是更新数据，而是简单地添加描述已执行操作的**事件**，例如*删除记录ID
    15*，*将ID 21中的名称更改为John*，等等。这些事件立即发送到所有依赖的边界上下文，在出现故障和/或添加新查询的情况下，我们只需要重新处理其中的一些。出于性能考虑，除了表示所有更改的事件外，当前状态也被维护；否则，每次需要时，都需要重新计算，回放所有事件。此外，通常在每进行，比如说，*N*次更改之后，将完整状态缓存起来。这样，如果发生崩溃或任何类型的故障，只需要回放少量事件。
- en: Replaying events can’t cause problems if events are **idempotent**—that is,
    if processing the same event several times has the same effect as processing it
    once.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件是**幂等的**——也就是说，处理相同的事件多次与处理一次具有相同的效果，那么回放事件不会引起问题。
- en: As we will discuss in *Chapter 11*, *Applying a Microservice Architecture to
    Your Enterprise Application*, idempotency is a standard requirement for microservices
    that communicate through events.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在*第11章*中讨论的，*将微服务架构应用于您的企业应用程序*，幂等性是微服务通过事件通信的标准要求。
- en: In the next section, we will describe a common pattern that’s used for handling
    operations that span several aggregates and several Bounded Contexts.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将描述一个用于处理跨越多个聚合和多个边界上下文的操作的常见模式。
- en: Command handlers and aggregate events
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令处理器和聚合事件
- en: According to the Command pattern, each application domain operation is handled
    by a so-called command handler. Since each command handler encodes a single application
    domain operation, all of its actions must take place in the same transaction because
    the operation must succeed or fail as a whole. Command handlers perform their
    job by calling aggregates and repository methods. However, some actions might
    be triggered by state changes inside aggregates, so they can’t be called by command
    handlers but must rely on some form of direct aggregate-to-aggregate communication.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 根据命令模式，每个应用领域操作都由一个所谓的命令处理器处理。由于每个命令处理器编码了一个单一的应用领域操作，因此其所有操作都必须在同一个事务中完成，因为操作必须作为一个整体成功或失败。命令处理器通过调用聚合和存储库方法来完成其工作。然而，某些操作可能由聚合内部的状态变化触发，因此不能由命令处理器调用，而必须依赖于某种形式的直接聚合到聚合的通信。
- en: 'To keep aggregates separated, usually, communication among aggregates and also
    with other Bounded Contexts is done through events. We already discussed domain
    events used to communicate with other bounded contexts in the *Domain events*
    subsection. However, direct communication among aggregates can also take advantage
    of the publisher/subscriber pattern to keep the code more modular and easy to
    modify. It is good practice to store all the events when they are triggered during
    the processing of each aggregate, instead of executing them immediately, in order
    to prevent event execution from interfering with the ongoing aggregate processing.
    This is easily achieved by adding the following code to the abstract `Entity`
    class defined in the *Entities* subsection of this chapter, as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持聚合分离，通常，聚合之间以及与其他边界上下文之间的通信是通过事件完成的。我们已经在*领域事件*子节中讨论了用于与其他边界上下文通信的领域事件。然而，聚合之间的直接通信也可以利用发布/订阅模式来保持代码更模块化和易于修改。在处理每个聚合时，将触发的事件全部存储起来，而不是立即执行它们，以防止事件执行干扰正在进行的聚合处理，这是一种良好的实践。这可以通过向本章*实体*子节中定义的抽象`Entity`类添加以下代码轻松实现，如下所示：
- en: '[PRE5]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, `IEventNotification` is an empty interface that’s used to mark classes
    as events.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`IEventNotification`是一个空接口，用于标记作为事件的类。
- en: Event processing is usually performed immediately before changes are stored
    in the storage engine. Accordingly, a good place to perform event processing is
    immediately before the command handler calls the `SaveEntitiesAsync()` method
    of each `IUnitOfWork` implementation (see the *Repository pattern* subsection).
    Similarly, if event handlers can create other events, they must process them after
    they finish processing all their aggregates.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理通常在更改存储在存储引擎之前立即执行。因此，执行事件处理的好地方是在命令处理程序调用每个 `IUnitOfWork` 实现的 `SaveEntitiesAsync()`
    方法之前（参见 *Repository 模式* 子节）。同样，如果事件处理程序可以创建其他事件，它们必须在处理完所有聚合之后处理它们。
- en: 'Subscriptions to an event, `T`, can be provided as an implementation of the
    `IEventHandler<T>` interface:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 事件 `T` 的订阅可以提供为 `IEventHandler<T>` 接口的实现：
- en: '[PRE6]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Analogously, the command pattern is implemented with a `command` object, which
    contains all the input data of the application domain operation, while the code
    that implements the actual operation can be provided through a command handler
    that is an implementation of an `ICommandHandler<T>` interface:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，命令模式通过一个 `command` 对象实现，该对象包含应用程序域操作的所有输入数据，而实现实际操作的实际代码可以通过一个实现 `ICommandHandler<T>`
    接口的命令处理程序提供：
- en: '[PRE7]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, `ICommand` is an empty interface that’s used to mark classes as commands.
    `ICommandHandler<T>` and `IEventHandler<T>` are examples of the **Command pattern**
    we described in *Chapter 6*, *Design Patterns and .NET 8 Implementation*.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ICommand` 是一个空接口，用于标记类为命令。`ICommandHandler<T>` 和 `IEventHandler<T>` 是我们在
    *第 6 章*，*设计模式和 .NET 8 实现* 中描述的 **命令模式** 的示例。
- en: Each `ICommandHandler<T>` can be registered in the dependency injection engine
    so that classes that need to execute a command, `T`, can use `ICommandHandler<T>`
    in their constructor. This way, we decouple the abstract definition of a command
    (the class that implements `ICommand`) from the way it is executed.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `ICommandHandler<T>` 都可以在依赖注入引擎中注册，这样需要执行命令 `T` 的类就可以在其构造函数中使用 `ICommandHandler<T>`。这样，我们就将命令的抽象定义（实现
    `ICommand` 的类）与其执行方式解耦。
- en: 'The same construction can’t be applied to events, `T`, and their `IEventHandler<T>`,
    because when an event is triggered, we need to retrieve several instances of `IEventHandler<T>`
    and not just one. We need to do this since each event may have several subscriptions.
    However, a few lines of code can easily solve this difficulty. First, we need
    to define a class that hosts all the handlers for a given event type:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的构造方法不能应用于事件 `T` 和它们的 `IEventHandler<T>`，因为当一个事件被触发时，我们需要检索几个 `IEventHandler<T>`
    的实例，而不仅仅是其中一个。我们需要这样做，因为每个事件可能有多个订阅。然而，几行代码就可以轻松解决这个问题。首先，我们需要定义一个类，它为给定的事件类型托管所有处理程序：
- en: '[PRE8]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Declaring a `handlers` `IEnumerable<IEventHandler<T>>` parameter in the `EventTrigger<T>`
    constructor lets a .NET dependency injection engine pass all `IEventHandler<T>`
    implementations available in the dependency injection container to this `handlers`
    parameter.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `EventTrigger<T>` 构造函数中声明一个 `handlers` `IEnumerable<IEventHandler<T>>` 参数，允许
    .NET 依赖注入引擎将依赖注入容器中可用的所有 `IEventHandler<T>` 实现传递给这个 `handlers` 参数。
- en: The idea is that each class that needs to trigger event `T` requires `EventTrigger<T>`
    and then passes the event to be triggered to its `Trigger` method, which, in turn,
    invokes all the handlers.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是，每个需要触发事件 `T` 的类都需要 `EventTrigger<T>`，然后将要触发的事件传递给它的 `Trigger` 方法，该方法反过来调用所有处理程序。
- en: 'Then, we need to register `EventTrigger<T>` in the dependency injection engine.
    A good idea is to define the dependency injection extensions that we can invoke
    to declare each event, as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在依赖注入引擎中注册 `EventTrigger<T>`。一个好主意是定义我们可以调用的依赖注入扩展，以声明每个事件，如下所示：
- en: '[PRE9]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This `AddEventHandler` extension must automatically produce a dependency injection
    definition for `EventTrigger<T>` and must process all the handlers that are declared
    with `AddEventHandler` for each type, `T`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `AddEventHandler` 扩展必须自动生成 `EventTrigger<T>` 的依赖注入定义，并且必须处理每个类型 `T` 声明为 `AddEventHandler`
    的所有处理程序。
- en: 'The following extension class does this for us:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下扩展类为我们做了这件事：
- en: '[PRE10]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `H` type passed to `AddEventHandler` is recorded in the dependency injection
    engine, and the first time `AddEventHandler` is called, `EventTrigger<T>` is also
    added to the dependency injection engine. Then, when an `EventTrigger<T>` instance
    is required by the dependency injection engine, all `IEventHandler<T>` types added
    to the dependency injection engine are created, collected, and passed to the `EventTrigger(IEnumerable<IEventHandler<T>>
    handlers)` constructor.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `AddEventHandler` 的 `H` 类型被记录在依赖注入引擎中，当第一次调用 `AddEventHandler` 时，`EventTrigger<T>`
    也会添加到依赖注入引擎中。然后，当依赖注入引擎需要 `EventTrigger<T>` 实例时，所有添加到依赖注入引擎中的 `IEventHandler<T>`
    类型都会被创建、收集并传递给 `EventTrigger(IEnumerable<IEventHandler<T>> handlers)` 构造函数。
- en: When the program starts up, all the `ICommandHandler<T>` and `IEventHandler<T>`
    implementations can be retrieved with reflection and registered automatically.
    To help with automatic discovery, they inherit from `ICommandHandler` and `IEventHandler`,
    which are both empty interfaces.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序启动时，所有 `ICommandHandler<T>` 和 `IEventHandler<T>` 的实现都可以通过反射自动检索并注册。为了帮助自动发现，它们继承自
    `ICommandHandler` 和 `IEventHandler`，这两个接口都是空的。
- en: The `EventDIExtensions` class, which is available in this book’s GitHub repository,
    contains methods for the automatic discovery and registration of command handlers
    and event handlers. The GitHub repository also contains an `IEventMediator` interface
    and its `EventMediator` implementation, whose `TriggerEvents(IEnumerable<IEventNotification>
    events)` method retrieves all the handlers associated with the events it receives
    in its argument from the dependency injection engine and executes them. It is
    sufficient to have `IEventMediator` injected into a class so that it can trigger
    events. `EventDIExtensions` also contains an extension method that discovers all
    the queries that implement the empty `IQuery` interface and adds them to the dependency
    injection engine.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 《这本书的GitHub仓库》中提供的 `EventDIExtensions` 类包含用于自动发现和注册命令处理程序和事件处理程序的方法。GitHub仓库还包含一个
    `IEventMediator` 接口及其 `EventMediator` 实现，其 `TriggerEvents(IEnumerable<IEventNotification>
    events)` 方法从依赖注入引擎检索与其参数中接收的事件关联的所有处理程序并执行它们。只要将 `IEventMediator` 注入到类中，就可以触发事件。`EventDIExtensions`
    还包含一个扩展方法，用于发现实现空 `IQuery` 接口的所有查询并将它们添加到依赖注入引擎。
- en: A more sophisticated implementation is given by the `MediatR` NuGet package.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`MediatR` NuGet 包提供了一个更复杂的实现。'
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we analyzed the main reasons for the adoption of DDD and why
    and how it meets the needs of the market. We described how to identify domains
    and how to coordinate the teams that work on different domains of the same application
    with domain maps. Then, we analyzed the way DDD represents data with entities,
    value objects, and aggregates, providing advice and code snippets so that we can
    implement them in practice.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们分析了采用 DDD 的主要原因以及为什么以及如何满足市场需求。我们描述了如何识别领域以及如何使用领域图协调同一应用程序不同领域工作的团队。然后，我们分析了
    DDD 如何使用实体、值对象和聚合来表示数据，并提供建议和代码片段，以便我们可以在实践中实现它们。
- en: We also described the onion architecture frequently used in conjunction with
    DDD-based projects, and compared it with the classical layer architecture.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还描述了在基于 DDD 的项目中经常使用的洋葱架构，并将其与经典分层架构进行了比较。
- en: We also covered some typical patterns that are used with DDD—that is, the repository
    and Unit of Work patterns, domain event patterns, CQRS, and event sourcing. Then,
    we learned how to implement them in practice. We also showed you how to implement
    domain events and the command pattern with decoupled handling so that we can add
    code snippets to real-world projects.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了一些与 DDD 一起使用的典型模式——即仓库和单元工作模式、领域事件模式、CQRS 和事件溯源。然后，我们学习了如何在实践中实现它们。我们还展示了如何使用解耦处理实现领域事件和命令模式，以便我们可以将代码片段添加到现实世界的项目中。
- en: Questions
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What provides the main hints so that we can discover domain boundaries?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么提供了主要的提示，以便我们可以发现领域边界？
- en: What is the main tool that’s used for coordinating the development of a separate
    Bounded Context?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于协调独立边界上下文开发的主要工具是什么？
- en: Is it true that each entry that composes an aggregate communicates with the
    remainder of the system with its own methods?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否每个组成聚合的条目都使用自己的方法与系统的其余部分进行通信？
- en: Why is there a single aggregate root?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么只有一个聚合根？
- en: How many repositories can manage an aggregate?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个聚合可以管理多少个仓库？
- en: How does a repository interact with the application layer?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仓库如何与应用层交互？
- en: Why is the Unit of Work pattern needed?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么需要工作单元模式？
- en: What are the reasons for the light form of CQRS? What about the reasons for
    its strongest form?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CQRS轻量级形式的原因是什么？其最强形式的原因又是什么？
- en: What is the main tool that allows us to couple commands/domain events with their
    handlers?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主要允许我们将命令/领域事件与其处理程序耦合的工具是什么？
- en: Is it true that event sourcing can be used to implement any Bounded Context?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件溯源是否可以用来实现任何有界上下文？
- en: Further reading
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Eric Evans, Domain-Driven Design: [https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20](https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Eric Evans, 领域驱动设计: [https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20](https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20)'
- en: 'More resources on DDD can be found here: [https://domainlanguage.com/ddd/](https://domainlanguage.com/ddd/)'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于DDD的资源可以在以下链接找到：[https://domainlanguage.com/ddd/](https://domainlanguage.com/ddd/)
- en: 'A detailed discussion of CQRS design principles can be found here: [http://udidahan.com/2009/12/09/clarified-cqrs/](http://udidahan.com/2009/12/09/clarified-cqrs/)'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在这里找到对CQRS设计原则的详细讨论：[http://udidahan.com/2009/12/09/clarified-cqrs/](http://udidahan.com/2009/12/09/clarified-cqrs/)
- en: 'More information on MediatR can be found on MediatR’s GitHub repository: [https://github.com/jbogard/MediatR](https://github.com/jbogard/MediatR)'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于MediatR的信息可以在MediatR的GitHub仓库中找到：[https://github.com/jbogard/MediatR](https://github.com/jbogard/MediatR)
- en: 'A good description of event sourcing, along with an example of it, can be seen
    in the following blog post by Martin Fowler: [https://martinfowler.com/eaaDev/EventSourcing.html](https://martinfowler.com/eaaDev/EventSourcing.html)'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以下由Martin Fowler撰写的博客文章中可以看到事件溯源的良好描述及其示例：[https://martinfowler.com/eaaDev/EventSourcing.html](https://martinfowler.com/eaaDev/EventSourcing.html)
- en: Learn more on Discord
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the authors, and learn about new releases – follow the QR code
    below:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的Discord社区——在那里您可以分享反馈、向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
- en: '![](img/QR_Code175081751210902046.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code175081751210902046.png)'
