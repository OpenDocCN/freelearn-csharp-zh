<html><head></head><body>
		<div id="_idContainer013">
			<h1 class="chapter-number" id="_idParaDest-27"><a id="_idTextAnchor026"/>1</h1>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>The One with the  Low-Level Secrets</h1>
			<p><em class="italic">Understanding </em><span class="No-Break"><em class="italic">low-level APIs</em></span></p>
			<p>Writing software can be a daunting task. You need to consider many things when you try to convert your ideas into something that works on the machine. After all, there are so many things you need to tell the computer before it does <span class="No-Break">something useful.</span></p>
			<p>But we are in luck. Many of the instructions we need to give the CPU are encapsulated in frameworks, tools, packages, and other pieces of software. These building blocks allow us to focus on what we want to build instead of how the CPU might interpret our instructions. That makes life a <span class="No-Break">lot easier!</span></p>
			<p>This chapter looks into those building blocks, how they help us, and how we can best use them. This chapter also covers how .NET works and where it comes from. This is important: most developers take the advantages of .NET for granted. That is fine since the framework hides much complexity. However, when writing lower-level system software, it is essential to know why things in .NET work the way they do and how to use other solutions if needed. Also, it doesn’t hurt to be reminded of some basic things occasionally, especially when you might have to deviate from the road user-facing software <span class="No-Break">developers take.</span></p>
			<p>So, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>What are <span class="No-Break">low-level APIs?</span></li>
				<li>How does the Base Class Library (BCL) help us .<span class="No-Break">NET developers?</span></li>
				<li>What is the Common Language <span class="No-Break">Runtime (CLR)?</span></li>
				<li>What are Win32 APIs and how do we <span class="No-Break">call them?</span></li>
			</ul>
			<p>All in all, we are going low here and getting <span class="No-Break">all technical.</span></p>
			<p>But before we dive into the building blocks the .NET ecosystem gives us, we need to chat about APIs – to be more precise, the difference between low-level and <span class="No-Break">high-level APIs.</span></p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor028"/>Technical requirements</h1>
			<p>You can visit the following link to view all the code in this <span class="No-Break">chapter: </span><a href="https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter01"><span class="No-Break">https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter01</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/>What are low-level APIs, and how do they differ from higher-level abstractions?</h1>
			<p>Well, maybe <a id="_idIndexMarker054"/>we are going a bit too fast. Before we can look at low-level and high-level APIs, we need to agree on what an <span class="No-Break">API means.</span></p>
			<p>API is an abbreviation for application programming interface. Although technically correct, it doesn’t tell us much. We need a better definition <span class="No-Break">of API.</span></p>
			<p>What <span class="No-Break">are interfaces?</span></p>
			<p>Let’s begin with the term <strong class="bold">interface.</strong> That alone can be defined entirely differently, depending on whom <span class="No-Break">you ask.</span></p>
			<p>An interface can <a id="_idIndexMarker055"/>be a <strong class="bold">software interface</strong>, which is the boundary between two pieces of software. For instance, a database such as SQL Server allows users to access data by accepting SQL queries. That is the main interface for that <span class="No-Break">database system.</span></p>
			<p>Another definition of an interface <a id="_idIndexMarker056"/>would be a <strong class="bold">hardware interface</strong>. The USB ports on your computer and the peripherals you connect to your machine using them are <span class="No-Break">hardware interfaces.</span></p>
			<p>Of course, in C#, we also have interfaces. Most object-oriented programming languages support interfaces in one way or another. For instance, C++ has the concept of pure virtual classes. Python supports abstract base classes, which serve the <span class="No-Break">same purpose.</span></p>
			<p>An API is the interface between a piece of software and other software meant for the programmer. This defines the boundaries of a given code set and how to interact <span class="No-Break">with it.</span></p>
			<p>So, it is possible to create a giant library filled with wondrous and highly complex code. As the library user, you get a list of methods, classes, interfaces (yes, the C# kind), enums, and other means of interacting with <span class="No-Break">that library.</span></p>
			<p>This is awesome since you can use that library without worrying about writing <span class="No-Break">code yourself.</span></p>
			<p>Low-level and <span class="No-Break">high-level APIs</span></p>
			<p>The level of an <a id="_idIndexMarker057"/>API is an arbitrary distinction to give you an idea of how close to the actual hardware an <span class="No-Break">API is.</span></p>
			<p>No metric tells us when something is a lower or higher-level API. It is all relative and open for debate. This, however, is something we are not going to <span class="No-Break">do here.</span></p>
			<p>Generally, a low-level API gives you more granular control over the hardware than a higher-level API. A higher-level API, however, is usually more portable and can be used to achieve goals <span class="No-Break">much quicker.</span></p>
			<p>If that all sounds a bit abstract, don’t worry. Let me clarify this with some examples. For instance, imagine that you want to send some data across a network. Well, when I say network, I mean we send it to IP address <strong class="source-inline">127.0.0.1</strong>. In other words, we send it to localhost; we are speaking <span class="No-Break">to ourselves.</span></p>
			<p>To do this, we<a id="_idIndexMarker058"/> need to call a lot of low-level APIs that the Windows SDK gives us. The code looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
static void UseLowLevelAPI()
{
    WSAData wsaData;
    if (WSAStartup(0x0202, out wsaData) != 0)
    {
        Console.WriteLine("WSAStartup failed");
        return;
    }
    IntPtr sock = socket(2 /* AF_INET */, 1 /* SOCK_STREAM */, 0);
    if (sock == new IntPtr(-1))
    {
        Console.WriteLine("socket() failed");
        WSACleanup();
        return;
    }
    sockaddr_in sin = new sockaddr_in();
    sin.sin_family = 2; // AF_INET
    sin.sin_port =(ushort)IPAddress.HostToNetworkOrder((short)8000);     // Port 8000
    sin.sin_addr = BitConverter.ToUInt32(IPAddress.Parse("127.0.0.1")    .GetAddressBytes(), 0);
    if (connect(sock, ref sin, Marshal.SizeOf(typeof(        sockaddr_in))) != 0)
    {
        Console.WriteLine("connect() failed");
        closesocket(sock);
        WSACleanup();
        return;
    }
    byte[] data = Encoding.ASCII.GetBytes("Hello, server!");
    if (send(sock, data, data.Length, 0) == -1)
    {
        Console.WriteLine("send() failed");
    }
    closesocket(sock);
    WSACleanup();
}</pre>			<p>As you can<a id="_idIndexMarker059"/> see, many things must happen for such a relatively simple task. I have omitted all the code we need to access the APIs and the definition of the classes and structs, such as <strong class="source-inline">WSAData</strong>. I also simplified this sample and didn’t use much error handling or <span class="No-Break">memory management.</span></p>
			<p>I won’t go through what’s happening in the preceding code as it isn’t part of what I’m trying to show you. We will revisit this later in this book when we discuss networking. I provided this code to show you what a low-level API looks like. Here, I want you to pay attention to the calls to <strong class="source-inline">WSAStartup()</strong>, <strong class="source-inline">WSACleanup()</strong>, <strong class="source-inline">socket()</strong>, <strong class="source-inline">connect(</strong>), <strong class="source-inline">send()</strong>, and <strong class="source-inline">closesocket()</strong>. These are APIs that come from the Windows SDK. They are the parts of Windows that help us set up connections to network interfaces, translate addresses, open and close sockets, and <span class="No-Break">send data.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">It is good to remember that the Windows SDK is a wrapper. The code inside the SDK, written mainly in C and a bit in C++, does the heavy lifting and calls the hardware. We don’t have to worry about this: the people at Microsoft have already figured out how to do <span class="No-Break">all this.</span></p>
			<p>Like I said, low-level and high-level terms depend on how you look at them. It is all relative. You can consider Windows SDK APIs high-level APIs when you look at them from a C programmer’s perspective, who has to do all the <span class="No-Break">heavy lifting.</span></p>
			<p>But we, as .NET developers, see this as rather low-level. This is because, as .NET developers, we have even easier tools to use. The preceding code isn’t something most developers will write. Instead, they will write <span class="No-Break">the following:</span></p>
			<pre class="source-code">
static void UseHighLevelAPI()
{
    try
    {
        // Connect to server at 127.0.0.1:8000
        using (TcpClient client = new TcpClient("127.0.0.1", 8000))
        using (NetworkStream stream = client.GetStream())
        {
            // Prepare the message
            byte[] data = Encoding.ASCII.GetBytes("Hello, server!");
            // Send the message
            stream.Write(data, 0, data.Length);
            Console.WriteLine("Sent: Hello, server!");
        }
    }
    catch (SocketException e)
    {
        Console.WriteLine($"SocketException: {e}");
    }
    catch (IOException e)
    {
        Console.WriteLine($"IOException: {e}");
    }
    catch (Exception e)
    {
        Console.WriteLine($"Exception: {e}");
    }
}</pre>			<p>This code is much easier and a lot smaller. Most of the preceding code consists of <span class="No-Break">catching exceptions.</span></p>
			<p>The <strong class="source-inline">TcpClient</strong> class is doing the hard work. We instantiate an instance of it, give it the address we want to connect to, get a <strong class="source-inline">NetworkStream</strong> instance from it, and then write a bunch of bytes. Simple. It <span class="No-Break">works brilliantly.</span></p>
			<p>So, why would you care about the <span class="No-Break">low-level stuff?</span></p>
			<p>Although<a id="_idIndexMarker060"/> the low-level code is a lot more work and complicated, it gives you one significant advantage: <span class="No-Break">more control.</span></p>
			<p>We use TCP/IP here. But what if the device you want to communicate with doesn’t have TCP? And before you say “Everything is IP-based these days,” I’m pretty sure you have computers in your house that communicate over older technology. You might use devices that don’t have TCP on board every day. I’m talking about remote controls for most television sets. They use infrared. Many devices still use infrared. It’s cheap, well-understood, quick to install, and robust in terms of its use cases. It is also not supported <span class="No-Break">by .NET.</span></p>
			<p>But when it comes to low-level APIs, it is pretty simple. There are some differences in how to set up the connection: there is no IP address, so you have to use the device ID, but the connection itself is not that hard to use. Look at the line where we set up the call to <strong class="source-inline">socket()</strong>. We use <strong class="source-inline">2</strong> as the first parameter, which stands for <strong class="source-inline">AF_INET</strong>, which means TCP. Change that to <strong class="source-inline">26 (AF_IRDA)</strong>, and the underlying libraries switch to <span class="No-Break">infrared devices.</span></p>
			<p>This can’t be done with the .NET libraries that <span class="No-Break">are available.</span></p>
			<p>The high-level APIs are amazing and help us write code that is easy to understand quickly. However, as systems programmers, we have to deal with hardware and other low-level systems. That’s when we have to use the <span class="No-Break">low-level APIs.</span></p>
			<p>Before we dive into how to use these APIs, let’s look at the .NET libraries themselves. While we’re at it, we’ll examine the CLR so that you have a clear picture of what .NET <span class="No-Break">gives us.</span></p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/>Overview of .NET Core runtime components (CLR, BCL)</h1>
			<p>Previously, we <a id="_idIndexMarker061"/>examined the difference between low-level and high-level programming languages. Like the APIs, lower and higher mean how close to or far away you are from the actual machine. Programming in C means you are very close to the hardware; programming in C# means you are far away. Of course, being further away means you are working in abstractions. The advantage is that many things are simplified, as seen earlier in this chapter. Also, with many abstractions, moving your code to other platforms is <span class="No-Break">more manageable.</span></p>
			<p>The magic that makes this possible is the .NET runtime. Since the first version, the designers have always aimed to shield you from the low-level stuff as much as possible. This lets you write your code quickly and focus on functionality instead <span class="No-Break">of boilerplate.</span></p>
			<p>.NET is a complex topic. But in short, it comes down to a set of tools in many different forms that help you achieve <span class="No-Break">your goal.</span></p>
			<p class="callout-heading">Fun fact</p>
			<p class="callout">Before its initial launch, the project’s code name was Project 42. 42 is the answer to life, the universe, and everything in the books, TV shows, and the major motion picture from science fiction author Douglas Adams: <em class="italic">The Hitchhikers Guide to the Galaxy</em>. Adams wrote that 42 was the answer to everything; hence, the .NET designers thought it appropriate to name the solution to all developer problems <span class="No-Break">Project 42.</span></p>
			<p>.NET does not solve all problems, but it makes life much easier. Let’s see how it <span class="No-Break">does that.</span></p>
			<p>We can identify three major areas where .NET <span class="No-Break">helps us:</span></p>
			<ul>
				<li><span class="No-Break">Development tools</span></li>
				<li><span class="No-Break">The CLR</span></li>
				<li><span class="No-Break">The BCL</span></li>
			</ul>
			<p>I will not be spending time on development tools here. Instead, I want to discuss the CLR and the BCL. These two form the backbone of the .NET ecosystem. In later chapters, I will cover other essential parts of the .NET ecosystem, such as the <strong class="bold">Common Type </strong><span class="No-Break"><strong class="bold">System</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">CTS</strong></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>CLR</h2>
			<p>CLR is the <a id="_idIndexMarker062"/>runtime environment in which our <span class="No-Break">code runs.</span></p>
			<p>The compiler (covered later in this book) compiles the<a id="_idIndexMarker063"/> code we have written. For now, we can imagine that the compiler takes our human-readable text and changes it into something a computer can understand <span class="No-Break">and use.</span></p>
			<p>Well, not quite. I need to clarify things a bit here. Although what I wrote is technically correct when discussing compilers, this is only true for real compilers, such as those found using C or C++. This does not apply to the .<span class="No-Break">NET-based world.</span></p>
			<p>The .NET compilers compile while targeting a common runtime instead of the hardware we <span class="No-Break">run on.</span></p>
			<p>The compiler’s output is not native to the hardware. Instead, it outputs something called Intermediate Language (IL). This is a sort of “in-between” form. It’s not human-readable, but it is too abstract for computers to understand. It is in between those <span class="No-Break">two forms.</span></p>
			<p>Let me clarify that with <span class="No-Break">an example.</span></p>
			<p>I have written a .NET Console app with no top-level statements. In other words, this is the most simple piece of code we can write using .NET. The whole program consists of one <span class="No-Break">single line:</span></p>
			<pre class="source-code">
Console.WriteLine("Hello, System Programmers!");</pre>			<p>I don’t need to explain what I’m doing <span class="No-Break">here, right?</span></p>
			<p>If we use Visual Studio to compile the code, it will take all of our files, give them to the compiler, and instruct it to build a binary. That looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
.method private hidebysig static void  '&lt;Main&gt;$'(string[] args) cil managed
{
  .entrypoint
  // Code size       12 (0xc)
  .maxstack  8
  IL_0000:  ldstr      "Hello, System Programmers!"
  IL_0005:  call       void
  [System.Console]System.Console::WriteLine(string)
  IL_000a:  nop
  IL_000b:  ret
} // end of method Program::'&lt;Main&gt;$'</pre>			<p>This is a <a id="_idIndexMarker064"/>bit harder to understand but not too hard. First, there’s some code to set things up (<strong class="source-inline">.maxstack 8</strong>). We load the string with the call to<a id="_idIndexMarker065"/> the <strong class="source-inline">ldstr</strong> function and then call the <strong class="source-inline">System.Console::WriteLine(string)</strong> method, and we <span class="No-Break">are done.</span></p>
			<p>Again, this is not machine code. That looks a lot harder, and I’m not going to show you that. If compiled to something the CPU can understand and execute, this code is several <span class="No-Break">pages long.</span></p>
			<p>However, I will show you part of it to give you <span class="No-Break">a taster:</span></p>
			<pre class="source-code">
00007FF9558C06B0  push        rbp
00007FF9558C06B1  push        rdi
00007FF9558C06B2  push        rsi
00007FF9558C06B3  sub         rsp,20h
00007FF9558C06B7  mov         rbp,rsp
00007FF9558C06BA  mov         qword ptr [rbp+40h],rcx
00007FF9558C06BE  cmp         dword ptr [7FF95597CFA8h],0
00007FF9558C06C5  je
Program.&lt;Main&gt;$(System.String[])+01Ch (07FF9558C06CCh)
00007FF9558C06C7  call        00007FF9B54D7A10
00007FF9558C06CC  mov         rcx,1A871002068h
00007FF9558C06D6  mov         rcx,qword ptr [rcx]
00007FF9558C06D9  call        qword ptr
[CLRStub[MethodDescPrestub]@00007FF9559C17E0
(07FF9559C17E0h)]
00007FF9558C06DF  nop
00007FF9558C06E0  nop
00007FF9558C06E1  lea         rsp,[rbp+20h]
00007FF9558C06E5  pop         rsi
00007FF9558C06E6  pop         rdi
00007FF9558C06E7  pop         rbp</pre>			<p>This tiny<a id="_idIndexMarker066"/> assembly code segment instructs the CPU to take a pointer to the memory where the string is and then calls the first part of the <span class="No-Break"><strong class="source-inline">WriteLine</strong></span><span class="No-Break"> method.</span></p>
			<p>Again, the complete code would be several <span class="No-Break">pages long.</span></p>
			<p>I hope you <a id="_idIndexMarker067"/>are beginning to appreciate the brevity and simplicity of the .NET system. But I also want you to know what happens behind the scenes. When writing system software, we sometimes need to do things that aren’t possible in .NET. Then, we have to rely on other ways to achieve our results. We won’t write pure assembly in this book: that would be too much. But I do want you to know what’s happening as that will benefit you enormously <span class="No-Break">later on.</span></p>
			<p>Okay. Between the IL code I showed you and the assembly code I showed you is the place where the <span class="No-Break">CLR lives.</span></p>
			<p>As stated in <a href="https://learn.microsoft.com/en-us/dotnet/standard/clr">https://learn.microsoft.com/en-us/dotnet/standard/clr</a>, the CLR offers us quite a <a id="_idIndexMarker068"/>lot <span class="No-Break">of things:</span></p>
			<ul>
				<li><span class="No-Break">Performance improvements</span></li>
				<li>The ability to easily use components developed in <span class="No-Break">other languages</span></li>
				<li>Extensible types provided by a <span class="No-Break">class library</span></li>
				<li>Language features such as inheritance, interfaces, and overloading for <span class="No-Break">object-oriented programming</span></li>
				<li>Support for explicit free threading that allows multithreaded and scalable applications to <span class="No-Break">be created</span></li>
				<li>Support for structured <span class="No-Break">exception handling</span></li>
				<li>Support for <span class="No-Break">custom attributes</span></li>
				<li><span class="No-Break">Garbage collection</span></li>
			</ul>
			<p>This information<a id="_idIndexMarker069"/> comes straight out of the documentation from Microsoft, so if you want to know more, I urge you to look it up and read more <a id="_idIndexMarker070"/>about it. Later chapters will discuss some of these items, such as threading, exception handling, and garbage collection. For now, it is enough to know that when we compile our code, we prepare it for the CLR to use and run it. The CLR will take care of the rest and make it work nicely on <span class="No-Break">actual hardware.</span></p>
			<p>The code that runs on the CLR is what we call managed code. All other code (thus code not under the CLR’s control) is unmanaged. You will deal with managed code most of the time, but when writing system software, you’ll encounter unmanaged code quite frequently. But don’t worry: I will guide you <span class="No-Break">through that!</span></p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>BCL</h2>
			<p>One of the <a id="_idIndexMarker071"/>goals the designers of .NET had in mind was to eliminate something developers called <span class="No-Break">DLL Hell.</span></p>
			<p>The<a id="_idIndexMarker072"/> idea was that, when writing software, developers quickly realized that writing the same code repeatedly would be tiresome and a nightmare to maintain. Instead, they created libraries with functions they could reuse. These libraries would be loaded on demand and linked to the calling code. That is where the <a id="_idIndexMarker073"/>name <strong class="bold">Dynamic Link Library</strong> (<span class="No-Break"><strong class="bold">DLL</strong></span><span class="No-Break">) originated.</span></p>
			<p>Of course, developers, being developers, were not content with the DLLs they or someone else wrote earlier and made changes to them. These changes weren’t always backward compatible. That meant that as a user of a DLL, you had to make sure you used the correct version. You couldn’t easily upgrade without testing if that particular version of the DLL worked with <span class="No-Break">your code.</span></p>
			<p>There were <a id="_idIndexMarker074"/>two types of DLLs. One was proprietary to your code. You placed these DLLs in the same directory as your application, so all you needed to do was load the DLLs in your app directory. If a new application version came out, it came with its own set <span class="No-Break">of DLLs.</span></p>
			<p>Since most of the DLLs didn’t change a lot (if they even changed at all) there were many repetitive and duplicate DLLs. So, instead of duplicating code, we were now <span class="No-Break">duplicating DLLs.</span></p>
			<p>Fortunately, a solution was available: you could place DLLs in a shared space. On Windows, that was the <strong class="source-inline">C:\Windows\System32</strong> directory. The runtime knew that if it needed to load a DLL and couldn’t locate it in the <strong class="source-inline">applications</strong> directory, it could look at the <strong class="source-inline">System32</strong> directory and find <span class="No-Break">it there.</span></p>
			<p>When doing this, you needed to be sure you maintained <span class="No-Break">backward compatibility.</span></p>
			<p>Naturally, things went wrong. Updates would replace DLLs with newer, non-compatible versions. Sometimes, applications updated a DLL without realizing something else depended on it. Sometimes, an update would delete DLLs and thus break applications. In many cases, developers deployed the wrong versions. The list goes on and on. This caused many developers many frustrations and resulted in them calling this DLL Hell. Project 42 was set up to solve this. And in a way, <span class="No-Break">it did.</span></p>
			<p>A few decades ago, a <strong class="source-inline">String</strong> class was the first thing a new C++ programmer would write. C and C++ did not have such a thing: strings were not native to the language (they still aren’t, but the helper classes containing them are part of the standard now). A string can be pretty simple: it is just a pointer to a place in memory where all subsequent bytes form one long string. The string ends when the system sees a byte with a value of 0 (zero, not the character o). That’s it. A <strong class="source-inline">String</strong> class would contain the address of that array of bytes, some helper methods that allocate and clear the memory, and additional functions such as <strong class="source-inline">Length()</strong>. <span class="No-Break">That’s it.</span></p>
			<p>Soon, everybody wrote different versions, which would all be slightly different. .NET solved that by having a <strong class="source-inline">String</strong> class available. That class was part of a DLL that got shipped with the framework. The system registered that DLL, along with its version number. So, all developers needed to do was tell the system which version of the framework it was using, and by magic, things such as Strings were available. I am oversimplifying things here, but that is basically how <span class="No-Break">things work.</span></p>
			<p>There is a vast library that you can use as a .NET developer. You can see it in <strong class="source-inline">C:\Windows\assembly</strong>. If you use Windows Explorer, you’ll see a filtered view of the contents. You can see the actual contents using a terminal or <span class="No-Break">command line.</span></p>
			<p>These <a id="_idIndexMarker075"/>DLLs are part of the BCL. The BCL is a set of helper classes, functions, methods, and enums that help you do your work. Instead of figuring out all the code yourself, it is part of the installation and ready <span class="No-Break">to use.</span></p>
			<p>The classes and other code constructs in the DLLs that form the BCL are organized into namespaces. The<a id="_idIndexMarker076"/> BCL contains lots of helpful code some of which are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Core functionalities</strong>: The <strong class="source-inline">System</strong> namespace, which contains classes such as O<strong class="source-inline">bject</strong>, <strong class="source-inline">String</strong>, <strong class="source-inline">Array</strong>, and <span class="No-Break">so on.</span></li>
				<li><strong class="bold">File I/O</strong>: The <strong class="source-inline">System.IO</strong> namespace, for dealing with files, streams, <span class="No-Break">and more.</span></li>
				<li><strong class="bold">Networking</strong>: This has <strong class="source-inline">System.Net</strong> for dealing <span class="No-Break">with networking.</span></li>
				<li><strong class="bold">Threading</strong>: This has <strong class="source-inline">System.Threading</strong> for dealing with – you guessed it – <span class="No-Break">multithreading.</span></li>
				<li><strong class="bold">Data access</strong>: This has <strong class="source-inline">System.Data</strong> for dealing with data storage in databases and other ways of <span class="No-Break">persisting data.</span></li>
				<li><strong class="bold">XML processing</strong>: You can find <strong class="source-inline">System.Xml</strong> here, which you can use to handle XML files <span class="No-Break">and data.</span></li>
				<li><strong class="bold">Diagnostics</strong>: <strong class="source-inline">System.Diagnostics</strong> helps you identify issues in your code. We will be diving into this <span class="No-Break">one later.</span></li>
				<li><strong class="bold">Security</strong>: This contains the <strong class="source-inline">System.Security</strong> namespace, along with all things related to security <span class="No-Break">and encryption.</span></li>
			</ul>
			<p>There are many more namespaces, but these are some of the most used ones. We will revisit <span class="No-Break">them later.</span></p>
			<p>However, remember that these classes are there to help you. They wrap complicated and extensive code in good ways for most developers. However, If you find that the BCL code doesn’t get you where you want to be, nothing is stopping you from writing the code yourself. As we saw earlier, the BCL code is awesome if you want to set up a TCP/IP connection, but if you want to use an infrared connection instead, you must do <span class="No-Break">it yourself.</span></p>
			<p>The good news is that you can mix and match. Use the BCL where you can and low-level APIs where you <span class="No-Break">need to.</span></p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Using P/Invoke to call low-level APIs</h1>
			<p>We have<a id="_idIndexMarker077"/> established that .NET gives you many tools to develop something quickly. It also helps you out by shielding you from the low-level details of <a id="_idIndexMarker078"/>the underlying operating system. But it also allows you to use low-level APIs if you <span class="No-Break">need to.</span></p>
			<p>But how can we access those APIs? The answer is <strong class="bold">Platform Invocation</strong>, or (<strong class="bold">P/Invoke</strong>). We<a id="_idIndexMarker079"/> can use this tool to access the Win32 API directly. P/Invoke bridges the gap between the two platforms so that we can mix and match to our <span class="No-Break">hearts’ content.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Win32 is the name of the SDK and the APIs made available. There is no such thing as a Win64 API. Our code is compiled against 64-bit Windows if you run that platform, yet we (and Microsoft) still call it the <span class="No-Break">Win32 API.</span></p>
			<p>How does <span class="No-Break">P/Invoke work?</span></p>
			<p>P/Invoke involves<a id="_idIndexMarker080"/> a couple of steps. These are the steps you must follow to use a Win32 API in a .<span class="No-Break">NET application:</span></p>
			<ol>
				<li>Find the API you want <span class="No-Break">to use.</span></li>
				<li>Find the DLL the API <span class="No-Break">resides in.</span></li>
				<li>Load that DLL in <span class="No-Break">your assembly.</span></li>
				<li>Declare a stub that tells your application how to call <span class="No-Break">that API.</span></li>
				<li>Convert the .NET data types into something the Win32 API <span class="No-Break">can understand.</span></li>
				<li>Use <span class="No-Break">the API.</span></li>
			</ol>
			<p class="callout-heading">Warning!</p>
			<p class="callout">You are out of the loving and caring hands of .NET Framework and the CLR. You are no longer protected against mistakes. You are in an unmanaged world now. In the old days, they probably would have marked this part of the documentation with the warning “Here be dragons.” You are now responsible for many more things than you might be used to, such as memory management and error handling. You have more power over the system now, but remember: great power comes with <span class="No-Break">great responsibility!</span></p>
			<p>Let me<a id="_idIndexMarker081"/> start <a id="_idIndexMarker082"/>with an example. This showcases the power of .NET Framework, but it also shows how the aforementioned steps work in <a id="_idIndexMarker083"/>practice. We are going to do a simple “<span class="No-Break">Hello World.”</span></p>
			<p>To make sure we’re on the same page, let me show you the .NET version of <span class="No-Break">this program:</span></p>
			<p><strong class="source-inline">Console.WriteLine(“Hello, </strong><span class="No-Break"><strong class="source-inline">System Programmers!”);</strong></span></p>
			<p>Yes, this is the same sample we saw earlier. Hey, we have to start <span class="No-Break">somewhere, right?</span></p>
			<p>Now, <strong class="source-inline">Console</strong> is a class from the BCL. It has a static method, <strong class="source-inline">WriteLine</strong>, that outputs that string to the output. But what if we assume we don’t want to use that class? How should we go about this then? To frame this question another way, how does <strong class="source-inline">WriteLine</strong> work internally? After all, there has to be a point somewhere during execution where the code has to call the Win32 API. That can be done by the CLR or by us, but something or someone has to <span class="No-Break">call it.</span></p>
			<p>Let’s rewrite the code using P/Invoke. I will show you the entire program first, then dissect it and explain how it works line <span class="No-Break">by line:</span></p>
			<pre class="source-code">
01: using System.Runtime.InteropServices;
02:
03: [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError =         true)]
04: static extern bool WriteConsole(
05:     IntPtr hConsoleOutput,
06:     string lpBuffer,
07:     uint nNumberOfCharsToWrite,
08:     out uint lpNumberOfCharsWritten,
09:     IntPtr lpReserved);
10:
11: [DllImport("kernel32.dll", SetLastError = true)]
12: static extern IntPtr GetStdHandle(int nStdHandle);
13:
14: const int STD_OUTPUT_HANDLE = -11;
15:
16: IntPtr stdHandle = GetStdHandle(STD_OUTPUT_HANDLE);
17: if (stdHandle == IntPtr.Zero)
18: {
19:     Console.WriteLine("Could not retrieve standard output           handle.");
20:     return;
21: }
22:
23: string output = "Hello, System Programmers!";
24: uint charsWritten;
25:
26: if (!WriteConsole(
27:     stdHandle,
28:     output,
29:     (uint)output.Length,
30:     out charsWritten,
31:     IntPtr.Zero))
32: {
33:     Console.WriteLine("Failed to write using Win32 API.");
34: }</pre>			<p>That’s a lot of code, but let’s go <span class="No-Break">through it.</span></p>
			<p>In <em class="italic">line 1</em>, we import <a id="_idIndexMarker084"/>the namespace that allows us to use<a id="_idIndexMarker085"/> P/Invoke. .NET uses the name <strong class="source-inline">InteropServices</strong> for this, so it makes sense to <span class="No-Break">import that.</span></p>
			<p>In <em class="italic">line 3</em>, we see the magic happening. Remember the steps we have to take? <em class="italic">Step 1</em> is to “Find the API you want to use.” Since we want to print something on the screen, the <strong class="source-inline">WriteConsole</strong> API sounds like a <span class="No-Break">good fit.</span></p>
			<p>The official documentation from Microsoft states that the <strong class="source-inline">WriteConsole</strong> API “<em class="italic">Writes a character string to a console screen buffer beginning at the current cursor location.</em>” That sounds good <span class="No-Break">to me.</span></p>
			<p>The documentation then gives us the signature of <span class="No-Break">this API:</span></p>
			<pre class="source-code">
BOOL WINAPI WriteConsole(
  _In_             HANDLE  hConsoleOutput,
  _In_       const VOID    *lpBuffer,
  _In_             DWORD   nNumberOfCharsToWrite,
  _Out_opt_        LPDWORD lpNumberOfCharsWritten,
  _Reserved_       LPVOID  lpReserved
);</pre>			<p>If you’re a .NET developer, this might look weird. A lot is going on that we don’t know about or understand. We need to translate those types into something the CLR understands. Luckily, somebody has already figured that out for us. To make life even easier, they did <em class="italic">Steps 2</em> (find the DLL) and <em class="italic">4</em> (declare the stub) for us as well. Given the correct parameters, the CLR takes care of <em class="italic">Step 3</em> (load <span class="No-Break">the DLL).</span></p>
			<p>That “someone who figured this out” is the people behind <a href="https://pinvoke.net">https://pinvoke.net</a>. You can search for APIs and learn how to use <span class="No-Break">them there.</span></p>
			<p>The official <a id="_idIndexMarker086"/>documentation has a part called <strong class="bold">Requirements</strong>, and in that section, you’ll learn that the API lives in <strong class="source-inline">Kernel32.dll</strong> (<strong class="source-inline">Pinvoke.Net</strong> also gives you <span class="No-Break">that information).</span></p>
			<p><em class="italic">Line 3</em> is what tells <strong class="source-inline">InteropServices</strong> to load the DLL. Let’s dive <span class="No-Break">into that:</span></p>
			<pre class="source-code">
[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]</pre>			<p>This line tells the <a id="_idIndexMarker087"/>CLR to load <strong class="source-inline">kernel32.dll</strong>. It then specifies how to handle characters. Characters and strings can be complicated. There are several different ways to represent a single character. It can be an ASCII character, it can be Unicode, or it can be ANSI. They all have a different representation in memory. Here, we say we want to use <strong class="source-inline">Auto</strong>. When doing that, the system looks at the complete string we use, finds out which set it can use to represent the complete string, and uses the first one it can find. Since it starts by trying to fit it in an ASCII string and then “moves up” toward more complicated, slower, and more memory-intensive ways, this guarantees we get the best way to represent <span class="No-Break">this string.</span></p>
			<p>Next, we can see <strong class="source-inline">SetLastError = true</strong>. This instructs the system to inform us whenever something goes wrong. In case of an error, it calls the <strong class="source-inline">GetLastError</strong> API to get the error and return it to us. We will use this a lot later. For now, I advise you to always set <strong class="source-inline">SetLastError</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
			<p>Our runtime now knows to load <strong class="source-inline">kernel32.dll</strong>. But we must tell it what specific API we want to use. That happens in the following line. The function’s signature must always follow that <strong class="source-inline">DllImport</strong> directly: they always belong together. If you want to load multiple functions from the same Dll, you must still use <strong class="source-inline">DllImport</strong> <span class="No-Break">for each.</span></p>
			<p>The following line is the stub for <span class="No-Break">the function:</span></p>
			<pre class="source-code">
static extern bool WriteConsole(
    IntPtr hConsoleOutput,
    string lpBuffer,
    uint nNumberOfCharsToWrite,
    out uint lpNumberOfCharsWritten,
    IntPtr lpReserved);</pre>			<p>This<a id="_idIndexMarker088"/> looks like <a id="_idIndexMarker089"/>the code we saw from the official documentation, but now, the types have been translated into their .NET equivalents. Again, <strong class="source-inline">Pinvoke.Net</strong> is your <span class="No-Break">friend here!</span></p>
			<p>The parameters are more or less self-explanatory, except for the first one. Let’s skip that one and look at <span class="No-Break">the others:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-2">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">String lpBuffer</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">The string we want </strong><span class="No-Break"><strong class="bold">to print</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">nNumberOfCharsToWrite</span></p>
						</td>
						<td class="No-Table-Style">
							<p>The number of characters we want to print from the <span class="No-Break">given string</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">lpNumberOfCharsWritten</span></p>
						</td>
						<td class="No-Table-Style">
							<p>How many characters were written to <span class="No-Break">the system</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">lpReserved</span></p>
						</td>
						<td class="No-Table-Style">
							<p>This isn’t used, so it can <span class="No-Break">be ignored</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 1.1: Parameters for WriteConsole</p>
			<p>One thing to notice here is that Win32 APIs use the Hungarian notation for their parameters. This style says you have to prefix every parameter with an abbreviation of the type so that when you read the code later, you know what type this stands for. In the days before the current modern and fast IDEs, this helped a lot: you couldn’t hover your mouse over a variable to see what type it was; you had to scroll through the code to find the declaration. By prefixing it, you could see it immediately. These days, we don’t need to do that anymore, but C and C++ developers still use <span class="No-Break">this standard.</span></p>
			<p>So, as you can see, the string to print is a long pointer (lp), and the number of characters to write is a <span class="No-Break">number (n).</span></p>
			<p>But let’s have a look at <strong class="source-inline">hConsoleOutput</strong>. It is a handle (it starts with h), which translates it into <strong class="source-inline">IntPtr</strong> <span class="No-Break">in .NET.</span></p>
			<p>A pointer is just an address of something in memory. In our case, this memory belongs to the place where the console is. But how do we get that? Where is the code that controls <strong class="source-inline">Console</strong>, which is located <span class="No-Break">in memory?</span></p>
			<p>The <a id="_idIndexMarker090"/>answer is <a id="_idIndexMarker091"/>that we don’t know. There is no fixed place; this can and will change every time you restart your program. So, we need to look <span class="No-Break">for it.</span></p>
			<p>Luckily, that isn’t that hard to do as there’s an API we can use to do so. This API is called <strong class="source-inline">GetStdHandle</strong> and it lives in <strong class="source-inline">kernel32.dll</strong>. We know how to import that, and we can see it in our code on <em class="italic">lines 11</em> <span class="No-Break">and </span><span class="No-Break"><em class="italic">12</em></span><span class="No-Break">:</span></p>
			<pre class="source-code">
[DllImport("kernel32.dll", SetLastError = true)]
static extern IntPtr GetStdHandle(int nStdHandle);</pre>			<p>There are no strings, so we don’t need to set <strong class="source-inline">CharSet</strong>. However, we do need to <span class="No-Break">set </span><span class="No-Break"><strong class="source-inline">SetLastError</strong></span><span class="No-Break">.</span></p>
			<p>The method to find the address is called <strong class="source-inline">GetStdHandle</strong>, and it takes one parameter: <strong class="source-inline">nStdHandle</strong>. This tells this API what type of Console we are looking for. There are three types available:  <strong class="source-inline">STD_INPUT_HANDLE, STD_OUTPUT_HANDLE</strong>, and <strong class="source-inline">STD_ERROR_HANDLE</strong>. These three constants have -10, -11, and -12 as values, respectively. You’re right if you think it’s strange that they’re negative values. It’s weird. However, in Win32, these values are unsigned. They are the end of the integer range, so they don’t get in the way of any other types of console you might define yourself. Casting a high value of an unsigned int to a signed int results in a <span class="No-Break">negative value.</span></p>
			<p>On <em class="italic">line 14</em>, we define the <strong class="source-inline">STD_OUTPUT_HANDLE</strong> constant and give it a value of <strong class="source-inline">-11</strong>. This sort of thing is common: the Win32 API is a mess with magic numbers <span class="No-Break">and constants.</span></p>
			<p>On <em class="italic">line 16</em>, we use <strong class="source-inline">GetStdHandle</strong> to get the pointer to <strong class="source-inline">Console</strong> in memory, giving it <strong class="source-inline">STD_OUTPUT_HANDLE</strong>. If that goes wrong, we get a 0 (zero) back. But since .NET is strongly typed, we cannot use that number. Instead, we have to use the <strong class="source-inline">IntPtr.Zero</strong> constant, which is the same thing but in the <span class="No-Break">correct type.</span></p>
			<p>Every time you get a 0 back from a Win32 API, you have an error situation going on. We need to deal with that, but that is a topic <span class="No-Break">for later.</span></p>
			<p>Assuming all goes well, we can define our string, and the <strong class="source-inline">out</strong> variable tells us how many characters are written (<em class="italic">lines 23</em> <span class="No-Break">and </span><span class="No-Break"><em class="italic">24</em></span><span class="No-Break">).</span></p>
			<p>Then, on <em class="italic">line 26</em>, we call the <span class="No-Break">actual API:</span></p>
			<pre class="source-code">
if (!WriteConsole(
    stdHandle,
    output,
    (uint)output.Length,
    out charsWritten,
    IntPtr.Zero))
{
    Console.WriteLine("Failed to write using Win32 API.");
}</pre>			<p>This<a id="_idIndexMarker092"/> should be clear now. We call the API, give it the correct parameters, and check if the result is <span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">IntPtr.Zero</strong></span><span class="No-Break">).</span></p>
			<p>The CLR <a id="_idIndexMarker093"/>converts the complex .NET <strong class="source-inline">String</strong> type into a simple array of bytes with a 0 at the end. We don’t have to worry about that. We can give this API a C# string and everything will work <span class="No-Break">out fine.</span></p>
			<p>And that’s it. We have written something to the console using <span class="No-Break">Win32 APIs!</span></p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>Dealing with errors</h1>
			<p>In the<a id="_idIndexMarker094"/> previous examples, we did a little bit of error checking. If we couldn’t get the handle, we showed a message. We did the same thing if we couldn’t write to the console. I realize it’s funny to write to the console that the system cannot write to it (look at <em class="italic">line 33</em>, for instance), but you get what I <span class="No-Break">mean here.</span></p>
			<p>But this isn’t good enough if you want to know what’s going on for real. We need a more thorough way of <span class="No-Break">handling errors.</span></p>
			<p>In .NET, we are used to getting exceptions whenever things go wrong. We know how to deal with that. In the low-level world, things are different. When something goes wrong, we get <strong class="source-inline">0</strong> back, and we’re left to deal with it. We could continue with the code without being bothered by the error. We could even ignore the results of a call to an API. However, that would lead to disaster. You should always check and deal with the results of an API call. How to deal with that is something we discuss in <span class="No-Break">this section.</span></p>
			<p>There is a<a id="_idIndexMarker095"/> low-level API called <strong class="source-inline">GetLastError</strong> that can help us out here. The signature for P/Invoke is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
[DllImport("kernel32.dll")]
static extern uint GetLastError();</pre>			<p>It seems pretty straightforward. There are no parameters to worry about, and we don’t have to set that <strong class="source-inline">SetLastError</strong> value here. Since <strong class="source-inline">SetLastError</strong> ensures that any error is saved in the registry so that <strong class="source-inline">GetLastError</strong> can read it, there’s no value in having that here. If there would be, and we set it to false, then how does <span class="No-Break"><strong class="source-inline">GetLastError</strong></span><span class="No-Break"> work?</span></p>
			<p>This function returns an unsigned integer. This number corresponds with an error; you can look up what that number means in <span class="No-Break">the documentation.</span></p>
			<p>But there’s an issue: it doesn’t work. Well, it does, but there are no guarantees regarding <span class="No-Break">the result.</span></p>
			<p>The BCL and the <strong class="source-inline">CLR</strong> work with the low-level Win32 APIs constantly. That is obvious: the BCL is a wrapper around the Win32 API, and the CLR uses that wrapper to call into the core system of the operating system. We can call the APIs ourselves, as we have just done, but the CLR also calls it. Sometimes, it does it in the same thread. Other times, it calls it on another thread. Things can also go wrong during the CLR calls to the APIs. That results in <strong class="source-inline">GetLastError</strong> possibly returning no errors or the wrong errors. Well, technically, they aren’t the wrong errors, but they might not have to do anything with what <span class="No-Break">we’re doing.</span></p>
			<p>Luckily, the designers of .NET have thought about that and have added a class called <strong class="source-inline">Marshal</strong> to the <strong class="source-inline">System.Runtime.InteropServices</strong> namespace. That class is used to marshal between managed and unmanaged code – or, to put it in the context of what we are doing here, between Win32 APIs and our C# .<span class="No-Break">NET code.</span></p>
			<p>Let’s assume we made a mistake. I know that’s hard to imagine but bear with me here. Instead of assigning <strong class="source-inline">-11</strong> to <strong class="source-inline">STD_OUTPUT_HANDLE</strong>, we set it to <strong class="source-inline">11</strong>. We all make <span class="No-Break">mistakes, right?</span></p>
			<p>We then call <strong class="source-inline">GetStdHandle</strong> with <strong class="source-inline">11</strong>. That isn’t correct; we know that. The documentation says that the function returns <strong class="source-inline">0</strong> (or <strong class="source-inline">IntPtr.Zero</strong> in C#) if anything goes wrong. But in our case, it returns something else: <strong class="source-inline">0xffffffffffffffff</strong>. This is the unsigned version of the signed value, <strong class="source-inline">-1</strong>. In other words, the call to the API returns <strong class="source-inline">-1</strong>, which is not a <span class="No-Break">valid handle.</span></p>
			<p>However, we don’t check that. We only check for the <strong class="source-inline">0</strong> value. This makes sense if you think about it. After all, <strong class="source-inline">0</strong> indicates something went wrong when calling that function. That didn’t happen: the function worked flawlessly. It just didn’t find anything matching the ID we gave it (<strong class="source-inline">11</strong> instead of <strong class="source-inline">-11</strong>). So, as far as the API is concerned, there are <span class="No-Break">no errors.</span></p>
			<p>But then we<a id="_idIndexMarker096"/> get to the point where we call <strong class="source-inline">WriteConsole</strong>. We give it the handle of the console – or rather, we think we do. Instead, we give it a value of <strong class="source-inline">-1</strong> (<strong class="source-inline">0xffffffffffffffff</strong>). That is not a valid handle that <strong class="source-inline">WriteConsole</strong> can <span class="No-Break">work with.</span></p>
			<p>In .NET you would get an exception, but that doesn’t happen here. The code continues happily without complaining. It just doesn’t <span class="No-Break">output anything.</span></p>
			<p>These errors can be a pain to find and solve. In this case, it is quite straightforward, but imagine a situation where you try to set up a connection to an infrared receiver and something goes wrong. However, we keep going since we don’t check for that result. By the time we are ready to send data, nothing happens – or worse, the system crashes. We start to look at the code that does the actual sending, but nothing is wrong there. It takes much time and careful debugging to see that the error happens when we set up the connection. Let me repeat something I said earlier: you should always check the results of all API calls. That burden is on you. The .NET runtime generates exceptions in these cases, but if you are in unmanaged land, you are responsible for <span class="No-Break">doing so.</span></p>
			<p>Let’s improve our code <span class="No-Break">a bit.</span></p>
			<p>First, we’ll wrap our call to <strong class="source-inline">WriteConsole</strong> in a <strong class="source-inline">try-catch</strong> block and just catch <strong class="source-inline">Exception</strong>, although that is generally a bad idea. However, here, this is <span class="No-Break">good enough.</span></p>
			<p>If <strong class="source-inline">WriteConsole</strong> returns <strong class="source-inline">IntPtr.Zero</strong>, we have a problem and something goes wrong. In an unmanaged environment, you would call <strong class="source-inline">GetLastError</strong> to see what happens, but that doesn’t work here. Instead, we use that <strong class="source-inline">Marshal</strong> class I spoke <span class="No-Break">about earlier:</span></p>
			<pre class="source-code">
if(!WriteConsole(stdHandle, output, (uint)output.Length, out charsWritten, IntPtr.Zero))
{
    var lastError = Marshal.GetLastWin32Error();
    Console.WriteLine($ something went wrong. Error code:
        {lastError}");
}</pre>			<p>When<a id="_idIndexMarker097"/> running this with <strong class="source-inline">STD_OUTPUT_HANDLE</strong> set to <strong class="source-inline">11</strong>, the system reports that something went wrong. It even tells us that the error code <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">6</strong></span><span class="No-Break">.</span></p>
			<p>Looking this up in the official documentation results in the <span class="No-Break">following information:</span></p>
			<p><span class="No-Break">ERROR_INVALID_HANDLE</span></p>
			<p><span class="No-Break">6 (0x6)</span></p>
			<p>The handle <span class="No-Break">is invalid.</span></p>
			<p>This is precisely what’s <span class="No-Break">going on.</span></p>
			<p>“Wait a minute,” I can almost hear you say. “I can’t ask my users to look up the official documentation to see what an error message means every time something <span class="No-Break">goes wrong!”</span></p>
			<p>Well, you’ve got a point there. And the .NET design team agrees. They’ve added some ways to get that error message. There are two ways to get it, and you can choose which one <span class="No-Break">you want.</span></p>
			<p>First, if you want to have that error message, you can get it with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
if(!WriteConsole(stdHandle, output, (uint)output.Length, out charsWritten, IntPtr.Zero))
{
    var lastError = Marshal.GetLastWin32Error();
    var errorMessage = Marshal.GetPInvokeErrorMessage(lastError);
    Console.WriteLine($"Something went wrong. Error message:         {errorMessage}");
}</pre>			<p>Again, we <a id="_idIndexMarker098"/>start by getting the error code. We always have to do this, and we should do it as quickly as possible before another error somewhere else messes <span class="No-Break">things up.</span></p>
			<p>Then, we call the <strong class="source-inline">Marshal.GetPInvokeErrorMessage</strong> method and give it that <strong class="source-inline">lastError</strong> code. It returns a string telling us <strong class="source-inline">The handle </strong><span class="No-Break"><strong class="source-inline">is invalid.</strong></span></p>
			<p>Nice. But what if this error is so impactful that we cannot continue? .NET tells us to use exceptions in those cases. Good practice teaches us never to throw an exception but to use a specialized derived exception. We have just the right thing for <span class="No-Break">that: </span><span class="No-Break"><strong class="source-inline">Win32Exception</strong></span><span class="No-Break">.</span></p>
			<p>We could throw that and set the message to the message we got from <strong class="source-inline">GetPInvokeErrorMessage</strong>, but since that is such a common scenario, .NET Framework gives us a shortcut to do just so. Look at the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
try
{
    if(!WriteConsole(stdHandle, output, (uint)output.Length, out         charsWritten, IntPtr.Zero))
    {
        var lastError = Marshal.GetLastWin32Error();
        throw new Win32Exception(lastError);
    }
}
catch(Win32Exception e)
{
    Console.WriteLine($"Error: {e.Message}");
};</pre>			<p>This looks a lot better. This code results in a message on our screen stating <strong class="source-inline">Error: The handle is invalid</strong>. Okay, since this is just a simple example, I fail to properly deal with the issue (a rethrow would be a good idea here). How you continue after such an error depends on your coding style, your use case, and what you want <span class="No-Break">to achieve.</span></p>
			<p>There is one <a id="_idIndexMarker099"/>other way to get the error message. This one is quite nice but not as straightforward as the others we’ve <span class="No-Break">discussed: </span><span class="No-Break"><strong class="source-inline">FormatMessage</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">FormatMessage</strong> function comes from the Win32 API. Its declaration is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
[DllImport("kernel32.dll")]
static extern uint FormatMessage(
    uint dwFlags,
    IntPtr lpSource,
    uint dwMessageId,
    uint dwLanguageId,
    [Out] StringBuilder lpBuffer,
    uint nSize,
    IntPtr Arguments);</pre>			<p>If we have an error code, we can use it <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
var lastError = Marshal.GetLastWin32Error();
int bufferSize = 256;
var errorBuffer = new StringBuilder(bufferSize);
var res = FormatMessage(
    0x00001000,
    IntPtr.Zero,
    (uint)lastError,
    0,
    errorBuffer,
    (uint)bufferSize,
    IntPtr.Zero);
if(res != IntPtr.Zero)
{
    var formattedError = errorBuffer.ToString();
    Console.WriteLine(formattedError);
}</pre>			<p>First, we <a id="_idIndexMarker100"/>create <strong class="source-inline">StringBuilder</strong>. The API uses this to build up the string with the error message. We give it a size of <strong class="source-inline">256</strong> characters. This size should be enough for most, if not all, errors. We need to give this size since in C and C++, you need to allocate a buffer beforehand; it cannot expand dynamically (well, it could, but you wouldn’t do that if you want high performance). We call <strong class="source-inline">FormatMessage</strong> with the 0x00001000 flag. This flag means “use the error code provided.” We can use other flags, but this one is used most of the time. We don’t have a message we want to format, so the second parameter is <strong class="source-inline">IntPtr.Zero</strong>. Then, we give it <strong class="source-inline">lastError</strong>, 0 for the language (that is, the system default, usually English), the buffer, the size of the buffer, and another <strong class="source-inline">IntPtr.Zero</strong> parameter. This last one means we don’t use arguments. Here, arguments are the same as what we have in C# when we want to format <span class="No-Break">a string:</span></p>
			<pre class="source-code">
Console.WriteLine("Hello {0}", 42);</pre>			<p>Here, <strong class="source-inline">42</strong> is <span class="No-Break">the argument.</span></p>
			<p>We get that same “The handle is invalid” message when we <span class="No-Break">run this.</span></p>
			<p>You might want to use this API because it can do some nice tricks. For instance, replace <strong class="source-inline">languageId</strong> code 0 with the code 0x0413. This <strong class="source-inline">languageId</strong> is the Windows language ID for Dutch (please use whatever language <span class="No-Break">you want.)</span></p>
			<p>The result is <strong class="source-inline">De ingang is ongeldig</strong>, which is more or less a good translation of the <span class="No-Break">original error.</span></p>
			<p>This way, you can have nicely formatted, translated <span class="No-Break">error messages!</span></p>
			<p>There’s one last thing to cover here: many samples online use the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
if(!WriteConsole(stdHandle, output, (uint)output.Length, out charsWritten, IntPtr.Zero))
{
    var lastError = Marshal.GetLastWin32Error();
    var errorMessage = new Win32Exception(lastError).Message;
    Console.WriteLine($"Error: {errorMessage}");
}</pre>			<p>Technically, there’s <a id="_idIndexMarker101"/>nothing wrong with this. But this isn’t why exceptions are there. Creating one just to get the message is wrong. However, I have seen this so many times that I thought I should warn you against it. If you don’t want to throw an exception, don’t create one. In that case, call <strong class="source-inline">Marshal.GetPInvokeErrorMessage</strong> instead. You will do yourself and those maintaining your code a <span class="No-Break">huge favor.</span></p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Issues when debugging code with low-level APIs</h1>
			<p>Working with<a id="_idIndexMarker102"/> low-level APIs such as the Win32 API opens up a treasure trove of new and powerful tools. However, it comes with a <a id="_idIndexMarker103"/>couple of downsides. Debugging your code suddenly gets a lot harder, and it also becomes <span class="No-Break">more critical.</span></p>
			<p>There are a couple of areas you need to be aware of when you want to debug your code using <span class="No-Break">low-level APIs:</span></p>
			<ul>
				<li><span class="No-Break">Error handling</span></li>
				<li><span class="No-Break">Interoperability</span></li>
				<li><span class="No-Break">Debugging tools</span></li>
				<li>Compatibility <span class="No-Break">and portability</span></li>
				<li>Documentation and <span class="No-Break">community support</span></li>
			</ul>
			<p>Each of these can pose a challenge, requiring you to think about your debugging strategy before you start coding. Let’s go through the <span class="No-Break">potential issues.</span></p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>Error handling</h2>
			<p>As <a id="_idIndexMarker104"/>mentioned previously, you’re responsible for error handling when using low-level APIs. You don’t get exceptions from the functions you call when something goes wrong. You always have to be careful to check the return code of the calling code to see if it is 0. And even then, there is no guarantee that things work out as you expected. For instance, the call to <strong class="source-inline">GetStdHandle</strong> worked fine when we gave it an invalid type of <strong class="source-inline">ConsoleId</strong>, but the result was still not what we expected. You have to be very careful with these kinds of calls. Ideally, we would have caught that problem immediately and informed the system that something <span class="No-Break">went wrong.</span></p>
			<p>Even if you catch all the error codes, that doesn’t mean you can identify what went wrong. Sometimes, the error messages are so cryptic that you must read the documentation to see <span class="No-Break">what’s happening.</span></p>
			<p>There is a method in the API called <strong class="source-inline">CoCreateInstance</strong>. It deals with creating COM objects, which you use to connect to other systems, such as Word or Excel. To make that connection, give it the ID of the object you want to connect to. Those IDs are in the form of GUIDs, and you have to type them in. If there ever were a situation where it is easy to get things wrong, this would <span class="No-Break">be it.</span></p>
			<p>Using a non-existing <strong class="source-inline">ClassID</strong> returns an error code of <strong class="source-inline">0x80004005</strong>. If we use the methods described previously to get the error message, you would expect to read something like <strong class="source-inline">Invalid ClassId</strong> or <strong class="source-inline">COM Object not found</strong>. Unfortunately, what you get is <strong class="source-inline">E_FAIL: </strong><span class="No-Break"><strong class="source-inline">Unspecified error</strong></span><span class="No-Break">.</span></p>
			<p><span class="No-Break">Sigh.</span></p>
			<p>That isn’t helpful at all, is it? It failed. Okay, we got that. But why? What failed? We don’t know. The system doesn’t help you here at all. You have to know what you’re doing and what the system expects and go through every single line of the code to spot the error. That’s <span class="No-Break">not easy.</span></p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>Interoperability</h2>
			<p>As we’ve <a id="_idIndexMarker105"/>discussed, one of the steps you must take when calling Win32 APIs is to translate the types used in C# into their Win32 equivalents and vice versa. Sometimes, that’s easy; sometimes, it can be <span class="No-Break">pretty challenging.</span></p>
			<p>The framework designers did a lot to help us: when the Win32 API expects a string, you can usually give it a C# string, and the CLR marshals the type back and forth without you even knowing it. But still, there is some marshaling going on. A C-style string is a pointer to a place in memory where a character sits. The next character is next to it, and so on, until the system finds a value of 0. That is the end-of-string marker. This is entirely different from the <strong class="source-inline">String</strong> class we have in C# (internally, the <strong class="source-inline">String</strong> class still has that list of characters ending with 0 somewhere, but we never see that, so we can pretend it isn’t there <span class="No-Break">at all).</span></p>
			<p>Most types in C# have a sibling in Win32. Here’s a list of the most <span class="No-Break">used types:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table002-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">C# Type</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Win32 Type</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">byte</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">BYTE</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>8-bit <span class="No-Break">unsigned integer.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">sbyte</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">CHAR</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>8-bit signed integer, typically used for <span class="No-Break">ASCII characters.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">short</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">SHORT</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>16-bit <span class="No-Break">signed integer.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">ushort</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">WORD</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>16-bit <span class="No-Break">unsigned integer.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">int</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">INT</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">LONG</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>32-bit <span class="No-Break">signed integer</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">uint</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">UINT</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">DWORD</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>32-bit unsigned integer. Also used for flags <span class="No-Break">and enumerations.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">long</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">LONGLONG</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>64-bit <span class="No-Break">signed integer.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">ulong</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">ULONGLONG</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>64-bit <span class="No-Break">unsigned integer.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">float</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">FLOAT</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>32-bit <span class="No-Break">floating-point number.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">double</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">DOUBLE</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>64-bit <span class="No-Break">floating-point number.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">char</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">WCHAR</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">TCHAR</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>16-bit Unicode character in C#, whereas <strong class="source-inline">WCHAR</strong>/<strong class="source-inline">TCHAR</strong> varies <span class="No-Break">in Win32.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">bool</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">BOOL</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Boolean type. <strong class="source-inline">True</strong> or <strong class="source-inline">False</strong> in C#, and typically <strong class="source-inline">TRUE</strong> or <strong class="source-inline">FALSE</strong> in Win32. Here, <strong class="source-inline">FALSE</strong> is defined as <strong class="source-inline">0</strong>, whereas <strong class="source-inline">TRUE</strong> is defined as <strong class="source-inline">NOT FALSE</strong>, meaning any other value, but usually, it <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">IntPtr</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">HANDLE</strong>, <strong class="source-inline">HINSTANCE</strong>, <strong class="source-inline">HWND</strong>, and <span class="No-Break">so on</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Represents a pointer or a handle. The type varies <span class="No-Break">on context.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">UIntPtr</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Rarely used <span class="No-Break">in Win32</span></p>
						</td>
						<td class="No-Table-Style">
							<p>An unsigned pointer <span class="No-Break">or handle.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">T[]</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">T*</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">SAFEARRAY</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>An array of the <strong class="source-inline">T</strong> type. Its representation depends on the context <span class="No-Break">in Win32.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">DateTime</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">FILETIME</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">SYSTEMTIME</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Represents Date and Time. Representation varies <span class="No-Break">in Win32.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Guid</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">GUID</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">UUID</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>GUID. 128-bit number. (GUID is usually tied to Windows platforms, while UUID is found on other platforms. They are basically the <span class="No-Break">same, though.)</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">TimeSpan</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Typically represented by a combination <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">DWORDs</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A time interval. This is not available <span class="No-Break">on Win32.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table1.2: C# and Win32 types</p>
			<p>As you can<a id="_idIndexMarker106"/> see, most types can easily be translated between the platforms. When we dive into the more complex types, things get a bit more complicated since a lot of them are dependent on context or implementation. This makes marshaling types between the platforms <span class="No-Break">a challenge.</span></p>
			<p>Another<a id="_idIndexMarker107"/> thing to consider is something called calling convention. A calling convention defines how to handle parameters when calling a function. The two most common types are <strong class="source-inline">stdcall</strong> and <strong class="source-inline">cdecl</strong>. Win32 APIs usually use <strong class="source-inline">stdcall</strong>, while most other C libraries <span class="No-Break">expect </span><span class="No-Break"><strong class="source-inline">cdecl</strong></span><span class="No-Break">.</span></p>
			<p>I won’t dive too deep into these two calling conventions. However, let’s summarize the most <span class="No-Break">important differences:</span></p>
			<ul>
				<li><strong class="source-inline">stdcall</strong>: The callee cleans the stack. It has a fixed number of arguments and it is commonly used in the Windows API. Here, function names usually <span class="No-Break">get decorated.</span></li>
				<li><strong class="source-inline">cdecl</strong>: The caller cleans the stack and allows variable-length argument lists. It is commonly used in the C standard library. Here, function names <span class="No-Break">aren’t decorated.</span></li>
			</ul>
			<p>As you can see, knowing how to call a function is essential. The wrong convention can mess up the stack, and the arguments are passed to the function or return the wrong results. You could even mess up the memory, which is almost unheard of when writing <span class="No-Break">managed code.</span></p>
			<p>When you don’t specify the calling convention, <strong class="source-inline">stdcall</strong> is assumed. You should give the correct calling convention if you need to call <span class="No-Break">another library.</span></p>
			<p>Maybe an example would help here. We used <strong class="source-inline">WriteConsole</strong> to write to the console earlier, but there is a much easier way: the <strong class="source-inline">printf</strong> function. This function is part of the C runtime in the Microsoft <strong class="source-inline">msvcrt.dll</strong> library. If you want to use this function, import it with the now well-known <span class="No-Break"><strong class="source-inline">DllImport</strong></span><span class="No-Break"> declaration:</span></p>
			<pre class="source-code">
[DllImport("msvcrt.dll", CallingConvention = CallingConvention.Cdecl)]
static extern int printf(string format, int i, double d);
printf("Hello, System Programmers!\n", 1, 2.0);</pre>			<p>Since this function is not part of the Win32 API but instead resides in a separate DLL, you must be careful and specify the correct calling convention. Here, we need to use <strong class="source-inline">cdecl</strong>, which we can specify by setting <strong class="source-inline">CallingConvention = </strong><span class="No-Break"><strong class="source-inline">CallingConvention.Cdecl</strong></span><span class="No-Break">.</span></p>
			<p>Other types include <strong class="source-inline">WinAPI</strong>, <strong class="source-inline">StdCall</strong> (they are basically the same), <strong class="source-inline">ThisCall</strong>, and <strong class="source-inline">FastCall</strong>. You will hardly ever encounter the last two, but at least you have heard of <span class="No-Break">them now.</span></p>
			<p>When you call an<a id="_idIndexMarker108"/> API and get weird errors or unexpected behavior, you might want to look into how to marshal the types or the calling conventions. The system doesn’t help you here by giving you good <span class="No-Break">error messages.</span></p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>Debugging tools</h2>
			<p>Visual Studio Debugger is <a id="_idIndexMarker109"/>awesome. However, when<a id="_idIndexMarker110"/> mixing managed with unmanaged code, things might get tricky. If something goes wrong, the system might halt and show you a breakpoint. But since the code that’s being called is not C#, the debugger might not show you what you need to see. It tries its best, so it will probably disassemble the code and show you the assembly code that is <span class="No-Break">at fault.</span></p>
			<p>I showed you some assembly code at the beginning of this chapter. That isn’t something you might want to see if you want to find errors in your code. Well, I don’t know if that applies to you, but I certainly don’t want to <span class="No-Break">see that.</span></p>
			<p>If that happens, you might want to use other debuggers, such as WinDbg. Later in this book, when we cover debugging, we take a closer look at this tool. But trust me, debugging mixed code is no walk in <span class="No-Break">the park.</span></p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>Compatibility and portability</h2>
			<p>Windows <a id="_idIndexMarker111"/>changes. Sometimes, it changes a lot; sometimes, the changes are subtle. Although Microsoft is known for trying <a id="_idIndexMarker112"/>to keep things backward compatible as much as possible, sometimes, APIs change. The signature might change, or the behavior might change. And you only find out about that when things go horribly wrong. Again, you see very few exceptions or error messages, so you’re left to debug the code and step <span class="No-Break">through it.</span></p>
			<p>As soon as you start using Win32 APIs, you are tying yourself to a limited set of devices and platforms you <span class="No-Break">can use.</span></p>
			<p>And don’t even think about deploying the preceding code to a Linux platform. Sure, .NET runs fine on Linux, but not when you start using P/Invoke. And it might be that your code runs fine on one edition of Windows but breaks horribly on the next one that comes out of Redmond. We could call that “job security” since it will require us to update our code now and then, but I wouldn’t go as far as calling <span class="No-Break">it fun.</span></p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>Documentation and community support</h2>
			<p>The primary <a id="_idIndexMarker113"/>audience for<a id="_idIndexMarker114"/> the documentation of the Win32 API is C and C++ developers. As a C# developer, it is hard to find the information needed. Sites such as <a href="https://pinvoke.net">https://pinvoke.net</a> help, but only if you know how <span class="No-Break">they work.</span></p>
			<p>The documentation of third-party DLLs you might want to use as a .NET developer is even harder to find. Sometimes, you must inspect a DLL, see how it works internally, and then translate it into the proper DLL import statement. If you do that, ensure you have the correct calling convention <span class="No-Break">and types!</span></p>
			<p>Community support when mixing managed and unmanaged code is also a challenge. Most developers fall into one of two camps: they work in the unmanaged world or they work in the managed world. Doing both is <span class="No-Break">very rare.</span></p>
			<p>Good developers who can do both are scarce. The good news is that by reading this book, you are on the right path to becoming one of that very <span class="No-Break">elite group!</span></p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor041"/>Next steps</h1>
			<p>This chapter looked at the difference between low-level and high-level APIs. We dove into the foundations of .NET by examining the BCL and CLR. Then, we examined how to call into low-level APIs such as the Win32 API. We did that by reimplementing the ubiquitous <strong class="source-inline">Console.WriteLine</strong> into code that the Windows operating system can run without using the BCL. That led us to discuss error discovery and error handling, and how to best go <span class="No-Break">about them.</span></p>
			<p>We also discussed the issues you might encounter when you start doing that sort of coding. We mentioned the differences in type systems and the issues you might have when dealing <span class="No-Break">with debuggers.</span></p>
			<p>I hope this chapter has made you appreciate the .NET Framework and the hard work the BCL and CLR do for you as a developer. But I also hope you realize the power you get when using the Win32 API or other third-party libraries written in C <span class="No-Break">or C++.</span></p>
			<p>System programming relies heavily on these techniques. Although using these APIs ties you to the operating system you’re developing for or even a specific version of that system, this is often the only way to achieve your results. And to be honest, I think working with these APIs is fun. It is all about getting back to <span class="No-Break">the basics.</span></p>
			<p>Working with low-level APIs can be challenging. They can lead to a lot of hard-to-solve errors. But when used correctly, they can lead to better performance in your code. When writing system software, that is very important. As discussed previously, system software should not get in the way of the user or the systems the user directly interacts with. Instead, it should be as fast as possible. So, using the correct APIs might give you just that extra performance you need. I think this is so important that I wrote a complete chapter on performance, which happens to be the next chapter. We were born to run, so let’s run as fast as possible to the <span class="No-Break">next part!</span></p>
		</div>
	</body></html>