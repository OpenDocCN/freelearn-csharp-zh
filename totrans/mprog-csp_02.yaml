- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Metaprogramming Concepts
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元编程概念
- en: Now that we have a few ideas about how metaprogramming can benefit you, we need
    to cover the basic concepts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对元编程如何为您带来好处有了一些想法，我们需要介绍基本概念。
- en: When working with metaprogramming, you get metadata for free from the environment
    it’s running in, and there is the opportunity to explicitly add more. With explicitness,
    you can enable clarity in your code base, and a level of transparency for the
    developers writing and reading the code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用元编程时，您可以从运行环境免费获得元数据，并且有机会显式地添加更多。通过显式性，您可以在代码库中实现清晰度，并为编写和阅读代码的开发者提供透明度。
- en: Some parts of your source code will benefit from more explicit metadata rather
    than having it implicitly and just magically do things that can be hard for developers
    to reason about why.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 您的源代码中的一些部分将受益于更多的显式元数据，而不是隐式地、神奇地执行一些可能难以让开发者推理其原因的操作。
- en: With explicitness also comes the possibility of representing the domain language
    of your business in code and with increasing expressiveness.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 显式性也带来了在代码中表示业务领域语言的可能性和更高的表达性。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Implicit – using what is already there
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式 - 使用已有的内容
- en: Explicit – additional adornment of code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式 - 代码的额外修饰
- en: Domain-specific languages
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域特定语言
- en: By the end of the chapter, you should have a good feel for the different metaprogramming
    concepts you can leverage, when to use which concept, and the benefits of each
    concept.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您应该对可以使用的不同元编程概念有良好的感觉，知道何时使用哪个概念，以及每个概念的好处。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find all the source code used in this chapter in the GitHub repository:
    [https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter2](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter2).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub仓库中找到本章使用的所有源代码：[https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter2](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter2)。
- en: Implicit – using what is already there
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式 - 使用已有的内容
- en: 'The compiler that compiles **C#** parses all our code and ends up creating
    what is referred to as **IL-code**, short for **Intermediate Language code**.
    This is standardized and part of the **ECMA-335** standard for the Common Language
    Infrastructure. You can read more about the standard here: [https://www.ecma-international.org/publications-and-standards/standards/ecma-335/](https://www.ecma-international.org/publications-and-standards/standards/ecma-335/).
    This type of code is not something that the CPU in the system understands and
    it requires another step for the CPU to understand it. The last step of translation
    is done when we run our programs and the **.NET runtime** takes over, interprets
    the IL, and generates the necessary instructions for the CPU type of the computer
    the program is running on.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 编译**C#**的编译器解析我们所有的代码，最终创建被称为**IL-code**（中间语言代码）的内容。这是标准化的，并且是通用语言基础设施（Common
    Language Infrastructure）的**ECMA-335**标准的一部分。您可以在以下链接中了解更多关于标准的信息：[https://www.ecma-international.org/publications-and-standards/standards/ecma-335/](https://www.ecma-international.org/publications-and-standards/standards/ecma-335/)。这种代码不是系统CPU所能理解的，它需要额外的步骤才能让CPU理解。程序的运行过程中，翻译的最后一个步骤是由**.NET运行时**执行的，它解释IL代码，并为程序运行的计算机的CPU类型生成必要的指令。
- en: Looking at the binary output, you can’t necessarily tell the difference. But
    by opening up the binary using a decompiler tool such as **ildasm**, or something
    more visual, such as **JetBrains dotPeek** ([https://www.jetbrains.com/decompiler/](https://www.jetbrains.com/decompiler/)),
    we can get a glimpse at what our programs look like.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看二进制输出，您可能无法确定差异。但通过使用如**ildasm**之类的反编译工具或更直观的工具，如**JetBrains dotPeek**（[https://www.jetbrains.com/decompiler/](https://www.jetbrains.com/decompiler/))，我们可以一窥我们的程序看起来是什么样子。
- en: 'Take, for instance, the following program:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下程序为例：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Compiling this will produce a **Dynamic Link Library** (**DLL**) file, and
    on opening the file with a decompiler, we would see something like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 编译此代码将生成一个**动态链接库**（**DLL**）文件，当使用反编译器打开文件时，我们会看到如下内容：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'On an x86/AMD64-based CPU, this then gets translated into something like the
    following disassembled code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于x86/AMD64的CPU上，这随后会被转换成如下反汇编代码：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The actual **Hello world!** string is then placed in memory at the location
    used by the first **mov** instruction. If you’re interested in trying out code
    and seeing how it translates yourself, I recommend heading over to [https://sharplab.io](https://sharplab.io).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的 **Hello world!** 字符串随后被放置在由第一个 **mov** 指令使用的内存位置。如果你对尝试代码并自己查看其翻译感兴趣，我建议你前往
    [https://sharplab.io](https://sharplab.io)。
- en: In the finished compiled result, there is actually no metadata whatsoever, making
    it impossible to reason about our code in any meaningful way.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终编译的结果中，实际上没有任何元数据，这使得我们无法以任何有意义的方式对代码进行推理。
- en: While the IL contains everything we wrote, all the type information is intact
    (type names, method names, and so forth).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然IL包含了我们编写的一切，但所有类型信息都是完整的（类型名称、方法名称等）。
- en: With that, we are being set up for success to do some proper metaprogramming.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就为成功进行一些适当的元编程做好了准备。
- en: Leveraging the power of reflection
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用反射的强大功能
- en: All this information is available to us, and it all starts with the powerful,
    and my personal favorite, namespace called **System.Reflection**. This holds all
    the C# types representing the different code elements we write. Since C# is a
    managed language running on top of the managed runtime, we get all the details
    about all the code we write.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些信息都对我们开放，并且这一切都始于强大且我个人最喜欢的命名空间 **System.Reflection**。它包含了所有代表我们编写的不同代码元素的
    C# 类型。由于 C# 是在托管运行时之上运行的托管语言，我们可以获得关于我们编写的所有代码的详细信息。
- en: Since every type we have created and will create is inherent of the **Object**
    type, every derived type inherently gets its methods and properties. One of these
    methods is called **GetType()**. This method returns an instance of the type of
    the object in the form of **Type**. It holds all the details about the particular
    type – everything from what namespace it resides in, to fields, properties, methods
    on it, and much more. For the type, we can even look at what it is inheriting
    and what interfaces it might implement. We can even see which assembly (DLL) it
    is defined in.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们创建的每个类型以及我们将创建的类型都是 **Object** 类型的派生类型，因此每个派生类型都固有地获得了其方法和属性。其中一个方法被称为 **GetType()**。此方法返回一个对象类型的实例，形式为
    **Type**。它包含了有关特定类型的所有详细信息——从它所在的命名空间，到字段、属性、方法，以及更多。对于类型，我们甚至可以查看它继承的内容以及它可能实现的接口。我们甚至可以看到它定义在哪个程序集（DLL）中。
- en: If you look at object-relational mappers such as **Microsoft’s Entity Framework**,
    **Dapper**, **NHibernate**, or even the **MongoDB C# Driver**, they all use reflection
    to reason about the types you have to translate into something expected by the
    underlying data store. For a relational store, it would typically translate into
    the correct **SQL** statements, while for MongoDB, it would be the correct MongoDB
    **Binary JSON** (**BSON**) objects.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看对象关系映射器，如 **Microsoft 的 Entity Framework**、**Dapper**、**NHibernate** 或甚至是
    **MongoDB C# 驱动程序**，它们都使用反射来推理你必须翻译成底层数据存储期望的类型。对于关系型存储，它通常翻译成正确的 **SQL** 语句，而对于
    MongoDB，它将是正确的 MongoDB **Binary JSON** （**BSON**）对象。
- en: The same is done by things that serialize from .NET types to other formats,
    such as JSON. Libraries such as **Newtonsoft.JSON** or the built-in **System.Text.Json**
    namespace leverages reflection to know what to translate.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，从 .NET 类型序列化为其他格式（如 JSON）的东西也会这样做。例如，**Newtonsoft.JSON** 或内置的 **System.Text.Json**
    命名空间利用反射来了解需要翻译的内容。
- en: 'Let’s say you have a **Person** type:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个 **Person** 类型：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'An extremely simplistic conversion to JSON could easily be done:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个极其简单的 JSON 转换可以轻松完成：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This can then be used as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以按以下方式使用：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output of running this would yield some nice JSON:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码的输出将产生一些漂亮的 JSON：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code basically gets the type information from the instance and gets the
    properties on it. It outputs a string containing the property name and leverages
    **PropertyInfo** to get a value from the instance and just outputs its **.****ToString()**
    representation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 代码基本上从实例中获取类型信息，并获取其上的属性。它输出一个包含属性名称的字符串，并利用 **PropertyInfo** 从实例中获取值，并仅输出其
    **.ToString()** 表示形式。
- en: Obviously, this sample is very simple and non-recursive for complex types or
    support arrays and doesn’t recognize well-known JSON primitive types. But this
    proves how easily you can get to the information.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个示例非常简单，并且对于复杂类型不支持递归，也不识别已知的 JSON 原始类型。但这证明了你可以多么容易地获取这些信息。
- en: Implicit metadata and the type system of .NET can be very powerful. The further
    down the rabbit hole you go with reflection, the more you’ll probably feel like
    going further and doing more. The flip side of that is for everything you do automatically,
    you lose the transparency of what’s going on. It needs to be balanced and be as
    close to the element of least surprise as possible.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式元数据和 .NET 的类型系统可以非常强大。您在反射的洞穴中走得越深，可能就越想继续深入并做更多的事情。另一方面，对于您自动执行的所有事情，您都会失去对正在发生的事情的透明度。这需要平衡，并尽可能接近最小惊讶元素。
- en: For some things, you’re better off going with being very explicit. There is
    also metadata that can’t be discovered with what the compiler generates, and the
    only way to go is to be very explicit.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些事情，最好是做得非常明确。还有一些元数据无法通过编译器生成的信息来发现，唯一的方法就是非常明确地指定。
- en: Explicit – additional adornment of code
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式 - 代码的额外修饰
- en: Pretty much all code elements can have additional information added to them.
    These are called **attributes**. Attributes are a powerful method of associating
    metadata with the element. Within the .NET framework itself, you’ll see quite
    a few of these attribute types that can be used.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的代码元素都可以添加额外的信息。这些被称为 **属性**。属性是将元数据与元素关联的强大方法。在 .NET 框架本身中，您会看到许多可以使用的属性类型。
- en: In the **System.ComponentModel.DataAnnotations** namespace, you can find some
    great examples of attributes that add metadata used by the runtime. Here, you’ll
    find attributes used for adding validation metadata. ASP.NET picks up the usage
    of these attributes and checks objects being sent to controller actions for validity
    according to the rules applied. As we saw briefly in [*Chapter 1*](B19418_01.xhtml#_idTextAnchor015),
    *How Can Metaprogramming Benefit You?*, with our **RegisterPerson** type, we could
    instruct properties that should be required. It contains much more, for instance,
    **[StringLength]** and **[Range]**. These are great examples of metadata recognized
    by the framework and components that support them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **System.ComponentModel.DataAnnotations** 命名空间中，您可以找到一些添加由运行时使用的元数据的属性示例。在这里，您将找到用于添加验证元数据的属性。ASP.NET
    会检测这些属性的用法，并检查发送到控制器操作的实体是否符合应用规则。正如我们在 [*第 1 章*](B19418_01.xhtml#_idTextAnchor015)
    简要提到的，“元编程如何为您带来好处？”，使用我们的 **RegisterPerson** 类型，我们可以指定哪些属性是必需的。它包含更多内容，例如 **[StringLength]**
    和 **[Range]**。这些都是框架和它们所支持的组件识别的元数据的优秀示例。
- en: 'Some attributes in the framework are recognized by the compiler and will direct
    the compiler to perform certain things. For instance, the **[Flags]** attribute
    can be added to enums that instruct it to require every value to represent a bit
    field:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 框架中的一些属性被编译器识别，并将指导编译器执行某些操作。例如，**[Flags]** 属性可以添加到枚举中，指示它要求每个值都表示一个位字段：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With this type of enum, we define flags, with each flag being a left bitwise
    shift for the number of places to move to represent the correct bit. You can also
    do this by giving the actual decimal or hexadecimal number of the bit (**1**,
    **2**, **4**, or **8**, or **0x1**, **0x2**, **0x4**, **0x8**, **0x10**, and so
    on).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种类型的枚举，我们定义标志，每个标志都是一个左移位，用于将数字移动到正确的位的位置。您也可以通过给出实际的十进制或十六进制数来做到这一点（**1**、**2**、**4**
    或 **8**，或 **0x1**、**0x2**、**0x4**、**0x8**、**0x10**，等等）。
- en: 'The **System.Text.Json** serializer also makes use of metadata. It uses metadata
    to know how to serialize or deserialize what it is given. For instance, it can
    ignore properties in an object:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**System.Text.Json** 序列化器也使用了元数据。它使用元数据来确定如何序列化或反序列化所提供的内容。例如，它可以忽略对象中的属性：'
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Serializing an instance of this would leave out **FullName**.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化此实例将省略 **FullName**。
- en: Creating custom attributes
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义属性
- en: You can easily create your own custom attributes by adding the metadata you
    want for your code. All attributes can take arguments with the extra metadata
    you want to have associated with them. This gives you the opportunity to be very
    specific on what data you want to associate as metadata with the code element
    being adorned.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过添加您想要为代码添加的元数据来轻松创建自己的自定义属性。所有属性都可以接受带有额外元数据的参数，这些元数据将与它们关联。这为您提供了机会，可以非常具体地指定您想要与被修饰的代码元素关联的数据作为元数据。
- en: All of the metadata added to an attribute needs to be resolvable by the compiler
    at compile time. That limits us to only have things that are typical primitive
    types and constant in nature. You can’t dynamically create instances of things
    to pass into an attribute.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到属性中的所有元数据都需要在编译时由编译器解析。这限制了我们只能使用典型的基本类型和本质上是常量的东西。你不能动态创建实例并将其传递给属性。
- en: An example of an attribute could, for instance, be for describing types or properties
    that hold **personal identifiable information** (**PII**). This can be very useful
    to be able to later reason about your code, to know what PII is being collected
    about users, which can be presented to the user themselves. With the European
    Union privacy law called **GDPR**, it could also be used as a reporting mechanism
    if your company is audited or have a GDPR-related incident and need to report
    it to the authorities.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个属性的例子可能是用于描述包含**个人可识别信息**（**PII**）的类型或属性。这非常有用，可以让你在以后推理你的代码时知道正在收集哪些PII信息，并将其展示给用户。根据欧盟的隐私法律**GDPR**，如果你的公司在接受审计或发生与GDPR相关的事件时需要向当局报告，这也可以作为一个报告机制。
- en: A huge benefit, once you have tagged types and properties with this metadata,
    is that you get an opportunity for future use cases – for example, the encryption
    of PII data or anything else.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你用这种元数据标记了类型和属性，你就有机会用于未来的用例——例如，加密PII数据或其他任何东西。
- en: 'Creating a custom attribute is in its basic form as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义属性的基本形式如下：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The **PersonalIdentifiableInformationAttribute** type needs to inherit the base
    **Attribute** type. The compiler also expects the type you create to be suffixed
    with **Attribute** as part of the name. However, when using your custom attribute,
    you can then leave out **Attribute** in the name, the compiler will map this to
    the full name with the suffix added to it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**PersonalIdentifiableInformationAttribute**类型需要继承基础**Attribute**类型。编译器还期望你创建的类型名称中包含**Attribute**作为后缀。然而，当使用你自定义的属性时，你可以在名称中省略**Attribute**，编译器会将它映射到带有后缀的完整名称。'
- en: The next thing you need to specify is actually a bit of metadata for the compiler.
    This is done using the **[AttributeUsage]** attribute. With this, we need to specify
    what target code elements are supported, and we can support multiple by *ORing*
    (the **OR** operation) them together.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步你需要指定的是实际上是一点编译器的元数据。这是通过使用**[AttributeUsage]**属性来完成的。使用它，我们需要指定支持哪些目标代码元素，并且我们可以通过*或操作*（**OR**操作）来支持多个。
- en: 'For **PersonalIdentifiableInformationAttribute**, we’d typically want this
    for classes, properties, and fields:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**PersonalIdentifiableInformationAttribute**，我们通常希望它在类、属性和字段中使用：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In addition, we specify that we don’t want to allow multiple copies of the same
    attribute. A good practice is to have your attributes be very specific and not
    create any inheritance chains of attributes. This will make your attribute a **sealed**
    type not allow inheritance from a C# perspective.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们指定我们不希望允许同一属性的多个副本。一个好的做法是让你的属性非常具体，不要创建任何属性的继承链。这将使你的属性成为一个**密封**类型，从C#的角度来看不允许继承。
- en: 'One of the things that GDPR mentions is to record the collection purpose. So,
    to add to this, we could include the purpose as optional metadata. You can do
    this by adding a constructor that takes the metadata as an argument, and if you
    want it to be optional, you can give it a default value:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: GDPR提到的一件事是记录收集目的。因此，为了补充这一点，我们可以包括作为可选元数据的用途。你可以通过添加一个接受元数据作为参数的构造函数来实现这一点，如果你想让它成为可选的，你可以提供一个默认值：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, in addition to adding the constructor with the argument for
    the metadata, you need to add the **Purpose** property that exposes the metadata.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，除了添加带有元数据参数的构造函数外，你还需要添加**Purpose**属性来公开元数据。
- en: 'With this, we can start applying the **PersonalIdentifiableInformation** attribute
    to properties on something, such as a **Person** object:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以开始将**PersonalIdentifiableInformation**属性应用于某些对象上的属性，例如**Person**对象：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We will go into more depth on how we can leverage this further in [*Chapter
    5*](B19418_05.xhtml#_idTextAnchor083), *Leveraging Attributes*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第五章*](B19418_05.xhtml#_idTextAnchor083)中更深入地探讨如何进一步利用它，*利用属性*。
- en: We’ve discussed how we can reason about our code through implicit structures
    and also how we can add explicit additional metadata and even our own custom data.
    What about going the other way? By this, we mean going from something and basically
    generating code.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何通过隐式结构来推理我们的代码，以及我们如何添加显式的额外元数据和甚至我们自己的自定义数据。那么反过来呢？我们的意思是从某个东西开始，基本上生成代码。
- en: As we talked about previously, the programming language itself is basically
    a higher-level metadata language designed to be able to express code more efficiently.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，编程语言本身基本上是一种高级元数据语言，旨在能够更有效地表达代码。
- en: With that mindset, there is really nothing stopping us from inventing our own
    language and leveraging the infrastructure to generate running code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种心态，实际上没有什么能阻止我们发明自己的语言，并利用基础设施生成运行代码。
- en: Domain-specific languages
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域特定语言
- en: The concept of creating your own **domain-specific language** (**DSL**) is nothing
    new and has been done for years by companies. This can be a very efficient way
    to include your domain experts in the mix and provide a way for them to contribute
    code in a language that is more familiar to them. The code they write is typically
    then on a much higher level and has a vocabulary that is supported by lower-level
    code constructs, which are actually doing the heavy lifting.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自己的**领域特定语言**（**DSL**）的概念并不是什么新鲜事，公司们已经做了很多年了。这可以是一个非常有效的方法，将你的领域专家纳入其中，并为他们提供一种用他们更熟悉的语言贡献代码的方式。他们编写的代码通常处于一个更高的层次，并且拥有由底层代码结构支持的词汇表，而这些底层代码结构实际上在做着繁重的工作。
- en: Think of this as a programming language and a compiler for your business, expressing
    your business problems.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将其视为一种编程语言和你的业务的编译器，用来表达你的业务问题。
- en: It could also be used for technical aspects and not just for the business side
    – for instance, if you have complex state machines or workflows that have their
    own vocabulary and you want to make it into a language that is easier to reason
    about. You could also imagine that the language is represented in a well-known
    file format such as JSON, YAML, or even Excel.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以用于技术方面，而不仅仅是业务方面——例如，如果你有复杂的状态机或工作流程，它们有自己的词汇表，你希望将其转化为更容易推理的语言。你也可以想象这种语言以JSON、YAML或甚至Excel等众所周知的文件格式表示。
- en: The purpose of going to the length of generating the code for this higher-level
    representation is that you get an opportunity to make the end result more optimal,
    and you can make decisions to optimize the flow before it hits the runtime. You
    also get a snappier startup of your application, as it doesn’t have to parse things
    at startup and hand it over to an engine that runs it. It will ultimately just
    be code running, just as any other code in your solution.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 生成这种高级表示形式的代码的目的在于，你可以有机会使最终结果更加优化，你可以在它到达运行时之前做出优化流程的决定。你还可以让你的应用程序启动更快，因为它不需要在启动时解析东西并将其传递给运行它的引擎。最终，它将只是运行代码，就像你的解决方案中的任何其他代码一样。
- en: Gherkin – technical sample
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gherkin – 技术样本
- en: 'If you’re familiar with writing unit tests, the typical structure is **arrange**,
    **act**, and then **assert**. A test would look something like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉编写单元测试，典型的结构是**准备**、**执行**，然后是**断言**。一个测试可能看起来像这样：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This code tests a calculator to verify that its add functionality works as expected.
    It does this by setting up the inputs and expected results, then calling into
    the calculator, and finally, verifying the result by using assertions that claim
    the result should be the same as the expected result.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码测试了一个计算器，以验证其加法功能是否按预期工作。它是通过设置输入和预期结果，然后调用计算器，最后通过断言来验证结果，断言结果应该与预期结果相同来完成的。
- en: While this is the more traditional **test-driven development** (**TDD**) style,
    there is something called **behavior-driven design** (**BDD**). This approach
    focuses much more on the behavior of a system and interactions between parts of
    your system rather than its state. For expressing this interaction, a DSL was
    created called **Gherkin**. It is somewhat similar in its basic form with *given*,
    *when*, and *then*, which maps pretty much to the same as TDD’s *arrange*, *act*,
    and *assert*. In addition, it has the concepts of features, scenarios, and steps.
    The goal is to write concrete functional requirements for a system.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是更传统的**测试驱动开发**（**TDD**）风格，但还有一种叫做**行为驱动设计**（**BDD**）的方法。这种方法更多地关注系统的行为以及系统各部分之间的交互，而不是其状态。为了表达这种交互，创建了一个名为**Gherkin**的领域特定语言（DSL）。在基本形式上，它与TDD的“arrange”（准备）、“act”（执行）和“assert”（断言）相对应，即“给定”、“当...时”和“然后”。此外，它还包括了功能、场景和步骤的概念。目标是编写系统的具体功能需求。
- en: For higher-order functionality, it is hard for domain experts to reason about
    C# code to verify whether we’re testing the right thing or delivering what is
    expected.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高级功能，领域专家很难对C#代码进行推理，以验证我们是否测试了正确的东西或是否交付了预期的内容。
- en: With the correct tool, we can start articulating the functionality of a system
    in plain English and let it be hooked up to code snippets that perform the actual
    code we need to test or specify.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正确的工具，我们可以用普通的英语来描述一个系统的功能，并将其连接到执行实际代码的代码片段，以便测试或指定。
- en: 'A great example of an implementation of this is the .NET BDD framework called
    **SpecFlow** ([https://specflow.org/](https://specflow.org/)). When navigating
    to their site, you’re presented with their data privacy dialog, and they’ve included
    the specification of the scenario:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的实现例子是.NET BDD框架**SpecFlow**（[https://specflow.org/](https://specflow.org/)）。当你访问他们的网站时，你会看到他们的数据隐私对话框，并且他们包括了场景的规范：
- en: '![](img/Figure_2.1_B19418.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_2.1_B19418.jpg)'
- en: Figure 2.1 - SpecFlow data privacy dialog
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 - SpecFlow数据隐私对话框
- en: SpecFlow embraces Gherkin and provides a compiler that compiles the DSL to runnable
    code, mixing in the necessary code to call for the feature under test.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: SpecFlow采用Gherkin，并提供了一个编译器，该编译器将DSL编译为可运行的代码，并混合了必要的代码来调用测试的功能。
- en: We will be looking at how we can do this at runtime using dynamic code generation
    emitting IL code into the running application in [*Chapter 6*](B19418_06.xhtml#_idTextAnchor098),
    *Dynamic Proxy Generation*, and also how we can leverage .NET Expression to create
    code and how these can be compiled on the fly in [*Chapter 8*](B19418_08.xhtml#_idTextAnchor132),
    *Building and Executing Expressions*. In [*Chapter 16*](B19418_16.xhtml#_idTextAnchor272),
    *Generating Code*, we will be looking at how we can really make this fly by doing
    it at the compiler level.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第6章“动态代码生成：在运行的应用程序中发射IL代码”中探讨如何在运行时实现这一点，以及如何利用.NET表达式创建代码，并在第8章“构建和执行表达式”中探讨这些代码如何即时编译。在第16章“生成代码”中，我们将探讨如何在编译器级别真正实现这一点。
- en: Summary
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You should now have a clearer idea of the different concepts of metaprogramming
    and a better understanding of when to use what. You’ll see health warnings throughout
    the book about being careful about doing too many implicit or magical things that
    the developers might not understand. This balance can be very hard to get right,
    and there is also a certain level of maturity involved for individual developers
    and teams as a whole involved as well.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该对元编程的不同概念有了更清晰的认识，并对何时使用什么有了更好的理解。本书中会多次提醒你，要小心不要做太多开发者可能不理解的内隐或神奇的事情。这种平衡非常难以掌握，而且对于个人开发者以及整个团队来说，也涉及一定程度的成熟度。
- en: The .NET compiler and what it produces give a lot of power to you as a developer.
    Use it wisely.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: .NET编译器和它产生的代码给了你作为开发者很大的权力。明智地使用它。
- en: In order to demystify and demonstrate more day-to-day use of metaprogramming,
    we will look into how Microsoft’s ASP.NET leverages metaprogramming techniques
    in the next chapter. This should give you some security in feeling it is not too
    exotic, and also get a feel for how it can make you more productive and be of
    help.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除神秘感并展示元编程在日常生活中的更多应用，我们将在下一章探讨微软的ASP.NET如何利用元编程技术。这应该能让你感到它并不那么神秘，同时也能让你感受到它如何提高你的工作效率并提供帮助。
