- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Storing and Retrieving Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You now have all the fundamentals to create and navigate pages, layouts, and
    the controls used to populate pages. Congratulations! You are now a .NET MAUI
    programmer.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter begins the intermediate section of the book, in which you will
    see how to store and retrieve data and then create unit tests – both critical
    aspects of writing real-world and, especially, enterprise apps.
  prefs: []
  type: TYPE_NORMAL
- en: Programs interact with data, and most need to store that data after an app closes
    and restore it as needed when the app resumes. In this chapter, we will consider
    two variations on this – long-term persistence of user preferences and long-term
    database storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Storing user preferences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing to a database on your device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with this chapter, you will need Visual Studio. You will also
    install another `NuGet` package, as shown later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for the finished code in this chapter can be found here: [https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/persistence](https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/persistence).
    To follow along, you will need to use the code from the previous chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Storing user preferences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most apps allow a user to set preferences that can be stored on a phone and
    retrieved, typically when the app starts. .NET MAUI provides a service for this,
    easily storing *key/value pairs*, such as theme preferences, the last date used,
    the login name, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '.NET MAUI provides the `IPreferences` interface to help store these preferences.
    With this, and the associated `Preferences` class (both in the `Microsoft.Maui.Storage`
    namespace), you can store string keys and values of any of the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Boolean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Int` (`int32`, `single`, and `int64`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DateTime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persisting DateTime
  prefs: []
  type: TYPE_NORMAL
- en: '`DateTime` values are stored as 64-bit integers and use the `ToBinary` and
    `FromBinary` methods to encode and decode respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a `UserPreferences` page with a short form to gather a user’s preferences.
    We’ll also add `Button`, which will display all the saved preferences and allow
    the user to delete one or all of them.
  prefs: []
  type: TYPE_NORMAL
- en: Name collisions
  prefs: []
  type: TYPE_NORMAL
- en: We have a preferences page, which may cause a problem because we want to use
    the built-in `Preferences` object. To solve this, go to `PreferencesViewModel`
    and rename `List<Preference>` `preferenceList`. There should be no other conflicts.
    The safest way to rename is to use the Visual Studio rename functionality, which
    you can get to by putting your cursor on the name and entering `Control-R R`.
    After you rename, you may have to manually rename `ObservableProperties`, depending
    on the latest update to Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new `UserPreferences` page will gather three preferences from the user,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The user’s display name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preferred theme
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the app can be used on cellular or Wi-Fi only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Light and dark themes
  prefs: []
  type: TYPE_NORMAL
- en: It has become common in apps to offer a user light and dark themes. In .NET
    MAUI, you can offer the user the choice, or if you are ambitious, you can create
    your own themes.
  prefs: []
  type: TYPE_NORMAL
- en: We will gather but not implement a user’s preferences relating to light and
    dark themes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `UserPreferences` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Having gathered the user’s display name, we can go on to ask them which of
    the two mutually exclusive themes they’d like. To do so, we will use `RadioButtonGroup`
    and two `RadioButtons`, initializing `Light` to be selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We now want to ask the user whether the app should only be used when connected
    to Wi-Fi. We can do this with a switch control, where `on` indicates `WiFi only`
    is `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`[1]` Here, we introduce a new control, `RadioButton`. Radio buttons are in
    either implicit or explicit groups. Implicit groups are created by putting all
    the `RadioButtons` into the same container (for example, `VerticalStackLayout`).
    Explicit groups are given `GroupName`, as we see here.'
  prefs: []
  type: TYPE_NORMAL
- en: '`[2]` The user’s choice is recorded by the `SelectedValue` property.'
  prefs: []
  type: TYPE_NORMAL
- en: '`[3]` When defining `RadioButtons`, you can (and should) set exactly one to
    `IsChecked=true`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`[4]` The switch control toggles off and on (`false` and `true`).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to gather the information the user wants to save, let’s
    take a look at the lightweight mechanism provided by .NET MAUI to do so.
  prefs: []
  type: TYPE_NORMAL
- en: UserPreferencesViewModel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you might expect, the first thing we’ll do is create properties for the
    bound controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to handle the `SavePreferences` command. We do this using the
    .NET MAUI `Preferences` object, calling the static `Set` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: .NET MAUI will handle the persistence for us.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the page, let’s set up navigation to get to it.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating to UserPreferences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need a way to get to our new page. A typical place to put this would be
    an `Button` as the last item in `VerticalStackLayout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnPreferences` command simply navigates to our new page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you register the `userpreferences` page in `AppShell` before invoking
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The page isn’t pretty, but it is ready to gather a user’s preferences, as shown
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – The preferences page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.1_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – The preferences page
  prefs: []
  type: TYPE_NORMAL
- en: A user is now able to set their preferences. The next time they start up the
    app, we’ll want to retrieve those preferences and set the app accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the preferences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a user closes the app, the preferences are preserved. The next time we
    return to the preferences page, we should see the preferences restored. We accomplish
    this using the `Get` method on `Preferences.Default`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Get` method takes two parameters, the *key* and *a default value*. We’ll
    put this in the `ViewModel` constructor so that the preferences page is populated
    when it is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that the first argument to `Get` is the key, as defined in the `Set` method
    in the `SavePreferences` method. The second argument is the default value that
    will be provided if the key is not present.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for a key
  prefs: []
  type: TYPE_NORMAL
- en: While you don’t have to check that a key exists before trying to retrieve it,
    there are times when you’ll want to differentiate between the value you get back
    being the default value or the value that is actually stored (for example, is
    `WiFiOnly` `false` because it really is `false`, or because that key doesn’t exist
    and you received the default value?).
  prefs: []
  type: TYPE_NORMAL
- en: 'To manage this, you can use the `ContainsKey` method on `Preferences.Default`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bool knowsWifi =` `Preferences.DefaultContainsKey("WifiOnly");`'
  prefs: []
  type: TYPE_NORMAL
- en: The user can now store their preferences, and in theory, they can be restored.
    Let’s make sure that this is working.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the persistence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To see that this works, navigate to the `UserPreferences` page by way of the
    `UserPreferences` page, you should see that your entered values have been restored.
  prefs: []
  type: TYPE_NORMAL
- en: Clear
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to clear a specific `UserPreference`, use the `Remove` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Preferences.Default.Remove("DisplayName");`'
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove them all, use the `Clear` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Preferences.Default.Clear()`'
  prefs: []
  type: TYPE_NORMAL
- en: The `Preferences` interface is designed to hold simple data in key/value pairs.
    Microsoft warns against storing long strings, as it may negatively affect performance.
    If you need to store more complex or larger data, you’ll want to use a database,
    and the database of choice for many .NET MAUI developers is **SQLite**.
  prefs: []
  type: TYPE_NORMAL
- en: The lightweight persistence mechanism is great for storing relatively short
    strings and other primitives, but if you are going to store substantial data,
    you’ll need a real database.
  prefs: []
  type: TYPE_NORMAL
- en: Storing to a database on your device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a couple of contenders for storing data on your device. The most popular
    is SQLite, which is an open source, small, fast, and highly reliable database.
    It is the most used database in the world and is built into all mobile phones
    and most computers.
  prefs: []
  type: TYPE_NORMAL
- en: Installing SQLite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, install the latest version of the **sqlite-net-pcl** NuGet package,
    as shown in *Figure 8**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Installing sqlite-net-pcl'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.2_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – Installing sqlite-net-pcl
  prefs: []
  type: TYPE_NORMAL
- en: Installing the correct package
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of SQLite packages available on NuGet. The one you want is
    **sqlite-net-pcl** and has the author **SQLite-net**, as shown in *Figure 8**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – The author should be SQLite-net'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.3_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – The author should be SQLite-net
  prefs: []
  type: TYPE_NORMAL
- en: Once `sqlitepclraw.bundle_green` and if it is not automatically installed, manually
    install **SQLitePCLRaw.bundle_green**, as shown in *Figure 8**.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Installing SQLitePCLRaw.bundle_green'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.4_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – Installing SQLitePCLRaw.bundle_green
  prefs: []
  type: TYPE_NORMAL
- en: With the packages installed, you are ready to set up your program to create
    and use an SQLite database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with SQLite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create your database, you’ll need to store the database filename and its
    path among other constant values. To do so, right-click on your project and create
    a `Constants.cs` file. For convenience, I’ll create a `Database` folder and place
    it there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`[1]` Set the name for your database. Feel free to use the name as shown or
    rename it to whatever you like.'
  prefs: []
  type: TYPE_NORMAL
- en: '`[2]` Set the flags for how the file should be managed. Here, we’ve set it
    to read/write mode, to create the database if it doesn’t exist, and finally, to
    enable multithreaded database access.'
  prefs: []
  type: TYPE_NORMAL
- en: '`[3]` Append the database filename we created earlier to the directory name
    for the app.'
  prefs: []
  type: TYPE_NORMAL
- en: With these constants established, we’re ready to create the database. We’ll
    encapsulate that work in a class.
  prefs: []
  type: TYPE_NORMAL
- en: The Database class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is a common pattern to wrap a database access layer in a class, abstracting
    it away and decoupling it from the rest of the app. We’ll put all the query logic
    into this class. This centralization of database concerns will help make our app
    scalable over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class will need an `Init()` method to create the database and our first
    table. To get us started, let’s create a table to hold all our preferences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`[1]` Declare an object of type `SQLiteAsyncConnection` and name it `Database`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`[2]` If it already exists, then return (that is, treat it as a singleton).'
  prefs: []
  type: TYPE_NORMAL
- en: '`[3]` Create `SQliteAsyncConnection`, passing in the path and flags from the
    `constant` class.'
  prefs: []
  type: TYPE_NORMAL
- en: '`[4]` Create our first table, declaring the type of object we’ll store in the
    table (the `Preference` objects).'
  prefs: []
  type: TYPE_NORMAL
- en: We are ready to start using the database, to add and manipulate our table.
  prefs: []
  type: TYPE_NORMAL
- en: CRUD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As is true for virtually all databases, we’ll want to support **Create, Read,
    Update, and Delete** (**CRUD**). For now, let’s just implement the methods to
    create and read records. The method to create is typically combined with the update
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Create/update
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to want to know whether a `Preference` is already in the table so
    that we know, when given a `Preference` record, whether to add it or update it.
    It will need a unique ID. Fortunately, SQLite is very good at providing IDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by opening `Preference.cs` in the `Model` folder and adding an `id` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, return to `ForgetMeNotDemoDatabase.cs` and add the `SavePreference` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`[1]` Our `SavePreference` method takes the type (`Preference`) as an argument
    and returns the number of rows updated (in this case, zero or one).'
  prefs: []
  type: TYPE_NORMAL
- en: '`[2]` Call `Init` on the database each time you take an action.'
  prefs: []
  type: TYPE_NORMAL
- en: '`[3]` Check to see whether the `Preference` object has `Id`. Since `Id` is
    an `int` type, it defaults to zero, so if it is not zero, we need to do an update;
    otherwise, we need to do an insert.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can create (or update) a record, let’s write code to read that data
    out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Read
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll want to be able to get all our preferences back from the database. For
    that, we’ll create a `GetPreferences` method that returns a list of `Preference`
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Soft deletion
  prefs: []
  type: TYPE_NORMAL
- en: When we write our `Delete` method, we probably will want to do a *soft* deletion
    – that is, mark it as deleted rather than actually removing it. For this to work,
    you’ll need to add another property to `Preference`, `Deleted`, and also `int`.
    Our read statement will then take a `where` clause, checking that the `Deleted`
    property is equal to zero.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a database design, you need to decide whether you are going to
    keep the database locally on a device or in the cloud, accessed through your API.
  prefs: []
  type: TYPE_NORMAL
- en: Local or remote?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A design question for this app is whether we want to store our preferences,
    buddies, invitations, and so forth in tables on a device, or instead use a web
    service and database in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: To facilitate a secure interaction when sending and receiving invitations and
    lists of preferences, we’ve decided to move all the database operations to the
    cloud. However, everything in this chapter is not only relevant to `ForgetMeNotDemo`;
    it will be of use to you if you decide to store data locally on a phone or computer.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed two ways of storing data. The simplest and most
    lightweight is to use the preferences facilities of .NET MAUI. This is great if
    all you need is to store primitives and short strings that are targeted at persisting
    a user’s preferences for a program.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to persist more substantial data, you’ll need a database, and by
    far the most popular type for on-device storage is SQLite. We examined the CRUD
    functionality of SQLite and then pointed out the alternative of not storing everything
    on a device but, rather, storing in the cloud and gaining access through a program’s
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the class that handles simple storage of user data in key/value pairs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What two values do we pass to the `Get` method to retrieve the stored value?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which `NuGet` packages do we need to work with SQLite in .NET MAUI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type of object do we use to create a table?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You try it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add the remaining CRUD operations to the `Preference` table (for example, delete
    and get by ID).
  prefs: []
  type: TYPE_NORMAL
