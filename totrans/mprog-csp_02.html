<html><head></head><body>
		<div><h1 id="_idParaDest-27" class="chapter-number"><a id="_idTextAnchor026"/>2</h1>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Metaprogramming Concepts</h1>
			<p>Now that we have a few ideas about how metaprogramming can benefit you, we need to cover the basic concepts.</p>
			<p>When working with metaprogramming, you get metadata for free from the environment it’s running in, and there is the opportunity to explicitly add more. With explicitness, you can enable clarity in your code base, and a level of transparency for the developers writing and reading the code.</p>
			<p>Some parts of your source code will benefit from more explicit metadata rather than having it implicitly and just magically do things that can be hard for developers to reason about why.</p>
			<p>With explicitness also comes the possibility of representing the domain language of your business in code and with increasing expressiveness.</p>
			<p>In this chapter, we will be covering the following topics:</p>
			<ul>
				<li>Implicit – using what is already there</li>
				<li>Explicit – additional adornment of code</li>
				<li>Domain-specific languages</li>
			</ul>
			<p>By the end of the chapter, you should have a good feel for the different metaprogramming concepts you can leverage, when to use which concept, and the benefits of each concept.</p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor028"/>Technical requirements</h1>
			<p>You can find all the source code used in this chapter in the GitHub repository: <a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter2">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter2</a>.</p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/>Implicit – using what is already there</h1>
			<p>The compiler that <a id="_idIndexMarker046"/>compiles <strong class="bo d">C#</strong> parses all our code and ends up creating what<a id="_idIndexMarker047"/> is referred<a id="_idIndexMarker048"/> to as <strong class="bo d">IL-code</strong>, short for <strong class="bo d">Intermediate Language code</strong>. This is standardized and part of the <strong class="bo d">ECMA-335</strong> standard <a id="_idIndexMarker049"/>for the Common Language Infrastructure. You can read more about the standard here: <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-335/">https://www.ecma-international.org/publications-and-standards/standards/ecma-335/</a>. This type of code is not something that the CPU in the system understands and it requires another step for the CPU to understand it. The last step of translation is done when we run our programs<a id="_idIndexMarker050"/> and the <strong class="bo d">.NET runtime</strong> takes over, interprets the IL, and generates the necessary instructions for the CPU type of the computer the program is running on.</p>
			<p>Looking at the binary output, you can’t necessarily tell the difference. But by opening up the binary using a <a id="_idIndexMarker051"/>decompiler tool such as <strong class="bo d">ildasm</strong>, or something more visual, such <a id="_idIndexMarker052"/>as <strong class="bo d">JetBrains dotPeek</strong> (<a href="https://www.jetbrains.com/decompiler/">https://www.jetbrains.com/decompiler/</a>), we can get a glimpse at what our programs look like.</p>
			<p>Take, for instance, the following program:</p>
			<pre class="source-code">
using System;
public class Program
{
    public static void Main()
    {
        Console.WriteLine("Hello world!");
    }
}</pre>
			<p>Compiling this will <a id="_idIndexMarker053"/>produce a <strong class="bo d">Dynamic Link Library</strong> (<strong class="bo d">DLL</strong>) file, and on opening the file with a decompiler, we would see something like this:</p>
			<pre class="source-code">
.class private auto ansi '&lt;Module&gt;'
{
}
.class public auto ansi beforefieldinit Program
    extends [System.Runtime]System.Object
{
    .method public hidebysig static
        void Main () cil managed
    {        .maxstack 8
        IL_0000: ldstr "Hello world!"
        IL_0005: call void [System.Console]System.
            Console::WriteLine(string)
        IL_000a: ret
    }
    .method public hidebysig specialname rtspecialname
        instance void .ctor () cil managed
    {
        .maxstack 8
        IL_0000: ldarg.0
        IL_0001: call instance void [System.Runtime]System.
            Object::.ctor()
        IL_0006: ret
    }
}</pre>
			<p>On an x86/AMD64-based <a id="_idIndexMarker054"/>CPU, this then gets translated into something like the following disassembled code:</p>
			<pre class="conso e">L0000: mov rcx, 0x2217fb34a50</pre>
			<pre class="conso e">L000a: mov rcx, [rcx]</pre>
			<pre class="conso e">L000d: jmp 0x00007ffef72f2fc8</pre>
			<p>The actual <strong class="source-in ine">Hello world!</strong> string is then placed in memory at the location used by the first <strong class="source-in ine">mov</strong> instruction. If you’re interested in trying out code and seeing how it translates yourself, I recommend heading over to <a href="https://sharplab.io">https://sharplab.io</a>.</p>
			<p>In the finished compiled result, there is actually no metadata whatsoever, making it impossible to reason about our code in any meaningful way.</p>
			<p>While the IL contains everything we wrote, all the type information is intact (type names, method <a id="_idIndexMarker055"/>names, and so forth).</p>
			<p>With that, we are being set up for success to do some proper metapro<a id="_idTextAnchor030"/>gramming.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor031"/>Leveraging the power of reflection</h2>
			<p>All this <a id="_idIndexMarker056"/>information is available to us, and it all starts with the powerful, and my personal favorite, namespace called <strong class="source-in ine">System.Reflection</strong>. This holds all the C# types representing the different code elements we write. Since C# is a managed language running on top of the managed runtime, we get all the details about all the code we write.</p>
			<p>Since every type we have created and will create is inherent of the <strong class="source-in ine">Object</strong> type, every derived type inherently gets its methods and properties. One of these methods is called <strong class="source-in ine">GetType()</strong>. This method returns an instance of the type of the object in the form of <strong class="source-in ine">Type</strong>. It holds all the details about the particular type – everything from what namespace it resides in, to fields, properties, methods on it, and much more. For the type, we can even look at what it is inheriting and what interfaces it might implement. We can even see which assembly (DLL) it is defined in.</p>
			<p>If you look <a id="_idIndexMarker057"/>at <a id="_idIndexMarker058"/>object-relational mappers <a id="_idIndexMarker059"/>such as <strong class="bo d">Microsoft’s Entity Framework</strong>, <strong class="bo d">Dapper</strong>, <strong class="bo d">NHibernate</strong>, or <a id="_idIndexMarker060"/>even the <strong class="bo d">MongoDB C# Driver</strong>, they all use reflection to reason about the types you have to translate into something expected by the underlying data store. For a relational store, it would typically translate into the correct <strong class="bo d">SQL</strong> statements, while <a id="_idIndexMarker061"/>for <a id="_idIndexMarker062"/>MongoDB, it would be the correct MongoDB <strong class="bo d">Binary JSON</strong> (<strong class="bo d">BSON</strong>) objects.</p>
			<p>The same is done by things that serialize from .NET types to other formats, such as JSON. Libraries such as <strong class="source-in ine">Newtonsoft.JSON</strong> or the built-in <strong class="source-in ine">System.Text.Json</strong> namespace leverages reflection to know what to translate.</p>
			<p>Let’s say you have a <strong class="source-in ine">Person</strong> type:</p>
			<pre class="source-code">
public class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public string SocialSecurityNumber { get; set; }
}</pre>
			<p>An extremely<a id="_idIndexMarker063"/> simplistic conversion to JSON could easily be done:</p>
			<pre class="source-code">
public string SerializeToJson(object instance)
{
    var stringBuilder = new StringBuilder();
    var type = instance.GetType();
    var properties = type.GetProperties();
    Var first = true;
    stringBuilder.Append("{\n");
    foreach( var property in properties )
    {
        if (!first)
        {
            StringBuilder.Append(",\n");
        }
        stringBuilder.Append($"   \"{property.Name}\":
          \"{property.GetValue(instance)}\"");
    }
    stringBuilder.Append("\n}");
}</pre>
			<p>This can then be used as follows:</p>
			<pre class="source-code">
var person = new Person
{
   FirstName = "Jane",
   LastName = "Doe",
   SocialSecurityNumber = "12345abcd"
};
Console.WriteLine(Serializer.SerializeToJson(person));</pre>
			<p>The output of running this would yield some nice JSON:</p>
			<pre class="source-code">
{
   "FirstName": "Jane",
   "LastName": "Doe",
   "SocialSecurityNumber": "12345abcd"
}</pre>
			<p>The code <a id="_idIndexMarker064"/>basically gets the type information from the instance and gets the properties on it. It outputs a string containing the property name and leverages <strong class="source-in ine">PropertyInfo</strong> to get a value from the instance and just outputs its <strong class="source-in ine">.</strong><strong class="source-in ine">ToString()</strong> representation.</p>
			<p>Obviously, this sample is very simple and non-recursive for complex types or support arrays and doesn’t recognize well-known JSON primitive types. But this proves how easily you can get to the information.</p>
			<p>Implicit metadata and the type system of .NET can be very powerful. The further down the rabbit hole you go with reflection, the more you’ll probably feel like going further and doing more. The flip side of that is for everything you do automatically, you lose the transparency of what’s going on. It needs to be balanced and be as close to the element of least surprise as possible.</p>
			<p>For some things, you’re better off going with being very explicit. There is also metadata that can’t be <a id="_idIndexMarker065"/>discovered with what the compiler generates, and the only way to go is t<a id="_idTextAnchor032"/>o be very explicit.</p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor033"/>Explicit – additional adornment of code</h1>
			<p>Pretty much all code<a id="_idIndexMarker066"/> elements can have additional information <a id="_idIndexMarker067"/>added to them. These are called <strong class="bo d">attributes</strong>. Attributes are a powerful method of associating metadata with the element. Within the .NET framework itself, you’ll see quite a few of these attribute types that can be used.</p>
			<p>In the <strong class="source-in ine">System.ComponentModel.DataAnnotations</strong> namespace, you can find some great examples of attributes that add metadata used by the runtime. Here, you’ll find attributes used for adding validation metadata. ASP.NET picks up the usage of these attributes and checks objects being sent to controller actions for validity according to the rules applied. As we saw briefly in <a href="B19418_01.xhtml#_idTextAnchor015"><em class="ita ic">Chapter 1</em></a>, <em class="ita ic">How Can Metaprogramming Benefit You?</em>, with our <strong class="source-in ine">RegisterPerson</strong> type, we could instruct properties that should be required. It contains much more, for instance, <strong class="source-in ine">[StringLength]</strong> and <strong class="source-in ine">[Range]</strong>. These are great examples of metadata recognized by the framework and components that support them.</p>
			<p>Some attributes in the framework are recognized by the compiler and will direct the compiler to perform certain things. For instance, the <strong class="source-in ine">[Flags]</strong> attribute can be added to enums that instruct it to require every value to represent a bit field:</p>
			<pre class="source-code">
[Flags]
public enum MyEnum
{
    Flag1 = 1,
    Flag2 = 1 &lt;&lt; 1,
    Flag3 = 1 &lt;&lt; 2,
    Flag4 = 1 &lt;&lt; 3
}</pre>
			<p>With this type of enum, we define flags, with each flag being a left bitwise shift for the number of places to move to represent the correct bit. You can also do this by giving the actual decimal or hexadecimal number of the bit (<strong class="source-in ine">1</strong>, <strong class="source-in ine">2</strong>, <strong class="source-in ine">4</strong>, or <strong class="source-in ine">8</strong>, or <strong class="source-in ine">0x1</strong>, <strong class="source-in ine">0x2</strong>, <strong class="source-in ine">0x4</strong>, <strong class="source-in ine">0x8</strong>, <strong class="source-in ine">0x10</strong>, and so on).</p>
			<p>The <strong class="source-in ine">System.Text.Json</strong> serializer also makes use of metadata. It uses metadata to know how to serialize or deserialize what it is given. For instance, it can ignore properties in an object:</p>
			<pre class="source-code">
public class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
    [JsonIgnore]
    public string FullName =&gt; $"{FirstName} {LastName}";
    public string SocialSecurityNumber { get; set; }
}</pre>
			<p>Serializing<a id="_idIndexMarker068"/> an<a id="_idIndexMarker069"/> instance of this wo<a id="_idTextAnchor034"/>uld leave out <strong class="source-in ine">FullName</strong>.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor035"/>Creating custom attributes</h2>
			<p>You can easily create<a id="_idIndexMarker070"/> your own custom attributes by adding the metadata you want for your code. All attributes can take arguments with the extra metadata you want to have associated with them. This gives you the opportunity to be very specific on what data you want to associate as metadata with the code element being adorned.</p>
			<p>All of the metadata added to an attribute needs to be resolvable by the compiler at compile time. That limits us to only have things that are typical primitive types and constant in nature. You can’t dynamically create instances of things to pass into an attribute.</p>
			<p>An example of an attribute could, for instance, be for describing types or properties that hold <strong class="bo d">personal identifiable information</strong> (<strong class="bo d">PII</strong>). This can be very useful to be able to later reason<a id="_idIndexMarker071"/> about your code, to know what PII is being collected about users, which can be presented to the user themselves. With the European Union privacy law<a id="_idIndexMarker072"/> called <strong class="bo d">GDPR</strong>, it could also be used as a reporting mechanism if your company is audited or have a GDPR-related incident and need to report it to the authorities.</p>
			<p>A huge benefit, once you have tagged types and properties with this metadata, is that you get an opportunity for future use cases – for example, the encryption of PII data or anything else.</p>
			<p>Creating a custom attribute is in its basic form as follows:</p>
			<pre class="source-code">
public class PersonalIdentifiableInformationAttribute :
Attribute
{
}</pre>
			<p>The <strong class="source-in ine">PersonalIdentifiableInformationAttribute</strong> type needs to inherit the base <strong class="source-in ine">Attribute</strong> type. The<a id="_idIndexMarker073"/> compiler also expects the type you create to be suffixed with <strong class="source-in ine">Attribute</strong> as part of the name. However, when using your custom attribute, you can then leave out <strong class="source-in ine">Attribute</strong> in the name, the compiler will map this to the full name with the suffix added to it.</p>
			<p>The next thing you need to specify is actually a bit of metadata for the compiler. This is done using the <strong class="source-in ine">[AttributeUsage]</strong> attribute. With this, we need to specify what target code elements are supported, and we can support multiple by <em class="ita ic">ORing</em> (the <strong class="source-in ine">OR</strong> operation) them together.</p>
			<p>For <strong class="source-in ine">PersonalIdentifiableInformationAttribute</strong>, we’d typically want this for classes, properties, and fields:</p>
			<pre class="source-code">
[AttributeUsage(AttributeTargets.Class | AttributeTargets.
Property | AttributeTargets.Parameter, AllowMultiple = false)]
public sealed class PersonalIdentifiableInformationAttribute :
Attribute
{
}</pre>
			<p>In addition, we specify that we don’t want to allow multiple copies of the same attribute. A good practice is to have your attributes be very specific and not create any inheritance chains of attributes. This will make your attribute a <strong class="source-in ine">sealed</strong> type not allow inheritance from a C# perspective.</p>
			<p>One of the things that GDPR mentions is to record the collection purpose. So, to add to this, we could include the purpose as optional metadata. You can do this by adding a constructor that takes the metadata as an argument, and if you want it to be optional, you can give it a<a id="_idIndexMarker074"/> default value:</p>
			<pre class="source-code">
[AttributeUsage(AttributeTargets.Class | AttributeTargets.
Property | AttributeTargets.Parameter, AllowMultiple = false)]
public sealed class PersonalIdentifiableInformationAttribute :
Attribute
{
    public PersonalIdentifiableInformationAttribute(string
      purpose = "")
    {
        Purpose = purpose;
    }
    public string Purpose { get; }
}</pre>
			<p>As you can see, in addition to adding the constructor with the argument for the metadata, you need to add the <strong class="source-in ine">Purpose</strong> property that exposes the metadata.</p>
			<p>With this, we can start applying the <strong class="source-in ine">PersonalIdentifiableInformation</strong> attribute to properties on something, such as a <strong class="source-in ine">Person</strong> object:</p>
			<pre class="source-code">
public class Person
{
    [PersonalIdentifiableInformation("First name of person")]
    public string FirstName { get; set; }
    [PersonalIdentifiableInformation("Last name of person")]
    public string LastName { get; set; }
    [PersonalIdentifiableInformation("Unique identifier for
      person")]
    public string SocialSecurityNumber { get; set; }
}</pre>
			<p>We will go into more depth on how we can leverage this further in <a href="B19418_05.xhtml#_idTextAnchor083"><em class="ita ic">Chapter 5</em></a>, <em class="ita ic">Leveraging Attributes</em>.</p>
			<p>We’ve discussed how we can reason about our code through implicit structures and also how we can add explicit additional metadata and even our own custom data. What about going the other way? By this, we mean going from something and basically generating code.</p>
			<p>As we talked about previously, the programming language itself is basically a higher-level metadata language designed to be able to express code more efficiently.</p>
			<p>With that<a id="_idIndexMarker075"/> mindset, there is really nothing stopping us from inventing our own language and leveraging the infrastruct<a id="_idTextAnchor036"/>ure to generate running code.</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor037"/>Domain-specific languages</h1>
			<p>The concept of <a id="_idIndexMarker076"/>creating your own <strong class="bo d">domain-specific language</strong> (<strong class="bo d">DSL</strong>) is nothing new and has been done for years by companies. This can be a very efficient way to include your domain experts in the mix and provide a way for them to contribute code in a language that is more familiar to them. The code they write is typically then on a much higher level and has a vocabulary that is supported by lower-level code constructs, which are actually doing the heavy lifting.</p>
			<p>Think of this as a programming language and a compiler for your business, expressing your business problems.</p>
			<p>It could also be used for technical aspects and not just for the business side – for instance, if you have complex state machines or workflows that have their own vocabulary and you want to make it into a language that is easier to reason about. You could also imagine that the language is represented in a well-known file format such as JSON, YAML, or even Excel.</p>
			<p>The purpose of going to the length of generating the code for this higher-level representation is that you get an opportunity to make the end result more optimal, and you can make decisions to optimize the flow before it hits the runtime. You also get a snappier startup of your application, as it doesn’t have to parse things at startup and hand it over to an<a id="_idIndexMarker077"/> engine that runs it. It will ultimately just be code running, just as a<a id="_idTextAnchor038"/>ny other code in your solution.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor039"/>Gherkin – technical sample</h2>
			<p>If you’re familiar<a id="_idIndexMarker078"/> with writing unit tests, the typical <a id="_idIndexMarker079"/>structure is <strong class="bo d">arrange</strong>, <strong class="bo d">act</strong>, and then <strong class="bo d">assert</strong>. A test would look something like this:</p>
			<pre class="source-code">
public class CalculatorTests
{
    [Fact]
    public void Add()
    {
        // Arrange
        var left = 5;
        var right = 3;
        var expectedResult = 8;
        // Act
        var actualResult = Calculator.Add(left, right);
        Assert.Equal(expectedResult, actualResult, 0);
    }
}</pre>
			<p>This code tests a calculator to verify that its add functionality works as expected. It does this by setting up the inputs and expected results, then calling into the calculator, and finally, verifying the result by using assertions that claim the result should be the same as the expected result.</p>
			<p>While this is the <a id="_idIndexMarker080"/>more traditional <strong class="bo d">test-driven development</strong> (<strong class="bo d">TDD</strong>) style, there is something called <strong class="bo d">behavior-driven design</strong> (<strong class="bo d">BDD</strong>). This<a id="_idIndexMarker081"/> approach focuses much more on the behavior of a system and interactions between parts of your system rather than its state. For expressing this interaction, a DSL was created<a id="_idIndexMarker082"/> called <strong class="bo d">Gherkin</strong>. It is somewhat similar in its basic form with <em class="ita ic">given</em>, <em class="ita ic">when</em>, and <em class="ita ic">then</em>, which maps pretty much to the same as TDD’s <em class="ita ic">arrange</em>, <em class="ita ic">act</em>, and <em class="ita ic">assert</em>. In addition, it has the concepts of features, scenarios, and steps. The goal is to write concrete functional requirements for a system.</p>
			<p>For higher-order<a id="_idIndexMarker083"/> functionality, it is hard for domain experts to reason about C# code to <a id="_idIndexMarker084"/>verify whether we’re testing the right thing or delivering what is expected.</p>
			<p>With the correct tool, we can start articulating the functionality of a system in plain English and let it be hooked up to code snippets that perform the actual code we need to test or specify.</p>
			<p>A great example of an implementation of this is the .NET BDD framework called <strong class="bo d">SpecFlow</strong> (<a href="https://specflow.org/">https://specflow.org/</a>). When <a id="_idIndexMarker085"/>navigating to their site, you’re presented with their data privacy dialog, and they’ve included the specification of the scenario:</p>
			<div><div><img src="img/Figure_2.1_B19418.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 - SpecFlow data privacy dialog</p>
			<p>SpecFlow embraces Gherkin and provides a compiler that compiles the DSL to runnable code, mixing in the necessary code to call for the feature under test.</p>
			<p>We will be looking at how we can do this at runtime using dynamic code generation emitting IL code into the running application in <a href="B19418_06.xhtml#_idTextAnchor098"><em class="ita ic">Chapter 6</em></a>, <em class="ita ic">Dynamic Proxy Generation</em>, and also how we can leverage .NET Expression to create code and how these can be compiled on the fly in <a href="B19418_08.xhtml#_idTextAnchor132"><em class="ita ic">Chapter 8</em></a>, <em class="ita ic">Building and Executing Expressions</em>. In <a href="B19418_16.xhtml#_idTextAnchor272"><em class="ita ic">Chapter 16</em></a>, <em class="ita ic">Generating Code</em>, we<a id="_idIndexMarker086"/> will be looking at how we can <a id="_idIndexMarker087"/>really make this fly by doing it at the compiler level.</p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor040"/>Summary</h1>
			<p>You should now have a clearer idea of the different concepts of metaprogramming and a better understanding of when to use what. You’ll see health warnings throughout the book about being careful about doing too many implicit or magical things that the developers might not understand. This balance can be very hard to get right, and there is also a certain level of maturity involved for individual developers and teams as a whole involved as well.</p>
			<p>The .NET compiler and what it produces give a lot of power to you as a developer. Use it wisely.</p>
			<p>In order to demystify and demonstrate more day-to-day use of metaprogramming, we will look into how Microsoft’s ASP.NET leverages metaprogramming techniques in the next chapter. This should give you some security in feeling it is not too exotic, and also get a feel for how it can make you more productive and be of help.</p>
		</div>
	</body></html>