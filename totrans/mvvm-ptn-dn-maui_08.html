<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer061">
<h1 class="chapter-number" id="_idParaDest-130"><a id="_idTextAnchor132"/>8</h1>
<h1 id="_idParaDest-131"><a id="_idTextAnchor133"/>Navigation in MVVM</h1>
<p>So far in our journey of building the <em class="italic">Recipes!</em> app, we have laid a robust foundation using the MVVM design pattern. Now, there’s one important part missing: navigation – that is, moving between different pages of the app. This chapter will focus on the practical side of navigation within .NET MAUI. We’ll break down our discussion into four <span class="No-Break">key areas:</span></p>
<ul>
<li>About .NET <span class="No-Break">MAUI Shell</span></li>
<li>Setting up navigation in a .NET MAUI <span class="No-Break">Shell app</span></li>
<li>Setting up navigation without .NET <span class="No-Break">MAUI Shell</span></li>
<li>Passing <span class="No-Break">results back</span></li>
</ul>
<p>MVVM largely focuses on the separation of concerns, decoupling the logic from the presentation layer. When we integrate navigation within the MVVM architecture, we’re essentially extending the principle of “separation of concerns” to the navigation logic. To implement this effectively, it’s essential to grasp key principles <span class="No-Break">of navigation.</span></p>
<p>By the end of this chapter, you’ll have a solid grasp of .NET MAUI’s navigation capabilities. Whether you opt to utilize .NET MAUI Shell or stick with traditional navigation methods, you’ll be equipped to make your app’s navigation seamless and user-friendly. It’s time to <span class="No-Break">dive in!</span></p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor134"/>Technical requirements</h1>
<p>We will continue to add functionality to the <em class="italic">Recipes!</em> app throughout this chapter. As always, everything can be found on GitHub at <a href="https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter08">https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter08</a>. You can start from the code provided in the <strong class="source-inline">Start</strong> folder to follow along with this chapter. The <strong class="source-inline">Finish</strong> folder contains the completed code, which you can consult <span class="No-Break">for reference.</span></p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor135"/>About .NET MAUI Shell</h1>
<p>.NET MAUI Shell is <a id="_idIndexMarker541"/>an opinionated way to create the structure of a .NET MAUI app. It introduces a more simplified approach to building mobile applications, which can be quite complex when it comes to structuring and navigation. Shell streamlines these aspects by providing a unified, declarative syntax for expressing the structure and navigation pattern of <span class="No-Break">an application.</span></p>
<p>Being opinionated, .NET MAUI Shell has specific guidelines and conventions it expects developers to follow, with the benefit of reducing boilerplate code and effort. It brings a variety of features to the table, aiming to reduce the complexity of mobile <span class="No-Break">application development:</span></p>
<ul>
<li><strong class="bold">URI-based navigation</strong>: Shell supports a URI-based navigation scheme, similar to web development <a id="_idIndexMarker542"/>models. Developers can define a <strong class="bold">route</strong> to a particular page. These routes allow for easy and loosely coupled navigation around the app, making the navigation code more straightforward and <span class="No-Break">less error-prone.</span></li>
<li><strong class="bold">Simplifying complex app structures</strong>: Shell offers out-of-the-box support for common UI elements such as flyout menus, tabs, and navigation bars, and all of them combined. Developers can easily add these structures to their apps and have Shell manage the rendering on <span class="No-Break">different platforms.</span></li>
<li><strong class="bold">Performance</strong>: Shell also aims to improve performance by handling the life cycle of its components more efficiently, offering faster <span class="No-Break">rendering times.</span></li>
</ul>
<p>However, the opinionated nature of Shell means it might not be suitable for every application scenario or developer. It provides a predefined structure and expects developers to adhere to it, which can be beneficial for simpler apps but might limit flexibility for more <span class="No-Break">complex scenarios.</span></p>
<p class="callout-heading">.NET MAUI Shell</p>
<p class="callout">.NET MAUI Shell is a powerful tool in any mobile developer’s toolbox. It provides a high level of abstraction to simplify app development, but developers should evaluate whether its opinionated approach aligns with their project requirements <span class="No-Break">and constraints.</span></p>
<p>Let’s have a <a id="_idIndexMarker543"/>look at how to leverage Shell in a .NET <span class="No-Break">MAUI app.</span></p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor136"/>Setting up Shell</h2>
<p>By default, when<a id="_idIndexMarker544"/> creating a new .NET MAUI app, <strong class="source-inline">Shell</strong> is already wired up automatically. An <strong class="source-inline">AppShell</strong> class, which inherits from <strong class="source-inline">Microsoft.Maui.Controls.Shell</strong>, is generated and an instance of this <strong class="source-inline">AppShell</strong> class is assigned to the <strong class="source-inline">MainPage</strong> property of the <span class="No-Break"><strong class="source-inline">App</strong></span><span class="No-Break"> class:</span></p>
<pre class="source-code">
public App()
{
    InitializeComponent();
    <strong class="bold">MainPage = new AppShell();</strong>
}</pre> <p>The value of the <strong class="source-inline">MainPage</strong> property specifies the first page that will be displayed when the application is launched. In other words, it’s the entry point into your application’s UI. This can be a single content page, a navigation page, a tabbed page, or even a master-detail page. Or, as shown here, when leveraging <strong class="source-inline">Shell</strong>, it can also be a <strong class="source-inline">Shell</strong> object. <strong class="source-inline">Shell</strong> acts as a container for your application’s structure and navigation, defining the initial layout and flow of <span class="No-Break">your application.</span></p>
<p>Though <strong class="source-inline">MainPage</strong> is the initial page that’s displayed, it is technically possible to change it at any point in the app’s life cycle to accommodate the needs of your application. For instance, you may initially set <strong class="source-inline">MainPage</strong> to <strong class="source-inline">LoginPage</strong>, and once the user successfully logs in, you could then change <strong class="source-inline">MainPage</strong> to <span class="No-Break">your </span><span class="No-Break"><strong class="source-inline">AppShell</strong></span><span class="No-Break">.</span></p>
<p>Within the <strong class="source-inline">AppShell</strong> class, you define the major structural elements of your application. For instance, if your app includes a flyout menu and several tabbed pages, you can define these elements in your <strong class="source-inline">AppShell</strong>. Here’s a basic example of what that might <span class="No-Break">look like:</span></p>
<pre class="source-code">
&lt;Shell.FlyoutHeader&gt;
    ...
&lt;/Shell.FlyoutHeader&gt;
&lt;FlyoutItem Title="Quotes" Icon="badge.png"&gt;
    &lt;Tab Title="MVVM"&gt;
        &lt;ShellContent
            Title="Quote of the Day"
            ContentTemplate="{DataTemplate
              local:MainPage_MVVM}"
            Icon="badge.png" /&gt;
    &lt;/Tab&gt;
    &lt;Tab Title="Not MVVM"&gt;
        &lt;ShellContent
            Title="Quote of the Day"
            ContentTemplate="{DataTemplate local:MainPage}"
            Icon="badge.png" /&gt;
    &lt;/Tab&gt;
&lt;/FlyoutItem&gt;
&lt;FlyoutItem Title="Settings" Icon="settings.png"&gt;
    &lt;ShellContent Title="Settings"
                  ContentTemplate="{DataTemplate
                    local:SettingsPage}" /&gt;
&lt;/FlyoutItem&gt;</pre> <p>The code shown<a id="_idIndexMarker545"/> here will render a shell containing a flyout menu with two items: <strong class="bold">Quotes</strong> and <strong class="bold">Settings</strong>, both accompanied by a relevant icon. Each <strong class="source-inline">FlyoutItem</strong> represents a distinct section of the app. The <strong class="source-inline">Quotes</strong> section is defined to contain two tabs, each with its title. The content of each tab is defined by a <strong class="source-inline">ShellContent</strong> object that references the page to be displayed when the tab is selected. The <strong class="source-inline">Settings</strong> section only contains a <strong class="source-inline">ShellContent</strong> item, which refers to <strong class="source-inline">SettingsPage</strong>. Without .NET MAUI Shell, creating a complex layout with a flyout menu, tabs, and separate sections, while managing the navigation between them, could be quite complex and require a lot of boilerplate code. But with Shell, you can define this structure in a simple, declarative way right in your <strong class="source-inline">AppShell</strong>, making it easier to manage and update. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.1</em> shows what the layout shown here, defined in XAML using Shell, <span class="No-Break">looks like:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer059">
<img alt="Figure 8.1: Flyout items and tabs when using Shell" height="942" src="image/B20941_08_01.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1: Flyout items and tabs when using Shell</p>
<p>Not only does <a id="_idIndexMarker546"/>Shell allow us to define the main structure of our app, but it also gives us the ability to define routes. Let’s have a look <span class="No-Break">at that.</span></p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor137"/>Routing</h2>
<p>.NET MAUI Shell’s <a id="_idIndexMarker547"/>routing system is based on the concept of named routes, which are essentially unique identifiers, or routes, for pages within your application. This simplifies the process of navigating among pages and introduces a way to loosely couple your navigation logic from your page types. Rather than directly referencing page types, you navigate to registered routes. This enables a level of abstraction as you’re navigating to “a page” registered with a specific name, not directly to a specific page. This allows your concrete page associated with a particular route to be changed without requiring changes in your <span class="No-Break">navigation logic.</span></p>
<p>We can register a route using the <strong class="source-inline">RegisterRoute</strong> method on the static <strong class="source-inline">Microsoft.Maui.Controls.Routing</strong> class. Often, routes are registered in the <strong class="source-inline">AppShell</strong> class’s constructor, but it can be done anywhere in the app, so long as it happens early on in the application’s life cycle. So, the <strong class="source-inline">CreateMauiApp</strong> method in the <strong class="source-inline">MauiProgram</strong> class is also a good candidate. In the <em class="italic">Quote Of The Day</em> app, the registration of routes is done in the latter. Whatever location you choose to register your app’s routes, here’s how <span class="No-Break">it’s done:</span></p>
<pre class="source-code">
Routing.RegisterRoute("about", typeof(AboutPage));</pre> <p>Once registered, you can navigate to the route <span class="No-Break">like so:</span></p>
<pre class="source-code">
await Shell.Current.GoToAsync("about");</pre> <p>In addition, Shell supports both absolute and relative navigation. An absolute URI, starting with a slash (<strong class="source-inline">/</strong>), resets the navigation stack before navigation, whereas a relative URI, not starting with a slash, pushes the navigation operation onto the navigation stack. For clarity, the navigation stack is essentially a history of pages the user has navigated through, allowing for forward and backward navigation in <span class="No-Break">the app.</span></p>
<p>This named-route-based navigation also supports passing parameters <span class="No-Break">between pages:</span></p>
<pre class="source-code">
await Shell.Current.GoToAsync("about<strong class="bold">?foo=bar</strong>");</pre> <p>I’m not a big fan of<a id="_idIndexMarker548"/> using query string parameters for navigation, as shown here. Instead, I prefer the following approach, which allows us to pass parameters in a dictionary of type <span class="No-Break"><strong class="source-inline">IDictionary&lt;string, object&gt;</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
await Shell.Current.GoToAsync("about",
    <strong class="bold">new Dictionary&lt;string, object&gt;()</strong>
<strong class="bold">    {</strong>
<strong class="bold">        {"foo", "bar" }</strong>
<strong class="bold">    }</strong>);</pre> <p>The reason I prefer this approach is the fact that this allows for passing complex objects, whereas the query string approach only allows for primitive types. And because I like consistency, I prefer to always use <span class="No-Break">the dictionary.</span></p>
<p>These parameters, which we pass from one page to another, can be retrieved in different ways. One of them is to let the target page inherit the <strong class="source-inline">Microsoft.Maui.Controls.IQueryAttributable</strong> interface. As shown here, this interface defines just one method, <strong class="source-inline">ApplyQueryAttributes</strong>, that needs to <span class="No-Break">be implemented:</span></p>
<pre class="source-code">
public partial class AboutPage : ContentPage,
  <strong class="bold">IQueryAttributable</strong>
{
...
    <strong class="bold">public void ApplyQueryAttributes(</strong>
<strong class="bold">    IDictionary&lt;string, object&gt; query)</strong>
    {
        lblParameter.Text = $"Parameter {query
          .First().Key}: {query.First().Value}";
    }
}</pre> <p>Moreover, if an instance of a class that implements the <strong class="source-inline">IQueryAttributable</strong> interface is assigned<a id="_idIndexMarker549"/> as the target page’s <strong class="source-inline">BindingContext</strong> (such as a ViewModel), that <strong class="source-inline">ApplyQueryAttributes</strong> method would also <span class="No-Break">be invoked.</span></p>
<p class="callout-heading">Adhering to MVVM best practices</p>
<p class="callout">I’ve often seen ViewModels inheriting the <strong class="source-inline">IQueryAttributable</strong> interface to receive navigation parameters. Although that works perfectly well, it goes against one of MVVM’s best practices, which says that ViewModels should be framework agnostic. This interface is .NET MAUI and Shell-specific, so it requires a dependency on these frameworks. Later in this chapter, I’ll show you how to not rely on the <strong class="source-inline">IQueryAttributable</strong> interface and still be able to receive <span class="No-Break">navigation parameters.</span></p>
<p>As we mentioned previously, there are also other ways to receive parameters on the navigation target. I’m not going to dive deeper into that as we won’t be relying on that when we implement navigation <span class="No-Break">in MVVM.</span></p>
<p>Let’s have a look at <a id="_idIndexMarker550"/>one final aspect I want to highlight about Shell before we go further: Shell’s support <span class="No-Break">for DI.</span></p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor138"/>Supporting Dependency Injection</h2>
<p>In the previous<a id="_idIndexMarker551"/> chapter, we discussed DI<a id="_idIndexMarker552"/> and briefly touched on the fact that Shell allows pages to be resolved dynamically. This allowed us to define the ViewModel as a dependency of a page, which gets injected through the page’s constructor, as <span class="No-Break">shown here:</span></p>
<pre class="source-code">
public AboutPage(<strong class="bold">AboutPageViewModel vm</strong>)
{
    InitializeComponent();
    BindingContext = vm;
}</pre> <p>The only caveat here is that the page itself needs to be registered in the <strong class="source-inline">IServiceCollection</strong>, alongside its dependencies of course. With the following in place, we can navigate to <strong class="source-inline">"about"</strong> and Shell will resolve <strong class="source-inline">AboutPage</strong> and its dependencies – in this case, <strong class="source-inline">AboutPageViewModel</strong> – and <span class="No-Break">inject them:</span></p>
<pre class="source-code">
Routing.RegisterRoute("about", typeof(AboutPage));
builder.Services.AddTransient&lt;AboutPage&gt;();
builder.Services.AddTransient&lt;AboutPageViewModel&gt;();</pre> <p>There is even a convenient extension method in the .NET MAUI Community Toolkit that does all of this at once. Take <span class="No-Break">a look:</span></p>
<pre class="source-code">
builder.Services.AddTransientWithShellRoute&lt;AboutPage,
  AboutPageViewModel&gt;("about");</pre> <p>The same method also exists for adding the types as scoped or singleton, <span class="No-Break">of course.</span></p>
<p>In this section, we merely scratched the surface of .NET MAUI Shell, exploring its routing system and support for DI. We saw how it provides a robust, flexible, and intuitive approach to structuring your application and <span class="No-Break">managing navigation.</span></p>
<p>However, remember that .NET MAUI Shell has a lot more to offer, including advanced features such as flyout customization, search handling, and life cycle events, among others. For deeper insights into these aspects of .NET MAUI Shell, be sure to visit the <em class="italic">Further reading</em> section at the end of <span class="No-Break">this chapter.</span></p>
<p>Now that we’ve established a solid understanding of .NET MAUI Shell, it’s time to see how we can leverage it within MVVM. In the next section, we’ll focus on setting up navigation in <a id="_idIndexMarker553"/>our <em class="italic">Recipes!</em> app while<a id="_idIndexMarker554"/> adhering to the MVVM pattern. So, let’s dive <span class="No-Break">right in!</span></p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor139"/>Setting up navigation in a .NET MAUI Shell app</h1>
<p>Effective navigation <a id="_idIndexMarker555"/>within the MVVM pattern begins with an integral component: a <strong class="source-inline">NavigationService</strong>. This service is the driving force behind MVVM navigation. In essence, a <strong class="source-inline">NavigationService</strong> is a class that implements an <strong class="source-inline">INavigationService</strong> interface. The <strong class="source-inline">INavigationService</strong> interface provides the contract for navigating between pages, defining the various methods needed for such operations. These methods could include operations such as <strong class="source-inline">GoToDetailPage()</strong>, <strong class="source-inline">GoBack()</strong>, and others, depending on your <span class="No-Break">specific requirements.</span></p>
<p>Here’s the beauty of this setup: during the app’s startup, we register a framework-specific implementation of the <strong class="source-inline">INavigationService</strong> interface with the DI container. It’s a perfect illustration of the power of DI, where we program to an interface, not an implementation. This allows our ViewModels to be completely platform-agnostic. This not only promotes code flexibility and testability but also allows us to replace or modify our <strong class="source-inline">NavigationService</strong> implementation without affecting the rest of <span class="No-Break">our app.</span></p>
<p>Before we dive deeper into the setup of an <strong class="source-inline">INavigationService</strong> and explore how it operates within our <em class="italic">Recipes!</em> app, notice that the UI of the app has changed a little bit. The main UI now shows two tabs: <strong class="bold">Recipes</strong>, which shows <strong class="source-inline">RecipesOverviewPage</strong>, and <strong class="bold">Settings</strong>, which holds a new <strong class="source-inline">SettingsPage</strong>. Let’s have a look at implementing a <strong class="source-inline">NavigationService</strong> interface that leverages .NET <span class="No-Break">MAUI Shell.</span></p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor140"/>Creating an INavigationService interface</h2>
<p>It all starts with <a id="_idIndexMarker556"/>this interface, which will get injected into the ViewModels that want to navigate. And this is where developers tend to have different opinions. Some developers prefer to have a very slimmed-down interface only containing methods such as <strong class="source-inline">GoTo(string name)</strong>, <strong class="source-inline">GoTo(string name, IDictionary&lt;string, object&gt; parameters)</strong>, and <strong class="source-inline">GoBack()</strong>. This allows for a very generic interface and implementation that can easily be reused. I prefer a more per-app approach where I have methods such as <strong class="source-inline">GoToOverview()</strong>, <strong class="source-inline">GoToDetail(string id)</strong>, and others. The big advantage I find in this approach is the fact that when I want to navigate to a certain page, I know exactly what parameters are required to navigate to that page. I also find it easier to unit test and it makes it easier to implement app-specific edge cases. I’ve also seen and used generic implementations over the years, containing methods such as <strong class="source-inline">GoTo&lt;TViewModel&gt;()</strong> for example. It pretty much comes down to personal preference, use case requirements, and the specific needs of the project. I’ll be demonstrating the approach I typically use and have used successfully over the years. Once you understand the main concept of a <strong class="source-inline">NavigationService</strong>, please use whatever approach you prefer! Let’s create the <strong class="source-inline">INavigationService</strong> interface for our <span class="No-Break"><em class="italic">Recipes!</em></span><span class="No-Break"> app:</span></p>
<ol>
<li>In the <strong class="source-inline">Recipes.Client.Core</strong> project, add a new folder by right-clicking the project in the <strong class="bold">Solution Explorer</strong>, selecting <strong class="bold">Add</strong> | <strong class="bold">New Folder</strong>, and naming the <span class="No-Break">folder </span><span class="No-Break"><strong class="source-inline">Navigation</strong></span><span class="No-Break">.</span></li>
<li>Next, right-click the <a id="_idIndexMarker557"/>newly created folder and select <strong class="bold">Add</strong> | <strong class="bold">New</strong> <strong class="bold">Item…</strong>. Select <strong class="bold">Interface</strong> from the list of templates and enter <strong class="source-inline">INavigationService</strong> as the name for the <span class="No-Break">new interface.</span></li>
<li>As the <em class="italic">Recipes!</em> app doesn’t have a lot of navigation going on, we can keep the interface pretty simple, as <span class="No-Break">shown here:</span><pre class="source-code">
public interface INavigationService
{
    Task GoToRecipeDetail(string recipeId);
    Task GoToRecipeRatingDetail(RecipeDetailDto
      recipe);
    Task GoBack();
}</pre><p class="list-inset">The interface currently holds three methods. The <strong class="source-inline">GoToRecipeDetail</strong> method should navigate to the detail page. It accepts a string parameter representing the ID of the recipe we want to load on that page. The <strong class="source-inline">GoToRecipeRatingDetail</strong> method should load the ratings overview page of the given <strong class="source-inline">RecipeDetailDto</strong> object. Finally, there is the <strong class="source-inline">GoBack</strong> method, which should allow us to programmatically navigate back into <span class="No-Break">the app.</span></p></li> </ol>
<p class="callout-heading">Note</p>
<p class="callout">This <strong class="source-inline">INavigationService</strong> interface holds no reference to .NET MAUI or Shell. It’s just a contract for triggering navigations. The fact the interface is part of the <strong class="source-inline">Recipes.Client.Core</strong> project already gives away that it is framework agnostic. So, whether you want to leverage Shell or not, this interface probably <span class="No-Break">won’t change.</span></p>
<p>Now that we have <a id="_idIndexMarker558"/>this interface in place, let’s see how we can implement a <strong class="source-inline">NavigationService</strong> interface that <span class="No-Break">leverages Shell.</span></p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor141"/>Creating and using a NavigationService</h2>
<p>Because <a id="_idIndexMarker559"/>the implementation<a id="_idIndexMarker560"/> of <strong class="source-inline">NavigationService</strong> is specific to a framework, we are going to add it to the <span class="No-Break"><strong class="source-inline">Recipes.Mobile</strong></span><span class="No-Break"> project:</span></p>
<ol>
<li>Let’s add a <strong class="source-inline">Navigation</strong> folder to the <strong class="bold">Recipes.Mobile</strong> project by right-clicking the project in the <strong class="bold">Solution Explorer</strong> and selecting <strong class="bold">Add</strong> | <span class="No-Break"><strong class="bold">New Folder</strong></span><span class="No-Break">.</span></li>
<li>Now, right-click the <strong class="bold">Navigation</strong> folder, select <strong class="bold">Add</strong> | <strong class="bold">Class…</strong>, and name <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">NavigationService</strong></span><span class="No-Break">.</span></li>
<li>This class needs to implement <strong class="source-inline">INavigationService</strong>, as <span class="No-Break">shown here:</span><pre class="source-code">
public class NavigationService : INavigationService
{
    ...
}</pre></li> <li>Now, this is where Shell comes in! Earlier in this chapter, we saw how easy it is to use Shell for navigation: just call <strong class="source-inline">Shell.Current.GoToAsync</strong> and pass in the name of the page you want to navigate to. Let’s add the following method, which wraps around this <strong class="source-inline">GoToAsync</strong> method, to our new <span class="No-Break"><strong class="source-inline">NavigationService</strong></span><span class="No-Break"> class:</span><pre class="source-code">
private async Task Navigate(string pageName,
    Dictionary&lt;string, object&gt; parameters)
{
    await Shell.Current.GoToAsync(pageName);
}</pre><p class="list-inset">This <strong class="source-inline">Navigate</strong> method just calls the <strong class="source-inline">GoToAsync</strong> method of <strong class="source-inline">Shell</strong>, passing in the given <strong class="source-inline">pageName</strong> parameter. We’ll look at the <strong class="source-inline">parameters</strong> <span class="No-Break">parameter later.</span></p></li> <li>What remains for <strong class="source-inline">NavigationService</strong> is implementing the <strong class="source-inline">INavigationService</strong> interface’s <a id="_idIndexMarker561"/>methods, which<a id="_idIndexMarker562"/> is now pretty easy to do, as <span class="No-Break">shown here:</span><pre class="source-code">
public Task GoToRecipeDetail(string recipeId)
    =&gt; Navigate("RecipeDetail",
        new () { { "id", recipeId } });
public Task GoToRecipeRatingDetail(RecipeDetailDto
  recipe)
    =&gt;  Navigate("RecipeRating",
        new () { { "recipe", recipe } });
public Task GoBack()
    =&gt;  Shell.Current.GoToAsync("..");</pre><p class="list-inset">The first two methods call the <strong class="source-inline">Navigate</strong> method we created earlier, passing in the name of the page that needs to be loaded, as well as a dictionary containing the <strong class="source-inline">recipeId</strong> parameter. The <strong class="source-inline">GoBack</strong> method calls the <strong class="source-inline">GoToAsync</strong> method of <strong class="source-inline">Shell</strong>, passing in "..", signaling we want to navigate up the <span class="No-Break">navigation stack.</span></p></li> <li>Next, we can go ahead and register this <strong class="source-inline">NavigationService</strong> in the DI container. Open <strong class="source-inline">MauiProgram.cs</strong> and add <span class="No-Break">the following:</span><pre class="source-code">
builder.Services.AddSingleton&lt;INavigationService,
  NavigationService&gt;();</pre></li> </ol>
<p>And with that in place, it’s time to update our ViewModels and add <strong class="source-inline">INavigationService</strong> as <span class="No-Break">a dependency:</span></p>
<ol>
<li>Head over to <strong class="source-inline">RecipesOverviewViewModel</strong> and update its constructor so that it accepts an <strong class="source-inline">INavigationService</strong>. As before, we should also create a <strong class="source-inline">readonly</strong> field to hold the <span class="No-Break">injected value:</span><pre class="source-code">
public class RecipesOverviewViewModel :
  ObservableObject
{
    <strong class="bold">private readonly INavigationService</strong>
<strong class="bold">      navigationService;</strong>
...
    public RecipesOverviewViewModel(
        IRecipeService recipeService,
        IFavoritesService favoritesService,
        <strong class="bold">INavigationService navigationService</strong>)
    {
        <strong class="bold">this.navigationService = navigationService;</strong>
...
    }
}</pre></li> <li>Further down this class, we can now update the <strong class="source-inline">NavigateToSelectedDetail</strong> method to <span class="No-Break">the following:</span><pre class="source-code">
private async Task NavigateToSelectedDetail()
{
    if (SelectedRecipe is not null)
    {
        <strong class="bold">await navigationService.GoToRecipeDetail</strong>
<strong class="bold">          (SelectedRecipe.Id);</strong>
        SelectedRecipe = null;
    }
}</pre></li> <li>In <strong class="source-inline">RecipesOverviewPage.xaml</strong>, the <a id="_idIndexMarker563"/>following <a id="_idIndexMarker564"/>can <span class="No-Break">be removed:</span><pre class="source-code">
SelectionChanged="CollectionView_SelectionChanged"</pre><p class="list-inset">In the <strong class="source-inline">RecipesOverviewPage.xaml.cs</strong> file, the <strong class="source-inline">CollectionView_SelectionChanged</strong> method can be removed as well. Up until now, this is what triggered the navigation from the overview page to the <span class="No-Break">detail page.</span></p></li> </ol>
<p>Now, we need to give <strong class="source-inline">RecipeDetailViewModel</strong> the same treatment: inject <strong class="source-inline">INavigationService</strong> and use it to execute navigation to <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">RecipeRatingsDetailPage</strong></span><span class="No-Break">:</span></p>
<ol>
<li>As before, add an additional parameter to the class’s constructor and keep a reference to it in a <span class="No-Break"><strong class="source-inline">readonly</strong></span><span class="No-Break"> field:</span><pre class="source-code">
public partial class RecipeDetailViewModel :
  ObservableObject
{
    <strong class="bold">private readonly INavigationService</strong>
<strong class="bold">      navigationService;</strong>
...
    public RecipeDetailViewModel(
        IRecipeService recipeService,
        IFavoritesService favoritesService,
        IRatingsService ratingsService,
        <strong class="bold">INavigationService navigationService</strong>)
    {
        <strong class="bold">this.navigationService = navigationService;</strong>
        ...
    }
...
}</pre></li> <li>The following snippet shows how we can update the <span class="No-Break"><strong class="source-inline">NavigateToRatings</strong></span><span class="No-Break"> method:</span><pre class="source-code">
<strong class="bold">private Task NavigateToRatings()</strong>
<strong class="bold">    =&gt; navigationService</strong>
<strong class="bold">        .GoToRecipeRatingDetail(recipeDto);</strong>
}</pre><p class="list-inset">This method gets called when <strong class="source-inline">NavigateToRatingsCommand</strong> <span class="No-Break">is invoked.</span></p></li> <li>Finally, we need to head over to the <strong class="source-inline">RecipeDetailPage.xaml</strong> file and update the <strong class="source-inline">TapGestureRecognizer</strong> on the <strong class="source-inline">HorizontalStackLayout</strong>, which shows the rating, to <span class="No-Break">the following:</span><pre class="source-code">
&lt;HorizontalStackLayout.GestureRecognizers&gt;
    &lt;TapGestureRecognizer <strong class="bold">Command="{Binding</strong>
<strong class="bold">      </strong><strong class="bold">NavigateToRatingsCommand}"</strong> /&gt;
&lt;/HorizontalStackLayout.GestureRecognizers&gt;</pre><p class="list-inset">Tapping this control will now trigger <strong class="source-inline">NavigateToRatingsCommand</strong>, which we just created, which will call the <strong class="source-inline">NavigationService</strong> to initiate navigation to <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">RatingsDetailPage</strong></span><span class="No-Break">.</span></p></li> <li>The <strong class="source-inline">Ratings_Tapped</strong> method in the code-behind of <strong class="source-inline">RecipeDetailPage</strong> can be deleted as it is no longer of <span class="No-Break">any use.</span></li>
</ol>
<p>The pages, their <a id="_idIndexMarker565"/>ViewModels, and<a id="_idIndexMarker566"/> their routes, are already registered in <strong class="source-inline">MauiProgram</strong>’s <strong class="source-inline">CreateMauiApp</strong> method, as <span class="No-Break">shown here:</span></p>
<pre class="source-code">
...
builder.Services.AddTransient&lt;RecipesOverviewPage&gt;();
builder.Services.AddTransient&lt;RecipesOverviewViewModel&gt;();
builder.Services.AddTransient&lt;RecipeDetailPage&gt;();
builder.Services.AddTransient&lt;RecipeDetailViewModel&gt;();
builder.Services.AddTransient&lt;RecipeRatingsDetailPage&gt;();
builder.Services.AddTransient&lt;RecipeRatingsDetailViewModel&gt;
();
builder.Services.AddTransient&lt;SettingsPage&gt;();
builder.Services.AddTransient&lt;SettingsViewModel&gt;();
Routing.RegisterRoute("MainPage", 
  typeof (RecipesOverviewPage));
Routing.RegisterRoute("RecipeDetail", 
  typeof (RecipeDetailPage));
Routing.RegisterRoute("RecipeRating", 
  typeof (RecipeRatingsDetailPage));</pre> <p>With all of these changes in place, we can now effectively navigate from one page to another. The injected instance of <strong class="source-inline">NavigationService</strong> in the ViewModels leverages Shell to<a id="_idIndexMarker567"/> navigate between pages. But there is still one thing missing: passing parameters from one page to another. Let’s see how to <span class="No-Break">add this!</span></p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor142"/>Passing parameters</h2>
<p>As mentioned earlier, although .NET MAUI Shell has a baked-in way of passing parameters, I’m not fond of using that in my ViewModels as it would require my ViewModels to depend on MAUI and Shell. Luckily, a solution to that is not that complex. Moreover, it fits nicely in the broader setup of our <strong class="source-inline">NavigationService</strong>, as we will discuss later in <span class="No-Break">this chapter.</span></p>
<p>Let’s introduce a new interface: <strong class="source-inline">INavigationParameterReceiver</strong>. This interface exposes one method called <strong class="source-inline">OnNavigatedTo</strong> that receives a dictionary of type <strong class="source-inline">Dictionary&lt;string, object&gt;</strong> as a single parameter. This interface can be implemented by ViewModels that want to accept navigation parameters. When navigated to a page, the <strong class="source-inline">NavigationService</strong> can check whether the <strong class="source-inline">BindingContext</strong> of the new page implements this interface and then call the <strong class="source-inline">OnNavigatedTo</strong> method, passing in the parameters. Let’s see how we can <span class="No-Break">implement this:</span></p>
<ol>
<li>First, let’s add the <strong class="source-inline">INavigationParameterReceiver</strong> interface. Right-click the <strong class="source-inline">Navigation</strong> folder in the <strong class="source-inline">Recipes.Client.Core</strong> project and select <strong class="bold">Add</strong> | <strong class="bold">New Item…</strong> in the list of templates. Then, select <strong class="bold">Interface</strong> and enter <strong class="source-inline">INavigationParameterReceiver</strong> as the name of <span class="No-Break">the interface.</span></li>
<li>As we mentioned previously, this interface should expose the <strong class="source-inline">OnNavigatedTo</strong> method. Let’s <span class="No-Break">add this:</span><pre class="source-code">
public interface INavigationParameterReceiver
{
    Task OnNavigatedTo(Dictionary&lt;string, object&gt;
      parameters);
}</pre></li> <li>Head over to <a id="_idIndexMarker568"/>the <strong class="source-inline">Navigate</strong> method of the <strong class="source-inline">NavigationService</strong> class and update it to <span class="No-Break">the following:</span><pre class="source-code">
private async Task Navigate(string pageName,
    Dictionary&lt;string, object&gt; parameters)
{
    await Shell.Current.GoToAsync(pageName);
    <strong class="bold">if (Shell.Current.CurrentPage.BindingContext</strong>
<strong class="bold">        </strong><strong class="bold">is INavigationParameterReceiver receiver)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        await receiver.OnNavigatedTo(parameters);</strong>
<strong class="bold">    }</strong>
}</pre><p class="list-inset">The preceding code will pass the provided parameters to the ViewModel once Shell has navigated to the new page. We can retrieve the current page by calling <strong class="source-inline">Shell.Current.CurrentPage</strong>. Once we have the current page, we can check whether the page’s <strong class="source-inline">BindingContext</strong> implements the <strong class="source-inline">INavigationParameterReceiver</strong> interface. If it does, we can call the <strong class="source-inline">OnNavigatedTo</strong> method to pass the <span class="No-Break">provided parameters.</span></p></li> <li><strong class="source-inline">RecipeDetailViewModel</strong> can now implement the <strong class="source-inline">INavigationParameterReceiver</strong> interface, as <span class="No-Break">shown here:</span><pre class="source-code">
public partial class RecipeDetailViewModel :
  ObservableObject, <strong class="bold">INavigationParameterReceiver</strong>
{
...
    <strong class="bold">public Task OnNavigatedTo(</strong>
<strong class="bold">        Dictionary&lt;string, object&gt; parameters)</strong>
<strong class="bold">        =&gt; LoadRecipe(parameters["id"].ToString());</strong>
<strong class="bold">}</strong></pre><p class="list-inset">When the <strong class="source-inline">OnNavigatedTo</strong> method is called, the <strong class="source-inline">id</strong> parameter is retrieved from the<a id="_idIndexMarker569"/> dictionary and passed to the <span class="No-Break"><strong class="source-inline">LoadRecipe</strong></span><span class="No-Break"> method.</span></p></li> <li>Up until now, the constructor of <strong class="source-inline">RecipeDetailViewModel</strong> called the <strong class="source-inline">LoadRecipe</strong> method with a hard-coded ID. This call can now <span class="No-Break">be removed.</span></li>
<li><strong class="source-inline">RecipeRatingsDetailViewModel</strong> also needs to be updated for it to be able to receive parameters. The following code block shows how it can <span class="No-Break">implement </span><span class="No-Break"><strong class="source-inline">INavigationParameterReceiver</strong></span><span class="No-Break">:</span><pre class="source-code">
public class RecipeRatingsDetailViewModel :
  ObservableObject, <strong class="bold">INavigationParameterReceiver</strong>
{
...
    <strong class="bold">public Task OnNavigatedTo(</strong>
<strong class="bold">        Dictionary&lt;string, object&gt; parameters)</strong>
<strong class="bold">        =&gt; LoadData(parameters["recipe"]</strong>
<strong class="bold">            </strong><strong class="bold">as RecipeDetailDto);</strong>
}</pre><p class="list-inset">Please note that there has been a slight change in the <strong class="source-inline">LoadData</strong> method signature since the previous chapter. Rather than accepting a string, it now takes a <strong class="source-inline">RecipeDetailDto</strong> object as its parameter. This is an optimization strategy that aims to avoid over-fetching. When we navigate from <strong class="source-inline">RecipeDetailPage</strong>, we have already loaded the details of a recipe. Therefore, it’s not needed to reload these same details when we move to <strong class="source-inline">RecipeRatingDetailPage</strong>. By passing in a <strong class="source-inline">RecipeDetailDto</strong>, we effectively utilize the data we’ve <span class="No-Break">already fetched.</span></p></li> </ol>
<p>With <strong class="source-inline">INavigationParameterReceiver</strong> in place, we can effectively pass navigation parameters from one page to another. Let’s see how we can extend our navigation infrastructure even more to allow us to hook into and manage important parts of the ViewModel’s life <a id="_idIndexMarker570"/>cycle: specifically, the moments of navigation to and from <span class="No-Break">a ViewModel.</span></p>
<p class="callout-heading">Avoid “magic strings”</p>
<p class="callout">The code samples in this chapter use a lot of “magic strings": specific routes are registered for pages, parameters are passed using exact keys, and navigation requires correct input of these routes and keys. While this makes the code samples simple and clear, it’s risky in practice. A single spelling error can lead to runtime errors that aren’t immediately apparent. To prevent such issues, it’s advisable to use string constants for route names and parameters stored in designated classes. We didn’t follow this best practice here for the sake of simplicity, but keep it in mind when you’re writing <span class="No-Break">your code.</span></p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor143"/>Hooking into navigation</h2>
<p>Often, we want to<a id="_idIndexMarker571"/> hook into the navigation process to effectively manage ViewModel states during transitions. This allows us to handle setup and cleanup operations, as well as manage state changes when a ViewModel becomes active or inactive in the application. This strategy is particularly useful for tasks such as subscribing to or unsubscribing from services, loading or saving states, and initiating or canceling <span class="No-Break">network requests.</span></p>
<p>For that purpose, let’s introduce two new interfaces: <strong class="source-inline">INavigatedFrom</strong> and <strong class="source-inline">INavigatedTo</strong>. Just like <strong class="source-inline">INavigationParameterReceiver</strong>, ViewModels can choose to implement these interfaces if they want to react to certain navigation events. Let’s see what they <span class="No-Break">look like:</span></p>
<pre class="source-code">
public interface INavigatedFrom
{
    Task OnNavigatedFrom(NavigationType navigationType);
}
public interface INavigatedTo
{
    Task OnNavigatedTo(NavigationType navigationType);
}</pre> <p>Both the <strong class="source-inline">OnNavigatedFrom</strong> and <strong class="source-inline">OnNavigatedTo</strong> methods accept one parameter of type <strong class="source-inline">NavigationType</strong>, which<a id="_idIndexMarker572"/> is an enum. This enum has the <span class="No-Break">following implementation:</span></p>
<pre class="source-code">
public enum NavigationType
{
    Unknown,
    Forward,
    Back,
    SectionChange,
}</pre> <p>With this <strong class="source-inline">enum</strong> type, we want to give context to the type of navigation that occurred. The <strong class="source-inline">SectionChanged</strong> value can be used when the user opens another tab for example or selects another item from <strong class="source-inline">FlyoutMenu</strong>. As you might expect, the <strong class="source-inline">Forward</strong> and <strong class="source-inline">Back</strong> values are used when navigating hierarchically from one page <span class="No-Break">to another.</span></p>
<p>These methods and values of the <strong class="source-inline">NavigationType</strong> enum enable nuanced reactions to a wide variety of navigation scenarios. Let’s consider <span class="No-Break">some examples:</span></p>
<ul>
<li>When the <strong class="source-inline">OnNavigatedFrom</strong> method of a ViewModel is called with <strong class="source-inline">Back</strong> as the parameter, we can infer that we’re navigating backward away from this ViewModel. In this context, you should consider stopping any ongoing tasks or network requests related to that ViewModel. The page no longer exists on the <strong class="source-inline">NavigationStack</strong>, so unsubscribing from messages or events may be wise, allowing any unneeded resources to be reclaimed via <span class="No-Break">garbage collection.</span></li>
<li>If the <strong class="source-inline">OnNavigatedFrom</strong> method is invoked with <strong class="source-inline">Forward</strong> as the parameter, we know the page and its ViewModel remain on the <strong class="source-inline">NavigationStack</strong>. Therefore, the user can easily navigate back to this page. In this situation, we may also want to clean up specific processes or running tasks, but it’s important to ensure they can be quickly reinstated. When the user navigates back to the ViewModel, the <strong class="source-inline">OnNavigatedTo</strong> method will be triggered with <strong class="source-inline">Back</strong> as the parameter, signaling a need to restart previously <span class="No-Break">paused processes.</span></li>
</ul>
<p>Let’s see how we<a id="_idIndexMarker573"/> can add these additional interfaces to our ViewModels and hook up the necessary code to call the methods these <span class="No-Break">interfaces expose:</span></p>
<ol>
<li>Add the interfaces (<strong class="source-inline">INavigatedFrom</strong> and <strong class="source-inline">INavigatedTo</strong>) and the <strong class="source-inline">NavigationType</strong> enum, as shown in the earlier code blocks, to the <strong class="source-inline">Navigation</strong> folder of the <span class="No-Break"><strong class="source-inline">Recipes.Client.Core</strong></span><span class="No-Break"> project.</span></li>
<li>When inheriting from the <strong class="source-inline">AppShell</strong> class, we can override the <strong class="source-inline">OnNavigated</strong> method. This method is invoked when a navigation is executed by the Shell framework. This is the ideal place to call into the methods of the interfaces that we’ve introduced. Go ahead to the <strong class="source-inline">AppShell</strong> class and override this method, as <span class="No-Break">shown here:</span><pre class="source-code">
protected override async void OnNavigated
  (ShellNavigatedEventArgs args)
{
    var navigationType =
        GetNavigationType(args.Source);
    base.OnNavigated(args);
}</pre><p class="list-inset">The <strong class="source-inline">ShellNavigatedEventArgs</strong> parameter that’s passed into this method has a <strong class="source-inline">Source</strong> property. This <strong class="source-inline">Source</strong> property is of type <strong class="source-inline">ShellNavigationSource</strong> and indicates how the navigation occurred: <strong class="source-inline">Push</strong>, <strong class="source-inline">Pop</strong>, <strong class="source-inline">PopToRoot</strong>, and so on. We want to translate this to the <strong class="source-inline">NavigationType</strong> enum we introduced earlier, allowing it to be framework-independent from <span class="No-Break">here on.</span></p></li> <li>To<a id="_idIndexMarker574"/> translate <strong class="source-inline">ShellNavigationSource</strong> to <strong class="source-inline">NavigationType</strong>, create the following <strong class="source-inline">GetNavigationType</strong> method in the <span class="No-Break"><strong class="source-inline">AppShell</strong></span><span class="No-Break"> class:</span><pre class="source-code">
private NavigationType GetNavigationType
  (ShellNavigationSource source) =&gt;
    source switch
    {
        ShellNavigationSource.Push or
        ShellNavigationSource.Insert
            =&gt; NavigationType.Forward,
        ShellNavigationSource.Pop or
        ShellNavigationSource.PopToRoot or
        ShellNavigationSource.Remove
            =&gt; NavigationType.Back,
        ShellNavigationSource.ShellItemChanged or
        ShellNavigationSource.ShellSectionChanged or
        ShellNavigationSource.ShellContentChanged
            =&gt; NavigationType.SectionChange,
        _ =&gt; NavigationType.Unknown
    };</pre></li> <li>Now, we need to find a way to access the ViewModels of the current and previous page, from within the overridden <strong class="source-inline">OnNavigated</strong> method. Once we get a hold of them, we can call <strong class="source-inline">OnNavigatedFrom</strong> and <strong class="source-inline">OnNavigatedTo</strong> when the ViewModel implements the corresponding interfaces. For that purpose, let’s introduce a new interface: <strong class="source-inline">INavigationInterceptor</strong>. Here’s what it <span class="No-Break">looks like:</span><pre class="source-code">
public interface INavigationInterceptor
{
    Task OnNavigatedTo(object bindingContext,
        NavigationType navigationType);
}</pre><p class="list-inset">For now, this<a id="_idIndexMarker575"/> interface only exposes one method: <strong class="source-inline">OnNavigatedTo</strong>. It accepts a parameter of the <strong class="source-inline">object</strong> type that represents the <strong class="source-inline">BindingContext</strong> of the current page. It also accepts a parameter of <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">NavigationType</strong></span><span class="No-Break">.</span></p></li> <li>Add this interface as a constructor parameter to <strong class="source-inline">AppShell</strong> and call its <strong class="source-inline">OnNavigatedTo</strong> method from the <strong class="source-inline">OnNavigated</strong> method of Shell, which we’ve just overridden. The following code block shows how to <span class="No-Break">add this:</span><pre class="source-code">
public partial class AppShell : Shell
{
    <strong class="bold">readonly INavigationInterceptor interceptor;</strong>
    public AppShell(<strong class="bold">INavigationInterceptor</strong>
<strong class="bold">      interceptor</strong>)
    {
        <strong class="bold">this.interceptor = interceptor;</strong>
        InitializeComponent();
    }
    protected override async void OnNavigated
      (ShellNavigatedEventArgs args)
    {
        var navigationType =
            GetNavigationType(args.Source);
        base.OnNavigated(args);
        <strong class="bold">await interceptor.OnNavigatedTo(</strong>
<strong class="bold">            CurrentPage?.BindingContext,</strong>
<strong class="bold">              navigationType);</strong>
    }
...
}</pre></li> <li>Because<a id="_idIndexMarker576"/> the <strong class="source-inline">AppShell</strong> class now lacks its default constructor and requires a parameter of type <strong class="source-inline">INavigationInterceptor</strong>, we need to update our code in the <strong class="source-inline">App.xaml.cs</strong> file, as <span class="No-Break">shown here:</span><pre class="source-code">
public App(<strong class="bold">INavigationInterceptor interceptor</strong>)
{
    ...
    <strong class="bold">MainPage = new AppShell(interceptor);</strong>
}</pre><p class="list-inset">The constructor of the <strong class="source-inline">App</strong> class has been updated so that it accepts a parameter of the <span class="No-Break"><strong class="source-inline">INavigationInterceptor</strong></span><span class="No-Break"> type.</span></p></li> <li>What remains is implementing <strong class="source-inline">INavigationInterceptor</strong> and registering it in the DI<a id="_idIndexMarker577"/> container. This interface can be implemented by our existing <strong class="source-inline">NavigationService</strong>. Let’s <span class="No-Break">see how:</span><pre class="source-code">
Public class NavigationService : INavigationService,
  INavigationInterceptor
{
...
    WeakReference&lt;INavigatedFrom&gt; previousFrom;
    public async Task OnNavigatedTo(object
      bindingContext, NavigationType navigationType)
    {
        if(previousFrom is not null &amp;&amp; previousFrom
            .TryGetTarget(out INavigatedFrom from))
        {
            await from.OnNavigatedFrom
              (navigationType);
        }
        if (bindingContext
            is INavigatedTo to)
        {
            await to.OnNavigatedTo(navigationType);
        }
        if(bindingContext is INavigatedFrom
          navigatedFrom)
            previousFrom = new (navigatedFrom);
        else
            previousFrom = null;
}</pre><p class="list-inset">A lot is going on here, so let’s discuss what happens. Remember that the <strong class="source-inline">OnNavigatedTo</strong> method is called when we have already navigated. So, we must keep a<a id="_idIndexMarker578"/> reference to the previous page’s <strong class="source-inline">BindingContext</strong> if we want to call a method on that later on. This reference is kept as <strong class="source-inline">WeakReference</strong> because we don’t want this reference to cause the object not to be garbage collected and causing memory leaks. First, we check whether the <strong class="source-inline">previousFrom</strong> field is not null and whether it still holds a reference to a value that implements the <strong class="source-inline">INavigatedFrom</strong> interface. If we get back a value, the <strong class="source-inline">OnNavigatedFrom</strong> method is called on the <strong class="source-inline">BindingContext</strong> of the page we’ve <span class="No-Break">navigated from.</span></p><p class="list-inset">Next, we check whether the passed-in <strong class="source-inline">bindingContext</strong> parameter implements the <strong class="source-inline">INavigatedTo</strong> interface. If that’s the case, the <strong class="source-inline">OnNavigatedTo</strong> method <span class="No-Break">is called.</span></p><p class="list-inset">In the end, we check whether the given <strong class="source-inline">bindingContext</strong> implements the <strong class="source-inline">INavigatedFrom</strong> interface. If so, we store it in the <strong class="source-inline">previousFrom</strong> field. If not, the <strong class="source-inline">previousFrom</strong> field is <span class="No-Break">assigned null.</span></p></li> <li>It’s important to notice that we’ve introduced state to our <strong class="source-inline">NavigationService</strong> by keeping track of the <strong class="source-inline">BindingContext</strong> of the previous page through the <strong class="source-inline">previousFrom</strong> field. As a result, <strong class="source-inline">NavigationService</strong> should be registered as Singleton so that throughout the app, the same instance of <strong class="source-inline">NavigationService</strong> is being used. Moreover, the <strong class="source-inline">NavigationService</strong> should be resolvable as <strong class="source-inline">INavigationService</strong> in the ViewModels and as <strong class="source-inline">INavigationInterceptor</strong> for instantiating the <strong class="source-inline">AppShell</strong> class. To accommodate this, we can update the registration, <span class="No-Break">as follows:</span><pre class="source-code">
builder.Services.AddSingleton&lt;NavigationService&gt;();
builder.Services.AddSingleton&lt;INavigationService&gt;(
    c =&gt; c.GetRequiredService&lt;NavigationService&gt;());
builder.Services.AddSingleton&lt;INavigationInterceptor&gt;(
    c =&gt; c.GetRequiredService&lt;NavigationService&gt;());</pre></li> </ol>
<p><strong class="source-inline">NavigationService</strong> itself is registered as a singleton. We also added singleton registrations <a id="_idIndexMarker579"/>for <strong class="source-inline">INavigationService</strong> and <strong class="source-inline">INavigationIntercepter</strong>, both returning the registration of <strong class="source-inline">NavigationService</strong>. This allows us to register one type for multiple interfaces, all pointing to the <span class="No-Break">same instance.</span></p>
<p>Go ahead and implement the <strong class="source-inline">INavigatedTo</strong> and <strong class="source-inline">INavigatedFrom</strong> interfaces in some ViewModels. Add a breakpoint to the implemented methods, run the app, and see what happens by inspecting the parameter values. For our little <em class="italic">Recipes!</em> app, there is no need to add an implementation to said methods, but as managing ViewModel states during transitions is something developers tend to struggle with in larger apps, I wanted to share how I handle these kinds <span class="No-Break">of scenarios.</span></p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor144"/>Setting up navigation without .NET MAUI Shell</h1>
<p>As I mentioned<a id="_idIndexMarker580"/> earlier, Shell is an opinionated way to create the structure of a .NET MAUI app. This might not work for you or your particular project. Not using Shell complicates the implementation of a <strong class="source-inline">NavigationService</strong> a lot, especially when your app has a complex structure such as tabs or a flyout menu. Let’s focus on a simple hierarchical navigation and see what is needed to implement a <strong class="source-inline">NavigationService</strong> without relying on <span class="No-Break">another framework.</span></p>
<p>Luckily, the interfaces we created earlier (<strong class="source-inline">INavigationService</strong>, <strong class="source-inline">INavigatedTo</strong>, <strong class="source-inline">INavigatedFrom</strong>, and <strong class="source-inline">INavigationParameterReceiver</strong>) are framework-independent and can still be used as the backbone of <span class="No-Break">this implementation:</span></p>
<ol>
<li>No Shell means no routing. However, I do like the concept of having keys associated with a particular view as it allows for a loosely coupled way of navigating. That’s why we’re creating a static <strong class="source-inline">Routes</strong> class in the <strong class="source-inline">Navigation</strong> folder of the <strong class="source-inline">Recipes.Mobile</strong> project, as <span class="No-Break">shown here:</span><pre class="source-code">
public static class Routes
{
    static Dictionary&lt;string, Type&gt; routes
        = new Dictionary&lt;string, Type&gt;();
    public static void Register&lt;T&gt;(string key)
        where T : Page
        =&gt; routes.Add(key, typeof(T));
    public static Type GetType(string key)
        =&gt; routes[key];
}</pre><p class="list-inset">This class allows us to map keys to types that inherit <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">Page</strong></span><span class="No-Break">.</span></p></li> <li>Next, instead of using the static <strong class="source-inline">Routing.RegisterRoute</strong> method to register routes in the <strong class="source-inline">MauiProgram</strong> class, we can now use our own <strong class="source-inline">Routes</strong> class, <span class="No-Break">like this:</span><pre class="source-code">
Routes.Register&lt;RecipesOverviewPage&gt;("MainPage");
Routes.Register&lt;RecipeDetailPage&gt;("RecipeDetail");
Routes.Register&lt;RecipeRatingsDetailPage&gt;
  ("RecipeRating");</pre><p class="list-inset">The <strong class="source-inline">Routes.GetType</strong> method will allow us to retrieve a key’s <span class="No-Break"><strong class="source-inline">Type</strong></span><span class="No-Break"> later.</span></p></li> <li>Before diving into the implementation of the non-Shell <strong class="source-inline">NavigationService</strong>, let’s add the following code to the <span class="No-Break"><strong class="source-inline">INavigationService</strong></span><span class="No-Break"> interface:</span><pre class="source-code">
Task GoToOverview();</pre></li> <li>In <strong class="source-inline">App.xaml.cs</strong>, update<a id="_idIndexMarker581"/> the <strong class="source-inline">App</strong>’s constructor as <span class="No-Break">shown here:</span><pre class="source-code">
public App(<strong class="bold">INavigationService navigationService</strong>)
{
    Application.Current.UserAppTheme = AppTheme.Light;
    InitializeComponent();
    <strong class="bold">MainPage = new NavigationPage();</strong>
<strong class="bold">    navigationService.GoToOverview();</strong>
}</pre><p class="list-inset">With the updated code, a class implementing the <strong class="source-inline">INavigationService</strong> interface will be injected. After assigning a new <strong class="source-inline">NavigationPage</strong> to the <strong class="source-inline">MainPage</strong> property, we can call the newly added <strong class="source-inline">GoToOverview</strong> method on the injected <strong class="source-inline">INavigationService</strong> for it to navigate to <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">OverviewPage</strong></span><span class="No-Break">.</span></p></li> <li>Now, we can go and start implementing the non-Shell <strong class="source-inline">NavigationService</strong>. Create a new class called <strong class="source-inline">NonShellNavigationService</strong> in the <strong class="source-inline">Navigation</strong> folder of the <strong class="source-inline">Recipes.Mobile</strong> project. As you might expect, this class needs to implement the <strong class="source-inline">INavigationService</strong> interface, as <span class="No-Break">shown here:</span><pre class="source-code">
public class NonShellNavigationService :
INavigationService</pre></li> <li>The first thing we want to add is the <strong class="source-inline">Navigation</strong> property, which is of type <strong class="source-inline">Microsoft.Maui.Controls.INavigation</strong>. Through this property, we want to effectively route our navigation. The <strong class="source-inline">INavigation</strong> interface defines navigation-related <a id="_idIndexMarker582"/>methods and properties. Let’s see what that property <span class="No-Break">looks like:</span><pre class="source-code">
protected INavigation Navigation
{
    get
    {
        INavigation? navigation =
            Application.Current?.MainPage?.Navigation;
        if (navigation is not null)
            return navigation;
        else
        {
            throw new Exception();
        }
    }
}</pre><p class="list-inset">Through the static <strong class="source-inline">Current</strong> property of the <strong class="source-inline">Application</strong> class, we can get to the instance of the application, allowing us to access its <strong class="source-inline">MainPage</strong> property. The <strong class="source-inline">MainPage</strong> property, which is of type <strong class="source-inline">Page</strong>, has a <strong class="source-inline">Navigation</strong> property of type <strong class="source-inline">INavigation</strong>, which is exactly what <span class="No-Break">we need.</span></p></li> <li>Like on <strong class="source-inline">NavigationService</strong>, which used <strong class="source-inline">Shell</strong>, we also want to add a private <strong class="source-inline">Navigate</strong> method<a id="_idIndexMarker583"/> that other methods in this class can use. Here’s what this <span class="No-Break">looks like:</span><pre class="source-code">
private async Task Navigate(string key,
    Dictionary&lt;string, object&gt; parameters)
{
    var type = Routes.GetType(key);
    var page = ServiceProvider.Current
        .GetService(type) as Page;
    page.NavigatedFrom += Page_NavigatedFrom;
    await Navigation.PushAsync(page);
    if (page.BindingContext
        is INavigationParameterReceiver receiver)
    {
        await receiver.OnNavigatedTo(parameters);
    }
    if (Navigation.NavigationStack.Count == 1)
    {
        if (page.BindingContext
        is INavigatedTo to)
            await to.OnNavigatedTo(NavigationType
              .SectionChange);
    }
}</pre><p class="list-inset">With the given key, we can resolve the type we want to navigate to. Using the <strong class="source-inline">ServiceProvider</strong>, we can retrieve an instance of the given type, satisfying all of its dependencies. Next, an event handler for the resolved page’s <strong class="source-inline">NavigatedFrom</strong> event is added before we access our <strong class="source-inline">Navigation</strong> property and push this page onto the navigation stack with the <strong class="source-inline">PushAsync</strong> method. This is what executes the effective navigation to the requested page. After the page is pushed, its <strong class="source-inline">BindingContext</strong> is checked to see whether it implements the <strong class="source-inline">INavigationParameterReceiver</strong> interface. If that’s the case, its <strong class="source-inline">OnNavigatedTo</strong> method is called, passing in the navigation parameters. The final thing that happens in this method is that it checks whether the size of <strong class="source-inline">NavigationStack</strong> is <strong class="source-inline">1</strong>. This means that we navigated to a page and that there’s only one item on the stack, or in other words, this is the first page we’re navigating <a id="_idIndexMarker584"/>to. If that is the case, we want to call the <strong class="source-inline">OnNavigatedTo</strong> method on the page’s <strong class="source-inline">BindingContext</strong> if said <strong class="source-inline">BindingContext</strong> implements the <strong class="source-inline">INavigatedTo</strong> interface and pass in <strong class="source-inline">NavigationType.SectionChange</strong>. With this in place, the <strong class="source-inline">OnNavigatedTo</strong> method is called on <span class="No-Break">initial navigation.</span></p></li> <li>In the previous method, we added a handler to the page’s <strong class="source-inline">NavigatedFrom</strong> event. The following code block shows <span class="No-Break">its implementation:</span><pre class="source-code">
private async void Page_NavigatedFrom(object sender,
  NavigatedFromEventArgs e)
{
    bool isForwardNavigation =
        Navigation.NavigationStack.Count &gt; 1
        &amp;&amp; Navigation.NavigationStack[^2] == sender;
    if (sender is Page page)
    {
        if (!isForwardNavigation)
        {
            page.NavigatedFrom -= Page_NavigatedFrom;
        }
        await OnNavigatedTo(Navigation.NavigationStack
          .Last().BindingContext,
            isForwardNavigation ? NavigationType
              .Forward : NavigationType.Back);
    }
}</pre><p class="list-inset">As we are focusing on hierarchical navigation, navigation from a page can happen for two reasons: we’re navigating forward to another page or we’re navigating back to the previous page. This is what is determined at the beginning of this<a id="_idIndexMarker585"/> method. As this event is handled after the navigation occurred, we can determine forward navigation by looking at the second-to-last item on the <strong class="source-inline">NavigationStack</strong>: if that entry equals the sender, it means we navigated forward from the sender to another page. If it wasn’t forward navigation, meaning we’ve navigated back from the page to the previous page, we need to remove the event handler from the page’s <strong class="source-inline">NavigateFrom</strong> event. We need to do this so that the page has no references and can be garbage collected, avoiding potential memory leaks. Finally, we call the <strong class="source-inline">OnNavigated</strong> method, passing in the <strong class="source-inline">BindingContext</strong> of the current page (which is the last item in <strong class="source-inline">NavigationStack</strong>). Depending on whether it is forward navigation or not, we pass in <strong class="source-inline">NavigationType.Forward</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">NavigationType.Backward</strong></span><span class="No-Break">.</span></p></li> <li>The <strong class="source-inline">OnNavigatedTo</strong> method that is being called in the previous code block might look familiar. That’s because it is completely identical to the <strong class="source-inline">OnNavigatedTo</strong> method <a id="_idIndexMarker586"/>we had in our previous implementation of <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">NavigationService</strong></span><span class="No-Break">:</span><pre class="source-code">
WeakReference&lt;INavigatedFrom&gt; previousFrom;
private async Task OnNavigatedTo(object
  bindingContext,
    NavigationType navigationType)
{
    if (previousFrom is not null &amp;&amp; previousFrom
        .TryGetTarget(out INavigatedFrom from))
    {
        await from.OnNavigatedFrom(navigationType);
    }
    if (bindingContext
        is INavigatedTo to)
    {
        await to.OnNavigatedTo(navigationType);
    }
    if (bindingContext is INavigatedFrom
      navigatedFrom)
        previousFrom = new(navigatedFrom);
    else
        previousFrom = null;
}</pre></li> <li>Finally, let’s have a look at the implemented methods of the <span class="No-Break"><strong class="source-inline">INavigationService</strong></span><span class="No-Break"> interface:</span><pre class="source-code">
public Task GoBack()
    =&gt; Navigation.PopAsync();
public Task GoToRecipeDetail(string recipeId)
=&gt; Navigate("RecipeDetail",
    new() { { "id", recipeId } });
public Task GoToRecipeRatingDetail(RecipeDetailDto
  recipe)
=&gt; Navigate("RecipeRating",
    new() { { "recipe", recipe } });
public Task GoToOverview()
=&gt; Navigate("Overview", null);</pre><p class="list-inset">They also look very <a id="_idIndexMarker587"/>much like they did in the previous implementation because the <strong class="source-inline">Navigate</strong> method accepts the same parameters as in the <span class="No-Break">previous sample.</span></p></li> <li>The only thing that’s left to do is register <span class="No-Break">this </span><span class="No-Break"><strong class="source-inline">NonShellNavigationService</strong></span><span class="No-Break">:</span><pre class="source-code">
builder.Services.AddSingleton&lt;INavigationService ,
  NonShellNavigationService&gt;();</pre><p class="list-inset">In this setup, we’re not using <strong class="source-inline">INavigationInterceptor</strong>, so there’s no need to <span class="No-Break">register that.</span></p></li> </ol>
<p>With that in place, we’ve successfully created a simple <strong class="source-inline">NavigationService</strong> that does not leverage .NET MAUI Shell. Many of the core concepts were reused in this example, demonstrating that they are a good level of abstraction. That said, this implementation is very simple and naïve. It lacks the support for modal navigation and navigation inside tabs and doesn’t have anything for handling a flyout menu. This example might give you some ideas and insights, but building a <strong class="source-inline">NavigationService</strong> from scratch, without leveraging Shell, is quite daunting. In many cases, when Shell is not an option for you or your specific project, I think relying on other third-party frameworks might be the way to go. Libraries such as <em class="italic">FreshMvvm</em> and especially <em class="italic">Prism Library</em> are worth <a id="_idIndexMarker588"/><span class="No-Break">checking out!</span></p>
<p>Before concluding this chapter, it’s important to address a potentially unclear aspect: how can we effectively return a result from a child page to <span class="No-Break">its parent?</span></p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor145"/>Passing results back</h1>
<p>In this chapter, we’ve<a id="_idIndexMarker589"/> explored passing parameters from one page to another during forward navigation. But what if we need to take an object, use it as a parameter to navigate to another page, manipulate it there, and then retrieve the <span class="No-Break">updated result?</span></p>
<p>There are various approaches to achieve this, but the most straightforward method is to add a little extension to our navigation framework and allow parameters to be passed when navigating back. For example, on the <strong class="source-inline">SettingsPage</strong> of the <em class="italic">Recipes!</em> app, we show the user’s current language. There’s a button that navigates to the <strong class="source-inline">PickLanguagePage</strong>, where the user can select a different language. The current language needs to be passed from the <strong class="source-inline">SettingsPage</strong> to the <strong class="source-inline">PickLanguage</strong> page so that the latter can show the current value. When the user selects a new language, the <strong class="source-inline">PickLanguagePage</strong> should navigate back to the <strong class="source-inline">SettingsPage</strong> and pass the selected language as a parameter. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.2</em> shows how this <span class="No-Break">looks schematically:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer060">
<img alt="Figure 8.2: Passing values back" height="362" src="image/B20941_08_02.jpg" width="1180"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2: Passing values back</p>
<p>Let’s explore how to implement <span class="No-Break">this scenario:</span></p>
<ol>
<li>First, add the <strong class="source-inline">GoBackAndReturn</strong> method <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">INavigationService</strong></span><span class="No-Break">:</span><pre class="source-code">
Task GoBackAndReturn(Dictionary&lt;string, object&gt;
parameters);</pre><p class="list-inset">By introducing this method, we want to allow a ViewModel to trigger back navigation and pass parameters to the ViewModel of the <span class="No-Break">previous page.</span></p></li> <li>This method is very easy to implement in both <strong class="source-inline">NavigationService</strong> and <strong class="source-inline">NonShellNavigationService</strong>. First, let’s take a look at the implementation<a id="_idIndexMarker590"/> <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">NavigationService</strong></span><span class="No-Break">:</span><pre class="source-code">
public async Task GoBackAndReturn(
    Dictionary&lt;string, object&gt; parameters)
{
    await GoBack();
    if (Shell.Current.CurrentPage.BindingContext
        is INavigationParameterReceiver receiver)
    {
        await receiver.OnNavigatedTo(parameters);
    }
}</pre><p class="list-inset">In this method, we first call the <strong class="source-inline">GoBack</strong> method. Once the back navigation is executed, we check whether <strong class="source-inline">BindingContext</strong> of the current page implements the <strong class="source-inline">INavigationParameterReceiver</strong> interface. If that’s the case, we call its <strong class="source-inline">OnNavigatedTo</strong> method, passing in <span class="No-Break">the parameters.</span></p></li> <li>On <strong class="source-inline">NonShellNavigationService</strong>, this method looks <span class="No-Break">very similar:</span><pre class="source-code">
public async Task GoBackAndReturn(
    Dictionary&lt;string, object&gt; parameters)
{
    await GoBack();
    if(Navigation.NavigationStack.Last()
      .BindingContext
        is INavigationParameterReceiver receiver)
        {
            await receiver.OnNavigatedTo(parameters);
        }
}</pre><p class="list-inset">We are doing the <a id="_idIndexMarker591"/>same thing here as in the <strong class="source-inline">NavigationService</strong>, except we’re not using the Shell APIs to retrieve the current page. Instead, we’re getting the current page <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">NavigationStack</strong></span><span class="No-Break">.</span></p></li> <li>Next, let’s add the method that should navigate to <strong class="source-inline">PickLanguagePage</strong>. Add the <strong class="source-inline">GoToChooseLanguage</strong> method to the <span class="No-Break"><strong class="source-inline">INavigationService</strong></span><span class="No-Break"> interface:</span><pre class="source-code">
Task GoToChooseLanguage(string currentLanguage);</pre></li> <li>In both <strong class="source-inline">ShellNavigationService</strong> and <strong class="source-inline">NonShellNavigationService</strong>, implement the <strong class="source-inline">GoToChooseLanguage</strong> method, <span class="No-Break">like this:</span><pre class="source-code">
public Task GoToChooseLanguage(string currentLanguage)
    =&gt; Navigate("PickLanguagePage",
    new() { { "language", currentLanguage } });</pre><p class="list-inset">The registration of <strong class="source-inline">PickLanguagePage</strong>, its route, and its ViewModel is already done in the <strong class="source-inline">CreateMauiApp</strong> method of the <strong class="source-inline">MauiProgram</strong> class, as <span class="No-Break">shown here:</span></p><pre class="source-code">...
builder.Services.AddTransient&lt;PickLanguagePage&gt;();
builder.Services.AddTransient&lt;PickLanguageViewModel&gt;
  ();
...
Routing.RegisterRoute("PickLanguagePage", 
  typeof (PickLanguagePage));
...
//Non-Shell
//Routes.Register&lt;PickLanguagePage&gt;
//("PickLanguagePage");
//Non-Shell
...</pre></li> <li>Update <strong class="source-inline">PickLanguageViewModel</strong> as it<a id="_idIndexMarker592"/> needs to implement the <strong class="source-inline">INavigationParameterReceiver</strong> interface and needs to get a dependency on the <strong class="source-inline">INavigationService</strong> interface. Here’s how <span class="No-Break">it looks:</span><pre class="source-code">
public class PickLanguageViewModel : ObservableObject,
    <strong class="bold">INavigationParameterReceiver</strong>
{
    <strong class="bold">readonly INavigationService _navigationService;</strong>
    ...
    public PickLanguageViewModel(I
        <strong class="bold">NavigationService navigationService)</strong>
    {
        <strong class="bold">_navigationService = navigationService;</strong>
    }
    <strong class="bold">public async Task OnNavigatedTo(</strong>
<strong class="bold">        Dictionary&lt;string, object&gt; parameters)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        _selectedLanguage =</strong>
<strong class="bold">            parameters["language"] as string;</strong>
<strong class="bold">        OnPropertyChanged(nameof(SelectedLanguage));</strong>
<strong class="bold">    }</strong>
}</pre><p class="list-inset">Note that in the <strong class="source-inline">OnNavigatedTo</strong> method, we’re assigning the _<strong class="source-inline">selectedLanguage</strong> field rather than the <strong class="source-inline">SelectedLanguage</strong> property. This is intentional because <a id="_idIndexMarker593"/>updating the property will immediately invoke the <strong class="source-inline">LanguagePicked</strong> method. We don’t want to trigger this when we set the initial value of this property. Because of that, we need to call <strong class="source-inline">OnPropertyChanged</strong> manually, passing the name of the <span class="No-Break"><strong class="source-inline">SelectedLanguage</strong></span><span class="No-Break"> property.</span></p></li> <li>The <strong class="source-inline">LanguagePicked</strong> method is called when the user selects a new language from the dropdown. This should be where we utilize our new <strong class="source-inline">GoBackAndReturn</strong> method to navigate back and return the selected language. Let’s take <span class="No-Break">a look:</span><pre class="source-code">
private Task LanguagePicked()
{
    return _navigationService.GoBackAndReturn(
        new Dictionary&lt;string, object&gt; {
            { "SelectedLanguage", SelectedLanguage }
        });
}</pre></li> <li>Go to <strong class="source-inline">SettingsViewModel</strong> and make it implement the <span class="No-Break"><strong class="source-inline">INavigationParameterReceiver</strong></span><span class="No-Break"> interface:</span><pre class="source-code">
public class SettingsViewModel :
    ObservableObject, INavigationParameterReceiver</pre><p class="list-inset">Here’s <a id="_idIndexMarker594"/>what the implemented <strong class="source-inline">OnNavigatedTo</strong> method <span class="No-Break">looks like:</span></p><pre class="source-code">public Task OnNavigatedTo(
    Dictionary&lt;string, object&gt; parameters)
{
    if(parameters is not null &amp;&amp;
        parameters.ContainsKey("SelectedLanguage"))
    {
        CurrentLanguage =
            parameters["SelectedLanguage"] as string;
    }
    return Task.CompletedTask;
}</pre><p class="list-inset">This <strong class="source-inline">OnNavigatedTo</strong> method will be called both when navigating “forward” to this ViewModel as well as when navigating “back” to it. The <strong class="source-inline">SelectedLanguage</strong> parameter that’s sent by <strong class="source-inline">PickLanguageViewModel</strong> can be picked <span class="No-Break">up here.</span></p></li> <li><strong class="source-inline">SettingsPageViewModel</strong> also needs to get the <strong class="source-inline">INavigationService</strong> interface injected. <span class="No-Break">Here’s how:</span><pre class="source-code">
Readonly INavigationService _navigationService;
...
public SettingsViewModel(INavigationService service)
{
    _navigationService = service;
...
}</pre></li> <li>Finally, the <strong class="source-inline">ChooseLanguage</strong> method, which gets triggered when the user taps <strong class="bold">Select Language</strong>, needs to trigger navigation to <strong class="source-inline">PickLanguagePage</strong>, as <span class="No-Break">shown here:</span><pre class="source-code">
private async Task ChooseLanguage()
{
    await _navigationService
        .GoToChooseLanguage(CurrentLanguage);
}</pre></li> </ol>
<p>With this update, moving<a id="_idIndexMarker595"/> data between pages is easier and more flexible. Our app now offers smoother user experiences, all thanks to our <span class="No-Break">navigation framework.</span></p>
<h1 id="_idParaDest-144"><a id="_idTextAnchor146"/>Summary</h1>
<p>The fundamental picture of navigation is quite straightforward: a navigation service, which is injected into ViewModels, is utilized to handle navigation. ViewModels can implement specific interfaces, enabling them to receive parameters or be notified about navigation activities, be it from or <span class="No-Break">to them.</span></p>
<p>While the overall idea seems simple, the implementation can be complex, and this is where developers often become puzzled. Fortunately, .NET MAUI Shell streamlines the navigation process in complex UIs, providing a level of ease in the implementation. But as with anything, Shell’s opinionated nature may not suit every application or developer’s preferences. Therefore, we didn’t stop at exploring Shell navigation but also dove into building a navigation service that is not reliant <span class="No-Break">on Shell.</span></p>
<p>Toward the end of this chapter, we looked a bit deeper into passing parameters and results between pages. We demonstrated that by efficiently combining navigation services and ViewModel coordination, we can create a seamless <span class="No-Break">user experience.</span></p>
<p>Navigating through the complexities of .NET MAUI navigation can be a challenge, but with a good understanding of the underlying principles and implementation details, we’re better equipped to handle it. As we move forward, we’ll explore handling user input and validation, diving into how to make our applications <span class="No-Break">more interactive.</span></p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor147"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the <span class="No-Break">following resources:</span></p>
<ul>
<li><em class="italic">.NET MAUI </em><span class="No-Break"><em class="italic">Shell</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/dotnet/maui/fundamentals/shell/"><span class="No-Break">https://learn.microsoft.com/dotnet/maui/fundamentals/shell/</span></a></li>
<li><em class="italic">Prism </em><span class="No-Break"><em class="italic">Library</em></span><span class="No-Break">: </span><a href="https://prismlibrary.com/"><span class="No-Break">https://prismlibrary.com/</span></a></li>
<li><span class="No-Break"><em class="italic">FreshMvvm</em></span><span class="No-Break">: </span><a href="https://github.com/XAM-Consulting/FreshMvvm.Maui"><span class="No-Break">https://github.com/XAM-Consulting/FreshMvvm.Maui</span></a></li>
</ul>
</div>
</div></body></html>