- en: Deploying Your Masterpiece Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we've designed and constructed our application framework, resources, and
    managers, added our Models, Views, and View Models, and after completing the development
    of our application, now it's time for deployment. In this chapter, we'll be looking
    at an overview of the three main methods of deploying WPF applications.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by investigating the original Windows Setup Project method, move
    on to discover the newer InstallShield Limited Edition Project method, and then
    progress to examine the recommended ClickOnce technology.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Windows applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In days gone by, creating a Setup and Deployment project in Visual Studio was
    a confusing and complicated process. However, as with just about everything in
    .NET, successive updates over the years have resulted in ever-improved creation
    methods for these projects.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Setup Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The latest deployment technologies are simpler to use and provide an easily
    understandable method of performing the same steps as the earlier technologies.
    However, in older versions of Visual Studio, we might only have access to the
    older Visual Studio Installer project types, so let''s first investigate the standard
    Setup Project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6164ad0-f5ea-42b6-be6a-b90a3bc57343.png)'
  prefs: []
  type: TYPE_IMG
- en: After adding a Setup Project to the solution, a page opens up showing the file
    system on the target computer. On this File System Editor page, we can specify
    what we would like to install and where. The page is divided into two, with a
    tree View of the folders to be installed on the users' computers on the left and
    their folder contents on the right. By default, the left pane contains the `Application`,
    `Desktop`, and `Program Files` folders.
  prefs: []
  type: TYPE_NORMAL
- en: If we would prefer to use other predefined locations, such as the `Fonts`, `Favorites`,
    or the `Common Files` folders, for example, then we can right-click on the background
    of these panes and select the Add Special Folder option. Typically, we would add
    a standard folder with our company's name into the `User's Programs Menu` folder
    and add a further folder named after our application into that.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we want to install our application as a 64 bit application, then
    we'll need to use this option to add the 64 bit `Program Files` folder to install
    into. To do so, we need to right-click on the File System on Target Machine item
    at the top of the tree View, select the Add Special Folder option, and then select
    the Program Files (64-bit) Folder item.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we should only perform this step if we want to have a 64 bit installation.
    We then need to set the project output of our startup project to the folder in
    the left pane, which represents our installation folder, whether 32 or 64 bit.
  prefs: []
  type: TYPE_NORMAL
- en: We'll need to right-click on that folder and select the Add option and then
    the Project Outputs option from the contextual menu, and then select the Primary
    Output option that relates to our `CompanyName.ApplicationName` project. After
    doing so, we'll see a copy of the executable and other dependent files from its
    `bin` folder being included in our selected application folder.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can create a shortcut to our application on the machine that it was
    installed on by right-clicking the icon for the project output in the right pane
    and selecting the Create Shortcut to Primary output from CompanyName.ApplicationName
    (Active) option from the menu.
  prefs: []
  type: TYPE_NORMAL
- en: We need to give it the same name as our application and set an icon for it,
    which we can do in its Properties window. We can then click and drag, or copy
    and paste it to the `User's Desktop` folder, or to whichever folder we want the
    shortcut to appear in.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the executable and shortcut files, we can right-click a folder
    in the left pane and select the Add option and then the Folder and/or File options
    from the contextual menu and choose any other files that we may need to install
    on the user's computer. Once we have finished configuring the File System Editor,
    we can right-click on the project node in the Solution Explorer and select another
    page to edit from the View menu.
  prefs: []
  type: TYPE_NORMAL
- en: The Registry Editor page is next, and it enables us to make entries in the Windows
    Registry of the host computer. The left window pane acts as the registry View
    of the target computer, and we can use it in the same way as the Registry Editor
    to add new keys. This page also allows us to import registry keys from a `.reg`
    file if we right-click on an empty space and select Import.
  prefs: []
  type: TYPE_NORMAL
- en: The File Types Editor page follows in the View menu and enables us to associate
    any custom file types that we may have created with our application. In doing
    so, after installation, Windows will then open our application whenever a file
    of one of the types specified on this page are clicked.
  prefs: []
  type: TYPE_NORMAL
- en: The Setup Project enables us to display a number of default dialogs during installation,
    such as welcome, confirmation, and completion dialogs. It also provides the ability
    to reorder or remove these default dialogs, or add new ones from a predefined
    list. Each dialog provides an image field and different options, such as whether
    a progress bar should be displayed, or what text to display at different stages
    of the installation. This is achieved on the User Interface page.
  prefs: []
  type: TYPE_NORMAL
- en: The Custom Actions Editor page enables us to specify assemblies that contain
    code in a particular form, that can be run after the application has been installed.
    These actions could be anything, such as popping up a small form and providing
    the user with some configuration options, or simply opening a particular web page
    after installation has completed.
  prefs: []
  type: TYPE_NORMAL
- en: The final option in the View menu of the Setup Project opens the Launch Conditions
    Editor page. Here, we can specify prerequisite conditions that must be satisfied
    in order for the application to be installed. For example, we might require a
    particular version of the .NET Framework to be installed, or the host computer
    to have a particular registry key setting.
  prefs: []
  type: TYPE_NORMAL
- en: Once the project pages have all been appropriately completed, we just need to
    build the Setup and Deployment project to generate the setup files. However, we
    need to ensure that we build it correctly, dependent upon the selections that
    we made on the File System Editor page.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we wanted to have a number of setup projects, let's say including
    32 bit and 64 bit installations, then we need to only build the 32 bit version
    of the Setup Project in the 32 bit solution platform and only build the 64 bit
    version in the 64 bit solution platform.
  prefs: []
  type: TYPE_NORMAL
- en: We can do this in the Configuration Manager in Visual Studio, which we can open
    from the last option in either the solution configuration or solution platform
    drop-down controls. If the `x86` and `x64` solution platforms do not already exist,
    we can add them by selecting the <New...> option from the solution platform drop-down
    control in the Configuration Manager dialog window.
  prefs: []
  type: TYPE_NORMAL
- en: To add the new solution platforms in the New Solution Platform dialog that opens,
    type either `x86` or `x64` in the Type or select the new platform field, select
    the <Empty> option from the Copy settings from drop-down control, and ensure that
    the Create new project platforms tick box is checked.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have these two solution platforms, we can select them one at a time
    in the Active solution platform drop-down control in the Configuration Manager
    dialog window and tick and untick the relevant setup projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot of the `x86` solutions selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a6a52b9-4eaf-4f03-a2e2-25b4af850ff1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is a screenshot of the `x64` solutions selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6584d8a9-5b40-4d88-aade-0001e547b8c8.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that we must select Release in the solution configuration drop-down and
    then build our project to generate the setup files. If we have set up our build
    configuration correctly, then building the `x86` solution platform will generate
    the 32-bit setup files, and building the `x64` solution platform will generate
    the 64 bit setup files.
  prefs: []
  type: TYPE_NORMAL
- en: It can be useful to uncheck the Build tick boxes for our deployment projects
    on all solution platforms when the Active solution configuration is set to Debug.
    Doing this will stop the deployment files from being regenerated every time that
    the solution is built while debugging and will therefore save time during any
    future development.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the InstallShield Limited Edition project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add a Setup Project in a modern version of Visual Studio, we need to select
    the InstallShield Limited Edition Project from the Setup and Deployment project
    type in the Other Project Types category in the left-hand pane of the Add New
    Project dialog window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7934c9fb-2391-48d9-967c-247f442cb1f4.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that this project type is already included with all paid versions of Visual
    Studio, but those who are using a free version may be directed to a website to
    download this functionality upon selection of the project type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it''s installed and the project has been successfully added, a help wizard,
    or a Project Assistant window as InstallShield likes to call it, will be opened
    in Visual Studio to aid the process of configuring the installation project. It
    walks us through the various tasks that we may need to perform when creating our
    installer, page by page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4cb5159-5741-4d22-b836-3195e3228b47.png)'
  prefs: []
  type: TYPE_IMG
- en: Each page is divided into two window panes; the right pane contains the various
    fields that we will edit to set our required specifications for the deployment,
    and the left pane contains additional options and contextual help topics, relevant
    to each page.
  prefs: []
  type: TYPE_NORMAL
- en: The first page of the Project Assistant is the Application Information page,
    where we can provide general information about the application, such as the company
    name and website, the application name and version, and the icon to display with
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: The Installation Requirements page enables us to select one or more particular
    operating systems that our application is compatible with. In addition to this,
    we can also specify that our application has a dependency from a pre-existing
    list of third-party software, such as Adobe Reader, various versions of the .NET
    Framework, and a number of Microsoft products.
  prefs: []
  type: TYPE_NORMAL
- en: While this list is short, it does contain the most likely prerequisite software
    titles. However, there are a couple of additional options, one of which enables
    us to create custom installation requirements. Upon clicking on this option, the
    System Search Wizard opens and lets us search for additional installation requirements,
    either by folder path, registry key, or by `.ini` file value, and enables us to
    choose what happens if the new requirement is not met during the installation
    process.
  prefs: []
  type: TYPE_NORMAL
- en: The Application Files page is next, and in it, we can add any required application
    files to the installation. The page is divided into two, with a tree View of the
    folders to be installed on the users' computers on the left and the folder contents
    on the right. The left pane contains a list of the most commonly used predefined
    folders, such as the `App Data`, `Common`, and `Program Files` folders.
  prefs: []
  type: TYPE_NORMAL
- en: If we need to use other predefined locations, such as the `Desktop`, `Favorites`,
    or the `My Pictures` folders, for example, then we can right-click on an item
    in this pane and select the Show Predefined Folder option. In fact, if we want
    to install our application as a 64 bit application, then we'll need to use this
    option to add the 64 bit `Program Files` folder, in a similar way to the Setup
    Project.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do this, we can right-click on the Destination Computer item at
    the top of the tree View, select the Show Predefined Folder option, and then select
    the `ProgramFiles64Folder` item. We would then need to set the project output
    of our startup project to the folder in the left pane that represents our installation
    folder. Note that it will be suffixed with `[INSTALLDIR]` and, in our case, will
    be named `ApplicationName`.
  prefs: []
  type: TYPE_NORMAL
- en: We should click the Add Project Outputs button and select the Primary Output
    option that relates to our `CompanyName.ApplicationName` project to include a
    copy of the DLLs and other dependent files from its `bin` folder in the deployment.
    We can right-click the added output item to select further properties if required,
    or if we are using COM objects in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Next up is the Application Shortcuts page, where we can control which custom
    shortcuts the installation will include on the users' computer. Note that default
    shortcuts will automatically be added for the executable files that we have specified,
    but this page enables us to delete these, as well as add new ones, or even specify
    uninstallation shortcuts or alternative icons to use.
  prefs: []
  type: TYPE_NORMAL
- en: The Application Registry page follows and enables us to make entries in the
    Windows Registry of the computer that our application is being installed on. The
    left window pane mirrors the registry View of the destination computer and we
    can use it in the same way to add new keys. This page also allows us to import
    registry keys from a `.reg` file and open the registry editor for the source computer.
  prefs: []
  type: TYPE_NORMAL
- en: The last page is the Installation Interview page, where we can specify which
    dialog screens are displayed to the user during the installation. Here, we can
    optionally upload an End User License Agreement file in the **Rich Text Format**
    (**RTF**) file format to require the user to agree to.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we can prompt the user to enter their username and company name
    and provide them with options to select the installation location and whether
    the application should open after the installation is complete. We can also specify
    custom images to be displayed in these dialog windows from this page.
  prefs: []
  type: TYPE_NORMAL
- en: Once the project assistant pages have all been appropriately completed, we just
    need to build the setup and deployment project to generate the setup files. However,
    we need to ensure that we build it correctly, dependent upon the selections that
    we made in the project assistant.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using and focusing the InstallShield Limited Edition Project in the Solution
    Explorer in Visual Studio, we get an extra InstallShield LE menu item, and in
    it, we can find an Open Release folder... option. Clicking this option will open
    a folder window showing the setup project folder, in which we can find the installation
    files to distribute to the users:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97985992-45c1-4fd2-9a16-e84f681117de.png)'
  prefs: []
  type: TYPE_IMG
- en: Utilizing ClickOnce functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ClickOnce is an application deployment technology that enables us to deploy
    applications that can be installed, run, and updated with minimal interaction
    from the end user. In fact, the name ClickOnce comes from the ideal scenario,
    where each application could be installed with a single click.
  prefs: []
  type: TYPE_NORMAL
- en: Each ClickOnce application is deployed into its own self-contained area on the
    host computer, with no access to other applications, rather than in one of the
    standard program files folders that the other deployment technologies use. Furthermore,
    they only grant the exact security permissions required by the application and
    so, can generally also be installed by non-administrative users.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of using ClickOnce is that it enables applications to be installed
    either from a web page, a network folder, or from physical media. We can also
    specify that applications installed using ClickOnce should check for updates at
    regular periods and can be easily updated by the end user, without requiring an
    administrator to be present.
  prefs: []
  type: TYPE_NORMAL
- en: ClickOnce deployments contain an application manifest and a deployment manifest.
    The application manifest contains details of the application, such as its dependencies,
    required security permissions, and the location where updates will be available.
    The deployment manifest contains details of the deployment, such as the location
    of the application manifest and the target version of the application.
  prefs: []
  type: TYPE_NORMAL
- en: ClickOnce is now the preferred method of deploying applications and is built
    right into the project properties of our startup project. We can open the properties
    window by either right-clicking on the `CompanyName.ApplicationName` project in
    the Solution Explorer and selecting the Properties option, by opening the project
    node and double-clicking on the Properties item, or by selecting the project node
    and pressing the *Alt* + *Enter* keys on the keyboard together.
  prefs: []
  type: TYPE_NORMAL
- en: In the project properties window, we can find the ClickOnce configuration fields
    in the Publish tab. In this tab, we can set the location of the publishing folder
    to a network shared folder or FTP server. This represents the location that files
    will be published to. Optionally, we can also specify the location that users
    will install the application from, if that will be different.
  prefs: []
  type: TYPE_NORMAL
- en: We can dictate that the installation mode should make the application available
    online only, like a web application, or offline as well, like a typical desktop
    application. In this section, we also have the Application Files button, which
    opens a dialog window where we can specify which additional files to include in
    the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: All files from the solution that currently get built into the `bin` folder will
    be included by default, but we can exclude them if we prefer. Alternatively, we
    can add new files from the Solution Explorer by setting their Build Action to
    Content in the Properties window. We can also specify whether any executable files
    are prerequisites, or whether any other file types are data files. However this
    is set for us automatically and we do not need to make changes here unless we
    have specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see the Prerequisites button, which opens a dialog window that enables
    us to create a setup program to install any prerequisite components that we may
    have, such as the .NET Framework and the Windows Installer software. If the users'
    computers do not already have the required prerequisites installed, we can specify
    where the installer should access them from. This dialog is also automatically
    populated according to the requirements of the application.
  prefs: []
  type: TYPE_NORMAL
- en: In order to specify that the installed applications should check for updates,
    we can tick the The application should check for updates checkbox in the dialog
    that opens after clicking the Updates button in the Publish tab. We can also specify
    whether this occurs before or after the application starts, or after a certain
    period of time.
  prefs: []
  type: TYPE_NORMAL
- en: In the Application Updates dialog window, we can also stipulate that the application
    should be mandatorily updated to a particular version by ticking the Specify a
    minimum required version for this application checkbox and setting the version.
    Additionally, we can specify a further location that updates can be accessed from,
    if it is different to the publish location.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the Install Mode and Settings section, we come to the Options button,
    which opens the Publish Options dialog window, where we can specify details such
    as the publisher and product names, and deployment and manifest settings, and
    associate our applications with our custom file types so that it will open when
    those file types are clicked.
  prefs: []
  type: TYPE_NORMAL
- en: The Deployment options enable us to specify a web page that users can use to
    download and install our ClickOnce application from, although if we enter `default.html`,
    we can use the default page that is generated for us. We can also specify whether
    the web page should automatically open, or whether the uploaded files should be
    verified after publishing the application.
  prefs: []
  type: TYPE_NORMAL
- en: The final section in the Publish tab is the Publish Version section, where we
    can specify the current version of the application. Rather than update this manually
    each time we publish, we can optionally tick the Automatically increment revision
    with each publish checkbox to update the revision for us.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have two publishing options. The Publish Wizard button opens
    a multi-page dialog window that walks us through many of the more essential options
    described previously and ends with publishing the application. While this is useful
    for the first time that we publish the application, we tend to use the other option,
    the Publish Now button, after that, which simply publishes the application.
  prefs: []
  type: TYPE_NORMAL
- en: Securing deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the Security tab of the project properties window, we can specify the security
    permissions that our application requires. To do so, we can tick the Enable ClickOnce
    security settings checkbox and select whether our application is a full or partial
    trust application.
  prefs: []
  type: TYPE_NORMAL
- en: For a typical desktop application, it is common to specify that it is a full
    trust application, but otherwise we can specify just the trust level that we require.
    Note that unless the application publisher is set as a trusted publisher on the
    end user's computer, they might be required to grant any required permissions
    during installation.
  prefs: []
  type: TYPE_NORMAL
- en: If we specify that our application is a partial trust application, then we can
    either select from pre-configured zones that contain specific groups of permissions,
    or select custom permissions, in which case, we can manually specify our required
    permissions directly in the application manifest file.
  prefs: []
  type: TYPE_NORMAL
- en: Note that even if we have specified our application as a partial trust application,
    we usually have full trust when developing. In order to develop using the same
    permissions that our application requires and therefore see the same errors as
    the users, we can click the Advanced button and tick the Debug this application
    with the selected permission set checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: On the Signing tab of the project properties window, we can optionally digitally
    sign the ClickOnce manifests by ticking the Sign the ClickOnce manifests checkbox.
    If we have a valid certificate that has been persisted in the computer's certificate
    store, then we can select it to sign the ClickOnce manifests using the Select
    from Store button.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, if we have a **Personal Information Exchange** (**PFX**) file,
    we can sign the manifests with it by clicking on the Select from File button and
    selecting it in the file explorer that opens. If we don't currently have a valid
    certificate, we can optionally create one for testing purposes by clicking on
    the Create Test Certificate button.
  prefs: []
  type: TYPE_NORMAL
- en: However, note that a test certificate should not be deployed with a production
    application as they do not contain verifiable information about the publisher.
    When installing the ClickOnce application with a test certificate, users will
    be informed that the publisher cannot be verified and asked to confirm whether
    they really want to install the application. For the peace of mind of the end
    users, a real certificate should be used and a copy stored in their Trusted Publishers
    Certificate Store.
  prefs: []
  type: TYPE_NORMAL
- en: We can also optionally sign the assembly by ticking the Sign the assembly checkbox
    and selecting a **Strong Name Key** (**SNK**) file from the associated drop-down
    control. If we haven't previously selected one, we can add a new one from the
    same drop-down control.
  prefs: []
  type: TYPE_NORMAL
- en: This completes the summary of the configuration pages used for a ClickOnce deployment.
    They provide practically the same settings as the other deployment technologies,
    except those to do with the location of the installed files and the security permissions
    that may be required to install. Let's now look at how we can safely store files
    on the host computer in non-full trust applications.
  prefs: []
  type: TYPE_NORMAL
- en: Isolating storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the reasons why ClickOnce can be installed directly by the end users
    without the need for administrator assistance is because it is installed into
    a self-contained ecosystem that's separate from all other programs and, in general,
    isolated from the rest of the user's computer.
  prefs: []
  type: TYPE_NORMAL
- en: When we need to store data locally, we can run into security problems if we
    have not specified our application as a full trust application. In these situations,
    we can take advantage of isolated storage, which is a data storage mechanism that
    abstracts the actual location of the data on the hard drive, which remains unknown
    to both users and developers.
  prefs: []
  type: TYPE_NORMAL
- en: When we use isolated storage, the actual data compartment where the data is
    stored is generated from some aspects of each application so that it is unique.
    The data compartment contains one or more isolated storage files called stores,
    which reference where the actual data is stored. The amount of data that can be
    stored in each store can be limited by code in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual physical location of the files will differ, depending upon the operating
    system running on the user''s computer and whether the store has roaming enabled
    or not. For all operating systems since Vista, the location is in the hidden `AppData`
    folder in the user''s personal user folder. Within this folder, it will either
    be found in the `Local` or `Roaming` folders, depending on the store''s settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can store any type of file in isolated storage, but as an example, let''s
    take a look at how we could utilize it to store text files. Let''s first see the
    interface that we will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And now let''s see the concrete implementation for the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As with the other manager classes, we declare the `HardDriveManager` class in
    the `CompanyName.ApplicationName.Managers` namespace. In the private `GetIsolatedStorageFile`
    method, we obtain the `IsolatedStorageFile` object that relates to the isolated
    storage store that we will save the user's data in by calling the `GetStore` method
    of the `IsolatedStorageFile` class.
  prefs: []
  type: TYPE_NORMAL
- en: This method has a number of overloads that enable us to specify the scope, application
    identity, evidence, and evidence types with which to generate the unique isolated
    storage file. In this example, we use the overload that takes the bitwise combination
    of the `IsolatedStorageScope` enumeration members and the domain and assembly
    evidence types, which we simply pass `null` for.
  prefs: []
  type: TYPE_NORMAL
- en: The scope input parameter here is interesting and requires some explanation.
    Isolated storage is always restricted to the user that was logged on and using
    the application when the store was created. However, it can also be restricted
    to the identity of the assembly, or to the assembly and application domain together.
  prefs: []
  type: TYPE_NORMAL
- en: When we call the `GetStore` method, it obtains a store that corresponds with
    the passed input parameters. When we pass the `User` and `Assembly` `IsolatedStorageScope`
    enumeration members, this acquires a store that can be shared between applications
    that use the same assembly, when used by the same user. Typically, this is allowed
    under the Intranet security zone, but not the Internet zone.
  prefs: []
  type: TYPE_NORMAL
- en: When we pass the `User`, `Assembly`, and `Domain` `IsolatedStorageScope` enumeration
    members, this acquires a store that can only be accessed by the user, when running
    the application that was used to create the store. This is the default and most
    common choice for most applications, and so these are the enumeration members
    that were used in our example.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if we had wanted to enable the user to use roaming profiles but still
    be able to access their data from their isolated storage file, then we could have
    additionally included the `Roaming` enumeration member with the other members.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to the `HardDriveManager` class now, in the `SaveTextFile` method,
    we first call the `GetIsolatedStorageFile` method to obtain the `IsolatedStorageFile`
    object. We then initialize an `IsolatedStorageFileStream` object with the filename
    specified by the `filePath` input parameter, the `OpenOrCreate` member of the
    `FileMode` enumeration and the storage file object.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we initialize a `StreamWriter` object with the `IsolatedStorageFileStream`
    variable and write the data from the `fileContents` input parameter to the file
    specified in the stream using the `Write` method of the `StreamWriter` class.
    Again, we enclose this in a `try...catch` block and would typically log any exceptions
    that might be thrown from this method, but omit this here for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: In the `ReadTextFile` method, we initialize the `fileContents` variable to an
    empty string and then obtain the `IsolatedStorageFile` object from the `GetIsolatedStorageFile`
    method. We verify that the file specified by the `filePath` input parameter actually
    exists before attempting to access it.
  prefs: []
  type: TYPE_NORMAL
- en: We then initialize an `IsolatedStorageFileStream` object with the filename specified
    by the `filePath` input parameter, the `Open` member of the `FileMode` enumeration,
    and the isolated storage file.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we initialize a `StreamReader` object with the `IsolatedStorageFileStream`
    variable and read the data from the file specified in the stream into the `fileContents`
    input parameter using the `Read` method of the `StreamReader` object. Once again,
    this is all enclosed in a `try...catch` block, and finally, we return the `fileContents`
    variable with the data from the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use it, we must first register the connection between the interface
    and our runtime implementation with our `DependencyManager` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can expose a reference to the new `IHardDriveManager` interface from
    our `BaseViewModel` class and resolve it using the `DependencyManager` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use it to save files to, or read files from, isolated storage from
    any View Model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Realistically, if we were to save user preferences in this way, they would typically
    be in an XML file, or in another format that is more easily parsed. However, for
    the purposes of this example, a plain string will suffice.
  prefs: []
  type: TYPE_NORMAL
- en: 'As well as saving and loading files in an isolated storage store, we can also
    delete them and add or remove folders to better organize the data. We can add
    further methods to our `HardDriveManager` class and `IHardDriveManager` interface to
    enable us to manipulate the files and folders from within the user''s isolated
    storage store. Let''s take a look at how we can do this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Quite simply, the `DeleteFile` method accesses the `IsolatedStorageFile` object
    from the `GetIsolatedStorageFile` method and then calls its `DeleteFile` method,
    passing in the name of the file to delete, which is specified by the `filePath`
    input parameter, within another `try...catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, the `CreateFolder` method obtains the `IsolatedStorageFile` object
    from the `GetIsolatedStorageFile` method and then calls its `CreateDirectory`
    method, passing in the name of the folder to create, specified by the `folderName`
    input parameter, within a `try...catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the `DeleteFolder` method acquires the `IsolatedStorageFile` object
    by calling the `GetIsolatedStorageFile` method and then calls its `DeleteDirectory`
    method, passing in the name of the folder to delete, which is specified by the
    `folderName` input parameter, within another `try...catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s adjust our previous example to demonstrate how we can use this
    new functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this extended example, we first create a folder named `Preferences` in the
    isolated storage store and then save the text file in that folder by prefixing
    the filename with the name of the folder and separated from the name with a forward
    slash.
  prefs: []
  type: TYPE_NORMAL
- en: At a later stage, we can then read back the contents of the file by passing
    in the same file path to the `ReadTextFile` method. If we need to clear up the
    store afterward, or if the file was temporary, we can delete it by passing the
    same file path to the `DeleteFile` method. Note that we must first delete the
    contents of a folder in the store before we can delete the folder itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note that we can create subdirectories in the isolated storage store by
    chaining their names in the file path. For example, we can create a `Login` folder
    in the folder named `Preferences` by simply appending the subdirectory name to
    the end of the parent folder name and separating them with a forward slash again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This concludes our look into isolated storage files in .NET. But before we end
    this chapter, let's briefly turn our attention to discover how to access our various
    application versions and, indeed, what they all relate to.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing application versions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In .NET, an application has a number of different versions, and so we have
    a number of alternative ways to access them. The version number that we discussed
    earlier and is displayed in the Publish Version section of the Publish tab of
    the project properties can be found using the `ApplicationDeployment` class from
    the `System.Deployment` DLL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that we need to verify that the application has actually been deployed
    before we can access the `CurrentVersion` property of the `ApplicationDeployment`
    class, otherwise an `InvalidDeploymentException` will be thrown. This means that
    we cannot attain the published version while debugging our WPF applications, and
    so we should return some other value instead in these instances.
  prefs: []
  type: TYPE_NORMAL
- en: In order to view the remaining application versions, we first need to access
    the assembly that we want to know the version of. The code that we use to access
    the assembly will depend on where in the code we currently are. For example, we
    typically want to display the version of the startup assembly, but we may want
    to access it from a View Model in the `ViewModels` project instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a number of ways of accessing assemblies, depending on where they are
    in relation to the calling code. If we want to access the startup assembly from
    the startup project, then we can use the `Assembly.GetExecutingAssembly` method
    after adding `using` statements for the following namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To access the same assembly from a different project, we can use the `Assembly.GetEntryAssembly`
    method. Alternatively, we can access the startup project's assembly from a different
    project (if that project was called from the startup assembly) using the `Assembly.GetCallingAssembly`
    method. For the remaining examples here, we'll use the `GetEntryAssembly` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the published version, we may also need to access the application''s
    assembly or file versions. The assembly version that we can set in the Assembly
    Information dialog window, which is accessible from the Application tab of the
    project properties window, can be accessed from the assembly using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The assembly version is used by the .NET Framework to load and link references
    to other assemblies at build and runtime. This is the version that is embedded
    when adding references to our projects in Visual Studio and if an incorrect version
    is found during a build, then an error will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we can also set this value using the assembly level `AssemblyVersionAttribute`
    class in the `AssemblyInfo.cs` file of the project, which can be found in the
    Properties node of the project in the Solution Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of converting the returned `Version` object to a `string` directly,
    we may prefer to access the individual components that make up the version number.
    They comprise the Major, Minor, Build, and Revision component values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could then chose to just output the Major and Minor components, along with
    the product name. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need the file version, which is used for non-ClickOnce deployments, we
    can pass the location of the assembly to the `GetVersionInfo` method of the `FileVersionInfo`
    class, as shown in the preceding code in the product name example, but access
    the `FileVersion` property instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we can also set this value in the Assembly Information dialog window,
    or by using the assembly level `AssemblyFileVersionAttribute` class in the `AssemblyInfo.cs`
    file of the project. This version can be seen in the Details tab of the file properties
    dialog window in Windows Explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4bfa08e4-bd61-4a19-b228-a56bb7bd766a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The product version that the assembly is distributed with can be accessed in
    a similar way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that this version can also be seen in the Details tab of the file properties
    dialog window in Windows Explorer, along with the product name that we accessed
    earlier. Also note that in a WPF application, this value typically comes from
    the assembly file version.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored a number of different ways to deploy our WPF applications.
    We looked over the older Setup Project type and the InstallShield Limited Edition
    Project type, but focused primarily on the newer ClickOnce technology. We investigated
    how ClickOnce deployments are made and how we can safely store and access data
    in isolated storage. We ended by looking at a number of ways to access the various
    application versions available to us in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: In the final chapter of this book, we'll take a look at a summary of what has
    been covered throughout this book and investigate what you can do next to continue
    this journey. We'll suggest a few possible ways that you could extend our application
    framework further and what you can do to advance your application development
    in general.
  prefs: []
  type: TYPE_NORMAL
