<html><head></head><body>
        

                            
                    <h1 class="header-title">Singleton</h1>
                
            
            
                
<p>The Singleton is the most infamous pattern in the industry, but ironically, it's very popular with Unity developers. In consequence, it has become somewhat the duct tape of programmers, overused as a quick fix instead of a cornerstone of a robust architecture. There are many ways to implement a Singleton, from the simple but unsafe to the complicated but robust; we will go with the latter, because if we need to implement an unpopular pattern, let's do it in a way that won't backfire on us.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>The basics of the Singleton's pattern</li>
<li>Implementing the perfect Singleton in Unity</li>
</ul>
<p>Programmers love to argue, sometimes to the point of paralysis, so it's important never to become religious about design patterns. Always remember that there's no perfect solution; every design decision you make will have trade-offs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p class="mce-root">This is a hands-on chapter; you will need to have a basic understanding of Unity and C#.</p>
<p>We will be using the following specific Unity engine and C# language concept:</p>
<ul>
<li>Generics</li>
</ul>
<p>If unfamiliar with this concept, please review them before starting this chapter.</p>
<p>The code files of this chapter can be found on GitHub:</p>
<p><a href="https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018">https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018</a></p>
<p class="mce-root">Check out the following video to see the code in action:</p>
<p><a href="http://bit.ly/2YwBVEv">http://bit.ly/2YwBVEv</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">An overview of the Singleton pattern</h1>
                
            
            
                
<p class="mce-root">As its name implies, the Singleton pattern's main goal is to guarantee a singularity. This approach means if a class implements this pattern correctly, once initialized, it will have only one instance of itself in memory during runtime. This mechanism can be useful when you have a class that manages a system that needs to be globally accessible from a singular entry point.</p>
<p class="mce-root">As we can see from the following diagram, the Singleton's design is quite simple; unlike the Prototype pattern, a class implemented as a Singleton doesn't make a copy of itself but only returns its current instance to a client that's requesting it:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a1c31bad-1e47-410b-9f00-f2c1c141a7d1.png" style="width:26.83em;height:32.67em;"/></p>
<p>And if correctly implemented, a Singleton instance will even destroy any other instances of itself, just in case someone is trying to duplicate it. In other words, there can only be one. But we will see further in this chapter, implementing a solid Singleton in Unity is not as easy as it looks.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Benefits and drawbacks</h1>
                
            
            
                
<p>The Singleton is a very controversial pattern; it's disliked by many because Unity developers frequently misuse it. If this contempt for this pattern is justified, I would say yes, but only to a certain degree. Instead of listing all the potential benefits and drawbacks of this pattern, I will present only one advantage and disadvantage; both are what I find to be the best arguments for or against the use of this pattern.</p>
<p>This is the benefit:</p>
<ul>
<li><strong>A singular point of entry</strong>: The Singleton offers a singular but global access point to an instance of itself. This mechanism makes it easier to access dependencies that are exposed by a Singleton instance.</li>
</ul>
<p>This is the drawback:</p>
<ul>
<li><strong>Obfuscation of dependencies</strong>: Singletons are often used as <em>duct tape</em> to simplify access to complex interlocked dependencies. It's an easy solution that prevents the weeding out of wrong architecture choices.</li>
</ul>
<p>So, taking into account these two arguments, there's a simple question we must ask when deciding to use a Singleton; is it because it's needed and fits with our overall architecture, or are we using it because it's a quick solution to a complex problem? From our answer, we can determine whether we are smart or just lazy with our design choices.</p>
<p>When you are making design choices, it's important to always keep in mind whether your architecture is maintainable, scalable, and testable. If you can't individually test your modules, it's a good indication that your design has made your code base coupled and dependent on global dependencies.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Use case example</h1>
                
            
            
                
<p>We must take into consideration that most games are made up of a collection of levels but each level includes a sequence of events during its lifespan, such as the following:</p>
<ul>
<li>Loading of previous save</li>
<li>Triggering of introductory sequence</li>
<li>Spawning of environment and characters</li>
<li>Managing runtime game states</li>
<li>Triggering the end scene sequence</li>
<li>Save current player stats</li>
<li>Trigger next level</li>
</ul>
<p>To be able to manage this, we will need a Game Manager that will be active throughout the entire life span of a scene. As an analogy, if we look at the classic pen-and-paper version of Dungeons and Dragons, there's usually a Game Master that moderates and overlooks the flow of the game so the players can have a consistent but structured experience.</p>
<p>So, for our use case, we will need something similar but, of course, not as sophisticated as a human Game Master. The Singleton is a perfect pattern to implement a GM because it offers us a way to write a class as a singular but global entity that will accessible throughout the runtime of our game.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Code example</h1>
                
            
            
                
<p>In this section, we will explore two versions of an implementation of the Singleton pattern in Unity. The first example is unsafe but straightforward. The second is advanced but more robust, as indicated at the beginning of this chapter.<br/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Simple approach</h1>
                
            
            
                
<p>Let's start by reviewing a simple way of implementing the Singleton in Unity. We have to keep in mind that we don't have access to a constructor when we use <kbd>MonoBehaviours</kbd>, so we will need to control the initialization of any member variables in the <kbd>Awake()</kbd> magic function, as follows:</p>
<pre>using UnityEngine;<br/><br/>public class GameManager: MonoBehaviour <br/>{<br/>    public static GameManager instance;<br/><br/>    void Awake()<br/>    {<br/>        instance = this;<br/>    }<br/><br/>    public void InitializeScene()<br/>    {<br/>        // Load persistent game state variables from the save system.<br/>        // Load game systems and dependencies.<br/>    }<br/>}</pre>
<p>As we can see, we have only one member, and it's static and public, which will make it easier for our clients to refer to it. In our <kbd>Awake()</kbd>, we pass our current <kbd>this</kbd> instance to the public static instance variable. This approach means our clients will have one constant and persistent access point to our <kbd>GameManager</kbd>, as seen in the following code snippet:</p>
<pre>using UnityEngine;<br/><br/>public class Client: MonoBehaviour<br/>{<br/>    void Start()<br/>    {<br/>        GameManager.instance.InitializeScene();<br/>    }<br/>}</pre>
<p>It looks pretty simple. We need to refer to the static instance member of the <kbd>GameManager</kbd> class, and we can call at any point its public functions. But there's one huge problem: this is not a Singleton for the reason that there's no mechanism in place that avoids having two instances of this object in memory.</p>
<p>We just implemented an interface to an instance of a global manager, but we are not protecting it from duplication in memory or preserving its integrity. Let's see whether we can do better with the next example:</p>
<pre>using UnityEngine;<br/><br/>public class GameManager: MonoBehaviour <br/>{<br/>    public static GameManager _instance;<br/><br/>    void Awake()<br/>    {<br/>        if (_instance == null)<br/>        {<br/>            // Assigning only if there's no other instances in memory.<br/>            _instance = this; <br/>        }<br/>        else if (_instance != null)<br/>        {<br/>            // Destroying itself if detects duplication.<br/>            Destroy(gameObject) <br/>        }<br/>    }<br/>}</pre>
<p>Now, this is getting better. We are at least checking for <kbd>null</kbd> references before assigning the <kbd>_instance</kbd> static member, and avoiding potential duplicated instances of our <kbd>GameManager</kbd> by destroying them at the moment they <em>awake</em>.</p>
<p>This approach seems valid, but there's nothing that will guarantee consistency if you decide to have multiple classes implemented as Singletons. You might have one programmer writing a Singleton one way and another writing entirely differently. In the long run, this nullifies one of the fundamental benefits of design patterns; consistency in the architecture.</p>
<p>In the next section, we will look at a potential candidate for an advanced Singleton implementation that can become a pillar for our code base and offer us complete re-usability.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Advanced approach</h1>
                
            
            
                
<p>The following class is an example of a complete Singleton implementation, but there's a lot to unpack here, so we are going to try to focus on the following essential elements:</p>
<pre>using UnityEngine;<br/><br/>// &lt;T&gt; can be any type.<br/>public class Singleton&lt;T&gt; : MonoBehaviour where T : Component<br/>{<br/>    // The instance is accessible only by the getter.<br/>    private static T m_Instance; <br/>    public static bool m_isQuitting;<br/><br/>    public static T Instance<br/>    {<br/>        get<br/>        {<br/>            if (m_Instance == null)<br/>            {<br/>                // Making sure that there's not other instances <br/>                // of the same type in memory. <br/>                m_Instance = FindObjectOfType&lt;T&gt;();<br/><br/>                if (m_Instance == null)<br/>                {<br/>                    // Making sure that there's not other instances <br/>                    // of the same type in memory.<br/>                    GameObject obj = new GameObject();<br/>                    obj.name = typeof(T).Name;<br/>                    m_Instance = obj.AddComponent&lt;T&gt;();<br/>                }<br/>            }<br/>            return m_Instance;<br/>        }<br/>    }<br/><br/>    // Virtual Awake() that can be overridden in a derived class.<br/>    public virtual void Awake()<br/>    {<br/>        if (m_Instance == null)<br/>        {<br/>            // If null, this instance is now the Singleton instance <br/>            // of the assigned type. <br/>            m_Instance = this as T;<br/><br/>            // Making sure that my Singleton instance <br/>            // will persist in memory across every scene.<br/>            DontDestroyOnLoad(this.gameObject);<br/>        }<br/>        else<br/>        {<br/>            // Destroy current instance because it must be a duplicate.<br/>            Destroy(gameObject);<br/>        }<br/>    }<br/>}</pre>
<p>In this example, we are introducing <strong>Generics</strong>, a compelling C# feature that permits us to defer the type of a class at runtime. When we say a class is generic, it means that it doesn't have a defined object type. This approach is advantageous because we can assign it a specific type when we initialize it. In other words, it can become anything we want, and this could solve a core issue we are having with Singletons, which is the consistency of implementation between our classes that are Singletons.</p>
<p class="mce-root"/>
<p>Let's apply our generic Singleton class to a couple of Managers and see how we maintain uniformity in the way we write Singleton classes, as follows:</p>
<pre>using UnityEngine;<br/><br/>// Inheriting Singleton and specifying the type.<br/>public class GameManager : Singleton&lt;GameManager&gt;<br/>{<br/>    public void InitializeGame()<br/>    {<br/>        Debug.Log("Initializing the game.");<br/>    }<br/>}</pre>
<p>As we can see, by inheriting the Singleton parent class, we have made our <kbd>GameManager</kbd> into a Singleton with one line of code (<kbd>Singleton&lt;GameManager&gt;</kbd>). This mechanism is possible because our parent class has all the core components of a Singleton.</p>
<p>Next up is another example of a <kbd>Manager</kbd> class converted into a Singleton with one simple line of code:</p>
<pre>using UnityEngine;<br/><br/>// Inheriting the Singleton and specifying it's type.<br/>public class InventoryManager : Singleton&lt;InventoryManager&gt; <br/>{<br/>    public void AddItem(int itemID)<br/>    {<br/>        Debug.Log("Adding item to the inventory.");<br/>    }<br/><br/>    public void RemoveItem(int itemID)<br/>    {<br/>        Debug.Log("Removing item to the inventory.");<br/>    }<br/>}</pre>
<p>We can test our new Singletons with the following <kbd>Client</kbd> class:</p>
<pre>using UnityEngine;<br/><br/>public class Client : MonoBehaviour<br/>{<br/>    void Update()<br/>    {<br/>        if (Input.GetKeyDown(KeyCode.I))<br/>        {<br/>            GameManager.Instance.InitializeGame();<br/>        }<br/><br/>        if (Input.GetKeyDown(KeyCode.A))<br/>        {<br/>            InventoryManager.Instance.AddItem(001);<br/>        }<br/><br/>        if (Input.GetKeyDown(KeyCode.R))<br/>        {<br/>            InventoryManager.Instance.RemoveItem(023);<br/>        }<br/>    }<br/>}</pre>
<p>Now that we have found a structured and reusable approach to the implementation of the Singleton pattern, we can safely integrate it into our code base while keeping in mind not to overuse it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we tackled one of the most controversial design patterns out there. But we found a way to implement with a consistent and reusable approach. Even if the debate around the Singleton's usefulness persists, we can see how it can be beneficial for Unity developers.</p>
<p>We have completed the creational pattern section of the book, and now we have three core patterns in our toolkit, each with a specific function:</p>
<ul>
<li>The Prototype pattern offers us a way to create objects by copying them from a reference</li>
<li>The Abstract pattern enforces the localization of the creation process of objects</li>
<li>The Singleton offers a way to implement a mechanism that guarantees one singular instance of an object in memory</li>
</ul>
<p>In the next chapter, we will transition out from Creational to Behavioral patterns. The first on our list is the Strategy pattern, a classic pattern that focuses on the dynamic selection of algorithms at runtime.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Exercise</h1>
                
            
            
                
<p class="mce-root">The main issue with the Singleton pattern is that its instance is globally accessible and persistent, so if any component that has dependencies related to a Singleton object, it cannot be tested as an isolated unit. But in the real world, code bases are never perfect, and programmers often use Singletons.<br/>
<br/>
So, you need to find a way to maintain proper unit testing best practices even when dealing with an architecture that is heavily dependent on global Singleton instances. So, as an exercise, I would recommend reading up on <strong>test-driven development</strong> (<strong>TDD</strong>) practices, especially core concepts such as <strong>Stubs</strong> and <strong>Mocks</strong>.</p>
<p>TDD is beyond the scope of this book, so please refer to the <em>Further reading</em> section for more information on the subject.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<ul>
<li><em>Test Driven Development: By Example</em> by Kent Beck<strong><br/></strong><a href="https://www.pearson.com/us/higher-education/program/Beck-Test-Driven-Development-By-Example/PGM206172.html">https://www.pearson.com/us/higher-education/program/Beck-Test-Driven-Development-By-Example/PGM206172.html</a></li>
<li><em>Real World: Test-Driven Development</em> by Mauricio Aniche<strong><br/></strong><a href="https://www.goodreads.com/book/show/24400837-real-world-test-driven-development">https://www.goodreads.com/book/show/24400837-real-world-test-driven-development</a></li>
</ul>


            

            
        
    </body></html>