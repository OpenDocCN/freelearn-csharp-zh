- en: Overview of OOP in .NET Core and C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For over 20 years, the most popular programming languages have been based on
    the principles of **object-oriented programming** (**OOP**). The rise in popularity
    of OOP languages is largely to do with the benefits of being able to abstract
    complex logic into a structure, called an object, that can be more easily explained,
    and, more importantly, reused within an application. In essence, OOP is a software
    design approach, that is, a pattern for developing software using the concept
    of objects that contain data and functionality. As the software industry matured,
    patterns appeared in OOP for commonly occurring problems, as they were effective
    in solving the same problems but across different contexts and industries. As
    software moved from the mainframe to client servers and then to the cloud, additional
    patterns have emerged to help in reducing development costs and improving reliability.
    This book will explore design patterns, from the foundation of OOP to the architecture
    design patterns for cloud-based software.
  prefs: []
  type: TYPE_NORMAL
- en: OOP is based on the concept of an object. This object generally contains data,
    referred to as properties and fields, and code or behavior referred to as methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**Design patterns** are solutions to general problems that software programmers
    face during development, and are built from the experience of what works and what
    doesn''t. These solutions are trialed and tested by numerous developers in various
    situations. The benefits of using a pattern based on this previous activity ensure
    that the same efforts are not repeated again and again. In addition to this, using
    a pattern adds a sense of reliability that the problem will be solved without
    introducing a defect or issue.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter reviews OOP and how it applies to C#. Note that this is simply
    intended as a brief introduction and it is not meant to be a complete primer for
    OOP or C#; instead, the chapter will cover aspects of both in enough detail to
    introduce you to the design patterns that will be covered in subsequent chapters.
    This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A discussion of OOP and how classes and objects work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter contains various code examples to explain these concepts. The code
    is kept simple and is just for demonstration purposes. Most of the examples involve
    a .NET Core console application written in C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run and execute the code, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2019 (you can also run the application using Visual Studio 2017
    version 3 or later)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL Server (the Express Edition is used in this chapter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to run these code examples, you will need to install Visual Studio
    or later (you can also use your preferred IDE). To do this, follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download Visual Studio from the following link: [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the installation instructions included in the link. Multiple versions
    of Visual Studio are available; in this chapter, we are using Visual Studio for
    Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you do not have .NET Core installed, you will need to follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download .NET Core from the following link: [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Follow the installation instructions in the related library: [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The complete source code is available in GitHub. The source code shown in the
    chapter might not be complete, so it is recommended that you retrieve the source
    code in order to run the examples ([https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter1](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter1)).
  prefs: []
  type: TYPE_NORMAL
- en: The models used in this book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a learning aid, this book will contain many code samples in C# alongside
    diagrams and images to help describe specific concepts where possible. This is
    not a **Unified Modeling Language** (**UML**) book; however, for those with a
    knowledge of UML, many of the diagrams should seem familiar. This section provides
    a description of the class diagrams that will be used in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, a class will be defined as including both fields and methods separated
    by a dashed line. If important to the discussion, then accessibility will be indicated
    as `-` for private, `+` for public, `#` for protected, and `~` for internal. The
    following screenshot illustrates this by showing a `Car` class with a private
    `_name` variable and a public `GetName()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d37335f-9e59-494a-bdf4-67d30cd832d0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When showing relationships between objects, an association is shown with a
    solid line, an aggregation is shown with an open diamond, and a composition is
    shown with a filled diamond. When important to the discussion, multiplicity will
    be shown next to the class in question. The following diagram illustrates the
    `Car` class as having a single **Owner**, and up to three **Passengers**; it consists
    of four **Wheels**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc1fc18d-dc06-4b38-ae24-f7898b19c050.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Inheritance** is shown using an open triangle on the base class using a solid
    line. The following diagram shows the relationship between an `Account` base class
    and the `CheckingAccount` and `SavingsAccount` child classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fe47763-223e-4667-8003-38f5116f7c82.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Interfaces** are shown in a similar manner to inheritance, but they use a
    dashed line as well as an additional `<<interface>>` label, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9fa7abd-7fda-4877-acf8-971a8c3fc429.png)'
  prefs: []
  type: TYPE_IMG
- en: This section provides an overview of the models used in this book. This style/approach
    was chosen because, hopefully, it will be familiar to the majority of readers.
  prefs: []
  type: TYPE_NORMAL
- en: OOP and how classes and objects work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OOP refers to a software programming approach that uses objects defined as classes.
    These definitions include fields, sometimes called attributes, to store data and
    methods in order to provide functionality. The first OOP language was a simulation
    of real systems known as Simula ([https://en.wikipedia.org/wiki/Simula](https://en.wikipedia.org/wiki/Simula))
    and was developed at the Norwegian Computing Center in 1960\. The first pure OOP
    language came into existence in 1970 as the Smalltalk ([https://en.wikipedia.org/wiki/Smalltalk](https://en.wikipedia.org/wiki/Smalltalk))
    language. This language was designed to program the Dynabook ([http://history-computer.com/ModernComputer/Personal/Dynabook.html](http://history-computer.com/ModernComputer/Personal/Dynabook.html)),
    which is a personal computer created by Alan Kay. Several OOP languages evolved
    from there, with the most popular being Java, C++, Python, and C#.
  prefs: []
  type: TYPE_NORMAL
- en: OOP is based on objects that contain data. The OOP paradigm allows developers
    to arrange/organize code into an abstract or logical structure called an object.
    An object can contain both data and behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the use of the OOP approach, we are doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modularizing**: Here, an application is decomposed into different modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusing the software**: Here, we rebuild or compose an application from different
    (that is, existing or new) modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will discuss and understand the concepts of OOP
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, programming approaches had limitations and they often became difficult
    to maintain. OOP offered a new paradigm in software development that had advantages
    over other approaches. The concept of organizing code into objects is not difficult
    to explain and this is a huge advantage for the adoption of a new pattern. Many
    examples can be taken from the real world in order to explain the concept. Complex
    systems can also be described using smaller building blocks (that is, an *objects*).
    These allow developers to look at sections of the solution individually while
    understanding how they fit into the entire solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, let''s define a program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A program is a list of instructions that instructs the language compiler on
    what to do."'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, an object is a way of organizing a list of instructions in a
    logical manner. Going back to the example of the house, the architect's instructions
    help us to build a house, but they are not the house itself. Instead the architect's
    instructions are an abstract representation of a house. A class is similar as
    it defines the features of an object. An object is then created from the definition
    of a class. This is often called **instantiating the object***.*
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand OOP more closely, we should mention two other significant programming
    approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Structured programming**: This is a term coined by Edsger W. Dijkstra in
    1966\. Structured programming is a programming paradigm that solves a problem
    to handle 1,000 lines of code and divides these into small parts. These small
    parts are mostly called **subroutines**, **block structures**, **for** and **while**
    loops, and more. Languages that use structured programming techniques include
    ALGOL, Pascal, PL/I, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Procedural programming**: This is a paradigm derived from structured programming
    and is simply based on how we make a call (also known as a **procedu****ral call**).
    Languages that use procedural programming techniques include COBOL, Pascal, and
    C. A recent example of the Go programming language was published in 2009.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Procedural calls
  prefs: []
  type: TYPE_NORMAL
- en: A procedural call is where a collection of statements, known as a *procedure*,is
    activated. This is sometimes referred to as a procedure that is *invoked*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main problem with these two approaches is that programs are not easily
    manageable once they grow. Programs with more complex and larger code bases strain
    these two approaches, leading to difficult-to-understand and difficult-to-maintain
    applications. To overcome such problems, OOP provides the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will discuss these features in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance, encapsulation, and polymorphism are sometimes referred to as the
    three pillars of OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Before we begin, let's discuss some structures that are found in OOP.
  prefs: []
  type: TYPE_NORMAL
- en: A class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **class** is a group or template definition of the methods and variables that
    describe an object. In other words, a class is a blueprint, containing the definition
    of the variables and the methods that are common to all instances of the class
    called objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have a `PetAnimal` class that has two private fields
    called `PetName` and `PetColor`, and one method called `MyPet()`.
  prefs: []
  type: TYPE_NORMAL
- en: An object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the real world, objects share two characteristics, that is, state and behavior.
    In other words, we can say that every object has a name, color, and more; these
    characteristics are simply the state of an object. Let''s take the example of
    any type of pet: a dog and a cat will both have a name by which they called. So,
    in this way, my dog is named Ace and my cat is named Clementine. Similarly, dogs
    and cats have specific behaviors, for example, dogs barks and cats meow.'
  prefs: []
  type: TYPE_NORMAL
- en: In the *Explaining OOP* section, we discussed that OOP is a programming model
    that is supposed to combine a state or structure (data) and the behavior (method)
    to deliver software functionality. In the previous example, the different states
    of pets make up the actual data, while the behavior of the pets is the method.
  prefs: []
  type: TYPE_NORMAL
- en: An object stores the information (which is simply data) in attributes and discloses
    its behavior through methods.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of an OOP language such as C#, an object is an instance of a class.
    In our previous example, the real-world object, `Dog`, would be an object of the
    `PetAnimal` class.
  prefs: []
  type: TYPE_NORMAL
- en: Objects can be concrete (that is, a real-world object, such as a dog or cat,
    or any type of file, such as physical file or a computer file) or they can be
    conceptual, such as database schemas or code blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how an object contains data and a method,
    and how you can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code snippet, we have created two objects: `dog` and `cat`.
    These objects are two different instances of a `PetAnimal` class. You can see
    that the fields or properties that contain data about the animal are given values
    using the constructor method. The constructor method is a special method used
    to create an instance of the class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s visualize this example in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/831ba13f-467e-4a85-9819-0d19dad2a714.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram is a pictorial representation of our previous code example,
    where we created two different `Dog` and `Cat` objects of the `PetAnimal` class.
    The diagram is relatively self-explanatory; it tells us that the object of `Dog`
    class is an instance of the `PetAnimal` class, as is the `Cat` object.
  prefs: []
  type: TYPE_NORMAL
- en: Associations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object associations are an important feature of OOP. Relationships exist between
    objects in the real world, and, in OOP, an association allows us to define a *has-a*
    relationship; for example, a bicycle *has a* rider or a cat *has a* nose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The types of *has-a* relationship are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Association**: An association is used to describe a relationship between
    objects so that there is no ownership described, for example, the relationship
    between a car and a person. The car and person have a relationship described,
    such as a driver. A person can drive multiple cars and a car can be driven by
    multiple people.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aggregation**: An aggregation is a specialized form of association. Similar
    to associations, objects have their own life cycle in aggregations, but it involves
    ownership. This means that a child object cannot belong to another parent object.
    Aggregation is a one-way relationship where the lives of the objects are independent
    from each other. For example, the child and parent relationship is an aggregation,
    because every child has a parent but it''s not necessary that every parent has
    a child.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composition**: A composition refers to a relationship of death; it represents
    the relationship between two objects where one object (child) depends on another
    object (parent). If the parent object is deleted, all its children automatically
    get deleted. Let''s consider a house and a room as an example. One house has multiple
    rooms, but a single room cannot belong to multiple houses. If we demolished the
    house, the rooms will automatically be deleted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's illustrate these concepts in C# by extending the previous pet example
    and introducing a `PetOwner` class. The `PetOwner` class could be associated with
    one or more `PetAnimal` instances. As the `PetAnimal` class can exist with or
    without having an owner, the relationship is an aggregation. `PetAnimal` is related
    to `PetColor` and, in this system, `PetColor` only exists if it is related to
    `PetAnimal`, making the association a composition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates both aggregation and composition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d132053d-f041-4a26-a000-436ad74ddaa6.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding model is based on UML and might not be familiar to you; so, let's
    point out some important things about the diagram. The class is represented by
    a box containing the class name as well as its attributes and methods (separated
    by a dashed line). For now, ignore the symbol before the name, for example, `+`
    or `-`, as we will cover access modifiers when we discuss encapsulation later.
    The associations are shown with a line connecting the classes. In the case of
    compositions, a solid diamond on the side of the parent is used, whereas an open
    diamond on the side of the parent is used to show aggregations. Additionally,
    note that the diagram supports a multiplicity value that indicates the number
    of possible children. In the diagram, a `PetOwner` class can have `0` or more
    `PetAnimal` classes (note that ***** indicates no enforced limit to the number
    of associations).
  prefs: []
  type: TYPE_NORMAL
- en: UML
  prefs: []
  type: TYPE_NORMAL
- en: The UML is a modeling language specifically developed for software engineering.
    It was developed over 20 years and is managed by the **Object Management Group**
    (**OMG**). You can refer to [http://www.uml.org/](http://www.uml.org/) for more
    details.
  prefs: []
  type: TYPE_NORMAL
- en: An interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C#, an **interface** defines what an object contains, or its contract; in
    particular, the methods, properties, events, or indices of the object. However,
    the interface does not provide implementation. Interfaces cannot contain attributes.
    This is in contrast to a base class, where the base class provides both the contract
    and the implementation. A class that implements an interface must implement everything
    specified in the interface.
  prefs: []
  type: TYPE_NORMAL
- en: An abstract class
  prefs: []
  type: TYPE_NORMAL
- en: An abstract class is a bit of a hybrid between the interface and base class
    as it provides both implementations and attributes as well as methods that must
    be defined in the child classes.
  prefs: []
  type: TYPE_NORMAL
- en: Signature
  prefs: []
  type: TYPE_NORMAL
- en: The term *signature* can also be used to describe the contract of an object.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important concepts in OOP is inheritance. Inheritance between
    classes allows us to define an *is-a-type-of relationship*; for example, a car
    *is a type of* vehicle. The importance of this concept is that it allows for objects
    of the same type to share similar features. Let's say that we have a system for
    managing different products of an online bookstore. We might have one class for
    storing information about a physical book and a different one for storing information
    about a digital or online book. The features that are similar between the two,
    such as the name, publisher, and author, could be stored in another class. Both
    the physical and digital book classes could then inherit from the other class.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different terms to describe classes in inheritance: a *child* or
    *derived* class inherits from another class while the class being inherited from
    can be called the *parent* or *base* class.'
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will discuss inheritance in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Types of inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inheritance helps us to define a child class. This child class inherits the
    behavior of the parent or base class.
  prefs: []
  type: TYPE_NORMAL
- en: In C#, inheritance is symbolically defined using a colon (`:`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the different types of inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single inheritance**: As the most common type of inheritance, single inheritance
    describes a single class that is is derived from another class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s revisit the `PetAnimal` class previously mentioned and, instead, use
    inheritance to define our `Dog` and `Cat` classes. With inheritance, we can define
    some attributes that are common for both. For example, the name of the pet and
    the color of the pet would be common, so they would be located in a base class.
    The specifics of a cat or a dog would then be defined in a specific class; for
    example, the sound the cat and dog make. The following diagram illustrates a `PetAnimal`
    base class with two child classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dcf9f6cd-c935-4973-a43a-4139b3d6ff1d.png)'
  prefs: []
  type: TYPE_IMG
- en: C# only supports single inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiple inheritance**: Multiple inheritance happens when a derived class
    inherits multiple base classes. Languages such as C++ support multiple inheritance.
    C# does not support multiple inheritance, but we can achieve behaviors similar
    to multiple inheritance with the help of interfaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can refer to the following post for more information about C# and multiple
    inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://blogs.msdn.microsoft.com/csharpfaq/2004/03/07/why-doesnt-c-supportmultiple-inheritance/](https://blogs.msdn.microsoft.com/csharpfaq/2004/03/07/why-doesnt-c-supportmultiple-inheritance/).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hierarchical inheritance**: Hierarchical inheritance happens when more than
    one class inherits from another class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multilevel inheritance**: When a class is derived from a class that is already
    a derived class, it is called multilevel inheritance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hybrid inheritance**: Hybrid inheritance is a combination of more than one
    inheritance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# does not support hybrid inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicit inheritance**: All the types in .NET Core implicitly inherit from
    the `System.Object` class and its derived classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encapsulation is another fundamental concept in OOP where the details of a class,
    that is, the attributes and methods, can be visible or not visible outside the
    object. With encapsulation, a developer is providing guidance on how a class should
    be used as well as helping to prevent a class from being handled incorrectly.
    For example, let's say we wanted to only allow adding `PetAnimal` objects by using
    the `AddPet(PetAnimal)` method. We would do this by having the `PetOwner` class's
    `AddPet(PetAnimal)` method available while having the `Pets` attribute restricted
    to anything outside the `PetAnimal` class. In C#, this is possible by making the
    `Pets` attribute private. One reason for doing this would be if additional logic
    was required whenever a `PetAnimal` class was added, such as logging or validating
    that the `PetOwner` class could have a pet.
  prefs: []
  type: TYPE_NORMAL
- en: 'C# supports different levels of access that can be set on an item. An item
    could be a class, a class''s attribute or method, or an enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Public**: This indicates that access is available outside the item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private**: This indicates that only the object has access to the item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protected**: This indicates that only the object (and objects of classes
    that extended the class) can access the attribute or method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internal**: This indicates that only objects within the same assembly have
    access to the item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protected Internal**: This indicates that only the object (and objects of
    classes that extended the class) can access the attribute or method within the
    same assembly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following diagram, access modifiers have been applied to `PetAnimal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4bb8946-f4a2-416c-938c-f39dc212a197.png)'
  prefs: []
  type: TYPE_IMG
- en: As an example, the name of the pet and the color were made private to prevent
    access from outside the `PetAnimal` class. In this example, we are restricting
    the `PetName` and `PetColor` properties so only the `PetAnimal` class can access
    them in order to ensure that only the base class, `PetAnimal`, can change their
    values. The constructor of `PetAnimal` was protected to ensure only a child class
    could access it. In this application, only classes within the same library as
    the `Dog` class have access to the `RegisterInObedienceSchool()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ability to handle different objects using the same interface is called
    polymorphism. This provides developers with the ability to build flexibility into
    applications by writing a single piece of functionality that can be applied to
    different forms as long as they share a common interface. There are different
    definitions of polymorphism in OOP, and we will distinguish between two main types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Static or early binding**: This form of polymorphism happens when the application
    is compiled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic or late binding**: This form of polymorphism happens when the application
    is running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Static or early binding polymorphism happens at compile time and it primarily
    consists of method overloading, where a class has multiple methods with the same
    name but with different parameters. This is often useful to convey a meaning behind
    the method or to simplify the code. For example, in a calculator, it is more readable
    to have multiple methods for adding different types of number rather than having
    a different method name for each scenario; let''s compare the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following, the code is shown again with the same functionality, but
    without overloading the `Add()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the pet example, an owner will use different food to feed objects of the
    `cat` and `dog` class. We can define this as the `PetOwner` class with two methods
    for `Feed()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Both methods use a `PetFeeder` class to feed the pet, while the `dog` class
    is given `Kibble` and the `cat` instance is given `Fish`. The `PetFeeder` class
    is described in the *Generics* section.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dynamic or late binding polymorphism happens while the application is running.
    There are multiple situations where this can occur and we''ll cover three common
    forms in C#: interface, inheritance, and generics.'
  prefs: []
  type: TYPE_NORMAL
- en: Interface polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An interface defines the signature that a class must implement. In the `PetAnimal`
    example, imagine that we define pet food as providing an amount of energy, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'By itself, the interface cannot be instantiated but describes what an instance
    of `IPetFood` must implement. For example, `Kibble` and `Fish` might provide different
    levels of energy, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, `Kibble` provides less energy than `Fish`.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inheritance polymorphism allows for functionality to be determined at runtime
    in a similar way to an interface but applies to class inheritance. In our example,
    a pet can be fed, so we can define this as having a new `Feed(IPetFood)` method,
    which uses the interface that was defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code indicates that all implementations of `PetAnimal` will have
    a `Feed(IPetFood)` method and child classes can provide a different implementation.
    `Eat(IPetFood food)` is not marked as virtual, as it is intended that all `PetAnimal`
    objects will use the method without needing to override its behavior. It is also
    marked as protected to prevent it being accessed from outside the object.
  prefs: []
  type: TYPE_NORMAL
- en: A virtual method does not have to be defined in a child class; this differs
    from an interface, where all methods in an interface must be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '`PetDog` will not override the behavior of the base class as a dog will eat
    both `Kibble` and `Fish`. A cat is more discerning, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Using the override keyword, `PetCat` will change the behavior of the base class,
    resulting in a cat only eating fish.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A generic defines a behavior that can be applied to a class. A commonly used
    form of this is in collections, where the same approach to handling an object
    can be applied regardless of the type of object. For example, a list of strings
    or a list of integers can be handled using the same logic without having to differentiate
    between the specific types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to pets, we could define a generic class for feeding a pet. This
    class simply feeds a pet given both the pet and some food, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of interesting thing to point out here. First of all, the
    class does not have to be instantiated as both the class and method are marked
    as static. The generic method is described using the method signature, `FeedPet<TP,
    TF>`. The `where` keyword is used to indicate additional requirements as to what
    `TP` and `TF` must be. In this example, the `where` keyword defines `TP` as having
    to be a type of `PetAnimal`, while `TF` must implement the `IPetFood` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed OOP and its three main features: inheritance,
    encapsulation, and polymorphism. Using these features, the classes within an application
    can be abstracted to provide definitions that are both easy to understand and
    protected against being used in a manner that is inconsistent with its purpose.
    This is an essential difference between OOP and some earlier types of software
    development language such as structural and procedural programming. With the ability
    to abstract functionality, the ability to reuse and maintain code is increased.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss various patterns used in enterprise software
    development. We will cover programming patterns as well as software development
    principles and patterns used in the **Software Development Life Cycle** (**SDLC**).
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What do the terms late and early binding refer to?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does C# support multiple inheritance?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In C#, what level of encapsulation could be used to prevent access to a class
    from outside the library?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between aggregation and composition?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can interfaces contain properties? (This is a bit of a trick question.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do dogs eat fish?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
