<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Pipeline and Producer-consumer Design Patterns"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Pipeline and Producer-consumer Design Patterns</h1></div></div></div><p>In this chapter, we will explore two popular design patterns to solve concurrent problems—Pipeline and producer-consumer, which are used in developing parallel applications using the TPL. A <span class="strong"><strong>Pipeline</strong></span> design<a id="id513" class="indexterm"/> is one where an application is designed with multiple tasks or stages of functionality with queues of work items between them. So, for each stage, the application will read from a queue of work to be performed, execute the work on that item, and then queue the results for the next stage. By designing the application this way, all of the stages can execute in parallel. Each stage just reads from its work queue, performs the work, and puts the results of the work into the queue for the next stage.</p><p>Each stage is a task and can run independently of the other stages or tasks. They continue executing until their queue is empty and marked completed. They also block and wait for more work items if the queue is empty but not completed.</p><p>The <span class="strong"><strong>producer-consumer</strong></span> design pattern<a id="id514" class="indexterm"/> is a similar concept but different. In this design, we have a set of functionality that produces data that is then consumed by another set of functionality. Each set of functionality is a TPL task. So, we have a producer task and a consumer task, with a buffer between them. Each of these tasks can run independently of each other. We can also have multiple producer tasks and multiple consumer tasks. The producers run independently and produce queue results to the buffer. The consumers run independently and dequeue from the buffer and perform work on the item. The producer can block if the buffer is full and wait for room to become available before producing more results. Also, the consumer can block if the buffer is empty, waiting on more results to be available to consume.</p><p>In this chapter, you will learn the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Designing an application with a Pipeline design</li><li class="listitem" style="list-style-type: disc">Designing an application with a producer-consumer design</li><li class="listitem" style="list-style-type: disc">Learning how to use <code class="literal">BlockingCollection</code></li><li class="listitem" style="list-style-type: disc">Learning how to use <code class="literal">BufferedBlocks</code></li><li class="listitem" style="list-style-type: disc">Understanding the classes of the <code class="literal">System.Threading.Tasks.Dataflow</code> library</li></ul></div><div class="section" title="Pipeline design pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec66"/>Pipeline design pattern</h1></div></div></div><p>The Pipeline design<a id="id515" class="indexterm"/> is very useful in parallel design <a id="id516" class="indexterm"/>when you can divide an application up into series of tasks to be performed in such a way that each task can run concurrently with other tasks. It is important that the output of each task is in the same order as the input. If the order does not matter, then a parallel loop can be performed. When the order matters and we don't want to wait until all items have completed task A before the items start executing task B, then a Pipeline implementation is perfect.</p><p>Some applications that lend themselves to pipelining are video streaming, compression, and encryption. In each of these examples, we need to perform a set of tasks on the data and preserve the data's order, but we do not want to wait for each item of data to perform a task before any of the data can perform the next task.</p><p>The key class that .NET has provided for implementing this design pattern is <code class="literal">BlockingCollection</code> of the <code class="literal">System.Collections.Concurrent</code> namespace. The <code class="literal">BlockingCollection</code> class was introduced with .NET 4.5. It is a thread-safe collection specifically designed for producer-consumer and Pipeline design patterns. It supports concurrently adding and removing items by multiple threads to and from the collection. It also has methods to add and remove that block when the collection is full or empty. You can specify a maximum collection size to ensure a producing task that outpaces a consuming task does not make the queue too large. It supports cancellation tokens. Finally, it supports enumerations so that you can use the <code class="literal">foreach</code> loop when processing items of the collection.</p><p>A producer of items to the collection can call the <code class="literal">CompleteAdding</code> method when the last item of data has been added to the collection. Until this method is called if a consumer is consuming items from the collection with a <code class="literal">foreach</code> loop and the collection is empty, it will block until an item is put into the collection instead of ending the loop.</p><p>Next, we will see a simple example of a Pipeline design implementation using an encryption program. This program will implement three stages in our pipeline. The first stage will read a text file character-by-character and place each character into a buffer (<code class="literal">BlockingCollection</code>). The next stage will read each character out of the buffer and encrypt it by adding 1 to its ASCII number. It will then place the new character into our second buffer and write it to an encryption file. Our final stage will read the character out of the second buffer, decrypt it to its original character, and write it out to a new file and to the screen. As you will see, stages 2 and 3 will start processing characters before stage 1 has finished reading all the characters from the input file. And all of this will be done while maintaining the order <a id="id517" class="indexterm"/>of the characters so that the <a id="id518" class="indexterm"/>final output file is identical to the input file:</p><div class="mediaobject"><img src="graphics/8321EN_09_01.jpg" alt="Pipeline design pattern"/></div><p>Let's get started.</p><div class="section" title="How to do it"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec81"/>How to do it</h2></div></div></div><p>First, let's open up Visual Studio and create a new <span class="strong"><strong>Windows Presentation Foundation</strong></span> (<span class="strong"><strong>WPF</strong></span>)<a id="id519" class="indexterm"/> application named <code class="literal">PipeLineApplication</code> and perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new class called <code class="literal">Stages.cs</code>. Next, make sure it has the following <code class="literal">using</code> statements.<div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Threading;</pre></div></li><li class="listitem">In the <code class="literal">MainWindow.xaml.cs</code> file, make sure the following <code class="literal">using</code> statements are present:<div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Threading;</pre></div></li><li class="listitem">Next, we will <a id="id520" class="indexterm"/>add a method <a id="id521" class="indexterm"/>for each of the three stages in our pipeline. First, we will create a method called <code class="literal">FirstStage</code>. It will take two parameters: one will be a <code class="literal">BlockingCollection</code> object that will be the output buffer of this stage, and the second will be a string pointing to the input data file. This will be a text file containing a couple of paragraphs of text to be encrypted. We will place this text file in the <code class="literal">projects</code> folder on <code class="literal">C:</code>. The <code class="literal">FirstStage</code> method will have the following code:<div class="informalexample"><pre class="programlisting">public void FirstStage(BlockingCollection&lt;char&gt; output, String PipelineInputFile)
        {
            String DisplayData = "";
            try
            {
                foreach (char C in GetData(PipelineInputFile))
                {
 //Displayed characters read in from the file.
                    DisplayData = DisplayData + C.ToString();

 // Add each character to the buffer for the next stage.
                    output.Add(C);

                }
            }
            finally
            {
                output.CompleteAdding();
            }
      }</pre></div></li><li class="listitem">Next, we will add a method for the second stage called <code class="literal">StageWorker</code>. This method will not return any values and will take three parameters. One will be a <code class="literal">BlockingCollection</code> value that will be its input buffer, the second one will be the output buffer of the stage, and the final one will be a file path to store the encrypted <a id="id522" class="indexterm"/>text in a data<a id="id523" class="indexterm"/> file. The code for this method will look like this:<div class="informalexample"><pre class="programlisting">public void StageWorker(BlockingCollection&lt;char&gt; input, BlockingCollection&lt;char&gt; output, String PipelineEncryptFile)
        {
            String DisplayData = "";

            try
            {
                foreach (char C in input.GetConsumingEnumerable())
                {
                    //Encrypt each character.
                    char encrypted = Encrypt(C);

                    DisplayData = DisplayData + encrypted.ToString();

 //Add characters to the buffer for the next stage.
                    output.Add(encrypted);

                }

 //write the encrypted string to the output file.
                using (StreamWriter outfile =
                           new StreamWriter(PipelineEncryptFile))
                {
                    outfile.Write(DisplayData);
                }

            }
            finally
            {
                output.CompleteAdding();
            }
        }</pre></div></li><li class="listitem">Now, we will add a method for the third and final stage of the Pipeline design. This method will be named <code class="literal">FinalStage</code>. It will not return any values and will take two parameters. One will be a <code class="literal">BlockingCollection</code> object that is the input <a id="id524" class="indexterm"/>buffer and the other<a id="id525" class="indexterm"/> will be a string pointing to an output data file. It will have the following code in it:<div class="informalexample"><pre class="programlisting">public void FinalStage(BlockingCollection&lt;char&gt; input, String PipelineResultsFile)
        {
            String OutputString = "";
            String DisplayData = "";

            //Read the encrypted characters from the buffer, decrypt them, and display them.
            foreach (char C in input.GetConsumingEnumerable())
            {
                //Decrypt the data.
                char decrypted = Decrypt(C);

                //Display the decrypted data.
                DisplayData = DisplayData + decrypted.ToString();

                //Add to the output string.
                OutputString += decrypted.ToString();

            }

            //write the decrypted string to the output file.
            using (StreamWriter outfile =
                       new StreamWriter(PipelineResultsFile))
            {
                outfile.Write(OutputString);
            }
        }</pre></div></li><li class="listitem">Now that we have methods for the three stages of our pipeline, let's add a few utility methods. The first of these methods will be one that reads in the input data file and places each character in the data file in a <code class="literal">List</code> object. This method will take a string parameter that has a filename and will return a <code class="literal">List</code> object of characters. It will have the following code:<div class="informalexample"><pre class="programlisting">public List&lt;char&gt; GetData(String PipelineInputFile)
        {
            List&lt;char&gt; Data = new List&lt;char&gt;();

            //Get the Source data.
            using (StreamReader inputfile = new StreamReader(PipelineInputFile))
            {
                while (inputfile.Peek() &gt;= 0)
                {
                    Data.Add((char)inputfile.Read());
                }

            }

            return Data;
       }</pre></div></li><li class="listitem">Now we will need <a id="id526" class="indexterm"/>a method to encrypt <a id="id527" class="indexterm"/>the characters. This will be a simple encryption method. The encryption method is not really important to this exercise. This exercise is designed to demonstrate the Pipeline design, not implement the world's toughest encryption. This encryption will simply take each character and add one to its ASCII numerical value. The method will take a character type as an input parameter and return a character. The code for it will be as follows:<div class="informalexample"><pre class="programlisting">public char Encrypt(char C)
        {
            //Take the character, convert to an int, add 1, then convert back to a character.
            int i = (int)C;
            i = i + 1;
            C = Convert.ToChar(i);

            return C;
}</pre></div></li><li class="listitem">Now we will add one final method to the <code class="literal">Stages</code> class to decrypt a character value. It will simply do the reverse of the <code class="literal">encrypt</code> method. It will take the ASCII numerical value and subtract 1. The code for this method will look like this:<div class="informalexample"><pre class="programlisting">public char Decrypt(char C)
        {
            int i = (int)C;
            i = i - 1;
            C = Convert.ToChar(i);

            return C;
       }</pre></div></li><li class="listitem">Now that we are done with the <code class="literal">Stages</code> class, let's switch our focus back to the <code class="literal">MainWindow.xaml.cs</code> file. First, you will need to add three <code class="literal">using</code> statements. They are for the <code class="literal">StreamReader</code>, <code class="literal">StreamWriter</code>, <code class="literal">Threads</code>, and <code class="literal">BlockingCollection</code> classes:<div class="informalexample"><pre class="programlisting">using System.Collections.Concurrent;
using System.IO;
using System.Threading;</pre></div></li><li class="listitem">At the top of the <code class="literal">MainWindow</code> class, we need four variables available for the whole class. We need three strings that point to our three data files—the input data, encrypted data, and output data. Then we will need a <code class="literal">Stages</code> object. These declarations will look like this:<div class="informalexample"><pre class="programlisting">private static String PipelineResultsFile = @"c:\projects\OutputData.txt";
       private static String PipelineEncryptFile = @"c:\projects\EncryptData.txt";
       private static String PipelineInputFile = @"c:\projects\InputData.txt";
       private Stages Stage;</pre></div></li><li class="listitem">Then, in <a id="id528" class="indexterm"/>the <code class="literal">MainWindow</code> constructor <a id="id529" class="indexterm"/>method, right after the <code class="literal">InitializeComponent</code> call, add a line to instantiate our <code class="literal">Stages</code> object:<div class="informalexample"><pre class="programlisting">//Create the Stage object and register the event listeners to update the UI as the stages work.
Stage = new Stages();</pre></div></li><li class="listitem">Next, add a button to the <code class="literal">MainWindow.xaml</code> file that will initiate the pipeline and encryption. Name this button control <code class="literal">butEncrypt</code>, and set its <code class="literal">Content</code> property to <code class="literal">Encrypt File</code>. Next, add a click event handler for this button in the <code class="literal">MainWindow.xaml.cs</code> file. Its event handler method will be <code class="literal">butEncrypt_Click</code> and will contain the main code for this application. It will instantiate two <code class="literal">BlockingCollection</code> objects for two queues. One queue between stages 1 and 2, and one queue between stages 2 and 3. This method will then create a task for each stage that executes the corresponding methods from the <code class="literal">Stages</code> classes. It will then start these three tasks and wait for them to complete. Finally, it will write the output of each stage to the input, encrypted, and results data files and text blocks for viewing. The code for it will look like the following code:<div class="informalexample"><pre class="programlisting">private void butEncrpt_Click(object sender, RoutedEventArgs e)
        {
            //PipeLine Design Pattern

            //Create queues for input and output to stages.
            int size = 20;
            BlockingCollection&lt;char&gt; Buffer1 = new BlockingCollection&lt;char&gt;(size);
            BlockingCollection&lt;char&gt; Buffer2 = new BlockingCollection&lt;char&gt;(size);

            TaskFactory tasks = new TaskFactory(TaskCreationOptions.LongRunning, TaskContinuationOptions.None);

            Task Stage1 = tasks.StartNew(() =&gt; Stage.FirstStage(Buffer1, PipelineInputFile));
            Task Stage2 = tasks.StartNew(() =&gt; Stage.StageWorker(Buffer1, Buffer2, PipelineEncryptFile));
            Task Stage3 = tasks.StartNew(() =&gt; Stage.FinalStage(Buffer2, PipelineResultsFile));

            Task.WaitAll(Stage1, Stage2, Stage3);

            //Display the 3 files.
            using (StreamReader inputfile = new StreamReader(PipelineInputFile))
            {
                while (inputfile.Peek() &gt;= 0)
                {
                    tbStage1.Text = tbStage1.Text + (char)inputfile.Read();
                }

            }
            using (StreamReader inputfile = new StreamReader(PipelineEncryptFile))
            {
                while (inputfile.Peek() &gt;= 0)
                {
                    tbStage2.Text = tbStage2.Text + (char)inputfile.Read();
                }

            }
            using (StreamReader inputfile = new StreamReader(PipelineResultsFile))
            {
                while (inputfile.Peek() &gt;= 0)
                {
                    tbStage3.Text = tbStage3.Text + (char)inputfile.Read();
                }

            }
      }</pre></div></li><li class="listitem">One last thing. Let's<a id="id530" class="indexterm"/> add three text<a id="id531" class="indexterm"/>blocks to display the outputs. We will call these <code class="literal">tbStage1</code>, <code class="literal">tbStage2</code>, and <code class="literal">tbStage3</code>. We will also add three label controls with the text <code class="literal">Input File</code>, <code class="literal">Encrypted File</code>, and <code class="literal">Output File</code>. These will be placed by the corresponding textblocks. Now, the <code class="literal">MainWindow.xaml</code> file should look like the following screenshot:<div class="mediaobject"><img src="graphics/8321EN_09_02.jpg" alt="How to do it"/></div></li><li class="listitem">Now we will need an input data file to encrypt. We will call this file <code class="literal">InputData.txt</code> and put it in the <code class="literal">C:\projects</code> folder on our computer. For our example, we<a id="id532" class="indexterm"/> have added the <a id="id533" class="indexterm"/>following text to it:<div class="mediaobject"><img src="graphics/8321EN_09_03.jpg" alt="How to do it"/></div></li><li class="listitem">We are all finished and ready to try it out. Compile and run the application and you should have a window that looks like the following screenshot:<div class="mediaobject"><img src="graphics/8321EN_09_04.jpg" alt="How to do it"/></div></li><li class="listitem">Now, click<a id="id534" class="indexterm"/> on the <span class="strong"><strong>Encrypt File</strong></span> <a id="id535" class="indexterm"/>button and you should see the following output:<div class="mediaobject"><img src="graphics/8321EN_09_05.jpg" alt="How to do it"/></div></li></ol></div><p>As you can see, the<a id="id536" class="indexterm"/> input and output files look the<a id="id537" class="indexterm"/> same and the encrypted file looks different. Remember that <span class="strong"><strong>Input File</strong></span> is the text we put in the input data text file; this is the input from the end of stage 1 after we have read the file in to a character list. <span class="strong"><strong>Encrypted File</strong></span> is the output from stage 2 after we have encrypted each character. <span class="strong"><strong>Output File</strong></span> is the output of stage 3 after we have decrypted the characters again. It should match <span class="strong"><strong>Input File</strong></span>.</p><p>Now, let's take a look at how this works.</p></div><div class="section" title="How it works"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec82"/>How it works</h2></div></div></div><p>Let's look at the <code class="literal">butEncrypt</code> click event handler method in the <code class="literal">MainWindow.xaml.cs</code> file, as this is where a lot of the action takes place. Let's examine the following lines of code:</p><div class="informalexample"><pre class="programlisting">            //Create queues for input and output to stages.
            int size = 20;
            BlockingCollection&lt;char&gt; Buffer1 = new BlockingCollection&lt;char&gt;(size);
            BlockingCollection&lt;char&gt; Buffer2 = new BlockingCollection&lt;char&gt;(size);
            TaskFactory tasks = new TaskFactory(TaskCreationOptions.LongRunning, TaskContinuationOptions.None);

            Task Stage1 = tasks.StartNew(() =&gt; Stage.FirstStage(Buffer1, PipelineInputFile));
            Task Stage2 = tasks.StartNew(() =&gt; Stage.StageWorker(Buffer1, Buffer2, PipelineEncryptFile));
            Task Stage3 = tasks.StartNew(() =&gt; Stage.FinalStage(Buffer2, PipelineResultsFile));</pre></div><p>First, we create two queues that are implemented using <code class="literal">BlockingCollection</code> objects. Each of these is set with a size of <code class="literal">20</code> items. These two queues take a character datatype.</p><p>Then we <a id="id538" class="indexterm"/>create a <code class="literal">TaskFactory</code> object <a id="id539" class="indexterm"/>and use it to start three tasks. Each task uses a lambda expression that executes one of the stages methods from the <code class="literal">Stages</code> class—<code class="literal">FirstStage</code>, <code class="literal">StageWorker</code>, and <code class="literal">FinalStage</code>.</p><p>So, now we have three separate tasks running besides the main UI thread. <code class="literal">Stage1</code> will read the input data file character by character and place each character in the queue <code class="literal">Buffer1</code>. Remember that this queue can only hold 20 items before it will block the <code class="literal">FirstStage</code> method waiting on room in the queue. This is how we know that <code class="literal">Stage2</code> starts running before <code class="literal">Stage1</code> completes. Otherwise, <code class="literal">Stage1</code> will only queue the first 20 characters and then block.</p><p>Once <code class="literal">Stage1</code> has read all of the characters from the input file and placed them into <code class="literal">Buffer1</code>, it then makes the following call:</p><div class="informalexample"><pre class="programlisting">            finally
            {
                output.CompleteAdding();
            }</pre></div><p>This lets the <code class="literal">BlockingCollection</code> instance, <code class="literal">Buffer1</code>, to know that there are no more items to be put in the queue. So, when <code class="literal">Stage2</code> has emptied the queue after <code class="literal">Stage1</code> has called this method, it will not block but will instead continue until completion. Prior to the <code class="literal">CompleteAdding</code> method call, <code class="literal">Stage2</code> will block if <code class="literal">Buffer1</code> is empty, waiting until more items are placed in the queue. This is why a <code class="literal">BlockingCollection</code> instance was developed for Pipeline and producer-consumer applications. It provides the perfect mechanism for this functionality.</p><p>When we created the <code class="literal">TaskFactory</code>, we used the following parameter:</p><div class="informalexample"><pre class="programlisting">TaskCreationOptions.LongRunning</pre></div><p>This tells the threadpool that these tasks may run for a long time and could occasionally block waiting on their queues. In this way, the threadpool can decide how to best manage the threads allocated for these tasks.</p><p>Now, let's look at the code in <code class="literal">Stage2</code>—the <code class="literal">StageWorker</code> method. We need a way to remove items in an enumerable way so that we can iterate over the queues items with a <code class="literal">foreach</code> loop because we do not know how many items to expect. Also, since <code class="literal">BlockingCollection</code> objects support multiple consumers, we need a way to remove items that no other consumer might remove. We use this method of the <code class="literal">BlockingCollection</code> class:</p><div class="informalexample"><pre class="programlisting">foreach (char C in input.GetConsumingEnumerable())</pre></div><p>This allows<a id="id540" class="indexterm"/> multiple consumers to <a id="id541" class="indexterm"/>remove items from a <code class="literal">BlockingCollection</code> instance while maintaining the order of the items. To further improve performance of this application (assuming we have enough available processing cores), we could create a fourth task that also runs the <code class="literal">StageWorker</code> method. So, then we would have two stages and two tasks running. This might be helpful if there are enough processing cores and stage 1 runs faster than stage 2. If this happens, it will continually fill the queue and block until space becomes available. But if we run multiple stage 2 tasks, then we will be able to keep up with stage 1.</p><p>Then, finally we have this line of code:</p><div class="informalexample"><pre class="programlisting">Task.WaitAll(Stage1, Stage2, Stage3);</pre></div><p>This tells our button handler to wait until all of the tasks are complete. Once we have called the <code class="literal">CompleteAdding</code> method on each <code class="literal">BlockingCollection</code> instance and the buffers are then emptied, all of our stages will complete and the <code class="literal">TaskFactory.WaitAll</code> command will be satisfied and this method on the UI thread can complete its processing, which in this application is to update the UI and data files:</p><div class="informalexample"><pre class="programlisting">            //Display the 3 files.
            using (StreamReader inputfile = new StreamReader(PipelineInputFile))
            {
                while (inputfile.Peek() &gt;= 0)
                {
                    tbStage1.Text = tbStage1.Text + (char)inputfile.Read();
                }

            }
            using (StreamReader inputfile = new StreamReader(PipelineEncryptFile))
            {
                while (inputfile.Peek() &gt;= 0)
                {
                    tbStage2.Text = tbStage2.Text + (char)inputfile.Read();
                }

            }
            using (StreamReader inputfile = new StreamReader(PipelineResultsFile))
            {
                while (inputfile.Peek() &gt;= 0)
                {
                    tbStage3.Text = tbStage3.Text + (char)inputfile.Read();
                }

            }</pre></div><p>Next, experiment <a id="id542" class="indexterm"/>with longer running, more complex <a id="id543" class="indexterm"/>stages and multiple consumer stages. Also, try stepping through the application with the Visual Studio debugger using the techniques we learned in <a class="link" href="ch08.html" title="Chapter 8. Debugging Multithreaded Applications with Visual Studio">Chapter 8</a>, <span class="emphasis"><em>Debugging Multithreaded Applications with Visual Studio</em></span>. Make sure you understand the interaction between the stages and the buffers.</p></div></div></div>
<div class="section" title="Explaining message blocks"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec67"/>Explaining message blocks</h1></div></div></div><p>Let's talk for a minute about<a id="id544" class="indexterm"/> message blocks and the TPL. There is a new library that Microsoft has developed as part of the TPL, but it does not ship directly with .NET 4.5. This library is called the TPL <code class="literal">Dataflow</code> library. It is located in the <code class="literal">System.Threading.Tasks.Dataflow</code> namespace. It comes with various dataflow components that assist in asynchronous concurrent applications where messages need to be passed between multiple tasks or the data needs to be passed when it becomes available, as in the case of a web camera streaming video.</p><p>The <code class="literal">Dataflow</code> library's message blocks are very helpful for design patterns such as Pipeline and producer-consumer where you have multiple producers producing data that can be consumed by multiple consumers. The two that we will take a look at are <code class="literal">BufferBlock</code> and <code class="literal">ActionBlock</code>.</p><p>The TPL <code class="literal">Dataflow</code> library contains classes to assist in message passing and parallelizing I/O-heavy applications that have a lot of throughput. It provides explicit control over how data is buffered and passed. Consider an application that asynchronously loads large binary files from storage and manipulates that data. Traditional programming requires that you use callbacks and synchronization classes, such as locks, to coordinate tasks and have access to data that is shared. By using the TPL <code class="literal">Dataflow</code> objects, you can create objects that process image files as they are read in from a disk location. You can set how data is handled when it becomes available. Because the CLR runtime engine manages dependencies between data, you do not have to worry about synchronizing access to shared data. Also, since the CLR engine schedules the work depending on the asynchronous arrival of data, the TPL <code class="literal">Dataflow</code> objects can improve performance by managing the threads the tasks run on.</p><p>In this section, we will<a id="id545" class="indexterm"/> cover two of these classes, <code class="literal">BufferBlock</code> and <code class="literal">ActionBlock</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>The TPL <code class="literal">Dataflow</code> library (<code class="literal">System.Threading.Tasks.Dataflow</code>) does not ship with .NET 4.5. To install <code class="literal">System.Threading.Tasks.Dataflow</code>, open your project in Visual Studio, select <span class="strong"><strong>Manage NuGet Packages</strong></span> from under the <span class="strong"><strong>Project</strong></span> menu and then search online for <code class="literal">Microsoft.Tpl.Dataflow</code>.</p></div></div><div class="section" title="BufferBlock"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec83"/>BufferBlock</h2></div></div></div><p>The <code class="literal">BufferBlock</code> object<a id="id546" class="indexterm"/> in the <code class="literal">Dataflow</code> library provides a buffer to store data. The syntax is, <code class="literal">BufferBlock&lt;T&gt;</code>. The <code class="literal">T</code> indicates that the datatype is generic and can be of any type. All static variables of this object type are guaranteed to be thread-safe. <code class="literal">BufferBlock</code> is an asynchronous message structure that stores messages in a first-in-first-out queue. Messages can be "posted" to the queue by multiple producers and "received" from the queue by multiple consumers.</p><p>The TPL <code class="literal">DatafLow</code> library provides interfaces for three types of objects—source blocks, target blocks, and propagator blocks. <code class="literal">BufferBlock</code> is a general-purpose message block that can act as both a source and a target message buffer, which makes it perfect for a producer-consumer application design. To act as both a source and a target, it implements two interfaces defined by the TPL <code class="literal">Dataflow</code> library—<code class="literal">ISourceBlock&lt;TOutput&gt;</code> and <code class="literal">ITargetBlock&lt;TOutput&gt;</code>. So, in the application that we will develop in the <span class="emphasis"><em>Producer-consumer design pattern</em></span> section of this chapter, you will see that the producer method implements <code class="literal">BufferBlock</code> using the <code class="literal">ITargetBlock</code> interface and the consumer implements <code class="literal">BufferBlock</code> with the <code class="literal">ISourceBlock</code> interface. </p><p>This will be the same <code class="literal">BufferBlock</code> object that they will act on but by defining their local objects with a different interface there will be different methods available to use. The producer method will have <code class="literal">Post</code> and <code class="literal">Complete</code> methods, and the consumer method will use the <code class="literal">OutputAvailableAsync</code> and <code class="literal">Receive</code> methods.</p><p>The <code class="literal">BufferBlock</code> object only has two properties, namely <code class="literal">Count</code>, which is a count of the number of data messages in the queue, and <code class="literal">Completion</code>, which gets a task that is an asynchronous operation and completion of the message block.</p><p>The following is a set of methods for this class:</p><div class="mediaobject"><img src="graphics/8321EN_09_06.jpg" alt="BufferBlock"/><div class="caption"><p>Referenced from http://msdn.microsoft.com/en-us/library/hh160414(v=vs.110).aspx</p></div></div><p>Here is a list of the <a id="id547" class="indexterm"/>extension methods provided by the interfaces that it implements:</p><div class="mediaobject"><img src="graphics/8321EN_09_07.jpg" alt="BufferBlock"/></div><div class="mediaobject"><img src="graphics/8321EN_09_08.jpg" alt="BufferBlock"/><div class="caption"><p>Referenced from http://msdn.microsoft.com/en-us/library/hh160414(v=vs.110).aspx</p></div></div><p>Finally, here are the<a id="id548" class="indexterm"/> interface references for this class:</p><div class="mediaobject"><img src="graphics/8321EN_09_09.jpg" alt="BufferBlock"/><div class="caption"><p>Referenced from http://msdn.microsoft.com/en-us/library/hh160414(v=vs.110).aspx</p></div></div><p>So, as you can see, these interfaces make using the <code class="literal">BufferBlock</code> object as a general-purpose queue between stages of a pipeline very easy. This technique is also useful between producers and consumers in a producer-consumer design pattern.</p></div><div class="section" title="ActionBlock"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec84"/>ActionBlock</h2></div></div></div><p>Another very useful <a id="id549" class="indexterm"/>object in the <code class="literal">Dataflow</code> library is <code class="literal">ActionBlock</code>. Its syntax is <code class="literal">ActionBlock&lt;TInput&gt;</code>, where <code class="literal">TInput</code> is an <code class="literal">Action</code> object. <code class="literal">ActionBlock</code> is a target block that executes a delegate when a message of data is received. The following is a very simple example of using an <code class="literal">ActionBlock</code>:</p><div class="informalexample"><pre class="programlisting">            ActionBlock&lt;int&gt; action = new ActionBlock&lt;int&gt;(x =&gt; Console.WriteLine(x));

            action.Post(10);</pre></div><p>In this sample piece of code, the <code class="literal">ActionBlock</code> object is created with an integer parameter and executes a simple lambda expression that does a <code class="literal">Console.WriteLine</code> when a message of data is posted to the buffer. So, when the <code class="literal">action.Post(10)</code> command is executed, the integer, <code class="literal">10</code>, is posted to the <code class="literal">ActionBlock</code> buffer and then the <code class="literal">ActionBlock</code> delegate, implemented as a lambda expression in this case, is executed.</p><p>In this example, since this is a target block, we would then need to call the <code class="literal">Complete</code> method to ensure the message block is completed.</p><p>Another handy method of the <code class="literal">BufferBlock</code> is the <code class="literal">LinkTo</code> method. This method allows you to link <code class="literal">ISourceBlock</code> to <code class="literal">ITargetBlock</code>. So, you can have a <code class="literal">BufferBlock</code> that is implemented as an <code class="literal">ISourceBlock</code> and link it to an <code class="literal">ActionBlock</code> since it is an <code class="literal">ITargetBlock</code>. In this way, an <code class="literal">Action</code> delegate can be executed when a <code class="literal">BufferBlock</code> receives data. This does not dequeue the data from the message block. It just allows you to execute some task when data is received into the buffer.</p><p>
<code class="literal">ActionBlock</code> only has<a id="id550" class="indexterm"/> two properties, namely <code class="literal">InputCount</code>, which is a count of the number of data messages in the queue, and <code class="literal">Completion</code>, which gets a task that is an asynchronous operation and completion of the message block. It has the following methods:</p><div class="mediaobject"><img src="graphics/8321EN_09_10.jpg" alt="ActionBlock"/><div class="caption"><p>Referenced from http://msdn.microsoft.com/en-us/library/hh194684(v=vs.110).aspx</p></div></div><p>The following extension methods are implemented from its interfaces:</p><div class="mediaobject"><img src="graphics/8321EN_09_11.jpg" alt="ActionBlock"/><div class="caption"><p>Referenced from http://msdn.microsoft.com/en-us/library/hh194684(v=vs.110).aspx</p></div></div><p>Also, it implements the following interfaces:</p><div class="mediaobject"><img src="graphics/8321EN_09_12.jpg" alt="ActionBlock"/><div class="caption"><p>Referenced from http://msdn.microsoft.com/en-us/library/hh194684(v=vs.110).aspx</p></div></div><p>Now that we have<a id="id551" class="indexterm"/> examined a little of the <code class="literal">Dataflow</code> library that Microsoft has developed, let's use it in a producer-consumer application.</p></div></div>
<div class="section" title="Producer-consumer design pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec68"/>Producer-consumer design pattern</h1></div></div></div><p>Now, that we have <a id="id552" class="indexterm"/>covered the TPL's <code class="literal">Dataflow</code> library <a id="id553" class="indexterm"/>and the set of objects it provides to assist in asynchronous message passing between concurrent tasks, let's take a look at the producer-consumer design pattern. In a typical producer-consumer design, we have one or more producers putting data into a queue or message data block. Then we have one or more consumers taking data from the queue and processing it. This allows for asynchronous processing of data. Using the <code class="literal">Dataflow</code> library objects, we can create a consumer task that monitors a <code class="literal">BufferBlock</code> and pulls items of the data from it when they arrive. If no items are available, the consumer method will block until items are available or the <code class="literal">BufferBlock</code> has been set to <code class="literal">Complete</code>. Because of this, we can start our consumer at any time, even before the producer starts to put items into the queue.</p><p>Then we create one or more tasks that produce items and place them into the <code class="literal">BufferBlock</code>. Once the producers are finished processing all items of data to the <code class="literal">BufferBlock</code>, they can mark the block as <code class="literal">Complete</code>. Until then, the <code class="literal">BufferBlock</code> object is still available to add items into. This is perfect for long-running tasks and applications when we do not know when the data will arrive.</p><p>Because the producer task is implementing an input parameter of a <code class="literal">BufferBlock</code> as an <code class="literal">ITargetBlock</code> object and the consumer task is implementing an input parameter of a <code class="literal">BufferBlock</code> as an <code class="literal">ISourceBlock</code>, they can both use the same <code class="literal">BufferBlock</code> object but have different methods available to them. One has methods to produces items to the block and mark it complete. The other one has methods to receive items and wait for more items until the block is marked complete. In this way, the <code class="literal">Dataflow</code> library implements the perfect object to act as a queue between our producers and consumers.</p><p>Now, let's take a look at the application we developed previously as a Pipeline design and modify it using the <code class="literal">Dataflow</code> library. We will also remove a stage so that it just has two stages, one producer and one consumer.</p><div class="section" title="How to do it"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec85"/>How to do it</h2></div></div></div><p>The first thing we need to do is open Visual Studio and create a new console application called <code class="literal">ProducerConsumerConsoleApp</code>. We will use a console application this time just for ease. Our main purpose here is to demonstrate how to implement the producer-consumer design pattern using the TPL <code class="literal">Dataflow</code> library.</p><p>Once you have opened <a id="id554" class="indexterm"/>Visual Studio and created the project, we need to perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we need to install and add a reference to the TPL <code class="literal">Dataflow</code> library. The TPL <code class="literal">Dataflow</code> library (<code class="literal">System.Threading.Tasks.Dataflow</code>) does not ship with .NET 4.5. Select <span class="strong"><strong>Manage NuGet Packages</strong></span> from under the <span class="strong"><strong>Project</strong></span> menu and then search online for <code class="literal">Microsoft.Tpl.Dataflow</code>.</li><li class="listitem">Now, we will need to add two <code class="literal">using</code> statements to our program. One for <code class="literal">StreamReader</code> and <code class="literal">StreamWriter</code> and one for the <code class="literal">BufferBlock</code> object:<div class="informalexample"><pre class="programlisting">using System.Threading.Tasks.Dataflow;
using System.IO;</pre></div></li><li class="listitem">Now, let's add two static strings that will point to our input data file and the encrypted data file that we output:<div class="informalexample"><pre class="programlisting">private static String PipelineEncryptFile = @"c:\projects\EncryptData.txt";
       private static String PipelineInputFile = @"c:\projects\InputData.txt";</pre></div></li><li class="listitem">Next, let's add a <a id="id555" class="indexterm"/>static method that will act as our producer. This method will have the following code:<div class="informalexample"><pre class="programlisting">        // Our Producer method.
        static void Producer(ITargetBlock&lt;char&gt; Target)
        {
            String DisplayData = "";

            try
            {
                foreach (char C in GetData(PipelineInputFile))
                {

                    //Displayed characters read in from the file.
                    DisplayData = DisplayData + C.ToString();

                    // Add each character to the buffer for the next stage.
                    Target.Post(C);

                }
            }

            finally
            {
                Target.Complete();
            }

        }</pre></div></li><li class="listitem">Then we will add a <a id="id556" class="indexterm"/>static method to <a id="id557" class="indexterm"/>perform our consumer functionality. It will have the following code:<div class="informalexample"><pre class="programlisting">        // This is our consumer method. IT runs asynchronously.
        static async Task&lt;int&gt; Consumer(ISourceBlock&lt;char&gt; Source)
        {
            String DisplayData = "";

            // Read from the source buffer until the source buffer has no  
            // available output data. 
            while (await Source.OutputAvailableAsync())
            {
                    char C = Source.Receive();

                    //Encrypt each character.
                    char encrypted = Encrypt(C);

                    DisplayData = DisplayData + encrypted.ToString();

            }

            //write the decrypted string to the output file.
            using (StreamWriter outfile =
                        new StreamWriter(PipelineEncryptFile))
            {
                outfile.Write(DisplayData);
            }

            return DisplayData.Length;
        }</pre></div></li><li class="listitem">Then, let's create a <a id="id558" class="indexterm"/>simple static <a id="id559" class="indexterm"/>helper method to read our input data file and put it in a <code class="literal">List</code> collection character by character. This will give us a character list for our producer to use. The code in this method will look like this:<div class="informalexample"><pre class="programlisting">        public static List&lt;char&gt; GetData(String PipelineInputFile)
        {
            List&lt;char&gt; Data = new List&lt;char&gt;();

            //Get the Source data.
            using (StreamReader inputfile = new StreamReader(PipelineInputFile))
            {
                while (inputfile.Peek() &gt;= 0)
                {
                    Data.Add((char)inputfile.Read());
                }

            }

            return Data;
        }</pre></div></li><li class="listitem">Next, we will add a static method to encrypt our characters. This method will work like the one we used in our pipelining application. It will add one to the ASCII numerical value of the character:<div class="informalexample"><pre class="programlisting">        public static char Encrypt(char C)
        {
            //Take the character, convert to an int, add 1, then convert back to a character.
            int i = (int)C;
            i = i + 1;
            C = Convert.ToChar(i);

            return C;
        }</pre></div></li><li class="listitem">Then, we need to add the code for our <code class="literal">Main</code> method. This method will start our consumer and producer tasks. Then, when they have completed processing, it will display the results in the console. The code for this method looks like this:<div class="informalexample"><pre class="programlisting">        static void Main(string[] args)
        {
            // Create the buffer block object to use between the producer and consumer. 
            BufferBlock&lt;char&gt; buffer = new BufferBlock&lt;char&gt;();

            // The consumer method runs asynchronously. Start it now.  
            Task&lt;int&gt; consumer = Consumer(buffer);

            // Post source data to the dataflow block.
            Producer(buffer);

            // Wait for the consumer to process all data.
            consumer.Wait();

            // Print the count of characters from the input file.
            Console.WriteLine("Processed {0} bytes from input file.", consumer.Result);

            //Print out the input file to the console.
            Console.WriteLine("\r\n\r\n");
            Console.WriteLine("This is the input data file. \r\n");
            using (StreamReader inputfile = new StreamReader(PipelineInputFile))
            {
                while (inputfile.Peek() &gt;= 0)
                {
                    Console.Write((char)inputfile.Read());
                }

            }

            //Print out the encrypted file to the console.
            Console.WriteLine("\r\n\r\n");
            Console.WriteLine("This is the encrypted data file. \r\n");
            using (StreamReader encryptfile = new StreamReader(PipelineEncryptFile))
            {
                while (encryptfile.Peek() &gt;= 0)
                {
                    Console.Write((char)encryptfile.Read());
                }

            }

            //Wait before closing the application so we can see the results.
            Console.ReadLine();
        }</pre></div></li><li class="listitem">That is all the code that is <a id="id560" class="indexterm"/>needed. Now, let's build <a id="id561" class="indexterm"/>and run the application using the following input data file:<div class="mediaobject"><img src="graphics/8321EN_09_13.jpg" alt="How to do it"/></div></li><li class="listitem">Once it runs and completes, your output should look like the following screenshot:<div class="mediaobject"><img src="graphics/8321EN_09_14.jpg" alt="How to do it"/></div></li></ol></div><p>Now, try this with your own data <a id="id562" class="indexterm"/>files and inputs. Let's <a id="id563" class="indexterm"/>examine what happened and how this works.</p></div><div class="section" title="How it works"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec86"/>How it works</h2></div></div></div><p>First we will go through the <code class="literal">Main</code> method. The first thing <code class="literal">Main</code> does is create a <code class="literal">BufferBlock</code> object called <code class="literal">buffer</code>. This will be used as the queue of items between our producer and consumer. This <code class="literal">BufferBlock</code> is defined to accept character datatypes.</p><p>Next, we start our consumer task using this command:</p><div class="informalexample"><pre class="programlisting">Task&lt;int&gt; consumer = Consumer(buffer);</pre></div><p>Also, note that when this buffer object goes into the consumer task, it is cast as <code class="literal">ISourceBlock</code>. Notice the method header of our consumer:</p><div class="informalexample"><pre class="programlisting">static async Task&lt;int&gt; Consumer(ISourceBlock&lt;char&gt; Source)</pre></div><p>Next, our <code class="literal">Main</code> method starts our producer task using the following command:</p><div class="informalexample"><pre class="programlisting">Producer(buffer);</pre></div><p>Then we wait until our consumer task finishes, using this command:</p><div class="informalexample"><pre class="programlisting">consumer.Wait();</pre></div><p>So, now our <code class="literal">Main</code> method just waits. Its work is done for now. It has started both the producer and consumer tasks. Now our consumer is waiting for items to appear in its <code class="literal">BufferBlock</code> so it can process them. The consumer will stay in the following loop until all items are removed from the message block and the block has been <span class="emphasis"><em>completed</em></span>, which is done by someone calling its <code class="literal">Complete</code> method:</p><div class="informalexample"><pre class="programlisting">     while (await Source.OutputAvailableAsync())
            {
                    char C = Source.Receive();

                    //Encrypt each character.
                    char encrypted = Encrypt(C);

                    DisplayData = DisplayData + encrypted.ToString();

            }</pre></div><p>So, now our consumer <a id="id564" class="indexterm"/>task will loop <a id="id565" class="indexterm"/>asynchronously, removing items from the message queue as they appear. It uses the following command in the while loop to do this:</p><div class="informalexample"><pre class="programlisting">await Source.OutputAvailableAsync())</pre></div><p>Likewise, other consumer tasks can run at the same time and do the same thing. If the producer is adding items to the block quicker than the consumer can process them, then adding another consumer will improve performance. Once an item is available, then the consumer calls the following command to get the item from the buffer:</p><div class="informalexample"><pre class="programlisting">char C = Source.Receive();</pre></div><p>Since the buffer contains items of type character, we place the item received into a character value. Then the consumer processes it by encrypting the character and appending it to our display string:</p><p>Now, let's look at the consumer. The consumer first gets its data by calling the following command:</p><div class="informalexample"><pre class="programlisting">GetData(PipelineInputFile)</pre></div><p>This method returns a <code class="literal">List</code> collection of characters that has an item for each character in the input data file. Now the producer iterates through the collection and uses the following command to place each item into the buffer block:</p><div class="informalexample"><pre class="programlisting">Target.Post(C);</pre></div><p>Also, notice in the method header for our consumer that we cast our buffer as an <code class="literal">ITargetBlock</code> type:</p><div class="informalexample"><pre class="programlisting">static void Producer(ITargetBlock&lt;char&gt; Target)</pre></div><p>Once the producer is done processing characters and adding them to the buffer, it officially closes the <code class="literal">BufferBlock</code> object using this command:</p><div class="informalexample"><pre class="programlisting">Target.Complete();</pre></div><p>That is it for the producer and consumer. Once the <code class="literal">Main</code> method is done waiting on the consumer to finish, it then uses the following code to write out the number of characters processed, the input data, and the<a id="id566" class="indexterm"/> encrypted <a id="id567" class="indexterm"/>data:</p><div class="informalexample"><pre class="programlisting">     // Print the count of characters from the input file.
            Console.WriteLine("Processed {0} bytes from input file.", consumer.Result);

            //Print out the input file to the console.
            Console.WriteLine("\r\n\r\n");
            Console.WriteLine("This is the input data file. \r\n");
            using (StreamReader inputfile = new StreamReader(PipelineInputFile))
            {
                while (inputfile.Peek() &gt;= 0)
                {
                    Console.Write((char)inputfile.Read());
                }

            }

            //Print out the encrypted file to the console.
            Console.WriteLine("\r\n\r\n");
            Console.WriteLine("This is the encrypted data file. \r\n");
            using (StreamReader encryptfile = new StreamReader(PipelineEncryptFile))
            {
                while (encryptfile.Peek() &gt;= 0)
                {
                    Console.Write((char)encryptfile.Read());
                }

            }</pre></div><p>Now that you are comfortable implementing a basic producer-consumer design using objects from the TPL <code class="literal">Dataflow</code> library, try experimenting with this basic idea but use multiple producers and multiple consumers all with the same <code class="literal">BufferBlock</code> object as the queue between them all.</p><p>Also, try converting <a id="id568" class="indexterm"/>our original Pipeline <a id="id569" class="indexterm"/>application from the beginning of the chapter into a TPL <code class="literal">Dataflow</code> producer-consumer application with two sets of producers and consumers. The first will act as stage 1 and stage 2, and the second will act as stage 2 and stage 3. So, in effect, stage 2 will be both a consumer and a producer.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec69"/>Summary</h1></div></div></div><p>We have covered a lot in this chapter. We have learned the benefits and how to implement a Pipeline design pattern and a producer-consumer design pattern. As we saw, these are both very helpful design patterns when building parallel and concurrent applications that require multiple asynchronous processes of data between tasks.</p><p>In the Pipeline design, we are able to run multiple tasks or stages concurrently even though the stages rely on data being processed and output by other stages. This is very helpful for performance since all functionality doesn't have to wait on each stage to finish processing every item of data. In our example, we are able to start decrypting characters of data while a previous stage is still encrypting data and placing it into the queue.</p><p>In the Pipeline example, we examined the benefits of the <code class="literal">BlockingCollection</code> class in acting as a queue between stages in our pipeline.</p><p>Next, we explored the new TPL <code class="literal">Dataflow</code> library and some of its messageblock classes. These classes implement several interfaces defined in the library—<code class="literal">ISourceBlock</code>, <code class="literal">ITargetBlock</code>, and <code class="literal">IPropogatorBlock</code>. By implementing these interfaces, it allows us to write generic producer and consumer task functionality that can be reused in a variety of applications.</p><p>Both of these design patterns and the <code class="literal">Dataflow</code> library allow for easy implementations of common functionality in a concurrent manner. You will use these techniques in many applications, and this will become a go-to design pattern when you evaluate a system's requirements and determine how to implement concurrency to help improve performance. Like all programming, parallel programming is made easier when you have a toolbox of easy-to-use techniques that you are comfortable with.</p><p>Most applications that benefit from parallelism will be conducive to some variation of a producer-consumer or Pipeline pattern. Also, the <code class="literal">BlockingCollection</code> and <code class="literal">Dataflow</code> message block objects are useful mechanisms for coordinating data between parallel tasks, no matter what design pattern is used in the application. It will be very useful to become comfortable with these messaging and queuing classes.</p><p>Now, we will move back to data parallelism in the next chapter, and this time, we will explore explicit data parallelism using PLINQ.</p></div></body></html>