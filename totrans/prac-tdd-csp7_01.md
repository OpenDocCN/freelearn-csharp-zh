# 为什么 TDD 很重要

你选择这本书是因为你想了解更多关于**测试驱动开发（TDD**）的知识。也许你之前听说过这个术语。也许你认识编写单元测试的软件开发者，并想了解更多。我们将向你介绍 TDD 相关的术语、结构和理念。到这本书的结尾，你将拥有足够的知识重新进入这个世界，作为一个测试驱动开发者，并在你漫长而繁荣的职业生涯中自信地使用你的技能。

为什么这本书？当然，关于 TDD 主题的书籍有很多。我们写这本书的目的是希望它能为你，读者，提供关于我们在进行 TDD 时所使用的思维方式的深入了解。我们也希望这本书能提供一些关于我们在过去 10 年进行 TDD 时所学到的一些概念和教训的更新观点。

那么，为什么 TDD 如此重要？随着越来越多的企业和行业依赖软件解决方案，确保这些解决方案稳健且无错误变得越来越重要。它们越便宜、越一致，就越好。以 TDD 为目标的开发的应用程序本质上更容易测试、更容易维护，并显示出在其他情况下难以达到的某种正确性水平。

在本章中，我们将了解以下内容：

+   定义 TDD 并探索基础知识

+   在 C#和 JavaScript 中创建我们的第一个测试

+   探索红、绿、重构的基本步骤

+   通过测试增长复杂性

# 首先，一些背景信息

在你的职业生涯中，你可能已经接触过单元测试。你很可能已经编写过一个或两个测试。不幸的是，许多开发者还没有机会体验到测试驱动开发（Test-Driven Development）的乐趣。

# 约翰关于测试驱动开发（TDD）的故事

我第一次接触 TDD 是在大约五年前。我正在面试一个小型初创公司的首席开发者职位。在面试过程中，CTO 提到开发团队正在实践 TDD。我告诉他我没有实际的 TDD 经验，但我确信我可以适应。

实话实说，我有点紧张。到那时，我甚至从未写过单个单元测试！我把自己带进了什么境地？一个提议被提出，我接受了。一旦我加入了这家小公司，我就被告知，虽然 TDD 是目标，但他们还没有完全达到。谢天谢地；危机解除。然而，我仍然很感兴趣。直到几个月后，团队才深入 TDD 的世界，正如人们所说，其余的就是历史了。

# 克莱顿关于 TDD 的故事

我对 TDD 的介绍与约翰的不同。我在 20 世纪 90 年代初上初中时就开始写代码了。从那时起直到 2010 年，我总是挣扎于在引入新需求时编写不需要进行重大架构更改的应用程序。2010 年，我终于厌倦了不断的重写，并开始研究工具和技术来帮助我解决这个问题。我很快发现了 TekPub，这是一个当时由 Rob Conery 拥有和运营的在线学习网站。通过 TekPub 我开始学习 SOLID 原则和 TDD。在几乎六个月的时间里不断碰壁后，我开始理解 TDD 是什么以及如何使用这些原则。结合 SOLID 原则，TDD 帮助我编写易于理解的代码，这些代码足够灵活，可以应对业务可能提出的任何需求。我最终来到了约翰工作的同一家公司，与他一起工作，正如他所说，其余的就是历史了。

SOLID 原则（稍后将会详细解释），是帮助产生干净、可维护和灵活代码的指导原则。它们有助于减少僵化、脆弱和复杂性。通常被认为是面向对象的原则，我发现它们适用于所有编程范式。

# 那么，TDD 究竟是什么呢？

在网上搜索，你肯定会发现 TDD 是 Test-Driven Development 的缩写。事实上，这本书的标题也会告诉你这一点。然而，我们使用一个稍微更有意义的定义。那么，TDD 究竟是什么呢？用最简单的话说，TDD 是一种软件开发方法，旨在减少错误并使应用程序内部具有灵活性。如果做得正确，TDD 是快速、准确和无所畏惧的应用程序开发的基石。

测试驱动开发是一种让测试驱动系统设计的方法。这究竟意味着什么呢？这意味着你不能带着解决方案开始，你必须让测试驱动正在编写的代码。这有助于最小化不必要的复杂性，并避免过度架构的解决方案。测试驱动开发的规则

TDD 的坚定支持者规定，在没有编写一个失败的单元测试的情况下，你甚至不能写一行生产代码，编译失败也是一种失败。这意味着你先写一个简单的测试，然后观察它失败，接着编写一些代码让它通过。随着测试和生产应用功能的增长，系统会逐渐演变。

TDD 不是关于测试的，它是关于设计的。

许多人会争论说，TDD 是关于测试的，进而也是关于应用程序的测试覆盖率。虽然这些都是 TDD 的绝佳副作用，但它们并不是实践背后的驱动力。

此外，如果代码覆盖率和指标成为目标，那么开发者可能会引入无意义的测试，只是为了增加数字。也许这与其说是一个风险，不如说是一个保证会发生的事情。让交付的功能和满意的客户成为衡量成功的指标。

TDD 是关于设计的。通过 TDD，应用程序的功能将增长，而不会引入不必要的复杂性。如果你只编写小的测试和足够的生产代码来使测试通过，那么引入复杂性是非常困难的。重构，即在不添加或更改行为的情况下修改代码结构，也不应该引入复杂性。

# 一种 TDD 方法

TDD 也被称为测试优先开发。在两个名称中，关键方面是测试必须在应用程序代码之前编写。被开发社区亲切地称为“Uncle Bob”的 Robert C. Martin 创建了 *TDD 的三条法则*。它们如下：

1.  除非是为了使失败的单元测试通过，否则不允许编写任何生产代码

1.  你不允许编写比足够使失败的单元测试失败更多的单元测试，编译失败也是失败。

1.  你不允许编写比足够通过一个失败的单元测试更多的生产代码。

你可以在 [`butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd`](http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd) 上了解更多关于这些法则的信息。

通过遵循这些规则，你将确保你的测试代码和生产代码之间有一个非常紧密的反馈循环。敏捷软件开发的主要组成部分之一是努力减少反馈周期。反馈周期越小，项目在出现问题的第一个迹象时就能进行纠正。同样，这也适用于测试反馈周期。你的测试越小，最终结果就越好。

想要了解敏捷的视频，可以查看 Martin Esposito 和 Massimo Fascinari 的 *Getting Started with Agile*（[`www.packtpub.com/application-development/getting-started-agile-video`](https://www.packtpub.com/application-development/getting-started-agile-video)）。

# 一种替代方法

TDD 的原始方法在多年以来引起了一些混淆。问题在于原则和方法的结构性不够。2006 年，Dan North 在《Better Software》杂志上发表了一篇文章（[`www.stickyminds.com/better-software-magazine/behavior-modification`](https://www.stickyminds.com/better-software-magazine/behavior-modification)）。这篇文章的目的是消除一些混淆，并帮助减少开发者在学习 TDD 流程时遇到的陷阱。这种新的 TDD 方法被称为 **行为驱动开发**（**BDD**）。BDD 为测试提供了一个结构，以及业务需求和单元测试之间沟通的一种几乎无缝的方式。

# 流程

没有目标开始任何旅程都是困难的。有一些技巧和窍门可以帮助你开始 TDD。首先是“红色”，“绿色”，“重构”。

# 红色，绿色，重构

我们已经讨论了在编写生产代码之前编写失败的测试。目标是通过对一系列微小改进的逐步构建系统。这通常被称为“红色”，“绿色”，“重构”。我们编写一个小测试（红色），然后通过编写一些生产代码使其通过（绿色），然后在我们再次开始之前重构我们的代码（重构）。

许多 TDD 实践者提倡先进行“存在性”测试。这将有助于确定你的环境设置是否正确，你不会收到错误的阳性结果。如果你编写了一个“存在性”测试并且一开始没有失败，你就知道有问题。一旦你收到第一个失败，你就可以安全地创建正在测试的类、方法或函数。这也会确保你在确定系统正常工作之前，不会一头扎进代码中，写下一行又一行的代码。

一旦你有了第一个失败和第一个工作示例，就是时候缓慢地扩展应用程序了。选择下一个最有趣的步骤，并编写一个失败的测试来覆盖这一步骤。

在每次迭代中，你应该暂停并评估是否可以进行任何清理工作。你能简化代码块吗？或许需要一个更具描述性的变量名？是否可以在此时安全地纠正代码中的错误？评估生产代码和测试套件都很重要。两者都应该是干净、准确且可维护的。毕竟，如果代码如此混乱，以至于没有人能够理解，那么代码还有什么价值？

# 程序员阻塞

TDD 也会帮助你避免作家们常说的“作家阻塞”和我们所称的“程序员阻塞”。程序员阻塞发生在你坐在键盘前试图解决问题，但不知道从何开始的时候。我们从开始的地方开始。写下你能想象的最简单、最简单的测试。写“存在性”。

# 我们为什么要关心？

我们是专业人士。我们希望做好工作。如果有人发现我们的代码有问题，我们会感到难过。如果 QA 发现了一个错误，我们会感到悲伤。如果我们的系统用户遇到了错误，我们可能会哭泣。我们应该努力交付高质量的、无错误的代码和一个功能齐全、特性丰富的应用程序。

我们也很懒惰，但这是好懒惰。我们不想不得不运行整个应用程序来验证一个简单的函数是否返回正确的值。

# TDD 的反对意见

对 TDD 的反对意见，有些是合理的，有些则不然。很可能你已经听说过一些，而且很可能你自己也重复过其中的一些。

# 测试需要时间

当然，测试需要时间。编写单元测试需要时间。遵循 TDD 的 *红、绿、重构* 循环确实需要时间。但是，如果不通过测试，你还能如何检查你的工作呢？

你验证了你编写的代码是否工作吗？没有测试你怎么做这件事？你是手动运行应用程序吗？这需要多长时间？在应用程序中有没有需要考虑的条件场景？你需要在手动测试应用程序时设置这些场景吗？你会跳过一些并只是 *相信它们会工作* 吗？

关于回归测试呢？如果你在一天、一周或一个月后进行更改怎么办？你是否必须手动回归测试整个应用程序？如果其他人进行了更改呢？你会信任他们像你一样彻底地进行测试，*我相信你会的*？

如果你的代码被一个你可以点击按钮运行的测试套件所覆盖，你会节省多少时间？

# 测试是昂贵的

通过编写测试，你实际上是在增加你正在编写的代码量，对吧？好吧，是的，也不是。好吧，在极端情况下，你可能会接近双倍代码。再次强调，*在极端情况下*。

不要把测试作为一项单独的条款。

在某些情况下，咨询公司已经将单元测试写入合同中，并附有条款和金额。不可避免的是，这给了客户机会争论删除这一条款，从而节省他们的钱。这是绝对错误的方法。测试将会进行，这是肯定的，无论是手动由开发者运行应用程序来验证其工作，还是由 QA 测试人员，或者由自动化测试套件。测试不是一个可以协商或删除的条款（哎呀！）。

你永远不会购买一个没有通过质量控制检验的汽车。灯泡必须通过检验。客户、客户或公司永远不会通过放弃测试来节省钱。问题变成了，你是早期在编写代码时编写测试，还是稍后手动编写？

# 测试是困难的

测试可能是困难的。这尤其适用于没有考虑到可测试性的应用程序。如果你在代码中使用了静态方法和散布着具体引用的实现，你将在以后添加测试时遇到困难。

# 我们不知道怎么做

*我不知道怎么测试* 真的是唯一可以接受的回答，前提是它很快就被 *但我愿意学习* 所跟随。我们是开发者。我们是房间里专家。我们被付钱来知道答案。承认自己不知道某事是可怕的。开始新事物更是如此。请放心，一切都会好起来的。一旦你掌握了 TDD，你会 wonder 你以前是怎么做到的。你会把那些时光称为 *黑暗时代，在轮子的发现之前*。

# TDD 的支持性论点

我们在这里想关注的是积极的方面，是支持 TDD 的论点。

# 减少了手动测试的劳动强度

我们已经提到，作为专业人士，我们不会在没有首先确定它是否工作的情况下发布任何东西。把东西扔给质量保证团队、用户或公众，并希望一切按预期工作，这并不是我们的业务方式。我们将验证我们的代码和应用程序是否按预期工作。在开始时，当应用程序规模小且功能有限时，我们可以手动测试我们能想到的一切。但是，随着应用程序规模和复杂性的增长，开发者或其他人手动测试整个应用程序是不切实际的。手动做这件事既耗时又昂贵。我们可以通过自动化测试来节省时间和我们的客户以及公司的金钱。我们可以从开始就通过 TDD 轻松地做到这一点。

# 减少错误数量

随着我们的应用程序增长，我们的测试也在增长。或者说，我们的测试套件已经增长，通过使我们的测试通过，我们的应用程序也在增长。随着两者的增长，我们已经覆盖了快乐路径（例如：2 + 2 = 4）以及潜在的失败（例如：2 + 香蕉 = 异常）。如果正在测试的方法或函数可以接受输入参数，那么存在失败的可能性。通过编写代码来防范这些场景，您可以减少意外行为、错误和异常的可能性。当您编写测试来表示潜在的失败时，您的生产代码将自然而然地变得更加健壮，并且更不容易出错。如果某个错误悄悄溜过并进入质量保证阶段，甚至进入生产环境，那么添加一个新的测试来覆盖新发现的缺陷是非常容易的。

以这种方式处理错误的附加好处是，相同的错误很少会在以后的某个时间再次出现，因为新的测试可以防止这种情况。如果相同的错误确实出现了，您知道，尽管发生了相同的结果，但错误是以新的和不同的方式发生的。通过添加另一个测试来覆盖这个新场景，这很可能是您最后一次看到这个老问题。

# 确保一定程度的正确性

通过一套全面的测试套件，您可以展示一定程度的正确性。在某个时候，某个地方的人会问您是否已经完成。您将如何展示您已经向应用程序添加了所需的功能？

# 消除了重构的恐惧

让我们面对现实，我们所有人都曾参与过我们不敢触碰的遗留应用程序的开发工作。想象一下，如果您负责修改的类被一套全面的单元测试所覆盖，那会多么容易。想象一下，做出改变后，知道一切如常，因为所有的单元测试仍然通过，这是多么简单。

# 更好的架构

编写单元测试往往会推动你的代码向解耦设计发展。紧密耦合的代码很快就会变得难以测试，因此，为了使生活更轻松，测试驱动开发者会开始解耦代码。解耦的代码更容易替换，这意味着，而不是修改一团糟的生产代码，开发者通常只需要替换一个子组件的新模块代码，就能做出必要的更改。

# 更快的开发

起初可能感觉不到（事实上，一开始肯定感觉不到），但编写单元测试是加快开发速度的绝佳方式。传统上，开发者从业务那里接收需求，坐下来，开始从指尖发射闪电，让代码倾泻而出，直到编写出一个可执行的应用程序。在 TDD 之前，开发者会写几分钟代码，然后启动应用程序，看看代码是否工作。当发现错误时，开发者会修复它，再次启动应用程序以检查修复是否有效。通常，开发者会发现她的修复破坏了其他东西，然后她必须追查她破坏了什么，并编写另一个修复。描述的过程可能是你以及世界上每个其他开发者都熟悉的过程。想象一下，你在进行开发者测试时发现并修复的 bug 浪费了多少时间。这还不包括由 QA 或客户在生产中发现的 bug。

现在，让我们想象另一个场景。在学习 TDD 之后，当我们从业务那里收到需求时，我们会迅速将这些需求直接转换为测试。随着每个测试通过，我们知道根据需求，我们的代码确实做了它被要求做的事情。我们可能会在过程中发现一些边缘情况，并创建测试来确保代码对每个边缘情况都有正确的行为。在测试通过后才发现测试失败的情况是很少见的。但是，当我们导致测试失败时，我们可以通过使用编辑器中的撤销命令快速修复它。这使我们几乎不需要运行应用程序，直到我们准备好将更改提交给 QA 和业务。尽管如此，我们仍然试图在提交之前验证应用程序的行为是否符合要求，但现在我们不是每几分钟手动做这件事。相反，每次你保存文件时，让你的单元测试验证你的代码。

# 不同类型的测试

在这本书的整个过程中，我们将倾向于一种特定的测试风格，但了解其他人将使用的术语很重要，这样你才能在他们谈论某种类型的测试时建立联系。

# 单元测试

让我们直接进入最被误用和最不被理解的测试类型。在 Kent Beck 的书籍《通过示例进行测试驱动开发》中，他定义单元测试为一个简单地在与其他测试隔离的情况下运行的测试。这意味着，为了使一个测试成为单元测试，唯一必须发生的事情是测试不能受到其他测试副作用的影响。一些常见的误解是，单元测试不能击中数据库，或者它不能使用被测试的方法或函数之外的代码。这些说法并不正确。我们在测试中通常在第三方交互上划线。任何你的测试将要访问你正在编写的应用程序之外代码的情况，你应该抽象出这种交互。我们这样做是为了在测试设计上获得最大的灵活性，并不是因为它不是一个单元测试。有些人认为单元测试是唯一应该编写的测试。这是基于原始定义，而不是基于术语的常见用法。

# 验收测试

直接受业务需求影响的测试，如 BDD 中建议的，通常被称为验收测试。这些测试位于应用程序的最外层，并测试了大量的代码。为了减少测试和产品代码之间的耦合，你可以几乎完全编写这种风格的测试。我们的观点是，如果结果不能在应用程序外部观察到，那么它作为测试的价值就不大。

# 集成测试

集成测试是与外部系统集成的测试。例如，与数据库交互的测试将被视为集成测试。外部系统不必是第三方产品；然而，有时外部系统只是独立于你正在开发的应用程序开发的库，但仍被视为内部软件。另一个大多数人不考虑的例子是与系统或语言框架的交互。你可以将任何使用 C#的`DateTime`对象功能的测试视为集成测试。

# 端到端测试

这些测试验证了应用程序的整个配置和使用情况。从用户界面开始，端到端测试将程序性地点击按钮或填写表单。UI 将调用应用程序的业务逻辑，一直执行到应用程序的数据源。这些测试的目的是确保所有外部系统都已配置并正常运行。

# 每种测试类型的数量

许多开发者都会问这样一个问题：每种类型的测试应该使用多少个？根据 Kent Beck 的定义，每个测试都应该是一个单元测试。我们将在稍后讨论测试的变体，这些变体会对每种类型的具体数量产生影响；但一般来说，你可能期望一个应用程序只有很少的端到端测试，稍微多一点集成测试，主要由验收测试组成。

# 单元测试的各个部分

要开始并确保你有可读性强的代码，最简单的方法是使用*安排*、*行动*和*断言*来结构化你的测试。

# 安排

也称为单元测试的上下文，*安排*包括作为测试先决条件的任何存在的事物。这包括从存储在变量中以改善可读性的参数值，到在测试运行时配置模拟数据库中的值以注入到你的应用程序中的所有内容。

关于模拟的更多信息，请参阅第三章，“设置 JavaScript 环境”，*抽象第三方软件*和*测试双倍类型*部分。

# 行动

动作，作为单元测试的一部分，仅仅是正在被测试的生产代码的一部分。通常，这可能是你代码中的一个单独的方法或函数。每个测试应该只有一个动作。有多个动作会导致测试更加混乱，并且对代码应该更改以使测试通过的位置的确定性更少。

# 断言

结果，或*断言*（预期的结果），正如其名。如果你期望被测试的方法将返回 3，那么你将编写一个验证该期望的断言。单一断言规则指出，每个测试应该只有一个断言。这并不意味着你只能断言一次；相反，这意味着你的断言应该只确认一个逻辑期望。作为一个快速示例，你可能有一个方法，在应用过滤器后返回一个项目列表。在设置测试上下文后调用该方法将导致只包含一个项目的列表，并且该项目将匹配我们定义的过滤器。在这种情况下，你将有一个针对列表中项目数量的程序性断言，以及一个针对我们正在测试的过滤器准则的程序性断言。

# 需求

虽然这本书不是关于业务分析或需求生成的，但需求将对你的有效测试驱动应用程序的能力产生巨大影响。我们将以适合高质量测试的格式提供这本书的需求。我们还将涵盖一些需求不太理想的情况，但在这本书的大部分内容中，需求都经过仔细推敲，以确保我们测试的系统有高质量的定义。

# 为什么它们很重要？

我们坚信，高质量的需求对于良好的解决方案至关重要。需求通知测试，而测试塑造代码。这个公理意味着，如果需求不佳，应用程序将导致质量较低的架构和整体设计。如果需求杂乱无章，产生的测试和应用程序将混乱且因素不佳。从积极的一面来看，即使考虑不周或书写不佳的需求，也不会是代码的终结。作为专业的软件开发人员，我们有责任纠正不良需求。我们的任务是提出问题，这些问题将导致更好的需求。

# 用户故事

用户故事通常在敏捷软件开发中用于需求定义。用户故事的形式相对简单，包括三个部分：`角色`、`请求`和`原因`。

```cs
As a <Role> 
 I want <Request> 
 So that <Reason> 
```

# 角色

用户故事的角色可以提供很多信息。在指定角色时，我们有能力暗示用户的能力。用户能否访问某些功能，或者他们是否因为身体残疾而需要以不同的方式与系统交互？我们还可以传达用户的心态。新用户可能会影响用户界面的设计，这与经验用户可能期望的相反。角色可以是通用用户、特定角色、角色或特定用户。

通用用户可能是最常用同时也是最不实用的。如果一个故事不能提供对用户的洞察，那么它通过不限制我们的上下文来限制我们对这个故事的决策。如果可能的话，请向你的业务分析师或产品负责人询问对需求对象更具体的定义。

定义一个特定的角色，例如管理员、用户或访客，可能非常有帮助。特定的角色提供了用户能力信息。有了特定的角色，我们可以确定用户是否应该被允许进入我们正在定义功能的应用程序部分。可能一个用户故事会导致用户在系统中的权限修改，仅仅因为我们指定了一个角色而不是一个通用的用户。

使用一个角色是广泛的角色类型中最具说明性的。角色是对一个虚构用户的完整定义。它包括一个名字，任何重要的生理特征，偏好，对应用程序主题的熟悉程度，对计算机的熟悉程度，以及可能影响虚构用户与软件交互的其他任何事物。通过拥有所有这些信息，我们可以开始模拟用户在系统中的行为。我们可以开始做出假设或决定，关于该用户会如何接近或对建议的功能有何感受，并且我们可以从这个用户的角度来设计用户界面。

# 请求

用户故事中的请求部分相对简单。我们应该有一个单独的功能或对请求的功能的小幅增加。通常，如果包括任何连接词，如*and*或*or*，请求就太大了。

# Reason

原因是陈述业务需求的地方。这是解释功能如何为公司增加价值的机会。通过将原因与角色联系起来，我们可以增强功能的有用性的影响。

一个完整的用户故事可能看起来如下：

```cs
As a Conference Speaker 
 I want to search for nearby conferences by open submission date 
 So that I may plan the submission of my talks 
```

# Gherkin

Gherkin 是一种常用于验收标准的需求定义风格。我们可以直接将这些需求转换为代码，QA 可以直接将它们转换为测试用例。Gherkin 格式通常与 BDD 相关联，并在 Dan North 关于该主题的原始文章中使用。

Gherkin 格式与用户故事格式一样简单。它由三个部分组成：`Given`、`When`和`Then`。

```cs
Given <Context> 
 And Given <More Context> 
 When <Action> 
 Then <Result> 
 And Then <More Results> 
```

# Givens

由于 Gherkin 格式相对简单，因此 givens 被拆分为每个上下文标准一个。在指定上下文的部分，我们希望看到这个场景的所有和任何先决条件。用户是否已登录？用户是否有任何特殊权限？这个场景是否需要在执行前设置任何设置？用户是否对这个场景提供了任何输入？还有一个需要考虑的问题是，应该只有少数几个 givens。

一个场景中存在的 givens 越多，这个场景太大或 givens 可以以某种方式逻辑分组以减少数量的可能性就越大。

当我们开始编写测试时，givens 相当于测试的 Arrange 部分。

# When

`when` 是用户执行的动作。应该只有一个动作，只有一个动作。这个动作将取决于 Given 定义的上下文，并输出 Then 期望的结果。在我们的应用程序中，这相当于一个函数或方法调用。

当我们开始编写测试时，When 相当于测试的 Act 部分。

# Then

*Thens* 等同于动作的输出。*Thens* 描述了可以从方法或函数的输出中验证和测试的内容，不仅限于开发者，还包括 QA。就像 givens 一样，我们希望我们的*Thens*在期望上是单一的。同样，如果我们发现太多的*Thens*，这可能是一个迹象，表明这个场景太大，或者我们过度指定了我们的期望。

当我们开始编写测试时，Then 相当于测试的 Assert 部分。

基于之前提出的用户故事的完整验收标准可能看起来如下：

```cs
Given I am a conference speaker 
 And Given a search radius of 25 miles 
 And Given an open submission start date 
 And Given an open submission end date 
 When I search for conferences 
 Then I receive only conferences within 25 miles of my location 
 And Then I receive only conferences that are open for submission within the specified date range 
```

就像在生活中一样，这本书中并不是所有内容都会完美。你看到前面验收标准中的任何问题吗？继续，花几分钟时间检查它；我们会等待。

如果你已经放弃了，我们会告诉你。上面的验收标准太长了。有太多的前提条件和太多的结果。这是怎么发生的？我们怎么能犯这样的错误呢？当我们编写用户故事时，我们无意中包含了太多信息，因为我们指定的原因。如果你回顾一下用户故事，你会看到我们无意中在请求中加入了“附近”。添加“附近”似乎无害；甚至似乎更正确。作为用户，我对为了我的演讲活动走得太远并不感兴趣。

当你开始看到用户故事或验收标准像这样失控时，你有责任与业务分析师或产品所有者交谈，并与他们合作以缩小需求范围。在这种情况下，我们可以提取两个用户故事和几个验收标准。

这里是我们一直在审查的要求的完整示例：

```cs
As a conference speaker 
 I want to search for nearby conferences 
 So that I may plan the submission of my talks 
Given I am a conference speaker 
 And Given search radius of five miles 
 When I search for conferences 
 Then I receive only conferences within five miles of my location 
Given I am a conference speaker 
 And Given search radius of 10 miles 
 When I search for conferences 
 Then I receive only conferences within 10 miles of my location 
Given I am a conference speaker 
 And Given search radius of 25 miles 
 When I search for conferences 
 Then I receive only conferences within 25 miles of my location 

As a conference speaker 
 I want to search for conferences by open submission date 
 So that I may plan the submission of my talks 
Given I am a conference speaker 
 And Given open submission start and end dates 
 When I search for conferences 
 Then I receive only conferences that are open for submission within the specified date range 
Given I am a conference speaker 
 And Given an open submission start date 
 And Given an empty open submission end date 
 When I search for conferences 
 Then an INVALID_DATE_RANGE error occurs for open submission date 
Given I am a conference speaker 
 And Given an empty open submission start date 
 And Given an open submission end date 
 When I search for conferences 
 Then an INVALID_DATE_RANGE error occurs for open submission date 
```

我们还没有讨论过用户故事和验收标准的内容方法。我们相信，需求应该尽可能不涉及用户界面和数据存储机制。因此，在需求示例中，你会发现没有任何关于按钮、表格、模态/弹出窗口、点击或输入的引用。据我们所知，这个应用程序可能正在虚拟现实头盔中运行，具有自然用户界面。同样，它也可能作为一个 RESTful Web API 运行，或者可能是一个手机应用程序。需求应该指定系统交互，而不是部署环境。

在软件开发中，确保高质量需求是每个人的责任。如果你发现你收到的需求太大、太模糊、依赖于用户界面或只是无用的，你有责任与你的业务分析师或产品所有者合作，使需求更好，并准备好开发和质量保证。

# 我们的第一组 C#测试

你是否曾在 Visual Studio 中创建过新的 MVC 项目？你注意到对话框底部的复选框了吗？你是否曾经选择过“创建单元测试项目”？使用此单元测试项目创建的测试在很大程度上几乎无用。它们所做的只是验证默认的 MVC 控制器返回正确的类型。这也许比“存在”多了一步。让我们看看为我们创建的第一组测试：

```cs
using System.Web.Mvc;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using SampleApplication.Controllers;

namespace SampleApplication.Tests.Controllers
{
  [TestClass]
  public class HomeControllerTest
  {
    [TestMethod]
    public void Index()
    {
      // Arrange
      HomeController controller = new HomeController();

      // Act
      ViewResult result = controller.Index() as ViewResult;

      // Assert
      Assert.IsNotNull(result);
    }

    [TestMethod]
    public void About()
    {
      // Arrange
      HomeController controller = new HomeController();

      // Act
      ViewResult result = controller.About() as ViewResult;

      // Assert
      Assert.AreEqual("Your application…", result.ViewBag.Message);
    }

    [TestMethod]
    public void Contact()
    {
      // Arrange
      HomeController controller = new HomeController();

      // Act
      ViewResult result = controller.Contact() as ViewResult;

      // Assert
      Assert.IsNotNull(result);
    }
  }
}
```

在这里，我们可以看到测试类的基本结构，以及其中包含的测试用例。Visual Studio 默认提供 MSTest，这就是我们在这里看到的内容。测试类必须用`[TestClass]`属性装饰。单个测试同样也必须用`[TestMethod]`属性装饰。这允许测试运行程序确定要执行哪些测试。我们将在未来的章节中介绍这些属性以及更多内容。其他测试框架使用类似的方法，我们将在稍后讨论。

目前，我们可以看到 `HomeController` 正在被测试。每个公共方法都有一个单独的测试，你可能想要创建额外的测试，或者将来将测试提取到单独的文件中。稍后我们将介绍选项和最佳实践，帮助你以更可管理的方式组织文件。所有这些都应该是你 *red, green, refactor* 循环中的 *refactor* 步骤的一部分。

# 使用测试增长应用程序

也许你想要接受你的端点之一的一个参数。也许你会接受访客的名字来显示友好的问候。让我们看看我们如何实现这一点：

```cs
[TestMethod]
public void ItTakesOptionalName()
{
  // Arrange
  HomeController controller = new HomeController();

  // Act
  ViewResult result = controller.About("") as ViewResult;

  // Assert
  Assert.AreEqual("Your application description page.", result.ViewBag.Message);
}
```

我们首先创建一个测试，允许 `About` 方法接受一个可选的字符串参数。我们开始的想法是这个参数是可选的，因为我们不希望破坏任何现有的测试。让我们看看修改后的方法：

```cs
public ActionResult About(string name = default(string))
{
  ViewBag.Message = "Your application description page.";
  return View();
}    
```

现在，让我们使用 `name` 参数并将其附加到我们的 `ViewBag.Message` 上。等等，不是控制器。我们需要先添加一个新的测试：

```cs
[TestMethod]
public void ItReturnsNameInMessage()
{
  // Arrange
  HomeController controller = new HomeController();

  // Act
  ViewResult result = controller.About("Fred") as ViewResult;

  // Assert
  Assert.AreEqual("Your application description page.Fred", result.ViewBag.Message); 
}
```

现在我们将使这个测试通过：

```cs
public ActionResult About(string name = default(string))
{
  ViewBag.Message = $"Your application description page.{name}";
  return View();
}
```

# 我们在 JavaScript 中的第一个测试

为了在 JavaScript 中启动，我们将编写一个 `Simple Calculator` 类。我们的计算器只有一个要求，即添加或减去一组数字。你用 TDD 编写的许多代码都将从非常简单开始，就像这个例子一样：

```cs
import { expect } from 'chai'

class SimpleCalc {
  add(a, b) {
    return a + b;
  }

  subtract(a, b) {
    return a - b;
  }
}

describe('Simple Calculator', () => {
  "use strict";

  it('exists', () => {
    // arrange
    // act
    // assert
    expect(SimpleCalc).to.exist;
  });

  describe('add function', () => {
    it('exists', () => {
      // arrange
      let calc;

      // act
      calc = new SimpleCalc();

      // assert
      expect(calc.add).to.exist;
    });

    it('adds two numbers', () => {
      // arrange
      let calc = new SimpleCalc();

      // act
      let result = calc.add(1, 2);

      // assert
      expect(result).to.equal(3);
    });
  });

  describe('subtract function', () => {
    it('exists', () => {
      // arrange
      let calc;

      // act
      calc = new SimpleCalc();

      // assert
      expect(calc.subtract).to.exist;
    });

    it('subtracts two numbers', () => {
      // arrange
      let calc = new SimpleCalc();

      // act
      let result = calc.subtract(3, 2);

      // assert
      expect(result).to.equal(1);
    });
  });
});
```

如果前面的代码现在看起来不太明白，不要担心；这只是一个快速示例，展示一些正在工作的测试代码。这里使用的测试框架是 Mocha，使用的断言库是 `chai`。在 JavaScript 社区中，大多数测试框架都是基于行为驱动开发（BDD）构建的。上面代码示例中描述的每个都代表一个场景或更高层次的抽象需求；而每个 `it` 都代表一个特定的测试。在测试中，唯一必需的元素是 `expect`，没有它测试将不会产生有价值的结果。

继续这个例子，假设我们收到一个需求，即加法和减法方法必须允许链式调用。我们将如何应对这个需求？有很多方法，但在这个情况下，我认为我想要快速重新设计，然后添加一些新的测试。首先，我们将进行重新设计，再次由测试驱动。

通过在 `describe` 或 `test` 上放置 `only`，我们可以隔离那个 `describe`/`test`。在这种情况下，我们想要隔离我们的 `add` 测试，并从这里开始做出更改：

```cs
it.only('adds two numbers', () => {
  // arrange
  let calc = new SimpleCalc(1);

  // act
  let result = calc.add(2).result;

  // assert
  expect(result).to.equal(3);
});
```

之前，我们已经将测试更改为使用一个接受数字的构造函数。我们还减少了 `add` 函数的参数数量到一个。最后，我们添加了一个必须用于评估加法结果的结果值。

测试将失败，因为它没有使用与类相同的接口，所以现在我们必须对类进行更改：

```cs
class SimpleCalc {
  constructor(value) {
    this._startingPoint = value || 0;
  }

  add(value) {
    return new SimpleCalc(this._startingPoint + value);
  }
  ... 
  get result() {
    return this._startingPoint;
  }
}
```

这个更改应该会使我们的测试通过。现在，是时候为 `subtract` 方法做出类似的变化了。首先，移除上一个例子中放置的 `only`：

```cs
it('subtracts two numbers', () => {
  // arrange
  let calc = new SimpleCalc(3);

  // act
  let result = calc.subtract(2).result;

  // assert
  expect(result).to.equal(1);
});
```

现在是类中适当的更改：

```cs
subtract(value) {
  return new SimpleCalc(this._startingPoint – value);
}
```

我们现在的测试又通过了。接下来我们应该做的是创建一个测试来验证一切是否正常工作。如果你想要尝试，我们将把这个测试留给你作为练习。

# 为什么这很重要？

那么，这一切为什么很重要？为什么我们要编写比必需的更多的代码？因为它值得。说实话，大多数时候这并不是更多的代码。当你花时间用测试来扩展你的应用时，会产生简单的解决方案。简单的解决方案通常比你可能想出的光滑解决方案要少很多代码。而且不可避免的是，光滑的解决方案容易出错，难以维护，并且往往只是完全错误。

# 摘要

如果你之前没有，你现在应该对 TDD 是什么以及为什么它很重要有一个很好的了解。你已经接触到了 C#和 JavaScript 中的单元测试，以及编写测试如何有助于应用的增长。

随着我们继续前进，我们将更多地了解 TDD。我们将探讨编写可测试代码的含义。

在第二章 *设置.NET 测试环境* 中，我们将设置你的开发环境并探索单元测试的更多方面。
