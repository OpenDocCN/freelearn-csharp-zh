<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    A Short Primer to Programming in Unity
                </header>
            
            <article>
                
<p class="mce-root">This chapter is a short primer to help you get familiar with advanced C# language and Unity engine features. I'm not going to attempt to explain in depth any of the subject matter presented here because it's beyond the scope of this book. Still, I will at least introduce you to some core concepts to avoid confusion when they are referenced in the upcoming chapters. I encourage those that have advanced knowledge of C# and Unity programming to skip this chapter. But I recommend beginners and intermediate developers take the time to review the content of this chapter to get a general idea of the language and engine features we will use to implement and design our game systems.</p>
<p class="mce-root">In all cases, complete mastery over C# and Unity is not needed to comprehend this book, just general awareness and familiarity with some advanced critical concepts.</p>
<p>In this chapter, we will go through the following topics:</p>
<ul>
<li><span>What you should already know</span></li>
<li>C# language features</li>
<li><span>Unity engine features </span></li>
</ul>
<div class="packt_infobox">The code showcased in this chapter is for educational purposes only. It has not been optimized and is not meant to be used in production code.</div>
<h1 id="uuid-b3d4f064-e750-47dd-b00d-881eebeb39e1">What you should already know</h1>
<p>In this section, I'm listing some core C# language and Unity engine features that you should already be familiar with before continuing to more advanced parts of this book.</p>
<p><strong>The following are some core features of C#</strong>:</p>
<ul>
<li>Familiarity with class access modifiers such as public and private</li>
<li><span>Fundamental knowledge of basic primitive data types (int, string, bool, float, and arrays)</span></li>
<li>A conceptual understanding of inheritance and the relation between a base class and a derived class</li>
</ul>
<p><strong>The following are some core features of Unity</strong>:</p>
<ul>
<li>A basic understanding of how to write a <kbd>MonoBehaviour</kbd> script and attach it to a <kbd>GameObject</kbd> as a component</li>
<li><span>Ability to create a new Unity Scene from scratch and manipulate GameObjects inside the editor</span></li>
<li>Familiarity with Unity's basic event functions (<kbd>Awake</kbd>, <kbd>Start</kbd>, <kbd>Update</kbd>) and their sequence of execution </li>
</ul>
<p>If you are not familiar with the concepts listed previously, I would recommend reading the books and documentation that are listed in the <em>Further reading</em> section of this chapter. </p>
<h1 id="uuid-967a6d8a-33ec-4b15-bea8-945d453f566d">C# language features</h1>
<div class="packt_infobox">Languages features such as events and delegates might be too advanced for beginners, so if you consider yourself in that category, don't worry; you can still enjoy this book. Just read the beginner-level chapters such as the ones that explain patterns such as Singleton, State, Facade, and Adapter.</div>
<p>The following C# advanced language features are fundamental to the optimal implementation of some design patterns that we will be implementing in the upcoming chapters:</p>
<ul>
<li class="mce-root"><span><span><strong>Static</strong>: Methods and members of a class with the <kbd>static</kbd> keyword can be accessed directly with its name and without initializing an instance. Static methods and members are helpful because they are easily accessible from anywhere in your code. The following example showcases a class that uses the keyword to establish a globally accessible event bus:<br/></span></span></li>
</ul>
<pre style="padding-left: 60px"><span>using </span><span>UnityEngine</span><span>.</span><span>Events</span><span>;<br/></span><span>using </span><span>System</span><span>.</span><span>Collections</span><span>.</span><span>Generic</span><span>;<br/></span><span><br/></span><span>namespace </span><span>Chapter</span><span>.</span><span>EventBus<br/></span><span>{<br/></span><span>    </span><span>public class </span><span>RaceEventBus<br/></span><span>    </span><span>{</span><span><br/></span><span>        </span><span>private static readonly <br/></span><span>            IDictionary</span><span>&lt;</span><span>RaceEventType</span><span>, </span><span>UnityEvent</span><span>&gt; <br/></span><span>            Events </span><span>=</span><span> </span><span>new </span><span>Dictionary</span><span>&lt;</span><span>RaceEventType</span><span>, </span><span>UnityEvent</span><span>&gt;();<br/></span><span><br/></span><span>        </span><span>public static void </span><span>Subscribe</span><span>(<br/></span><span>            RaceEventType </span><span>eventType, </span><span>UnityAction </span><span>listener)<br/></span><span>        {<br/></span><span>            </span><span>UnityEvent </span><span>thisEvent;<br/></span><span>            </span><span>if </span><span>(</span><span>Events</span><span>.</span><span>TryGetValue</span><span>(eventType, </span><span>out </span><span>thisEvent))<br/></span><span>            {<br/></span><span>                thisEvent.</span><span>AddListener</span><span>(listener);<br/></span><span>            }<br/></span><span>            </span><span>else<br/></span><span>            </span><span>{<br/></span><span>                thisEvent = </span><span>new </span><span>UnityEvent</span><span>();<br/></span><span>                thisEvent.</span><span>AddListener</span><span>(listener);<br/></span><span>                </span><span>Events</span><span>.</span><span>Add</span><span>(eventType, thisEvent);<br/></span><span>            }<br/></span><span>        }<br/></span><span><br/></span><span>        </span><span>public static void </span><span>Unsubscribe</span><span>(<br/></span><span>            RaceEventType </span><span>eventType, </span><span>UnityAction </span><span>listener)<br/></span><span>        {<br/></span><span>            </span><span>UnityEvent </span><span>thisEvent;<br/></span><span>            </span><span>if </span><span>(</span><span>Events</span><span>.</span><span>TryGetValue</span><span>(eventType, </span><span>out </span><span>thisEvent))<br/></span><span>            {<br/></span><span>                thisEvent.</span><span>RemoveListener</span><span>(listener);<br/></span><span>            }<br/></span><span>        }<br/></span><span><br/></span><span>        </span><span>public static void </span><span>Publish</span><span>(</span><span>RaceEventType </span><span>eventType)<br/></span><span>        {<br/></span><span>            </span><span>UnityEvent </span><span>thisEvent;<br/></span><span>            </span><span>if </span><span>(</span><span>Events</span><span>.</span><span>TryGetValue</span><span>(eventType, </span><span>out </span><span>thisEvent))<br/></span><span>            {<br/></span><span>                thisEvent.</span><span>Invoke</span><span>();<br/></span><span>            }<br/></span><span>        }<br/></span><span>    </span><span>}</span><span><br/></span><span>}</span></pre>
<ul>
<li class="mce-root"><strong>Events</strong><span>: An event permits an object that acts as a publisher to send out a signal that other objects can receive; these objects that listen for a particular event are called subscribers. Events are useful when you want to build an event-driven architecture.</span> <span>The following is an example of a class that publishes events:</span></li>
</ul>
<pre style="padding-left: 60px"><span>using </span><span>UnityEngine</span><span>;<br/></span><span>using </span><span>System</span><span>.</span><span>Collections</span><span>;<br/></span><span><br/></span><span>public class </span><span>CountdownTimer </span>: <span>MonoBehaviour<br/></span><span>{<br/>    </span><span>public delegate void </span><span>TimerStarted</span><span>(); <br/>    </span><span>public static event </span><span>TimerStarted </span><span>OnTimerStarted</span><span>;<br/></span><span>     <br/>    </span><span>public delegate void </span><span>TimerEnded</span><span>(); <br/>    </span><span>public static event </span><span>TimerEnded </span><span>OnTimerEnded</span><span>;<br/></span><span>        <br/>    </span><span>[</span><span>SerializeField</span><span>]<br/>    </span><span>private float </span><span>duration </span><span>= </span><span>5.0f</span><span>;<br/></span><span>        <br/>    </span><span>void </span><span>Start</span><span>()<br/>    </span><span>{<br/>        </span><span>StartCoroutine</span><span>(</span><span>StartCountdown</span><span>());<br/>    </span><span>}<br/></span><span><br/>    private </span><span>IEnumerator </span><span>StartCountdown</span><span>()<br/>    </span><span>{<br/>        </span><span>if </span><span>(</span><span>OnTimerStarted </span><span>!= </span><span>null</span><span>) <br/>            </span><span>OnTimerStarted</span><span>();<br/></span><span>         <br/>        </span><span>while </span><span>(</span><span>duration </span><span>&gt; </span><span>0</span><span>)<br/>        </span><span>{<br/>            </span><span>yield return new </span><span>WaitForSeconds</span><span>(</span><span>1f</span><span>);<br/>            </span><span>duration</span><span>--;<br/>        </span><span>}<br/></span><span>        <br/>        if </span><span>(</span><span>OnTimerEnded </span><span>!= </span><span>null</span><span>) <br/>            </span><span>OnTimerEnded</span><span>();<br/>    </span><span>}<br/></span><span>        <br/>    </span><span>void </span><span>OnGUI</span><span>()<br/>    </span><span>{<br/>        </span><span>GUI</span><span>.</span><span>color </span><span>= </span><span>Color</span><span>.</span><span>blue</span><span>;<br/>        </span><span>GUI</span><span>.</span><span>Label</span><span>(<br/></span><span>            new </span><span>Rect</span><span>(</span><span>125</span><span>, </span><span>0</span><span>, </span><span>100</span><span>, </span><span>20</span><span>), </span><span>"COUNTDOWN: " </span><span>+ </span><span>duration</span><span>)<br/>    </span><span>}<br/></span><span>}</span></pre>
<ul>
<li class="mce-root"><span><strong>Delegates</strong>: The concept behind delegates is simple when you understand their underlying low-level mechanism. A high-level definition of delegates is that they hold references to functions. But this is a very abstract definition of what delegates actually do behind the scenes. They're function pointers, which means that they hold the memory address to other functions. So, we could visualize them as an address book that contains a list of locations of functions. That is why a delegate can hold multiple of them and call them all at once. The following is an example of a class that subscribes to events triggered by a publisher class by assigning specific local functions to the publisher's delegates:<br/></span></li>
</ul>
<pre style="color: black;padding-left: 60px">using UnityEngine;<br/><br/>public class Buzzer : MonoBehaviour<br/>{<br/>    void OnEnable()<br/>    {<br/>        // Assigning local functions to delegates defined in the <br/>        // Timer class<br/>        CountdownTimer.OnTimerStarted += PlayStartBuzzer;<br/>        CountdownTimer.OnTimerEnded += PlayEndBuzzer;<br/>    }<br/><br/>    void OnDisable()<br/>    {<br/>        CountdownTimer.OnTimerStarted -= PlayStartBuzzer;<br/>        CountdownTimer.OnTimerEnded -= PlayEndBuzzer;<br/>    }<br/><br/>    void PlayStartBuzzer()<br/>    {<br/>        Debug.Log("[BUZZER] : Play start buzzer!");<br/>    }<br/><br/>    void PlayEndBuzzer()<br/>    {<br/>        Debug.Log("[BUZZER] : Play end buzzer!");<br/>    }<br/>}</pre>
<ul>
<li class="mce-root"><span><strong>Generics</strong>: A relevant C# feature that permits the deferred specification of a type until the class is declared and instantiated by the client. When we say a class is generic, it doesn't have a defined object type. The following is an example of a generic class and can act as a template:<br/></span></li>
</ul>
<pre style="color: black;padding-left: 60px">// &lt;T&gt; can be any type.<br/>public class Singleton&lt;T&gt; : MonoBehaviour where T : Component<br/>{<br/>    // ...<br/>}</pre>
<ul>
<li><span><span><span><strong>Serialization</strong>:<strong> </strong>Serialization is the process of converting an instance of an object into a binary or textual form. This mechanism permits us to preserve the state of an object in a file. The following is an example of a function that serializes an instance of an object and saves it as a file:</span></span></span></li>
</ul>
<pre style="padding-left: 60px"><span>private void </span><span>SerializePlayerData</span><span>(</span>PlayerData <span>playerData)<br/></span><span>{</span><span><br/></span><span>    </span><span>// Serializing the PlayerData instance<br/></span><span>    </span>BinaryFormatter <span>bf = </span><span>new </span>BinaryFormatter<span>();<br/></span><span>    </span>FileStream <span>file = </span>File<span>.</span>Create<span>(</span>Application<span>.</span>persistentDataPath <span>+ <br/></span><span>        "/playerData.dat"</span><span>);<br/></span><span>    bf.</span>Serialize<span>(file, playerData);<br/></span><span>    file.</span>Close<span>();<br/></span><span>}</span></pre>
<p>C# is a programming language with a lot of depth so it would be impossible for me to explain each of its core features within the scope of this book. Those presented in this section of this book are very useful and will help us implement the game systems and patterns described in the upcoming chapters.</p>
<h1 id="uuid-d70ab462-6235-4195-977d-910cf8bd0825">Unity engine features </h1>
<p>Unity is a fully featured engine, including a comprehensive scripting API, an animation system, and many additional features for game development. We can't cover them all in this book, so I will only list the core Unity components that we will be using in the upcoming design pattern chapters:</p>
<ul>
<li><strong>Prefabs</strong>: A prefab is a prefabricated container of assembled GameObjects and components. For example, you can have individual prefabs for each type of vehicle in your game and dynamically load them in your scene. Prefabs permit you to construct and organize reusable game entities as building blocks.</li>
<li><strong>Unity Events and Actions</strong>: Unity has a native event system; it's very similar to the C# event system but with extra engine-specific features, such as the ability to view and configure them in the Inspector.</li>
<li><span><span><strong>ScriptableObjects</strong>: A class that derives from the <kbd>ScriptableObject</kbd> base class can act as a data container. The other native Unity base class, named MonoBehaviour, is used to implement behaviors. Therefore, it's recommended to use MonoBehaviours to contain your logic and ScriptableObjects to contain your data. An instance of a <kbd>ScriptableObject</kbd> can be saved as an asset and is often used for authoring workflows. It permits non-programmers to create new variations of a specific type of entity without a single line of code.</span></span></li>
</ul>
<p style="padding-left: 60px">The following is an example of a simple <kbd>ScriptableObject</kbd> <span>that permits creating new configurable</span> <kbd>Sword</kbd> <span>instances:</span></p>
<pre style="color: black;padding-left: 60px">using UnityEngine;

[CreateAssetMenu(fileName = "NewSword", menuName = "Weaponary/Sword")]
public class Sword: ScriptableObject <br/>{
    public string swordName;<br/>    public string swordPrefab;
}</pre>
<ul>
<li class="mce-root"><strong>Coroutines</strong>: <span>The concept of coroutines is not limited to Unity but is an essential tool of the Unity API. The typical behavior of a function is to execute itself from start to finish. But a coroutine is a function with the extra ability of waiting, timing, and even pausing its execution process. These additional features permit us to implement complex behaviors that are not easy to do with conventional functions. Coroutines are similar to threads but provide concurrency instead of parallelism. The following code example showcases the implementation of a countdown timer using coroutines:<br/></span></li>
</ul>
<pre style="padding-left: 60px"><span>using </span><span>UnityEngine</span><span>;<br/></span><span>using </span><span>System</span><span>.</span><span>Collections</span><span>;<br/></span><span><br/></span><span>public class </span><span>CountdownTimer </span>: <span>MonoBehaviour<br/></span><span>{</span><span><br/></span><span>    </span><span>private float </span><span>_duration </span><span>= </span><span>10.0f</span><span>;<br/></span><span><br/></span><span>    </span><span>IEnumerator </span><span>Start</span><span>()<br/></span><span>    {<br/></span><span>        </span><span>Debug</span><span>.</span><span>Log</span><span>(</span><span>"Timer Started!"</span><span>);<br/></span><span>        </span><span>yield return </span><span>StartCoroutine</span><span>(</span><span>WaitAndPrint</span><span>(</span><span>1.0F</span><span>));<br/></span><span>        </span><span>Debug</span><span>.</span><span>Log</span><span>(</span><span>"Timer Ended!"</span><span>);<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>IEnumerator </span><span>WaitAndPrint</span><span>(</span><span>float </span><span>waitTime)<br/></span><span>    {<br/></span><span>        </span><span>while </span><span>(</span><span>Time</span><span>.</span><span>time </span><span>&lt; </span><span>_duration</span><span>)<br/></span><span>        {<br/></span><span>            </span><span>yield return new </span><span>WaitForSeconds</span><span>(waitTime);<br/></span><span>            </span><span>Debug</span><span>.</span><span>Log</span><span>(</span><span>"Seconds: " </span><span>+ </span><span>Mathf</span><span>.</span><span>Round</span><span>(</span><span>Time</span><span>.</span><span>time</span><span>));<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p class="mce-root"><span>As we can see, Unity has some rich but straightforward features that permit us to implement systems and organize data. We can't cover in depth each of Unity's core features because it's beyond the intended scope of the book. If you feel that you need more information about the engine before moving along, I recommend reviewing the material linked under the </span><em><span>Further reading</span></em><span> section.</span></p>
<h1 id="uuid-24171886-9e7a-42c6-95e6-8f8c56e92940">Summary</h1>
<p>This chapter is intended to be used as a primer to set up a shared knowledge base before moving along to the book's hands-on section. But mastery over the features presented in the previous sections is not required to start using design patterns in Unity. We will review some of them again in more detail in upcoming chapters, this time in a practical context.</p>
<p class="mce-root">In the next chapter, we are going to review our first pattern, the infamous Singleton. We will use it to implement a Game Manager class responsible for initializing the game.</p>
<h1 id="uuid-6930d1d8-f9d6-4d02-b7b7-2df836548071">Further reading</h1>
<p>For more information, you can refer to the following material:</p>
<ul>
<li><em>Learning C# by Developing Games with Unity 2020 </em>by Harrison Ferrone</li>
<li><em>Unity User Manual</em> by Unity Technologies: <a href="https://docs.unity3d.com/2021.1/Documentation/Manual/UnityManual.html">https://docs.unity3d.com/Manual/index.html</a></li>
</ul>


            </article>

            
        </section>
    </body></html>