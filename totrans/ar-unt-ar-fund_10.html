<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer106">
			<h1 id="_idParaDest-161"><em class="italic"><a id="_idTextAnchor170"/>Chapter 7</em>: Gallery: Editing Virtual Objects</h1>
			<p>In this chapter, we will continue building the project we started previously in <a href="B15145_06_Final_SB_epub.xhtml#_idTextAnchor136"><em class="italic">Chapter 6</em></a>, <em class="italic">Gallery: Building an AR App</em>, where we created an AR gallery that lets users place virtual framed photos on their real-world walls. In this chapter, we will build out more features related to interacting with and editing virtual objects that have already been added to a scene. Specifically, we'll let users select an object for editing, including moving, resizing, deleting, and replacing the image in the picture frame. In the process, we'll add new input actions, make use of Unity collision detection, and see more C# coding techniques using the Unity API. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Detecting collisions to avoid intersecting objects</li>
				<li>Building an edit mode and edit menu UI</li>
				<li>Using a physics raycast to select an object</li>
				<li>Adding touch input actions to drag to move and pinch to scale</li>
				<li>C# coding and the Unity API, including collision hooks and vector geometry</li>
			</ul>
			<p>By the end of this chapter, you'll have a working AR application with many user interactions implemented.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor171"/>Technical requirements</h1>
			<p>To complete the project in this chapter, you will need Unity installed on your development computer, connected to a mobile device that supports augmented reality applications (see <a href="B15145_01_Final_SB_epub.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Setting Up for AR Development</em>, for instructions). We will also assume you have created the <em class="italic">ARGallery</em> scene that we started in <a href="B15145_06_Final_SB_epub.xhtml#_idTextAnchor136"><em class="italic">Chapter 6</em></a>, <em class="italic">Gallery: Building an AR App</em>, where you'll also find additional dependencies detailed for you in the <em class="italic">Technical requirements</em> section. You can find that scene, as well as the one we will build in this chapter, in this book's GitHub repository at <a href="https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation">https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation</a>. </p>
			<p>Note that in this book's repository, some of the scripts (and classes) for this chapter have been post-fixed with <strong class="source-inline">07</strong>, such as <strong class="source-inline">AddPictureMode07</strong>, to distinguish them from the corresponding scripts that were written for the previous chapter. In your own project, you can leave the un-post-fixed name as is when you edit the existing scripts described in this chapter.</p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor172"/>Creating an Edit mode</h1>
			<p>To<a id="_idIndexMarker562"/> get started with this chapter, you should have the <em class="italic">ARGallery</em> scene open in Unity where we left off at the end of <a href="B15145_06_Final_SB_epub.xhtml#_idTextAnchor136"><em class="italic">Chapter 6</em></a>, <em class="italic">Gallery: Building an AR App</em>. To recap, after launching the app, it starts by initializing the AR session and scanning to detect features in your real-world environment. Once the vertical planes (walls) have been detected, the main menu will be presented. Here, the user can tap the <strong class="bold">Add</strong> button, which opens an image select menu where the user can pick a photo to use. Then, the user will be prompted to tap on a trackable vertical plane to place the framed photo on. Once the photo is hanging on their wall, the user is returned to Main-mode.</p>
			<p>In this chapter, we'll let users modify existing virtual framed photos that have been added to the scene. The first step is for the user to select an existing object to edit from Main-mode, which then activates EditPicture-mode for the selected object. When an object is selected and being edited, it should be highlighted so that it's apparent which object has been selected.</p>
			<p>Using the AR user framework that's been developed for this book, we will start by adding an EditPicture-mode UI to the scene. First, we'll create the edit menu user interface, including multiple buttons for various edit functions, and an Edit-mode controller script for managing it.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor173"/>Creating an edit menu UI</h2>
			<p>To <a id="_idIndexMarker563"/>create the UI for editing a placed picture, we'll make a new <strong class="bold">EditPicture UI</strong> panel. It's simpler to duplicate the existing <strong class="bold">Main UI</strong> and adapt it. Perform the following steps:</p>
			<ol>
				<li>In the <strong class="bold">Hierarchy</strong> window, <em class="italic">right-click</em> <strong class="bold">Main UI</strong> (child of <strong class="bold">UI Canvas</strong>) and select <strong class="bold">Duplicate</strong>. Rename the copy <strong class="source-inline">EditPicture UI</strong>. Delete any child objects, including <strong class="bold">Add Button</strong>, by <em class="italic">right-clicking</em> <strong class="bold">| Delete</strong>.</li>
				<li>Create a subpanel for the menu by <em class="italic">right-clicking</em> <strong class="bold">EditPicture UI</strong> and selecting <strong class="bold">UI | Panel</strong>. Rename it <strong class="source-inline">Edit Menu</strong>.</li>
				<li>Use <strong class="bold">the Anchors presets</strong> to set <strong class="bold">Bottom-Stretch</strong>, and then use <em class="italic">Shift + Alt +</em> <strong class="bold">Bottom-Stretch</strong> to make a bottom panel. Then, set its <strong class="bold">Rect Transform | Height</strong> value to <strong class="source-inline">175</strong>. </li>
				<li>I set my <a id="_idIndexMarker564"/>background <strong class="bold">Image | Color</strong> to opaque white with <strong class="bold">Alpha at</strong><strong class="source-inline">55</strong>.</li>
				<li>Select <strong class="bold">Add Component</strong>, search for <strong class="source-inline">layout</strong>, and select <strong class="bold">Horizontal Layout Group</strong>.</li>
				<li>On the <strong class="bold">Horizontal Layout Group</strong> component, check the <strong class="bold">Control Child Size | Width</strong> and <strong class="bold">Height</strong> checkboxes. (Leave the others at their default values, <strong class="bold">Use Child Scale</strong> unchecked, and <strong class="bold">Child Force Expand</strong> checked). The <strong class="bold">Edit Menu</strong> panel looks like this in the <strong class="bold">Inspector</strong> window:<div id="_idContainer099" class="IMG---Figure"><img src="Images/Figure_7.01-EditMenu-inspector.jpg" alt="Figure 7.1 – The Edit Menu panel settings&#13;&#10;" width="811" height="548"/></div><p class="figure-caption"> </p><p class="figure-caption">Figure 7.1 – The Edit Menu panel settings</p></li>
				<li>Now, we <a id="_idIndexMarker565"/>will add four buttons to the menu. Begin by <em class="italic">right-clicking</em> <strong class="bold">Edit Menu</strong> and selecting <strong class="bold">UI | Button – TextMeshPro</strong>. Rename it <strong class="source-inline">Replace Image Button</strong>.</li>
				<li>Select its child text object, set the <strong class="bold">Text</strong> value to <strong class="source-inline">Replace Image</strong>, and set <strong class="bold">Font Size</strong> to <strong class="source-inline">48</strong>.</li>
				<li><em class="italic">Right-click</em> the <strong class="bold">Replace Image</strong> button and select <strong class="bold">Duplicate</strong> (or <em class="italic">Ctrl + D</em>). Repeat this two more times so that there are four buttons in total.</li>
				<li>Rename the buttons and change the text on the buttons so that they read as <strong class="source-inline">Replace Frame</strong>, <strong class="source-inline">Remove Picture</strong>, and <strong class="source-inline">Done</strong>. </li>
				<li>We may not use the <strong class="bold">Replace Frame</strong> feature soon, so disable that button by unchecking its <strong class="bold">Interactable</strong> checkbox in the <strong class="bold">Button</strong> component. The resulting menu will look as follows:</li>
			</ol>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="Images/Figure_7.02-EditMenubuttons.jpg" alt="Figure 7.2 – Edit Menu buttons&#13;&#10;" width="469" height="82"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – Edit Menu buttons</p>
			<p>Add the panel to<a id="_idIndexMarker566"/> the UI Controller, as follows:</p>
			<ol>
				<li value="1">To add the panel to the UI Controller, in the <strong class="bold">Hierarchy</strong> window, select the <strong class="bold">UI Canvas</strong> object.</li>
				<li>In the <strong class="bold">Inspector</strong> window, at the bottom right of the <strong class="bold">UI Controller</strong> component, click the <strong class="bold">+</strong> button to add an item to the UI Panels dictionary.</li>
				<li>Enter <strong class="source-inline">EditPicture</strong> in the <strong class="bold">Id</strong> field.</li>
				<li>Drag the <strong class="bold">EditPicture UI</strong> game object from the <strong class="bold">Hierarchy</strong> window onto the <strong class="bold">Value</strong> slot. </li>
			</ol>
			<p>The next step is to create an <strong class="bold">EditPicture</strong> mode object and controller script.</p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor174"/>Creating EditPicture mode </h2>
			<p>As you now know, our <a id="_idIndexMarker567"/>framework manages interaction modes by activating game objects under the Interaction Controller. Each mode has a control script that displays the UI for that mode and handles any user interactions until certain conditions are met; then, it transitions to a different mode. In terms of our EditPicture-mode, its control script will have a <strong class="source-inline">currentPicture</strong> variable that specifies which picture is being edited, a <strong class="source-inline">DoneEditing</strong> function that returns the user to Main-mode, among other features.</p>
			<p>Create a new C# script named <strong class="source-inline">EditPictureMode</strong> and begin to write it, as follows:</p>
			<p class="source-code">using UnityEngine;</p>
			<p class="source-code">public class EditPictureMode : MonoBehaviour</p>
			<p class="source-code">{</p>
			<p class="source-code">    public FramedPhoto currentPicture;</p>
			<p class="source-code">    void OnEnable()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        UIController.ShowUI("EditPicture");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Now, we can<a id="_idIndexMarker568"/> add it to our <strong class="bold">Interaction Controller</strong> object, as follows:</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong> window, <em class="italic">right-click</em> the <strong class="bold">Interaction Controller</strong> game object and select <strong class="bold">Create Empty</strong>. Rename the new object <strong class="source-inline">EditPicture Mode</strong>.</li>
				<li>Drag the <strong class="source-inline">EditPictureMode</strong> script from the <strong class="bold">Project</strong> window onto the <strong class="bold">EditPicture Mode</strong> object, adding it as a component.</li>
				<li>Now, we'll add the mode to the Interaction Controller. In the <strong class="bold">Hierarchy</strong> window, select the <strong class="bold">Interaction Controller</strong> object.</li>
				<li>In the <strong class="bold">Inspector</strong> window, at the bottom right of the <strong class="bold">Interaction Controller</strong> component, click the <strong class="bold">+</strong> button to add an item to the <strong class="bold">Interaction Modes</strong> dictionary.</li>
				<li>Enter <strong class="source-inline">EditPicture</strong> in the <strong class="bold">Id</strong> field.</li>
				<li>Drag the <strong class="bold">EditPicture Mode</strong> game object from the <strong class="bold">Hierarchy</strong> window onto the <strong class="bold">Value</strong> slot. </li>
			</ol>
			<p>With that, we have created an <strong class="bold">EditPicture UI</strong> containing edit buttons that is controlled by <strong class="source-inline">UIController</strong>. After this, we created an <strong class="bold">EditPicture Mode</strong> game object with an <strong class="source-inline">EditPictureMode</strong> script <a id="_idIndexMarker569"/>that is controlled by <strong class="source-inline">InteractionController</strong>. </p>
			<p>With this set up, the next thing we must do is enhance Main-mode so that it detects when the user taps on an existing <strong class="bold">FramedPhoto</strong> and can start EditPicture-mode for the selected object. </p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor175"/>Selecting a picture to edit</h1>
			<p>While in <a id="_idIndexMarker570"/>Main-mode, the user should be able to tap on an existing picture to edit it. Utilizing the Unity Input System, we will add a new <strong class="source-inline">SelectObject</strong> input action. Then, we'll have the <strong class="source-inline">MainMode</strong> script listen for that action's messages, find which picture was tapped using a <strong class="source-inline">Raycast</strong>, and enable Edit-mode on that picture. Let's get started!</p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor176"/>Defining a SelectObject input action</h2>
			<p>We will start by<a id="_idIndexMarker571"/> adding a <strong class="source-inline">SelectObject</strong> action to the <strong class="bold">AR Input Actions</strong> asset by performing the following steps:</p>
			<ol>
				<li value="1">In the <strong class="bold">Project</strong> window, locate and <em class="italic">double-click</em> the <strong class="bold">AR Input Actions</strong> asset we created previously (it may be in the <strong class="source-inline">Assets/Inputs/</strong> folder) to open it for editing (alternatively, use its <strong class="bold">Edit Asset</strong> button).</li>
				<li>In the middle <strong class="bold">Actions</strong> section, select <strong class="bold">+</strong> and name it <strong class="source-inline">SelectObject</strong>.</li>
				<li>In the rightmost <strong class="bold">Properties</strong> section, select <strong class="bold">Action Type | Value</strong> and <strong class="bold">Control Type | Vector 2</strong>.</li>
				<li>In the middle <strong class="bold">Actions</strong> section, select the <strong class="bold">&lt;No Binding&gt;</strong> child. Then, in the <strong class="bold">Properties</strong> section, select <strong class="bold">Path | Touchscreen | Primary Touch | Position</strong> to bind this action to a primary screen touch.</li>
				<li>Press <strong class="bold">Save Asset</strong> (unless <strong class="bold">Auto-Save</strong> is enabled).</li>
			</ol>
			<p>The updated <strong class="bold">AR Input Actions</strong> asset is shown in the following screenshot:</p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="Images/Figure_7.03-imputaction-selectobject.jpg" alt="Figure 7.3 – AR Input Actions asset with the SelectObject action added&#13;&#10;" width="865" height="218"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – AR Input Actions asset with the SelectObject action added</p>
			<p>Although we're defining this action with the same touchscreen binding that we used for the <strong class="source-inline">PlaceObject</strong> action we created earlier (<strong class="bold">Touchscreen Primary Position</strong>), it serves a somewhat<a id="_idIndexMarker572"/> different purpose (tap-to-select versus tap-to-place). For example, perhaps, in the future, if you decide to use a <em class="italic">double-tap</em> for selecting an item instead of a single tap, you can simply change its input action.</p>
			<p>Now, we can add the code for this action.</p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor177"/>Replacing the MainMode script</h2>
			<p>First, because we're <a id="_idIndexMarker573"/>deviating from the default <strong class="source-inline">MainMode</strong> script provided in the <strong class="source-inline">ARFramework</strong> template, we should make a new, separate script for this project. Perform the following steps to copy and edit the new <strong class="source-inline">GalleryMainMode</strong> script:</p>
			<ol>
				<li value="1">In the <strong class="source-inline">Project</strong> window's <strong class="source-inline">Scripts/</strong> folder, select the <strong class="bold">MainMode</strong> script. Then, from the main menu bar, select <strong class="bold">Edit | Duplicate</strong>.</li>
				<li>Rename the new file <strong class="source-inline">GalleryMainMode</strong>. </li>
				<li>You'll see a namespace error in the <strong class="bold">Console</strong> window because we now have two files defining the <strong class="source-inline">MainMode</strong> class.<p>Open <strong class="bold">GalleryMainMode</strong> for editing and change the class name to <strong class="source-inline">GalleryMainMode</strong>, as <a id="_idIndexMarker574"/>highlighted here:</p><p class="source-code">using UnityEngine;</p><p class="source-code">using UnityEngine.InputSystem;</p><p class="source-code">public class <strong class="bold">GalleryMainMode</strong> : MonoBehaviour</p><p class="source-code">{</p><p class="source-code">    void OnEnable()</p><p class="source-code">    {</p><p class="source-code">        UIController.ShowUI("Main");</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Save the script. Then, back in Unity, in the <strong class="bold">Hierarchy</strong> window, select the <strong class="bold">Main Mode</strong> game object (under <strong class="bold">Interaction Controller</strong>).</li>
				<li>Drag the <strong class="bold">GalleryMainMode</strong> script onto the <strong class="bold">Main Mode</strong> object, adding it as a new component.</li>
				<li>Remove the previous <strong class="bold">Main Mode</strong> component from the <strong class="bold">Main Mode</strong> object.</li>
			</ol>
			<p>Now, we're ready to enhance the behavior of Main-mode.</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor178"/>Selecting an object from Main-mode</h2>
			<p>When<a id="_idIndexMarker575"/> the user taps the screen, the <strong class="source-inline">GalleryMainMode</strong> script will get the touch position and use a Raycast to determine whether one of the <strong class="source-inline">PlacedPhoto</strong> objects was selected. If so, it will enable <strong class="bold">EditPicture</strong> mode on that picture. </p>
			<p>We have seen Raycasts previously in our tap-to-place scripts, including <strong class="source-inline">AddPictureMode</strong>. In that case, our scripts used the <strong class="bold">AR Raycast Manager</strong> class's version of the function because we were only interested in hitting a tracked AR plane. But in this case, we're interested in selecting a regular GameObject – an instantiated FramedPhoto prefab. For this, we'll use the <strong class="source-inline">Physics.Raycast</strong> function (<a href="https://docs.unity3d.com/ScriptReference/Physics.Raycast.html">https://docs.unity3d.com/ScriptReference/Physics.Raycast.html</a>). As part of the Unity Physics system, it requires the raycast-able object to have a <strong class="bold">Collider</strong> (which <strong class="bold">FramedPhoto</strong> does, and I'll show you soon). </p>
			<p>Also, we will be using the AR Camera's <strong class="source-inline">ScreenPointToRay</strong> function to define the 3D ray that corresponds to the touch position that we're going to Raycast into the scene. </p>
			<p>To add this, open the <strong class="source-inline">GalleryMainMode</strong> script for editing and follow these steps:</p>
			<ol>
				<li value="1">We're going to listen for Input System events, so to begin, we need to add a <strong class="source-inline">using</strong> statement for that namespace. Ensure the following line is at the top of the file:<p class="source-code">using UnityEngine.InputSystem;</p></li>
				<li>We need a reference to tell <strong class="source-inline">EditPictureMode</strong> which object to edit. Add it to the top of the class, as follows:<p class="source-code">public class GalleryMainMode : MonoBehaviour</p><p class="source-code">{</p><p class="source-code"><strong class="bold">    [SerializeField] EditPictureMode editMode;</strong></p></li>
				<li>We're going to be using <strong class="bold">AR Camera</strong> here, so it's good practice to get a reference to that at the start by using the <strong class="source-inline">Camera.main</strong> shortcut. (This requires the AR Camera to be tagged as <strong class="source-inline">MainCamera</strong>, which should be done from the scene template.) Add a private variable at the top of the class and initialize it using <strong class="source-inline">Start</strong>:<p class="source-code">    Camera camera;</p><p class="source-code">    void Start()</p><p class="source-code">    {</p><p class="source-code">        <strong class="bold">camera = Camera.main;</strong></p><p class="source-code">    }</p></li>
				<li>Now for <a id="_idIndexMarker576"/>the meat of our task – add the following <strong class="source-inline">OnSelectObject</strong> and <strong class="source-inline">FindObjectToEdit</strong> functions:<p class="source-code">    public void OnSelectObject(InputValue value)</p><p class="source-code">    {</p><p class="source-code">        Vector2 touchPosition = value.Get&lt;Vector2&gt;();</p><p class="source-code">        FindObjectToEdit(touchPosition);</p><p class="source-code">    }</p><p class="source-code">    void FindObjectToEdit(Vector2 touchPosition)</p><p class="source-code">    {</p><p class="source-code">        Ray ray = camera.ScreenPointToRay(touchPosition);</p><p class="source-code">        RaycastHit hit;</p><p class="source-code">        int layerMask =             1 &lt;&lt; LayerMask.NameToLayer("PlacedObjects");</p><p class="source-code">        if (Physics.Raycast(ray, out hit, Mathf.Infinity,            layerMask))</p><p class="source-code">        {</p><p class="source-code">            FramedPhoto picture = hit.collider.                GetComponentInParent&lt;FramedPhoto&gt;();</p><p class="source-code">            editMode.currentPicture = picture;</p><p class="source-code">            InteractionController.                EnableMode("EditPicture");</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
			</ol>
			<p>Let's walk through <a id="_idIndexMarker577"/>this code together. The <strong class="source-inline">OnSelectObject</strong> function is automatically called when the <strong class="source-inline">SelectObject</strong> Input System action is used (the <strong class="source-inline">On</strong> prefix is a standard Unity convention for event interfaces). It grabs <strong class="source-inline">Vector2 touchPosition</strong> from the input value and passes it to our private <strong class="source-inline">FindObjectToEdit</strong> function. (You don't need to separate this into two functions, but I did for clarity.)</p>
			<p><strong class="source-inline">FindObjectToEdit</strong> gets the 3D ray corresponding to the touch position by calling <strong class="source-inline">camera.ScreenPointToRay</strong>. This is passed to <strong class="source-inline">Physics.Raycast</strong> to find an object in the scene that intersects with the ray. Rather than casting to every possible object, we'll limit it to ones on a layer named <strong class="source-inline">PlacedObjects</strong> using its <strong class="source-inline">layermask</strong>. (For this, we need to make sure <strong class="bold">FramedPhoto</strong> is assigned to this layer, which we'll do soon.)</p>
			<p class="callout-heading">Information – Layer Name, Layer Number, and Layermask</p>
			<p class="callout">A <strong class="bold">layermask</strong> uses <a id="_idIndexMarker578"/>the binary bits of a 32-bit integer to identify up to 32 layers, one bit each. We define the mask by getting the layer number from its name (<strong class="source-inline">LayerMask.NameToLayer</strong>) and shifting one bit to the left that many times. To manage the layers in your project and see what name has been assigned to each layer number, click the <strong class="bold">Layers</strong> button in the top-right corner of the Editor. </p>
			<p>If the raycast gets a hit, we must grab a reference to the <strong class="source-inline">FramedPhoto</strong> component in the prefab and pass it to the <strong class="source-inline">EditPictureMode</strong> component. Then, the app will transition to EditPicture-mode.</p>
			<p>Save the script. Now, let's fix the housekeeping things on our game objects that I mentioned: set the camera tag to <strong class="source-inline">MainCamera</strong>, set the <strong class="bold">FramedPhoto</strong> object so that it resides on the <strong class="source-inline">PlacedObjects</strong> layer, and ensure <strong class="bold">FramedPhoto</strong> has a collider component. In Unity, do the <a id="_idIndexMarker579"/>following:</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong> window, with the <strong class="bold">Main Mode</strong> game object selected, drag the <strong class="bold">EditPicture Mode</strong> object from the <strong class="bold">Hierarchy</strong> window into the <strong class="bold">Inspector</strong> window and drop it onto the <strong class="bold">Gallery Main Mode | Edit Mode</strong> slot.</li>
				<li>In the scene <strong class="bold">Hierarchy</strong>, unfold <strong class="bold">AR Session Origin</strong> and select its child <strong class="bold">AR Camera</strong>. In the top-left position of the <strong class="bold">Inspector</strong> window, verify that <strong class="bold">Tag</strong> (atop the <strong class="bold">Inspector</strong> window) is set to <strong class="bold">MainCamera</strong>. If not, set it now.</li>
				<li>Next, open the <strong class="bold">FramedPhoto</strong> prefab for editing by <em class="italic">double-clicking</em> the asset in the <strong class="bold">Project</strong> window.</li>
				<li>With its root <strong class="bold">FramedPhoto</strong> object selected, in the top right of its <strong class="bold">Inspector</strong> window, click the <strong class="bold">Layer</strong> drop-down list and select <strong class="source-inline">PlacedObjects</strong>.<p>If the layer named <strong class="source-inline">PlacedObjects</strong> doesn't exist, select <strong class="bold">Add Layer</strong> to open the <strong class="bold">Layers manager</strong> window. Add <strong class="source-inline">PlacedObjects</strong> to one of the empty slots. In the <strong class="bold">Hierarchy</strong> window, click the <strong class="bold">FramedPhoto Prefab</strong> object to get back to its <strong class="bold">Inspector</strong> window. Again, using the <strong class="bold">Layers</strong> drop-down list, select <strong class="source-inline">PlacedObjects</strong>.</p><p>You will then be prompted with the question <strong class="bold">Do you want to set layer to PlacedObjects for all child objects as well?</strong>. Click <strong class="bold">Yes, Change Children</strong>.</p></li>
				<li>While we're here, let's also verify that the prefab has a collider, as required for <strong class="source-inline">Physics.Raycast</strong>. If you recall, when we constructed the prefab, we started with an <strong class="bold">Empty</strong> game object for the root and added another <strong class="bold">Empty</strong> child for <strong class="bold">AspectScaler</strong>. Then, we added a 3D Cube for the <strong class="bold">Frame</strong> object. Click this <strong class="bold">Frame</strong> object.</li>
				<li>In the <strong class="bold">Inspector</strong> window, you will see that the <strong class="bold">Frame</strong> object already has a <strong class="bold">Box Collider</strong>. Perfect. Note that if you press its <strong class="bold">Edit Collider</strong> button, you can see (and edit) the collider's shape in the <strong class="bold">Scene</strong> window, as shown in the following screenshot, where<a id="_idIndexMarker580"/> its edges are outlined and there are little handles to move the faces. But there's no need for us to change it here:<div id="_idContainer102" class="IMG---Figure"><img src="Images/Figure_7.04-FrameBoxCollider.jpg" alt="Figure 7.4 – Editing the Box Collider of the Frame object&#13;&#10;" width="745" height="540"/></div><p class="figure-caption">Figure 7.4 – Editing the Box Collider of the Frame object</p></li>
				<li>Save the prefab and exit the prefab editor to get back to the Scene hierarchy.</li>
			</ol>
			<p>If you were to <strong class="bold">Build and Run</strong> the scene now, and then add a picture to a wall, when you tap on that picture, it should hide the main menu and show the edit menu. Now, we need a way to get back from Edit-mode to Main-mode. Let's wire up the <strong class="bold">Done</strong> button.</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor179"/>Wiring the Done edit button</h2>
			<p>In this section, we will set <a id="_idIndexMarker581"/>up the <strong class="bold">Done</strong> button to switch from EditPicture-mode to Main-mode. It simply needs to call <strong class="source-inline">EnableMode</strong> in <strong class="source-inline">InteractionController</strong>. Follow these steps:</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong> window, select the <strong class="bold">Done</strong> button, which should be located under <strong class="bold">UI Canvas | EditPicture UI | Edit Menu</strong>.</li>
				<li>In the <strong class="bold">Inspector</strong> window, click the <strong class="bold">+</strong> button on the bottom right of the <strong class="bold">Button | OnClick</strong> area to add a new event action.</li>
				<li>Drag the <strong class="bold">Interaction Controller</strong> object from the <strong class="bold">Hierarchy</strong> window and drop it onto the <strong class="bold">Object</strong> slot of the <strong class="bold">OnClick</strong> action.</li>
				<li>In the function select list, choose <strong class="bold">InteractionController | EnableMode</strong>.</li>
				<li>Type <strong class="source-inline">Main</strong> into the mode string parameter slot.</li>
			</ol>
			<p>Now, if you <strong class="bold">Build and Run</strong> the scene where you have a picture instantiated in the scene and tap the picture, you'll switch to Edit-mode and see the edit menu. Tap the <strong class="bold">Done</strong> button to get back to Main-mode.</p>
			<p>This is progress. But if there's more than one picture on your wall, it's not obvious which one is currently being edited. We need to highlight the currently selected picture. </p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor180"/>Highlighting the selected picture </h1>
			<p>There <a id="_idIndexMarker582"/>are many ways to highlight objects in Unity to indicate that an object has been selected by the user. Often, you'll find that a custom shader will do the trick (there are many on the Asset Store). The decision comes down to what "look" you want. Do you want to change the selected object's color tint, draw a wireframe outline, or create some other effect? Instead of doing this and to keep things easy, I'll just introduce a "highlight" game object in the <strong class="bold">FramedPhoto</strong> prefab as a thin yellow box that extends from the edges of the frame. Let's make that now:</p>
			<ol>
				<li value="1">Open the <strong class="bold">FramedPhoto</strong> prefab for editing by <em class="italic">double-clicking</em> it in the <strong class="bold">Project</strong> window.</li>
				<li>In the <strong class="bold">Hierarchy</strong> window, <em class="italic">right-click</em> on the <strong class="bold">AspectScaler</strong> object and select <strong class="bold">3D Object | Cube</strong>. Rename the cube <strong class="source-inline">Highlight</strong>.</li>
				<li>Set its <strong class="bold">Transform | Scale</strong> setting to (<strong class="source-inline">1.05, 1.05, 0.005</strong>) so that it is thin and extends past the edges of the frame.</li>
				<li>Set its <strong class="bold">Transform | Position</strong> setting to (<strong class="source-inline">0, 0, -0.025</strong>).</li>
				<li>Create a yellow material. In the <strong class="bold">Project</strong> window, <em class="italic">right-click</em> in your <strong class="source-inline">Materials/</strong> folder (create one if needed) and select <strong class="bold">Create | Material</strong>. Rename it <strong class="source-inline">Highlight Material</strong>.</li>
				<li>Set <strong class="bold">Highlight Material | Shader | Universal Render Pipeline | Unlit</strong>.</li>
				<li>Set <a id="_idIndexMarker583"/>its <strong class="bold">Base Map</strong> color (using the color swatch) to yellow. </li>
				<li>Drag <strong class="bold">Highlight Material</strong> onto the <strong class="bold">Highlight</strong> game object. The <strong class="bold">Scene</strong> view should now look as follows:</li>
			</ol>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="Images/Figure_7.05-FameHighlight.jpg" alt="Figure 7.5 – FramedPhoto with highlight&#13;&#10;" width="646" height="484"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – FramedPhoto with highlight</p>
			<p>We can now<a id="_idIndexMarker584"/> control this from the <strong class="source-inline">FramedPhoto</strong> script. You may want the highlight the picture for different reasons, but for this project, I've decided that when the object is selected and highlighted, that means it is being edited. So, we can toggle the highlight when making the object editable. Open the script in your editor and make the following changes:</p>
			<ol>
				<li value="1">Declare a variable for <strong class="source-inline">highlightObject</strong>:<p class="source-code">    [SerializeField] GameObject highlightObject;</p><p class="source-code">    bool isEditing;</p></li>
				<li>Add a function to toggle the highlight:<p class="source-code">    public void Highlight(bool show)</p><p class="source-code">    {</p><p class="source-code">        if (highlightObject) // handle no object or app                                 end object destroyed</p><p class="source-code">            highlightObject.SetActive(show);</p><p class="source-code">    }</p></li>
				<li>Ensure the picture isn't highlighted at the beginning:<p class="source-code">    void Awake()</p><p class="source-code">    {</p><p class="source-code">        Highlight(false);</p><p class="source-code">    }</p></li>
				<li>Add a <strong class="source-inline">BeingEdited</strong> function. This will be called when the object is being edited. It'll highlight the object and enable other editing behavior later. Likewise, when <a id="_idIndexMarker585"/>we stop editing and pass a <strong class="source-inline">false</strong> value, the object will be un-highlighted:<p class="source-code">   public void BeingEdited(bool editing)</p><p class="source-code">    {</p><p class="source-code">        Highlight(editing);</p><p class="source-code">        isEditing = editing;</p><p class="source-code">    }</p></li>
				<li>Save the script. In Unity, select the root <strong class="bold">FramedPhoto</strong> object.</li>
				<li>Drag the <strong class="bold">Highlight</strong> object from the <strong class="bold">Hierarchy</strong> window onto the <strong class="bold">Framed Photo | Highlight Object</strong> slot.</li>
			</ol>
			<p>This is great! Now, we can update <strong class="source-inline">EditPictureMode</strong> to tell the picture when it's being edited or not. Open the <strong class="source-inline">EditPictureMode</strong> script and make the following edits:</p>
			<ol>
				<li value="1">Add the <strong class="source-inline">BeingEdited</strong> call to <strong class="source-inline">OnEnable</strong>: <p class="source-code">   void OnEnable()</p><p class="source-code">    {</p><p class="source-code">        UIController.ShowUI("EditPicture");</p><p class="source-code">        if (currentPicture)</p><p class="source-code">            currentPicture.BeingEdited(true);</p><p class="source-code">    }</p></li>
				<li>Also, add the <strong class="source-inline">BeingEdited</strong> call to <strong class="source-inline">OnDisable</strong> for when it's not being edited; that is, when Edit-mode has been exited:<p class="source-code">    void OnDisable()</p><p class="source-code">    {</p><p class="source-code">        if (currentPicture)</p><p class="source-code">            currentPicture.BeingEdited(false);</p><p class="source-code">    }</p><p>Notice that although we would never intentionally enter Edit-mode without <strong class="source-inline">currentPicture</strong> defined, I've added null checks in case the mode is activated or deactivated during the app startup or teardown sequences.</p></li>
			</ol>
			<p>If you play the<a id="_idIndexMarker586"/> scene now and add a picture, when you tap the picture via Main-mode, Edit-mode will become enabled, and the picture will be highlighted. When you exit back to Main-mode, the picture will be un-highlighted.</p>
			<p>Let's keep going. Suppose you have multiple pictures on your walls. Currently, when you're editing one picture and you want to edit a different one, you must press <strong class="bold">Done</strong> to exit Edit-mode and then select the other picture from Main-mode. To switch between objects that are currently being editing, we can add that code to the <strong class="source-inline">EditMode</strong> script.</p>
			<h1 id="_idParaDest-172"><a id="_idTextAnchor181"/>Selecting an object from Edit mode</h1>
			<p>When in<a id="_idIndexMarker587"/> Edit-mode for<a id="_idIndexMarker588"/> one picture, to let the user choose a different picture without exiting Edit-mode, we can use the same <strong class="bold">SelectObject</strong> input action we used in Main-mode. In fact, the code is mostly the same. Open the <strong class="source-inline">EditPictureMode</strong> script for editing and make the following changes:</p>
			<ol>
				<li value="1">We're going to listen for Input System events, so to begin, we need to add a <strong class="source-inline">using</strong> statement for that namespace. Ensure the following line is at the top of the file:<p class="source-code">using UnityEngine.InputSystem;</p></li>
				<li>Add a private <strong class="source-inline">camera</strong> variable <a id="_idIndexMarker589"/>at the top of the class and initialize it in <strong class="source-inline">Start</strong>:<p class="source-code">    Camera camera;</p><p class="source-code">    void Start()</p><p class="source-code">    {</p><p class="source-code">        camera = Camera.main;</p><p class="source-code">    }</p></li>
				<li>The <strong class="source-inline">OnSelectObject</strong> action listener will call <strong class="source-inline">FindObjectToEdit</strong>. Like in <strong class="source-inline">GalleryMainMode</strong>, it does a Raycast on the <strong class="source-inline">PlacedObjects</strong> layer. But now, we must <a id="_idIndexMarker590"/>check whether it has hit an object other than the current picture. If so, we must stop editing <strong class="source-inline">currentPicture</strong> and make the new selection current:<p class="source-code">    public void OnSelectObject(InputValue value)</p><p class="source-code">    {</p><p class="source-code">        Vector2 touchPosition = value.Get&lt;Vector2&gt;();</p><p class="source-code">        FindObjectToEdit(touchPosition);</p><p class="source-code">    }</p><p class="source-code">    void FindObjectToEdit(Vector2 touchPosition)</p><p class="source-code">    {</p><p class="source-code">        Ray ray = camera.ScreenPointToRay(touchPosition);</p><p class="source-code">        RaycastHit hit;</p><p class="source-code">        int layerMask =             1 &lt;&lt; LayerMask.NameToLayer("PlacedObjects");</p><p class="source-code">        if (Physics.Raycast(ray, out hit, 50f,            layerMask))</p><p class="source-code">        {</p><p class="source-code">            if (hit.collider.gameObject !=                currentPicture.gameObject)</p><p class="source-code">            {</p><p class="source-code">                currentPicture.BeingEdited(false);</p><p class="source-code">                FramedPhoto picture = hit.collider.                    GetComponentInParent&lt;FramedPhoto&gt;();</p><p class="source-code">                currentPicture = picture;</p><p class="source-code">                picture.BeingEdited(true);</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
			</ol>
			<p>To summarize, when you have more than one <strong class="bold">FramedPhoto</strong> instantiated in the scene and you are editing one, if you tap on a different picture, the current one will be un-highlighted and the<a id="_idIndexMarker591"/> new one will be highlighted and become the <strong class="source-inline">currentPicture</strong> object<a id="_idIndexMarker592"/> being edited.</p>
			<p>Here's another problem: if you've been playing with the project, you may have noticed that you can place pictures on top of one another, or actually, <em class="italic">inside</em> one another, as they do not seem to have any physical presence! Oops. Let's fix this.</p>
			<h1 id="_idParaDest-173"><a id="_idTextAnchor182"/>Avoiding intersecting objects</h1>
			<p>In Unity, to specify that an <a id="_idIndexMarker593"/>object should participate in the Unity Physics system, you must add a <strong class="bold">Rigidbody</strong> component to the GameObject. Adding a Rigidbody gives an object mass, velocity, collision detection, and other physical properties. We can use this to prevent objects from intersecting. In many games and XR apps, Rigidbody is <a id="_idIndexMarker594"/>important for applying motion forces to objects to let them bounce when they collide, for example. </p>
			<p>In our project, if a picture collides with another picture, it should simply move out of the way so that they're never intersecting. But it should also stay flush with the wall plane. Although a Rigidbody allows you to constrain movement along any of the <strong class="bold">X</strong>, <strong class="bold">Y</strong>, and <strong class="bold">Z</strong> directions, these are the orthogonal world space planes, not the arbitrary angled wall plane. In the end, I decided to position the picture manually when a collision is detected rather than using physics forces. My solution is to constrain the position (and rotation) of all the pictures so that physics forces won't move them. Then, I can use the collision as a trigger to manually move the picture out of the way. </p>
			<p class="callout-heading">Information – Collision Versus Trigger Detection</p>
			<p class="callout">When two<a id="_idIndexMarker595"/> GameObjects with <strong class="bold">Rigidbody</strong> and <strong class="bold">Collider</strong> collide, physics forces will be applied to the objects, sending them in different directions. You can add <a id="_idIndexMarker596"/>constraints and other properties to limit this behavior. In that case, you can write functions for <strong class="source-inline">OnCollisionEnter</strong>, <strong class="source-inline">OnCollisionStay</strong>, and <strong class="source-inline">OnCollisionExit</strong> to hook into these events. </p>
			<p class="callout">However, you can completely disable Unity applying physical forces by marking a Collider as <strong class="bold">Is Trigger</strong>. When it's a trigger, you would instead write functions for <strong class="source-inline">OnTriggerEnter</strong>, <strong class="source-inline">OnTriggerStay</strong>, and <strong class="source-inline">OnTriggerExit</strong> to hook into these events.</p>
			<p>To add collision detection to the <strong class="bold">FramedPhoto</strong> prefab, follow these steps:</p>
			<ol>
				<li value="1">In the <strong class="bold">Project</strong> window, locate and <em class="italic">double-click</em> on the <strong class="bold">FramedPhoto</strong> prefab to open it for editing.</li>
				<li>Ensure you have selected the root <strong class="bold">FramedPhoto</strong> object in the <strong class="bold">Hierarchy</strong> window.</li>
				<li>In the <strong class="bold">Inspector</strong> window, click <strong class="bold">Add Component</strong>, search for <strong class="source-inline">rigidbody</strong>, and add a <strong class="bold">Rigidbody</strong> to the object.</li>
				<li>Unfold the <strong class="bold">Constraints</strong> properties and check all six boxes; that is, <strong class="bold">Freeze Position: X, Y, Z</strong> and <strong class="bold">Freeze Rotation: X, Y, Z</strong>.</li>
				<li>Uncheck its <strong class="bold">Use Gravity</strong> checkbox. (This is not necessary since we set constraints, but I like to be clear about this anyway.)</li>
				<li>We need a <strong class="bold">Collider</strong>. As we've seen, there is one on the <strong class="bold">Frame</strong> child object. So, select the <strong class="bold">Frame</strong> game object.</li>
				<li>In the <strong class="bold">Inspector</strong> window, in<a id="_idIndexMarker597"/> its <strong class="bold">Box Collider</strong> component, check the <strong class="bold">Is Trigger</strong> checkbox.</li>
				<li>To avoid any problems, disable (or remove) other colliders in the prefab. Namely, remove <strong class="bold">Mesh Collider</strong> from <strong class="bold">Image</strong> and <strong class="bold">Box Collider</strong> from <strong class="bold">Highlight</strong>.</li>
			</ol>
			<p>Now, we can handle the collision trigger and move the picture out of the way when another picture is in the same space. We just want to make sure it moves along the wall. We can make use of the fact that the wall plane's normal vector (the vector that's perpendicular to the surface of the plane) is also the forward direction vector of our picture prefab since we originally placed it there. Also, we only want to consider collisions with objects on the placed object plane (for example, not the AR tracked plane objects). </p>
			<p>My algorithm determines the distance between this picture and the other intersecting picture, in 3D. Then, it finds the direction to move this picture in by projecting the distance vector onto the wall plane and scaling it. The picture will continue moving away from the other frames until it is no longer intersecting.</p>
			<p>Let's write the code for this. Open the <strong class="source-inline">FramedPhoto</strong> script for editing and follow these steps:</p>
			<ol>
				<li value="1">Begin by adding a reference to the <strong class="source-inline">collider</strong> and <strong class="source-inline">layer</strong> numbers at the top of the class, as follows:<p class="source-code">    [SerializeField] Collider boundingCollider;</p><p class="source-code">    int layer;</p></li>
				<li>Initialize the <strong class="source-inline">layer</strong> number from its name. It's good to initialize this ahead of time because <strong class="source-inline">OnTriggerStay</strong> may be called every frame:<p class="source-code">    void Awake()</p><p class="source-code">    {</p><p class="source-code"><strong class="bold">        layer = LayerMask.NameToLayer("PlacedObjects");</strong></p><p class="source-code">        Highlight(false);</p><p class="source-code">    }</p></li>
				<li>We'll use <strong class="source-inline">OnTriggerStay</strong> here, which<a id="_idIndexMarker598"/> is called with each update while the object is colliding with another object, as follows:<p class="source-code">    void OnTriggerStay(Collider other)</p><p class="source-code">    {</p><p class="source-code">        const float spacing = 0.1f;</p><p class="source-code">        if (isEditing &amp;&amp; other.gameObject.layer == layer)</p><p class="source-code">        {</p><p class="source-code">            Bounds bounds = boundingCollider.bounds;</p><p class="source-code">            if (other.bounds.Intersects(bounds))</p><p class="source-code">            {</p><p class="source-code">                Vector3 centerDistance =                     bounds.center - other.bounds.center;</p><p class="source-code">                Vector3 distOnPlane =                     Vector3.ProjectOnPlane(centerDistance,                        transform.forward);</p><p class="source-code">                Vector3 direction =                     distOnPlane.normalized;</p><p class="source-code">                float distanceToMoveThisFrame =                     bounds.size.x * spacing;</p><p class="source-code">                transform.Translate(direction *                    distanceToMoveThisFrame);</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
				<li>Save the script. In Unity, drag the <strong class="bold">Frame</strong> object (which has a Box Collider) from the <strong class="bold">Hierarchy</strong> window <a id="_idIndexMarker599"/>onto the <strong class="bold">Framed Photo | Bounding Collider</strong> slot. The <strong class="bold">Framed Photo</strong> component now looks as follows:<div id="_idContainer104" class="IMG---Figure"><img src="Images/Figure_7.06-framedphoto-bounding.jpg" alt="Figure 7.6 – Framed Photo component properties, including Bounding Collider&#13;&#10;" width="597" height="145"/></div><p class="figure-caption">Figure 7.6 – Framed Photo component properties, including Bounding Collider</p></li>
				<li>Save the prefab and return to the scene <strong class="bold">hierarchy</strong>.</li>
			</ol>
			<p>When you play the scene now, place a picture on a wall, and then place another picture in the same space, the new picture will move away from the first one until they're no longer colliding.</p>
			<p>Now that we can have many pictures on our walls, you might want to learn how to remove one from the scene. We'll look at this in the next section.</p>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor183"/>Deleting a picture</h1>
			<p>Deleting the picture <a id="_idIndexMarker600"/>that is being edited is straightforward. We just need to destroy the <strong class="source-inline">currentPicture</strong> GameObject and go back to Main-mode. Perform the following steps:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">EditPictureMode</strong> script and add the following function:<p class="source-code">    public void DeletePicture()</p><p class="source-code">    {</p><p class="source-code">        GameObject.Destroy(currentPicture.gameObject);</p><p class="source-code">        InteractionController.EnableMode("Main");</p><p class="source-code">    }</p></li>
				<li>Save the script. </li>
				<li>In Unity, in the <strong class="bold">Hierarchy</strong> window, select <strong class="bold">Remove Button</strong> (located under <strong class="bold">UI Canvas | EditPicture UI | Edit Menu</strong>).</li>
				<li>In the <strong class="bold">Inspector</strong>, click the <strong class="bold">+</strong> button at the bottom right of the <strong class="bold">Button | OnClick</strong> area.</li>
				<li>Drag the <strong class="bold">EditPicture Mode</strong> object from the <strong class="bold">Hierarchy</strong> window onto the <strong class="bold">OnClick Object</strong> slot.</li>
				<li>From the function selection, choose <strong class="bold">EditPictureMode | DeletePicture</strong>.</li>
			</ol>
			<p>When you play the scene, create a picture, go into EditPicture-mode, and then tap the <strong class="bold">Remove Picture</strong> button, the picture will be deleted from the scene, and you will be back in Main-mode.</p>
			<p>We now have two of the Edit menu buttons operating – <strong class="bold">Remove Picture</strong> and <strong class="bold">Done</strong>. Now, let's add the feature that lets you change the picture in an existing <strong class="bold">FramedPhoto</strong> from the <strong class="bold">Image Select</strong> menu panel.</p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor184"/>Replacing the picture's image</h1>
			<p>When you add a picture <a id="_idIndexMarker601"/>from the Main menu, the Select Image menu is<a id="_idIndexMarker602"/> displayed. From here, you can pick a picture. At this point, you will be prompted to add a <strong class="bold">FramedPhoto</strong> to the scene using the image you selected. We implemented this by adding a separate <strong class="bold">SelectImage Mode</strong>. We now want to make that mode serve two purposes. It's called from Main-mode when you're adding a new, framed photo to the scene, and it's called from EditPicture-mode when you want to replace the image of an existing framed photo that's already in the scene. This requires us to refactor the code.</p>
			<p>Currently, when we build the Select Image buttons (in the <strong class="source-inline">ImageButtons</strong> script) we have it configure and enable AddPicture-mode directly. Instead, it now needs to depend on how SelectImage-mode is being used, so we'll move that code from <strong class="source-inline">ImageButtons</strong> to <strong class="source-inline">SelectImageMode</strong>, as follows:</p>
			<ol>
				<li value="1">Edit the <strong class="source-inline">SelectImageMode</strong> script and add a reference to <strong class="source-inline">AddPictureMode</strong> at the top of the class:<p class="source-code">    [SerializeField] AddPictureMode addPicture;</p></li>
				<li>Then, add a public <strong class="source-inline">ImageSelected</strong> function:<p class="source-code">    public void ImageSelected(ImageInfo image)</p><p class="source-code">    {</p><p class="source-code">        addPicture.imageInfo = image;</p><p class="source-code">        InteractionController.EnableMode("AddPicture");</p><p class="source-code">    }</p></li>
				<li>Edit the <strong class="source-inline">ImageButtons</strong> script and add a reference to <strong class="source-inline">SelectImageMode</strong> at the top of the class:<p class="source-code">    [SerializeField] SelectImageMode selectImage;</p></li>
				<li>Then, replace<a id="_idIndexMarker603"/> the <strong class="source-inline">OnClick</strong> code with a call to <strong class="source-inline">ImageSelected</strong>, which <a id="_idIndexMarker604"/>we just wrote:<p class="source-code">    void OnClick(ImageInfo image)</p><p class="source-code">    {</p><p class="source-code">        selectImage.ImageSelected(image);</p><p class="source-code">    }</p><p>This refactoring has not added any new functionality, but it restructures the code for <strong class="source-inline">SelectImageMode</strong> to decide how the modal menu will be used. Now, let's edit <strong class="source-inline">SelectImageMode</strong> again and add support for replacing the <strong class="source-inline">currentPicture</strong> image.</p></li>
				<li>At the top of the <strong class="source-inline">SelectImageMode</strong> script, add the following declarations:<p class="source-code">    [SerializeField] EditPictureMode editPicture;</p><p class="source-code">    public bool isReplacing = false;</p></li>
				<li>Then, update the <strong class="source-inline">ImageSelected</strong> function, as follows:<p class="source-code">    public void ImageSelected(ImageInfo image)</p><p class="source-code">    {</p><p class="source-code"><strong class="bold">        if (isReplacing)</strong></p><p class="source-code"><strong class="bold">        {</strong></p><p class="source-code"><strong class="bold">            editPicture.currentPicture.SetImage(image);</strong></p><p class="source-code"><strong class="bold">            InteractionController.                EnableMode("EditPicture");</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code"><strong class="bold">        else</strong></p><p class="source-code"><strong class="bold">        {</strong></p><p class="source-code">            addPicture.imageInfo = image;</p><p class="source-code">            InteractionController.                EnableMode("AddPicture");</p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code">    }</p><p>So, now, when the menu is being used for replacing, it sends the selected image data to the edit mode's <strong class="source-inline">currentPicture</strong> object. Otherwise, it behaves as it did previously for AddPicture-mode.</p><p>Now, we need <a id="_idIndexMarker605"/>to make sure the <strong class="source-inline">isReplacing</strong> flag is set to <strong class="source-inline">false</strong> when <em class="italic">adding</em> and set to <strong class="source-inline">true</strong> when <em class="italic">replacing</em>. Again, this <a id="_idIndexMarker606"/>requires some refactoring. Currently, the main menu's <strong class="bold">Add</strong> button enables SelectImage-mode directly. Let's replace this with a <strong class="source-inline">SelectImageToAdd</strong> function in the <strong class="source-inline">GalleryMainMode</strong> script.</p></li>
				<li>At the top of the <strong class="source-inline">GalleryMainMode</strong> class, add a reference to <strong class="source-inline">SelectImageMode</strong>:<p class="source-code">    [SerializeField] SelectImageMode selectImage; </p></li>
				<li>Then, add a <strong class="source-inline">SelectImageToAdd</strong> function, as follows:<p class="source-code">    public void SelectImageToAdd ()</p><p class="source-code">    {</p><p class="source-code">        selectImage.isReplacing = false;</p><p class="source-code">        InteractionController.EnableMode("AddPicture");</p><p class="source-code">    }</p><p>We just need to remember to update the <strong class="bold">Add</strong> button <strong class="bold">OnClick</strong> action before we're done.</p></li>
				<li>Likewise, now, we can add a <strong class="source-inline">SelectImageToReplace</strong> function to the <strong class="source-inline">EditPictureMode</strong> script. Declare <strong class="source-inline">selectImage</strong> at the top of the class:<p class="source-code">    [SerializeField] SelectImageMode selectImage;</p><p>Then, add the function, as follows:</p><p class="source-code">    public void SelectImageToReplace()</p><p class="source-code">    {</p><p class="source-code">        selectImage.isReplacing = true;</p><p class="source-code">        InteractionController.EnableMode("SelectImage");</p><p class="source-code">    }</p></li>
			</ol>
			<p>Save all the scripts. Now, we <a id="_idIndexMarker607"/>need to connect it up in Unity, including setting the <strong class="bold">Add</strong> and <strong class="bold">Replace Image</strong> buttons' <strong class="bold">OnClick</strong> actions, and then setting the new <strong class="bold">SelectImage Mode</strong> parameters. Back <a id="_idIndexMarker608"/>in Unity, starting with the <strong class="bold">Add</strong> button, follow these steps:</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong> window, select the <strong class="bold">Add</strong> button under <strong class="bold">UI Canvas | Main UI</strong>.</li>
				<li>From the <strong class="bold">Hierarchy</strong> window, drag the <strong class="bold">Main Mode</strong> game object (under <strong class="bold">Interaction Controller</strong>) onto the <strong class="bold">Button | OnClick</strong> action's <strong class="bold">Object</strong> slot.</li>
				<li> In the <strong class="bold">Function</strong> selector, choose <strong class="bold">Gallery Main Mode | Select Image To Add</strong>.</li>
				<li>Now, we'll wire up the <strong class="bold">Replace Image</strong> button, which is located under <strong class="bold">UI Canvas | EditPicture UI | Edit Menu</strong>.</li>
				<li>In the <strong class="bold">Inspector</strong> window, on its <strong class="bold">Button</strong> component, click the <strong class="bold">+</strong> button at the bottom right of the <strong class="bold">OnClick</strong> actions.</li>
				<li>From the <strong class="bold">Hierarchy</strong> window, drag the <strong class="bold">EditPicture Mode</strong> game object onto the <strong class="bold">OnClick</strong> <strong class="bold">Object</strong> slot.</li>
				<li>In the <strong class="bold">Function</strong> selector, choose <strong class="bold">Edit Picture Mode | Select Image To Replace</strong>.<p>The buttons are now set up. All we have to do now is assign the other references.</p></li>
				<li>In the <strong class="bold">Hierarchy</strong> window, select the <strong class="bold">Main Mode</strong> game object (under <strong class="bold">Interaction Controller</strong>).</li>
				<li>Drag the <strong class="bold">SelectImage Mode</strong> object from the <strong class="bold">Hierarchy</strong> window onto the <strong class="bold">Select Image</strong> slot.</li>
				<li>In the <strong class="bold">Hierarchy</strong> window<a id="_idIndexMarker609"/> select the <strong class="bold">SelectImage Mode</strong> game object (under <strong class="bold">Interaction Controller</strong>). </li>
				<li>Drag the <strong class="bold">AddPicture Mode</strong> object <a id="_idIndexMarker610"/>from the <strong class="bold">Hierarchy</strong> window onto the <strong class="bold">Add Picture</strong> slot.</li>
				<li>Drag the <strong class="bold">EditPicture Mode</strong> object from the <strong class="bold">Hierarchy</strong> window onto the <strong class="bold">Edit Picture</strong> slot.</li>
				<li>In the <strong class="bold">Hierarchy</strong> window, select the <strong class="bold">EditPicture Mode</strong> game object (under <strong class="bold">Interaction Controller</strong>). </li>
				<li>Drag the <strong class="bold">SelectImage Mode</strong> object from the <strong class="bold">Hierarchy</strong> window onto the <strong class="bold">Select Image</strong> slot.</li>
				<li>In the <strong class="bold">Hierarchy</strong> window, select the <strong class="bold">Image Buttons</strong> game object (under <strong class="bold">UI Canvas | SelectImage UI</strong>).</li>
				<li>Drag the <strong class="bold">SelectImage Mode</strong> object from the <strong class="bold">Hierarchy</strong> window onto the <strong class="bold">Select Image</strong> slot.</li>
			</ol>
			<p>That should do it! </p>
			<p>In summary, we have refactored the <strong class="source-inline">ImageButtons</strong> script to call <strong class="source-inline">SelectImageMode.ImageSelected</strong> when a button is pressed. <strong class="source-inline">SelectImageMode</strong> will know whether the user is adding a new picture or replacing the image with an existing one. In the former case, the modal was called from Main-mode. In the latter case, the modal was called from EditPicture-mode and has an <strong class="source-inline">isReplacing</strong> flag set.</p>
			<p>Go ahead and <strong class="bold">Build and Run</strong> the scene. Add a picture and then edit it. Then, tap the <strong class="bold">Replace Image</strong> button. The <strong class="bold">Select Image</strong> menu should appear. At this point, you can pick another image, and it will replace the one in the currently selected <strong class="bold">FramedPhoto</strong>. There are <a id="_idIndexMarker611"/>more features you could add to this project, including letting the<a id="_idIndexMarker612"/> user choose a different frame for their pictures.</p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor185"/>Replacing the frame</h2>
			<p>The last <strong class="bold">Edit</strong> button we <a id="_idIndexMarker613"/>must implement is <strong class="bold">Replace Frame</strong>. I will leave this feature up to you to build since at this point, you may have the skills to work through this challenge on your own. A basic solution may be to keep the current <strong class="bold">FramedPhoto</strong> prefab and let the user just pick a different color for the frame. Alternatively, you could define separate frame objects within the <strong class="bold">FramedPhoto</strong> prefab, perhaps using models found on the Asset Store or elsewhere, and pick a frame that enables one or another frame object. Here are some suggestions regarding where to find models:</p>
			<ul>
				<li><em class="italic">Classic Picture Frame</em>: <a href="https://assetstore.unity.com/packages/3d/props/furniture/classic-picture-frame-59038">https://assetstore.unity.com/packages/3d/props/furniture/classic-picture-frame-59038</a><a href="https://assetstore.unity.com/packages/3d/props/furniture/classic-picture-frame-59038%20"/></li>
				<li><em class="italic">Turbosquid:</em> <a href="https://www.turbosquid.com/3d-model/free/picture-frame">https://www.turbosquid.com/3d-model/free/picture-frame</a><a href="https://www.turbosquid.com/3d-model/free/picture-frame%20"/></li>
			</ul>
			<p>So far, we've been interacting with the placed object indirectly through the Edit menu buttons. Next, we'll consider directly interacting with the virtual object.</p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor186"/>Interacting to edit a picture</h1>
			<p>We will now <a id="_idIndexMarker614"/>implement the ability to move and resize a virtual object we have placed in the AR scene. For this, I've decided to give the object being edited responsibility for its own interactions. That is, when <strong class="bold">FramedPhoto</strong> is being edited, it'll listen for input action events and move or resize itself.</p>
			<p>I've also decided to implement these features as separate components, <strong class="source-inline">MovePicture</strong> and <strong class="source-inline">ResizePicture</strong>, on the <strong class="bold">FramedPhoto</strong> prefab. This will only be enabled while <strong class="bold">FramedPhoto</strong> is being edited. First, let's ensure that instantiated <strong class="bold">FramedPhoto</strong> objects receive Input Action messages so that they can respond to user input.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor187"/>Ensuring FramedPhoto objects receive Input Action messages</h2>
			<p>We are <a id="_idIndexMarker615"/>currently using the Unity Input System, which lets you define and configure user input actions, as well as listening for those action events with a Player Input component. Currently, the scene has one Player Input component, attached to the Interaction Controller game object. The component is configured to broadcast messages down the local hierarchy. Therefore, if we want the <strong class="source-inline">FramedPhoto</strong> script to receive input action messages (which we now do), we must make sure the <strong class="bold">FramedPhoto</strong> object instances are children of the Interaction Controller. Let's simply parent the <strong class="bold">FramedPhoto</strong> objects under the <strong class="bold">AddPicture Mode</strong> game object where it's instantiated, as follows:</p>
			<ol>
				<li value="1">Edit the <strong class="source-inline">AddPictureMode</strong> script.</li>
				<li>In the <strong class="source-inline">PlaceObject</strong> function, set the spawned object's parent as the <strong class="bold">AddPicture Mode</strong> game object by adding this line of code:<p class="source-code">            GameObject spawned = Instantiate(placedPrefab,                position, rotation);</p><p class="source-code"><strong class="bold">            spawned.transform.SetParent(                transform.parent);</strong></p></li>
			</ol>
			<p>The instantiated <strong class="bold">FramedPhoto</strong> prefabs will now be parented by the <strong class="bold">AddPicture Mode</strong> game object.</p>
			<p class="callout-heading">Information – Scene Organization and Input Action Messages</p>
			<p class="callout">It's advisable to consider how you will organize your scene object hierarchy and where to place instantiated objects. For example, generally, I'd prefer to keep all our <strong class="bold">FramedPhotos</strong> in a separate root object container. If we did that now, we would have to set <strong class="bold">Player Input Behavior</strong> to invoke events, instead of broadcasting messages down the local hierarchy. And then, scripts responding to those input actions would subscribe (add listeners) to those messages (see <a href="mailto:https://docs.unity3d.com/Packages/com.unity.inputsystem@1.1/manual/Components.html#notification-behaviors">https://docs.unity3d.com/Packages/com.unity.inputsystem@1.1/manual/Components.html#notification-behaviors</a>). On the other hand, for tutorial projects such as the ones in this book, I've decided that using the built-in input action messages is cleaner and more straightforward to explain. </p>
			<p>Let's start by <a id="_idIndexMarker616"/>creating the empty scripts and adding them to the scene. Then, we'll build them out.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor188"/>Adding the interaction components</h2>
			<p>To expedite the implementation, we <a id="_idIndexMarker617"/>must create the script files first by performing the following steps:</p>
			<ol>
				<li value="1">In your <strong class="bold">Project</strong> assets, create a new C# script named <strong class="source-inline">MovePicture</strong>.</li>
				<li>Create another new C# script named <strong class="source-inline">ResizePicture</strong>.</li>
				<li>Open the <strong class="bold">FramedPhoto</strong> prefab for editing.</li>
				<li>Drag the <strong class="bold">MovePicture</strong> script and the <strong class="bold">ResizePicture</strong> script from the <strong class="bold">Project</strong> assets folder onto the root <strong class="bold">FramedPhoto</strong> object.</li>
				<li>Edit the <strong class="source-inline">FramedPhoto</strong> script in your code editor. Add the following declarations at the top of the class:<p class="source-code">MovePicture movePicture;</p><p class="source-code">ResizePicture resizePicture;</p></li>
				<li>Initialize it in <strong class="source-inline">Awake</strong> and start with the components disabled:<p class="source-code">    void Awake()</p><p class="source-code">    {</p><p class="source-code"><strong class="bold">        movePicture = GetComponent&lt;MovePicture&gt;();</strong></p><p class="source-code"><strong class="bold">        resizePicture = GetComponent&lt;ResizePicture&gt;();</strong></p><p class="source-code"><strong class="bold">        movePicture.enabled = false;</strong></p><p class="source-code"><strong class="bold">        resizePicture.enabled = false;</strong></p><p class="source-code">        layer = LayerMask.NameToLayer("PlacedObjects"); </p><p class="source-code">        Highlight(false);   </p><p class="source-code">}</p></li>
				<li>Then, enable these components when editing:<p class="source-code">   public void BeingEdited(bool editing)</p><p class="source-code">    {</p><p class="source-code">        Highlight(editing);</p><p class="source-code"><strong class="bold">        movePicture.enabled = editing;</strong></p><p class="source-code"><strong class="bold">        resizePicture.enabled = editing;</strong></p><p class="source-code">        isEditing = editing;</p><p class="source-code">    }</p></li>
			</ol>
			<p>We've now prepared <a id="_idIndexMarker618"/>ourselves to add the move and resize direct manipulation features to the <strong class="source-inline">FramedPhoto</strong> object. These will be separate components that are enabled only while the picture is in EditPicture mode.</p>
			<p>OK. Let's start by interactively moving the picture along the wall by dragging it with our finger on the screen.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor189"/>Using our finger to move the picture</h2>
			<p>We will<a id="_idIndexMarker619"/> start by implementing the drag-to-move feature by adding a <strong class="source-inline">MoveObject</strong> action to the <strong class="bold">AR Input Actions</strong> asset. Like the <strong class="bold">SelectObject</strong> action (and <strong class="bold">PlaceObject</strong>) that we already have, this will be bound to the touchscreen's primary touch position. We'll keep this action separate from the others, for example, should you decide to use a different interaction technique, such as a touch and hold, to start the dragging operation. But for now, we can just copy the other one, as follows: </p>
			<ol>
				<li value="1">In the <strong class="bold">Project</strong> window, <em class="italic">double-click</em> the <strong class="bold">AR Input Actions</strong> asset (in the <strong class="source-inline">Assets/Inputs/</strong> folder) to open it for editing (or use its <strong class="bold">Edit Asset</strong> button).</li>
				<li>In the middle section, <em class="italic">right-click</em> the <strong class="bold">SelectObject</strong> action and select <strong class="bold">Duplicate</strong>.</li>
				<li>Rename the new one <strong class="source-inline">MoveObject</strong>.</li>
				<li>Press <strong class="bold">Save Asset</strong> (unless <strong class="bold">Auto-Save</strong> is enabled).</li>
			</ol>
			<p>Now, we can add the <a id="_idIndexMarker620"/>code that will listen for this action. Edit the <strong class="source-inline">MovePicture</strong> script and write the following:</p>
			<p class="source-code">using System.Collections.Generic;</p>
			<p class="source-code">using UnityEngine;</p>
			<p class="source-code">using UnityEngine.EventSystems;</p>
			<p class="source-code">using UnityEngine.InputSystem;</p>
			<p class="source-code">using UnityEngine.XR.ARFoundation;</p>
			<p class="source-code">using UnityEngine.XR.ARSubsystems;</p>
			<p class="source-code">public class MovePicture : MonoBehaviour</p>
			<p class="source-code">{</p>
			<p class="source-code">    ARRaycastManager raycaster;</p>
			<p class="source-code">    List&lt;ARRaycastHit&gt; hits = new List&lt;ARRaycastHit&gt;();</p>
			<p class="source-code">    void Start()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        raycaster = FindObjectOfType&lt;ARRaycastManager&gt;();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    void Start(){ }</p>
			<p class="source-code">    public void OnMoveObject(InputValue value)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        if (!enabled) return;</p>
			<p class="source-code">        if (EventSystem.current.IsPointerOverGameObject(0))            return;</p>
			<p class="source-code">        Vector2 touchPosition = value.Get&lt;Vector2&gt;();</p>
			<p class="source-code">        MoveObject(touchPosition);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    void MoveObject(Vector2 touchPosition)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        if (raycaster.Raycast(touchPosition, hits,            TrackableType.PlaneWithinPolygon))</p>
			<p class="source-code">        {</p>
			<p class="source-code">            ARRaycastHit hit = hits[0];</p>
			<p class="source-code">            Vector3 position = hit.pose.position;</p>
			<p class="source-code">            Vector3 normal = -hit.pose.up;</p>
			<p class="source-code">            Quaternion rotation =                 Quaternion.LookRotation(normal, Vector3.up);</p>
			<p class="source-code">            transform.position = position;</p>
			<p class="source-code">            transform.rotation = rotation;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This code is very similar to that in the <strong class="source-inline">AddPictureMode</strong> script. It's using <strong class="bold">AR Raycast Manager</strong> to find a <a id="_idIndexMarker621"/>trackable plane and place the object so that it's flush with the plane and upright. The difference is that we're not instantiating a new object, we're just updating the transform of the existing one. And we're doing this continuously, so long as the input action events are being generated (that is, so long as the user is touching the screen). </p>
			<p>The <strong class="source-inline">OnMoveObject</strong> function is skipped if the input action message is received but this component is not enabled. It also checks that the user is not tapping a UI element (an event system object), such as one of our edit menu buttons.</p>
			<p>Try it out. If you play the scene, create a picture, and begin editing it, you should be able to drag the picture with your finger and it will move along the wall plane. In fact, since we are raycasting each update, it could find a newer, refined tracked plane as you're dragging, or even move the picture to a different wall.</p>
			<p>As we mentioned previously, if you tap the screen on any tracked plane, the current picture will "jump" to that location. If that is not your desired behavior, we can check that the initial touch is on the current picture before we start updating the transform position. The modified code is as follows:</p>
			<ol>
				<li value="1">Declare and initialize references to <strong class="source-inline">camera</strong> and <strong class="source-inline">layerMask</strong>:<p class="source-code">    Camera camera;</p><p class="source-code">    int layerMask;</p><p class="source-code">    void Start() {</p><p class="source-code">        raycaster = FindObjectOfType&lt;ARRaycastManager&gt;();</p><p class="source-code"><strong class="bold">        camera = Camera.main;</strong></p><p class="source-code"><strong class="bold">        layerMask =             1 &lt;&lt; LayerMask.NameToLayer("PlacedObjects");</strong></p><p class="source-code">    }</p></li>
				<li>Add a<a id="_idIndexMarker622"/> raycast to <strong class="source-inline">MoveObject</strong> to ensure the touch is on a picture before you move it:</li>
			</ol>
			<p class="source-code">    void MoveObject(Vector2 touchPosition)</p>
			<p class="source-code">    {</p>
			<p class="source-code"><strong class="bold">       Ray ray = camera.ScreenPointToRay(touchPosition);</strong></p>
			<p class="source-code"><strong class="bold">        if (Physics.Raycast(ray, Mathf.Infinity, layerMask))</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code">            if (raycaster.Raycast(touchPosition, hits,                TrackableType.PlaneWithinPolygon))</p>
			<p class="source-code">            {</p>
			<p class="source-code">                ARRaycastHit hit = hits[0];</p>
			<p class="source-code">                Vector3 position = hit.pose.position;</p>
			<p class="source-code">                Vector3 normal = -hit.pose.up;</p>
			<p class="source-code">                Quaternion rotation =                     Quaternion.LookRotation(normal,                         Vector3.up);</p>
			<p class="source-code">                transform.position = position;</p>
			<p class="source-code">                transform.rotation = rotation;</p>
			<p class="source-code">            }</p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code">    }</p>
			<p>Currently, we only have the tracked planes visible in AddPicture-mode. I think it would be useful to also show them in Edit-mode. We can use the same <strong class="source-inline">ShowTrackablesOnEnable</strong> script we wrote in a previous chapter that's already been applied <a id="_idIndexMarker623"/>to the <strong class="bold">AddPicture Mode</strong> game object. Add this as follows:</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong> window, select the <strong class="bold">EditPicture Mode</strong> game object (under <strong class="bold">Interaction Controller</strong>).</li>
				<li>Locate the <strong class="source-inline">ShowTrackablesOnEnable</strong> script in your Project <strong class="source-inline">Scripts/</strong> folder.</li>
				<li>From the <strong class="bold">Hierarchy</strong> window, drag the <strong class="bold">AR Session Origin</strong> game object onto the <strong class="bold">Show Trackables On Enable | Session Origin</strong> slot.</li>
				<li>Drag the script onto the <strong class="bold">EditPicture Mode</strong> object, adding it as a component.</li>
			</ol>
			<p>Now, when <strong class="bold">EditPicture Mode</strong> is enabled, the trackable planes will be displayed. When it's disabled and you go back to Main-mode, they'll be hidden again.</p>
			<p>Next, we'll implement the pinch-to-resize feature.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor190"/>Pinching to resize the picture</h2>
			<p>To implement<a id="_idIndexMarker624"/> pinch-to-resize, we'll also use an Input Action, but this will require a two-finger touch. As such, the action is not simply returning a single value (for example, Vector2). So, this time, we'll use a <strong class="bold">PassThrough</strong> Action Type. Add it by performing the following steps:</p>
			<ol>
				<li value="1">Edit the <strong class="bold">AR Input Actions</strong> asset, as we did previously.</li>
				<li>In the middle <strong class="bold">Actions</strong> section, select <strong class="bold">+</strong> and name it <strong class="source-inline">ResizeObject</strong>.</li>
				<li>In the rightmost <strong class="bold">Properties</strong> section, select <strong class="bold">Action Type | Pass Through</strong>, and <strong class="bold">Control Type | Vector 2</strong>.</li>
				<li>In the middle <strong class="bold">Actions</strong> section, select the <strong class="bold">&lt;No Binding&gt;</strong> child. Then, in the <strong class="bold">Properties</strong> section, select <strong class="bold">Properties | Path | Touchscreen | Touch #1 | Position</strong> to bind this action to a second finger screen touch.</li>
				<li>Press <strong class="bold">Save Asset</strong> (unless <strong class="bold">Auto-Save</strong> is enabled).</li>
			</ol>
			<p>Now, we can add the code to listen for this action. Edit the <strong class="source-inline">ResizePicture</strong> script and write it as follows. In the first part of the script, we declare several properties that we can use to tweak the behavior of the script from the Unity Inspector. <strong class="source-inline">pinchspeed</strong> lets you adjust the sensitivity of the pinch, while <strong class="source-inline">minimumScale</strong> and <strong class="source-inline">maximumScale</strong> let you limit <a id="_idIndexMarker625"/>how small or big the user will end up making the picture, respectively. Follow these steps:</p>
			<ol>
				<li value="1">Begin the script with the following code:<p class="source-code">using UnityEngine;</p><p class="source-code">using UnityEngine.EventSystems;</p><p class="source-code">using UnityEngine.InputSystem;</p><p class="source-code">public class ResizePicture : MonoBehaviour</p><p class="source-code">{</p><p class="source-code">    [SerializeField] float pinchSpeed = 1f;</p><p class="source-code">    [SerializeField] float minimumScale = 0.1f;</p><p class="source-code">    [SerializeField] float maximumScale = 1.0f;</p><p class="source-code">    float previousDistance = 0f;</p><p class="source-code">    void Start() { }</p><p>Note that I declared an empty <strong class="source-inline">Start()</strong> function. This is needed because a <strong class="source-inline">MonoBehaviour</strong> component without a <strong class="source-inline">Start</strong> or <strong class="source-inline">Update</strong> function cannot be <a id="_idIndexMarker626"/>disabled (you'll see this for yourself if you remove <strong class="source-inline">Start</strong> from the code and look at it in the <strong class="bold">Inspector</strong> window – you'll see that the <strong class="bold">Enable</strong> checkbox is missing).</p></li>
				<li>The <strong class="source-inline">OnResizeObject</strong> function is the listener for the input action messages. Because we specified the Action Type as <strong class="bold">Pass Through</strong>, there are no incoming arguments to the function. Instead, we can read the current state of <strong class="source-inline">Touchscreen</strong> to get the first and second finger touches. Then, we can pass those touch positions to our <strong class="source-inline">TouchToResize</strong> function:<p class="source-code">    public void OnResizeObject()</p><p class="source-code">    {</p><p class="source-code">        if (!enabled) return;</p><p class="source-code">        if (EventSystem.current.            IsPointerOverGameObject(0)) return;</p><p class="source-code">        Touchscreen ts = Touchscreen.current;</p><p class="source-code">        if (ts.touches[0].isInProgress &amp;&amp;             ts.touches[1].isInProgress)</p><p class="source-code">        {</p><p class="source-code">            Vector2 pos =                 ts.touches[0].position.ReadValue();</p><p class="source-code">            Vector2 pos1 =                 ts.touches[1].position.ReadValue();</p><p class="source-code">            TouchToResize(pos, pos1);</p><p class="source-code">        }</p><p class="source-code">        else</p><p class="source-code">        {</p><p class="source-code">            previousDistance = 0;</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
				<li>The <strong class="source-inline">TouchToResize</strong> algorithm <a id="_idIndexMarker627"/>is straightforward. It gets the distance between the two finger touches (in screen pixels) and compares it against the previous distance. Dividing the new distance by the previous distance gives us the percentage change, which we can use to directly modify the transform scale. It seems to work pretty well for me:<p class="source-code">    void TouchToResize(Vector2 pos, Vector2 pos1)</p><p class="source-code">    {</p><p class="source-code">        float distance = Vector2.Distance(pos, pos1);</p><p class="source-code">        if (previousDistance != 0)</p><p class="source-code">        {</p><p class="source-code">            float scale = transform.localScale.x;</p><p class="source-code">            float scaleFactor = (distance /                previousDistance) * pinchSpeed;</p><p class="source-code">            scale *= scaleFactor;</p><p class="source-code">            if (scale &lt; minimumScale)</p><p class="source-code">                scale = minimumScale;</p><p class="source-code">            if (scale &gt; maximumScale)</p><p class="source-code">                scale = maximumScale;</p><p class="source-code">            Vector3 localScale = transform.localScale;</p><p class="source-code">            localScale.x = scale;</p><p class="source-code">            localScale.y = scale;</p><p class="source-code">            transform.localScale = localScale;</p><p class="source-code">        }</p><p class="source-code">        previousDistance = distance;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Try it out. If you <a id="_idIndexMarker628"/>play the scene, create a picture, and begin editing it, you should be able to use two fingers to resize the picture, pinching your fingers together to make it smaller and un-pinching them apart to increase the picture's size. Here's a screen capture from my phone with some pictures arranged on my dining room wall, all of which are various sizes:</p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="Images/Figure_7.07-diningroom.jpg" alt="Figure 7.7 – Virtual framed photos arranged on my dining room wall&#13;&#10;" width="701" height="1401"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.7 – Virtual framed photos arranged on my dining room wall</p>
			<p>In this section, we<a id="_idIndexMarker629"/> looked at how to directly interact with virtual objects. Using input actions, we added features using the touchscreen to drag and move a picture on a wall, as well as pinching to resize a picture.</p>
			<p>We could improve this by adding a Cancel Edit feature that restores the picture to its pre-edited state. One way to do this is to make a temporary copy of the object when it enters edit mode, and then restore or discard it if the user cancels or saves their changes, respectively.</p>
			<p>Another feature worth considering is persisting the picture object arrangements between sessions, so that the app saves your pictures when you exit the app and restores them when you restart the app. This is an advanced topic that I will not cover in this book since it is outside of Unity AR Foundation itself. Each provider has its own proprietary <a id="_idIndexMarker630"/>solutions. If you're <a id="_idIndexMarker631"/>interested, take a<a id="_idIndexMarker632"/> look at <em class="italic">ARCore Cloud Anchors</em>, which is <a id="_idIndexMarker633"/>supported by Unity <em class="italic">ARCore Extensions</em> (<a href="https://developers.google.com/ar/develop/unity-arf/cloud-anchors/overview">https://developers.google.com/ar/develop/unity-arf/cloud-anchors/overview</a>) and <em class="italic">ARKit ARWorldMap</em> (<a href="https://developer.apple.com/documentation/arkit/arworldmap">https://developer.apple.com/documentation/arkit/arworldmap</a>), as exposed in the Unity <em class="italic">ARKit XR Plugin</em> (<a href="mailto:https://docs.unity3d.com/Packages/com.unity.xr.arkit@4.0/api/UnityEngine.XR.ARKit.ARWorldMap.html">https://docs.unity3d.com/Packages/com.unity.xr.arkit@4.0/api/UnityEngine.XR.ARKit.ARWorldMap.html</a>). </p>
			<p>This concludes our exploration of, and building, an AR photo gallery project.</p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor191"/>Summary</h1>
			<p>In this chapter, you expanded on the AR gallery project we began in <a href="B15145_06_Final_SB_epub.xhtml#_idTextAnchor136"><em class="italic">Chapter 6</em></a><em class="italic">, Gallery: Building an AR App</em>. That project left us with the ability to place framed photos on our walls. In this chapter, you added the ability to edit virtual objects in the scene.</p>
			<p>You implemented the ability to select an existing virtual object in Main-mode, where the selected object is highlighted and the app goes into EditPicture-mode. Here, there is an edit menu with buttons for <strong class="bold">Replace Image</strong>, <strong class="bold">Replace Frame</strong>, <strong class="bold">Remove Picture</strong>, and <strong class="bold">Done</strong> (return to Main-mode). The <strong class="bold">Replace Image</strong> feature displayed the same <strong class="bold">SelectImage</strong> modal menu that is used when we're creating (adding) new pictures. We had to refactor the code to make it reusable. </p>
			<p>While placing and moving a picture on the wall, you implemented a feature to avoid overlapping or colliding objects, automatically moving the picture away from the other ones. After that, you implemented some direct interactions with the virtual objects by using touch events to drag a picture to a new location. You also implemented pinching to resize pictures on the wall. Finally, you learned how to use more Unity APIs from C#, including collision trigger hooks and vector geometry. </p>
			<p>In the next chapter, we'll begin a new project while using a different AR tracking mechanism – tracked images – as we build a project for visualizing 3D data; namely, the planets in our Solar System.</p>
		</div>
	</div></body></html>