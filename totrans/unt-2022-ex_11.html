<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><div id="_idContainer120" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-144"><a id="_idTextAnchor151" class="pcalibre1 pcalibre calibre6"/>8</h1>
<h1 id="_idParaDest-145" class="calibre5"><a id="_idTextAnchor152" class="pcalibre1 pcalibre calibre6"/>Extending the Adventure Game</h1>
<p class="calibre3">In <a href="B18347_07.xhtml#_idTextAnchor130" class="pcalibre1 pcalibre calibre6"><span><em class="italic">Chapter 7</em></span></a>, we added polish to the game by applying some simple VFX using post-processing effects (mainly Bloom) with the Universal RP, Shader Graph for a custom 2D shader to make specific parts of a sprite glow, 2D lights to highlight the player, and the Trail Renderer component for a quick VFX win on our <span>bullet sprite.</span></p>
<p class="calibre3">We then moved away from the player to give some much-needed attention to the enemy NPCs in the game by creating configurable enemies using a ScriptableObject architecture and introducing changing behaviors based on the state pattern as implemented via a <span>simple FSM.</span></p>
<p class="calibre3">With the base functionality in place for the playable character and enemies with behaviors (mostly) set up, we can now move on to spawning enemies that attack the player and vice versa with a reusable health and <span>damage system.</span></p>
<p class="calibre3">In this chapter, we’re going to cover the following <span>main topics:</span></p>
<ul class="calibre17">
<li class="calibre15">Health and <span>inflicting damage</span></li>
<li class="calibre15">Updating the player and enemy to <span>use health</span></li>
<li class="calibre15">Enemy <span>wave spawner</span></li>
</ul>
<p class="calibre3">By the end of this chapter, you’ll be able to spawn enemies with simple health and damage systems – that will also be applicable for the player or any damageable objects in <span>the game!</span></p>
<h1 id="_idParaDest-146" class="calibre5"><a id="_idTextAnchor153" class="pcalibre1 pcalibre calibre6"/>Technical requirements</h1>
<p class="calibre3">To follow along in this chapter with the same artwork created for the project in the book, download the assets from the following <span>GitHub repository:</span><a id="_idTextAnchor154" class="pcalibre1 pcalibre calibre6"/></p>
<p class="calibre3"><a href="https://github.com/PacktPublishing/Unity-2022-by-Example" class="pcalibre1 pcalibre calibre6"><span>https://github.com/PacktPublishing/Unity-2022-by-Example</span></a></p>
<p class="calibre3">To follow along with your own artwork, you’ll need to create similar artwork using Adobe Photoshop, or a graphics program that can export layered Photoshop PSD/PSB files (e.g., Gimp, MediBang Paint, Krita, and <span>Affinity Photo).</span></p>
<h1 id="_idParaDest-147" class="calibre5"><a id="_idTextAnchor155" class="pcalibre1 pcalibre calibre6"/>Health and inflicting damage</h1>
<p class="calibre3">At this point in our project, we have implemented much of what we specified in our GDD (<a href="B18347_04.xhtml#_idTextAnchor079" class="pcalibre1 pcalibre calibre6"><span><em class="italic">Chapter 4</em></span></a>, <em class="italic">Table 4.1</em>) for our player character and enemies, but an essential system is still missing – health <span>and damage.</span></p>
<p class="calibre3">In the coming sections, we’ll not only tackle adding health to the player and enemies with a reusable component but also finish the enemy’s attack behavior for inflicting damage on the player. The player can already fire a weapon that shoots a projectile, so we’ll add to the <strong class="source-inline">Bullet</strong> object we previously made in <a href="B18347_06.xhtml#_idTextAnchor116" class="pcalibre1 pcalibre calibre6"><span><em class="italic">Chapter 6</em></span></a>, so that it can inflict <span>damage, too.</span></p>
<h2 id="_idParaDest-148" class="calibre8"><a id="_idTextAnchor156" class="pcalibre1 pcalibre calibre6"/>Health system</h2>
<p class="calibre3">We’ll develop a <strong class="source-inline">HealthSystem</strong> component<a id="_idIndexMarker764" class="pcalibre1 pcalibre calibre6"/> to create a reusable component for <strong class="source-inline">Player</strong>, enemy, and other objects (e.g., in the environment – think a destructible crate). This health system will track health, take damage and/or heal, and can be added to any object. The remainder of the setup will include creating Interfaces that tie the system together and make the whole thing operate in an abstract way (i.e., reusable, <span>extensible, maintainable).</span></p>
<p class="calibre3">Like before, to clearly understand how we’ll create the health system, we’ll utilize a UML diagram based on the concepts we just described in the preceding paragraph. We can always refer back to this diagram at any point <span>if needed.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer110">
<img alt="Figure 8.1 – Health system class diagram" src="image/B18347_08_1.jpg" class="calibre88"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Health system class diagram</p>
<p class="calibre3">Now, let’s dive into it! Create<a id="_idIndexMarker765" class="pcalibre1 pcalibre calibre6"/> a new script in the <strong class="source-inline">Assets/Scripts</strong> folder and name it <strong class="source-inline">HealthSystem</strong>. This, being central to the UML diagram, will be the largest class we’ll be creating for the health system because, well, it <em class="italic">is</em> the health system! Since it will consist of the most code we’ll be writing in this section, we’ll break it up by first just declaring the member variables and a Unity message event, then proceed to flesh it out as we build up the <span>system’s functionality:</span></p>
<pre class="source-code">
using UnityEngine;
public class HealthSystem: MonoBehaviour
{
    [SerializeField] private int _healthMax;
    private int _healthCurrent;
    private void OnTriggerEnter2D(Collision collision)
    {
        // UNDONE: Test for a collision with a component
        // that can damage us.
        // UNDONE: HandleDamageCollision();
        // UNDONE: Test for a collision with a component
        // that can heal us.
        // UNDONE: HandleHealCollision();
    }
}</pre> <p class="callout-heading">Task list (IDE)</p>
<p class="callout">You’ve undoubtedly seen <strong class="source-inline1">// UNDONE:</strong> in the preceding code<a id="_idIndexMarker766" class="pcalibre1 pcalibre calibre6"/> and may have wondered what that’s all about. Well, we can use some tokens in our comments that our IDE will pick up, and it will generate a task list<a id="_idIndexMarker767" class="pcalibre1 pcalibre calibre6"/> based on them! This feature helps us locate incomplete tasks and highlight things that need attention. Additionally, you can create your own custom tokens, which can be super useful for your specific needs (but you’ll need to check your specific IDE <span>for support).</span></p>
<p class="callout">Common tokens include <span>the following:</span></p>
<p class="callout"><strong class="source-inline1">    // </strong><span><strong class="source-inline1">TODO:</strong></span></p>
<p class="callout"><strong class="source-inline1">    // </strong><span><strong class="source-inline1">UNDONE:</strong></span></p>
<p class="callout"><strong class="source-inline1">    // </strong><span><strong class="source-inline1">HACK:</strong></span></p>
<p class="calibre3">As you may be able to infer from the code we have so far – and if you’ve read the code comments – <strong class="source-inline">HealthSystem</strong> functions through collisions with other objects in the scene, such as projectiles from enemies or healing pickups. The other objects can either damage or heal the object with the <strong class="source-inline">HealthSystem</strong> component on it, and that will depend on the interface the object inherits from (from the UML diagram: <strong class="source-inline">IDamage</strong> and <strong class="source-inline">IHeal</strong>). Even the ground as an object can potentially damage the player if, let’s say, the player’s velocity is above a certain threshold <span>when colliding.</span></p>
<p class="calibre3">Here’s the breakdown for the code added so far, plus the <span>required additions:</span></p>
<ul class="calibre17">
<li class="calibre15">Variable declarations will enable<a id="_idIndexMarker768" class="pcalibre1 pcalibre calibre6"/> the core function <span>of </span><span><strong class="source-inline">HealthSystem</strong></span><span>:</span><ul class="calibre22"><li class="calibre15"><strong class="source-inline">_healthMax</strong> will specify the maximum health value for the object (i.e., the object we’re giving health by adding the <span><strong class="source-inline">HealthSystem</strong></span><span> component).</span></li><li class="calibre15"><strong class="source-inline">_healthCurrent</strong> will specify the current health of the object. As the object is either damaged or healed, this value will decrease or increase respectively. When the object is created in the scene, we should set the current health to the <strong class="source-inline">_healthMax</strong> value, which we’ll do now by adding the <strong class="source-inline">Awake()</strong> Unity message event <span>as follows:</span><pre class="source-code">
    private void Awake()
    {
        _healthCurrent = _healthMax;
    }</pre></li><li class="calibre15">Note here that the max health value (<strong class="source-inline">_healthMax</strong> is the serialized stored value) will be saved within the <strong class="source-inline">Object with Health</strong> Prefab, but imagine that you could also use a ScriptableObject, database, cloud-obtained (JSON) data, or even<a id="_idIndexMarker769" class="pcalibre1 pcalibre calibre6"/> Unity’s own <strong class="bold">Remote Config</strong> (as part of <strong class="bold">Unity Gaming Services</strong>) so that we can change the<a id="_idIndexMarker770" class="pcalibre1 pcalibre calibre6"/> max health value dynamically (and, with some of these methods, at any time without being dependent on distributing a new build of <span>the game).</span></li></ul></li> </ul>
<p class="callout-heading">Additional reading | Unity Gaming Services</p>
<p class="callout">Remote<a id="_idIndexMarker771" class="pcalibre1 pcalibre calibre6"/> <span>Config: </span><a href="https://unity.com/products/remote-config" class="pcalibre1 pcalibre calibre6"><span>https://unity.com/products/remote-config</span></a></p>
<ul class="calibre17">
<li class="calibre15"><strong class="source-inline">OnTriggerEnter2D()</strong> is where the magic happens! Collisions with other objects drive the health system, so we’ll use this Unity message event to handle the interactions when triggered from the <span>physics system.</span></li>
</ul>
<p class="calibre3">Let’s add both damage and healing methods first, and then we’ll add the evaluations that call these <span>methods next:</span></p>
<p class="callout-heading">Note | Physical interactions</p>
<p class="callout">To have the objects physically respond to each other when colliding, use a <strong class="bold">Collider</strong> instance on the object that does not have <strong class="bold">IsTrigger</strong> enabled and respond to the collision using the <strong class="source-inline1">OnCollisionEnter2D()</strong> Unity message event. For an object to not have a physical response when colliding, use a <strong class="bold">Collider</strong> instance with the <strong class="bold">IsTrigger</strong> field enabled and respond to the collision using the <strong class="source-inline1">OnTriggerEnter2D()</strong> Unity <span>message event.</span></p>
<ul class="calibre17">
<li class="calibre15"><strong class="source-inline">HandleDamageCollision()</strong>, as the name implies, handles<a id="_idIndexMarker772" class="pcalibre1 pcalibre calibre6"/> when we collide with another object that can damage us. We’ll pass in the collision parameter from when <strong class="source-inline">OnTriggerEnter2D()</strong> is called and, a future addition, the object that caused the damage (which is the object inheriting from the <span><strong class="source-inline">IDamage</strong></span><span> interface).</span></li>
<li class="calibre15">Add the following method to the <span><strong class="source-inline">HealthSystem</strong></span><span> class:</span><pre class="source-code">
internal void HandleDamageCollision
    (Collider2D collision, IDamage damage)
{
    // UNDONE: TakeDamage(amount);
}</pre></li> <li class="calibre15">Okay, yes, we’ve added another unfinished method to be called here that we’ll again add to later: <strong class="source-inline">TakeDamage()</strong>. We’re keeping the approach simple, taking one baby step at a time to build out the health system. The simple UML diagram may set an expectation that this will be easy. Well, it is – provided we tackle the implementation one step at <span>a time.</span></li>
<li class="calibre15">Our future selves will again tackle implementing the <strong class="source-inline">TakeDamage()</strong> method in the coming <em class="italic">Taking damage – IDamage interface</em> section when we also add the required <span><strong class="source-inline">IDamage</strong></span><span> interface.</span></li>
<li class="calibre15"><strong class="source-inline">HandleHealCollision()</strong> is similar to the method for handling damage. We’ll add one for handling object healing. However, we’ll omit to pass in the <strong class="source-inline">collision</strong> object as a parameter this time; we’ll handle things a bit differently for healing compared to taking damage (as you’ll see in the coming <em class="italic">Healing – IHeal </em><span><em class="italic">interface</em></span><span> section).</span></li>
<li class="calibre15">Add the following method to the <span><strong class="source-inline">HealthSystem</strong></span><span> class:</span><pre class="source-code">
internal void HandleHealCollision(IHeal heal)
{
    // UNDONE: ApplyHealing(amount);
}</pre></li> <li class="calibre15">Okay, we’re piling on the <em class="italic">undone</em> methods to implement here, right?! Just like for <strong class="source-inline">TakeDamage()</strong>, we’ll have a method called for healing and changing the health value of the <span>affected object.</span></li>
</ul>
<p class="calibre3">And that’s the core of the <strong class="source-inline">HealthSystem</strong> class laid out. Let’s go<a id="_idIndexMarker773" class="pcalibre1 pcalibre calibre6"/> ahead and add the required interfaces that our new health system classes inherit from and make things <span>actually function!</span></p>
<h2 id="_idParaDest-149" class="calibre8"><a id="_idTextAnchor157" class="pcalibre1 pcalibre calibre6"/>Interfaces required!</h2>
<p class="calibre3">There’s still more work<a id="_idIndexMarker774" class="pcalibre1 pcalibre calibre6"/> to do before we add a <strong class="source-inline">HealthSystem</strong> component to any of our GameObjects, so let’s sort out and evaluate these damage and <span>heal collisions.</span></p>
<p class="calibre3">The first part we’ll need interfaces for is the evaluation of the object that collides with the object that has health (e.g., a <strong class="source-inline">Player</strong> or enemy object with the <strong class="source-inline">HealthSystem</strong> component added). We’ll determine whether the colliding object can damage or heal – we’re replacing this first <strong class="source-inline">UNDONE</strong> token in our <span>task list:</span></p>
<pre class="source-code">
    // UNDONE: Test for a collision with a component
    // that can damage us.</pre> <p class="calibre3">From the UML diagram, we can see the object we want to evaluate is either inherited from <strong class="source-inline">IDamage</strong> or <strong class="source-inline">IHeal</strong>. Using interfaces to inherit from ensures that the required members exist in our classes that provide the intended functionality (i.e., the class must satisfy the “contract” of <span>the interface).</span></p>
<p class="calibre3">Standard naming conventions<a id="_idIndexMarker775" class="pcalibre1 pcalibre calibre6"/> dictate that when naming an interface, it should begin with the letter “<em class="italic">I</em>,” which offers us an opportunity to be a bit clever, or even memorable, in our naming and bring more readability to our codebase. So, for an object that can damage another object, we’ll name the interface <strong class="source-inline">IDamage</strong> – as in <em class="italic">I damage [an object]</em>. In the <em class="italic">Healing – IHeal interface</em> section, we’ll add additional interfaces for <strong class="source-inline">IHaveHealth</strong> and <strong class="source-inline">IHeal</strong> – see what we did there. Not that I’m being terribly clever here because <em class="italic">IDamage</em>, <em class="italic">IDamageable</em>, and <em class="italic">ITakeDamage</em> are pretty common interface names for game code for the same <span>naming reasoning.</span></p>
<p class="calibre3">Now, let’s update the <strong class="source-inline">OnTriggerEnter2D()</strong> method with the following <strong class="source-inline">if</strong> statements that include the interfaces (that we’ll create just after <span>this step):</span></p>
<pre class="source-code">
    private void OnTriggerEnter2D(Collision collision)
    {
        // Test for a collision with a component that can
        // damage us.
        if (collision.
            TryGetComponent&lt;IDamage&gt;(out var damage))
        {
            HandleDamageCollision(collision, damage);
        }
        // Test for a collision with a component that can
        // heal us.
        else if (collision.
            TryGetComponent&lt;IHeal&gt;(out var heal))
        {
            HandleHealCollision(heal);
        }
    }</pre> <p class="calibre3">Let’s have a look at the following two evaluations<a id="_idIndexMarker776" class="pcalibre1 pcalibre calibre6"/> and how they’ll provide the desired functionality for our <span>health system:</span></p>
<ul class="calibre17">
<li class="calibre15"><strong class="source-inline">collision.TryGetComponent&lt;IDamage&gt;()</strong>: If you haven’t realized by now, I’m a fan of the <em class="italic">try get component pattern</em> – we can fail gracefully if the component doesn’t exist on the object we’re testing. And if it does exist, we conveniently have an <strong class="source-inline">out</strong> parameter that returns the <span>component. Simples!</span></li>
</ul>
<p class="callout-heading">Optimization note</p>
<p class="callout">When using the <strong class="source-inline1">TryGetComponent</strong> method, the method does not allocate<a id="_idIndexMarker777" class="pcalibre1 pcalibre calibre6"/> memory on the heap when it doesn’t find a component. When it does find a component, it allocates memory only for the return value, not the component itself. This can be very beneficial for improving performance and reducing garbage collection, unlike the <strong class="source-inline1">GetComponent</strong> methods, which can generate garbage and allocate more memory – both negatively impacting performance. By utilizing <strong class="source-inline1">TryGetComponent</strong> instead, you can avoid unnecessary memory allocations and keep your game running smooth <span>as butter.</span></p>
<p class="calibre3">So, what’s occurring here is, if the object we collided with has a component that inherits from <strong class="source-inline">IDamage</strong> on it, as in, <em class="italic">I damage this object</em>, then return the component and pass it into <strong class="source-inline">HandleDamageCollision()</strong> as a parameter along with the collision object itself. Peeking ahead a bit and referring back to the UML diagram, we can see that we’ll be implementing a <strong class="source-inline">ProjectileDamage</strong> component (e.g., on <strong class="source-inline">Bullet</strong>) that inherits <span>from </span><span><strong class="source-inline">IDamage</strong></span><span>.</span></p>
<ul class="calibre17">
<li class="calibre15"><strong class="source-inline">collision.TryGetComponent&lt;IHeal&gt;()</strong>: Ditto here. If the component we collided with has a component that inherits from <strong class="source-inline">IHeal</strong> on it, as in, <em class="italic">I heal this object</em>, then return the component and pass it into <strong class="source-inline">HandleHealCollision()</strong>. Again, peeking back at the UML diagram, we can see that we’ll be implementing a <strong class="source-inline">PickupHeal</strong> component (e.g., on a Water Diamond) that inherits <span>from </span><span><strong class="source-inline">IHeal</strong></span><span>.</span></li>
</ul>
<p class="calibre3">Currently, if the object collided does neither damage nor heal, then we simply ignore the collision (of course, when colliding with anything, the obvious choice here is to do a <span>camera shake!).</span></p>
<p class="calibre3">Now that we have an implementation<a id="_idIndexMarker778" class="pcalibre1 pcalibre calibre6"/> of the interface, we need to actually create them. These interfaces aren’t going to write themselves, so let’s start <span>with </span><span><strong class="source-inline">IDamage</strong></span><span>.</span></p>
<h2 id="_idParaDest-150" class="calibre8"><a id="_idTextAnchor158" class="pcalibre1 pcalibre calibre6"/>Taking damage – IDamage interface</h2>
<p class="calibre3">We’ve already seen<a id="_idIndexMarker779" class="pcalibre1 pcalibre calibre6"/> the UML <a id="_idIndexMarker780" class="pcalibre1 pcalibre calibre6"/>diagram (<span><em class="italic">Figure 8</em></span><em class="italic">.1</em>) and the <strong class="source-inline">HandleDamageCollision()</strong> code, where the <strong class="source-inline">IDamage</strong> interface is implemented but hasn’t been defined yet. I lied above, too: they can write themselves (at least partially) if we use the IDE’s refactoring tools – in <strong class="source-inline">OnTriggerEnter2D()</strong>, <strong class="source-inline">IDamage</strong> will have a red squiggly underline. Right-clicking on the word (or clicking anywhere on it and pressing <em class="italic">Alt + Enter</em> or <em class="italic">Ctrl + .</em> depending on your IDE) and selecting <strong class="bold">Generate interface ‘IDamage’ in a new file</strong> will generate <span>the following:</span></p>
<pre class="source-code">
internal interface IDamage
{
}</pre> <p class="calibre3">If you decided not to use refactoring tools (why not?), create a new C# script in the <strong class="source-inline">Assets/Scripts/Interfaces</strong> folder and name it <strong class="source-inline">IDamage</strong>. Even if you did use the refactoring tools, you’ll likely still need to move the generated script into the <strong class="source-inline">Assets/Scripts/Interfaces</strong> folder to keep <span>things tidy.</span></p>
<p class="calibre3">Now, we’ll need a field for specifying the value for how much the object inheriting from <strong class="source-inline">IDamage</strong> will damage the object with health, so add a <strong class="source-inline">DamageAmount</strong> variable declaration <span>like so:</span></p>
<pre class="source-code">
    int DamageAmount { get; }</pre> <p class="calibre3">Remember, all members of an interface are public, so there is no need to add the accessor. We’ll set the property to be a getter only, though; we’ll only want the value to be read by other classes (no modification outside of the class inheriting the interface – all nice and hidden, how we <span>like it).</span></p>
<p class="calibre3">Now that we have<a id="_idIndexMarker781" class="pcalibre1 pcalibre calibre6"/> our <strong class="source-inline">IDamage</strong> interface. We can use<a id="_idIndexMarker782" class="pcalibre1 pcalibre calibre6"/> it for making projectiles and, well, just about any other object that hurt the player, by subtracting health when a collision occurs between the object <span>and </span><span><strong class="source-inline">HealthSystem</strong></span><span>.</span></p>
<p class="calibre3">Let’s fix up the <strong class="source-inline">HandleDamageCollision()</strong> method now back in our <strong class="source-inline">HealthSystem</strong> class by removing the <strong class="source-inline">// UNDONE:</strong> token comment and using <strong class="source-inline">DamageAmount</strong> for <span>the parameter:</span></p>
<pre class="source-code">
    internal void HandleDamageCollision
        (Collider2D collision, IDamage damage)
    {
        TakeDamage(damage.DamageAmount);
    }</pre> <p class="calibre3">This sets us up nicely to have our IDE’s refactoring tools generate the <strong class="source-inline">TakeDamage()</strong> method for us, so let’s continue by doing just that. You know the drill: red squiggly line, etc., etc., then select <strong class="bold">Generate </strong><span><strong class="bold">method ‘TakeDamage.’</strong></span><span>.</span></p>
<p class="calibre3">And here <span>we are:</span></p>
<pre class="source-code">
    private void TakeDamage(int amount)
    {
        // UNDONE: Subtract from current health.
        // UNDONE: HealthChanged();
    }</pre> <p class="calibre3">I’m so sorry, more <em class="italic">undone</em> comments! Please don’t fret; with this very temporary instruction, we’ll fix up the code straight away. Fill in the method with the <span>following statements:</span></p>
<pre class="source-code">
    private void TakeDamage(int amount)
    {
        _healthCurrent = Mathf.Max(_healthCurrent - amount,
            0);
        HealthChanged();
    }</pre> <p class="calibre3">The first thing we do is update the current health value for the amount of damage received by subtracting <strong class="source-inline">amount</strong> from <strong class="source-inline">_healthCurrent</strong>. We’re getting some help from the <strong class="source-inline">Mathf.Max()</strong> function here so that the current health value will never dip below <a id="_idIndexMarker783" class="pcalibre1 pcalibre calibre6"/>zero (keeping <span>things positive).</span></p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout"><span><strong class="source-inline1">Mathf.Max()</strong></span><span>: </span><a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Mathf.Max.xhtml" class="pcalibre1 pcalibre calibre6"><span>https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Mathf.Max.xhtml</span></a></p>
<p class="calibre3">Let’s uncomment our placeholder<a id="_idIndexMarker784" class="pcalibre1 pcalibre calibre6"/> for the <strong class="source-inline">HealthChanged()</strong> method. Go ahead<a id="_idIndexMarker785" class="pcalibre1 pcalibre calibre6"/> and create an empty method block for it, but completing this method will be a job for our future selves when we actually have some objects set up to enact the <span>health change:</span></p>
<pre class="source-code">
    private void HealthChanged()
    {
        // UNDONE: If current health is greater than zero,
        // notify the object with health.
        // UNDONE: If current health is zero, the object
        // with health dies/is destroyed.
    }</pre> <p class="calibre3">We’ll call this method anytime the health value has changed so we can evaluate the current health of the object and <em class="italic">do stuff</em> accordingly – such as notify other classes about the health value of the object<a id="_idIndexMarker786" class="pcalibre1 pcalibre calibre6"/> changing or die/destroy<a id="_idIndexMarker787" class="pcalibre1 pcalibre calibre6"/> if health <span>reaches zero.</span></p>
<p class="calibre3">So, let’s get an object set up now that will inflict damage on <span>the player.</span></p>
<h2 id="_idParaDest-151" class="calibre8"><a id="_idTextAnchor159" class="pcalibre1 pcalibre calibre6"/>ProjectileDamage component</h2>
<p class="calibre3">Create a new script<a id="_idIndexMarker788" class="pcalibre1 pcalibre calibre6"/> called <strong class="source-inline">ProjectileDamage</strong> in the <strong class="source-inline">Assets/Scripts</strong> folder – this<a id="_idIndexMarker789" class="pcalibre1 pcalibre calibre6"/> is a component we’ll add to our <strong class="source-inline">Bullet</strong> Prefab. To ensure this component will cause damage to our health system, it will implement the <span><strong class="source-inline">IDamage</strong></span><span> interface:</span></p>
<pre class="source-code">
using UnityEngine;
public class ProjectileDamage : MonoBehaviour, IDamage
{
    public int DamageAmount =&gt; _damageAmount;
    [SerializeField] private int _damageAmount = 5;
}</pre> <p class="calibre3">The public <strong class="source-inline">DamageAmount int</strong> variable is required to be declared to satisfy the <strong class="source-inline">IDamage</strong> interface contract – it’s also necessary for the health system to obtain the value for the amount of damage this projectile causes! <strong class="source-inline">DamageAmount</strong> is a public property because all interface members are public and cannot contain fields. Because C# properties are not serialized by Unity, to assign a value in the <strong class="bold">Inspector</strong> window (i.e., save a damage amount value within our <strong class="source-inline">Bullet</strong> Prefab), we’ll encapsulate a private <strong class="source-inline">_damageAmount</strong> variable and decorate it with the <strong class="source-inline">[SerializeField]</strong> attribute. If you haven’t already guessed, this is the structure we’ll continue with throughout the remainder of <span>the book.</span></p>
<p class="calibre3">When you’ve finished saving the script, open up the <strong class="source-inline">Bullet</strong> Prefab in <strong class="bold">Prefab Edit Mode</strong> (double-click on it in the <strong class="bold">Project</strong> window) and add <strong class="source-inline">ProjectileDamage</strong> to the root GameObject, as seen in the <span>following figure:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer111">
<img alt="Figure 8.2 – Bullet Prefab ProjectileDamage component" src="image/B18347_08_2.jpg" class="calibre39"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Bullet Prefab ProjectileDamage component</p>
<p class="calibre3">When we declared <strong class="source-inline">_damageAmount</strong> in the preceding code, we set a default value of <strong class="source-inline">5</strong>, which you can already see as the assigned value in the <span><strong class="bold">Inspector</strong></span><span> window.</span></p>
<p class="calibre3">Okay, we can damage<a id="_idIndexMarker790" class="pcalibre1 pcalibre calibre6"/> stuff now; great! But that’s not really fair if objects such as our player<a id="_idIndexMarker791" class="pcalibre1 pcalibre calibre6"/> cannot also have a chance <span>to heal.</span></p>
<h2 id="_idParaDest-152" class="calibre8"><a id="_idTextAnchor160" class="pcalibre1 pcalibre calibre6"/>Healing – IHeal interface</h2>
<p class="calibre3">We’ve taken care of the left<a id="_idIndexMarker792" class="pcalibre1 pcalibre calibre6"/> side of the UML diagram (<span><em class="italic">Figure 8</em></span><em class="italic">.1</em>) for our health system, so now, similar to <strong class="source-inline">IDamage</strong>, we need to define the <strong class="source-inline">IHeal</strong> interface to take care of the right side. We’ll also create a component to add to objects that can <span>apply healing.</span></p>
<p class="calibre3">Back in the <strong class="source-inline">OnTriggerEnter2D()</strong> method now, let’s repeat the steps performed for creating the <strong class="source-inline">IDamage</strong> interface but <span>for </span><span><strong class="source-inline">IHeal</strong></span><span>:</span></p>
<ol class="calibre14">
<li class="calibre15">Create the <strong class="source-inline">IHeal</strong> interface script (have your IDE generate it) in the <strong class="source-inline">Assets/Scripts/Interfaces</strong> folder and add the <strong class="source-inline">HealAmount</strong> variable for, you guessed it, specifying the amount of <span>healing power:</span><pre class="source-code">
internal interface IHeal
{
    int HealAmount { get; }
}</pre></li> <li class="calibre15">Update the placeholder <strong class="source-inline">HandlHealCollision()</strong> method, specifying the <strong class="source-inline">HealAmount</strong> value from the interface<a id="_idIndexMarker793" class="pcalibre1 pcalibre calibre6"/> as the parameter when <span>calling </span><span><strong class="source-inline">ApplyHealing()</strong></span><span>:</span><pre class="source-code">
    private void HandleHealCollision(IHeal heal)
    {
        ApplyHealing(heal.HealAmount);
    }</pre></li> <li class="calibre15">Lastly, create the <span><strong class="source-inline">ApplyHealing()</strong></span><span> method:</span><pre class="source-code">
    private void ApplyHealing(int amount)
    {
        _healthCurrent = Mathf.Min(_healthCurrent + amount,
            _healthMax);
        HealthChanged();
    }</pre></li> </ol>
<p class="calibre3">The first thing we do is update the current health value for the amount of healing received by adding <strong class="source-inline">amount</strong> to <strong class="source-inline">_healthCurrent</strong>. Just like when we took damage, we’re getting some help from a <strong class="source-inline">Mathf</strong> function here again, but it’s <strong class="source-inline">Mathf.Min()</strong> this time, so that the current health value will never exceed the object’s maximum health<a id="_idIndexMarker794" class="pcalibre1 pcalibre calibre6"/> value (<span>no cheating).</span></p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout"><span><strong class="source-inline1">Mathf.Min</strong></span><span>: </span><a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Mathf.Min.xhtml" class="pcalibre1 pcalibre calibre6"><span>https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Mathf.Min.xhtml</span></a></p>
<p class="calibre3">And, like with damage, we’ll create<a id="_idIndexMarker795" class="pcalibre1 pcalibre calibre6"/> a healing component that will add health when a <span>collision occurs.</span></p>
<h3 class="calibre10">PickupHeal component</h3>
<p class="calibre3">Create a new script<a id="_idIndexMarker796" class="pcalibre1 pcalibre calibre6"/> called <strong class="source-inline">PickupHeal</strong> in the <span><strong class="source-inline">Assets/Scripts</strong></span><span> folder:</span></p>
<pre class="source-code">
using UnityEngine;
public class PickupHeal : MonoBehaviour, IHeal
{
    public int HealAmount =&gt; _healAmount;
    [SerializeField] private int _healAmount = 10;
}</pre> <p class="calibre3">Same as with the <strong class="source-inline">ProjectileDamage</strong> script, we can see that we’ve inherited from <strong class="source-inline">IHeal</strong> (to ensure healing with our health system) and implemented the <strong class="source-inline">IHeal</strong> interface by defining <strong class="source-inline">HealAmount</strong>. We’ve also encapsulated <strong class="source-inline">HealAmount</strong> by declaring a private <strong class="source-inline">_healAmount</strong> variable serialized so we can set the value in the <strong class="bold">Inspector</strong> window (note a default value of <strong class="source-inline">10</strong> is also <span>assigned here).</span></p>
<p class="callout-heading">Note on code architecture</p>
<p class="callout">If you find yourself needing many different types for damage or heal components, you can create a new base class for each that implements the interface, so you aren’t repeating yourself with the event and method to invoke. The current implementation suits our current needs, so you can also leave off here, or challenge yourself to create both a <strong class="source-inline1">DamageBase</strong> and <strong class="source-inline1">HealBase</strong> abstract class that <strong class="source-inline1">ProjectileDamage</strong> and <strong class="source-inline1">PickupHeal</strong> inherit <span>from, respectively.</span></p>
<p class="calibre3"><strong class="source-inline">PickupHeal</strong> is a component we’ll add to… hmmm… what object will we add it to? Let’s consult our GDD (<a href="B18347_04.xhtml#_idTextAnchor079" class="pcalibre1 pcalibre calibre6"><span><em class="italic">Chapter 4</em></span></a>, <span><em class="italic">Table 4.2</em></span><span>):</span></p>
<table class="no-table-style" id="table001-4">
<colgroup class="calibre11">
<col class="calibre12"/>
<col class="calibre12"/>
</colgroup>
<tbody class="calibre13">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">What is a buff mechanic for the player in the </strong><span><strong class="bold">adventure game?</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3">The player will be able to collect energy shards (water diamonds) scattered throughout the environment that, when a certain quantity has been collected, will give a power-up state to all of the weapons (increasing <span>damage dealt).</span></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US">Table 8.1 – Adding a buff to the GDD</p>
<p class="calibre3">Sounds great. Well, actually, I think we can do better. Let’s revise; after all, the GDD is a <span>living document:</span></p>
<table class="no-table-style" id="table002-2">
<colgroup class="calibre11">
<col class="calibre12"/>
<col class="calibre12"/>
</colgroup>
<tbody class="calibre13">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">What is a buff mechanic for the player in the </strong><span><strong class="bold">adventure game?</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3">Players can gather energy shards (water diamonds) as they explore the game world. The player can later use the collected energy to power up weapons (increase damage dealt) or heal the player, offering more strategic options for the player while navigating the <span>game’s challenges.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US">Table 8.2 – Revising the buff in the GDD</p>
<p class="calibre3">Better! Allowing players to choose between using energy shards to power up weapons or to heal themselves creates a risk-versus-reward strategy in the game. To make the mechanic meaningful to the player, a game designer must consider the approach carefully, especially if the choice<a id="_idIndexMarker797" class="pcalibre1 pcalibre calibre6"/> is only <span>sometimes clear!</span></p>
<p class="calibre3">For now, let’s just create an object that will heal the player when <span>picked up.</span></p>
<h3 class="calibre10">Creating a water diamond pickup</h3>
<p class="calibre3">Let’s use the water diamond<a id="_idIndexMarker798" class="pcalibre1 pcalibre calibre6"/> from the artwork provided at the following <span>link: </span><a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch8/Art-Assets" class="pcalibre1 pcalibre calibre6"><span>https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch8/Art-Assets</span></a><span>.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer112">
<img alt="Figure 8.3 – Water diamond artwork" src="image/B18347_08_3.jpg" class="calibre83"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Water diamond artwork</p>
<p class="calibre3">To create our water diamond pickup<a id="_idIndexMarker799" class="pcalibre1 pcalibre calibre6"/> Prefab based on the water diamond artwork, and as a refresher, follow <span>these steps:</span></p>
<ol class="calibre14">
<li class="calibre15">Import the artwork to the <strong class="source-inline">Assets/Sprites/Pickups</strong> folder. (I love how this water diamond art came out, by the way; nice <span>job, Nica!)</span></li>
<li class="calibre15">In the <strong class="bold">Project</strong> window, select the water diamond sprite and, in the <strong class="bold">Inspector</strong> window, use <strong class="bold">Sprite Editor</strong> to set the provided normal map as the <span>secondary texture.</span></li>
<li class="calibre15">Drag the water diamond sprite into the <strong class="bold">Hierarchy</strong> window and parent it to an empty game object (graphics should be parented to a base object), then name the parent <strong class="source-inline">Water Diamond (Heal)</strong> (remember, you can easily parent a GameObject in the <strong class="bold">Hierarchy</strong> window by right-clicking on it and selecting <strong class="bold">Create </strong><span><strong class="bold">Empty Parent</strong></span><span>).</span></li>
<li class="calibre15">Add a <strong class="source-inline">CapsuleCollider2D</strong> instance to the parent object to enable physics (precisely, <span>collision detection).</span></li>
<li class="calibre15">Use the <strong class="bold">Edit Collider</strong> button to enable resizing of the collider around the diamond shape, as seen in the <span>following figure.</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer113">
<img alt="Figure 8.4 – Water diamond healing Prefab" src="image/B18347_08_4.jpg" class="calibre39"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Water diamond healing Prefab</p>
<ol class="calibre14">
<li value="6" class="calibre15">Add the <strong class="source-inline">PickupHeal</strong> component to the Prefab root (also seen in <span><em class="italic">Figure 8</em></span><span><em class="italic">.4</em></span><span>).</span></li>
<li class="calibre15">Lastly, drag the parent object from the <strong class="bold">Hierarchy</strong> window to the <strong class="bold">Project</strong> window to create a Prefab asset in the <span><strong class="source-inline">Assets/Prefabs</strong></span><span> folder.</span></li>
</ol>
<p class="calibre3">For a quick hack to bump up<a id="_idIndexMarker800" class="pcalibre1 pcalibre calibre6"/> the visuals, you can cheat a bit (as indie game devs, it’s all about cheating to save time anywhere we can) and reuse the material we created in <a href="B18347_07.xhtml#_idTextAnchor130" class="pcalibre1 pcalibre calibre6"><span><em class="italic">Chapter 7</em></span></a>, for the bullet. Follow <span>these steps:</span></p>
<ol class="calibre14">
<li class="calibre15">In the <strong class="source-inline">Assets/Materials</strong> folder, duplicate the <strong class="source-inline">Bullet 1</strong> material and rename it <strong class="source-inline">Water </strong><span><strong class="source-inline">Diamond 1</strong></span><span>.</span></li>
<li class="calibre15">Assign the water diamond sprite to the <strong class="source-inline">MainTex</strong> channel but leave the <strong class="bold">Emission</strong> channel set to the <span><strong class="source-inline">bullet1_emission</strong></span><span> map.</span></li>
<li class="calibre15">Assign this new material to the <strong class="bold">Sprite Renderer Material</strong> field on the <strong class="bold">Water Diamond 1</strong> <span>Prefab’s graphic.</span></li>
<li class="calibre15">Adjust the HDR color and intensity for <span>desired visuals.</span></li>
</ol>
<p class="calibre3">Our pickup Prefab is looking <span>good. Yay!</span></p>
<p class="calibre3">We need to add one last bit of functionality<a id="_idIndexMarker801" class="pcalibre1 pcalibre calibre6"/> for this Prefab to be a pickup for the player. It has to disappear once “collected,” and we can do that by revisiting an existing reusable component we previously made – along with a <span>new one.</span></p>
<h3 class="calibre10">Composition for pickup behavior</h3>
<p class="calibre3">As previously introduced, being able to bring<a id="_idIndexMarker802" class="pcalibre1 pcalibre calibre6"/> multiple objects together to achieve<a id="_idIndexMarker803" class="pcalibre1 pcalibre calibre6"/> a desired behavior or functionality is a form of <strong class="bold">composition</strong>. To state another way, we’ll combine two or more reusable components, each responsible for a specific aspect of an object’s behavior or appearance. This will allow us to create a new behavior directly in the editor without introducing new code – this is especially valuable for designers on your team where experimentation can generate new <span>ideas independently.</span></p>
<p class="calibre3">Let’s start by adding the <strong class="source-inline">TriggeredEvent</strong> component to the root <strong class="source-inline">gameObject</strong> of the <strong class="bold">Water Diamond (Heal)</strong> Prefab. We made this component back in <a href="B18347_04.xhtml#_idTextAnchor079" class="pcalibre1 pcalibre calibre6"><span><em class="italic">Chapter 4</em></span></a>, section <em class="italic">Triggering actions in the level</em>. Now we have an <strong class="source-inline">OnTriggered</strong> event that fires when the player collides with the pickup object. We want to destroy the pickup, but there isn’t a built-in way to do that. However, it’s <span>easily solved.</span></p>
<h3 class="calibre10">Destroyer component</h3>
<p class="calibre3">To destroy the pickup, all we need is an additional<a id="_idIndexMarker804" class="pcalibre1 pcalibre calibre6"/> component serving as a single-purpose but reusable component. This component will be added to the existing composition for the pickup behavior. To clarify, we need to destroy the pickup object by calling the <strong class="source-inline">TriggeredEvent.OnTriggered</strong> event. So, first,  make a new script named <strong class="source-inline">Destroyer</strong> in the <span><strong class="source-inline">Assets/Scripts</strong></span><span> folder:</span></p>
<pre class="source-code">
using UnityEngine;
public class Destroyer : MonoBehaviour
{
    public float Delay = 0f;
    public void DestroyMe()
    {
        if (Delay &gt; 0)
            Invoke(nameof(DestroyNow), Delay);
        else
            DestroyNow();
    }
    private void DestroyNow() =&gt; Destroy(gameObject);
}</pre> <p class="calibre3">Simple. A public method that can be called that destroys<a id="_idIndexMarker805" class="pcalibre1 pcalibre calibre6"/> the object – <strong class="source-inline">DestroyMe()</strong>. I’ve added the option for setting a delay before destroying the object – yes, I’m confident this is a typical enough use case, it literally only took seconds to add, and I’ll defend that I’m not violating the <span>YAGNI principle!</span></p>
<p class="callout-heading">YAGNI | “You ain’t gonna need it”</p>
<p class="callout">This principle states that a programmer should only add functionality <span>if necessary.</span></p>
<p class="callout">Another one I like is <strong class="bold">DRY</strong> (<strong class="bold">don’t repeat yourself</strong>), which is simply directed<a id="_idIndexMarker806" class="pcalibre1 pcalibre calibre6"/> at reducing repetition (a basic example would be if you find yourself writing the same code more than once, extract it to a method <span>or abstraction).</span></p>
<p class="calibre3">Go ahead and add <strong class="source-inline">Destroyer</strong> to the root of the <strong class="source-inline">Water Diamond (Heal)</strong> Prefab so we can wire things up in the <span><strong class="bold">Inspector</strong></span><span> window:</span></p>
<ol class="calibre14">
<li class="calibre15">Set the execution state dropdown to <span><strong class="bold">Runtime Only</strong></span><span>.</span></li>
<li class="calibre15">Drag the <strong class="source-inline">Destroyer</strong> component to the object field (using its <span>title area).</span></li>
<li class="calibre15">In the function selection dropdown, select <strong class="bold">Destroyer</strong> | <span><strong class="bold">DestroyMe( )</strong></span><span>.</span></li>
<li class="calibre15">I’d leave <strong class="bold">Delay</strong> at <strong class="source-inline">0</strong> for this pickup, but for other behavior, you may want to adjust (see, you have that option!). And, yes, although <strong class="source-inline">Destroy()</strong> has a second parameter to delay destroying the object, the <strong class="source-inline">Destroyer</strong> class serves as a general example for introducing an <span>execution delay.</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer114">
<img alt="Figure 8.5 – Assign DestroyMe to OnTriggered (UnityEvent)" src="image/B18347_08_5.jpg" class="calibre89"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Assign DestroyMe to OnTriggered (UnityEvent)</p>
<p class="calibre3">Okay, so let’s talk about what objects can affect the health of other objects – right now, it’s like the Wild West out there, with everything able to damage everything else. We can’t have any of that going on, so let’s put on a mask<a id="_idIndexMarker807" class="pcalibre1 pcalibre calibre6"/> to start getting everyone to behave properly – a LayerMask, <span>that is.</span></p>
<h2 id="_idParaDest-153" class="calibre8"><a id="_idTextAnchor161" class="pcalibre1 pcalibre calibre6"/>Controlling what damages/heals what</h2>
<p class="calibre3">The problem we have to solve here is finding a simple way to specify what objects can damage other objects – this is essential for reinforcing<a id="_idIndexMarker808" class="pcalibre1 pcalibre calibre6"/> the game’s design. We’ve solved<a id="_idIndexMarker809" class="pcalibre1 pcalibre calibre6"/> this problem before by using a <strong class="bold">tag</strong> and also a <strong class="bold">LayerMask</strong>. My preference, generally, is to use tags only when comparing a single type of object in code and using a LayerMask for sorting out several different types of objects, with the added bonus of a LayerMask being designer friendly since the assignment is made in the <span><strong class="bold">Inspector</strong></span><span> window.</span></p>
<h3 class="calibre10">What damages</h3>
<p class="calibre3">The time to evaluate the objects <a id="_idIndexMarker810" class="pcalibre1 pcalibre calibre6"/>is at the time of the collision, so we will update the <em class="italic">handle collision</em> methods in <strong class="source-inline">HealthSystem</strong> accordingly. But first, we need to define the <strong class="source-inline">LayerMask</strong> variables in the right places, starting <span>with damage.</span></p>
<p class="calibre3">Add a <strong class="source-inline">DamageMask</strong> declaration to the <span><strong class="source-inline">IDamage</strong></span><span> interface:</span></p>
<pre class="source-code">
internal interface IDamage
{
    int DamageAmount { get; }
    LayerMask DamageMask { get; }
}</pre> <p class="calibre3">Now, add the following variables so we can use <strong class="source-inline">DamageMask</strong> and satisfy the existing contract we have in <strong class="source-inline">ProjectileDamage</strong> for the <span>interface implementation:</span></p>
<pre class="source-code">
public class ProjectileDamage : MonoBehaviour, IDamage
{
    public LayerMask DamageMask =&gt; _damageMask;
    [SerializeField] private LayerMask _damageMask;
    …</pre> <p class="calibre3">Here is the encapsulation pattern again (told you!) for the <span><strong class="source-inline">_damageMask</strong></span><span> variable.</span></p>
<p class="calibre3">We can now revise the <strong class="source-inline">HandleDamageCollision()</strong> method in <strong class="source-inline">HealthSystem</strong> to implement the <span>mask check:</span></p>
<pre class="source-code">
    internal void HandleDamageCollision
        (Collider2D collision, IDamage damage)
    {
        if (damage.DamageMask
            &amp; (1 &lt;&lt; gameObject.layer)) != 0)
        {
            TakeDamage(damage.DamageAmount);
        }
    }</pre> <p class="calibre3">This <strong class="source-inline">if</strong> statement should look<a id="_idIndexMarker811" class="pcalibre1 pcalibre calibre6"/> a bit familiar; it’s the same <em class="italic">is this object’s layer in the LayerMask?</em> evaluation we used for our <strong class="source-inline">Bullet</strong> back in <a href="B18347_06.xhtml#_idTextAnchor116" class="pcalibre1 pcalibre calibre6"><span><em class="italic">Chapter 6</em></span></a>. So, if the <strong class="source-inline">ProjectileDamage.DamageMask</strong> includes the object with health’s layer, only then will <strong class="source-inline">TakeDamage()</strong> <span>be called.</span></p>
<p class="calibre3">Damage bad. Heal good. Let’s do the same for what <span>can heal.</span></p>
<h3 class="calibre10">What heals</h3>
<p class="calibre3">We’re going to repeat what<a id="_idIndexMarker812" class="pcalibre1 pcalibre calibre6"/> we did for what damages, so add the <strong class="source-inline">LayerMask</strong> variable <strong class="source-inline">HealMask</strong> to the <span><strong class="source-inline">IHeal</strong></span><span> interface:</span></p>
<pre class="source-code">
internal interface IHeal
{
    int HealAmount { get; }
    LayerMask HealMask { get; }
}</pre> <p class="calibre3">Implement the updated <strong class="source-inline">IHeal</strong> interface contract in <strong class="source-inline">PickupHeal</strong> – encapsulating the <span><strong class="source-inline">_healMask</strong></span><span> variable:</span></p>
<pre class="source-code">
public class PickupHeal : MonoBehaviour, IHeal
{
    public LayerMask HealMask =&gt; _healMask;
    [SerializeField] private LayerMask _healMask;
    …</pre> <p class="calibre3">As an exception to repeating what we did in the <strong class="source-inline">HandleDamageCollision()</strong> method, let’s not repeat ourselves here by also adding the layer mask check code to <strong class="source-inline">HealthSystem.HandleHealCollision()</strong>; instead, let’s extract the layer mask evaluation to a method, and we’ll give it a nice, easy-to-understand name: <strong class="source-inline">IsLayerInLayerMask()</strong> (using <strong class="source-inline">Is</strong> to start the name with makes it obvious this will return a bool <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong> <span>value, no?):</span></p>
<pre class="source-code">
    private bool IsLayerInLayerMask(
        int layer,
        LayerMask mask)
            =&gt; (mask &amp; (1 &lt;&lt; layer)) != 0;</pre> <p class="callout-heading">Utility methods (C#)</p>
<p class="callout">You’ll likely need this <strong class="source-inline1">IsLayerInLayerMask()</strong> check in other classes, so consider creating a new static class for utility methods such as this one that can be used from anywhere in the <span>code base.</span></p>
<p class="callout">Or, for action on specific<a id="_idIndexMarker813" class="pcalibre1 pcalibre calibre6"/> types, consider adding an <strong class="bold">extension </strong><span><strong class="bold">method</strong></span><span>: </span><a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods" class="pcalibre1 pcalibre calibre6"><span>https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods</span></a><span>.</span></p>
<p class="calibre3">Let’s update <strong class="source-inline">HandleHealCollision()</strong> and use our new utility LayerMask<a id="_idIndexMarker814" class="pcalibre1 pcalibre calibre6"/> <span>check method:</span></p>
<pre class="source-code">
        private void HandleHealCollision(IHeal heal)
        {
            if (IsLayerInLayerMask(
                gameObject.layer, heal.HealMask))
            {
                ApplyHealing(heal.HealAmount);
            }
        }</pre> <p class="calibre3">Better readability for the win! Don’t forget to return to the <strong class="source-inline">HandleDamageCollision()</strong> method to refactor the LayerMask evaluation to use the new <strong class="source-inline">IsLayerInLayerMask()</strong> <span>method too!</span></p>
<p class="callout-heading">Optimization note | Physics 2D</p>
<p class="callout">We can also control the physics interactions between objects by specifying what collisions are processed by their layer using the physics Layer Collision Matrix (<strong class="bold">Edit</strong> | <strong class="bold">Project Settings</strong> | <strong class="bold">Physics 2D</strong>, select the <strong class="bold">Layer Collision </strong><span><strong class="bold">Matrix</strong></span><span> tab).</span></p>
<p class="calibre3">In this section, we created our health system that any object in the game can use for receiving damage and healing – it also provides<a id="_idIndexMarker815" class="pcalibre1 pcalibre calibre6"/> a method for handling the final death/destruction of the object. You learned how to use interfaces to tie everything together in an extensible way by not relying on concrete <span>class references.</span></p>
<p class="calibre3">We haven’t added our new <strong class="source-inline">HealthSystem</strong> to any of our game’s objects yet. Let’s do that in the next section, starting with <span>the player.</span></p>
<h1 id="_idParaDest-154" class="calibre5"><a id="_idTextAnchor162" class="pcalibre1 pcalibre calibre6"/>Updating the player and enemy to use health</h1>
<p class="calibre3">Not only <strong class="source-inline">Player</strong> and enemy objects<a id="_idIndexMarker816" class="pcalibre1 pcalibre calibre6"/> but any object can<a id="_idIndexMarker817" class="pcalibre1 pcalibre calibre6"/> be set up <a id="_idIndexMarker818" class="pcalibre1 pcalibre calibre6"/>to use <strong class="source-inline">HealthSystem</strong>. It’s barely<a id="_idIndexMarker819" class="pcalibre1 pcalibre calibre6"/> an inconvenience; in fact, the object simply needs to implement the <span><strong class="source-inline">IHaveHealth</strong></span><span> interface.</span></p>
<h2 id="_idParaDest-155" class="calibre8"><a id="_idTextAnchor163" class="pcalibre1 pcalibre calibre6"/>Assigning the object with health – IHaveHealth interface</h2>
<p class="calibre3">Back in the health system<a id="_idIndexMarker820" class="pcalibre1 pcalibre calibre6"/> UML diagram (<span><em class="italic">Figure 8</em></span><em class="italic">.1</em>), we see at the bottom<a id="_idIndexMarker821" class="pcalibre1 pcalibre calibre6"/> that the object having health will implement<a id="_idIndexMarker822" class="pcalibre1 pcalibre calibre6"/> the <strong class="source-inline">IHaveHealth</strong> interface (again, some meaningful naming here). Create a new file named <strong class="source-inline">IHaveHealth</strong> in the <span><strong class="source-inline">Assets/Scripts/Interfaces</strong></span><span> folder:</span></p>
<pre class="source-code">
internal interface IHaveHealth
{
    void HealthChanged(int amount);
    void Died();
}</pre> <p class="calibre3">We don’t yet have a class for the <strong class="source-inline">Player</strong> object, only <strong class="source-inline">PlayerController</strong>. We don’t want to add health<a id="_idIndexMarker823" class="pcalibre1 pcalibre calibre6"/> to something named <strong class="source-inline">controller</strong> because it wouldn’t make sense<a id="_idIndexMarker824" class="pcalibre1 pcalibre calibre6"/> considering the single-responsibility<a id="_idIndexMarker825" class="pcalibre1 pcalibre calibre6"/> principle – and the controller’s only concern is movement. Let’s fix that now by creating a script named <strong class="source-inline">Player</strong> in the <span><strong class="source-inline">Assets/Scripts</strong></span><span> folder:</span></p>
<pre class="source-code">
using UnityEngine;
public class Player : MonoBehaviour, IHaveHealth
{
}</pre> <p class="calibre3">Make sure it implements <strong class="source-inline">IHaveHealth</strong>. You can use the IDE’s refactoring tools again here. <strong class="source-inline">IHaveHealth</strong> should have the ever-so-helpful red squiggly underline – so, use the IDE refactoring to <em class="italic">implement interface</em> on it, and you will get <span>the following:</span></p>
<pre class="source-code">
public class Player : MonoBehaviour, IHaveHealth
{
    public void HealthChanged(int amount)
    {
        throw new System.NotImplementedException();
    }
    public void Died()
    {
        throw new System.NotImplementedException();
    }
}</pre> <p class="calibre3">Until we decide what actions to perform for these methods, we’ll leave<a id="_idIndexMarker826" class="pcalibre1 pcalibre calibre6"/> it as is for now. You will get a reminder in the <strong class="bold">console</strong> anytime these are called because <strong class="source-inline">throw</strong> indicates an exception has occurred while the program is running – in this case, <strong class="source-inline">NotImplementedException: The method or operation is </strong><span><strong class="source-inline">not implemented</strong></span><span>.</span></p>
<p class="callout-heading">Caution when using throw</p>
<p class="callout">Be warned, however: throwing<a id="_idIndexMarker827" class="pcalibre1 pcalibre calibre6"/> these exceptions will cause program execution in the calling method to stop – meaning any statements that follow <strong class="source-inline1">HealthChanged()</strong> will not be executed! If unsure, replace the <strong class="source-inline1">throw</strong> statements with something such as <strong class="source-inline1">Debug.LogError("Player.HealthChanged() has not </strong><span><strong class="source-inline1">been implemented!");</strong></span><span>.</span></p>
<p class="calibre3">Do exactly the same <span>for </span><span><strong class="source-inline">Enemy</strong></span><span>:</span></p>
<ol class="calibre14">
<li class="calibre15">Create a new <strong class="source-inline">Enemy</strong> script in the <span><strong class="source-inline">Assets/Scripts</strong></span><span> folder.</span></li>
<li class="calibre15">Add <strong class="source-inline">IHaveHealth</strong> to the <span>class declaration.</span></li>
<li class="calibre15">Implement the <strong class="source-inline">IHaveHealth</strong> <span>interface methods.</span></li>
</ol>
<p class="calibre3">The last step is to add<a id="_idIndexMarker828" class="pcalibre1 pcalibre calibre6"/> the components<a id="_idIndexMarker829" class="pcalibre1 pcalibre calibre6"/> to their respective <a id="_idIndexMarker830" class="pcalibre1 pcalibre calibre6"/>objects: adding <strong class="source-inline">Player</strong> to the <strong class="source-inline">Player</strong> Prefab and <strong class="source-inline">Enemy</strong> to both enemy Prefabs. Of course, they also both get <strong class="source-inline">HealthSystem</strong> added, as <span>seen here:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer115">
<img alt="Figure 8.6 – Player and Enemy Prefabs with health" src="image/B18347_08_6.jpg" class="calibre90"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Player and Enemy Prefabs with health</p>
<p class="calibre3">Initial values for max health are just initial values for testing. Playtesting will determine what values they’ll eventually<a id="_idIndexMarker831" class="pcalibre1 pcalibre calibre6"/> land on, depending<a id="_idIndexMarker832" class="pcalibre1 pcalibre calibre6"/> on difficulty and balanced<a id="_idIndexMarker833" class="pcalibre1 pcalibre calibre6"/> gameplay. You <span>got this!</span></p>
<p class="calibre3">Now that we have objects with health, we have one final part of our <strong class="source-inline">HealthSystem</strong> in need of completion – <span>processing.</span></p>
<h2 id="_idParaDest-156" class="calibre8"><a id="_idTextAnchor164" class="pcalibre1 pcalibre calibre6"/>Process changes to health</h2>
<p class="calibre3">To finish up our fully<a id="_idIndexMarker834" class="pcalibre1 pcalibre calibre6"/> functioning <strong class="source-inline">HealthSystem</strong>, we just need to process the changes to health for our objects that, yeah, have health. Back in our <strong class="source-inline">HealthSystem</strong> class, add the variable that will hold the reference to the object with health and get the object reference in <strong class="source-inline">Awake()</strong> using a <span><strong class="source-inline">GetComponent()</strong></span><span> call:</span></p>
<pre class="source-code">
public class HealthSystem : MonoBehaviour
{
    …
    private IHaveHealth _objectWithHealth;
    private void Awake()
    {
        …
        _objectWithHealth = GetComponent&lt;IHaveHealth&gt;();
    }</pre> <p class="calibre3">As our future selves now, we’ll revisit<a id="_idIndexMarker835" class="pcalibre1 pcalibre calibre6"/> the <strong class="source-inline">HealthChanged()</strong> method and squash those final lingering <strong class="source-inline">UNDONE</strong> token comments! We’ll use a null check (<strong class="source-inline">if</strong> statement) to ensure we have a sibling component on this GameObject that implements the <strong class="source-inline">IHaveHealth</strong> interface. We’ll give ourselves a warning in the console if we don’t (and use a <strong class="source-inline">return</strong> statement as a sort of cancellation not to execute any code that follows), and proceed to process the health <span>change otherwise:</span></p>
<pre class="source-code">
    private void HealthChanged()
    {
        if (_objectWithHealth == null)
        {
            Debug.LogWarning($"HealthSystem on " +
                $"'{gameObject.name}' requires a " +
                $"sibling component that inherits from " +
                $"IHaveHealth!", gameObject);
            return;
        }
        if (_healthCurrent &gt; 0)
            _objectWithHealth.HealthChanged
                (_healthCurrent);
        else
            _objectWithHealth.Died();
    }</pre> <p class="calibre3">With that, our health system is complete! It allows the addition of health to any object and gives the ability for any object to cause damage or heal without any concrete class references! Interfaces for <span>the win!</span></p>
<p class="calibre3">We covered much territory creating the health system and wrote lots of code back and forth in several classes, so don’t forget that you can always refer to the completed project code for this chapter on the book’s GitHub repo <span>here: </span><a href="https://github.com/PacktPublishing/Unity-2022-by-Example" class="pcalibre1 pcalibre calibre6"><span>https://github.com/PacktPublishing/Unity-2022-by-Example</span></a><span>.</span></p>
<p class="calibre3">Keeping with our composition pattern, let’s quickly look<a id="_idIndexMarker836" class="pcalibre1 pcalibre calibre6"/> at how we can set up the ability to easily add different behaviors (i.e., components) when interactions with <span><strong class="source-inline">HealthSystem</strong></span><span> occur.</span></p>
<h3 class="calibre10">Adding behavior with UnityEvent</h3>
<p class="calibre3">We’ve used <strong class="source-inline">UnityEvent</strong> before, for<a id="_idIndexMarker837" class="pcalibre1 pcalibre calibre6"/> the <strong class="source-inline">TriggeredEvent</strong> component<a id="_idIndexMarker838" class="pcalibre1 pcalibre calibre6"/> back in <a href="B18347_04.xhtml#_idTextAnchor079" class="pcalibre1 pcalibre calibre6"><span><em class="italic">Chapter 4</em></span></a>. It’s flexible, in that listeners can be registered by code or assigned in the <strong class="bold">Inspector</strong> window (you already know I’m a fan of this one), so it will be a perfect use case for our <span>needs here.</span></p>
<p class="calibre3">Only a few additions are required to add a <strong class="source-inline">UnityEvent</strong> instance that will be invoked when we handle the collisions for <strong class="source-inline">IDamage</strong> and <strong class="source-inline">IHeal</strong>. Let’s start by adding a method declaration to <span>the interfaces:</span></p>
<pre class="source-code">
internal interface IDamage
{
    …
    void DoDamage(Collider2D collision, bool isAffected);
}
internal interface IHeal
{
    …
    void DoHeal(GameObject healedObject);
}</pre> <p class="calibre3">As you can see in the differences<a id="_idIndexMarker839" class="pcalibre1 pcalibre calibre6"/> in the declarations, we’ll change things<a id="_idIndexMarker840" class="pcalibre1 pcalibre calibre6"/> up just a bit with each implementation. <strong class="source-inline">DoDamage()</strong> will pass two parameters for collision and whether the object is affected by the collision (as in, did it just collide or was it affected by the damage?). We can use this bool to alter things such as the visual effect (e.g., small versus a sizeable varying particle effect), where <strong class="source-inline">DoHeal()</strong> will just pass in the object that is <span>being healed.</span></p>
<p class="calibre3">Now let’s implement the changes to the interfaces, starting with damage in the <strong class="source-inline">ProjectileDamage</strong> class. Add the <strong class="source-inline">UnityEvent</strong> and <span><strong class="source-inline">DoDamage()</strong></span><span> methods:</span></p>
<pre class="source-code">
public class ProjectileDamage : MonoBehaviour, IDamage
{
    …
    public UnityEvent&lt;Collider2D, bool&gt; OnDamageEvent;
    public void DoDamage(Collider2D collision,
        bool isAffected)
            =&gt; OnDamageEvent?.Invoke(collision,
                isAffected);
}</pre> <p class="calibre3">Here are the specifics of the implementation coded in the <span>preceding snippet:</span></p>
<ul class="calibre17">
<li class="calibre15"><strong class="source-inline">OnDamageEvent</strong>: Declare as a <strong class="source-inline">UnityEvent</strong> instance with two parameters. <strong class="source-inline">Collider2D</strong> takes the collision object that can be used to get the intersection position between the objects. And the <strong class="source-inline">isAffected</strong> value indicates whether or not the damage was applied as a result of the collision - this is from the layer mask evaluation, as we’ll see in <span>a minute.</span></li>
</ul>
<p class="calibre3">Take notice that we won’t use the <strong class="source-inline">event</strong> keyword here because it is a <strong class="source-inline">UnityEvent</strong> instance – it’s not a delegate type but a serializable class. Otherwise, always use the <strong class="source-inline">event</strong> keyword for your events to enforce the event pattern, where only the implementing class <span>should invoke!</span></p>
<ul class="calibre17">
<li class="calibre15"><strong class="source-inline">DoDamage()</strong>: This is the public method called from <strong class="source-inline">HandleDamageCollision()</strong> when the interaction occurs, and its sole responsibility is to invoke the <strong class="source-inline">UnityEvent</strong> instance (passing <span>the parameters).</span></li>
</ul>
<p class="calibre3">And now do the same<a id="_idIndexMarker841" class="pcalibre1 pcalibre calibre6"/> for <strong class="source-inline">PickupHeal</strong> – implement<a id="_idIndexMarker842" class="pcalibre1 pcalibre calibre6"/> the changes with <span>the interface:</span></p>
<pre class="source-code">
public class PickupHeal : MonoBehaviour, IHeal
{
    …
    public UnityEvent&lt;GameObject&gt; OnHealEvent;
    public void DoHeal(GameObject healedObject)
        =&gt; OnHealEvent?.Invoke(healedObject);
}</pre> <p class="calibre3">Here is the explanation for these <span>code changes:</span></p>
<ul class="calibre17">
<li class="calibre15"><strong class="source-inline">OnHealEvent</strong>: Declared as a <strong class="source-inline">UnityEvent</strong> instance with one parameter. The <strong class="source-inline">GameObject</strong> instance is just the object that is affected by the healing. The usage could simply be getting the object’s transform position for instantiating an object or <span>particle effect.</span></li>
<li class="calibre15"><strong class="source-inline">DoHeal()</strong>: Just like the damage method, this is a public method called from <strong class="source-inline">HandleHealCollision()</strong> when the interaction occurs and is also solely responsible for invoking the <strong class="source-inline">UnityEvent</strong> instance (passing <span>the parameter).</span></li>
</ul>
<p class="calibre3">The final step is to add<a id="_idIndexMarker843" class="pcalibre1 pcalibre calibre6"/> the public <strong class="source-inline">Do</strong> calls to<a id="_idIndexMarker844" class="pcalibre1 pcalibre calibre6"/> the <strong class="source-inline">HealthSystem.OnTriggerEnter2D()</strong> method. Update <strong class="source-inline">HandleDamageCollision()</strong> <span>like so:</span></p>
<pre class="source-code">
    internal void HandleDamageCollision
        (Collider2D collision, IDamage damage)
    {
        var isAffected = IsLayerInLayerMask(
            gameObject.layer, damage.DamageMask);
        damage.DoDamage(collision, isAffected);
        if (isAffected)
            TakeDamage(damage.DamageAmount);
    }</pre> <p class="calibre3">We introduced a local bool variable, <strong class="source-inline">isAffected</strong>, to get the <strong class="source-inline">IsLayerInLayerMask()</strong> result – we can then use the variable in place of calling <strong class="source-inline">IsLayerInLayerMask()</strong> <span>multiple times.</span></p>
<p class="calibre3">We can then just call <strong class="source-inline">DoDamage()</strong> and only call <strong class="source-inline">TakeDamage()</strong> if the object is affected by the <span>damaging object.</span></p>
<p class="calibre3">Now, update <strong class="source-inline">HandleHealCollision()</strong> <span>like so:</span></p>
<pre class="source-code">
    private void HandleHealCollision(IHeal heal)
    {
        if (IsLayerInLayerMask(gameObject.layer,
            heal.HealMask))
        {
            heal.DoHeal(gameObject);
            ApplyHealing(heal.HealAmount);
        }
    }</pre> <p class="calibre3">Unlike with damage, we don’t care about the impact of the damaging object having an effect or not. We’ll process healing if it’s in <strong class="source-inline">HealMask</strong>. We just need to call the public <strong class="source-inline">DoHeal()</strong> – passing in the object being healed – and <span>we’re done!</span></p>
<p class="calibre3">Now that we have<a id="_idIndexMarker845" class="pcalibre1 pcalibre calibre6"/> an event <a id="_idIndexMarker846" class="pcalibre1 pcalibre calibre6"/>exposed on the <strong class="source-inline">ProjectileDamage</strong> and <strong class="source-inline">PickupHeal</strong> components, let’s refactor an earlier composition for destroying the water diamond pickup. Hence, we have an example of <span>its usage.</span></p>
<h3 class="calibre10">Re-composition for Destroyer</h3>
<p class="calibre3">With <strong class="source-inline">PickupHeal</strong> now having a <strong class="source-inline">UnityEvent</strong> instance triggered<a id="_idIndexMarker847" class="pcalibre1 pcalibre calibre6"/> when the collision occurs, we can improve the composition for destroying the water diamond object when it’s collected. We previously used the <strong class="source-inline">TriggeredEvent</strong> component, but now we need to assign the <strong class="source-inline">Destroyer.DestroyMe()</strong> function to the <strong class="source-inline">OnHealEvent</strong> function selection <span>drop-down menu.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer116">
<img alt="Figure 8.7 – Revising Destroyer" src="image/B18347_08_7.jpg" class="calibre91"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.7 – Revising Destroyer</p>
<p class="calibre3">Referring to <span><em class="italic">Figure 8</em></span><em class="italic">.7</em>, let’s walk through <span>this change:</span></p>
<ol class="calibre14">
<li class="calibre15">(<em class="italic">A</em>) – Click the little <strong class="bold">+</strong> icon on the <strong class="source-inline">OnHealEvent</strong> tab to add a new listener to <span>the list.</span></li>
<li class="calibre15">(<em class="italic">B</em>) – Drag the <strong class="source-inline">Destroyer</strong> component to the object field (using its <span>title area).</span><ul class="calibre22"><li class="calibre15">In the function selection drop-down menu, select <strong class="bold">Destroyer | </strong><span><strong class="bold">DestroyMe( )</strong></span><span>.</span></li></ul></li>
<li class="calibre15">(<em class="italic">C</em>) – Right-click on the <strong class="source-inline">TriggeredEvent</strong> title area to bring up the context menu and select <span><strong class="bold">Remove Component</strong></span><span>.</span></li>
</ol>
<p class="calibre3">You end up with an <strong class="bold">Inspector</strong> window that looks like the right-most image – you are <span>done. Easy-peasy.</span></p>
<p class="calibre3">Also, we don’t need to worry about <strong class="source-inline">IsTriggeredByPlayer</strong> from the <strong class="source-inline">TriggeredEvent</strong> component anymore since <strong class="source-inline">DoHeal()</strong> will only be called if the <strong class="source-inline">HealMask</strong> check <span>is satisfied.</span></p>
<p class="calibre3">In this section, we have created a fully implemented health system, and that’s a game changer (yes, bad pun). Again, you learned the power of interfaces and how we can quickly add functionality to existing systems. We also practiced composition by refactoring some reusable components<a id="_idIndexMarker848" class="pcalibre1 pcalibre calibre6"/> to explore a different approach to destroying the heal <span>pickup object.</span></p>
<p class="calibre3">In the next section, let’s put the health system through its paces by having a bunch of pesky enemies to contend with as we introduce a <span>wave spawner.</span></p>
<h1 id="_idParaDest-157" class="calibre5"><a id="_idTextAnchor165" class="pcalibre1 pcalibre calibre6"/>Enemy wave spawner</h1>
<p class="calibre3">A <strong class="bold">wave spawner</strong> may sound scary, but it’s just a straightforward<a id="_idIndexMarker849" class="pcalibre1 pcalibre calibre6"/> script. We need to instantiate a new enemy<a id="_idIndexMarker850" class="pcalibre1 pcalibre calibre6"/> from a given position and on a fixed (or random) time interval. We’ll also ensure things don’t get out of hand by limiting the number of <span>enemies spawned.</span></p>
<p class="calibre3">So, with that in mind, let’s have a look at our new <strong class="source-inline">EnemySpawner</strong> script – create it in the <strong class="source-inline">Assets/Scripts</strong> folder – and see whether you can point out where the few requirements I just stated have <span>been implemented:</span></p>
<pre class="source-code">
using UnityEngine;
public class EnemySpawner : MonoBehaviour
{
    [SerializeField] private Enemy _enemyPrefab;
    [SerializeField] private float _spawnInterval = 5f;
    [SerializeField] private int _maxSpawned = 3;
    private int _objectCount = 0;
    private void Start()
        =&gt; InvokeRepeating(
            nameof(SpawnEnemy), 0f, _spawnInterval);
    private void SpawnEnemy()
    {
        if (_objectCount &lt; _maxSpawned)
        {
            var enemy = Instantiate(_enemyPrefab,
                transform.position, Quaternion.identity);
            enemy.Init(DestroyedCallback);
            _objectCount++;
        }
    }
    public void DestroyedCallback() =&gt; _objectCount--;
}</pre> <p class="calibre3">Let’s break this class down – a lot of this should<a id="_idIndexMarker851" class="pcalibre1 pcalibre calibre6"/> be looking very familiar <span>by now:</span></p>
<ol class="calibre14">
<li class="calibre15">Declare a variable for the enemy Prefab that will be spawned – we use the <strong class="source-inline">Enemy</strong> type here instead of <strong class="source-inline">GameObject</strong> because when we reference <strong class="source-inline">_enemyPrefab</strong> later, we’ll be referencing the <strong class="source-inline">Enemy</strong> class directly and won’t need to <span>do </span><span><strong class="source-inline">GetComponent()</strong></span><span>.</span></li>
<li class="calibre15">Declare a variable for <strong class="source-inline">_spawnInterval</strong>, which will be the delay before spawning the <span>next enemy.</span></li>
<li class="calibre15">Declare a variable for <strong class="source-inline">_maxSpawned</strong>, which will be the total number of enemies onscreen – from this spawner – at the <span>same time.</span></li>
<li class="calibre15">Declare a variable for <strong class="source-inline">_objectCount</strong>, which keeps track of how many enemies are <span>currently spawned.</span></li>
<li class="calibre15">Create the <strong class="source-inline">Start()</strong> method – here we’ll simply use <strong class="source-inline">InvokeRepeating()</strong> to repeatedly call <strong class="source-inline">SpawnEnemy()</strong> at the specified spawn <span>interval (</span><span><strong class="source-inline">_spawnInterval</strong></span><span>).</span></li>
<li class="calibre15">Create the <strong class="source-inline">SpawnEnemy()</strong> method – we first check to see whether we’ve already instantiated our <strong class="source-inline">_maxSpawned</strong> amount of enemies, and, if not, <strong class="source-inline">Instantiate()</strong> a <span>new </span><span><strong class="source-inline">Enemy</strong></span><span>.</span><ol class="calibre42"><li class="calibre15">We create a new (implicit declaration using <strong class="source-inline">var</strong>) local <strong class="source-inline">enemy</strong> variable – returned from the <strong class="source-inline">Instantiate()</strong> call – so that we can call <strong class="source-inline">Init()</strong> and pass in a callback parameter (as a pseudo constructor). This is in place of what would usually be the C# constructor (objects created with the <strong class="source-inline">new</strong> keyword, which, if you remember, we cannot do <span>with </span><span><strong class="source-inline">MonoBehaviour</strong></span><span>).</span></li><li class="calibre15">Increment the number of spawned objects <span>with </span><span><strong class="source-inline">_objectCount++</strong></span><span>.</span></li></ol></li>
<li class="calibre15">Define the <strong class="source-inline">DestroyedCallback()</strong> method passed into the <strong class="source-inline">Enemy.Init()</strong> call so that, when the enemy object is destroyed, the currently spawned enemy count can be decreased – resulting in the spawner instantiating another enemy to maintain the <span><strong class="source-inline">_maxSpawned</strong></span><span> count.</span></li>
</ol>
<p class="callout-heading">Don’t forget about object pooling!</p>
<p class="callout">Note that if we have waves<a id="_idIndexMarker852" class="pcalibre1 pcalibre calibre6"/> and waves of many enemies, we do want to optimize this by introducing object pooling. Refer back to <a href="B18347_06.xhtml#_idTextAnchor116" class="pcalibre1 pcalibre calibre6"><span><em class="italic">Chapter 6</em></span></a><span>.</span></p>
<p class="calibre3">We’ll have to tie <strong class="source-inline">DestroyedCallback</strong> to the <strong class="source-inline">Enemy</strong> class because<a id="_idIndexMarker853" class="pcalibre1 pcalibre calibre6"/> it’s passed to the instantiated enemy object via the <strong class="source-inline">enemy.Init()</strong> call. Let’s add everything to support that now; it’s not much, so open the <strong class="source-inline">Enemy</strong> script and add <span>the following:</span></p>
<pre class="source-code">
public class Enemy : MonoBehaviour, IHaveHealth
{
    private event UnityAction _onDestroyed;
    internal void Init(UnityAction destroyedCallback)
        =&gt; _onDestroyed = destroyedCallback;
    private void OnDestroy()
        =&gt; _onDestroyed?.Invoke();
    …</pre> <p class="calibre3">Here we have a <strong class="source-inline">UnityAction</strong> instance that we’ll use to invoke the callback when the enemy object is destroyed – you’ve seen all <span>this before.</span></p>
<p class="calibre3">We just need to actually destroy the enemy object, and we do that when the object dies, as dictated by the <strong class="source-inline">IhaveHealth</strong>-interface-implemented <span><strong class="source-inline">Died()</strong></span><span> method:</span></p>
<pre class="source-code">
    public void Died() =&gt; Destroy(gameObject);</pre> <p class="calibre3">A note about <strong class="source-inline">DestroyedCallback</strong> and why we don’t have to <em class="italic">unregister from the event</em> when enemy is destroyed: the responsibility is being flipped here since <strong class="source-inline">EnemySpawner</strong> is not holding a reference to the instantiated enemy object. You only need to unregister (or <strong class="source-inline">RemoveListener</strong>) from events<a id="_idIndexMarker854" class="pcalibre1 pcalibre calibre6"/> that can become <span>invalid references.</span></p>
<p class="calibre3">Let’s set up a Prefab we can reuse as a preconfigured <span>enemy spawner.</span></p>
<h2 id="_idParaDest-158" class="calibre8"><a id="_idTextAnchor166" class="pcalibre1 pcalibre calibre6"/>Creating the enemy spawner Prefab</h2>
<p class="calibre3">Go ahead and, in your current<a id="_idIndexMarker855" class="pcalibre1 pcalibre calibre6"/> open scene in Unity, create a new empty GameObject in the <strong class="bold">Hierarchy</strong> window and name it <strong class="source-inline">EnemyB Spawner 1</strong> – we can have different Prefabs for different enemy spawning behaviors. Make sure to place it right at ground level in your environment because the spawner’s transform position will be used as the enemy instantiation point. Add the <strong class="source-inline">EnemySpawner</strong> component to the <strong class="source-inline">EnemyB</strong><strong class="bold"> </strong><strong class="source-inline">Spawner 1</strong> object and drag in the <strong class="source-inline">EnemyB</strong> Prefab from the <strong class="source-inline">Assets/Prefabs</strong> folder to the <strong class="bold">Enemy Prefab</strong> field, as seen in <span><em class="italic">Figure 8</em></span><span><em class="italic">.8</em></span><span>.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer117">
<img alt="Figure 8.8 – Enemy spawner setup" src="image/B18347_08_8.jpg" class="calibre39"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.8 – Enemy spawner setup</p>
<p class="calibre3">Finish up by dragging the <strong class="source-inline">EnemyB Spawner 1</strong> object in the <strong class="bold">Hierarchy</strong> window to the <strong class="source-inline">Assets/Prefabs</strong> <span>folder. Yay!</span></p>
<p class="calibre3">If you playtest the enemy wave spawner now, they’ll just spawn on top of one another, be disorganized, and not go anywhere – in other words, not acting<a id="_idIndexMarker856" class="pcalibre1 pcalibre calibre6"/> like robots at all. Let’s integrate spawning with the patrolling behavior to keep <span>things orderly.</span></p>
<h2 id="_idParaDest-159" class="calibre8"><a id="_idTextAnchor167" class="pcalibre1 pcalibre calibre6"/>Integrating spawning with patrol behavior</h2>
<p class="calibre3">If you haven’t picked up<a id="_idIndexMarker857" class="pcalibre1 pcalibre calibre6"/> on it already, because we’ve paid attention<a id="_idIndexMarker858" class="pcalibre1 pcalibre calibre6"/> to the project’s code structure and followed good programming practices from the beginning, maintaining and extending the code to add new functionality has been simple and straightforward. Integrating our new wave spawner to work with the existing patrol behavior will also be quick work. We’ll just need to add a few things to set <span>it up.</span></p>
<p class="calibre3">First things first, let’s see if the instantiated <strong class="source-inline">Enemy B</strong> Prefab has a patrol behavior and, if so, <strong class="source-inline">SetWaypoints()</strong>. To do that, let’s modify the <strong class="source-inline">SpawnEnemy()</strong> method in the <strong class="source-inline">EnemySpawner</strong> class. Here you can see we’re again using <strong class="source-inline">TryGetComponent()</strong> to fail gracefully if the component doesn’t exist on <span>the enemy:</span></p>
<pre class="source-code">
    private void SpawnEnemy()
    {
        if (_objectCount &lt; _maxSpawned)
        {
            …
            if (enemy.TryGetComponent
                &lt;IBehaviorPatrolWaypoints&gt;(out var patrol))
                    patrol.SetWaypoints(
                        _waypointPatrolLeft,
                        _waypointPatrolRight);
        }</pre> <p class="calibre3">In the <strong class="source-inline">PatrolWaypoints</strong> class, add the following <strong class="source-inline">SetWaypoints()</strong> method (or, again, use the IDE’s refactoring tools to generate it) to allow setting the left and right waypoint private variables externally (encapsulation <span>at work):</span></p>
<pre class="source-code">
    public void SetWaypoints(
        Transform left,
        Transform right)
    {
        _waypointPatrolLeft = left;
        _waypointPatrolRight = right;
    }</pre> <p class="calibre3">And, don’t forget: we’ll need to add a <strong class="source-inline">SetWaypoints()</strong> method declaration to our <strong class="source-inline">IBehaviorPatrolWaypoints</strong> interface so that it’s accessible from the reference in the <span><strong class="source-inline">EnemySpawner</strong></span><span> class:</span></p>
<pre class="source-code">
public interface IBehaviorPatrolWaypoints
{
    …
    void SetWaypoints(Transform left, Transform right);
}</pre> <p class="calibre3">Seriously, that’s it – three simple additions<a id="_idIndexMarker859" class="pcalibre1 pcalibre calibre6"/> get the patrolling behavior<a id="_idIndexMarker860" class="pcalibre1 pcalibre calibre6"/> all wired up to our enemy spawner. You’ll just have to add two empty GameObjects to the scene for the patrolling path of this enemy spawner, one for left and one for right, and assign them in the <strong class="bold">Inspector</strong> window, as seen in the enemy spawner setup from <span><em class="italic">Figure 8</em></span><span><em class="italic">.8</em></span><span>.</span></p>
<p class="calibre3">However, you’ll notice we have a problem (you playtested, right?). Enemies won’t be able to pass each other as they patrol between the waypoints – a simple problem to solve by removing their physics interactions with each other. First, we’ll need a layer to set the enemy objects to… how <span>about </span><span><strong class="source-inline">Enemy</strong></span><span>?</span></p>
<p class="calibre3">Using the <strong class="bold">Layers</strong> drop-down menu in the top-right corner of the <strong class="bold">Editor</strong> window, select <span><strong class="bold">Edit Layers…</strong></span><span>.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer118">
<img alt="Figure 8.9 – Add an enemy layer" src="image/B18347_08_9.jpg" class="calibre92"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.9 – Add an enemy layer</p>
<p class="calibre3">Under the <strong class="bold">Layers</strong> sections, in the first empty <strong class="bold">User Layer</strong> field, simply type in <strong class="source-inline">Enemy</strong> to <span>add it.</span></p>
<p class="calibre3">Now we can control the physics<a id="_idIndexMarker861" class="pcalibre1 pcalibre calibre6"/> interactions between enemy<a id="_idIndexMarker862" class="pcalibre1 pcalibre calibre6"/> objects by specifying what collisions<a id="_idIndexMarker863" class="pcalibre1 pcalibre calibre6"/> are processed by their layer. Using the <strong class="bold">Physics Layer Collision Matrix</strong> (<strong class="bold">Edit</strong> | <strong class="bold">Project Settings</strong> | <strong class="bold">Physics 2D</strong>; select the <strong class="bold">Layer Collision Matrix</strong> tab), we’re showing that we disabled physics interactions between all objects set to the <strong class="source-inline">Enemy</strong> layer (<span>uncheck </span><span><strong class="bold">Enemy/Enemy</strong></span><span>):</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer119">
<img alt="Figure 8.10 – Physics 2D layer collision matrix" src="image/B18347_08_10.jpg" class="calibre93"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.10 – Physics 2D layer collision matrix</p>
<p class="calibre3">When you playtest the enemy wave spawner in the scene now, the spawned enemies will patrol past one <span>another. Awesome!</span></p>
<p class="calibre3">In this section, we created a wave spawner<a id="_idIndexMarker864" class="pcalibre1 pcalibre calibre6"/> to instantiate new enemies<a id="_idIndexMarker865" class="pcalibre1 pcalibre calibre6"/> on a fixed time interval and integrated it with the existing patrol behavior. We finished up by resolving physics interactions between enemy objects to allow them to pass each other <span>while patrolling.</span></p>
<h1 id="_idParaDest-160" class="calibre5"><a id="_idTextAnchor168" class="pcalibre1 pcalibre calibre6"/>Summary</h1>
<p class="calibre3">In this chapter, we covered the implementation of a health system that any object in the game can use to receive damage, heal, and handle the final death/destruction of the object. This system was designed using interfaces to tie everything together in an extensible way without relying on concrete class references – the flexibility of interfaces allowed for the quick addition of new functionality to our <span>existing code.</span></p>
<p class="calibre3">We continued by creating a wave spawner that instantiates new enemies on a fixed time interval and integrates with the existing patrol behavior. This allows for adding in more complex enemy behavior, which adds new challenges to the game. Additionally, we discussed how to disable physics interactions between objects, which allowed patrolling enemies to pass each other in <span>this case.</span></p>
<p class="calibre3">Finally, we further explored composition by refactoring some of our reusable components to explore a different approach to destroying the heal pickup object. Through examples such as this, the importance of good programming practices and the use of interfaces to build flexible and extensible systems <span>was highlighted.</span></p>
<p class="calibre3">In the next chapter, we’ll complete the adventure game by creating a simple quest system for collecting key objects for solving the entryway puzzle. We will also introduce a new event system for keeping our code <span>loosely coupled.</span></p>
</div>
</div></body></html>