- en: Event Bus
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件总线
- en: For our first subject in the *Decoupling* section of this book, we are going
    to review the Event Bus pattern. But first, we need to address the confusion that
    often arises between the definition of an Event Bus and its close cousin, the
    Event Queue. We can quickly boil down the core difference between both from their
    names.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的*解耦*部分，我们将回顾事件总线模式。但首先，我们需要解决经常出现在事件总线定义及其紧密相关的表亲事件队列定义之间的混淆。我们可以从它们的名字中快速总结出两者之间的核心区别。
- en: A bus permits data to flow between different components, while a queue collects
    a list of data that needs processing at sequential intervals. And by this high-level
    definition of a bus, we can conclude that an Event Bus will focus on serving as
    a central hub for the publishing and broadcasting of events, and not as a queue
    of those events.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 公交车允许数据在不同组件之间流动，而队列收集需要按顺序间隔处理的数据列表。通过这个高级的公交车定义，我们可以得出结论，事件总线将专注于作为事件发布和广播的中心枢纽，而不是作为这些事件的队列。
- en: So, in this chapter, we will be focusing on building an Event Bus that will
    optimize the way we decouple listeners and consumers of events in Unity.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将专注于构建一个事件总线，这将优化我们在Unity中解耦事件监听者和消费者事件的方式。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Reviewing the basics of the Event Bus pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查事件总线模式的基本原理
- en: Implementing a global messaging system that can be adapted to any game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个可以适应任何游戏的全球消息系统
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The Event Bus is an extension of the Observer pattern, so I recommend revisiting [Chapter
    10](b24cadf0-e8e7-45c8-b2f3-f6d72985f19a.xhtml), *Observer*, before starting this
    one.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 事件总线是观察者模式的扩展，因此在开始这一部分之前，我建议您重新阅读第10章，*观察者*。
- en: 'We will also be using the following specific Unity engine API features:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用以下特定的Unity引擎API功能：
- en: '`UnityEvents`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UnityEvents`'
- en: '`UnityActions`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UnityActions`'
- en: If you're unfamiliar with these, please review their official Unity API documentation,
    but note that we will be reviewing them in the *Code example* section of this
    chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对这些不熟悉，请查阅它们的官方Unity API文档，但请注意，我们将在本章的*代码示例*部分对其进行回顾。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际效果：
- en: '[http://bit.ly/2OxHxto](http://bit.ly/2OxHxto)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2OxHxto](http://bit.ly/2OxHxto)'
- en: An overview of the Event Bus Pattern
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件总线模式概述
- en: There's a possible point of confusion around the Event Bus pattern. It's sometimes
    referred to as a **Messaging System** or the **Publish-Subscribe** pattern, the
    latter being the most accurate name for what we are implementing in this chapter.
    But because we are taking a very hands-on approach to this book, we are going
    to refer to this pattern's design as an Event Bus, which is a more high-level
    and system-oriented name for it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件总线模式周围可能存在一些混淆点。有时它被称为**消息系统**或**发布-订阅**模式，后者是我们在本章中实现的最准确名称。但因为我们在这本书中采取了一种非常实际的方法，所以我们将会把这种模式的设计称为事件总线，这是一个更高级和系统化的名称。
- en: As we have seen in [Chapter 9](b24cadf0-e8e7-45c8-b2f3-f6d72985f19a.xhtml), *Observer*,
    C# has native implementations that simplify the process of integrating events
    by offering an event-driven mechanism that permits Subjects and Observers to communicate
    with each other. But C#'s native event system does have a drawback – observers
    need to be *aware* of the presence of potential subjects, or unexpected behaviors
    can occur.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第9章中看到的，*观察者*，C#有原生的实现，通过提供事件驱动机制简化了集成事件的过程，允许主题和观察者相互通信。但C#的原生事件系统确实有一个缺点——观察者需要*意识到*潜在主题的存在，否则可能会出现意外的行为。
- en: This, therefore, is why we are going to learn how to use the Event Bus—with
    this pattern, we are going to eliminate this dependency and make it possible for
    any object to publish events and subscribe to them without any direct dependencies
    between each other. Consequently, we will shift from an observer/subject arrangement
    to a more flexible publisher/subscriber approach.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将学习如何使用事件总线——使用这种模式，我们将消除这种依赖关系，并使任何对象都能够发布事件并订阅它们，而无需彼此之间有任何直接依赖。因此，我们将从观察者/主题安排转变为更灵活的发布者/订阅者方法。
- en: '![](img/4fdc7d33-f5cd-485c-a783-15093ddb647a.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4fdc7d33-f5cd-485c-a783-15093ddb647a.png)'
- en: 'Let''s review the following diagram of the Event Bus and examine its elements:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下事件总线图，并检查其元素：
- en: 'As we can see, there are three main ingredients:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，有三个主要成分：
- en: '**Publishers**:These objects can request the hub to manage specific events
    and broadcast them to the right listeners'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**出版商**：这些对象可以请求中心管理特定事件并将它们广播给正确的听众'
- en: '**Event Hub**: This object is responsible for coordinating the communication
    of events between the **Publishers** and **Subscribers**'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件中心**：该对象负责协调发布者和订阅者之间的事件通信'
- en: '**Subscribers**: These objects subscribe themselves to the hub''s event broadcast
    channel so they can listen for specific events'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订阅者**：这些对象将自己订阅到中心的广播事件频道，以便它们可以监听特定事件'
- en: Benefits and drawbacks
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点和缺点
- en: 'The benefits and drawbacks of the Event Bus are quite moderate—it''s a pattern
    that permits the implementation of an event management system without asking for
    significant architectural changes in your code base:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 事件总线的优点和缺点相当适中——这是一个允许在不要求对代码库进行重大架构更改的情况下实现事件管理系统的模式：
- en: 'The **benefits** are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**如下：'
- en: '**Decouples systems**: Because publishers and subscribers only communicate
    through the Event Bus, it reduces direct references and decouples objects from
    each other'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解耦系统**：因为发布者和订阅者只通过事件总线进行通信，这减少了直接引用，并使对象彼此解耦'
- en: '**Broadcast channels**: Similar to a TV or radio broadcast system, you can
    use the Event Bus as a way to transmit messages through specific channels that
    listeners can subscribe to at their discretion'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**广播频道**：类似于电视或广播系统，您可以使用事件总线作为通过特定频道传输消息的方式，听众可以自行订阅'
- en: 'The **drawbacks** to be aware of are as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意的**缺点**如下：
- en: '**Memory overhead**: Under the hood of any event system, there''s a lot of
    low-level memory mechanisms that are being triggered to manage the communication
    between objects, so it might not be the best choice if you need to squeeze milliseconds
    of processing out of every frame'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存开销**：在任何一个事件系统的底层，都有大量的低级内存机制被触发以管理对象之间的通信，因此如果您需要从每一帧中挤出毫秒级的处理时间，这可能不是最佳选择'
- en: An example use case
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例用例
- en: Unlike other patterns in this book, the Event Bus is a functional and complete
    system in itself. This fact means that we can implement it without having to map
    it into a specific in-game system, and it will still become an instrumental component
    of our game's architecture.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中的其他模式不同，事件总线是一个功能完整且自成一体的系统。这一事实意味着我们可以在不将其映射到特定游戏系统的情况下实现它，并且它仍将成为我们游戏架构的一个关键组件。
- en: We could almost view the Event Bus as a global service that offers a way for
    all our components to message each other on specific channels. So, in the *Code
    example* section, we are going to implement the Event Bus in its native form,
    and make sure that it's globally accessible as a service for all our components.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎可以将事件总线视为一个全局服务，它为所有我们的组件提供了一个在特定频道上相互发送消息的方法。因此，在*代码示例*部分，我们将以原生形式实现事件总线，并确保它作为一项服务对所有我们的组件都是全局可访问的。
- en: Before starting the *Code example* section, I recommend reviewing [Chapter 6](b8d60568-5961-4e57-b722-36028db5d1a9.xhtml),
    *Singleton*, because we are going to use it as a base for our Event Bus class.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始*代码示例*部分之前，我建议回顾[第6章](b8d60568-5961-4e57-b722-36028db5d1a9.xhtml)，*单例*，因为我们打算将其用作事件总线类的基础。
- en: Code example
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: As mentioned in the *An example use case* section, we are going to implement
    the Event Bus as a service that all our components will be able to use when they
    need to broadcast events to other objects.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如*示例用例*部分所述，我们将实现事件总线作为一个服务，所有我们的组件在需要向其他对象广播事件时都可以使用。
- en: 'So, let''s start by implementing the core of the system by writing our Event
    Bus class:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先通过编写事件总线类来实现系统的核心：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As we can see, we are making our class into a Singleton; this will permit our
    `EventBus` instance to be globally accessible. But the most critical element that
    we need to notice is that we are using two new specific Unity API features: `UnityEvent`
    and `UnityAction`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们正在将我们的类变成一个单例（Singleton），这将允许我们的`EventBus`实例全局可访问。但我们需要注意的最关键元素是，我们正在使用两个新的特定Unity
    API功能：`UnityEvent`和`UnityAction`。
- en: '`UnityEvent` and `UnityAction` are API wrappers over the .NET native delegate
    type. They behave almost exactly like regular delegates under the hood, but they
    offer extra features that are custom to Unity, such as the following, for example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnityEvent`和`UnityAction`是.NET原生委托类型的API包装器。在底层，它们的行为几乎与常规委托完全相同，但它们提供了Unity特有的额外功能，例如以下内容：'
- en: Inspector access
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查器访问
- en: Persistent callbacks
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久回调
- en: We are using them in our example for reasons of simplicity while making sure
    we exploit Unity API's features to the fullest.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在示例中使用它们是为了简化，同时确保我们最大限度地利用Unity API的功能。
- en: For more detailed information on the specific features that `UnityEvent` offers,
    please refer the official API documentation in the *Further reading* section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`UnityEvent`提供的特定功能的更详细信息，请参阅*进一步阅读*部分的官方API文档。
- en: 'If we break down the class even further, we can see that four core functions
    make the Event Hub function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将类进一步分解，我们可以看到四个核心函数使事件中心（Event Hub）功能得以实现：
- en: '`Init()`: This initializes a dictionary that will hold in memory events to
    which `Subscribers` register'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Init()`: 这个函数初始化一个字典，该字典将存储内存中的事件，这些事件是`Subscribers`注册的。'
- en: '`StartListening()`: This is a function that `Listeners` uses to register themselves
    to listen to a specific event'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StartListening()`: 这是一个`Listeners`使用的函数，用于将自己注册为监听特定事件。'
- en: '`StopListening()`: This function permits `Listeners` to stop listening to a
    specific event'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StopListening()`: 这个函数允许`Listeners`停止监听特定事件。'
- en: '`TriggerEvent()`: This function will trigger an event and broadcast it to all
    its `Listeners`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TriggerEvent()`: 这个函数将触发一个事件并将其广播给所有监听者。'
- en: In theory, our work is done—with one class, we were able to implement an Event
    Bus that's globally accessible and ready to manage the communication of events
    between objects. So now, the only thing to do is to write ourselves an example
    of a Publisher object, along with a couple of Subscribers to test our new Event
    Bus service.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，我们的工作已经完成——通过一个类，我们能够实现一个全局可访问的事件总线（Event Bus），它可以管理对象之间的事件通信。因此，现在我们唯一要做的就是编写一个发布者（Publisher）对象的示例，以及几个订阅者（Subscribers）来测试我们新的事件总线服务。
- en: 'Let''s start with the Publisher, as without one, our `Listeners` will have
    nothing to listen to except silence. We are going to implement a straightforward
    Publisher that triggers a broadcast of specific events depending on user input:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从发布者开始，因为没有发布者，我们的`Listeners`除了沉默之外将没有可以监听的内容。我们将实现一个简单的发布者，根据用户输入触发特定事件的广播：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our `EventPublisher` class is elementary—it asks the Event Hub to broadcast
    the `Launch` and `Shoot` events depending on user input. This implementation means
    that any `Listeners` that are listening for events named `Launch` or `Shoot` will
    be triggered.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`EventPublisher`类很简单——它要求事件中心根据用户输入广播`Launch`和`Shoot`事件。这种实现意味着任何监听名为`Launch`或`Shoot`事件的`Listeners`都将被触发。
- en: 'To validate this functionality, let''s implement two Listeners, each with different
    responsibilities:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这个功能，让我们实现两个监听者，每个监听者都有不同的职责：
- en: '`Rocket`: This class listens for a `Launch` command event, and when it receives
    it, it triggers a launch sequence:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rocket`：这个类监听`Launch`命令事件，当它接收到这个命令时，将触发发射序列：'
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`Cannon`: Similar to the `Rocket` class, `Cannon` listens for a `Shoot` command
    and then triggers the shooting mechanism at the reception of the message:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cannon`: 与`Rocket`类类似，`Cannon`监听`Shoot`命令，并在接收到消息时触发射击机制：'
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Listeners only need to register themselves as listeners of a specific event
    by calling the `StartListening()` function and specifying the name of the event
    they want to listen to, along with the callback function. The Event Bus will take
    responsibility for coordinating the broadcast of events to the right Listeners
    and trigger their respective callback function when required.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 监听者只需要通过调用`StartListening()`函数并指定他们想要监听的事件名称以及回调函数来注册自己为特定事件的监听者。事件总线将负责协调将事件广播给正确的监听者，并在需要时触发它们各自的回调函数。
- en: There's something else we need to address. Notice that we are checking if the
    application is quitting with `OnApplicationQuit()` and validating the Boolean
    value of `m_IsQuitting` for `false` before calling the `EventBus.StopListening()`
    function. This approach is to avoid calling objects that might not be in memory
    anymore once the application is quitting.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要解决其他问题。请注意，我们在调用`EventBus.StopListening()`函数之前，使用`OnApplicationQuit()`检查应用程序是否正在退出，并验证`m_IsQuitting`的布尔值为`false`。这种方法是为了避免在应用程序退出后调用可能不再存在于内存中的对象。
- en: In conclusion, the Event Bus almost performs a similar function to a motherboard
    bus in the sense that it's acting like a system of communication between separate
    components. But even a simple Event Bus, like the one we just implemented, can
    be extended into a more complex system, such as an Event Queue or a multi-channel
    Messaging System, if need be.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，事件总线（Event Bus）在某种程度上几乎执行着与主板总线相似的功能，因为它在充当着不同组件之间的通信系统。但即使是像我们刚刚实现的这样一个简单的事件总线，如果需要的话，也可以扩展成一个更复杂的系统，比如事件队列（Event
    Queue）或多通道消息系统（multi-channel Messaging System）。
- en: Summary
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed and implemented the Event Bus, a pattern with a
    focus on decoupling the relationship between the objects that broadcast events
    and those that listen to them. By exploiting new native Unity API features such
    as `UnityEvents`, we were able to implement this pattern with the minimum amount
    of code quickly.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾并实现了事件总线（Event Bus），这是一种关注解耦广播事件的对象和监听这些事件的对象之间关系的模式。通过利用新的原生Unity
    API功能，如`UnityEvents`，我们能够以最少的代码量快速实现这一模式。
- en: In the next chapter, we will be reviewing the Service Locator, another pattern
    that focuses on decoupling complex relationships between dependencies, but this
    time by offering a way for objects to locate services.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回顾服务定位器（Service Locator），这是另一种关注解耦依赖项之间复杂关系的模式，但这次是通过提供一种对象定位服务的方法来实现的。
- en: I encourage any Unity programmer to take the time to read the engine's entire
    API documentation, currently available on Unity's official website, and to memorize
    as much of it as you can. This exercise will make you more aware of the features
    it offers, and may even make you a faster coder. The detailed knowledge of this
    API will also impress your colleagues or potential future interviewers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励任何Unity程序员花时间阅读整个引擎的API文档，目前这些文档可在Unity的官方网站上找到，并尽可能多地记住其中的内容。这项练习将使你更加了解它提供的功能，甚至可能使你成为更快的程序员。对这一API的深入了解也会给你的同事或潜在的未来的面试官留下深刻印象。
- en: Exercise
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: As indicated at the beginning of this chapter, we decided to focus on the Event
    Bus pattern, and not its cousin, the Event Queue. But a bus mechanism can be converted
    to a queue. So, as a practical exercise, I would recommend to converting the Event
    Bus example we just completed, and instead of just having it forwarding triggered
    events to subscribers, it should hold them in a queue so they can be handled sequentially.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章开头所述，我们决定专注于事件总线模式，而不是它的近亲事件队列（Event Queue）。但是，总线机制可以被转换成队列。因此，作为一个实际练习，我建议将我们刚刚完成的事件总线示例进行转换，而不仅仅是将触发的事件转发给订阅者，它应该将它们保存在队列中以便按顺序处理。
- en: You can refer to the material indicated in the *Further reading* section of
    this chapter for inspiration.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考本章“**进一步阅读**”部分中指出的材料以获取灵感。
- en: Further reading
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Unity - Manual: UnityEvents:*[https://docs.unity3d.com/Manual/UnityEvents.html](https://docs.unity3d.com/Manual/UnityEvents.html)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Unity - 手册: UnityEvents:*[https://docs.unity3d.com/Manual/UnityEvents.html](https://docs.unity3d.com/Manual/UnityEvents.html)'
- en: '*Unity - Scripting API Documentation:*'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Unity - 脚本API文档:*'
- en: '**[https://docs.unity3d.com/ScriptReference/](https://docs.unity3d.com/ScriptReference/)**'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**[https://docs.unity3d.com/ScriptReference/](https://docs.unity3d.com/ScriptReference/**) '
- en: '*Game Programming Patterns* by *Robert Nystrom*:[http://gameprogrammingpatterns.com](http://gameprogrammingpatterns.com/)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由**罗伯特·尼斯特罗姆**（Robert Nystrom）所著的《**游戏编程模式**》:[http://gameprogrammingpatterns.com](http://gameprogrammingpatterns.com/)
