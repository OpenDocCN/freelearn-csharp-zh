<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Coding for the Cloud</h1>
                </header>
            
            <article>
                
<p>The previous chapters explored patterns, from lower-level concepts such as the Singleton and Factory patterns, to patterns for specific technologies such as databases and web applications. These patterns are essential for ensuring the good design of a solution to ensure maintainability and efficient implementation. These patterns provide a solid foundation that allows applications to be enhanced and modified as requirements change and new functionality is added.</p>
<p>This chapter takes a higher-level view of a solution to address concerns involving designing implementing solutions that are reliable, scalable, and secure. The patterns in this chapter often involve environments that contain multiple applications, a repository, and a range of possible infrastructure configurations.</p>
<p>The software industry is continually evolving and with the change comes new opportunity as well as new challenges. In this chapter, we will look at different software patterns for the cloud. Many of these patterns are not new, and existed in on-premises environments. As cloud-first solutions are becoming the norm, these patterns are even more commonplace due to the ease of implementing solutions that do not rely on on-premises infrastructure.</p>
<div class="packt_infobox">Cloud-first or cloud-native solutions have been designed to target cloud computing resources, while hybrid solutions have been designed to use both cloud computing resources as well as resources from a private data center. </div>
<p>This chapter defines five key concerns when building solutions in the cloud:</p>
<ul>
<li>Scalability</li>
<li>Availability</li>
<li>Security</li>
<li>Application design</li>
<li>DevOps</li>
</ul>
<p>We will discuss the key concerns and why they are significant to building cloud solutions. As the concerns are discussed, different patterns will be described that can be applied to address these concerns.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>This chapter does not require any special technical requirements or source code as it is primarily theoretical. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Key considerations when building solutions in the cloud</h1>
                </header>
            
            <article>
                
<p>Making the decision to move to the cloud comes with its own set of problems and challenges. In this section, we will cover five key areas of consideration for building cloud-based solutions. While these are not unique to the cloud, they require <span>special attention when switching to</span> the cloud due to the wide range of technologies and solutions that are <span>available.</span></p>
<p>The five primary considerations are as follows:</p>
<ul>
<li><strong>Scalability</strong>: This allows for accommodation of increased load or traffic for a growing business.</li>
<li><strong>Resilience/availability</strong>: This ensures the handling of failures in a system gracefully with as little impact on the user as possible. </li>
<li><strong>Security</strong>: This ensures that private and proprietary data stays that way and is safe from hacks and attacks.</li>
<li><strong>Application design</strong>: This refers to the design of applications with special consideration for cloud-based solutions.</li>
<li><strong>DevOps</strong>: This is a collection of tools and practices that supports the development and running of cloud-based solutions.</li>
</ul>
<p>Depending on your business requirements, you may need to look for solutions for some or all of these considerations. It is also in your business's best interest to adopt providers with solutions to problems that you don't anticipate but would make for good contingency planning.</p>
<p>In the following sections, we will discuss these considerations <span>in further detail along with </span>the available solution patterns for them.</p>
<div class="packt_infobox">These patterns range from a type of technology to architectural to business processes and a single pattern could address more than one concern.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scalability</h1>
                </header>
            
            <article>
                
<p><span>Scalability refers to the ability to allocate and manage resources used by an application in order for the application to maintain an acceptable level of quality under a given workload. Most cloud offerings provide mechanisms for increasing the quality and quantity of resources used by an application. For example, the Azure App Service allows scaling of both the size of the App Service and the number of instances of the App Service.</span></p>
<p>Scalability can be viewed as demand on a limited number of resources. A resource could be disk space, RAM, bandwidth, or another aspect of software that can be quantified. The demand can range from the number of users, concurrent connections, or another demand that would produce a constraint on a resource. As the demand increases, a strain is placed on the application in order to provide the resource. When the strain affects the performance of the application, this is referred to as a resource bottleneck.</p>
<p>For example, a measure might be the number of users that can access an application before the performance of the application begins to deteriorate. The performance could be set as an average latency on requests being less than 2 seconds. As the number of users increases, the load on the system could then be viewed, and specific resource bottlenecks affecting the performance could be identified. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Workload</h1>
                </header>
            
            <article>
                
<p>In order to determine how to effectively address scaling issues, it is important to understand the workload that the system will be under. There are four main types of workload: static, periodic, once-in-a-lifetime and unpredictable.</p>
<p>A static workload represents a constant level of activity on a system. Because the workload does not fluctuate, this type of system does not require a very elastic infrastructure.</p>
<p>Systems that have a predictable change in workload have a periodic workload. An example would be a system that experiences a surge of activity around the weekends or around the months when income tax is due. These systems can be scaled up to maintain a desired level of quality when the load increases and scaled down to save cost when the load decreases.</p>
<p>Once-in-a-lifetime workloads indicate systems designed around a specific event. These systems are provisioned to handle the workload around the event and deprovisioned once they are no longer needed.</p>
<p>Unpredictable workloads often benefit from the auto-scale functionality mentioned earlier. These systems have large fluctuations in activity that are either not understood by the business yet or are influenced by other factors. </p>
<p>Understanding and designing a cloud-based application for its type of workload is essential for both maintaining a high level of performance as well as lowering costs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Solution patterns</h1>
                </header>
            
            <article>
                
<p><span>We have available three design patterns and one architecture pattern to choose from to enable us to add scalability to our systems: </span></p>
<ul>
<li>Vertical scaling</li>
<li>Horizontal scaling</li>
<li>Auto-scaling</li>
<li>Microservices</li>
</ul>
<p>Let's review each in more detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Vertical scaling</h1>
                </header>
            
            <article>
                
<p>Though it is possible to add physical RAM or an additional disk drive to an on-premises server, most cloud providers support the ability to easily increase or decrease the computing power of a system. This is often with little or no downtime as the system scales. This type of scaling is called vertical scaling and refers to when a resource such as the type of CPU, size and quality of RAM, or size and quality of the disk is altered.</p>
<div class="packt_infobox">Vertical scaling<span> </span><span>is often referred to as <em>scaling up</em> while horizontal scaling is often referred to as <em>scaling out</em>. In this context, the term <em>up</em> refers to the size of the resource while <em>out</em> refers to the number of instances.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Horizontal scaling</h1>
                </header>
            
            <article>
                
<p>Horizontal scaling differs from vertical scaling because, instead of altering the size of a system, horizontal scaling changes the number of systems involved. For example, a web application might run on a single server having 4 GB RAM and 2 CPUs. If the server was increased in size to 8 GB RAM and 4 CPUs, then this would be vertical scaling. However, if two more servers were added with the same configuration of 4 GB RAM and 2 CPUs, then this would be horizontal scaling.</p>
<p>Horizontal scaling can be achieved by using some form of load balancing that redirects the requests across a collection of systems as illustrated in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1248ceaf-6ac8-4e3c-b613-ad243ecee78e.png" style=""/></div>
<p>Horizontal scaling is usually preferred in cloud solutions over vertical scaling. This is because, in general, it is more cost effective to use several smaller virtual machines to a single large server to provide the same measure of performance.</p>
<p>For horizontal scaling to be most effective, it does require a system design that supports this type of scaling. For example, web applications designed without sticky sessions and/or state stored on the server work better for horizontal scaling. This is because sticky sessions cause a user's requests to be routed to the same virtual machine for processing and, over time, the balance of the routing across the virtual machines could become uneven and therefore not as efficient as possible.</p>
<div class="packt_infobox"><span class="packt_screen">Stateful<span> </span><span>applications</span></span><br/>
A <em>stateful<span> </span></em>application maintains information about an active session on the server or repository.<br/>
<span class="packt_screen"><br/>
Stateless<span> </span><span>applications</span></span><br/>
<em>Stateless</em><span> </span>applications are designed to not require information about an active session to be stored on the server or repository. This allows for subsequent requests in a single session to be sent to any server to be handled and not just to the same server for the entire session.</div>
<p><span>Web applications designed that are stateful require sessions or information to be maintained in a shared repository. Stateless web applications support a more resilient pattern as any server in a web garden or web farm. This allows for a single node in the web application to fail without losing session information. </span></p>
<div class="packt_infobox">A web <em>garden</em> is a pattern where multiple copies of the same web application are hosted on the same server, whereas a web <em>farm</em> is a pattern where multiple copies of the same web application are hosted on different servers. In both patterns, routing is used to expose the multiple copies as if they were a single application.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Auto-scaling</h1>
                </header>
            
            <article>
                
<p>An advantage of using a cloud provider over on-premises solutions is the built-in support for auto-scaling. As an added benefit to horizontal scaling, the ability to auto-scale an application is often a configurable feature of a cloud service. For example, an Azure App Service provides the ability to set up auto-scale profiles that allow an application to react to conditions. For example, the following screenshot shows an auto-scale profile:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9d5b1f53-4831-473c-af9e-263e3667205e.png" style=""/></div>
<p>The profile designed for weekdays will increase or decrease the number of app service instances depending on the load on the servers. The load is being measured in CPU percentage. If the CPU percentage is averages above 60%, then the number of instances is increased up to a maximum of 10. Similarly, if the CPU percentage falls below 30%, the number of instances is reduced to a minimum of 2.</p>
<div class="packt_infobox">An elastic infrastructure allows for resources to be scaled vertically or horizontally without requiring a re-deploy or downtime.<span> </span>The term is actually more of a degree of elasticity instead of referring to whether a system is<span> </span><em>elastic</em><span> </span>or<span> </span><em>not elastic</em>. For example, an elastic service could allow for scaling both vertically and horizontally without requiring a restart of the service instances. A less elastic service would allow for scaling horizontally without a restart but would require a restart of the service when the size of the server is altered.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Microservices</h1>
                </header>
            
            <article>
                
<p>There are different interpretations of what microservices means and how it relates to <strong>service-oriented architecture</strong> (<strong>SOA</strong>). In this section, we are going to view microservices as a refinement of SOA and not a new architectural pattern. The microservice architecture extends SOA by adding some additional key principles which require that services must:</p>
<ul>
<li>be small - hence the term <em>micro</em></li>
<li>be built around a business capability</li>
<li>be loosely coupled with other services</li>
<li>be independently maintainable</li>
<li>have an isolated state</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Small</h1>
                </header>
            
            <article>
                
<p>Microservices takes the services in SOA farther by reducing them to their smallest possible size. This fits well with some other patterns that we have seen, such as <strong>Keep It Simple Stupid</strong> (<strong>KISS</strong>) and <strong>You Aren't Gonna Need It</strong> (<strong>YAGNI</strong>) from <a href="e8666bee-88b0-4d5d-a62f-ee8aa27f3e29.xhtml"/><a href="e8666bee-88b0-4d5d-a62f-ee8aa27f3e29.xhtml">Chapter 2</a>, <em>Modern Software Design Patterns and Principles</em>. The microservice should only fulfill its requirements and nothing more.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Business capability</h1>
                </header>
            
            <article>
                
<p>By building a service around a business capability, we align our implementation in such a way that, as the business requirements change, our services will be changed in a similar manner. Because of this, it is less likely that change in one area of the business will impact other areas.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loosely coupled</h1>
                </header>
            
            <article>
                
<p>A microservice should interact with other services across a service boundary using a technology-agnostic protocol such as HTTP. This allows for the microservices to be integrated more easily and, more importantly, not require the rebuild of a microservice when another service changes. This does require a known <em>service contract</em> to exist.</p>
<div class="packt_tip"><span class="packt_screen">Service contract</span><br/>
A <em>service contract</em> is the definition of a service that is distributed to other development teams. <strong>Web Services Description Language</strong> (<strong>WSDL</strong>) is a widely known XML-based language for describing services, but other languages, such as Swagger, are also very popular.</div>
<p><span>When implementing a microservice, it is important to have a strategy for how the change will be managed. By having a versioned service contract, it is then possible to communicate the change clearly to a client of the service.</span></p>
<p>For example, the strategy of a microservice used to store an inventory of books could have the following strategy:</p>
<ul>
<li>Each service will be versioned and include a Swagger definition.</li>
<li>Each service will start with version 1.</li>
<li>When a change is made that requires the service contract to change, the version will be increased by 1.</li>
<li>The service will maintain up to three versions.</li>
<li>Changes to a service must ensure that all current versions behave suitably.</li>
</ul>
<p>The preceding basic strategy does have interesting implications. First of all, the team maintaining a service must ensure that changes do not break existing services. This ensures a new deployment will not break other services while allowing for new functionality to be deployed. The contract does allow for up to three services to be active at a time, thus allowing for a dependable service to update independently.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Independently maintainable</h1>
                </header>
            
            <article>
                
<p>This is one of the most distinguishing features of microservices. Having a microservice able to be maintained independent of other microservices empowers a business to be able to manage the service without impacting other services. By managing a service, we are including both the development as well as the deployment of a service. With this principle, microservices can be updated and deployed with a reduced chance of impacting other services, as well as at a different rate of change from other services.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Isolated state</h1>
                </header>
            
            <article>
                
<p>Isolated state includes both data and other resources that could be shared including databases and files. This is also a distinguishing feature of microservice architecture. By having an independent state, we are reducing the chance that a change in the data model to support one service will impact other services.</p>
<p>The following diagram illustrates a more traditional SOA approach, where a single database is used by multiple services:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d160a26b-1edb-470c-91ef-e87a93b40e64.png" style=""/></div>
<p>By requiring a microservice to have an isolated state, we would then require a database per service as shown in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6b3b7c88-5528-4c3a-8215-2f707c7365f4.png" style=""/></div>
<p>This has an advantage in that each service can choose the technology that best fits the requirements of the services. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advantages</h1>
                </header>
            
            <article>
                
<p>The microservice architecture does represent a shift from traditional service design and it does fit well in a cloud-based solution. The advantages of microservices and why they are gaining in popularity might not be immediately obvious. We have touched on how the design of microservices provides advantages for handling change gracefully. From a technical point of view, microservices can be scaled independently both at the service level and at the database.</p>
<p>What might not be clear is the benefit a microservice architecture has to a business. By having small independent services, the business can then look at different ways to maintain and develop microservices. The business now has options to host the services in different ways, including different cloud providers, as best fits the independent services. Likewise, the isolated nature of the services allows for a greater degree of agility in developing the services. As change happens, resources (that is, development team members) can be allocated to different services as required, and, as the scope of service is smaller, the amount of business knowledge required is also reduced. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resiliency/availability</h1>
                </header>
            
            <article>
                
<p>Resiliency is the ability of an application to handle failure gracefully while availability is a measure of the amount of time the application is working. An application may have a collection of resources and still remain available if one of the resources becomes inoperable or unavailable. </p>
<div class="packt_infobox">If an application is designed to handle one or more resources failing without the entire system becoming inoperable, this is referred to as <strong>graceful degradation</strong>.</div>
<p>Patterns apply to both isolate the elements of an application as well as handle the interaction between the elements so that when a failure occurs, the impact is limited. Many of the resiliency-related patterns focus on the messaging between the components within the application or to other applications. The Bulkhead pattern, for example, isolates the traffic into pools so that when one pool becomes overwhelmed or fails, the other pools are not adversely affected. Other patterns apply specific techniques to handle messaging, such as retry policies or compensating transactions.</p>
<p>Availability is an important factor to many cloud-based applications and, typically, availability is measured against a <strong>service level agreement</strong> (<strong>SLA</strong>). In most cases, the SLA stipulates the percentage of time the application must remain operable. Patterns involve both allowing for redundancy of components as well as using techniques to limit the effect of an increase in activity. For example, the Queue-Based Load Leveling pattern uses a queue to limit the effect a spike in activity might have on an application by acting as a buffer between the caller, or client, and the application or service.</p>
<div class="packt_infobox">Resiliency and availability are identified here as related cloud solution factors as often a resilient application allows for a strict SLA on availability to be achieved.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Solution pattern</h1>
                </header>
            
            <article>
                
<p><span>To ensure we have a system that has resilience and availability, our best bet is to look for a provider with a specific architecture. Enter <strong>event-driven architecture</strong> (<strong>EDA</strong>).</span></p>
<p><span>EDA is an architectural pattern that uses</span><span> </span><em>events</em><span> to drive the behavior and activity of a system. The solution patterns available under it will help us achieve the intended resolutions. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">EDA</h1>
                </header>
            
            <article>
                
<p>EDA promotes the concept of having loosely connected producers and consumers where the producers do not have direct knowledge of the consumers. An event in this context is any change ranging from a user logging onto a system, to an order being placed, to a process failing to complete successfully. EDA fits well in distributed systems and allows for highly scalable solutions.</p>
<p>There are many related patterns and approaches to EDA and the following patterns are presented in this section as being directly relevant to EDA:</p>
<ul>
<li>Queue-Based Load Leveling</li>
<li>Publisher Subscriber</li>
<li>Priority Queue</li>
<li>Compensating Transaction</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Queue-Based Load Leveling</h1>
                </header>
            
            <article>
                
<p class="CDPAlignLeft CDPAlign">Queue-Based Load Leveling is an effective way of minimizing the impact of occurrences of high demand on availability. By introducing a queue between a client and service, we are able to throttle or restrict the number of requests that are being handled by the service at a time. This allows for smoother user experience. Take the following diagram as an example:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/80878957-90a5-47bd-a052-acb18a6d198c.png" style=""/></div>
<p>The preceding diagram shows a client submitting a request to a queue to be processed and the result saved to a table. The queue acts to prevent the function from being overwhelmed by a sudden spike in activity.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Publisher Subscriber</h1>
                </header>
            
            <article>
                
<p>The Publisher Subscriber pattern states that there are event publishers and event consumers. Essentially, this is the heart of EDA, as the publishers are decoupled from the consumers and are not concerned about the delivery of events to the consumers, but only with publishing events. The event will contain information that will be used to route the event to interested consumers. A consumer would then register or subscribe to being interested in specific events: </p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/93444369-0f06-4847-b5ec-f974300ac2cd.png" style=""/></div>
<p>The preceding diagram illustrates a Customer Service and an Order Service. The Customer Service acts as a publisher and submits an event when a customer is added. The Order Service has subscribed to new customer events. When a new customer event is received, the Order Service inserts the customer information into its local store. </p>
<p>By introducing the Publisher Subscriber pattern into the architecture, the Order Service is then decoupled from the Customer Service. An advantage of this is it provides a more flexible architecture for change. For example, a new service could be introduced to add new customers to the solutions that do not require being added to the same repository used by the Customer Service. Also, more than one service could subscribe to the new customer event. Adding a welcome email could more easily be added as a new subscriber, rather than having to build this functionality into a single monolithic solution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Priority Queue</h1>
                </header>
            
            <article>
                
<p>Another related pattern is Priority Queue, which provides a mechanism for treating similar events differently. Using the new customer example from the previous section, it would be possible to have two subscribers for a new customer event. One subscriber would be interested in the majority of the new customers, while one subscriber would identify a subset of the customers that should be handled differently. For example, new subscribers from rural areas might receive an email with additional information about specialized shipping providers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Compensating transaction</h1>
                </header>
            
            <article>
                
<p>With distributed systems, it is not always practical or desirable to issue a command as a transaction. A transaction in this context refers to a lower-level programming construct that manages one or more commands as a single action that either all succeeds or all fails. In some situations, a distributed transaction is not supported, or the overhead of using a distributed transaction outweighs the benefits. The Compensating Transaction pattern was developed to handle this situation. Let's use the following as an example based on a BizTalk orchestration:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e76b66c8-dbb6-4406-abf7-ff38d425fd48.png" style=""/></div>
<p>The diagram shows two steps in a process: creating order in an Order Service and debiting funds from a Customer Service. The diagram shows how, first the order is created and then the funds are removed. If the debit of funds does not succeed then the order is removed from the Order Service. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Security</h1>
                </header>
            
            <article>
                
<p>Security ensures an application does not disclose information incorrectly or provide functionality outside of intended use. Security includes both malicious and accidental actions. With cloud applications and increasing use of a wide range of identity providers, restricting access to only approved users is often challenging.</p>
<p>End-user authentication and authorization requires design and planning as fewer applications run in isolation, and it is common for multiple identity providers, such as Facebook, Google, and Microsoft, to be used. In some instances, patterns are used to provide access directly to resources for improved performance and scalability. Furthermore, other patterns are concerned with creating a virtual wall between clients and applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Solution patterns</h1>
                </header>
            
            <article>
                
<p><span>As the industry has become more interconnected, the pattern of using an external party to authenticate users has become more common. The Federated Security pattern has been chosen for discussion here as it is one of the best ways to ensure security in our systems, and most <strong>software-as-a-service (SaaS)</strong> platforms offer this feature</span><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Federated security</h1>
                </header>
            
            <article>
                
<p>Federated security delegates the authentication of user or service (consumer) to an external party known as an <strong>identity provider</strong> (<strong>IdP</strong>). An application using federated security will trust the IdP to properly authenticate the consumer and provide details about the consumer or claims accurately. This information about the consumer is presented as a token. A common scenario for this would be a web application using a social IdP such as Google, Facebook, or Microsoft. </p>
<p>Federated security can handle a variety of scenarios, from interactive sessions to authentication backend services or non-interactive sessions. Another common scenario is the ability to provide a single authentication experience or <strong>single sign-on</strong> (<strong>SSO</strong>) across a suite of separately hosted applications. This scenario allows for a single token to be acquired from a <strong>security token service</strong> (<strong>STS</strong>) and the same token used to present to the multiple applications without requiring the login procedure to be repeated:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8b8e558d-26c7-47d9-b3b8-1bdc16566e6f.png" style=""/></div>
<p>Federated security has two main purposes. First, it simplifies the management of identities by having a single identity store. This allows for identities to be managed in a central and unified manner, making it easier to perform management tasks such as providing the login experience, forgotten password management, as well as revoking passwords in a consistent manner. Secondly, it provides a better user experience by <span>offering</span> users a similar experience across multiple applications as well as requiring only a single form of authentication, instead of needing to remember multiple passwords.</p>
<p>There are several standards for federated security and two widely used ones are<span> </span><span class="ILfuVd"><strong>Security Assertion Markup Language</strong> (<strong>SAML</strong>) and <strong>OpenId Connect</strong> (<strong>OIDC</strong>). SAML is older than OIDC and allows for the exchange of messages using an XML SAML format. OIDC is built upon OAuth 2.0 and commonly uses <strong>JSON Web Token</strong> (<strong>JWT</strong>) for describing the security token. Both formats support federated security, SSO, and many public IdPs such as Facebook, Google, and Microsoft support both standards.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application design</h1>
                </header>
            
            <article>
                
<p>The design of an application can vary significantly and be influenced by many factors. These factors are not only technical but are influenced by the teams involved in building, managing, and maintaining the applications. Some patterns, for example, work best with small dedicated teams as opposed to a larger number of geographically dispersed teams. Other design-related patterns handle different types of workload better and are used in specific scenarios. Other patterns have been designed around the frequency of change and how to limit the disruption of changes to an application once it has been released to users. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Solution patterns</h1>
                </header>
            
            <article>
                
<p><span>As almost all on-premises patterns are applicable to cloud-based solutions, the scope of patterns that could be covered is staggering. The Cache and CQRS patterns have been chosen because the former is a very common pattern employed by most web applications and the latter shifts how designers think of building solutions and lends itself well to other architectural patterns such as SOA and microservices.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cache</h1>
                </header>
            
            <article>
                
<p>Storing information retrieved from slower forms of storage into faster forms of storage, or caching, has been a technique that has been used in programming for decades and can be seen in software <span>such as a browser cache and hardware such as RAM</span>. In this chapter, we will look at three examples: Cache-aside, Write-through Cache, and Static Content Hosting.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cache-aside</h1>
                </header>
            
            <article>
                
<p><span>The Cache-aside pattern can be used to improve performance by loading frequently referenced data in a local or faster form of storage. With this pattern, it is the responsibility of the application to maintain the state of the cache. This is illustrated in the following diagram:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0fd306bb-6874-4916-83c7-54ffcdd30e3f.png" style=""/></div>
<p>First, the application requests information from the cache. If the information is missing, then it is requested from the data store. The application then updates the cache with the information. Once the information is stored, it will then be retrieved from the cache and used without referencing the slower data store. With this pattern, it is the application's responsibility to maintain the cache, both when there is a cache miss, and when the data is updated. </p>
<div class="packt_tip">The term<span> </span><em>cache miss</em> refers to when data is not found in the cache. In other words, it is missing from the cache.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Write-through cache</h1>
                </header>
            
            <article>
                
<p>The Write-through Cache pattern can also be used to improve performance in a similar manner as the Cache-aside pattern. Its approach differs by moving the management of the cache's content from the application to the cache itself, as shown in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2b8f50a0-1ebe-44cd-943e-2011381bb41e.png" style=""/></div>
<p><span>A request is made for a piece of information in the cache. If the data is not already loaded, then the information is retrieved from the data store, placed in the cache, and then returned. If the data was already held, then it is immediately returned. This pattern supports updating the cache by passing the write of the information through the cache service. The cache service then updates the information held, </span><span>both</span><span> in the cache and in the data store.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Static Content Hosting</h1>
                </header>
            
            <article>
                
<p>The Static Content Hosting pattern moves static content such as media images, movies, and other non-dynamic files to a system dedicated for fast retrieval. A specialized service for this is called a <strong>content delivery network</strong> (<strong>CDN</strong>), which manages to distribute content across multiple data centers and directs requests to the data center closest to the caller, as shown in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d72bd427-be1a-4e5b-b152-8c8bc6e0ec2d.png" style=""/></div>
<p>Static Content Hosting is a common pattern for web applications where a dynamic page is requested from the web application and the page contains a collection of static content, such as JavaScript and images, which the browser then retrieves directly from the CDN. This is an effective way to reduce the traffic on the web application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Command and Query Responsibility Segregation</h1>
                </header>
            
            <article>
                
<p><span><strong>Command and Query Responsibility Segregation</strong> (<strong>CQRS</strong>) is a great software pattern to discuss in more detail as it is conceptually simple and relatively easy to implement but has dramatic implications to both the application and the developers involved. The pattern clearly separates the commands that affect the state of the application from queries that only retrieve data. Simply put, commands such as updates, adds, and deletes are provided in different services from the queries that do not change any data. </span></p>
<p>You might say <em>CQRS again!</em> and we recognize that we have used an example of CQRS in OOP and database design. The same principle does apply to many areas of software development. <span>We are presenting CQRS in this section as a pattern for service design as it leads to some interesting benefits and fits well in modern patterns such as microservices and reactive application design.</span></p>
<div class="packt_infobox">CQRS is based on the object-oriented design presented in the late 1980s by Bertrand Meyer's book, <em>Object-Oriented Software Construction</em>: <a href="http://se.ethz.ch/~meyer/publications/">http://se.ethz.ch/~meyer/publications/</a>.</div>
<p>If we revisit <a href="fd71001a-4673-4391-a10b-2490e07f135e.xhtml">Chapter 5</a><span class="cdp-organizer-chapter-number">:</span><span> </span><span class="cdp-organizer-chapter-title"><span class="cdp-organize-title-label"><em>Implementing Design Patterns - .NET Core</em>, </span></span>we illustrated this pattern by splitting our inventory context into two interfaces: <kbd>IInventoryReadContext</kbd> and <kbd>IInventoryWriteContext</kbd>. As a reminder, here are the interfaces:</p>
<pre>public interface IInventoryContext : IInventoryReadContext, IInventoryWriteContext { }<br/><br/>public interface IInventoryReadContext<br/>{<br/>    Book[] GetBooks();<br/>}<br/><br/>public interface IInventoryWriteContext<br/>{<br/>    bool AddBook(string name);<br/>    bool UpdateQuantity(string name, int quantity);<br/>}</pre>
<p>As we can see, the <kbd>GetBooks</kbd> method is separated from the two methods, <kbd>AddBook</kbd> and <kbd>UpdateQuantity</kbd>, that modify the state of the inventory. This illustrated CQRS within the code solution.</p>
<p>The same approach can be applied at a service level. If we use a service for maintaining inventory as an example, we would break the service between a service for updating the inventory and another service for retrieving the inventory. This is illustrates in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/54d55117-1d9a-43ec-85f4-67b74384663e.png" style=""/></div>
<p>Let's explore CQRS first by looking at the challenges of when it is applied in cloud-based solutions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Challenges of CQRS</h1>
                </header>
            
            <article>
                
<p>There are significant challenges to using the CQRS pattern with services:</p>
<ul>
<li>Consistency</li>
<li>Adoption</li>
</ul>
<p>Staleness is a measure of how closely data reflects the committed version of the data. Data, in most circumstances, has the potential to change, so, as soon as a piece of data is read, there is a chance that the data could be updated, making the read data become inconsistent with the source data. This is a challenge with all distributed systems where it is not practical to guarantee the value shown to a user reflects the source value. When the data directly reflects what is stored, we can call the data consistent; when the data does not, it is viewed as inconsistent.</p>
<div class="packt_infobox">A common term used in distributed systems is <em>eventual consistency</em>. Eventual consistency is used to say a system will over time become consistent. In other words, it will eventually become consistent.</div>
<p>The other more subtle challenge is adoption. Implementing CQRS into an established development team can be met with resistance both from developers and designers who are unfamiliar with the pattern and may lack support from the business for deviating from current design patterns. </p>
<p>So what are the benefits?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why CQRS?</h1>
                </header>
            
            <article>
                
<p>The following are three compelling factors for using CQRS:</p>
<ul>
<li><strong>Collaboration</strong></li>
<li><strong>Model separation</strong></li>
<li><strong>Independent scalability</strong></li>
</ul>
<p>With separate services, we can then maintain, deploy, and scale these services independently. This increases the level of collaboration we can achieve between the development teams.</p>
<p>By having separate services, we can use a model that best fits our service. The command service might use simple SQL statements directly against a database, as that is the most familiar technology to the team responsible, while the team building the query service might use a framework for handling complex statements against the database. </p>
<p><span>Most solutions tend to have a higher level of reads than writes (or vice versa) so splitting the services along this criterion makes sense in many scenarios.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DevOps</h1>
                </header>
            
            <article>
                
<p>With cloud-based solutions, the data center is remotely hosted and you often do not have full control or access to all aspects of an application. In some cases, such as serverless services, the infrastructure is abstracted away. An application must still expose information about a running application that can be used to manage and monitor an application. Patterns used to manage and monitor are essential for the success of an application by providing both the ability to keep an application running healthily as well as providing strategic information to the business.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Solution patterns</h1>
                </header>
            
            <article>
                
<p><span>With the availability of commercial packages relating to monitoring and managing solutions, many businesses have gained better control and understanding of their distributed systems. Telemetry and continuous delivery/continuous integration have been chosen to cover in more detail as they have particular value in cloud-based solutions.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Telemetry</h1>
                </header>
            
            <article>
                
<p>As the software industry has evolved and distributed systems involve more services and applications, being able to have a collective and consistent view of a system has become a huge asset. Popularized by services such as New Relic and Microsoft Application Insights, <strong>application performance management</strong> (<strong>APM</strong>) systems use information recorded about applications and infrastructure, known as telemetry, to monitor, manage performance, and view the availability of a system. In cloud-based solutions, where it is often not possible or practical to gain direct access to the infrastructure of a system, an APM allows for telemetry to be sent to a central service, digested, and then presented to operations and the business, as shown in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3799f3e4-3f09-45ba-b16e-43093c14d35c.png"/></div>
<p>The preceding diagram is taken from Microsoft Application Insights and provides a high-level snapshot of a running web application. At a glance, operations can identify changes in the behavior of the system and react accordingly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Continuous integration/continuous deployment</h1>
                </header>
            
            <article>
                
<p><strong>Continuous integration/continuous deployment</strong> (<strong>CI/CD</strong>) is a modern development process designed to streamline the <strong>software delivery product life cycle</strong> (<strong>SDLC</strong>) by merging changes frequently and deploying those changes often. CI addresses the issues that arise in enterprise software development where multiple programmers are working on the same code base or when a single product is managed with multiple code branches.</p>
<p>Take a look at the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/242a34d7-263b-49fd-bcbd-c06e5fe5d85c.png" style=""/></div>
<p>In the preceding example, there are three target environments: Development, <strong>User Acceptance Testing</strong> (<strong>UAT</strong>), and Production. The Development environment is the initial environment where all the changes made to an application are tested together. The UAT environment is used by the <strong>Quality Assurance</strong> (<strong>QA</strong>) team to verify the system is working as intended before the changes are moved to a customer-facing environment, referred to in the diagram as Production. The code base has been broken into three matching branches: the trunk which all changes by the development team are merged into, UAT, which is used to deploy to the UAT environment, and the Production code base, which is used to deploy into the Production environment. </p>
<p>The CI pattern is applied by creating a new build when the code base changes. After a successful build, a suite of unit tests is run against the build to ensure existing functionality has not been broken. If a build is not successful, the development team investigates and either fixes the code base or the unit test so the build then passes. </p>
<p><span>Successful builds are then pushed to a target environment. The Trunk might be set to push a new build automatically once a day to the Integration environment, while the QA team has requested less disturbance in the environment, so a new build is only pushed once a week after office hours. Production might require a manual trigger to coordinate new releases as to announce the new features and bug fixes in a formal release.</span></p>
<div class="packt_infobox">There is confusion over the terms <em>continuous deployment</em> and <em>continuous delivery</em>. Many sources differentiate the two terms as to whether the process of deploying is automated or manual. In other words, continuous deployment requires automated continuous delivery. </div>
<p>The trigger to cause a merge between environments and therefore a build to be pushed to an environment, or released, might differ. In our illustration for the Development environment, we have a set of automated tests that are run against new builds automatically. If the tests are successful, then the merge is automatically performed from the Trunk to the UAT code base. The merge between UAT and Production code bases is <span>only</span><span> performed once the QA team has signed off or accepted the changes in the UAT environment.</span></p>
<p>Each enterprise will tailor the CI/CD process to fit their particular SDLC and business requirements. A public-facing website, for example, might require a rapid SDLC to stay competitive in the market, whereas an internal application might require a more conservative approach to limit the disruption caused by changing functionality without staff training.</p>
<p>Regardless, suites of tools have been developed to manage the CI/CD process within an organization. Azure DevOps, for example, helps to manage this process by allowing for a pipeline to be built to handle when builds are created and when they are released to environments, including both manual and automated triggers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Cloud development requires careful planning, maintenance, and monitoring, and patterns can help achieve highly scalable, reliable, and secure solutions. Many of the patterns discussed in this chapter are applicable to on-premises applications and are essential in cloud solutions. The design of a cloud-first application should consider many factors, including scalability, availability, maintenance, monitoring, and security.</p>
<p>A scalable application allows for fluctuations in system load while maintaining an acceptable level of performance. The load can be measured in the number of users, concurrent processes, amount of data, and other factors in software. The ability to scale a solution horizontally requires a particular type of application development and is a paradigm that is especially significant to cloud computing. Patterns such as Queue-Based Load Leveling are a great technique to ensure solutions remain responsive under an increased load.</p>
<p>Many of the patterns covered in this chapter are complementary. For example, an application following the Command and Query Responsibility Segregation might leverage federated security for providing a single sign-on experience and use an event-driven architecture to handle consistency across the different components of an application.</p>
<p>In cloud-based solutions, there is a near-endless collection of applicable patterns that address different challenges in distributed systems. The patterns presented in this chapter represent a selection chosen for their breadth, as well as how they complement one another. Please see the references to explore other patterns suitable in cloud-based solutions.</p>
<p><span>What a journey! We have covered patterns from software design patterns used in object-oriented programming and architectural patterns used in cloud-based solutions, to business patterns for more efficient teams and patterns for building successful applications. Though we tried to cover a wide range of patterns, there are bound to be ones that could have, and should have, been added.</span><br/></p>
<p>With that, thank you from Gaurav and Jeffrey and we hope you enjoyed and gained something from reading <em>Hands-On Design Patterns with C# and .NET Core</em>. Please let us know what you think and share with us your favorite patterns.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<p><span>The following questions will allow you to consolidate the information contained in this chapter:</span></p>
<ol>
<li>Most patterns have been developed recently and only apply to cloud-based applications. True or false<span>? </span></li>
<li>An ESB stands for what, and can be used in what type of architecture: EDA, SOA or monolithic?</li>
<li>Is Queue-Based Load Leveling primarily used for DevOps, scalability, or availability?</li>
<li>What are the benefits of CI/CD? Would it be more beneficial in a large number of globally dispersed teams or a single small team of collocated developers?</li>
<li>In a website following Static Content Hosting, does a browser retrieve images and static content directly through a CDN, or does the web application retrieve the information on behalf of the browser?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p><span>To learn more about the topics covered in this chapter, refer to the following books. These books will provide you with various in-depth and hands-on exercises on the topics that have been covered in this chapter:</span></p>
<ul>
<li><em>Azure Serverless Computing Cookbook,</em> by <span><em>Praveen Kumar Sreeram,</em> published by <em>Packt Publishing</em>: <a href="https://www.packtpub.com/in/virtualization-and-cloud/azure-serverless-computing-cookbook">https://www.packtpub.com/in/virtualization-and-cloud/azure-serverless-computing-cookbook</a></span></li>
<li><em>Microservices with Azure,</em> by <em>Namit Tanasseri</em> <em>and Rahul Rai</em>,<span> published by </span><em>Packt Publishing</em>: <a href="https://www.packtpub.com/in/virtualization-and-cloud/microservices-azure">https://www.packtpub.com/in/virtualization-and-cloud/microservices-azure</a></li>
<li><em>Hands-On Azure for Developers,</em> by <em>Kamil Mrzygłód,</em><span> published by </span><em>Packt Publishing</em>: <a href="https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers">https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers</a></li>
<li><em>Building Microservices with .NET Core 2.0 - Second Edition</em> by <em>Gaurav Aroraa</em>, published by <em>Packt Publishing</em>: <a href="https://www.packtpub.com/application-development/building-microservices-net-core-20-second-edition">https://www.packtpub.com/application-development/building-microservices-net-core-20-second-edition</a>.</li>
</ul>


            </article>

            
        </section>
    </body></html>