<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-186"><a id="_idTextAnchor196"/>12</h1>
<h1 id="_idParaDest-187"><a id="_idTextAnchor197"/>Localization with MVVM</h1>
<p>So, we’ve built this fantastic <em class="italic">Recipes!</em> app, and we’re quite pleased with its design and features. However, as it stands, the app is entirely in English. What about culinary enthusiasts from different parts of the world? The answer is localization, specifically focusing on translating all aspects of our app to make it accessible and user-friendly to a global audience.</p>
<p>In this chapter, we’ll tackle localization through the lens of MVVM. We’ll be looking at translating the hardcoded <code>copy</code> labels that are baked into the app, but also at effectively fetching language-specific data from the API. To accomplish this, we’ll delve into the following topics:</p>
<ul>
<li>Working with cultures, resource files, and localization</li>
<li>Looking at a localization solution for MVVM</li>
<li>Using a custom <code>Translate</code> markup extension</li>
<li>Fetching localized data from APIs</li>
</ul>
<p>As we dive into this chapter, remember that our journey through localization also showcases thoughtful app design with MVVM principles. By the end, not only will we have the tools and knowledge to extend the reach of our app to a diverse, global audience through the UI, but we’ll also see how the right design choices ensure that every layer of our app, down to the data we present, is coherent and organized.</p>
<h1 id="_idParaDest-188"><a id="_idTextAnchor198"/>Technical requirements</h1>
<p>As always, for hands-on experience and to keep pace with the content, head over to our GitHub repository at <a href="https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter12">https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter12</a>. Begin with the code in the <code>Start</code> folder, and, for a comprehensive view, you can always refer to the <code>Finish</code> folder, which houses the polished, end-of-chapter code.</p>
<h1 id="_idParaDest-189"><a id="_idTextAnchor199"/>Working with cultures, resource files, and localization</h1>
<p>Before we jump into the actual coding bits and look at how we can integrate localization in MVVM, let’s make <a id="_idIndexMarker806"/>sure we’re all on the same page about what we mean by <em class="italic">culture</em> in the .NET MAUI context. Culture, in this case, refers to the settings that determine the language to be used and the display format for items such as dates, times, currency, and so on.</p>
<p>Let’s start with how to retrieve the user’s culture in .NET MAUI.</p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor200"/>Getting the user’s culture</h2>
<p>The <code>CultureInfo</code> class is part of the <code>System.Globalization</code> namespace in .NET and <a id="_idIndexMarker807"/>serves as a central point for obtaining culture-specific information, such as language, country, date formats, number formats, and more. It also contains <code>CurrentCulture</code> and <code>CurrentUICulture</code> properties that can be used to get or set the user’s current culture and “UI culture.”</p>
<p class="callout-heading">CurrentCulture versus CurrentUICulture</p>
<p class="callout"><code>CurrentCulture</code> defines <a id="_idIndexMarker808"/>how data types such as dates, numbers, and <a id="_idIndexMarker809"/>currencies should be formatted <a id="_idIndexMarker810"/>in the application. This ensures that the look and feel of the data aligns with the user’s cultural context. On the other hand, <code>CurrentUICulture</code> dictates the <a id="_idIndexMarker811"/>language used for the UI elements and text resources. <code>CurrentCulture</code> determines <em class="italic">how things look</em> (formatting), while <code>CurrentUICulture</code> controls <em class="italic">which language is being </em><em class="italic">used</em> (localization).</p>
<p>The user’s current culture settings can be easily obtained with the following lines of code:</p>
<pre class="source-code">
var currentCulture = CultureInfo.CurrentCulture;
var currentUICulture = CultureInfo.CurrentUICulture;</pre> <p>This will get the device’s culture settings, which the user has set up in their system settings. Let’s see how we can set a different culture.</p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor201"/>Setting a different culture</h2>
<p>Setting a <a id="_idIndexMarker812"/>particular culture is as easy as assigning it to the relevant properties on the <code>CultureInfo</code> class:</p>
<pre class="source-code">
var cultureInfo = new CultureInfo("fr-FR");
CultureInfo.CurrentCulture = cultureInfo;
CultureInfo.CurrentUICulture = cultureInfo;
CultureInfo.DefaultThreadCurrentCulture = cultureInfo;
CultureInfo.DefaultThreadCurrentUICulture = cultureInfo;</pre> <p>The <code>DefaultThreadCurrentCulture</code> and <code>DefaultThreadCurrentUICulture</code> properties are used to set the default culture settings for all threads in a .NET application, including background threads that you may spin up for various tasks.</p>
<p class="callout-heading">Note</p>
<p class="callout">For the sake of simplicity and to keep our focus on the overall process of localization, throughout this chapter we won’t be making a distinction between <code>CurrentCulture</code> and <code>CurrentUICulture</code> unless explicitly mentioned. When we talk about updating the culture settings, we’ll be updating both <code>CurrentCulture</code> and <code>CurrentUICulture</code>, as well as their <code>DefaultThread</code> counterparts.</p>
<p>If we want, we can allow users to select a culture from a list of supported cultures and save it for future sessions. Here’s a simplified example using <code>Microsoft.Maui.Storage.Preferences</code> to store the chosen culture:</p>
<pre class="source-code">
Preferences.Set("SelectedCulture", "fr-FR");</pre> <p>Retrieving and assigning the previously stored selected culture can be done like this:</p>
<pre class="source-code">
var storedCulture = Preferences.Get("SelectedCulture", 
"en-US");</pre> <p>The <code>Preferences</code>’s <code>Get</code> method accepts a second parameter that serves as a default value to return when no existing value for the given key exists. The string value that we retrieved can now be used to instantiate a new <code>CultureInfo</code> object, which we can then use to set the application’s culture. Take a look:</p>
<pre class="source-code">
var cultureInfo = new CultureInfo(storedCulture);
CultureInfo.CurrentCulture = cultureInfo;</pre> <p>As mentioned <a id="_idIndexMarker813"/>earlier, the <code>CurrentCulture</code> property defines how particular data types are being displayed. So, let’s have a quick look at what we mean by that.</p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor202"/>Displaying formatted data</h2>
<p>Culture settings have a direct impact on how data types such as dates and numbers are formatted <a id="_idIndexMarker814"/>when they are displayed in the UI. When you set <code>CultureInfo.CurrentCulture</code>, it will also influence the formatting in data-binding scenarios. This means that <code>DateTime</code> values, for instance, will be displayed according to the format rules of the set culture.</p>
<p>Let’s say we have a <code>DateTime</code> property in our ViewModel:</p>
<pre class="source-code">
public DateTime LastUpdated { get; set; } = new
DateTime(2020, 7, 3);</pre> <p>And we are binding this property to a <code>Label</code> in XAML:</p>
<pre class="source-code">
&lt;Label Text="{Binding LastUpdated}" /&gt;</pre> <p>Because we are not specifying how the data should be formatted, the <code>ToString</code> method will be called on the <code>DateTime</code> object, and that result will be shown on the screen. The <code>ToString</code> method will take the current culture settings into account. As a result, if the culture is set to US English (<code>en-US</code>), the date will be formatted as <code>7/3/2020 12:00:00 AM</code>, whereas if the culture is set to French (<code>fr-FR</code>), the date will appear as <code>03/07/2020 00:00:00</code>.</p>
<p>The <code>StringFormat</code> property in XAML binding expressions allows us to define custom formatting for data types such as <code>DateTime</code>. What’s great is that <code>StringFormat</code> will also respect the current culture settings, so it’s a fantastic way to combine customization with localization. For instance, we could use <code>StringFormat</code> in XAML to specify how you’d like that date to appear:</p>
<pre class="source-code">
&lt;Label Text="{Binding LastUpdated, StringFormat='{0:MMMM d,
  yyyy}'}" /&gt;</pre> <p>In this example, <code>StringFormat</code> is set to display the full month name, the day, and the full year. In US English, it will be displayed as <code>July 3, 2020</code>, whereas when the app’s culture is set to French, the date will automatically adjust to <code>juillet 3, 2020</code>. The format specified in <code>StringFormat</code> remains consistent, but the actual string values for the day and month adapt to the set culture.</p>
<p>The same <a id="_idIndexMarker815"/>principles apply to number formatting. Different cultures have various ways of representing numbers, particularly when it comes to separating thousands and decimal points. By being mindful of the culture settings, we ensure that our application displays numbers in a format that is both familiar and understandable to the user.</p>
<p>In contrast to the <code>CurrentCulture</code> property, the <code>CurrentUICulture</code> property determines the language that is being used in the app. So, let’s have a look at how this can be managed through resource files.</p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor203"/>What are Resources Files?</h2>
<p>Resources Files are a core feature of the .NET ecosystem, used to facilitate localization across a wide <a id="_idIndexMarker816"/>array of application types. Typically named with a <code>.resx</code> extension, these XML-based files allow you to define key-value pairs where the key represents a specific piece of text or asset in your application, and the value represents its localized equivalent. Visual Studio even provides an editor for <code>.resx</code> files, allowing developers to easily define keys and their value (<em class="italic">Figure 12</em><em class="italic">.1</em>):</p>
<div><div><img alt="Figure 12.1: Visual Studio .resx designer" height="332" src="img/B20941_12_01.jpg" width="1292"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1: Visual Studio .resx designer</p>
<p>What’s particularly handy is that a strongly typed class is automatically generated when you create a <code>.resx</code> file. This class allows us to access localized resources programmatically in a type-safe manner, eliminating the need to manually look up resource keys in your code. The name of this autogenerated class is derived from the name of the <code>resx</code> file itself. For example, if the resource file is named <code>AppResources.resx</code>, the generated class will be named <code>AppResources</code>.</p>
<p>By suffixing the name of the file, we can specify which culture a specific resource file belongs to – for example, <code>AppResources.resx</code> for the default culture of the app (let’s say English), <code>AppResources.fr-FR.resx</code> for French, <code>AppResources.es-ES.resx</code> for Spanish, and so on.</p>
<p>.NET MAUI will look in the <code>.resx</code> file that corresponds with the set culture for the requested value. Fetching a localized string can be done as shown here:</p>
<pre class="source-code">
var s1 = AppResources.
    ResourceManager.GetString("AddAsFavorite");</pre> <p>If the current <a id="_idIndexMarker817"/>UI culture is set to French (<code>fr-FR</code>), .NET MAUI will automatically look for <code>AddAsFavorite</code> in the <code>AppResources.fr-FR.resx</code> file. If there is no resource file matching the current UI culture, the default file (the one without a suffix) will be used.</p>
<p>Alternatively, retrieving a value for the <code>AddAsFavorite</code> key can also be done as follows:</p>
<pre class="source-code">
var s2 = AppResources.AddAsFavorite;</pre> <p>A static property will be generated in the <code>AppResources</code> class for every key in the <code>.resx</code> file. These properties utilize <code>ResourceManager</code>’s <code>GetString</code> method to retrieve the corresponding value.</p>
<p class="callout-heading">Note</p>
<p class="callout">It’s important to note that the generated class will only be based on the default resource file. This means that only properties will be generated for the keys in the default file. So, it is very important to have the same keys in each of the different culture-specific files! Resolving a value for a key that is not present in the resource file of the current UI culture will result in an exception!</p>
<p>Let’s add some resource files to our solution:</p>
<ol>
<li>Right-click the <code>Resources</code> folder in the <code>Recipes.Mobile</code> project and select <code>Strings</code>.</li>
<li>Right-click this folder and select <strong class="bold">Add</strong> | <strong class="bold">New Item…</strong>.</li>
<li>In the <code>resources</code>, select the <code>AppResources.resx</code> as the name (<em class="italic">Figure 12</em><em class="italic">.2</em>):</li>
</ol>
<div><div><img alt="Figure 12.2: Creating a new Resources File" height="709" src="img/B20941_12_02.jpg" width="1298"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2: Creating a new Resources File</p>
<ol>
<li value="4">Double-check <a id="_idIndexMarker818"/>the newly created file’s properties in the <strong class="bold">Properties</strong> window. The <strong class="bold">Build Action</strong> property should be set to <strong class="bold">Embedded resource</strong>, and the <strong class="bold">Custom Tool</strong> property should be set to <strong class="bold">ResXFileCodeGenerator</strong>, as <em class="italic">Figure </em><em class="italic">12</em><em class="italic">.3</em> shows:</li>
</ol>
<div><div><img alt="Figure 12.3: Properties of the AppResources.resx file" height="316" src="img/B20941_12_03.jpg" width="738"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3: Properties of the AppResources.resx file</p>
<ol>
<li value="5">Add a second <code>AppResources.fr-FR.resx</code>. Note that only the default resource file has its <strong class="bold">Custom Tool</strong> property set to <strong class="bold">ResXFileCodeGenerator</strong>. Other resource files will not have this property set, but their <strong class="bold">Build Action</strong> property does have to be set to <strong class="bold">Embedded resource</strong> as well.</li>
<li>In the <code>Chapter 12</code><code>/Resources</code> folder, you will find an <code>AppResources.resx</code> file and an <code>AppResources.fr-FR.resx</code> file containing the <a id="_idIndexMarker819"/>English and French resources respectively. Copy them over to the <code>Strings</code> folder in Visual Studio and override the files you just created.</li>
</ol>
<p>With this in place, let’s have a look at how we can get those values on the screen.</p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor204"/>Getting localized resources on the screen</h2>
<p>In its simplest form, we can use the <code>x:Static</code> markup extension. This markup extension is <a id="_idIndexMarker820"/>used to reference static fields or properties from a specified class. As mentioned earlier, the generated <code>AppResources</code> class has a static property for each of the keys in the <code>x:Static</code> markup extension to reference the localized values. Let’s see how we can add this:</p>
<ol>
<li>Add the following code to the <code>CreateMauiApp</code> method of the <code>MauiProgram</code> class:<pre class="source-code">
public static MauiApp CreateMauiApp()
{
    var builder = MauiApp.CreateBuilder();
    ...
    <strong class="bold">var french = new CultureInfo("fr-FR");</strong>
<strong class="bold">    CultureInfo.CurrentCulture = french;</strong>
<strong class="bold">    CultureInfo.CurrentUICulture = french;</strong>
...
}</pre><p class="list-inset">This will force the app’s culture to French.</p></li> <li>Go to <code>AppShell.xaml</code> and add an XML namespace pointing to the namespace of the <code>AppResources</code> class:<pre class="source-code">
</pre></li> <li>Next, update the <code>Title</code> property of the first <code>Tab</code> element to the following:<pre class="source-code">
Title="{x:Static strings:AppResources.Tab1Title}"</pre><p class="list-inset">By leveraging the <code>x:Static</code> markup extension, we are pointing to the static <code>Tab1Title</code> property of the <code>AppResources</code> class.</p></li> <li>The <code>Title</code> property of the second <code>Tab</code> element should point to the <code>Tab2Title</code> property as shown here:<pre class="source-code">
Title="{x:Static strings:AppResources.Tab2Title}"</pre></li> <li>And finally, for this <a id="_idIndexMarker821"/>first example, head over to <code>RecipeDetailPage</code> and find the <code>MultiBinding</code> on the label that shows the <code>LastUpdated</code> and <code>Author</code> properties. The <code>x:Static</code> markup extension can also be used on the <code>StringFormat</code> property on a binding statement, as shown here:<pre class="source-code">
&lt;MultiBinding <strong class="bold">StringFormat="{x:Static</strong>
<strong class="bold">    strings:AppResources.ModifiedDateAuthorFormat}"</strong>&gt;
    &lt;Binding Path="LastUpdated" /&gt;
    &lt;Binding Path="Author" /&gt;
&lt;/MultiBinding&gt;</pre><p class="list-inset">It’s worth mentioning that <code>ModifiedDateAuthorFormat</code> contains a <code>D</code> format specifier that represents a long date pattern. As a result, the notation of the date will be different depending on the selected culture. For example, when <code>CurrentCulture</code> is set to French (<code>fr-FR</code>), July 3, 2020, will be shown as <code>vendredi 3 </code><code>juillet 2020</code>.</p></li> </ol>
<p>If we now run the app, we should immediately see that the titles of the two main tabs are now in French, as <em class="italic">Figure </em><em class="italic">12</em><em class="italic">.4</em> shows:</p>
<div><div><img alt="Figure 12.4: Localized tab titles" height="75" src="img/B20941_12_04.jpg" width="530"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4: Localized tab titles</p>
<p>When navigating to <code>RecipeDetailPage</code>, the label showing the <code>LastUpdated</code> and <code>Author</code> properties is now also translated. Now, go ahead and change the culture in the <code>CreateMauiApp</code> method to <code>nl-BE</code>. Run the app, and you should see the localized labels in English. That’s because there is no resource file for this culture, so the default one is used. Do note <a id="_idIndexMarker822"/>that the date is being formatted according to the Dutch (Belgium) notation: <code>vrijdag 3 </code><code>juli 2020</code>.</p>
<p>As said, this approach is the simplest form of getting the localized resources on the screen. This is a perfectly valid approach, but it’s not very MVVM-friendly, and it has its limitations:</p>
<ul>
<li>The biggest limitation is that <code>x:Static</code> doesn’t react to changes. If you change the value of the static property at runtime, the UI will not update to reflect the new value. This makes it unsuitable for scenarios where the localized text might change dynamically, such as when a user switches languages in-app. Only when navigating to a new page will the <code>x:Static</code> markup extension load the required values for the newly selected culture. When navigating (back) to pages that are in memory, the values of the previous culture will still be there.</li>
<li>There is no way to access these resources from within our ViewModels. This can be an issue if we want to show dialogs or alerts from a ViewModel.</li>
</ul>
<p>So far, we’ve laid down the essential groundwork for understanding localization in .NET MAUI, including the role of resource files, the <code>CultureInfo</code> class, and the <code>x:Static</code> markup extension. While the methods and concepts we’ve discussed so far form the essential backbone of localization in .NET MAUI, our next section will explore how to seamlessly integrate them into MVVM. Ultimately, our goal is to make use of data binding to <a id="_idIndexMarker823"/>connect our UI to localized values. This enables dynamic updates: if the user switches languages or cultures during runtime, the displayed text will automatically reflect these changes.</p>
<p class="callout-heading">Note</p>
<p class="callout">The properties on a binding statement such as <code>StringFormat</code>, <code>FallbackValue</code>, and <code>TargetNullValue</code> aren’t bindable properties. This means that the only way to assign values from a resource file to these properties is by leveraging the <code>x:Static</code> markup extension, with its limitations.</p>
<h1 id="_idParaDest-195"><a id="_idTextAnchor205"/>Looking at a localization solution for MVVM</h1>
<p>In this section, we’ll look at a solution that’s not just functional but also fits well with the MVVM architectural pattern. Whether you need to localize text within your ViewModels or dynamically <a id="_idIndexMarker824"/>update language in your UI, this approach has you covered. It’s a solution that I’ve personally implemented in numerous projects over the years. While I’ve made some refinements along the way, the core concept has stood the test of time and proven its effectiveness in real-world applications.</p>
<p class="callout-heading">Warning – culture settings are thread-specific</p>
<p class="callout">When allowing the user to switch cultures inside the app, we should be wary of the fact that when updating <code>CultureInfo</code> inside <code>async</code> operations, those changes will not automatically propagate to the parent thread. A localization strategy needs to be designed with this in mind to avoid inconsistencies.</p>
<p>In the code accompanying this chapter, two new projects have been added: <code>Localization</code> and <code>Localization.Maui</code>. The primary objective of the <code>Localization</code> project is to provide a framework-agnostic approach to manage and access localization settings and resources. By encapsulating this localization logic within its own project, we facilitate easy code sharing across different projects, paving the way<a id="_idTextAnchor206"/><a id="_idTextAnchor207"/> for potential packaging and reuse in other projects.</p>
<p>On the other hand, the <code>Localization.Maui</code> project is tailored specifically for .NET MAUI. It houses <a id="_idIndexMarker825"/>the code responsible for storing and retrieving localization information. Putting this logic separately from the rest of our <em class="italic">Recipes!</em> app code allows us to ensure that it remains modular and reusable for other .NET MAUI applications. Let’s discuss the <code>Localization</code> project first.</p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor208"/>The Localization project</h2>
<p>Let’s take <a id="_idIndexMarker826"/>a look at the <code>ILocalizationManager</code> interface in the <code>Localization</code> project:</p>
<pre class="source-code">
public interface ILocalizationManager
{
    void RestorePreviousCulture(
        CultureInfo defaultCulture = null);
    void UpdateUserCulture(CultureInfo cultureInfo);
    CultureInfo GetUserCulture(
        CultureInfo defaultCulture = null);
}</pre> <p>The <code>ILocalizationManager</code> interface defines three methods for managing localization settings:</p>
<ul>
<li><code>RestorePreviousCulture</code> is a method that can be used to restore the previous <a id="_idIndexMarker827"/>culture used by the user. The <code>defaultCulture</code> parameter can be used to specify a fallback culture in case there is no previous culture set.</li>
<li><code>UpdateUserCulture</code> updates <a id="_idIndexMarker828"/>and stores the culture settings for the current user. The <code>cultureInfo</code> parameter specifies the new culture to use.</li>
<li>The <code>GetUserCulture</code> method <a id="_idIndexMarker829"/>retrieves the stored culture settings. The <code>defaultCulture</code> parameter can be used to specify a fallback culture in case there is no culture set.</li>
</ul>
<p>The primary intent behind this interface is to abstract tasks related to the persistence and retrieval <a id="_idIndexMarker830"/>of user-specified cultures. In the context of a .NET MAUI-specific implementation, we might, for instance, opt to save the most recently chosen <code>CultureInfo</code> within <code>Preferences</code>, ensuring it’s available the next time the app launches so that it can be restored. We’ll delve deeper into this specific approach shortly.</p>
<p>The second interface in the <code>Localization</code> project is the <code>ILocalizedResourcesProvider</code> interface. Let’s see what this looks like:</p>
<pre class="source-code">
public interface ILocalizedResourcesProvider
{
    string this[string key]
    {
        get;
    }
    void UpdateCulture(CultureInfo cultureInfo);
}</pre> <p>At its core, this interface facilitates the retrieval of localized string values that align with the user’s chosen <code>CultureInfo</code>. It provides a read-only indexer to fetch the localized string corresponding to a specified key. Additionally, the <code>UpdateCulture</code> method lets you modify the current <code>CultureInfo</code>, ensuring that subsequent localized string retrievals reflect the updated cultural context.</p>
<p>Next, we’ll explore the <code>Localization</code> project’s concrete implementation of the <code>ILocalizedResourceProvider</code> interface – namely,  <code>LocalizedResourcesProvider</code>. Let’s start by looking at its constructor:</p>
<pre class="source-code">
ResourceManager resourceManager;
CultureInfo currentCulture;
public static LocalizedResourcesProvider Instance
{
    get;
    private set;
}
public LocalizedResourcesProvider(
    ResourceManager resourceManager)
{
    this.resourceManager = resourceManager;
    currentCulture = CultureInfo.CurrentUICulture;
    Instance = this;
}</pre> <p>The constructor <a id="_idIndexMarker831"/>takes a single parameter, <code>resourceManager</code>. This is the <code>ResourceManager</code> that needs to be used to retrieve the localized values. The <code>currentCulture</code> field is initialized with a default value, being the current UI culture. Within the constructor, the current instance is assigned to the static <code>Instance</code> property. This allows us to access this <code>LocalizedResourcesProvider</code> implementation through a static property, which will be handy in data-binding scenarios, as we’ll see later on.</p>
<p class="callout-heading">Note</p>
<p class="callout">Assigning the current instance of <code>LocalizedResourcesProvider</code> to the static <code>Instance</code> property means there can only be one <code>LocalizedResourcesProvider</code> implementation throughout the app. While this is a limitation to be wary of, it should not pose a significant problem.</p>
<p>The indexer of this class allows us to get the localized string value for a given key. Here’s how this is implemented:</p>
<pre class="source-code">
public string this[string key]
    =&gt; resourceManager.GetString(key, currentCulture)
    ?? key;</pre> <p>When the <a id="_idIndexMarker832"/>key exists within our resources, the method fetches the corresponding localized string using the <code>currentCulture</code>. However, if the provided key doesn’t match any resource key, the key itself is returned as a fallback. It’s crucial to observe that we’re passing the <code>currentCulture</code> explicitly when calling <code>GetString</code>. This ensures that the <code>resourceManager</code> fetches values specific to the provided <code>currentCulture</code>, rather than defaulting to the <code>CultureInfo</code> of the currently executing thread. This design choice addresses potential challenges arising from culture settings being thread-specific.</p>
<p>Now, let’s look at the <code>UpdateCulture</code> method within the <code>LocalizedResourcesProvider</code>:</p>
<pre class="source-code">
public void UpdateCulture(CultureInfo cultureInfo)
{
    currentCulture = cultureInfo;
    OnPropertyChanged("Item");
}</pre> <p>This method updates the <code>currentCulture</code> field. As a result, any subsequent calls to the class’s indexer will retrieve the localized string value for the given key, based on the updated <code>currentCulture</code>. Additionally, the method calls the <code>OnPropertyChanged</code> method, sending <code>Item</code> as its argument. In scenarios involving data binding, this prompts a re-evaluation of all bindings linked to the indexer. Consequently, any values that are data-bound to this indexer will refresh, returning the localized strings of the updated <code>CultureInfo</code>. Let’s transition our focus to the <code>Localization.Maui</code> project.</p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor209"/>The Localization.Maui project</h2>
<p>The <code>LocalizationManager</code> class in the <code>Localization.Maui</code> project is an implementation <a id="_idIndexMarker833"/>of the <code>ILocaliazationManager</code>. It has <a id="_idIndexMarker834"/>a dependency on <code>ILocalizedResourcesProvider</code>, as yo<a id="_idTextAnchor210"/><a id="_idTextAnchor211"/>u can see here:</p>
<pre class="source-code">
readonly ILocalizedResourcesProvider _resourceProvider;
public LocalizationManager(
    ILocalizedResourcesProvider resoureProvider)
{
    _resourceProvider = resoureProvider;
}</pre> <p>By having this reference, we can, later on, call its <code>UpdateCulture</code> method, keeping the updated culture in sync with the <code>ILocalizedResourcesProvider</code>.</p>
<p>The <code>LocalizationManager</code> class should also store the selected <code>CultureInfo</code> so that it can be retrieved on subsequent app launches and restore the previous <code>CultureInfo</code>. The following code block shows how the <code>UpdateUserCulture</code> uses the <code>Preferences</code> API to store the given <code>CultureInfo</code>, assigns the updated value to the <code>currentCulture</code> field, updates the static properties on the <code>CultureInfo</code> object, and calls the <code>ILocalizedResourcesProvider</code>’s <code>UpdateCulture</code> method:</p>
<pre class="source-code">
public void UpdateUserCulture(CultureInfo cultureInfo)
{
    Preferences.Default.Set("UserCulture",
        cultureInfo.Name);
    SetCulture(cultureInfo);
}
private void SetCulture(CultureInfo cultureInfo)
{
    currentCulture = cultureInfo;
    Application.Current.Dispatcher.Dispatch(() =&gt;
    {
        CultureInfo.CurrentCulture = cultureInfo;
        CultureInfo.CurrentUICulture = cultureInfo;
        CultureInfo.DefaultThreadCurrentCulture =
            cultureInfo;
        CultureInfo.DefaultThreadCurrentUICulture =
            cultureInfo;
    });
    _resourceProvider.UpdateCulture(cultureInfo);
}</pre> <p>Notice how <a id="_idIndexMarker835"/>the updates on the <code>CultureInfo</code> object are dispatched to the main thread. Remember the note about <code>CultureInfo</code> being bound to <a id="_idIndexMarker836"/>the current thread? We want to ensure that the main thread’s <code>CultureInfo</code> is updated to maintain consistency. Failing to apply these changes to the main thread could result in data binding using the outdated or previous <code>CultureInfo</code>. This misalignment can lead to inaccuracies when formatting data, such as displaying <code>DateTime</code> objects.</p>
<p>The <code>GetUserCulture</code> method first checks if its <code>currentCulture</code> field is set. If it is, that value is returned directly. If not, the method tries to retrieve the culture based on the <code>UserCulture</code> key from <code>Preferences</code>. If no value is found there, it either resorts to the provided <code>defaultCulture</code> parameter or, in its absence, the current system culture. Once determined, this culture is assigned to the <code>currentCulture</code> field, which is then returned. Take a look:</p>
<pre class="source-code">
public CultureInfo GetUserCulture(
    CultureInfo defaultCulture = null)
{
    if (currentCulture is null)
    {
        var culture = Preferences.Default.Get(
            "UserCulture", string.Empty);
        if (string.IsNullOrEmpty(culture))
        {
            currentCulture = defaultCulture
                ?? CultureInfo.CurrentCulture;
        }
        else
        {
            currentCulture = new CultureInfo(culture);
        }
    }
    return currentCulture;
}</pre> <p>Finally, the <code>RestorePreviousCulture</code> method uses the <code>GetUserCutlure</code> method to retrieve the <a id="_idIndexMarker837"/>previously used <a id="_idIndexMarker838"/>culture and passes this on to the <code>SetCulture</code> method, as you can see here:</p>
<pre class="source-code">
public void RestorePreviousCulture(
    CultureInfo defaultCulture = null)
    =&gt; SetCulture(GetUserCulture(defaultCulture));</pre> <p>This method can be used when the app starts to set the current culture to the culture that t<a id="_idTextAnchor212"/><a id="_idTextAnchor213"/>he user selected previously.</p>
<p>Now that <a id="_idIndexMarker839"/>we’re familiar with the roles and workings of these classes, let’s integrate them into the <em class="italic">Recipes!</em> app. This will enable us to handle localization <a id="_idIndexMarker840"/>in a manner that complements the MVVM architectural pattern. Here’s a step-by-step guide:</p>
<ol>
<li>Go to <code>MauiProgram.cs</code> and add the following line of code to the <code>CreateMauiApp</code> method:<pre class="source-code">
builder.Services.AddSingleton&lt;ILocalizationManager,
  LocalizationManager&gt;();</pre><p class="list-inset">This registers an instance of <code>LocalizationManager</code> to the DI container.</p></li> <li>Create an instance of <code>LocalizedResourcesProvider</code>. Pass the <code>ResourceManager</code> of <code>AppResources</code> to its constructor, allowing <code>LocalizedResourceProvider</code> to access the resources defined <a id="_idTextAnchor214"/><a id="_idTextAnchor215"/>in the <code>AppResources</code> files:<pre class="source-code">
var resources = new LocalizedResourcesProvider(
    <a id="_idTextAnchor216"/><a id="_idTextAnchor217"/>AppResources.ResourceManager);</pre></li> <li>Let’s register this <code>LocalizedResourcesProvider</code> as <code>Singleton</code> to the DI container, as shown here:<pre class="source-code">
builder.Services
    .AddSingleton&lt;ILocalizedResourcesProvider&gt;(
    resources);</pre><p class="list-inset">By doing this, we’re ensuring a single instance of the <code>LocalizedResourcesProvider</code> class is used throughout the app. Any time this instance is resolved through DI, it’s guaranteed to be the same as that referred to by the <code>LocalizedResourcesProvider</code>’s static <code>Instance</code> property. This is essential for accessing localized resources consistently across the application.</p></li> </ol>
<p>This sets <a id="_idIndexMarker841"/>the foundation for a solid <a id="_idIndexMarker842"/>localization solution that is ready to be used in our app. Let’s see how we can integrate the <code>LocalizedResourcesProvider</code> and <code>LocalizationManager</code> in our app.</p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor218"/>Using the LocalizedResourcesProvider and LocalizationManager</h2>
<p>Let’s <a id="_idIndexMarker843"/>take a look at how <a id="_idIndexMarker844"/>we can use the <code>LocalizedResourcesProvider</code> and <code>LocalizationManager</code> to access localized <a id="_idIndexMarker845"/>resources from within a ViewModel. On the <code>SettingsPage</code>, the user can select a new language through the <code>PickLanguagePage</code>. When selecting a language, a prompt should ask, in the current language, whether <a id="_idIndexMarker846"/>the user wants to switch. After switching, an alert in the updated language should confirm the update. Here’s how we can do this:</p>
<ol>
<li>First, let’s add the following two fields to <code>SettingsViewModel</code>:<pre class="source-code">
<strong class="bold">readonly ILocalizedResourcesProvider _resources;</strong>
<strong class="bold">readonly ILocalizationManager _localizationManager;</strong>
<strong class="bold">readonly IDialogService _dialogService</strong>
...
public PickLanguageViewModel(
    INavigationService navigationService
    <strong class="bold">IDialogService dialogService,</strong>
    <strong class="bold">ILocalizedResourcesProvider resourcesProvider,</strong>
<strong class="bold">    ILocalizationManager localizationManager</strong>)
{
    <strong class="bold">_dialogService = dialogService;</strong>
    <strong class="bold">_resources = resourcesProvider;</strong>
<strong class="bold">    _localizationManager = localizationManager;</strong>
    ...
}
...</pre><p class="list-inset">The <a id="_idIndexMarker847"/>DI container <a id="_idIndexMarker848"/>will automatically inject these additional <a id="_idIndexMarker849"/>dependencies into the constructor.</p></li> <li>Next, we <a id="_idIndexMarker850"/>can update the <code>ConfirmSwitchLanguage</code> method to this:<pre class="source-code">
private Task&lt;bool&gt; ConfirmSwitchLanguage()
    =&gt; _dialogService.AskYesNo(
        _resources["SwitchLanguageDialogTitle"],
        _resources["SwitchLanguageDialogText"],
        _resources["YesDialogButton"],
        _resources["NoDialogButton"]);</pre><p class="list-inset">See how we use the <code>_resources</code> field to fetch localized strings, which are then passed to the <code>IDialogService</code>’s <code>AskYesNo</code> method. The keys exactly match the keys present in the <code>AppResources</code> files.</p></li> <li>Likewise, we can also update the <code>NotifySwitch</code> method, as shown here:<pre class="source-code">
private Task NotifySwitch()
    =&gt; _dialogService.Notify(
        _resources["LanguageSwitchedTitle"],
        _resources["LanguageSwitchedText"],
        _resources["OKDialogButton"]);</pre></li> <li>Lastly, we <a id="_idIndexMarker851"/>need to <a id="_idIndexMarker852"/>add the following line of code to the <code>SwitchLanguage</code> method:<pre class="source-code">
private void SwitchLanguage()
{
    CurrentLanguage = newLanguage;
    <strong class="bold">_localizationManager</strong>
<strong class="bold">        .UpdateUserCulture(</strong>
<strong class="bold">        new CultureInfo(SelectedLanguage));</strong>
}</pre><p class="list-inset">This <a id="_idIndexMarker853"/>method is called when the user has confirmed <a id="_idIndexMarker854"/>switching to the new language. By calling the <code>_localizationManager</code>’s <code>UpdateUserCulture</code>, we’ll be persisting the selected culture, updating the <code>CultureInfo</code> properties, and notifying the <code>ILocalizedResourcesProvider</code> about the updated culture. As a result, subsequential calls to the <code>_resources</code> field will retrieve the localized values for the updated <code>CultureInfo</code>.</p></li> </ol>
<p>We can now run the app, go to the <code>SettingsPage</code>, and click through to the <code>PickLanguagePage</code>, where we can change the language of the app. Once a new language is chosen, we automatically navigate back to the <code>SettingsPage</code>, where we’ll get a prompt in the current language of the app (<em class="italic">Figure 12</em><em class="italic">.5</em>):</p>
<div><div><img alt="Figure 12.5: Prompt in English" height="377" src="img/B20941_12_05.jpg" width="805"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5: Prompt in English</p>
<p>After <a id="_idIndexMarker855"/>confirmation, the language will be updated, and we’ll <a id="_idIndexMarker856"/>see an alert in the new language (<em class="italic">Figure 12</em><em class="italic">.6</em>):</p>
<div><div><img alt="Figure 12.6: Alert in French" height="358" src="img/B20941_12_06.jpg" width="765"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6: Alert in French</p>
<p>The fact that we can switch cultures from within our ViewModels and retrieve localized string values for the currently set culture is already very exciting! But how do we handle the localization in our Views if we want them to update to the newly selected culture as well? Let’s have a look!</p>
<ol>
<li>Go to <code>SettingsPage.xml</code> and add the following XML namespace:<pre class="source-code">
xmlns:localization="clr-namespace:
  Localization;assembly=Localization"</pre><p class="list-inset">This namespace points to the <code>Localization</code> namespace of the <code>Localization</code> project.</p></li> <li>Update the <code>Text</code> property of the <strong class="bold">Select Language</strong> button to the following:<pre class="source-code">
Text="{Binding Path=[ChooseLanguage], Source={x:Static
localization:LocalizedResourcesProvider.Instance}}"
LocalizedResourcesProvider.Instance["ChooseLanguage"]</pre><p class="list-inset">As we <a id="_idIndexMarker857"/>saw in the <code>LocalizedResourcesProvider</code>’s implementation, the indexer takes a provided <a id="_idIndexMarker858"/>key and fetches the corresponding localized string using the configured <code>ResourceManager</code>.</pre></li> <li>Let’s also update the text of the <code>LocalizedResourcesProvider</code>, as shown here:<pre class="source-code">
{Binding Path=[About], Source={x:Static
localization:LocalizedResourcesProvider.Instance}}"</pre><p class="list-inset">And while we’re at it, let’s also update the page’s title as well:</p><pre class="source-code">Title="{Binding Path=[SettingsTitle], Source={x:Static
localization:LocalizedResourcesProvider.Instance}}"</pre></li> <li>Take a look at the <code>Text</code> property of the label that shows the current selected language:<pre class="source-code">
Text="{Binding CurrentLanguage, StringFormat=
  'Language: {0}'}"
<p class="list-inset">We’ve <a id="_idIndexMarker859"/>extracted the hardcoded <code>Language</code> part from the <code>StringFormat</code> property and defined two placeholders. By leveraging <a id="_idIndexMarker860"/>multi-binding, we can indicate the first placeholder should get the value associated with <code>Language</code> in the <code>AppResources</code>. The second placeholder is bound to the <code>CurrentLanguage</code> property on the ViewModel.</pre><p class="list-inset">Note that the <code>StringFormat</code> property starts with <code>{}</code>. Putting just <code>{0}: {1}</code> in there is not allowed, because the  <code>{</code> curly brace is a special character in XAML, often signaling the start of a markup extension. <code>{}</code> is an escape sequence to handle this.</p></li> </ol>
<p>With these changes in place, run the app again. Go to the <code>SettingsPage</code> and select a different language. After confirming to switch the language of the app, you should not only see the alert in the updated language appearing but also see that the labels on the <code>SettingsPage</code> instantly update (<em class="italic">Figure 12</em><em class="italic">.7</em>)!</p>
<div><div><img alt="Figure 12.7: The Settings page before (left) and after (right) switching to French" height="388" src="img/B20941_12_07.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7: The Settings page before (left) and after (right) switching to French</p>
<p>The magic <a id="_idIndexMarker861"/>happens because our bindings target the indexer <a id="_idIndexMarker862"/>of the <code>LocalizedResourcesProvider</code> class. Thus, any trigger of the <code>PropertyChanged</code> event (with <code>Item</code> as the property name) will prompt a re-evaluation of these bindings. Triggering the <code>PropertyChanged</code> event is done because the <code>LocalizationManager</code> calls the <code>UpdateCulture</code> method on its <code>_resourceProvider</code> field.</p>
<p>Currently, the selected culture isn’t persisted across app launches. To be exact: the selected culture does get stored, but it is not being restored when the application starts. We can easily add that functionality by updating the constructor of the <code>App</code> class:</p>
<pre class="source-code">
public App(INavigationInterceptor navigationInterceptor<strong class="bold">,</strong>
<strong class="bold">    ILocalizationManager manager)</strong>
{
    <strong class="bold">manager.RestorePreviousCulture();</strong>
...
}</pre> <p>By calling the <code>RestorePreviousCulture</code> on the injected <code>ILocalizationManager</code> interface, the previously set culture is being restored. It’s done in the constructor of the <code>App</code> class so that it is applied early on in the application’s life cycle.</p>
<p>Personally, I think this is a beautiful and very MVVM-friendly solution to localization; well, except for the rather complex data-binding statements we have to put in place. In the next section, we’ll see how we can improve on that.</p>
<h1 id="_idParaDest-199"><a id="_idTextAnchor219"/>Using a custom Translate markup extension</h1>
<p>We previously set up a localization solution for our app. While it works effectively, the data-binding <a id="_idIndexMarker863"/>statements were a bit verbose and would have to be repeated for each string. Building on that foundation, in this section, we’ll introduce a streamlined approach: a custom markup extension designed specifically for translations.</p>
<p>But before we <a id="_idIndexMarker864"/>proceed, let’s briefly revisit what markup extensions are. <strong class="bold">Markup extensions</strong> provide a way to compute or retrieve property values at runtime rather than just setting them to static values. This functionality makes them particularly handy for tasks such as resource lookups, data binding, or, in our case, simplifying translation retrieval.</p>
<p>It’s important to note that we’re not changing how we leverage data binding to bind to our resources. Instead, we’re just making the XAML code easier to write and read. The actual data-binding process stays the same. This is essentially what the <code>Translate</code> markup extension will look like in XAML:</p>
<pre class="source-code">
Title="{mauiloc:Translate SettingsTitle}"</pre> <p>This is synonymous with the following:</p>
<pre class="source-code">
Title="{Binding Path=[SettingsTitle], Source={x:Static
  localization:LocalizedResourcesProvider.Instance},
    Mode=OneWay}"</pre> <p>The <code>Translate</code> markup extension is a wrapper around a conventional data-binding statement. Let’s take a look at the <code>TranslateExtension</code> class in the <code>Localization.Maui</code> project. This class implements the generic <code>IMarkupExtension</code> interface, and as a result, it needs to implement the following methods:</p>
<pre class="source-code">
object IMarkupExtension.ProvideValue(IServiceProvider
  serviceProvider);
T ProvideValue(IServiceProvider serviceProvider);</pre> <p>The non-generic <code>ProvideValue</code> method will be called at runtime and must return the value we <a id="_idIndexMarker865"/>want to be using in our XAML. In this case, we want to return a <code>Binding</code>. Here’s how it’s implemented:</p>
<pre class="source-code">
[ContentProperty(nameof(<strong class="bold">Key</strong>))]
public class TranslateExtension :
    IMarkupExtension&lt;<strong class="bold">Binding</strong>&gt;
{
    <strong class="bold">public string Key { get; set; }</strong>
    object IMarkupExtension.ProvideValue(
        IServiceProvider serviceProvider)
        =&gt; ProvideValue(serviceProvider);
    public <strong class="bold">Binding</strong> ProvideValue(
        IServiceProvider serviceProvider)
        =&gt; ...
}</pre> <p>The non-generic <code>ProvideValue</code> method calls its generic version, which returns a <code>Binding</code>. The class has a property named <code>Key</code>, which represents the key used to fetch the localized value. This <code>Key</code> property can be assigned in the markup extension, as shown here:</p>
<pre class="source-code">
Title="{mauiloc:Translate <code>ContentProperty</code> attribute applied to this class, we can omit the <code>Key=</code> segment, simplifying our markup extension’s use even more. <code>ContentProperty</code> specifies the default property that is to be used when no identifier is specified in XAML. Remember how we don’t need to explicitly state <code>Path=</code> in a data-binding statement and can simply write the path? This <code>ContentProperty</code> attribute is exactly what drives that! Let’s finally see what the generic <code>ProvideValue</code> method returns:</p>
<pre class="source-code">
public Binding ProvideValue(
    IServiceProvider serviceProvider)
    =&gt; new Binding
    {
        Mode = BindingMode.OneWay,
        Path = $"[{Key}]",
        Source = LocalizedResourcesProvider.Instance
    };</pre> <p>The <code>ProvideValue</code> method returns a <code>Binding</code> object. Its <code>Source</code> value is set to the <a id="_idIndexMarker866"/>static <code>Instance</code> property of <code>LocalizedResourcesProvider</code>, equivalent to this:</p>
<pre class="source-code">
{x:Static localization:LocalizedResourcesProvider.Instance}</pre> <p>For the <code>Path</code> property, when the <code>Key</code> value is <code>SettingsTitle</code>, it translates to <code>Path=[SettingsTitle]</code>. The <code>Binding</code>’s <code>Mode</code> is set to <code>OneWay</code> to ensure it listens for the <code>PropertyChanged</code> event and updates the bound value when needed.</p>
<p>The <code>Translate</code> markup extension provides a convenient way to define the exact same binding statements we had earlier. Let’s go ahead and update some of our Views so that they leverage this <code>Translate</code> markup extension:</p>
<ol>
<li>Go to <code>SettingsPage</code> and add the following XML namespace, which points to the <code>Localization.Maui</code> namespace of the <code>Localization.Maui</code> project:<pre class="source-code">
xmlns:mauiloc="clr-namespace:Localization.Maui;
  assembly=Localization.Maui"</pre></li> <li>Update the binding statements on the <code>SettingsPage</code>, as shown here:<pre class="source-code">
...
Title="{mauiloc:Translate SettingsTitle}"
...
Text="{mauiloc:Translate ChooseLanguage}"
...
Text="{mauiloc:Translate About}"
...</pre></li> <li>In <code>AppShell.xaml</code>, add the same XML namespace that we previously added to <code>SettingsPage</code> in <em class="italic">step 1</em>.</li>
<li>Now, update <a id="_idIndexMarker867"/>the binding statements on <code>AppShell.xaml</code>, as shown in the following snippet:<pre class="source-code">
&lt;Tab Title="<strong class="bold">{mauiloc:Translate Tab1Title}</strong>"&gt;
    ...
&lt;/Tab&gt;
&lt;Tab Title="<strong class="bold">{mauiloc:Translate Tab2Title}</strong>"&gt;
    ...
&lt;/Tab&gt;</pre></li> </ol>
<p>The <code>Translate</code> markup extension offers an elegant approach to what is typically considered a complex task. Everywhere hardcoded text is used, we can very simply replace it with this <code>TranslateExtension</code>. Note that the <code>TranslateExtension</code> can still be improved: all the typical data-binding properties such as <code>Converter</code>, <code>ConverterParameter</code>, and so on can be added to this class as well and be used in the <code>Binding</code> object that is being returned.</p>
<p>Now that we know how to localize hardcoded <code>copy</code> labels, let’s have a look at how we can fetch localized data from APIs.</p>
<h1 id="_idParaDest-200"><a id="_idTextAnchor220"/>Fetching localized data from APIs</h1>
<p>Before we wrap up this chapter, let’s have a quick look at how we could pass the user’s language to <a id="_idIndexMarker868"/>the API so that it can return localized data. One approach is to include a language parameter in every service and repository method, allowing the ViewModel to pass the user’s current language. However, I believe adding such parameters can clutter the code. A cleaner alternative is to handle this within the repositories. Let’s see how:</p>
<ol>
<li>First, let’s update the <code>IRecipeAPI</code> interface by adding a <code>language</code> parameter of type <code>string</code> to the <code>GetRecipes</code> method. The following snippet shows how we can configure Refit to pass this additional parameter as an <code>Accept-Language</code> request header when executing the API call:<pre class="source-code">
Task&lt;ApiResponse&lt;RecipeOverviewItemsDto&gt;&gt;
  GetRecipes(<strong class="bold">[Header("Accept-Language")] string</strong>
<code>Header</code> attribute, but I think this approach is a lot cleaner.</p></li> <li>It’s the <code>RecipeApiGateway</code> class that invokes the updated <code>GetRecipes</code> method. In order for it to access the current culture, let’s inject an instance of the <code>ILocalizationManager</code>, as shown here:<pre class="source-code">
readonly ILocalizationManager _localizationManager;
...
public RecipeApiGateway(IRecipeApi api,
    ILocalizationManager localizationManager)
{
    _api = api;
    _localizationManager = localizationManager;
}</pre></li> <li>The next code block shows how we can now use the <code>_localizationManager</code> field to access the current user culture and pass its <code>Name</code> property to the <code>GetRecipes</code> method:<pre class="source-code">
public Task&lt;Result&lt;LoadRecipesResponse&gt;&gt;
  LoadRecipes(int pageSize, int page)
    =&gt; InvokeAndMap(_api.GetRecipes(
        <strong class="bold">_localizationManager.GetUserCulture().Name</strong>,
         pageSize, page), MapRecipesOverview);</pre><p class="list-inset">While directly using <code>CultureInfo.CurrentCulture.Name</code> might seem straightforward, accessing the culture via our <code>ILocalizationManager</code> ensures <a id="_idIndexMarker869"/>greater consistency, as mentioned earlier.</p></li> <li>Accessing the <code>Accept-Language</code> that’s now being sent with this API call can be achieved by updating the <code>GetRecipes</code> endpoint in the <code>Program.cs</code> file inside the <code>Recipes.Web.Api</code> project. Here’s what the updated code looks like:<pre class="source-code">
app.MapGet("/recipes", (int pageSize, int pageIndex,
    <strong class="bold">[FromHeader(Name = "Accept-Language")] string</strong>
<strong class="bold">       language</strong>) =&gt;
    {
        //use language to retrieve recipes
        return new RecipeService()
            .LoadRecipes(pageSize, pageIndex);
})
.WithName("GetRecipes")
.WithOpenApi();</pre></li> </ol>
<p>In contrast to the data-bound values on the screen, changing the app’s language won’t automatically fetch any localized data coming from the API anew. So, how can we tackle this? In <a href="B20941_07.xhtml#_idTextAnchor119"><em class="italic">Chapter 7</em></a>, <em class="italic">Dependency Injection, Services, and Messaging</em>, we already discussed thoroughly <a id="_idIndexMarker870"/>how ViewModels can communicate with each other in a loosely coupled manner through <code>Messaging</code>. <code>Messaging</code> offers a solution to this challenge: <code>SettingsViewModel</code> can send a message notifying other ViewModels about the updated language. ViewModels can react to this and re-fetch their data. Let’s implement this:</p>
<ol>
<li>Add a new class called <code>CultureChangedMessage</code> to the <code>Messages</code> folder of the <code>Recipes.Client.Core</code> project. Here’s what it looks like:<pre class="source-code">
public class CultureChangedMessage :
    ValueChangedMessage&lt;CultureInfo&gt;
{
    public CultureChangedMessage(CultureInfo value) :
        base(value)
    { }
}</pre></li> <li>Update the <code>SwitchLanguage</code> method on <code>SettingsViewModel</code>, as shown here:<pre class="source-code">
private void SwitchLanguage(string newLanguage)
{
    CurrentLanguage = newLanguage;
    var newCulture = new CultureInfo(newLanguage);
    _localizationManager
        .UpdateUserCulture(newCulture);
    <strong class="bold">WeakReferenceMessenger.Default.Send(</strong>
<strong class="bold">        </strong><strong class="bold">new CultureChangedMessage(newCulture));</strong>
}</pre></li> <li>Finally, in the constructor of the <code>RecipesOverviewViewModel</code>, we can add the following code that listens for the <code>CultureChangedMessage</code> to arrive so that we can reload the list of recipes:<pre class="source-code">
WeakReferenceMessenger.Default
    .Register&lt;CultureChangedMessage&gt;(this, (r, m) =&gt;
{
    Recipes.Clear();
    (r as RecipesOverviewViewModel).LoadRecipes(7, 0);
});</pre><p class="list-inset">We don’t need <a id="_idIndexMarker871"/>to bother with passing the updated culture or language around. Once the message is received, the <code>LocalizationManager</code> is already updated to the selected culture and will return the newly selected culture. This ensures that any new recipe fetch will use the updated culture.</p></li> </ol>
<p>When running the app and changing the language on the <code>SettingsPage</code>, the <code>RecipesOverviewViewModel</code> will reload its recipes. If you debug and set a breakpoint in the API, you’ll observe that the language parameter consistently matches the newly selected language.</p>
<h1 id="_idParaDest-201"><a id="_idTextAnchor221"/>Summary</h1>
<p>We kicked off this chapter with an introduction to localization, understanding its importance in ensuring our app resonates with users globally. Before diving deep, we explored the basics of how localizable values can be statically bound, offering a foundational approach.</p>
<p>Building on this, we introduced a more dynamic localization framework. This allowed for more flexible updates and interactions. Following this, we delved into simplifying our XAML through the <code>Translate</code> markup extension. While it made our data-binding statements sleeker, the underlying mechanism remained unchanged.</p>
<p>Next, we discussed getting localized data from our APIs. We found a neat way to tell the API about the user’s language choice without making our code messy. By using the <code>ILocalizationManager</code>, we kept our approach consistent. And, with <code>Messaging</code>, our app knows when to fetch new data if a user changes their language.</p>
<p>The big takeaway? All our steps respected the key MVVM idea of “separation of concerns.” Each part of our app has its job, making things organized and easier to manage.</p>
<p class="callout-heading">Note</p>
<p class="callout">Be aware that what we’ve seen throughout this chapter doesn’t completely cover everything there is to localizing your apps, such as localizing the app’s name or localizing images. Take a look at <a href="https://learn.microsoft.com/dotnet/maui/fundamentals/localization">https://learn.microsoft.com/dotnet/maui/fundamentals/localization</a> to find out more!</p>
<p>As we wrap up this chapter, we’ve truly come a long way in building the <em class="italic">Recipes!</em> app, while adhering to the MVVM principles. But, of course, no app development journey is complete without ensuring its robustness. And that’s where the next chapter comes in. We’ll dive into how MVVM isn’t just about structuring our app effectively, but also about setting the stage for thorough and effective unit testing.</p>
<h1 id="_idParaDest-202"><a id="_idTextAnchor222"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li>The <code>ResourceManager</code> class: <a href="https://learn.microsoft.com/dotnet/api/system.resources.resourcemanager?view=net-8.0">https://learn.microsoft.com/dotnet/api/system.resources.resourcemanager?view=net-8.0</a></li>
<li><em class="italic">XAML markup </em><em class="italic">extensions</em>: <a href="https://learn.microsoft.com/dotnet/maui/xaml/fundamentals/markup-extensions">https://learn.microsoft.com/dotnet/maui/xaml/fundamentals/markup-extensions</a></li>
<li><em class="italic">Create XAML markup </em><em class="italic">extensions</em>: <a href="https://learn.microsoft.com/dotnet/maui/xaml/markup-extensions/create">https://learn.microsoft.com/dotnet/maui/xaml/markup-extensions/create</a></li>
</ul>
</div>
</div></body></html>