- en: Surface Shaders and Texture Mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore the topic of Surface Shaders in greater detail
    than in the previous chapter. We will start from building a very simple matte
    material and end with holographic projections and the advanced blending of terrains.
    We will also see how you can use textures to animate, blend, and drive any other
    property that they like.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Diffuse shading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing and modifying packed arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a texture to a shader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scrolling textures by modifying UV values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a shader with normal mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a transparent material
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Holographic Shader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packing and blending textures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a circle around your terrain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Surface Shaders were introduced in [Chapter 2](part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08),
    *Creating Your First Shader*, as the main type of shader that's used in Unity.
    This chapter will show you in detail what these actually are and how they work.
    Generally speaking, there are two essential steps in every Surface Shader. First,
    you have to specify certain physical properties of the material that you want
    to describe, such as its diffuse color, smoothness, and transparency. These properties
    are initialized in a function called the **surface function** and are stored in
    a structure called the `SurfaceOutput`. Secondly, the `SurfaceOutput` is passed
    to a lighting model. This is a special function that will also take information
    about the nearby lights in the scene. Both of these parameters are then used to
    calculate the final color for each pixel of your model. The lighting function
    is where the real calculations of a shader take place as it's the piece of code
    that determines how light should behave when it touches a material.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram loosely summarizes how a Surface Shader works. Custom
    lighting models will be explored in [Chapter 4](part0107.html#361C60-e8c76c858d514bc3b1668fda96f8fa08),
    *Understanding Lighting Models*, while [Chapter 6](part0158.html#4MLOS0-e8c76c858d514bc3b1668fda96f8fa08),
    *Vertex Functions*, will focus on vertex modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Diffuse shading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before starting our journey into texture mapping, it is important to understand
    how diffuse materials work. Certain objects might have a uniform color and smooth
    surface, but are not smooth enough to shine in reflected light. These matte materials
    are best represented with a Diffuse Shader. While, in the real world pure diffuse
    materials do not exist, Diffuse Shaders are relatively cheap to implement and
    are largely applied in games with low-poly aesthetics, so they're worth learning
    about.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways in which you can create your own Diffuse Shader. A quick
    way is to start with Unity's Standard Surface Shader and edit it to remove any
    additional texture information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before starting this recipe, you should have created a Standard Surface Shader
    with the name `SimpleDiffuse`. For instructions on creating a Standard Surface
    Shader, look at the *Creating a basic Standard Surface Shader* recipe located
    in  [Chapter 2](part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08), *Creating
    Your First Shader, *if you haven't done so already.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open up the `SimpleDiffuse` shader you''ve created and make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Properties` section, remove all of the variables except for  `_Color`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: From the `SubShader{}` section, remove the `_MainTex`, `_Glossiness`, and `_Metallic`
    variables. You should not remove the reference to `uv_MainTex` as Cg does not
    allow the `Input` struct to be empty. The value will simply be ignored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, remove the `UNITY_INSTANCING_BUFFER_START/END` macros and the comments
    used with them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove the content of the `surf()` function and replace it with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Your shader should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The two lines below `CGPROGRAM` is actually one line and is cut off due to the
    size of the book.
  prefs: []
  type: TYPE_NORMAL
- en: As this shader has been refitted with a Standard Shader, it will use physically-based
    rendering to simulate how light behaves on your models.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are trying to achieve a non-photorealistic look, you can change the first
    `#pragma` directive so that it uses `Lambert` rather than `Standard`. If you do
    so, you should also replace the  `SurfaceOutputStandard` parameter of the `surf`
    function with `SurfaceOutput`. For more information on this and the other lighting
    models that Unity supports, Jordan Stevens put together a very nice article about
    it, which you can see here: [http://www.jordanstevenstechart.com/lighting-models](http://www.jordanstevenstechart.com/lighting-models)
  prefs: []
  type: TYPE_NORMAL
- en: Save the shader and dive back into Unity. Using the same instructions as in
    the *Creating a basic Standard Surface Shader* recipe located in  [Chapter 2](part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08), *Creating
    Your First Shader,* create a new material called `SimpleDiffuseMat` and apply
    our newly created shader to it. Change the color to something different, such
    as red, by clicking on the window next to the Color property in the Inspector window
    while selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, go into the `Models` folder of this book''s example code and bring the
    bunny object into our scene by dragging and dropping it from the Project window
    into the Hierarchy window. From there, assign the `SimpleDiffuseMat` material
    to the object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can double-click on an object in the Hierarchy tab in order to center the
    camera on the object that's been selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The way shaders allow you to communicate the rendering properties of your material
    to their lighting model is via their `SurfaceOutput`. It is basically a wrapper
    around all the parameters that the current lighting model needs. It should not
    surprise you that different lighting models have different `SurfaceOutput` structs.
    The following table shows the three main output structs used in Unity and how
    they can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type of shaders** | **Standard** | **Physically-Based Lighting Models**
    |'
  prefs: []
  type: TYPE_TB
- en: '| Diffuse | Any Surface Shader`SurfaceOutput` | Standard`SurfaceOutputStandard`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Specular | Any Surface Shader`SurfaceOutput` | Standard (Specular setup)`SurfaceOutputStandardSpecular`
    |'
  prefs: []
  type: TYPE_TB
- en: 'The `SurfaceOutput` struct has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fixed3 Albedo;`: This is the diffuse color of the material'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fixed3 Normal;`: This is the tangent space, normal, if written'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fixed3 Emission;`: This is the color of the light emitted by the material
    (this property is declared as `half3` in the Standard Shaders)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fixed Alpha;`: This is the transparency of the material'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`half Specular;`: This is the specular power from `0` to `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fixed Gloss;`: This is the specular intensity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `SurfaceOutputStandard` struct has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fixed3 Albedo;`: This is the base color of the material (whether it''s diffuse
    or specular)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fixed3 Normal;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`half3 Emission;`: This property is declared as `half3`, while it was defined
    as `fixed3` in `SurfaceOutput`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fixed Alpha;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`half Occlusion;`: This is the occlusion (default `1`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`half Smoothness;`: This is the smoothness (`0` = rough, `1` = smooth)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`half Metallic;`: `0` = non-metal, `1`= metal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `SurfaceOutputStandardSpecular` struct has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fixed3 Albedo;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fixed3 Normal;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`half3 Emission;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fixed Alpha;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`half Occlusion;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`half Smoothness;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fixed3 Specular;`: This is the specular color. This is very different from
    the `Specular` property in `SurfaceOutput` as it allows you to specify a color
    rather than a single value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a Surface Shader correctly is a matter of initializing the `SurfaceOutput`
    with the correct values.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on creating Surface Shaders, check out the following link: [https://docs.unity3d.com/Manual/SL-SurfaceShaders.html](https://docs.unity3d.com/Manual/SL-SurfaceShaders.html)
  prefs: []
  type: TYPE_NORMAL
- en: Accessing and modifying packed arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loosely speaking, the code inside a shader has to be executed for at least every
    pixel in your screen. This is the reason why GPUs are highly optimized for parallel
    computing; they can execute multiple processes at the same time. This philosophy
    is also evident in the standard type of variables and operators available in Cg.
    Understanding them is essential, not just so that you can use the shaders correctly,
    but also to write highly optimized ones.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two types of variables in Cg: single values and packed arrays. The
    latter can be identified because their type ends with a number such as `float3`
    or `int4`. As their names suggest, these types of variables are similar to structs,
    which means that they each contain several single values. Cg calls them packed
    arrays, though they are not exactly *arrays* in the traditional sense.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The elements of a packed array can be accessed as a normal struct. They are
    typically called `x`, `y`, `z`, and `w`. However, Cg also provides you with another
    alias for them, that is, `r`, `g`, `b`, and `a`. Despite there being no difference
    between using `x` or `r`, it can make a huge difference for the readers. Shader
    coding, in fact, often involves calculation with positions and colors. You might
    have seen this in the Standard Shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `o` was a struct and `_Color` was a packed array. This is also why Cg
    prohibits the mixed usage of these two syntaxes: you cannot use `_Color.xgz`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also another important feature of packed arrays that has no equivalent
    in C#: **swizzling**. Cg allows addressing and reordering elements within packed
    arrays in just a single line. Once again, this appears in the Standard Shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`Albedo` is `fixed3`, which means that it contains three values of the `fixed`
    type. However, `_Color` is defined as a  `fixed4` type.  A direct assignment would
    result in a compiler error as `_Color` is bigger than `Albedo`. The C# way of
    doing this would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it can be compressed in Cg:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Cg also allows reordering elements, for instance, using `_Color.bgr` to swap
    the red and blue channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, when a single value is assigned to a packed array, it is copied to
    all of its fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is referred to as **smearing**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swizzling can also be used on the left-hand side of an expression, allowing
    only certain components of a packed array to be overwritten:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, it is called **masking**.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Where swizzling really shows its full potential is when it''s applied to packed
    matrices. Cg allows types such as `float4x4`, which represents a matrix of floats
    with four rows and four columns. You can access a single element of the matrix
    using the `_mRC` notation, where *R* is the row and *C* is the column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_mRC` notation can also be chained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'An entire row can be selected using squared brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to being easier to write, swizzling, smearing, and masking properties
    have performance benefits as well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, inappropriate use of swizzling can also make your code harder to understand
    at first glance, and may make it harder for the compiler to automatically optimize
    your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packed arrays are one of the nicest features of Cg. You can discover more about
    them here: [http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter02.html](http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter02.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a texture to a shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Textures can bring our shaders to life very quickly in terms of achieving very
    realistic effects. In order to effectively use textures, we need to understand
    how a 2D image is mapped to a 3D model. This process is called texture mapping,
    and it requires some work to be done on the shader and 3D model that we want to
    use. Models, in fact, are made out of triangles, which are often referred to as
    polygons; each vertex on the model can store data that shaders can access and
    use to determine what to draw.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most important pieces of information that are stored in vertices
    is the **UV data**. It consists of two coordinates, *U* and *V*, ranging from
    0 to 1\. They represent the *XY* position of the pixel in the 2D image that will
    be mapped to the vertices. UV data is present only for vertices; when the inner
    points of a triangle have to be texture-mapped, the GPU interpolates the closest
    UV values to find the right pixel in the texture to be used. The following diagram
    shows you how a **2D Texture** is mapped to a triangle from a 3D model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The UV data is stored in the 3D model and requires modeling software to be edited.
    Some models lack the UV component, hence they cannot support texture mapping.
    The Stanford bunny, for example, was not originally provided with one.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, you'll need a 3D model with UV data and its texture. They both
    need to be imported to Unity before starting. You can do this simply by dragging
    them to the editor. As the Standard Shader supports texture mapping by default,
    we'll use this and then explain how it works in detail.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding a texture to your model using the Standard Shader is incredibly simple,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Sample Code for this chapter that's provided with this book, you can
    find the `basicCharacter` model which, by default, has UV information embedded
    into it, making it so that when we attach a material, it will draw the texture
    using that information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Standard Surface Shader called `TexturedShader` by going to the
    Project tab and then selecting Create | Shaders | Standard Surface Shader. Once
    created, you can type in a new name for the shader and then press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For organization''s sake, open the shader and change the first line to the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will allow us to find the shader inside of the organization we have been
    using so far for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new material called `TexturedMaterial` by going to the Project tab
    and then selecting Create | Material. Once created, you can type in a new name
    for the material and then press *Enter* to confirm the change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assign the shader to the material by going to the Inspector tab and then clicking
    on the Shader dropdown before selecting `CookbookShaders/Chapter 03/TexturedShader`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You may also do this by first selecting the material and then dragging the shader
    file over it in the Project tab.
  prefs: []
  type: TYPE_NORMAL
- en: 'After selecting the material, drag your texture to the empty rectangle called
    Albedo (RGB). If you are missing some, there are textures located in this chapter''s
    example code that can be used. If you have followed all of these steps correctly,
    your material Inspector tab should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Standard Shader knows how to map a 2D image to a 3D model using its UV models
    and textures used in this example were created by Kenney Vleugels and Casper Jorissen.
    You can find these and many other public domain game assets at [Kenney.nl](http://Kenney.nl).
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the UV data in action, in the example code''s `Models` folder, drag
    and drop the model into the Hierarchy tab. Once there, double-click on the newly
    created object to zoom in so that you can see the object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once there, you may go to the Project tab and open up the `Chapter 3 `| `Materials`
    folder and drag and drop our `Textured Material` onto the character. Note that
    the model consists of different objects, each of which provides direction to draw
    in a particular place. This means that you will need to drop the material on each
    part of the model (`ArmLeft1`, `ArmRight1`, `Body1`, and so on); trying to apply
    this to the top level of the hierarchy only (`basicCharacter`) will not work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is also possible to change what the object looks like by changing the texture
    that''s being used. For instance, if we use the other texture provided (`skin_womanAlternative`),
    we have a very different looking character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is often used in games to provide different kinds of characters with minimal
    cost.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the Standard Shader is used from the Inspector of a material, the process
    behind texture mapping is completely transparent to developers. If we want to
    understand how it works, it''s necessary to take a closer look at `TexturedShader`.
    From the `Properties` section, we can see that the `Albedo (RGB)` texture is actually
    referred to in the code as `_MainTex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `CGPROGRAM` section, this texture is defined as `sampler2D`, the standard
    type for 2D textures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line shows a `struct` called `Input`. This is the input parameter
    for the surface function and contains a packed array called `uv_MainTex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Every time the `surf()` function is called, the `Input` structure will contain
    the UV of `_MainTex` for the specific point of the 3D model that needs to be rendered.
    The Standard Shader recognizes that the name `uv_MainTex` refers to `_MainTex`
    and initializes it automatically. If you are interested in understanding how the
    UV is actually mapped from a 3D space to a 2D texture, you can check out [Chapter
    5](part0107.html#361C60-e8c76c858d514bc3b1668fda96f8fa08), *Understanding Lighting
    Models*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the UV data is used to sample the texture in the first line of the
    surface function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is done using the `tex2D()` function of Cg; it takes a texture and UV and
    returns the color of the pixel at that position.
  prefs: []
  type: TYPE_NORMAL
- en: The *U* and *V* coordinates go from *0* to *1*, where (0,0) and (1,1) correspond
    to two opposite corners. Different implementations associate UV with different
    corners; if your texture happens to appear reversed, try inverting the V component.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you import a texture to Unity, you are setting up some of the properties
    that `sampler2D` will use. The most important is the Filter mode, which determines
    how colors are interpolated when the texture is sampled. It is very unlikely that
    the UV data will point exactly to the center of a pixel; in all other cases, you
    might want to interpolate between the closest pixels to get a more uniform color.
    The following is a screenshot of the Inspector tab of an example texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For most applications, Bilinear provides an inexpensive, yet effective, way
    to smooth the texture. If you are creating a 2D game, however, Bilinear might
    produce blurred tiles. In this case, you can use Point to remove any interpolation
    from the texture sampling.
  prefs: []
  type: TYPE_NORMAL
- en: When a texture is seen from a steep angle, texture sampling is likely to produce
    visually unpleasant artifacts. You can reduce them by setting the Aniso Level
    to a higher value. This is particularly useful for floor and ceiling textures,
    where glitches can break the illusion of continuity.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you would like to know more about the inner workings of how textures are
    mapped to a 3D surface, you can read the information available at [http://developer.nvidia.com/CgTutorial/cg_tutorial_chapter03.html](http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter03.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a complete list of the options available when importing a 2D texture, you
    can refer to the following website: [http://docs.unity3d.com/Manual/class-TextureImporter.html](http://docs.unity3d.com/Manual/class-TextureImporter.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scrolling textures by modifying UV values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common texture techniques used in today's game industry is the
    process of allowing you to scroll the textures over the surface of an object.
    This allows you to create effects such as waterfalls, rivers, and lava flows.
    It's also a technique that is the basis of creating animated sprite effects, but
    we will cover this in a subsequent recipe of this chapter. First, let's see how
    we will create a simple scrolling effect in a Surface Shader.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin this recipe, you will need to create a new shader file (`ScrollingUVs`)
    and material (`ScrollingUVMat`). This will set us up with a nice clean shader
    that we can use to study the scrolling effect by itself.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin with, we will launch our new shader file that we just created and
    enter the code mentioned in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The shader will need two new properties that will allow us to control the speed
    of the texture scrolling. So, let''s add a speed property for the *X* direction
    and a speed property for the *Y* direction, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When working in ShaderLab, `Properties` has a syntax that looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Each property contained in the `Properties` block first has a name that is used
    in code to refer to the object, here specified as `_propertyName`. The underscore
    isn't required but is a common standard in place. Inside the parenthesis, you'll
    see two parameters. The first is a string that defines what text will be displayed
    in the Inspector for what this property is. The second parameter is the type of
    data we wish to store.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, for the *X* and *Y* Scroll Speed, we are creating a number with
    a possible Range from 0 to 10\. Lastly, we can initialize the property with a
    default value which is done on the end. As we've seen before, these properties
    will show up in the Inspector if you select a material that is using this shader.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on Properties and how to create them, check out [https://docs.unity3d.com/Manual/SL-Properties.html](https://docs.unity3d.com/Manual/SL-Properties.html).
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we don't need the `Smoothness` or `Metallic` properties, so
    we can remove them as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the Cg properties in the `CGPROGRAM` section above the definition of
    `_MainTex` and create new variables so that we can access the values from our
    properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We also need to remove the `_Glossiness` and `_Metallic` definitions as we are
    not using them anymore.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the surface function to change the UVs given to the `tex2D()` function.
    Then, use the built-in `_Time` variable to animate the UVs over time when the
    Play button is pressed in the editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the script is finished, save it and then go back to the Unity editor.
    Go to the `Materials` folder and assign `ScrollingUVsMat` to use our `ScrollingUVs`
    shader. Once that is done, under the Albedo (RGB) property, drag and drop the
    water texture from the example code provided with this book to assign the property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After this is created, we need to create an object that can use the shader.
    From a new scene, go ahead and select GameObject | 3D Object | Plane and drag
    and drop the `ScrollingUVMat` material onto it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once applied, go ahead and play the game to see the shader in action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: While it's not visible in this still image, you will notice that in the Unity
    editor, the object will now move in both the *X* and *Y* axes! Feel free to drag
    the X Scroll Speed and Y Scroll Speed properties in the Inspector tab to see how
    the changes affect how the object moves. Also, feel free to move the camera to
    make it easier to see if you would like.
  prefs: []
  type: TYPE_NORMAL
- en: If you modify a variable on a Material during gameplay, the value will stay
    changed, unlike how Unity typically works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pretty cool! With this knowledge, we can take this concept much further to
    create interesting visual effects. The following screenshot demonstrates the result
    of utilizing the scrolling UV system with multiple materials in order to create
    a simple river motion for your environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The scrolling system starts with the declaration of a couple of properties,
    which will allow the user of this shader to increase or decrease the speed of
    the scrolling effect itself. At their core, they are float values being passed
    from the material's Inspector tab to the surface function of the shader. For more
    information on shader properties, see [Chapter 2](part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08),
    *Creating Your First Shader*.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have these float values from the material's Inspector tab, we can use
    them to offset our UV values in the shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin this process, we first store the UVs in a separate variable called
    `scrolledUV`. This variable has to be `float2`/`fixed2` because the UV values
    are being passed to us from the `Input` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Once we have access to the mesh's UVs, we can offset them using our scroll speed
    variables and built-in `_Time` variable. This built-in variable returns a variable
    of the `float4` type, meaning that each component of this variable contains different
    values of time as it pertains to game time.
  prefs: []
  type: TYPE_NORMAL
- en: 'A complete description of these individual time values is described at the
    following link: [http://docs.unity3d.com/Manual/SL-UnityShaderVariables.html](http://docs.unity3d.com/Manual/SL-UnityShaderVariables.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This `_Time` variable will give us an incremented float value based on Unity''s
    game time clock. So, we can use this value to move our UVs in a UV direction and
    scale that time with our scroll speed variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With the correct offset being calculated by time, we can add the new offset
    value back to the original UV position. This is why we are using the `+=` operator
    in the next line. We want to take the original UV position, add the new offset
    value, and then pass this to the `tex2D()` function as the texture''s new UVs.
    This creates the effect of the texture moving on the surface. What we are really
    doing is manipulating the UVs, so we are faking the effect of the texture moving:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Creating a shader with normal mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every triangle of a 3D model has a *facing direction*, which is the direction
    that it is pointing toward. It is often represented with an arrow placed in the
    center of the triangle and is orthogonal to the surface. The facing direction
    plays an important role in the way light reflects on a surface. If two adjacent
    triangles face different directions, they will reflect lights at different angles,
    hence they''ll be shaded differently. For curved objects, this is a problem: it
    is obvious that the geometry is made out of flat triangles.'
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this problem, the way the light reflects on a triangle doesn't take
    into account its facing direction, but its *normal direction* instead. As stated
    in the *Adding a texture to a shader* recipe, vertices can store data; the normal
    direction is the most used information after the UV data. This is a vector of
    unit length (which means it has a length of 1) that indicates the direction faced
    by the vertex.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the facing direction, every point within a triangle has its own
    normal direction that is a linear interpolation of the ones stored in its vertices.
    This gives us the ability to fake the effect of high-resolution geometry on a
    low-resolution model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the same geometric shape rendered with different
    per-vertex normals. In the image, on the left, normals are orthogonal to the face
    represented by its vertices; this indicates that there is a clear separation between
    each face. On the right, normals are interpolated along the surface, indicating
    that even if the surface is rough, a light should reflect as if it''s smooth.
    It''s easy to see that even if the three objects in the following screenshot share
    the same geometry, they reflect light differently. Despite being made out of flat
    triangles, the object on the right reflects light as if its surface was actually
    curved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Smooth objects with rough edges are a clear indication that per-vertex normals
    have been interpolated. This can be seen if we draw the direction of the normal
    stored in every vertex, as shown in the following screenshot. You should note
    that every triangle has only three normals, but as multiple triangles can share
    the same vertex, more than one line can come out of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Calculating the normals from the 3D model is a technique that has rapidly declined
    in favor of a more advanced one-normal mapping. Similar to what happens with texture
    mapping, the normal directions can be provided using an additional texture, usually
    called a normal map or bump map.
  prefs: []
  type: TYPE_NORMAL
- en: Normal maps are usually images where the red, green, and blue channels of the
    image are used to indicate the *X*, *Y*, and *Z* components of the normal direction.
    There are many ways to create normal maps these days. Some applications, such
    as CrazyBump ([http://www.crazybump.com/](http://www.crazybump.com/)) and NDO
    Painter ([http://quixel.se/ndo/](http://quixel.se/ndo/)), will take in 2D data
    and convert it to normal data for you. Other applications such as Zbrush 4R7 ([http://www.pixologic.com/](http://www.pixologic.com/))
    and AUTODESK ([http://usa.autodesk.com](http://usa.autodesk.com/)) will take 3D-sculpted
    data and create normal maps for you. The actual process of creating normal maps
    is out of the scope of this book, but the links in the previous text should help
    you get started.
  prefs: []
  type: TYPE_NORMAL
- en: Unity makes the process of adding normals to your shaders quite an easy process
    in the Surface Shader realm using the `UnpackNormals()` function. Let's see how
    this is done.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin this recipe, first create a new scene by selecting File | New Scene.
    Then, create a sphere game object by going to GameObject | 3D Objects | Sphere.
    Double-click on the object in the Hierarchy tab to bring the object into focus
    in the Scene tab. You will also need to create a new standard Surface Shader file
    (`NormalShader`) and material (`NormalShaderMat`). Once created, set the material
    to a sphere in the Scene view. This will give us a clean workspace in which we
    can look at just the normal mapping technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You will need a normal map for this recipe, but there is also one in the Unity
    project included with this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example normal map included with this book''s content is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can see it for yourself in the `Assets `|  `Chapter 03 `| `Textures` folder
    under `normalMapExample`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the steps to create a normal map shader:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get the `Properties` block set up in order to have a color `Tint` and
    texture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this case, I have 1 in the green and alpha channels and `0` for red and blue,
    so the default color will be green. For the `_NormalTex` property, we are using
    a 2D type, which means we can use a 2D image to dictate what each pixel will use.
    By initializing the texture as `bump`, we are telling Unity that `_NormalTex` will
    contain a normal map (sometimes referred to as bump maps as well, hence the bump
    name). If the texture is not set, it will be replaced by a grey texture. The color
    used (`0.5`, `0.5`, `0.5`, `1`) indicates no bump at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `SubShader{}` block, scroll below the `CGPROGRAM` statement and remove
    the original `_MainText`,  `_Glossiness`, `_Metallic`, and `_Color` definitions.
    Afterward, add in our `_NormalTex` and `_MainTint`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to make sure that we update the `Input` struct with the proper variable
    name so that we can use the model''s UVs for the normal map texture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we extract the normal information from the normal map texture using
    the built-in `UnpackNormal()` function. Then, you only have to apply these new
    normals to the output of the Surface Shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Save your script and return to the Unity editor. You should notice that the
    sphere has now become green by default if added. More importantly though, notice
    the Normal Map property that has been added. Drag and drop the normal map texture
    into the slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may notice some changes, but it may be hard to visually see what is going
    on. In the Normal Map property, change the Tiling to (`10`, `10`). This way, you
    can see the normal map duplicated 10 times over the course of the sphere in the
    *X* and *Y* axes instead of only once:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot demonstrates the result of our normal map shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Shaders can have both a texture map and a normal map. It is not uncommon to
    use the same UV data to address both. However, it is possible to provide a secondary
    set of UVs in the vertex data (UV2), which are specifically used for the normal
    map.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The actual math to perform the normal mapping effect is definitely beyond the
    scope of this chapter, but Unity has done it all for us already. It has created
    the functions for us so that we don't have to keep doing it over and over again.
    This is another reason why Surface Shaders are a really efficient way to write
    shaders.
  prefs: []
  type: TYPE_NORMAL
- en: If you look in the `UnityCG.cginc` file found in the `Editor` | `Data`| `CGIncludes`
    folder in your Unity installation directory, you will find the definitions for
    the `UnpackNormal()` function. When you declare this function in your Surface
    Shader, Unity takes the normal map provided and processes it for you, giving you
    the correct type of data so that you can use it in your per-pixel lighting function.
    It's a huge time-saver! When sampling a texture, you get RGB values from `0` to
    `1`; however, the directions of a normal vector range from `-1` to `1`. `UnpackNormal()`
    brings these components into the right range.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have processed the normal map with the `UnpackNormal()` function, you
    send it back to your `SurfaceOutput` struct so that it can be used in the lighting
    function. This is done by using `o.Normal = normalMap.rgb;`. We will see how the
    normal is actually used to calculate the final color of each pixel in [Chapter
    4](part0107.html#361C60-e8c76c858d514bc3b1668fda96f8fa08), *Understanding Lighting
    Models*.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also add some controls to your normal map shader that lets a user adjust
    the intensity of the normal map. This is easily done by modifying the `x` and
    `y` components of the normal map variable and then adding it all back together.
    Add another property to the `Properties` block and name it `_NormalMapIntensity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we are giving the property the ability to be between `0` and
    `3` with a default value of `1`. Once created, you''ll need to add the variable
    inside the SubShader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'After the property is added, we can make use of it. Multiply the `x` and `y`
    components of the unpacked normal map and reapply this value to the normal map
    variable with the bolded changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Normal vectors are supposed to have lengths equal to one. Multiplying them for `_NormalMapIntensity` changes
    their length, making normalization necessary. The normalize function will take
    the vector and adjust it so that it is pointing in the correct direction but with
    a length of one, which is what we are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can let a user adjust the intensity of the normal map in the material''s
    Inspector tab, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the result of modifying the normal map with
    our scalar values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a transparent material
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the shaders we have seen so far have something in common; they are used
    for solid materials. If you want to improve the look of your game, transparent
    materials are often a good way to start. They can be used for anything from a
    fire effect to a glass window. Working with them, unfortunately, is slightly more
    complicated. Before rendering solid models, Unity orders them according to the
    distance from the camera (*Z ordering*) and skips all the triangles that are facing
    away from the camera (**culling**). When rendering transparent geometries, there
    are instances in which these two aspects can cause problems. This recipe will
    show you how to solve some of these issues when it comes to creating a transparent
    Surface Shader. This topic will be heavily revisited in [Chapter 7](part0188.html#5J99O0-e8c76c858d514bc3b1668fda96f8fa08),
    *Fragment Shaders and Grab Passes*, where realistic glass and water shaders will
    be provided.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe requires a new shader, which we''ll be calling `Transparent`, and
    a new material (`TransparentMat`) so that it can be attached to an object. As
    this is going to be a transparent glass window, a quad or plane is perfect (GameObject
    | 3D Objects | Quad). We will also need several other non-transparent objects
    to test the effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, we will use a PNG image file for the glass texture since it
    has support for an alpha channel that will be used to determine the transparency
    of the glass. The process of creating such an image depends on the software that
    you are using. However, these are the main steps that you will need to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the image of the glass you want for your windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open it with a photo editing software, such as *GIMP* or *Photoshop*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the parts of the image that you want to be semi-transparent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a white (full opacity) layer mask on your image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the selection previously made to fill the layer mask with a darker color.
    White is treated as fully visible, black will be treated as invisible, and grey
    will be somewhere in the middle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the image and import it into Unity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The toy image used in this recipe is a picture of stained glass from the *Meaux
    Cathedral *in *France* ([https://en.wikipedia.org/wiki/Stained_glass](https://en.wikipedia.org/wiki/Stained_glass)).
    If you have followed all of these steps, your image should look like this (**RGB**
    channels on the left, and **A** channel on the right):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can also make use of the image file in provided the example code for this
    book in `Chapter 3 `| `Textures` folder (`Meaux_Vitrail.psd`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Attaching this image to the material will cause the image to show up, but we
    cannot see it behind the glass:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As we would like to see behind this, we can make adjustments to the shader to
    do exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned previously, there are a few aspects that we need to take care
    of while using a Transparent Shader:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the `_Glossiness` and `_Metallic` variables from the `Properties` and
    `SubShader` sections of the code as they aren't needed for this example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `SubShader{}` section of the shader, modify the `Tags` section to the
    following so that we can signal that the shader is transparent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Tags are used by the `SubShader` to know how and when items should be rendered.
    Similar to the dictionary type, tags are key-value pairs where the left-hand side
    is the tag name and the right-hand side is the value you wish for it to be set
    to.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on tags in ShaderLab, check out: [https://docs.unity3d.com/Manual/SL-SubShaderTags.html](https://docs.unity3d.com/Manual/SL-SubShaderTags.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'As this shader is designed for 2D materials, make sure that the back geometry
    of your model is not drawn by adding the following below the `LOD 200` line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Tell the shader that this material is transparent and needs to be blended with
    what was drawn on the screen before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Use this Surface Shader to determine the final color and transparency of the
    glass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterward, save your script and dive back to the Unity editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that you can now see the cube behind the glass. Perfect!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This shader introduces several new concepts. First of all, `Tags` are used to
    add information about how the object is going to be rendered. The really interesting
    one here is `Queue`. Unity, by default, will sort your objects for you based on
    the distance from the camera. So, as an object gets nearer to the camera, it is
    going to be drawn over all the objects that are further away from the camera.
    For most cases, this works out just fine for games, but you will find yourself
    in certain situations where you will want to have more control over the sorting
    of your objects in your scene. Unity has provided us with some default render
    queues, each with a unique value that directs Unity when to draw the object to
    the screen. These built-in render queues are called `Background`, `Geometry`,
    `AlphaTest`, `Transparent`, and `Overlay`. These queues weren't just created arbitrarily;
    they actually serve a purpose to make our lives easier when writing shaders and
    interacting with the real-time renderer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following table for descriptions on the usage of each of these
    individual render queues:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Render queue** | **Render queue description** | **Render queue value**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Background` | This render queue is rendered first. It is used for skyboxes
    and so on. | `1000` |'
  prefs: []
  type: TYPE_TB
- en: '| `Geometry` | This is the default render queue. This is used for most objects.
    Opaque geometry uses this queue. | `2000` |'
  prefs: []
  type: TYPE_TB
- en: '| `AlphaTest` | Alpha-tested geometry uses this queue. It''s different from
    the `Geometry` queue as it''s more efficient to render alpha-tested objects after
    all the solid objects are drawn. | `2450` |'
  prefs: []
  type: TYPE_TB
- en: '| `Transparent` | This render queue is rendered after `Geometry` and `AlphaTest`
    queues in back-to-front order. Anything alpha-blended (that is, shaders that don''t
    write to the depth buffer) should go here, for example, glass and particle effects.
    | `3000` |'
  prefs: []
  type: TYPE_TB
- en: '| `Overlay` | This render queue is meant for overlay effects. Anything rendered
    last should go here, for example, lens flares. | `4000` |'
  prefs: []
  type: TYPE_TB
- en: So, once you know which render queue your object belongs to, you can assign
    its built-in render queue tag. Our shader used the `Transparent` queue, so we
    wrote `Tags{"Queue"="Transparent"}`.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that the `Transparent` queue is rendered after `Geometry` does *not*
    mean that our glass will appear on top of all the other solid objects. Unity will
    draw the glass last, but it will not render pixels that belong to pieces of geometry
    hidden behind something else. This control is done using a technique called **ZBuffering**.
    More information on how models are rendered can be found at the following link: [http://docs.unity3d.com/Manual/SL-CullAndDepth.html](http://docs.unity3d.com/Manual/SL-CullAndDepth.html).
  prefs: []
  type: TYPE_NORMAL
- en: The `IgnoreProjector` tag makes this object unaffected by Unity's projectors.
    Lastly, `RenderType` plays a role in **shader replacement**, a topic that will
    be covered briefly in [Chapter 10](part0246.html#7AJAC0-e8c76c858d514bc3b1668fda96f8fa08),
    *Gameplay and Screen Effects*.
  prefs: []
  type: TYPE_NORMAL
- en: The last concept introduced is `alpha:fade`. This indicates that all the pixels
    from this material have to be blended with what was on the screen before according
    to their alpha values. Without this directive, the pixels will be drawn in the
    correct order, but they won't have any transparency.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Holographic Shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'More and more space-themed games are being released every year. An important
    part of a good sci-fi game is the way futuristic technology is presented and integrated
    into gameplay. There''s nothing that screams futuristic more than holograms. Despite
    being present in many flavors, holograms are often represented as semi-transparent,
    thin projections of an object. This recipe shows you how to create a shader that
    simulates such effects. Take this as a starting point: you can add noise, animated
    scan lines, and vibrations to create a truly outstanding holographic effect. The
    following screenshot shows an example of a Holographic effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a shader called `Holographic`. Attach it to a material (`HolographicMat`)
    and assign it to a 3D model in your scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following changes will change our existing shader into a holographic one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the following properties as they will not be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`_Glossiness`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_Metallic`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the following property to the shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Add its respective variable to the `CGPROGRAM` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As this material is transparent, add the following tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: According to the type of object that you will use, you might want its backside
    to appear. If this is the case, add `Cull Off` so that the back of the model won't
    be removed (*culled*).
  prefs: []
  type: TYPE_NORMAL
- en: 'This shader is not trying to simulate a realistic material, so there is no
    need to use the PBR lighting model. **Lambertian reflectance**, which is very
    cheap, is used instead. Additionally, we should disable any lighting with `nolighting`
    and signal to Cg that this is a Transparent Shader using `alpha:fade`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the `Input` structure so that Unity will fill it with the current view
    direction and the world normal direction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following surface function. Remember that since this shader is using
    Lambertian reflectance as its lighting function, the name of the `SurfaceOutput`
    structure should be changed accordingly to `SurfaceOutput` instead of `SurfaceOutputStandard`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Save your script and dive into Unity. From there, change the Color property
    in the HolographicMat and see your hologram come to life:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can now use the Rim effect slider to choose the strength of the holographic
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned previously, this shader works by showing only the silhouette of
    an object. If we look at the object from another angle, its outline will change.
    Geometrically speaking, the edges of a model are all those triangles whose *normal
    direction* is orthogonal (90 degrees) to the current *view direction*. The `Input`
    structure declares these parameters, `worldNormal` and `viewDir`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The problem of understanding when two vectors are orthogonal can be solved using `_DotProduct`.
    This is an operator that takes two vectors and returns zero if they are orthogonal.
    We use `_DotProduct` to determine how close to zero the `_DotProduct` has to be
    for the triangle to fade completely.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second aspect that is used in this shader is the gentle fading between
    the edge of the model (fully visible) and the angle determined by `_DotProduct`
    (invisible). This linear interpolation is effected as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the original `alpha` from the texture is multiplied with the newly
    calculated coefficient to achieve the final look.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This technique is very simple and relatively inexpensive, and yet it can be
    used for a large variety of effects, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The slightly colored atmosphere of a planet in sci-fi games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The edge of an object that has been selected or is currently under the mouse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A ghost or specter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smoke coming out of an engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The shockwave of an explosion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bubble shield of a spaceship under attack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `_DotProduct` plays an important role in the way reflections are calculated.
    [Chapter 4](part0107.html#361C60-e8c76c858d514bc3b1668fda96f8fa08), *Understanding
    Lighting Models*, will explain in detail how it works and why it is widely used
    in so many shaders.
  prefs: []
  type: TYPE_NORMAL
- en: Packing and blending textures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Textures are useful for storing not only loads of data, not just pixel colors
    as we generally tend to think of them, but also for multiple sets of pixels in
    both the *x* and *y* directions and RGBA channels. We can actually pack multiple
    images into a single RGBA texture and use each of the R, G, B, and A components
    as individual textures themselves by extracting each of these components from
    the shader code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of packing individual grayscale images into a single RGBA texture
    can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Why is this helpful? Well, in terms of the amount of actual memory that your
    application takes up, textures are a large portion of your application's size.
    We can, of course, reduce the size of the image, but then we would lose details
    in how it can be represented. So, to begin reducing the size of your application,
    we can look at all of the images that we are using in our shader and see if we
    can merge these textures into a single texture. Using a single texture with multiple
    images in them requires fewer draw calls and less overhead than separate files.
    We can also use this concept to combine irregularly shaped textures (that being,
    those that are not squares) into a single one to take up less space than giving
    them their own full texture.
  prefs: []
  type: TYPE_NORMAL
- en: Any texture that is grayscale can be packed into one of the RGBA channels of
    another texture. This might sound a bit odd at first, but this recipe is going
    to demonstrate one of the uses of packing a texture and using these packed textures
    in a shader.
  prefs: []
  type: TYPE_NORMAL
- en: One example of using these packed textures is when you want to blend a set of
    textures together onto a single surface. You see this most often in terrain type
    shaders, where you need to blend into another texture nicely using some sort of
    control texture or the packed texture, in this case. This recipe covers this technique
    and shows you how to construct the beginnings of a nice four-texture blended terrain
    shader.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a new shader file in your `Shaders` folder (`TextureBlending`)
    and then create a new material for this shader (`TextureBlendingMat`). The naming
    convention is entirely up to you for your shader and material files, so try your
    best to keep them organized, and easy to reference later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have your shader and material ready, create a new scene in which we
    can test our shader. Inside to the scene, place the `Terrain_001` object from
    the `Chapter 3 `| `Models` folder and assign the `TextureBlendingMat` material
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You will also need to gather up four textures that you would want to blend together.
    These can be anything, but for a nice terrain shader, you will want grass, dirt,
    rocky dirt, and rock textures. You can find these assets in `Chapter 1 `| `Standard
    Assets `| `Environment `| `TerrainAssets `| `SurfaceTextures` folder in the example
    code for this book.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will also need a blending texture that is packed with grayscale
    images. This will give us the four blending textures that we can use to direct
    how the color textures will be placed on the object surface.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use very intricate blending textures to create a very realistic distribution
    of terrain textures over a terrain mesh, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s learn how to use packed textures by entering the code shown in the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add a few properties to our `Properties` block. We will need five
    `sampler2D` objects, or textures, and two `Color` properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As always, remove the properties we are not using from the base shader from
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then need to create the `SubShader{}` section variables that will be our
    link to the data in the `Properties` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to the number of items inside of our shader, we will need to update the
    target level version of our shader model to `3.5`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For more information on Shader Compilation Target Levels, check out: [https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html](https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now we have our texture properties and we are passing them to our `SubShader{}`
    function. In order to allow the user to change the tiling rates on a per-texture
    basis, we will need to modify our `Input` struct. This will allow us to use the
    tiling and offset parameters on each texture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `surf()` function, get the texture information and store it in its own
    variables so that we can work with the data in a clean, easy-to-understand way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Remember that due to us using Lambert, we will be using `SurfaceOutput` instead
    of `SurfaceOutputStandard` for the `surf` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s blend each of our textures together using the `lerp()` function. It
    takes three arguments, `lerp(value : a, value : b,` and `blend: c)`. The `lerp()`
    function takes in two textures and blends them with the float value given in the
    last argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we multiply our blended texture by the color tint values and use the
    red channel to determine where the two different terrain tint colors go:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Save your script and go back into Unity. Once there, you can assign the `TerrainBlend`
    texture to the Blend Texture property. Once you''ve done that, place different
    textures in the different channels in order to see our script in action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This effect can be taken even further by using different textures and terrain
    tinting to create some great looking terrains with minimal effort. The result
    of blending together four terrain textures and creating a terrain tinting technique
    can be seen in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This might seem like quite a few lines of code, but the concept behind blending
    is actually quite simple. For the technique to work, we have to employ the built-in
    `lerp()` function from the `CgFX` standard library. This function allows us to
    pick a value between argument one and argument two using argument three as the
    blend amount:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `lerp(a, b, f )` | This involves linear interpolation:*(1 - f )* a + b *
    f*Here, `a` and `b` are matching vector or scalar types. The `f` parameter can
    be either a scalar or vector of the same type as `a` and `b`. |'
  prefs: []
  type: TYPE_TB
- en: So, for example, if we wanted to find the mid-value between `1` and `2`, we
    could feed the value `0.5` as the third argument to the `lerp()` function and
    it would return the value `1.5`. This works perfectly for our blending needs as
    the values of an individual channel in an RGBA texture are single float values,
    usually in the range of `0` to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: In the shader, we simply take one of the channels from our Blend Texture and
    use it to drive the color that is picked in a `lerp()` function for each pixel.
    For instance, we take our grass texture and dirt texture, use the red channel
    from our blending texture, and feed this to a `lerp()` function. This will give
    us the correct blended color result for each pixel on the surface.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more visual representation of what is happening when using the `lerp()` function
    is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The shader code simply uses the four channels of the Blend Texture and all the
    color textures to create a final Blended Texture. This final texture then becomes
    the color that we can multiply with our diffuse lighting.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a circle around your terrain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many RTS games display distances (range attack, moving distance, sight, and
    so on) by drawing a circle around the selected unit. If the terrain is flat, this
    can be done simply by stretching a quad with the texture of a circle. If that's
    not the case, the quad will most likely be clipped behind a hill or another piece
    of geometry. This recipe will show you how to create a shader that allows you
    to draw circles around an object of arbitrary complexity. If you want to be able
    to move or animate your circle, we will need both a shader and C# script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows an example of drawing a circle in a hilly region
    using a shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Despite working with every piece of geometry, this technique is oriented to
    terrains. Hence, the first step is setting up a terrain in Unity, but instead
    of using a model, we will create one within the Unity editor:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating a new shader called `RadiusShader` and the respective
    material, `RadiusMat`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have the character for your object ready; we will draw a circle around it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the menu, navigate to GameObject | 3D Object | Terrain to create a new
    terrain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the geometry for your terrain. You can either import an existing one
    or draw your own using the tools available (Raise/Lower Terrain, Paint Height, Smooth
    Height).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The terrains are special objects in Unity, and the way texture mapping works
    on them is different from traditional 3D models. You cannot provide `_MainTex`
    from a shader as it needs to be provided directly from the terrain itself. To
    do this, select Paint Texture and then click on Add Texture...:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The creation  of a terrain isn't covered in this book, but if you would like
    to learn more about it, check out the following link: [https://docs.unity3d.com/Manual/terrain-UsingTerrains.html](https://docs.unity3d.com/Manual/terrain-UsingTerrains.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the texture is set, you have to change the material of the terrain
    so that a custom shader can be provided. From Terrain Settings, change the Material
    property to `Custom`, and then drag the Radius material to the `Custom Material`
    box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You are now ready to create your shader.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by editing the `RadiusShader` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the new shader, remove the `_Glossiness` and `_Metallic` properties and
    add these four properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Add their respective variables to the `CGPROGRAM` section, remembering to remove
    the declaration of `_Glossiness` and `_Metallic`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`Input` to our surface function requires not only the UV of the texture but
    also the position (in world coordinates) of every point of the terrain. We can
    retrieve this parameter by changing the `struct Input ` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we use this surface function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'These steps are all it takes to draw a circle on your terrain. You can use
    the material''s Inspector tab to change the position, radius, and color of the
    circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Moving the circle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is great, but you''ll likely also want to change where the circle is at
    run-time, which we can do via code. If you want the circle to follow your character,
    other steps are necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new C# script called `SetRadiusProperties`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since you may wish to see this change both in the game and outside, we can
    add a tag to the top of the class saying to execute this code while in the editor,
    in addition to when the game is being played, by adding the following tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Add these properties to the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Update()` method, add these lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Attach the script to the object you wish to have the circle drawn around.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, drag the `RadiusMat` material to the Radius Material slot of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can now move your character around and this will create a nice circle around
    it. Changing the properties of the `Radius` script will change the radius as well.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The relevant parameters to draw a circle are its center, radius, and color.
    They are all available in the shader with the names `_Center`, `_Radius`, and
    `_RadiusColor`. By adding the `worldPos` variable to the `Input` structure, we
    are asking Unity to provide us with the position of the pixel that we are drawing
    expressed in world coordinates. This is the actual position of an object in the
    editor.
  prefs: []
  type: TYPE_NORMAL
- en: The `surf()` function is where the circle is actually drawn. It calculates the
    distance from the point being drawn and the center of the radius, and then it
    checks whether it is between `_Radius` and `_Radius + _RadiusWidth`; if this is
    the case, it uses the chosen color. In the other case, it just samples the texture
    map like all the other shaders we have seen so far.
  prefs: []
  type: TYPE_NORMAL
