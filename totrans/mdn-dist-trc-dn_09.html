<html><head></head><body>
<div id="_idContainer104">
<h1 class="chapter-number" id="_idParaDest-149"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-150"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.2.1">Best Practices</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapters, we focused on how to collect, enrich, correlate, and use individual telemetry signals. </span><span class="koboSpan" id="kobo.3.2">In this chapter, we’re going to discuss what information to collect and how to represent it efficiently using all the available signals. </span><span class="koboSpan" id="kobo.3.3">We’ll start by providing recommendations on how to pick a suitable telemetry signal and suggest cross-signal cost optimization strategies. </span><span class="koboSpan" id="kobo.3.4">Finally, we’ll explore about OpenTelemetry semantic conventions and use them to create consistent telemetry supported by most </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">observability vendors.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">You’ll learn how to do </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Find telemetry signals that work for </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">your scenarios</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Control telemetry costs with aggregation, sampling, </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">and verbosity</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Follow common practices when reporting telemetry with OpenTelemetry </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">semantic conventions</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.13.1">By the end of this chapter, you will be able to use existing semantics for common technologies or create your own cross-signal and </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">cross-service conventions.</span></span></p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.15.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.16.1">There are no specific requirements for this chapter, and there are no associated code </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">files either.</span></span></p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.18.1">Choosing the right signal</span></h1>
<p><span class="koboSpan" id="kobo.19.1">When we discussed</span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.20.1"> individual telemetry signals in </span><em class="italic"><span class="koboSpan" id="kobo.21.1">Chapters 6</span></em><span class="koboSpan" id="kobo.22.1"> to </span><em class="italic"><span class="koboSpan" id="kobo.23.1">8</span></em><span class="koboSpan" id="kobo.24.1">, we provided suggestions on when to use each of them. </span><span class="koboSpan" id="kobo.24.2">Let’s do a </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">quick recap:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.26.1">Distributed traces</span></strong><span class="koboSpan" id="kobo.27.1"> describe individual network calls and other interesting operations in detail. </span><span class="koboSpan" id="kobo.27.2">Spans have causal relationships, allowing us to understand the request flow in </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">distributed systems.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.29.1">Traces document the request flow through the system and are essential for investigating errors or outliers in the long tail of latency distribution. </span><span class="koboSpan" id="kobo.29.2">Traces provide means to correlate other </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">telemetry signals.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.31.1">Metrics</span></strong><span class="koboSpan" id="kobo.32.1"> collect aggregated data with low-cardinality attributes and provide a low-resolution view of the overall system state. </span><span class="koboSpan" id="kobo.32.2">They help optimize telemetry collection and reduce storage costs and </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">query time.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.34.1">Events</span></strong><span class="koboSpan" id="kobo.35.1"> provide highly structured information about individual occurrences of important things. </span><span class="koboSpan" id="kobo.35.2">The key difference between spans and events is that spans have unique contexts and describe something </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">that lasts.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.37.1">Events have high-cardinality attributes and can help answer ad hoc questions about system behavior </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">and usage.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.39.1">Logs</span></strong><span class="koboSpan" id="kobo.40.1"> provide details about operations in a human-readable and less </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">structured format.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.42.1">They are useful for</span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.43.1"> debugging things when other signals don’t provide enough information. </span><span class="koboSpan" id="kobo.43.2">Also, logs are the only signal that </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">supports verbosity.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.45.1">Profiles</span></strong><span class="koboSpan" id="kobo.46.1"> are low-level performance data describing individual operations within a single process that helps optimize performance and identify </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">resource bottlenecks.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.48.1">When instrumenting some specific scenario, we usually need a combination </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">of signals.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">For example, to get observability into network calls, we need traces to ensure we can track the request flow across services and correlate other signals. </span><span class="koboSpan" id="kobo.50.2">Logs are necessary to record exceptions and warnings, describe local operations, and provide debug-level data for complicated investigations. </span><span class="koboSpan" id="kobo.50.3">Finally, we may need metrics to record non-sampled measurements, optimize collection, and reduce </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">query time.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.52.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.53.1">Before thinking about signals, we should have an idea of what information we want to be available, how we’re going to use it, how fast and frequently we need it, how many details we want to capture, for how long we need it, how much we can afford, and the </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">downtime cost.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">The answers to these questions should shape our decisions </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">around observability.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">Essentially, we have multiple trade-offs between having enough data to investigate issues fast and the cost of the observability solution. </span><span class="koboSpan" id="kobo.57.2">For example, collecting too many traces would give us all the details we need to investigate all sorts of issues. </span><span class="koboSpan" id="kobo.57.3">It would have a noticeable performance impact and significantly increase observability backend costs. </span><span class="koboSpan" id="kobo.57.4">As a result, traces might become so deep and detailed that it would be hard to understand where</span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.58.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">problems are.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">The conversation about a good set of telemetry signals is not possible without talking about costs. </span><span class="koboSpan" id="kobo.60.2">Let’s see how we can </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">control them.</span></span></p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.62.1">Getting more with less</span></h1>
<p><span class="koboSpan" id="kobo.63.1">Since we usually need to</span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.64.1"> collect multiple signals about the same component, we need to be able to tune them individually, depending on </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">our needs.</span></span></p>
<p><span class="koboSpan" id="kobo.66.1">The key is to reduce the volume of expensive, but not essential, data, potentially replacing it with cheaper options while keeping the system observable. </span><span class="koboSpan" id="kobo.66.2">We saw how we can do this by combining hot and cold storage or changing the retention period in </span><a href="B19423_08.xhtml#_idTextAnchor131"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.67.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.68.1">, </span><em class="italic"><span class="koboSpan" id="kobo.69.1">Writing Structured and Correlated Logs</span></em><span class="koboSpan" id="kobo.70.1">. </span><span class="koboSpan" id="kobo.70.2">Here, let’s focus on the </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">collection side.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">While observability vendors have different pricing models, it’s common for them to bill for traces, logs, and events depending on the volume, and for metrics depending on the number of time series. </span><span class="koboSpan" id="kobo.72.2">Queries (or API calls) can also be charged for and may have </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">concurrency limits.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">Of course, we can always add or remove instrumentations or stop writing logs and events, but there are a few more factors affecting how much telemetry </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">is collected:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.76.1">We can control tracing volume with the sampling rate and by adding or removing </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">new attributes</span></span></li>
<li><span class="koboSpan" id="kobo.78.1">To control the number of metric time series, we can add or remove resource attributes or drop dimensions </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">or instruments</span></span></li>
<li><span class="koboSpan" id="kobo.80.1">We can tune logging verbosity for individual categories or do so globally and add or </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">remove attributes</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.82.1">Applications’ needs may vary, depending on their maturity, the number of changes, the downtime they</span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.83.1"> can afford, and other factors – let’s go through several examples to demonstrate possible compromises they </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">can apply.</span></span></p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.85.1">Building a new application</span></h2>
<p><span class="koboSpan" id="kobo.86.1">When writing</span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.87.1"> the first version of an application, telemetry</span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.88.1"> can play a critical role in helping teams investigate issues and move faster. </span><span class="koboSpan" id="kobo.88.2">The interesting part here is that we don’t know which type of telemetry we need and how we’re going to </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">use it.</span></span></p>
<p><span class="koboSpan" id="kobo.90.1">We can leverage existing instrumentations that allow us to focus our efforts on building the application and having all means to debug it as it evolves, while also finding answers to questions about telemetry we </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">outlined before.</span></span></p>
<p><span class="koboSpan" id="kobo.92.1">The initial stages are a great time to design the observability story and it makes sense to start with the most flexible signals – traces, events, and logs. </span><span class="koboSpan" id="kobo.92.2">Initially, telemetry volume is likely to be low, so recording traces with a high sampling rate or just rate-limiting should be affordable. </span><span class="koboSpan" id="kobo.92.3">Also, we probably don’t have strict SLAs yet and don’t use dashboards and </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">alerts much.</span></span></p>
<p><span class="koboSpan" id="kobo.94.1">Until we get some real users, metrics or events might be unnecessary, but this is a good time to experiment and get familiar </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">with them.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">Even if the telemetry volume is quite low and we can capture verbose data, we should avoid adding excessive amounts of telemetry and should remove </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">unused signals.</span></span></p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.98.1">Evolving applications</span></h2>
<p><span class="koboSpan" id="kobo.99.1">As our</span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.100.1"> application</span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.101.1"> starts getting some real users, getting performance data quickly becomes critical. </span><span class="koboSpan" id="kobo.101.2">By this time, we have more clarity on what’s important to measure in the application and how to debug issues (hopefully not relying on </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">verbose logging).</span></span></p>
<p><span class="koboSpan" id="kobo.103.1">This is the time to optimize and tune telemetry collection. </span><span class="koboSpan" id="kobo.103.2">As the load grows, we usually want to lower the sampling rate for traces and reduce </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">log verbosity.</span></span></p>
<p><span class="koboSpan" id="kobo.105.1">Also, we would probably need to create alerts and build dashboards that are much more efficient when done over metrics, as we discussed in </span><a href="B19423_07.xhtml#_idTextAnchor115"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.106.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.107.1">, </span><em class="italic"><span class="koboSpan" id="kobo.108.1">Adding Custom Metrics</span></em><span class="koboSpan" id="kobo.109.1">. </span><span class="koboSpan" id="kobo.109.2">While instrumentation libraries should cover the basics, we might need to add custom metrics where we previously relied on queries over traces. </span><span class="koboSpan" id="kobo.109.3">As we scale up, the number of time series only increases with the number of </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">service instances.</span></span></p>
<p><span class="koboSpan" id="kobo.111.1">At this stage, we might also decide to collect precise and unsampled usage data with events </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">and metrics.</span></span></p>
<p><span class="koboSpan" id="kobo.113.1">The application is still changing a lot and we frequently need to investigate functional issues for specific requests and optimize requests from the long tail of latency. </span><span class="koboSpan" id="kobo.113.2">So, tracing still plays a key role in day-to-day work. </span><span class="koboSpan" id="kobo.113.3">We might need to instrument more layers in the application to capture logical operations or add applications-specific context. </span><span class="koboSpan" id="kobo.113.4">At the same time, we may find some auto-instrumentations too verbose and can tune them to remove unnecessary attributes or suppress </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">some spans.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">Sometimes, we need to capture profiles or use diagnostic tools to investigate lower-level issues, so having a continuous profiler or adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">dotnet-monitor</span></strong><span class="koboSpan" id="kobo.117.1"> in a sidecar could make such investigations </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">much easier.</span></span></p>
<p><span class="koboSpan" id="kobo.119.1">If the application (or some parts of it) becomes more stable due to having fewer and fewer issues, it makes sense to remove non-essential traces and reduce the sampling rate for stable services or endpoints. </span><span class="koboSpan" id="kobo.119.2">Tail-based sampling could help capture more traces for failures or </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">long requests.</span></span></p>
<p><span class="koboSpan" id="kobo.121.1">When the application</span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.122.1"> is not changing anymore except for </span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.123.1">basic maintenance, but more importantly, if it does not have many issues and investigations, it could be reasonable to reduce tracing to just incoming and outgoing requests, potentially forwarding logs to </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">colder storage.</span></span></p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.125.1">Performance-sensitive scenarios</span></h2>
<p><span class="koboSpan" id="kobo.126.1">Instrumentation </span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.127.1">introduces performance overhead. </span><span class="koboSpan" id="kobo.127.2">Between traces, metrics, and logs, traces are the most expensive. </span><span class="koboSpan" id="kobo.127.3">When instrumenting an HTTP request, this overhead is usually negligible compared to the </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">call itself.</span></span></p>
<p><span class="koboSpan" id="kobo.129.1">But in some cases, instrumentation costs can be too high. </span><span class="koboSpan" id="kobo.129.2">For example, when returning cached responses or rate-limiting requests across all service instances, logging or tracing all such calls can significantly impact performance. </span><span class="koboSpan" id="kobo.129.3">Moreover, if we recorded a trace for every request, a DDOS attack or buggy client might kill our observability pipeline, if not the </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">whole service.</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">Tracing overhead, to some extent, can be reduced with sampling, which protects the observability pipeline and reduces the number of allocations when populating attributes, but a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">Activity</span></strong><span class="koboSpan" id="kobo.133.1"> is created and a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">SpanId</span></strong><span class="koboSpan" id="kobo.135.1"> is generated, regardless of the </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">sampling decision.</span></span></p>
<p><span class="koboSpan" id="kobo.137.1">Adding tracing for a hot path should be done with caution. </span><span class="koboSpan" id="kobo.137.2">Keep the number of traces to a minimum: trace incoming requests only if the corresponding request is going to be processed by your application and avoid tracing outgoing network calls to the leaf services if they’re extremely fast or reliable. </span><span class="koboSpan" id="kobo.137.3">For example, it makes sense to report an event instead of a span when talking </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">to Redis.</span></span></p>
<p><span class="koboSpan" id="kobo.139.1">Metrics are the most performant telemetry signal and should be preferred for a hot path when possible. </span><span class="koboSpan" id="kobo.139.2">For example, reporting the Redis call duration as a metric with a cache hit/miss dimension would likely be cheaper than an event. </span><span class="koboSpan" id="kobo.139.3">And for tracing purposes, we can put a hit/miss flag as an attribute on an existing current span (for example, one representing an </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">incoming request).</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">Recording exceptions and errors is usually fine from a performance perspective since exceptions create a huge overhead anyway. </span><span class="koboSpan" id="kobo.141.2">But in the case of a failure storm, we get too many of them, so it’s a good idea to throttle </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">exception reporting.</span></span></p>
<p><span class="koboSpan" id="kobo.143.1">Implementing</span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.144.1"> efficient, useful, but minimalistic instrumentation usually requires several iterations. </span><span class="koboSpan" id="kobo.144.2">Luckily, OpenTelemetry provides a set of semantic conventions for common scenarios that can help with it. </span><span class="koboSpan" id="kobo.144.3">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">see how.</span></span></p>
<h1 id="_idParaDest-157"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.146.1">Staying consistent with semantic conventions</span></h1>
<p><span class="koboSpan" id="kobo.147.1">One of the most</span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.148.1"> important questions we’re yet to discuss is what information to add to telemetry signals to make them useful – this is where OpenTelemetry semantic conventions come </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">into play.</span></span></p>
<p><span class="koboSpan" id="kobo.150.1">Semantic conventions describe what information to collect for specific technologies, such as HTTP or gRPC calls, database operations, messaging scenarios, serverless environments, runtime metrics, resource attributes, and </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.152.1">Semantic conventions are part of the OpenTelemetry specification and have been published in the specification repository at </span><a href="https://github.com/open-telemetry/opentelemetry-specification"><span class="koboSpan" id="kobo.153.1">https://github.com/open-telemetry/opentelemetry-specification</span></a><span class="koboSpan" id="kobo.154.1">. </span><span class="koboSpan" id="kobo.154.2">They apply to all instrumentations authored by the </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">OpenTelemetry project.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.156.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.157.1">At the time of writing, semantic conventions are in an experimental status. </span><span class="koboSpan" id="kobo.157.2">The community is actively working on stabilization and the attributes I use in this book will likely be renamed or changed in </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">other ways.</span></span></p>
<p><span class="koboSpan" id="kobo.159.1">The goal of semantic conventions is to unify telemetry collection for specific scenarios or technology across languages, runtimes, and libraries. </span><span class="koboSpan" id="kobo.159.2">For example, traces and metrics for all HTTP clients look very similar, making it possible to visualize or query HTTP telemetry or diagnose problems in the same way for any application. </span><span class="koboSpan" id="kobo.159.3">Let’s look at HTTP semantic</span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.160.1"> conventions to understand how they work and give you an idea of what other conventions </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">look like.</span></span></p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.162.1">Semantic conventions for HTTP requests</span></h2>
<p><span class="koboSpan" id="kobo.163.1">The conventions </span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.164.1">cover tracing and metrics for</span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.165.1"> incoming and outgoing HTTP requests. </span><span class="koboSpan" id="kobo.165.2">Spans with </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">client</span></strong><span class="koboSpan" id="kobo.167.1"> kind describe outgoing requests, whereas </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">server</span></strong><span class="koboSpan" id="kobo.169.1"> spans describe incoming requests. </span><span class="koboSpan" id="kobo.169.2">Instrumentations create a new span for </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">each attempt.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">client</span></strong><span class="koboSpan" id="kobo.172.1"> HTTP spans contain attributes that describe the request, response, and remote destination. </span><span class="koboSpan" id="kobo.172.2">According to the current version, a minimal HTTP client instrumentation must report the following attributes: </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">http.method</span></strong><span class="koboSpan" id="kobo.174.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">http.url</span></strong><span class="koboSpan" id="kobo.176.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">net.peer.name</span></strong><span class="koboSpan" id="kobo.178.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">net.peer.port</span></strong><span class="koboSpan" id="kobo.180.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">http.status_code</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">If a response is not received, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">http.status_code</span></strong><span class="koboSpan" id="kobo.186.1"> attribute is not populated; instead, the span status would indicate an error and provide a status description that explained what happened. </span><span class="koboSpan" id="kobo.186.2">The port (</span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">net.peer.port</span></strong><span class="koboSpan" id="kobo.188.1">) attribute may be skipped if it’s 80 or 443. </span><span class="koboSpan" id="kobo.188.2">Other attributes are required, so all instrumentations that follow conventions must populate them in all scenarios. </span><span class="koboSpan" id="kobo.188.3">These attributes, combined with the span start timestamp, duration, and status, provide a minimal necessary description of the </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">HTTP request.</span></span></p>
<p><span class="koboSpan" id="kobo.190.1">All the attributes except </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">http.status_code</span></strong><span class="koboSpan" id="kobo.192.1"> should be provided at the span start time – this allows us to make sampling decisions based on </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">these attributes.</span></span></p>
<p><span class="koboSpan" id="kobo.194.1">You probably noticed that the host and port information is available inside the URL and via separate attributes. </span><span class="koboSpan" id="kobo.194.2">The URL is a high-cardinality attribute, but the host and port are very likely to be of low cardinality, so reporting all of them allows us to unify instrumentation code and report traces and metrics in one place. </span><span class="koboSpan" id="kobo.194.3">It also makes it possible to calculate metrics from traces and </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">simplify queries.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">Minimal HTTP server instrumentation reports the </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">http.method</span></strong><span class="koboSpan" id="kobo.198.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">http.status_code</span></strong><span class="koboSpan" id="kobo.200.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">http.scheme</span></strong><span class="koboSpan" id="kobo.202.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">http.target</span></strong><span class="koboSpan" id="kobo.204.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">net.host.name</span></strong><span class="koboSpan" id="kobo.206.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">net.host.port</span></strong><span class="koboSpan" id="kobo.208.1">, and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">http.route</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.210.1"> attributes.</span></span></p>
<p><span class="koboSpan" id="kobo.211.1">Since HTTP servers don’t have full URLs readily available, instrumentations don’t construct them and report individual URL components instead. </span><span class="koboSpan" id="kobo.211.2">Route information is provided by an HTTP framework such as ASP.NET Core and even there, you may handle requests in middleware without using routing. </span><span class="koboSpan" id="kobo.211.3">Reporting route is quite important for metrics, as we’ve seen in </span><a href="B19423_07.xhtml#_idTextAnchor115"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.212.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.213.1">, </span><em class="italic"><span class="koboSpan" id="kobo.214.1">Adding Custom Metrics</span></em><span class="koboSpan" id="kobo.215.1">, so if you don’t have the route available out of the box, you might want to provide one manually to distinguish different classes of API calls. </span><span class="koboSpan" id="kobo.215.2">HTTP client and server instrumentations usually also report recommended attributes, such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">User-Agent</span></strong><span class="koboSpan" id="kobo.217.1"> header, request and response content length, HTTP </span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.218.1">protocol </span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.219.1">version, and remote </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">IP address.</span></span></p>
<p><span class="koboSpan" id="kobo.221.1">Conventions also standardize attribute value types – for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">http.status_code</span></strong><span class="koboSpan" id="kobo.223.1"> has an integer type, simplifying comparison at </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">query time.</span></span></p>
<p><span class="koboSpan" id="kobo.225.1">You can find the full HTTP tracing conventions </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">at </span></span><a href="https://opentelemetry.io/docs/reference/specification/trace/semantic_conventions/http"><span class="No-Break"><span class="koboSpan" id="kobo.227.1">https://opentelemetry.io/docs/reference/specification/trace/semantic_conventions/http</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.228.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.229.1">Metrics are based on the same tracing attributes and cover request duration, content size, and the number of active requests on servers. </span><span class="koboSpan" id="kobo.229.2">The metrics conventions are available </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">at </span></span><a href="https://opentelemetry.io/docs/reference/specification/metrics/semantic_conventions/http-metrics"><span class="No-Break"><span class="koboSpan" id="kobo.231.1">https://opentelemetry.io/docs/reference/specification/metrics/semantic_conventions/http-metrics</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.232.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.233.1">HTTP semantic conventions provide a good set of default things to collect. </span><span class="koboSpan" id="kobo.233.2">You can move between teams, companies, and web frameworks, or start using a different programming language, but OpenTelemetry instrumentations would provide a common </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">baseline everywhere.</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">Having a</span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.236.1"> reliable</span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.237.1"> set of required attributes helps the backend visualize traces and service maps, build dashboards, and automate analysis and </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">issue detection.</span></span></p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.239.1">General considerations</span></h2>
<p><span class="koboSpan" id="kobo.240.1">When you need to</span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.241.1"> instrument some specific technology or scenario and no suitable instrumentation library is available, make sure to also check whether there is an applicable semantic convention. </span><span class="koboSpan" id="kobo.241.2">By following it, you will be able to leverage any experiences built on top of it by your observability backend, prevent inconsistent signals coming from different parts of your system, and also save some time designing and polishing </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">your signals.</span></span></p>
<p><span class="koboSpan" id="kobo.243.1">But what if you want to instrument something very specific to your application, such as adding spans for logical operations or adding usage metrics? </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">Let’s see.</span></span></p>
<h3><span class="koboSpan" id="kobo.245.1">Tracing</span></h3>
<p><span class="koboSpan" id="kobo.246.1">As we’ve</span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.247.1"> seen in </span><a href="B19423_06.xhtml#_idTextAnchor098"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.248.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.249.1">, </span><em class="italic"><span class="koboSpan" id="kobo.250.1">Tracing Your Code</span></em><span class="koboSpan" id="kobo.251.1">, we can create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">Activity</span></strong><span class="koboSpan" id="kobo.253.1"> instance without specifying any parameters. </span><span class="koboSpan" id="kobo.253.2">By default, it’s named after the caller method and has an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">internal</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.255.1"> kind.</span></span></p>
<p><span class="koboSpan" id="kobo.256.1">OpenTelemetry recommends using low-cardinality span names. </span><span class="koboSpan" id="kobo.256.2">HTTP client span names follow the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">HTTP &lt;method&gt;</span></strong><span class="koboSpan" id="kobo.258.1"> pattern (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">HTTP GET</span></strong><span class="koboSpan" id="kobo.260.1">), while the HTTP server span name looks like </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">&lt;method&gt; &lt;route&gt;</span></strong><span class="koboSpan" id="kobo.262.1"> (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">GET /users/{userId}</span></strong><span class="koboSpan" id="kobo.264.1">). </span><span class="koboSpan" id="kobo.264.2">The span name describes a class of operations and is frequently used to group </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">common spans.</span></span></p>
<p><span class="koboSpan" id="kobo.266.1">Another important property is the span kind: it helps backends visualize and query traces them. </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">client</span></strong><span class="koboSpan" id="kobo.268.1"> spans represent outgoing requests – their context is propagated over the wire, and they become remote parents of </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">server</span></strong><span class="koboSpan" id="kobo.270.1"> spans. </span><span class="koboSpan" id="kobo.270.2">When instrumenting a remote call, we would typically want to create a new span for each attempt so that we know how long an attempt took, how many there were, and what the backoff </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">interval was.</span></span></p>
<p><span class="koboSpan" id="kobo.272.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">server</span></strong><span class="koboSpan" id="kobo.274.1"> spans are those that track incoming requests; they either have no parents or have a </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">remote parent.</span></span></p>
<p><span class="koboSpan" id="kobo.276.1">OpenTelemetry also defines </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">consumer</span></strong><span class="koboSpan" id="kobo.278.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">producer</span></strong><span class="koboSpan" id="kobo.280.1"> kinds – they are used in asynchronous scenarios where a request-response pattern is not applicable. </span><span class="koboSpan" id="kobo.280.2">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">producer</span></strong><span class="koboSpan" id="kobo.282.1"> span could be a parent of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">consumer</span></strong><span class="koboSpan" id="kobo.284.1"> span (or be linked to it), but it usually ends before the corresponding </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">consumer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.286.1"> span.</span></span></p>
<p><span class="koboSpan" id="kobo.287.1">All other spans are </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">internal</span></strong><span class="koboSpan" id="kobo.289.1">. </span><span class="koboSpan" id="kobo.289.2">For example, to represent an I/O operation or a local long-running call, we should use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">internal</span></strong><span class="koboSpan" id="kobo.291.1"> kind. </span><span class="koboSpan" id="kobo.291.2">When instrumenting client library calls or logical operations that can do multiple HTTP requests underneath, it makes sense to describe them as </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">internal</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.293.1"> spans.</span></span></p>
<p><span class="koboSpan" id="kobo.294.1">If an operation ends with an error, we should reflect it with a span status, but this can be tricky. </span><span class="koboSpan" id="kobo.294.2">For example, HTTP semantic conventions recommend setting the status to an error on the client side if a response was not received, there were too many redirects, or when the status code was in the 4xx or 5xx ranges. </span><span class="koboSpan" id="kobo.294.3">But for HTTP servers, a 4xx response does not indicate an error and should be left unset. </span><span class="koboSpan" id="kobo.294.4">Even for client requests, status codes such as 404 (</span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">Not Found</span></strong><span class="koboSpan" id="kobo.296.1">) do not necessarily indicate an error and can be used to check whether some </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">resource exists.</span></span></p>
<p><span class="koboSpan" id="kobo.298.1">When recording errors, the status description can be used to record some predictable and short information about it, such as its exception type and/or message. </span><span class="koboSpan" id="kobo.298.2">Exceptions follow their own</span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.299.1"> semantic conventions – we discussed this in </span><a href="B19423_06.xhtml#_idTextAnchor098"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.300.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.301.1">, </span><em class="italic"><span class="koboSpan" id="kobo.302.1">Tracing Your Code</span></em><span class="koboSpan" id="kobo.303.1">. </span><span class="koboSpan" id="kobo.303.2">They can be huge (because of stack traces), so we should avoid recording </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">handled exceptions.</span></span></p>
<h4><span class="koboSpan" id="kobo.305.1">Attributes</span></h4>
<p><span class="koboSpan" id="kobo.306.1">Application-specific </span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.307.1">context or details about an operation can be recorded in attributes. </span><span class="koboSpan" id="kobo.307.2">Before inventing a new attribute name, make sure you check existing semantic conventions to see whether something similar is defined there already. </span><span class="koboSpan" id="kobo.307.3">For example, you can use general network attributes to describe remote destinations or host and </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">RPC calls.</span></span></p>
<p><span class="koboSpan" id="kobo.309.1">If you must create a new attribute, use a short name that consists of basic Latin characters. </span><span class="koboSpan" id="kobo.309.2">OpenTelemetry recommends using namespaces to avoid naming collisions (they are delimited with the dot (</span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">.</span></strong><span class="koboSpan" id="kobo.311.1">) character) and using </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">snake_case</span></strong><span class="koboSpan" id="kobo.313.1"> to separate words. </span><span class="koboSpan" id="kobo.313.2">For example, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">http.status_code</span></strong><span class="koboSpan" id="kobo.315.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">http</span></strong><span class="koboSpan" id="kobo.317.1"> is a namespace. </span><span class="koboSpan" id="kobo.317.2">So, if you’re defining a new attribute specific to your company, it makes sense to use the company name in </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">the namespace.</span></span></p>
<p><span class="koboSpan" id="kobo.319.1">The number of attributes per span is limited to 128 by default, but this limit can </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">be increased.</span></span></p>
<p><span class="koboSpan" id="kobo.321.1">Keeping consistent names and value types across your system can be challenging, so it’s a good idea to come up with some registry to keep </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">them consistent.</span></span></p>
<p><span class="koboSpan" id="kobo.323.1">So, which information would you add to attributes? </span><span class="koboSpan" id="kobo.323.2">Anything that describes your operation, except sensitive information or secrets. </span><span class="koboSpan" id="kobo.323.3">Be cautious with long values and avoid adding something that needs to be serialized or calculated – use verbose logging </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">for it.</span></span></p>
<p><span class="koboSpan" id="kobo.325.1">It’s also a good idea</span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.326.1"> to avoid duplication and record a reasonable set of information, moving static attributes to resources instead </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">of spans.</span></span></p>
<h3><span class="koboSpan" id="kobo.328.1">Metrics</span></h3>
<p><span class="koboSpan" id="kobo.329.1">When creating</span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.330.1"> instruments, we can provide a name, unit, </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">and description.</span></span></p>
<p><span class="koboSpan" id="kobo.332.1">Instrument names are case-insensitive and consist of alphanumeric characters, underscores, dots, and dashes. </span><span class="koboSpan" id="kobo.332.2">Instrument names must be short – up to </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">63 characters.</span></span></p>
<p><span class="koboSpan" id="kobo.334.1">Instrument names are formatted similarly to attribute names and support namespaces – for example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">http.server.active_requests</span></strong><span class="koboSpan" id="kobo.336.1"> counter or the </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">http.server.duration</span></strong><span class="koboSpan" id="kobo.338.1"> histogram, which represent the number of active HTTP requests and server-side duration of </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">requests, respectively.</span></span></p>
<p><span class="koboSpan" id="kobo.340.1">Units usually follow UCUM</span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.341.1"> standards (</span><a href="https://ucum.org/"><span class="koboSpan" id="kobo.342.1">https://ucum.org/</span></a><span class="koboSpan" id="kobo.343.1">) and it’s important to keep them consistent for the same instrument across the </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">whole system.</span></span></p>
<p><span class="koboSpan" id="kobo.345.1">Attribute naming conventions are common between different signals and usually, metrics rely on a subset of tracing attributes. </span><span class="koboSpan" id="kobo.345.2">The most important characteristic of metric attributes is low cardinality, which we described in </span><a href="B19423_07.xhtml#_idTextAnchor115"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.346.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.347.1">, </span><em class="italic"><span class="koboSpan" id="kobo.348.1">Adding </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.349.1">Custom Metrics</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.351.1">Before adding custom metrics, make sure to check whether there is an existing instrumentation library or an OpenTelemetry semantic convention. </span><span class="koboSpan" id="kobo.351.2">For example, there is a generic one for RPC requests, process </span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.352.1">and system resource utilization metrics, databases, and other technology-specific ones, such </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">as Kafka.</span></span></p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.354.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.355.1">In this chapter, we discussed suggestions and recommendations for telemetry collection. </span><span class="koboSpan" id="kobo.355.2">To describe some scenario or operation, we usually need multiple signals: tracing enables correlation and causation, logs provide additional information not covered by traces, events collect usage information, and metrics optimize instrumentations, queries, </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">and alerts.</span></span></p>
<p><span class="koboSpan" id="kobo.357.1">Depending on your application’s needs and stability, you can control costs by tuning the sampling rate on tracing and using metrics for performance data and events for </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">usage reports.</span></span></p>
<p><span class="koboSpan" id="kobo.359.1">OpenTelemetry semantic conventions provide instrumentation recipes for common technologies and concepts. </span><span class="koboSpan" id="kobo.359.2">By following them, you can create high-quality instrumentations with good defaults that you can tune to your needs. </span><span class="koboSpan" id="kobo.359.3">Observability backends can provide their best experiences to help you visualize, detect anomalies, and perform other semi-automated analyses. </span><span class="koboSpan" id="kobo.359.4">For proprietary technologies or application-specific instrumentation, where there are no existing conventions, it’s important to follow general the OpenTelemetry specification and naming patterns and report telemetry consistently across </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">your system.</span></span></p>
<p><span class="koboSpan" id="kobo.361.1">With this, you should be ready to instrument advanced scenarios with multiple signals and provide a rich context while following the available practices. </span><span class="koboSpan" id="kobo.361.2">In the next chapter, we’re going to apply these skills to instrument gRPC streaming calls that are not covered by any existing conventions. </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">Stay tuned.</span></span></p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.363.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.364.1">Can you instrument a tiny stateless RESTful microservice with </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">tracing only?</span></span></li>
<li><span class="koboSpan" id="kobo.366.1">When working on an application that processes thousands of requests per second on each instance, which sampling rate would </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">you choose?</span></span></li>
<li><span class="koboSpan" id="kobo.368.1">Your application communicates with client devices over web sockets. </span><span class="koboSpan" id="kobo.368.2">How would you approach instrumenting </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">this communication?</span></span></li>
</ol>
</div>
</body></html>