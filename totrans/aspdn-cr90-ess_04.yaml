- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Real-Time Interactions with SignalR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As part of ASP.NET Core 9, the web API is a framework for building HTTP services,
    which can be made available for both web page consumption and mobile applications.
    The structure provided by the .Net Core platform provides the development of APIs
    with high quality and performance. In this chapter, we will learn more about WebAPI,
    including the standards, conventions, and best practices for delivering solutions
    via a service.
  prefs: []
  type: TYPE_NORMAL
- en: We will work on creating a real-time task management application where we will
    use various techniques available on the .NET platform and SignalR to learn about
    the concepts and implement an example of applications that use the Stream concept.
    We will also explore the premises for hosting SignalR applications on a server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is SignalR?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the concepts of server and clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with streaming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hosting the ASP.NET Core SignalR applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code examples used in this chapter can be found in the book’s GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter04](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter04)'
  prefs: []
  type: TYPE_NORMAL
- en: What is SignalR?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we learned in previous chapters, web-based applications have two parts:
    the client and the Server.'
  prefs: []
  type: TYPE_NORMAL
- en: A **browser** generally represents the client, where the user interacts with
    the application. Applications have actions executed on a server to process information
    and return a response.
  prefs: []
  type: TYPE_NORMAL
- en: This process is based on two phases, which are **request** and **response**
    . These phases happen in sequence. With each interaction between the client and
    the server, a new communication process is created.
  prefs: []
  type: TYPE_NORMAL
- en: Most web applications have these features that are sufficient for most business
    contexts. However, there are scenarios where there is a need for a **real-time
    communication model** , where the information processed by an application is constantly
    updated. This provides an immediate response to users, enriching usability and
    certain functional requirements.
  prefs: []
  type: TYPE_NORMAL
- en: A good example of real-time applications would be, for example, a map application
    where users have traffic information on a given route, and are notified about
    any aspects that affect navigation. Furthermore, other types of applications such
    as games, social networks, or even collaborative web text editors depend on constant
    updates to users.
  prefs: []
  type: TYPE_NORMAL
- en: To develop applications that contain real-time features, it would be necessary
    for the server and client to be able to communicate constantly on an active channel.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET platform has SignalR. This is a library that adds the ability to build
    real-time solutions in a simplified way, instantly allowing constant communication
    between client and server.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – SignalR components](img/B21788_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – SignalR components
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, *Figure 4* *.1* demonstrates most of the SignalR components
    that abstract the communication model between the client and the server. Communication
    between the client and the server occurs over an active connection, using a transport
    technique that transports JSON or binary messages. WebSockets is the standard
    communication technique used by SignalR. The other two options are used as fallback.
    In other words, if WebSockets is not supported, Server-sent events or long polling
    will be used immediately. The order of precedence for transport is the same as
    that established in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**WebSockets** : It provides the ability to establish a *full-duplex connection*
    , that is, allowing constant communication between client and server.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Server-sent events** : It establishes a *one-way connection* from the Server
    to the client. The client does not have the ability to send messages to the server
    over the same connection, requiring a separate HTTP request.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Long polling** : It is a more basic technique whereby the client sends a
    message to the server. Instead of sending an immediate message, the server then
    processes the information and only returns the response after finishing.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SignalR abstracts the choice of transport, making it possible to define the
    use of just WebSocket, if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: The connection between the client and the server depends on an important component
    called the Hub. The Hub is a special object. It’s a part of the SignalR API that
    acts as a proxy, allowing server-client communication, where the server can execute
    functions or methods on the client, remotely, through the use of **RPC** ( **Remote**
    **Procedure Call** ).
  prefs: []
  type: TYPE_NORMAL
- en: RPC
  prefs: []
  type: TYPE_NORMAL
- en: RPC is a communication protocol that has existed since 1970 and serves as the
    basis for several innovations that currently exist, such as gRPC, a high-performance
    communication model developed by Google. You can find more information about RPC
    at [https://en.wikipedia.org/wiki/Remote_procedure_call](https://en.wikipedia.org/wiki/Remote_procedure_call)
    .
  prefs: []
  type: TYPE_NORMAL
- en: SignalR abstracts all the complexity of connection and communication management,
    in addition to bringing other capabilities, such as sending notifications to all
    connected clients, specific clients, or a group of clients. Additionally, APIs
    can be used in conjunction with .NET applications, even console, Java, and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible, for example, to have a server that communicates with a console
    application developed on the .NET or even Java platform.
  prefs: []
  type: TYPE_NORMAL
- en: It may seem complex at first, but as we learn about the main concepts and good
    practices, we will come to understand how powerful the SignalR library is. Let’s
    explore some concepts, patterns, and good practices that involve SignalR and how
    to develop a real-time application using this library.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the concepts of Servers and Clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned earlier, SignalR is a powerful library that abstracts much of
    the complexity of creating real-time applications.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is important to know the concepts and standards related to using
    the SignalR library to benefit from its features.
  prefs: []
  type: TYPE_NORMAL
- en: As we know, web applications basically have two main components, the Client
    and the Server. Likewise, real-time applications using SignalR require both client
    and server components. We will learn how these components interact with each other
    through a task management application.
  prefs: []
  type: TYPE_NORMAL
- en: Working with a task management application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The task management application will be created using **Razor Pages** technology
    and have the following functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement concepts in real time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complete tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View created tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View completed tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All functionalities will be resolved using Visual Studio Code. JavaScript will
    be used to work with the functionalities on the Client side and C# will be used
    on the Server side.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see an outline of the main components used in the application in *Figure
    4* *.2* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – TaskManager application components](img/B21788_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – TaskManager application components
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in *Figure 4* *.2* , we have some important components that will
    be used in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Client will be implemented using Razor Pages, which will aim to allow user
    interaction in relation to the application’s functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: The **index-page.js** file will be responsible for managing interactions between
    the server and the application’s main page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **signalr.js** file is part of the SignalR JavaScript SDK.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server is the Razor Page application that will act as an orchestrator server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Hub implementation will be responsible for managing real-time communication
    between the server and the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we create the project, we will explain how each component works and implementation
    details. For now, let’s start with creating the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will focus on the main activities for creating a task manager project. However,
    you can check the entire implementation of the solution in the book GitHub repository,
    mentioned in the *Technical requirements* section. Here are the steps we will
    be following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the project, open the terminal in a directory of your choice and
    run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A new folder called **TaskManager** will be created containing the entire project
    structure. Access this page with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that the project has been created, we need to add the SignalR JavaScript
    SDK. It will not be necessary to add the SDK to the server, as it is automatically
    added when creating the project, as part of the . NET platform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we are using Razor Pages, we will have the client and server in the same
    project. However, we can create a **Single-Page Application** ( **SPA** ) solution
    and a WebAPI in Asp.NET Core 9 and perform the same procedures.
  prefs: []
  type: TYPE_NORMAL
- en: We will continue with the Razor pages and go to the installation of the SignalR
    JavaScript SDK. We will use a tool called **LibMan** , which is a **Command Line
    Interface** ( **CLI** ) from Microsoft, responsible for managing client libraries.
    Its operation is similar to **Node Package** **Management** ( **NPM** ).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it, it is advisable to uninstall any previous version existing on your
    operating system. Therefore, we’ll follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following commands in sequence to install the tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will run the command to install the SignalR SDK. Run the following
    command and check in the application’s main directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding command avoided installing the **@microsoft/signalr@latest** library
    and then only added the necessary scripts to the application directories.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At this moment, the project is being created and prepared to receive implementations
    of real-time features. We must start by creating the Hub and configuring the application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Hub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Hub is one of the most important components for implementing SignalR. It
    acts as a proxy that manages the connections of all clients to the server and
    allows both the client and the server to talk to each other to execute methods
    in real time.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our **TaskManager** application, our first task will be to create a Hub
    and prepare it for communicating with clients. To do this, still in the terminal
    and the application directory, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This command will open an instance of VS Code in the application directory.
  prefs: []
  type: TYPE_NORMAL
- en: At the root of the project, create a folder called **Hubs** and then a file
    called **TaskManagerHub.cs** .
  prefs: []
  type: TYPE_NORMAL
- en: 'The project class will have two methods and will look like the code that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first detail to note is inherited from the **Hub** class. The **Hub** class
    is a superclass that abstracts all connection management and interaction with
    clients, available through the **Microsoft.AspNetCore.SignalR** package. All custom
    **Hub** classes must inherit from this class.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the **CreateTask** and **CompleteTask** methods. These methods
    will be invoked through clients and at the same time will invoke methods on clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **CreateTask** method receives as a parameter a class called **TaskModel**
    . This class has been broken into the **Model/TaskModel.cs** directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the **TaskModel** class only has a few basic properties such
    as **Id** , **Name** , and **IsCompleted** , which represent a task.
  prefs: []
  type: TYPE_NORMAL
- en: Communication between the client and the server is done through a transport
    strategy, as mentioned previously, and WebSockets will generally be used. The
    information transmitted is serialized in JSON or binary. However, binary data,
    commonly used for audio, images, and videos, is not supported. Only text data
    will be transmitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at the complete implementation of the **CreateTask** method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code performs two basic procedures:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Persist a task** : The **_taskRepository** property is an interface that
    abstracts communication with a persistence layer. For this persistence project,
    it is being done in memory and the complete code for this implementation can be
    found in the book’s GitHub repository (see the *Technical* *requirements* section).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Notify customers** : The **Hub** base class has a **Client** property with
    some functionality. In the code example, a notification is being made to all potential
    clients connected to **Hub** . The **SendAsync** method has 10 overloads of different
    variations. However, for the preceding code, two main parameters are being used.
    The first parameter concerns the name of the client method that will process the
    Hub’s response, while the second parameter is the task object itself that will
    be sent to clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constants are best practices
  prefs: []
  type: TYPE_NORMAL
- en: As we noted in the **SendAsync** method, the first parameter references a constant.
    This is good practice as it is necessary to know the name of the method that will
    process the communication made through the server. Since it’s a string, it’s easy
    to make mistakes. Use constants whenever necessary to center strings containing
    method names. This will facilitate maintenance and improvements.
  prefs: []
  type: TYPE_NORMAL
- en: With the Hub implemented, it will now be necessary to configure the application
    to handle communication through SignalR.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the server application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The application needs to be configured to be able to handle connectivity between
    the client and the server. Without this step, the Hub will have no use.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we will need to change the code in the **Program.cs** file and add
    some important lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: We must configure the SignalR services in the application container and map
    the Hub endpoint that will be used by the client to establish the connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the changes, the file should be similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It is very important to follow the order in which the settings were made. The
    **builder.Services.AddSignalR()** method was added before the **var app = builder.Build()**
    line. Likewise, the Hub route mapping is added right after the **app.MapRazorPages()**
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note the mapping of the Hub route, configured as **/taskmanagerhub**
    . The Hub route definition follows the same REST API pattern and this same route
    will be used so that client applications are able to establish connections with
    the server. The client will use the previously installed SignalR JavaScript SDK
    to connect to the Hub.
  prefs: []
  type: TYPE_NORMAL
- en: The Hub is configured and ready to receive connections. Now, it’s time to configure
    the client.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the client application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the Hub configured, we must add the necessary features to the client application.
    To do this, we will use the **Pages/index.cshtml** page and create the JavaScript
    that will orchestrate all interactions between the client and the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the entire contents of the **Index.cshtml** page to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The HTML available is quite simple, just adding a form containing a field to
    name the task and a button that will be responsible for sending the new task to
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, there are two lists (completed tasks and uncompleted tasks) that
    will be displayed according to user interaction. We are not using any Razor Pages
    directives in the HTML elements, so it will not be necessary to make any changes
    to the **Index.cshtml.cs** file.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that to facilitate the understanding of the concepts
    of client and server, together with SignalR, we are using a Razor Pages application.
    However, it is possible to benefit from another approach called SPA, which makes
    it possible to use Frameworks such as Angular, React, or VueJS to create applications
    in JavaScript and HTML that run on the client and interact with the server.
  prefs: []
  type: TYPE_NORMAL
- en: SPA
  prefs: []
  type: TYPE_NORMAL
- en: The **TaskManager** application uses Razor Pages to facilitate the explanation
    of SignalR concepts, concentrating the client and server in the same project.
    However, SignalR can be installed in a separate application that uses pure JavaScript,
    typescript, or any framework such as Angular, Vue.js, and so on. Furthermore,
    the SPA concept is a great practice for developing real-time functionalities.
    Otherwise, if there are several pages being loaded by the browser, with each new
    request, a new connection with the server is established. SPA makes it possible
    to render application pages dynamically while maintaining the same connection
    when using SignalR.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the HTML code uses a **@section Scripts {}** directive, where the
    previously installed SignalR libraries and the JavaScript file that we will create
    are added. This section was defined in the **Pages/Shared/_Layout.cshtml** file,
    as we learned in [*Chapter 2*](B21788_02.xhtml#_idTextAnchor031) .
  prefs: []
  type: TYPE_NORMAL
- en: Create an **index-page.js** file in the **wwwroot/js/index** directory. The
    entire content of this file is available in the application’s source code in the
    book’s repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s focus on the most important points for establishing a connection with
    the Hub. To do this, we will basically need three main steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a connection object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Map the events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These three steps are defined in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, we have the creation of the connection object using a SignalR
    object. Note that the **withUrl(HUB_URL)** method uses a constant that must contain
    the value of the Hub URL. As we are using Razor Pages, the client and server will
    be available through the same address, and in this case, we can enter a relative
    URL such as **/taskmanagerhub** . This URL is exactly the endpoint that was previously
    mapped on the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the event implementation that will process the return from the
    server. In this case, we use the **on** method of the connection object. This
    method receives two parameters, the first being a string that represents the event.
    In this case, the **NotifyTaskManager** value was set to a constant. The **updateTaskList**
    method will process the return. We can use an inline function. However, to facilitate
    maintenance, we create a separate function that has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This function could have any name and different types of parameters. However,
    the methods available in the Hub are sending the client a **TaskModel** object
    as a parameter. This object will be serialized in JSON or binary and SignalR will
    add it to the event corresponding to the processing of this return.
  prefs: []
  type: TYPE_NORMAL
- en: The **updateTaskList** function just gets the returned object and dynamically
    feeds the completed or incomplete task lists into the HTML using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Best practice
  prefs: []
  type: TYPE_NORMAL
- en: It is good practice to use objects as method parameters, both on the client
    and on the server. This prevents us from having to change method signatures in
    applications if output and input parameters are modified. The use of objects simplifies
    information traffic between the client and server.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the name of the event must be the same both on
    the client and on the server, hence the use of constants to facilitate maintenance
    and writing.
  prefs: []
  type: TYPE_NORMAL
- en: The third step is to start the connection through the **Start** method of the
    connection object. The **Start** method delivers a promise that is triggered after
    the connection is established. Additionally, it is possible to implement the **catch**
    method, for mapping and any possible error when trying to connect with the Hub.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it’s time to add the **click** event to the **Add Task** button, which
    will be responsible for requesting the addition of a new task, according to the
    code that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code requests the server through the **connection.Invoke()** function,
    having the name of the method available in the Hub and a **TaskModel** object
    with the name defined through user input as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: We currently have all the necessary requirements for the **TaskManager** application
    to have real-time functionality. Although it may seem complex, the approach is
    simple, requiring the client to be aware of the methods available on the server
    and the server to be aware of the events that can be executed on the client.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s analyze the application execution flow in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the client and server communication flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the Hub and client properly configured, it’s time to understand how the
    communication flow will work. The flow for creating a task is represented according
    to *Figure 4* *.3* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Communication between the Client and Server using SignalR](img/B21788_04_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Communication between the Client and Server using SignalR
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps shown in *Figure 4* *.3* simply illustrate the entire communication
    flow of the application. Let’s understand each of these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: After entering the task name, the user clicks the **Add Task** button. The button’s
    click event requests the **CreateTask** method, available on the server, through
    the Hub, passing a **TaskModel** object with the **Name** property defined as
    a parameter. The invocation of the server-side method is done through the connection
    that was previously made to the Hub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upon receiving a request for the **CreateTask** method, the Hub then processes
    the task, adding it to a list in memory through the **Save** method, which adds
    values to the **Id** and **IsCompleted** properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the Hub invokes the **NotifyTaskManager** method on the client, passing
    it as a parameter from the created **TaskModel** object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client executes the method responsible for processing the server notification.
    This method was implemented in the SignalR connection object and updates the application
    screen, displaying the list of created tasks and the list of completed tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we learned the main concepts of SignalR for implementing real-time
    communication between client and server. These concepts can be used in different
    types of applications, such as chat apps, order status updates in an online store,
    and so on. However, there are cases wherein we must work with a constant data-sending
    model between the client and server and this depends on another synchronization
    model that can be implemented with SignalR through the use of streaming. This
    concept is widely used in dashboards and applications such as news feeds. In the
    next section, we will understand how streaming works.
  prefs: []
  type: TYPE_NORMAL
- en: Working with streaming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the context of SignalR, streaming is a powerful way of sending data from
    the server to the client and vice versa, in a continuous stream. Unlike traditional
    request/response models, where data is sent in a single batch, streaming allows
    for a constant flow of data, which is particularly useful for scenarios involving
    real-time updates, such as live feeds, dashboards, or even chat apps.
  prefs: []
  type: TYPE_NORMAL
- en: Streaming on SignalR is characterized by several important features that make
    it an exceptional choice for real-time applications. Through a continuous flow,
    data is sent as soon as it becomes available, which is crucial to creating a real-time
    user experience. This means users receive updates immediately, keeping them constantly
    informed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, streaming operations in SignalR are inherently asynchronous, ensuring
    that the application remains responsive even when dealing with multiple streaming
    operations or large volumes of data. Lastly, SignalR supports bidirectional streaming,
    allowing not only server-to-client but also client-to-server data flows.
  prefs: []
  type: TYPE_NORMAL
- en: This flexibility opens up a wide range of possibilities for interactive applications
    where both the server and clients can initiate and participate in data exchanges,
    further enhancing the dynamic, real-time capabilities of applications built with
    SignalR.
  prefs: []
  type: TYPE_NORMAL
- en: 'The streaming strategy is a powerful solution. However, it is important to
    keep some limitations and challenges in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Network dependency and stability** : One of the main limitations of streaming
    on SignalR is its dependence on network quality. Since streaming involves a continuous
    flow of data, a stable and reliable network connection is crucial. Instabilities
    can cause a loss of connection, compromising the user experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource intensity** : Streaming can be more resource-intensive than traditional
    request/response interactions. Since the server must maintain an open connection
    and continually process and send data, this can increase CPU and memory usage.
    In high-volume scenarios or with a large number of connected clients, this can
    become a significant challenge for resource management and expansion strategies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity in implementation and maintenance** : Implementing streaming logic
    is generally more complex than dealing with standard request/response models due
    to the need to manage continuous connections and deal with asynchronous data streams.
    Additionally, it is challenging to debug streaming applications, especially when
    it comes to ensuring data integrity and dealing with network issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability challenges** : Scaling real-time streaming applications can be
    challenging as the number of concurrent users increases and the load on the server
    can increase quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited browser support and compatibility issues** : Although modern browsers
    generally support the technologies underlying SignalR, there may still be compatibility
    issues, especially with older browsers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security considerations** : With open and continuous connections, streaming
    applications may have different security considerations compared to traditional
    web applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding these limitations provides better strategy definition and application
    design to take advantage of the best benefits available in SignalR.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing basic streaming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already understand the most important concepts of SignalR, such as how the
    Hub and the communication between the client and the server work. However, it
    is important to implement a simple application example to understand the streaming
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s nothing better than making an application to capture the concepts we’re
    learning. Therefore, follow these steps to implement an application that uses
    streaming:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Access your operating system’s terminal navigate to a directory of your choice
    and create a folder with the following instructions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, follow these steps to create the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command to create the project:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, access the created application directory and open Visual Studio code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same way as we did in the **TaskManager** project, the first task will
    be to create a Hub. Create a new folder called **Hubs** and then a class called
    **StreamHub.cs** :'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: This code has a **Countdown** method that returns a stream of integers counting
    down from a specified number.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let’s change the **Program.cs** file by adding SignalR functionalities
    in the same way as we did in the **TaskManager** project. The class should look
    like the following code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the signalR client library using the **libman** application:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to create a script to establish the connection to the Hub. To do
    this, create a file called **index-stream.js** in the **wwwroo/js** directory.
    This file must contain the following code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code aims to connect the client application to the server, using
    the same approach learned in the previous session. In this example, first, there
    is the connection to the Hub. This is accomplished by creating the connection
    using the new **SignalR.HubConnectionBuilder()** line of code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, when starting the connection, the streaming approach is used, initiated
    by the **connection.stream(..)** method. The **stream** method depends on two
    arguments, the first being the name of the method that will be requested on the
    server, called **Countdown** , previously created in the **StreamHub.cs** file.
    The second parameter is an integer value, where the countdown implemented in the
    server’s **Countdown** method will start. It is important to note that the number
    of parameters required by the stream method, in addition to the name of the function
    defined as a string, will vary according to the number of parameters implemented
    on the server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The stream method has a nested method called **subscribe** , which has an implementation
    to obtain responses from the server. The **subscribe** method has an object that
    contains three main callback methods: **next** , **complete** , and **error**
    . Each of these events is executed at a certain point in the streaming. The **next**
    method is used for the response sent from the server. The **complete** method
    is used when the streaming flow is finished and the error method is used if an
    error occurs. All three subscribe methods use a **logStream** javascript function
    implemented in the **index-stream.js** file that adds a list element to the HTML
    containing the response to events.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we need to change the **Pages/Index.cshtml** file to the following code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, just run the application using the following command:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 4.4 – SignalR streaming app](img/B21788_04_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – SignalR streaming app
  prefs: []
  type: TYPE_NORMAL
- en: As seen in *Figure 4* *.4* , we have a countdown starting from the number **10**
    and, at the end, there is a **Stream Completed** message, which determines the
    end of the streaming. In this example, the **next** and **complete** events from
    the **subscribe** method were used. This way, we can work with constant interaction
    between the client and the server using streaming, bringing greater power to our
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: The application is very simple and basically generates a list of numbers obtained
    through the connection to the Hub, with a small delay to simulate latency.
  prefs: []
  type: TYPE_NORMAL
- en: The stream approach is very interesting for transporting small blocks of information
    and allowing active processing in parts, ensuring a better user experience.
  prefs: []
  type: TYPE_NORMAL
- en: We already understand the main features available in SignalR, but now let’s
    learn what is needed to host applications on a server.
  prefs: []
  type: TYPE_NORMAL
- en: Hosting the ASP.NET Core SignalR application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like any web-based application, we must make them available through a server
    after the development stage. Applications developed in ASP.NET Core SignalR have
    the same characteristics and with all the power of the .NET platform, there is
    the possibility of hosting on internal servers and different cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss more about hosting applications in [*Chapter 10*](B21788_10.xhtml#_idTextAnchor162)
    . For now, we will just learn what is necessary to generate a hostable package
    for a SignalR application.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of hosting a SignalR application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hosting an ASP.NET Core SignalR application isn’t drastically different from
    hosting a regular ASP.NET Core web app. However, due to the real-time nature of
    SignalR, there are specific considerations to keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to define what the hosting model will be. In general, currently
    public clouds are selected, such as Azure, AWS, or GCP (Google). However, let’s
    understand each type of hosting available for ASP.NET Core 9 applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Traditional hosting (IIS, Nginx, and Apache)** : These are standard web servers
    that can also serve SignalR applications. They mainly act as reverse proxies,
    forwarding client requests to the SignalR application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud hosting** : Cloud platforms offer robust and scalable hosting environments.
    **Azure App Service** , for example, provides an easy-to-use hosting model for
    ASP.NET Core applications, including those using SignalR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Containers (Docker and Kubernetes)** : For those looking for more control
    over their hosting environment, containerization offers a way to package the SignalR
    application with all its dependencies, ensuring consistency across different environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After defining the hosting server, the process of hosting the application follows
    approximately four steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Publishing the application** : Use Visual Studio or the .NET CLI to publish
    your application, generating a deployable unit. This task can be done by running
    the following command as an example that compiles the application in the **Release**
    mode and generates publication files in the **Published** folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Configuring the server** : Whether it’s IIS, a Linux server with Nginx/Apache,
    or a cloud service, you will need to configure the server or service to host your
    application. This includes installing the necessary .NET runtimes, in the case
    of IIS or Nginex/Apache servers, and configuring the web server or cloud service.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Configuring reverse proxy (if necessary)** : For IIS, Nginx, and Apache,
    ensure they are configured to correctly forward requests to your ASP.NET Core
    application. This is crucial for SignalR as it relies on persistent connections.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Deploying the application** : Upload or deploy the published application
    to your hosting environment. This can be done via FTP, Web Deploy, or CI/CD pipelines
    if you are using cloud services or containerization.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hosting SignalR applications presents unique challenges due to their nature
    of maintaining persistent connections to clients and can significantly burden
    server resources.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to be aware of the connection limits of your server or hosting
    plan, as each will have a maximum number of simultaneous connections it can support.
    In environments where load balancing is employed, the use of sticky sessions is
    recommended to preserve the integrity of connections, ensuring that a client communicates
    consistently with the same server instance.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, as the number of concurrent connections increases, you may need
    to expand your application, involving deploying multiple instances of your application
    and distributing traffic between them. This would let you increase your ability
    to effectively manage a larger volume of concurrent connections. This approach
    helps maintain the optimal performance and reliability of your SignalR application
    under heavy load.
  prefs: []
  type: TYPE_NORMAL
- en: However, we understand that SignalR applications add the option of developing
    real-time applications using ASP.NET Core 9 and their hosting does not present
    major differences from traditional web-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 10*](B21788_10.xhtml#_idTextAnchor162) , we will explore in greater
    detail how we can host any type of web-based application dynamically, using the
    best practices available.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned vital skills for creating dynamic real-time applications.
    We learned about the powerful features of ASP.NET Core 9 SignalR, its architectural
    model and fundamentals, and supporting technologies, as well as creating a real-time
    task management application. Furthermore, we explained the concepts of streaming
    in SignalR and covered the main activities required to host SignalR applications
    on servers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore working with data and persistence by learning
    the aspects of data management and persistence in ASP.NET Core 9 applications,
    using technologies such as Entity Framework Core. We will delve deeper into your
    understanding of database interactions and state management. These are essential
    components for any web-based application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Data and Security'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing modern web solutions, we must deal with data persistence models
    and, of course, security. In this part, we will cover the principles, patterns,
    and best practices for connecting applications developed in ASP.NET Core 9 to
    databases such as SQL Server. We will learn about the entity-relational and NoSQL
    persistence models. We will learn how ASP.NET Core 9 provides powerful tools for
    interacting with data access layers and we will learn about the use of technologies
    such as EntityFramework Core and Dapper. In addition to interacting with data,
    we will learn about aspects related to application security, understanding the
    use of authorization and authentication, and how to implement applications that
    restrict access to information using ASP.NET Core Identity.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B21788_05.xhtml#_idTextAnchor078) , *Working with Data and Persistence*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B21788_06.xhtml#_idTextAnchor093) , *Enhancing Security and Quality*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
