- en: Chapter 6. The Sharing Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss one of the most interesting and important
    aspects of developing with Xamarin: cross-platform code sharing. We will cover
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The file linking technique
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Portable Class Libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pros and cons of each approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing and reuse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the advantages of using Xamarin and C# is the ability to share code across
    your mobile apps as well as other .NET solutions. The reuse of code can provide
    significant productivity and reliability advantages as well as reduce many of
    the long-term maintenance headaches that come with long-lived apps. That's great,
    but anyone who has been involved in software development for a long period of
    time understands that reuse is not free and not simple to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are practical aspects of reuse; the question is, "Physically, how do
    I package my code for reuse?" For this, we can use one of the following three
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Share source code that can be compiled into multiple projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Share **Dynamic-Link Library** (**DLL**) that can be referenced by multiple
    projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Share code as a service that can be accessed remotely by multiple clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also more strategic aspects; again the question arises, "How can
    I organize my code so that I can reuse more of it?" To solve this problem, we
    have the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a layered approach so that data access logic and business validation
    is separated out of the user interface logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize interfaces and frameworks that abstract platform-specific services away
    from the reusable layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will touch on both these aspects of reuse, but primarily
    focus on the practical side of reuse. Specifically, we will present two different
    approaches to bundle up the code for reuse.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what parts of our code should we try and reuse? In the work we have done
    on the `NationalParks` apps so far, one obvious set of code stands out for reuse:
    the persistence code, which is the logic that loads parks from a JSON file and
    saves them back to the same file. In [Chapter 5](ch05.html "Chapter 5. Developing
    Your First Android App with Xamarin.Android"), *Developing Your First Android
    App with Xamarin.Android*, we moved towards a reusable solution by creating the
    `NationalParkData` singleton. In this chapter, we will demonstrate two different
    methods for sharing the `NationalParkData` singleton across both our projects
    as well as other .NET projects that might need it.'
  prefs: []
  type: TYPE_NORMAL
- en: Old school source file linking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File linking refers to a technique where source code files are linked or referenced
    by a Xamarin project and are compiled when a build is run on the project along
    with the rest of the source code in the project. When using file linking, a separate
    DLL is not created for the files you are sharing, rather the code is compiled
    into the same DLL produced for the project that the file is linked to; in our
    case, either `NationalParks.iOS.dll` or `NationalParks.Droid.dll`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a shared library project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by creating a new `Library` project to house the reusable code.
    To create a `Library` project, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new library project with the name `NationalParks.Data` to the `NationalParks`
    solution. You can find the `Library` project template in the **New Project** dialog
    box under **C#** | **Library**, as shown in the following screenshot:![Creating
    a shared library project](img/0838OT_06_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove `MyClass.cs` from the new project. When removing the file, selecting
    **Delete** will remove the file from being referenced by the project and delete
    the underlying file from the filesystem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Target Framework** option to **Mono/.NET 4.5** in the **Project Options**
    dialog box under **Build** | **General**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the `NationalPark.cs` and `NationalParkData.cs` files from `NationalParks.Droid`
    to `NationalPark.Data`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `NationalPark.cs` and `NationalParkData.cs` and change the namespace to
    `NationalParks.Data`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a public string `DataDir` property to `NationalParkData` and use it in
    the `GetFilename()` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Move the logic to load the `parks` data from the constructor to a new method
    named `Load()`, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile `NationalParks.Data`. You will receive compile errors due to unresolved
    references to Json.NET. Unfortunately, we cannot simply add a reference to the
    component version of Json.NET that we previously downloaded from the Xamarin component
    store because this version is built to be used with the Xamarin.iOS and Xamarin.Android
    profiles and is not binary compatible with Mono/.NET 4.5 library projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the Json.NET library to the project using NuGet. Select `NationalParks.Data`,
    right-click on it, and navigate to **Add** | **Add Packages**. Enter `Json.NET`
    in the search field, check the **Json.NET** entry in the list, and select **Add
    Packages**. The following screenshot shows the **Add Packages** dialog box:![Creating
    a shared library project](img/0838OT_06_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile `NationalParks.Data`; you should receive no compile errors this time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating NationalParks.Droid to use shared files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the `NationalParksData` singleton in a separate project, we
    are now ready to reuse it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To update `NationalParks.Droid` in order to use the shared solution, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select `NationalPark.cs` and `NationalParksData.cs` in the **Solution** pad,
    right-click on it, select **Remove**, and then select **Delete**. This will remove
    the selected files from the project and physically delete them from the project
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `NationalParks.Droid`, add a folder named `NationalParks.Data`. This folder
    will not contain any files, but will simply be used within the project structure
    to organize links to the shared files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `NationalParks.Data` folder, right-click on it, and navigate to **Add**
    | **Add Files** to add the existing files to the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Add Files** dialog box, navigate to the `NationalParks.Data` project
    folder, select `NationalPark.cs` and `NationalParkData.cs`, and click on **Open**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Add File to Folder** dialog box, select **Add a link to file**, check
    the **Use the same action for all selected files** option, and click on **OK**.
    Expand the **NationalParks.Data** folder to see that two file links are added.
    The following screenshot shows the **Add File to Folder** dialog box:![Updating
    NationalParks.Droid to use shared files](img/0838OT_06_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `using` clause to the `NationalParks.Data` namespace and remove any `using`
    directives for `Newtonsoft.Json` in `MainActivity`, `DetailActivity`, `EditActivity`,
    and `NationalParksAdapter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `MainActivity.OnCreate()`, set the `NationalParksData.DataDir` property
    and call the `Load()` method prior to creating the `ListView` adapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app. You should see no noticeable behavior changes, but
    we are now using the serialization and storage logic in a shareable way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating NationalParks.iOS to use shared files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's move on to update `NationalParks.iOS`. We have a little more work
    to do here because if you can recall, we had the file handling logic spread out
    in several areas.
  prefs: []
  type: TYPE_NORMAL
- en: 'To update `NationalParks.iOS` in order to use the shared solution, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove `NationalPark.cs` from the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a folder named `NationalParks.Data` in the `NationalParks.Droid` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add file links to `NationalPark.cs` and `NationalParksData.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `MasterViewController.cs`, add a `using` instance of `NationalParks.Data`,
    and remove the `using` instance of `Newtonsoft.Json`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `MasterViewController.ViewDidLoad()`, set the `DataDir` property before
    creating the data source for `UITableView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `DataSource` class, remove the `Parks` collection and remove the loading
    action of the `Parks` collection in the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the methods in `DataSource` to reference the `Parks` collection property
    in `NationalParksData`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the `Parks` property from `DataSource` and update `MasterViewController.PrepareForSegue()`
    to use the `Parks` property in `NationalParksData`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `DetailViewController` and add a `using` instance of `NationalParks.Data`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `SetNavData()`, remove the `Parks` collection argument, corresponding private
    variable, and then update the navigation logic in `MasterViewController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `EditViewController` and add a `using` directive for `NationalParks.Data`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `SetNavData()`, remove the `Parks` collection argument, corresponding private
    variable, and then update the navigation logic in `MasterViewController` and `DetailViewController`
    so that no `Parks` collection is passed in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the `SaveParks()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `DoneClicked()`, replace the logic that adds the park to the collection
    and saves the collection with a call to `NationalParksData.Instance.Save()`, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `DeleteClicked()`, replace the logic that removes the park from the collection
    and saves the collection with a call to `NationalParks.Instance.Delete()`, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app. As with `NationalParks.Droid`, you should see no noticeable
    behavior changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Portable Class Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Portable Class Libraries** (**PCL**) are libraries that conform to a Microsoft
    standard and can be shared in a binary format across many different platforms
    such as Windows 7 desktop, Windows 8 desktop, Windows 8 phone, Xbox 360, and Mono.
    The big advantage with a PCL is that you can share a single binary for all these
    platforms and avoid distributing source code. However, there are some significant
    challenges.'
  prefs: []
  type: TYPE_NORMAL
- en: One issue we face straightaway is the fact that our code uses APIs that are
    not supported across all the platforms; specifically `File.Exists()`, `File.ReadAllText()`,
    and `File.WriteAllText()`. It seems surprising, but most of `System.IO` is not
    common across all of the .NET profiles; so, the file I/O logic can be difficult
    to deal with within the shared code. In our case, there are only three methods
    and we can easily abstract this logic away from the shared code by creating an
    IO interface. Each platform that uses our shared solution will be responsible
    for providing an implementation of the IO interface.
  prefs: []
  type: TYPE_NORMAL
- en: Creating NationalParks.PortableData
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step is to create the Portable Class Library to house our shared
    solution. To create `NationalParks.PortableData`, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new Portable Class Library project to the `NationalParks` solution. The
    project template can be found under **C#** | **Portable Library**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove `MyClass.cs` from the newly created project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy `NationalPark.cs` and `NationalParksData.cs` from the `NationalParks.Data`
    project to `NationalParks.PortableData`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a reference to the Json.NET Portable Class Library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `IFileHandler` interface and add three methods that abstract the
    three IO methods we need. It will be best to make the read and write methods asynchronous
    returning `Task<>`, because many of the platforms only support asynchronous IO.
    This will simplify implementing the interface on these platforms. The following
    code demonstrates the required action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a public `IFileHandler` property to `NationalParksData` and change all
    the logic to use this property rather than using `System.IO.File`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implementing IFileHandler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now need to create an implementation of `IFileHandler` that can be used by
    both our projects. We will share the file handler implementation using the file
    linking method from the previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement `IFileHandler`, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `NationalParks` solution, create a new `Library` project named `NationalParks.IO`
    and set the **Target framework** option to **Mono/.NET 4.5**. This will serve
    as a shared project for our file handler implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the `MyClass.cs file` created by default and add a reference to `NationalParks.PortableData`.
    This will give us access to the `IFileHandler` interface we intend to implement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class named `FileHandler` in `NationalParks.IO`. Add a `using` directive
    for the `NationalParks.PortableData` namespace and specify that the class implements
    the `IFileHandler` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the **Implement** interface menu item under **Refactor** to create stub
    implementations for each method on the interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement each of the stub methods. The following code demonstrates the required
    action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Updating NationalParks.Droid to use PCL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, it's time to update `NationalParks.Droid` in order to use our new PCL.
  prefs: []
  type: TYPE_NORMAL
- en: 'To update `NationalParks.Droid` in order to use `NationalParks.PortableData`,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `NationalParks.Droid` project, remove the `NationalParks.Data` folder,
    create a new folder named `NationalParks.IO`, and add a reference to `NationalParks.PortableData`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `NationalParks.IO` folder, add **Link** to the `FileHandler` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `MainActivity.cs`, add a `using` clause for `NationalParks.IO` and `NationalParks.PortableData`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `MainActivity.OnCreate()`, initialize the `FileHandler` property with an
    instance of `FileHandler`, place an `await` instance on the call to `Load()`,
    and move the assignment of `NationalParksAdapter` before the call to `Load()`,
    as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we are loading data asynchronously, the `OnPause()` method will likely
    be called before the asynchronous return of `OnCreate()`. Thus we need to add
    a null check for the logic in `OnPause()` that calls `NotifyDataSetChanged()`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `NationalParksAdapter.cs`, `DetailActivity.cs`, and `EditActivity.cs`, add
    a `using` clause for `NationalParks.PortableData`, and remove the `using` directive
    for `NationalParks.Data`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and run the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating NationalParks.iOS to use PCL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, it's time to update `NationalParks.IOS`. For the most part, we go through
    essentially the same steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'To update `NationalParks.iOS` in order to use `NationalParks.PortableData`,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `NationalParks.Droid` project, remove the `NationalParks.Data` folder,
    create a new folder named `NationalParks.IO`, and add a reference to `NationalParks.PortableData`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `NationalParks.IO` folder, add **Link** to the `FileHandler` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `MasterViewController.cs`, add a `using` clause for `NationalParks.IO` and
    `NationalParks.PortableData`, and remove the `using` directive for `NationalParks.Data`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `MasterViewController.ViewDidLoad()`, initialize the `FileHandler` property
    with an instance of `FileHandler`, place an `await` instance on the call to `Load()`,
    and place a call to `TableView.ReloadData()` after the assignment of the data
    source, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `DetailViewController.cs` and `EditViewController.cs`, replace the `using`
    directive for `NationalParks.Data` with `NationalParks.PortableData`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and run the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The pros and cons of the code-sharing techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have some experience with two practical methods for sharing code
    across Xamarin.iOS and Xamarin.Android apps, let''s look at some pros and cons.
    The following table summarizes some of the pros and cons of each approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Pros | Cons |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| File linking |'
  prefs: []
  type: TYPE_TB
- en: This allows for a broader use of .NET APIs, assuming that these APIs are supported
    by all the platforms that will use the shared code. If you are only targeting
    Xamarin.iOS and Xamarin.Android, this works pretty well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: This requires source code to be shared.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These API dependency issues might not be known until shared code has been compiled
    for each target platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Portable Class Library |'
  prefs: []
  type: TYPE_TB
- en: This ensures platform API compatibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This allows for distribution of binary code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: This limits the namespaces and APIs available for use in your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed two practical approaches to share code across Xamarin
    projects as well as other .NET solutions. In the next chapter, we will investigate
    MvvmCross, a framework that simplifies implementing the Model-View-ViewModel design
    pattern, increasing the amount of shared code across platforms.
  prefs: []
  type: TYPE_NORMAL
