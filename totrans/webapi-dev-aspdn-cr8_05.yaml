- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: 'Data Access in ASP.NET Core (Part 1: Entity Framework Core Fundamentals)'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core 中的数据访问（第 1 部分：EF Core 基础）
- en: In [*Chapter 2*](B18971_02.xhtml#_idTextAnchor068), we introduced a simple ASP.NET
    Core application to manage blog posts, which uses a static field to store the
    data in memory. In many real-world applications, the data is persisted in databases
    – such as SQL Server, MySQL, SQLite, PostgreSQL, and so on – so we will need to
    access the database to implement the CRUD operations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 2 章*](B18971_02.xhtml#_idTextAnchor068) 中，我们介绍了一个简单的 ASP.NET Core 应用程序来管理博客文章，它使用静态字段在内存中存储数据。在许多实际应用中，数据持久化在数据库中——如
    SQL Server、MySQL、SQLite、PostgreSQL 等——因此我们需要访问数据库以实现 CRUD 操作。
- en: In this chapter, we will learn about data access in ASP.NET Core. There are
    many ways to access the database in ASP.NET Core, such as through ADO.NET, Entity
    Framework Core, and Dapper, among others. In this chapter, we will focus on Entity
    Framework Core, which is the most popular **object-relational mapping** (**ORM**)
    framework in .NET Core.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章，我们将学习 ASP.NET Core 中的数据访问。在 ASP.NET Core 中访问数据库有多种方式，例如通过 ADO.NET、Entity
    Framework Core 和 Dapper 等。在本章中，我们将重点介绍 Entity Framework Core，它是 .NET Core 中最受欢迎的
    **对象关系映射**（**ORM**）框架。
- en: '**Entity Framework Core**, or **EF Core** for short, is an open-source ORM
    framework that allows us to create and manage mapping configurations between the
    database schema and the object models. It provides a set of APIs to perform CRUD
    operations using LINQ methods, which is like operating the objects in memory.
    EF Core supports many database providers, such as SQL Server, SQLite, PostgreSQL,
    MySQL, and so on. It also supports many other features, such as migrations, change
    tracking, and so on.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**Entity Framework Core**，简称 **EF Core**，是一个开源的 ORM 框架，它允许我们创建和管理数据库模式与对象模型之间的映射配置。它提供了一套使用
    LINQ 方法执行 CRUD 操作的 API，就像在内存中操作对象一样。EF Core 支持许多数据库提供程序，如 SQL Server、SQLite、PostgreSQL、MySQL
    等。它还支持许多其他功能，如迁移、变更跟踪等。'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章，我们将涵盖以下主题：
- en: Why use ORM?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么使用 ORM？
- en: Configuring the DbContext class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 DbContext 类
- en: Implementing CRUD controllers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 CRUD 控制器
- en: Basic LINQ queries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本 LINQ 查询
- en: Configuring the mapping between models and database tables
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置模型与数据库表之间的映射
- en: By the end of this chapter, you will be able to use EF Core to access the database
    in ASP.NET Core applications and perform basic CRUD operations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用 EF Core 在 ASP.NET Core 应用程序中访问数据库并执行基本的 CRUD 操作。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code example in this chapter can be found at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter5/](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter5/).
    You can use VS 2022 or VS Code to open the solution.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码示例可以在 [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter5/](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter5/)
    找到。你可以使用 VS 2022 或 VS Code 打开解决方案。
- en: 'You are expected to have basic knowledge of SQL queries and LINQ. If you are
    not familiar with them, you can refer to the following resources:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 预期你具备基本的 SQL 查询和 LINQ 知识。如果你不熟悉它们，可以参考以下资源：
- en: 'SQL queries: [https://www.w3schools.com/sql/](https://www.w3schools.com/sql/)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL 查询：[https://www.w3schools.com/sql/](https://www.w3schools.com/sql/)
- en: 'LINQ: [https://learn.microsoft.com/en-us/dotnet/csharp/linq/](https://learn.microsoft.com/en-us/dotnet/csharp/linq/)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LINQ：[https://learn.microsoft.com/en-us/dotnet/csharp/linq/](https://learn.microsoft.com/en-us/dotnet/csharp/linq/)
- en: Why use ORM?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用 ORM？
- en: To operate the data in relational databases, we need to write SQL statements.
    However, SQL statements are not easy to maintain and are not type-safe. Every
    time you update the database schema, you need to update the SQL statements as
    well, which is error-prone. In many traditional applications, the logic is tightly
    coupled with the database. For example, the logic could be defined in a SQL database
    directly, such as stored procedures, triggers, and so on. This makes the application
    hard to maintain and extend.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要操作关系型数据库中的数据，我们需要编写 SQL 语句。然而，SQL 语句不易维护且不安全类型。每次更新数据库模式时，都需要更新 SQL 语句，这容易出错。在许多传统应用中，逻辑与数据库紧密耦合。例如，逻辑可以直接在
    SQL 数据库中定义，如存储过程、触发器等。这使得应用难以维护和扩展。
- en: ORM helps us to map the database schema to the object model, so we can operate
    the data in the database just like we operate the objects in memory. ORM can translate
    the CRUD operations to SQL statements, which means it is like an abstract layer
    between the application and the database. The data access logic is decoupled from
    the database, so we can easily change the database without changing the code.
    Also, it provides strong type safety, so we can avoid runtime errors caused by
    type mismatch.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 帮助我们将数据库架构映射到对象模型，这样我们就可以像操作内存中的对象一样操作数据库中的数据。ORM 可以将 CRUD 操作转换为 SQL 语句，这意味着它就像应用程序和数据库之间的一个抽象层。数据访问逻辑与数据库解耦，因此我们可以轻松地更改数据库而无需更改代码。此外，它提供了强类型安全，因此我们可以避免由类型不匹配引起的运行时错误。
- en: Keep in mind that we are not saying that ORM is the best solution for all scenarios.
    Sometimes, we need to write SQL statements directly to achieve the best performance.
    For example, if we need to generate a complex data report, we may need to write
    SQL statements to optimize the performance of the query. However, for most scenarios,
    ORM provides more benefits than drawbacks.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们并不是说 ORM 是所有场景下的最佳解决方案。有时，我们需要直接编写 SQL 语句以实现最佳性能。例如，如果我们需要生成一个复杂的数据报告，我们可能需要编写
    SQL 语句来优化查询性能。然而，对于大多数场景，ORM 提供的好处比缺点更多。
- en: 'There are many ORM frameworks in .NET. In this book, we will use EF Core, which
    is the most popular ORM framework in .NET Core. The following are the reasons
    why we chose EF Core:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 中有许多 ORM 框架。在这本书中，我们将使用 EF Core，这是 .NET Core 中最受欢迎的 ORM 框架。以下是选择 EF Core
    的原因：
- en: '**Open-source**: EF Core is an open-source project and is mainly maintained
    by Microsoft, so it is well-supported. The contribution is also very active.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开源**: EF Core 是一个开源项目，主要由微软维护，因此它得到了良好的支持。贡献也非常活跃。'
- en: '**Multiple database support**: EF Core supports many database providers, such
    as SQL Server, SQLite, PostgreSQL, MySQL and so on. Developers can use the same
    APIs to access different databases.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多数据库支持**: EF Core 支持许多数据库提供程序，例如 SQL Server、SQLite、PostgreSQL、MySQL 等等。开发者可以使用相同的
    API 访问不同的数据库。'
- en: '**Migration**: EF Core supports database migrations, which allows us to update
    the database schema easily.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迁移**: EF Core 支持数据库迁移，这使得我们能够轻松地更新数据库架构。'
- en: '**LINQ support**: EF Core provides support for LINQ, which allows us to use
    a familiar syntax to query the database.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LINQ 支持**: EF Core 提供了对 LINQ 的支持，这使得我们可以使用熟悉的语法来查询数据库。'
- en: '**Code-first approach**: EF Core supports the code-first approach, which means
    we can define the database schema using C# code, and EF Core will generate the
    database schema automatically.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码优先方法**: EF Core 支持代码优先方法，这意味着我们可以使用 C# 代码定义数据库架构，EF Core 将自动生成数据库架构。'
- en: '**Performance**: EF Core is designed to be lightweight and performant. It supports
    query caching and lazy loading to help improve performance. Also, EF Core provides
    asynchronous APIs, which allows us to perform database operations asynchronously
    to improve the scalability of the application. In addition, EF Core supports raw
    SQL queries, enabling us to write SQL statements directly to achieve the best
    performance.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**: EF Core 被设计成轻量级且性能良好。它支持查询缓存和延迟加载，有助于提高性能。此外，EF Core 提供了异步 API，允许我们异步执行数据库操作，从而提高应用程序的可伸缩性。此外，EF
    Core 支持原始 SQL 查询，使我们能够直接编写 SQL 语句以实现最佳性能。'
- en: Overall, EF Core is a good choice for most scenarios if you are using .NET Core.
    So, in this book, we will be using EF Core as the ORM framework.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，如果您使用 .NET Core，EF Core 对于大多数场景都是一个不错的选择。因此，在这本书中，我们将使用 EF Core 作为 ORM
    框架。
- en: 'To use the .NET Core CLI to perform EF Core-related tasks, we first need to
    install the `dotnet-ef` tool. You can install it using the following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 .NET Core CLI 执行 EF Core 相关任务，我们首先需要安装 `dotnet-ef` 工具。您可以使用以下命令进行安装：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is recommended to install the tool as a global tool, so you can use it in
    any project for convenience.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 建议将工具安装为全局工具，这样您就可以方便地在任何项目中使用它。
- en: 'Next, create a new web API project using the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令创建一个新的 Web API 项目：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, navigate to the project folder and run the following command to install
    EF Core packages:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，导航到项目文件夹并运行以下命令来安装 EF Core 包：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first package is the database provider, which is used to connect the application
    to a SQL Server database. For this demo application, we will use **LocalDB**,
    which is a lightweight version of SQL Server. The second package contains shared
    design-time components for EF Core tools, which are required to perform database
    migrations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个包是数据库提供程序，用于将应用程序连接到SQL Server数据库。对于这个演示应用程序，我们将使用**LocalDB**，这是SQL Server的一个轻量级版本。第二个包包含EF
    Core工具的共享设计时组件，这些组件是执行数据库迁移所必需的。
- en: What is LocalDB?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是LocalDB？
- en: LocalDB is designed to be used as a substitute for the full version of SQL Server;
    it is suitable for development and testing, but not for production use. We can
    use LocalDB for development and replace the connection string when we deploy the
    application to production. LocalDB is installed with VS 2022\. If you do not have
    VS 2022 by default, you can find the installation package at [https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/sql-server-express-localdb](https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/sql-server-express-localdb).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: LocalDB被设计成SQL Server完整版本的替代品；它适用于开发和测试，但不适用于生产使用。当我们部署应用程序到生产环境时，我们可以使用LocalDB进行开发并替换连接字符串。LocalDB与VS
    2022一起安装。如果您默认没有VS 2022，您可以在[https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/sql-server-express-localdb](https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/sql-server-express-localdb)找到安装包。
- en: LocalDB is supported by Windows only. If you use macOS or Linux, you can use
    SQLite instead of LocalDB, or use a Docker container to run SQL Server. For more
    information about SQLite, please refer to [https://docs.microsoft.com/en-us/ef/core/providers/sqlite/](https://docs.microsoft.com/en-us/ef/core/providers/sqlite/).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: LocalDB仅由Windows支持。如果您使用macOS或Linux，可以使用SQLite代替LocalDB，或者使用Docker容器来运行SQL Server。有关SQLite的更多信息，请参阅[https://docs.microsoft.com/en-us/ef/core/providers/sqlite/](https://docs.microsoft.com/en-us/ef/core/providers/sqlite/)。
- en: For more information about SQL Server on Docker, please refer to [https://learn.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker](https://learn.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker).
    Note that there are many other database providers, such as SQLite, PostgreSQL,
    MySQL, and so on. You can find the full list of database providers at [https://docs.microsoft.com/en-us/ef/core/providers/](https://docs.microsoft.com/en-us/ef/core/providers/).
    Some providers are not maintained by Microsoft.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有关SQL Server在Docker上的更多信息，请参阅[https://learn.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker](https://learn.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker)。请注意，还有许多其他数据库提供程序，例如SQLite、PostgreSQL、MySQL等。您可以在[https://docs.microsoft.com/en-us/ef/core/providers/](https://docs.microsoft.com/en-us/ef/core/providers/)找到数据库提供程序的完整列表。一些提供程序不是由Microsoft维护的。
- en: Next, let’s explore how to use EF Core to access the database.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索如何使用EF Core访问数据库。
- en: Configuring the DbContext class
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置DbContext类
- en: To represent the database, EF Core uses the `DbContext` class, which allows
    us to query and save data. An instance of the `DbContext` class maintains the
    database connection and maps the database schema to the object model. It also
    tracks the changes in objects and manages the transactions. If you are familiar
    with OOP, you can think of the `DbContext` class as a bridge between the database
    and the object model, just like an interface. When you query or save data, you
    operate the objects through the `DbContext` class, and EF Core will translate
    the operations to the corresponding SQL statements.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示数据库，EF Core使用`DbContext`类，它允许我们查询和保存数据。`DbContext`类的一个实例维护数据库连接并将数据库模式映射到对象模型。它还跟踪对象的变化并管理事务。如果您熟悉面向对象编程，可以将`DbContext`类视为数据库和对象模型之间的桥梁，就像一个接口。当您查询或保存数据时，您通过`DbContext`类操作对象，EF
    Core会将操作转换为相应的SQL语句。
- en: In this chapter, we will develop a simple application to manage invoices. This
    application will be used to demonstrate how to use EF Core to access the database,
    including how to define the database schema, how to perform CRUD operations, and
    how to use migrations to update the database schema.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发一个简单的应用程序来管理发票。这个应用程序将用于演示如何使用EF Core访问数据库，包括如何定义数据库模式，如何执行CRUD操作，以及如何使用迁移来更新数据库模式。
- en: You can follow [*Chapter 1*](B18971_01.xhtml#_idTextAnchor012) to define the
    API contract first. The API contract defines the endpoints and the request/response
    models. When we define the API contract, note that we need to consult stakeholders
    to understand the requirements. For example, we need to know the fields of the
    invoice, the data types of the fields, and so on. We also need to understand the
    business rules, such as *the invoice number should be unique*, and *the invoice
    amount should be greater than 0*, for example. That means we will spend lots of
    time on the API design phase. Here, we assume that we have already defined the
    API contract, and we can start to develop the application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考 [*第 1 章*](B18971_01.xhtml#_idTextAnchor012) 来首先定义 API 合同。API 合同定义了端点和请求/响应模型。当我们定义
    API 合同时，请注意我们需要咨询利益相关者以了解需求。例如，我们需要知道发票的字段、字段的数据类型等。我们还需要了解业务规则，例如 *发票号应该是唯一的*，*发票金额应该大于
    0* 等。这意味着我们将在 API 设计阶段花费大量时间。在这里，我们假设我们已经定义了 API 合同，并且可以开始开发应用程序。
- en: Creating models
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模型
- en: The first step is to define the models. A model, also known as an entity, is
    a class that represents an object in the real world, which will be mapped to a
    table (or multiple tables) in the database. In this demo application, we need
    to define the `Invoice` model.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是定义模型。模型，也称为实体，是一个代表现实世界中对象的类，它将被映射到数据库中的表（或多个表）。在本演示应用程序中，我们需要定义 `Invoice`
    模型。
- en: 'An invoice can be defined as the following class:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 发票可以定义为以下类：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`InvoiceStatus` is a custom enum type, which is defined as the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`InvoiceStatus` 是一个自定义枚举类型，其定义如下所示：'
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can create a file named `Invoice.cs` in the `Models` folder and copy the
    `Invoice` class code into the file.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `Models` 文件夹中创建一个名为 `Invoice.cs` 的文件，并将 `Invoice` 类代码复制到该文件中。
- en: Important note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We use the `Guid` type for the `Id` property, which is the unique identifier
    for the invoice. You can also use `int` or `long` as the identifier. Either way
    has its pros and cons. For example, `int` is more efficient than `Guid`, but it
    is not unique across databases. When the database grows, you may need to split
    the data into multiple databases, which means the `int` identifier may not be
    unique anymore. On the other hand, `Guid` is unique no matter how many databases
    you have, but it is more expensive to store, insert, query, and sort the records
    than using `int` or `long`. The `Guid` primary key with the cluster index may
    cause poor performance in some scenarios. In this demo application, we use `Guid`
    as the identifier for now. We will discuss more about the techniques to optimize
    the application performance in future chapters.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Guid` 类型来表示 `Id` 属性，这是发票的唯一标识符。您也可以使用 `int` 或 `long` 作为标识符。两种方式都有其优缺点。例如，`int`
    比使用 `Guid` 更高效，但它不是跨数据库唯一的。当数据库增长时，您可能需要将数据分割到多个数据库中，这意味着 `int` 标识符可能不再唯一。另一方面，`Guid`
    无论您有多少个数据库都是唯一的，但与使用 `int` 或 `long` 相比，存储、插入、查询和排序记录的成本更高。在某些场景中，具有聚类索引的 `Guid`
    主键可能会导致性能下降。在本演示应用程序中，我们目前使用 `Guid` 作为标识符。我们将在未来的章节中讨论更多关于优化应用程序性能的技术。
- en: We also use the `DateTimeOffset` type for the `InvoiceDate` and `DueDate` properties,
    which is the recommended type for date and time in .NET Core. You can also use
    the `DateTime` type if you do not care about the time zone. `DateTimeOffset` includes
    a time zone offset from UTC time, and it is supported by both .NET type and SQL
    Server. This is helpful if you want to avoid the time zone issues.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用 `DateTimeOffset` 类型来表示 `InvoiceDate` 和 `DueDate` 属性，这是 .NET Core 中日期和时间的推荐类型。如果您不关心时区，也可以使用
    `DateTime` 类型。`DateTimeOffset` 包含从 UTC 时间的时间偏移量，它由 .NET 类型和 SQL Server 支持。如果您想避免时区问题，这将很有帮助。
- en: We may need more properties in the future, such as contact information, invoice
    items, and so on, but we will add them later. Let’s focus on only the model for
    now.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 未来我们可能需要更多的属性，例如联系信息、发票项目等，但我们稍后再添加。现在让我们只关注模型。
- en: Creating and configuring the DbContext class
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和配置 DbContext 类
- en: 'Next, we will create a `DbContext` class to represent the database. Create
    a file named `InvoiceDbContext.cs` in the `Data` folder and add the following
    code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个 `DbContext` 类来表示数据库。在 `Data` 文件夹中创建一个名为 `InvoiceDbContext.cs` 的文件，并添加以下代码：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding code, we have done the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下操作：
- en: Inherited the `DbContext` class and defined the `InvoiceDbContext` class, which
    represents the database.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承了 `DbContext` 类并定义了 `InvoiceDbContext` 类，该类代表数据库。
- en: Defined the `Invoices` property, which is a `DbSet<Invoice>` type. It is used
    to represent the `Invoices` table in the database.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义了 `Invoices` 属性，它是一个 `DbSet<Invoice>` 类型。它用于表示数据库中的 `Invoices` 表。
- en: Important note
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Why we do not use `public DbSet<Invoice> Invoices { get; set; }` here? The reason
    is that if the `DbSet<T>` properties are not initialized, the compiler will emit
    warnings from them because the nullable reference type feature is enabled by default.
    So we can use a `Set<TEntity>()` method to initialize the property to eliminate
    the warning. Another way to fix that is to use the null-forgiving operator, `!`,
    which forces the silencing of the compiler warnings. The `DbContext` base constructor
    will initialize the `DbSet<T>` properties for us, so it is safe to use `!` for
    this case. If you do not mind seeing the warnings, using `public DbSet<Invoice>
    Invoices { get; set; }` also works. You can use either method.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这里不使用 `public DbSet<Invoice> Invoices { get; set; }`？原因是如果 `DbSet<T>` 属性未初始化，由于默认启用了可空引用类型功能，编译器会从它们发出警告。因此，我们可以使用
    `Set<TEntity>()` 方法初始化属性以消除警告。另一种修复方法是使用空值忽略运算符 `!`，它强制关闭编译器警告。`DbContext` 基类构造函数会为我们初始化
    `DbSet<T>` 属性，所以在这种情况下使用 `!` 是安全的。如果你不介意看到警告，使用 `public DbSet<Invoice> Invoices
    { get; set; }` 也可以。你可以使用这两种方法中的任何一种。
- en: 'Next, let’s configure the database connection string. Open the `appsettings.json`
    file and add the following code to the `ConnectionStrings` section:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们配置数据库连接字符串。打开 `appsettings.json` 文件，并在 `ConnectionStrings` 部分添加以下代码：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Important note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can use other databases, such as SQLite or PostgreSQL, but you need to install
    the corresponding database provider and change the connection string accordingly.
    To learn more about connection strings, please refer to [https://learn.microsoft.com/en-us/dotnet/framework/data/adonet/connection-string-syntax](https://learn.microsoft.com/en-us/dotnet/framework/data/adonet/connection-string-syntax).
    There is a website called [https://connectionstrings.com/](https://connectionstrings.com/)
    that can generate connection strings for different database providers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用其他数据库，例如 SQLite 或 PostgreSQL，但你需要安装相应的数据库提供程序并相应地更改连接字符串。有关连接字符串的更多信息，请参阅
    [https://learn.microsoft.com/en-us/dotnet/framework/data/adonet/connection-string-syntax](https://learn.microsoft.com/en-us/dotnet/framework/data/adonet/connection-string-syntax)。有一个网站叫做
    [https://connectionstrings.com/](https://connectionstrings.com/)，可以为不同的数据库提供程序生成连接字符串。
- en: In the preceding connection string, we use `Server=(localdb)\\mssqllocaldb`
    to specify the server as a LocalDB instance, and `Database=BasicEfCoreDemoDb`
    to specify the name of the database. You can change the database name to whatever
    you want. The `Trusted_Connection=True` option specifies that the connection is
    trusted, which means you do not need to provide the username and password. The
    `MultipleActiveResultSets=true` option specifies that the connection can have
    `Include()` method in EF Core.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的连接字符串中，我们使用 `Server=(localdb)\\mssqllocaldb` 来指定服务器为一个 LocalDB 实例，并使用 `Database=BasicEfCoreDemoDb`
    来指定数据库名称。你可以将数据库名称更改为你想要的任何名称。`Trusted_Connection=True` 选项指定连接是受信任的，这意味着你不需要提供用户名和密码。`MultipleActiveResultSets=true`
    选项指定连接可以包含 EF Core 中的 `Include()` 方法。
- en: 'Open the `Program.cs` file and add the following code after `builder` is created:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Program.cs` 文件，并在 `builder` 创建后添加以下代码：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code registers the `InvoiceDbContext` class to the dependency
    injection container. The `AddDbContext<TContext>()` method is an extension method
    that accepts a `DbContextOptionsBuilder` parameter, which calls the `UseSqlServer()`
    method to configure the database provider to use SQL Server or LocalDB. Note that
    we use the `UseSqlServer()` method for both SQL Server and LocalDB. The difference
    is that LocalDB has a `(localdb)\\mssqllocaldb` server name by default. We also
    pass the database connection string to the `UseSqlServer()` method, which should
    be the same as the name we defined in the `appsettings.json` file.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码将 `InvoiceDbContext` 类注册到依赖注入容器中。`AddDbContext<TContext>()` 方法是一个扩展方法，它接受一个
    `DbContextOptionsBuilder` 参数，该参数调用 `UseSqlServer()` 方法来配置数据库提供程序以使用 SQL Server
    或 LocalDB。请注意，我们为 SQL Server 和 LocalDB 都使用了 `UseSqlServer()` 方法。区别在于 LocalDB 默认的服务器名称为
    `(localdb)\\mssqllocaldb`。我们还向 `UseSqlServer()` 方法传递了数据库连接字符串，该字符串应与我们在 `appsettings.json`
    文件中定义的名称相同。
- en: Currently, this code just registers the `InvoiceDbContext` class to the dependency
    injection container, but we have not created the database yet. Next, we will create
    the database using the `dotnet` `ef` command.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，此代码只是将 `InvoiceDbContext` 类注册到依赖注入容器中，但我们尚未创建数据库。接下来，我们将使用 `dotnet` `ef`
    命令创建数据库。
- en: Creating the database
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据库
- en: 'We have defined the `InvoiceDbContext` class, and the instance of `InvoiceDbContext`
    is added to the dependency injection container. Next, we need to create the database
    and the `Invoices` table before we can use it. To create the database and the
    `Invoices` table, we need to run the following command to apply the database migration:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已定义 `InvoiceDbContext` 类，并将 `InvoiceDbContext` 的实例添加到依赖注入容器中。接下来，在我们可以使用它之前，我们需要创建数据库和
    `Invoices` 表。要创建数据库和 `Invoices` 表，我们需要运行以下命令来应用数据库迁移：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `InitialDb` parameter is the migration name. You can use any name you like
    as long as it is a valid C# identifier. It is recommended to use a meaningful
    name, such as `InitialDb`, `AddInvoiceTable`, and so on.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`InitialDb` 参数是迁移名称。只要它是有效的 C# 标识符，您可以使用任何喜欢的名称。建议使用有意义的名称，例如 `InitialDb`、`AddInvoiceTable`
    等。'
- en: The preceding command creates a couple of migration files, such as `<timestamp>_InitialDb.cs`
    and `<timestamp>_InitialDb.Designer.cs`, which are stored in the `Migrations`
    folder. The `<timestamp>_InitialDb.cs` migration file contains an `Up()` method
    to create the database and the tables. It also has a `Down()` method to roll back
    the changes. Note that this command does not create the database; it just creates
    the migration files. Please do not manually modify or delete the migration files
    as they are required to apply or roll back the database changes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令创建了一些迁移文件，例如 `<timestamp>_InitialDb.cs` 和 `<timestamp>_InitialDb.Designer.cs`，这些文件存储在
    `Migrations` 文件夹中。`<timestamp>_InitialDb.cs` 迁移文件包含一个 `Up()` 方法来创建数据库和表。它还有一个
    `Down()` 方法来回滚更改。请注意，此命令不会创建数据库；它只是创建迁移文件。请勿手动修改或删除迁移文件，因为它们是应用或回滚数据库更改所必需的。
- en: 'Here is a sample of the migration files:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是迁移文件的示例：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, the `Up()` method creates the table, columns, and constraints.
    The `Down()` method drops the table. You can use `dotnet ef migrations remove`
    to remove the migration files.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Up()` 方法创建表、列和约束。`Down()` 方法删除表。您可以使用 `dotnet ef migrations remove` 来删除迁移文件。
- en: Important note
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'You may see a warning message like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到如下警告信息：
- en: '**Microsoft.EntityFrameworkCore.Model.Validation[30000]**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**Microsoft.EntityFrameworkCore.Model.Validation[30000]**'
- en: '**No store type was specified for the decimal property ‘Amount’ on entity type
    ‘Invoice’. This will cause > values to be silently truncated if they do not fit
    in the default precision and scale. Explicitly > specify the SQL server column
    type that can accommodate all the values in ‘OnModelCreating’ using > ‘HasColumnType’,
    specify precision and scale using ‘HasPrecision’, or configure a value converter
    using > ‘****HasConversion’.**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**在实体类型‘Invoice’的decimal属性‘Amount’上未指定存储类型。如果这些值不适用于默认的精度和刻度，则会导致 > 值被静默截断。在‘OnModelCreating’中使用
    > ‘HasColumnType’显式指定可以容纳所有值的SQL服务器列类型，使用 > ‘HasPrecision’指定精度和刻度，或使用 > ‘****HasConversion’配置值转换器。**'
- en: This is because we did not specify the precision and scale for the `Amount`
    property. We will fix it later. Currently, EF Core will use the default precision
    and scale for the `decimal` type, which is `decimal(18,2)`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们没有指定 `Amount` 属性的精度和刻度。我们将在稍后修复它。目前，EF Core 将使用 `decimal` 类型的默认精度和刻度，即
    `decimal(18,2)`。
- en: 'The migration file has been created, but it has not been applied to the database
    yet. Next, run the following command to create the database and the `Invoices`
    table:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移文件已创建，但尚未应用到数据库中。接下来，运行以下命令来创建数据库和 `Invoices` 表：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the command is successful, we should find the database file in your user
    folder, such as `C:\Users\{username}\BasicEfCoreDemoDb.mdf` if you use Windows.
    You can use `%USERPROFILE%` to get the user folder path.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令成功，我们应该能在您的用户文件夹中找到数据库文件，例如如果您使用 Windows，则为 `C:\Users\{username}\BasicEfCoreDemoDb.mdf`。您可以使用
    `%USERPROFILE%` 来获取用户文件夹路径。
- en: Important note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'You may encounter an error `System.Globalization.CultureNotFoundException`:
    Only the invariant culture is supported in globalizati[on-invarian](https://aka)t
    mode. See https://aka`.ms/GlobalizationInvariantMode` for more information. `(Parameter
    ''name'')`. This is because starting in .NET 6, the globalization invariant mode
    is enabled by default. You can disable it by setting the `InvariantGlobalization`
    property to `false` in the `csproj` file.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到一个错误 `System.Globalization.CultureNotFoundException`：在全球化不变模式中只支持不变文化。有关更多信息，请参阅
    https://aka.ms/GlobalizationInvariantMode（参数 'name'）。这是因为从 .NET 6 开始，全球化不变模式默认启用。你可以在
    `csproj` 文件中将 `InvariantGlobalization` 属性设置为 `false` 来禁用它。
- en: 'There are several tools you can use to open the LocalDB database file – for
    example, **SQL Server Management Studio** (**SSMS**), which is supported by Microsoft.
    Yo[u can downloa](https://learn)d it here: [https://learn.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms](https://learn.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms).
    You can also use other [tools, such as](https://dbeaver) Dbeaver ([https://dbeaver.io/](https://dbeaver.io/)),
    a free, universal database tool, [or JetBrai](https://www)ns DataGrip ([https://www.jetbrains.com/datagrip/](https://www.jetbrains.com/datagrip/)),
    a powerful database IDE. We’ll be using SSMS.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用几个工具来打开 LocalDB 数据库文件 – 例如，**SQL Server Management Studio**（**SSMS**），它是微软支持的。你可以从这里下载它：[https://learn.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms](https://learn.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms)。你也可以使用其他
    [工具，例如](https://dbeaver) Dbeaver ([https://dbeaver.io/](https://dbeaver.io/))，一个免费、通用的数据库工具，[或者
    JetBrains DataGrip ([https://www.jetbrains.com/datagrip/](https://www.jetbrains.com/datagrip/))，一个强大的数据库
    IDE。我们将使用 SSMS。
- en: 'Open the database file in SSMS, and you will see that the `BasicEfCoreDemoDb`
    database has been created. It will have two tables – `Invoices` and `__EFMigrationsHistory`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SSMS 中打开数据库文件，你会看到已经创建了 `BasicEfCoreDemoDb` 数据库。它将有两个表 – `Invoices` 和 `__EFMigrationsHistory`：
- en: '![Figure 5.1 – The database created by EF Core migration](img/B18971_05_01.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 由 EF Core 迁移创建的数据库](img/B18971_05_01.jpg)'
- en: Figure 5.1 – The database created by EF Core migration
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 由 EF Core 迁移创建的数据库
- en: The `__EFMigrationsHistory` table is used to track the migrations. It is created
    automatically by EF Core. Do not manually modify it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`__EFMigrationsHistory` 表用于跟踪迁移。它由 EF Core 自动创建。请不要手动修改它。'
- en: Now that we have created the database and the `Invoices` table. Next,let’s add
    some seed data to the table.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了数据库和 `Invoices` 表。接下来，让我们向表中添加一些种子数据。
- en: Adding seed data
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加种子数据
- en: 'Open the `InvoiceDbContext.cs` file and add the following code to the `OnModelCreating()`
    method:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `InvoiceDbContext.cs` 文件，并在 `OnModelCreating()` 方法中添加以下代码：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We need to create a new database migration to apply the changes to the database.
    Run the following command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个新的数据库迁移来将更改应用到数据库。运行以下命令：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you check the database in SSMS, you will see that the seed data is added
    to the `Invoices` table.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查 SSMS 中的数据库，你会看到种子数据已经被添加到 `Invoices` 表中。
- en: The data is ready. Next, we will create the controllers to handle the HTTP requests
    and operate the data with the database.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 数据已经准备好了。接下来，我们将创建控制器来处理 HTTP 请求并使用数据库操作数据。
- en: Implementing CRUD controllers
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现CRUD控制器
- en: In this section, we will implement the controllers to handle the HTTP requests,
    which are the `GET`, `POST`, `PUT`, and `DELETE` operations that are used to retrieve,
    create, update, and delete data, respectively.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现控制器来处理 HTTP 请求，这些请求是 `GET`、`POST`、`PUT` 和 `DELETE` 操作，分别用于检索、创建、更新和删除数据。
- en: Creating the controller
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建控制器
- en: 'If you have installed the `dotnet aspnet-codegenerator` tool following [*Chapter
    2*](B18971_02.xhtml#_idTextAnchor068), you can use the following command to create
    a controller with the specific `DbContext`. Do not forget to install the `Microsoft.VisualStudio.Web.CodeGeneration.Design`
    NuGet package, which is required by the `dotnet` `aspnet-codegenerator` tool:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经按照 [*第 2 章*](B18971_02.xhtml#_idTextAnchor068) 安装了 `dotnet aspnet-codegenerator`
    工具，你可以使用以下命令来创建一个具有特定 `DbContext` 的控制器。不要忘记安装 `Microsoft.VisualStudio.Web.CodeGeneration.Design`
    NuGet 包，这是 `dotnet` `aspnet-codegenerator` 工具所必需的：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding command has some parameters as shown here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令有一些参数，如下所示：
- en: '`-name`: The name of the controller.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-name`：控制器的名称。'
- en: '`-api`: Indicates that the controller is an API controller.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-api`：表示控制器是一个 API 控制器。'
- en: '`-outDir`: The output directory of the controller.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-outDir`：控制器的输出目录。'
- en: '`--model`: The model class name. In this case, it is the `Invoice` class.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--model`：模型类名。在这种情况下，它是 `Invoice` 类。'
- en: '`--dataContext`: The `DbContext` class name. In this case, it is the `InvoiceDbContext`
    class.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--dataContext`：`DbContext` 类名。在这种情况下，它是 `InvoiceDbContext` 类。'
- en: '`-async`: Indicates that the actions of the controller are asynchronous.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-async`：表示控制器的操作是异步的。'
- en: For more information about the `dotnet` [`aspnet-codeg`](https://learn)`enerator`
    tool, see [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/tools/dotnet-aspnet-codegenerator](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/tools/dotnet-aspnet-codegenerator).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 `dotnet` `aspnet-codegenerator` 工具的更多信息，请参阅 [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/tools/dotnet-aspnet-codegenerator](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/tools/dotnet-aspnet-codegenerator)。
- en: 'The `dotnet aspnet-codegenerator` tool will create a controller with the following
    actions:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`dotnet aspnet-codegenerator` 工具将创建一个具有以下操作的控制器：'
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It is so easy! The `dotnet aspnet-codegenerator` tool has generated the controller
    with basic CRUD operations. You can run the application and test the API endpoints
    with the Swagger UI. We will explain the code of the controller in detail.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 它非常简单！`dotnet aspnet-codegenerator` 工具已生成具有基本 CRUD 操作的控制器。您可以运行应用程序并使用 Swagger
    UI 测试 API 端点。我们将详细解释控制器的代码。
- en: How controllers work
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器是如何工作的
- en: In [*Chapter 2*](B18971_02.xhtml#_idTextAnchor068) and[*Chapter 3*](B18971_03.xhtml#_idTextAnchor130),
    we introduced how HTTP requests are mapped to the controller actions. In this
    chapter, we focus on data access and database operations.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 2 章*](B18971_02.xhtml#_idTextAnchor068) 和 [*第 3 章*](B18971_03.xhtml#_idTextAnchor130)
    中，我们介绍了 HTTP 请求是如何映射到控制器操作的。在本章中，我们重点关注数据访问和数据库操作。
- en: First, we use DI to inject the `InvoiceDbContext` instance into the controller,
    which handles the database operations. As developers, normally, we do not need
    to worry about the database connection. `InvoiceDbContext` is registered as scoped,
    which means that each HTTP request will create a new `InvoiceDbContext` instance,
    and the instance will be disposed of after the request is completed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用依赖注入（DI）将 `InvoiceDbContext` 实例注入到控制器中，该控制器处理数据库操作。作为开发者，我们通常不需要担心数据库连接。`InvoiceDbContext`
    被注册为作用域，这意味着每个 HTTP 请求都会创建一个新的 `InvoiceDbContext` 实例，并在请求完成后销毁该实例。
- en: Once we get the `InvoiceDbContext` instance, we can use the `DbSet` property
    to access the entity set. The `DbSet<Invoice>` property represents a collection
    of the `Invoice` model class, which is mapped to the `Invoices` table in the database.
    We can use `FindAsync()`, `Add()`, `Remove()`, and `Update()`, to retrieve, add,
    remove, and update the entity in the database, respectively. The `SaveChangesAsync()`
    method is used to save the changes to the database. In this way, we operate the
    database through .NET objects, which is much easier than using SQL statements.
    That is the power of ORMs.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获取到 `InvoiceDbContext` 实例，我们可以使用 `DbSet` 属性来访问实体集。`DbSet<Invoice>` 属性代表
    `Invoice` 模型类的集合，该集合映射到数据库中的 `Invoices` 表。我们可以使用 `FindAsync()`、`Add()`、`Remove()`
    和 `Update()` 来分别检索、添加、删除和更新数据库中的实体。`SaveChangesAsync()` 方法用于将更改保存到数据库。这样，我们通过
    .NET 对象操作数据库，这比使用 SQL 语句要容易得多。这就是 ORM 的力量。
- en: What is LINQ?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 是什么？
- en: '**Language-Integrated Query** (**LINQ**) is a set of features in .NET that
    provide a consistent and expressive way to query and manipulate data from various
    data sources, such as a database, XML, and in-memory collections. With LINQ, you
    can write queries in a declarative way, which is much easier than using SQL statements.
    We will show you some basic LINQ queries in the next section. [For more info](https://lear)rmation
    about LINQ, see [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**语言集成查询**（**LINQ**）是 .NET 中提供一致且表达性查询和操作来自各种数据源（如数据库、XML 和内存集合）的功能集合。使用 LINQ，你可以以声明性方式编写查询，这比使用
    SQL 语句要容易得多。我们将在下一节中展示一些基本的 LINQ 查询。[有关 LINQ 的更多信息](https://lear)rmation，请参阅 [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/)。'
- en: 'Let us look at the generated SQL statements. Use `dotnet run` to start the
    application and test the `api/Invoices` API endpoint with the Swagger UI or any
    tool you like. You can see the following SQL statements in the **Debug** window:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看生成的 SQL 语句。使用 `dotnet run` 启动应用程序，并使用 Swagger UI 或您喜欢的任何工具测试 `api/Invoices`
    API 端点。您可以在 **调试** 窗口中看到以下 SQL 语句：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The logs are helpful for understanding the SQL statements generated by EF Core.
    EF Core executes the SQL query and then maps the result to the models. It significantly
    simplifies data access and database operations.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 日志有助于理解 EF Core 生成的 SQL 语句。EF Core 执行 SQL 查询，然后将结果映射到模型。这显著简化了数据访问和数据库操作。
- en: Next, let us learn how to query data using LINQ in controllers.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们学习如何在控制器中使用 LINQ 查询数据。
- en: Basic LINQ queries
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本LINQ查询
- en: 'This book is not intended to be a LINQ handbook. However, we will show you
    some basic LINQ queries in this section:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本书并非旨在成为 LINQ 手册。然而，在本节中，我们将向你展示一些基本的 LINQ 查询：
- en: Querying the data
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询数据
- en: Filtering the data
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤数据
- en: Sorting the data
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序数据
- en: Paging the data
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分页数据
- en: Creating the data
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据
- en: Updating the data
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新数据
- en: Deleting the data
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除数据
- en: Querying the data
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询数据
- en: 'The `DbSet<Invoice> Invoices` property in the `InvoiceDbContext` class represents
    a collection of the `Invoice` entity. We can use LINQ methods to query the data.
    For example, we can use the `ToListAsync()` method to retrieve all the invoices
    from the database:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`InvoiceDbContext` 类中的 `DbSet<Invoice> Invoices` 属性表示 `Invoice` 实体的集合。我们可以使用
    LINQ 方法来查询数据。例如，我们可以使用 `ToListAsync()` 方法从数据库检索所有发票：'
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That is how the `GetInvoices` action method works.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `GetInvoices` 动作方法的工作原理。
- en: 'To find a specific invoice, we can use the `FindAsync()` method, as shown in
    the `GetInvoice()` action method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找特定发票，我们可以使用 `FindAsync()` 方法，如 `GetInvoice()` 动作方法中所示：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `FindAsync()` method accepts the primary key value as the parameter. EF
    Core will translate the `FindAsync()` method to the SQL `SELECT` statement, as
    shown here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`FindAsync()` 方法接受主键值作为参数。EF Core 将 `FindAsync()` 方法转换为 SQL `SELECT` 语句，如下所示：'
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can also use `Single()` or `SingleOrDefault()` methods to find a specific
    entity. For example, we can use the `SingleAsync()` method to find the invoice
    with the specified ID:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `Single()` 或 `SingleOrDefault()` 方法来查找特定实体。例如，我们可以使用 `SingleAsync()`
    方法来查找具有指定 ID 的发票：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Important note
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You may notice that we use `SingleAsync()` instead of `Single()` in the code.
    Many methods of EF Core have both synchronous and asynchronous versions. The asynchronous
    versions are suffixed with `Async`. It is recommended to use the asynchronous
    versions in the controller actions because they are non-blocking and can improve
    the performance of the application.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到我们在代码中使用 `SingleAsync()` 而不是 `Single()`。EF Core 的许多方法都有同步和异步版本。异步版本以
    `Async` 结尾。建议在控制器操作中使用异步版本，因为它们是非阻塞的，可以提高应用程序的性能。
- en: 'If you have LINQ experience, you may know there are other methods – such as
    `First()`, `FirstOrDefault()`, and so on – that can be used to find a specific
    entity. The differences are listed as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你具有 LINQ 经验，你可能知道还有其他方法，例如 `First()`、`FirstOrDefault()` 等，可以用来查找特定实体。差异如下：
- en: '`Find()` or `FindAsync()` is used to find an entity by the primary key value.
    If the entity is not found, it returns `null`. Note that these two methods are
    related to the tracking state of the entity. If the entity is already tracked
    by `DbContext`, the `Find()` and `FindAsync()` methods will return the tracked
    entity immediately without querying the database. Otherwise, they will execute
    the SQL `SELECT` statement to retrieve the entity from the database.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Find()` 或 `FindAsync()` 用于通过主键值查找实体。如果找不到实体，则返回 `null`。请注意，这两个方法与实体的跟踪状态相关。如果实体已被
    `DbContext` 跟踪，则 `Find()` 和 `FindAsync()` 方法将立即返回跟踪的实体，而无需查询数据库。否则，它们将执行 SQL `SELECT`
    语句从数据库检索实体。'
- en: '`Single()` or `SingleAsync()` can accept a predicate as the parameter. It returns
    the *single* entity that satisfies the predicate and throws an exception if the
    entity is not found or more than one entity satisfies the condition. If it is
    called without a predicate, it returns the only entity of the collection and throws
    an exception if more than one entity exists in the collection.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Single()` 或 `SingleAsync()` 可以接受一个谓词作为参数。它返回满足谓词的单个实体，如果找不到实体或多个实体满足条件，则抛出异常。如果没有提供谓词调用，它将返回集合中的唯一实体，如果集合中存在多个实体，则抛出异常。'
- en: '`SingleOrDefault()` or `SingleOrDefaultAsync()` can accept a predicate as the
    parameter. It also returns the *single* entity that satisfies the predicate and
    throws an exception if more than one entity satisfies the condition but returns
    a default value if the entity is not found. If it is called without a predicate,
    it returns a default value (or a specified default value) if the collection is
    empty and throws an exception if more than one entity exists in the collection.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SingleOrDefault()` 或 `SingleOrDefaultAsync()` 可以接受一个谓词作为参数。它也返回满足谓词的单个实体，如果多个实体满足条件，则抛出异常，如果找不到实体，则返回默认值。如果没有提供谓词，它在集合为空时返回默认值（或指定的默认值），如果集合中存在多个实体，则抛出异常。'
- en: '`First()` or `FirstAsync()` can accept a predicate as the parameter. It returns
    the *first* entity that satisfies the predicate and throws an exception if the
    entity is not found or the collection is null or empty. If it is called without
    a predicate, it returns the first entity of the collection and throws an exception
    if the collection is null or empty.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`First()` 或 `FirstAsync()` 可以接受一个谓词作为参数。它返回满足谓词的第一个实体，如果找不到实体或集合为空，则抛出异常。如果没有提供谓词，它返回集合中的第一个实体，如果集合为空，则抛出异常。'
- en: '`FirstOrDefault()` or `FirstOrDefaultAsync()` can accept a predicate as the
    parameter. It also returns the *first* entity that satisfies the predicate. If
    the entity is not found or the collection is empty, it returns a default value
    (or a specified default value). If it is called without a predicate, it returns
    the first entity if the collection is not empty; otherwise, it returns a default
    value (or a specified default value). If the collection is null, it throws an
    exception.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FirstOrDefault()` 或 `FirstOrDefaultAsync()` 可以接受一个谓词作为参数。它也返回满足谓词的第一个实体。如果找不到实体或集合为空，它返回默认值（或指定的默认值）。如果没有提供谓词，它在集合不为空时返回第一个实体；否则，它返回默认值（或指定的默认值）。如果集合为空，则抛出异常。'
- en: 'These methods are kind of confusing. The recommended practice is as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法有点令人困惑。建议的做法如下：
- en: If you want to find an entity by the primary key value and leverage the tracking
    state to improve the performance, use `Find()` or `FindAsync()`.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想通过主键值查找实体并利用跟踪状态来提高性能，请使用 `Find()` 或 `FindAsync()`。
- en: If you are sure that the entity exists and only one entity satisfies the condition,
    use `Single()` or `SingleAsync()`. If you would like to specify a default value
    when the entity is not found, use `SingleOrDefault()` or `SingleOrDefaultAsync()`.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您确信实体存在且只有一个实体满足条件，请使用 `Single()` 或 `SingleAsync()`。如果您希望在找不到实体时指定默认值，请使用
    `SingleOrDefault()` 或 `SingleOrDefaultAsync()`。
- en: If you are not sure whether the entity exists, or there may be more than one
    entity that satisfies the condition, use `First()` or `FirstAsync()`. If you would
    like to specify a default value when the entity is not found, use `FirstOrDefault()`
    or `FirstOrDefaultAsync()`.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您不确定实体是否存在，或者可能存在多个满足条件的实体，请使用 `First()` 或 `FirstAsync()`。如果您希望在找不到实体时指定默认值，请使用
    `FirstOrDefault()` 或 `FirstOrDefaultAsync()`。
- en: Do not forget to check whether the result is `null` if you use `Find()`, `FindAsync()`,
    `SingleOrDefault()`, `SingleOrDefaultAsync()`, `FirstOrDefault()`, and `FirstOrDefaultAsync()`.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用 `Find()`、`FindAsync()`、`SingleOrDefault()`、`SingleOrDefaultAsync()`、`FirstOrDefault()`
    和 `FirstOrDefaultAsync()`，不要忘记检查结果是否为 `null`。
- en: Filtering the data
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤数据
- en: 'If the table contains a lot of records, we may want to filter the data based
    on some conditions, instead of returning all of them. We can use the `Where()`
    method to filter the invoices by status. Update the `GetInvoices` action method
    as shown here:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表中包含大量记录，我们可能希望根据某些条件过滤数据，而不是返回所有记录。我们可以使用 `Where()` 方法根据状态过滤发票。更新 `GetInvoices`
    动作方法如下所示：
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `Where()` method accepts a lambda expression as the parameter. A lambda
    expression is a concise way to define a delegate method inline, which is widely
    used in LINQ queries to define filtering, sorting, and projection operations.
    In the preceding example, the `x => status == null || x.Status == status` lambda
    expression means that the `Status` property of the `Invoice` entity is equal to
    the `status` parameter if the `status` parameter is not `null`. EF Core will translate
    the lambda expression to the SQL `WHERE` clause.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`Where()`方法接受一个lambda表达式作为参数。lambda表达式是一种在行内定义委托方法的简洁方式，它在LINQ查询中广泛用于定义过滤、排序和投影操作。在前面的示例中，`x
    => status == null || x.Status == status`的lambda表达式意味着如果`status`参数不是`null`，则`Invoice`实体的`Status`属性等于`status`参数。EF
    Core会将lambda表达式转换为SQL的`WHERE`子句。'
- en: 'Run the application and check the Swagger UI. You will find the `/api/Invoices`
    endpoint now has a `status` parameter. You can use the parameter to filter the
    invoices by status:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并检查Swagger UI。你会发现`/api/Invoices`端点现在有一个`status`参数。你可以使用该参数按状态过滤发票：
- en: '![Figure 5.2 – Filtering the invoices by status](img/B18971_05_02.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – 根据状态过滤发票](img/B18971_05_02.jpg)'
- en: Figure 5.2 – Filtering the invoices by status
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 根据状态过滤发票
- en: 'Send a request with a status parameter to the `/api/Invoices` endpoint. You
    will get the invoices with the specified status. The SQL query is shown here:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 向`/api/Invoices`端点发送带有状态参数的请求。你将获得具有指定状态的发票。SQL查询如下所示：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can see that the `Where()` method is translated to the SQL `WHERE` clause.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`Where()`方法被转换为SQL的`WHERE`子句。
- en: Sorting and paging
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和分页
- en: 'It is not always enough to filter the data. We may also want to sort the data
    based on some properties and return a subset of the data using paging. We can
    use some methods, such as `OrderBy()`, `OrderByDescending()`, `Skip()`, `Take()`,
    and so on, to sort and page the data. Update the `GetInvoices` action method as
    shown here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 仅过滤数据可能并不总是足够。我们可能还希望根据某些属性对数据进行排序，并使用分页返回数据子集。我们可以使用一些方法，如`OrderBy()`、`OrderByDescending()`、`Skip()`、`Take()`等，来排序和分页数据。更新`GetInvoices`操作方法如下所示：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code, we use the `AsQueryable()` method to convert the `DbSet<Invoice>`
    to `IQueryable<Invoice>`. We can use `IQueryable` to build a query. The `Where()`
    and `OrderByDescending()` methods return a new `IQueryable` object. So, we can
    chain the LINQ methods to build a new query. The `Where()` method is used to filter
    the data, the `OrderByDescending()` method is used to sort the data based on the
    `InvoiceDate` property in descending order, and the `Skip()` and `Take()` methods
    are used to page the data. The `Skip()` method skips the first `pageSize * (page
    - 1)` records, and the `Take()` method returns the next `pageSize` records. At
    the end of the statement, the `ToListAsync()` method executes the query and returns
    the result.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`AsQueryable()`方法将`DbSet<Invoice>`转换为`IQueryable<Invoice>`。我们可以使用`IQueryable`来构建查询。`Where()`和`OrderByDescending()`方法返回一个新的`IQueryable`对象。因此，我们可以链式调用LINQ方法来构建一个新的查询。`Where()`方法用于过滤数据，`OrderByDescending()`方法用于根据`InvoiceDate`属性按降序排序数据，而`Skip()`和`Take()`方法用于分页数据。`Skip()`方法跳过前`pageSize
    * (page - 1)`条记录，`Take()`方法返回接下来的`pageSize`条记录。在语句的末尾，`ToListAsync()`方法执行查询并返回结果。
- en: In fact, the `AsQueryable()` method is not required here because the `DbSet<TEntity>`
    class implements the `IQueryble<TEntity>` interface, which means the `DbSet<Invoice>`
    property is already an `IQueryable` object. We can chain the LINQ methods directly.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这里不需要`AsQueryable()`方法，因为`DbSet<TEntity>`类实现了`IQueryable<TEntity>`接口，这意味着`DbSet<Invoice>`属性已经是一个`IQueryable`对象。我们可以直接链式调用LINQ方法。
- en: What is IQueryable?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是IQueryable？
- en: When we use some LINQ methods, such as `Where()`, `OrderBy()`, `Skip()`, and
    `Take()`, EF Core will not execute the query immediately. It will build a query
    and return a new `IQueryable` object. `IQueryable` is an interface in the `System.Linq`
    namespace that represents a queryable collection of entities that can be used
    to compose a query against a specific data source, such as a database. It allows
    us to build complex queries by chaining the LINQ methods, but it postpones the
    query execution until the very last moment when the result is needed. Generally,
    when we call the `ToListAsync()` method, the query will be translated to a server-specific
    query language, such as SQL, and executed against the database. This can improve
    the performance of the application because we do not need to fetch all the data
    from the database before we can filter and sort the data.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用一些 LINQ 方法，例如 `Where()`、`OrderBy()`、`Skip()` 和 `Take()` 时，EF Core 不会立即执行查询。它将构建一个查询并返回一个新的
    `IQueryable` 对象。`IQueryable` 是 `System.Linq` 命名空间中的一个接口，它表示可以用于对特定数据源（如数据库）进行查询的实体可查询集合。它允许我们通过链式调用
    LINQ 方法来构建复杂的查询，但会推迟查询执行，直到需要结果的那一刻。通常，当我们调用 `ToListAsync()` 方法时，查询将被转换为特定于服务器的查询语言，如
    SQL，并针对数据库执行。这可以提高应用程序的性能，因为我们不需要在过滤和排序数据之前从数据库中检索所有数据。
- en: 'Run the application using `dotnet run` and check the Swagger UI, you will see
    the `page` and `pageSize` parameters are added to the `/api/Invoices` endpoint.
    You can use the parameters to page the invoices as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dotnet run` 运行应用程序并检查 Swagger UI，你会看到 `/api/Invoices` 端点已添加了 `page` 和 `pageSize`
    参数。你可以使用这些参数按如下方式分页发票：
- en: '![Figure 5.3 – Sorting and paging the invoices](img/B18971_05_03.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 对发票进行排序和分页](img/B18971_05_03.jpg)'
- en: Figure 5.3 – Sorting and paging the invoices
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 对发票进行排序和分页
- en: 'The generated SQL query is shown here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 SQL 查询如下所示：
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that the SQL statement uses the `OFFSET/FETCH` clause to page the data.
    These keywords are supported by SQL Server but may not be supported by other databases.
    For example, MySQL uses the `LIMIT` clause to page the data. EF Core can eliminate
    the differences between different databases. It will translate the LINQ query
    to the correct SQL statement for the database. In this way, developers can focus
    on writing the LINQ query in a database-agnostic way. That is the beauty of EF
    Core.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，SQL 语句使用了 `OFFSET/FETCH` 子句来分页数据。这些关键字由 SQL Server 支持，但可能不被其他数据库支持。例如，MySQL
    使用 `LIMIT` 子句来分页数据。EF Core 可以消除不同数据库之间的差异。它将 LINQ 查询转换为数据库的正确 SQL 语句。这样，开发者可以以数据库无关的方式编写
    LINQ 查询。这就是 EF Core 的美妙之处。
- en: Creating an entity
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建实体
- en: 'Next, let’s see how to create a new invoice. Check the code of the `PostInvoice`
    action method:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何创建一个新的发票。检查 `PostInvoice` 动作方法的代码：
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '}The `PostInvoice` action method accepts an `Invoice` object as the request
    body. It uses the `Add()` method to add the invoice to the `Invoices` entity set.
    Note that this change occurs in the memory. The data will not be added to the
    database until the `SaveChangesAsync()` method is called to save the changes to
    the database. The `CreatedAtAction()` method returns a `201 Created` response
    with the location of the newly created invoice. You can return a `200 OK` response
    instead but it is recommended to return a `201 Created` response for the creation
    of a new resource.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`PostInvoice` 动作方法接受一个 `Invoice` 对象作为请求体。它使用 `Add()` 方法将发票添加到 `Invoices` 实体集中。请注意，此更改发生在内存中。数据将不会添加到数据库，直到调用
    `SaveChangesAsync()` 方法将更改保存到数据库。`CreatedAtAction()` 方法返回一个 `201 Created` 响应，其中包含新创建的发票的位置。你可以返回一个
    `200 OK` 响应，但建议在创建新资源时返回 `201 Created` 响应。'
- en: 'You can send a `POST` request to the `/api/invoices` endpoint to create a new
    invoice and see how the SQL statement is generated from the logs. It should be
    similar to the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向 `/api/invoices` 端点发送 `POST` 请求来创建一个新的发票，并查看从日志中生成的 SQL 语句。它应该类似于以下内容：
- en: '[PRE25]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Important note
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The JSON body for the `POST` action does not need to contain the `Id` property.
    EF Core will generate a new `Guid` value for the `Id` property.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST` 动作的 JSON 请求体不需要包含 `Id` 属性。EF Core 将为 `Id` 属性生成一个新的 `Guid` 值。'
- en: Updating an entity
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新实体
- en: 'To update an entity, we use the `Put` request. The code of the `PutInvoice`
    action method is shown here:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新一个实体，我们使用 `Put` 请求。`PutInvoice` 动作方法的代码如下所示：
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `PutInvoice` action method accepts the `id` parameter and the `Invoice`
    object as the request body. If you check the Swagger UI, you will see the `id`
    parameter is defined in the URL but the `Invoice` object is defined in the request
    body. This is because `Invoice` is not a primitive type, so ASP.NET Core can only
    get it from the request body. We discussed this in the *Binding source attributes*
    section in [*Chapter 3*](B18971_03.xhtml#_idTextAnchor130).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`PutInvoice` 动作方法接受 `id` 参数和作为请求体的 `Invoice` 对象。如果你检查 Swagger UI，你会看到 `id`
    参数在 URL 中定义，但 `Invoice` 对象在请求体中定义。这是因为 `Invoice` 不是一个原始类型，所以 ASP.NET Core 只能从请求体中获取它。我们已经在
    *绑定源属性* 部分中讨论过这一点，见 [*第 3 章*](B18971_03.xhtml#_idTextAnchor130)。'
- en: Next, we use the `_context.Entry()` method to get the `EntityEntry` object of
    the invoice. Then, we set the `State` property to `EntityState.Modified`. It seems
    that the `EntityState` enum plays an important role here. What is the `EntityState`
    enum?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `_context.Entry()` 方法获取发票的 `EntityEntry` 对象。然后，我们将 `State` 属性设置为 `EntityState.Modified`。看起来
    `EntityState` 枚举在这里起着重要的作用。那么，`EntityState` 枚举是什么？
- en: In EF Core, each instance of `DbContext` has a `ChangeTracker` to track the
    changes in the entities, which is a powerful feature of EF Core. In other words,
    EF Core knows the state of each entity – whether it is added, deleted, or modified.
    When we update the entity, we just update the entity in the memory. EF Core can
    track the changes. When the `SaveChangesAsync()` method is called, it will generate
    the SQL statement to update the data in the database.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 EF Core 中，每个 `DbContext` 实例都有一个 `ChangeTracker` 来跟踪实体的变化，这是 EF Core 的一个强大功能。换句话说，EF
    Core 知道每个实体的状态——是已添加、已删除还是已修改。当我们更新实体时，我们只需在内存中更新实体。EF Core 可以跟踪这些变化。当调用 `SaveChangesAsync()`
    方法时，它将生成更新数据库中数据的 SQL 语句。
- en: 'The `EntityState` enum can have the following values:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`EntityState` 枚举可以有以下值：'
- en: '`Detached`: The entity is not being tracked by the context.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Detached`：实体没有被上下文跟踪。'
- en: '`Unchanged`: The entity is being tracked by the context, but the values are
    not changed.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unchanged`：实体被上下文跟踪，但值没有改变。'
- en: '`Deleted`: The entity is being tracked and exists in the database, but it has
    been marked for deletion. So, when the `SaveChangesAsync()` method is called,
    EF Core will generate the SQL statement to delete the entity from the database.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Deleted`：实体正在被跟踪且存在于数据库中，但它已被标记为删除。因此，当调用 `SaveChangesAsync()` 方法时，EF Core
    将生成删除数据库中实体的 SQL 语句。'
- en: '`Modified`: The entity is being tracked and exists in the database, and the
    values have been modified in `DbContext`. When the `SaveChangesAsync()` method
    is called, EF Core will generate the SQL statement to update the entity in the
    database.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Modified`：实体正在被跟踪且存在于数据库中，且在 `DbContext` 中的值已被修改。当调用 `SaveChangesAsync()`
    方法时，EF Core 将生成更新数据库中实体的 SQL 语句。'
- en: '`Added`: The entity is being tracked but it does not exist in the database.
    When the `SaveChangesAsync()` method is called, EF Core will generate the SQL
    statement to insert the entity into the database.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Added`：实体正在被跟踪，但它不存在于数据库中。当调用 `SaveChangesAsync()` 方法时，EF Core 将生成将实体插入数据库的
    SQL 语句。'
- en: 'In the *Creating an entity* section, we used the `Add()` method to add the
    entity to the entity set. This is equivalent to setting the `State` property to
    `Added`, such as in the following code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *创建实体* 部分中，我们使用了 `Add()` 方法将实体添加到实体集中。这相当于将 `State` 属性设置为 `Added`，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Similar to the `Add()` method, changing the state of the entity does not modify
    the data in the database. You must call the `SaveChangesAsync()` method to save
    the changes to the database.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Add()` 方法类似，改变实体的状态不会修改数据库中的数据。你必须调用 `SaveChangesAsync()` 方法来将更改保存到数据库。
- en: 'Let''s try to call the `PutInvoice` action method to update an invoice. Send
    a `PUT` request to the `/api/invoices/{id}` endpoint in the Swagger UI. The request
    body is like this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试调用 `PutInvoice` 动作方法来更新一个发票。在 Swagger UI 中向 `/api/invoices/{id}` 端点发送 `PUT`
    请求。请求体如下所示：
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Please update the JSON body to change the `contactName` property only. The
    SQL statement generated by EF Core is shown here:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 请更新 JSON 主体以仅更改 `contactName` 属性。EF Core 生成的 SQL 语句如下所示：
- en: '[PRE29]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can see EF Core omits the `Id` column in the `UPDATE` statement. This is
    because the `Id` column is the primary key of the `Invoices` table. EF Core knows
    that it does not need to update the `Id` column. But EF Core will update the other
    properties irrespective of whether the values are changed or not because the `EntityState`
    of the entity is `Modified`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到 EF Core 在 `UPDATE` 语句中省略了 `Id` 列。这是因为 `Id` 列是 `Invoices` 表的主键。EF Core
    知道它不需要更新 `Id` 列。但是，无论值是否更改，EF Core 都会更新其他属性，因为实体的 `EntityState` 是 `Modified`。
- en: 'Sometimes we want to update only the changed properties. For example, if we
    just want to update the `Status` property, the SQL statement should not have to
    update other columns. To do this, we can find the entity that needs to be updated,
    and then update the properties explicitly. Let us update the `PutInvoice` action
    method to do this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们只想更新已更改的属性。例如，如果我们只想更新 `Status` 属性，SQL 语句就不需要更新其他列。为了做到这一点，我们可以找到需要更新的实体，然后显式地更新属性。让我们更新
    `PutInvoice` 动作方法来完成这个任务：
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this example, we first find the entity by the `FindAsync()` method. Then,
    we update the `Status` property. EF Core will mark the `Status` property as modified.
    Finally, we call the `SaveChangesAsync()` method to save the changes to the database.
    You can see the generated SQL statement only updates the `Status` property, which
    is like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先通过 `FindAsync()` 方法找到实体，然后更新 `Status` 属性。EF Core 将 `Status` 属性标记为已修改。最后，我们调用
    `SaveChangesAsync()` 方法将更改保存到数据库。你可以看到生成的 SQL 语句只更新了 `Status` 属性，如下所示：
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'However, in an actual scenario, normally, the endpoint will receive the whole
    entity, not just the changed properties. We may not know which properties are
    changed. In this case, we can just update all the properties in the code. EF Core
    can track the state of the entity, so it is smart enough to determine which properties
    are changed. Let us update the `PutInvoice` action method to explicitly update
    all the properties:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实际场景中，通常端点会接收到整个实体，而不仅仅是已更改的属性。我们可能不知道哪些属性已更改。在这种情况下，我们可以在代码中更新所有属性。EF Core
    可以跟踪实体的状态，因此它足够智能，可以确定哪些属性已更改。让我们更新 `PutInvoice` 动作方法以显式更新所有属性：
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Send a `PUT` request to the `/api/Invoices/{id}` endpoint and attach a JSON
    body to the request. If you just update the `Status` and `Description` properties,
    the SQL statement will be like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `/api/Invoices/{id}` 端点发送一个 `PUT` 请求，并将 JSON 主体附加到请求中。如果你只更新 `Status` 和 `Description`
    属性，SQL 语句将如下所示：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding SQL statement slightly improves the performance because it only
    updates the changed properties. It might not be a big deal for a small table,
    but if you have a large table that has many columns, it will be a good practice.
    However, it needs a `SELECT` statement to get the entity first. Choose the way
    that suits your scenario.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 SQL 语句略微提高了性能，因为它只更新了已更改的属性。对于一个小表来说，这可能不是什么大问题，但如果你的表很大，并且有很多列，那么这是一个好的实践。然而，它需要一个
    `SELECT` 语句来首先获取实体。选择适合你场景的方法。
- en: 'There is an issue in the preceding code. If the entity has many properties,
    it will be tedious to update all the properties one by one. In this case, we can
    use the `Entry` method to get the `EntityEntry` object and then set the `CurrentValues`
    property to the new values. Let us update the `PutInvoice` action method to use
    the `Entry` method:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码中存在一个问题。如果实体有多个属性，逐个更新所有属性将会很麻烦。在这种情况下，我们可以使用 `Entry` 方法来获取 `EntityEntry`
    对象，然后设置 `CurrentValues` 属性为新值。让我们更新 `PutInvoice` 动作方法以使用 `Entry` 方法：
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `SetValues()` method will set all the properties of the entity to the new
    values. EF Core can detect the changes and mark the properties that have changed
    as `Modified`. So, we do not need to manually set each property. This way is a
    good practice when updating an entity that has many properties. Also, the object
    used to update the properties does not have to be the same type as the entity.
    It is useful in a layered application. For example, the entity received from the
    client is a **Data Transfer Object** (**DTO**) object, and the entity in the database
    is a domain object. In this case, EF Core will update the properties that match
    the names of the properties in the DTO object.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetValues()` 方法将设置实体的所有属性为新值。EF Core 可以检测到变化并将已更改的属性标记为 `Modified`。因此，我们不需要手动设置每个属性。当更新具有许多属性的实体时，这种方式是一种良好的实践。此外，用于更新属性的对象不必与实体具有相同的类型。这在分层应用程序中非常有用。例如，从客户端接收到的实体是一个
    **数据传输对象**（**DTO**）对象，而数据库中的实体是一个领域对象。在这种情况下，EF Core 将更新与 DTO 对象中属性名称匹配的属性。'
- en: Note that the `SetValues()` method only updates the simple properties, such
    as `string`, `int`, `decimal`, `DateTime`, and so on. If the entity has a navigation
    property, the `SetValues()` method will not update the navigation property. In
    this case, we need to update the properties explicitly.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`SetValues()` 方法只更新简单的属性，例如 `string`、`int`、`decimal`、`DateTime` 等等。如果实体有一个导航属性，`SetValues()`
    方法将不会更新导航属性。在这种情况下，我们需要显式地更新属性。
- en: Test the `/api/Invoices/{id}` endpoint by sending a `PUT` request again. You
    can see the generated SQL statement is similar to the previous one.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过再次发送 `PUT` 请求来测试 `/api/Invoices/{id}` 端点。你可以看到生成的 SQL 语句与之前的一个类似。
- en: Deleting an entity
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除实体
- en: 'In the generated code of the `DeleteInvoice` action method, we can see the
    following code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DeleteInvoice` 操作方法生成的代码中，我们可以看到以下代码：
- en: '[PRE35]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The logic is to find the entity first, and then remove it from `DbSet` using
    the `Remove()` method. Finally, we call the `SaveChangesAsync()` method to save
    the changes to the database. If you understand `EntityState` already, you might
    know that the `Remove()` method is equivalent to setting `EntityState` to `Deleted`,
    as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑是先找到实体，然后使用 `Remove()` 方法将其从 `DbSet` 中移除。最后，我们调用 `SaveChangesAsync()` 方法将更改保存到数据库。如果你已经理解了
    `EntityState`，你可能会知道 `Remove()` 方法相当于将 `EntityState` 设置为 `Deleted`，如下所示：
- en: '[PRE36]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The generated SQL statement is like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 SQL 语句如下：
- en: '[PRE37]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As you can see, EF Core generates two SQL statements, which seems a little
    bit unnecessary to find the entity first. When we delete an entity, the only thing
    we need is the primary key. So, we can update the `DeleteInvoice()` action like
    this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，EF Core 生成两个 SQL 语句，这似乎在先找到实体之前有点不必要。当我们删除一个实体时，我们唯一需要的是主键。因此，我们可以这样更新
    `DeleteInvoice()` 操作：
- en: '[PRE38]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, the SQL statement is as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，SQL 语句如下：
- en: '[PRE39]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It is much simpler than the previous one.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这比之前的一个简单得多。
- en: 'From EF Core 7.0, we have a new method called `ExecuteDeleteAsync()` that can
    be used to delete an entity without loading it first. The code is as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 从 EF Core 7.0 开始，我们有一个名为 `ExecuteDeleteAsync()` 的新方法，可以用来在不先加载实体的情况下删除实体。代码如下：
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Important note
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `ExecuteDeleteAsync()` method does not involve the change tracker, so it
    will execute the SQL statement immediately to the database. It does not need to
    call the `SaveChangesAsync()` method at the end. It is a recommended way to delete
    one entity (or more) from EF Core 7.0 and later versions. However, if the entity
    already exists in `DbContext` and is tracked by the change tracker, executing
    the SQL statement directly may cause the data in `DbContext` and the database
    to be inconsistent. In this case, you may need to use the `Remove()` method or
    set the `EntityState` property to `Deleted` to delete the entity from `DbContext`.
    Please consider your scenario carefully before using the `ExecuteDeleteAsync()`
    method.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecuteDeleteAsync()` 方法不涉及更改跟踪器，因此它将 SQL 语句立即执行到数据库。它不需要在最后调用 `SaveChangesAsync()`
    方法。这是从 EF Core 7.0 及以后的版本中删除一个实体（或多个）的推荐方法。然而，如果实体已经在 `DbContext` 中并且被更改跟踪器跟踪，直接执行
    SQL 语句可能会导致 `DbContext` 和数据库中的数据不一致。在这种情况下，你可能需要使用 `Remove()` 方法或将 `EntityState`
    属性设置为 `Deleted` 来从 `DbContext` 中删除实体。在使用 `ExecuteDeleteAsync()` 方法之前，请仔细考虑你的场景。'
- en: You must be wondering how EF Core knows the names of columns and tables in the
    database. We will talk about the configuration and see how EF Core maps the models
    to the database next.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道 EF Core 如何知道数据库中列和表的名字。我们将讨论配置并看看 EF Core 如何将模型映射到数据库。
- en: Configuring the mapping between models and database
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置模型与数据库之间的映射
- en: 'ORM, as the name suggests, is used to map the objects to the relational database.
    EF Core uses the mapping configuration to map the models to the database. In the
    previous section, we saw that we did not configure any mappings; however, EF Core
    could still map the models to the database automatically. This is because EF Core
    has a set of built-in conventions to configure the mappings. We can also explicitly
    customize the configuration to meet our needs. In this section, we will discuss
    the configuration in EF Core, including the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，ORM 用于将对象映射到关系型数据库。EF Core 使用映射配置将模型映射到数据库。在上一节中，我们看到我们没有配置任何映射；然而，EF
    Core 仍然可以自动将模型映射到数据库。这是因为 EF Core 有一组内置约定来配置映射。我们也可以显式自定义配置以满足我们的需求。在本节中，我们将讨论
    EF Core 中的配置，包括以下内容：
- en: Mapping conventions
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射约定
- en: Data annotations
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据注释
- en: Fluent API
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fluent API
- en: Mapping conventions
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射约定
- en: 'There are some conventions in EF Core for mapping the models to the database:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 在映射模型到数据库方面有一些约定：
- en: The database uses the `dbo` schema by default.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，数据库使用 `dbo` 架构。
- en: The table name is the plural form of the model name. For example, we have a
    `DbSet<Invoice> Invoices` property in the `InvoiceDbContext` class, so the table
    name is `Invoices`.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表名是模型名称的复数形式。例如，我们在 `InvoiceDbContext` 类中有一个 `DbSet<Invoice> Invoices` 属性，因此表名是
    `Invoices`。
- en: The column name is the property name.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列名是属性名。
- en: 'The data type of the column is based on the property type and the database
    providers. Here is a list of the default mapping for some common C# types in SQL
    Server:'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列的数据类型基于属性类型和数据库提供程序。以下是 SQL Server 中一些常见 C# 类型的默认映射列表：
- en: '| **.****NET type** | **SQL Server** **data type** |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| **.NET 类型** | **SQL Server 数据类型** |'
- en: '| --- | --- |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `int` | `int` |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `int` | `int` |'
- en: '| `long` | `bigint` |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `long` | `bigint` |'
- en: '| `string` | `nvarchar(max)` |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `string` | `nvarchar(max)` |'
- en: '| `bool` | `bit` |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | `bit` |'
- en: '| `datetime` | `datetime` |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `datetime` | `datetime` |'
- en: '| `double` | `float` |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `float` |'
- en: '| `decimal` | `decimal(18,2)` |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `decimal` | `decimal(18,2)` |'
- en: '| `byte` | `tinyint` |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | `tinyint` |'
- en: '| `short` | `smallint` |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `short` | `smallint` |'
- en: '| `byte[]` | `varbinary(max)` |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `byte[]` | `varbinary(max)` |'
- en: Table 5.1 – Default mapping for some common C# types in SQL Server
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1 – SQL Server 中一些常见 C# 类型的默认映射
- en: If a property is named `Id` or `<entity name>Id`, EF Core will map it to the
    primary key.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个属性名为 `Id` 或 `<实体名>Id`，EF Core 将将其映射为主键。
- en: If EF Core detects that the relationship between two models is one-to-many,
    it will map the navigation property to a foreign key column in the database automatically.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 EF Core 检测到两个模型之间的关系是一对多，它将自动将导航属性映射到数据库中的外键列。
- en: If a column is a primary key, EF Core will create a clustered index for it automatically.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个列是主键，EF Core 将自动为其创建一个聚集索引。
- en: If a column is a foreign key, EF Core will create a non-clustered index for
    it automatically.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个列是外键，EF Core 将自动为其创建一个非聚集索引。
- en: An `enum` type is mapped to the underlying type of the enum. For example, the
    `InvoiceStatus` enum is mapped to the `int` type in the database.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举类型映射到枚举的底层类型。例如，`InvoiceStatus` 枚举在数据库中映射到 `int` 类型。
- en: However, sometimes we need to refine the mapping. For example, we may want to
    use the `varchar(100)` column instead of the `nvarchar(max)` column for a `string`
    property. We may also want to save enums as strings in the database instead of
    `int` values. In such cases, we can override the default conventions to customize
    the mapping based on our needs.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时我们需要细化映射。例如，我们可能希望对于 `string` 属性使用 `varchar(100)` 列而不是 `nvarchar(max)`
    列。我们可能还希望将枚举作为字符串而不是 `int` 值保存到数据库中。在这种情况下，我们可以覆盖默认约定以根据我们的需求自定义映射。
- en: 'There are two ways to explicitly configure the mapping between the models and
    the database:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以显式配置模型与数据库之间的映射：
- en: Data annotations
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据注释
- en: Fluent API
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fluent API
- en: Let us see how to use data annotations and Fluent API to customize the mapping.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用数据注释和 Fluent API 来自定义映射。
- en: Data annotations
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据注释
- en: 'Data annotations are attributes that you can apply to the model classes to
    customize the mapping. For example, you can use the `Table` attribute to specify
    the table name and use the `Column` attribute to specify the column name. The
    following code shows how to use data annotations to customize the mapping:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 数据注释是您可以应用于模型类的属性，以自定义映射。例如，您可以使用 `Table` 属性来指定表名，并使用 `Column` 属性来指定列名。以下代码展示了如何使用数据注释来自定义映射：
- en: '[PRE41]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code, each property has one or more data annotations. These
    data annotations are attributes that you can apply to the model classes to customize
    the mapping. You can specify some mapping information, such as the table name,
    column name, column data type, and so on.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，每个属性都有一个或多个数据注释。这些数据注释是您可以应用于模型类的属性，以自定义映射。您可以指定一些映射信息，例如表名、列名、列数据类型等。
- en: 'Here is a list of the most commonly used data annotations:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个常用数据注释的列表：
- en: '| **Attribute** | **Description** |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** |'
- en: '| --- | --- |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Table` | The table name that the model class is mapped to. |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `Table` | 模型类映射到的表名。 |'
- en: '| `Column` | The column name in the table that a property is mapped to. You
    can also specify the column data type using the `TypeName` property. |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `Column` | 属性映射到的表中的列名。您还可以使用 `TypeName` 属性指定列数据类型。 |'
- en: '| `Key` | Specifies the property as a key. |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `Key` | 指定属性作为键。 |'
- en: '| `ForeignKey` | Specifies the property as a foreign key. |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `ForeignKey` | 指定属性作为外键。 |'
- en: '| `NotMapped` | The model or property is not mapped to the database. |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `NotMapped` | 模型或属性未映射到数据库。 |'
- en: '| `Required` | The value of the property is required. |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `Required` | 属性的值是必需的。 |'
- en: '| `MaxLength` | Specifies the maximum length of the value in the database.
    Applied to string or array values only. |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `MaxLength` | 指定数据库中值的最大长度。仅适用于字符串或数组值。 |'
- en: '| `Index` | Creates an index on the column that the property is mapped to.
    |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `Index` | 在属性映射到的列上创建索引。 |'
- en: '| `Precision` | Specifies the precision and scale of the property if the database
    supports precision and scale facets. |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `Precision` | 如果数据库支持精度和刻度特性，指定属性的精度和刻度。 |'
- en: '| `DatabaseGenerated` | Specifies how the database should generate the values
    for the property. If you use `int` or `long` as the primary key for an entity,
    you can use this attribute and set `DatabaseGeneratedOption` as `Identity`, such
    as `[DatabaseGenerated(DatabaseGeneratedOption.Identity)]`. |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `DatabaseGenerated` | 指定数据库应如何生成属性的值。如果您使用 `int` 或 `long` 作为实体的主键，您可以使用此属性并将
    `DatabaseGeneratedOption` 设置为 `Identity`，例如 `[DatabaseGenerated(DatabaseGeneratedOption.Identity)]`。'
- en: '| `TimeStamp` | Specifies the property is used for concurrency management.
    The property will map to a `rowversion` type in SQL Server. The implementation
    may vary in different database providers. |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| `Timestamp` | 指定属性用于并发管理。该属性将映射到SQL Server中的 `rowversion` 类型。在不同的数据库提供程序中的实现可能有所不同。
    |'
- en: Table 5.2 – Commonly used data annotations
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.2 – 常用数据注释
- en: In this way, the mapping configuration is embedded in the model classes. It
    is easy to understand, but it is a little bit intrusive, which means the model
    classes are polluted with the database-related configuration. To decouple the
    model classes from the database mapping configuration, we can use Fluent API.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，映射配置被嵌入到模型类中。它易于理解，但稍微有些侵入性，这意味着模型类被数据库相关的配置所污染。为了将模型类与数据库映射配置解耦，我们可以使用Fluent
    API。
- en: Important note
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Every time the mapping is changed, you need to run the `dotnet ef migrations
    add <migration name>` command to generate a new migration. Then, run the `dotnet
    ef database update` command to update the database.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 每次映射更改时，您都需要运行 `dotnet ef migrations add <迁移名称>` 命令来生成一个新的迁移。然后，运行 `dotnet ef
    database update` 命令来更新数据库。
- en: Fluent API
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fluent API
- en: Fluent API is a set of extension methods that you can use to configure the mappings
    gracefully. It is the most flexible and powerful way to apply the mapping configuration
    without polluting the model classes. Another important thing to note is that Fluent
    API has a higher priority than data annotations. If you configure the same property
    in both data annotations and Fluent API, Fluent API will override the data annotations.
    So, Fluent API is the recommended way to configure the mapping.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Fluent API 是一组扩展方法，您可以使用它来优雅地配置映射。这是应用映射配置最灵活和最强大的方式，而不会污染模型类。另一个需要注意的重要事项是，Fluent
    API 的优先级高于数据注释。如果您在数据注释和 Fluent API 中配置了相同的属性，Fluent API 将覆盖数据注释。因此，Fluent API
    是配置映射的推荐方式。
- en: Fluent API is applied in the order of the method calls. If there are two calls
    to configure the same property, the latest call will override the previous configuration.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Fluent API 按方法调用的顺序应用。如果有两次调用配置相同的属性，则最新调用将覆盖之前的配置。
- en: 'To use Fluent API, we need to override the `OnModelCreating()` method in the
    derived `DbContext` class. The following code shows how to use Fluent API to configure
    the mapping:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Fluent API，我们需要在派生的 `DbContext` 类中重写 `OnModelCreating()` 方法。以下代码显示了如何使用
    Fluent API 配置映射：
- en: '[PRE42]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding code, we use the `Entity()` method to configure the `Invoice`
    entity. This method accepts an `Action<EntityTypeBuilder<TEntity>>` parameter
    to specify the mappings. The `EntityTypeBuilder<TEntity>` class has a lot of methods
    to configure the entity, such as table name, column name, column data type, and
    so on. You can chain these methods in a fluent way to configure the entity, so
    it is called Fluent API.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `Entity()` 方法配置 `Invoice` 实体。此方法接受一个 `Action<EntityTypeBuilder<TEntity>>`
    参数来指定映射。`EntityTypeBuilder<TEntity>` 类有很多方法可以配置实体，例如表名、列名、列数据类型等。您可以通过流畅的方式链式调用这些方法来配置实体，因此它被称为
    Fluent API。
- en: 'Here is a list of the most commonly used Fluent API methods:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是常用 Fluent API 方法的列表：
- en: '| **Method** | **Description** | **Equivalent** **data annotation** |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** | **等效** **数据注释** |'
- en: '| --- | --- | --- |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `HasDefaultSchema()` | Specifies the database schema. The default schema
    is `dbo`. | N/A |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `HasDefaultSchema()` | 指定数据库模式。默认模式是 `dbo`。 | N/A |'
- en: '| `ToTable()` | The table name that the model class is mapped to. | `Table`
    |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `ToTable()` | 模型类映射到的表名。 | `Table` |'
- en: '| `HasColumnName()` | The column name in the table that a property is mapped
    to. | `Column` |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `HasColumnName()` | 属性映射到的表中的列名。 | `Column` |'
- en: '| `HasKey()` | Specifies the property as a key. | `Key` |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `HasKey()` | 指定属性作为键。 | `Key` |'
- en: '| `Ignore()` | Ignores a model or a property from the mapping. This method
    can be applied on an entity level or a property level. | `NotMapped` |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `Ignore()` | 忽略模型或属性从映射中。此方法可以在实体级别或属性级别上应用。 | `NotMapped` |'
- en: '| `IsRequired()` | The value of the property is required. | `Required` |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `IsRequired()` | 属性的值是必需的。 | `Required` |'
- en: '| `HasColumnType()` | Specifies the data type of the column that the property
    is mapped to. | `Column` with the `TypeName` property |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `HasColumnType()` | 指定属性映射到的列的数据类型。 | 带有 `TypeName` 属性的 `Column` |'
- en: '| `HasMaxLength()` | Specifies the maximum length of the value in the database.
    Applied to a string or array only. | `MaxLength` |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| `HasMaxLength()` | 指定数据库中值的最大长度。仅适用于字符串或数组。 | `MaxLength` |'
- en: '| `HasIndex()` | Creates an index on the specific property. | `Index` |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `HasIndex()` | 在特定属性上创建索引。 | `Index` |'
- en: '| `IsRowVersion()` | Specifies the property is used for concurrency management.
    The property will map to a `rowversion` type in SQL Server. The implementation
    may vary in different database providers. | `TimeStamp` |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `IsRowVersion()` | 指定属性用于并发管理。该属性将映射到 SQL Server 中的 `rowversion` 类型。不同数据库提供者的实现可能有所不同。
    | `TimeStamp` |'
- en: '| `HasDefaultValue()` | Specifies a default value for a column. The value must
    be a constant. | N/A |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `HasDefaultValue()` | 为列指定默认值。该值必须是常量。 | N/A |'
- en: '| `HasDefaultValueSql()` | Specifies a SQL expression to generate the default
    value for a column, such as `GetUtcDate()`. | N/A |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `HasDefaultValueSql()` | 指定用于生成列默认值的 SQL 表达式，例如 `GetUtcDate()`。 | N/A |'
- en: '| `HasConversion()` | Defines a value converter to map the property to the
    column data type. It contains two `Func` expressions to convert the values. |
    N/A |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `HasConversion()` | 定义一个值转换器，将属性映射到列数据类型。它包含两个 `Func` 表达式来转换值。 | N/A |'
- en: '| `ValueGeneratedOnAdd()` | Specifies the value of the property to be generated
    by the database when a new entity is added. EF Core will ignore this property
    when inserting a record. | `DatabaseGenerated` with the `DatabaseGeneratedOption.Identity`
    option |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `ValueGeneratedOnAdd()` | 指定当添加新实体时数据库生成的属性值。EF Core 在插入记录时会忽略此属性。 | 使用 `DatabaseGenerated`
    并带有 `DatabaseGeneratedOption.Identity` 选项的 `DatabaseGenerated` |'
- en: Table 5.3 – Commonly used Fluent API methods
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.3 – 常用的 Fluent API 方法
- en: There are some other methods to configure the relationships using Fluent API,
    such as `HasOne()`, `HasMany()`, `WithOne()`, `WithMany()`, and so on. We will
    cover them in the next chapter.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Fluent API 配置关系还有一些其他方法，例如 `HasOne()`、`HasMany()`、`WithOne()`、`WithMany()`
    等。我们将在下一章中介绍它们。
- en: Separating the mapping configurations
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分离映射配置
- en: In a large project, there may be a lot of model classes. If we put all the mapping
    configurations in the `OnModelCreating()` method, the method will be very long
    and hard to maintain. To make the code more readable and maintainable, we can
    extract the mapping configuration to one class or a couple of separate classes.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型项目中，可能会有很多模型类。如果我们把所有的映射配置都放在 `OnModelCreating()` 方法中，该方法将会非常长且难以维护。为了使代码更易于阅读和维护，我们可以将映射配置提取到一个类或几个单独的类中。
- en: 'One way to do this is to create an extension method for the `ModelBuilder`
    class. Create a new class named `InvoiceModelCreatingExtensions` in the `Data`
    folder. Then, add the following code to the class:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的其中一种方法是为 `ModelBuilder` 类创建一个扩展方法。在 `Data` 文件夹中创建一个名为 `InvoiceModelCreatingExtensions`
    的新类。然后，将以下代码添加到该类中：
- en: '[PRE43]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, in the `OnModelCreating()` method, call the extension method:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `OnModelCreating()` 方法中，调用扩展方法：
- en: '[PRE44]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, the `OnModelCreating()` method is much cleaner and easier to read.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`OnModelCreating()` 方法更加简洁且易于阅读。
- en: 'Another way to separate the mapping configurations is to implement the `IEntityTypeConfiguration<TEntity>`
    interface. Create a new class named `InvoiceConfiguration` in the `Data` folder.
    Then, add the following code to the class:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种分离映射配置的方法是实现 `IEntityTypeConfiguration<TEntity>` 接口。在 `Data` 文件夹中创建一个名为 `InvoiceConfiguration`
    的新类。然后，将以下代码添加到该类中：
- en: '[PRE45]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, in the `OnModelCreating()` method, there are two ways to apply the configuration:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `OnModelCreating()` 方法中，有两种应用配置的方式：
- en: 'If you use the `ApplyConfiguration()` method, add the following code to the
    `OnModelCreating()` method:'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用 `ApplyConfiguration()` 方法，请将以下代码添加到 `OnModelCreating()` 方法中：
- en: '[PRE46]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Or you can call the `Configure()` method directly:'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，您可以直接调用 `Configure()` 方法：
- en: '[PRE47]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As the project grows, it might be a little bit tedious to call the mapping
    configuration for each entity. In this case, EF Core has a method called `ApplyConfigurationsFromAssembly()`
    to apply all the configurations in the assembly, as shown in the following code:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目的增长，为每个实体调用映射配置可能会有些繁琐。在这种情况下，EF Core 有一个名为 `ApplyConfigurationsFromAssembly()`
    的方法，可以应用程序集中所有的配置，如下面的代码所示：
- en: '[PRE48]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You can choose the one that fits your project best. One reminder is that if
    you use the `ApplyConfigurationsFromAssembly()` method, you need to make sure
    that all the configuration classes are in the same assembly as the `DbContext`
    class. Also, you cannot control the order of the configurations. If the order
    matters, you need to call each configuration explicitly in the correct order.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择最适合您项目的选项。有一点提醒，如果您使用 `ApplyConfigurationsFromAssembly()` 方法，请确保所有配置类都与
    `DbContext` 类位于同一程序集中。此外，您无法控制配置的顺序。如果顺序很重要，您需要按照正确的顺序显式调用每个配置。
- en: 'After you run the `dotnet ef migrations add <migration name>` command, you
    can find that the generated migration file has the following code:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在您运行 `dotnet ef migrations add <迁移名称>` 命令后，您会发现生成的迁移文件包含以下代码：
- en: '[PRE49]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The preceding snippet shows that the `Status` property is changed from `int`
    to `varchar(16)`, and the `InvoiceNumber` property is changed from `nvarchar(max)`
    to `varchar(32)`. Then, you can run the `dotnet ef database update` command to
    update the database. You will see the `Status` column is stored as strings.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段显示，`Status` 属性已从 `int` 更改为 `varchar(16)`，而 `InvoiceNumber` 属性已从 `nvarchar(max)`
    更改为 `varchar(32)`。然后，您可以运行 `dotnet ef database update` 命令来更新数据库。您将看到 `Status`
    列存储为字符串。
- en: Important note
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: During the migration, the data may get lost if the data type is changed. For
    example, if the data type is changed from `nvarchar(max)` to `varchar(32)`, the
    original data will be truncated to 32 characters. Please make sure you understand
    the data type change before you run the migration.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在迁移过程中，如果数据类型发生变化，数据可能会丢失。例如，如果数据类型从 `nvarchar(max)` 更改为 `varchar(32)`，原始数据将被截断为32个字符。请在运行迁移之前确保您理解数据类型的变化。
- en: It is recommended to explicitly configure the mapping for each entity in order
    to ensure optimal performance. For example, `nvarchar(max)` requires more storage
    space than `varchar`, so the default mapping configuration may not be the most
    efficient. Additionally, the default `dbo` database schema may not be suitable
    for your particular scenario. Therefore, explicitly configuring the mapping is
    a recommended practice.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 建议明确为每个实体配置映射，以确保最佳性能。例如，`nvarchar(max)` 比起 `varchar` 需要更多的存储空间，因此默认的映射配置可能不是最有效的。此外，默认的
    `dbo` 数据库模式可能不适合您的特定场景。因此，明确配置映射是一种推荐的做法。
- en: Summary
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to access the database using EF Core. We implemented
    CRUD operations using the `DbContext` class. We introduced some basic LINQ queries,
    such as query, filter, sort, create, update, and delete. We also learned how to
    configure the mapping using data annotations and Fluent API. With the knowledge
    gained in this chapter, you can build a simple application to access the database.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 EF Core 访问数据库。我们使用 `DbContext` 类实现了 CRUD 操作。我们介绍了某些基本的 LINQ 查询，例如查询、筛选、排序、创建、更新和删除。我们还学习了如何使用数据注释和
    Fluent API 配置映射。通过本章获得的知识，您可以构建一个简单的应用程序来访问数据库。
- en: However, the application we built in this chapter is quite basic and only has
    one entity. In a real-world project, there are usually multiple entities and relationships
    between them.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本章中我们构建的应用程序相当基础，并且只有一个实体。在现实世界的项目中，通常存在多个实体以及它们之间的关系。
- en: In the next chapter, we will learn how to configure relationshiseps between
    entities using EF Core.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用 EF Core 配置实体之间的关系。
