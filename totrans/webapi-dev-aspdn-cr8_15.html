<html><head></head><body>
<div id="_idContainer142">
<h1 class="chapter-number" id="_idParaDest-331"><a id="_idTextAnchor632"/><span class="koboSpan" id="kobo.1.1">15</span></h1>
<h1 id="_idParaDest-332"><a id="_idTextAnchor633"/><span class="koboSpan" id="kobo.2.1">ASP.NET Core Web API Common Practices</span></h1>
<p><span class="koboSpan" id="kobo.3.1">We have introduced a lot of concepts in the previous chapters, including the basics of ASP.NET web API, the RESTful style, Entity Framework, unit testing and integration testing, CI/CD, and so on. </span><span class="koboSpan" id="kobo.3.2">You should be able to build a simple ASP.NET Core web API application by yourself. </span><span class="koboSpan" id="kobo.3.3">However, there are still many things that we need </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">to learn.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">You may have heard the phrase “</span><em class="italic"><span class="koboSpan" id="kobo.6.1">there is no silver bullet</span></em><span class="koboSpan" id="kobo.7.1">” before. </span><span class="koboSpan" id="kobo.7.2">It means that there are often no simple, universal, or one-size-fits-all solutions to solve all problems. </span><span class="koboSpan" id="kobo.7.3">No matter how powerful the technologies, tools, or frameworks are, they are not omnipotent. </span><span class="koboSpan" id="kobo.7.4">This is true for ASP.NET Core web API development. </span><span class="koboSpan" id="kobo.7.5">However, there are some common practices that can help us build a better ASP.NET Core web </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">API application.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, we will summarize the common practices of ASP.NET Core web API development. </span><span class="koboSpan" id="kobo.9.2">We will cover the following topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Common practices of ASP.NET Core web </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">API development</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Optimizing the performance by </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">implementing caching</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Using HttpClientFactory to manage </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">HttpClient instances</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">After reading this chapter, you should be able to expand your knowledge of ASP.NET Core web API development and build a better web </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">API application.</span></span></p>
<h1 id="_idParaDest-333"><a id="_idTextAnchor634"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.20.1">The code example in this chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">at </span></span><a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter15"><span class="No-Break"><span class="koboSpan" id="kobo.22.1">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter15</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.23.1">.</span></span></p>
<h1 id="_idParaDest-334"><a id="_idTextAnchor635"/><span class="koboSpan" id="kobo.24.1">Common practices of ASP.NET web API development</span></h1>
<p><span class="koboSpan" id="kobo.25.1">In this section, we will introduce some common practices of ASP.NET web API development. </span><span class="koboSpan" id="kobo.25.2">Of course, we can’t cover all the common practices in this book. </span><span class="koboSpan" id="kobo.25.3">However, we will try to cover the most </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">important ones.</span></span></p>
<h2 id="_idParaDest-335"><a id="_idTextAnchor636"/><span class="koboSpan" id="kobo.27.1">Using HTTPS instead of HTTP</span></h2>
<p><span class="koboSpan" id="kobo.28.1">In the</span><a id="_idIndexMarker1650"/><span class="koboSpan" id="kobo.29.1"> previous chapters, we have used HTTP endpoints for simplicity; however, in the real world, HTTPS should always be used instead of HTTP. </span><span class="koboSpan" id="kobo.29.2">HTTPS is a secure version of HTTP, which uses TLS/SSL to encrypt the HTTP traffic, thus preventing data from being intercepted or tampered with by a third party. </span><span class="koboSpan" id="kobo.29.3">This ensures the safety and integrity of the data </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">being transmitted.</span></span></p>
<p><span class="koboSpan" id="kobo.31.1">HTTPS is becoming increasingly popular for websites that require secure data transmission, such as online banking and online shopping. </span><span class="koboSpan" id="kobo.31.2">This trend is reflected in the fact that many web browsers, such as Google Chrome, Microsoft Edge, Firefox, and so on, now mark HTTP websites as </span><strong class="bold"><span class="koboSpan" id="kobo.32.1">Not Secure</span></strong><span class="koboSpan" id="kobo.33.1"> to encourage users to switch to HTTPS. </span><span class="koboSpan" id="kobo.33.2">This is a clear indication of the growing trend toward using HTTPS for secure </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">data transmission.</span></span></p>
<p><span class="koboSpan" id="kobo.35.1">The default ASP.NET Core web API template uses HTTPS by default. </span><span class="koboSpan" id="kobo.35.2">You can find the following code in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">Program.cs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.37.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.38.1">
app.UseHttpsRedirection();</span></pre> <p><span class="koboSpan" id="kobo.39.1">This code redirects all HTTP requests to HTTPS. </span><span class="koboSpan" id="kobo.39.2">In the development environment, the ASP.NET Core web API application uses a self-signed certificate. </span><span class="koboSpan" id="kobo.39.3">When you deploy your ASP.NET Core web API application to the production environment, you need to use a valid certificate issued by a </span><a id="_idIndexMarker1651"/><span class="koboSpan" id="kobo.40.1">trusted </span><strong class="bold"><span class="koboSpan" id="kobo.41.1">certificate authority</span></strong><span class="koboSpan" id="kobo.42.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.43.1">CA</span></strong><span class="koboSpan" id="kobo.44.1">), such as Let’s Encrypt, DigiCert, Comodo, and </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">so on</span><a id="_idTextAnchor637"/><span class="koboSpan" id="kobo.46.1">.</span></span></p>
<h2 id="_idParaDest-336"><a id="_idTextAnchor638"/><span class="koboSpan" id="kobo.47.1">Using HTTP status codes correctly</span></h2>
<p><span class="koboSpan" id="kobo.48.1">HTTP status codes</span><a id="_idIndexMarker1652"/><span class="koboSpan" id="kobo.49.1"> are used to indicate the status of the HTTP request. </span><span class="koboSpan" id="kobo.49.2">There are five categories of HTTP </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">status codes:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.51.1">1xx: Informational</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.52.1">2xx: Success</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.53.1">3xx: Redirection</span></span></li>
<li><span class="koboSpan" id="kobo.54.1">4xx: </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">Client errors</span></span></li>
<li><span class="koboSpan" id="kobo.56.1">5xx: </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">Server errors</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.58.1">The</span><a id="_idIndexMarker1653"/><span class="koboSpan" id="kobo.59.1"> following table provides a summary of some of the most commonly used HTTP status codes in RESTful </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">web APIs:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-10">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.61.1">Status code</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.62.1">Description</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">200</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.64.1">OK</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">201</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.66.1">Created</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">202</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.68.1">Accepted</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">204</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.70.1">No Content</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">301</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.72.1">Moved Permanently</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">302</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.74.1">Found</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">304</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.76.1">Not Modified</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">400</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.78.1">Bad Request</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">401</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.80.1">Unauthorized</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">403</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.82.1">Forbidden</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">404</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.84.1">Not Found</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">405</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.86.1">Method </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">Not Allowed</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">409</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.89.1">Conflict</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">410</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.91.1">Gone</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">415</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.93.1">Unsupported </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">Media Type</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">422</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.96.1">Unprocessable Entity</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">429</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.98.1">Too </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">Many Requests</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">500</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.101.1">Internal </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">Server Error</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">501</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.104.1">Not Implemented</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">503</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.106.1">Service Unavailable</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">504</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.108.1">Gateway Timeout</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.109.1">Table 15.1 – Commonly used HTTP status codes in RESTful web APIs</span></p>
<p><span class="koboSpan" id="kobo.110.1">The </span><a id="_idIndexMarker1654"/><span class="koboSpan" id="kobo.111.1">following list shows the HTTP methods and their corresponding status codes for RESTful </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">web APIs:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">GET</span></strong><span class="koboSpan" id="kobo.114.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">GET</span></strong><span class="koboSpan" id="kobo.116.1"> method is</span><a id="_idIndexMarker1655"/><span class="koboSpan" id="kobo.117.1"> used to retrieve a single resource or a collection of resources. </span><span class="koboSpan" id="kobo.117.2">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">GET</span></strong><span class="koboSpan" id="kobo.119.1"> request should not modify the state of the server. </span><span class="koboSpan" id="kobo.119.2">It can return the following </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">status codes:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">200</span></strong><span class="koboSpan" id="kobo.122.1">: The resource is found </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">and returned.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">404</span></strong><span class="koboSpan" id="kobo.125.1">: The resource is not found. </span><span class="koboSpan" id="kobo.125.2">Note that if a collection exists but is empty, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">GET</span></strong><span class="koboSpan" id="kobo.127.1"> method should return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">200</span></strong><span class="koboSpan" id="kobo.129.1"> status code instead of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">404</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.131.1">status code.</span></span></li></ul></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">POST</span></strong><span class="koboSpan" id="kobo.133.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">POST</span></strong><span class="koboSpan" id="kobo.135.1"> method </span><a id="_idIndexMarker1656"/><span class="koboSpan" id="kobo.136.1">is used to create a new single resource or a collection of resources. </span><span class="koboSpan" id="kobo.136.2">It can be also used to update a resource. </span><span class="koboSpan" id="kobo.136.3">It can return the following </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">status codes:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">200</span></strong><span class="koboSpan" id="kobo.139.1">: The resource is </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">updated successfully.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">201</span></strong><span class="koboSpan" id="kobo.142.1">: The resource is created successfully. </span><span class="koboSpan" id="kobo.142.2">The response should include the identifier of the newly </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">created resource.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">202</span></strong><span class="koboSpan" id="kobo.145.1">: The </span><a id="_idIndexMarker1657"/><span class="koboSpan" id="kobo.146.1">resource is accepted for processing, but the processing is not yet complete. </span><span class="koboSpan" id="kobo.146.2">This status code is often used for </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">long-running operations.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">400</span></strong><span class="koboSpan" id="kobo.149.1">: The request </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">is invalid.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">409</span></strong><span class="koboSpan" id="kobo.152.1">: The resource </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">already exists.</span></span></li></ul></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">PUT</span></strong><span class="koboSpan" id="kobo.155.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">PUT</span></strong><span class="koboSpan" id="kobo.157.1"> method</span><a id="_idIndexMarker1658"/><span class="koboSpan" id="kobo.158.1"> is used to update a single resource or a collection of resources. </span><span class="koboSpan" id="kobo.158.2">It is rarely used to create resources. </span><span class="koboSpan" id="kobo.158.3">It can return the following </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">status codes:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">200</span></strong><span class="koboSpan" id="kobo.161.1">: The resource was </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">updated successfully.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">204</span></strong><span class="koboSpan" id="kobo.164.1">: The resource was updated successfully but there is no content </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">to return.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">404</span></strong><span class="koboSpan" id="kobo.167.1">: The resource was </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">not found.</span></span></li></ul></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">DELETE</span></strong><span class="koboSpan" id="kobo.170.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">DELETE</span></strong><span class="koboSpan" id="kobo.172.1"> method is </span><a id="_idIndexMarker1659"/><span class="koboSpan" id="kobo.173.1">used to delete a single resource with a specific </span><a id="_idIndexMarker1660"/><span class="koboSpan" id="kobo.174.1">identifier. </span><span class="koboSpan" id="kobo.174.2">It can be used to delete a collection of resources but it is not a common scenario. </span><span class="koboSpan" id="kobo.174.3">It can return the following </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">status codes:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">200</span></strong><span class="koboSpan" id="kobo.177.1">: The resource was deleted successfully and the response includes the </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">deleted resource.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">204</span></strong><span class="koboSpan" id="kobo.180.1">: The resource was deleted successfully but there is no content </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">to return.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">404</span></strong><span class="koboSpan" id="kobo.183.1">: The resource was </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">not found.</span></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.185.1">It is important to note that this list is not exhaustive and only applies to RESTful web APIs. </span><span class="koboSpan" id="kobo.185.2">When selecting the appropriate HTTP status codes, please consider the specific scenarios. </span><span class="koboSpan" id="kobo.185.3">For GraphQL APIs, </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">200</span></strong><span class="koboSpan" id="kobo.187.1"> is typically used for most responses, with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">errors</span></strong><span class="koboSpan" id="kobo.189.1"> field indicating </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">any e</span><a id="_idTextAnchor639"/><span class="koboSpan" id="kobo.191.1">rrors.</span></span></p>
<h2 id="_idParaDest-337"><a id="_idTextAnchor640"/><span class="koboSpan" id="kobo.192.1">Using asynchronous programming</span></h2>
<p><span class="koboSpan" id="kobo.193.1">The</span><a id="_idIndexMarker1661"/><span class="koboSpan" id="kobo.194.1"> ASP.NET Core web API framework is designed to process requests asynchronously, so we should use asynchronous programming as much as possible. </span><span class="koboSpan" id="kobo.194.2">Asynchronous programming allows the application to process multiple tasks concurrently, which can improve the performance of the application. </span><span class="koboSpan" id="kobo.194.3">For many I/O-bound operations, such as accessing the database, sending HTTP requests, and operating files, using asynchronous programming can release the thread to process other requests while waiting for the I/O operation </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">to complete.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">In C#, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">async</span></strong><span class="koboSpan" id="kobo.198.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">await</span></strong><span class="koboSpan" id="kobo.200.1"> keywords to define and await asynchronous operations. </span><span class="koboSpan" id="kobo.200.2">Many methods in .NET have synchronous and asynchronous versions. </span><span class="koboSpan" id="kobo.200.3">For example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">StreamReader</span></strong><span class="koboSpan" id="kobo.202.1"> class has the following synchronous and asynchronous methods to read the content of </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">the stream:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.204.1">
// Synchronous methodspublic int Read();
public string ReadToEnd();
// Asynchronous methods
public Task&lt;int&gt; ReadAsync();
public Task&lt;string&gt; ReadToEndAsync();</span></pre>
<p><span class="koboSpan" id="kobo.205.1">In these four methods, the methods without the </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">Async</span></strong><span class="koboSpan" id="kobo.207.1"> suffix are synchronous, which blocks the thread until the operation is completed. </span><span class="koboSpan" id="kobo.207.2">In contrast, the methods that have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">Async</span></strong><span class="koboSpan" id="kobo.209.1"> suffix are asynchronous, which returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">Task</span></strong><span class="koboSpan" id="kobo.211.1"> object immediately and allows the thread to process other requests. </span><span class="koboSpan" id="kobo.211.2">When the operation is completed, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">Task</span></strong><span class="koboSpan" id="kobo.213.1"> object will be completed and the thread will continue to process the request. </span><span class="koboSpan" id="kobo.213.2">Whenever possible, we should use asynchronous programming to improve the performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.215.1">For I/O operations, we should always use asynchronous programming. </span><span class="koboSpan" id="kobo.215.2">For example, when accessing </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">HttpRequest</span></strong><span class="koboSpan" id="kobo.217.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">HttpResponse</span></strong><span class="koboSpan" id="kobo.219.1"> objects, we should use the asynchronous methods. </span><span class="koboSpan" id="kobo.219.2">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.221.1">
[HttpPost]public async Task&lt;ActionResult&lt;Post&gt;&gt; PostAsync()
{
    // Read the content of the request body
    var jsonString = await new StreamReader(Request.Body).ReadToEndAsync();
    // Do something with the content
    var result = JsonSerializer.Deserialize&lt;Post&gt;(jsonString);
    return Ok(result);
}</span></pre>
<p><span class="koboSpan" id="kobo.222.1">In the </span><a id="_idIndexMarker1662"/><span class="koboSpan" id="kobo.223.1">preceding code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">ReadToEndAsync()</span></strong><span class="koboSpan" id="kobo.225.1"> method is used to read the content of the request body. </span><span class="koboSpan" id="kobo.225.2">For this case, we should not use the synchronous </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">ReadToEnd()</span></strong><span class="koboSpan" id="kobo.227.1"> method because it will block the thread until the operation </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">is completed.</span></span></p>
<p><span class="koboSpan" id="kobo.229.1">If there are multiple asynchronous operations that need to be executed concurrently, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">Task.WhenAll()</span></strong><span class="koboSpan" id="kobo.231.1"> method to wait for all the asynchronous operations to complete. </span><span class="koboSpan" id="kobo.231.2">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.233.1">
[HttpGet]public async Task&lt;ActionResult&gt; GetAsync()
{
    // Simulate a long-running I/O-bound operation
    var task1 = SomeService.DoSomethingAsync();
    var task2 = SomeService.DoSomethingElseAsync();
    await Task.WhenAll(task1, task2);
    return Ok();
}</span></pre>
<p><span class="koboSpan" id="kobo.234.1">In the preceding code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">Task.WhenAll()</span></strong><span class="koboSpan" id="kobo.236.1"> method waits for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">task1</span></strong><span class="koboSpan" id="kobo.238.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">task2</span></strong><span class="koboSpan" id="kobo.240.1"> tasks to complete. </span><span class="koboSpan" id="kobo.240.2">If you need to get the results of the tasks after they are completed, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">Result</span></strong><span class="koboSpan" id="kobo.242.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">Task</span></strong><span class="koboSpan" id="kobo.244.1"> object to get the results. </span><span class="koboSpan" id="kobo.244.2">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.246.1">
[HttpGet]public async Task&lt;ActionResult&gt; GetAsync()
{
    // Simulate long-running I/O-bound operations
    var task1 = SomeService.DoSomethingAsync();
    var task2 = SomeService.DoSomethingElseAsync();
    await Task.WhenAll(task1, task2);
    var result1 = task1.Result;
    var result2 = task2.Result;
    // Do something with the results
    return Ok();
}</span></pre>
<p><span class="koboSpan" id="kobo.247.1">In the</span><a id="_idIndexMarker1663"/><span class="koboSpan" id="kobo.248.1"> preceding code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">Result</span></strong><span class="koboSpan" id="kobo.250.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">task1</span></strong><span class="koboSpan" id="kobo.252.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">task2</span></strong><span class="koboSpan" id="kobo.254.1"> objects is used to get the results of the tasks. </span><span class="koboSpan" id="kobo.254.2">As we already used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">await</span></strong><span class="koboSpan" id="kobo.256.1"> keyword to wait for the tasks to be completed, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">Result</span></strong><span class="koboSpan" id="kobo.258.1"> property will return the results immediately. </span><span class="koboSpan" id="kobo.258.2">But if we don’t use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">await</span></strong><span class="koboSpan" id="kobo.260.1"> keyword to wait for the tasks to be completed, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">Result</span></strong><span class="koboSpan" id="kobo.262.1"> property will block the thread until the tasks are completed. </span><span class="koboSpan" id="kobo.262.2">So, please be careful when using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">Result</span></strong><span class="koboSpan" id="kobo.264.1"> property. </span><span class="koboSpan" id="kobo.264.2">Similarly, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">Wait()</span></strong><span class="koboSpan" id="kobo.266.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">Task</span></strong><span class="koboSpan" id="kobo.268.1"> object will also block the thread until the task is completed. </span><span class="koboSpan" id="kobo.268.2">If you want to wait for a task to complete, use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">await</span></strong><span class="koboSpan" id="kobo.270.1"> keyword instead of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">Wait</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.272.1"> method.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.273.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.274.1">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">Task.WhenAll()</span></strong><span class="koboSpan" id="kobo.276.1"> method is not suitable for all scenarios. </span><span class="koboSpan" id="kobo.276.2">For example, EF Core does not support running multiple queries in parallel on the same database context. </span><span class="koboSpan" id="kobo.276.3">If you need to execute multiple queries on the same database context, you should use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">await</span></strong><span class="koboSpan" id="kobo.278.1"> keyword to wait for the previous query to complete before executing the </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">next query.</span></span></p>
<p><span class="koboSpan" id="kobo.280.1">When</span><a id="_idIndexMarker1664"/><span class="koboSpan" id="kobo.281.1"> utilizing asynchronous programming, there are several important considerations to keep in mind. </span><span class="koboSpan" id="kobo.281.2">These include, but are not limited to, </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.283.1">Do not use </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">async void</span></strong><span class="koboSpan" id="kobo.285.1"> in ASP.NET Core. </span><span class="koboSpan" id="kobo.285.2">The only scenario where </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">async void</span></strong><span class="koboSpan" id="kobo.287.1"> is allowed is in event handlers. </span><span class="koboSpan" id="kobo.287.2">If an async method returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">void</span></strong><span class="koboSpan" id="kobo.289.1">, the exceptions thrown in the method will not be caught by the </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">caller properly.</span></span></li>
<li><span class="koboSpan" id="kobo.291.1">Do not mix synchronous and asynchronous methods in the same method. </span><span class="koboSpan" id="kobo.291.2">Try to use async for the entire process if possible. </span><span class="koboSpan" id="kobo.291.3">This allows the entire call stack to </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">be asynchronous.</span></span></li>
<li><span class="koboSpan" id="kobo.293.1">If you need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">Result</span></strong><span class="koboSpan" id="kobo.295.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">Task</span></strong><span class="koboSpan" id="kobo.297.1"> object, make sure that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">Task</span></strong><span class="koboSpan" id="kobo.299.1"> object is completed. </span><span class="koboSpan" id="kobo.299.2">Otherwise, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">Result</span></strong><span class="koboSpan" id="kobo.301.1"> property will block the thread until the </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">Task</span></strong><span class="koboSpan" id="kobo.303.1"> object </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">is completed.</span></span></li>
<li><span class="koboSpan" id="kobo.305.1">If you have a method that only returns the result of another async method, there’s no need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">async</span></strong><span class="koboSpan" id="kobo.307.1"> keyword. </span><span class="koboSpan" id="kobo.307.2">Just return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">Task</span></strong><span class="koboSpan" id="kobo.309.1"> object directly. </span><span class="koboSpan" id="kobo.309.2">For example, the following code </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">is unnecessary:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.311.1">
public async Task&lt;int&gt; GetDataAsync(){    return await SomeService.GetDataAsync();}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.312.1">The following code does not use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">async</span></strong><span class="koboSpan" id="kobo.314.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">await</span></strong><span class="koboSpan" id="kobo.316.1"> keywords, which </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">is better:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.318.1">public Task&lt;int&gt; GetDataAsync(){    return SomeService.GetDataAsync();}</span></pre></li> </ul>
<p><span class="koboSpan" id="kobo.319.1">This is because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">async</span></strong><span class="koboSpan" id="kobo.321.1"> keyword will create a state machine to manage the execution of the async method. </span><span class="koboSpan" id="kobo.321.2">In this case, it is unnecessary. </span><span class="koboSpan" id="kobo.321.3">Returning the </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">Task</span></strong><span class="koboSpan" id="kobo.323.1"> directly does not create </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">additional</span><a id="_idTextAnchor641"/><span class="koboSpan" id="kobo.325.1"> overhead.</span></span></p>
<h2 id="_idParaDest-338"><a id="_idTextAnchor642"/><span class="koboSpan" id="kobo.326.1">Using pagination for large collections</span></h2>
<p><span class="koboSpan" id="kobo.327.1">It is not</span><a id="_idIndexMarker1665"/><span class="koboSpan" id="kobo.328.1"> recommended to return a large collection of resources in a single response, as this can lead to performance issues. </span><span class="koboSpan" id="kobo.328.2">Such issues may include </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.330.1">The server may require a significant amount of time to query the database and process </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">the response.</span></span></li>
<li><span class="koboSpan" id="kobo.332.1">The response payload may be quite large, resulting in network congestion. </span><span class="koboSpan" id="kobo.332.2">This can negatively impact the performance of the system, leading to increased latency and </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">decreased throughput.</span></span></li>
<li><span class="koboSpan" id="kobo.334.1">The client may require additional time and resources to process the large response. </span><span class="koboSpan" id="kobo.334.2">Deserializing a large JSON object can be computationally expensive for the client. </span><span class="koboSpan" id="kobo.334.3">Also, rendering a large collection of items on the UI may cause the client to </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">become unresponsive.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.336.1">In order to efficiently manage large collections, it is recommended to use pagination. </span><a href="B18971_05.xhtml#_idTextAnchor198"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.337.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.338.1"> introduces pagination and filtering through the use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">Skip()</span></strong><span class="koboSpan" id="kobo.340.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">Take()</span></strong><span class="koboSpan" id="kobo.342.1"> methods of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">IQueryable</span></strong><span class="koboSpan" id="kobo.344.1"> interface. </span><span class="koboSpan" id="kobo.344.2">Also, we mentioned that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">AsNoTracking()</span></strong><span class="koboSpan" id="kobo.346.1"> method should be used to improve the performance of the read-only queries. </span><span class="koboSpan" id="kobo.346.2">This will result in a collection of resources being returned to the client. </span><span class="koboSpan" id="kobo.346.3">However, the client may not be aware of whether there are more resources available. </span><span class="koboSpan" id="kobo.346.4">To address this issue, we can create a custom class to represent the paginated response. </span><span class="koboSpan" id="kobo.346.5">An example of this is </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">provided here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.348.1">
public class PaginatedList&lt;T&gt; where T : class{
    public int PageIndex { get; }
    public int PageSize { get; }
    public int TotalPages { get; }
    public List&lt;T&gt; Items { get; } = new();
    public PaginatedList(List&lt;T&gt; items, int count, int pageIndex = 1, int pageSize = 10)
    {
        PageIndex = pageIndex;
        PageSize = pageSize;
        TotalPages = (int)Math.Ceiling(count / (double)pageSize);
        Items.AddRange(items);
    }
    public bool HasPreviousPage =&gt; PageIndex &gt; 1;
    public bool HasNextPage =&gt; PageIndex &lt; TotalPages;
}</span></pre>
<p><span class="koboSpan" id="kobo.349.1">In the preceding code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">PaginatedList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.351.1"> class contains a couple of properties to represent the </span><a id="_idIndexMarker1666"/><span class="No-Break"><span class="koboSpan" id="kobo.352.1">pagination information:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">PageIndex</span></strong><span class="koboSpan" id="kobo.354.1">: The current </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">page index</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">PageSize</span></strong><span class="koboSpan" id="kobo.357.1">: The </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">page size</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">TotalPages</span></strong><span class="koboSpan" id="kobo.360.1">: The total number </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">of pages</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">Items</span></strong><span class="koboSpan" id="kobo.363.1">: The collection of items on the </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">current page</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">HasPreviousPage</span></strong><span class="koboSpan" id="kobo.366.1">: Indicates whether there is a </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">previous page</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">HasNextPage</span></strong><span class="koboSpan" id="kobo.369.1">: Indicates whether there is a </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">next page</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.371.1">Then, we can use this class in the controller for pagination. </span><span class="koboSpan" id="kobo.371.2">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.373.1">
[HttpGet]public async Task&lt;ActionResult&lt;PaginatedList&lt;Post&gt;&gt;&gt; GetPosts(int pageIndex = 1, int pageSize = 10)
{
    var posts = _context.Posts.AsQueryable().AsNoTracking();
    var count = await posts.CountAsync();
    var items = await posts.Skip((pageIndex - 1) * pageSize).Take(pageSize).ToListAsync();
    var result = new PaginatedList&lt;Post&gt;(items, count, pageIndex, pageSize);
    return Ok(result);
}</span></pre>
<p><span class="koboSpan" id="kobo.374.1">In the </span><a id="_idIndexMarker1667"/><span class="koboSpan" id="kobo.375.1">preceding code, besides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">Items</span></strong><span class="koboSpan" id="kobo.377.1"> property, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">PaginatedList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.379.1"> class also contains the pagination information, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">PageIndex</span></strong><span class="koboSpan" id="kobo.381.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">PageSize</span></strong><span class="koboSpan" id="kobo.383.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">TotalPages</span></strong><span class="koboSpan" id="kobo.385.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">HasPreviousPage</span></strong><span class="koboSpan" id="kobo.387.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">HasNextPage</span></strong><span class="koboSpan" id="kobo.389.1">, and so on. </span><span class="koboSpan" id="kobo.389.2">The response of the endpoint will be </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.391.1">
{  "pageIndex": 1,
  "pageSize": 10,
  "totalPages": 3,
  "items": [
    {
      "id": "3c979917-437b-406d-a784-0784170b5dd9",
      "title": "Post 26",
      "content": "Post 26 content",
      "categoryId": "ffdd0d80-3c3b-4e83-84c9-025d5650c6e5",
      "category": null
    },
    ...
</span><span class="koboSpan" id="kobo.391.2">  ],
  "hasPreviousPage": false,
  "hasNextPage": true
}</span></pre>
<p><span class="koboSpan" id="kobo.392.1">In this way, the </span><a id="_idIndexMarker1668"/><span class="koboSpan" id="kobo.393.1">clients can implement pagination easily. </span><span class="koboSpan" id="kobo.393.2">You can also include more information in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">PaginatedList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.395.1"> class, such as the links to the previous page and the next page, and </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.397.1">When implementing pagination, it is important to consider sorting and filtering. </span><span class="koboSpan" id="kobo.397.2">Generally, the data should be filtered first, followed by sorting and then pagination. </span><span class="koboSpan" id="kobo.397.3">For example, the following LINQ query can </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">be used:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.399.1">
var posts = _context.Posts.AsQueryable().AsNoTracking();posts = posts.Where(x =&gt; x.Title.Contains("Post")).OrderBy(x =&gt; x.PublishDate).Skip((pageIndex - 1) * pageSize).Take(pageSize).ToListAsync();</span></pre>
<p><span class="koboSpan" id="kobo.400.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">Where()</span></strong><span class="koboSpan" id="kobo.402.1"> method should be used to filter the data first in order to reduce the amount of data to be sorted. </span><span class="koboSpan" id="kobo.402.2">This is important, as sorting is often an expensive operation. </span><span class="koboSpan" id="kobo.402.3">Once the data has been filtered, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">OrderBy()</span></strong><span class="koboSpan" id="kobo.404.1"> method can be used to sort it. </span><span class="koboSpan" id="kobo.404.2">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">Skip()</span></strong><span class="koboSpan" id="kobo.406.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">Take()</span></strong><span class="koboSpan" id="kobo.408.1"> methods can be used to pagi</span><a id="_idTextAnchor643"/><span class="koboSpan" id="kobo.409.1">nate </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">the data.</span></span></p>
<h2 id="_idParaDest-339"><a id="_idTextAnchor644"/><span class="koboSpan" id="kobo.411.1">Specifying the response types</span></h2>
<p><span class="koboSpan" id="kobo.412.1">An </span><a id="_idIndexMarker1669"/><span class="koboSpan" id="kobo.413.1">ASP.NET Core web API endpoint can return various types of responses, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">ActionResult</span></strong><span class="koboSpan" id="kobo.415.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">ActionResult&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.417.1">, or a specific type of the object. </span><span class="koboSpan" id="kobo.417.2">For example, the following code returns a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">Post</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.419.1"> object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.420.1">
[HttpGet("{id}")]public async Task&lt;Post&gt; GetAsync(Guid id)
{
    var post = await _postService.GetAsync(id);
    return post;
}</span></pre>
<p><span class="koboSpan" id="kobo.421.1">The preceding code works, but what if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">post</span></strong><span class="koboSpan" id="kobo.423.1"> cannot be found? </span><span class="koboSpan" id="kobo.423.2">It is recommended to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">ActionResult&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.425.1"> instead of the specific type of the object. </span><span class="koboSpan" id="kobo.425.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">ActionResult&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.427.1"> class is a generic class that can be used to return various HTTP status codes. </span><span class="koboSpan" id="kobo.427.2">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.429.1">
public async Task&lt;ActionResult&lt;Post&gt;&gt; GetPost(Guid id){
    var post = await _context.Posts.FindAsync(id);
    if (post == null)
    {
        return NotFound();
    }
    return Ok(post);
}</span></pre>
<p><span class="koboSpan" id="kobo.430.1">In the</span><a id="_idIndexMarker1670"/><span class="koboSpan" id="kobo.431.1"> preceding code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">ActionResult&lt;Post&gt;</span></strong><span class="koboSpan" id="kobo.433.1"> class is used to return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">Post</span></strong><span class="koboSpan" id="kobo.435.1"> object. </span><span class="koboSpan" id="kobo.435.2">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">post</span></strong><span class="koboSpan" id="kobo.437.1"> cannot be found, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">NotFound</span></strong><span class="koboSpan" id="kobo.439.1"> method is used to return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">404 Not Found</span></strong><span class="koboSpan" id="kobo.441.1"> status code. </span><span class="koboSpan" id="kobo.441.2">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">post</span></strong><span class="koboSpan" id="kobo.443.1"> is found, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">Ok</span></strong><span class="koboSpan" id="kobo.445.1"> method is used to return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">200 OK</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.447.1">status code.</span></span></p>
<p><span class="koboSpan" id="kobo.448.1">We can add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">[ProducesResponseType]</span></strong><span class="koboSpan" id="kobo.450.1"> attribute to specify the response types of the endpoint. </span><span class="koboSpan" id="kobo.450.2">Here is a </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">complete example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.452.1">
[HttpGet("{id}")][ProducesResponseType(StatusCodes.Status200OK)]
[ProducesResponseType(StatusCodes.Status404NotFound)]
public async Task&lt;ActionResult&lt;Post&gt;&gt; GetPost(Guid id)
{
    var post = await _context.Posts.FindAsync(id);
    if (post == null)
    {
        return NotFound();
    }
    return Ok(post);
}</span></pre>
<p><span class="koboSpan" id="kobo.453.1">In the </span><a id="_idIndexMarker1671"/><span class="koboSpan" id="kobo.454.1">preceding code, there are two </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">[ProducesResponseType]</span></strong><span class="koboSpan" id="kobo.456.1"> attributes. </span><span class="koboSpan" id="kobo.456.2">The first one specifies the </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">200 OK</span></strong><span class="koboSpan" id="kobo.458.1"> status code and the second one specifies the </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">404 Not Found</span></strong><span class="koboSpan" id="kobo.460.1"> status code. </span><span class="koboSpan" id="kobo.460.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">[ProducesResponseType]</span></strong><span class="koboSpan" id="kobo.462.1"> attribute is optional, but it is recommended to use it to specify the response types of the endpoint. </span><span class="koboSpan" id="kobo.462.2">The Swagger UI will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">[ProducesResponseType]</span></strong><span class="koboSpan" id="kobo.464.1"> attribute to generate the response types of the endpoint, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.465.1">Figure 15</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.466.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer138">
<span class="koboSpan" id="kobo.468.1"><img alt="Figure 15.1 – The Swagger UI uses the [ProducesResponseType] attribute to generate the response types of the endpoint" src="image/B18971_15_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.469.1">Figure 15.1 – The Swagger UI uses the [ProducesResponseType] attribute to generate the response types of the endpoint</span></p>
<p><span class="koboSpan" id="kobo.470.1">We can see</span><a id="_idIndexMarker1672"/><span class="koboSpan" id="kobo.471.1"> there are possible responses in the Swagger UI. </span><span class="koboSpan" id="kobo.471.2">This endpoint can return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">200 OK</span></strong><span class="koboSpan" id="kobo.473.1"> status code or the </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">404 Not Found</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.475.1">status code.</span></span></p>
<p><span class="koboSpan" id="kobo.476.1">To enforce the use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">[ProducesResponseType]</span></strong><span class="koboSpan" id="kobo.478.1"> attribute, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">OpenAPIAnalyzers</span></strong><span class="koboSpan" id="kobo.480.1">. </span><span class="koboSpan" id="kobo.480.2">This analyzer can be used to report the missing </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">[ProducesResponseType]</span></strong><span class="koboSpan" id="kobo.482.1"> attribute. </span><span class="koboSpan" id="kobo.482.2">Add the following code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">&lt;PropertyGroup&gt;</span></strong><span class="koboSpan" id="kobo.484.1"> section of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">*.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">csproj</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.487.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.488.1">
&lt;IncludeOpenAPIAnalyzers&gt;true&lt;/IncludeOpenAPIAnalyzers&gt;</span></pre> <p><span class="koboSpan" id="kobo.489.1">Then, we can see the warning in Visual Studio if the controller action does not have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">[ProducesResponseType]</span></strong><span class="koboSpan" id="kobo.491.1"> attribute, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.492.1">Figure 15</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.493.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer139">
<span class="koboSpan" id="kobo.495.1"><img alt="Figure 15.2 – Visual Studio displays the warning if the controller action does not have the [ProducesResponseType] attribute" src="image/B18971_15_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.496.1">Figure 15.2 – Visual Studio displays the warning if the controller action does not have the [ProducesResponseType] attribute</span></p>
<p><span class="koboSpan" id="kobo.497.1">Visual Studio</span><a id="_idIndexMarker1673"/><span class="koboSpan" id="kobo.498.1"> will provide you with a quick fix to add these attributes. </span><span class="koboSpan" id="kobo.498.2">This analyzer is very useful and it is recom</span><a id="_idTextAnchor645"/><span class="koboSpan" id="kobo.499.1">mended to </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">use it.</span></span></p>
<h2 id="_idParaDest-340"><a id="_idTextAnchor646"/><span class="koboSpan" id="kobo.501.1">Adding comments to the endpoints</span></h2>
<p><span class="koboSpan" id="kobo.502.1">Adding XML comments </span><a id="_idIndexMarker1674"/><span class="koboSpan" id="kobo.503.1">to the endpoints can help other developers understand them better. </span><span class="koboSpan" id="kobo.503.2">These comments will be displayed in the Swagger UI, providing a comprehensive description of the endpoints. </span><span class="koboSpan" id="kobo.503.3">This can be a great resource for developers to use when working with </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">the endpoints.</span></span></p>
<p><span class="koboSpan" id="kobo.505.1">Adding XML comments to the endpoints is very simple. </span><span class="koboSpan" id="kobo.505.2">We just need to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">///</span></strong><span class="koboSpan" id="kobo.507.1"> comments to them. </span><span class="koboSpan" id="kobo.507.2">Visual Studio will automatically generate the XML comments structure when you type </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">///</span></strong><span class="koboSpan" id="kobo.509.1">. </span><span class="koboSpan" id="kobo.509.2">You need to add the description of the method, the parameters, the return value, and so on. </span><span class="koboSpan" id="kobo.509.3">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.511.1">
/// &lt;summary&gt;/// Get a post by id
/// &lt;/summary&gt;
/// &lt;param name="id"&gt;The id of the post&lt;/param&gt;
/// &lt;returns&gt;The post&lt;/returns&gt;
[HttpGet("{id}")]
[ProducesResponseType(StatusCodes.Status200OK)]
[ProducesResponseType(StatusCodes.Status404NotFound)]
public async Task&lt;ActionResult&lt;Post&gt;&gt; GetPost(Guid id)
{
    // Omitted for brevity
}</span></pre>
<p><span class="koboSpan" id="kobo.512.1">You can</span><a id="_idIndexMarker1675"/><span class="koboSpan" id="kobo.513.1"> also add comments to the model classes. </span><span class="koboSpan" id="kobo.513.2">Here is a </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">simple example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.515.1">
/// &lt;summary&gt;/// The post model
/// &lt;/summary&gt;
public class Post
{
    /// &lt;summary&gt;
    /// The id of the post
    /// &lt;/summary&gt;
    public Guid Id { get; set; }
    /// &lt;summary&gt;
    /// The title of the post
    /// &lt;/summary&gt;
    public string Title { get; set; }
    /// &lt;summary&gt;
    /// The content of the post
    /// &lt;/summary&gt;
    public string Content { get; set; }
}</span></pre>
<p><span class="koboSpan" id="kobo.516.1">Then, we need to enable the XML documentation file generation in the project file. </span><span class="koboSpan" id="kobo.516.2">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">*.csproj</span></strong><span class="koboSpan" id="kobo.518.1"> file and add the following code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">&lt;</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">PropertyGroup&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.521.1"> element:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.522.1">
&lt;GenerateDocumentationFile&gt;true&lt;/GenerateDocumentationFile&gt;&lt;NoWarn&gt;$(NoWarn);1591&lt;/NoWarn&gt;</span></pre>
<p><span class="koboSpan" id="kobo.523.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">GenerateDocumentationFile</span></strong><span class="koboSpan" id="kobo.525.1"> property specifies whether an XML documentation</span><a id="_idIndexMarker1676"/><span class="koboSpan" id="kobo.526.1"> file should be generated. </span><span class="koboSpan" id="kobo.526.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">NoWarn</span></strong><span class="koboSpan" id="kobo.528.1"> property can be used to suppress specific warnings, such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">1591</span></strong><span class="koboSpan" id="kobo.530.1"> warning code, which is associated with missing XML comments. </span><span class="koboSpan" id="kobo.530.2">Suppressing this warning is beneficial, as it prevents the warning from appearing when the project </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">is built.</span></span></p>
<p><span class="koboSpan" id="kobo.532.1">Next, we need to configure the Swagger UI to use the XML documentation file. </span><span class="koboSpan" id="kobo.532.2">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">Program.cs</span></strong><span class="koboSpan" id="kobo.534.1"> file and update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">builder.Services.AddSwaggerGen()</span></strong><span class="koboSpan" id="kobo.536.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.538.1">
builder.Services.AddSwaggerGen(c =&gt;{
    // The below line is optional. </span><span class="koboSpan" id="kobo.538.2">It is used to describe the API.
</span><span class="koboSpan" id="kobo.538.3">    // c.SwaggerDoc("v1", new OpenApiInfo { Title = "MyBasicWebApiDemo", Version = "v1" });
    c.IncludeXmlComments(Path.Combine(AppContext.BaseDirectory, $"{Assembly.GetExecutingAssembly().GetName().Name}.xml"));
});</span></pre>
<p><span class="koboSpan" id="kobo.539.1">In the preceding code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">IncludeXmlComments</span></strong><span class="koboSpan" id="kobo.541.1"> method is used to specify the XML documentation file. </span><span class="koboSpan" id="kobo.541.2">We can use reflection </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">{Assembly.GetExecutingAssembly().GetName().Name}.xml</span></strong><span class="koboSpan" id="kobo.543.1">, to get the name of the XML documentation file. </span><span class="koboSpan" id="kobo.543.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">AppContext.BaseDirectory</span></strong><span class="koboSpan" id="kobo.545.1"> property is used to get the base directory of </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">To</span><a id="_idIndexMarker1677"/><span class="koboSpan" id="kobo.548.1"> view the comments in the Swagger UI, run the application and open the Swagger UI. </span><span class="koboSpan" id="kobo.548.2">As shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.549.1">Figure 15</span></em></span><em class="italic"><span class="koboSpan" id="kobo.550.1">.3</span></em><span class="koboSpan" id="kobo.551.1">, the comments will </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">be displayed:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer140">
<span class="koboSpan" id="kobo.553.1"><img alt="Figure 15.3 – The Swagger UI displays the comments of the endpoints" src="image/B18971_15_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.554.1">Figure 15.3 – The Swagger UI displays the comments of the endpoints</span></p>
<p><span class="koboSpan" id="kobo.555.1">The model classes are also described in the Swagger UI, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.556.1">Figure 15</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.557.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer141">
<span class="koboSpan" id="kobo.559.1"><img alt="Figure 15.4 – The Swagger UI displays the comments of the model classes" src="image/B18971_15_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.560.1">Figure 15.4 – The Swagger UI displays the comments of the model classes</span></p>
<p><span class="koboSpan" id="kobo.561.1">Displaying</span><a id="_idIndexMarker1678"/><span class="koboSpan" id="kobo.562.1"> the comments in the Swagger UI is a great way to provide developer-friendly API documentation. </span><span class="koboSpan" id="kobo.562.2">It is highly recommended to add comments to the endpoint</span><a id="_idTextAnchor647"/><span class="koboSpan" id="kobo.563.1">s and </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">model classes.</span></span></p>
<h2 id="_idParaDest-341"><a id="_idTextAnchor648"/><span class="koboSpan" id="kobo.565.1">Using System.Text.Json instead of Newtonsoft.Json</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">Newtonsoft.Json</span></strong><span class="koboSpan" id="kobo.567.1"> is a popular JSON library for .NET and is widely used in many projects. </span><span class="koboSpan" id="kobo.567.2">It </span><a id="_idIndexMarker1679"/><span class="koboSpan" id="kobo.568.1">was created as a personal project by James Newton-King in 2006 and has since become the number one library on NuGet, with over one billion downloads. </span><span class="koboSpan" id="kobo.568.2">An interesting fact is that in 2022, the downloads of </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">Newtonsoft.Json</span></strong><span class="koboSpan" id="kobo.570.1"> on NuGet reached an impressive 2.1 billion, surpassing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">Int32.MaxValue</span></strong><span class="koboSpan" id="kobo.572.1"> of 2,147,483,647. </span><span class="koboSpan" id="kobo.572.2">This milestone necessitated a change to NuGet to support the continued downloads </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">Newtonsoft.Json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.576.1">Microsoft has introduced a new JSON library, </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">System.Text.Json</span></strong><span class="koboSpan" id="kobo.578.1">, with the release of .NET Core 3.0. </span><span class="koboSpan" id="kobo.578.2">This library was designed to be high performing by utilizing </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">Span&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.580.1">, which provides a type-safe and memory-safe representation of contiguous regions of arbitrary memory. </span><span class="koboSpan" id="kobo.580.2">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">Span&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.582.1"> can reduce memory allocation and improve the performance of .NET code. </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">System.Text.Json</span></strong><span class="koboSpan" id="kobo.584.1"> is included in the .NET Core SDK and is actively</span><a id="_idIndexMarker1680"/><span class="koboSpan" id="kobo.585.1"> being developed. </span><span class="koboSpan" id="kobo.585.2">Although it may not have all the features of </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">Newtonsoft.Json</span></strong><span class="koboSpan" id="kobo.587.1">, it is a great choice for </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">new projects.</span></span></p>
<p><span class="koboSpan" id="kobo.589.1">The latest ASP.NET web API template uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">System.Text.Json</span></strong><span class="koboSpan" id="kobo.591.1"> by default. </span><span class="koboSpan" id="kobo.591.2">It provides a simple way to serialize and deserialize JSON data. </span><span class="koboSpan" id="kobo.591.3">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.593.1">
var options = new JsonSerializerOptions{
    PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
    WriteIndented = true
};
// Serialize
var json = JsonSerializer.Serialize(post, options);
// Deserialize
var post = JsonSerializer.Deserialize&lt;Post&gt;(json, options);</span></pre>
<p><span class="koboSpan" id="kobo.594.1">If you still want to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">Newtonsoft.Json</span></strong><span class="koboSpan" id="kobo.596.1">, you can install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">Microsoft.AspNetCore.Mvc.NewtonsoftJson</span></strong><span class="koboSpan" id="kobo.598.1"> NuGet package and update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">Program.cs</span></strong><span class="koboSpan" id="kobo.600.1"> file </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.602.1">
builder.Services.AddControllers()    .AddNewtonsoftJson(options =&gt;
    {
        options.SerializerSettings.ContractResolver = new CamelCasePropertyNamesContractResolver();
        options.SerializerSettings.Formatting = Formatting.Indented;
    });</span></pre>
<p><span class="koboSpan" id="kobo.603.1">You can </span><a id="_idIndexMarker1681"/><span class="koboSpan" id="kobo.604.1">update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">options</span></strong><span class="koboSpan" id="kobo.606.1"> object to configure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">Newtonsoft.Json</span></strong><span class="koboSpan" id="kobo.608.1"> library. </span><span class="koboSpan" id="kobo.608.2">Again, it is recommended to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">System.Text.Json</span></strong><span class="koboSpan" id="kobo.610.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">Newtonsoft.Json</span></strong><span class="koboSpan" id="kobo.612.1"> unless you need some specific features of </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">Newtonsoft.Json </span></strong><span class="koboSpan" id="kobo.614.1">because </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">System.Text.Json</span></strong> <a id="_idTextAnchor649"/><span class="koboSpan" id="kobo.616.1">has </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">better performance.</span></span></p>
<h1 id="_idParaDest-342"><a id="_idTextAnchor650"/><span class="koboSpan" id="kobo.618.1">Optimizing the performance by implementing caching</span></h1>
<p><span class="koboSpan" id="kobo.619.1">Caching is a</span><a id="_idIndexMarker1682"/><span class="koboSpan" id="kobo.620.1"> common technique used to improve the performance of the application. </span><span class="koboSpan" id="kobo.620.2">In web API development, caching can store frequently accessed data in a temporary storage, such as memory or disk, to reduce the number of database queries and improve the responsiveness of the application. </span><span class="koboSpan" id="kobo.620.3">In this section, we will introduce the caching in ASP.NET Core web </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">API development.</span></span></p>
<p><span class="koboSpan" id="kobo.622.1">Caching is an effective tool when handling data that is not regularly updated but is costly to compute or obtain from the database. </span><span class="koboSpan" id="kobo.622.2">It is also useful when multiple clients access the same data frequently. </span><span class="koboSpan" id="kobo.622.3">As an example, consider an e-commerce application that displays a list of categories. </span><span class="koboSpan" id="kobo.622.4">The categories of the products are not often changed, yet they are frequently viewed by users. </span><span class="koboSpan" id="kobo.622.5">To improve the performance of the application, we can cache the categories. </span><span class="koboSpan" id="kobo.622.6">When a user requests the categories, the application can return the cached data directly without querying </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.624.1">In ASP.NET Core, we have several</span><a id="_idIndexMarker1683"/><span class="koboSpan" id="kobo.625.1"> options for implementing caching, each suited to a </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">specific scenario:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.627.1">In-memory caching</span></strong><span class="koboSpan" id="kobo.628.1">: This </span><a id="_idIndexMarker1684"/><span class="koboSpan" id="kobo.629.1">type of caching stores data in the </span><a id="_idIndexMarker1685"/><span class="koboSpan" id="kobo.630.1">memory of the application. </span><span class="koboSpan" id="kobo.630.2">It is fast and efficient and is suitable for scenarios where the data does not need to be shared across multiple instances of the application. </span><span class="koboSpan" id="kobo.630.3">However, the data will be lost when the application </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">is restarted.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.632.1">Distributed caching</span></strong><span class="koboSpan" id="kobo.633.1">: This</span><a id="_idIndexMarker1686"/><span class="koboSpan" id="kobo.634.1"> type of caching involves storing</span><a id="_idIndexMarker1687"/><span class="koboSpan" id="kobo.635.1"> cached data in a shared storage, such as Redis or SQL Server, which can be accessed by multiple instances of the application. </span><span class="koboSpan" id="kobo.635.2">It is suitable for applications that are deployed with multiple instances, such as a web farm, container orchestration, or </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">serverless computing.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.637.1">Response caching</span></strong><span class="koboSpan" id="kobo.638.1">: This</span><a id="_idIndexMarker1688"/><span class="koboSpan" id="kobo.639.1"> caching technique is based </span><a id="_idIndexMarker1689"/><span class="koboSpan" id="kobo.640.1">on the HTTP </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">caching mechanism.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.642.1">In the following sections, we will introduce the in-memory caching and distributed caching in ASP.NET Core web API development, as well as the output caching, which is </span><a id="_idTextAnchor651"/><span class="koboSpan" id="kobo.643.1">introduced in ASP.NET </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">Core 7.0.</span></span></p>
<h2 id="_idParaDest-343"><a id="_idTextAnchor652"/><span class="koboSpan" id="kobo.645.1">In-memory caching</span></h2>
<p><span class="koboSpan" id="kobo.646.1">In-memory caching </span><a id="_idIndexMarker1690"/><span class="koboSpan" id="kobo.647.1">is a fast and easy way to store data in an application’s </span><a id="_idIndexMarker1691"/><span class="koboSpan" id="kobo.648.1">memory. </span><span class="koboSpan" id="kobo.648.2">ASP.NET Core provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">IMemoryCache</span></strong><span class="koboSpan" id="kobo.650.1"> interface to facilitate this process. </span><span class="koboSpan" id="kobo.650.2">This type of caching is highly versatile, as it can store any type of data in the form of a </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">key-value pair.</span></span></p>
<p><span class="koboSpan" id="kobo.652.1">The example project in this section can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">chapter15/CachingDemo</span></strong><span class="koboSpan" id="kobo.654.1"> folder. </span><span class="koboSpan" id="kobo.654.2">This is a simple ASP.NET Core web API application. </span><span class="koboSpan" id="kobo.654.3">It contains a </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">/categories</span></strong><span class="koboSpan" id="kobo.656.1"> endpoint that returns the categories </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">of products.</span></span></p>
<p><span class="koboSpan" id="kobo.658.1">To simplify the example, we use a static list to store the categories to simulate a database. </span><span class="koboSpan" id="kobo.658.2">When the application queries the categories, it will print a log to indicate that the categories are queried from the database. </span><span class="koboSpan" id="kobo.658.3">Here is the code in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">CategoryService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.660.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.661.1">
public async Task&lt;IEnumerable&lt;Category&gt;&gt; GetCategoriesAsync(){
    // Simulate a database query
    _logger.LogInformation("Getting categories from the database");
    await Task.Delay(2000);
    return Categories;
}</span></pre>
<p><span class="koboSpan" id="kobo.662.1">In the preceding code, we use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">Task.Delay()</span></strong><span class="koboSpan" id="kobo.664.1"> method to simulate a database query. </span><span class="koboSpan" id="kobo.664.2">This query takes two seconds to complete, which is slow. </span><span class="koboSpan" id="kobo.664.3">As the categories are not often changed, we can use in-memory caching to improve the performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.666.1">To </span><a id="_idIndexMarker1692"/><span class="koboSpan" id="kobo.667.1">use </span><a id="_idIndexMarker1693"/><span class="koboSpan" id="kobo.668.1">in-memory caching, we need to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">Microsoft.Extensions.Caching.Memory</span></strong><span class="koboSpan" id="kobo.670.1"> NuGet package by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.672.1">
dotnet add package Microsoft.Extensions.Caching.Memory</span></pre> <p><span class="koboSpan" id="kobo.673.1">Then, we need to register the in-memory caching in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">Program</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.675.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.676.1">
builder.Services.AddMemoryCache();</span></pre> <p><span class="koboSpan" id="kobo.677.1">Next, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">IMemoryCache</span></strong><span class="koboSpan" id="kobo.679.1"> interface in other classes. </span><span class="koboSpan" id="kobo.679.2">Inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">IMemoryCache</span></strong><span class="koboSpan" id="kobo.681.1"> interface into the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">CategoryService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.683.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.684.1">
public class CategoryService(ILogger&lt;CategoryService&gt; logger, IMemoryCache cache)    : ICategoryService
{
    // Omitted for brevity
}</span></pre>
<p><span class="koboSpan" id="kobo.685.1">Update </span><a id="_idIndexMarker1694"/><span class="koboSpan" id="kobo.686.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">GetCategoriesAsync</span></strong><span class="koboSpan" id="kobo.688.1"> method</span><a id="_idIndexMarker1695"/> <span class="No-Break"><span class="koboSpan" id="kobo.689.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.690.1">
public async Task&lt;IEnumerable&lt;Category&gt;&gt; GetCategoriesAsync(){
    // Try to get the categories from the cache
    if (_cache.TryGetValue(CacheKeys.Categories, out IEnumerable&lt;Category&gt;? </span><span class="koboSpan" id="kobo.690.2">categories))
    {
        _logger.LogInformation("Getting categories from cache");
        return categories ?? </span><span class="koboSpan" id="kobo.690.3">new List&lt;Category&gt;();
    }
    // Simulate a database query
    _logger.LogInformation("Getting categories from the database");
    await Task.Delay(2000);
    categories = Categories;
    // Cache the categories for 10 minutes
    var cacheEntryOptions = new MemoryCacheEntryOptions()
        .SetAbsoluteExpiration(TimeSpan.FromMinutes(10));
    _cache.Set(CacheKeys.Categories, categories, cacheEntryOptions);
    return Categories;
}</span></pre>
<p><span class="koboSpan" id="kobo.691.1">In the updated code, we first try to get the categories from the cache by the cache key. </span><span class="koboSpan" id="kobo.691.2">If the categories are found in the cache, we return them directly. </span><span class="koboSpan" id="kobo.691.3">Otherwise, we query the database and cache the categories for 10 minutes. </span><span class="koboSpan" id="kobo.691.4">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">SetAbsoluteExpiration()</span></strong><span class="koboSpan" id="kobo.693.1"> method is used to set the absolute expiration time of the cache entry. </span><span class="koboSpan" id="kobo.693.2">After 10 minutes, the cache entry will be removed from </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">the cache.</span></span></p>
<p><span class="koboSpan" id="kobo.695.1">Run the </span><a id="_idIndexMarker1696"/><span class="koboSpan" id="kobo.696.1">application and send a request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">/categories</span></strong><span class="koboSpan" id="kobo.698.1"> endpoint. </span><span class="koboSpan" id="kobo.698.2">The first request will take 2 seconds to complete, and then the subsequent</span><a id="_idIndexMarker1697"/><span class="koboSpan" id="kobo.699.1"> requests will be completed immediately. </span><span class="koboSpan" id="kobo.699.2">You may see the following log in </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">the console:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.701.1">
info: CachingDemo.Services.CategoryService[0]      Getting categories from the database
info: CachingDemo.Services.CategoryService[0]
      Getting categories from cache</span></pre>
<p><span class="koboSpan" id="kobo.702.1">In this way, in-memory caching can significantly improve the performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.704.1">To ensure that the cache does not become bloated with outdated entries, the cache must apply a proper expiration policy. </span><span class="koboSpan" id="kobo.704.2">The cache has several options for expiration, two of them are </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.706.1">Absolute expiration</span></strong><span class="koboSpan" id="kobo.707.1">: The </span><a id="_idIndexMarker1698"/><span class="koboSpan" id="kobo.708.1">cache entry will be removed from the cache after a </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">specified time.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.710.1">Sliding expiration</span></strong><span class="koboSpan" id="kobo.711.1">: The </span><a id="_idIndexMarker1699"/><span class="koboSpan" id="kobo.712.1">cache entry will be removed after a predetermined period of time if it is </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">not accessed.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.714.1">When using </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">SlidingExpiration</span></strong><span class="koboSpan" id="kobo.716.1">, the cache can be retained indefinitely if it is accessed frequently. </span><span class="koboSpan" id="kobo.716.2">To avoid this, we can set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">AbsoluteExpiration</span></strong><span class="koboSpan" id="kobo.718.1"> property or </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">AbsoluteExpirationRelativeToNow</span></strong><span class="koboSpan" id="kobo.720.1"> property to limit the maximum lifetime of the cache entry. </span><span class="koboSpan" id="kobo.720.2">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.722.1">
var cacheEntryOptions = new MemoryCacheEntryOptions{
    SlidingExpiration = TimeSpan.FromMinutes(10),
    AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(30)
};
cache.Set(CacheKeys.Categories, categories, cacheEntryOptions);</span></pre>
<p><span class="koboSpan" id="kobo.723.1">In the preceding code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">SlidingExpiration</span></strong><span class="koboSpan" id="kobo.725.1"> property is set to 10 minutes, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">AbsoluteExpirationRelativeToNow</span></strong><span class="koboSpan" id="kobo.727.1"> property is set to 30 minutes. </span><span class="koboSpan" id="kobo.727.2">This means that the cache entry will be removed from the cache after 30 minutes, even if it is </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">frequently accessed.</span></span></p>
<p><span class="koboSpan" id="kobo.729.1">Sometimes </span><a id="_idIndexMarker1700"/><span class="koboSpan" id="kobo.730.1">we may need to manually update the cache entry. </span><span class="koboSpan" id="kobo.730.2">For </span><a id="_idIndexMarker1701"/><span class="koboSpan" id="kobo.731.1">example, when a new category is created, or an existing category is updated or deleted, we can remove the cache entry to force the application to query the database again and refresh the cache entry. </span><span class="koboSpan" id="kobo.731.2">Move the preceding code to a </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">new method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.733.1">
private async Task RefreshCategoriesCache(){
    // Query the database first
    logger.LogInformation("Getting categories from the database");
    // Simulate a database query
    await Task.Delay(2000);
    var categories = Categories;
    // Then refresh the cache
    cache.Remove(CacheKeys.Categories);
    var cacheEntryOptions = new MemoryCacheEntryOptions
    {
        SlidingExpiration = TimeSpan.FromMinutes(10),
        AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(30)
    };
    cache.Set(CacheKeys.Categories, categories, cacheEntryOptions);
}</span></pre>
<p><span class="koboSpan" id="kobo.734.1">Note that in the preceding code, we should query the database first, then remove the cache entry </span><a id="_idIndexMarker1702"/><span class="koboSpan" id="kobo.735.1">and reset it. </span><span class="koboSpan" id="kobo.735.2">Otherwise, the application may query the </span><a id="_idIndexMarker1703"/><span class="koboSpan" id="kobo.736.1">database multiple times if the cache entry is removed before the database query </span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">is completed.</span></span></p>
<p><span class="koboSpan" id="kobo.738.1">Then, we can call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">RefreshCategoriesCache()</span></strong><span class="koboSpan" id="kobo.740.1"> method when a new category is created or an existing category is updated or deleted. </span><span class="koboSpan" id="kobo.740.2">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.742.1">
public async Task&lt;Category?&gt; UpdateCategoryAsync(Category category){
    var existingCategory = Categories.FirstOrDefault(c =&gt; c.Id == category.Id);
    if (existingCategory == null)
    {
        return null;
    }
    existingCategory.Name = category.Name;
    existingCategory.Description = category.Description;
    await RefreshCategoriesCache();
    return existingCategory;
}</span></pre>
<p><span class="koboSpan" id="kobo.743.1">Alternatively, we can create a background task to update the cache entry periodically. </span><span class="koboSpan" id="kobo.743.2">A background task is a task that runs behind the scenes without user interaction. </span><span class="koboSpan" id="kobo.743.3">It is useful for performing tasks that are not time-sensitive, such as updating the cache entry. </span><span class="koboSpan" id="kobo.743.4">To create a background task, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">BackgroundService</span></strong><span class="koboSpan" id="kobo.745.1"> class. </span><span class="koboSpan" id="kobo.745.2">Create</span><a id="_idIndexMarker1704"/><span class="koboSpan" id="kobo.746.1"> a </span><a id="_idIndexMarker1705"/><span class="koboSpan" id="kobo.747.1">new class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">CategoriesCacheBackgroundService</span></strong><span class="koboSpan" id="kobo.749.1"> that inherits from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">BackgroundService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.751.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.752.1">
public class CategoriesCacheBackgroundService(    IServiceProvider serviceProvider,
    ILogger&lt;CategoriesCacheBackgroundService&gt; logger,
    IMemoryCache cache)
    : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        // Remove the cache every 1 hour
        while (!stoppingToken.IsCancellationRequested)
        {
            logger.LogInformation("Updating the cache in background service");
            using var scope = serviceProvider.CreateScope();
            var categoryService = scope.ServiceProvider.GetRequiredService&lt;ICategoryService&gt;();
            var categories = await categoryService.GetCategoriesAsync();
            cache.Remove(CacheKeys.Categories);
            cache.Set(CacheKeys.Categories, categories, TimeSpan.FromHours(1));
            await Task.Delay(TimeSpan.FromHours(1), stoppingToken);
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.753.1">In the preceding code, we use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">while</span></strong><span class="koboSpan" id="kobo.755.1"> loop to reset the cache entry every one hour. </span><span class="koboSpan" id="kobo.755.2">Note that you cannot inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">ICategoryService</span></strong><span class="koboSpan" id="kobo.757.1"> directly because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">BackgroundService</span></strong><span class="koboSpan" id="kobo.759.1"> class will be registered as a singleton service, but the </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">ICategoryService</span></strong><span class="koboSpan" id="kobo.761.1"> is registered as a scoped service. </span><span class="koboSpan" id="kobo.761.2">A singleton service cannot depend on a scoped service. </span><span class="koboSpan" id="kobo.761.3">To solve this problem, we need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">IServiceProvider</span></strong><span class="koboSpan" id="kobo.763.1"> interface to create a scope and get the </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">ICategoryService</span></strong><span class="koboSpan" id="kobo.765.1"> from </span><span class="No-Break"><span class="koboSpan" id="kobo.766.1">the scope.</span></span></p>
<p><span class="koboSpan" id="kobo.767.1">Then, register the </span><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">CacheBackgroundService</span></strong><span class="koboSpan" id="kobo.769.1"> class in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">Program</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.771.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.772.1">
builder.Services.AddHostedService&lt;CacheBackgroundService&gt;();</span></pre> <p><span class="koboSpan" id="kobo.773.1">When </span><a id="_idIndexMarker1706"/><span class="koboSpan" id="kobo.774.1">the </span><a id="_idIndexMarker1707"/><span class="koboSpan" id="kobo.775.1">background task is executed every one hour, the cache entry will be removed from the cache. </span><span class="koboSpan" id="kobo.775.2">The background task should first query the database and then remove the cache entry and reset it. </span><span class="koboSpan" id="kobo.775.3">If the cache entry is deleted first, the application may query the database multiple times, resulting in </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">performance issues.</span></span></p>
<p><span class="koboSpan" id="kobo.777.1">When implementing caching, it is important to consider scenarios where records cannot be found in the database. </span><span class="koboSpan" id="kobo.777.2">Let us see how it happens. </span><span class="koboSpan" id="kobo.777.3">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">GetCategoryAsync()</span></strong><span class="koboSpan" id="kobo.779.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.781.1">
public async Task&lt;Category?&gt; GetCategoryAsync(int id){
    if (cache.TryGetValue($"{CacheKeys.Categories}:{id}", out Category? </span><span class="koboSpan" id="kobo.781.2">category))
    {
        logger.LogInformation($"Getting category with id {id} from cache");
        return category;
    }
    // Simulate a database query
    logger.LogInformation($"Getting category with id {id} from the database");
    await Task.Delay(2000);
    var result = Categories.FirstOrDefault(c =&gt; c.Id == id);
    if (result is not null)
    {
        cache.Set($"{CacheKeys.Categories}:{id}", result);
    }
    return result;
}</span></pre>
<p><span class="koboSpan" id="kobo.782.1">In the </span><a id="_idIndexMarker1708"/><span class="koboSpan" id="kobo.783.1">preceding code, if the category cannot be found in the </span><a id="_idIndexMarker1709"/><span class="koboSpan" id="kobo.784.1">cache, we query the database and cache the category. </span><span class="koboSpan" id="kobo.784.2">But there is a potential issue here. </span><span class="koboSpan" id="kobo.784.3">What if the category with the specified ID does not exist? </span><span class="koboSpan" id="kobo.784.4">In this case, the application will not set the cache and each request will query the database. </span><span class="koboSpan" id="kobo.784.5">Cache is not used at all. </span><span class="koboSpan" id="kobo.784.6">To solve this problem, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">GetOrCreateAsync</span></strong><span class="koboSpan" id="kobo.786.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">IMemoryCache</span></strong><span class="koboSpan" id="kobo.788.1"> interface. </span><span class="koboSpan" id="kobo.788.2">Here is the </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">updated code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.790.1">
public async Task&lt;Category?&gt; GetCategoryAsync(int id){
    var category = await cache.GetOrCreateAsync($"{CacheKeys.Categories}:{id}", async entry =&gt;
    {
        // Simulate a database query
        logger.LogInformation($"Getting category with id {id} from the database");
        await Task.Delay(2000);
        return Categories.FirstOrDefault(c =&gt; c.Id == id);
    });
    return category;
}</span></pre>
<p><span class="koboSpan" id="kobo.791.1">The updated </span><a id="_idIndexMarker1710"/><span class="koboSpan" id="kobo.792.1">code uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">GetOrCreateAsync</span></strong><span class="koboSpan" id="kobo.794.1"> method to retrieve the category from the cache. </span><span class="koboSpan" id="kobo.794.2">If the category is not present, the method will </span><a id="_idIndexMarker1711"/><span class="koboSpan" id="kobo.795.1">execute the specified delegate to fetch it from the database. </span><span class="koboSpan" id="kobo.795.2">Upon successful retrieval, the category will be cached and returned. </span><span class="koboSpan" id="kobo.795.3">If the category is not found, </span><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">null</span></strong><span class="koboSpan" id="kobo.797.1"> will be returned. </span><span class="koboSpan" id="kobo.797.2">So, the application will not query the database every time. </span><span class="koboSpan" id="kobo.797.3">To avoid the issue mentioned earlier, it is recommended to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">GetOrCreateAsync</span></strong><span class="koboSpan" id="kobo.799.1"> method to obtain the data from </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">the cache.</span></span></p>
<p><span class="koboSpan" id="kobo.801.1">There are more important considerations when using </span><span class="No-Break"><span class="koboSpan" id="kobo.802.1">in-memory caching:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.803.1">Consider the expiration time of the cache entry</span></em><span class="koboSpan" id="kobo.804.1">. </span><span class="koboSpan" id="kobo.804.2">If the data is not often changed, we can set a longer expiration time. </span><span class="koboSpan" id="kobo.804.3">Otherwise, use a shorter expiration time. </span><span class="koboSpan" id="kobo.804.4">Also, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">SlidingExpiration</span></strong><span class="koboSpan" id="kobo.806.1"> property and the absolute expiration time to achieve a balance between the performance and the freshness of </span><span class="No-Break"><span class="koboSpan" id="kobo.807.1">the data.</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.808.1">The in-memory cache can cache any object, but be careful when caching large objects</span></em><span class="koboSpan" id="kobo.809.1">. </span><span class="koboSpan" id="kobo.809.2">It is important to limit the size of the cache entry. </span><span class="koboSpan" id="kobo.809.3">We can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">SetSize</span></strong><span class="koboSpan" id="kobo.811.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">Size</span></strong><span class="koboSpan" id="kobo.813.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">SizeLimit</span></strong><span class="koboSpan" id="kobo.815.1"> to limit the size of the cache. </span><span class="koboSpan" id="kobo.815.2">Note that when using these methods, the in-memory cache must be registered as a singleton service. </span><span class="koboSpan" id="kobo.815.3">Please refer to the documentation for more information </span><span class="No-Break"><span class="koboSpan" id="kobo.816.1">at </span></span><a href="https://learn.microsoft.com/en-us/aspnet/core/performance/caching/memory"><span class="No-Break"><span class="koboSpan" id="kobo.817.1">https://learn.microsoft.com/en-us/aspnet/core/performance/caching/memory</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.818.1">.</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.819.1">Define proper cache keys</span></em><span class="koboSpan" id="kobo.820.1">. </span><span class="koboSpan" id="kobo.820.2">The cache keys should be unique and descriptive. </span><span class="koboSpan" id="kobo.820.3">Especially, when using caching for users, ensure that the cache keys are unique for each user. </span><span class="koboSpan" id="kobo.820.4">Otherwise, the cached data of one user may be used by </span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">another user.</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.822.1">Provide a way to fall back to the data source when the cache is </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.823.1">not available</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.824.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.825.1">There are no hard rules for these settings. </span><span class="koboSpan" id="kobo.825.2">You need to consider the specific scenarios and adjust the </span><span class="No-Break"><span class="koboSpan" id="kobo.826.1">settings accordingly.</span></span></p>
<p><span class="koboSpan" id="kobo.827.1">In-memory caching </span><a id="_idIndexMarker1712"/><span class="koboSpan" id="kobo.828.1">is a simple and effective way to improve the performance</span><a id="_idIndexMarker1713"/><span class="koboSpan" id="kobo.829.1"> of the application. </span><span class="koboSpan" id="kobo.829.2">However, it is not suitable for applications that are deployed with multiple instances. </span><span class="koboSpan" id="kobo.829.3">The cached data only works for the current instance. </span><span class="koboSpan" id="kobo.829.4">When a client requests the data from another instance, the cached data in the original instance will not be used. </span><span class="koboSpan" id="kobo.829.5">To solve this problem, one solution is to implement session affinity, which means the request from a user will always be routed to the same instance. </span><span class="koboSpan" id="kobo.829.6">This can be achieved by using a load balancer that supports session affinity, such as Nginx, Azure Application Gateway, and so on. </span><span class="koboSpan" id="kobo.829.7">This is out of the scope of this book. </span><span class="koboSpan" id="kobo.829.8">Please refer to the documentation of the load balancer for </span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">more information.</span></span></p>
<p><span class="koboSpan" id="kobo.831.1">Another approach to this issue is to implement a d</span><a id="_idTextAnchor653"/><span class="koboSpan" id="kobo.832.1">istributed cache, as outlined in the </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">following section.</span></span></p>
<h2 id="_idParaDest-344"><a id="_idTextAnchor654"/><span class="koboSpan" id="kobo.834.1">Distributed caching</span></h2>
<p><span class="koboSpan" id="kobo.835.1">Distributed caching offloads</span><a id="_idIndexMarker1714"/><span class="koboSpan" id="kobo.836.1"> the cache from the application to a shared storage, such as Redis or SQL Server. </span><span class="koboSpan" id="kobo.836.2">The data stored in the distributed cache can be accessed by multiple instances of the application. </span><span class="koboSpan" id="kobo.836.3">If the application restarts, the cached data will not be lost. </span><span class="koboSpan" id="kobo.836.4">There is no need to implement session affinity when using </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">distributed caching.</span></span></p>
<p><span class="koboSpan" id="kobo.838.1">There are several</span><a id="_idIndexMarker1715"/><span class="koboSpan" id="kobo.839.1"> options to implement distributed </span><a id="_idIndexMarker1716"/><span class="koboSpan" id="kobo.840.1">caching in ASP.NET Core. </span><span class="koboSpan" id="kobo.840.2">The following are the most commonly </span><span class="No-Break"><span class="koboSpan" id="kobo.841.1">used options:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.842.1">Redis</span></strong><span class="koboSpan" id="kobo.843.1">: Redis is an</span><a id="_idIndexMarker1717"/><span class="koboSpan" id="kobo.844.1"> open-source, in-memory data structure store. </span><span class="koboSpan" id="kobo.844.2">It has many features, such as caching, pub/sub, and </span><span class="No-Break"><span class="koboSpan" id="kobo.845.1">so on.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.846.1">SQL Server</span></strong><span class="koboSpan" id="kobo.847.1">: SQL Server</span><a id="_idIndexMarker1718"/><span class="koboSpan" id="kobo.848.1"> can be also used as a </span><span class="No-Break"><span class="koboSpan" id="kobo.849.1">distributed cache.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.850.1">Azure Cache for Redis</span></strong><span class="koboSpan" id="kobo.851.1">: Azure Cache</span><a id="_idIndexMarker1719"/><span class="koboSpan" id="kobo.852.1"> for Redis is a fully managed, open-source, in-memory data structure store. </span><span class="koboSpan" id="kobo.852.2">It is based on the popular open-source Redis cache. </span><span class="koboSpan" id="kobo.852.3">You can use a local Redis server for development and testing and use Azure Cache for Redis </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">in production.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.854.1">NCache</span></strong><span class="koboSpan" id="kobo.855.1">: NCache</span><a id="_idIndexMarker1720"/><span class="koboSpan" id="kobo.856.1"> is an open-source distributed cache for .NET applications. </span><span class="No-Break"><span class="koboSpan" id="kobo.857.1">See </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">https://github.com/Alachisoft/NCache</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.859.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.860.1">In this section, we </span><a id="_idIndexMarker1721"/><span class="koboSpan" id="kobo.861.1">will introduce the Redis cache using the same sample project as the previous section. </span><span class="koboSpan" id="kobo.861.2">We use a static </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">Dictionary&lt;int, List&lt;Category&gt;&gt;</span></strong><span class="koboSpan" id="kobo.863.1"> to store the users’ favorites categories, which simulates</span><a id="_idIndexMarker1722"/><span class="koboSpan" id="kobo.864.1"> the data stored in the database. </span><span class="koboSpan" id="kobo.864.2">When a user requests the favorites categories, the application will use the user ID as the key to query the database. </span><span class="koboSpan" id="kobo.864.3">If we use in-memory caching, the caching key should include the user ID, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">1_Favorites_Categories</span></strong><span class="koboSpan" id="kobo.866.1">. </span><span class="koboSpan" id="kobo.866.2">However, if this user’s subsequent requests are routed to another instance, there is no way to get the cached data. </span><span class="koboSpan" id="kobo.866.3">That is why we need to use the </span><span class="No-Break"><span class="koboSpan" id="kobo.867.1">distributed caching.</span></span></p>
<p><span class="koboSpan" id="kobo.868.1">First, we need to prepare a Redis server. </span><span class="koboSpan" id="kobo.868.2">We can use the Docker to run a Redis server. </span><span class="koboSpan" id="kobo.868.3">Start Docker Desktop on your machine and run the following command to pull the </span><span class="No-Break"><span class="koboSpan" id="kobo.869.1">Redis image:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.870.1">
docker pull redis</span></pre> <p><span class="koboSpan" id="kobo.871.1">Then, run the </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">Redis server:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.873.1">
docker run --name redis -p 6379:6379 -d redis</span></pre> <p><span class="koboSpan" id="kobo.874.1">The Redis server will be listening on </span><span class="No-Break"><span class="koboSpan" id="kobo.875.1">port </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">6379</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.878.1">To access the Redis server in the terminal, we need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">redis-cli</span></strong><span class="koboSpan" id="kobo.880.1"> command. </span><span class="koboSpan" id="kobo.880.2">This command is included in the Redis image. </span><span class="koboSpan" id="kobo.880.3">Run the following command to access the </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">Redis server:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.882.1">
docker exec -it redis redis-cli</span></pre> <p><span class="koboSpan" id="kobo.883.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.884.1">docker exec</span></strong><span class="koboSpan" id="kobo.885.1"> command is used to execute a command in a running container. </span><span class="koboSpan" id="kobo.885.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">-it</span></strong><span class="koboSpan" id="kobo.887.1"> option is used to run the command interactively. </span><span class="koboSpan" id="kobo.887.2">It means we want to execute the </span><strong class="source-inline"><span class="koboSpan" id="kobo.888.1">redis-cli</span></strong><span class="koboSpan" id="kobo.889.1"> command in the container. </span><span class="koboSpan" id="kobo.889.2">You will see the </span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.891.1">
127.0.0.1:6379&gt;</span></pre> <p><span class="koboSpan" id="kobo.892.1">This means we have successfully accessed the Redis server. </span><span class="koboSpan" id="kobo.892.2">Now we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">redis-cli</span></strong><span class="koboSpan" id="kobo.894.1"> command to access the Redis server. </span><span class="koboSpan" id="kobo.894.2">For example, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">set</span></strong><span class="koboSpan" id="kobo.896.1"> command to set the value of </span><span class="No-Break"><span class="koboSpan" id="kobo.897.1">a key:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.898.1">
set my-key "Hello World"</span></pre> <p><span class="koboSpan" id="kobo.899.1">Then, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">get</span></strong><span class="koboSpan" id="kobo.901.1"> command to get the value of </span><span class="No-Break"><span class="koboSpan" id="kobo.902.1">the key:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.903.1">
get my-key</span></pre> <p><span class="koboSpan" id="kobo.904.1">You will see </span><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">Hello World</span></strong><span class="koboSpan" id="kobo.906.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.907.1">the output.</span></span></p>
<p><span class="koboSpan" id="kobo.908.1">Now</span><a id="_idIndexMarker1723"/><span class="koboSpan" id="kobo.909.1"> the </span><a id="_idIndexMarker1724"/><span class="koboSpan" id="kobo.910.1">Redis server is ready to use. </span><span class="koboSpan" id="kobo.910.2">To use the Redis cache in ASP.NET Core, we need to install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">Microsoft.Extensions.Caching.StackExchangeRedis</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.912.1">NuGet package:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.913.1">
dotnet add package Microsoft.Extensions.Caching.StackExchangeRedis</span></pre> <p><span class="koboSpan" id="kobo.914.1">Then, we need to register the Redis cache in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">Program</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.916.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.917.1">
builder.Services.AddStackExchangeRedisCache(options =&gt;    options.Configuration = "localhost:6379";    options.InstanceName = "CachingDemo";
});</span></pre>
<p><span class="koboSpan" id="kobo.918.1">In the preceding code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">AddStackExchangeRedisCache</span></strong><span class="koboSpan" id="kobo.920.1"> extension method is used to register the Redis cache. </span><span class="koboSpan" id="kobo.920.2">We specify the Redis server address and an optional instance name, which is used to create a logical partition for the cache. </span><span class="koboSpan" id="kobo.920.3">Note that these configurations can be defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.921.1">appsettings.json</span></strong><span class="koboSpan" id="kobo.922.1"> file or environment variables, allowing for different Redis instances to be used for development and </span><span class="No-Break"><span class="koboSpan" id="kobo.923.1">production purposes.</span></span></p>
<p><span class="koboSpan" id="kobo.924.1">Next, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">IDistributedCache</span></strong><span class="koboSpan" id="kobo.926.1"> interface to operate the Redis cache. </span><span class="koboSpan" id="kobo.926.2">Inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.927.1">IDistributedCache</span></strong><span class="koboSpan" id="kobo.928.1"> interface into the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">CategoryService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.930.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.931.1">
public class CategoryService(ILogger&lt;CategoryService&gt; logger, IMemoryCache cache, IDistributedCache distributedCache) : ICategoryService{
    // Omitted for brevity
}
// Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">GetFavoritesCategoriesAsync()</span></strong><span class="koboSpan" id="kobo.933.1"> method as follows:
public async Task&lt;IEnumerable&lt;Category&gt;&gt; GetFavoritesCategoriesAsync(int userId)
{
    // Try to get the categories from the cache
    var cacheKey = $"{CacheKeys.FavoritesCategories}:{userId}";
    var bytes = await distributedCache.GetAsync(cacheKey);
    if (bytes is { Length: &gt; 0 })
    {
        logger.LogInformation("Getting favorites categories from distributed cache");
        var serializedFavoritesCategories = Encoding.UTF8.GetString(bytes);
        var favoritesCategories = JsonSerializer.Deserialize&lt;IEnumerable&lt;Category&gt;&gt;(serializedFavoritesCategories);
        return favoritesCategories ?? </span><span class="koboSpan" id="kobo.933.2">new List&lt;Category&gt;();
    }
    // Simulate a database query
    logger.LogInformation("Getting favorites categories from the database");
    var categories = FavoritesCategories[userId];
    // Store the result in the distributed cache
    var cacheEntryOptions = new DistributedCacheEntryOptions
    {
        SlidingExpiration = TimeSpan.FromMinutes(10),
        AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(30)
    };
    var serializedCategories = JsonSerializer.Serialize(categories);
    var serializedCategoriesBytes = Encoding.UTF8.GetBytes(serializedCategories);
    await distributedCache.SetAsync(cacheKey, serializedCategoriesBytes, cacheEntryOptions);
    await Task.Delay(2000);
    return FavoritesCategories[userId].AsEnumerable();
}</span></pre>
<p><span class="koboSpan" id="kobo.934.1">In the </span><a id="_idIndexMarker1725"/><span class="koboSpan" id="kobo.935.1">preceding code, we</span><a id="_idIndexMarker1726"/><span class="koboSpan" id="kobo.936.1"> first try to get the favorites categories from the cache using the cache key. </span><span class="koboSpan" id="kobo.936.2">If the favorites categories are found in the distributed cache, we return the cached data directly. </span><span class="koboSpan" id="kobo.936.3">Otherwise, we query the database and store the result in the </span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">distributed cache.</span></span></p>
<p><span class="koboSpan" id="kobo.938.1">As the Redis cache stores the data as </span><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">byte[]</span></strong><span class="koboSpan" id="kobo.940.1">, to store the cached data, we need to serialize the data into a JSON string and then convert the JSON string into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.941.1">byte[]</span></strong><span class="koboSpan" id="kobo.942.1"> value using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">Encoding.UTF8.GetBytes()</span></strong><span class="koboSpan" id="kobo.944.1"> method. </span><span class="koboSpan" id="kobo.944.2">Similarly, when getting the cached data, we need to convert the </span><strong class="source-inline"><span class="koboSpan" id="kobo.945.1">byte[]</span></strong><span class="koboSpan" id="kobo.946.1"> value to a JSON string using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">Encoding.UTF8.GetString()</span></strong><span class="koboSpan" id="kobo.948.1"> method and then deserialize the JSON string into the strongly-typed object using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.949.1">JsonSerializer.Deserialize()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.950.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.951.1">In addition, the caching key must be a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">string</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.953.1"> value.</span></span></p>
<p><span class="koboSpan" id="kobo.954.1">To make it easier to convert the data to and from </span><strong class="source-inline"><span class="koboSpan" id="kobo.955.1">byte[]</span></strong><span class="koboSpan" id="kobo.956.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">IDistributedCache</span></strong><span class="koboSpan" id="kobo.958.1"> interface has a few extension methods </span><span class="No-Break"><span class="koboSpan" id="kobo.959.1">as follows:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.960.1">SetStringAsync</span></strong><span class="koboSpan" id="kobo.961.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">SetString</span></strong><span class="koboSpan" id="kobo.963.1">: These two methods can save </span><strong class="source-inline"><span class="koboSpan" id="kobo.964.1">string</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.965.1">values directly</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">GetStringAsync</span></strong><span class="koboSpan" id="kobo.967.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.968.1">GetString</span></strong><span class="koboSpan" id="kobo.969.1">: These two methods can read </span><strong class="source-inline"><span class="koboSpan" id="kobo.970.1">string</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.971.1">values directly</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.972.1">To remove a cache entry, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.973.1">RemoveAsync()</span></strong><span class="koboSpan" id="kobo.974.1"> method or </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">Remove()</span></strong><span class="koboSpan" id="kobo.976.1"> method. </span><span class="koboSpan" id="kobo.976.2">As we mentioned before, using the asynchronous versions of these methods </span><span class="No-Break"><span class="koboSpan" id="kobo.977.1">is preferred.</span></span></p>
<p><span class="koboSpan" id="kobo.978.1">Run the</span><a id="_idIndexMarker1727"/><span class="koboSpan" id="kobo.979.1"> application </span><a id="_idIndexMarker1728"/><span class="koboSpan" id="kobo.980.1">and send some requests to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.981.1">Categories/favorites/1</span></strong><span class="koboSpan" id="kobo.982.1"> endpoint. </span><span class="koboSpan" id="kobo.982.2">You will see that the logs show the first response was from the database and the subsequent responses were from the </span><span class="No-Break"><span class="koboSpan" id="kobo.983.1">distributed cache:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.984.1">
info: CachingDemo.Services.CategoryService[0]      Getting favorites categories from the database
info: CachingDemo.Services.CategoryService[0]
      Getting favorites categories from distributed cache</span></pre>
<p><span class="koboSpan" id="kobo.985.1">You can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.986.1">redis-cli</span></strong><span class="koboSpan" id="kobo.987.1"> to examine the cached data. </span><span class="koboSpan" id="kobo.987.2">Run the following command to get </span><span class="No-Break"><span class="koboSpan" id="kobo.988.1">the keys:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.989.1">
127.0.0.1:6379&gt; keys *</span></pre> <p><span class="koboSpan" id="kobo.990.1">The output should look </span><span class="No-Break"><span class="koboSpan" id="kobo.991.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.992.1">
1) "CachingDemo_FavoritesCategories:1"</span></pre> <p><span class="koboSpan" id="kobo.993.1">Then, use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.994.1">HGETALL</span></strong><span class="koboSpan" id="kobo.995.1"> command to show the </span><span class="No-Break"><span class="koboSpan" id="kobo.996.1">cached data:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.997.1">
127.0.0.1:6379&gt; hgetall CachingDemo_FavoritesCategories:1</span></pre> <p><span class="koboSpan" id="kobo.998.1">Note that you cannot use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.999.1">GET</span></strong><span class="koboSpan" id="kobo.1000.1"> command here because it is used to retrieve the string values only. </span><span class="koboSpan" id="kobo.1000.2">The categories data is stored as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1001.1">hash</span></strong><span class="koboSpan" id="kobo.1002.1"> in Redis, so we need to use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1003.1">HGETALL</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1004.1"> command.</span></span></p>
<p><span class="koboSpan" id="kobo.1005.1">The output should look as follows, including all the fields of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1006.1">cached entry:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1007.1">
1) "absexp"2) "638322378838137428"
3) "sldexp"
4) "6000000000"
5) "data"
6) " [{\"Id\":1,\"Name\":\"Toys\",\"Description\":\"Soft toys, action figures, dolls, and puzzles\"},{\"Id\":2,\"Name\":\"Electronics\",\"Description\":\"Smartphones, tablets, laptops, and smartwatches\"},{\"Id\":3,\"Name\":\"Clothing\",\"Description\":\"Shirts, pants, dresses, and shoes\"}]"</span></pre>
<p><span class="koboSpan" id="kobo.1008.1">Using a</span><a id="_idIndexMarker1729"/><span class="koboSpan" id="kobo.1009.1"> distributed cache </span><a id="_idIndexMarker1730"/><span class="koboSpan" id="kobo.1010.1">can help make applications more scalable by allowing cached data to be shared across multiple instances. </span><span class="koboSpan" id="kobo.1010.2">However, this does come with the potential cost of increased latency due to the extra network I/O required. </span><span class="koboSpan" id="kobo.1010.3">Careful consideration should be taken when deciding whether to use a </span><span class="No-Break"><span class="koboSpan" id="kobo.1011.1">distributed cache.</span></span></p>
<p><span class="koboSpan" id="kobo.1012.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1013.1">IDistributedCache</span></strong><span class="koboSpan" id="kobo.1014.1"> interface does not have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1015.1">GetOrCreateAsync()</span></strong><span class="koboSpan" id="kobo.1016.1"> method. </span><span class="koboSpan" id="kobo.1016.2">If the cached data is not found, the application still needs to query the database. </span><span class="koboSpan" id="kobo.1016.3">To solve this problem, we can implement our own </span><strong class="source-inline"><span class="koboSpan" id="kobo.1017.1">GetOrCreateAsync()</span></strong><span class="koboSpan" id="kobo.1018.1"> method. </span><span class="koboSpan" id="kobo.1018.2">Create an extension method for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1019.1">IDistributedCache</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1020.1"> interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1021.1">
public static class DistributedCacheExtension{
    public static async Task&lt;T?&gt; GetOrCreateAsync&lt;T&gt;(this IDistributedCache cache, string key, Func&lt;Task&lt;T?&gt;&gt; createAsync, DistributedCacheEntryOptions? </span><span class="koboSpan" id="kobo.1021.2">options = null)
    {
        // Get the value from the cache.
</span><span class="koboSpan" id="kobo.1021.3">        // If the value is found, return it.
</span><span class="koboSpan" id="kobo.1021.4">        var value = await cache.GetStringAsync(key);
        if (!string.IsNullOrWhiteSpace(value))
        {
            return JsonSerializer.Deserialize&lt;T&gt;(value);
        }
        // If the value is not cached, then create it using the provided function.
</span><span class="koboSpan" id="kobo.1021.5">        var result = await createAsync();
        var json = JsonSerializer.Serialize(result);
        await cache.SetStringAsync(key, json, options ?? </span><span class="koboSpan" id="kobo.1021.6">new DistributedCacheEntryOptions());
        return result;
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1022.1">Now</span><a id="_idIndexMarker1731"/><span class="koboSpan" id="kobo.1023.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">GetFavoritesCategoriesAsync</span></strong><span class="koboSpan" id="kobo.1025.1"> method can be</span><a id="_idIndexMarker1732"/><span class="koboSpan" id="kobo.1026.1"> updated </span><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1028.1">
public async Task&lt;IEnumerable&lt;Category&gt;?&gt; GetFavoritesCategoriesAsync(int userId){
    var cacheKey = $"{CacheKeys.FavoritesCategories}:{userId}";
    var cacheEntryOptions = new DistributedCacheEntryOptions
    {
        SlidingExpiration = TimeSpan.FromMinutes(10),
        AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(30)
    };
    var favoritesCategories = await distributedCache.GetOrCreateAsync(cacheKey, async () =&gt;
    {
        // Simulate a database query
        logger.LogInformation("Getting favorites categories from the database");
        var categories = FavoritesCategories[userId];
        await Task.Delay(2000);
        return categories;
    }, cacheEntryOptions);
    return favoritesCategories?.AsEnumerable();
}</span></pre>
<p><span class="koboSpan" id="kobo.1029.1">If the </span><a id="_idIndexMarker1733"/><span class="koboSpan" id="kobo.1030.1">category is </span><a id="_idIndexMarker1734"/><span class="koboSpan" id="kobo.1031.1">not found in the database, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1032.1">GetOrCreateAsync()</span></strong><span class="koboSpan" id="kobo.1033.1"> method will return </span><strong class="source-inline"><span class="koboSpan" id="kobo.1034.1">null</span></strong><span class="koboSpan" id="kobo.1035.1"> and cache the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1036.1">null</span></strong><span class="koboSpan" id="kobo.1037.1"> value for future requests. </span><span class="koboSpan" id="kobo.1037.2">In this way, the application will not query the database again </span><span class="No-Break"><span class="koboSpan" id="kobo.1038.1">and again.</span></span></p>
<p><span class="koboSpan" id="kobo.1039.1">The following table shows the differences between in-memory caching and </span><span class="No-Break"><span class="koboSpan" id="kobo.1040.1">distributed caching:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-8">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1041.1">In-memory caching</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1042.1">Distributed caching</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1043.1">Cache data in the memory of </span><span class="No-Break"><span class="koboSpan" id="kobo.1044.1">the application</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1045.1">Cache data in a </span><span class="No-Break"><span class="koboSpan" id="kobo.1046.1">shared storage</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1047.1">Suitable for applications that are deployed with a </span><span class="No-Break"><span class="koboSpan" id="kobo.1048.1">single instance</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1049.1">Suitable for applications that are deployed with </span><span class="No-Break"><span class="koboSpan" id="kobo.1050.1">multiple instances</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1051.1">The cached data is lost when the </span><span class="No-Break"><span class="koboSpan" id="kobo.1052.1">application restarts</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1053.1">The cached data is not lost when the </span><span class="No-Break"><span class="koboSpan" id="kobo.1054.1">application restarts</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1055.1">The caching keys can be </span><span class="No-Break"><span class="koboSpan" id="kobo.1056.1">any </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1057.1">object</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1058.1">The caching keys must </span><span class="No-Break"><span class="koboSpan" id="kobo.1059.1">be </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1060.1">string</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1061.1">The cached data value can be any </span><span class="No-Break"><span class="koboSpan" id="kobo.1062.1">strongly-typed object</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1063.1">The cached data is persisted as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1064.1">byte[]</span></strong><span class="koboSpan" id="kobo.1065.1"> and may need serialization </span><span class="No-Break"><span class="koboSpan" id="kobo.1066.1">and deserialization.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1067.1">Table 15.2 – The differences between in-memory caching and distributed caching</span></p>
<p><span class="koboSpan" id="kobo.1068.1">If you would like to</span><a id="_idIndexMarker1735"/><span class="koboSpan" id="kobo.1069.1"> use other distributed cache, you can install other packages such </span><a id="_idIndexMarker1736"/><span class="koboSpan" id="kobo.1070.1">as </span><span class="No-Break"><span class="koboSpan" id="kobo.1071.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1072.1">SqlServer</span></strong><span class="koboSpan" id="kobo.1073.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1074.1">dotnet add </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1075.1">package Microsoft.Extensions.Caching.SqlServer</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1076.1">NCache</span></strong><span class="koboSpan" id="kobo.1077.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1078.1">dotnet add </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1079.1">package NCache.Microsoft.Extensions.Caching.OpenSource</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1080.1">Please refer to their official documentation for </span><span class="No-Break"><span class="koboSpan" id="kobo.1081.1">more details</span><a id="_idTextAnchor655"/><span class="koboSpan" id="kobo.1082.1">.</span></span></p>
<h2 id="_idParaDest-345"><a id="_idTextAnchor656"/><span class="koboSpan" id="kobo.1083.1">Response caching</span></h2>
<p><span class="koboSpan" id="kobo.1084.1">Response caching</span><a id="_idIndexMarker1737"/><span class="koboSpan" id="kobo.1085.1"> is defined in the RFC 9111 specification (</span><a href="https://www.rfc-editor.org/rfc/rfc9111"><span class="koboSpan" id="kobo.1086.1">https://www.rfc-editor.org/rfc/rfc9111</span></a><span class="koboSpan" id="kobo.1087.1">). </span><span class="koboSpan" id="kobo.1087.2">It uses the HTTP header </span><strong class="source-inline"><span class="koboSpan" id="kobo.1088.1">cache-control</span></strong><span class="koboSpan" id="kobo.1089.1"> to specify the caching </span><a id="_idIndexMarker1738"/><span class="koboSpan" id="kobo.1090.1">behavior. </span><span class="koboSpan" id="kobo.1090.2">The clients (such as browsers) and immediate proxies (such as CDNs and gateways), can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1091.1">cache-control</span></strong><span class="koboSpan" id="kobo.1092.1"> header to determine whether to cache the response and how long to cache </span><span class="No-Break"><span class="koboSpan" id="kobo.1093.1">it for.</span></span></p>
<p><span class="koboSpan" id="kobo.1094.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1095.1">cache-control</span></strong><span class="koboSpan" id="kobo.1096.1"> header</span><a id="_idIndexMarker1739"/><span class="koboSpan" id="kobo.1097.1"> has several directives </span><span class="No-Break"><span class="koboSpan" id="kobo.1098.1">as</span></span><span class="No-Break"><a id="_idIndexMarker1740"/></span><span class="No-Break"><span class="koboSpan" id="kobo.1099.1"> follows:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1100.1">public</span></strong><span class="koboSpan" id="kobo.1101.1">: The response can be cached by the clients and the </span><span class="No-Break"><span class="koboSpan" id="kobo.1102.1">intermediate proxies.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1103.1">private</span></strong><span class="koboSpan" id="kobo.1104.1">: The response can be cached by the clients only. </span><span class="koboSpan" id="kobo.1104.2">A shared cache, such as CDN, must not cache </span><span class="No-Break"><span class="koboSpan" id="kobo.1105.1">the response.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1106.1">no-cache</span></strong><span class="koboSpan" id="kobo.1107.1">: For</span><a id="_idIndexMarker1741"/><span class="koboSpan" id="kobo.1108.1"> requests, the clients must send the request to the server for validation before using a cached copy of the response. </span><span class="koboSpan" id="kobo.1108.2">For responses, the clients must not use a cached copy of the response without successful validation on </span><span class="No-Break"><span class="koboSpan" id="kobo.1109.1">the server.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1110.1">no-store</span></strong><span class="koboSpan" id="kobo.1111.1">: For requests, the clients must not store any part of the request. </span><span class="koboSpan" id="kobo.1111.2">For responses, the clients must not store any part of </span><span class="No-Break"><span class="koboSpan" id="kobo.1112.1">the response.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1113.1">max-age</span></strong><span class="koboSpan" id="kobo.1114.1">: This is the maximum age of the response in seconds. </span><span class="koboSpan" id="kobo.1114.2">The clients can use the cached copy of the response if it is not expired. </span><span class="koboSpan" id="kobo.1114.3">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1115.1">max-age=3600</span></strong><span class="koboSpan" id="kobo.1116.1"> means the response can be cached for </span><span class="No-Break"><span class="koboSpan" id="kobo.1117.1">one hour.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1118.1">We</span><a id="_idIndexMarker1742"/><span class="koboSpan" id="kobo.1119.1"> can </span><a id="_idIndexMarker1743"/><span class="koboSpan" id="kobo.1120.1">use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1121.1">ResponseCache</span></strong><span class="koboSpan" id="kobo.1122.1"> attribute to specify the caching behavior of the endpoint. </span><span class="koboSpan" id="kobo.1122.2">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.1123.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1124.1">
[HttpGet][ResponseCache(Duration = 60)]
public async Task&lt;ActionResult&lt;IEnumerable&lt;Category&gt;&gt;&gt; Get()
{
    var result = await categoryService.GetCategoriesAsync();
    return Ok(result);
}</span></pre>
<p><span class="koboSpan" id="kobo.1125.1">In the preceding code, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1126.1">ResponseCache</span></strong><span class="koboSpan" id="kobo.1127.1"> attribute on the controller to specify the caching behavior of the endpoint. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1128.1">Duration = 60</span></strong><span class="koboSpan" id="kobo.1129.1"> means the response can be cached for </span><span class="No-Break"><span class="koboSpan" id="kobo.1130.1">60 seconds.</span></span></p>
<p><span class="koboSpan" id="kobo.1131.1">Run the application and test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1132.1">/Categories</span></strong><span class="koboSpan" id="kobo.1133.1"> endpoint in the Swagger UI. </span><span class="koboSpan" id="kobo.1133.2">You will see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1134.1">cache-control</span></strong><span class="koboSpan" id="kobo.1135.1"> header in the response, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1136.1">shown here:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1137.1">
cache-control: public,max-age=60content-type: application/json; charset=utf-8
date: Sat,07 Oct 2023 03:56:06 GMT
server: Kestrel</span></pre>
<p><span class="koboSpan" id="kobo.1138.1">If you </span><a id="_idIndexMarker1744"/><span class="koboSpan" id="kobo.1139.1">resubmit the request, the browser will use the cached </span><a id="_idIndexMarker1745"/><span class="koboSpan" id="kobo.1140.1">version of the response without sending the request to the server. </span><span class="koboSpan" id="kobo.1140.2">This is managed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1141.1">max-age</span></strong><span class="koboSpan" id="kobo.1142.1"> directive in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1143.1">cache-control</span></strong><span class="koboSpan" id="kobo.1144.1"> header. </span><span class="koboSpan" id="kobo.1144.2">After 60 seconds have elapsed, the browser will send the request to the server for validation if the request </span><span class="No-Break"><span class="koboSpan" id="kobo.1145.1">is resubmitted.</span></span></p>
<p><span class="koboSpan" id="kobo.1146.1">The HTTP-based response caching takes effect on the client side. </span><span class="koboSpan" id="kobo.1146.2">If multiple clients send requests to the same endpoint, each request will cause the server to handle the request and generate the response. </span><span class="koboSpan" id="kobo.1146.3">ASP.NET Core provides a server-side response caching middleware to cache the response on the server side. </span><span class="koboSpan" id="kobo.1146.4">However, this middleware has a </span><span class="No-Break"><span class="koboSpan" id="kobo.1147.1">few limitations.</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1148.1">It only supports the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1149.1">GET</span></strong><span class="koboSpan" id="kobo.1150.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1151.1">HEAD</span></strong><span class="koboSpan" id="kobo.1152.1"> requests and it does not support requests that contain the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1153.1">Authorization</span></strong><span class="koboSpan" id="kobo.1154.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1155.1">Set-Cookie</span></strong><span class="koboSpan" id="kobo.1156.1"> headers, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1157.1">so on.</span></span></li>
<li><span class="koboSpan" id="kobo.1158.1">You cannot invalidate the client-side cached response on the server side when the data </span><span class="No-Break"><span class="koboSpan" id="kobo.1159.1">is changed.</span></span></li>
<li><span class="koboSpan" id="kobo.1160.1">Additionally, most browsers, such as Chrome and Edge, automatically send requests with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1161.1">cache-control: max-age=0</span></strong><span class="koboSpan" id="kobo.1162.1"> header, which disables response caching on the client side. </span><span class="koboSpan" id="kobo.1162.2">As a result, the server will also respect this header and disable server-side </span><span class="No-Break"><span class="koboSpan" id="kobo.1163.1">response caching.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1164.1">This book does not cover the middleware mentioned; for more information, please refer to the documentation at </span><a href="https://learn.microsoft.com/en-us/aspnet/core/performance/caching/middleware"><span class="koboSpan" id="kobo.1165.1">https://learn.microsoft.com/en-us/aspnet/core/performance/caching/middleware</span></a><span class="koboSpan" id="kobo.1166.1">. </span><span class="koboSpan" id="kobo.1166.2">We will, however, introduce output caching, which is available in ASP.NET Core 7.0 and later versions. </span><span class="koboSpan" id="kobo.1166.3">This middleware resolves some of the limitations of the server-side response </span><span class="No-Break"><span class="koboSpan" id="kobo.1167.1">caching m</span><a id="_idTextAnchor657"/><span class="koboSpan" id="kobo.1168.1">iddleware.</span></span></p>
<h2 id="_idParaDest-346"><a id="_idTextAnchor658"/><span class="koboSpan" id="kobo.1169.1">Output caching</span></h2>
<p><span class="koboSpan" id="kobo.1170.1">In ASP.NET Core 7.0, Microsoft introduced the output caching middleware. </span><span class="koboSpan" id="kobo.1170.2">This middleware works in a </span><a id="_idIndexMarker1746"/><span class="koboSpan" id="kobo.1171.1">similar way to the server-side response caching</span><a id="_idIndexMarker1747"/><span class="koboSpan" id="kobo.1172.1"> middleware, but it has</span><a id="_idIndexMarker1748"/><span class="koboSpan" id="kobo.1173.1"> a </span><span class="No-Break"><span class="koboSpan" id="kobo.1174.1">few advantages:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1175.1">It configures the caching behavior on the server side, so the client HTTP caching configuration does not affect the output </span><span class="No-Break"><span class="koboSpan" id="kobo.1176.1">caching configuration.</span></span></li>
<li><span class="koboSpan" id="kobo.1177.1">It has the capability to invalidate the cached response on the server side when the data </span><span class="No-Break"><span class="koboSpan" id="kobo.1178.1">is changed.</span></span></li>
<li><span class="koboSpan" id="kobo.1179.1">It can use external cache stores, such as Redis, to store the </span><span class="No-Break"><span class="koboSpan" id="kobo.1180.1">cached response.</span></span></li>
<li><span class="koboSpan" id="kobo.1181.1">It can return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1182.1">304 Not Modified</span></strong><span class="koboSpan" id="kobo.1183.1"> response to the client when the cached response is not modified. </span><span class="koboSpan" id="kobo.1183.2">This can save the </span><span class="No-Break"><span class="koboSpan" id="kobo.1184.1">network bandwidth.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1185.1">However, the output caching middleware</span><a id="_idIndexMarker1749"/><span class="koboSpan" id="kobo.1186.1"> also has similar limitations to the response </span><span class="No-Break"><span class="koboSpan" id="kobo.1187.1">caching middleware:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1188.1">It only supports </span><strong class="source-inline"><span class="koboSpan" id="kobo.1189.1">GET</span></strong><span class="koboSpan" id="kobo.1190.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1191.1">HEAD</span></strong><span class="koboSpan" id="kobo.1192.1"> requests with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1193.1">200 OK</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1194.1">status code</span></span></li>
<li><span class="koboSpan" id="kobo.1195.1">It does not support </span><strong class="source-inline"><span class="koboSpan" id="kobo.1196.1">Authorization</span></strong><span class="koboSpan" id="kobo.1197.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1198.1">Set-Cookie</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1199.1"> headers</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1200.1">To enable output caching, we need to register the output caching middleware in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1201.1">Program</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1202.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1203.1">
builder.Services.AddOutputCache(options =&gt;{
    options.AddBasePolicy(x =&gt; x.Cache());
});</span></pre>
<p><span class="koboSpan" id="kobo.1204.1">Then, we need to add the middleware to the HTTP </span><span class="No-Break"><span class="koboSpan" id="kobo.1205.1">request pipeline:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1206.1">
app.UseOutputCache();</span></pre> <p><span class="koboSpan" id="kobo.1207.1">Next, apply the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1208.1">OutputCache</span></strong><span class="koboSpan" id="kobo.1209.1"> attribute to the endpoints that need to be cached. </span><span class="koboSpan" id="kobo.1209.2">For example, we can apply the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1210.1">OutputCache</span></strong><span class="koboSpan" id="kobo.1211.1"> attribute to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1212.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1213.1">categories/{id}</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1214.1"> endpoint:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1215.1">
[HttpGet("{id}")][OutputCache]
public async Task&lt;ActionResult&lt;Category?&gt;&gt; Get(int id)
{
    var result = await categoryService.GetCategoryAsync(id);
    if (result is null)
    {
        return NotFound();
    }
    return Ok(result);
}</span></pre>
<p><span class="koboSpan" id="kobo.1216.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1217.1">GetOrCreateAsync()</span></strong><span class="koboSpan" id="kobo.1218.1"> method is shown </span><span class="No-Break"><span class="koboSpan" id="kobo.1219.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1220.1">
public async Task&lt;Category?&gt; GetCategoryAsync(int id){
    // Simulate a database query
    logger.LogInformation($"Getting category with id {id} from the database");
    await Task.Delay(2000);
    return Categories.FirstOrDefault(c =&gt; c.Id == id);
}</span></pre>
<p><span class="koboSpan" id="kobo.1221.1">Similarly, we</span><a id="_idIndexMarker1750"/><span class="koboSpan" id="kobo.1222.1"> use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1223.1">Task.Delay()</span></strong><span class="koboSpan" id="kobo.1224.1"> method to simulate the</span><a id="_idIndexMarker1751"/><span class="koboSpan" id="kobo.1225.1"> database query. </span><span class="koboSpan" id="kobo.1225.2">Run the application and test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1226.1">/categories/1</span></strong><span class="koboSpan" id="kobo.1227.1"> endpoint in the Swagger UI. </span><span class="koboSpan" id="kobo.1227.2">You will see that the console log shows that the first response was from the database. </span><span class="koboSpan" id="kobo.1227.3">The headers of the response look </span><span class="No-Break"><span class="koboSpan" id="kobo.1228.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1229.1">
content-type: application/json; charset=utf-8date: Sat,07 Oct 2023 06:43:02 GMT
server: Kestrel</span></pre>
<p><span class="koboSpan" id="kobo.1230.1">Send the request again. </span><span class="koboSpan" id="kobo.1230.2">You will not see the database query log in the console. </span><span class="koboSpan" id="kobo.1230.3">The headers of the response look </span><span class="No-Break"><span class="koboSpan" id="kobo.1231.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1232.1">
age: 5content-length: 87
content-type: application/json; charset=utf-8
date: Sat,07 Oct 2023 06:44:39 GMT
server: Kestrel</span></pre>
<p><span class="koboSpan" id="kobo.1233.1">You can </span><a id="_idIndexMarker1752"/><span class="koboSpan" id="kobo.1234.1">find that the headers of the response contain the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1235.1">age</span></strong><span class="koboSpan" id="kobo.1236.1"> header, which indicates that the response is cached. </span><span class="koboSpan" id="kobo.1236.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1237.1">age</span></strong><span class="koboSpan" id="kobo.1238.1"> header is the number of seconds since the response </span><span class="No-Break"><span class="koboSpan" id="kobo.1239.1">was generated.</span></span></p>
<p><span class="koboSpan" id="kobo.1240.1">By default, the </span><a id="_idIndexMarker1753"/><span class="koboSpan" id="kobo.1241.1">expiration time of the cached response is 60 seconds. </span><span class="koboSpan" id="kobo.1241.2">After 60 seconds have elapsed, the next request will query the </span><span class="No-Break"><span class="koboSpan" id="kobo.1242.1">database again.</span></span></p>
<p><span class="koboSpan" id="kobo.1243.1">We can define different caching policies for different endpoints. </span><span class="koboSpan" id="kobo.1243.2">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1244.1">AddOutputCache()</span></strong><span class="koboSpan" id="kobo.1245.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.1246.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1247.1">
builder.Services.AddOutputCache(options =&gt;{
    options.AddBasePolicy(x =&gt; x.Cache());
    options.AddPolicy("Expire600", x =&gt; x.Expire(TimeSpan.FromSeconds(600)));
    options.AddPolicy("Expire3600", x =&gt; x.Expire(TimeSpan.FromSeconds(3600)));
});</span></pre>
<p><span class="koboSpan" id="kobo.1248.1">In the preceding code, we added two caching policies. </span><span class="koboSpan" id="kobo.1248.2">The first </span><strong class="source-inline"><span class="koboSpan" id="kobo.1249.1">Expire600</span></strong><span class="koboSpan" id="kobo.1250.1"> policy will expire the cached response after 10 minutes, and the second one will expire the cached response after 1 hour. </span><span class="koboSpan" id="kobo.1250.2">Then, we can apply the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1251.1">OutputCache</span></strong><span class="koboSpan" id="kobo.1252.1"> attribute to the endpoints </span><span class="No-Break"><span class="koboSpan" id="kobo.1253.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1254.1">
[HttpGet("{id}")][OutputCache(PolicyName = "Expire600")]
public async Task&lt;ActionResult&lt;Category?&gt;&gt; Get(int id)
{
    // Omitted for brevity
}</span></pre>
<p><span class="koboSpan" id="kobo.1255.1">Now, the cached response will exp</span><a id="_idTextAnchor659"/><span class="koboSpan" id="kobo.1256.1">ire in </span><span class="No-Break"><span class="koboSpan" id="kobo.1257.1">10 minutes.</span></span></p>
<h2 id="_idParaDest-347"><a id="_idTextAnchor660"/><span class="koboSpan" id="kobo.1258.1">What caching strategy should I use?</span></h2>
<p><span class="koboSpan" id="kobo.1259.1">Caching is a</span><a id="_idIndexMarker1754"/><span class="koboSpan" id="kobo.1260.1"> useful tool for improving the performance of applications. </span><span class="koboSpan" id="kobo.1260.2">In this section, we</span><a id="_idIndexMarker1755"/><span class="koboSpan" id="kobo.1261.1"> introduced a couple of caching techniques, including in-memory caching, distributed caching, response caching, and output caching. </span><span class="koboSpan" id="kobo.1261.2">Each caching technique has its suitable scenarios. </span><span class="koboSpan" id="kobo.1261.3">We need to choose the proper caching technique based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.1262.1">specific scenarios.</span></span></p>
<p><span class="koboSpan" id="kobo.1263.1">Response caching is relatively straightforward to implement; however, it is dependent on the client-side HTTP caching configuration. </span><span class="koboSpan" id="kobo.1263.2">If the client-side HTTP caching is disabled, response caching will not work as intended. </span><span class="koboSpan" id="kobo.1263.3">Output caching is more flexible and can be used independently of the client-side HTTP caching configuration. </span><span class="koboSpan" id="kobo.1263.4">It does not need much effort to implement, but it has a </span><span class="No-Break"><span class="koboSpan" id="kobo.1264.1">few limitations.</span></span></p>
<p><span class="koboSpan" id="kobo.1265.1">In-memory caching is a fast and easy way to cache data in a single instance of the application. </span><span class="koboSpan" id="kobo.1265.2">However, it needs session affinity to work properly if there are multiple instances of the application. </span><span class="koboSpan" id="kobo.1265.3">Distributed caching supports multiple instances, but it needs extra network I/O to access the cache. </span><span class="koboSpan" id="kobo.1265.4">So, we need to consider the trade-off between the performance and the scalability. </span><span class="koboSpan" id="kobo.1265.5">If retrieving the data from the database is complex or needs expensive computation and the data is not often changed, we can use distributed caching to reduce the load on the database or the computation. </span><span class="koboSpan" id="kobo.1265.6">Additionally, we can use in-memory caching and distributed caching together to leverage the advantages of both caching techniques. </span><span class="koboSpan" id="kobo.1265.7">For example, we can query the data from the in-memory cache first, and if the data is not found, we can then query the distributed cache. </span><span class="koboSpan" id="kobo.1265.8">Also, consider the expiration time of the cache entry. </span><span class="koboSpan" id="kobo.1265.9">You may need various expiration policies for </span><span class="No-Break"><span class="koboSpan" id="kobo.1266.1">different data.</span></span></p>
<p><span class="koboSpan" id="kobo.1267.1">This section only introduces the basic concepts of caching in ASP.NET Core. </span><span class="koboSpan" id="kobo.1267.2">To learn more about caching, please refer to the documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.1268.1">at </span></span><a href="https://docs.microsoft.com/en-us/aspnet/core/p﻿erformance/caching/"><span class="No-Break"><span class="koboSpan" id="kobo.1269.1">https://docs.microsoft.com/en-us/aspnet/core/p</span><span id="_idTextAnchor661"/><span class="koboSpan" id="kobo.1270.1">erformance/caching/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1271.1">.</span></span></p>
<h1 id="_idParaDest-348"><a id="_idTextAnchor662"/><span class="koboSpan" id="kobo.1272.1">Using HttpClientFactory to manage HttpClient instances</span></h1>
<p><span class="koboSpan" id="kobo.1273.1">.NET provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1274.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1275.1"> class for sending HTTP requests. </span><span class="koboSpan" id="kobo.1275.2">However, there is some</span><a id="_idIndexMarker1756"/><span class="koboSpan" id="kobo.1276.1"> confusion when using it. </span><span class="koboSpan" id="kobo.1276.2">In the past, many developers would misuse the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1277.1">using</span></strong><span class="koboSpan" id="kobo.1278.1"> statement to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1279.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1280.1"> instance, as it implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1281.1">IDisposal</span></strong><span class="koboSpan" id="kobo.1282.1"> interface. </span><span class="koboSpan" id="kobo.1282.2">This is not recommended, as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1283.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1284.1"> class is designed to be reused for multiple requests. </span><span class="koboSpan" id="kobo.1284.2">Creating a new instance for each request can exhaust the local </span><span class="No-Break"><span class="koboSpan" id="kobo.1285.1">socket ports.</span></span></p>
<p><span class="koboSpan" id="kobo.1286.1">To solve this problem, Microsoft introduced the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1287.1">IHttpClientFactory</span></strong><span class="koboSpan" id="kobo.1288.1"> interface in ASP.NET Core 2.1. </span><span class="koboSpan" id="kobo.1288.2">This interface simplifies the management of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1289.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1290.1"> instances. </span><span class="koboSpan" id="kobo.1290.2">It allows us to use dependency injection to inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.1291.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1292.1"> instances into the application without worrying about the life cycle of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1293.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1294.1"> instances. </span><span class="koboSpan" id="kobo.1294.2">In this section, we will introduce how to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1295.1">IHttpClientFactory</span></strong><span class="koboSpan" id="kobo.1296.1"> interface to manage </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1297.1">HttpClient</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1298.1"> instances.</span></span></p>
<p><span class="koboSpan" id="kobo.1299.1">You can find the sample application for this section in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1300.1">samples/chapter15/HttpClientDemo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1301.1"> folder.</span></span></p>
<p><span class="koboSpan" id="kobo.1302.1">To demonstrate how to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1303.1">IHttpClientFactory</span></strong><span class="koboSpan" id="kobo.1304.1"> interface, we need to have a web API application as the backend service. </span><span class="koboSpan" id="kobo.1304.2">You can use any sample applications we have created in the previous chapters. </span><span class="koboSpan" id="kobo.1304.3">In this section, we will use a fake API service: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1305.1">https://jsonplaceholder.typicode.com/</span></strong><span class="koboSpan" id="kobo.1306.1">. </span><span class="koboSpan" id="kobo.1306.2">This is a free online REST API service that can be used for testing and prototyping. </span><span class="koboSpan" id="kobo.1306.3">It provides a set of endpoints, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1307.1">/posts</span></strong><span class="koboSpan" id="kobo.1308.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1309.1">/comments</span></strong><span class="koboSpan" id="kobo.1310.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1311.1">/albums</span></strong><span class="koboSpan" id="kobo.1312.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1313.1">/photos</span></strong><span class="koboSpan" id="kobo.1314.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1315.1">/todos</span></strong><span class="koboSpan" id="kobo.1316.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1317.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1318.1">/users</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1319.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1320.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1321.1">When you create C# models from JSON data, you can use the </span><strong class="bold"><span class="koboSpan" id="kobo.1322.1">Paste JSON as Classes</span></strong><span class="koboSpan" id="kobo.1323.1"> feature in Visual Studio. </span><span class="koboSpan" id="kobo.1323.2">You can find this feature in the </span><strong class="bold"><span class="koboSpan" id="kobo.1324.1">Edit</span></strong> <a id="_idTextAnchor663"/><span class="koboSpan" id="kobo.1325.1">| </span><strong class="bold"><span class="koboSpan" id="kobo.1326.1">Paste </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1327.1">Special</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1328.1"> menu.</span></span></p>
<h2 id="_idParaDest-349"><a id="_idTextAnchor664"/><span class="koboSpan" id="kobo.1329.1">Creating a basic HttpClient instance</span></h2>
<p><span class="koboSpan" id="kobo.1330.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1331.1">IHttpClientFactory</span></strong><span class="koboSpan" id="kobo.1332.1"> interface provides an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1333.1">AddHttpClient()</span></strong><span class="koboSpan" id="kobo.1334.1"> extension method to </span><a id="_idIndexMarker1757"/><span class="koboSpan" id="kobo.1335.1">register the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1336.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1337.1"> instances. </span><span class="koboSpan" id="kobo.1337.2">Add the following code in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1338.1">Program.cs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1339.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1340.1">
builder.Services.AddHttpClient();</span></pre> <p><span class="koboSpan" id="kobo.1341.1">Then, we can inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1342.1">IHttpClientFactory</span></strong><span class="koboSpan" id="kobo.1343.1"> interface into the controller and use it to create a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1344.1">HttpClient</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1345.1"> instance:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1346.1">
[ApiController][Route("[controller]")]
public class PostsController(IHttpClientFactory httpClientFactory) : ControllerBase
{
    [HttpGet]
    public async Task&lt;IActionResult&gt; Get()
    {
        var httpClient = httpClientFactory.CreateClient();
        var httpRequestMessage = new HttpRequestMessage
        {
            Method = HttpMethod.Get,
            RequestUri = new Uri("https://jsonplaceholder.typicode.com/posts")
        };
        var response = await httpClient.SendAsync(httpRequestMessage);
        response.EnsureSuccessStatusCode();
        var content = await response.Content.ReadAsStringAsync();
        var posts = JsonSerializerHelper.DeserializeWithCamelCase&lt;List&lt;Post&gt;&gt;(content);
        return Ok(posts);
    }
    // Omitted for brevity
}</span></pre>
<p><span class="koboSpan" id="kobo.1347.1">In the </span><a id="_idIndexMarker1758"/><span class="koboSpan" id="kobo.1348.1">preceding code, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1349.1">CreateClient()</span></strong><span class="koboSpan" id="kobo.1350.1"> method to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1351.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1352.1"> instance. </span><span class="koboSpan" id="kobo.1352.2">Then, we create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1353.1">HttpRequestMessage</span></strong><span class="koboSpan" id="kobo.1354.1"> instance and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1355.1">SendAsync()</span></strong><span class="koboSpan" id="kobo.1356.1"> method to send the HTTP request. </span><span class="koboSpan" id="kobo.1356.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1357.1">EnsureSuccessStatusCode()</span></strong><span class="koboSpan" id="kobo.1358.1"> method is used to ensure the response is successful. </span><span class="koboSpan" id="kobo.1358.2">If the response fails, an exception will be thrown. </span><span class="koboSpan" id="kobo.1358.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1359.1">ReadAsStringAsync()</span></strong><span class="koboSpan" id="kobo.1360.1"> method is used to read the response content as a string. </span><span class="koboSpan" id="kobo.1360.2">Finally, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1361.1">JsonSerializerHelper</span></strong><span class="koboSpan" id="kobo.1362.1"> class to deserialize the JSON string into a list of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1363.1">Post</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1364.1"> objects.</span></span></p>
<p><span class="koboSpan" id="kobo.1365.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1366.1">JsonSerializerHelper</span></strong><span class="koboSpan" id="kobo.1367.1"> class is defined </span><span class="No-Break"><span class="koboSpan" id="kobo.1368.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1369.1">
public static class JsonSerializerHelper{
    public static string SerializeWithCamelCase&lt;T&gt;(T value)
    {
        var options = new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            DictionaryKeyPolicy = JsonNamingPolicy.CamelCase,
        };
        return JsonSerializer.Serialize(value, options);
    }
    public static T? </span><span class="koboSpan" id="kobo.1369.2">DeserializeWithCamelCase&lt;T&gt;(string json)
    {
        var options = new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            DictionaryKeyPolicy = JsonNamingPolicy.CamelCase,
        };
        return JsonSerializer.Deserialize&lt;T&gt;(json, options);
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1370.1">This is</span><a id="_idIndexMarker1759"/><span class="koboSpan" id="kobo.1371.1"> because the JSON data returned by the API uses the camel case naming convention. </span><span class="koboSpan" id="kobo.1371.2">We need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1372.1">JsonNamingPolicy.CamelCase</span></strong><span class="koboSpan" id="kobo.1373.1"> property to deserialize the JSON string into the strongly-typed object. </span><span class="koboSpan" id="kobo.1373.2">We can pass a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1374.1">JsonSerializerOptions</span></strong><span class="koboSpan" id="kobo.1375.1"> instance to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1376.1">JsonSerializer.Serialize()</span></strong><span class="koboSpan" id="kobo.1377.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1378.1">JsonSerializer.Deserialize()</span></strong><span class="koboSpan" id="kobo.1379.1"> methods to specify the serialization and deserialization options. </span><span class="koboSpan" id="kobo.1379.2">Using a helper method can simplify </span><span class="No-Break"><span class="koboSpan" id="kobo.1380.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.1381.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1382.1">HttpRequestMessage</span></strong><span class="koboSpan" id="kobo.1383.1"> class is a low-level class that represents an HTTP request message. </span><span class="koboSpan" id="kobo.1383.2">In most cases, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1384.1">GetStringAsync()</span></strong><span class="koboSpan" id="kobo.1385.1"> method to send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1386.1">GET</span></strong><span class="koboSpan" id="kobo.1387.1"> request and get the response content as a string, </span><span class="No-Break"><span class="koboSpan" id="kobo.1388.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1389.1">
var content = await httpClient.GetStringAsync("https://jsonplaceholder.typicode.com/posts");var posts = JsonSerializerHelper.DeserializeWithCamelCase&lt;List&lt;Post&gt;&gt;(content);
return Ok(posts);</span></pre>
<p><span class="koboSpan" id="kobo.1390.1">The </span><a id="_idIndexMarker1760"/><span class="koboSpan" id="kobo.1391.1">code to send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1392.1">POST</span></strong><span class="koboSpan" id="kobo.1393.1"> request </span><span class="No-Break"><span class="koboSpan" id="kobo.1394.1">is similar:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1395.1">
[HttpPost]public async Task&lt;IActionResult&gt; Post(Post post)
{
    var httpClient = httpClientFactory.CreateClient();
    var json = JsonSerializer.Serialize(post);
    var data = new StringContent(json, Encoding.UTF8, "application/json");
    var response = await httpClient.PostAsync("https://jsonplaceholder.typicode.com/posts", data);
    var content = await response.Content.ReadAsStringAsync();
    var newPost = JsonSerializer.Deserialize&lt;Post&gt;(content);
    return Ok(newPost);
}</span></pre>
<p><span class="koboSpan" id="kobo.1396.1">To send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1397.1">POST</span></strong><span class="koboSpan" id="kobo.1398.1"> request, we need to serialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1399.1">Post</span></strong><span class="koboSpan" id="kobo.1400.1"> object to a JSON string and then convert the JSON string into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1401.1">StringContent</span></strong><span class="koboSpan" id="kobo.1402.1"> instance. </span><span class="koboSpan" id="kobo.1402.2">Then, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1403.1">PostAsync()</span></strong><span class="koboSpan" id="kobo.1404.1"> method to send </span><span class="No-Break"><span class="koboSpan" id="kobo.1405.1">the request.</span></span></p>
<p><span class="koboSpan" id="kobo.1406.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1407.1">StringContent</span></strong><span class="koboSpan" id="kobo.1408.1"> class is a concrete implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1409.1">HttpContent</span></strong><span class="koboSpan" id="kobo.1410.1"> class. </span><span class="koboSpan" id="kobo.1410.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1411.1">HttpContent</span></strong><span class="koboSpan" id="kobo.1412.1"> class is an abstract class that represents the content of an HTTP message. </span><span class="koboSpan" id="kobo.1412.2">It has the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1413.1">concrete implementations:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1414.1">ByteArrayContent</span></strong><span class="koboSpan" id="kobo.1415.1">: Represents an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1416.1">HttpContent</span></strong><span class="koboSpan" id="kobo.1417.1"> instance based on a </span><span class="No-Break"><span class="koboSpan" id="kobo.1418.1">byte array</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1419.1">FormUrlEncodedContent</span></strong><span class="koboSpan" id="kobo.1420.1">: Represents a collection of name/value pairs encoded using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1421.1">application/x-www-form-urlencoded</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1422.1">MIME type</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1423.1">MultipartContent</span></strong><span class="koboSpan" id="kobo.1424.1">: Represents a collection of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1425.1">HttpContent</span></strong><span class="koboSpan" id="kobo.1426.1"> instances serialized using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1427.1">multipart/*</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1428.1">MIME type</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1429.1">StreamContent</span></strong><span class="koboSpan" id="kobo.1430.1">: Represents an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1431.1">HttpContent</span></strong><span class="koboSpan" id="kobo.1432.1"> instance based on </span><span class="No-Break"><span class="koboSpan" id="kobo.1433.1">a stream</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1434.1">StringContent</span></strong><span class="koboSpan" id="kobo.1435.1">: Represents an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1436.1">HttpContent</span></strong><span class="koboSpan" id="kobo.1437.1"> instance based on </span><span class="No-Break"><span class="koboSpan" id="kobo.1438.1">a string</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1439.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1440.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1441.1"> class has a few methods and extension methods to send HTTP requests. </span><span class="koboSpan" id="kobo.1441.2">The following</span><a id="_idIndexMarker1761"/><span class="koboSpan" id="kobo.1442.1"> table shows the commonly </span><span class="No-Break"><span class="koboSpan" id="kobo.1443.1">used methods:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table003-5">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1444.1">Method name</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1445.1">Description</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1446.1">SendAsync()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1447.1">Sends an HTTP request to the specified URI. </span><span class="koboSpan" id="kobo.1447.2">This method can send any </span><span class="No-Break"><span class="koboSpan" id="kobo.1448.1">HTTP request.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1449.1">GetAsync()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1450.1">Sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1451.1">GET</span></strong><span class="koboSpan" id="kobo.1452.1"> request to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1453.1">specified URI.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1454.1">GetStringAsync()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1455.1">Sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1456.1">GET</span></strong><span class="koboSpan" id="kobo.1457.1"> request to the specified URI. </span><span class="koboSpan" id="kobo.1457.2">This method returns the response body as </span><span class="No-Break"><span class="koboSpan" id="kobo.1458.1">a string.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1459.1">GetByteArrayAsync()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1460.1">Sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1461.1">GET</span></strong><span class="koboSpan" id="kobo.1462.1"> request to the specified URI. </span><span class="koboSpan" id="kobo.1462.2">This method returns the response body as a </span><span class="No-Break"><span class="koboSpan" id="kobo.1463.1">byte array.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1464.1">GetStreamAsync()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1465.1">Sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1466.1">GET</span></strong><span class="koboSpan" id="kobo.1467.1"> request to the specified URI. </span><span class="koboSpan" id="kobo.1467.2">This method returns the response body as </span><span class="No-Break"><span class="koboSpan" id="kobo.1468.1">a stream.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1469.1">GetFromJsonAsync&lt;T&gt;()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1470.1">Sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1471.1">GET</span></strong><span class="koboSpan" id="kobo.1472.1"> request to the specified URI. </span><span class="koboSpan" id="kobo.1472.2">This method returns the response body as a </span><span class="No-Break"><span class="koboSpan" id="kobo.1473.1">strongly-typed object.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1474.1">GetFromJsonAsAsyncEnumerable&lt;T&gt;()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1475.1">Sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1476.1">GET</span></strong><span class="koboSpan" id="kobo.1477.1"> request to the specified URI. </span><span class="koboSpan" id="kobo.1477.2">This method returns the response body as an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1478.1">IAsyncEnumerable&lt;T&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1479.1"> instance.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1480.1">PostAsync()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1481.1">Sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1482.1">POST</span></strong><span class="koboSpan" id="kobo.1483.1"> request to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1484.1">specified URI.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1485.1">PostAsJsonAsync()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1486.1">Sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1487.1">POST</span></strong><span class="koboSpan" id="kobo.1488.1"> request to the specified URI. </span><span class="koboSpan" id="kobo.1488.2">The request body is serialized </span><span class="No-Break"><span class="koboSpan" id="kobo.1489.1">as JSON.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1490.1">PutAsync()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1491.1">Sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1492.1">PUT</span></strong><span class="koboSpan" id="kobo.1493.1"> request to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1494.1">specified URI.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1495.1">PutAsJsonAsync()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1496.1">Sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1497.1">PUT</span></strong><span class="koboSpan" id="kobo.1498.1"> request to the specified URI. </span><span class="koboSpan" id="kobo.1498.2">The request body is serialized </span><span class="No-Break"><span class="koboSpan" id="kobo.1499.1">as JSON.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1500.1">DeleteAsync()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1501.1">Sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1502.1">DELETE</span></strong><span class="koboSpan" id="kobo.1503.1"> request to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1504.1">specified URI.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1505.1">DeleteFromJsonAsync&lt;T&gt;()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1506.1">Sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1507.1">DELETE</span></strong><span class="koboSpan" id="kobo.1508.1"> request to the specified URI. </span><span class="koboSpan" id="kobo.1508.2">This method returns the response body as a </span><span class="No-Break"><span class="koboSpan" id="kobo.1509.1">strongly-typed object.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1510.1">PatchAsync()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1511.1">Sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1512.1">PATCH</span></strong><span class="koboSpan" id="kobo.1513.1"> request to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1514.1">specified URI.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor665"/><span class="koboSpan" id="kobo.1515.1">Table 15.3 – The commonly used methods of the HttpClient class</span></p>
<p><span class="koboSpan" id="kobo.1516.1">When</span><a id="_idIndexMarker1762"/><span class="koboSpan" id="kobo.1517.1"> we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1518.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1519.1"> instance created by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1520.1">IHttpClientFactory</span></strong><span class="koboSpan" id="kobo.1521.1"> interface, we need to specify the request URL. </span><span class="koboSpan" id="kobo.1521.2">We can set the base address of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1522.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1523.1"> instance when registering the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1524.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1525.1"> instance. </span><span class="koboSpan" id="kobo.1525.2">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1526.1">AddHttpClient()</span></strong><span class="koboSpan" id="kobo.1527.1"> method in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1528.1">Program.cs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1529.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1530.1">
builder.Services.AddHttpClient(client =&gt;{
    client.BaseAddress = new Uri("https://jsonplaceholder.typicode.com/");
    // You can set more options like the default request headers, timeout, and so on.
</span><span class="koboSpan" id="kobo.1530.2">});</span></pre>
<p><span class="koboSpan" id="kobo.1531.1">Then, we do not need to specify the base address when sending the HTTP request. </span><span class="koboSpan" id="kobo.1531.2">However, what if we need to send requests to multiple endpoints with different base addresses? </span><span class="koboSpan" id="kobo.1531.3">Let us see how to solve this problem in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1532.1">next section.</span></span></p>
<h2 id="_idParaDest-350"><a id="_idTextAnchor666"/><span class="koboSpan" id="kobo.1533.1">Named HttpClient instances</span></h2>
<p><span class="koboSpan" id="kobo.1534.1">It is</span><a id="_idIndexMarker1763"/><span class="koboSpan" id="kobo.1535.1"> tedious to specify the base address of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1536.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1537.1"> instance or the request URI every time. </span><span class="koboSpan" id="kobo.1537.2">We can specify some common settings when registering the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1538.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1539.1"> instance. </span><span class="koboSpan" id="kobo.1539.2">For example, we can specify the base address of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1540.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1541.1"> instance </span><span class="No-Break"><span class="koboSpan" id="kobo.1542.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1543.1">
builder.Services.AddHttpClient("JsonPlaceholder", client =&gt;{
    client.BaseAddress = new Uri("https://jsonplaceholder.typicode.com/");
    // You can set more options like the default request headers, timeout, etc.
</span><span class="koboSpan" id="kobo.1543.2">    client.DefaultRequestHeaders.Add(HeaderNames.Accept, "application/json");
    client.DefaultRequestHeaders.Add(HeaderNames.UserAgent, "HttpClientDemo");
});</span></pre>
<p><span class="koboSpan" id="kobo.1544.1">In the </span><a id="_idIndexMarker1764"/><span class="koboSpan" id="kobo.1545.1">preceding code, we register the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1546.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1547.1"> instance with the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.1548.1">JsonPlaceholder</span></strong><span class="koboSpan" id="kobo.1549.1"> and specify the base address of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1550.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1551.1"> instance. </span><span class="koboSpan" id="kobo.1551.2">We can also set the default request headers, such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1552.1">Accept</span></strong><span class="koboSpan" id="kobo.1553.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1554.1">User-Agent</span></strong><span class="koboSpan" id="kobo.1555.1"> headers. </span><span class="koboSpan" id="kobo.1555.2">Then, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1556.1">JsonPlaceholder</span></strong><span class="koboSpan" id="kobo.1557.1"> name to inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1558.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1559.1"> instance into </span><span class="No-Break"><span class="koboSpan" id="kobo.1560.1">the controller:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1561.1">
var httpClient = httpClientFactory.CreateClient("JsonPlaceholder");</span></pre> <p><span class="koboSpan" id="kobo.1562.1">This is called named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1563.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1564.1"> instances, which allows us to register multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.1565.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1566.1"> instances with different names. </span><span class="koboSpan" id="kobo.1566.2">This is useful when we need multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.1567.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1568.1"> instances with different configurations. </span><span class="koboSpan" id="kobo.1568.2">By using the name, we can easily access the </span><span class="No-Break"><span class="koboSpan" id="kobo.1569.1">desired instanc</span><a id="_idTextAnchor667"/><span class="koboSpan" id="kobo.1570.1">e.</span></span></p>
<h2 id="_idParaDest-351"><a id="_idTextAnchor668"/><span class="koboSpan" id="kobo.1571.1">Typed HttpClient instances</span></h2>
<p><span class="koboSpan" id="kobo.1572.1">To better</span><a id="_idIndexMarker1765"/><span class="koboSpan" id="kobo.1573.1"> encapsulate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1574.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1575.1"> instances, we can create a typed </span><strong class="source-inline"><span class="koboSpan" id="kobo.1576.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1577.1"> instance for a specific type. </span><span class="koboSpan" id="kobo.1577.2">For example, we can create a typed </span><strong class="source-inline"><span class="koboSpan" id="kobo.1578.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1579.1"> instance for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1580.1">User</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1581.1"> type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1582.1">
public class UserService{
    private readonly HttpClient _httpClient;
    private readonly JsonSerializerOptions _jsonSerializerOptions = new()
    {
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        DictionaryKeyPolicy = JsonNamingPolicy.CamelCase
    };
    public UserService(HttpClient httpClient)
    {
        _httpClient = httpClient;
        _httpClient.BaseAddress = new Uri("https://jsonplaceholder.typicode.com/");
        _httpClient.DefaultRequestHeaders.Add(HeaderNames.Accept, "application/json");
        _httpClient.DefaultRequestHeaders.Add(HeaderNames.UserAgent, "HttpClientDemo");
    }
    public Task&lt;List&lt;User&gt;?&gt; GetUsers()
    {
        return _httpClient.GetFromJsonAsync&lt;List&lt;User&gt;&gt;("users", _jsonSerializerOptions);
    }
    public async Task&lt;User?&gt; GetUser(int id)
    {
        return await _httpClient.GetFromJsonAsync&lt;User&gt;($"users/{id}", _jsonSerializerOptions);
    }
    // Omitted for brevity
}</span></pre>
<p><span class="koboSpan" id="kobo.1583.1">In the preceding</span><a id="_idIndexMarker1766"/><span class="koboSpan" id="kobo.1584.1"> code, we create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1585.1">UserService</span></strong><span class="koboSpan" id="kobo.1586.1"> class to encapsulate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1587.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1588.1"> instance. </span><span class="koboSpan" id="kobo.1588.2">Register the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1589.1">UserService</span></strong><span class="koboSpan" id="kobo.1590.1"> class in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1591.1">Program</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1592.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1593.1">
builder.Services.AddHttpClient&lt;UserService&gt;();</span></pre> <p><span class="koboSpan" id="kobo.1594.1">Then, we can inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1595.1">UserService</span></strong><span class="koboSpan" id="kobo.1596.1"> class into </span><span class="No-Break"><span class="koboSpan" id="kobo.1597.1">the controller:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1598.1">
[ApiController][Route("[controller]")]
public class UsersController(UserService usersService) : ControllerBase
{
    [HttpGet]
    public async Task&lt;ActionResult&lt;List&lt;User&gt;&gt;&gt; Get()
    {
        var users = await usersService.GetUsers();
        return Ok(users);
    }
    [HttpGet("{id}")]
    public async Task&lt;ActionResult&lt;User&gt;&gt; Get(int id)
    {
        var user = await usersService.GetUser(id);
        if (user == null)
        {
            return NotFound();
        }
        return Ok(user);
    }
    // Omitted for brevity
}</span></pre>
<p><span class="koboSpan" id="kobo.1599.1">In the preceding</span><a id="_idIndexMarker1767"/><span class="koboSpan" id="kobo.1600.1"> code, the controller does not need to know the details of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1601.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1602.1"> instance. </span><span class="koboSpan" id="kobo.1602.2">It only needs to call the methods of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1603.1">UserService</span></strong><span class="koboSpan" id="kobo.1604.1"> class. </span><span class="koboSpan" id="kobo.1604.2">The code is </span><span class="No-Break"><span class="koboSpan" id="kobo.1605.1">much cleaner.</span></span></p>
<p><span class="koboSpan" id="kobo.1606.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1607.1">IHttpClientFactory</span></strong><span class="koboSpan" id="kobo.1608.1"> interface is the recommended way to manage </span><strong class="source-inline"><span class="koboSpan" id="kobo.1609.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1610.1"> instances. </span><span class="koboSpan" id="kobo.1610.2">It saves us from the tedious work of managing the lifetime of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1611.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1612.1"> instances. </span><span class="koboSpan" id="kobo.1612.2">It also allows us to configure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1613.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1614.1"> instances in a centralized place. </span><span class="koboSpan" id="kobo.1614.2">For more information, please refer to the documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.1615.1">at </span></span><a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/http-requ﻿ests"><span class="No-Break"><span class="koboSpan" id="kobo.1616.1">https://learn.microsoft.com/en-us/aspnet/core/fundamentals/http-requ</span><span id="_idTextAnchor669"/><span class="koboSpan" id="kobo.1617.1">ests</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1618.1">.</span></span></p>
<h1 id="_idParaDest-352"><a id="_idTextAnchor670"/><span class="koboSpan" id="kobo.1619.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1620.1">In this chapter, we discussed common practices in ASP.NET Core web API development, such as HTTP status codes, asynchronous programming, pagination, response types, and API documentation. </span><span class="koboSpan" id="kobo.1620.2">We also explored several caching techniques, including in-memory caching, distributed caching, response caching, and output caching. </span><span class="koboSpan" id="kobo.1620.3">Each technique has its own advantages and disadvantages, so it is important to consider the trade-offs and choose the appropriate caching strategy for the given scenario. </span><span class="koboSpan" id="kobo.1620.4">Additionally, we discussed the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1621.1">IHttpClientFactory</span></strong><span class="koboSpan" id="kobo.1622.1"> interface, which simplifies the management of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1623.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1624.1"> instances and allows us to use dependency injection to inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.1625.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1626.1"> instances into the application without worrying about their </span><span class="No-Break"><span class="koboSpan" id="kobo.1627.1">life cycle.</span></span></p>
<p><span class="koboSpan" id="kobo.1628.1">In the next chapter, we will discuss how to handle errors in ASP.NET Core web API applications and how to monitor the applications </span><span class="No-Break"><span class="koboSpan" id="kobo.1629.1">using OpenTelemetry.</span></span></p>
</div>
</body></html>