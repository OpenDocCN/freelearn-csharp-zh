- en: 19 Introduction to Microservices Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 19 微服务架构简介
- en: 'Before you begin: Join our book community on Discord'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开始之前：加入我们的 Discord 书籍社区
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向作者本人提供反馈，并在我们的 Discord 服务器上与其他早期读者聊天（在“architecting-aspnet-core-apps-3e”频道下找到，位于“EARLY
    ACCESS SUBSCRIPTION”）。
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
- en: '![Qr code Description automatically generated](img/file127.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![二维码描述自动生成](img/file127.png)'
- en: 'The chapter covers some essential microservices architecture concepts. It is
    designed to get you started with those principles and an overview of the concepts
    surrounding microservices, which should help you make informed decisions about
    whether to go for a microservices architecture or not.Since microservices architecture
    is larger in scale than the previous application-scale patterns we visited and
    often involves complex components or setup, there is very limited C# code in the
    chapter. Instead, I explain the concepts and list open-source or commercial offerings
    that you can leverage to apply these patterns to your applications. Moreover,
    you should not aim to implement many of the pieces discussed in the chapter because
    it can be a lot of work to get them right, and they don’t add business value,
    so you are better off just using an existing implementation instead. There is
    more context about this throughout the chapter.Monolithic architecture patterns,
    such as Vertical Slice and Clean Architecture, are still good to know, as you
    can apply those to individual microservices. Don’t worry—all of the knowledge
    you have acquired since the beginning of this book is not forfeit and is still
    worthwhile.In this chapter, we cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了微服务架构的一些基本概念。它旨在帮助你开始了解这些原则以及围绕微服务的概念概述，这应该有助于你做出是否采用微服务架构的明智决定。由于微服务架构的规模比我们之前探讨的应用程序规模更大，并且通常涉及复杂的组件或设置，因此本章中
    C# 代码非常有限。相反，我解释了这些概念，并列出了你可以利用的开源或商业产品，以将这些模式应用到你的应用程序中。此外，你不需要实现本章中讨论的许多组件，因为正确实现它们可能是一项大量工作，而且它们并不增加业务价值，所以你最好使用现有的实现。关于这一点，本章中还有更多背景信息。垂直切片和清洁架构等单体架构模式仍然值得了解，因为你可以将这些应用到单个微服务上。不用担心——你从本书开始以来所获得的所有知识都不是徒劳的，仍然很有价值。在本章中，我们涵盖了以下主题：
- en: What are microservices?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是微服务？
- en: An introduction to event-driven architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件驱动架构简介
- en: Getting started with message queues
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从消息队列开始
- en: Implementing the Publish-Subscribe pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现发布-订阅模式
- en: Introducing Gateway patterns
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍网关模式
- en: Project – REPR.BFF—that transforms the REPR project into microservices
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目 – REPR.BFF – 将 REPR 项目转换为微服务
- en: Revisiting the CQRS pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重访 CQRS 模式
- en: The Microservices Adapter pattern
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务适配器模式
- en: Let’s get started!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: What are microservices?
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是微服务？
- en: 'Microservices represent an application that is divided into multiple smaller
    applications. Each application, or microservice, interacts with the others to
    create a scalable system. Usually, microservices are deployed to the cloud as
    containerized or serverless applications.Before getting into too many details,
    here are the principles to keep in mind when building microservices:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务代表的是一个被划分为多个更小应用的应用程序。每个应用，或微服务，与其他应用交互以创建一个可扩展的系统。通常，微服务以容器化或无服务器应用的形式部署到云端。在深入太多细节之前，以下是在构建微服务时需要记住的原则：
- en: Each microservice should be a cohesive unit of business.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务应该是一个业务上的内聚单元。
- en: Each microservice should own its data.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务应该拥有自己的数据。
- en: Each microservice should be independent of the others.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务应该独立于其他微服务。
- en: Furthermore, everything we have studied so far—the other principles of designing
    software—applies to microservices but on another scale. For example, you don’t
    want tight coupling between microservices (solved by microservices independence),
    but the coupling is inevitable (as with any code). There are numerous ways to
    solve this problem, such as the Publish-Subscribe pattern.There are no hard rules
    about how to design microservices, how to divide them, how big they should be,
    and what to put where. Nevertheless, I’ll lay down a few foundations to help you
    get started and orient your journey into microservices.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们迄今为止所学的所有内容——其他软件设计原则——都适用于微服务，但规模不同。例如，你不想微服务之间存在紧密耦合（通过微服务独立性解决），但这种耦合是不可避免的（就像任何代码一样）。有无数种方法可以解决这个问题，例如发布-订阅模式。关于如何设计微服务、如何划分它们、它们应该有多大以及应该放在哪里，没有硬性规则。尽管如此，我仍会为你奠定一些基础，帮助你开始并指导你进入微服务的旅程。
- en: Cohesive unit of business
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 业务内聚单元
- en: 'A microservice should have a single business responsibility. Always design
    the system with the domain in mind, which should help you divide the application
    into multiple pieces. If you know **Domain-Driven Design** (**DDD**), a microservice
    will most likely represent a **Bounded Context**, which in turn is what I call
    a *cohesive unit of business*. Basically, a cohesive unit of business (or bounded
    context) is a self-contained part of the domain with limited interactions with
    other parts.Even if a **microservice** has *micro* in its name, it is more important
    to group logical operations under it than to aim at a micro-size. Don’t get me
    wrong here; if your unit is tiny, that’s even better. However, suppose you split
    a unit of business into multiple smaller parts instead of keeping it together
    (breaking cohesion); you are likely to introduce useless chattiness within your
    system (coupling between microservices). This could lead to performance degradation
    and to a system that is harder to debug, test, maintain, monitor, and deploy.
    Moreover, it is easier to split a big microservice into smaller pieces than to
    assemble multiple microservices back together. Try to apply the SRP to your microservices:
    a microservice should have only one reason to change unless you have a good reason
    to do otherwise.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个微服务应该只有一个业务职责。始终以领域为出发点来设计系统，这应该有助于你将应用程序划分为多个部分。如果你了解**领域驱动设计**（**DDD**），那么一个微服务很可能会代表一个**边界上下文**，而这正是我所说的*业务内聚单元*。基本上，一个业务内聚单元（或边界上下文）是领域中的一个自包含部分，与其他部分的交互有限。即使一个**微服务**的名字中有*微*字，将其下的逻辑操作分组比追求微小的规模更为重要。请别误解我的意思；如果你的单元很小，那甚至更好。然而，如果你将一个业务单元拆分成多个更小的部分而不是保持其完整性（破坏内聚），你可能会在你的系统中引入无用的冗余（微服务之间的耦合）。这可能导致性能下降，并使系统更难调试、测试、维护、监控和部署。此外，将一个大微服务拆分成更小的部分比将多个微服务重新组装起来更容易。尝试将SRP（单一职责原则）应用到你的微服务中：除非你有充分的理由这样做，否则一个微服务应该只有一个改变的理由。
- en: Ownership of data
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据所有权
- en: Each microservice should be the source of truth of its cohesive unit of business.
    A microservice should share its data through an API (a web API/HTTP, for example)
    or another mechanism (integration events, for example). It should own that data
    and not share it with other microservices directly at the database level.For instance,
    two different microservices should never access the same relational database table.
    If a second microservice needs some of the same data, it can create its own cache,
    duplicate the data, or query the owner of that data but not access the database
    directly; **never**.This data-ownership concept is probably the most critical
    part of the microservices architecture and leads to microservices independence.
    Failing at this will most likely lead to a tremendous number of problems. For
    example, if multiple microservices can read or write data in the same database
    table, each time something changes in that table, all of them must be updated
    to reflect the changes. If different teams manage the microservices, that means
    cross-team coordination. If that happens, each microservice is not independent
    anymore, which opens the floor to our next topic.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务应该是其业务单元的真相来源。微服务应通过API（例如，Web API/HTTP）或另一种机制（例如集成事件）共享其数据。它应该拥有这些数据，而不是在数据库级别直接与其他微服务共享。例如，两个不同的微服务永远不应该访问同一个关系型数据库表。如果第二个微服务需要一些相同的数据，它可以创建自己的缓存，复制数据，或查询数据的所有者，但不能直接访问数据库；**永远不要**。这种数据所有权概念可能是微服务架构中最关键的部分，并导致微服务独立。在这方面失败很可能会导致大量问题。例如，如果多个微服务可以读取或写入同一个数据库表中的数据，那么每次该表中的数据发生变化时，它们都必须更新以反映这些变化。如果不同的团队管理微服务，那就意味着跨团队协调。如果发生这种情况，每个微服务就不再独立了，这为我们接下来的主题打开了大门。
- en: Microservice independence
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微服务独立性
- en: At this point, we have microservices that are cohesive units of business and
    own their data. That defines **independence**.This independence allows the systems
    to scale while having minimal to no impact on the other microservices. Each microservice
    can also scale independently without needing the whole system to be scaled. Additionally,
    when the business requirements grow, each part of that domain can evolve independently.Furthermore,
    you could update one microservice without impacting the others or even have a
    microservice go offline without the whole system stopping.Of course, microservices
    have to interact with one another, but the way they do should define how well
    your system runs. A little like Vertical Slice architecture, you are not limited
    to using one set of architectural patterns; you can independently make specific
    decisions for each microservice. For example, you could choose a different way
    for how two microservices communicate with each other versus two others. You could
    even use different programming languages for each microservice.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有了拥有自己数据的业务单元的微服务。这定义了**独立性**。这种独立性允许系统在最小化或没有对其他微服务产生影响的情况下进行扩展。每个微服务也可以独立扩展，而无需整个系统进行扩展。此外，当业务需求增长时，该领域的每个部分都可以独立发展。此外，您可以更新一个微服务而不会影响其他微服务，甚至可以让一个微服务离线而不会导致整个系统停止。当然，微服务必须相互交互，但它们交互的方式应该定义您的系统运行得有多好。有点像垂直切片架构，您不必局限于使用一组特定的架构模式；您可以独立地为每个微服务做出特定的决策。例如，您可以为两个微服务之间的通信选择不同的方式，而不是为其他两个微服务选择。甚至可以为每个微服务使用不同的编程语言。
- en: I recommend sticking to one or a few programming languages for smaller businesses
    and organizations, as you most likely have fewer developers, and each has more
    to do. Based on my experience, you want to ensure business continuity when people
    leave and make sure you can replace them and not sink the ship due to some obscure
    technologies used here and there (or too many technologies).
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我建议对于较小的企业和组织，坚持使用一种或几种编程语言，因为您很可能有更少的开发者，他们有更多的事情要做。根据我的经验，您想要确保在人们离开时业务连续性，并确保您可以替换他们，而不会因为这里那里使用的一些神秘技术（或太多技术）而使船只沉没。
- en: Now that we’ve covered the basics, let’s jump into the different ways microservices
    can communicate using event-driven architecture.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了基础知识，让我们深入了解微服务如何通过事件驱动架构进行通信的不同方式。
- en: An introduction to event-driven architecture
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件驱动架构简介
- en: '**Event-driven architecture** (**EDA**) is a paradigm that revolves around
    consuming streams of events, or data in motion, instead of consuming static states.What
    I define by a static state is the data stored in a relational database table or
    other types of data stores, like a NoSQL documents store. That data is dormant
    in a central location and waiting for actors to consume and mutate it. It is stale
    between every mutation; the data (a record, for example) represents a finite state.On
    the other hand, data in motion is the opposite: you consume the ordered events
    and determine the change in state that each event brings or what process the program
    should trigger in reaction to an event.What is an event? People often interchange
    the words event, message, and command. Let’s try to clarify this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件驱动架构**（**EDA**）是一种围绕消费事件流或动态数据而不是消费静态状态的模式。我所说的静态状态是指存储在关系数据库表或其他类型的数据存储（如NoSQL文档存储）中的数据。这些数据在中央位置处于休眠状态，等待参与者消费和修改它。在每次修改之间，数据（例如，一条记录）代表一个有限状态。另一方面，动态中的数据正好相反：你消费有序的事件，并确定每个事件带来的状态变化或程序应该触发的事件响应过程。什么是事件？人们经常互换使用事件、消息和命令这些词。让我们尝试澄清这一点：'
- en: A message is a piece of data that represents something.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息是表示某事物的一份数据。
- en: A message can be an object, a JSON string, bytes, or anything else your system
    can interpret.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息可以是对象、JSON字符串、字节或其他系统可以解释的内容。
- en: An event is a message that represents something that happened in the past.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件是表示过去发生的事情的消息。
- en: A command is a message sent to tell one or more recipients to do something.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令是发送给一个或多个收件人的消息，告诉他们做某事。
- en: A command is sent (past tense), so we can also consider it an event.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令是发送的（过去时态），因此我们也可以将其视为一个事件。
- en: 'A message usually has a payload (or body), headers (metadata), and a way to
    identify it (this can be through the body or headers).We can use events to divide
    a complex system into smaller pieces or have multiple systems talk to each other
    without creating tight coupling. Those systems could be subsystems or external
    applications, such as microservices.Like a REST API''s **Data Transfer Objects
    (DTOs)**, events become the data contracts that tie the multiple systems together
    (coupling). It is essential to think about that carefully when designing events.
    Of course, we cannot foresee the future, so we can only do so much to get it perfect
    the first time. We can version the events to improve maintainability.EDA is a
    fantastic way of breaking tight coupling between microservices but requires rewiring
    your brain to learn this newer paradigm. Tooling is becoming more mature, and
    expertise is less scarce than more linear ways of thinking (like using point-to-point
    communication and relational databases). However, this is slowly changing and
    well worth learning.Before moving further, we can categorize events into the following
    overlapping buckets:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 消息通常有一个有效载荷（或主体）、头信息（元数据）以及一种识别它的方式（这可以通过主体或头信息实现）。我们可以使用事件将复杂系统划分为更小的部分，或者让多个系统相互通信而无需创建紧密耦合。这些系统可以是子系统或外部应用程序，例如微服务。就像REST
    API的**数据传输对象（DTOs）**一样，事件成为将多个系统连接在一起的数据契约（耦合）。在设计事件时，仔细考虑这一点至关重要。当然，我们无法预见未来，所以我们只能尽力第一次就做到完美。我们可以对事件进行版本控制以提高可维护性。EDA是打破微服务之间紧密耦合的绝佳方式，但需要重新调整你的思维方式来学习这种新的范式。工具正在变得更加成熟，专业知识也比使用更线性的思维方式（如使用点对点通信和关系数据库）更为丰富。然而，这种情况正在慢慢改变，学习它是非常值得的。在继续前进之前，我们可以将事件分类到以下重叠的类别中：
- en: Domain events
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域事件
- en: Integration events
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成事件
- en: Application events
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序事件
- en: Enterprise events
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业事件
- en: As we explore next, all types of events play a similar role with different intents
    and scopes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们接下来要探讨的，所有类型的事件都发挥着类似的作用，但意图和范围不同。
- en: Domain events
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 领域事件
- en: A domain event is a term based on DDD representing an event in the domain. This
    event could then trigger other pieces of logic to be executed subsequently. It
    allows us to divide a complex process into multiple smaller processes. Domain
    events work well with domain-centric designs, like Clean Architecture, as we can
    use them to split complex domain objects into multiple smaller pieces. Domain
    events are usually application events. For example, we can use MediatR to publish
    domain events inside an application.To summarize, **domain events integrate pieces
    of domain logic together while keeping the domain logic segregated**, leading
    to loosely coupled components that hold one domain responsibility each (single
    responsibility principle).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 领域事件是基于领域驱动设计（DDD）的一个术语，代表领域中的事件。这个事件可以触发其他逻辑的后续执行。它允许我们将复杂的过程分解成多个较小的过程。领域事件与以领域为中心的设计（如Clean
    Architecture）配合得很好，因为我们可以使用它们将复杂的领域对象分解成多个较小的部分。领域事件通常是应用事件。例如，我们可以在应用内部使用MediatR来发布领域事件。总结来说，**领域事件在保持领域逻辑分离的同时将领域逻辑的各个部分集成在一起**，导致松散耦合的组件，每个组件承担一个领域责任（单一责任原则）。
- en: Integration events
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成事件
- en: Integration events are like domain events but propagate messages to external
    systems, integrating multiple systems together while keeping them independent.
    For example, a microservice could send the `new user registered` event message
    that other microservices react to, like saving the `user id` to enable additional
    capabilities or sending a greeting email to that new user.We use a message broker
    or message queue to publish such events. We explore those after covering application
    and enterprise events.To summarize, **integration events integrate multiple systems
    together while keeping them independent**.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 集成事件就像领域事件，但将消息传播到外部系统，将多个系统集成在一起同时保持它们的独立性。例如，一个微服务可以发送`新用户注册`事件消息，其他微服务会做出反应，比如保存`用户ID`以启用额外功能或向新用户发送问候邮件。我们使用消息代理或消息队列来发布此类事件。在介绍完应用和企业事件后，我们将探讨这些事件。总结来说，**集成事件在保持系统独立的同时将多个系统集成在一起**。
- en: Application events
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用事件
- en: An application event is an event that is internal to an application; it is just
    a matter of scope. If the event is internal to a single process, that event is
    also a domain event (most likely). If the event crosses microservices boundaries
    that your team owns (the same application), it is also an integration event. The
    event itself won’t be different; it is the reason why it exists and its scope
    that describes it as an application event or not.To summarize, **application events
    are related to a single application**.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 应用事件是应用内部的事件；这只是范围问题。如果事件是单个进程内部的事件，那么这个事件也是一个领域事件（很可能是）。如果事件跨越了你团队拥有的微服务边界（同一个应用），那么它也是一个集成事件。事件本身并没有不同；它存在的原因及其范围决定了它是否被描述为应用事件。总结来说，**应用事件与单个应用相关**。
- en: Enterprise events
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 企业事件
- en: An enterprise event describes an event that crosses internal enterprise boundaries.
    These are tightly coupled with your organizational structure. For example, a microservice
    sends an event that other teams, part of other divisions or departments, consume.The
    governance model around those events should differ from application events only
    your team consumes and be more strict with strong oversight.Someone must consider
    who can consume that data, under what circumstances, the impact of changing the
    event schema (data contract), schema ownership, naming conventions, data-structure
    conventions, and more, or risk building an unstable data highway.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 企业事件描述的是跨越内部企业边界的事件。这些事件与你的组织结构紧密相连。例如，一个微服务发送一个事件，其他团队，属于其他部门或部门，会消费这个事件。围绕这些事件的治理模式应与仅你团队消费的应用事件不同，并且需要更严格的监管。必须有人考虑谁可以消费这些数据，在什么情况下，更改事件架构（数据合同）的影响、架构所有权、命名约定、数据结构约定等等，否则可能会构建一个不稳定的数据高速公路。
- en: I like to see EDA as a central **data highway** in the middle of applications,
    systems, integrations, and organizational boundaries, where the events (data)
    flow between systems in a loosely coupled manner.
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我喜欢将EDA视为应用、系统、集成和组织边界之间的中央**数据高速公路**，在这里事件（数据）以松散耦合的方式在系统之间流动。
- en: ''
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It’s like a highway where cars flow between cities (without traffic jams). The
    cities are not controlling what car goes where but are open to visitors.
  id: totrans-52
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它就像一条高速公路，汽车在城市之间流动（没有交通堵塞）。城市并不控制汽车去往何方，而是对游客开放。
- en: To summarize, **enterprise events are integration events that cross organizational
    boundaries**.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，**企业事件是跨越组织边界的集成事件**。
- en: Conclusion
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'In this overview of event-driven architecture, we defined events, messages,
    and commands. An event is a snapshot of the past, a message is data, and a command
    is an event that suggests other systems take action. Since all messages are from
    the past, calling them events is accurate. We then organized events into a few
    overlapping buckets to help identify the intents. We can send events for different
    objectives, but whether it is about designing independent components or reaching
    out to different parts of the business, an event remains a payload that respects
    a certain format (schema). That schema is the data contract (coupling) between
    the consumers of those events. That data contract is probably the most important
    piece of it all: break the contract, break the system.Now, let’s see how event-driven
    architecture can help us follow the **SOLID** principles at cloud-scale:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节对事件驱动架构的概述中，我们定义了事件、消息和命令。事件是过去的快照，消息是数据，命令是建议其他系统采取行动的事件。由于所有消息都是来自过去，称它们为事件是准确的。然后我们将事件组织到几个重叠的类别中，以帮助识别意图。我们可以发送不同目的的事件，但无论是关于设计独立组件还是接触业务的不同部分，事件始终是一个遵守一定格式（模式）的有效负载。这个模式是这些事件消费者之间的数据合约（耦合）。这个数据合约是其中最重要的部分：打破合约，系统就会崩溃。现在，让我们看看事件驱动架构如何帮助我们以云规模遵循**SOLID**原则：
- en: '**S**: Systems are independent of each other by raising and responding to events.
    The events themselves are the glue that ties those systems together. Each piece
    has a single responsibility.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**：系统通过触发和响应事件相互独立。事件本身是把这些系统粘合在一起的内聚力。每个部分都有单一的责任。'
- en: '**O**: We can modify the system’s behaviors by adding new consumers to a particular
    event without impacting the other applications. We can also raise new events to
    build a new process without affecting existing applications.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**：我们可以通过向特定事件添加新的消费者来修改系统的行为，而不会影响其他应用程序。我们还可以触发新的事件来构建新的流程，而不会影响现有应用程序。'
- en: '**L**: N/A'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**：N/A'
- en: '**I**: Instead of building a single system, EDA allows us to create multiple
    smaller systems that integrate through data contracts (events), and those contracts
    are the messaging interfaces of the system.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我**：不是构建一个单一的系统，EDA（电子设计自动化）允许我们创建多个较小的系统，这些系统通过数据合约（事件）进行集成，而这些合约是系统的消息接口。'
- en: '**D**: EDA enables systems to break tight coupling by depending on the events
    (interfaces/abstractions) instead of communicating directly with one another,
    inverting the dependency flow.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**：EDA通过依赖于事件（接口/抽象）而不是直接相互通信，从而实现了系统之间的紧密耦合的解耦，反转了依赖流。'
- en: EDA does not only come with advantages; it also has a few drawbacks that we
    explore in subsequent sections of the chapter.Next, we explore message queues
    followed by the Publish-Subscribe pattern, two ways of interacting with events.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: EDA不仅带来了优势；它也有一些缺点，我们将在本章后续部分进行探讨。接下来，我们将探讨消息队列，然后是发布-订阅模式，这两种与事件交互的方式。
- en: Getting started with message queues
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用消息队列
- en: A **message queue** is nothing more than a queue we leverage to send ordered
    messages. A queue works on a **First In, First Out** (**FIFO**) basis. If our
    application runs in a single process, we could use one or more `Queue<T>` instances
    to send messages between our components or a `ConcurrentQueue<T>` instance to
    send messages between threads. Moreover, queues can be managed by an independent
    program to send messages in a distributed fashion (between applications or microservices).A
    distributed message queue can add more or less features to the mix, especially
    for cloud programs that handle failures at more levels than a single server. One
    of those features is the **dead letter queue**, which stores messages that failed
    some criteria in another queue. For example, if the target queue is full, a message
    could be sent to the **dead letter queue** instead. One could requeue such messages
    by putting the message back at the end of the queue.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息队列**不过是一个我们用来发送有序消息的队列。队列按照**先进先出**（**FIFO**）的原则工作。如果我们的应用程序在一个单独的进程中运行，我们可以使用一个或多个`Queue<T>`实例在组件之间发送消息，或者使用`ConcurrentQueue<T>`实例在线程之间发送消息。此外，队列可以由一个独立的程序管理，以分布式的方式发送消息（在应用程序或微服务之间）。分布式消息队列可以添加更多或更少的特性到混合中，特别是对于处理比单个服务器更多级别的故障的云程序。其中一个特性是**死信队列**，它存储在另一个队列中未通过某些标准的消息。例如，如果目标队列已满，可以将消息发送到**死信队列**。可以通过将消息放回队列末尾来重新排队这些消息。'
- en: Beware that requeing messages change the order of the messages. If the order
    is important in your app, consider this.
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，重新排队消息会改变消息的顺序。如果顺序在您的应用程序中很重要，请考虑这一点。
- en: 'Many messaging queue protocols exist; some are proprietary, while others are
    open source. Some messaging queues are cloud-based and used *as a service*, such
    as Azure Service Bus and Amazon Simple Queue Service. Others are open source and
    can be deployed to the cloud or on-premises, such as Apache ActiveMQ.If you need
    to process messages in order and want each message to be delivered to a single
    recipient at a time, a **message queue** seems like the right choice. Otherwise,
    the **Publish-Subscribe** pattern could be a better fit for you.Here is a basic
    example that illustrates what we just discussed:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多消息队列协议；有些是专有的，而有些是开源的。一些消息队列是基于云的，作为服务使用，例如Azure Service Bus和Amazon Simple
    Queue Service。其他是开源的，可以部署到云或本地，例如Apache ActiveMQ。如果您需要按顺序处理消息，并且希望每次只将消息发送给单个接收者，那么**消息队列**似乎是正确的选择。否则，**发布-订阅**模式可能更适合您。以下是一个基本示例，说明了我们刚才讨论的内容：
- en: '![Figure 19.1: A publisher that enqueues a message with a subscriber that dequeues
    it](img/file128.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图19.1：一个将消息入队的发布者与一个出队的订阅者](img/file128.png)'
- en: 'Figure 19.1: A publisher that enqueues a message with a subscriber that dequeues
    it'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.1：一个将消息入队的发布者与一个出队的订阅者
- en: 'For a more concrete example, in a distributed user registration process, when
    a user registers, we could want to do the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了一个更具体的例子，在一个分布式用户注册过程中，当用户注册时，我们可能想要做以下事情：
- en: Send a confirmation email.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送确认邮件。
- en: Process their picture and save one or more thumbnails.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理他们的图片并保存一个或多个缩略图。
- en: Send an onboarding message to their in-app mailbox.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向他们的应用内邮箱发送欢迎信息。
- en: 'To sequentially achieve this, one operation after the other, we could do the
    following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了顺序地实现这一点，一个操作接一个操作，我们可以这样做：
- en: '![Figure 19.2: A process flow that sequentially executes three operations that
    happen after a user creates an account](img/file129.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图19.2：用户创建账户后按顺序执行三个操作的流程图](img/file129.png)'
- en: 'Figure 19.2: A process flow that sequentially executes three operations that
    happen after a user creates an account'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.2：用户创建账户后按顺序执行三个操作的流程图
- en: 'In this case, the user would not receive the *Onboarding Message* if the process
    crashes during the *Process Thumbnail* operation. Another drawback would be that
    to insert a new operation between the *Process Thumbnail* and *Send an onboarding
    message* steps, we’d have to modify the *Send an onboarding message* operation
    (tight coupling).If the order does not matter, we could queue all the messages
    from the *Auth Server* instead, right after the user’s creation, like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果处理缩略图操作期间进程崩溃，用户将不会收到**欢迎信息**。另一个缺点是，要在**处理缩略图**和**发送欢迎信息**步骤之间插入新的操作，我们必须修改**发送欢迎信息**操作（紧耦合）。如果顺序不重要，我们可以在用户创建后立即，像这样将所有来自**认证服务器**的消息排队：
- en: '![Figure 19.3: The Auth Server is queuing the operations sequentially while
    different processes execute them in parallel](img/file130.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图19.3：*认证服务器*正在按顺序排队操作，而不同的进程并行执行它们](img/file130.png)'
- en: 'Figure 19.3: The Auth Server is queuing the operations sequentially while different
    processes execute them in parallel'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.3：*认证服务器*正在按顺序排队操作，而不同的进程并行执行它们
- en: This process is better, but the *Auth Server* now controls what should happen
    once a new user has been created. The *Auth Server* was queuing an event in the
    previous workflow that told the system that a new user registered. However, now,
    it has to be aware of the post-processing workflow to queue each operation sequentially
    to enqueue the correct commands. Doing this is not wrong in itself and is easier
    to follow when you dig into the code, but it creates tighter coupling between
    the services where the *Auth Server* is aware of the external processes. Moreover,
    it packs too many responsibilities into the *Auth Server*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程更好，但现在*认证服务器*控制着一旦创建新用户后应该发生什么。在之前的流程中，*认证服务器*正在排队一个事件，告诉系统有新用户注册。然而，现在，它必须意识到后处理流程，以便按顺序排队每个操作以排队正确的命令。这样做本身并没有错，当你深入研究代码时，它更容易理解，但它会在*认证服务器*了解外部过程的各个服务之间创建更紧密的耦合。此外，它将太多的责任打包到*认证服务器*中。
- en: SRP-wise, why would an authentication/authorization server be responsible for
    anything other than authentication, authorization, and managing that data?
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从SRP（单一责任原则）的角度来看，为什么认证/授权服务器除了认证、授权和管理那些数据之外，还要负责其他任何事情？
- en: If we continue from there and want to add a new operation between two existing
    steps, we would only have to modify the *Auth Server*, which is less error-prone
    than the preceding workflow.If we want the best of both worlds, we could use the
    **Publish-Subscribe** pattern instead, which we cover next, and continue building
    on top of this example.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从那里继续并想在两个现有步骤之间添加一个新操作，我们只需修改*认证服务器*，这比先前的流程更不容易出错。如果我们想两者兼得，我们可以使用**发布-订阅**模式，我们将在下一节中介绍，并在此基础上继续构建。
- en: Conclusion
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: If you need messages to be delivered sequentially, a queue might be the right
    tool. The example we explored was destined to fail from the beginning, but it
    allowed us to explore the thinking process behind designing the system. Sometimes,
    the first idea is not the best and can be improved by exploring new ways of doing
    things or learning new skills. Being open-minded to the ideas of others can also
    lead to better solutions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要消息按顺序传递，队列可能是一个合适的工具。我们探索的例子从一开始就注定会失败，但它允许我们探索设计系统背后的思考过程。有时，第一个想法并不是最好的，可以通过探索新的做事方式或学习新技能来改进。对他人想法的开放心态也可能导致更好的解决方案。
- en: Sometimes, just speaking out loud makes our own brain solve the issue by itself.
    So explain the problem to someone and see what happens.
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有时候，只是大声说出来，我们自己的大脑就能自己解决问题。所以向某人解释问题，看看会发生什么。
- en: 'Message queues are amazing at buffering messages for high-demand scenarios
    where an application may not be able to handle spikes of traffic. In that case,
    the messages are enqueued so the application can catch up at its own speed, reading
    them sequentially.Implementing distributed message queues requires a lot of knowledge
    and effort and is not worth it for almost all scenarios. The big cloud providers
    like AWS and Azure offer fully managed message queue systems as a service. You
    can also look at **ActiveMQ**, **RabbitMQ**, or any **Advanced Message Queuing
    Protocol** (**AMQP**) broker.One essential aspect of choosing the right queue
    system is whether you are ready and have the skills to manage your own distributed
    message queue. Suppose you want to speed up development, cut infrastructure management
    costs, and have enough money. In that case, you could use a fully managed offering
    for at least your production environment, especially if you expect a large volume
    of messages. On the other hand, using a local or on-premise instance for development
    or smaller-scale usage may save you a considerable sum of money. Choosing an open
    source system with fully managed cloud offerings is a good way to achieve both:
    low local development cost with an always available high-performance cloud production
    offering that the service provider maintains for you.Another aspect is to base
    your choice on needs. Have clear requirements and ensure the system you choose
    does what you need. Some offerings cover multiple use cases like queues and pub-sub,
    leading to a simplified tech stack requiring fewer skills.Before moving to the
    pub-sub pattern, let’s see how message queues can help us follow the **SOLID**
    principles at the app scale:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 消息队列在为高需求场景缓冲消息方面非常出色，在这些场景中，应用程序可能无法处理流量峰值。在这种情况下，消息将被入队，以便应用程序可以以自己的速度赶上，按顺序读取它们。实现分布式消息队列需要大量的知识和努力，并且对于几乎所有场景来说都不值得。大型云提供商如AWS和Azure提供完全管理的消息队列系统作为服务。您还可以查看**ActiveMQ**、**RabbitMQ**或任何**高级消息队列协议**（**AMQP**）代理。选择正确的队列系统的一个基本方面是您是否准备好并具备管理自己的分布式消息队列的技能。假设您想加快开发速度，降低基础设施管理成本，并且有足够的资金。在这种情况下，您可以使用至少生产环境的完全管理服务，尤其是如果您预计会有大量消息。另一方面，使用本地或本地实例进行开发或较小规模的用途可能会节省您相当一部分资金。选择具有完全管理云提供的开源系统是实现这两者的好方法：低本地开发成本，以及始终可用的、性能始终如一的高性能云生产服务，服务提供商为您维护。另一个方面是，您的选择应基于需求。有明确的要求，并确保您选择的系统能够满足您的需求。一些服务涵盖了多个用例，如队列和发布-订阅，从而简化了技术堆栈，需要更少的技能。在转向发布-订阅模式之前，让我们看看消息队列如何帮助我们遵循**SOLID**原则在应用规模上：
- en: '**S**: Helps centralize and divide responsibilities between applications or
    components without them directly knowing each other, breaking tight coupling.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**: 帮助在应用程序或组件之间集中和分配责任，而无需它们直接相互了解，从而打破紧密耦合。'
- en: '**O**: Allows us to change the message producer’s or subscriber’s behaviors
    without the other knowing about it.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**: 允许我们更改消息生产者或订阅者的行为，而无需对方知道。'
- en: '**L**: N/A'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**: 无'
- en: '**I**: Each message and handler can be as small as needed, while each microservice
    indirectly interacts with the others to solve the bigger problem.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**: 每个消息和处理程序都可以小到所需的程度，而每个微服务则间接与其他微服务交互以解决更大的问题。'
- en: '**D**: By not knowing the other dependencies (breaking tight coupling between
    microservices), each microservice depends only on the messages (abstractions)
    instead of concretions (the other microservices API).'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**: 通过不知道其他依赖项（打破微服务之间的紧密耦合），每个微服务只依赖于消息（抽象）而不是具体实现（其他微服务的API）。'
- en: One drawback is the delay between enqueuing a message and processing a message.
    We talk about delay and latency in more detail in subsequent sections.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个缺点是消息入队和消息处理之间的延迟。我们将在后续章节中更详细地讨论延迟和延迟。
- en: Implementing the Publish-Subscribe pattern
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现发布-订阅模式
- en: The **Publish-Subscribe** pattern (Pub-Sub) is similar to what we did using
    **MediatR** and what we explored in the *Getting started with message queues*
    section. However, instead of sending one message to one handler (or enqueuing
    a message), we publish (send) a message (event) to zero or more subscribers (handlers).
    Moreover, the publisher is unaware of the subscribers; it only sends messages
    out, hoping for the best (also known as **fire and forget**).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**发布-订阅**（Publish-Subscribe）模式（Pub-Sub）类似于我们在使用 **MediatR** 和在 *开始使用消息队列* 部分中探索的内容。然而，我们不是向一个处理器（或入队一个消息）发送一个消息，而是向零个或多个订阅者（处理器）发布（发送）一个消息（事件）。此外，发布者对订阅者一无所知；它只发送消息，希望一切顺利（也称为
    **fire and forget**）。'
- en: Using a message queue does not mean you are limited to only one recipient.
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用消息队列并不意味着你只能限制于只有一个接收者。
- en: We can use **Publish-Subscribe** in-process or in a distributed system through
    a **message broker**. The message broker is responsible for delivering the messages
    to the subscribers. Using a message broker is the way to go for microservices
    and other distributed systems since they are not running in a single process.This
    pattern has many advantages over other ways of communication. For example, we
    could recreate the state of a database by replaying the events that happened in
    the system, leading to the **event sourcing** pattern. More on that later.The
    design depends on the technology used to deliver the messages and the system's
    configuration. For example, you could use **MQTT** to deliver messages to **Internet
    of Things** (**IoT**) devices and configure them to retain the last message sent
    on each topic. That way, when a device connects to a topic, it receives the latest
    message. You could also configure a **Kafka** broker that keeps a long history
    of messages and asks for all of them when a new system connects to it. All of
    that depends on your needs and requirements.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 **发布-订阅**（Publish-Subscribe）模式在进程内或分布式系统中通过 **消息代理**（message broker）来实现。消息代理负责将消息传递给订阅者。对于微服务和其他分布式系统来说，使用消息代理是最佳选择，因为它们不是在单个进程中运行的。这种模式与其他通信方式相比具有许多优势。例如，我们可以通过重放系统中发生的事件来重新创建数据库的状态，从而实现
    **事件溯源**（event sourcing）模式。关于这一点，我们稍后再详细讨论。设计取决于用于传递消息的技术和系统的配置。例如，你可以使用 **MQTT**
    将消息传递到 **物联网**（**IoT**）设备，并配置它们在每个主题上保留最后发送的消息。这样，当设备连接到主题时，它会收到最新的消息。你也可以配置一个保留大量消息历史的
    **Kafka** 代理，当新的系统连接到它时，它会请求所有这些消息。所有这些都取决于你的需求和需求。
- en: '**MQTT and Apache Kafka**'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**MQTT 和 Apache Kafka**'
- en: ''
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you were wondering what MQTT is, here is a quote from their website [https://adpg.link/mqtt](https://adpg.link/mqtt):'
  id: totrans-97
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你想知道 MQTT 是什么，这里是从他们的网站 [https://adpg.link/mqtt](https://adpg.link/mqtt) 上的引用：
- en: ''
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*“MQTT is an OASIS standard messaging protocol for the Internet of Things (IoT).
    It is designed as an extremely lightweight publish/subscribe messaging transport
    […]”*'
  id: totrans-99
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“MQTT 是一个 OASIS 标准，用于物联网 (IoT) 的消息协议。它被设计为一个极轻量级的发布/订阅消息传输 [...]”*'
- en: ''
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here is a quote from Apache Kafka’s website [https://adpg.link/kafka](https://adpg.link/kafka):'
  id: totrans-101
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '这里引用了 Apache Kafka 网站上的话 [https://adpg.link/kafka](https://adpg.link/kafka):'
- en: ''
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*“Apache Kafka is an open-source distributed event streaming platform […]”*'
  id: totrans-103
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“Apache Kafka 是一个开源的分布式事件流平台 [...]”*'
- en: 'We cannot cover every single scenario of every system that follows every protocol.
    Therefore, I’ll highlight some shared concepts behind the Pub-Sub design pattern
    so you know how to get started. Then, you can dig into the specific technology
    you want (or need) to use.A topic is a way to organize events, a channel, a place
    to read or write specific events so consumers know where to find them. As you
    can probably imagine, sending all events to the same place is like creating a
    relational database with a single table: it would be suboptimal and hard to manage,
    use, and evolve.To receive messages, subscribers must subscribe to topics (or
    the equivalent of a topic):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法涵盖遵循每个协议的每个系统的每个场景。因此，我将强调 Pub-Sub 设计模式背后的某些共享概念，以便你知道如何开始。然后，你可以深入研究你想要（或需要）使用的特定技术。主题是一种组织事件的方式，一个频道，一个读取或写入特定事件的地点，以便消费者知道在哪里找到它们。正如你可能想象的那样，将所有事件发送到同一个地方就像创建一个只有一个表的数据库关系型数据库：这将是不太理想的，难以管理、使用和演进。为了接收消息，订阅者必须订阅主题（或主题的等效物）：
- en: '![Figure 19.4: A subscriber subscribes to a pub-sub topic](img/file131.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 19.4：一个订阅者订阅了一个发布/订阅主题](img/file131.png)'
- en: 'Figure 19.4: A subscriber subscribes to a pub-sub topic'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.4：一个订阅者订阅了一个发布/订阅主题
- en: 'The second part of the Pub-Sub pattern is to publish messages, like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Pub-Sub 模式的第二部分是发布消息，如下所示：
- en: '![Figure 19.5: A publisher is sending a message to the message broker. The
    broker then forwards that message to N subscribers, where N can be zero or more](img/file132.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图19.5：发布者正在向消息代理发送消息。然后代理将此消息转发给N个订阅者，其中N可以是零个或更多](img/file132.png)'
- en: 'Figure 19.5: A publisher is sending a message to the message broker. The broker
    then forwards that message to *N* subscribers, where *N* can be zero or more'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.5：发布者正在向消息代理发送消息。然后代理将此消息转发给*N*个订阅者，其中*N*可以是零个或更多
- en: 'Many abstracted details here depend on the broker and the protocol. However,
    the following are the two primary concepts behind the Publish-Subscribe pattern:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里许多抽象的细节取决于代理和协议。然而，以下是基于发布-订阅模式的两个主要概念：
- en: Publishers publish messages to topics.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布者向主题发布消息。
- en: Subscribers subscribe to topics to receive messages when they are published.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅者订阅主题以在消息发布时接收消息。
- en: Security is a crucial implementation detail not illustrated here. Security is
    mandatory in most systems; not every subsystem or device should have access to
    all topics.
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 安全性是一个重要的实现细节，这里没有展示。在大多数系统中，安全性是强制性的；不是每个子系统或设备都应该有权访问所有主题。
- en: 'Publishers and subscribers could be any part of any system. For example, many
    Microsoft Azure services are publishers (for example, Blob storage). You can then
    have other Azure services (for example, Azure Functions) subscribe to those events
    and react to them.You can also use the **Publish-Subscribe** pattern inside your
    applications—there’s no need to use cloud resources for that; this can even be
    done inside the same process (we explore this in the next chapter).The most significant
    advantage of the Publish-Subscribe pattern is breaking tight coupling between
    systems. One system publishes events while others consume them without the systems
    knowing each other.That loose coupling leads to scalability, where each system
    can scale independently, and messages can be processed in parallel using the required
    resources. It is also easier to add new processes to a workflow since the systems
    are unaware of the others. To add a new process that reacts to an event, you only
    have to create a new microservice, deploy it, start to listen to one or more events,
    and process them.On the downside, the message broker can become the application’s
    single point of failure and must be configured appropriately. It is also essential
    to consider the best delivery policies for each message type. An example of a
    policy could be to ensure the delivery of crucial messages while delaying less
    time-sensitive messages and dropping unimportant messages during load surges.If
    we revisit our previous example using Publish-Subscribe, we end up with the following
    simplified workflow:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者和订阅者可以是任何系统的任何部分。例如，许多Microsoft Azure服务都是发布者（例如，Blob存储）。然后，您可以让其他Azure服务（例如，Azure
    Functions）订阅这些事件并对它们做出反应。您还可以在您的应用程序中使用**发布-订阅**模式——不需要使用云资源；这甚至可以在同一个进程中完成（我们将在下一章中探讨这一点）。发布-订阅模式最显著的优势是打破系统之间的紧密耦合。一个系统发布事件，而其他系统消费它们，而无需系统相互了解。这种松散的耦合导致可伸缩性，其中每个系统可以独立扩展，并且可以使用所需资源并行处理消息。由于系统对彼此一无所知，因此更容易将新流程添加到工作流中。要添加一个对新事件做出反应的新流程，您只需创建一个新的微服务，部署它，开始监听一个或多个事件，并处理它们。不利的一面是，消息代理可能成为应用程序的单点故障，必须适当地配置。还必须考虑每种消息类型最佳的分发策略。策略的一个例子可能是确保关键消息的传递，同时延迟不那么紧急的消息，并在负载激增期间丢弃不重要的消息。如果我们回顾一下之前使用发布-订阅的例子，我们最终得到以下简化的工作流程：
- en: '![Figure 19.6: The Auth Server is publishing an event representing the creation
    of a new user. The broker then forwards that message to the three subscribers,
    who then execute their tasks in parallel](img/file133.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图19.6：认证服务器正在发布一个表示创建新用户的事件的条目。然后代理将此消息转发给三个订阅者，他们随后并行执行他们的任务](img/file133.png)'
- en: 'Figure 19.6: The Auth Server is publishing an event representing the creation
    of a new user. The broker then forwards that message to the three subscribers,
    who then execute their tasks in parallel'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.6：认证服务器正在发布一个表示创建新用户的事件的条目。然后代理将此消息转发给三个订阅者，他们随后并行执行他们的任务
- en: 'Based on this workflow, we broke the tight coupling between the *Auth Server*
    and the post-registration process. The *Auth Server* is unaware of the workflow,
    and the individual services are unaware of each other. Moreover, if we want to
    add a new task, we only have to create or update a microservice that subscribes
    to the right topic (in this case, the “new user registered” topic).The current
    system does not support synchronization and does not handle process failures or
    retries, but it is a good start since we combine the pros of the message queue
    examples and leave the cons behind.Using an event broker inverts the dependency
    flow. The diagrams we explored show the message flow, but here’s what happens
    on the dependency sides of things:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个工作流程，我们打破了**认证服务器**和注册后流程之间的紧密耦合。**认证服务器**对工作流程一无所知，各个服务之间也互不关心。此外，如果我们想添加一个新任务，我们只需创建或更新一个订阅正确主题（在这种情况下，是“新用户注册”主题）的微服务。当前系统不支持同步，也不处理流程失败或重试，但这是一个良好的开端，因为我们结合了消息队列示例的优点，而将缺点留在了后面。使用事件代理反转了依赖流。我们探讨的图显示了消息流，但这里发生的是事物依赖方面的变化：
- en: '![Figure 19.7: A diagram representing the inverted dependency flow of using
    the pub-sub pattern](img/file134.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图19.7：一个表示使用发布-订阅模式反转依赖流的图](img/file134.png)'
- en: 'Figure 19.7: A diagram representing the inverted dependency flow of using the
    pub-sub pattern'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.7：一个表示使用发布-订阅模式反转依赖流的图
- en: 'Now that we have explored the Publish-Subscribe pattern, we look at message
    brokers, then dig deeper into EDA and leverage the Publish-Subscribe pattern to
    create a persistent database of events that can be replayed: the Event Sourcing
    pattern.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了发布-订阅模式，接下来我们看看消息代理，然后深入探讨事件驱动架构（EDA），并利用发布-订阅模式创建一个可重放的持久化事件数据库：事件溯源模式。
- en: Message brokers
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消息代理
- en: A message broker is a program that allows us to send (**publish**) and receive
    (**subscribe**) messages. It plays the mediator role at scale, allowing multiple
    applications to talk to each other without knowing each other (**loose coupling**).
    The message broker is usually the central piece of any event-based distributed
    system that implements the publish-subscribe pattern.An application (**publisher**)
    publishes messages to topics, while other applications (**subscribers**) receive
    messages from those topics. The notion of **topics** may differ from one protocol
    or system to another, but all systems I know have a topic-like concept to route
    messages to the right place. For example, you can publish to the `Devices` topic
    using Kafka, but to `devices/abc-123/do-something` using MQTT.How you name your
    topics depends significantly on the system you are using and the scale of your
    installation. For example, MQTT is a lightweight event broker recommending a path-like
    naming convention. On the other hand, Apache Kafka is a full-featured event broker
    and event streaming platform that is not opinionated about topic names, leaving
    you in charge of that. Depending on the scale of your implementation, you can
    use the entity name as the topic name or may need prefixes to identify who in
    the enterprise can interact with what part of the system. Due to the small scale
    of the examples in the chapter, we stick with simple topic names, making the examples
    easier to understand.The message broker is responsible for forwarding the messages
    to the registered recipients. The lifetime of those messages can vary by broker
    or even per individual message or topic.There are multiple message brokers out
    there using different protocols. Some brokers are cloud-based, such as Azure Event
    Grid. Other brokers are lightweight and more suited for IoT, such as Eclipse Mosquitto/MQTT.
    In contrast to MQTT, others are more robust and allow for high-velocity data streaming,
    such as Apache Kafka.What message broker to use should be based on the requirements
    of the software you are building. Moreover, you are not limited to one broker.
    Nothing stops you from picking a message broker that handles the dialogs between
    your microservices and using another to handle the dialogs with external IoT devices.
    If you are building a system in Azure, want to go serverless, or prefer paying
    for SaaS components that scale without investing maintenance time, you can leverage
    Azure services such as Event Grid, Service Bus, and Queue Storage. If you prefer
    open-source software, you can choose Apache Kafka and even run a fully managed
    cloud instance as a service using Confluent Cloud if you don’t want to manage
    your own cluster.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 消息代理是一种程序，它允许我们发送（**发布**）和接收（**订阅**）消息。它在规模上扮演着调解者的角色，使得多个应用程序能够相互通信而无需彼此了解（**松耦合**）。消息代理通常是任何实现发布-订阅模式的基于事件的分布式系统的核心组件。一个应用程序（**发布者**）将消息发布到主题，而其他应用程序（**订阅者**）则从这些主题接收消息。**主题**的概念可能因协议或系统而异，但我知道的所有系统都有一个类似主题的概念，用于将消息路由到正确的位置。例如，您可以使用Kafka将消息发布到`Devices`主题，但使用MQTT则发布到`devices/abc-123/do-something`。您如何命名主题在很大程度上取决于您所使用的系统和您安装的规模。例如，MQTT是一种轻量级的事件代理，推荐使用路径式命名约定。另一方面，Apache
    Kafka是一个功能齐全的事件代理和事件流平台，对主题名称没有固定看法，让您负责这一点。根据您实现的规模，您可以使用实体名称作为主题名称，或者可能需要前缀来识别企业中谁可以与系统的哪个部分交互。由于本章中示例的规模较小，我们坚持使用简单的主题名称，使示例更容易理解。消息代理负责将消息转发给已注册的接收者。这些消息的寿命可能因代理而异，甚至可能因单个消息或主题而异。市面上有多种使用不同协议的消息代理。一些代理是基于云的，如Azure
    Event Grid。其他代理轻量级且更适合物联网，如Eclipse Mosquitto/MQTT。与MQTT相比，其他代理更健壮，允许高速数据流，如Apache
    Kafka。您应该根据您正在构建的软件的需求来选择使用哪种消息代理。此外，您并不局限于一个代理。没有任何东西阻止您选择一个处理微服务之间对话的消息代理，同时使用另一个处理与外部物联网设备之间对话的代理。如果您在Azure上构建系统，希望无服务器化，或者更喜欢为可扩展的SaaS组件付费而不投入维护时间，您可以利用Azure服务，如Event
    Grid、Service Bus和Queue Storage。如果您更喜欢开源软件，您可以选择Apache Kafka，如果您不想管理自己的集群，甚至可以使用Confluent
    Cloud作为服务运行一个完全管理的云实例。
- en: The event sourcing pattern
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件溯源模式
- en: Now that we have explored the Publish-Subscribe pattern, learned what an event
    is, and talked about event brokers, it is time to explore **how to replay the
    state of an application**. To achieve this, we can follow the **event sourcing
    pattern**.The idea behind event sourcing is to **store a chronological list of
    events** instead of a single entity, where that collection of events becomes the
    source of truth. That way, every single operation is saved in the right order,
    helping with concurrency. Moreover, we could replay all of these events to generate
    an object’s current state in a new application, allowing us to deploy new microservices
    more easily.Instead of just storing the data, if the system propagates it using
    an event broker, other systems can cache some of it as one or more **materialized
    views**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了发布-订阅模式，了解了事件是什么，也讨论了事件代理，是时候探索**如何回放应用程序的状态**了。为了实现这一点，我们可以遵循**事件溯源模式**。事件溯源背后的理念是**存储一系列按时间顺序排列的事件**，而不是单个实体，其中这些事件的集合成为真相的来源。这样，每个单独的操作都按正确的顺序保存，有助于处理并发。此外，我们可以回放所有这些事件以生成新应用程序中对象的当前状态，使我们能够更容易地部署新的微服务。除了存储数据之外，如果系统使用事件代理传播它，其他系统可以将其缓存为一种或多种**物化视图**。
- en: A **materialized view** is a model created and stored for a specific purpose.
    The data can come from one or more sources, improving performance when querying
    that data. For example, the application returns the materialized view instead
    of querying multiple other systems to acquire the data. You can view the materialized
    view as a cached entity that a microservice stores in its own database.
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**物化视图**是为特定目的创建和存储的模型。数据可以来自一个或多个来源，在查询该数据时提高性能。例如，应用程序返回物化视图，而不是查询多个其他系统以获取数据。您可以将物化视图视为一个缓存的实体，微服务将其存储在其自己的数据库中。'
- en: One of the drawbacks of event sourcing is data consistency. There is an unavoidable
    delay between when a service adds an event to the store and when all the other
    services update their materialized views. We call this phenomenon **eventual consistency**.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源的一个缺点是数据一致性。当服务将事件添加到存储中时与所有其他服务更新其物化视图之间存在不可避免的延迟。我们称这种现象为**最终一致性**。
- en: '**Eventual consistency** means that the data will be consistent at some point
    in the future, but not outright. The delay can be from a few milliseconds to much
    longer, but the goal is to keep that delay as small as possible.'
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**最终一致性**意味着数据将在未来的某个时刻变得一致，但不是立即。延迟可能从几毫秒到更长的时间，但目标是尽可能减小这个延迟。'
- en: 'Another drawback is the complexity of creating such a system compared to a
    single application that queries a single database. Like the microservices architecture,
    event sourcing is not just rainbows and unicorns. It comes at a price: **operational
    complexity**.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺点是创建这样一个系统与查询单个数据库的单个应用程序相比的复杂性。像微服务架构一样，事件溯源不仅仅是彩虹和独角兽。它是有代价的：**操作复杂性**。
- en: 'In a microservices architecture, each piece is smaller, but gluing them together
    has a cost. For example, the infrastructure to support microservices is more complex
    than a monolith (one app and one database). The same goes for event sourcing;
    all applications must subscribe to one or more events, cache data (materialized
    view), publish events, and more. This **operational complexity** represents the
    shift of complexity from the application code to the operational infrastructure.
    In other words, it requires more work to deploy and maintain multiple microservices
    and databases and to fight the possible instability of network communication between
    those external systems than it does for a single application containing all of
    the code. Monoliths are simpler: they work or don’t; they rarely partially work.'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在微服务架构中，每个部分都更小，但将它们粘合在一起是有成本的。例如，支持微服务的基础设施比单体（一个应用程序和一个数据库）更复杂。对于事件溯源也是如此；所有应用程序都必须订阅一个或多个事件，缓存数据（物化视图），发布事件，等等。这种**操作复杂性**代表了复杂性从应用程序代码转移到操作基础设施的转变。换句话说，部署和维护多个微服务和数据库以及与这些外部系统之间可能的不稳定网络通信需要更多的工作，比包含所有代码的单个应用程序要多。单体更简单：要么工作，要么不工作；很少部分工作。
- en: A crucial aspect of event sourcing is appending new events to the store and
    never changing existing events (append-only). In a nutshell, microservices communicating
    using the Pub-Sub pattern publish events, subscribe to topics, and generate materialized
    views to serve their clients.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源的关键方面是将新事件追加到存储中，并且永远不更改现有事件（仅追加）。简而言之，使用 Pub-Sub 模式通信的微服务发布事件，订阅主题，并生成物化视图以服务其客户端。
- en: Example
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: 'Let’s explore an example of what could happen if we combine what we just studied.
    **Context**: We need to build a program that manages IoT devices. We begin by
    creating two microservices:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨一下如果我们结合我们刚刚学习的内容可能会发生什么的情况。**上下文**：我们需要构建一个管理物联网设备的程序。我们首先创建两个微服务：
- en: The `DeviceTwin` microservice handles an IoT device’s twin’s data (digital representation
    of the device).
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeviceTwin` 微服务处理物联网设备孪生的数据（设备的数字表示）。'
- en: The `Networking` microservice manages the networking-related information of
    IoT devices (how to reach a device).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Networking` 微服务管理物联网设备的网络相关信息（如何到达设备）。'
- en: 'As a visual reference, the final system could look as follows (we cover the
    `DeviceLocation` microservice later):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 作为视觉参考，最终系统可能看起来如下（我们稍后介绍 `DeviceLocation` 微服务）：
- en: '![Figure 19.8: Three microservices communicating using the Publish-Subscribe
    pattern](img/file135.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图 19.8：三个微服务使用发布-订阅模式进行通信](img/file135.png)'
- en: 'Figure 19.8: Three microservices communicating using the Publish-Subscribe
    pattern'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.8：三个微服务使用发布-订阅模式进行通信
- en: 'Here are the user interactions and the published events:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了用户交互和发布的事件：
- en: 'A user creates a twin in the system named Device 1\. The `DeviceTwin` microservice
    saves the data and publishes the `DeviceTwinCreated` event with the following
    payload:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户在系统中创建了一个名为 Device 1 的孪生体。`DeviceTwin` 微服务保存数据并发布以下负载的 `DeviceTwinCreated`
    事件：
- en: '[PRE0]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In parallel, the `Networking` microservice must know when a device is created,
    so it subscribed to the `DeviceTwinCreated` event. When a new device is created,
    the `Networking` microservice creates default networking information for that
    device in its database; the default is `unknown`. This way, the `Networking` microservice
    knows what devices exist or not:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，`Networking` 微服务必须知道何时创建设备，因此它订阅了 `DeviceTwinCreated` 事件。当创建新设备时，`Networking`
    微服务在其数据库中为该设备创建默认网络信息；默认为 `unknown`。这样，`Networking` 微服务就知道哪些设备存在或不存在：
- en: '![Figure 19.9: A workflow representing the creation of a device twin and its
    default networking information](img/file136.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图 19.9：表示创建设备孪生及其默认网络信息的流程](img/file136.png)'
- en: 'Figure 19.9: A workflow representing the creation of a device twin and its
    default networking information'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.9：表示创建设备孪生及其默认网络信息的流程
- en: 'A user then updates the networking information of that device and sets it to
    `MQTT`. The `Networking` microservice saves the data and publishes the `NetworkingInfoUpdated`
    event with the following payload:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户随后更新了该设备的网络信息，并将其设置为 `MQTT`。`Networking` 微服务保存数据并发布以下负载的 `NetworkingInfoUpdated`
    事件：
- en: '[PRE1]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is demonstrated by the following diagram:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下图表来演示：
- en: '![Figure 19.10: A workflow representing updating the networking type of a device](img/file137.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 19.10：表示更新设备网络类型的流程](img/file137.png)'
- en: 'Figure 19.10: A workflow representing updating the networking type of a device'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.10：表示更新设备网络类型的流程
- en: 'A user changes the device’s display name to `Kitchen Thermostat`, which is
    more relevant. The `DeviceTwin` microservice saves the data and publishes the
    `DeviceTwinUpdated` event with the following payload. The payload uses **JSON
    patch** to publish only the differences instead of the whole object (see the *Further
    reading* section for more information):'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户将设备的显示名称更改为 `Kitchen Thermostat`，这更相关。`DeviceTwin` 微服务保存数据并发布以下负载的 `DeviceTwinUpdated`
    事件。负载使用 **JSON 补丁**来发布仅有的差异而不是整个对象（有关更多信息，请参阅 *进一步阅读* 部分）：
- en: '[PRE2]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following diagram demonstrates this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了这一点：
- en: '![Figure 19.11: A workflow representing a user updating the name of the device
    to Kitchen Thermostat](img/file138.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 19.11：表示用户将设备名称更新为 Kitchen Thermostat 的流程](img/file138.png)'
- en: 'Figure 19.11: A workflow representing a user updating the name of the device
    to Kitchen Thermostat'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.11：表示用户将设备名称更新为 Kitchen Thermostat 的流程
- en: 'From there, let’s say another team designed and built a new microservice that
    organizes the devices at physical locations. This new `DeviceLocation` microservice
    allows users to visualize their devices’ location on a map, such as a map of their
    house.The `DeviceLocation` microservice subscribes to all three events to manage
    its materialized view, like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，假设另一个团队设计并构建了一个新的微服务，该服务组织物理位置的设备。这个新的 `DeviceLocation` 微服务允许用户在地图上可视化他们的设备位置，例如他们的家中的地图。《DeviceLocation》微服务订阅所有三个事件来管理其物化视图，如下所示：
- en: When receiving a `DeviceTwinCreated` event, it saves its unique identifier and
    display name.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当接收到一个 `DeviceTwinCreated` 事件时，它会保存其唯一标识符和显示名称。
- en: When receiving a `NetworkingInfoUpdated` event, it saves the communication type.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当接收到一个 `NetworkingInfoUpdated` 事件时，它会保存通信类型。
- en: When receiving a `DeviceTwinUpdated` event, it updates the device’s display
    name.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当接收到一个 `DeviceTwinUpdated` 事件时，它会更新设备的显示名称。
- en: 'When the service is deployed for the first time, it replays all events from
    the beginning (**event sourcing**); here is what happens:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务首次部署时，它会从开始处重新播放所有事件（**事件溯源**）；以下是发生的情况：
- en: '`DeviceLocation` receives the `DeviceTwinCreated` event and creates the following
    model for that object:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 《DeviceLocation》接收到 `DeviceTwinCreated` 事件并为该对象创建以下模型：
- en: '[PRE3]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following diagram demonstrates this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了这一点：
- en: '![Figure 19.12: The DeviceLocation microservice replaying the DeviceTwinCreated
    event to create its materialized view of the device twin](img/file139.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图 19.12：DeviceLocation 微服务重新播放 DeviceTwinCreated 事件以创建其设备孪生的物化视图](img/file139.png)'
- en: 'Figure 19.12: The DeviceLocation microservice replaying the DeviceTwinCreated
    event to create its materialized view of the device twin'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.12：DeviceLocation 微服务重新播放 DeviceTwinCreated 事件以创建其设备孪生的物化视图
- en: 'The `DeviceLocation` microservice receives the `NetworkingInfoUpdated` event,
    which updates the networking type to `MQTT`, leading to the following:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 《DeviceLocation》微服务接收到 `NetworkingInfoUpdated` 事件，该事件将网络类型更新为 `MQTT`，导致以下结果：
- en: '[PRE4]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following diagram demonstrates this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了这一点：
- en: '![Figure 19.13: The DeviceLocation microservice replaying the NetworkingInfoUpdated
    event to update its materialized view of the device twin](img/file140.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 19.13：DeviceLocation 微服务重新播放 NetworkingInfoUpdated 事件以更新其设备孪生的物化视图](img/file140.png)'
- en: 'Figure 19.13: The DeviceLocation microservice replaying the NetworkingInfoUpdated
    event to update its materialized view of the device twin'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.13：DeviceLocation 微服务重新播放 NetworkingInfoUpdated 事件以更新其设备孪生的物化视图
- en: 'The `DeviceLocation` microservice receives the `DeviceTwinUpdated` event, updating
    the device’s name. The final model looks like this:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 《DeviceLocation》微服务接收到 `DeviceTwinUpdated` 事件，更新设备的名称。最终的模型如下所示：
- en: '[PRE5]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following diagram demonstrates this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了这一点：
- en: '![Figure 19.14: The DeviceLocation microservice replaying the DeviceTwinUpdated
    event to update its materialized view of the device twin](img/file141.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 19.14：DeviceLocation 微服务重新播放 DeviceTwinUpdated 事件以更新其设备孪生的物化视图](img/file141.png)'
- en: 'Figure 19.14: The DeviceLocation microservice replaying the DeviceTwinUpdated
    event to update its materialized view of the device twin'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.14：DeviceLocation 微服务重新播放 DeviceTwinUpdated 事件以更新其设备孪生的物化视图
- en: 'From there, the `DeviceLocation` microservice is initialized and ready. Users
    could set the kitchen thermostat’s location on the map or continue using the other
    microservices. When a user queries the `DeviceLocation` microservice for information
    about `Kitchen Thermostat`, it displays the **materialized view**, which contains
    all the required information without sending external requests.With that in mind,
    we could spawn new instances of the `DeviceLocation` microservice or other microservices,
    and they could generate their materialized views from past events—all of that
    with very limited to no knowledge of other microservices. In this type of architecture,
    a microservice can only know about events, not the other microservices. How a
    microservice handles events should be relevant only to that microservice, never
    to the others. The same applies to both publishers and subscribers.This example
    illustrates the event sourcing pattern, integration events, the materialized view,
    the use of a message broker, and the Publish-Subscribe pattern.In contrast, using
    direct communication (HTTP, gRPC, and so on) would look like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，`DeviceLocation` 微服务被初始化并准备就绪。用户可以在地图上设置厨房恒温器的位置或继续使用其他微服务。当用户查询 `DeviceLocation`
    微服务以获取 `Kitchen Thermostat` 的信息时，它显示 **物化视图**，其中包含所有所需信息，而无需发送外部请求。考虑到这一点，我们可以生成
    `DeviceLocation` 微服务或其他微服务的新实例，它们可以从过去的事件中生成它们的物化视图——所有这些都可以在非常有限或没有其他微服务的知识的情况下完成。在这种类型的架构中，微服务只能了解事件，而不能了解其他微服务。微服务处理事件的方式应该只与该微服务相关，而永远不要与其他微服务相关。这一点同样适用于发布者和订阅者。这个例子说明了事件源模式、集成事件、物化视图、消息代理的使用以及发布-订阅模式。相比之下，使用直接通信（HTTP、gRPC
    等）将看起来像这样：
- en: '![Figure 19.15: Three microservices communicating directly with one another](img/file142.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 19.15：三个微服务直接相互通信](img/file142.png)'
- en: 'Figure 19.15: Three microservices communicating directly with one another'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.15：三个微服务直接相互通信
- en: 'If we compare both approaches by looking at the first diagram (*Figure 16.7*),
    we can see that the message broker plays the role of a **mediator** and breaks
    the direct coupling between the microservices. By looking at the preceding diagram
    (*Figure 16.14*), we can see the tight coupling between the microservices, where
    the `DeviceLocation` microservice would need to interact with the `DeviceTwin`
    and `Networking` microservices directly to build the equivalent of its materialized
    view. Furthermore, the `DeviceLocation` microservice translates one interaction
    into three since the `Networking` microservice also talks to the `DeviceTwin`
    microservice, leading to indirect tight coupling between microservices, which
    can negatively impact performance.Suppose eventual consistency is not an option,
    or the Publish-Subscribe pattern cannot be applied or could be too hard to apply
    to your scenario. In this case, microservices can directly call each other. They
    can achieve this using HTTP, gRPC, or any other means that best suits that particular
    system’s needs.I won’t be covering this topic in this book, but one thing to be
    careful of when calling microservices directly is the indirect call chain that
    could bubble up fast. You don’t want your microservices to create a super deep
    call chain, or your system will likely become very slow. Here is an abstract example
    of what could happen to illustrate what I mean:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过查看第一个图（*图 16.7*）来比较这两种方法，我们可以看到消息代理扮演着 **调解者** 的角色，并打破了微服务之间的直接耦合。通过查看前面的图（*图
    16.14*），我们可以看到微服务之间的紧密耦合，其中 `DeviceLocation` 微服务需要直接与 `DeviceTwin` 和 `Networking`
    微服务交互，以构建其物化视图的等效物。此外，`DeviceLocation` 微服务将一次交互转换为三次，因为 `Networking` 微服务也与其他的
    `DeviceTwin` 微服务进行通信，导致微服务之间的间接紧密耦合，这可能会对性能产生负面影响。假设最终一致性不是一个选项，或者发布-订阅模式不能应用于您的场景，或者应用起来可能过于困难。在这种情况下，微服务可以直接相互调用。它们可以使用
    HTTP、gRPC 或任何最适合该特定系统需求的任何其他方式来实现。我不会在本书中涵盖这个主题，但直接调用微服务时需要注意的一点是可能会迅速冒泡的间接调用链。您不希望您的微服务创建一个超级深的调用链，否则您的系统可能会变得非常慢。以下是一个抽象示例，说明可能会发生什么，以说明我的意思：
- en: '![Figure 19.16: A user calling microservice A, which then triggers a chain
    reaction of subsequent calls, leading to disastrous performance](img/file143.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 19.16：用户调用微服务 A，这随后引发了一系列后续调用，导致性能灾难](img/file143.png)'
- en: 'Figure 19.16: A user calling microservice A, which then triggers a chain reaction
    of subsequent calls, leading to disastrous performance'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.16：一个用户调用微服务A，然后触发一系列后续调用，导致灾难性的性能
- en: 'In terms of the preceding diagram, let’s think about failures (for one). If
    microservice C goes offline, the whole request ends with an error. No matter the
    measures we put in place to mitigate the risks, if microservice C cannot recover,
    the system will remain down; goodbye to microservices’ promise of independence.
    Another issue is latency: ten calls are made for a single operation; that takes
    time.Such chatty systems have most likely emerged from an incorrect domain modeling
    phase, leading to multiple microservices working together to handle trivial tasks.
    Now think of *Figure 16.15* but with 500 microservices instead of 6\. That could
    be catastrophic!This type of interdependent microservices system is known as the
    **Death Star anti-pattern**. We can see the Death Star anti-pattern as a *distributed
    big ball of mud*. One way to avoid such pitfalls is to ensure that the bounded
    contexts are well segregated and that responsibilities are well distributed. A
    good domain model should allow you to avoid building a Death Star and create the
    “most correct” system possible instead. No matter the type of architecture you
    choose, if you are not building the right thing, you may end up with a big ball
    of mud or a Death Star. Of course, the Pub-Sub pattern and EDA can help us break
    the tight coupling between microservices to avoid such issues.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的图示，让我们思考一下失败的情况（以一个为例）。如果微服务C离线，整个请求将以错误结束。无论我们采取什么措施来减轻风险，如果微服务C无法恢复，系统将保持故障状态；微服务的独立性承诺就此破灭。另一个问题是延迟：对一个单一操作就需要进行十个调用；这需要时间。这种健谈的系统很可能源于错误的领域建模阶段，导致多个微服务共同处理琐碎的任务。现在想象一下*图16.15*，但用500个微服务代替6个。那可能是灾难性的！这种相互依赖的微服务系统被称为**死亡之星反模式**。我们可以将死亡之星反模式视为一个*分布式的大泥球*。避免这种陷阱的一种方法是确保边界上下文得到良好的隔离，并且责任得到良好的分配。一个好的领域模型应该允许你避免构建死亡之星，并创建“最正确”的系统。无论你选择哪种类型的架构，如果你没有构建正确的东西，你可能会得到一个大泥球或死亡之星。当然，发布/订阅模式和事件驱动架构可以帮助我们打破微服务之间的紧密耦合，避免此类问题。
- en: Conclusion
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'The Publish-Subscribe pattern uses events to break tight coupling between parts
    of an application. In a microservices architecture, we can use a message broker
    and integration events to allow microservices to talk to each other indirectly.
    The different pieces are now coupled with the data contract representing the event
    (its schema) instead of each other, leading to a potential gain in flexibility.
    One risk of this type of architecture is breaking events’ consumers by publishing
    breaking changes in the event’s format without letting them know or without having
    events versioning in place so they can adapt to the changes. Therefore, it is
    critical to think about event schema evolutions thoroughly. Most systems evolve,
    as will events, but since schemas are the glue between systems in a Publish-Subscribe
    model, it is essential to treat them as such. Some brokers, like Apache Kafka,
    offer a schema store and other mechanisms to help with these; some don’t.Then,
    we can leverage the event sourcing pattern to persist those events, allowing new
    microservices to populate their databases by replaying past events. The event
    store then becomes the source of truth of those systems. Event sourcing can also
    become very handy for tracing and auditing purposes since the whole history is
    persisted. We can also replay messages to recreate the system’s state at any given
    point in time, making it very powerful for debugging purposes. The storage size
    requirement for the event store is something to consider before going down the
    event sourcing path. The event store could grow quite large because we have been
    keeping all messages since the beginning of time and could grow fast based on
    the number of events sent. You could compact the history to reduce the data size
    but lose part of the history. Once again, you must decide based on the requirements
    and ask yourself the appropriate questions. For example, is it acceptable to lose
    part of the history? How long should we keep the data? Do we want to keep the
    original data in cheaper storage if we need it later? Do we even need replaying
    capabilities? Can we afford to keep all the data forever? What are the data retention
    policies or regulations the system must follow? Craft your list of questions based
    on the specific business problem you want to solve. This advice applies to all
    aspects of software engineering: clearly define the business problem first, then
    find how to fix it. Such patterns can be compelling but take time to learn and
    implement. Like message queues, cloud providers offer fully managed brokers as
    a service. Those can be faster to get started with than building and maintaining
    your own infrastructure. If building servers is your thing, you can use open-source
    software to “economically” build your stack or pay for managed instances of such
    software to save yourself the trouble. The same tips as with message queues apply
    here; for example, you can leverage a managed service for your production environment
    and a local version on the developer’s machine.Apache Kafka is one of the most
    popular event brokers that enables advanced functionalities like event streaming.
    Kafka has partially and fully managed cloud offerings like Confluent Cloud. Redis
    Pub/Sub is another open-source project with fully managed cloud offerings. Redis
    is also a key-value store trendy for distributed caching scenarios. Other offerings
    are (but are not limited to) Solace PubSub+, RabbitMQ, and ActiveMQ. Once again,
    I suggest comparing the offerings with your requirements to make the best choice
    for your scenarios.Now, let’s see how the Publish-Subscribe pattern can help us
    follow the **SOLID** principles at cloud-scale:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 发布-订阅模式使用事件来打破应用程序各部分之间的紧密耦合。在微服务架构中，我们可以使用消息代理和集成事件，允许微服务间接地相互通信。现在，不同的部分通过表示事件的（其模式）数据合约而不是彼此耦合，这可能导致灵活性的潜在提升。这种类型架构的一个风险是，通过在不通知它们或没有事件版本控制的情况下发布事件格式的破坏性更改，从而破坏事件的消费者。因此，彻底思考事件模式演变至关重要。大多数系统都会发展，事件也是如此，但因为在发布-订阅模型中，模式是系统之间的粘合剂，所以必须将其视为此类。一些代理，如Apache
    Kafka，提供模式存储和其他机制来帮助这些；一些则没有。然后，我们可以利用事件源模式来持久化这些事件，允许新的微服务通过重放过去的事件来填充其数据库。事件存储随后成为这些系统的真相来源。事件源对于跟踪和审计目的也非常有用，因为整个历史都被持久化了。我们还可以重放消息以在任何给定时间点重新创建系统的状态，这使得它在调试目的上非常强大。在开始事件源路径之前，必须考虑事件存储的存储大小需求。事件存储可能会非常大，因为我们一直在从时间开始就保留所有消息，并且可以根据发送的事件数量快速增长。你可以压缩历史记录以减少数据大小，但会丢失部分历史记录。再次强调，你必须根据需求做出决定，并问自己适当的问题。例如，是否可以接受丢失部分历史记录？我们应该保留数据多长时间？如果我们以后需要，是否希望以更便宜的价格存储原始数据？我们甚至需要重放功能吗？我们能否负担得起永远保留所有数据？系统必须遵循的数据保留策略或法规是什么？根据你想要解决的特定业务问题，制定你的问题清单。此建议适用于软件工程的各个方面：首先明确业务问题，然后找到解决问题的方法。这些模式可能很有吸引力，但学习和实施需要时间。像消息队列一样，云提供商提供完全管理的代理作为服务。这些服务可能比构建和维护自己的基础设施更快地开始。如果你喜欢构建服务器，你可以使用开源软件“经济”地构建你的堆栈，或者支付此类软件的托管实例以节省麻烦。与消息队列相同的提示也适用于此处；例如，你可以利用托管服务来处理生产环境，并在开发人员的机器上使用本地版本。Apache
    Kafka是最受欢迎的事件代理之一，它提供了高级功能，如事件流。Kafka提供了部分和完全管理的云服务，如Confluent Cloud。Redis Pub/Sub是另一个具有完全管理云服务的开源项目。Redis也是一个流行的键值存储，适用于分布式缓存场景。其他服务（但不限于）包括Solace
    PubSub+、RabbitMQ和ActiveMQ。再次建议，将服务与你的需求进行比较，以在你的场景中做出最佳选择。现在，让我们看看发布-订阅模式如何帮助我们遵循**SOLID**原则在云规模上：
- en: '**S**: Helps centralize and divide responsibilities between applications or
    components without them directly knowing each other, breaking tight coupling.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**：有助于在应用程序或组件之间集中和划分责任，而它们无需直接了解彼此，从而打破紧密耦合。'
- en: '**O**: Allows us to change how publishers and subscribers behave without directly
    impacting the other microservices (breaking tight coupling between them).'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**：允许我们改变发布者和订阅者的行为，而不会直接影响其他微服务（打破它们之间的紧密耦合）。'
- en: '**L**: N/A'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**：N/A'
- en: '**I**: Each event can be as small as needed, leading to multiple smaller communication
    interfaces (data contracts).'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**：每个事件可以小到所需的程度，导致多个较小的通信接口（数据合同）。'
- en: '**D**: The microservices depend on events (abstractions) instead of concretions
    (the other microservices), breaking tight coupling between them and inverting
    the dependency flow.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**：微服务依赖于事件（抽象）而不是具体实现（其他微服务），这打破了它们之间的紧密耦合，并反转了依赖关系流。'
- en: 'As you may have noticed, pub-sub is very similar to message queues. The main
    difference is the way messages are read and dispatched:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，发布/订阅（pub-sub）与消息队列非常相似。主要区别在于消息的读取和分发方式：
- en: 'Queues: Messages are pulled one at a time, consumed by one service, and then
    disappear.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列：消息一次一个地被拉取，由一个服务消费，然后消失。
- en: 'Pub-Sub: Messages are read in order and sent to all consumers instead of to
    only one, like with queues.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布/订阅（Pub-Sub）：消息按顺序读取，并发送给所有消费者，而不是像队列那样只发送给一个。
- en: I intentionally kept the **Observer design pattern** out of this book since
    we rarely need it in .NET. C# offers multicast events, which are well-versed in
    replacing the Observer pattern (in most cases). If you don’t know the Observer
    pattern, don’t worry–chances are, you will never need it. Nevertheless, if you
    already know the Observer pattern, here are the differences between it and the
    Pub-Sub pattern.
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我故意将**观察者设计模式**排除在这本书之外，因为我们很少在.NET中使用它。C# 提供了多播事件，这些事件在大多数情况下可以很好地替代观察者模式。如果你不知道观察者模式，不要担心——可能性很大，你永远不会需要它。不过，如果你已经知道观察者模式，这里有一些它与发布/订阅模式之间的区别。
- en: ''
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the Observer pattern, the subject keeps a list of its observers, creating
    direct knowledge of their existence. Concrete observers also often know about
    the subject, leading to even more knowledge of other entities and more coupling.
  id: totrans-193
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在观察者模式中，主题保持其观察者的列表，从而直接了解它们的存在。具体的观察者也经常了解主题，导致对其他实体的更多了解和更多耦合。
- en: ''
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the Pub-Sub pattern, the publisher is not aware of the subscribers; it is
    only aware of the message broker. The subscribers are not aware of the publishers
    either, only of the message broker. The publishers and subscribers are linked
    only through the data contract of the messages they publish or receive.
  id: totrans-195
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在发布/订阅模式中，发布者不知道订阅者；它只知道消息代理。订阅者也不知道发布者，只知道消息代理。发布者和订阅者仅通过它们发布或接收的消息的数据合同相连接。
- en: ''
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We could view the Pub-Sub pattern as the distributed evolution of the Observer
    pattern or, more precisely, like adding a mediator to the Observer pattern.
  id: totrans-197
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们可以将发布/订阅模式视为观察者模式的分布式演变，或者更确切地说，就像在观察者模式中添加一个中介。
- en: 'Next, we explore some patterns that directly call other microservices by visiting
    a new kind of **Façade**: the **Gateway**.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨一些直接通过访问一种新的**外观**（Façade）——网关——来调用其他微服务的模式。
- en: Introducing Gateway patterns
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入网关模式
- en: 'When building a microservices-oriented system, the number of services grows
    with the number of features; the bigger the system, the more microservices you
    have.When you think about a user interface that has to interact with such a system,
    this can become tedious, complex, and inefficient (dev-wise and speed-wise). Gateways
    can help us achieve the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建面向微服务的系统时，服务的数量随着功能的数量增长；系统越大，微服务的数量就越多。当你考虑一个必须与这种系统交互的用户界面时，这可能会变得繁琐、复杂和低效（从开发和速度的角度来看）。网关可以帮助我们实现以下目标：
- en: Hide complexity by routing requests to the appropriate services.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将请求路由到适当的服务来隐藏复杂性。
- en: Hide complexity by aggregating responses and translating one external request
    into many internal ones.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过聚合响应并将一个外部请求翻译成多个内部请求来隐藏复杂性。
- en: Hide complexity by exposing only the subset of features that a client needs.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过仅暴露客户端需要的功能子集来隐藏复杂性。
- en: Translate a request into another protocol.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将请求翻译成另一种协议。
- en: A gateway can also centralize different processes, such as logging and caching
    requests, authenticating and authorizing users and clients, enforcing request
    rate limits, and other similar policies.You can see gateways as façades, but instead
    of being a class in a program, it is a program of its own, shielding other programs.
    There are multiple variants of the Gateway pattern, and we explore many of them
    here.Regardless of the type of gateway you need, you can code it yourself or leverage
    existing tools to speed up the development process.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 网关还可以集中管理不同的流程，例如日志记录和缓存请求、验证和授权用户和客户端、实施请求速率限制以及其他类似策略。您可以将网关视为门面，但它不是程序中的一个类，而是一个独立的程序，保护其他程序。网关模式有多种变体，我们在这里探讨了其中许多。无论您需要哪种类型的网关，您都可以自己编写代码，或者利用现有工具来加速开发过程。
- en: Beware that there is a strong chance that your homemade gateway version 1.0
    has more flaws than a proven solution. This tip is not only applicable to gateways
    but to most complex systems. That being said, sometimes, no proven solution does
    exactly what we want, and we have to code it ourselves, which is where the real
    fun begins!
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请注意，您的自建网关版本 1.0 可能比经过验证的解决方案存在更多缺陷。这个提示不仅适用于网关，也适用于大多数复杂系统。话虽如此，有时没有经过验证的解决方案能完全满足我们的需求，我们必须自己编写代码，这就是真正的乐趣所在！
- en: An open-source project that could help you out is Ocelot ([https://adpg.link/UwiY](https://adpg.link/UwiY)).
    It is an API gateway written in C# that supports many things that we expect from
    a gateway. You can route requests using configuration or write custom code to
    create advanced routing rules. Since it is open source, you can contribute to
    it, fork it, and explore the source code if necessary.If you want a managed offering
    with a long list of features, you can explore Azure API Management ([https://adpg.link/8CEX](https://adpg.link/8CEX)).
    It supports security, load-balancing, routing, and more. It also offers a service
    catalog where teams can consult and manage the APIs with internal teams, partners,
    and customers.We can see a gateway as a **reverse proxy** that offers advanced
    functionalities. A Gateway fetches the information clients request, which can
    come from one or more resources, possibly from one or more servers. A reverse
    proxy usually routes a request to only one server. A reverse proxy often serves
    as a load balancer. Microsoft released a reverse proxy named YARP, written in
    C# and open-source ([https://adpg.link/YARP](https://adpg.link/YARP)). Microsoft
    built it for their internal teams. YARP is now part of Azure App Service ([https://adpg.link/7eu4](https://adpg.link/7eu4)).
    If YARP does what you need, it seems like a stable enough product to invest in
    that will evolve and be maintained over time. A significant advantage of such
    a service is the ability to deploy it with your application, optionally as a container,
    allowing us to use it locally during development.Now, let’s explore a few types
    of gateways.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能帮助到您的开源项目是 Ocelot ([https://adpg.link/UwiY](https://adpg.link/UwiY))。它是一个用
    C# 编写的 API 网关，支持我们从网关期望的许多功能。您可以使用配置来路由请求，或者编写自定义代码来创建高级路由规则。由于它是开源的，您可以对其进行贡献、分叉，并在必要时探索源代码。如果您想要一个具有长列表功能的托管服务，您可以探索
    Azure API Management ([https://adpg.link/8CEX](https://adpg.link/8CEX))。它支持安全性、负载均衡、路由等。它还提供了一个服务目录，团队可以在此咨询和管理与内部团队、合作伙伴和客户的
    API。我们可以将网关视为提供高级功能的**反向代理**。网关检索客户端请求的信息，这些信息可能来自一个或多个资源，可能来自一个或多个服务器。反向代理通常只将请求路由到一台服务器。反向代理通常充当负载均衡器。微软发布了一个名为
    YARP 的反向代理，用 C# 编写且为开源项目 ([https://adpg.link/YARP](https://adpg.link/YARP))。微软为他们的内部团队构建了它。现在，YARP
    是 Azure App Service 的一部分 ([https://adpg.link/7eu4](https://adpg.link/7eu4))。如果
    YARP 满足您的需求，它似乎是一个足够稳定的投资产品，随着时间的推移将发展和维护。此类服务的显著优势是能够与您的应用程序一起部署，可选地作为容器，允许我们在开发期间本地使用它。现在，让我们探索几种网关类型。
- en: Gateway Routing pattern
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网关路由模式
- en: 'We can use this pattern to hide the complexity of our system by having the
    gateway route requests to the appropriate services.For example, let’s say we have
    two microservices: one that holds our device data and another that manages device
    locations. We want to show the latest known location of a specific device (`id=102`)
    and display its name and model.To achieve that, a user requests the web page,
    and then the web page calls two services (see the following diagram). The `DeviceTwin`
    microservice is accessible from `service1.domain.com`, and the `Location` microservice
    is accessible from `service2.domain.com`. From there, the web application must
    track the two services, their domain name, and their operations. The UI has to
    handle more complexity as we add more microservices. Moreover, if we decide to
    change `service1` to `device-twins` and `service2` to `location`, we’d also need
    to update the web application. If there is only a UI, it is still not so bad,
    but if we have multiple user interfaces, each has to handle that complexity.Furthermore,
    if we want to hide the microservices inside a private network, it would be impossible
    unless all the user interfaces are also part of that private network (which exposes
    it). Here’s the diagram representing the interactions mentioned previously:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过让网关路由请求到适当的服务来使用这种模式来隐藏我们系统的复杂性。例如，假设我们有两个微服务：一个存储我们的设备数据，另一个管理设备位置。我们想显示特定设备（`id=102`）的最新已知位置，并显示其名称和型号。为了实现这一点，用户请求网页，然后网页调用两个服务（见以下图示）。`DeviceTwin`
    微服务可通过 `service1.domain.com` 访问，而 `Location` 微服务可通过 `service2.domain.com` 访问。从那里，Web
    应用程序必须跟踪这两个服务、它们的域名和它们的操作。随着我们添加更多的微服务，UI 必须处理更多的复杂性。此外，如果我们决定将 `service1` 改为
    `device-twins`，将 `service2` 改为 `location`，我们还需要更新 Web 应用程序。如果只有一个 UI，那还算不错，但如果我们有多个用户界面，每个界面都必须处理这种复杂性。此外，如果我们想在私有网络内隐藏微服务，除非所有用户界面也都是该私有网络的一部分（这会暴露它），否则将不可能实现。以下是表示之前提到的交互的图示：
- en: '![Figure 19.17: A web application and a mobile app that are calling two microservices
    directly](img/file144.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图19.17：直接调用两个微服务的Web应用程序和移动应用程序](img/file144.png)'
- en: 'Figure 19.17: A web application and a mobile app that are calling two microservices
    directly'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.17：直接调用两个微服务的Web应用程序和移动应用程序
- en: 'We can implement a gateway that does the routing for us to fix some of these
    issues. That way, instead of knowing what services are accessible through what
    sub-domain, the UI only has to know the gateway:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实施一个网关来为我们解决这些问题进行路由。这样，UI 只需要知道网关，而不是知道通过什么子域名可以访问哪些服务：
- en: '![Figure 19.18: A web application and a mobile app that are calling two microservices
    through a gateway application](img/file145.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图19.18：通过网关应用程序调用两个微服务的Web应用程序和移动应用程序](img/file145.png)'
- en: 'Figure 19.18: A web application and a mobile app that are calling two microservices
    through a gateway application'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.18：通过网关应用程序调用两个微服务的Web应用程序和移动应用程序
- en: 'Of course, this brings some possible issues to the table as the gateway becomes
    a single point of failure. We could consider using a load balancer to ensure we
    have strong enough availability and fast enough performance. Since all requests
    pass through the gateway, we may also need to scale it up at some point.We should
    also ensure the gateway supports failure by implementing different resiliency
    patterns, such as **Retry** and **Circuit Breaker**. The chances that an error
    will occur on the other side of the gateway increase with the number of microservices
    you deploy and the number of requests sent to those microservices.You can also
    use a routing gateway to reroute the URI to create easier-to-use URI patterns.
    You can also reroute ports; add, update, or remove HTTP headers; and more. Let’s
    explore the same example but using different URIs. Let’s assume the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这会带来一些可能的问题，因为网关成为了一个单点故障。我们可以考虑使用负载均衡器来确保我们有足够的可用性和快速的性能。由于所有请求都通过网关传递，我们可能还需要在某个时候对其进行扩展。我们还应该确保网关支持故障，通过实现不同的弹性模式，如**重试**和**断路器**。随着你部署的微服务数量和发送到这些微服务的请求数量的增加，网关另一侧发生错误的可能性也会增加。您还可以使用路由网关重新路由URI以创建更易于使用的URI模式。您还可以重新路由端口；添加、更新或删除HTTP头；等等。让我们探索相同的示例，但使用不同的URI。让我们假设以下：
- en: '| **Microservice** | **URI** |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| **微服务** | **URI** |'
- en: '| API 1 (get a device) | `internal.domain.com:8001/{id}` |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| API 1（获取设备） | `internal.domain.com:8001/{id}` |'
- en: '| API 2 (get a device location) | `internal.domain.com:8002/{id}` |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| API 2（获取设备位置）| `internal.domain.com:8002/{id}` |'
- en: 'Table 19.1: Internal microservice URI patterns.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 表 19.1：内部微服务 URI 模式。
- en: 'UI developers would have a harder time remembering what port is leading to
    what microservice and what is doing what (and who could blame them?). Moreover,
    we could not transfer the requests as we did earlier (only routing the domain).
    We could use the gateway as a way to create memorable URI patterns for developers
    to consume, like these:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: UI 开发者可能更难记住哪个端口通向哪个微服务以及它在做什么（而且谁能责怪他们呢？）。此外，我们无法像之前那样传输请求（仅路由域名）。我们可以使用网关作为为开发者创建记忆
    URI 模式的方式，如下所示：
- en: '| **Gateway URI** | **Microservice URI** |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| **网关 URI** | **微服务 URI** |'
- en: '| `gateway.domain.com/devices/{id}` | `internal.domain.com:8001/{id}` |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `gateway.domain.com/devices/{id}` | `internal.domain.com:8001/{id}` |'
- en: '| `gateway.domain.com/devices/{id}/location` | `internal.domain.com:8002/{id}`
    |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `gateway.domain.com/devices/{id}/location` | `internal.domain.com:8002/{id}`
    |'
- en: 'Table 19.1: Memorable URI patterns that are easier to use and semantically
    meaningful.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 表 19.1：易于使用且语义上有意义的记忆 URI 模式。
- en: As we can see, we took the ports out of the equation to create usable, meaningful,
    and easy-to-remember URIs.However, we are still making two requests to the gateway
    to display one piece of information (the location of a device and its name/model),
    which leads us to our next Gateway pattern.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们排除了端口，以创建可用的、有意义的、易于记忆的 URI。然而，我们仍然向网关发送两个请求来显示一条信息（设备的地理位置及其名称/型号），这导致我们转向下一个网关模式。
- en: Gateway Aggregation pattern
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网关聚合模式
- en: 'Another role we can give to a gateway is aggregating requests to hide complexity
    from its consumers. Aggregating multiple requests into one makes it easier for
    consumers of a microservices system to interact with it; clients need to know
    about one endpoint instead of multiple. Moreover, it moves the chattiness from
    the client to the gateway, which is closer to the microservices, lowering the
    many calls’ latency, and thus making the request-response cycle faster.Continuing
    with our previous example, we have two UI applications that contain a feature
    to show a device’s location on a map before identifying it using its name/model.
    To achieve this, they must call the device twin endpoint to obtain the device’s
    name and model and the location endpoint to get its last known location. So, two
    requests to display a small box times two UIs means four requests to maintain
    a simple feature. If we extrapolate, we could end up managing a huge number of
    HTTP requests for a handful of features.Here is a diagram showing our feature
    in its current state:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以赋予网关另一个角色，即聚合请求以隐藏其消费者的复杂性。将多个请求聚合为一个请求，使得微服务系统的消费者更容易与之交互；客户端只需要知道一个端点而不是多个端点。此外，它将客户端的冗余从客户端转移到网关，网关更靠近微服务，降低了多次调用的延迟，从而使得请求-响应周期更快。继续我们之前的例子，我们有两个用户界面应用，它们包含一个在识别设备名称/型号之前在地图上显示设备位置的功能。为了实现这一点，它们必须调用设备孪生端点以获取设备的名称和型号以及位置端点以获取其最后已知位置。因此，显示一个小框的两次请求乘以两个用户界面意味着四个请求来维护一个简单的功能。如果我们外推，我们可能会为少量功能管理大量的
    HTTP 请求。以下是显示我们当前状态的功能图：
- en: '![Figure 19.19: A web application and a mobile app that are calling two microservices
    through a gateway application](img/file146.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图 19.19：一个通过网关应用调用两个微服务的 Web 应用和移动应用](img/file146.png)'
- en: 'Figure 19.19: A web application and a mobile app that are calling two microservices
    through a gateway application'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.19：一个通过网关应用调用两个微服务的 Web 应用和移动应用
- en: 'To remedy this problem, we can apply the Gateway Aggregation pattern to simplify
    our UIs and offload the responsibility of managing those details to the gateway.By
    applying the Gateway Aggregation pattern, we end up with the following simplified
    flow:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以应用网关聚合模式来简化我们的用户界面，并将管理这些细节的责任转移到网关。通过应用网关聚合模式，我们最终得到以下简化的流程：
- en: '![Figure 19.20: A gateway that aggregates the response of two requests to serve
    a single request from both a web application and a mobile app](img/file147.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图 19.20：一个聚合两个请求的响应以服务于来自 Web 应用和移动应用的单一请求的网关](img/file147.png)'
- en: 'Figure 19.20: A gateway that aggregates the response of two requests to serve
    a single request from both a web application and a mobile app'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.20：一个网关，它聚合了两个请求的响应，以服务于来自 Web 应用和移动应用的单一请求
- en: 'In the previous flow, the Web App calls the Gateway that calls the two APIs,
    then crafts a response combining the two responses it got from the APIs. The Gateway
    then returns that response to the Web App. With that in place, the Web App is
    loosely coupled with the two APIs while the Gateway plays the intermediary. With
    only one HTTP request, the Web App has all the information it needs, aggregated
    by the Gateway.Next, let’s explore the steps that occurred. The following diagram
    shows that the Web App makes a single request (1) while the gateway makes two
    calls (2 and 4). In the diagram, the requests are sent in series, but we could
    have sent them in parallel to speed things up:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的流程中，Web应用调用网关，网关调用两个API，然后制作一个结合从API获取的两个响应的响应。然后网关将此响应返回给Web应用。有了这个，Web应用与两个API松散耦合，而网关充当中间人。仅通过一个HTTP请求，Web应用就拥有了它所需的所有信息，由网关聚合。接下来，让我们探索发生的步骤。以下图表显示Web应用发起一个请求（1），而网关发起两个调用（2和4）。在图表中，请求是按顺序发送的，但我们也可以并行发送它们以加快速度：
- en: '![Figure 19.21: The order in which the requests take place](img/file148.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图19.21：请求发生的顺序](img/file148.png)'
- en: 'Figure 19.21: The order in which the requests take place'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.21：请求发生的顺序
- en: Like the routing gateway, an aggregation gateway can become the bottleneck of
    your application and a single point of failure, so beware of that.Another important
    point is the latency between the gateway and the internal APIs. The clients will
    wait for every response if the latency is too high. So, deploying the gateway
    close to the microservices it interacts with could become crucial for system performance.
    The gateway can also implement caching to improve performance further and make
    subsequent requests faster.Next, we explore another type of gateway that creates
    specialized gateways instead of generic ones.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 与路由网关一样，聚合网关也可能成为应用程序的瓶颈和单点故障，因此要小心。另一个重要点是网关和内部API之间的延迟。如果延迟太高，客户端将等待每个响应。因此，将网关部署在与它交互的微服务附近可能对系统性能至关重要。网关还可以实现缓存以进一步提高性能并使后续请求更快。接下来，我们将探索另一种类型的网关，它创建的是专用网关而不是通用网关。
- en: Backend for Frontend pattern
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后端前端模式
- en: 'The Backend for Frontend (BFF) pattern is yet another variation of the Gateway
    pattern. With Backend for Frontend, instead of building a general-purpose gateway,
    we build a gateway per user interface (for each application that interacts with
    the system), lowering the complexity. Moreover, it allows for fine-grained control
    of what endpoints are exposed. It removes the chances of app B breaking when changes
    are made to app A. Many optimizations can come out of this pattern, such as sending
    only the data that’s required for each call instead of sending data that only
    a few applications are using, saving some bandwidth along the way.Let’s say that
    our Web App needs to display more data about a device. To achieve that, we would
    need to change the endpoint and send that extra information to the mobile app
    as well. However, the mobile app doesn’t need that information since it doesn’t
    have room on its screen to display it. Next is an updated diagram that replaces
    the single gateway with two gateways, one per frontend:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 后端前端（BFF）模式是网关模式的一种另一种变体。在后端前端模式中，我们不是构建一个通用网关，而是为每个用户界面（与系统交互的每个应用程序）构建一个网关，从而降低复杂性。此外，它允许对暴露哪些端点进行精细控制。它消除了当对应用A进行更改时应用B可能崩溃的机会。许多优化可以由此模式产生，例如，只发送每个调用所需的必要数据，而不是发送只有少数应用程序使用的数据，从而在过程中节省一些带宽。假设我们的Web应用需要显示更多关于设备的详细信息。为了实现这一点，我们需要更改端点并将这些额外信息发送到移动应用。然而，移动应用不需要这些信息，因为它没有足够的空间在屏幕上显示它。接下来是一个更新的图表，用两个网关替换了单个网关，每个前端一个：
- en: '![Figure 19.22: Two Backend for Frontend gateways; one for the Web App and
    one for the Mobile App](img/file149.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图19.22：两个后端前端网关；一个用于Web应用，一个用于移动应用](img/file149.png)'
- en: 'Figure 19.22: Two Backend for Frontend gateways; one for the Web App and one
    for the Mobile App'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.22：两个后端前端网关；一个用于Web应用，一个用于移动应用
- en: 'Doing this allows us to develop specific features for each frontend without
    impacting the other. Each gateway now shields its particular frontend from the
    rest of the system and the other frontend. This is the most important benefit
    this pattern brings: client independence.Once again, the Backend for Frontend
    pattern is a gateway. Like other variations of the Gateway pattern, it can become
    the bottleneck of its frontend and its single point of failure. The good news
    is that the outage of one BFF gateway limits the impact to a single frontend,
    shielding the other frontends from that downtime.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们可以为每个前端开发特定的功能，而不会影响其他部分。现在每个网关都保护其特定的前端不受整个系统和其他前端的影响。这是该模式带来的最重要的好处：客户端独立性。再次强调，前端后端模式是一种网关。与其他网关模式的变体一样，它可能成为其前端和单一故障点。好消息是，一个BFF网关的故障只会影响单个前端，保护其他前端免受这种停机时间的影响。
- en: Mixing and matching gateways
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混合匹配网关
- en: 'Now that we’ve explored three variations of the Gateway pattern, it is important
    to note that we can mix and match them, either at the codebase level or as multiple
    microservices.For example, a gateway can be built for a single client (backend
    for frontend), perform simple routing, and aggregate results.We can also mix them
    as different applications, for example, by putting multiple backend for frontend
    gateways in front of a more generic gateway to simplify the development and maintenance
    of those backend for frontend gateways.Beware that each hop has a cost. The more
    pieces you add between your clients and your microservices, the more time it will
    take for those clients to receive the response (latency). Of course, you can put
    mechanisms in place to lower that overhead, such as caching or non-HTTP protocols
    such as gRPC, but you still must consider it. That goes for everything, not just
    gateways.Here is an example illustrating this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了网关模式的三个变体，重要的是要注意我们可以混合匹配它们，无论是在代码库级别还是在多个微服务中。例如，可以为单个客户端（前端后端）构建网关，执行简单的路由，并聚合结果。我们也可以将它们混合为不同的应用，例如，通过在更通用的网关前面放置多个前端后端网关来简化这些前端后端网关的开发和维护。请注意，每个跳转都有成本。你在客户端和微服务之间添加的组件越多，这些客户端接收响应所需的时间就越长（延迟）。当然，你可以实施机制来降低这种开销，例如缓存或非HTTP协议如gRPC，但你仍然必须考虑这一点。这适用于所有事情，而不仅仅是网关。以下是一个说明这一点的例子：
- en: '![Figure 19.23: A mix of the Gateway patterns](img/file150.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图19.23：网关模式的混合](img/file150.png)'
- en: 'Figure 19.23: A mix of the Gateway patterns'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.23：网关模式的混合
- en: As you’ve possibly guessed, the Generic Gateway is the single point of failure
    of all applications, while at the same time, each backend for frontend gateway
    is a point of failure for its specific client.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所可能猜到的，通用网关是所有应用的单一故障点，同时，每个前端后端网关也是其特定客户端的故障点。
- en: A **service mesh** is an alternative to help microservices communicate with
    one another. It is a layer, outside of the application, that proxies communications
    between services. Those proxies are injected on top of each service and are referred
    to as **sidecars**. The service mesh can also help with distributed tracing, instrumentation,
    and system resiliency. If your system needs service-to-service communication,
    a service mesh would be an excellent place to look.
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**服务网格**是帮助微服务相互通信的替代方案。它是一个位于应用程序之外的一层，代理服务之间的通信。这些代理被注入到每个服务之上，被称为**边车**。服务网格还可以帮助进行分布式跟踪、仪表化和系统弹性。如果你的系统需要服务间通信，服务网格将是一个绝佳的解决方案。'
- en: Conclusion
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'A gateway is a façade that shields or simplifies access to one or more other
    services. In this section, we explored the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 网关是一种门面，用于保护或简化对一个或多个其他服务的访问。在本节中，我们探讨了以下内容：
- en: '**Routing**: This forwards a request from point A to point B (a reverse proxy).'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由**：这是将请求从A点转发到B点（反向代理）。'
- en: '**Aggregation**: This combines the result of multiple sub-requests into a single
    response.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合**：这是将多个子请求的结果合并为一个单一响应。'
- en: '**Backend for Frontend**: This is used in a one-to-one relationship with a
    frontend.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前端后端**：这是与前端一对一关系使用。'
- en: We can use any microservices pattern, including gateways, and like any other
    pattern, we can mix and match them. Just consider the advantages, but also the
    drawbacks, that they bring to the table. If you can live with them, you’ve got
    your solution.Gateways often become the single point of failure of the system,
    so that is a point to consider. On the other hand, a gateway can have multiple
    instances running simultaneously behind a load balancer. Moreover, we must also
    consider the delay added by calling a service that calls another service since
    that slows down the response time.All in all, a gateway is a great tool to simplify
    consuming microservices. They also allow hiding the microservices topology behind
    them, possibly even isolated in a private network. They can also handle cross-cutting
    concerns such as security.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用任何微服务模式，包括网关，就像任何其他模式一样，我们可以混合搭配它们。只需考虑它们带来的优势，但也考虑它们的缺点。如果你能接受它们，你就找到了你的解决方案。网关往往成为系统的单点故障，所以这是一个需要考虑的点。另一方面，网关可以在负载均衡器后面同时运行多个实例。此外，我们还必须考虑调用调用另一个服务的服务时增加的延迟，因为这会减慢响应时间。总的来说，网关是一个简化消费微服务的优秀工具。它们还允许在它们后面隐藏微服务拓扑，甚至可能是在私有网络中隔离。它们还可以处理跨领域关注点，如安全性。
- en: 'It is imperative to use gateways as a requests passthrough and avoid coding
    business logic into them; gateways are just reverse proxies. Think single responsibility
    principle: a gateway is a façade in front of your microservices cluster. Of course,
    you can unload specific tasks into your gateways like authorization, resiliency
    (retry policies, for example), and similar cross-cutting concerns, but the business
    logic must remain in the backend microservices.'
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 强烈建议使用网关作为请求的透传，并避免将业务逻辑编码到网关中；网关只是反向代理。想想单一责任原则：网关是你微服务集群前面的门面。当然，你可以将特定的任务卸载到网关中，比如授权、弹性（例如重试策略）和类似的跨领域关注点，但业务逻辑必须保留在后端的微服务中。
- en: ''
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The BFF’s role is to simplify the UI, so moving logic from the UI to the BFF
    is encouraged.
  id: totrans-256
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: BFF（最佳朋友功能）的作用是简化用户界面，因此鼓励将逻辑从UI移动到BFF。
- en: 'In most cases, I recommend against rolling out your hand-crafted gateway and
    suggest leveraging existing offerings instead. There are many open-source and
    cloud gateways that you can use in your application. Using existing components
    leaves you more time to implement the business rules that solve the issues your
    program is trying to tackle.Of course, cloud-based offerings exist, like Azure
    Application Gateway and Amazon API Gateway. Both are extendable with cloud offerings
    like load balancers and **web application firewalls** (**WAF**). For example,
    Azure Application Gateway also supports autoscaling, zone redundancy, and can
    serve as **Azure Kubernetes Service** (**AKS**) Ingress Controller (in a nutshell,
    it controls the traffic to your microservices cluster).If you want more control
    over your gateways or to deploy them with your application, you can leverage one
    existing options, like Ocelot, YARP, or Envoy.Ocelot is an open source production-ready
    API Gateway programmed in .NET. Ocelot supports routing, request aggregation,
    load-balancing, authentication, authorization, rate limiting, and more. It also
    integrates well with Identity Server. In my eyes, the biggest advantage of Ocelot
    is that you create the .NET project yourself, install a NuGet package, configure
    your gateway, and then deploy it like any other ASP.NET Core application. Since
    Ocelot is written in .NET, extending it if needed or contributing to the project
    or its ecosystem is easier.To quote their GitHub `README.md` file: « *YARP is
    a reverse proxy toolkit for building fast proxy servers in .NET using the infrastructure
    from ASP.NET and .NET. The key differentiator for YARP is that it''s been designed
    to be easily customized and tweaked to match the specific needs of each deployment
    scenario.* »Envoy is an « *open source edge and service proxy, designed for cloud-native
    applications* », to quote their website. Envoy is a **Cloud Native Computing Foundation**
    (**CNCF**) graduated project originally created by Lyft. Envoy was designed to
    run as a separate process from your application, allowing it to work with any
    programming language. Envoy can serve as a gateway and has an extendable design
    through TCP/UDP and HTTP filters, supports HTTP/2 and HTTP/3, gRPC, and more.Which
    offering to choose? If you are looking for a fully managed service, look at the
    cloud provider’s offering of your choice. Consider YARP or Ocelot if you are looking
    for a configurable reverse proxy or gateway that supports the patterns covered
    in this chapter. If you have complex use cases that Ocelot does not support, you
    can look into Envoy, a proven offering with many advanced capabilities. Please
    remember that these are just a few possibilities that can play the role of a gateway
    in a microservices architecture system and are not intended to be a complete list.Now,
    let’s see how gateways can help us follow the **SOLID** principles at cloud-scale:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我建议不要使用您亲手打造的网关，而是建议利用现有的产品。有许多开源和云网关可供您在应用程序中使用。使用现有组件可以让您有更多时间来实现解决您程序试图解决的问题的业务规则。当然，也存在基于云的产品，例如Azure应用程序网关和Amazon
    API网关。两者都可以通过云产品（如负载均衡器和**Web应用程序防火墙**（WAF））进行扩展。例如，Azure应用程序网关还支持自动扩展、区域冗余，并可以作为**Azure
    Kubernetes服务**（AKS）网关控制器使用（简单来说，它控制着流量到您的微服务集群）。如果您希望对网关有更多控制权或与您的应用程序一起部署，您可以使用一个现有选项，如Ocelot、YARP或Envoy。Ocelot是一个用.NET编写的开源生产就绪API网关。Ocelot支持路由、请求聚合、负载均衡、身份验证、授权、速率限制等。它还与Identity
    Server很好地集成。在我看来，Ocelot最大的优势是您可以自己创建.NET项目，安装NuGet包，配置您的网关，然后像其他ASP.NET Core应用程序一样部署它。由于Ocelot是用.NET编写的，如果需要，扩展它或为其项目或其生态系统做出贡献更容易。引用他们的GitHub
    `README.md`文件：“*YARP是一个用于在.NET中使用ASP.NET和.NET基础设施构建快速代理服务器的反向代理工具包。YARP的关键区别在于它被设计成易于定制和调整，以匹配每个部署场景的具体需求。”Envoy是一个“*开源边缘和服务代理，专为云原生应用程序设计*”，正如他们的网站所述。Envoy是一个由Lyft最初创建的**云原生计算基金会**（CNCF）毕业项目。Envoy被设计为作为与您的应用程序分离的独立进程运行，使其能够与任何编程语言一起工作。Envoy可以作为网关使用，并通过TCP/UDP和HTTP过滤器具有可扩展的设计，支持HTTP/2和HTTP/3、gRPC等。选择哪个产品？如果您正在寻找一个完全托管的服务，请查看您选择的云提供商的产品。如果您正在寻找一个可配置的反向代理或网关，它支持本章中涵盖的模式，请考虑YARP或Ocelot。如果您有Ocelot不支持复杂用例，您可以查看Envoy，这是一个具有许多高级功能的经过验证的产品。请记住，这些只是可以在微服务架构系统中扮演网关角色的几种可能性，并不旨在成为完整列表。现在，让我们看看网关如何帮助我们以云规模遵循**SOLID**原则：
- en: '**S**: A gateway can handle routing, aggregation, and other similar logic that
    would otherwise be implemented in different components or applications.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**：网关可以处理路由、聚合和其他类似逻辑，否则这些逻辑将实现在不同的组件或应用程序中。'
- en: '**O**: I see many ways to tackle this one, but here are two takes on this:'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**：我看到了很多处理这个问题的方法，但这里提供两种看法：'
- en: Externally, a gateway could reroute its sub-requests to new URIs without its
    consumers knowing about it, as long as its contract does not change.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在外部，网关可以在其消费者不知道的情况下将其子请求重定向到新的URI，只要其合同不改变。
- en: Internally, a gateway could load its rules from configurations, allowing it
    to change without updating its code.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内部，网关可以从配置中加载其规则，允许它在不更新其代码的情况下进行更改。
- en: '**L**: N/A'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**：N/A'
- en: '**I**: Since a backend for frontend gateway serves a single frontend system,
    one contract (interface) per frontend system leads to multiple smaller interfaces
    instead of one big general-purpose gateway.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**：由于前端网关为单个前端系统服务，每个前端系统一个合同（接口）会导致多个较小的接口而不是一个大的通用网关。'
- en: '**D**: We could see a gateway as an abstraction, hiding the real microservices
    (implementations) and inverting the dependency flow.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**：我们可以将网关视为一个抽象，隐藏实际的微服务（实现）并反转依赖流。'
- en: Next, we build a BFF and evolve e-commerce application from *Chapter 18*.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从第18章开始构建一个bff并演进电子商务应用。
- en: Project – REPR.BFF
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目 – REPR.BFF
- en: This project leverages the Backend for Frontend (BFF) design pattern to reduce
    the complexity of using the low-level API of the *REPR project* we created in
    *Chapter 18*. The BFF endpoints act as several types of gateway we explore.This
    design makes two layers of API, so let’s start here.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目利用后端为前端（BFF）设计模式来降低使用我们在第18章中创建的*REPR项目*的底层API的复杂性。bff端点充当我们探索的几种类型的网关。这种设计使得API有两层，所以让我们从这里开始。
- en: Layering APIs
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 层次化API
- en: 'From a high-level architecture perspective, we can leverage multiple layers
    of APIs to group different levels of operation granularity. For example, in this
    case, we have two layers:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 从高级架构的角度来看，我们可以利用多个API层来分组不同级别的操作粒度。例如，在这个案例中，我们有两层：
- en: Low-level APIs that offer atomic foundational operations.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供原子基础操作的底层API。
- en: High-level APIs that offer domain-specific functionalities.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供特定领域功能的顶层API。
- en: 'Here’s a diagram that represents this concept (high-level APIs are BFFs in
    this case, but the design could be nuanced):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个表示这个概念的图（在这种情况下，顶层API是bff，但设计可能有所细微差别）：
- en: '![Figure 19.24: diagram showcasing a two-layer architecture.](img/file151.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图19.24：展示两层架构的示意图](img/file151.png)'
- en: 'Figure 19.24: diagram showcasing a two-layer architecture.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.24：展示两层架构的示意图。
- en: The low-level layer showcases atomic foundational operations, like adding an
    item to the shopping basket and removing an item from the shopping basket. Those
    operations are simple, so they are more complicated to use. For example, loading
    the products in the user’s shopping cart requires multiple API calls, one to get
    the items and quantity and one per item to get the product details like its name
    and price. The high-level layer offers domain-specific functionalities, which
    are easier to use but can become more complex. For example, a single endpoint
    could handle adding, updating, and deleting items from the shopping basket, making
    its usage trivial for its consumer but its logic more complex to implement. Moreover,
    the product team could prefer a shopping cart to a shopping basket, so the endpoint’s
    URL could reflect this.Let’s have a look at the advantages and disadvantages.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 低层展示原子基础操作，如向购物车添加项目或从购物车中删除项目。这些操作很简单，因此使用起来更复杂。例如，加载用户购物车中的产品需要多个API调用，一个用于获取项目和数量，每个项目一个用于获取产品详情，如名称和价格。高层提供特定领域的功能，使用起来更简单，但可能变得更复杂。例如，单个端点可以处理向购物车添加、更新和删除项目，使其对消费者的使用变得简单，但其逻辑实现更复杂。此外，产品团队可能更喜欢购物车而不是购物篮，因此端点的URL可以反映这一点。让我们看看优势和劣势。
- en: Advantages of a two-layer design
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 两层设计的优势
- en: '**Separation of Concerns:** This architecture separates the generic functionalities
    from the domain-specific ones, promoting cleaner code and modularization.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离**：此架构将通用功能与特定领域功能分开，促进更干净的代码和模块化。'
- en: '**Scalability:** Each layer can be scaled independently based on the demand.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：每一层可以根据需求独立扩展。'
- en: '**Flexibility and Reusability:** The low-level APIs can be reused across multiple
    high-level functionalities or applications, promoting code reusability.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性和可重用性：** 低级API可以在多个高级功能或应用程序之间重用，从而促进代码的可重用性。'
- en: '**Optimized Data Fetching:** BFFs can call multiple low-level APIs, aggregate
    responses, and send only the necessary data to the frontend, reducing payload
    sizes and making frontend development more straightforward.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化数据获取：** BFF可以调用多个低级API，聚合响应，并将必要的数据发送到前端，从而减少有效载荷大小，使前端开发更加简单。'
- en: '**Easier Maintenance:** We can address issues in a specific domain without
    touching the low-level generic APIs. On the other hand, we can fix an issue in
    a lower-level API, which will propagate to all the domains.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于维护：** 我们可以在不触及低级通用API的情况下解决特定领域的问题。另一方面，我们可以在较低级别的API中修复问题，这将传播到所有领域。'
- en: '**Tailored User Experience:** High-level APIs can be crafted specifically for
    individual client types (web, mobile, etc.), ensuring an optimal user experience.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定制用户体验：** 高级API可以专门为特定客户端类型（网页、移动等）定制，确保最佳用户体验。'
- en: '**Security:** Domain-specific functionalities can implement additional security
    measures relevant to their context without burdening the low-level APIs with unnecessary
    complexity.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性：** 针对特定领域的功能可以实现与其上下文相关的额外安全措施，而不会给低级API带来不必要的复杂性。'
- en: Disadvantages of a two-layer design
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 双层设计的缺点
- en: '**Increased Complexity:** Maintaining two layers introduces additional deployment,
    monitoring, and management complexity.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加复杂性：** 维护两层引入了额外的部署、监控和管理复杂性。'
- en: '**Potential Performance Overhead:** An additional layer introduces latency,
    especially if not properly optimized.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**潜在的性能开销：** 添加额外的层会引入延迟，尤其是在没有适当优化的情况下。'
- en: '**Duplication:** There''s potential for code duplication when similar logic
    gets implemented in multiple high-level functionalities.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码重复：** 当类似的逻辑在多个高级功能中实现时，可能会出现代码重复。'
- en: '**Tight Coupling Concerns:** Changes in the low-level APIs can impact multiple
    domain-specific functionalities. A poor design could lead to a tightly coupled
    distributed system.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**紧密耦合关注点：** 低级API的更改可能会影响多个特定领域的功能。糟糕的设计可能导致紧密耦合的分布式系统。'
- en: '**Coordination Required:** As the system evolves, ensuring that the low-level
    APIs meet the needs of all high-level functionalities requires more coordination
    among development teams.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**需要协调：** 随着系统的演变，确保低级API满足所有高级功能的需求需要在开发团队之间进行更多协调。'
- en: '**Overhead in Development:** Developers need to consider two layers, which
    can slow down the development process, especially if there''s a need to modify
    both layers to achieve a specific feature or fix.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发中的开销：** 开发者需要考虑两层，这可能会减慢开发过程，尤其是在需要修改两层以实现特定功能或修复问题时。'
- en: '**Potential for Stale Data:** If high-level functionalities cache data from
    low-level APIs, there''s potential for serving stale data to users.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**潜在的数据过时：** 如果高级功能从低级API缓存数据，可能会向用户提供服务过时的数据。'
- en: '**Increased Risk of Failures:** Introducing additional APIs increases the odds
    of one of them experiencing issues or outages.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加失败风险：** 引入额外的API增加了其中之一出现问题或中断的概率。'
- en: While a two-layer design can offer flexibility and optimization, it also introduces
    additional complexities. The decision to use such an architecture should be based
    on the specific needs of the project, the anticipated scale, and the capabilities
    of the development and operations teams.We look at booting up these APIs next.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然双层设计可以提供灵活性和优化，但它也引入了额外的复杂性。是否使用这种架构的决定应基于项目的具体需求、预期的规模以及开发和运营团队的能力。我们接下来将查看启动这些API。
- en: Running the microservices
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行微服务
- en: 'Let’s start by exploring the deployment topology. First, we split the *Chapter
    18* REPR project into two services: *Baskets* and *Products*. Then, we add a *BFF*
    API that fronts the two services to simplify using the system. We do not have
    a UI per se, but one `http` file per project exists to simulate HTTP requests.
    Here’s a diagram that represents the relationship between the different services:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从探索部署拓扑开始。首先，我们将第18章REPR项目拆分为两个服务：*购物车*和*产品*。然后，我们添加一个*bff* API作为两个服务的代理，以简化系统的使用。我们本身没有用户界面，但每个项目都有一个`http`文件来模拟HTTP请求。以下是一个表示不同服务之间关系的图：
- en: '![Figure 19.25: a diagram that represents the deployment topology and relationship
    between the different services](img/file152.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图 19.25：表示不同服务部署拓扑和关系的图](img/file152.png)'
- en: 'Figure 19.25: a diagram that represents the deployment topology and relationship
    between the different services'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.25：表示不同服务部署拓扑和关系的图
- en: The easiest and most extendable way to start the projects is to use Docker,
    but it is optional; we can also start the three projects manually. Using Docker
    opens many possibilities, like using a real SQL Server to persist the data between
    runs and add more pieces to our puzzle, like a Redis cache or an event broker,
    to name a few.Let’s start by manually starting the apps.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 开始项目最简单且最可扩展的方式是使用 Docker，但这不是必须的；我们也可以手动启动三个项目。使用 Docker 打开了许多可能性，比如使用真实的 SQL
    Server 在运行之间持久化数据，并添加更多拼图碎片，例如 Redis 缓存或事件代理，仅举几例。让我们先手动启动应用程序。
- en: Manually starting the projects
  id: totrans-299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 手动启动项目
- en: We have three projects and need three terminals to start them all. From the
    chapter directory, you can execute the following commands, one set per terminal
    window, and all projects should start:# In one terminal
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个项目，需要三个终端来启动它们。从章节目录中，您可以执行以下命令，每个终端窗口一组命令，所有项目都应该启动：# 在一个终端
- en: '[PRE6]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Doing this should work. You can use the `PROJECT_NAME.http` files to test the
    APIs.Next, let’s explore the second option about using Docker.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作应该可以工作。您可以使用 `PROJECT_NAME.http` 文件来测试 API。接下来，让我们探索使用 Docker 的第二个选项。
- en: Using Docker Compose to run the projects
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 运行项目
- en: At the same level as the solution file, the `docker-compose.yml`, `docker-compose.override.yml`,
    and various `Dockerfile` files are preconfigured to make the projects start in
    the correct order.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案文件同一级别，`docker-compose.yml`、`docker-compose.override.yml` 和各种 `Dockerfile`
    文件预先配置，以便项目按正确顺序启动。
- en: 'Here’s a link to get started with Docker: [https://adpg.link/1zfM](https://adpg.link/1zfM)'
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这里有一个链接，可以帮助您开始使用 Docker：[https://adpg.link/1zfM](https://adpg.link/1zfM)
- en: Since ASP.NET Core uses HTTPS by default, we must register a development certificate
    with the container, so let’s start here.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 ASP.NET Core 默认使用 HTTPS，我们必须在容器中注册一个开发证书，所以让我们从这里开始。
- en: Configuring HTTPS
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 配置 HTTPS
- en: 'This section quickly explores using PowerShell to set up HTTPS on Windows.
    If you are using a different operating system or if the instructions are not working,
    please consult the official documentation: [https://adpg.link/o1tu](https://adpg.link/o1tu)First,
    we must generate a development certificate. In a PowerShell terminal, run the
    following commands:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 本节简要探讨了在 Windows 上使用 PowerShell 设置 HTTPS 的方法。如果您使用的是不同的操作系统或说明不起作用，请参阅官方文档：[https://adpg.link/o1tu](https://adpg.link/o1tu)首先，我们必须生成一个开发证书。在
    PowerShell 终端中，运行以下命令：
- en: '[PRE7]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding commands create a `pfx` file with the password `devpassword` (you
    must provide a password, or it won’t work), then tell .NET to trust the dev certificates.From
    there, the `ASPNETCORE_Kestrel__Certificates__Default__Path` and `ASPNETCORE_Kestrel__Certificates__Default__Password`
    environment variables are configured in the `docker-compose.override.yml` file
    and should be taken into account.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令创建了一个带有密码 `devpassword` 的 `pfx` 文件（您必须提供密码，否则它将无法工作），然后告诉 .NET 信任开发证书。从那里，`ASPNETCORE_Kestrel__Certificates__Default__Path`
    和 `ASPNETCORE_Kestrel__Certificates__Default__Password` 环境变量在 `docker-compose.override.yml`
    文件中配置，应予以考虑。
- en: If you change the certificate location or the password, you must update the
    `docker-compose.override.yml` file.
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您更改证书位置或密码，必须更新 `docker-compose.override.yml` 文件。
- en: Composing the application
  id: totrans-312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 组合应用程序
- en: 'Now that we set up HTTPS, we can build the container using the following commands:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们设置了 HTTPS，我们可以使用以下命令构建容器：
- en: '[PRE8]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can execute the following command to start the containers:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行以下命令来启动容器：
- en: '[PRE9]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This should start the containers and feed you an aggregated log with a color
    per service. The beginning of the log trail should look like this:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会启动容器，并为您提供带有每个服务颜色的聚合日志。日志的开头应该看起来像这样：
- en: '[PRE10]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To stop the services, press `Ctrl+C`. When you want to destroy the running
    application, enter the following command:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止服务，请按 `Ctrl+C`。当您想要销毁正在运行的应用程序时，请输入以下命令：
- en: '[PRE11]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, with `docker compose up`, our services should be running. To make sure,
    let’s try them out.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 `docker compose up`，我们的服务应该正在运行。为了确保这一点，让我们试一试。
- en: Briefly testing the services
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 简单测试服务
- en: 'The project contains the following services, each containing an `http` file
    you can leverage to query the services using Visual Studio or in VS Code using
    an extension:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 项目包含以下服务，每个服务都包含一个你可以利用的`http`文件，用于使用Visual Studio或通过VS Code扩展查询服务：
- en: '| Service | HTTP file | Host |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| 服务 | HTTP文件 | 主机 |'
- en: '| `REPR.Baskets` | `REPR.Baskets.http` | [https://localhost:60280](https://localhost:60280)
    |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| `REPR.Baskets` | `REPR.Baskets.http` | [https://localhost:60280](https://localhost:60280)
    |'
- en: '| `REPR.BFF` | `REPR.BFF.http` | [https://localhost:7254](https://localhost:7254)
    |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| `REPR.BFF` | `REPR.BFF.http` | [https://localhost:7254](https://localhost:7254)
    |'
- en: '| `REPR.Products` | `REPR.Products.http` | [https://localhost:57362](https://localhost:57362)
    |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| `REPR.Products` | `REPR.Products.http` | [https://localhost:57362](https://localhost:57362)
    |'
- en: 'Table 19.3: each service, HTTP file, and HTTPS hostname and port.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 表19.3：每个服务、HTTP文件、HTTPS主机名和端口。
- en: We can leverage the HTTP requests from each directory to test the API. I suggest
    starting by trying the low-level APIs, then the BFF, so you know if something
    is wrong with them directly instead of wondering what is wrong with the BFF (which
    calls the low-level APIs).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用每个目录的HTTP请求来测试API。我建议先尝试低级API，然后是BFF，这样你可以直接知道它们是否有问题，而不是猜测BFF（它调用低级API）出了什么问题。
- en: I use the *REST Client* extension in VS Code ([https://adpg.link/UCGv](https://adpg.link/UCGv))
    and the built-in support in Visual Studio 2022 version 17.6 or later.
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我使用VS Code中的*REST客户端*扩展（[https://adpg.link/UCGv](https://adpg.link/UCGv)）和Visual
    Studio 2022版本17.6或更高版本的内置支持。
- en: 'Here’s a part of the `REPR.Baskets.http` file:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`REPR.Baskets.http`文件的一部分：
- en: '[PRE12]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The highlighted lines are variables that the requests reuse. The `###` characters
    act as a separator between requests. In VS or VS Code, you should see a `Send
    request` button on top of each request. Executing the `POST` request, then the
    `GET` should output the following:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行是请求重复使用的变量。`###`字符在请求之间充当分隔符。在VS或VS Code中，你应该在每个请求的顶部看到一个`发送请求`按钮。执行`POST`请求后，然后执行`GET`应该输出以下内容：
- en: '[PRE13]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you can reach one endpoint, this means the service is running. Nonetheless,
    feel free to play with the requests, modify them, and add more.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够访问一个端点，这意味着服务正在运行。尽管如此，请随意玩转请求，修改它们，并添加更多。
- en: I did not move the tests over from *Chapter 18*. Automating the validation of
    our deployment could be a good exercise for you to test your testing skills.
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我没有将测试从*第18章*迁移过来。自动化我们部署的验证可能是一个很好的练习，让你测试你的测试技能。
- en: After you validate that the three services are running, we can continue and
    look at how the BFF communicates with the Baskets and Products services.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证了三个服务都在运行之后，我们可以继续并查看BFF如何与Baskets和Products服务进行通信。
- en: Creating typed HTTP clients using Refit
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Refit创建类型化HTTP客户端
- en: 'The BFF service must communicate to the Baskets and Products services. The
    services are REST APIs, so we must leverage HTTP. We could leverage the out-of-the-box
    ASP.NET Core `HttpClient` class and `IHttpClientFactory` interface, then send
    raw HTTP requests to the downstream APIs. On the other hand, we could also create
    a typed client, which translates the HTTP calls to simple method calls with evocative
    names. We are exploring the second option, encapsulating the HTTP calls inside
    the typed clients.The concept is simple: we create one interface per service and
    translate its operation into methods. Each interface revolves around a service.
    Optionally, we can aggregate the services under a master interface to inject the
    aggregate service and have access to all child services. Moreover, this central
    access point allows us to reduce the number of injected services to one and improve
    discoverability with IntelliSense. Here’s a diagram representing this concept:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: BFF服务必须与Baskets和Products服务通信。这些服务是REST API，因此我们必须利用HTTP。我们可以利用现成的ASP.NET Core
    `HttpClient`类和`IHttpClientFactory`接口，然后向下游API发送原始HTTP请求。另一方面，我们也可以创建一个类型化的客户端，将HTTP调用转换为具有启发性的简单方法调用。我们正在探索第二种选择，将HTTP调用封装在类型化的客户端中。这个概念很简单：我们为每个服务创建一个接口，并将其操作转换为方法。每个接口都围绕一个服务展开。可选地，我们可以将服务聚合到一个主接口下，注入聚合服务并访问所有子服务。此外，这个中心访问点允许我们将注入的服务数量减少到只有一个，并通过IntelliSense提高可发现性。以下是一个表示这个概念的图：
- en: '![Figure 19.25: UML class diagram representing a generic typed client class
    hierarchy.](img/file153.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图19.25：表示通用类型化客户端类层次的UML类图。](img/file153.png)'
- en: 'Figure 19.25: UML class diagram representing a generic typed client class hierarchy.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.25：表示通用类型化客户端类层次的UML类图。
- en: 'In the preceding diagram, the `IClient` interface is composed and exposes the
    other typed clients, each of which queries a specific downstream API.In our case,
    we have two downstream services, so our interface hierarchy looks like the following:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，`IClient` 接口由组合而成，并公开了其他类型化的客户端，每个客户端都查询特定的下游 API。在我们的案例中，我们有两个下游服务，所以我们的接口层次结构看起来如下：
- en: '![Figure 19.26: UML class diagram representing the BFF downstream typed client
    class hierarchy.](img/file154.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图 19.26：表示 BFF 下游类型化客户端类层次的 UML 类图](img/file154.png)'
- en: 'Figure 19.26: UML class diagram representing the BFF downstream typed client
    class hierarchy.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.26：表示 BFF 下游类型化客户端类层次的 UML 类图。
- en: After implementing this, we can query the downstream APIs from our code without
    worrying about their data contract because our client is strongly typed.We leverage
    *Refit*, an open-source library, to implement the interfaces automatically.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 实现之后，我们可以在代码中查询下游 API，而无需担心它们的数据合约，因为我们的客户端是强类型的。我们利用开源库 *Refit* 自动实现接口。
- en: 'We could use any other library or barebone ASP.NET Core `HttpClient`; it does
    not matter. I picked *Refit* to leverage its code generator, save myself the trouble
    of writing the boilerplate code, and save you the time of reading through such
    code. Refit on GitHub: [https://adpg.link/hneJ](https://adpg.link/hneJ).'
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们可以使用任何其他库或裸骨 ASP.NET Core `HttpClient`；这并不重要。我选择 *Refit* 是为了利用其代码生成器，省去编写样板代码的麻烦，并节省你阅读此类代码的时间。Refit
    在 GitHub 上的链接：[https://adpg.link/hneJ](https://adpg.link/hneJ)。
- en: ''
  id: totrans-347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'I used the out-of-the-box `IHttpClientFactory` functionalities in the past,
    so if you want to reduce the number of dependencies in your project, you can also
    use that instead. Here’s a link to help you get started: [https://adpg.link/HCj7](https://adpg.link/HCj7).'
  id: totrans-348
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我过去使用过 `IHttpClientFactory` 的内置功能，所以如果你想在项目中减少依赖项的数量，你也可以使用它。以下是一个帮助你开始的链接：[https://adpg.link/HCj7](https://adpg.link/HCj7)。
- en: Refit acts like Mapperly and generates code based on attributes, so all we have
    to do is define our methods, and Refit writes the code.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: Refit 类似于 Mapperly，根据属性生成代码，所以我们只需要定义我们的方法，Refit 就会编写代码。
- en: The *BFF* project references the *Products* and *Baskets* projects to reuse
    their DTOs. I could have architected this in many different ways, including hosting
    the typed client in a library of its own so we could share it between many projects.
    We could also extract the DTOs from the web applications to one or more shared
    projects so we don’t depend on the web applications themselves. For this demo,
    there is no need to overengineer the solution.
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*BFF* 项目引用了 *Products* 和 *Baskets* 项目以重用它们的 DTO。我可以用很多不同的方式来设计这个架构，包括在一个自己的库中托管类型化客户端，这样我们就可以在多个项目中共享它。我们还可以将
    DTO 从 Web 应用程序提取到一个或多个共享项目中，这样我们就不会依赖于 Web 应用程序本身。对于这个演示，没有必要过度设计解决方案。'
- en: 'Let’s look at the typed client interfaces, starting with the `IBasketsClient`
    interface:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看类型化的客户端接口，从 `IBasketsClient` 接口开始：
- en: '[PRE14]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding interface leverages Refit’s attributes (highlighted) to explain
    to its code generator what to write. The operations themselves are self-explanatory
    and carry the features’ DTOs over HTTP.Next, we look at the `IProductsClient`
    interface:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的接口利用 Refit 的属性（突出显示）来向其代码生成器说明要编写的内容。操作本身是自解释的，并且通过 HTTP 传输功能的数据传输对象（DTO）。接下来，我们看看
    `IProductsClient` 接口：
- en: '[PRE15]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding interface is similar to `IBasketsClient` but creates a typed bridge
    on the *Products* API.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的接口类似于 `IBasketsClient`，但在 `Products` API 上创建了一个类型化的桥梁。
- en: The generated code contains much gibberish code and would be very hard to clean
    enough to make it relevant to study, so let’s assume those interfaces have working
    implementations instead.
  id: totrans-356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 生成的代码包含很多无意义的代码，清理起来非常困难，以至于很难使其与学习相关，所以让我们假设这些接口有可工作的实现。
- en: 'Next, let’s look at our aggregate:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们的聚合：
- en: '[PRE16]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding interface exposes the two clients we had Refit generate for us.
    Its implementation is fairly straightforward as well:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的接口展示了我们让 Refit 为我们生成的两个客户端。其实现方式相当直接：
- en: '[PRE17]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding default implementation composes itself through constructor injection,
    exposing the two typed clients.Of course, dependency injection means we must register
    services with the container. Let’s start with some configuration. To make the
    setup code parametrizable and allow the Docker container to override those values,
    we extract the services base addresses to the settings file like this (`appsettings.Development.json`):'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的默认实现通过构造函数注入自己组合，暴露了两个类型化的客户端。当然，依赖注入意味着我们必须将服务注册到容器中。让我们从一些配置开始。为了使设置代码可参数化并允许Docker容器覆盖这些值，我们将服务的基本地址提取到设置文件中，如下所示（`appsettings.Development.json`）：
- en: '[PRE18]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code defines two keys, one per service, which we then load individually
    in the `Program.cs` file, like this:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码定义了两个密钥，每个服务一个，然后我们在`Program.cs`文件中单独加载它们，如下所示：
- en: '[PRE19]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding code loads the two configurations into variables.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将两个配置加载到变量中。
- en: We can leverage all the techniques we learned in *Chapter 9*, *Options, Settings,
    and Configuration*, to create a more elaborate system.
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们可以利用我们在*第9章*，“选项、设置和配置”中学到的所有技术，来创建一个更复杂的系统。
- en: 'Next, we register our Refit clients like this:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们这样注册我们的Refit客户端：
- en: '[PRE20]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding code, calling the `AddRefitClient` method replaces the .NET
    `AddHttpClient` method and registers our auto-generated client with the container.
    Because Refit registration returns an `IHttpClientBuilder` interface, we can use
    the `ConfigureHttpClient` method to configure the `HttpClient` as we would any
    other typed HTTP client. In this case, we set the `BaseAddress` property to the
    values of the previously loaded settings.Next, we must also register our aggregate:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，调用`AddRefitClient`方法替换了.NET的`AddHttpClient`方法，并将我们自动生成的客户端注册到容器中。因为Refit注册返回一个`IHttpClientBuilder`接口，我们可以使用`ConfigureHttpClient`方法来配置`HttpClient`，就像配置任何其他类型化的HTTP客户端一样。在这种情况下，我们将`BaseAddress`属性设置为之前加载的设置的值。接下来，我们还必须注册我们的聚合：
- en: '[PRE21]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: I picked a transient state because the service only fronts other services, so
    it will serve the other services as they are registered, regardless of whether
    it is the same instance every time. Moreover, it needs a transient or scoped lifetime
    because the BFF must manage who is the current customer, not the client. It would
    be quite a security vulnerability to allow users to decide who they want to impersonate
    for every request.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择了一个瞬态状态，因为该服务仅作为其他服务的代理，所以它将根据注册情况提供服务，而不管每次是否是相同的实例。此外，它需要一个瞬态或作用域生命周期，因为bff必须管理当前客户是谁，而不是客户端。允许用户为每个请求决定他们想要模仿谁将是一个很大的安全漏洞。
- en: The project does not authenticate the users, but the service we explore next
    is designed to make this evolve, abstracting and managing this responsibility
    so we could add authentication without impacting the code we are writing.
  id: totrans-372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 该项目不进行用户身份验证，但我们接下来要探索的服务旨在使这一过程演变，抽象并管理这一责任，这样我们就可以在不影响我们正在编写的代码的情况下添加身份验证。
- en: Let’s explore how we manage the current user.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索如何管理当前用户。
- en: Creating a service that serves the current customer
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个为当前客户服务的服务
- en: 'To keep the project simple, we are not using any authentication or authorization
    middleware, yet we want our BFF to be realistic and to handle who’s querying the
    downstream APIs. To achieve this, let’s create the `ICurrentCustomerService` interface
    that abstracts this away from the consuming code:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使项目简单，我们目前没有使用任何身份验证或授权中间件，但我们希望bff是现实的，并处理谁在查询下游API。为了实现这一点，让我们创建一个`ICurrentCustomerService`接口，它将这个功能从消费代码中抽象出来：
- en: '[PRE22]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The only thing that interface does is provide us with the identifier representing
    the current customer. Since we do not have authentication in the project, let’s
    implement a development version that always returns the same value:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口所做的唯一事情是提供代表当前客户的标识符。由于我们在项目中没有身份验证，让我们实现一个开发版本，它总是返回相同的值：
- en: '[PRE23]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we must register it in the `Program.cs` class like this:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须在`Program.cs`类中这样注册它：
- en: '[PRE24]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With this last piece, we are ready to write some features in our BFF service.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后部分，我们已经准备好在我们的bff服务中编写一些功能。
- en: 'In a project that uses authentication, you can inject the `IHttpContextAccessor`
    interface into a class to access the current `HttpContext` object that contains
    a `User` property that enables access to the current user’s `ClaimsPrincipal`
    object, which should include the current user’s `CustomerId`. Of course, you must
    ensure the authentication server returns such a claim. You must register the accessor
    using the following method before using it: `builder.Services.AddHttpContextAccessor()`.'
  id: totrans-382
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在使用身份验证的项目中，您可以将`IHttpContextAccessor`接口注入到类中，以访问包含`User`属性的当前`HttpContext`对象，该属性允许访问当前用户的`ClaimsPrincipal`对象，其中应包括当前用户的`CustomerId`。当然，您必须确保身份验证服务器返回此类声明。在使用之前，您必须使用以下方法注册访问器：`builder.Services.AddHttpContextAccessor()`。
- en: Features
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 功能
- en: 'The BFF service serves an unexisting user interface, yet we can imagine what
    it needs to do; it must:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: BFF服务提供了一个不存在的用户界面，但我们可以想象它需要做什么；它必须：
- en: Serve the product catalog so customers can browse the shop.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为客户提供产品目录，以便他们可以浏览商店。
- en: Serve a specific product to render a product details page.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为渲染产品详情页面提供特定产品。
- en: Serve the list of items in a user’s shopping cart.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为用户提供其购物车中的商品列表。
- en: Enable users to manage their shopping cart by adding, updating, and removing
    items.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户通过添加、更新和删除商品来管理他们的购物车。
- en: Of course, the list of features could go on, like allowing the users to purchase
    the items, which is the ultimate goal of an e-commerce website. However, we are
    not going that far. Let’s start with the catalog.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，功能列表可以继续，比如允许用户购买商品，这是电子商务网站最终目标。然而，我们不会走那么远。让我们从目录开始。
- en: Fetching the catalog
  id: totrans-390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取目录
- en: 'The catalog acts as a routing gateway and forwards the requests to the `Products`
    downstream service.The first endpoint serves the whole catalog by using our typed
    client (highlighted):'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 目录充当路由网关，并将请求转发到`Products`下游服务。第一个端点通过我们的类型客户端（突出显示）提供整个目录：
- en: '[PRE25]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Sending the following requests should hit the endpoint:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 发送以下请求应击中端点：
- en: '[PRE26]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The endpoint should respond with something like the following:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 端点应响应如下：
- en: '[PRE27]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here’s a visual representation of what happens:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是发生情况的视觉表示：
- en: '![Figure 19.27: a sequence diagram representing the BFF routing the request
    to the Products service](img/file155.png)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![图19.27：表示BFF将请求路由到产品服务的序列图](img/file155.png)'
- en: 'Figure 19.27: a sequence diagram representing the BFF routing the request to
    the Products service'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.27：表示BFF将请求路由到产品服务的序列图
- en: 'The other catalog endpoint is very similar and also simply routes the request
    to the correct downstream service:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个目录端点非常相似，并且也简单地路由请求到正确的下游服务：
- en: '[PRE28]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Sending an HTTP call will result in the same as calling it directly because
    the BFF only acts as a router.We explore more exciting features next.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 发送HTTP调用将产生与直接调用相同的结果，因为BFF仅作为路由器。我们将在下一部分探索更多令人兴奋的功能。
- en: Fetching the shopping cart
  id: totrans-403
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取购物车
- en: 'The *Baskets* service only stores the `customerId`, `productId`, and `quantity`
    properties. However, a shopping cart page displays the product name and price,
    but the *Products* service manages those two properties.To overcome this problem,
    the endpoint acts as an aggregation gateway. It queries the shopping cart and
    loads all the products from the *Products* service before returning an aggregated
    result, removing the burden of managing this complexity from the client/UI.Here’s
    the code main feature code:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '*购物车*服务仅存储`customerId`、`productId`和`quantity`属性。然而，购物车页面显示产品名称和价格，但*产品*服务管理这两个属性。为了克服这个问题，端点充当聚合网关。它在查询购物车之前从*产品*服务加载所有产品，然后返回聚合结果，从而减轻客户端/UI管理这种复杂性的负担。以下是主要功能代码：'
- en: '[PRE29]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding code starts by fetching the items from the Baskets service and
    then loads the products using the `Parallel.ForEachAsync` method before returning
    the aggregated result.The `Parallel` class allows us to execute multiple operations
    in parallel, in this case, multiple HTTP calls. There are many ways of achieving
    a similar result using .NET, and this is one of those. When an HTTP call succeeds,
    it adds a `BasketProduct` item to the `result` collection. Once all operations
    are completed, the endpoint returns the collection of `BasketProduct` objects,
    which contains all the combined information required by the user interface to
    display the shopping cart. Here’s the `BasketProduct` class:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码首先从 Baskets 服务获取项目，然后使用 `Parallel.ForEachAsync` 方法加载产品，最后返回聚合结果。`Parallel`
    类允许我们并行执行多个操作，在这种情况下，多个 HTTP 调用。使用 .NET 实现类似结果的方法有很多，这是其中之一。当 HTTP 调用成功时，它将 `BasketProduct`
    项目添加到 `result` 集合中。一旦所有操作完成，端点返回 `BasketProduct` 对象的集合，其中包含用户界面显示购物车所需的所有组合信息。以下是
    `BasketProduct` 类：
- en: '[PRE30]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The sequence of this endpoint is like this (the `loop` represents the `Parallel.ForEachAsync`
    method):'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 此端点的顺序如下（`loop` 代表 `Parallel.ForEachAsync` 方法）：
- en: '![Figure 19.28: A sequence diagram representing the shopping cart endpoint
    interacting with the Products and the Baskets downstream services.](img/file156.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![图 19.28：表示购物车端点与下游服务 Products 和 Baskets 交互的序列图。](img/file156.png)'
- en: 'Figure 19.28: A sequence diagram representing the shopping cart endpoint interacting
    with the Products and the Baskets downstream services.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.28：表示购物车端点与下游服务 Products 和 Baskets 交互的序列图。
- en: 'Since the requests to the *Products* service are sent in parallel, we cannot
    predict the order they will complete. Here is an excerpt from the application
    log depicting what can happen (I omitted the logging code in the book, but it
    is available on GitHub):'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对 *Products* 服务的请求是并行发送的，我们无法预测它们完成的顺序。以下是应用程序日志的摘录，描述了可能发生的情况（我在书中省略了日志代码，但它在
    GitHub 上可用）：
- en: '[PRE31]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding trace shows that we requested products `3` and `2` but received
    inverted responses (`2` and `3`). This is a possibility when running code in parallel.When
    we send the following request to the BFF:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的跟踪显示，我们请求了产品 `3` 和 `2`，但收到了倒置的响应（`2` 和 `3`）。在并行运行代码时，这种情况是可能的。当我们向 BFF 发送以下请求时：
- en: '[PRE32]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The BFF returns a response similar to the following:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: BFF 返回的响应类似于以下内容：
- en: '[PRE33]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding example showcases the aggregated result, simplifying the logic
    the client (UI) must implement to display the shopping cart.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例展示了聚合结果，简化了客户端（UI）必须实现以显示购物车的逻辑。
- en: Since we are not ordering the results, the items will not always be in the same
    order. As an exercise, you could sort the results using one of the existing properties
    or add a property that saves when a customer adds the item to the cart and sort
    the items using this new property; the first item added is displayed first, and
    so on.
  id: totrans-418
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于我们没有对结果进行排序，项目不一定会按相同的顺序出现。作为一个练习，你可以使用现有的某个属性对结果进行排序，或者添加一个属性，当客户将商品添加到购物车时保存该属性，并使用这个新属性对项目进行排序；首先添加的项目将首先显示，依此类推。
- en: Let’s move to the last endpoint and explore how the BFF manages the shopping
    cart items.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到最后一个端点，并探讨 BFF 如何管理购物车项目。
- en: Managing the shopping cart
  id: totrans-420
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 管理购物车
- en: 'One of the primary goals of our BFF is to reduce the frontend’s complexity.
    When examining the *Baskets* service, we realized it would add a bit of avoidable
    complexity if we were only to serve the raw operation, so instead, we decided
    to encapsulate all of the shopping cart logic behind a single endpoint. When a
    client POST to the `api/cart` endpoint, it:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 BFF 的一个主要目标是减少前端复杂性。在检查 *Baskets* 服务时，我们意识到如果我们只提供原始操作，将会增加一些不必要的复杂性，因此我们决定将所有购物车逻辑封装在一个单独的端点之后。当客户端向
    `api/cart` 端点 POST 时，它：
- en: Adds a non-existent item.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个不存在的商品。
- en: Update an existing item’s quantity.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新现有商品的数量。
- en: Remove an item that has a quantity equal to 0 or less.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除数量等于 0 或更少的商品。
- en: 'With this endpoint, the clients don’t have to worry about adding or updating.
    Here’s a simplified sequence diagram that represents this logic:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此端点，客户端无需担心添加或更新。以下是一个简化的序列图，表示此逻辑：
- en: '![Figure 19.29: A sequence diagram that displays the high-level algorithm of
    the cart endpoint.](img/file157.png)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![图 19.29：显示购物车端点高级算法的序列图。](img/file157.png)'
- en: 'Figure 19.29: A sequence diagram that displays the high-level algorithm of
    the cart endpoint.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.29：一个序列图，显示了购物车端点的高级算法。
- en: 'As the diagram depicts, we call the remove endpoint if the quantity is inferior
    or equal to zero. Otherwise, we try to add the item to the basket. If the endpoint
    returns a `409 Conflict`, we try to update the quantity. Here’s the code:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，如果数量低于或等于零，我们调用移除端点。否则，我们尝试将项目添加到篮子中。如果端点返回`409冲突`，我们尝试更新数量。以下是代码：
- en: '[PRE34]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding code follows the same pattern but contains the previously explained
    logic. We explore the two highlighted methods next, starting with the `RemoveItemFromCart`
    method:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码遵循相同的模式，但包含之前解释的逻辑。我们接下来探索两个突出显示的方法，首先是`RemoveItemFromCart`方法：
- en: '[PRE35]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The highlighted code of the preceding block leverages the typed HTTP client
    and sends a remove item command to the *Baskets* service. If the item is not in
    the cart, the code ignores the error and continues. Why? Because it does not affect
    the business logic or the end-user experience. Maybe the customer clicked the
    remove or update button twice. However, the code propagates to the client any
    other error.Let’s explore the `AddOrUpdateItem` method’s code:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中突出显示的代码利用了强类型HTTP客户端，并发送了一个移除项目命令到*篮子*服务。如果项目不在购物车中，代码忽略错误并继续。为什么？因为它不影响业务逻辑或最终用户体验。也许顾客点击了移除或更新按钮两次。然而，代码将任何其他错误传播到客户端。让我们探索`AddOrUpdateItem`方法的代码：
- en: '[PRE36]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding logic is very similar to the other method. It starts by adding
    the item to the cart. If it receives a `409 Conflict`, it tries to update its
    quantity. Otherwise, it lets the exception bubble up the stack to let an exception
    middleware catch it later to uniformize the error messages.With that code in place,
    we can send `POST` requests to the `api/cart` endpoint for adding, updating, and
    removing an item from the cart. The three operations return an empty `200 OK`
    response.Assuming we have an empty shopping cart, the following request adds *10*
    *Habanero Peppers* (`id=3`) to the shopping cart:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的逻辑与其他方法非常相似。它首先将项目添加到购物车中。如果收到`409冲突`，它会尝试更新数量。否则，它让异常向上冒泡到堆栈，以便稍后由异常中间件捕获以统一错误消息。有了这段代码，我们可以向`api/cart`端点发送`POST`请求以添加、更新和从购物车中删除项目。这三个操作返回一个空的`200
    OK`响应。假设我们的购物车为空，以下请求将*10* *哈瓦那辣椒*（`id=3`）添加到购物车中：
- en: '[PRE37]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following request adds *5 Apples* (`id=2`) to the cart:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 以下请求将*5个苹果*（`id=2`）添加到购物车中：
- en: '[PRE38]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following request updates the quantity to *20* *Habanero Peppers* (`id=3`)
    :'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 以下请求将数量更新为*20* *哈瓦那辣椒*（`id=3`）：
- en: '[PRE39]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following request removes the *Apples* (`id=2`) from the cart:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 以下请求从购物车中移除了*苹果*（`id=2`）：
- en: '[PRE40]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Leaving us with *20* *Habanero Peppers* in our shopping cart (`GET https://localhost:7254/api/cart`):'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 留下我们在购物车中的*20* *哈瓦那辣椒*（`GET https://localhost:7254/api/cart`）：
- en: '[PRE41]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The requests of the previous sequence are all in the same format, reaching the
    same endpoint but doing different things, which makes it very easy for the frontend
    client to manage.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 之前序列中的请求都采用相同的格式，到达相同的端点但执行不同的操作，这使得前端客户端管理起来非常容易。
- en: If you prefer having the UI to manage the operations individually or want to
    implement a batch update feature, you can; this is only an example of what you
    can leverage a BFF for.
  id: totrans-445
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你希望UI单独管理操作或想实现批量更新功能，你可以这样做；这只是一个示例，说明你可以利用BFF做什么。
- en: We are now done with the BFF service.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在完成了BFF服务。
- en: Conclusion
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'In this section, we learned about using the Backend for Frontend (BFF) design
    pattern to front a micro e-commerce web application. We discussed layering APIs
    and the advantages and disadvantages of a two-layer design. We autogenerated strongly
    typed HTTP clients using Refit, managed a shopping cart, and fetched the catalog
    from the BFF. We learned how to use a BFF to reduce complexity by moving domain
    logic from the frontend to the backend by implementing multiple Gateway patterns.Here
    are a few benefits that we explored:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用后端为前端（BFF）设计模式来面向微电子商务Web应用。我们讨论了分层API和双层设计的优缺点。我们使用Refit自动生成了强类型HTTP客户端，管理了购物车，并从BFF获取了目录。我们学习了如何通过实现多个网关模式将领域逻辑从前端移动到后端来使用BFF减少复杂性。以下是我们在探索中发现的几个好处：
- en: The BFF pattern can significantly simplify the interaction between frontend
    and backend systems. It provides a layer of abstraction that can reduce the complexity
    of using low-level atomic APIs. It separates generic and domain-specific functionalities
    and promotes cleaner, more modular code.
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: bff模式可以显著简化前端和后端系统之间的交互。它提供了一个抽象层，可以减少使用低级原子API的复杂性。它将通用功能和领域特定功能分离，并促进更干净、更模块化的代码。
- en: A BFF can act as a gateway that routes specific requests to relevant services,
    reducing the work the frontend has to perform. It can also serve as an aggregation
    gateway, gathering data from various services into a unified response. This process
    can simplify frontend development by reducing the complexity of the frontend and
    the number of separate calls the frontend must make. It can also reduce the payload
    size transported between the frontend and backend.
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个bff可以作为网关，将特定请求路由到相关服务，从而减少前端需要执行的工作。它还可以作为聚合网关，将来自各种服务的数据进行汇总，形成统一的响应。这个过程可以通过减少前端的复杂性和前端必须进行的单独调用数量来简化前端开发。它还可以减少前端和后端之间传输的有效负载大小。
- en: Each BFF is tailored to a specific client, optimizing the frontend interaction.
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个bff都是针对特定客户端定制的，优化前端交互。
- en: A BFF can handle issues in one domain without affecting the low-level APIs or
    the other applications, thus providing easier maintenance.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个bff可以在不影响低级API或其他应用程序的情况下处理一个域的问题，从而提供更简单的维护。
- en: A BFF can implement security logic, such as specific domain-oriented authentication
    and authorization rules.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个bff可以实现安全逻辑，例如特定领域导向的认证和授权规则。
- en: Despite these benefits, using a BFF may also increase complexity and introduce
    potential performance overhead. Using a BFF is no different than any other pattern
    and must be counter-balanced and adapted to the specific needs of a project.Next,
    we revisit CQRS on a distributed scale.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这些好处，使用bff也可能增加复杂性并引入潜在的性能开销。使用bff与其他模式没有区别，必须权衡并适应项目的具体需求。接下来，我们再次在分布式规模上重新审视CQRS。
- en: Revisiting the CQRS pattern
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视CQRS模式
- en: '**Command Query Responsibility Segregation** (**CQRS**) applies the **Command
    Query Separation** (**CQS**) principle. Compared to what we saw in *Chapter 14*,
    *Mediator and CQRS Design Patterns*, we can push CQRS further using microservices
    or serverless computing. Instead of simply creating a clear separation between
    commands and queries, we can divide them even more using multiple microservices
    and data sources.**CQS** is a principle stating that a method should either return
    data or mutate data, but not both. On the other hand, **CQRS** suggests using
    one model to read the data and one model to mutate the data.**Serverless computing**
    is a cloud execution model where the cloud provider manages the servers and allocates
    the resources on-demand, based on usage and configuration. Serverless resources
    fall into the platform as a service (PaaS) offering.Let’s come back to our IoT
    example again. We queried the last known location of a device in the previous
    examples, but what about the device updating that location? This can mean pushing
    many updates every minute. To solve this issue, we are going to use CQRS and focus
    on two operations:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令查询责任分离**（**CQRS**）应用了**命令查询分离**（**CQS**）原则。与我们在*第14章*，*中介者和CQRS设计模式*中看到的内容相比，我们可以通过使用微服务或无服务器计算来进一步推进CQRS。我们不仅可以在命令和查询之间创建清晰的分离，还可以通过多个微服务和数据源将它们进一步细分。**CQS**是一个原则，表示一个方法应该要么返回数据，要么修改数据，但不能两者兼有。另一方面，**CQRS**建议使用一个模型来读取数据，另一个模型来修改数据。**无服务器计算**是一种云执行模型，其中云提供商管理服务器，并根据使用情况和配置按需分配资源。无服务器资源属于平台即服务（PaaS）提供的产品。让我们再次回到我们的物联网示例。在先前的示例中，我们查询了设备的最后已知位置，但设备更新位置怎么办？这可能意味着每分钟推送许多更新。为了解决这个问题，我们将使用CQRS并专注于两个操作：'
- en: Updating the device location.
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新设备位置。
- en: Reading the last known location of a device.
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取设备的最后已知位置。
- en: 'Simply put, we have a `Read Location` microservice, a `Write Location` microservice,
    and two databases. Remember that each microservice should own its data. This way,
    a user can access the last known device location through the read microservice
    (query model), while a device can punctually send its current position to the
    write microservice (command model). By doing this, we split the load from reading
    and writing the data as both occur at different frequencies:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们有一个`Read Location`微服务，一个`Write Location`微服务，以及两个数据库。请记住，每个微服务应该拥有自己的数据。这样，用户可以通过读取微服务（查询模型）访问最后已知的设备位置，而设备可以准时将其当前位置发送到写入微服务（命令模型）。通过这种方式，我们将读取和写入数据的负载分开，因为这两种操作发生的频率不同：
- en: '![Figure 19.30: Microservices that apply CQRS to divide the reads and writes
    of a device’s location](img/file158.png)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![图19.30：应用CQRS来分割设备位置读取和写入的微服务](img/file158.png)'
- en: 'Figure 19.30: Microservices that apply CQRS to divide the reads and writes
    of a device’s location'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.30：应用CQRS来分割设备位置读取和写入的微服务
- en: In the preceding schema that illustrates the concept, the reads are queries,
    and the writes are commands. How to update the Read DB once a new value is added
    to the Write DB depends on the technology at play. One essential thing in this
    type of architecture is that, per the CQRS pattern, a command should not return
    a value, enabling a “fire and forget” scenario. With that rule in place, consumers
    don’t have to wait for the command to complete before doing something else.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前说明概念的方案中，读取是查询，写入是命令。一旦在写入数据库中添加了新值，如何更新Read DB取决于所使用的技术。在这种类型的架构中，一个基本的事情是，根据CQRS模式，命令不应该返回值，从而实现“发射并忘记”场景。有了这个规则，消费者不必等待命令完成就可以做其他事情。
- en: Fire and forget does not apply to every scenario; sometimes, we need synchronization.
    Implementing the Saga pattern is one way to solve coordination issues.
  id: totrans-463
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “发射并忘记”并不适用于每个场景；有时，我们需要同步。实现Saga模式是解决协调问题的一种方法。
- en: 'Conceptually, we can implement this example by leveraging serverless cloud
    infrastructures, such as Azure Functions. Let’s revisit this example using a high-level
    conceptual serverless design:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，我们可以通过利用无服务器云基础设施，如Azure Functions，来实现这个示例。让我们使用一个高级概念性的无服务器设计重新审视这个示例：
- en: '![Figure 19.31: Using Azure services to manage a CQRS implementation](img/file159.png)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![图19.31：使用Azure服务管理CQRS实现](img/file159.png)'
- en: 'Figure 19.31: Using Azure services to manage a CQRS implementation'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.31：使用Azure服务管理CQRS实现
- en: 'The previous diagram illustrates the following:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的图示说明了以下内容：
- en: The device sends its location regularly by posting it to *Azure Function 1*.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设备通过将其发布到*Azure Function 1*来定期发送其位置。
- en: '*Azure Function 1* then publishes the `LocationAdded` event to the event broker,
    which is also an event store (the Write DB).'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*Azure Function 1* 然后将`LocationAdded`事件发布到事件代理，该代理也是一个事件存储（写入数据库）。'
- en: All subscribers to the `LocationAdded` event can now handle the event appropriately,
    in this case, *Azure Function 2*.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，所有订阅`LocationAdded`事件的订阅者都可以适当地处理该事件，在这种情况下，*Azure Function 2*。
- en: '*Azure Function 2* updates the device''s last known location in the *Read DB*.'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*Azure Function 2* 在*Read DB*中更新设备的最后已知位置。'
- en: Any subsequent queries should result in reading the new location.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何后续的查询都应该导致读取新的位置。
- en: The message broker is also the event store in the preceding diagram, but we
    could store events elsewhere, such as in an Azure Storage Table, in a time-series
    database, or in an Apache Kafka cluster. Azure-wise, the datastore could also
    be CosmosDB. Moreover, I abstracted this component for multiple reasons, including
    the fact that there are multiple “as-a-service” offerings to publish events in
    Azure and multiple ways of using third-party components (both open-source and
    proprietary).Furthermore, the example demonstrates **eventual consistency** well.
    All the last known location reads between *steps 1* and *4* get the old value
    while the system processes the new location updates (commands). If the command
    processing slows down for some reason, a longer delay could occur before the next
    read database updates. The commands could also be processed in batches, leading
    to another kind of delay. No matter what happens with the command processing,
    the read database is available all that time, whether it serves the latest data
    or not and whether the write system is overloaded or not. This is the beauty of
    this type of design, but it is more complex to implement and maintain.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 消息代理也是前面图中的事件存储，但我们可以在其他地方存储事件，例如在Azure存储表中、在时间序列数据库中或在Apache Kafka集群中。在Azure方面，数据存储也可以是CosmosDB。此外，我出于多个原因抽象了这个组件，包括在Azure中发布事件有多种“作为服务”的提供方式，以及使用第三方组件（开源和专有）的多种方式。此外，该示例很好地展示了**最终一致性**。在步骤1和步骤4之间，所有最后已知的读取位置都获取了旧值，而系统正在处理新的位置更新（命令）。如果由于某种原因命令处理速度减慢，下一次读取数据库更新之前可能会出现更长的延迟。命令也可以批量处理，导致另一种类型的延迟。无论命令处理发生什么情况，读取数据库始终可用，无论它是否提供最新数据，以及写入系统是否过载。这是此类设计的美丽之处，但实现和维护起来更为复杂。
- en: '**Time-series databases** are optimized for temporally querying and storing
    data, where you always append new records without updating old ones. This kind
    of NoSQL database can be useful for temporal-intensive usage, like metrics.'
  id: totrans-474
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**时间序列数据库**针对时间查询和存储数据进行了优化，在这种数据库中，你总是追加新的记录而不更新旧的记录。这种NoSQL数据库对于需要大量时间处理的用途，如指标，可能很有用。'
- en: 'Once again, we used the Publish-Subscribe pattern to get another scenario going.
    Assuming that events are persisted forever, the previous example could also support
    event sourcing. Furthermore, new services could subscribe to the `LocationAdded`
    event without impacting the code that has already been deployed. For example,
    we could create a SignalR microservice that pushes the updates to its clients.
    It is not CQRS-related, but it flows well with everything that we’ve explored
    so far, so here is an updated conceptual diagram:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用发布-订阅模式来启动另一个场景。假设事件永久保存，前面的示例也可以支持事件溯源。此外，新服务可以订阅`LocationAdded`事件，而不会影响已部署的代码。例如，我们可以创建一个SignalR微服务，将其更新推送到其客户端。这与CQRS无关，但它与迄今为止我们所探索的一切都很好地融合在一起，所以这里有一个更新的概念图：
- en: '![Figure 19.32: Adding a SignalR service as a new subscriber without impacting
    the other part of the system](img/file160.png)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
  zh: '![图19.32：在不影响系统其他部分的情况下添加SignalR服务作为新的订阅者](img/file160.png)'
- en: 'Figure 19.32: Adding a SignalR service as a new subscriber without impacting
    the other part of the system'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.32：在不影响系统其他部分的情况下添加SignalR服务作为新的订阅者
- en: The SignalR microservice could be custom code or an Azure SignalR Service (backed
    by another Azure Function); it doesn’t matter. With this design, the Web App could
    know that a change occurred before the Read DB gets updated.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR微服务可以是自定义代码或Azure SignalR服务（由另一个Azure Function支持）；这无关紧要。在这种设计下，Web应用可以在读取数据库更新之前知道已发生更改。
- en: With this design, I wanted to illustrate that dropping new services into the
    mix is easier when using a Pub-Sub model than with point-to-point communication.
  id: totrans-479
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用这种设计，我想说明在采用发布-订阅模型时，将新服务添加到系统中比使用点对点通信更容易。
- en: As you can see, a microservices system adds more and more small pieces that
    indirectly interconnect with each other over one or more message brokers. Maintaining,
    diagnosing, and debugging such systems is harder than with a single application;
    that’s the **operational complexity** we discussed earlier. However, containers
    can help deploy and maintain such systems.Starting in ASP.NET Core 3.0, the ASP.NET
    Core team invested much effort into **distributed tracing**. Distributed tracing
    is necessary to find failures and bottlenecks related to an event that flows from
    one program to another (such as microservices). If something bugs out, it is important
    to trace what the user did to isolate the error, reproduce it, and then fix it.
    The more independent pieces there are, the harder it can become to make that trace
    possible. This is outside the scope of this book, but it is something to consider
    if you plan to leverage microservices.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，微服务系统添加了越来越多的组件，这些组件通过一个或多个消息代理间接相互连接。与单个应用程序相比，维护、诊断和调试此类系统更困难；这就是我们之前讨论的**操作复杂性**。然而，容器可以帮助部署和维护此类系统。从ASP.NET
    Core 3.0开始，ASP.NET Core团队投入了大量精力进行**分布式跟踪**。分布式跟踪对于查找从程序到程序（如微服务）流动的事件相关的故障和瓶颈是必要的。如果出现问题，追踪用户的行为以隔离错误、重现它并修复它非常重要。独立组件越多，使这种跟踪变得越困难。这超出了本书的范围，但如果你计划利用微服务，这是一个需要考虑的问题。
- en: Advantages and potential risks
  id: totrans-481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优势和潜在风险
- en: This section explores some advantages and risks of separating a data store's
    read and write operations using the CQRS pattern.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了使用CQRS模式分离数据存储的读和写操作的一些优势和风险。
- en: Benefits of the CQRS pattern
  id: totrans-483
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CQRS模式的好处
- en: '**Scalability:** Given that read and write workloads can be scaled independently,
    CQRS can lead to much higher scalability in a distributed cloud- or microservices-based
    applications.'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性：** 由于读和写工作负载可以独立扩展，CQRS可以导致基于分布式云或微服务的应用程序具有更高的可伸缩性。'
- en: '**Simplified and Optimized Models:** It separates the read model (query responsibility)
    and write model (command responsibility), which simplifies application development
    and can optimize performance.'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化和优化模型：** 它将读模型（查询责任）和写模型（命令责任）分开，这简化了应用程序开发并可以优化性能。'
- en: '**Flexibility:** Different models increase the number of choices one can make,
    increasing flexibility.'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性：** 不同的模型增加了可以选择的数量，增加了灵活性。'
- en: '**Enhanced Performance:** CQRS can prevent unnecessary data fetching and allows
    choosing an optimized database for each job, improving the performance of both
    read and write operations.'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强性能：** CQRS可以防止不必要的数据库访问，并允许为每个任务选择优化的数据库，从而提高读和写操作的性能。'
- en: '**Increased Efficiency:** It enables parallel development on complex applications,
    as teams can work independently on the separate read and write sides of the application.'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高效率：** 它允许在复杂应用程序上进行并行开发，因为团队可以在应用程序的独立读和写两侧独立工作。'
- en: Potential Risks of using the CQRS pattern
  id: totrans-489
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用CQRS模式的潜在风险
- en: '**Complexity:** CQRS adds complexity to the system. It may not be necessary
    for simple CRUD apps and could over-complicate the application unnecessarily.
    Therefore, using CQRS only in complex systems and when the advantages outweigh
    the cons is advisable.'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性：** CQRS增加了系统的复杂性。它可能不是简单的CRUD应用程序所必需的，并且可能会不必要地使应用程序过于复杂。因此，建议仅在复杂系统中使用CQRS，并且当优势超过劣势时才使用。'
- en: '**Data Consistency:** It can introduce eventual consistency issues between
    the read and write sides because the read model''s updates are asynchronous, which
    might not fit every business requirement.'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据一致性：** 由于读模型的更新是异步的，这可能会引入读和写之间的最终一致性问题和业务需求不匹配。'
- en: '**Increased Development Effort:** CQRS could mean increased development, testing,
    and maintenance efforts due to handling two separate models and more pieces.'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加的开发工作量：** CQRS可能意味着由于处理两个独立的模型和更多组件，开发、测试和维护工作量的增加。'
- en: '**Learning Curve:** The pattern has its own learning curve. Team members unfamiliar
    with the CQRS pattern will require training and to gain some experience.'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学习曲线：** 该模式有其自己的学习曲线。对CQRS模式不熟悉的团队成员需要培训并获得一些经验。'
- en: '**Synchronization Challenges:** Maintaining synchronization between the read
    and write models can be challenging, especially in high data volume cases.'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步挑战：** 在高数据量情况下，保持读模型和写模型之间的同步可能具有挑战性。'
- en: Conclusion
  id: totrans-495
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'CQRS helps divide queries and commands and helps encapsulate and isolate each
    block of logic independently. Mixing that concept with serverless computing or
    microservices architecture allows us to scale reads and writes independently.
    We can also use different databases, empowering us with the tools we need for
    the transfer rate required by each part of that system (for example, frequent
    writes and occasional reads or vice versa).Major cloud providers like Azure and
    AWS provide serverless offerings to help support such scenarios. Each cloud provider’s
    documentation should help you get started. Meanwhile, for Azure, we have Azure
    Functions, Event Grid, Event Hubs, Service Bus, Cosmos DB, and more. Azure also
    offers bindings between the different services that are triggered or react to
    events for you, removing a part of the complexity yet locking you down with that
    vendor.Now, let’s see how CQRS can help us follow the **SOLID** principles at
    the cloud scale:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS有助于划分查询和命令，并有助于封装和独立隔离每一块逻辑。将这个概念与无服务器计算或微服务架构相结合，使我们能够独立扩展读取和写入。我们还可以使用不同的数据库，赋予我们所需的工具，以满足该系统各部分所需的传输速率（例如，频繁的写入和偶尔的读取或反之亦然）。像Azure和AWS这样的主要云提供商提供无服务器服务来支持此类场景。每个云提供商的文档都应该能帮助你入门。同时，对于Azure，我们有Azure
    Functions、Event Grid、Event Hubs、Service Bus、Cosmos DB等。Azure还提供了不同服务之间的绑定，这些服务由事件触发或响应，为你移除了一部分复杂性，但同时也将你锁定在该供应商上。现在，让我们看看CQRS如何帮助我们遵循**SOLID**原则在云规模上：
- en: '**S**: Dividing an application into smaller reads and writes applications (or
    functions) leans toward encapsulating single responsibilities into different programs.'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**: 将应用程序划分为更小的读取和写入应用程序（或函数）倾向于将单一责任封装到不同的程序中。'
- en: '**O**: CQRS, mixed with serverless computing or microservices, helps extend
    the software without needing us to modify the existing code by adding, removing,
    or replacing applications.'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**: 将CQRS与无服务器计算或微服务相结合，可以帮助我们扩展软件，而无需通过添加、删除或替换应用程序来修改现有代码。'
- en: '**L**: N/A'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**: 无需操作'
- en: '**I**: CQRS set us up to create multiple small interfaces (or programs) with
    a clear distinction between commands and queries.'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**: CQRS使我们能够创建多个小型接口（或程序），其中命令和查询之间有明确的区分。'
- en: '**D**: N/A'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**: 无需操作'
- en: Exploring the Microservice Adapter pattern
  id: totrans-502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索微服务适配器模式
- en: 'The Microservice Adapter pattern allows adding missing features, adapting one
    system to another, or migrating an existing application to an event-driven architecture
    model, to name a few possibilities. The Microservice Adapter pattern is similar
    to the Adapter pattern we cover in *Chapter 9*, *Structural Patterns*, but applied
    to a microservices system that uses event-driven architecture instead of creating
    a class to adapt an object to another signature.In the scenarios we cover in this
    section, the microservices system represented by the following diagram can be
    replaced by a standalone application as well; this pattern applies to all sorts
    of programs, not just microservices, which is why I abstracted away the details:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务适配器模式允许添加缺失的功能，将一个系统适配到另一个系统，或将现有应用程序迁移到事件驱动架构模型，仅举几个可能性。微服务适配器模式类似于我们在第9章“结构型模式”中介绍的适配器模式，但应用于使用事件驱动架构的微服务系统，而不是创建一个类来适配一个对象到另一个签名。在本节中我们讨论的场景中，以下图中表示的微服务系统也可以被一个独立的应用程序所替代；这个模式适用于各种程序，而不仅仅是微服务，这就是为什么我抽象掉了细节：
- en: '![Figure 19.33: Microservice system representation used in the subsequent examples](img/file161.png)'
  id: totrans-504
  prefs: []
  type: TYPE_IMG
  zh: '![图19.33：后续示例中使用的微服务系统表示](img/file161.png)'
- en: 'Figure 19.33: Microservice system representation used in the subsequent examples'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.33：后续示例中使用的微服务系统表示
- en: 'Here are the examples we are covering next and possible usages of this pattern:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们接下来要讨论的示例和此模式可能的用法：
- en: Adapting an existing system to another.
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将现有系统适配到另一个系统。
- en: Decommissioning a legacy application.
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停用遗留应用程序。
- en: Adapting an event broker to another.
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将事件代理适配到另一个系统。
- en: Let’s start by connecting a standalone system to an event-driven one.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从一个独立系统连接到一个事件驱动系统开始。
- en: Adapting an existing system to another
  id: totrans-511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将现有系统适配到另一个系统
- en: 'In this scenario, we have an existing system of which we don’t control the
    source code or don’t want to change, and we have a microservices system built
    around an event-driven architecture model. We don’t have to control the source
    code of the microservices system either as long as we have access to the event
    broker.Here is a diagram that represents this scenario:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有一个现有系统，我们无法控制其源代码或者不想对其进行更改，并且我们有一个围绕事件驱动架构模型构建的微服务系统。只要我们能访问事件代理，我们也不必控制微服务系统的源代码。以下是一个表示此场景的图示：
- en: '![Figure 19.34: A microservices system that interacts with an event broker
    and an existing system that is disconnected from the microservices](img/file162.png)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![图19.34：一个与事件代理和未连接到微服务的现有系统交互的微服务系统](img/file162.png)'
- en: 'Figure 19.34: A microservices system that interacts with an event broker and
    an existing system that is disconnected from the microservices'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.34：一个与事件代理和未连接到微服务的现有系统交互的微服务系统
- en: 'As we can see from the preceding diagram, the existing system is disconnected
    from the microservices and the broker. To adapt the existing system to the microservices
    system, we must subscribe or publish certain events. Let’s see how to read data
    from the microservices (subscribe to the broker) and then update that data into
    the existing system.When we control the existing system’s code, we can open the
    source code, subscribe to one or more topics, and change the behaviors from there.
    In our case, we don’t want to do that or can’t, so we can’t directly subscribe
    to topics, as demonstrated by the following diagram:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，现有系统与微服务和代理断开连接。为了使现有系统适应微服务系统，我们必须订阅或发布某些事件。让我们看看如何从微服务（订阅代理）读取数据，然后将该数据更新到现有系统中。当我们控制现有系统的代码时，我们可以打开源代码，订阅一个或多个主题，并从那里更改行为。在我们的情况下，我们不想这样做或者不能这样做，因此我们无法直接订阅主题，如下面的图示所示：
- en: '![Figure 19.35: Missing capabilities to connect an existing system to an event-driven
    one](img/file163.png)'
  id: totrans-516
  prefs: []
  type: TYPE_IMG
  zh: '![图19.35：连接现有系统到事件驱动型系统的缺失功能](img/file163.png)'
- en: 'Figure 19.35: Missing capabilities to connect an existing system to an event-driven
    one'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.35：连接现有系统到事件驱动型系统的缺失功能
- en: 'This is where the microservice adapter comes into play and allows us to fill
    the capability gap of our existing system. To add the missing link, we create
    a microservice that subscribes to the appropriate events, then apply the changes
    in the existing system, like this:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是微服务适配器发挥作用并允许我们填补现有系统能力差距的地方。为了添加缺失的环节，我们创建了一个订阅适当事件的微服务，然后在此处应用对现有系统的更改，如下所示：
- en: '![Figure 19.36: An adapter microservice adding missing capabilities to an existing
    system](img/file164.png)'
  id: totrans-519
  prefs: []
  type: TYPE_IMG
  zh: '![图19.36：一个适配器微服务向现有系统添加缺失的功能](img/file164.png)'
- en: 'Figure 19.36: An adapter microservice adding missing capabilities to an existing
    system'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.36：一个适配器微服务向现有系统添加缺失的功能
- en: As we can see in the preceding diagram, the `Adapter` microservice gets the
    events (subscribes to one or more topics) and then uses that data from the microservices
    system to execute some business logic on the existing system.In this design, the
    new `Adapter` microservice allowed us to add missing capabilities to a system
    we had no control over with little to no disruption to users’ day-to-day activities.The
    example assumes the existing system had some form of extensibility mechanism like
    an API. If the system does not, we would have to be more creative to interface
    with it.For example, the microservices system could be an e-commerce website,
    and the existing system could be a legacy inventory management system. The adapter
    could update the legacy system with new order data.The existing system could also
    be an old **customer relationship management** (**CRM**) system that you want
    to update when users of the microservices application execute some actions, like
    changing their phone number or address.The possibilities are almost endless; you
    create a link between an event-driven system and an existing system you don’t
    control or don’t want to change. In this case, the microservice adapter allows
    us to follow the **Open-Closed principle** by extending the system without changing
    the existing pieces. The primary drawback is that we are deploying another microservice
    that has direct coupling with the existing system, which may be best for temporary
    solutions. On that same line of thought, next, we replace a legacy application
    with a new one with limited to no downtime.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，`适配器`微服务获取事件（订阅一个或多个主题），然后使用来自微服务系统的数据在现有系统上执行一些业务逻辑。在这个设计中，新的`适配器`微服务使我们能够向一个我们无法控制的系统中添加缺失的功能，同时对用户日常活动的影响很小或没有。示例假设现有系统具有某种形式的可扩展机制，如API。如果系统没有，我们就需要更具创造性来与之接口。例如，微服务系统可能是一个电子商务网站，而现有系统可能是一个遗留的库存管理系统。适配器可以更新遗留系统中的新订单数据。现有系统也可能是你希望当微服务应用程序的用户执行某些操作时（如更改电话号码或地址）进行更新的旧**客户关系管理**（**CRM**）系统。可能性几乎是无限的；你创建一个事件驱动系统和你不控制或不想改变的现实系统之间的链接。在这种情况下，微服务适配器使我们能够通过扩展系统而不改变现有部分来遵循**开闭原则**。主要的缺点是我们正在部署另一个与现有系统直接耦合的微服务，这可能最适合临时解决方案。沿着这个思路，接下来，我们用一个新的应用程序替换遗留应用程序，尽量减少停机时间。
- en: Decommissioning a legacy application
  id: totrans-522
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 退役遗留应用程序
- en: 'In this scenario, we have a legacy application to decommission and a microservices
    system to which we want to connect some existing capabilities. To achieve this,
    we can create one or more adapters to migrate all features and dependencies to
    the new model.Here is a representation of the current state of our system:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有一个要退役的遗留应用程序和一个我们想要连接一些现有功能的微服务系统。为了实现这一点，我们可以创建一个或多个适配器，将所有功能和依赖项迁移到新的模型。以下是我们的系统当前状态的表示：
- en: '![Figure 19.37: The original legacy application and its dependencies](img/file165.png)'
  id: totrans-524
  prefs: []
  type: TYPE_IMG
  zh: '![图19.37：原始遗留应用程序及其依赖项](img/file165.png)'
- en: 'Figure 19.37: The original legacy application and its dependencies'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.37：原始遗留应用程序及其依赖项
- en: 'The preceding diagram shows the two distinct systems, including the legacy
    application we want to decommission. Two other applications, dependency A and
    B, directly depend on the legacy application. The exact migration flow is strongly
    dependent on your use case. If you want to keep the dependencies, we want to migrate
    them first. To do that, we can create an event-driven `Adapter` microservice that
    breaks the tight coupling between the dependencies and the legacy application
    like this:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了两个不同的系统，包括我们想要退役的遗留应用程序。另外两个应用程序，依赖项A和B，直接依赖于遗留应用程序。确切的迁移流程强烈依赖于你的用例。如果你想保留依赖项，我们希望首先迁移它们。为此，我们可以创建一个事件驱动的`适配器`微服务，像这样打破依赖项和遗留应用程序之间的紧密耦合：
- en: '![Figure 19.38: Adding a microservice adapter that implements the event-driven
    flow required to break tight coupling between the dependencies and the legacy
    application](img/file166.png)'
  id: totrans-527
  prefs: []
  type: TYPE_IMG
  zh: '![图19.38：添加一个实现事件驱动流程的微服务适配器，以打破依赖项和遗留应用程序之间的紧密耦合](img/file166.png)'
- en: 'Figure 19.38: Adding a microservice adapter that implements the event-driven
    flow required to break tight coupling between the dependencies and the legacy
    application'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.38：添加一个实现事件驱动流程的微服务适配器，以打破依赖项和遗留应用程序之间的紧密耦合
- en: 'The preceding diagram shows an `Adapter` microservice and the rest of a microservices
    system that communicates using an event broker. As we explored in the previous
    example, the adapter was placed there to connect the legacy application to the
    microservices. Our scenario focuses on removing the legacy application and migrating
    its two dependencies. Here, we carved out the required capabilities using the
    adapter, allowing us to migrate the dependencies to an event-driven model and
    break tight coupling with the legacy application. Such migration could be done
    in multiple steps, migrating each dependency one by one, and we could even create
    one adapter per dependency. For the sake of simplicity, I chose to draw only one
    adapter. You may want to revisit this choice if your dependencies are large or
    complex.Once we are done migrating the dependencies, our systems look like the
    following:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图表显示了使用事件代理进行通信的`Adapter`微服务和微服务系统中的其余部分。正如我们在上一个示例中所探讨的，适配器被放置在那里以连接遗留应用和微服务。我们的场景专注于移除遗留应用并迁移其两个依赖项。在这里，我们使用适配器划出了所需的能力，使我们能够将依赖项迁移到事件驱动模型，并打破与遗留应用的紧密耦合。这种迁移可以分多步进行，逐个迁移每个依赖项，我们甚至可以为每个依赖项创建一个适配器。为了简化，我选择只画一个适配器。如果你的依赖项很大或很复杂，你可能需要重新考虑这个选择。一旦我们完成了依赖项的迁移，我们的系统看起来如下：
- en: '![Figure 19.39: The dependencies are now using an event-driven architecture,
    and the adapter microservice is bridging the gap between the events and the legacy
    system](img/file167.png)'
  id: totrans-530
  prefs: []
  type: TYPE_IMG
  zh: '![图19.39：依赖项现在正在使用事件驱动架构，适配器微服务正在弥合事件和遗留系统之间的差距](img/file167.png)'
- en: 'Figure 19.39: The dependencies are now using an event-driven architecture,
    and the adapter microservice is bridging the gap between the events and the legacy
    system'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.39：依赖项现在正在使用事件驱动架构，适配器微服务正在弥合事件和遗留系统之间的差距
- en: In the preceding diagram, the Adapter microservice executes the operations against
    the legacy application API that the two dependencies were doing before. The dependencies
    are now publishing events instead of using the API. For example, when an operation
    happens in `DependencyB`, it publishes an event to the broker. The Adapter microservice
    picks up that event and executes the original operation against the API. Doing
    this creates more complexity and is a temporary state.With this new architecture
    in place, we can start migrating existing features away from the legacy application
    into the new application without impacting the dependencies; we broke tight coupling.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一张图表中，适配器微服务执行了两个依赖项之前对遗留应用API的操作。现在，依赖项正在发布事件而不是使用API。例如，当`DependencyB`中发生操作时，它会向代理发布一个事件。适配器微服务接收到该事件，并针对API执行原始操作。这样做增加了复杂性，是一种临时状态。有了这种新的架构，我们可以开始将现有功能从遗留应用迁移到新应用，而不会影响依赖项；我们打破了紧密耦合。
- en: From this point forward, we are applying the **Strangler Fig** pattern to migrate
    the legacy system piece by piece to our new architecture. For the sake of simplicity,
    think of the Strangler Fig pattern as migrating features from one application
    to another, one by one. In this case, we replaced one application with another,
    but we could also use the same patterns to split an application into multiple
    smaller applications (like microservices).
  id: totrans-533
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从现在开始，我们正在应用**Strangler Fig**模式，逐步将遗留系统迁移到我们的新架构中。为了简化，你可以将Strangler Fig模式视为逐个迁移功能从一个应用到另一个应用。在这种情况下，我们用一个应用替换了另一个应用，但我们也可以使用相同的模式将一个应用拆分成多个更小的应用（如微服务）。
- en: ''
  id: totrans-534
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I left a few links in the further reading section in case migrating legacy systems
    is something you do or simply if you want to know more about that pattern.
  id: totrans-535
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我在“进一步阅读”部分留下了一些链接，以防迁移遗留系统是你正在做的事情，或者只是想了解更多关于该模式的信息。
- en: The following diagram is a visual representation that adds the modern application
    we are building to replace the legacy application. That new modern application
    could also be a purchased product you are putting in place instead; the concepts
    we are exploring apply to both use cases, but the exact steps are directly related
    to the technology at play.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表是一个视觉表示，它将我们正在构建的、用于替换遗留应用的现代应用添加进去。那个新的现代应用也可能是一个你正在部署的购买产品；我们正在探讨的概念适用于这两种用例，但具体的步骤与所涉及的技术直接相关。
- en: '![Figure 19.40: The modern application to replace the legacy application is
    starting to emerge by migrating capabilities to that new application](img/file168.png)'
  id: totrans-537
  prefs: []
  type: TYPE_IMG
  zh: '![图19.40：通过将功能迁移到那个新应用，用于替换旧应用的现代应用开始显现](img/file168.png)'
- en: 'Figure 19.40: The modern application to replace the legacy application is starting
    to emerge by migrating capabilities to that new application'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.40：通过将功能迁移到那个新应用，用于替换旧应用的现代应用开始显现
- en: 'In the preceding diagram, we see the new modern application has appeared. Each
    time we deploy a new feature to the new application, we can remove it from the
    adapter, leading to a graceful transition between the two models. At the same
    time, we are keeping the legacy application in place to continue to provide the
    capabilities that are not yet migrated.Once all the features we want to keep are
    migrated, we can remove the adapter and decommission the legacy application, leading
    to the following system:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们看到新的现代应用已经出现。每次我们将新功能部署到新应用中，我们都可以将其从适配器中移除，从而在两种模型之间实现优雅的过渡。同时，我们保留旧应用以继续提供尚未迁移的功能。一旦我们想要保留的所有功能都已迁移，我们就可以移除适配器并淘汰旧应用，从而得到以下系统：
- en: '![Figure 19.41: The new system topology after the retirement of the legacy
    application, showing the new modern application and its two loosely coupled dependencies](img/file169.png)'
  id: totrans-540
  prefs: []
  type: TYPE_IMG
  zh: '![图19.41：在淘汰了旧应用后，新的系统拓扑结构，展示了新的现代应用及其两个松散耦合的依赖项](img/file169.png)'
- en: 'Figure 19.41: The new system topology after the retirement of the legacy application,
    showing the new modern application and its two loosely coupled dependencies'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.41：在淘汰了旧应用后，新的系统拓扑结构，展示了新的现代应用及其两个松散耦合的依赖项
- en: The preceding diagram shows the new system topology encompassing a new modern
    application and the two original dependencies that are now loosely coupled through
    event-driven architecture. Of course, the bigger the migration, the more complex
    it will be and the longer it will take, but the Adapter Microservice pattern is
    one way to help do a partial or complete migration from one system to another.Like
    the preceding example, the main advantage is adding or removing capabilities without
    impacting the other systems, which allows us to migrate and break the tight coupling
    between the different dependencies. The downside is the added complexity of this
    temporary solution. Moreover, during the migration step, you will most likely
    need to deploy both the modern application and the adapter in the correct sequence
    to ensure both systems are not handling the same events twice, leading to duplicate
    changes. For example, updating the phone number to the same value twice should
    be all right because it leads to the same final data set. However, creating two
    records instead of one should be more important to mitigate as it may lead to
    integrity errors in the data set. For example, creating an online order twice
    instead of once could create customer dissatisfaction or internal issues.And voilà,
    we decommissioned a system using the Microservice Adapter pattern without breaking
    its dependencies. Next, we look at an **Internet of Things** (**IoT**) example.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示显示了新的系统拓扑，包括一个新现代应用和现在通过事件驱动架构松散耦合的两个原始依赖项。当然，迁移规模越大，就越复杂，耗时也越长，但适配器微服务模式是帮助从一个系统部分或完全迁移到另一个系统的一种方式。就像前面的例子一样，主要优势是添加或删除功能而不会影响其他系统，这使我们能够迁移并打破不同依赖项之间的紧密耦合。缺点是这种临时解决方案增加了复杂性。此外，在迁移步骤中，你很可能会需要按正确顺序部署现代应用和适配器，以确保两个系统不会处理相同的事件两次，从而导致重复更改。例如，将电话号码更新为相同的值两次应该是可以的，因为它会导致相同的最终数据集。然而，创建两个记录而不是一个可能更重要，因为这可能导致数据集中的完整性错误。例如，创建一个在线订单两次而不是一次可能会引起客户不满或内部问题。就这样，我们使用微服务适配器模式淘汰了一个系统，而没有破坏其依赖项。接下来，我们看看一个**物联网**（**IoT**）的例子。
- en: Adapting an event broker to another
  id: totrans-543
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将事件代理适配到另一个
- en: 'In this scenario, we are adapting an event broker to another. In the following
    diagram, we look at two use cases: one that translates events from broker B to
    broker A (left) and the other that translates events from broker A to broker B
    (right). Afterwards, we explore a more concrete example:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们正在将一个事件代理适配到另一个。在下面的图中，我们查看两个用例：一个将事件从代理B翻译到代理A（左侧）和另一个将事件从代理A翻译到代理B（右侧）。之后，我们探索一个更具体的例子：
- en: '![Figure 19.42: An adapter microservice that translates events from broker
    B to broker A (left) and from broker A to broker B (right)](img/file170.png)'
  id: totrans-545
  prefs: []
  type: TYPE_IMG
  zh: '![图19.42：一个适配器微服务，将事件从代理B转换为代理A（左侧）以及从代理A转换为代理B（右侧）](img/file170.png)'
- en: 'Figure 19.42: An adapter microservice that translates events from broker B
    to broker A (left) and from broker A to broker B (right)'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.42：一个适配器微服务，将事件从代理B转换为代理A（左侧）以及从代理A转换为代理B（右侧）
- en: We can see the two possible flows in the preceding diagram. The first flow,
    on the left, allows the adapter to read events from broker B and publish them
    to broker A. The second flow, on the right, enables the adapter to read events
    from broker A and publish them to broker B. Those flows allow us to translate
    or copy events from one broker to another by leveraging the Microservice Adapter
    pattern.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的图中看到两种可能的流程。左侧的第一种流程允许适配器从代理B读取事件并将其发布到代理A。右侧的第二种流程使适配器能够从代理A读取事件并将其发布到代理B。这些流程使我们能够通过利用微服务适配器模式将事件从一种代理转换到另一种代理。
- en: In *Figure 16.35*, there is one adapter per flow. I did that to make the two
    flows as independent as possible, but the adapters could be a single microservice.
  id: totrans-548
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在*图16.35*中，每个流程都有一个适配器。我这样做是为了使两个流程尽可能独立，但适配器可以是单个微服务。
- en: 'This pattern can be very useful for an IoT system where your microservices
    leverage Apache Kafka internally for its full-featured suite of event-streaming
    capabilities but use MQTT to communicate with the low-powered IoT devices that
    connect to the system. An adapter can solve this problem by translating the messages
    from one protocol to the other. Here is a diagram that represents the complete
    flows, including a device and the microservices:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式对于物联网系统非常有用，其中您的微服务在内部使用Apache Kafka的完整功能的事件流能力，但使用MQTT与连接到系统的低功耗物联网设备进行通信。适配器可以通过将消息从一种协议转换为另一种协议来解决此问题。以下是一个表示完整流程的图，包括设备和微服务：
- en: '![Figure 19.43: Complete protocol adapter flows, including a device and microservices](img/file171.png)'
  id: totrans-550
  prefs: []
  type: TYPE_IMG
  zh: '![图19.43：完整的协议适配器流程，包括设备和微服务](img/file171.png)'
- en: 'Figure 19.43: Complete protocol adapter flows, including a device and microservices'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.43：完整的协议适配器流程，包括设备和微服务
- en: 'Before we explore what the events could be, let’s explore both flows step by
    step. The left flow allows getting events inside the system from the devices through
    the following sequence:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索事件可能是什么之前，让我们逐步探索这两个流程。左侧的流程允许通过以下顺序从设备获取系统内部的事件：
- en: A device publishes an event to the MQTT broker.
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个设备向MQTT代理发布事件。
- en: The adapter reads that event.
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适配器读取该事件。
- en: The adapter publishes a similar or different event to the Kafka broker.
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适配器向Kafka代理发布类似或不同的事件。
- en: Zero or more microservices subscribed to the event act on it.
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 零个或多个订阅了事件的微服务对其执行操作。
- en: 'On the other hand, the right flow allows getting events out of the system to
    the devices through the following sequence:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，右侧流程允许通过以下顺序将事件从系统中输出到设备：
- en: A microservice publishes an event to the Kafka broker.
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个微服务向Kafka代理发布事件。
- en: The adapter reads the event.
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适配器读取该事件。
- en: The adapter publishes a similar or different event to the MQTT broker.
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适配器向MQTT代理发布类似或不同的事件。
- en: Zero or more devices subscribed to the event act on it.
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 零个或多个订阅了事件的设备对其执行操作。
- en: You don’t have to implement both flows; the adapter could be bidirectional (supporting
    both flows), we could have two unidirectional adapters that support one of the
    flows, or we could allow the communication to flow only one way (in or out but
    not both). The choice relates to your specific use cases.Concrete examples of
    sending a message from a device to a microservice (left flow) could be sending
    its GPS position, a status update (the light is now on), or a message indicating
    a sensor failure.Concrete examples of sending a message to a device (right flow)
    could be to remotely control a speaker’s volume, flip a light on, or send a confirmation
    that a message has been acknowledged.In this case, the adapter is not a temporary
    solution but a permanent capability. We could leverage such adapters to create
    additional capabilities with minimal impact on the rest of the system. The primary
    downside is deploying one or more other microservices, but your system and processes
    are probably robust enough to handle that added complexity when leveraging such
    capabilities.This third scenario that leverages the Microservice Adapter is our
    last. Hopefully, I sparked your imagination enough to leverage this simple yet
    powerful design pattern.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必实现两种流程；适配器可以是双向的（支持两种流程），我们可以有两个单向适配器，支持其中一种流程，或者我们可以允许通信单向流动（仅入或出，但不双向）。选择与你的具体使用案例相关。从设备向微服务发送消息的具体例子（左侧流程）可能是发送其GPS位置、状态更新（灯现在亮了）或指示传感器故障的消息。向设备发送消息的具体例子（右侧流程）可能是远程控制扬声器的音量、打开灯或发送确认消息已被接收。在这种情况下，适配器不是一个临时解决方案，而是一个永久性功能。我们可以利用这样的适配器以最小的系统影响创建额外的功能。主要的缺点是部署一个或多个其他微服务，但你的系统和流程可能足够强大，足以在利用这些功能时处理这种额外的复杂性。这种利用微服务适配器的第三种场景是我们的最后一个场景。希望这足以激发你的想象力，利用这个简单而强大的设计模式。
- en: Conclusion
  id: totrans-563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'We explored the Microservice Adapter pattern that allows us to connect two
    elements of a system by adapting one to the other. We explored how to push information
    from an event broker into an existing system that does not support such capabilities.
    We also explored how to leverage an adapter to break tight coupling, migrate features
    into a newer system, and decommission a legacy application seamlessly. We finally
    connected two event brokers through an adapter microservice, allowing a low-powered
    IoT device to communicate with a microservices system without draining their battery
    and without the complexity it would incur to use a more complex communication
    protocol.This pattern is very powerful and can be implemented in many ways, but
    it all depends on the exact use cases. You can write an adapter using a serverless
    offering like an Azure function, no-code/low-code offerings like Power Automate,
    or C#. Of course, these are just a few examples. The key to designing the correct
    system is to nail down the problem statement because once you know what you are
    trying to fix, the solution becomes clearer.Now, let’s see how the Microservice
    Adapter pattern can help us follow the **SOLID** principles at cloud-scale:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了微服务适配器模式，该模式允许我们通过适配一个元素以适应另一个元素来连接系统的两个元素。我们探讨了如何将信息从事件代理推送到不支持此类功能现有系统。我们还探讨了如何利用适配器来打破紧密耦合，将功能迁移到较新的系统，以及无缝退役遗留应用程序。最后，我们通过适配器微服务连接了两个事件代理，允许低功耗的物联网设备在不耗尽电池和避免使用更复杂通信协议带来的复杂性情况下与微服务系统通信。这种模式非常强大，可以以多种方式实现，但一切都取决于具体的使用案例。你可以使用无服务器产品如Azure函数、无代码/低代码产品如Power
    Automate或C#来编写适配器。当然，这些只是几个例子。设计正确系统的关键是明确问题陈述，因为一旦你知道你试图解决的问题，解决方案就会变得清晰。现在，让我们看看微服务适配器模式如何帮助我们以云规模遵循**SOLID**原则：
- en: '**S**: The microservice adapter helps manage long- or short-term responsibilities.
    For example, adding an adapter that translates between two protocols or creating
    a temporary adapter to decommission a legacy system.'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**：微服务适配器有助于管理长期或短期责任。例如，添加一个在两种协议之间进行转换的适配器或创建一个临时适配器来退役遗留系统。'
- en: '**O**: You can leverage microservice adapters to dynamically add or remove
    features without impacting or with limited impact on the rest of the system. For
    example, in the IoT scenario, we could add support for a new protocol like AMQP
    without changing the rest of the system.'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**：你可以利用微服务适配器动态添加或删除功能，而不会对系统造成影响或造成有限的影响。例如，在物联网场景中，我们可以添加对AMQP等新协议的支持，而无需更改系统的其余部分。'
- en: '**L**: N/A'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**：N/A'
- en: '**I**: Adding smaller adapters can make changes easier and less risky than
    updating large legacy applications. As we saw in the legacy system decommissioning
    scenario, we could also leverage temporary adapters to split large applications
    into smaller pieces.'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我**：添加较小的适配器可以使更改更容易且风险更低，比更新大型遗留应用程序更佳。正如我们在遗留系统退役场景中所见，我们还可以利用临时适配器将大型应用程序拆分成更小的部分。'
- en: '**D**: A microservice adapter inverts the dependency flow between the system
    it adapts. For example, in the legacy system decommissioning scenario, the adapter
    reversed the flow from the two dependencies to the legacy system by leveraging
    an event broker.'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**：微服务适配器反转了被适配系统之间的依赖关系流。例如，在遗留系统退役场景中，适配器通过利用事件代理，将两个依赖项到遗留系统的流向反转。'
- en: Summary
  id: totrans-570
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The microservices architecture is different from everything we’ve covered in
    this book and how we build monoliths. Instead of one big application, we split
    it into multiple smaller ones called microservices. Microservices must be independent
    of one another; otherwise, we will face the same problems associated with tightly
    coupled classes, but at the cloud scale.We can leverage the Publish-Subscribe
    design pattern to loosely couple microservices while keeping them connected through
    events. Message brokers are programs that dispatch those messages. We can use
    event sourcing to recreate the application’s state at any point in time, including
    when spawning new containers. We can use application gateways to shield clients
    from the microservices cluster’s complexity and publicly expose only a subset
    of services.We also looked at how we can build upon the CQRS design pattern to
    decouple reads and writes of the same entities, allowing us to scale queries and
    commands independently. We also looked at using serverless resources to create
    that kind of system.Finally, we explored the Microservice Adapter pattern that
    allowed us to adapt two systems together, decommission a legacy application, and
    connect two event brokers. This pattern is simple but powerful at inverting the
    dependency flow between two dependencies in a loosely coupled manner. The use
    of the pattern can be temporary, as we saw in the legacy application decommissioning
    scenario, or permanent, as we saw in the IoT scenario.On the other hand, microservices
    come at a cost and are not intended to replace all that exists. Building a monolith
    is still a good idea for many projects. Starting with a monolith and migrating
    it to microservices when scaling is another solution. This allows us to develop
    the application faster (monolith). It is also easier to add new features to a
    monolith than it can be to add them to a microservice application. Most of the
    time, mistakes cost less in a monolith than in a microservices application. You
    can also plan your future migration toward microservices, which leads to the best
    of both worlds while keeping operational complexity low. For example, we could
    leverage the Publish-Subscribe pattern through MediatR notifications in your monolith
    and migrate the events dispatching responsibility to a message broker later when
    migrating your system to microservices architecture (if the need ever arises).
    We are exploring ways to organize our monolith in *Chapter 20*, *Modular Monolith*.I
    don’t want you to discard the microservices architecture, but I want to ensure
    you weigh up the pros and cons of such a system before blindly jumping in. Your
    team’s skill level and ability to learn new technologies may also impact the cost
    of jumping into the microservices boat.**DevOps** (development [Dev] and IT operations
    [Ops]) or **DevSecOps** (adding security [Sec] to the DevOps mix), which we do
    not cover in the book, is essential when building microservices. It brings deployment
    automation, automated quality checks, auto-composition, and more. Your microservices
    cluster will be very hard to deploy and maintain without that.Microservices are
    great when you need scaling, want to go serverless, or split responsibilities
    between multiple teams, but keep the operational costs in mind.In the next chapter,
    we combine the microservices and monolith worlds.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构与本书中我们所涵盖的以及我们构建单体应用的方式都不同。我们不是将一个大型应用作为一个整体，而是将其拆分为多个更小的应用，这些应用被称为微服务。微服务必须相互独立；否则，我们将面临与紧密耦合的类相关联的相同问题，但这些问题是在云规模上出现的。我们可以利用发布-订阅设计模式来松散耦合微服务，同时通过事件将它们连接起来。消息代理是负责派发这些消息的程序。我们可以使用事件溯源在任意时间点重新创建应用程序的状态，包括在启动新容器时。我们可以使用应用程序网关来保护客户端免受微服务集群复杂性的影响，并公开仅暴露服务的一部分。我们还探讨了如何基于CQRS设计模式来解耦相同实体的读写操作，从而允许我们独立扩展查询和命令。我们还探讨了使用无服务器资源来创建这种类型的系统。最后，我们探讨了微服务适配器模式，该模式允许我们适应两个系统，退役一个遗留应用程序，并连接两个事件代理。这种模式简单但强大，能够在松散耦合的方式下反转两个依赖项之间的依赖关系流。该模式的使用可以是临时的，就像我们在遗留应用程序退役场景中看到的那样，也可以是永久的，就像我们在物联网场景中看到的那样。另一方面，微服务是有代价的，并不打算取代所有现有的东西。对于许多项目来说，从单体开始并随着扩展将其迁移到微服务仍然是一个好主意。从单体开始，并在扩展时迁移到微服务，这也是另一种解决方案。这使我们能够更快地开发应用程序（单体）。与向微服务应用程序添加新功能相比，向单体添加新功能更容易。大多数情况下，错误在单体中比在微服务应用程序中成本更低。您还可以规划您未来的微服务迁移，这将带来两全其美的结果，同时保持操作复杂性较低。例如，我们可以在单体中利用发布-订阅模式通过MediatR通知，并在迁移系统到微服务架构时（如果需要的话）将事件派发责任迁移到消息代理。我们在探索如何组织我们的单体在*第20章*，*模块化单体*。我不想你放弃微服务架构，但我想确保你在盲目跳入之前权衡这种系统的利弊。您的团队的技术水平和学习新技术的能力也可能影响跳入微服务之船的成本。**DevOps**（开发[Dev]和IT运营[Ops]）或**DevSecOps**（在DevOps中添加安全[Sec]），我们在书中没有涉及，但在构建微服务时是必不可少的。它带来了部署自动化、自动质量检查、自动组合等。没有这些，您的微服务集群将很难部署和维护。当您需要扩展、想要无服务器或在不同团队之间划分责任时，微服务很棒，但请记住运营成本。在下一章中，我们将结合微服务和单体世界。
- en: Questions
  id: totrans-572
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'Let’s take a look at a few practice questions:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个练习题：
- en: What is the most significant difference between a **message queue** and a **pub-sub**
    model?
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**消息队列**和**发布-订阅**模型之间最显著的区别是什么？'
- en: What is **event sourcing**?
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 **事件溯源**？
- en: Can an **application gateway** be both a **routing gateway** and an **aggregation
    gateway**?
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**应用程序网关**可以既是**路由网关**又是**聚合网关**吗？'
- en: Is it true that real CQRS requires a serverless cloud infrastructure?
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真实的 CQRS 是否需要无服务器云基础设施？
- en: What is a significant advantage of using the BFF design pattern?
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 BFF 设计模式有什么显著优势？
- en: Further reading
  id: totrans-579
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here are a few links that will help you build on what you learned in this chapter:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些链接，可以帮助你构建本章所学的内容：
- en: 'Event Sourcing pattern by Martin Fowler: [https://adpg.link/oY5H](https://adpg.link/oY5H)'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 马丁·福勒的 Event Sourcing 模式：[https://adpg.link/oY5H](https://adpg.link/oY5H)
- en: 'Event Sourcing pattern by Microsoft: [https://adpg.link/ofG2](https://adpg.link/ofG2)'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软提供的事件溯源模式：[https://adpg.link/ofG2](https://adpg.link/ofG2)
- en: 'Publisher-Subscriber pattern by Microsoft: [https://adpg.link/amcZ](https://adpg.link/amcZ)'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软提供的发布-订阅模式：[https://adpg.link/amcZ](https://adpg.link/amcZ)
- en: 'Event-driven architecture by Microsoft: [https://adpg.link/rnck](https://adpg.link/rnck)'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软提供的事件驱动架构：[https://adpg.link/rnck](https://adpg.link/rnck)
- en: 'Microservices architecture and patterns on microservices.io: [https://adpg.link/41vP](https://adpg.link/41vP)'
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: microservices.io 上的微服务架构和模式：[https://adpg.link/41vP](https://adpg.link/41vP)
- en: 'Microservices architecture and patterns by Martin Fowler: [https://adpg.link/Mw97](https://adpg.link/Mw97)'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 马丁·福勒提供的微服务架构和模式：[https://adpg.link/Mw97](https://adpg.link/Mw97)
- en: 'Microservices architecture and patterns by Microsoft: [https://adpg.link/s2Uq](https://adpg.link/s2Uq)'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构和模式，由微软提供：[https://adpg.link/s2Uq](https://adpg.link/s2Uq)
- en: 'RFC 6902 (JSON Patch): [https://adpg.link/bGGn](https://adpg.link/bGGn)'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 6902（JSON Patch）：[https://adpg.link/bGGn](https://adpg.link/bGGn)
- en: 'JSON Patch in ASP.NET Core web API: [https://adpg.link/u6dw](https://adpg.link/u6dw)'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core web API 中的 JSON Patch：[https://adpg.link/u6dw](https://adpg.link/u6dw)
- en: 'Strangler Fig Application pattern:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: Strangler Fig 应用程序模式：
- en: 'Martin Fowler: [https://adpg.link/Zi9G](https://adpg.link/Zi9G)'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 马丁·福勒：[https://adpg.link/Zi9G](https://adpg.link/Zi9G)
- en: 'Microsoft: [https://adpg.link/erg2](https://adpg.link/erg2)'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软：[https://adpg.link/erg2](https://adpg.link/erg2)
- en: Answers
  id: totrans-593
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 答案
- en: The message queue gets a message and has a single subscriber dequeue it. If
    nothing dequeues a message, it stays in the queue indefinitely (FIFO model). The
    Pub-Sub model gets a message and sends it to zero or more subscribers.
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消息队列接收到消息并有一个唯一的订阅者将其出队。如果没有东西出队，消息将无限期地留在队列中（FIFO 模式）。发布-订阅模型接收到消息并将其发送到零个或多个订阅者。
- en: Event sourcing is the process of chronologically accumulating events that happened
    in a system instead of persisting in the current state of an entity. It allows
    you to recreate the entity's state by replaying those events.
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件溯源是将系统发生的事件按时间顺序积累的过程，而不是在实体的当前状态中持久化。它允许你通过重放这些事件来重新创建实体的状态。
- en: Yes, you can mix Gateway patterns (or sub-patterns).
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，你可以混合使用网关模式（或子模式）。
- en: No, you can deploy micro-applications (microservices) on-premises if you want
    to.
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，如果你想的话，可以在本地部署微应用程序（微服务）。
- en: It separates generic functionalities from app-specific ones, promoting cleaner
    code and modularization. It also helps simplify the frontend.
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将通用功能与应用特定功能分离，促进代码的整洁和模块化。它也有助于简化前端。
