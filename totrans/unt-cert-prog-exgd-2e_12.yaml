- en: '*Chapter 12*: NavMesh, Timeline, and a Mock Test'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：NavMesh、时间轴和模拟测试'
- en: In this chapter, we are going to cover two main functionalities that Unity offers
    developers for issuing **AI** to our game objects and for animation that supports
    logic.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍Unity为开发者提供的两个主要功能，用于向游戏对象分配**AI**以及支持逻辑的动画。
- en: Unity has a ready-made system for our game objects to issue a path-finding algorithm
    where a game object can be given an area to patrol. This can be very handy in
    a series of games that use enemy soldiers to walk up and down a corridor looking
    for the player. A soldier can react depending on the behavior given to them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Unity为我们游戏对象提供了一个现成的系统，可以发出路径查找算法，其中游戏对象可以被赋予一个巡逻区域。这在一系列使用敌方士兵在走廊上来回寻找玩家的游戏中非常有用。士兵可以根据赋予他们的行为做出反应。
- en: The other functionality we will be covering is the **Timeline** component, which
    is used for animation in scenarios such as cutscenes in games/films. You may be
    thinking that we already covered an animation system back in [*Chapter 4*](B18381_04_Epub.xhtml#_idTextAnchor087),
    *Applying Art, Animation, and Particles*. Yes, you are right, but for a more complex
    animation that holds multiple game objects and animations, transitions and states
    can get complex pretty easily. Also, Timeline supports a series of tracks that
    work specifically with our code, and we can add our own custom animation tracks
    to our timeline.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的另一个功能是**时间轴**组件，它用于游戏/电影中的场景如电影场景的动画。你可能认为我们在[*第4章*](B18381_04_Epub.xhtml#_idTextAnchor087)，“应用艺术、动画和粒子”中已经介绍了动画系统。是的，你是对的，但对于一个包含多个游戏对象和动画、过渡和状态可能很快变得复杂的复杂动画，时间轴支持一系列特定于我们代码的轨道，并且我们可以向时间轴添加我们自己的自定义动画轨道。
- en: These two main features will be assigned to our Killer Wave game project. The
    **Navigation Mesh** (**NavMesh**) controls a flock of small **Non-Player-Character**
    (**NPC**) robots that will move away from our player's ship as if they're panicking
    to stay alive.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个主要功能将被分配给我们的Killer Wave游戏项目。**导航网格**（**NavMesh**）控制着一群小型**非玩家角色**（**NPC**）机器人，它们会远离玩家的飞船，就像它们在恐慌中为了生存而移动一样。
- en: Timeline will be used to apply a mid-level cutscene where our player will see
    the end-of-level boss rush past them and lights in the scene will flash red.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 时间轴将用于应用一个中等难度的电影场景，玩家将看到关卡结束时的Boss冲过他们，场景中的灯光会闪烁红色。
- en: Finally, we will end this chapter with the last mini-mock test, which will include
    questions covering the content from this chapter and previous ones.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将以最后一个迷你模拟测试结束本章，该测试将包括涵盖本章和之前章节内容的问题。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Preparing the final scene
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备最终场景
- en: Developing AI with NavMesh
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NavMesh开发AI
- en: Exploring the timeline
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索时间轴
- en: Extending the timeline
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延长时间线
- en: Let's start by reviewing what skills are covered in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先回顾一下本章涵盖的技能。
- en: The core exam skills covered in this chapter
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章涵盖的核心考试技巧
- en: '*Programming core interaction*:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*编程核心交互*：'
- en: Implementing behaviors and interactions of game objects and environments
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现游戏对象和环境的行为和交互
- en: Identifying methods to implement camera views and movement
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定实现摄像机视图和移动的方法
- en: '*Working in an art pipeline*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*在艺术管道中工作*：'
- en: 'Knowledge of materials, textures, and shaders: The Unity rendering API'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解材质、纹理和着色器：Unity渲染API
- en: 'Knowledge of lighting: The Unity lighting API'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解照明：Unity照明API
- en: 'Knowledge of two-dimensional and three-dimensional animation: The Unity animation
    API'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解二维和三维动画：Unity动画API
- en: '*Programming for the scene and environment design*:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*场景和环境设计编程*：'
- en: Determining scripts for pathfinding with the Unity navigation system
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Unity导航系统确定路径查找脚本
- en: Technical requirements
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The project content for this chapter can be found at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目内容可在[https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition)找到。
- en: You can download the entirety of each chapter's project files at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以下载每个章节的项目文件的完整内容，链接为 [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition)。
- en: All the content for this chapter is held in the chapter's `unitypackage` file,
    including a `Complete` folder that holds all of the work we'll carry out in the
    chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有内容都保存在章节的 `unitypackage` 文件中，包括一个包含我们在本章中将要完成的所有工作的 `Complete` 文件夹。
- en: 'Check out the following video to see the *Code in Action*: [https://bit.ly/3LsC0B4](https://bit.ly/3LsC0B4).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看 *代码执行情况*：[https://bit.ly/3LsC0B4](https://bit.ly/3LsC0B4)。
- en: Preparing the final scene
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备最终场景
- en: In this section, we are going to prepare our new `level3` scene in two parts
    – the first part of our game will have some three-dimensional art assets for the
    player to potentially collide with. Also, the environment will be used for our
    new fleeing enemies. The second part of this section is used to upgrade our camera's
    behavior so that instead of it being static, we now require it to move across
    the level. The player will also be given the same fixed speed as the camera.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分两部分准备我们的新 `level3` 场景 – 游戏的第一部分将有一些三维艺术资源供玩家可能与之碰撞。此外，环境还将用于我们的新逃跑敌人。本节的第二部分用于升级摄像机的行为，使其不再是静态的，我们现在需要它穿越关卡。玩家也将获得与摄像机相同的固定速度。
- en: 'By the end of this section, we will have an environment set up, as shown in
    the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，我们将设置好环境，如下面的截图所示：
- en: '![Figure 12.1 – Our third level assets'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.1 – 我们的第 3 级资源'
- en: '](img/Figure_12.01_B18381.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.01_B18381.jpg)'
- en: Figure 12.1 – Our third level assets
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – 我们的第 3 级资源
- en: The arrow going from left to right in the previous screenshot shows the path
    of the camera. Once it reaches a particular point, it will stop, and the level
    will end shortly after.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图从左到右的箭头显示了摄像机的路径。一旦它到达一个特定的点，它就会停止，然后不久关卡就会结束。
- en: It is worth mentioning that within the `level3Env` prefab is a game object that
    holds a script called `BossTrigger`. This game object contains a box collider,
    a rigid body, and a `BossTriggerBox` script.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在 `level3Env` 预制件中有一个名为 `BossTrigger` 的脚本的游戏对象。此游戏对象包含一个盒子碰撞体、一个刚体和一个
    `BossTriggerBox` 脚本。
- en: The purpose of the `BossTrigger` game object is to activate the `BossTrigger`
    collider. We will discuss this further in the *Exploring the timeline* section
    of this chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`BossTrigger` 游戏对象的目的激活 `BossTrigger` 碰撞体。我们将在本章的 *探索时间轴* 部分进一步讨论这一点。'
- en: 'Let''s continue by moving our `level3` file''s environment into the scene:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续，将我们的 `level3` 文件的环境移动到场景中：
- en: From the `Assets/Scene` and double-click on the `level3` scene file.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Assets/Scene` 中双击 `level3` 场景文件。
- en: From the `Assets/Prefab`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Assets/Prefab`。
- en: Click and drag the `level3Env` prefab into the `_SceneAssets` game object in
    the **Hierarchy** window.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `level3Env` 预制件拖放到 **Hierarchy** 窗口中的 `_SceneAssets` 游戏对象。
- en: Select `level3Env` from the `2500`, `17`, and `-24`
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `2500`、`17` 和 `-24` 中选择 `level3Env`
- en: '`0.55`, `0.55`, and `0.55`'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`0.55`、`0.55` 和 `0.55`'
- en: 'The following screenshot shows our scene setup, which is ready for our player
    to fly into:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的场景设置，已经准备好让玩家飞入：
- en: '![Figure 12.2 – The level 3 assets in place'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.2 – 已放置的第 3 级资源'
- en: '](img/Figure_12.02_B18381.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.02_B18381.jpg)'
- en: Figure 12.2 – The level 3 assets in place
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 第 3 级资源已放置
- en: So, we need to make some changes to our `level3` scene so that it acts in a
    way that ensures the camera supports the new environment and the environment itself
    doesn't have extra assets that we don't need, such as the animating texture quad
    for the background and the prefab particle system for the stars flying past. Be
    aware, if any of these game objects are in a prefab state, be sure to unpack (right
    click game object in **Hierarchy** **Prefab | Unpack**) them otherwise we will
    be changing the content in levels 1 and 2.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要对我们的 `level3` 场景做一些修改，以确保摄像机支持新的环境，并且环境本身没有我们不需要的额外资源，例如背景的动画纹理四边形和飞过星星的预制粒子系统。请注意，如果这些游戏对象处于预制状态，请确保解包（在
    **Hierarchy** 中右键单击游戏对象 **Prefab | Unpack**），否则我们将更改 1 和 2 级别的内 容。
- en: 'Alter the `level3` scene in the **Hierarchy** window by doing the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下方式在 **Hierarchy** 窗口中修改 `level3` 场景：
- en: Thankfully, the aforementioned two assets sit within the `GameSpeed` game object
    in the `GameSpeed` game object.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 幸运的是，上述两个资源都位于`GameSpeed`游戏对象中的`GameSpeed`游戏对象内。
- en: We won't be using any directional lighting in our scene, so also remove `Directional
    Light` from the **Hierarchy** window.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的场景中，我们不会使用任何方向性光照，因此也从**层次结构**窗口中移除`Directional Light`。
- en: Also, for the sake of running our `level3` scene without going through the entire
    game loop, we can drop our `GameManager` prefab from the `Assets/Prefab` folder
    location into the **Hierarchy** window.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，为了在没有经过整个游戏循环的情况下运行我们的`level3`场景，我们可以将`GameManager`预制件从`Assets/Prefab`文件夹位置拖放到**层次结构**窗口中。
- en: 'Our `level3` will now look like the one in the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`level3`将看起来像以下截图所示：
- en: '![Figure 12.3 – Our Hierarchy layout so far'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3 – 到目前为止的层次结构布局'
- en: '](img/Figure_12.03_B18381.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.03_B18381.jpg]'
- en: Figure 12.3 – Our Hierarchy layout so far
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 到目前为止的层次结构布局
- en: 'We now need to make it so that the **Camera** component supports a far clipping-plane
    value. To do this, we need to do the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要让**Camera**组件支持远裁剪平面值。为此，我们需要执行以下操作：
- en: Select the main camera in the **Hierarchy** window.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择主摄像机。
- en: In the `1300`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`1300`。
- en: So, we have adjusted the clipping plane of the camera to show all of the `level3`
    file's environment, removed the `GameSpeed` game object that helps art assets
    for our previous levels, and added `GameManager` to `level3` to make development
    easier. We now need to turn our focus toward making the camera actually move instead
    of creating the illusion it is moving, as with `level1` and `level2`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经调整了摄像机的裁剪平面以显示`level3`文件的环境，移除了帮助我们之前级别的艺术资源的`GameSpeed`游戏对象，并将`GameManager`添加到`level3`以简化开发。现在，我们需要将注意力转向使摄像机真正移动，而不是像`level1`和`level2`那样创建移动的错觉。
- en: I have created a small script that will make the camera move from one point
    to another; everything inside the script demonstrates elements of code that we
    have already covered throughout this book. So, there's no need for you to create
    the script, but understanding it is obviously the main purpose.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经创建了一个小脚本，它将使摄像机从一个点移动到另一个点；脚本中的所有内容都展示了我们在本书中已经覆盖过的代码元素。因此，您不需要创建脚本，但理解它是显然的主要目的。
- en: 'We are going to attach the script to the main camera in our scene to control
    its movement. Follow these instructions:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把脚本附加到场景中的主摄像机上以控制其移动。按照以下说明操作：
- en: Select the main camera from the **Hierarchy** window.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**窗口中选择主摄像机。
- en: Click the `CameraMovement` until you see the script appear in the dropdown.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`CameraMovement`直到在下拉菜单中看到脚本出现。
- en: Select the **CameraMovement** script.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**CameraMovement**脚本。
- en: Click on `box collider` into the drop-down list. When it appears, select it
    and check its **Is Trigger** box.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下拉列表中点击`box collider`。当它出现时，选择它并检查其**Is Trigger**框。
- en: In brief, this script will translate along its *x* axis after 6 seconds when
    active. When the script reaches a particular point, it will stop; it will also
    make sure that the player stops traveling with it.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简而言之，此脚本将在激活后6秒沿*x*轴进行平移。当脚本到达特定点时，它将停止；它还将确保玩家不会随它一起移动。
- en: 'Let''s modify our `Player` script to act on the movement of the camera for
    `level3`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的`Player`脚本以对`level3`的摄像机移动做出反应：
- en: In the `Assets/Script` and double-click on the `Player` script to open it.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Script`中双击`Player`脚本以打开它。
- en: 'Inside the `Player` script, at the top where we have our global variables,
    enter the private variable and its property:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Player`脚本内部，在我们全局变量顶部的地方，输入私有变量及其属性：
- en: '[PRE0]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `camTravelSpeed` variable that we just entered will be used as an extra
    multiplier to set the pace of the player's ship when the camera moves along the
    *x* axis.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才输入的`camTravelSpeed`变量将用作额外的乘数，以设置摄像机沿*x*轴移动时的玩家飞船的节奏。
- en: The second variable, `movingScreen`, will hold the result of `Time.deltaTime`
    multiplied by `camTravelspeed`. Later, `movingScreen` will be used when it comes
    to comparing the player's ship's *x* axis.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个变量`movingScreen`将保存`Time.deltaTime`乘以`camTravelspeed`的结果。稍后，`movingScreen`将用于比较玩家飞船的*x*轴。
- en: 'In the `Start` function, add the following line at the bottom of its function:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start`函数中，在其函数底部添加以下行：
- en: '[PRE1]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Inside the `Start` function, we will add our `width float` measurement to `movingScreen`
    (this happens after `width` has been updated in the `Start` function), as this
    will be the starting position before it receives its increments from `Time.deltaTime`
    and `camTravelspeed`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Start` 函数内部，我们将 `width float` 测量值添加到 `movingScreen` 中（这发生在 `width` 在 `Start`
    函数中更新之后），因为这将是它接收来自 `Time.deltaTime` 和 `camTravelspeed` 的增量之前的起始位置。
- en: Still inside the `Player` script, scroll down to the `Movement` method.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在 `Player` 脚本中，滚动到 `Movement` 方法。
- en: 'At the top of the `Movement` method, enter the following code, which will multiply
    our player''s ship''s speed:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Movement` 方法的顶部，输入以下代码，这将乘以我们的玩家飞船的速度：
- en: '[PRE2]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the code that we've just entered, we will run a check to see whether `camTravelSpeed`
    has increased from our new `CameraMovement` script. If `camTravelSpeed` has been
    updated, we fall into the scope of the `if` statement.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚输入的代码中，我们将运行一个检查来查看 `camTravelSpeed` 是否已从我们的新 `CameraMovement` 脚本中更新。如果
    `camTravelSpeed` 已更新，我们将进入 `if` 语句的作用域。
- en: Within the `if` statement, we will increment the player's ship's *x* axis to
    the right, multiplied by `Time.deltaTime` and `camTravelSpeed`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `if` 语句内，我们将玩家的飞船的 *x* 轴向右增加，乘以 `Time.deltaTime` 和 `camTravelSpeed`。
- en: The second thing we do is add the `movingScreen` value that originally holds
    the current `width` of our playing area. However, because the screen is moving,
    we need to increment the playing area so that the player doesn't get left behind
    or go too far out of the camera view.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的第二件事是添加 `movingScreen` 值，它最初持有我们游戏区域的当前 `width`。然而，因为屏幕在移动，我们需要增加游戏区域，这样玩家就不会落后或超出摄像机的视野太远。
- en: The last amendment we add to our `Player` script is our horizontal movements,
    still in the `Movement` method.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到我们的 `Player` 脚本中的最后一个修改是水平移动，仍然在 `Movement` 方法中。
- en: 'Scroll down until you get to where the player can press the *right arrow* to
    move (`Input.GetAxisRaw("Horizontal") > 0`). Within the scope of the `if` statement,
    we can amend the second `if` statement to the following:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动直到你到达玩家可以按 *右箭头* 键来移动的位置（`Input.GetAxisRaw("Horizontal") > 0`）。在 `if` 语句的作用域内，我们可以修改第二个
    `if` 语句为以下内容：
- en: '[PRE3]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If the player presses the *right arrow* on their keyboard/joypad, we can run
    a check to see whether the player's *x* axis is less than the `movingScreen` float
    value; plus, we will include a buffer to push the player further to the edge of
    the screen.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家在键盘/手柄上按下 *右箭头* 键，我们可以运行一个检查来查看玩家的 *x* 轴是否小于 `movingScreen` 浮点值；此外，我们还将包括一个缓冲区，将玩家推到屏幕边缘。
- en: 'We can then do the same for when the player presses the *left arrow* on the
    keyboard/joystick within the second `if` statement:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以在玩家在键盘/摇杆上按下 *左箭头* 键时，在第二个 `if` 语句中做同样的事情：
- en: '[PRE4]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Similar rules apply where we make use of the `movingScreen` variable, which
    is constantly incremented along with a slight buffer to keep our player's ship
    within the game screen.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `movingScreen` 变量时，适用类似的规则，该变量会随着轻微的缓冲区不断递增，以保持我们的玩家飞船在游戏屏幕内。
- en: Save the `Player` script.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 `Player` 脚本。
- en: Before we move on to the next script, we need to uncomment two lines of code
    in our new `CameraMovement` script so that it can interact with the `Player` script.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续到下一个脚本之前，我们需要在我们的新 `CameraMovement` 脚本中取消注释两行代码，以便它可以与 `Player` 脚本交互。
- en: 'Back in the `CameraMovement` script and uncomment the two following lines by
    removing `//`. The first line to uncomment is the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `CameraMovement` 脚本，通过移除 `//` 来取消注释以下两行。需要取消注释的第一行是以下内容：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The second line to uncomment is the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 需要取消注释的第二行是以下内容：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, these two lines of code can alter the speed of the player ship.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这两行代码可以改变玩家飞船的速度。
- en: Next, we need to update our `GameManager` script so that it recognizes the difference
    between `level1`, `level2`, and `level3`, which has a moving camera.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新我们的 `GameManager` 脚本，使其能够识别 `level1`、`level2` 和 `level3` 之间的差异，这些级别有移动的摄像机。
- en: 'So, let''s move to the `GameManager` script and add two main elements – the
    camera speed and noticing the difference between scenes. Let''s start by opening
    the `GameManager` script:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们转到 `GameManager` 脚本，并添加两个主要元素——摄像机速度和识别场景之间的差异。让我们首先打开 `GameManager` 脚本：
- en: From the `Assets/Script`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Assets/Script`。
- en: Double-click on the `GameManager` script to open it in your IDE.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 `GameManager` 脚本来在您的 IDE 中打开它。
- en: You may or may not have looked into the `CameraMovement` script that we attached
    to the main camera, but inside that script is a variable called `camSpeed`. This
    variable manipulates the camera's speed; in our `GameManager` script, we set the
    speed of the main camera.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经或还没有查看我们附加到主相机的 `CameraMovement` 脚本，但在这个脚本内部有一个名为 `camSpeed` 的变量。这个变量操纵相机的速度；在我们的
    `GameManager` 脚本中，我们设置了主相机的速度。
- en: The main takeaway from this is that the `CameraMovement` script will manipulate
    the camera's speed from what is set in the `GameManager` script.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中我们可以得出的主要结论是，`CameraMovement` 脚本将根据 `GameManager` 脚本中设置的值来操纵相机的速度。
- en: In the `GameManger` script, scroll down to the method titled `CameraSetup`.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GameManger` 脚本中，向下滚动到标题为 `CameraSetup` 的方法。
- en: 'We are going to make this method take a variable to alter the camera''s speed.
    Change the `CameraSetup` method to take a `float` value in its parameter. The
    `CameraSetup` method will first look as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使这个方法接受一个变量来改变相机的速度。将 `CameraSetup` 方法更改为接受参数中的 `float` 值。`CameraSetup` 方法将首先看起来如下：
- en: '[PRE7]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It will then change to this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它将变成这样：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Within the `CameraSetup` method, we need to transfer `camSpeed` to the new
    `CameraMovement` script:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CameraSetup` 方法中，我们需要将 `camSpeed` 传递到新的 `CameraMovement` 脚本中：
- en: '[PRE9]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the line of code we add to our `CameraSetup` method needs to be added
    after the main camera has been stored in a `gameCamera` variable. Before continuing
    we also need to remove the reference to the `CameraSetup` from the `PlayerSpawner`
    script as we also don't need this anymore.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们添加到 `CameraSetup` 方法的代码需要在将主相机存储在 `gameCamera` 变量之后添加。在继续之前，我们还需要从 `PlayerSpawner`
    脚本中移除对 `CameraSetup` 的引用，因为我们也不再需要它了。
- en: Open the `PlayerSpawner` script.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `PlayerSpawner` 脚本。
- en: 'Scroll to the bottom and remove: `GameManager.Instance.CameraSetup()`.'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下滚动并删除：`GameManager.Instance.CameraSetup()`。
- en: Save the script and return to the `GameManager` script.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并返回到 `GameManager` 脚本。
- en: The last thing to do in the `GameManager` script is to update the `LightandCameraSetup`
    method so that when the `CameraSetup` method within it is called, it takes a value
    that sets the main camera's speed. So, in `level1` and `level2`, we want the camera
    to continue to not move; in `level3`, we will need to apply speed to the camera.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GameManager` 脚本中要做的最后一件事是更新 `LightandCameraSetup` 方法，以便当调用其中的 `CameraSetup`
    方法时，它将接受一个设置主相机速度的值。因此，在 `level1` 和 `level2` 中，我们希望相机继续不移动；在 `level3` 中，我们需要给相机应用速度。
- en: 'Within `LightandCameraSetup`, replace its original `switch` statement with
    the following:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LightandCameraSetup` 中，用以下内容替换其原始的 `switch` 语句：
- en: '[PRE10]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So, before, our `switch` statement had all the cases run `LightSetup` and `CameraSetup`
    within cases `3`, `4`, and `5`. But now, in the previous code, we have split the
    roles up. In cases `3` and `4`, we run `LightSetup` as usual, and now, because
    `CameraSetup` now takes a `float` value, we set the camera speed to `0`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，之前我们的 `switch` 语句在情况 `3`、`4` 和 `5` 中都运行了 `LightSetup` 和 `CameraSetup`。但现在，在之前的代码中，我们已经将角色分开。在情况
    `3` 和 `4` 中，我们像往常一样运行 `LightSetup`，而现在，因为 `CameraSetup` 现在接受一个 `float` 值，我们将相机速度设置为
    `0`。
- en: In case `5`, which is the build number for our `level3` scene, we ignore `LightSetup`,
    as we won't be using a directional light in this scene. We run `CameraSetup` but
    give it a value of `150`, which will also be the speed we set the `camSpeed` variable
    within the method.Save the `GameManager` script.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `5` 情况下，这是我们的 `level3` 场景的构建号，我们忽略 `LightSetup`，因为我们在这个场景中不会使用方向光。我们运行 `CameraSetup`，但给它一个值为
    `150` 的值，这也会是我们在方法内设置的 `camSpeed` 变量的值。保存 `GameManager` 脚本。
- en: 'Press `level3` scene plays out. The following screenshot shows what we have
    so far:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 `level3` 场景开始播放。以下截图显示了到目前为止我们所拥有的内容：
- en: '![Figure 12.4 – Level 3 in Play mode'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.4 – Level 3 in Play mode](Figure_12.4 – Level 3 in Play mode)'
- en: '](img/Figure_12.04_B18381.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_12.04_B18381.jpg](img/Figure_12.04_B18381.jpg)'
- en: Figure 12.4 – Level 3 in Play mode
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 12.4 – Level 3 in Play mode
- en: 'The previous screenshot shows a series of events of what happens after we press
    **Play** in the Unity Editor Let''s go through each event sequentially:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了在 Unity 编辑器中按下 **Play** 后发生的一系列事件。让我们按顺序逐一分析这些事件：
- en: The `level3` scene before pressing **Play** (denoted by **1.**).
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下 **Play** 之前的 `level3` 场景（标记为 **1**）。
- en: The scene is in play mode and sets up the camera position and background (denoted
    by **2.**).
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景处于播放模式，并设置了相机位置和背景（标记为 **2**）。
- en: The UI for the level is animated, and the enemies start floating into the game
    window (denoted by **3.**).
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 级别的 UI 是动画的，敌人开始飘入游戏窗口（标记为 **3**）。
- en: The player enters the level, and the scene pauses for a few seconds before the
    player gets control of their ship (denoted by **4.**).
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家进入关卡，场景暂停几秒钟，然后玩家才能控制他们的飞船（标记为**4.**）。
- en: The camera begins to move along with the radar camera, following the progress
    of the player and the oncoming enemies (denoted by **5.**).
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摄像机开始跟随雷达摄像机移动，跟踪玩家的进度和即将到来的敌人（标记为**5.**）。
- en: In the next section, we will add our second enemy type (flee enemy), which will
    flee across the span of our new art.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将添加我们的第二种敌人类型（逃跑敌人），它将在我们新的艺术作品中逃跑。
- en: Developing AI with NavMesh
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NavMesh开发AI
- en: In this section, we are going to introduce a new enemy that will attempt to
    flee with frenzy-type behavior from our player's ship. This enemy's behavior will
    be implemented with the use of Unity's built-in `NavMesh` functionality.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一个新敌人，该敌人将尝试从玩家的飞船上以狂热型行为逃跑。这个敌人的行为将通过使用Unity内置的`NavMesh`功能来实现。
- en: As you can imagine, this built-in feature from Unity can answer a lot of problems
    with regard to games with NPCs, similar to ones in the Metal Gear Solid game,
    where the player has to sneak around and not get detected by the enemy soldiers.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，Unity的这个内置功能可以解决许多关于NPC游戏的问题，类似于《Metal Gear Solid》游戏中的问题，其中玩家必须偷偷摸摸地行动，以免被敌人士兵发现。
- en: '`NavMesh` gives the enemy soldiers a path to walk around, and then if they
    see the player, their behavior changes from `Patrolling` to `Attack`.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`NavMesh`为敌人士兵提供了一条行走路径，然后如果他们看到玩家，他们的行为将从`巡逻`变为`攻击`。'
- en: So, with our game, we are going to implement `NavMesh` but make it so that our
    enemies react differently to how they would in *Metal Gear Solid*. We will add
    multiple flee enemies in clusters to our third-level scene. This chaotic, distracting
    behavior will make the final level more challenging for our players.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的游戏中，我们将实现`NavMesh`，但使其敌人的反应与他们在*Metal Gear Solid*中的反应不同。我们将向第三级场景添加多个成群的逃跑敌人。这种混乱、分散注意力的行为将使最终关卡对玩家更具挑战性。
- en: 'The following screenshot shows our fleeing enemy with a cylindrical radius
    around it. This radius is called the agent radius and can be altered to stop other
    obstacles and enemies from intersecting with each other:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了围绕我们的逃跑敌人有一个圆柱形半径。这个半径被称为代理半径，可以调整以阻止其他障碍物和敌人相互交叉：
- en: '![Figure 12.5 – Fleeing enemies'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5 – 逃跑敌人'
- en: '](img/Figure_12.05_B18381.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.05_B18381.jpg)'
- en: Figure 12.5 – Fleeing enemies
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – 逃跑敌人
- en: Before we add these fleeing enemies to our scene, we need to tell the fleeing
    enemies where they can move around by baking a NavMesh first.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将这些逃跑敌人添加到场景之前，我们需要通过烘焙一个NavMesh来告诉逃跑敌人他们可以移动的地方。
- en: 'First, we need to select the game object that we will use to bake, which also
    means we need to deselect game objects that don''t need to be **Navigation Static**.
    To bake a NavMesh, follow these instructions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要选择我们将用于烘焙的游戏对象，这也意味着我们需要取消选择不需要设置为**Navigation Static**的游戏对象。要烘焙一个NavMesh，请按照以下说明操作：
- en: From the `_SceneAssets` game object.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`_SceneAssets`游戏对象。
- en: From the `_SceneAssets`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`_SceneAssets`。
- en: 'The following screenshot shows `_SceneAssets` selected and the static dropdown
    (denoted by **1.**), followed by **Navigation Static** being unticked (denoted
    by **2.**):'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了选中`_SceneAssets`并显示静态下拉菜单（标记为**1.**），然后取消选中**Navigation Static**（标记为**2.**）：
- en: '![Figure 12.6 – Unticking Navigation Static'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.6 – 取消选中Navigation Static'
- en: '](img/Figure_12.06_B18381.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.06_B18381.jpg)'
- en: Figure 12.6 – Unticking Navigation Static
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – 取消选中Navigation Static
- en: A window pops up asking whether we want to apply the changes to all the child
    objects. Select **Yes, change children**.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个窗口弹出，询问我们是否希望将更改应用于所有子对象。选择**是，更改子对象**。
- en: 'So, we have just deactivated all of our environment art assets in the `level3`
    scene so that they are not recognized for navigation baking. We now need to turn
    on one of the child game objects within the `_SceneAssets` hierarchy:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们刚刚在`level3`场景中停用了所有环境艺术资产，以便它们不被用于导航烘焙。我们现在需要打开`_SceneAssets`层次结构中的其中一个子游戏对象：
- en: 'From the `corridorFloorNav`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`corridorFloorNav`：
- en: '`_SceneAssets`'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_SceneAssets`'
- en: '`level`'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level`'
- en: '`corridorFloor`'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`corridorFloor`'
- en: 'The following screenshot shows that from the `corridorFloorNav` (denoted by
    **1.**):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了从`corridorFloorNav`（标记为**1.**）：
- en: With `corridorFloorNav` selected, make sure its **Mesh Renderer** component
    is ticked in the **Inspector** window (denoted by **2.**).
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择`corridorFloorNav`时，确保在**Inspector**窗口中选中其**Mesh Renderer**组件（标记为**2.**）。
- en: 'Finally, select **Navigation Static** for this game object (denoted by **3.**):'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为这个游戏对象选择**Navigation Static**（标记为**3.**）：
- en: '![Figure 12.7 – Turning on the ''corridorFloorNav'' game object, Mesh Renderer,
    and the ''Navigation Static'' layer'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.7 – 打开''corridorFloorNav''游戏对象、网格渲染器和''Navigation Static''层'
- en: '](img/Figure_12.07_B18381.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.07_B18381.jpg)'
- en: Figure 12.7 – Turning on the 'corridorFloorNav' game object, Mesh Renderer,
    and the 'Navigation Static' layer
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 – 打开'corridorFloorNav'游戏对象、网格渲染器和'Navigation Static'层
- en: We now need to check the `CorridorFloorNav` mesh.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要检查`CorridorFloorNav`网格。
- en: Select **Window** at the top of the Unity Editor and then click on **AI | Navigation**.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器的顶部选择**窗口**，然后点击**AI | 导航**。
- en: 'It''s likely that the **Navigation** window will appear at the top-right corner
    of the Editor If it doesn''t and has appeared as a floating window somewhere in
    the Unity Editor simply click and hold on the **Navigation** tab and dock it next
    to the **Inspector** tab, as in the following screenshot:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，**导航**窗口会出现在编辑器的右上角。如果它没有出现，并且作为浮动窗口出现在Unity编辑器的某个地方，只需单击并按住**导航**选项卡，并将其停靠在**检查器**选项卡旁边，如图下所示：
- en: '![Figure 12.8 – The Navigation window'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.8 – 导航窗口'
- en: '](img/Figure_12.08_B18381.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.08_B18381.jpg)'
- en: Figure 12.8 – The Navigation window
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 – 导航窗口
- en: In the **Navigation** window, click on the **Bake** button at the top to give
    us our **Navigation** bake options.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**导航**窗口中，点击顶部的**烘焙**按钮，以获取我们的**导航**烘焙选项。
- en: Further Information
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多信息
- en: It's also worth noting that a game object that is manipulated in the NavMesh
    is referred to as an agent.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 还值得注意的是，在NavMesh中操作的游戏对象被称为代理。
- en: 'In this window, we are presented with a series of options for our navigation
    bake. This may look a little intimidating at first, but the blue cylinder is basically
    our agent (the fleeing enemy) and the following parameters are based on how flexible
    our agent is with the navigation path it''ll be walking around. Let''s briefly
    go through each of the options so that we are aware of its features before we
    bake:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个窗口中，我们看到了一系列用于导航烘焙的选项。一开始这可能看起来有些令人畏惧，但蓝色圆柱体基本上是我们的代理（逃跑的敌人）以及以下参数是基于我们的代理在导航路径上的灵活性。让我们简要地浏览每个选项，以便在我们烘焙之前了解其功能：
- en: '**Agent Radius**: This will create an invisible shield around our agent so
    that they can''t clip into other agents, walls, doors, and so on.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理半径**：这将围绕我们的代理创建一个不可见的护盾，使他们不能与其他代理、墙壁、门等发生碰撞。'
- en: '**Agent Height**: Similar to **Agent Radius**, this gives our agent an invisible
    height; this can be useful for the game object that the NavMesh is manipulating
    to pass through doors.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理高度**：类似于**代理半径**，这给我们的代理一个不可见的高度；这对于NavMesh正在操作的游戏对象通过门很有用。'
- en: '**Max Slope**: We can alter, in degrees, how much of a slope our agent can
    walk up.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大坡度**：我们可以以度为单位调整代理可以爬上的坡度。'
- en: '**Step Height**: This is similar to the **Max Slope** property, but in this
    case, this controls how much our agent is allowed to move up a step/stair.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步高**：这与**最大坡度**属性类似，但在这个情况下，它控制我们的代理可以移动多高的一步/楼梯。'
- en: '**Drop Height**: Enter a value for the maximum height the character can drop
    down from (associated with the **Off Mesh Link** component).'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下落高度**：输入角色可以下落的最大高度（与**Off Mesh Link**组件相关联）。'
- en: '**Jump Distance**: This specifies the value for the jump distance between the
    character and the object (associated with the **Off Mesh Link** component).'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跳跃距离**：这指定了角色和对象之间的跳跃距离（与**Off Mesh Link**组件相关联）。'
- en: Further Information
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多信息
- en: Information about the **Off Mesh Link** component can be found at [https://docs.unity3d.com/Manual/class-OffMeshLink.html](https://docs.unity3d.com/Manual/class-OffMeshLink.html).
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于**Off Mesh Link**组件的信息可以在[https://docs.unity3d.com/Manual/class-OffMeshLink.html](https://docs.unity3d.com/Manual/class-OffMeshLink.html)找到。
- en: '**Manual Voxel**: A voxel is a three-dimensional measurement that is used to
    scale the accuracy of our navigation bake.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手动体素**：体素是一种三维测量，用于调整我们导航烘焙的精度。'
- en: '**Voxel Size**: If the **Manual Voxel** option is ticked, this means we can
    give each agent tighter precision. The lower the number, the more accurate our
    agent will be; note that this will make the NavMesh take longer to bake.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**体素大小**：如果勾选了**手动体素**选项，这意味着我们可以为每个代理提供更紧密的精度。数字越低，我们的代理将越精确；请注意，这将使NavMesh烘焙时间更长。'
- en: '**Min Region Area**: This specifies a minimum area that a surface must have
    for it to be included in the NavMesh.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小区域面积**：这指定了一个表面必须具有的最小面积，才能被包含在NavMesh中。'
- en: '**Height Mesh**: This checkbox will create a height mesh, which will improve
    the movement accuracy. This will also make navigation baking slower.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高度网格**：此复选框将创建一个高度网格，这将提高移动精度。这也会使导航烘焙变慢。'
- en: 'The following screenshot shows the navigation bake settings we just went through:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了刚刚经过的导航烘焙设置：
- en: '![Figure 12.9 – The Navigation window with the ''Bake'' tab selected'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.9 – 选择“烘焙”标签的导航窗口'
- en: '](img/Figure_12.09_B18381.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.09_B18381.jpg)'
- en: Figure 12.9 – The Navigation window with the 'Bake' tab selected
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9 – 选择“烘焙”标签的导航窗口
- en: Thankfully, the **Bake** properties of our default setup window will work just
    fine as it is.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们默认设置窗口的**烘焙**属性将按原样正常工作。
- en: 'Click on the **Bake** button at the bottom right of the **Navigation** window
    and wait until the meter at the bottom-right corner of the Editor completes, as
    shown in the following screenshot:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**导航**窗口右下角的**烘焙**按钮，等待编辑器右下角的仪表完成，如下截图所示：
- en: '![Figure 12.10 – Exporting Tiles for your NavMesh'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.10 – 为你的NavMesh导出瓦片'
- en: '](img/Figure_12.10_B18381.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.10_B18381.jpg)'
- en: Figure 12.10 – Exporting Tiles for your NavMesh
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10 – 为你的NavMesh导出瓦片
- en: Once the navigation bake has completed, `corridorFloorNav` in our **Scene**
    window will have a NavMesh sitting on top of its mesh.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦导航烘焙完成，我们**场景**窗口中的`corridorFloorNav`将会有一个位于其网格上的NavMesh。
- en: 'If you can''t see the navigation-baked mesh, make sure that the **Show NavMesh**
    checkbox is ticked at the bottom-right corner of the mesh. The following screenshot
    shows our NavMesh and the **Navmesh Display** box:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看不到导航烘焙的网格，请确保在网格右下角的**显示NavMesh**复选框被勾选。以下截图显示了我们的NavMesh和**Navmesh显示**框：
- en: '![Figure 12.11 – Our navigation mesh and its display at the bottom-right corner
    of the ''Scene'' window'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.11 – 我们的导航网格及其在“场景”窗口右下角显示'
- en: '](img/Figure_12.11_B18381.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.11_B18381.jpg)'
- en: Figure 12.11 – Our navigation mesh and its display at the bottom-right corner
    of the 'Scene' window
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11 – 我们的导航网格及其在“场景”窗口右下角显示
- en: The last thing to do in this section is turn off the `corridorFloorNav` game
    object's **Mesh Renderer** component. We only needed this component to be active
    for the NavMesh to be baked.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中最后要做的就是关闭`corridorFloorNav`游戏对象的**网格渲染器**组件。我们只需要这个组件处于活动状态，以便烘焙NavMesh。
- en: 'To turn off the `corridorFloorNav` game object''s **Mesh Renderer** component,
    do the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭`corridorFloorNav`游戏对象的**网格渲染器**组件，请执行以下操作：
- en: Select the `corridorFloorNav` game object in the **Hierarchy** window.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择`corridorFloorNav`游戏对象。
- en: In the **Inspector** window, uncheck the **Mesh Renderer** component.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，取消选中**网格渲染器**组件。
- en: 'The following screenshot shows the highlighted box that needs unchecking:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了需要取消选中的高亮框：
- en: '![Figure 12.12 – Unticking the ''corridorFloorNav'' mesh'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.12 – 取消选中''corridorFloorNav''网格'
- en: '](img/Figure_12.12_B18381.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.12_B18381.jpg)'
- en: Figure 12.12 – Unticking the 'corridorFloorNav' mesh
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12 – 取消选中'corridorFloorNav'网格
- en: This is all that is needed to allow our fleeing enemies to move around.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是允许我们的逃跑敌人四处移动所需的所有内容。
- en: Further Information
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: If you would like to find out more about the **Navigation** window, check out
    [https://docs.unity3d.com/Manual/Navigation.html](https://docs.unity3d.com/Manual/Navigation.html).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于**导航**窗口的信息，请查看[https://docs.unity3d.com/Manual/Navigation.html](https://docs.unity3d.com/Manual/Navigation.html)。
- en: So far in this section, we have discussed the requirements of AI and how it
    is used in games and how we are going to apply such methods to our fleeing enemies,
    with the use of the `NavMesh` system that Unity offers as standard.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本节中，我们讨论了AI的要求以及它在游戏中的应用，以及我们将如何使用Unity提供的标准NavMesh系统来应用这些方法到我们的逃跑敌人上。
- en: Now that we have our NavMesh baked for our agents to move around on, we can
    look into setting up our `NavMeshAgent` component to give our agents a set speed,
    acceleration, stopping distance, and more in the next section.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的代理烘焙了NavMesh，以便它们可以移动，我们可以在下一节中查看设置我们的`NavMeshAgent`组件，为我们的代理设置一个固定的速度、加速度、停止距离等。
- en: Customizing our agents – NavMeshAgent
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制我们的代理 – NavMeshAgent
- en: In this section, we will be continuing from setting up our NavMesh but shifting
    the focus toward the agent (the fleeing enemy game object). The agent will be
    moving around the baked NavMesh.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将继续设置 NavMesh，但将重点转向代理（逃跑敌人游戏对象）。代理将在烘焙的 NavMesh 上移动。
- en: It is necessary for the fleeing enemy game object to be able to react and move
    within the NavMesh but also be able to move in a way that suits the behavior of
    what we're trying to achieve. For example, the enemy is to flee with an element
    of panic; so, we need to consider characteristics such as when the enemy decides
    to move, how quickly the enemy will react, and how fast the enemy can move. These
    properties, and more, come from a component called `NavMeshAgent`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 逃跑敌人游戏对象需要能够在 NavMesh 内部做出反应和移动，同时也能以适合我们想要实现的行为的方式移动。例如，敌人需要带有恐慌的逃跑；因此，我们需要考虑诸如敌人何时决定移动、敌人反应速度有多快以及敌人移动速度有多快等特征。这些属性以及更多，都来自于一个名为
    `NavMeshAgent` 的组件。
- en: '`NavMeshAgent` is a required component that will be attached to each of the
    fleeing enemy game objects. The purpose of this component is to make it so that
    the game object is recognized as an agent and will stick to the NavMesh.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`NavMeshAgent` 是一个必需的组件，它将被附加到每个逃跑敌人游戏对象上。这个组件的目的是使游戏对象被识别为代理，并保持在 NavMesh
    上。'
- en: 'Before we add `NavMeshAgent` to the fleeing enemy, we need to create a prefab
    of the enemy so that we have a place where we can grab and clone copies of multiple
    enemies:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将 `NavMeshAgent` 添加到逃跑敌人之前，我们需要创建一个敌人预制件，这样我们就有了一个可以抓取和克隆多个敌人副本的地方：
- en: From the `Assets/Model` folder and drag `enemy_flee.fbx` to the bottom of the
    **Hierarchy** window.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Assets/Model` 文件夹中拖动 `enemy_flee.fbx` 到 **Hierarchy** 窗口的底部。
- en: Drag `enemy_flee` from the `Assets/Prefab/Enemies`. When the window pops up
    asking if you want a variant or original. Pick original. As there is only one
    type of this enemy.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Assets/Prefab/Enemies` 中拖动 `enemy_flee`。当窗口弹出询问是否要选择变体或原始时，选择原始。因为这种敌人只有一种类型。
- en: 'That''s our fleeing enemy created; now, we can apply a material to it by doing
    the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们的逃跑敌人就创建完成了；现在，我们可以通过以下步骤为其应用材质：
- en: Navigate to the `Assets/Prefab/Enemies` folder and select the `enemy_flee` prefab.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `Assets/Prefab/Enemies` 文件夹并选择 `enemy_flee` 预制件。
- en: From the **Inspector** window, select the remote button of the **Mesh Renderer**
    component (denoted by **1**. in the following screenshot).
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Inspector** 窗口中，选择 **Mesh Renderer** 组件的远程按钮（以下屏幕截图标记为 **1**）。
- en: A dropdown will appear. Type `darkRed` in the search bar at the top if you can't
    see the material on the list.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在列表中看不到材质，请在顶部的搜索栏中输入 `darkRed`。
- en: Double-click on `darkRed` from the dropdown (denoted by **2.** in the following).
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击下拉菜单中的 `darkRed`（以下标记为 **2**）。
- en: At this point, make sure that the `0` value and that the `1`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，请确保 `0` 值和 `1` 值。
- en: 'The following screenshot shows the `enemy_flee` prefab with its update material
    and the correct **Transform** values:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了带有更新材质和正确 **Transform** 值的 `enemy_flee` 预制件：
- en: '![Figure 12.13 – Adding the ''darkRed'' material to the ''enemy_flee'' Mesh
    Renderer Materials slot'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.13 – 将 ''darkRed'' 材质添加到 ''enemy_flee'' 网格渲染器材质槽中'
- en: '](img/Figure_12.13_B18381.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.13_B18381.jpg)'
- en: Figure 12.13 – Adding the 'darkRed' material to the 'enemy_flee' Mesh Renderer
    Materials slot
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.13 – 将 'darkRed' 材质添加到 'enemy_flee' 网格渲染器材质槽中
- en: 'You may have noticed in the previous screenshot that `enemy_flee` has hard,
    shiny edges. We can make these appear smoother in our three-dimensional model
    import settings by doing the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到在前一个屏幕截图中，`enemy_flee` 有硬朗、闪亮的边缘。我们可以在三维模型导入设置中通过以下方式使这些边缘看起来更平滑：
- en: From the `Assets/Model` folder and select `enemy_flee`.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Assets/Model` 文件夹中选择 `enemy_flee`。
- en: In the **Inspector** window, change the property value for **Normals** from
    **Import** to **Calculate**.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Inspector** 窗口中，将 **Normals** 属性值从 **Import** 更改为 **Calculate**。
- en: 'We can now adjust the **Smoothing Angle** value with the slider to change the
    smoothness between angles, as shown in the following screenshot:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过滑动条调整 **Smoothing Angle** 值来改变角度之间的平滑度，如图所示：
- en: '![Figure 12.14 – Smoothing the edges of our enemy'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.14 – 平滑我们的敌人边缘'
- en: '](img/Figure_12.14_B18381.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.14_B18381.jpg)'
- en: Figure 12.14 – Smoothing the edges of our enemy
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.14 – 平滑我们的敌人边缘
- en: In the previous screenshot, you can see three distinct stages in making the
    model look smoother. This can be done with any three-dimensional model imported
    into Unity.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你可以看到制作模型看起来更平滑的三个不同阶段。这可以通过任何导入到Unity中的三维模型来完成。
- en: Once you're happy with the **Smoothing Angle** value, click on **Apply** at
    the bottom-right corner of the **Inspector** window.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你对 **平滑角度** 值满意，点击 **检查器** 窗口右下角的 **应用**。
- en: 'Coming back to `enemy_flee` in the **Hierarchy** window, as this is an enemy,
    we also need to give it an **Enemy** tag so that the player recognizes it as such
    if and when they collide with each other:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 **层次** 窗口的 `enemy_flee`，因为这是一个敌人，我们还需要给它一个 **敌人** 标签，以便玩家在碰撞时能识别它：
- en: Click on the **Tag** parameter at the top of the **Inspector** window.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **检查器** 窗口顶部的 **标签** 参数。
- en: Select **Enemy**.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **敌人**。
- en: 'The following screenshot shows the `enemy_flee`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 `enemy_flee`：
- en: '![Figure 12.15 – Our enemy being given an ''Enemy'' tag'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.15 – 我们正在给敌人添加一个“敌人”标签'
- en: '](img/Figure_12.15_B18381.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.15 – 我们正在给敌人添加一个“敌人”标签'
- en: Figure 12.15 – Our enemy being given an 'Enemy' tag
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15 – 我们正在给敌人添加一个“敌人”标签
- en: 'We are now ready to apply `NavMeshAgent` to the `enemy_flee` game object. With
    `enemy_flee` still selected, do the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好将 `NavMeshAgent` 应用到 `enemy_flee` 游戏对象上。在 `enemy_flee` 仍然被选中时，执行以下操作：
- en: Click on the **Add Component** button in the **Inspector** window.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **检查器** 窗口中点击 **添加组件** 按钮。
- en: A drop-down list will appear. Type in `nav` and select `NavMeshAgent` from the
    list.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将出现一个下拉列表。输入 `nav` 并从列表中选择 `NavMeshAgent`。
- en: '`enemy_flee` now has `NavMeshAgent` attached to it. As previously mentioned,
    let''s go through each of the properties. The following screenshot also shows
    the `NavMeshAgent` default values (these may differ from your default values,
    but don''t be concerned, as we will be changing the majority of the values):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`enemy_flee` 现在已附加了 `NavMeshAgent`。如前所述，让我们逐一查看每个属性。以下截图也显示了 `NavMeshAgent`
    的默认值（这些值可能不同于您的默认值，但请放心，我们将更改大多数值）：'
- en: '![Figure 12.16 – The ''Nav Mesh Agent'' component (its own default values –
    ignore them)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.16 – “导航网格代理”组件（其默认值 – 忽略它们）'
- en: '](img/Figure_12.16_B18381.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.16 – “导航网格代理”组件（其默认值 – 忽略它们）'
- en: Figure 12.16 – The 'Nav Mesh Agent' component (its own default values – ignore
    them)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16 – “导航网格代理”组件（其默认值 – 忽略它们）
- en: '**Agent Type**: By default, there is only one agent type. This holds a preset
    of the name of the agent, the radius, height, step height, and max slope. To find
    out more about these values, check the previous section.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理类型**：默认情况下，只有一个代理类型。这包含代理名称、半径、高度、步高和最大坡度的预设。要了解更多关于这些值的信息，请查看前面的部分。'
- en: '**Base Offset**: This will change the placement of the agent mesh, which wraps
    around the fleeing enemy in the form of a cylinder that can only be seen in the
    **Scene** window.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础偏移**：这将改变代理网格的位置，它以圆柱的形式围绕逃跑的敌人，只能在 **场景** 窗口中看到。'
- en: '**Speed**: The maximum speed value, based on world units per second.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：基于每秒世界单位的最大速度值。'
- en: '**Angular Speed**: Sets how quickly the agent can rotate in degrees per second.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角速度**：设置代理每秒旋转的度数。'
- en: '**Acceleration**: Maximum acceleration based on world units per second squared.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加速度**：基于每秒平方世界单位的最大加速度。'
- en: '**Stopping Distance**: Agents will stop when they are at a particular measurement.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止距离**：代理将在达到特定测量值时停止。'
- en: '**Auto Braking**: The agent will slow down gradually before reaching a complete
    stop.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动制动**：代理在完全停止之前会逐渐减速。'
- en: '**Radius**: The agent''s spatial area will increase the scale of the agent
    cylinder.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半径**：代理的空间区域将增加代理圆柱的缩放比例。'
- en: '**Height**: This will increase the height of the agent''s cylinder.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高度**：这将增加代理圆柱的高度。'
- en: '**Quality**: The ranges of the accuracy of obstacle avoidance.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量**：障碍物避免的精度范围。'
- en: '**Priority**: Agents of a lower priority will be ignored by this agent when
    performing avoidance.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先级**：在执行规避时，此代理将忽略优先级较低的代理。'
- en: '**Auto Traverse Off Mesh Link**: If you want the agent to move between gaps,
    keep this checked; otherwise, custom animation will move the agent across the
    gap.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动穿越网格链接**：如果您想让代理在缝隙之间移动，请勾选此选项；否则，自定义动画将使代理穿越缝隙。'
- en: '**Auto Repath**: If the agent is no longer on the path they are walking, with
    this option checked, they will try and make their way back to the nearest point.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动重规划路径**：如果代理不再在它们正在走的路径上，勾选此选项后，它们将尝试回到最近的点。'
- en: '**Area Mask**: With navigation baking, we can set which area this agent belongs
    to.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区域遮罩**：通过导航烘焙，我们可以设置这个代理属于哪个区域。'
- en: For `NavMeshAgent`, we will set its agents to a high speed, rotation, and acceleration
    value to make these enemies react fast to match their fleeing behavior.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `NavMeshAgent`，我们将将其代理设置为高速、旋转和加速度值，以便这些敌人能够快速反应，以匹配它们的逃跑行为。
- en: 'Change the `NavMeshAgent` values for the `enemy_flee` prefab to the ones shown
    in the following screenshot. However, it''s recommended to change and alter the
    values to make the enemies behave differently. Theres no wrong approach. But as
    a guide, match the ones in the following screenshot:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `enemy_flee` 预制体的 `NavMeshAgent` 值更改为以下截图所示的值。然而，建议更改和调整这些值以使敌人行为不同。没有错误的方法。但作为指导，匹配以下截图中的值：
- en: '![](img/Figure_12.17_B18381.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_12.17_B18381.jpg)'
- en: Figure 12.17 – 'Nav Mesh Agent' with set values
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.17 – 'Nav Mesh Agent' 设置的值
- en: Click **Overrides | Apply All** at the top-right corner of the **Inspector**
    window to confirm your prefab changes.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **检查器** 窗口的右上角点击 **覆盖 | 应用全部** 以确认您的预制体更改。
- en: In this section, we created the fleeing enemy prefab and gave it a material.
    We also applied a `NavMeshAgent` component to our enemy so that it's calibrated
    and ready to react.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了逃跑的敌人预制体并为其添加了材质。我们还为我们的敌人应用了一个 `NavMeshAgent` 组件，使其校准并准备好反应。
- en: 'The following screenshot shows what the fleeing enemy looks like with its `NavMeshAgent`
    component wrapped around it, which can only be seen in the **Scene** window:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了逃跑的敌人及其 `NavMeshAgent` 组件包裹的样子，这只能在 **场景** 窗口中看到：
- en: '![Figure 12.18 – Our enemy with its NavMeshAgent collider wrapped around it'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.18 – 我们带有 NavMeshAgent 碰撞体的敌人'
- en: '](img/Figure_12.18_B18381.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.18_B18381.jpg)'
- en: Figure 12.18 – Our enemy with its NavMeshAgent collider wrapped around it
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.18 – 我们带有 NavMeshAgent 碰撞体的敌人
- en: In the next section, we will give the fleeing enemy prefab a collider so that
    when the player makes contact with it, the player and the enemy are destroyed
    with the soon-to-come scripting.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将为逃跑的敌人预制体添加一个碰撞体，以便当玩家接触它时，玩家和敌人将随着即将到来的脚本被销毁。
- en: Adding a capsule collider to our fleeing enemy
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为我们的逃跑敌人添加胶囊碰撞体
- en: 'In this section, we are going to add a capsule collider to the fleeing enemy
    so that a collision can be detected from the player''s ship when they collide
    with each other:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为逃跑的敌人添加一个胶囊碰撞体，以便在它们相互碰撞时检测到来自玩家飞船的碰撞：
- en: With the `enemy_flee` prefab still selected, scroll down to the bottom of the
    **Inspector** window and click on **Add Component**.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `enemy_flee` 预制体仍然被选中的情况下，滚动到 **检查器** 窗口的底部并点击 **添加组件**。
- en: Start typing `Capsule` into the drop-down window until you see **Capsule Collider**.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下拉窗口中开始输入 `Capsule`，直到你看到 **胶囊碰撞体**。
- en: Select **Capsule Collider** from the drop-down list. The fleeing enemy will
    now have a capsule collider wrapped around them.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉列表中选择 **胶囊碰撞体**。逃跑的敌人现在将有一个胶囊碰撞体包裹在其周围。
- en: Finally, tick the **Is Trigger** checkbox in the **Capsule Collider** component.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 **胶囊碰撞体** 组件中勾选 **是触发器** 复选框。
- en: Click on the `enemy_flee` prefab's settings.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `enemy_flee` 预制体的设置。
- en: Select the `enemy_flee` game object in **Hierarchy** and delete it.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次结构** 中选择 `enemy_flee` 游戏对象并删除它。
- en: 'The following screenshot shows `enemy_flee` with its capsule collider; these
    values may differ to yours:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 `enemy_flee` 带有其胶囊碰撞体；这些值可能与你不同：
- en: '![Figure 12.19 – ''enemy_flee'' with its capsule collider'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.19 – 带其胶囊碰撞体的 ''enemy_flee'''
- en: '](img/Figure_12.19_B18381.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.19_B18381.jpg)'
- en: Figure 12.19 – 'enemy_flee' with its capsule collider
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.19 – 带其胶囊碰撞体的 'enemy_flee'
- en: The fleeing enemy is nearly ready to be tried out in the game. We just need
    to add a script to tell the game object what to do when it gets within a certain
    distance of the player. We will cover this in the next section.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 逃跑的敌人几乎准备好在游戏中尝试了。我们只需要添加一个脚本，告诉游戏对象当它接近玩家一定距离时该做什么。我们将在下一节中介绍这一点。
- en: Creating our fleeing enemy script
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的逃跑敌人脚本
- en: In this section, we will be making it so that the fleeing enemy detects when
    the player is getting close to them. If the player is too close, we will make
    it so that the enemy begins to flee.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使逃跑的敌人能够检测到玩家是否靠近。如果玩家太近，我们将使敌人开始逃跑。
- en: 'We will be taking a script that is partially made and import it into this chapter,
    as the majority of the `EnemyFlee` script will contain a similar setup to the
    previous enemy that we made in [*Chapter 2*](B18381_02_Epub.xhtml#_idTextAnchor048)*,
    Adding and Manipulating Objects*. Follow these steps:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将取一个部分完成的脚本并将其导入到本章，因为`EnemyFlee`脚本的大部分内容将与我们之前制作的相同设置，即[*第2章*](B18381_02_Epub.xhtml#_idTextAnchor048)*，添加和操作对象*。按照以下步骤操作：
- en: From the `Assets/Script`.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Assets/Script`。
- en: Double-click on the `EnemyFlee` script to begin adding its navigation code.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`EnemyFlee`脚本以开始添加其导航代码。
- en: The `EnemyFlee` script will contain similar-looking code to the `EnemyWave`
    script. The enemies in our game will carry the same properties, such as giving
    and taking damage when hit or dying, detecting a collision, and inheriting their
    own scriptable object asset. There's no real need to go through this process again.
    What we are interested in is how the `enemy_flee` game object acts.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`EnemyFlee`脚本将包含类似于`EnemyWave`脚本的代码。我们的游戏中的敌人将具有相同的属性，例如被击中或死亡时给予和接受伤害、检测碰撞以及继承它们自己的可脚本化对象资产。实际上没有必要再次进行这个过程。我们感兴趣的是`enemy_flee`游戏对象的行为。'
- en: 'To add the fleeing behavior to the `EnemyFlee` script, we need to do the following:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要将逃跑行为添加到`EnemyFlee`脚本中，我们需要执行以下步骤：
- en: 'At the top of the script, add the AI library to give our script access to the
    **Navigation Agent** files:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本顶部添加AI库，以便我们的脚本可以访问**导航代理**文件：
- en: '[PRE11]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In our script, we will need access to the `NavMeshAgent` component (which is
    attached to our `enemy_flee` game object). The AI library gives us this functionality.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的脚本中，我们需要访问`NavMeshAgent`组件（它附加到我们的`enemy_flee`游戏对象上）。AI库为我们提供了这个功能。
- en: 'Scroll down in the script to where our global variables are (`health`, `travelSpeed`,
    `fireRate`, and so on) and add the following variables that we will be using with
    our navigation setup:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本中向下滚动到我们的全局变量位置（`health`、`travelSpeed`、`fireRate`等），并添加以下我们将要使用的变量，这些变量将用于我们的导航设置：
- en: '[PRE12]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first variable will be used to store the reference to the player's ship,
    as we will be comparing its distance later on. The `bool` value will be used as
    part of a delayed start for our script. We will talk more about this later on
    as well.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变量将用于存储对玩家飞船的引用，因为我们将在稍后比较其距离。布尔值将作为我们脚本延迟启动的一部分使用。我们稍后会更详细地讨论这一点。
- en: '`enemyDistanceRun` will be used as a rule to "act" within the measured distance
    between the player and our fleeing enemy. We have also added the `SerializeField`
    attribute to this, as it will be handy to change these values in the **Inspector**
    window while keeping this variable private. Do try a different value if you think
    200 is too low. Experiment!'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`enemyDistanceRun`将用作规则，在玩家和我们的逃跑敌人之间的测量距离内“行动”。我们还添加了`SerializeField`属性，因为它在**检查器**窗口中更改这些值时将非常方便，同时保持这个变量为私有。如果你认为200太低，可以尝试不同的值。实验一下吧！'
- en: Finally, we have `NavMeshAgent`, which will be required to receive data from
    the player and fleeing enemy results.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`NavMeshAgent`，它将需要接收来自玩家和逃跑敌人的数据。
- en: 'Create a `Start` function that will require a short delay to get a reference
    from the player ship. Enter the following code. We will go through each step to
    see why there is a delay and the standard `ActorStats` method:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Start`函数，它需要一个短暂的延迟来从玩家飞船获取引用。输入以下代码。我们将逐步分析为什么会有延迟以及标准的`ActorStats`方法：
- en: '[PRE13]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `Start` function contains the `ActorStats` method, which will update our
    enemy's abilities (the health value, points added to the score, and so on), similar
    to our `enemy_wave` game object. We will also run an `Invoke` function, which
    takes the name of the method we wish to run along with a parameter that determines
    when the method will be run.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start`函数包含`ActorStats`方法，它将更新我们的敌人能力（如健康值、添加到分数中的点数等），类似于我们的`enemy_wave`游戏对象。我们还将运行一个`Invoke`函数，该函数接受我们希望运行的方法的名称以及一个参数，用于确定方法将在何时运行。'
- en: We are running a short `0.5f` second delay, giving the player's ship time to
    be instantiated into the scene before we take a reference from it. We set a Boolean
    value to `true` to say that the `update` function can run the content within it,
    which we will cover shortly. The final thing we do is take reference from the
    `NavMeshAgent` component attached to the game object.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行了一个短暂的`0.5f`秒延迟，给玩家的飞船时间在我们在它上面获取引用之前实例化到场景中。我们设置一个布尔值为`true`，表示`update`函数可以运行其中的内容，我们将在稍后讨论。我们做的最后一件事是从附加到游戏对象的`NavMeshAgent`组件中获取引用。
- en: We need to add a slight amendment to our speed value in our `ActorStats` method.
    Because we are affecting `NavMeshAgent_speed`, we need to manipulate this directly.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`ActorStats`方法中的速度值上进行轻微的修改。因为我们正在影响`NavMeshAgent_speed`，所以我们需要直接操作它。
- en: 'To make the enemies'' speed adjustable, add the following line of code within
    `ActorStats` of the `EnemyFlee` script:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使敌人的速度可调节，请在`EnemyFlee`脚本的`ActorStats`中添加以下代码行：
- en: '[PRE14]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The enemy flee speed value is now hooked up.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人逃跑的速度值现在已连接。
- en: 'Moving on to the last piece of our code, the `Update` function will be measuring
    and reacting to and from the distance of our fleeing enemy and the player. Enter
    the following `Update` function and its content, and we will go through each step:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续到我们代码的最后一部分，`Update`函数将测量并响应逃跑的敌人和玩家之间的距离。输入以下`Update`函数及其内容，我们将逐步讲解：
- en: '[PRE15]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the `Update` function, we will run an `if` statement to check whether the
    `gameStarts` Boolean value is `true`; if it is `true`, we then check to see whether
    `player_ship` is still in the scene. And if that is `true`, we move on to the
    content in that `if` statement. Within this `if` statement, we use `Vector3.Distance`
    to measure the distance between the player's ship and the fleeing enemy. We then
    store the measurement as a `float` value called `distance`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Update`函数中，我们将运行一个`if`语句来检查`gameStarts`布尔值是否为`true`；如果是`true`，我们接着检查`player_ship`是否仍在场景中。如果是`true`，我们继续执行该`if`语句中的内容。在这个`if`语句中，我们使用`Vector3.Distance`来测量玩家飞船和逃跑的敌人之间的距离。然后我们将测量结果存储为一个名为`distance`的`float`值。
- en: Next, we run a check to see whether the distance measured is less than the `enemyDistanceRun`
    value, which is currently set to `200`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们运行一个检查，看看测量的距离是否小于`enemyDistanceRun`值，该值目前设置为`200`。
- en: If the `distance` variable's value is lower, then that means the player's ship
    is too close to the fleeing enemy, so we run the following steps for it to react.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`distance`变量的值较低，那么这意味着玩家的飞船离逃跑的敌人太近，因此我们需要执行以下步骤来使其做出反应。
- en: Store the `Vector3` variable, which minuses the player's position from our own.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储减去玩家位置的`Vector3`变量。
- en: We then add this `Vector3` variable to the fleeing enemy's `newPos` position
    of `Vector3`, which will be the direction for the enemy flee to run in.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们将这个`Vector3`变量添加到逃跑的敌人的`newPos`位置，这将是指引敌人逃跑的方向。
- en: Finally, we send this `newPos` position to `NavMeshAgent`.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将这个`newPos`位置发送到`NavMeshAgent`。
- en: Save the `EnemyFlee` script.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存`EnemyFlee`脚本。
- en: 'We are now ready to attach the `EnemyFlee` script to our `enemy_flee` prefab.
    Let''s do this now; then, we will be able to test the results:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备将`EnemyFlee`脚本附加到我们的`enemy_flee`预制体上。让我们现在就做这件事；然后，我们将能够测试结果：
- en: Back in the Unity Editor navigate to the `Assets/Prefab/Enemies` folder in the
    **Project** window.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器中，导航到**项目**窗口中的`Assets/Prefab/Enemies`文件夹。
- en: Select the `enemy_flee` prefab.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`enemy_flee`预制体。
- en: Click on the `EnemyFlee`.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`EnemyFlee`。
- en: Select the `Enemy Flee` script from the drop-down list.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉列表中选择`Enemy Flee`脚本。
- en: Create a new `BasicFlee_Enemy`, and then store it in `Assets/ScriptableObject`.
    Drag the Actor into the Actor Model area of the `EnemyFlee` script in the **Inspector**
    window, as shown in the following screenshot.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`BasicFlee_Enemy`，并将其存储在`Assets/ScriptableObject`中。将Actor拖入**检查器**窗口中`EnemyFlee`脚本的Actor
    Model区域，如图所示。
- en: 'The following screenshot shows the scriptable object asset for the `EnemyFlee`
    script''s **Actor Model** parameter on the right:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`EnemyFlee`脚本的可脚本化对象资产在右侧的**Actor Model**参数：
- en: '![Figure 12.20 – The ''enemy_flee'' game object holding its ''EnemyFlee'' script
    and updated fields'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.20 – 持有其''EnemyFlee''脚本和更新字段的''enemy_flee''游戏对象](img/Figure_12.20_B18381.jpg)'
- en: '](img/Figure_12.20_B18381.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_12.20_B18381.jpg](img/Figure_12.20_B18381.jpg)'
- en: Figure 12.20 – The 'enemy_flee' game object holding its 'EnemyFlee' script and
    updated fields
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.20 – 持有其'EnemyFlee'脚本和更新字段的'enemy_flee'游戏对象
- en: We now need to make our `enemy_flee` script recognizable on the radar map in
    the game HUD, as with the `enemy_wave` game object. As a reminder, we made a `radarPoint`
    object before in [*Chapter 9*](B18381_09_Epub.xhtml#_idTextAnchor161), *Creating
    a 2D Shop Interface and In-Game HUD*. So, in this chapter, we're going to speed
    things up and use a ready-made `radarPoint` object to attach to the `enemy_flee`
    game object. The only difference with the ready-made `radarPoint` game object
    is that I have attached a small script called `RadarRotation` that will make the
    `radarPoint` sprite always face the camera, regardless of which rotation the `enemy_flee`
    game object makes.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要使我们的`enemy_flee`脚本在游戏HUD中的雷达图上可识别，就像`enemy_wave`游戏对象一样。作为提醒，我们在[*第9章*](B18381_09_Epub.xhtml#_idTextAnchor161)，*创建2D商店界面和游戏内HUD*中创建了一个`radarPoint`对象。因此，在本章中，我们将加快速度，并使用一个现成的`radarPoint`对象将其附加到`enemy_flee`游戏对象上。与现成的`radarPoint`游戏对象唯一的不同之处在于，我附加了一个名为`RadarRotation`的小脚本，该脚本将使`radarPoint`精灵始终面向相机，无论`enemy_flee`游戏对象进行何种旋转。
- en: The `RadarRotation` script takes the current rotation in the `Awake` function,
    followed by reapplying the rotation on `LateUpdate`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`RadarRotation`脚本在`Awake`函数中获取当前旋转，然后在`LateUpdate`中重新应用旋转。'
- en: What Is LateUpdate?
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是`LateUpdate`？
- en: '`LateUpdate` is the last function called in Unity''s execution order game logic.
    The benefit to this is that there is no fighting between the rotation of the `radarPoint`
    object and the `enemy_flee` rotation being called at the same time. If you would
    like to learn more about the execution order, check out [https://docs.unity3d.com/Manual/ExecutionOrder.html](https://docs.unity3d.com/Manual/ExecutionOrder.html).'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`LateUpdate`是Unity执行顺序中最后调用的函数。这样做的好处是，`radarPoint`对象的旋转和同时被调用的`enemy_flee`旋转之间没有冲突。如果您想了解更多关于执行顺序的信息，请查看[https://docs.unity3d.com/Manual/ExecutionOrder.html](https://docs.unity3d.com/Manual/ExecutionOrder.html)。'
- en: 'To attach the pre-made `radarPoint` object to the `enemy_flee` prefab, we need
    to do the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 要将预制的`radarPoint`对象附加到`enemy_flee`预制体上，我们需要执行以下操作：
- en: Back in the `enemy_flee` prefab from `Assets/Prefab/Enemies` into the **Hierarchy**
    window.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回`enemy_flee`预制体，从`Assets/Prefab/Enemies`到**层次结构**窗口。
- en: Drag and drop the `radarPoint` object from `Assets/Prefab/Enemies` onto the
    `enemy_flee` prefab in the **Hierarchy** window.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`radarPoint`对象从`Assets/Prefab/Enemies`拖放到**层次结构**窗口中的`enemy_flee`预制体上。
- en: Then, drag and drop the `RadarRotation` script from `Assets/Script` into the
    `enemy_flee` `radarPoint` object point toward the camera.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将`RadarRotation`脚本从`Assets/Script`拖放到`enemy_flee`的`radarPoint`对象上，使其指向相机。
- en: Once applied, select the `enemy_flee` prefab from the **Hierarchy** window,
    and then click on **Overrides | Apply All** at the top-right corner of the **Inspector**
    window.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦应用，从**层次结构**窗口中选择`enemy_flee`预制体，然后点击**覆盖 | 应用全部**在**检查器**窗口的右上角。
- en: 'The following screenshot shows the `enemy_flee` prefab holding the `radarPoint`
    object, along with the `radarPoint` object in the **Inspector** window, as a reference
    to help avoid any errors:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了`enemy_flee`预制体持有的`radarPoint`对象，以及**检查器**窗口中的`radarPoint`对象，作为避免任何错误的参考：
- en: '![Figure 12.21 – The ''radarPoint'' game object and its Transform property
    values'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.21 – ‘radarPoint’游戏对象及其变换属性值'
- en: '](img/Figure_12.21_B18381.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.21_B18381.jpg)'
- en: Figure 12.21 – The 'radarPoint' game object and its Transform property values
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.21 – ‘radarPoint’游戏对象及其变换属性值
- en: 'Our `enemy_flee` prefab is now ready to be trialed out in `enemy_flee` from
    its current location to the `_Enemies` game object in the `enemy_flee` now is
    in the **Hierarchy** window:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`enemy_flee`预制体现在可以从其当前位置在`enemy_flee`中试验到`_Enemies`游戏对象，现在在**层次结构**窗口中：
- en: '![Figure 12.22 – The ''Enemies'' game object children in the Hierarchy window'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.22 – **层次结构**窗口中‘Enemies’游戏对象的子对象'
- en: '](img/Figure_12.22_B18381.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.22_B18381.jpg)'
- en: Figure 12.22 – The 'Enemies' game object children in the Hierarchy window
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.22 – **层次结构**窗口中‘Enemies’游戏对象的子对象
- en: 'Set the `enemy_flee` prefab to somewhere near the start of the level. I have
    placed mine at the following **Transform** values:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`enemy_flee`预制体放置在关卡开始附近的位置。我将其放置在以下**变换**值中：
- en: '![Figure 12.23 – The ''enemy_flee'' game object placement in level 3'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.23 – 第3级中‘enemy_flee’游戏对象的位置'
- en: '](img/Figure_12.23_B18381.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.23_B18381.jpg)'
- en: Figure 12.23 – The 'enemy_flee' game object placement in level 3
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.23 – 第3级中‘enemy_flee’游戏对象的位置
- en: If you also have the `EnemySpawner` object in the scene close to the start of
    the level, push it back along the *x* axis as far as `1000` to get it out of the
    way.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你也在关卡开始附近有 `EnemySpawner` 对象，将其沿 *x* 轴推回直到 `1000`，以便将其移开。
- en: Click the `enemy_flee` object should now start panicking and moving around to
    try and escape from you!
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击 `enemy_flee` 对象应该开始恐慌并四处移动，试图逃离你！
- en: 'Feel free to select the `enemy_flee` object in the **Hierarchy** window and
    press *Left* + *Ctrl* (*Command* on macOS) + *D* on your keyboard to spread a
    few fleeing enemies around to make the level more interesting, as shown in the
    following screenshot:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自由地在 **层次结构** 窗口中选择 `enemy_flee` 对象，然后按键盘上的 *左键* + *Ctrl* (*Command* 在 macOS
    上) + *D*，将几个逃跑的敌人分散到周围，使关卡更有趣，如以下截图所示：
- en: '![Figure 12.24 – Duplicated ''enemy_flee'' game objects'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.24 – 复制的 ''enemy_flee'' 游戏对象'
- en: '](img/Figure_12.24_B18381.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_12.24_B18381.jpg](img/Figure_12.24_B18381.jpg)'
- en: Figure 12.24 – Duplicated 'enemy_flee' game objects
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.24 – 复制的 'enemy_flee' 游戏对象
- en: The following screenshot shows our new fleeing enemies trying to escape from
    the player in pure panic!
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的新逃跑敌人试图在纯粹的恐慌中逃离玩家！
- en: '![Figure 12.25 – Enemies fleeing from the player!'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.25 – 敌人从玩家那里逃跑！'
- en: '](img/Figure_12.25_B18381.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_12.25_B18381.jpg](img/Figure_12.25_B18381.jpg)'
- en: Figure 12.25 – Enemies fleeing from the player!
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.25 – 敌人从玩家那里逃跑！
- en: Save the scene.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景。
- en: That's the end of this section, and hopefully, you now feel comfortable with
    this introduction to using the NavMesh and agents. As you can imagine, our fleeing
    enemy could have other events attached to it, such as shooting bullets at the
    player when at a safe distance, taking cover around a corner, and calling for
    help. Adding a series of events to an NPC would require a finite state machine
    to go through each appropriate event.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内容到此结束，希望你现在对使用 NavMesh 和代理的介绍感到舒适。正如你可以想象的那样，我们的逃跑敌人可能还有其他事件与之关联，例如在安全距离向玩家射击子弹、在角落周围躲避，以及呼救。给一个
    NPC 添加一系列事件需要有限状态机来遍历每个适当的事件。
- en: In this section, we introduced a new enemy that acted differently from our current
    wave enemy. We also became familiar with the ready-made path-finding algorithms
    offered by Unity, such as `NavMesh`.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了一个与当前波次敌人行为不同的新敌人。我们还熟悉了 Unity 提供的现成路径查找算法，如 `NavMesh`。
- en: We are going to move on to the next section, where we will introduce the timeline,
    which works as an animator but can also be used with regard to blending the logical
    behavior with our components – for example, to make a light blend into a different
    color by using scripting.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进入下一节，我们将介绍时间轴，它作为一个动画师工作，但也可以与我们的组件结合使用，例如，通过脚本使灯光融合成不同的颜色。
- en: Exploring the timeline
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索时间轴
- en: '**Timeline** is a component in the Unity Editor that is intended to put a sequence
    of animations together, which is attractive to industries such as film and TV.
    **Timeline** is also welcomed in games that may have cutscenes to help tell a
    story or introduce a player to a level. Unity also has two other useful components
    – **Animator Controller** and **Animation** **Clips** – as you will know if you
    have been following this book, as we covered these other components in [*Chapter
    4*](B18381_04_Epub.xhtml#_idTextAnchor087)*, Applying Art, Animation, and Particles*.
    They carry out the same tasks, but as a scene becomes busier with a series of
    individual animation clips, things can get messy quickly in the animator controller,
    with the multiple states transitioning between each other.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间轴**是 Unity 编辑器中的一个组件，旨在将一系列动画组合在一起，这对电影和电视等行业很有吸引力。**时间轴**也受到可能包含场景的游戏的欢迎，以帮助讲述故事或向玩家介绍关卡。Unity
    还有两个其他有用的组件——**动画控制器**和**动画剪辑**——如果你一直在跟随这本书，你应该知道，因为我们已经在 [*第 4 章*](B18381_04_Epub.xhtml#_idTextAnchor087)
    *应用艺术、动画和粒子* 中介绍了这些其他组件。它们执行相同的任务，但随着场景变得越来越繁忙，一系列单独的动画剪辑，动画控制器中可能会变得混乱，多个状态之间相互转换。'
- en: 'The following screenshot shows the animator controller with multiple states
    and transitions:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了具有多个状态和转换的动画控制器：
- en: '![Figure 12.26 – An example of how chaotic Animator Controllers can get'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.26 – 动画控制器可能变得多么混乱的示例'
- en: '](img/Figure_12.26_B18381.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_12.26_B18381.jpg](img/Figure_12.26_B18381.jpg)'
- en: Figure 12.26 – An example of how chaotic Animator Controllers can get
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.26 – 动画控制器可能变得多么混乱的示例
- en: '**Timeline** supports three tasks:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间轴**支持三个任务：'
- en: Playing animations and clips
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放动画和剪辑
- en: Playing audio
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放音频
- en: Turning game objects on or off
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开或关闭游戏对象
- en: These three capabilities on their own limit **Timeline** – for example, if we
    want to change the color of light, **Timeline** wouldn't be able to change the
    individual property alone. To change the color of light, we will need to change
    the light's property values in the **Animation** window itself. However, with
    some extra scripting to our timeline, we can introduce dragging and dropping game
    objects that hold components, such as a light component, where changes can be
    made on the fly.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个功能本身限制了**时间轴**——例如，如果我们想改变光线的颜色，**时间轴**就无法单独改变单个属性。要改变光线的颜色，我们需要在**动画**窗口本身中改变光线的属性值。然而，通过在时间轴上添加一些额外的脚本，我们可以引入拖放带有组件的游戏对象，例如灯光组件，这样就可以在飞行中做出更改。
- en: In this section, we are going to start by animating a large robotic craft in
    the timeline. Then, we will discuss playables and how they can extend a timeline's
    functionality. Finally, we will implement additional tracks to the timeline to
    control the color of the lights and fade the level into darkness once the player
    reaches the end of the level.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先在时间轴中动画化一个大型机器人飞船。然后，我们将讨论可玩性以及它们如何扩展时间轴的功能。最后，我们将向时间轴添加额外的轨道来控制灯光的颜色，并在玩家到达关卡末尾时将关卡淡入黑暗。
- en: Let's start by creating our `Timeline` game object and adding a **Timeline**
    component to it in the next section.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建我们的**时间轴**游戏对象并添加一个**时间轴**组件到它开始。
- en: Creating a timeline
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建时间轴
- en: In this section, we are going to get more familiar with the **Timeline** component
    and create some of our own animations with a large flying robot. When setting
    up the timeline, we will also discuss the components and properties that are involved.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更熟悉**时间轴**组件，并使用一个大型飞行机器人创建一些自己的动画。在设置时间轴时，我们还将讨论涉及的组件和属性。
- en: 'To add a timeline to our scene, do the following:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 要将时间轴添加到场景中，请执行以下操作：
- en: In the Unity Editor's `Assets/Scene`.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器的`Assets/Scene`。
- en: Double-click on `level3` to load the scene if it isn't loaded already.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`level3`以加载场景，如果尚未加载。
- en: Right-click in the **Hierarchy** window and select **Create Empty** from the
    dropdown to create an empty game object.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中右键单击，并从下拉菜单中选择**创建空对象**以创建一个空的游戏对象。
- en: Click on `GameObject` twice slowly to rename it.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 慢慢点击`GameObject`两次以重命名它。
- en: Rename `GameObject` `Timeline`.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`GameObject`重命名为`时间轴`。
- en: With our `Timeline` game object still selected in the **Hierarchy** window,
    we can now open our **Timeline** window.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中仍然选择我们的`时间轴`游戏对象，我们现在可以打开我们的**时间轴**窗口。
- en: 'At the top of the Unity Editor, click on **Window | Sequencing** and then **Timeline**;
    the following screenshot shows this:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器顶部，点击**窗口 | 序列**然后**时间轴**；以下截图显示了这一点：
- en: '![Figure 12.27 – Selecting the ''Timeline'' game object and opening a Timeline
    window'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.27 – 选择 ''时间轴'' 游戏对象并打开时间轴窗口'
- en: '](img/Figure_12.27_B18381.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_12.27_B18381.jpg)'
- en: Figure 12.27 – Selecting the 'Timeline' game object and opening a Timeline window
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.27 – 选择 '时间轴' 游戏对象并打开时间轴窗口
- en: 'It''s likely that the **Timeline** window will appear in the same window layout
    as your scene, which isn''t ideal, as we want to see our **Scene** while animating.
    To move the **Timeline** window to a better place, click on the name of the **Timeline**
    tag and drag it down to the bottom of the screen, where the **Console** and **Project**
    windows are. The following screenshot shows my current Unity Editor layout proportions:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能**时间轴**窗口将出现在与你的场景相同的窗口布局中，这并不理想，因为我们希望在动画时看到我们的**场景**。要将**时间轴**窗口移动到更好的位置，请点击**时间轴**标签的名称并将其拖到屏幕底部，那里有**控制台**和**项目**窗口。以下截图显示了我当前的
    Unity 编辑器布局比例：
- en: '![Figure 12.28 – Window placements in the Unity Editor'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.28 – Unity 编辑器中的窗口布局'
- en: '](img/Figure_12.28_B18381.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_12.28_B18381.jpg)'
- en: Figure 12.28 – Window placements in the Unity Editor
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.28 – Unity 编辑器中的窗口布局
- en: We can now continue to create our `Timeline` asset, where we will be creating
    our new animations for all of our game objects and their components.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续创建我们的**时间轴**资产，其中我们将为所有游戏对象及其组件创建新的动画。
- en: 'To make a playable `Timeline` asset, do the following:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可玩的**时间轴**资产，请执行以下操作：
- en: With the `Timeline` game object still selected in the **Hierarchy** window,
    click on the **Create** button in the **Timeline** window.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中仍然选择`时间轴`游戏对象，点击**时间轴**窗口中的**创建**按钮。
- en: A window browser will appear to let us select where we want to save our playable
    file.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将出现一个窗口浏览器，让我们选择保存可播放文件的位置。
- en: Choose the `Assets` folder.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `Assets` 文件夹。
- en: Give the playable file a name (something relevant to what it's going to be used
    for; I'm naming mine `level3`) and click on the **Save** button.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给可播放文件命名（与它将要被用于的内容相关；我将其命名为 `level3`）并点击 **Save** 按钮。
- en: Our `Timeline` asset has been created.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已创建 `Timeline` 资产。
- en: If you have been following along with this book, at first glance, the **Timeline**
    window will likely look like the **Animation** window we saw in [*Chapter 4*](B18381_04_Epub.xhtml#_idTextAnchor087)*,
    Applying Art, Animation, and Particles*. If so, that's good! A good section of
    the controls and methodology will be familiar to you. One of the main differences
    of **Timeline** is that any of the game objects can be dragged into the **Timeline**
    window without needing to have any kind of hierarchical relationship between them.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直跟随这本书，那么乍一看，**Timeline** 窗口可能会看起来像我们在 [*第 4 章*](B18381_04_Epub.xhtml#_idTextAnchor087)“应用艺术、动画和粒子”中看到的
    **Animation** 窗口。如果是这样，那就很好！控制部分和方法的一部分将对你来说很熟悉。**Timeline** 的主要区别之一是，任何游戏对象都可以拖放到
    **Timeline** 窗口中，而无需它们之间有任何层次关系。
- en: 'The following screenshot shows our **Timeline** window holding the **Timeline**
    game object in its first **Timeline** track:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的 **Timeline** 窗口，其中包含在第一个 **Timeline** 轨道中的 **Timeline** 游戏对象：
- en: '![Figure 12.29 – The Timeline window'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.29 – 时间线窗口'
- en: '](img/Figure_12.29_B18381.jpg)'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.29_B18381.jpg)'
- en: Figure 12.29 – The Timeline window
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.29 – 时间线窗口
- en: 'Also, in the **Inspector** window, our **Timeline** game object has gained
    some extra components. The following screenshot shows two of the added components
    – **Playable Director** and **Animator**:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 **Inspector** 窗口中，我们的 **Timeline** 游戏对象增加了一些额外的组件。以下截图显示了添加的两个组件 – **Playable
    Director** 和 **Animator**：
- en: '![Figure 12.30 – The ''Timeline'' game object holding the Playable Director
    and Animator components in the Inspector window'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.30 – 在检查器窗口中持有 Playable Director 和 Animator 组件的 ''Timeline'' 游戏对象'
- en: '](img/Figure_12.30_B18381.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.30_B18381.jpg)'
- en: Figure 12.30 – The 'Timeline' game object holding the Playable Director and
    Animator components in the Inspector window
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.30 – 在检查器窗口中持有 Playable Director 和 Animator 组件的 'Timeline' 游戏对象
- en: We worked with the **Animator** component in [*Chapter 4*](B18381_04_Epub.xhtml#_idTextAnchor087)*,
    Applying Art, Animation, and Particles*, so for more details about this particular
    component, refer back to that chapter. Also, we don't actually do anything with
    the **Animator** component; it's just a required component for our **Timeline**
    setup.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [*第 4 章*](B18381_04_Epub.xhtml#_idTextAnchor087)“应用艺术、动画和粒子”中使用了 **Animator**
    组件，因此有关此特定组件的更多详细信息，请参阅该章节。此外，我们实际上并没有对 **Animator** 组件做任何事情；它只是我们 **Timeline**
    设置中所需的一个组件。
- en: The other component we gain when creating a `Timeline` asset file is **Playable
    Director**. It's the responsibility of this component to keep a relationship between
    the timeline and the game objects/components that are being manipulated. So, let's
    go through each of the properties under the **Playable Director** component to
    briefly get a general understanding of them.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 创建时间线资产文件时，我们获得的另一个组件是 **Playable Director**。该组件的职责是保持时间线与正在操作的游戏对象/组件之间的关系。因此，让我们简要了解
    **Playable Director** 组件下的每个属性，以获得一般了解。
- en: First, we have **Playable**. When we click on the **Create** button in the **Timeline**
    window, we create a **Playable** file. This file holds all of the animations and
    game object/component instances relating to the timeline.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有 **Playable**。当我们点击 **Timeline** 窗口中的 **Create** 按钮时，我们创建一个 **Playable**
    文件。此文件包含与时间线相关的所有动画和游戏对象/组件实例。
- en: 'Then, we have **Update Method**. This parameter offers four properties that
    control how time affects the timeline. These properties are as follows:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有 **Update Method**。此参数提供了四个属性，用于控制时间如何影响时间线。这些属性如下：
- en: '**Digital Signal Processing** (**DSP**) helps to improve accuracy between our
    timeline and its audio to prevent it from going out of sync.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字信号处理** (**DSP**) 有助于提高时间线与音频之间的准确性，以防止它们不同步。'
- en: '**Game Time**: The time for the timeline will be sourced from the game''s time.
    This also means the time can be scaled (that is, slowed down or paused).'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏时间**：时间线的来源将是游戏的时间。这也意味着时间可以进行缩放（即减速或暂停）。'
- en: '**Unscaled Game Time**: This option works the same as the **Game Time** property,
    but it is not affected by scaling.'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未缩放的游戏时间**：此选项与**游戏时间**属性的工作方式相同，但它不受缩放的影响。'
- en: '**Manual**: This property uses the clock time we give it through scripting.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手动**：此属性使用我们通过脚本提供的时钟时间。'
- en: Next, we have **Play On Awake**. If this checkbox is ticked, our timeline will
    play as soon as the scene is active.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有**在唤醒时播放**。如果这个复选框被勾选，我们的时间轴将在场景激活时立即播放。
- en: 'The next parameter is **Wrap Mode**. This property determines what happens
    when the timeline has finished playing:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个参数是**循环模式**。此属性确定时间轴播放完毕后会发生什么：
- en: '**Hold**: When the timeline reaches the end, it holds on to the last frame.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持**：当时间轴到达末尾时，它会停留在最后一帧。'
- en: '**Loop**: The timeline repeats.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环**：时间轴重复。'
- en: '**None**: The timeline plays and then resets.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无**：时间轴播放后重置。'
- en: '**Initial Time** adds a delay in seconds before the timeline begins.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始时间**在时间轴开始之前添加延迟（以秒为单位）。'
- en: Finally, we have **Bindings**. When a game object or component is dragged into
    the **Timeline** window, the **Bindings** list will update and show what object
    is connected to the timeline.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有**绑定**。当一个游戏对象或组件被拖入**时间轴**窗口时，**绑定**列表将更新并显示连接到时间轴的对象。
- en: So far, we have discussed the timeline and introduced it to our scene. We have
    also gone through the components that are required to make the timeline work.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了时间轴并将其引入到我们的场景中。我们还介绍了使时间轴工作所需的组件。
- en: Now that we are more familiar with the timeline and the components that work
    in conjunction with it, in the next subsections, we are going to incorporate our
    large boss ship into our `level3` scene and animate it through the timeline.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对时间轴及其协同工作的组件更加熟悉，在接下来的小节中，我们将把我们的大型Boss飞船整合到`level3`场景中，并通过时间轴对其进行动画处理。
- en: Setting up the boss game object in our scene
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在场景中设置Boss游戏对象
- en: In this section, we are going to take a static UFO-looking game object from
    our imported project files, drop it into the scene, and attach it to the timeline.
    From there, we will animate our UFO so that it spins and moves across the scene
    on two occasions.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从导入的项目文件中取出一个静态的类似UFO的游戏对象，将其拖入场景，并将其附加到时间轴上。从那里，我们将对UFO进行动画处理，使其在两个场合旋转并在场景中移动。
- en: 'To bring the large boss `UFO` game object into our scene before animating it,
    we need to do the following:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 要在动画之前将大型Boss `UFO` 游戏对象引入我们的场景，我们需要做以下操作：
- en: Drag and drop the `boss.prefab` object from `Assets/Prefab/Enemies` into the
    `_Enemies` game object in the **Hierarchy** window.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Assets/Prefab/Enemies`中的`boss.prefab`对象拖放到**层次结构**窗口中的`_Enemies`游戏对象。
- en: Next, we need to position the boss so that it's in our scene but out of view
    of the camera. That way, when it comes to animating the boss in the timeline,
    we can change its position and rotation when required.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定位Boss，使其在我们的场景中但不在摄像机的视野中。这样，当在时间轴中动画Boss时，我们可以根据需要更改其位置和旋转。
- en: Select the `boss` game object in the `0`, `0`, and `-2000`
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`0`，`0`，和`-2000`处选择`boss`游戏对象
- en: '`0`, `0`, and `0`'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`0`，`0`，和`0`'
- en: '`1`, `1`, and `1`'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`1`，`1`，和`1`'
- en: With the `boss` object still selected in the **Hierarchy** window, press *F*
    on your keyboard to see what it looks like in the **Scene** window.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中仍然选择`boss`对象时，按键盘上的*F*键，以查看它在**场景**窗口中的样子。
- en: 'The following screenshot shows the imported `boss` prefab, which contains a
    list of components and property values:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了导入的`boss`预制件，其中包含组件列表和属性值：
- en: '![Figure 12.31 – The ''boss'' game object tagged as ''Enemy'', positioned with
    the Transform component, and finally, set as a trigger with a scaled radius in
    Sphere Collider'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.31 – 标记为''Enemy''的''boss''游戏对象，使用变换组件定位，最后设置为具有缩放半径的触发器]'
- en: '](img/Figure_12.31_B18381.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_12.31_B18381.jpg]'
- en: Figure 12.31 – The 'boss' game object tagged as 'Enemy', positioned with the
    Transform component, and finally, set as a trigger with a scaled radius in Sphere
    Collider
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.31 – 标记为'Enemy'的'boss'游戏对象，使用变换组件定位，最后设置为具有缩放半径的触发器
- en: 'The `boss` object holds the following component and property values, as shown
    in the previous screenshot:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，`boss`对象包含以下组件和属性值：
- en: Tagged as **Enemy** (denoted by **1.**).
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记为**Enemy**（用**1**表示）。
- en: The **Transform** property values are set to the ones detailed under *step 2*
    (denoted by **2.**).
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变换**属性值设置为*步骤2*（用**2**表示）中详细说明的值。'
- en: '`80` (denoted by **3.**).'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`80`（用**3**表示）。'
- en: '`BossScript` makes the `boss` game object invincible to the player, and if
    the player makes contact with the boss, the player will die (denoted by **4.**).'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BossScript`使`boss`游戏对象对玩家不可见，如果玩家与boss接触，玩家将死亡（用**4.**表示）。'
- en: Because the `boss` object is an enemy, it has a `radarPoint` object that is
    picked up on the radar (denoted by **5.**).
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为`boss`对象是一个敌人，它有一个在雷达上被拾取的`radarPoint`对象（用**5.**表示）。
- en: 'Before we move on to the next section, we need to add a `RadarRotation` script
    to the `radarPoint` game object, which is a child of the `boss` game object. This
    script will make `radarPoint` always face the camera:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一节之前，我们需要将一个`RadarRotation`脚本添加到`radarPoint`游戏对象中，该对象是`boss`游戏对象的子对象。这个脚本将使`radarPoint`始终面向摄像机：
- en: Expand the `boss` content in the **Hierarchy** window.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中展开`boss`内容。
- en: Select `radarPoint`, and then drag and drop the `RadarRotation` script from
    `Assets/Script`, moving it from the **Project** window to the **Inspector** window.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`radarPoint`，然后从`Assets/Script`拖动并放下`RadarRotation`脚本，将其从**项目**窗口移动到**检查器**窗口。
- en: Finally, select the `boss` game object in the `BossScript` from `Assets/Script`
    into the **Inspector** window.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从`Assets/Script`将`BossScript`中的`boss`游戏对象拖入**检查器**窗口。
- en: Now that the `boss` object is in the scene, we can add it to the timeline in
    the next section.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`boss`对象已经在场景中，我们可以在下一节中将其添加到时间轴中。
- en: Preparing the boss for the timeline
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为时间轴准备boss
- en: In this section, we are going to take the `boss` game object from our `boss`
    object greet the player at the end of the level before jetting off after the player.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从`boss`对象中取出`boss`游戏对象，在玩家到达关卡末尾并离开之前向玩家打招呼。
- en: Further sections will continue to make use of the timeline, including using
    specialized `boss` object animated.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 后续章节将继续使用时间轴，包括使用专门的`boss`对象动画。
- en: 'To animate the `boss` object in the timeline, do the following:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 要在时间轴上动画化`boss`对象，请执行以下操作：
- en: Select the `Timeline` game object, and in the **Inspector** window, untick **Play
    On Awake**, as we will be triggering the **Timeline** animation ourselves.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Timeline`游戏对象，并在**检查器**窗口中取消勾选**在唤醒时播放**，因为我们自己将触发**Timeline**动画。
- en: To trigger the `BossTrigger` game object, which we mentioned at the beginning
    of this chapter.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 要触发我们在本章开头提到的`BossTrigger`游戏对象。
- en: 'To have the main camera recognized as a trigger, we need to do the following:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 要使主摄像机被识别为触发器，我们需要执行以下操作：
- en: Select the main camera in the **Hierarchy** window.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择主摄像机。
- en: Click on the **Add Component** button in the **Inspector** window.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**检查器**窗口中的**添加组件**按钮。
- en: Type in `Box Collider`, and when you see it in the drop-down list, select it.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`Box Collider`，当你在下拉列表中看到它时，选择它。
- en: Tick the **Is Trigger** box under the **Box Collider** component.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Box Collider**组件下勾选**是触发器**框。
- en: 'Let''s now continue setting up our `boss` game object into it:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在继续设置我们的`boss`游戏对象：
- en: Select the **Timeline** tab, which, as you will know if you have been following
    along with the previous sections, is found at the bottom of the Unity Editor
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Timeline**选项卡，如果您一直跟随前面的章节，您会知道它位于Unity编辑器的底部
- en: The `Timeline` game object and the `Timeline` game object from the **Timeline**
    window because we aren't going to animate it.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '`Timeline`游戏对象和从**Timeline**窗口中的`Timeline`游戏对象，因为我们不会对它进行动画化。'
- en: Right-click on the `Timeline` object in the **Timeline** window and select **Delete**
    from the dropdown.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Timeline**窗口中右键单击`Timeline`对象，并从下拉菜单中选择**删除**。
- en: 'The following screenshot shows the `Timeline` game object being deleted:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了正在删除的`Timeline`游戏对象：
- en: '![Figure 12.32 – Deleting the ''Timeline'' game object from the Timeline window'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.32 – Deleting the ''Timeline'' game object from the Timeline window'
- en: '](img/Figure_12.32_B18381.png)'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.32_B18381.png)'
- en: Figure 12.32 – Deleting the 'Timeline' game object from the Timeline window
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.32 – 从时间轴窗口中删除'Timeline'游戏对象
- en: With the `Timeline` game object still selected in the `boss` game object from
    the **Hierarchy** window down into the **Timeline** window.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中仍然选择`boss`游戏对象，并将其从**Timeline**窗口向下拖入。
- en: 'A dropdown will appear with a choice of three selections:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 将出现一个下拉菜单，有三个选择项：
- en: '**Activation Track**: Turns a game object on or off'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**激活轨道**：打开或关闭游戏对象'
- en: '**Animation Track**: Animates the game object'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画轨道**：动画化游戏对象'
- en: '**Audio Track**: Sets particular audio on or off'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音频轨道**：打开或关闭特定的音频'
- en: Because we want to animate our `boss` game object, we will choose **Animation
    Track**.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们想要对`boss`游戏对象进行动画处理，所以我们将选择**动画轨道**。
- en: We will now have the `boss` game object in our `boss` game object will gain
    an **Animator** component in the **Inspector** window.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`boss`游戏对象将在**检查器**窗口中获得一个**动画器**组件。
- en: 'The following screenshot shows what our timeline currently looks like:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的时间轴当前的外观：
- en: '![Figure 12.33 – Timeline holding the ''boss'' game object'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.33 – 持有‘boss’游戏对象的时间轴'
- en: '](img/Figure_12.33_B18381.jpg)'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.33_B18381.jpg)'
- en: Figure 12.33 – Timeline holding the 'boss' game object
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.33 – 持有‘boss’游戏对象的时间轴
- en: 'Next, we will start adding keyframes to our **Timeline** window, which will
    affect our boss''s position and rotation. Let''s start by locking our **Timeline**
    window so that when we click on another game object, it will remain active:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始在**时间轴**窗口中添加关键帧，这将影响我们的boss对象的位置和旋转。让我们首先锁定我们的**时间轴**窗口，这样当我们点击另一个游戏对象时，它将保持活动状态：
- en: Select the `Timeline` game object in the **Hierarchy** window.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择`Timeline`游戏对象。
- en: Select the **Timeline** window tab.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**时间轴**窗口标签。
- en: Click on the padlock button at the top-right corner of the **Timeline** window.
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**时间轴**窗口右上角的小锁按钮。
- en: 'The padlock button is highlighted in the following screenshot:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图突出显示了小锁按钮：
- en: '![Figure 12.34 – Locking the Timeline window'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.34 – 锁定时间轴窗口'
- en: '](img/Figure_12.34_B18381.jpg)'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.34_B18381.jpg)'
- en: Figure 12.34 – Locking the Timeline window
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.34 – 锁定时间轴窗口
- en: Let's now move on to the next section, where we will start adding keyframes
    to the timeline and make our `boss` game object move and rotate in two phases
    of the third level. Let's start with phase one.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续下一节，我们将开始在时间轴中添加关键帧，并使我们的`boss`游戏对象在第三级的两个阶段中移动和旋转。让我们从第一阶段开始。
- en: Animating the boss in the timeline – phase one
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在时间轴中动画化boss – 第一阶段
- en: In this section, we will be adding keyframes to the `boss` game object. This
    will make the `boss` game object travel from one point to another while rotating
    on its center pivot.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为`boss`游戏对象添加关键帧。这将使`boss`游戏对象在其中心轴上旋转的同时从一个点到另一个点移动。
- en: 'To start adding keyframes for the `boss` game object, do the following:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 要为`boss`游戏对象添加关键帧，请执行以下操作：
- en: With the `boss` game object.
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与`boss`游戏对象一起。
- en: We will now start recording our boss's position and rotation.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将开始记录boss的位置和旋转。
- en: In the `boss` game object name; the button should begin to flash.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`boss`游戏对象名称中；按钮应该开始闪烁。
- en: 'Make sure that the `0`, as shown in the following screenshot:'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保如以下截图所示的`0`：
- en: '![Figure 12.35 – The Timeline frame set to zero'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.35 – 时间轴帧设置为零'
- en: '](img/Figure_12.35_B18381.jpg)'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.35_B18381.jpg)'
- en: Figure 12.35 – The Timeline frame set to zero
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.35 – 时间轴帧设置为零
- en: In the `1675`, `0`, and `600`
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`1675`、`0`和`600`
- en: '`60`, `-90`, and `0`'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`60`、`-90`和`0`'
- en: '![Figure 12.36 – The ''boss'' game object''s current location in our level
    3 scene'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.36 – ‘boss’游戏对象在我们3级场景中的当前位置'
- en: '](img/Figure_12.36_B18381.jpg)'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.36_B18381.jpg)'
- en: Figure 12.36 – The 'boss' game object's current location in our level 3 scene
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.36 – ‘boss’游戏对象在我们3级场景中的当前位置
- en: 'Now, to animate the `boss` object from one end of the corridor to the other,
    we need to add another keyframe for the boss. Follow these steps:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使`boss`对象从走廊的一端移动到另一端，我们需要为`boss`添加另一个关键帧。按照以下步骤操作：
- en: With the record button still flashing in the `112` or change the value of the
    `112`.
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当录音按钮仍然闪烁在`112`或更改`112`的值。
- en: Select the `boss` game object in the `3160`, `0`, and `600`
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`3160`、`0`和`600`中选择`boss`游戏对象
- en: '`60`, `-90`, and `20`'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`60`、`-90`和`20`'
- en: Further Information
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 进一步信息
- en: The **Timeline** and **Animation** windows have the same navigation rules with
    regard to zooming and panning in either window. Holding down the middle mouse
    button and moving the mouse will pan. Rolling the middle mouse wheel up or down
    zooms in and out. Hovering the mouse cursor over the animation bar and pressing
    *F* on the keyboard shows all the keyframes on the window.
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**时间轴**和**动画**窗口在缩放和滚动方面遵循相同的导航规则。按住鼠标中键并移动鼠标可以进行滚动。通过上下滚动鼠标中键可以放大或缩小。将鼠标光标悬停在动画条上并按键盘上的*F*键，可以在窗口中显示所有关键帧。'
- en: Click on the record button next to the `boss` game object in the **Timeline**
    window to stop recording.
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**时间轴**窗口中`boss`游戏对象旁边的录音按钮以停止录音。
- en: Click and scrub (`boss` game object move from left to right while rotating.
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并拖动（`boss`游戏对象从左到右移动并旋转）。
- en: 'The following screenshot shows a bird''s-eye view of the `boss` game object
    moving from left to right:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`boss`游戏对象从左向右移动的鸟瞰图：
- en: '![Figure 12.37 – The ''boss'' game object will move from left to right'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.37 – ''boss''游戏对象将从左向右移动'
- en: '](img/Figure_12.37_B18381.jpg)'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_12.37_B18381.jpg)'
- en: Figure 12.37 – The 'boss' game object will move from left to right
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.37 – 'boss'游戏对象将从左向右移动
- en: Later on, when we play the third level, we will see a moment where the `boss`
    game object rushes past the player in the distance. For now, we will continue
    by adding more keyframes to our **Timeline** window before moving on to looking
    at playables.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 在稍后，当我们玩第三级时，我们将看到`boss`游戏对象从远处冲过玩家的那一刻。现在，我们将在查看可玩性之前，继续在我们的**时间轴**窗口中添加更多关键帧。
- en: Let's move on to phase two of animating our `boss` game object.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行动画化我们的`boss`游戏对象的第二阶段。
- en: Animating the boss in the timeline – phase two
  id: totrans-517
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在时间轴中动画化老板 – 第二阶段
- en: In this section, we are going to animate our boss for a second time before the
    level ends as some form of resolution for the ending of this third and final level.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在关卡结束时对老板进行第二次动画，作为对第三个和最后一个关卡结束的一种形式的解决。
- en: We are going to continue from the same **Timeline** track that we started in
    the previous section.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续从上一节开始的同**时间轴**轨道进行。
- en: 'So, let''s continue animating our boss from where we left off:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从我们离开的地方继续动画化我们的老板：
- en: Keep the **Timeline** window padlocked to stop the window from losing its display.
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持**时间轴**窗口锁定，以防止窗口丢失其显示。
- en: Select the `boss` object from the **Hierarchy** window.
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**窗口中选择`boss`对象。
- en: Press the record button next to the `boss` object's name in the **Timeline**
    window so that the button flashes.
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**时间轴**窗口中，按住`boss`对象名称旁边的记录按钮，使其闪烁。
- en: Enter `1012` into the **Frame** parameter.
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**帧**参数中输入`1012`。
- en: 'With the `boss` object still selected in the `boss` object''s position and
    rotation values to the following:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 在`boss`对象的位置和旋转值仍然被选中时，将其移动到以下：
- en: '`4545`, `0`, and `600`'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4545`、`0`和`600`'
- en: '`60`, `-90`, and `0`'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`60`、`-90`和`0`'
- en: 'The following screenshot shows where our boss sits in phase two:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的老板在第二阶段的位置：
- en: '![Figure 12.38 – The ''boss'' game object positions'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.38 – ''boss''游戏对象的位置'
- en: '](img/Figure_12.38_B18381.jpg)'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_12.38_B18381.jpg)'
- en: Figure 12.38 – The 'boss' game object positions
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.38 – 'boss'游戏对象的位置
- en: With the record button still flashing, move to frame `1180` in the `boss` game
    object to the following `6390`, `0`, and `600`
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在记录按钮仍然闪烁的情况下，将帧移动到`boss`游戏对象的`1180`帧，到以下`6390`、`0`和`600`。
- en: '`60`, `-90`, and `20`'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`60`、`-90`和`20`'
- en: Now, move to frame `1193` in the `boss` game object to the following `6390`,
    `0`, and `207`
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`boss`游戏对象的帧移动到`1193`，到以下`6390`、`0`和`207`。
- en: '`60`, `450`, and `0`'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`60`、`450`和`0`'
- en: Now, move to frame `1215` in the `boss` game object to the following `5520`,
    `0`, and `50`
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`boss`游戏对象的帧移动到`1215`，到以下`5520`、`0`和`50`。
- en: '`60`, `90`, and `-40`'
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`60`、`90`和`-40`'
- en: Now, move to frame `1380` in the `boss` game object to the following `5510`,
    `0`, and `50`
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`boss`游戏对象的帧移动到`1380`，到以下`5510`、`0`和`50`。
- en: '`60`, `90`, and `0`'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`60`、`90`和`0`'
- en: Now, move to frame `1400` in the `boss` game object to the following `5510`,
    `0`, and `50`
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`boss`游戏对象的帧移动到`1400`，到以下`5510`、`0`和`50`。
- en: '`60`, `-70`, and `-40`'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`60`、`-70`和`-40`'
- en: Now, move to frame `1420` in the `boss` game object to the following `7540`,
    `0`, and `50`
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`boss`游戏对象的帧移动到`1420`，到以下`7540`、`0`和`50`。
- en: '`60`, `-70`, and `0`'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`60`、`-70`和`0`'
- en: Press the `boss` game object in the **Timeline** window to stop recording.
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**时间轴**窗口中按`boss`游戏对象停止录制。
- en: 'The following screenshot shows a bird''s-eye view of each of these positions
    with their **Timeline** frame numbers:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了每个这些位置及其**时间轴**帧编号的鸟瞰图：
- en: '![Figure 12.39 – The Timeline frame numbers of where the ''boss'' game object
    will be'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.39 – ''boss''游戏对象将出现的位置的时间轴帧编号'
- en: '](img/Figure_12.39_B18381.jpg)'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_12.39_B18381.jpg)'
- en: Figure 12.39 – The Timeline frame numbers of where the 'boss' game object will
    be
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.39 – 'boss'游戏对象将出现的位置的时间轴帧编号
- en: If you want to adjust the `boss` game object rotation more, it is recommended
    to have **boss** selected in the **Hierarchy** window. Make sure the local position
    is selected (denoted by **1** in the following screenshot) and, with the Timeline
    still in record mode, rotate the *z* axes several times (denoted by **2**).
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想调整 `boss` 游戏对象的旋转，建议在 **Hierarchy** 窗口中选中 **boss**。确保选中了本地位置（以下截图中的 **1**
    所示），并且，在时间轴仍然处于录制模式时，旋转 *z* 轴几次（以下截图中的 **2** 所示）。
- en: '![Figure 12.40 – Rotating the ''boss'' game object'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.40 – 旋转 ''boss'' 游戏对象'
- en: '](img/Figure_12.40_B18381.jpg)'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.40_B18381.jpg)'
- en: Figure 12.40 – Rotating the 'boss' game object
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.40 – 旋转 'boss' 游戏对象
- en: Finally, scrub backward and forward (move the **Timeline** indicator) in **Timeline**
    to see the result you are given.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 **Timeline** 中前后滚动（移动 **Timeline** 指示器）以查看您得到的结果。
- en: When you are happy, stop recording.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 当您感到高兴时，停止录制。
- en: As you can see in the previous screenshot, the `boss` game object flies in from
    the left to the right toward where the player will be. The boss will stop rotating,
    pause, turn around, and zip off to the far right.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的截图中所见，`boss` 游戏对象从左向右飞来，朝向玩家所在的位置。`boss` 将停止旋转，暂停，转身，然后飞向最右边。
- en: Let's press `level3` scene so far, with the boss versus our player's ship throughout
    the `level3` scene.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按下 `level3` 场景，直到 `boss` 与玩家飞船在整个 `level3` 场景中对抗。
- en: The player moves through the level, and the boss animation is seen on two occasions.
    What we do see that we likely shouldn't is the large yellow dot of the boss even
    when the boss has moved on. It would be good if we could make the boss disappear
    off the radar when we can't see the game object itself.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家穿过关卡，`boss` 动画出现在两次。我们可能看到的是，即使 `boss` 已经移动，`boss` 的那个大黄色点仍然存在。如果我们能在看不到游戏对象本身时让
    `boss` 从雷达上消失，那就更好了。
- en: 'The following screenshot shows the `boss` object on the left screen, which
    is not visible on the right screen but still detected on the radar:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了左屏幕上的 `boss` 对象，它在右屏幕上不可见，但仍然被雷达检测到：
- en: '![Figure 12.41 – The ''boss'' game object''s radar is still detecting the boss'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.41 – ''boss'' 游戏对象的雷达仍在检测 ''boss'''
- en: '](img/Figure_12.41_B18381.jpg)'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.41_B18381.jpg)'
- en: Figure 12.41 – The 'boss' game object's radar is still detecting the boss
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.41 – 'boss' 游戏对象的雷达仍在检测 'boss'
- en: 'Let''s make use of the timeline before ending this section to simply turn the
    `radarPoint` game object off and then on when we see the `boss` game object. Follow
    these steps:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本节之前，让我们利用时间轴来简单地关闭 `radarPoint` 游戏对象，并在我们看到 `boss` 游戏对象时重新打开它。按照以下步骤操作：
- en: Select the `Timeline` game object from the **Hierarchy** window.
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Hierarchy** 窗口中选择 `Timeline` 游戏对象。
- en: Select the `Timeline` tab to see the `boss` animation.
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `Timeline` 选项卡以查看 `boss` 动画。
- en: Click and drag the boss's `radarPoint` object from the **Hierarchy** window
    into the **Timeline** window.
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Hierarchy** 窗口中将 `boss` 的 `radarPoint` 对象拖动到 **Timeline** 窗口中。
- en: The **Timeline** dropdown appears. This time, select **Activation Track**.
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Timeline** 下拉菜单出现。这次，选择 **Activation Track**。'
- en: Our `radarPoint` track.
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `radarPoint` 轨迹。
- en: 'Let''s now add an activation clip to decide when the player should and shouldn''t
    see the `radarPoint` object. Follow these steps:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加一个激活剪辑来决定玩家何时应该看到以及何时不应该看到 `radarPoint` 对象。按照以下步骤操作：
- en: 'Right-click on the track of the `radarPoint` object and select **Add Activation
    Clip**, as shown in the following screenshot:'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `radarPoint` 对象的轨道，并选择 **Add Activation Clip**，如下面的截图所示：
- en: '![Figure 12.42 – In the Timeline window, add an activation clip for our ''radarPoint''
    game object'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.42 – 在时间轴窗口中，为我们的 ''radarPoint'' 游戏对象添加一个激活剪辑'
- en: '](img/Figure_12.42_B18381.jpg)'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.42_B18381.jpg)'
- en: Figure 12.42 – In the Timeline window, add an activation clip for our 'radarPoint'
    game object
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.42 – 在时间轴窗口中，为我们的 'radarPoint' 游戏对象添加一个激活剪辑
- en: An `boss` game object to be active on two occasions – once when the boss moves
    past the player in the open-space area of the environment, and once at the end
    when the boss approaches the player head-on.
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个 `boss` 游戏对象在两次出现时应该是活跃的——一次是在 `boss` 穿过环境中的开放空间区域时，另一次是在结束时 `boss` 正面接近玩家时。
- en: 'For the first occasion, we need to set the `35` and `95` on the timeline. We
    can do this by clicking and dragging its bar down to the `95` mark, as shown in
    the following screenshot:'
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第一次出现，我们需要在时间轴上设置 `35` 和 `95`。我们可以通过点击并拖动其条形到 `95` 标记来完成此操作，如下面的截图所示：
- en: '![Figure 12.43 – Setting the activity of the ''radarPoint'' game object between
    set frames'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.43 – 在设置帧之间设置 ''radarPoint'' 游戏对象的活动'
- en: '](img/Figure_12.43_B18381.jpg)'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_12.43_B18381.jpg)'
- en: Figure 12.43 – Setting the activity of the 'radarPoint' game object between
    set frames
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.43 – 在设置帧之间设置'radarPoint'游戏对象的活动
- en: For the second occasion, we can set the `boss` object from around `1020` to
    `1420`.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次操作中，我们可以将`boss`对象从大约`1020`设置为`1420`。
- en: 'Repeat this process by doing the following:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤重复此过程：
- en: Right-click and create an activation clip on the `radarPoint` track.
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击并在`radarPoint`轨道上创建一个激活剪辑。
- en: Scale the **Active** bar between the two **Timeline** points.
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整两个**时间轴**点之间的**活动**条。
- en: Save the scene.
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景。
- en: We have now set the settings so that the `boss` game object and its `radarPoint`
    object are active at the same time.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已设置设置，使`boss`游戏对象及其`radarPoint`对象同时处于活动状态。
- en: We have successfully introduced a timeline to our scene and customized it so
    that it accommodates a new game object that needs to be animated throughout the
    third and final level of our game. In the next section, we are going to look further
    into extending the features of the timeline by introducing animating lights.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地将时间轴引入到场景中，并对其进行定制，使其能够容纳在整个游戏的第三级和最终级中需要动画化的新游戏对象。在下一节中，我们将进一步探讨通过引入动画灯光来扩展时间轴的功能。
- en: Extending the timeline
  id: totrans-585
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展时间轴
- en: 'In this section, we are going to add more functionality to the timeline by
    increasing its standard track selection, as shown in the following screenshot:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过增加标准轨道选择来为时间轴添加更多功能，如下截图所示：
- en: '![Figure 12.44 – Expanding the functionality of our Timeline will be done next'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.44 – 下一步将扩展我们时间轴的功能'
- en: '](img/Figure_12.44_B18381.jpg)'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_12.44_B18381.jpg)'
- en: Figure 12.44 – Expanding the functionality of our Timeline will be done next
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.44 – 下一步将扩展我们时间轴的功能
- en: From this new extended track selection list, as shown in the previous screenshot,
    we will make use of **Light Control Track**.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一张截图所示的新扩展轨道选择列表中，我们将使用**灯光控制轨道**。
- en: It is possible to see a bigger selection from the drop-down list; this, however,
    is beyond the scope of this book. However, if you are interested, I will direct
    you to what to read to find out how to extend the list later on in this section.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从下拉列表中看到更大的选择；然而，这超出了本书的范围。但是，如果您感兴趣，我将在本节稍后指导您如何扩展列表。
- en: In the next few sections, we will increase our tracklist with the aid of the
    Asset Store and download a free asset from Unity to increase our **Timeline**
    functionality. Then, we will animate the lights in our scene, which wouldn't have
    been possible before.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将借助资产商店增加我们的轨道列表，并从Unity下载一个免费资产来增加我们的**时间轴**功能。然后，我们将对场景中的灯光进行动画处理，这在之前是不可能的。
- en: Adding Default Playables to the project
  id: totrans-593
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将默认可播放内容添加到项目中
- en: In this section, we will take a shortcut in scripting to extend the timeline's
    functionality by going to the Unity Asset Store and downloading a free package
    called **Default Playables**. We will discuss the main features of playables and
    what they entail, but it is too lengthy to discuss it as a scripting approach.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过访问Unity资产商店并下载一个名为**默认可播放内容**的免费包来简化脚本编写，以扩展时间轴的功能。我们将讨论可播放内容的主要功能和它们包含的内容，但这太长了，不能作为脚本方法来讨论。
- en: 'Playables organize, mix, and blend data through a playable graph to create
    a single output. To download and import **Default Playables** to our list, do
    the following:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 可播放内容通过可播放图来组织、混合和融合数据，以创建单个输出。要下载并导入**默认可播放内容**到我们的列表中，请执行以下操作：
- en: 'Open your web browser and go to the Unity Asset Store: [https://assetstore.unity.com/](https://assetstore.unity.com/).'
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的网络浏览器并转到Unity资产商店：[https://assetstore.unity.com/](https://assetstore.unity.com/)。
- en: At the top of the `default playables` and press *Enter* on your keyboard.
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`default playables`的顶部按下键盘上的*Enter*键。
- en: Select the only selection from the thumbnail list – **Default Playables**.
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从缩略图列表中选择唯一选项 – **默认可播放内容**。
- en: On the **Default Playables** shop screen, click on the **Download** button.
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**默认可播放内容**商店屏幕上，点击**下载**按钮。
- en: 'Once downloaded, we can now import the asset into our project by clicking on
    the **Add to My Assets** button, as shown in the following screenshot:'
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完成后，我们可以通过点击以下截图所示的**添加到我的资产**按钮，将资产导入到我们的项目中：
- en: '![Figure 12.45 – Downloading and importing the free Default Playables package
    into our project from the Asset Store'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.45 – 从资产商店下载并导入免费默认可播放包到我们的项目中'
- en: '](img/Figure_12.45_B18381.jpg)'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_12.45_B18381.jpg)'
- en: Figure 12.45 – Downloading and importing the free Default Playables package
    into our project from the Asset Store
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.45 – 从Asset Store将免费的默认可播放文件包导入到我们的项目中
- en: '**Default Playables** can now be downloaded from your Unity project via **Package
    Manager**.'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '**默认可播放文件**现在可以通过**包管理器**从您的Unity项目中下载。'
- en: '**Package Manager** gives us access to assets we''ve downloaded from the **Asset
    Store** and also other "packages" we can add to our project. We will talk about
    **Package Manager** more in the next chapter.'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '**包管理器**为我们提供了访问从**Asset Store**下载的资产以及我们可以添加到项目中的其他“包”。我们将在下一章中详细介绍**包管理器**。'
- en: 'To download **Default Playables** into our project, we need to do the following:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 要将**默认可播放文件**下载到我们的项目中，我们需要执行以下操作：
- en: In the Unity Editor, click **Window**, followed by **Package Manager**.
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器中，点击**窗口**，然后选择**包管理器**。
- en: '**Package Manager** will load in a new window. At the top-left corner of the
    window, select **Packages:**, followed by **My Assets** from the dropdown, as
    shown in the following screenshot:'
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**包管理器**将在新窗口中加载。在窗口的左上角，选择**包**，然后从下拉菜单中选择**我的资产**，如图下截图所示：'
- en: '![Figure 12.46 – Selecting "My Assets" from the dropdown in the Package Manager
    window'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.46 – 在包管理器窗口的下拉菜单中选择“我的资产”'
- en: '](img/Figure_12.46_B18381.jpg)'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.46_B18381.jpg)'
- en: Figure 12.46 – Selecting "My Assets" from the dropdown in the Package Manager
    window
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.46 – 在包管理器窗口的下拉菜单中选择“我的资产”
- en: We will now be presented with the assets we own from the Asset Store.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看到从Asset Store拥有的资产。
- en: 'At the top-right corner of `default playable` to shorten the list on the left
    side, as shown in the following screenshot:'
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`default playable`的右上角以缩短左侧的列表，如图下截图所示：
- en: '![Figure 12.47 – The Package Manager search bar highlighted at the top-right
    corner'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.47 – 在包管理器窗口右上角突出显示的搜索栏'
- en: '](img/Figure_12.47_B18381.jpg)'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.47_B18381.jpg)'
- en: Figure 12.47 – The Package Manager search bar highlighted at the top-right corner
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.47 – 在包管理器窗口右上角突出显示的搜索栏
- en: Select **Default Playables** at the left side of the window, followed by clicking
    **Download**, and then the **Import** button (at the bottom-right corner of the
    window).
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在窗口的左侧选择**默认可播放文件**，然后点击**下载**，接着点击窗口右下角的**导入**按钮。
- en: We will then be presented with a list of folders and files that will be imported
    into the project.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到要导入到项目中的文件夹和文件列表。
- en: 'Click the **Import** button, as shown in the following screenshot:'
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击如图下截图所示的**导入**按钮：
- en: '![Figure 12.48 – The Default Playables files to be imported into the project'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.48 – 要导入到项目中的默认可播放文件'
- en: '](img/Figure_12.48_B18381.jpg)'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.48_B18381.jpg)'
- en: Figure 12.48 – The Default Playables files to be imported into the project
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.48 – 要导入到项目中的默认可播放文件
- en: We now have extra functionality added to our timeline, with an added folder
    in our `Assets` folder called `DefaultPlayables`. Also, as mentioned, to add even
    more functionality (such as timeline tracks) to the timeline, check out the file
    inside the `DefaultPlayables` folder named `DefaultPlayablesDocumentation`.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经向我们的时间轴添加了额外的功能，在`Assets`文件夹中新增了一个名为`DefaultPlayables`的文件夹。此外，正如之前提到的，要向时间轴添加更多功能（如时间轴轨道），请查看`DefaultPlayables`文件夹内的名为`DefaultPlayablesDocumentation`的文件。
- en: Let's now move on to the next section, where we will make use of manipulating
    the lights in the scene.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进入下一节，我们将利用场景中灯光的操作。
- en: Manipulating light components in the timeline
  id: totrans-625
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在时间轴中操作灯光组件
- en: In this section, we will continue working on the same timeline and expand it
    to hold more tracks. In the last section, we introduced a free-to-download asset
    from the Asset Store called **Default Playables** to save us from writing code
    from scratch and to offer new playables. This asset gave us the ability to add
    new tracks to our timeline. To continue adding new tracks, we will manipulate
    the lights in our third-level scene.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将继续在同一个时间轴上工作，并扩展它以容纳更多轨道。在上一个章节中，我们介绍了一个来自Asset Store的免费可下载资产，名为**默认可播放文件**，以避免从头编写代码并提供新的可播放文件。这个资产使我们能够向时间轴添加新轨道。为了继续添加新轨道，我们将操作第三级场景中的灯光。
- en: 'To add a light component to the timeline, we need to do the following:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 要将灯光组件添加到时间轴，我们需要执行以下操作：
- en: Make sure the **Timeline** window is still locked, which we set in the *Preparing
    the boss for the timeline* section.
  id: totrans-628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保时间轴窗口仍然处于锁定状态，这是我们之前在*为时间轴准备BOSS*部分设置的。
- en: 'Right-click at the bottom-left open-space corner of the **Timeline** window
    and select **Light Control Track**, as shown in the following screenshot:'
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**时间轴**窗口的左下角空白角落处右键单击并选择**灯光控制轨道**，如图下截图所示：
- en: '![Figure 12.49 – Adding ''Light Control Track'' to the Timeline'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.49 – Adding ''Light Control Track'' to the Timeline]'
- en: '](img/Figure_12.49_B18381.jpg)'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_12.49_B18381.jpg]'
- en: Figure 12.49 – Adding 'Light Control Track' to the Timeline
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 12.49 – Adding 'Light Control Track' to the Timeline
- en: We now have an empty light component track added to our timeline.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经在时间轴中添加了一个空的光组件轨道。
- en: 'Next, we can add an **Animation** clip by right-clicking on the timeline''s
    track line and selecting **Add Light Control Clip**, as shown in the following
    screenshot:'
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以通过在时间轴的轨道线上右键单击并选择**添加灯光控制剪辑**来添加一个**动画**剪辑，如图下截图所示：
- en: '![Figure 12.50 – Adding control to our lights with the control clip'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.50 – Adding control to our lights with the control clip]'
- en: '](img/Figure_12.50_B18381.jpg)'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_12.50_B18381.jpg]'
- en: Figure 12.50 – Adding control to our lights with the control clip
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 12.50 – Adding control to our lights with the control clip
- en: We now have a `LightControlClip` object in our timeline. Click on this clip
    and look at the **Inspector** window. There are a few options here, but we are
    going to focus mainly on **Color**, **Intensity**, and **Range**.
  id: totrans-638
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在在时间轴中有一个`LightControlClip`对象。单击此剪辑并查看**检查器**窗口。这里有几个选项，但我们主要关注**颜色**、**强度**和**范围**。
- en: These properties will directly change the values of the light that sits in the
    **None (Light)** parameter.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性将直接改变位于**无（灯光）**参数中的灯光的值。
- en: 'Set your **Light Control Clip** values to the ones shown in the following screenshot
    in your **Inspector** window:'
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的**检查器**窗口中将您的**灯光控制剪辑**值设置为以下截图所示：
- en: '![Figure 12.51 – Copying the values from your ''Light Control Clip'' to the
    ones in this screenshot'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.51 – Copying the values from your ''Light Control Clip'' to the
    ones in this screenshot]'
- en: '](img/Figure_12.51_B18381.jpg)'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_12.51_B18381.jpg]'
- en: Figure 12.51 – Copying the values from your 'Light Control Clip' to the ones
    in this screenshot
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 12.51 – Copying the values from your 'Light Control Clip' to the ones
    in this screenshot
- en: 'Next, we will set the duration of this clip to `100`. We can do this by either
    changing the value of the `LightControlClip` to the `100` mark, as shown in the
    following screenshot:'
  id: totrans-644
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将设置此剪辑的持续时间为`100`。我们可以通过将`LightControlClip`的值更改为`100`标记来实现，如图下截图所示：
- en: '![Figure 12.52 – Setting the duration of the light control clip to 100'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.52 – Setting the duration of the light control clip to 100]'
- en: '](img/Figure_12.52_B18381.jpg)'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_12.52_B18381.jpg]'
- en: Figure 12.52 – Setting the duration of the light control clip to 100
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 12.52 – Setting the duration of the light control clip to 100
- en: Because this light is going to flash white and then red, ideally, it would make
    sense to have a loop between the two transitions. However, for the sake of blending
    and filling up the timeline, we are going to do it this way.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个灯光将会从白色闪烁到红色，理想情况下，在两个过渡之间有一个循环是有意义的。然而，为了混合和填充时间轴，我们将这样做。
- en: Select `LightControlClip` and press *Ctrl* (*command* on the macOS) + *D* 25
    times to spam the track line with light control clips.
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`LightControlClip`并按*Ctrl* (*command* 在 macOS 上) + *D* 25次，以在轨道线上填充灯光控制剪辑。
- en: Select the second `LightControlClip` object from the left and change its **Color**
    property from white to red.
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧选择第二个`LightControlClip`对象并将其**颜色**属性从白色更改为红色。
- en: Repeat this process for clips `4`, `6`, `8`, `10`, `12`, `14`, `16`, `18`, `20`,
    `22`, `24`, and `26`.
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对剪辑`4`、`6`、`8`、`10`、`12`、`14`、`16`、`18`、`20`、`22`、`24`和`26`重复此过程。
- en: 'Now, zoom into the second `LightControlClip` object and move it 50% of the
    way across to its previous clip to create a blend between the color of the light,
    as in the following screenshot:'
  id: totrans-652
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，放大第二个`LightControlClip`对象并将其移动到其前一个剪辑的一半位置，以在灯光颜色之间创建混合，如图下截图所示：
- en: '![Figure 12.53 – 1st light clip splicing into the 2nd light clip'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.53 – 1st light clip splicing into the 2nd light clip]'
- en: '](img/Figure_12.53_B18381.jpg)'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_12.53_B18381.jpg]'
- en: Figure 12.53 – 1st light clip splicing into the 2nd light clip
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 12.53 – 1st light clip splicing into the 2nd light clip
- en: 'Continue moving each clip 50% of the way across to the previous clip''s location
    to make the lights flash white to red until the level finishes. The following
    screenshot shows the position of the third clip:'
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个剪辑移动到上一个剪辑位置的一半，以使灯光从白色闪烁到红色，直到级别结束。以下截图显示了第三个剪辑的位置：
- en: '![Figure 12.54 – The 2nd light clip splicing into the 3rd'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.54 – The 2nd light clip splicing into the 3rd]'
- en: '](img/Figure_12.54_B18381.jpg)'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.54_B18381.jpg]'
- en: Figure 12.54 – The 2nd light clip splicing into the 3rd
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 12.54 – The 2nd light clip splicing into the 3rd
- en: Once we've merged the clips, we can now duplicate our light track asset so that
    more than one light can flash.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们合并了剪辑，现在我们可以复制我们的灯光轨道资产，这样就可以让多个灯光闪烁。
- en: 'Click on the track asset and press *Ctrl* (*Command* on macOS) + *D* four times.
    The following screenshot uses the ***** symbol to highlight where to click, along
    with the duplicates made:'
  id: totrans-661
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击轨道资产，然后按*Ctrl* (*Command* 在macOS上) + *D*四次。以下截图使用*****符号突出显示点击位置，以及创建的副本：
- en: '![Figure 12.55 – Duplicating the track asset'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.55 – 复制轨道资产'
- en: '](img/Figure_12.55_B18381.jpg)'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.55_B18381.jpg](img/Figure_12.55_B18381.jpg)'
- en: Figure 12.55 – Duplicating the track asset
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.55 – 复制轨道资产
- en: As these are all the same types of tracks, we can put them into a track group
    to keep our timeline tidy.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些都是相同类型的轨道，我们可以将它们放入一个轨道组中，以保持我们的时间轴整洁。
- en: Right-click in the open-space area at the bottom left of the timeline and select
    **Track Group** from the dropdown.
  id: totrans-666
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在时间轴底部左边的空白区域右键单击，并从下拉菜单中选择**轨道组**。
- en: Our track group is made. Now, click and hold the top light track asset while
    holding down *Shift*, and click on the bottom light track asset to select all
    of the light track assets. Still holding down the left mouse button, drag these
    track assets into the track group.
  id: totrans-667
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的轨道组已经创建好了。现在，按住*Shift*键的同时，点击并拖动顶部的灯光轨道资产，然后点击底部的灯光轨道资产以选择所有的灯光轨道资产。仍然按住鼠标左键，将这些轨道资产拖动到轨道组中。
- en: Click on the `Lights`.
  id: totrans-668
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Lights`。
- en: You can use the **+** button to expand and collapse the group.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用**+**按钮展开和折叠组。
- en: 'The following screenshot shows the final result of the timeline lights:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了时间轴灯光的最终结果：
- en: '![Figure 12.56 – The track group called ''Lights'' holding all our light track
    assets'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.56 – 被称为''Lights''的轨道组，包含所有我们的灯光轨道资产'
- en: '](img/Figure_12.56_B18381.jpg)'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.56_B18381.jpg](img/Figure_12.56_B18381.jpg)'
- en: Figure 12.56 – The track group called 'Lights' holding all our light track assets
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.56 – 被称为'Lights'的轨道组，包含所有我们的灯光轨道资产
- en: Now that you know how to make a track group, follow the same process for the
    `boss` object and its `radarPoint` object, and call the track group `Boss`.
  id: totrans-674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经知道如何创建轨道组了，按照相同的过程为`boss`对象及其`radarPoint`对象创建轨道组，并将其命名为`Boss`。
- en: The final step is to drag and drop the five lights that will flash red and white
    into the **Game** window.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将将闪烁红白光的五个灯光拖放到**游戏**窗口中。
- en: Either click on the small, round remote button next to `light00`, `light01`,
    `light02`, `light03`, and `light04` into each parameter.
  id: totrans-676
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为每个参数选择`light00`、`light01`、`light02`、`light03`和`light04`旁边的小型圆形遥控按钮。
- en: Scrub or drag the **Timeline** indicator backward and forward on the timeline
    to see the selected lights flashing red.
  id: totrans-677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在时间轴上前后拖动或滑动**时间轴指示器**，以查看选定的灯光闪烁红色。
- en: Save the scene.
  id: totrans-678
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景。
- en: 'The following screenshot shows our player on the third level with a new set
    of AI enemies, a large boss flying in the background, and flashing lights:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的玩家在第3关，有一组新的AI敌人，一个大型BOSS在背景中飞行，以及闪烁的灯光：
- en: '![Figure 12.57 – The midway of level 3'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.57 – 第3关的中段'
- en: '](img/Figure_12.57_B18381.jpg)'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.57_B18381.jpg](img/Figure_12.57_B18381.jpg)'
- en: Figure 12.57 – The midway of level 3
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.57 – 第3关的中段
- en: 'Now would be a good time to apply the pause screen, if you haven''t already
    done so, to all three scenes. Follow these instructions if you don''t feel comfortable
    doing this on your own:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，现在是一个很好的时机来应用暂停屏幕，对所有三个场景执行以下操作。如果你不习惯自己操作，请遵循以下说明：
- en: With the `level3` scene saved, load up `level1` from the `Assets/Scene` folder
    from the **Project** window.
  id: totrans-684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`level3`场景保存后，从**项目**窗口的`Assets/Scene`文件夹中加载`level1`。
- en: In the `Canvas` and `EventSystem` game objects, and then press *C* to copy them.
  id: totrans-685
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Canvas`和`EventSystem`游戏对象中，然后按*C*键复制它们。
- en: Load the `level3` scene back up.
  id: totrans-686
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次加载`level3`场景。
- en: Select the `Canvas` game object from the **Hierarchy** window and press *Delete*
    on your keyboard.
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**窗口中选择`Canvas`游戏对象，然后在键盘上按*Delete*键。
- en: Press *Ctrl* (*Command* on macOS) + *V* to paste `EventSystem` and `Canvas`
    from the level that contains the pause screen.
  id: totrans-688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Ctrl* (*Command* 在macOS上) + *V*粘贴来自包含暂停屏幕的场景的`EventSystem`和`Canvas`。
- en: Expand `Canvas` and then the `LevelTitle` game object in the **Hierarchy** window.
  id: totrans-689
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中展开`Canvas`，然后展开`LevelTitle`游戏对象。
- en: Select the `Level` game object, and change the `level 1` to `level` `3` in the
    **Inspector** window.
  id: totrans-690
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Level`游戏对象，并在**检查器**窗口中将`level 1`更改为`level` `3`。
- en: Save the scene.
  id: totrans-691
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景。
- en: Repeat this process for `level2`.
  id: totrans-692
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`level2`重复此过程。
- en: 'The following screenshot shows `level3` paused:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了暂停的`level3`：
- en: '![Figure 12.58 – The pause screen working for level 3'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.58 – 暂停屏幕在3级关卡中工作'
- en: '](img/Figure_12.58_B18381.jpg)'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.58_B18381.jpg)'
- en: Figure 12.58 – The pause screen working for level 3
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.58 – 暂停屏幕在3级关卡中工作
- en: Let's move on to summarizing what we have covered in this chapter.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续总结本章我们所学的内容。
- en: Summary
  id: totrans-698
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced a new concept to our game to make it more interesting
    than just taking place in space. Our camera and player needed to be slightly tweaked
    for the final level to support side-scrolling, instead of them being static in
    one screen, as is the case on the previous two levels. We also introduced a second
    enemy that can move around the floor, dodging other enemies in a panic-like state.
    The fleeing enemy used the navigation system that comes with Unity as standard,
    and we gave the enemy a floor to run around on. Lastly, we introduced the **Timeline**
    feature, which is related to the original animation system we used in [*Chapter
    4*](B18381_04_Epub.xhtml#_idTextAnchor087)*, Applying Art, Animation, and Particles*.
    We also discovered how **Timeline** lets any game object or component be animated
    in it without needing some form of hierarchical link between the game objects.
    Also, we extended the timeline to cover other components, such as lights, which
    we can't animate alone with the **Timeline** feature.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向我们的游戏引入了一个新概念，使其比仅仅发生在空间中更有趣。我们的摄像机和玩家需要稍作调整以支持最终关卡的水平滚动，而不是像前两个关卡那样在屏幕上保持静态。我们还引入了一个可以在地板上移动的第二个敌人，它在恐慌状态下躲避其他敌人。逃跑的敌人使用了Unity标准提供的导航系统，我们给了敌人一个可以跑动的地板。最后，我们引入了**时间轴**功能，这与我们在[*第4章*](B18381_04_Epub.xhtml#_idTextAnchor087)*，应用艺术、动画和粒子*中使用的原始动画系统相关。我们还发现了**时间轴**如何让任何游戏对象或组件在其中被动画化，而无需在游戏对象之间建立某种形式的层次链接。此外，我们还扩展了时间轴以涵盖其他组件，例如灯光，我们无法仅使用**时间轴**功能单独对它们进行动画化。
- en: The main takeaways from this chapter are the introduction of AI with a navigation
    system that can also be used for other behaviors in other games and the introduction
    of the timeline and its use to encourage creativity in projects, such as cutscenes,
    films, and animated TV sequences.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要收获是介绍了具有导航系统的人工智能，该系统也可以用于其他游戏中的其他行为，以及介绍了时间轴及其在项目（如过场动画、电影和动画电视连续剧）中鼓励创造性的使用。
- en: In the next chapter, we will look at polishing the visuals of our game, and
    we will see what tools can help us in optimizing performance and testing for bugs.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何打磨我们游戏的外观，并查看哪些工具可以帮助我们优化性能和测试错误。
- en: Before you move on to the next chapter, try out the following mock test, as
    this is the last mini-mock test in this book before the big one.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 在你进入下一章之前，尝试以下模拟测试，因为这是本书在大型模拟测试之前最后的迷你模拟测试。
- en: Mock test
  id: totrans-703
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟测试
- en: You are developing a game where your player is inside an office with other staff
    workers around them. When your player walks to a particular point, a trigger event
    is called to move the staff into another room with the use of **Playable Director**.
  id: totrans-704
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你正在开发一个游戏，你的玩家在办公室里，周围有其他工作人员。当你的玩家走到一个特定点时，会调用一个触发事件，使用**可玩导演**将工作人员移动到另一个房间。
- en: You notice that when the game is paused and then un-paused, the audio and animation
    are out of sync with each other.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，当游戏暂停然后取消暂停时，音频和动画彼此不同步。
- en: Which property in the **Playable Director** component will likely fix this issue?
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 在**可玩导演**组件中，哪个属性可能会解决这个问题？
- en: Set the wrap mode to **Hold**.
  id: totrans-707
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包装模式设置为**保持**。
- en: Set the update method to **DSP**.
  id: totrans-708
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将更新方法设置为**DSP**。
- en: Set **Initial Time** to the current time (the time when the game is paused).
  id: totrans-709
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**初始时间**设置为当前时间（游戏暂停时的时间）。
- en: Set the update method to **Unscaled Game Time**.
  id: totrans-710
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将更新方法设置为**未缩放的游戏时间**。
- en: We have a set of playables linked within our playable graph. We need to remove
    one of these playables and its inputs.
  id: totrans-711
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在我们的可玩图中有一些可玩元素链接。我们需要移除其中一个可玩元素及其输入。
- en: Which **PlayerGraph** function should we use?
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该使用哪个**PlayerGraph**函数？
- en: '`DestroyOutput`'
  id: totrans-713
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DestroyOutput`'
- en: '`DestroyPlayable`'
  id: totrans-714
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DestroyPlayable`'
- en: '`DestroySubgraph`'
  id: totrans-715
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DestroySubgraph`'
- en: '`Destroy`'
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Destroy`'
- en: You have developed an eight-ball pool game. One of the testers has come back
    to you, saying that the frame rate of the game drops too low when one of the players
    breaks the balls up at the start of a game. All of the balls have rigid body sphere
    colliders.
  id: totrans-717
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你开发了一个八球台球游戏。一位测试人员回到你这里，说当一名玩家在游戏开始时打碎球时，游戏的帧率会过低。所有的球都有刚体球体碰撞器。
- en: How can we improve the drop in the frame rate?
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何提高帧率的下降？
- en: Use a less expensive shader on the objects that are colliding with one another.
  id: totrans-719
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相互碰撞的对象上使用更便宜的着色器。
- en: Set the maximum allowed timestep to a range of 8–10 fps to account for this
    worst-case scenario.
  id: totrans-720
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将最大允许的时间步长设置为 8-10 fps 的范围，以应对这种最坏的情况。
- en: Change the rigid bodies so that they are kinematic.
  id: totrans-721
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将刚体更改为运动学。
- en: Use box and capsule colliders instead of sphere colliders.
  id: totrans-722
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用盒子和胶囊碰撞器而不是球体碰撞器。
- en: What does the `NavMesh` modifier do?
  id: totrans-723
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NavMesh` 修改器做什么？'
- en: A `NavMesh` modifier determines what stage of the build process the NavMesh
    is baked at.
  id: totrans-724
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个 `NavMesh` 修改器确定 NavMesh 在构建过程的哪个阶段进行烘焙。
- en: A `NavMesh` modifier describes the AI of each agent in the scene.
  id: totrans-725
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个 `NavMesh` 修改器描述场景中每个代理的 AI。
- en: A `NavMesh` modifier allows NavMesh baking to occur outside the main thread
    so that it can be dynamically baked at runtime.
  id: totrans-726
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个 `NavMesh` 修改器允许在主线程之外进行 NavMesh 烘焙，以便可以在运行时动态烘焙。
- en: A `NavMesh` modifier adjusts how a game object behaves during NavMesh baking
    and can, for example, only affect certain agents.
  id: totrans-727
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个 `NavMesh` 修改器调整游戏对象在 NavMesh 烘焙期间的行为，例如，可以仅影响某些代理。
- en: Why does it help to only have the necessary boxes checked in the layer collision
    matrix?
  id: totrans-728
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么只选中必要的框在层碰撞矩阵中会有帮助？
- en: Unchecking boxes will hide layers so that they're not rendered.
  id: totrans-729
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选中框将隐藏层，以便它们不会被渲染。
- en: Checking boxes will indicate which collisions can be ignored.
  id: totrans-730
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选中框将指示哪些碰撞可以忽略。
- en: Checking boxes will show which layers are colliding in the frame debugger.
  id: totrans-731
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选中框将在帧调试器中显示哪些层正在碰撞。
- en: Unchecking boxes will reduce the number of layer collisions the physics system
    needs to check.
  id: totrans-732
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选中框将减少物理系统需要检查的层碰撞数量。
- en: When we create a `Timeline` asset for a game object, what component is created
    and added to our game object?
  id: totrans-733
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们为游戏对象创建一个 `Timeline` 资产时，会创建并添加到我们的游戏对象的组件是什么？
- en: '`PlayableBinding`'
  id: totrans-734
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PlayableBinding`'
- en: '`PlayableDirector`'
  id: totrans-735
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PlayableDirector`'
- en: '`PlayableOutput`'
  id: totrans-736
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PlayableOutput`'
- en: '`PlayableGraph`'
  id: totrans-737
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PlayableGraph`'
- en: In your first-person shooter, which you are testing, you notice that when the
    alarm is sounded, the enemy guards come running toward the player. When you observe
    the enemy guards advancing, you close the door on them but notice that their arms
    and heads are coming through the door that you have closed.
  id: totrans-738
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你正在测试的第一人称射击游戏中，你注意到当警报响起时，敌人守卫会跑向玩家。当你观察敌人守卫前进时，你关上了门，但注意到他们的手臂和头部正穿过你关上的门。
- en: What setting do you need to increase to stop these arms and heads coming through
    objects that they shouldn't?
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要增加哪个设置来停止这些手臂和头部穿过它们不应该穿过的物体？
- en: '**Step Height**'
  id: totrans-740
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**步高**'
- en: '**Max Slope**'
  id: totrans-741
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最大坡度**'
- en: '**Agent Height**'
  id: totrans-742
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**代理高度**'
- en: '**Agent Radius**'
  id: totrans-743
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**代理半径**'
- en: You have got yourself involved in a classic Save the Mayor rescue game. Your
    player is a trained vigilante trying to eliminate potential attackers to harm
    the city's mayor. One of the attackers gets too close, and you take a shot to
    warn them off. The attacker runs away but returns shortly after, crawling toward
    the mayor.
  id: totrans-744
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你已经卷入了一场经典的拯救市长救援游戏。你的玩家是一名受过训练的义警，试图消除可能攻击市长的潜在攻击者。其中一名攻击者离得太近，你开枪警告他们。攻击者跑开了，但不久后又回来，匍匐着向市长爬去。
- en: Which `NavMesh` agent property can simulate this cautious behavior?
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个 `NavMesh` 代理属性可以模拟这种谨慎的行为？
- en: '**Area Mask**'
  id: totrans-746
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**区域遮罩**'
- en: '**Auto Braking**'
  id: totrans-747
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**自动制动**'
- en: '**Stopping Distance**'
  id: totrans-748
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**停止距离**'
- en: '**Priority**'
  id: totrans-749
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**优先级**'
- en: Congratulations – Save the Mayor was a massive success, and you have been asked
    to start development straight away on Save the Mayor 2! Your vigilante is back,
    and this time, he can jump *and* run and jump across building rooftops.
  id: totrans-750
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恭喜——拯救市长取得了巨大成功，你被要求立即开始开发拯救市长 2！你的义警回来了，这次他可以跳 *和* 跑，并跳过建筑物的屋顶。
- en: Yet again, you have applied the `NavMesh` agent so that your vigilante can run
    and jump across buildings in a linear path. You have correctly hooked all your
    animation controls up but have noticed that your vigilante isn't animating when
    it comes to jumping between building rooftops.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你已经应用了 `NavMesh` 代理，让你的义警可以在直线路径上跑和跳过建筑物。你已经正确连接了所有动画控制，但注意到你的义警在跳过建筑物屋顶时没有进行动画。
- en: What setting or property do we need to change to solve this issue?
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更改哪个设置或属性来解决此问题？
- en: Uncheck `NavMesh` agent component.
  id: totrans-753
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选中 `NavMesh` 代理组件。
- en: Increase the `NavMesh` agent component.
  id: totrans-754
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加导航网格代理组件。
- en: Uncheck the **Height Mesh** property in the **Bake** settings under **Navigation**.
  id: totrans-755
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**导航**下的**烘焙**设置中取消选中**高度网格**属性。
- en: Increase the jump distance in the **Bake** settings under **Navigation**.
  id: totrans-756
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**导航**下的**烘焙**设置中增加跳跃距离。
- en: We are working on a third-person game, and our character is using a finite state
    machine to react to their states. We currently have it set so that if we get too
    close to a particular character, they will attempt to run and hug us.
  id: totrans-757
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在制作一款第三人称游戏，我们的角色正在使用有限状态机来对其状态做出反应。目前我们设置为，如果我们离某个角色太近，他们就会试图跑过来拥抱我们。
- en: What finite state machine component is the programmer working on?
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员正在工作的有限状态机组件是什么？
- en: '**Actions**'
  id: totrans-759
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动作**'
- en: '**Transitions**'
  id: totrans-760
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**过渡**'
- en: '**Events**'
  id: totrans-761
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**事件**'
- en: '**Rules**'
  id: totrans-762
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**规则**'
- en: Which of these tracks can the timeline not add without applying additional coding?
  id: totrans-763
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些轨道在不需要额外编码的情况下，时间轴无法添加？
- en: '**Activation Track**'
  id: totrans-764
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**激活轨道**'
- en: '**Animation Track**'
  id: totrans-765
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动画轨道**'
- en: '**Light Control Track**'
  id: totrans-766
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**灯光控制轨道**'
- en: '**Playable Track**'
  id: totrans-767
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**可玩轨道**'
- en: One of the 3D artists has supplied you with a series of three-dimensional models
    to be applied to one of the start up scenes for the project you are currently
    developing.
  id: totrans-768
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其中一位3D艺术家向您提供了一系列三维模型，这些模型将被应用于您目前正在开发的项目中的一个启动场景。
- en: When importing the models into the scene, you notice that all the models have
    sharp edges. You have asked the artist to make the models smoother.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 当将模型导入场景时，你会注意到所有模型都有尖锐的边缘。你已经要求艺术家使模型更平滑。
- en: Is there anything else that can be done on the developer side to possibly fix
    these sharp three-dimensional model edges?
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者这边还有其他什么可以做的来可能修复这些尖锐的三维模型边缘？
- en: Calculate the normals to a particular smoothing angle value.
  id: totrans-771
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算特定平滑角度值的法线。
- en: Import the files through Unity instead of dragging and dropping the files.
  id: totrans-772
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 Unity 导入文件，而不是拖放文件。
- en: Apply materials to each three-dimensional model.
  id: totrans-773
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将材质应用于每个三维模型。
- en: Make sure there is lighting in the scene.
  id: totrans-774
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保场景中有灯光。
- en: What does `LateUpdate` do?
  id: totrans-775
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LateUpdate` 做什么？'
- en: Replaces the standard `Update` function when frames are overloaded.
  id: totrans-776
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当帧过载时，替换标准的 `Update` 函数。
- en: '`LateUpdate` takes fewer resources to run, which makes it ideal for mobile
    platforms.'
  id: totrans-777
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LateUpdate` 运行资源较少，这使得它非常适合移动平台。'
- en: An update is only called once on every frame. `LateUpdate` is called every three
    frames.
  id: totrans-778
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个帧只调用一次更新。`LateUpdate` 每三帧调用一次。
- en: '`LateUpdate` is the last item in the execution order before rendering.'
  id: totrans-779
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LateUpdate` 是在渲染之前的执行顺序中的最后一个项目。'
- en: What are the advantages of using `GameObject.Find` (if any)?
  id: totrans-780
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `GameObject.Find`（如果有任何优点）的优点是什么？
- en: There aren't any; it's slow and demanding.
  id: totrans-781
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有这些；它很慢且要求高。
- en: If not called on every frame, it makes coding useful for referencing.
  id: totrans-782
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不在每个帧上调用，它使编码对引用很有用。
- en: '`GameObject.Find` is deprecated.'
  id: totrans-783
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GameObject.Find` 已弃用。'
- en: '`GameObject.Find` searches through library asset data outside of the Unity
    project.'
  id: totrans-784
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GameObject.Find` 在 Unity 项目之外的库资产数据中搜索。'
- en: Do we have to import the `UnityEngine` library and `MonoBehaviour` with every
    script?
  id: totrans-785
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们是否必须在每个脚本中导入 `UnityEngine` 库和 `MonoBehaviour`？
- en: No, as long as they are not applied to a game object.
  id: totrans-786
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，只要它们没有被应用到游戏对象上。
- en: Yes, or the Unity engine rejects the script.
  id: totrans-787
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，或者 Unity 引擎会拒绝脚本。
- en: Yes, as they act as a header to all scripts.
  id: totrans-788
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，因为它们充当所有脚本的标题。
- en: Only `MonoBehaviour` must be inherited in all cases.
  id: totrans-789
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有情况下，必须继承 `MonoBehaviour`。
- en: When moving from one scene to another, you notice that the second scene is much
    darker, even though it uses the same art and lighting as the scene before it.
  id: totrans-790
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当从一个场景移动到另一个场景时，你会注意到第二个场景比之前使用相同艺术和灯光的场景要暗得多。
- en: How do we make the lighting act how it should in the scene?
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何让场景中的灯光表现出应有的效果？
- en: Make sure all the lights are turned off before being turned on in the second
    scene.
  id: totrans-792
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个场景开启灯光之前，确保所有灯光都已关闭。
- en: Keep all the lights on from the first scene when moving into the second scene.
  id: totrans-793
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进入第二个场景时，保持第一个场景中的所有灯光开启。
- en: Duplicate the lights from the previous scene over to the new one when loaded
    up.
  id: totrans-794
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在加载时，将前一个场景中的灯光复制到新场景中。
- en: Turn off **Auto Generate** in the lighting settings and manually generate the
    lights.
  id: totrans-795
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在灯光设置中关闭**自动生成**，并手动生成灯光。
- en: What are the benefits of `Debug.Log()`?
  id: totrans-796
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Debug.Log()` 的好处是什么？'
- en: It is useful if developers want to know the value of a variable.
  id: totrans-797
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果开发者想了解变量的值，这很有用。
- en: It sends string values to each variable.
  id: totrans-798
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将字符串值发送到每个变量。
- en: There aren't any; it's deprecated, so we don't use it.
  id: totrans-799
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有这些；它已弃用，所以我们不使用它。
- en: It logs information into Unity's database.
  id: totrans-800
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将信息记录到Unity的数据库中。
- en: Is the Audio Mixer useful to developers?
  id: totrans-801
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 音频混音器对开发者有用吗？
- en: No, it's specifically built for audio users; developers use an AudioSource.
  id: totrans-802
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，它是专门为音频用户构建的；开发者使用AudioSource。
- en: Yes, as it can be used to hold all the sounds in one central point.
  id: totrans-803
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，因为它可以用来在一点集中存储所有声音。
- en: Only if the developer is skilled in handling audio alone.
  id: totrans-804
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有当开发者擅长单独处理音频时。
- en: Yes, it helps the performance of the audio.
  id: totrans-805
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，它有助于音频的性能。
- en: Why do some developers prefer JSON over PlayerPrefs?
  id: totrans-806
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么一些开发者更喜欢JSON而不是PlayerPrefs？
- en: PlayerPrefs was released before JSON, which gives it a bigger following.
  id: totrans-807
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: PlayerPrefs在JSON之前发布，这使得它拥有更多的追随者。
- en: JSON can be used with more data types and is a more compatible API.
  id: totrans-808
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: JSON可以与更多数据类型一起使用，并且是一个更兼容的API。
- en: Both are good; it's just a matter of personal preference.
  id: totrans-809
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两者都很好；这只是个人偏好的问题。
- en: JSON is owned by Unity, so it incorporates a lot of features.
  id: totrans-810
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: JSON由Unity拥有，因此它集成了许多功能。
- en: Why would we use a trigger box instead of a collider?
  id: totrans-811
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们会使用触发器框而不是碰撞体？
- en: Triggers and colliders carry out the same task.
  id: totrans-812
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触发器和碰撞体执行相同的任务。
- en: Triggers have more functionality and cost less to run than colliders.
  id: totrans-813
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触发器比碰撞体功能更强大，且运行成本更低。
- en: A trigger can call code when another collider/trigger enters it.
  id: totrans-814
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当另一个碰撞体/触发器进入它时，触发器可以调用代码。
- en: Triggers have different colored boxes.
  id: totrans-815
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触发器有不同的彩色框。
