<html><head></head><body>
<div id="_idContainer101">
<h1 class="chapter-number" id="_idParaDest-199"><a id="_idTextAnchor344"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-200"><a id="_idTextAnchor345"/><span class="koboSpan" id="kobo.2.1">Master Data Management</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we showed you a method to design information entities in such a way that they do not have any technical coupling, in an effort for the information system containing them to be free to evolve when the business changes. </span><span class="koboSpan" id="kobo.3.2">If the data model is a pure reflection of the business represented, it makes it much easier to follow business changes (and change is the only constant) because there won’t be some technical constraint in our way forcing us to compromise on the quality of the design, and thus on the performance of the system as </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">a whole.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we will start talking about the implementation of the data model into something concrete (if this can be said about software, which is mostly virtual). </span><span class="koboSpan" id="kobo.5.2">It is only in </span><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapters 16 to 19</span></em><span class="koboSpan" id="kobo.7.1"> that we will code what we will call for the rest of the book the “</span><em class="italic"><span class="koboSpan" id="kobo.8.1">data referential(s)</span></em><span class="koboSpan" id="kobo.9.1">”. </span><span class="koboSpan" id="kobo.9.2">For now, we will start some actual software architecture to welcome the data model, persist the associated entities, and so on. </span><span class="koboSpan" id="kobo.9.3">There are many responsibilities in the data referential, and the discipline of handling these essential resources in an information system is </span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.10.1">called </span><strong class="bold"><span class="koboSpan" id="kobo.11.1">Master Data Management</span></strong><span class="koboSpan" id="kobo.12.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.13.1">MDM</span></strong><span class="koboSpan" id="kobo.14.1">). </span><span class="koboSpan" id="kobo.14.2">At first sight, these responsibilities might look like those you would trust a database with, or even find in a resource-based API. </span><span class="koboSpan" id="kobo.14.3">But this chapter should convince you that there are many more things to the model that justify this use of a neologism like “</span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">data referential”.</span></span></p>
<p><span class="koboSpan" id="kobo.16.1">In addition to defining the functions of the data referential, MDM is about choosing the right architecture, defining the streams of data in the overall information system, and even putting in place governance of the data, which involves finding who is responsible for what action on the data in order to keep the system in shape. </span><span class="koboSpan" id="kobo.16.2">Having clean and available master data may be the single most important factor in the quality of the system. </span><span class="koboSpan" id="kobo.16.3">Reporting cannot be done without clean data and most business processes depend on the availability of the data referential. </span><span class="koboSpan" id="kobo.16.4">Also, some regulatory reasons, such as accounting or compliance questions, demand </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">high-quality data.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">After showing the different types of data referential that you may encounter – or create – in an information system, we will finish this chapter with an overview of possible issues with data, patterns of use, possible evolution of data in time, and some other general topics that will hopefully provide you with up-to-date knowledge about the </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">MDM architecture.</span></span><a id="_idTextAnchor346"/></p>
<h1 id="_idParaDest-201"><a id="_idTextAnchor347"/><span class="koboSpan" id="kobo.20.1">Responsibilities around the data</span></h1>
<p><span class="koboSpan" id="kobo.21.1">The </span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.22.1">concept of the data referential as a unique point of truth for the data entities of a given domain has already been explained globally, but we have not formally described what functional responsibilities are contained in it. </span><span class="koboSpan" id="kobo.22.2">This section will explain each of the main responsibilities and features of the referential. </span><span class="koboSpan" id="kobo.22.3">Looking at the responsibilities explained in the following subsections, you might ask why we’re talking about the data referential instead of simply using the better-known expression of a database, but we will see in the second part of this chapter that a referential is much more </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">than this</span><a id="_idTextAnchor348"/><span class="koboSpan" id="kobo.24.1">.</span></span></p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor349"/><span class="koboSpan" id="kobo.25.1">Persistence</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.26.1">Persistence</span></strong><span class="koboSpan" id="kobo.27.1"> is</span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.28.1"> the responsibility that immediately comes to mind when we talk about managing data. </span><span class="koboSpan" id="kobo.28.2">After all, when we trust an information system’s data, the very first demand we have is that the computer does not forget it once it has learned about it. </span><span class="koboSpan" id="kobo.28.3">This demand is crucial, as even an electricity failure should not have an impact on it. </span><span class="koboSpan" id="kobo.28.4">This is why databases were invented and why engineers went such a long way to ensure the safe travel of data between memory and hard disks, </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">both ways.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">Persistence may be often</span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.31.1"> reduced to </span><strong class="bold"><span class="koboSpan" id="kobo.32.1">CRUD</span></strong><span class="koboSpan" id="kobo.33.1"> (which stands for </span><strong class="bold"><span class="koboSpan" id="kobo.34.1">Create, Read, Update, Delete</span></strong><span class="koboSpan" id="kobo.35.1"> – the four main operations on data), but this concept is way too limited compared to the features encompassed by the data referential, though it is enough for most of the standard uses of low-importance data in the information system. </span><span class="koboSpan" id="kobo.35.2">Since we talk here about primary data used in many places in the information system, some other aspects of persistence have to be taken into account. </span><span class="koboSpan" id="kobo.35.3">The first one was talked about at length in </span><a href="B21293_04.xhtml#_idTextAnchor121"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.36.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.37.1"> – namely, time. </span><span class="koboSpan" id="kobo.37.2">When one includes time in the MDM equation, storing the so-called “current” state of the data (which, most of the time, is only the last-known or best-known state of the corresponding business reality) suddenly becomes much more complicated and means, at least, storing the different states of data over time, with an indication of time to follow the history of these </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">successive states.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">As we explained in </span><a href="B21293_05.xhtml#_idTextAnchor164"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.40.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.41.1">, a good MDM is a “know it all” system that, instead of states, should store the actual commands modifying the data to enable us to retrace why the state of such an entity has evolved. </span><span class="koboSpan" id="kobo.41.2">This means that what will be written in the database is not a state with a date but, ideally, a “delta” command causing a change from one state to another – for example, modifying the zip code in the first address of an author in our sample information system. </span><span class="koboSpan" id="kobo.41.3">This way, not only can we reconstitute the state of a business entity at any time in its life cycle but we also avoid the complexity of optimistic/pessimistic locks, transactions, data reconciliation, compensation, and </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">Metadata is</span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.44.1"> also an important addition to the simple CRUD approach. </span><span class="koboSpan" id="kobo.44.2">Indeed, it is of great importance in the manipulation of master data to be able to retrieve and manipulate information linked to the data changes – for example, its author, the IP of the machine where the command came from, the identifier of the interaction that has caused this change, the actual date of the interaction, maybe also a value date if it has been stipulated by the author, and so on. </span><span class="koboSpan" id="kobo.44.3">This allows for traceability, which becomes more and more important for the main business entities in an information system. </span><span class="koboSpan" id="kobo.44.4">It also provides powerful insights into the data itself. </span><span class="koboSpan" id="kobo.44.5">Being able to analyze the history of the data will help you fight fraud (for example, by checking which entity changes its bank coordinates often, or limiting how many representatives of a given company can change in a given period of time). </span><span class="koboSpan" id="kobo.44.6">It can also help with some regulatory questions that are becoming more and more common, as we will see a bit later when talking about </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">data deletion.</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">When talking about persistence, we often think of a given entity (and I, for one, have only been given examples of such atomic manipulations previously mentioned), but the ability to manipulate masses of data is also an important responsibility of the data referential. </span><span class="koboSpan" id="kobo.46.2">In most cases, this translates into being able to perform actions in batches, but the consequences are also in terms of performance management and the capacity to handle referential-wide transactions (which are very different from business entity-centered translations, which the data referential should </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">help elimina</span><a id="_idTextAnchor350"/><span class="koboSpan" id="kobo.48.1">te).</span></span></p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor351"/><span class="koboSpan" id="kobo.49.1">The question of identifiers</span></h2>
<p><span class="koboSpan" id="kobo.50.1">As </span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.51.1">soon as a business entity unit is created, the question of how to identify it arises, since persistence is the capability of retrieving data that the information system has been given, and this naturally means that a deterministic way must exist to point at this given entity. </span><span class="koboSpan" id="kobo.51.2">At the very least, a system-wide identifier should exist to do so. </span><span class="koboSpan" id="kobo.51.3">It can take a lot of forms but, for the sake of applicability, we will consider the following as a URI, for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">https://demoeditor.com/authors/202312-007</span></strong><span class="koboSpan" id="kobo.53.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">urn:com:demoeditor:library:books:978-2409002205</span></strong><span class="koboSpan" id="kobo.55.1">. </span><span class="koboSpan" id="kobo.55.2">This kind of identifier is supposed to be understood globally, by any module participating in the information</span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.56.1"> system. </span><span class="koboSpan" id="kobo.56.2">It acts a bit as the ubiquitous language in Domain-Driven Design but allows pointing at a given entity instead of defining a </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">business concept.</span></span></p>
<p><span class="koboSpan" id="kobo.58.1">Of course, local identifiers may exist. </span><span class="koboSpan" id="kobo.58.2">For example, the book pointed at </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">urn:com:demo</span></strong></span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">
editor:library:books:978-2409002205</span></strong><span class="koboSpan" id="kobo.62.1"> could be stored in a MongoDB database where its technical </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">ObjectID</span></strong><span class="koboSpan" id="kobo.64.1"> would be </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">22b2e840-27ed-4315-bb33-dff8e95f1709</span></strong><span class="koboSpan" id="kobo.66.1">. </span><span class="koboSpan" id="kobo.66.2">This kind of identifier is local to the module it belongs to. </span><span class="koboSpan" id="kobo.66.3">Thus, it is generally a bad idea to make it known by other modules, as a change in the implementation could alter the link and make it impossible for them to retrieve the entity they were </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">pointing at.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">An entity can also have business identifiers that are not local per se but bear no guarantee of being understood anywhere in the information system. </span><span class="koboSpan" id="kobo.68.2">The book generally identified by </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">urn:com:demoeditor:library:books:978-2409002205</span></strong><span class="koboSpan" id="kobo.70.1"> could be retrieved only by its 13-digit ISBN </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">978-2409002205</span></strong><span class="koboSpan" id="kobo.72.1">; in fact, it is the variable part of the unique system identifier. </span><span class="koboSpan" id="kobo.72.2">However, other identifiers exist. </span><span class="koboSpan" id="kobo.72.3">For example, the same book can also be retrieved by its 10-digit ISBN, which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">240900220X</span></strong><span class="koboSpan" id="kobo.74.1">. </span><span class="koboSpan" id="kobo.74.2">Business identifiers can also be created inside the information system for particular uses. </span><span class="koboSpan" id="kobo.74.3">In our sample edition company, one could imagine that a serial number is applied to a book to keep track at the printing station, where batches are used and a single integer might be easier to handle than a full-blown ISBN, without risking any confusion as the workshop only prints books of the </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">sample editor.</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">Additional technical identifiers are more often encountered, particularly in information systems with legacy software applications. </span><span class="koboSpan" id="kobo.76.2">Indeed, those generally insist on having their own identifiers. </span><span class="koboSpan" id="kobo.76.3">This way, the accounting system of </span><em class="italic"><span class="koboSpan" id="kobo.77.1">DemoEditor</span></em><span class="koboSpan" id="kobo.78.1"> might know </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">urn:com:demoeditor:</span></strong></span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">
library:books:978-2409002205</span></strong><span class="koboSpan" id="kobo.82.1"> book by its local identifier, </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">BK4648</span></strong><span class="koboSpan" id="kobo.84.1">. </span><span class="koboSpan" id="kobo.84.2">The ERP system might have a technical identifier of </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">00000786</span></strong><span class="koboSpan" id="kobo.86.1"> if the book is the 786th product that has been entered into it. </span><span class="koboSpan" id="kobo.86.2">And so on. </span><span class="koboSpan" id="kobo.86.3">Of course, the dream would be that all software applications are modern and can handle an externally-provided, HTTP-standards-aligned URN. </span><span class="koboSpan" id="kobo.86.4">But this is rarely the case and even modern web applications seem to forget that interoperating with other applications means using the URL that they </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">provide indiscriminately.</span></span></p>
<p><span class="koboSpan" id="kobo.88.1">To provide a good service and account for this reality of information systems, the data referential should provide the capacity to store the business identifiers for the other software</span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.89.1"> modules participating in the system. </span><span class="koboSpan" id="kobo.89.2">At the very least, this should be a dictionary of identifiers associated with an entity, with each value pointed at by a key that globally identifies the module in the system. </span><span class="koboSpan" id="kobo.89.3">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">urn:com:demoeditor:accounting</span></strong><span class="koboSpan" id="kobo.91.1"> could be the key that points to </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">BK4648</span></strong><span class="koboSpan" id="kobo.93.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">urn:com:demoeditor:erp</span></strong><span class="koboSpan" id="kobo.95.1"> could point to </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">00000786</span></strong><span class="koboSpan" id="kobo.97.1">. </span><span class="koboSpan" id="kobo.97.2">When defining the keys, there is a natural tendency to use the name of the specific software used to implement the function, and it would not matter much because the identifier is indeed specific to this software. </span><span class="koboSpan" id="kobo.97.3">But it still remains a good idea to stay generic in order to prepare for any cases. </span><span class="koboSpan" id="kobo.97.4">To give just an example, in the fusion of two administrative regions in France, it proved very useful to have such a separation. </span><span class="koboSpan" id="kobo.97.5">The two existing software applications for finance management were competing to have a unique market after the merger. </span><span class="koboSpan" id="kobo.97.6">It happened that one of the software applications was more customizable than the other and could handle external identifiers, which was part of the decision to keep it as the new unique finance management application. </span><span class="koboSpan" id="kobo.97.7">However, since the identifiers used by the abandoned software were prefixed by a vendor mark and the key for the software that stayed was not generic but used its name, there were some strange associations of identifiers such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">urn:fr:region:VENDOR1=VENDOR2-KEY</span></strong><span class="koboSpan" id="kobo.99.1">. </span><span class="koboSpan" id="kobo.99.2">Since the two brands were well-known competing companies in France and the merger of the two administrative regions caused lots of team modification and change management, this additional confusion quickly became an irritant, with people not even able to tell which software they should use to manipulate financial data. </span><span class="koboSpan" id="kobo.99.3">In the end, switching to a generic key such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">urn:fr:region:FINANCE</span></strong><span class="koboSpan" id="kobo.101.1"> really helped, even if this sounded like a little </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">technical move.</span></span></p>
<p><span class="koboSpan" id="kobo.103.1">I will finish this review of identifiers with a very special case, which is the change of business identifier. </span><span class="koboSpan" id="kobo.103.2">Identifiers are, by essence, stable since they should be a deterministic way to point at an entity in the information system. </span><span class="koboSpan" id="kobo.103.3">A documented case of a change of global identifier is when a social security number is designated to a person who has not been born yet, typically because surgery is necessary on a fetus. </span><span class="koboSpan" id="kobo.103.4">As the first digit in French social security numbers uses the ISO gender equality standard to specify the gender of the owner, it may happen that instead of using 1 (for male) or 2 (for female), a social security number starts with 0 (for unknown). </span><span class="koboSpan" id="kobo.103.5">The identifier is then changed to a new one after the birth of the individual since the first number is then known (or maybe unknown in some other conditions – in this case, the norm specifies the number should be 9 for an undetermined gender). </span><span class="koboSpan" id="kobo.103.6">This is admittedly a very special case that provokes the change of the global, system-wide identifier. </span><span class="koboSpan" id="kobo.103.7">However, the architecture of the system has to be able to handle </span><em class="italic"><span class="koboSpan" id="kobo.104.1">any</span></em><span class="koboSpan" id="kobo.105.1"> existing business case (which does not mean there cannot be some manual adjustment for these cases) to be </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">considered “al</span><a id="_idTextAnchor352"/><span class="koboSpan" id="kobo.107.1">igned.”</span></span></p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor353"/><span class="koboSpan" id="kobo.108.1">The single entity reading responsibility</span></h2>
<p><span class="koboSpan" id="kobo.109.1">Persistence</span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.110.1"> really means nothing if data stored somewhere cannot be retrieved afterward for subsequent use. </span><span class="koboSpan" id="kobo.110.2">This is why reading data is the second responsibility of the data referential that we will study. </span><span class="koboSpan" id="kobo.110.3">This section details the different kinds of read operations and, contrarily to persisting the data, they are actually very diverse in </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">their forms.</span></span></p>
<p><span class="koboSpan" id="kobo.112.1">The first reading act we naturally think of is the retrieval of a unique entity, directly using its identifier. </span><span class="koboSpan" id="kobo.112.2">In API terms, this sums up as calling a </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">GET</span></strong><span class="koboSpan" id="kobo.114.1"> operation on the URL that has been sent back in the response under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">Location</span></strong><span class="koboSpan" id="kobo.116.1"> header when creating the entity. </span><span class="koboSpan" id="kobo.116.2">Or at least, this sends the latest known state of the data because parameters can be added to specify which time version of the data should be retrieved. </span><span class="koboSpan" id="kobo.116.3">This normally raises the question of how to get the state of data since we said we would store changes, not states. </span><span class="koboSpan" id="kobo.116.4">The response there can be simple or complex, depending on the level of detail we go into. </span><span class="koboSpan" id="kobo.116.5">If we radically apply the “</span><em class="italic"><span class="koboSpan" id="kobo.117.1">premature optimization is the root of all evil</span></em><span class="koboSpan" id="kobo.118.1">” principle made popular by Donald Knuth, then it is enough to specify that states can be deduced from changes by applying them to the previous state and consider this recursion uses the initial state of the date, which is an empty set of attributes designated by a </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">unique identifier.</span></span></p>
<p><span class="koboSpan" id="kobo.120.1">I know very well that most technically minded people (and thus at least 99% of you reading this book) will always think a step further and ponder the huge performance problem the data referential would have to deal with if each </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">GET</span></strong><span class="koboSpan" id="kobo.122.1"> operation caused the iterative application of hundreds of patches to an entity in order to find its state at some point of its life cycle. </span><span class="koboSpan" id="kobo.122.2">The very least we would do would be to cache the calculated states to improve on this. </span><span class="koboSpan" id="kobo.122.3">But when you think about it, the vast majority of read operations ask for the best-so-far state of the entity, which is the latest known state. </span><span class="koboSpan" id="kobo.122.4">So, to improve storage while still keeping good performance, caching the last known state of the entities is the </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">right choice.</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">But there are, of course, some exceptions and, as has been many times explained in this book, business-justified exceptions have to be taken into account – not only because it is the goal of the alignment but mostly because these exceptions are generally great challenges on the data model and if it can accommodate them while staying simple, it means this design is mature and has a much greater chance of correctness and, hence, stability. </span><span class="koboSpan" id="kobo.124.2">One such exception can be when the data is often read using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">date</span></strong><span class="koboSpan" id="kobo.126.1"> parameter value. </span><span class="koboSpan" id="kobo.126.2">In this case, improving the performance might mean storing</span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.127.1"> all calculated states, but this uses lots of storage and wastes most of it, as not all states will be called in time. </span><span class="koboSpan" id="kobo.127.2">A good compromise might be to store only a state calculated every 20, 50, or 100 changes. </span><span class="koboSpan" id="kobo.127.3">This way, we can start from an existing state all the time and quickly calculate the specified state because we need only apply a few limited patches to the data. </span><span class="koboSpan" id="kobo.127.4">Depending on business constraints, some states that are more often used than others can be the milestones that are kept in the cache. </span><span class="koboSpan" id="kobo.127.5">For example, in financial applications, it is generally interesting to keep the value just before and just after the change of </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">fiscal year.</span></span></p>
<p><span class="koboSpan" id="kobo.129.1">Another detail that has got to be taken into account is the optional possibility of inserting modifications in the life cycle of the entity. </span><span class="koboSpan" id="kobo.129.2">I understand how this may sound weird to “rewrite the history” and insert changes with potential impacts on the following ones, but there are some cases where this makes sense. </span><span class="koboSpan" id="kobo.129.3">For example, I have seen this happen in accounting systems when errors have been made and calculation rules were reapplied to find the correct result, inserting correcting operations at the time the initial error arose. </span><span class="koboSpan" id="kobo.129.4">Again, this is a rare case and it should be conditioned by strict authorization rules, but the situation has to be cited for the sake </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">of exha</span><a id="_idTextAnchor354"/><span class="koboSpan" id="kobo.131.1">ustivity.</span></span></p>
<h2 id="_idParaDest-205"><a id="_idTextAnchor355"/><span class="koboSpan" id="kobo.132.1">Other kinds of reading responsibilities</span></h2>
<p><span class="koboSpan" id="kobo.133.1">There are</span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.134.1"> cases when the unique system-wide identifier of a business entity is not known or has been forgotten (which means not stored outside its original referential) and, in this case, the responsibility of searching the entities corresponding to given criteria has to be used. </span><span class="koboSpan" id="kobo.134.2">This responsibility is often</span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.135.1"> called </span><strong class="bold"><span class="koboSpan" id="kobo.136.1">querying data</span></strong><span class="koboSpan" id="kobo.137.1">. </span><span class="koboSpan" id="kobo.137.2">Based on the criteria specified in the request, the operation will return a set of results, which can be an empty set or one that contains corresponding data. </span><span class="koboSpan" id="kobo.137.3">There can be cases when the query attributes are such that the results will always contain zero or one entity – for example, because the constraint used is a unique business identifier. </span><span class="koboSpan" id="kobo.137.4">But there can also be cases where the results are particularly numerous, and an additional responsibility </span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.138.1">called </span><strong class="bold"><span class="koboSpan" id="kobo.139.1">pagination</span></strong><span class="koboSpan" id="kobo.140.1"> will be quite useful to reduce </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">bandwidth consumption.</span></span></p>
<p><span class="koboSpan" id="kobo.142.1">Pagination can be active (the client specifies which page of data they want) but also passive (the server restricts the amount of data and provides a means for the client to request the next page of data). </span><span class="koboSpan" id="kobo.142.2">A standard way to implement the first approach is to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">$skip</span></strong><span class="koboSpan" id="kobo.144.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">$top</span></strong><span class="koboSpan" id="kobo.146.1"> attributes, as specified</span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.147.1"> in the </span><strong class="bold"><span class="koboSpan" id="kobo.148.1">OASIS</span></strong><span class="koboSpan" id="kobo.149.1"> (short for, </span><strong class="bold"><span class="koboSpan" id="kobo.150.1">Organization for the Advancement of Structured Information Standards</span></strong><span class="koboSpan" id="kobo.151.1">) standard called </span><strong class="bold"><span class="koboSpan" id="kobo.152.1">Open Data Protocol</span></strong><span class="koboSpan" id="kobo.153.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.154.1">OData</span></strong><span class="koboSpan" id="kobo.155.1">). </span><span class="koboSpan" id="kobo.155.2">This </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.156.1">standard also includes a grammar for the possible values of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">$filter</span></strong><span class="koboSpan" id="kobo.158.1"> attribute, which is used to specify the </span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.159.1">constraints reducing the query results that have been cited previously, when talking about performance in retrieving data. </span><span class="koboSpan" id="kobo.159.2">This book is not the place to explain the richness of this standard, which is sadly not used as often as it should be. </span><span class="koboSpan" id="kobo.159.3">Most API implementers indeed chose to use their attribute names, without realizing that they recreate functions (such as pagination offset, for example) that have been done so many times that they are completely normalized. </span><span class="koboSpan" id="kobo.159.4">Lack of interest in standards, and a “not invented here” syndrome that many developers suffer, are dragging our whole industry back. </span><span class="koboSpan" id="kobo.159.5">But enough ranting about this: a complete chapter has been dedicated to the importance of norms and standards, so we will just close the subject by taking you to the study of the OData standard, or in this case, the GraphQL syntax as well, since these two approaches can be seen as competing (though they are complementary one to the other, and a great API exposes </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">both protocols).</span></span></p>
<p><span class="koboSpan" id="kobo.161.1">Another type of reading responsibility is reporting: this can sometimes be implemented directly by the data referential but this is quite rare, as reporting is often done by crossing data coming from several business domains. </span><span class="koboSpan" id="kobo.161.2">Even if there are only a few of the reporting needs that demand such an external, shared-responsibility implementation, then it is better to handle all data for reporting to this entity. </span><span class="koboSpan" id="kobo.161.3">Depending on the technology you use, this may be a data warehouse, an OLAP cube, a data lake, or any other application. </span><span class="koboSpan" id="kobo.161.4">Again, the implementation does not really matter: as long as you are clean on the interfaces, you may change them any time you like with limited impact on </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.163.1">In the case of reporting, these interfaces can be solicited with different </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">time-based approaches:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.165.1">A synchronous, on-demand, call is always possible but generally not used for performance reasons, at least in complex reports (this is the “pull” mode). </span><span class="koboSpan" id="kobo.165.2">Indeed, if the reporting system needs to wait for all sources to answer and then only calculates the aggregations on its side, the results are, of course, as fresh as possible, but they may take minutes to come and this is often not acceptable </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">by users.</span></span></li>
<li><span class="koboSpan" id="kobo.167.1">The </span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.168.1">asynchronous, regular read of data, is the most commonly used pattern. </span><span class="koboSpan" id="kobo.168.2">Here, data is collected at a given frequency (once a day or more often, sometimes down to once an hour), generally by an ETL, and sent to the data warehousing system where it is aggregated and prepared for reporting. </span><span class="koboSpan" id="kobo.168.3">This way, reports are sent to users quicker (sometimes, they are even produced and made available directly upon data retrieval). </span><span class="koboSpan" id="kobo.168.4">The counterpart is that the data is not as fresh as possible, and moving the cursor to a quicker sending of data increases the consumption of resources. </span><span class="koboSpan" id="kobo.168.5">Optimizations are possible – for example, by reducing the transfer to only new or updated data – but this only goes some way into improving the minimal time needed to update the whole data warehouse. </span><span class="koboSpan" id="kobo.168.6">The greatest technical drawback of this approach is that most of the calculations are reproduced even if the source data has not changed, which is a waste </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">of resources.</span></span></li>
<li><span class="koboSpan" id="kobo.170.1">To go on further in the “push” approach, it is possible to use webhooks to register data refresh to an event of source data change. </span><span class="koboSpan" id="kobo.170.2">This way, the calculations are reproduced only when the data has changed, and the moment is as close as possible to the interaction that has changed the data, which means the reports are very fresh most of the time. </span><span class="koboSpan" id="kobo.170.3">Dealing with large amounts of events is a challenge, but grouping the changes into minimum packages (or with a maximum freshness time constraint) </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">can help.</span></span></li>
<li><span class="koboSpan" id="kobo.172.1">A very modern but technically demanding approach is to mix these “push” and “calculate on demand” strategies by using a system with queues of messages containing data changes and a dedicated architecture to apply fine-grained computations on each of these messages as needed. </span><span class="koboSpan" id="kobo.172.2">Such implementations of a big data approach include Kafka architectures or Apache Spark clusters. </span><span class="koboSpan" id="kobo.172.3">The goal here is not to detail these approaches but just to explain that they will collect all events at the source and then smartly calculate the consequences in aggregated data (the smartness being in the fact that they know the consequences and calculate only what is needed and they can balance these computations on many machines of a cluster and grouping the result in the end). </span><span class="koboSpan" id="kobo.172.4">They can even go as far as producing the final reports on aggregated data and making them available to end users, achieving a complete “</span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">push” paradigm.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.174.1">These four</span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.175.1"> approaches are symbolically represented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">following schema:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer083">
<span class="koboSpan" id="kobo.177.1"><img alt="Figure 10.1 – Modes of reporting" src="image/Figure_10.1_B21293.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.178.1">Figure 10.1 – Modes of reporting</span></p>
<p><span class="koboSpan" id="kobo.179.1">To be exhaustive on these additional reading responsibilities, indexing is another function that is used to accelerate data (and some simple aggregates) reading. </span><span class="koboSpan" id="kobo.179.2">It does not go as far in data transformation as big data and the preceding reporting approaches, but can already prepare a few aggregates (such as sums, local joins, and so on) and make them available through simple protocols as raw data. </span><span class="koboSpan" id="kobo.179.3">Indexing engines such as SOLR or Elasticsearch are generally used to accompany the data referential on the speed of data retrieval. </span><span class="koboSpan" id="kobo.179.4">In this case, the data referential itself concentrates on data consistency and validation rules and then handles reference data to the indexing system to make it available in </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">quick-</span><a id="_idTextAnchor356"/><span class="koboSpan" id="kobo.181.1">read operations.</span></span></p>
<h2 id="_idParaDest-206"><a id="_idTextAnchor357"/><span class="koboSpan" id="kobo.182.1">The complex art of deleting data</span></h2>
<p><span class="koboSpan" id="kobo.183.1">If deltas </span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.184.1">are stored instead of states, there is not much difference between </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">POST</span></strong><span class="koboSpan" id="kobo.186.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">PUT</span></strong><span class="koboSpan" id="kobo.188.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">PATCH</span></strong><span class="koboSpan" id="kobo.190.1"> operations on a resource, as they all translate into a change in the state of the entity, the particular case of a resource creation being a change from something completely empty. </span><span class="koboSpan" id="kobo.190.2">But as far as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">DELETE</span></strong><span class="koboSpan" id="kobo.192.1"> operation is concerned, we are in a different situation. </span><span class="koboSpan" id="kobo.192.2">Indeed, we could blindly apply the same principle and consider that </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">DELETE</span></strong><span class="koboSpan" id="kobo.194.1"> removes all attributes of an entity and brings it back to its initial state, but that would not be exactly true as the entity still keeps an identifier (otherwise, one would not be able to delete it). </span><span class="koboSpan" id="kobo.194.2">This means it is not in the same state as when it did not exist and there is no way to go back to </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">this situation.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">The best way to handle the situation is generally to use a particular attribute of the date stating that it is not active anymore. </span><span class="koboSpan" id="kobo.196.2">When using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">status</span></strong><span class="koboSpan" id="kobo.198.1"> attribute to keep the value of the calculated position in the life cycle of an entity, this attribute may be used with a value such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">archived</span></strong><span class="koboSpan" id="kobo.200.1"> to realize a similar operation. </span><span class="koboSpan" id="kobo.200.2">This is the way the data referential can store the fact that the data has been deleted without actually suppressing data (which is incompatible with what has been said previously about the data referential and its responsibility for history persistence). </span><span class="koboSpan" id="kobo.200.3">Of course, this creates a bit of complexity in the referential because it has to take this into account in every operation it allows. </span><span class="koboSpan" id="kobo.200.4">For example, reading some piece of data that is inactive should react as if the data did not exist (with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">404</span></strong><span class="koboSpan" id="kobo.202.1"> result, in the case of API access), unless in the exceptional case that the user accessing the referential has an </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">archive</span></strong><span class="koboSpan" id="kobo.204.1"> role and can read erased data. </span><span class="koboSpan" id="kobo.204.2">Other questions naturally arise then, such as the possibility of reactivating data and continuing its life cycle (hint: it is generally a bad idea, as many business rules are not thought to handle this very </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">peculiar case).</span></span></p>
<p><span class="koboSpan" id="kobo.206.1">But let’s stop this digression here and come back to the initial idea of data conservation even after a deletion command has been issued. </span><span class="koboSpan" id="kobo.206.2">The functional rationale behind this is mainly regulatory, such as traceability, but also prohibiting data erasing for other purposes, such as forensics after a cyber-attack. </span><span class="koboSpan" id="kobo.206.3">An interesting fact is that some regulations also exist that specify when data should indeed be erased for real (and not simply rendered inactive). </span><span class="koboSpan" id="kobo.206.4">For example, the European GDPR states that personal data should not be kept longer than some legally defined periods, depending on the processes they are associated with. </span><span class="koboSpan" id="kobo.206.5">In the case of personal data collected for marketing reasons (with the consent of the user, of course), the delay is generally a year. </span><span class="koboSpan" id="kobo.206.6">After this time, without renewal of storage consent, the </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.207.1">data shall be erased from the information system that has collected it. </span><span class="koboSpan" id="kobo.207.2">That means the actual removal of the data everywhere it may be (which </span><a id="_idTextAnchor358"/><span class="No-Break"><span class="koboSpan" id="kobo.208.1">includes backups).</span></span></p>
<h2 id="_idParaDest-207"><a id="_idTextAnchor359"/><span class="koboSpan" id="kobo.209.1">Relation to specialized links</span></h2>
<p><span class="koboSpan" id="kobo.210.1">As always, the </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.211.1">devil lies in details, and links can become a problem when dealing with data. </span><span class="koboSpan" id="kobo.211.2">Imagine we use a link between a book and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">author</span></strong><span class="koboSpan" id="kobo.213.1"> entity. </span><span class="koboSpan" id="kobo.213.2">The simplest expression of such an RFC link is </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.215.1">
{
    „isbn13": „978-2409002205",
    „title": [
        {
            „lang": „fr-FR",
            «value»: «Open Data - Consommation, traitement, analyse et visualisation de la donnée publique»
        }
    ],
    "additionalIdentifiers": [
        {
            "key": "urn:com:demoeditor:accounting",
            "value": "BK4648"
        }
    ],
    "links": [
        {
            "rel": "self",
            "href": "https://demoeditor.com/library/books/978-2409002205"
        },
        {
            "rel": "author",
            "href": "https://demoeditor.com/authors/202312-007",
            "title": "JP Gouigoux"
        }
    ]
}</span></pre> <p><span class="koboSpan" id="kobo.216.1">The links are often inherited from specialized links – in our case, a specialized author link that could contain additional important information in its schema, for example, extract restricted to the portion of JSON that has changed, for </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">readability purposes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.218.1">
{
    "rel": "author",
    "href": "https://demoeditor.com/authors/202312-007",
    "title": "JP Gouigoux",
    "authorMainContactPhone": "+33 787 787 787"
}</span></pre> <p><span class="koboSpan" id="kobo.219.1">Having </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.220.1">additional information in links is useful when you know this is a piece of information that will frequently be used when manipulating the link, as it avoids an additional roundtrip to the other API to find this information. </span><span class="koboSpan" id="kobo.220.2">Of course, there should be a right balance, and including the phone number here is questionable because it can be considered volatile data, not changing frequently but on some specific occasions in the mass of authors of an editor’s database. </span><span class="koboSpan" id="kobo.220.3">The consequence is that all links should – in this case – be updated, which accounts for quite a large amount of work. </span><span class="koboSpan" id="kobo.220.4">When you know it is a piece of data that does not change (the author’s name, for example, does not change very often) or even data that should never be changed for regulatory reasons (an approved version, for example, should not be modified even if further versions appear), there is no </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">such problem.</span></span></p>
<p><span class="koboSpan" id="kobo.222.1">This is the first </span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.223.1">issue that should be taken care of with links. </span><span class="koboSpan" id="kobo.223.2">The second one is more subtle: since the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">title</span></strong><span class="koboSpan" id="kobo.225.1"> attribute (which is not an extended one added through inheritance but exists in the standard RFC link definition) has been used to store the common designation of the author, as expected from the definition of this attribute in the RFC, deleting an author will end up with their name still existing in the book’s data referential through these links. </span><span class="koboSpan" id="kobo.225.2">This may be interesting for archiving reasons (even if we do not deal with this author anymore, for example, even though they have died, the books are still in their name). </span><span class="koboSpan" id="kobo.225.3">However, in some other regulatory contexts, this can be a tough problem: if we go back to the example of the European GDPR “right to be forgotten” for personal data, that means that when the author is deleted from the database, we should also go over all the books they authored and replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">title</span></strong><span class="koboSpan" id="kobo.227.1"> contents with something like </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">N/A (GDPR)</span></strong><span class="koboSpan" id="kobo.229.1">. </span><span class="koboSpan" id="kobo.229.2">This is how </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">DELETE</span></strong><span class="koboSpan" id="kobo.231.1"> operations can work under specific </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">func</span><a id="_idTextAnchor360"/><span class="koboSpan" id="kobo.233.1">tional circumstances!</span></span></p>
<h2 id="_idParaDest-208"><a id="_idTextAnchor361"/><span class="koboSpan" id="kobo.234.1">So-called secondary features</span></h2>
<p><span class="koboSpan" id="kobo.235.1">Though </span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.236.1">we might think we have covered all the responsibilities of the data referential since we passed on the four letters of the CRUD acronym, the spectrum of a good application is much larger. </span><span class="koboSpan" id="kobo.236.2">To be thorough, we should talk about all the functions that are generally called “secondary,” even though they are critical and – in some cases – equally important as the persistence of the </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">data itself.</span></span></p>
<p><span class="koboSpan" id="kobo.238.1">The first one of these</span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.239.1"> additional features is </span><strong class="bold"><span class="koboSpan" id="kobo.240.1">security</span></strong><span class="koboSpan" id="kobo.241.1">. </span><span class="koboSpan" id="kobo.241.2">There should be no doubt about the importance of this one anymore, but if it is necessary to convince anyone, let’s just stress the fact that the four criteria commonly used in security categorization are all </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">about data:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.243.1">Availability</span></strong><span class="koboSpan" id="kobo.244.1">: The </span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.245.1">data should be available to authorized persons, which means denial of service (among others) has to be treated. </span><span class="koboSpan" id="kobo.245.2">Though unavailable data is a good way to prevent leakage or unauthorized access, it remains the primary criterion, as the whole idea is to provide a service in a solid way. </span><span class="koboSpan" id="kobo.245.3">Availability also means that a simple mishap should not get the whole </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">system offline.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.247.1">Integrity</span></strong><span class="koboSpan" id="kobo.248.1">: The </span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.249.1">data should not be tampered with by anyone and its correctness should be guaranteed – the consequence being that all functions underlying the service have to be secured as well (database, network, source </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">code, etc.).</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.251.1">Confidentiality</span></strong><span class="koboSpan" id="kobo.252.1">: This</span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.253.1"> is the counterpart of the first criterion, as access should be forbidden to non-authorized requesters. </span><span class="koboSpan" id="kobo.253.2">It is the basis for authorization management systems (more on this in the </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">next chapter).</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.255.1">Traceability</span></strong><span class="koboSpan" id="kobo.256.1">: This </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.257.1">criterion is a more recent one but becomes more and more important with regulations on IT systems; it states that the modification and use of data should be stored in a log that cannot be tampered with, allowing it to retrieve what happened back in time. </span><span class="koboSpan" id="kobo.257.2">Traceability is most important after an attack has happened to understand where the vulnerability was and what the attackers </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">have done.</span></span></li>
</ul>
<p><strong class="bold"><span class="koboSpan" id="kobo.259.1">Performance</span></strong><span class="koboSpan" id="kobo.260.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.261.1">robustness</span></strong><span class="koboSpan" id="kobo.262.1"> are</span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.263.1"> also so-called secondary features that have a high importance in MDM. </span><span class="koboSpan" id="kobo.263.2">They are</span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.264.1"> very much linked to the first criterion (availability). </span><span class="koboSpan" id="kobo.264.2">Indeed, the robustness of the software underpins its capacity to answer requests in time with great confidence, and performance is a quality associated with the availability of the data. </span><span class="koboSpan" id="kobo.264.3">After all, if someone gets a response to their request for</span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.265.1"> data after 5 minutes, they would not think of the service as being available, though it could be qualified as such since the data indeed arrived… at some point. </span><span class="koboSpan" id="kobo.265.2">Rapid availability of data has often been a drive to move existing “manual” information systems to a </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">software-oriented approach.</span></span></p>
<p><span class="koboSpan" id="kobo.267.1">Dealing with these features is the subject of many books, so we will just leave it there for now, since those are indeed responsibilities expec</span><a id="_idTextAnchor362"/><span class="koboSpan" id="kobo.268.1">ted from the </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">data referential.</span></span></p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor363"/><span class="koboSpan" id="kobo.270.1">Metadata and special kinds of data</span></h2>
<p><span class="koboSpan" id="kobo.271.1">Finally, the</span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.272.1"> data referential should handle data and also metadata. </span><span class="koboSpan" id="kobo.272.2">Metadata </span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.273.1">is all the information that sits around the data entities themselves and allows for a good comprehension of them. </span><span class="koboSpan" id="kobo.273.2">This provides some additional richness to the data, but please be aware that metadata should have a different life cycle from the data itself. </span><span class="koboSpan" id="kobo.273.3">For example, storing information about the history of data is not metadata, though it can abide by the definition of metadata just given. </span><span class="koboSpan" id="kobo.273.4">As has been exposed many times now, the data referential keeps track of every change in the entities it hosts. </span><span class="koboSpan" id="kobo.273.5">So, information about who changed what at what times is data and not metadata for a complete and correct data referential. </span><span class="koboSpan" id="kobo.273.6">In the same way, dates of changes, indicators of modification, or reading frequency can be directly deduced from the series of operations in the data referential, so they are not </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">metadata either.</span></span></p>
<p><span class="koboSpan" id="kobo.275.1">A good example of metadata is the units associated with numeric data. </span><span class="koboSpan" id="kobo.275.2">Having a number in a named attribute of the entity is often not enough. </span><span class="koboSpan" id="kobo.275.3">Sure, the attribute can have a name that describes its content and also the units (examples would be </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">populationInMillions</span></strong><span class="koboSpan" id="kobo.277.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">lengthInMillimeters</span></strong><span class="koboSpan" id="kobo.279.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">nbDaysBackupRotation</span></strong><span class="koboSpan" id="kobo.281.1">), but that does not make it any easier to manipulate the values and, in addition, that makes for longer names, which can be a bit cumbersome when the unit sounds obvious. </span><span class="koboSpan" id="kobo.281.2">Having metadata somewhere in the schema of the referential that states that </span><em class="italic"><span class="koboSpan" id="kobo.282.1">this</span></em><span class="koboSpan" id="kobo.283.1"> attribute of </span><em class="italic"><span class="koboSpan" id="kobo.284.1">this</span></em><span class="koboSpan" id="kobo.285.1"> entity uses </span><em class="italic"><span class="koboSpan" id="kobo.286.1">this</span></em><span class="koboSpan" id="kobo.287.1"> unit is a better way to communicate the handling of the data, and can also help in some modern database engines to directly calculate formulas between attributes that are not on the same scale of units, and even provide some warning when the formulas are not safe in terms of units definition, such as adding meters and seconds. </span><span class="koboSpan" id="kobo.287.2">These new servers generally use a standard definition of units that includes the powers in </span><strong class="bold"><span class="koboSpan" id="kobo.288.1">MKS</span></strong><span class="koboSpan" id="kobo.289.1"> form (short for </span><strong class="bold"><span class="koboSpan" id="kobo.290.1">meters, kilograms, and seconds</span></strong><span class="koboSpan" id="kobo.291.1">); this makes it possible to express almost any kind of scientific unit. </span><span class="koboSpan" id="kobo.291.2">For example, the Newton unit of force can be described as kg.m.s</span><span class="superscript"><span class="koboSpan" id="kobo.292.1">-2</span></span><span class="koboSpan" id="kobo.293.1">. </span><span class="koboSpan" id="kobo.293.2">When the unit metadata is well implemented, it also allows us to specify a multiplier and a name associated with the unit. </span><span class="koboSpan" id="kobo.293.3">For example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">kN</span></strong><span class="koboSpan" id="kobo.295.1"> unit is associated with M</span><span class="superscript"><span class="koboSpan" id="kobo.296.1">1</span></span><span class="koboSpan" id="kobo.297.1">K</span><span class="superscript"><span class="koboSpan" id="kobo.298.1">1</span></span><span class="koboSpan" id="kobo.299.1">S</span><span class="superscript"><span class="koboSpan" id="kobo.300.1">-2</span></span><span class="koboSpan" id="kobo.301.1"> as seen previously, but with a multiplier of 10</span><span class="superscript"><span class="koboSpan" id="kobo.302.1">^3</span></span><span class="koboSpan" id="kobo.303.1"> and the </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">name </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">kiloNewton</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">Geographical attributes are another good example of metadata addition to the usual data in a database. </span><span class="koboSpan" id="kobo.307.2">Generally, longitude and latitude were expressed as double-precision numbers in </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">lon</span></strong><span class="koboSpan" id="kobo.309.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">lat</span></strong><span class="koboSpan" id="kobo.311.1"> attributes, but this did not account for the kind of world-map projection (which can create some discrepancies in the number) and would not prevent silly computations such as adding the two numbers. </span><span class="koboSpan" id="kobo.311.2">With database or geographical servers able to understand the metadata added to the coordinates data, it is now possible to calculate distance, transpose coordinates from one projection system to another, and </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.313.1">Metadata is </span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.314.1">the long-forgotten </span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.315.1">cousin of data. </span><span class="koboSpan" id="kobo.315.2">Apart from CMIS, the standard for electronic document management systems, where they enjoy first-order citizenship (supporting groups of metadata implemented in schemas that can be applied to the documents, used in the queries when searching, and sometimes even versioned independently of the documents supporting them), there are not that many standards that formalize them. </span><span class="koboSpan" id="kobo.315.3">The evolution of this depends entirely on engineers who are interested in doing their jobs in a professional and clean manner. </span><span class="koboSpan" id="kobo.315.4">As long as “quick and dirty” tricks are used in the software programming and the structuring of information systems, metadata will continue to be set aside. </span><span class="koboSpan" id="kobo.315.5">When people – hopefully after reading this book and some others advising in the same quality and long-term approach – decide that the burden of the coupling is too high and they have to address the problem by modernizing their information system, metadata use should naturally rise, making it in time as standard and usual as any </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">other practice.</span></span></p>
<p><span class="koboSpan" id="kobo.317.1">Now that we know how the data referential should be defined, we will dive into how this can</span><a id="_idTextAnchor364"/><span class="koboSpan" id="kobo.318.1"> be provided by a </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">software system.</span></span></p>
<h1 id="_idParaDest-210"><a id="_idTextAnchor365"/><span class="koboSpan" id="kobo.320.1">The different kinds of data referential applications</span></h1>
<p><span class="koboSpan" id="kobo.321.1">We will not talk </span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.322.1">about technical aspects in this section (this is the role of the following one, called </span><em class="italic"><span class="koboSpan" id="kobo.323.1">Some architectural choices</span></em><span class="koboSpan" id="kobo.324.1">) but about architectural strategies to structure the </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">data persistence.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">In the previous chapter, the metaphor of the flower was introduced to show how data can be organized inside an entity. </span><span class="koboSpan" id="kobo.326.2">We will follow this idea to represent how persistence can be implemented in the data referential that manages instances of such an entity. </span><span class="koboSpan" id="kobo.326.3">Before we dive into the main architectures, please remember that the main criteria of choice should always remain functional, which, in the case of data, means that the life cycle in your system is what will drive you principally into this or that architectural choice. </span><span class="koboSpan" id="kobo.326.4">Also keep in mind that the </span><em class="italic"><span class="koboSpan" id="kobo.327.1">people</span></em><span class="koboSpan" id="kobo.328.1"> aspect of data management is as important as the </span><em class="italic"><span class="koboSpan" id="kobo.329.1">technical</span></em><span class="koboSpan" id="kobo.330.1"> aspect; governance, designation of people responsible, and good communication about which team owns which pieces of data are essential to the correc</span><a id="_idTextAnchor366"/><span class="koboSpan" id="kobo.331.1">t use of data in </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">your organization.</span></span></p>
<h2 id="_idParaDest-211"><a id="_idTextAnchor367"/><span class="koboSpan" id="kobo.333.1">Centralized architecture</span></h2>
<p><span class="koboSpan" id="kobo.334.1">The centralized (or “unique”) referential is the simplest one (as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.335.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.336.1">.2</span></em><span class="koboSpan" id="kobo.337.1">) that </span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.338.1">everybody first thinks of and that solves so many problems in the information system when it can be applied: it consists of having a single storage mechanism for every bit of data concerning a </span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.339.1">given type of entity (including, of course, history, metadata, and so on). </span><span class="koboSpan" id="kobo.339.2">This way, all services working in the system know that, when needing to read or write something, they have to address their request to a single repository service, as the whole “flower” is in one </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">well-known place.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer084">
<span class="koboSpan" id="kobo.341.1"><img alt="Figure 10.2 – Centralized data referential architecture" src="image/Figure_10.2_B21293.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.342.1">Figure 10.2 – Centralized data referential architecture</span></p>
<p><span class="koboSpan" id="kobo.343.1">The great thing about this approach is that it simplifies the work for everyone in the information system. </span><span class="koboSpan" id="kobo.343.2">Of course, this </span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.344.1">constitutes a </span><strong class="bold"><span class="koboSpan" id="kobo.345.1">single point of failure</span></strong><span class="koboSpan" id="kobo.346.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.347.1">SPOF</span></strong><span class="koboSpan" id="kobo.348.1">) and, if the implementing application is down, all applications needing this referential information will be impacted. </span><span class="koboSpan" id="kobo.348.2">But this is just a technical problem, with many battle-proven solutions such as active/active synchronization of the database, scaling of the application server, redundancy of hardware, and so on. </span><span class="koboSpan" id="kobo.348.3">By now, you should also be convinced that the functional aspects are </span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.349.1">always more important to take into account than the technical ones. </span><span class="koboSpan" id="kobo.349.2">As technicians, we tend to focus on low-occurrence problems such as hardware failure or a locked transaction, whereas the immensely </span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.350.1">greater problems in information systems nowadays are duplicates of data, poor cleanliness of the inputs, and other commonly observed issues that urgently need to be addressed. </span><span class="koboSpan" id="kobo.350.2">The SPOF might be more important in the people organization: a centralized data referential might mean that a single team or even a single person is in charge of the management of this set of data, and some drawbacks are always possible with too much centralization (feedback not taken into account, the re</span><a id="_idTextAnchor368"/><span class="koboSpan" id="kobo.351.1">lative obscurity of the </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">changes, etc.).</span></span></p>
<h2 id="_idParaDest-212"><a id="_idTextAnchor369"/><span class="koboSpan" id="kobo.353.1">Clone architecture</span></h2>
<p><span class="koboSpan" id="kobo.354.1">One way to address</span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.355.1"> this SPOF limitation is to locally copy some of the data that is needed by important applications. </span><span class="koboSpan" id="kobo.355.2">In this case, some applications will keep part of the “flower” in their own persistence system, and it is their choice to manage how fresh the data should be compared to the central referential, which remains the global single version of </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">the truth.</span></span></p>
<p><span class="koboSpan" id="kobo.357.1">When</span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.358.1"> the data is initially scattered around an information system, it can be a first step toward cleaning it, by obeying centralized business rules while still keeping the data as it was stored. </span><span class="koboSpan" id="kobo.358.2">The advantage is that, for legacy applications, nothing changes: they still consume the data locally, so all reading functions work as before. </span><span class="koboSpan" id="kobo.358.3">With some effort, writing commands can even be kept in the software – for example, by using database triggers that will implement a return of data to the unique referential. </span><span class="koboSpan" id="kobo.358.4">Most of the time, though, and particularly if the application is composable and has a unique graphical interface to create entities, it is easier to plug the referential GUI into this application instead of the </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">legacy form.</span></span></p>
<p><span class="koboSpan" id="kobo.360.1">The main difficulty with this approach is consistency: as there are several copies of data in the system, discrepancies can happen and it is thus important to keep them as reduced in time and impact as possible. </span><span class="koboSpan" id="kobo.360.2">If applications are well separated in function silos, it can end up being very easy, but if the way the application has been decomposed is bad, then you may have to implement distributed transactions, which can be quite complicated. </span><span class="koboSpan" id="kobo.360.3">Eventual consistency will be your friend in this situation, but it may not be </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">applicable everywhere.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">The most </span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.363.1">efficient form of the clone architecture is the following one, where the cloning of the data (only part of the flower, as only a partial set of the petals are normally useful) is synchronously based on events in the data referential and the data modification GUI has been replaced by the one coming from the centralized </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">data-managing application:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer085">
<span class="koboSpan" id="kobo.365.1"><img alt="Figure 10.3 – Cloned data referential, the most efficient form" src="image/Figure_10.3_B21293.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.366.1">Figure 10.3 – Cloned data referential, the most efficient form</span></p>
<p><span class="koboSpan" id="kobo.367.1">An option </span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.368.1">in this form is to add a synchronization mechanism for all the data, which compensates at night for messages of data change that could be skipped during the day due to network micro-failures or such low-frequency but still existing incidents if one does not want to put a</span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.369.1"> full-blown </span><strong class="bold"><span class="koboSpan" id="kobo.370.1">message-oriented middleware</span></strong><span class="koboSpan" id="kobo.371.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.372.1">MOM</span></strong><span class="koboSpan" id="kobo.373.1">) to work for this </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">simple stream.</span></span></p>
<p><span class="koboSpan" id="kobo.375.1">An alternative to the first form is when the synchronization connector uses an asynchronous, typically time-based mechanism to keep the clone database similar to the referential information. </span><span class="koboSpan" id="kobo.375.2">The best approach in this case is to call the data referential APIs, as they give the best quality </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">of information:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer086">
<span class="koboSpan" id="kobo.377.1"><img alt="Figure 10.4 – Cloned data referential, with asynchronous alternative" src="image/Figure_10.4_B21293.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.378.1">Figure 10.4 – Cloned data referential, with asynchronous alternative</span></p>
<p><span class="koboSpan" id="kobo.379.1">An </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.380.1">often-seen alternative (but I really do not recommend it) is to have an ETL perform the synchronization, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.381.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.382.1">.5</span></em><span class="koboSpan" id="kobo.383.1">. </span><span class="koboSpan" id="kobo.383.2">This</span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.384.1"> is often seen in companies that have invested lots of money in ETL to keep data in sync with their system and use this tool for everything. </span><span class="koboSpan" id="kobo.384.2">When there is an API (and every good data referential should have one), it is better to not couple ourselves directly on the data. </span><span class="koboSpan" id="kobo.384.3">Sadly, lots of companies still have this kind of stream in place, starting their own “spaghetti dish” of an information system, with all responsibilities and streams of data entangled and not clearly defined (see </span><a href="B21293_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.385.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.386.1"> for more explanation </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">on this).</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer087">
<span class="koboSpan" id="kobo.388.1"><img alt="Figure 10.5 – Cloned data referential, using an ETL (not recommended)" src="image/Figure_10.5_B21293.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.389.1">Figure 10.5 – Cloned data referential, using an ETL (not recommended)</span></p>
<p><span class="koboSpan" id="kobo.390.1">As explained </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.391.1">previously, some implementations cannot be changed and have to rely on their legacy GUI. </span><span class="koboSpan" id="kobo.391.2">In </span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.392.1">this case, the only possible approach is to rely on specific triggers on the database to get the creation and modification commands and send them as requests to the </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">MDM application:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer088">
<span class="koboSpan" id="kobo.394.1"><img alt="Figure 10.6 – Cloned data referential, with legacy GUI still in place" src="image/Figure_10.6_B21293.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.395.1">Figure 10.6 – Cloned data referential, with legacy GUI still in place</span></p>
<p><span class="koboSpan" id="kobo.396.1">The difficulty in this approach is when the data changes in the data referential due to some business rules, as the change cannot be sent back to the GUI. </span><span class="koboSpan" id="kobo.396.2">Indeed, most applications will keep the state of the data when they have submitted the change to their server. </span><span class="koboSpan" id="kobo.396.3">Even for the rare applications that listen to the returned data by their back office, the difficulty is that the complete roundtrip will not be finished before this reading, and the “updated” data will only be the latest in the local database, but not the latest that </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.397.1">will come back moments later from the webhook callback. </span><span class="koboSpan" id="kobo.397.2">When stuck in this situation, it is best to explain to the users that this is a temporary situation before reaching the centralized referential architecture and that they can refresh their GUI a bit later to see the effects of their change. </span><span class="koboSpan" id="kobo.397.3">Even better, learn how to use the new</span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.398.1"> centralized referential, which will always give them the freshest information, at the price of using two graphical interfaces instead of one (which is not such a high price when those are web applications that can be opened in two </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">browser tabs).</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.400.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.401.1">In </span><a href="B21293_08.xhtml#_idTextAnchor271"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.402.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.403.1">, we briefly talked about enterprise integration patterns. </span><span class="koboSpan" id="kobo.403.2">They are the ideal bricks to construct the synchronization connectors that we talked about previously, particularly </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.404.1">if a </span><strong class="bold"><span class="koboSpan" id="kobo.405.1">message-oriented middleware</span></strong><span class="koboSpan" id="kobo.406.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.407.1">MOM</span></strong><span class="koboSpan" id="kobo.408.1">) solution is put in place during the project of information syst</span><a id="_idTextAnchor370"/><span class="koboSpan" id="kobo.409.1">em reorganization/data </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">referential structuring.</span></span></p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor371"/><span class="koboSpan" id="kobo.411.1">Consolidated and distributed architectures</span></h2>
<p><span class="koboSpan" id="kobo.412.1">This type of</span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.413.1"> referential </span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.414.1">consists of exposing, from a central point of view (an API, generally), data that is actually placed into different parts of the information system. </span><span class="koboSpan" id="kobo.414.2">Generally, the core of the flower and some petals are in the data referential dedicated persistence. </span><span class="koboSpan" id="kobo.414.3">But for other petals, persistence can stay in the business applications they are associated with because it is considered they know the content of these petals better. </span><span class="koboSpan" id="kobo.414.4">In the most collaborative form of this approach, the referential exposes the full data for every actor of the information system and shares ownership of </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">the petals:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer089">
<span class="koboSpan" id="kobo.416.1"><img alt="Figure 10.7 – Consolidated referential architecture" src="image/Figure_10.7_B21293.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.417.1">Figure 10.7 – Consolidated referential architecture</span></p>
<p><span class="koboSpan" id="kobo.418.1">The</span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.419.1"> data referential can produce an entire flower of data through, and expose it in, its API but that means it </span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.420.1">has to consume the different petals it does not own from the business applications (keeping a local cache of these petals is a choice of implementation based on freshness, rate of change, and performance but does not change the ownership of the data). </span><span class="koboSpan" id="kobo.420.2">To expose the whole flower with fresh content, the data referential needs to have access to its own database, and also to the business applications data (or, again, the cache it may </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">keep locally).</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">Also, some applications, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">App2</span></strong><span class="koboSpan" id="kobo.424.1"> in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.425.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.426.1">.7</span></em><span class="koboSpan" id="kobo.427.1">, may not need anything other than the petal they own (notice that, of course, everyone has the core of the flower, by definition). </span><span class="koboSpan" id="kobo.427.2">Some applications, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">App1</span></strong><span class="koboSpan" id="kobo.429.1">, may need some additional petals, and in this case, they have to call the data referential API to obtain </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">this data.</span></span></p>
<p><span class="koboSpan" id="kobo.431.1">Another difference has been made in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.432.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.433.1">.7</span></em><span class="koboSpan" id="kobo.434.1"> to show that the data referential may use a business application API to obtain the data (best case) or may resort to direct access to the database of the business application, which causes more coupling but is sometimes the only way to go. </span><span class="koboSpan" id="kobo.434.2">The alternative shown on the right is dangerous and should not be applied: in this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">App3</span></strong><span class="koboSpan" id="kobo.436.1"> is not talked to but this is not the main problem. </span><span class="koboSpan" id="kobo.436.2">The actual issue is that using an ETL to feed the referential database should never be done, as this shortcuts the business and validation rules inside the data referential. </span><span class="koboSpan" id="kobo.436.3">No application should ever touch the referential database but the referential application itself. </span><span class="koboSpan" id="kobo.436.4">In fact, this rule is so important that, when deploying on-premises, it is a good practice to hide, obfuscate, deny access, or use any other possible way to prevent anyone from directly accessing a referential database. </span><span class="koboSpan" id="kobo.436.5">The results are already bad enough when this is a “normal” database, with its trail of coupling and other bad consequences; doing so on such an important database is the recipe </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">for problems.</span></span></p>
<p><span class="koboSpan" id="kobo.438.1">When the </span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.439.1">data referential </span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.440.1">exposes all the data possible on an entity (the complete “flower”), the architecture is also called “consolidated.” </span><span class="koboSpan" id="kobo.440.2">It is possible, in some cases, that some bits of data are only useful by the owner application and will not be of any use to anyone else. </span><span class="koboSpan" id="kobo.440.3">In this case, the term “consolidated” is not appropriate as some data is – willingly – not available, and the referential should be considered “distributed” only. </span><span class="koboSpan" id="kobo.440.4">Such a situation would be schematized </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer090">
<span class="koboSpan" id="kobo.442.1"><img alt="Figure 10.8 – Distributed referential architecture" src="image/Figure_10.8_B21293.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.443.1">Figure 10.8 – Distributed referential architecture</span></p>
<p><span class="koboSpan" id="kobo.444.1">The main</span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.445.1"> difficulty of a distributed referential architecture is to maintain performance. </span><span class="koboSpan" id="kobo.445.2">Optimizations are of course possible, such as the cache mechanism we talked about or the parallelism of calls to the different business applications when no cache is used, but all of these technical additions come with a price that should not be underestimated, particularly when we know that the situation is temporary and that the goal is a centralized architecture. </span><span class="koboSpan" id="kobo.445.3">It often happens that a “temporary” situation, supposedly cheaper and made as a stepping stone to the next architecture, actually costs as much as directly putting in place the target architecture. </span><span class="koboSpan" id="kobo.445.4">Most of the time, the decision comes from the fact that the difficulties of the target vision are well known, but the ones associated with the intermediate step are less envisioned, mostly because these unstable situations are numerous and thus not as well documented as the </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">final architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.447.1">Let me give</span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.448.1"> you an example of how hard it can be to set up an intermediate distributed system, by talking about the pagination of data. </span><span class="koboSpan" id="kobo.448.2">When calling the data referential API with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">$top=10</span></strong><span class="koboSpan" id="kobo.450.1"> query attribute, if the referential is distributed and consolidates data from two business applications, it will have to make two requests to the application, but the limiting thing is that, depending on the order of the data requested by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">$order</span></strong><span class="koboSpan" id="kobo.452.1"> attribute, there may be zero data coming from one source and 10 pieces from the other one, or the other way around, or any situation between these two extremes. </span><span class="koboSpan" id="kobo.452.2">This means that the gateway in charge of merging the data will have to take 10 lines from one application and 10 lines from the other, then re-apply an ordering algorithm on the 20 lines, finally sending the first 10 to the requesting client and discarding the following </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">10 lines.</span></span></p>
<p><span class="koboSpan" id="kobo.454.1">Do not</span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.455.1"> think it would be easier to use a local cache, as you would have to implement the query mechanism on it in addition to the ordering algorithm just talked about. </span><span class="koboSpan" id="kobo.455.2">Imagine if this has to be done with more applications! </span><span class="koboSpan" id="kobo.455.3">With 5 business applications, you already cache 50 lines in order to actually use only 10, which is an 80% waste of resources. </span><span class="koboSpan" id="kobo.455.4">You may think of pre-querying the applications in order to know which will provide data out of the filtered values, but that means you should already query one application and then adjust the counting querying to the other ones, maybe to realize that the optimization will not reduce the number of queries but only the number of lines retrieved. </span><span class="koboSpan" id="kobo.455.5">The choice of a pivot application may be difficult in itself for a resulting improvement that may be weak since we deal with reduced sets of data anyway (this is the goal of paginating the requests). </span><span class="koboSpan" id="kobo.455.6">Wait! </span><span class="koboSpan" id="kobo.455.7">We have not talked yet about the worst part of it: when paginating for the 10th page of data (between 90 and 100, if we stay on 10-line pages), you will not be able to simply call 10 lines from each of the 5 applications, because there may be one application that will account for almost all the lines in the order applied since the beginning of the pagination, and some others will provide nothing in the same range. </span><span class="koboSpan" id="kobo.455.8">This means that you may very well have the first result coming from an application only when calling the 10th page! </span><span class="koboSpan" id="kobo.455.9">You now see it coming, don’t you? </span><span class="koboSpan" id="kobo.455.10">Yes, we will have to query the 5 applications for 100 lines to extract the 10 lines corresponding to the 90 to 100 range of the aggregated data, which means a huge waste of 98%… and, the cherry on this sad cake is that, if an application does not support dynamic range, you will have to query it several times in order to compose the complete range of data needed. </span><span class="koboSpan" id="kobo.455.11">Sure, it may be possible with some implementations to keep cursors on the database queries in the state, but that means that your application is now stateful, and this will account for some other </span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.456.1">technical limitations in terms of scalability. </span><span class="koboSpan" id="kobo.456.2">Well, the only thing that will save us there is that, generally, the users will stop at the second or third page of data, refining their </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">$filter</span></strong><span class="koboSpan" id="kobo.458.1"> attribute to reach </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">quicker results.</span></span></p>
<p><span class="koboSpan" id="kobo.460.1">Consistency</span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.461.1"> problems also exist, but they are a bit easier to deal with as long as the cutting of data follows a functionally logical order. </span><span class="koboSpan" id="kobo.461.2">This is generally the case because the distribution of data is done in business applications, so the risk that they have duplicate data (apart from the core of the flower, </span><a id="_idTextAnchor372"/><span class="koboSpan" id="kobo.462.1">of course, which is always shared) is normally </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">very low.</span></span></p>
<h2 id="_idParaDest-214"><a id="_idTextAnchor373"/><span class="koboSpan" id="kobo.464.1">Other types of referential architectures</span></h2>
<p><span class="koboSpan" id="kobo.465.1">A “virtual” data referential </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.466.1">is a particular case</span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.467.1"> of a “distributed” referential where the central part simply holds no data by itself, and thus has no persistance, relying on the surrounding business applications databases. </span><span class="koboSpan" id="kobo.467.2">Schematically, this is the </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">following state:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer091">
<span class="koboSpan" id="kobo.469.1"><img alt="Figure 10.9 – Virtual referential architecture" src="image/Figure_10.9_B21293.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.470.1">Figure 10.9 – Virtual referential architecture</span></p>
<p><span class="koboSpan" id="kobo.471.1">Other, more exotic, referential architectures exist but it does not sound really useful to expose them here. </span><span class="koboSpan" id="kobo.471.2">For those of you who are curious, the French government-issued document called </span><em class="italic"><span class="koboSpan" id="kobo.472.1">Cadre Commun d’Architecture des Référentiels</span></em><span class="koboSpan" id="kobo.473.1"> (common framework for </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.474.1">referential architectures, freely available on the internet and in the French language) should not be a limitation, as the different possibilities are shown using </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">mainly diagrams.</span></span></p>
<p><span class="koboSpan" id="kobo.476.1">Now the architecture patterns have been shown, we can talk about the implementation itself, including what technical choices </span><a id="_idTextAnchor374"/><span class="koboSpan" id="kobo.477.1">should be made and how when creating the </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">data referential.</span></span></p>
<h1 id="_idParaDest-215"><a id="_idTextAnchor375"/><span class="koboSpan" id="kobo.479.1">Some architectural choices</span></h1>
<p><span class="koboSpan" id="kobo.480.1">One of the first is, of course, the database. </span><span class="koboSpan" id="kobo.480.2">By the way, I should even say the persistence mechanism because a database is a very well-known persistence mechanism, but there are others, as we will see at the end of this section. </span><span class="koboSpan" id="kobo.480.3">Some other technical considerations will have to be dealt with – in particular, on the streams </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">of data.</span></span></p>
<p><span class="koboSpan" id="kobo.482.1">This section</span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.483.1"> will also be an opportunity for a little rant about the dogmas in IT, and how they delay the long-awaited industrialization of information systems. </span><span class="koboSpan" id="kobo.483.2">Lots of technical choices remain based on the knowledge of the teams available rather than on the adequateness of the functional problem at hand. </span><span class="koboSpan" id="kobo.483.3">This is not to say that competencies should not be taken into account, but training should sometimes be forced on technical people who have not changed their way of thinking for decades and may hinder your information system development because they simply apply the wrong tool to the problem. </span><span class="koboSpan" id="kobo.483.4">You have likely heard the proverb “When all you have is a hammer, all problems look like nails.” </span><span class="koboSpan" id="kobo.483.5">If you have this kind of person in your team, a manager’s job is to open their eyes through </span><a id="_idTextAnchor376"/><span class="koboSpan" id="kobo.484.1">training, whether it be internal, external, formal, </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">or not.</span></span></p>
<h2 id="_idParaDest-216"><a id="_idTextAnchor377"/><span class="koboSpan" id="kobo.486.1">Tabular versus NoSQL</span></h2>
<p><span class="koboSpan" id="kobo.487.1">One of the </span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.488.1">very first decisions one has to make when implementing the data referential is the kind of database paradigm to use. </span><span class="koboSpan" id="kobo.488.2">Should it be tabular or document-oriented? </span><span class="koboSpan" id="kobo.488.3">SQL or NoSQL? </span><span class="koboSpan" id="kobo.488.4">Knowing that the natural shape of 99% of business entities is a document structure with many levels, like a tree of attributes and arrays with varying depth, the obvious choice if you want to reach business / IT alignment should be a NoSQL database, adapted to the shape of your data: document-based NoSQL if you manage business entities, or graph-based NoSQL if you manipulate data entities linked to other entities by many typed relationships, causing a network of entities that can be traversed by many paths, and </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.490.1">If one really</span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.491.1"> applies business/IT alignment and looks for a persistence mechanism that closely mimics the shape of their data, SQL tabular databases should be used for business entities that are naturally tabular… which is almost never! </span><span class="koboSpan" id="kobo.491.2">Sure, there are cases, just like there are some for key-value pair lists in the NoSQL domain, but they are very scarce. </span><span class="koboSpan" id="kobo.491.3">In fact, it looks like the main reason SQL is still largely used for the data referential is simply history. </span><span class="koboSpan" id="kobo.491.4">And this is a justified reason when dealing with legacy software… After all, if it has worked for years this way, you are better off not touching it. </span><span class="koboSpan" id="kobo.491.5">But the real problem is when a new data referential, designed during a project of information system modernization, also uses a </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">non-efficient approach.</span></span></p>
<p><span class="koboSpan" id="kobo.493.1">Why do I say </span><em class="italic"><span class="koboSpan" id="kobo.494.1">non-efficient</span></em><span class="koboSpan" id="kobo.495.1">? </span><span class="koboSpan" id="kobo.495.2">The history of computer science and databases should be invoked in order to explain why… In the old times of data storage, when spin disks were used with random-access controllers, data was not randomized in the magnetic disks but placed in sequences of blocks (preferably on the outermost lines of the hard disk, as the linear speed was higher, providing for quicker reads). </span><span class="koboSpan" id="kobo.495.3">In order to quickly access the right block, database engines would force the size of a line of data in order to quickly jump to the next, knowing the total length of each line of data in advance. </span><span class="koboSpan" id="kobo.495.4">This is why old types of strings in the database required a fixed length, by the way. </span><span class="koboSpan" id="kobo.495.5">This is also why the data has to be stored in tabular blocks, and structured data decomposed into many tables where lines are related to each other by keys, as this was the only way to calculate the next </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">block index.</span></span></p>
<p><span class="koboSpan" id="kobo.497.1">These assumptions came with a high price, though: since data was tabular, the only way to store multiple values for an attribute of an entity was to create another table in the database and join the two lines of data. </span><span class="koboSpan" id="kobo.497.2">The consequence of this was that complicated mechanisms were necessary to handle global consistency, such as transactions. </span><span class="koboSpan" id="kobo.497.3">In turn, transactions made it necessary to create the concepts of pessimistic and optimistic locks, then manage isolation levels for transactions (as the only fully </span><strong class="bold"><span class="koboSpan" id="kobo.498.1">ACID</span></strong><span class="koboSpan" id="kobo.499.1"> ones, which are the serializable transactions, have a dramatic impact on performance), then deadlock management and so many other </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">complicated things.</span></span></p>
<p><span class="koboSpan" id="kobo.501.1">When you think about it and realize that hard disk controllers have been providing randomized access for decades (and the very concept of a spinning disk does not exist in SSD), it is hard to understand why the consequences of this remain so pervasive today. </span><span class="koboSpan" id="kobo.501.2">One of the reasons is the change management, as nobody likes changing. </span><span class="koboSpan" id="kobo.501.3">But if there is a job where one should adapt and embrace change, that should definitely be a developer. </span><span class="koboSpan" id="kobo.501.4">I can also understand that SQL is still used in workshops where people only know this as a persistence technique. </span><span class="koboSpan" id="kobo.501.5">It is much better to start an important work with maybe not the best tool but one that is well known by </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.502.1">the whole team, and I would not advise starting with a complex technology that nobody knows. </span><span class="koboSpan" id="kobo.502.2">But in this particular case of not using NoSQL for a business entity data referential, there would be </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">two problems:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.504.1">First, this would be a training problem, as these technologies have been here for more than a decade now, and returns on experience are perfectly established, with </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">trustworthy operators.</span></span></li>
<li><span class="koboSpan" id="kobo.506.1">Second, there are actually few technologies as easy as document-based NoSQL. </span><span class="koboSpan" id="kobo.506.2">Take MongoDB, for example – writing a full-fledged JSON entity into a MongoDB-compatible database is as simple as follows (example </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">in C#):</span></span><pre class="source-code"><span class="koboSpan" id="kobo.508.1">
MongoDBConnection conn = new MongoDBConnection(ConnectionString);
conn.Insert("Actors", "{ 'lastName': 'Gouigoux', 'firstName': 'Jean-Philippe', 'addresses': [ { 'city': 'Vannes', 'zipCode': '56000' } ] }");</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.509.1">The equivalent with </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.510.1">an SQL-based tabular </span><strong class="bold"><span class="koboSpan" id="kobo.511.1">RDBMS</span></strong><span class="koboSpan" id="kobo.512.1"> (short for, </span><strong class="bold"><span class="koboSpan" id="kobo.513.1">Relational Database Management System</span></strong><span class="koboSpan" id="kobo.514.1">) is </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">the following:</span></span></p><pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.516.1">SQLConnection conn = new SQLConnection(ConnectionString);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.517.1">SQLTransaction transac = new SQLTransaction(conn);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.518.1">try {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.519.1">    transac.Begin();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.520.1">    SQLCommand comm = new SQLCommand(conn, "INSERT INTO ACTORS (lastName, firstName) VALUES (@lastName, @firstName)");</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.521.1">    Comm.Parameters.Add(new SQLParameter("@lastName", "Gouigoux"));</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.522.1">    Comm.Parameters.Add(new SQLParameter("@firstName", "Jean-Philippe"));</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.523.1">    string idActor = Comm.ExecuteGetId();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.524.1">    comm = new SQLCommand(conn, "INSERT INTO ADRESSES (id, city, zipcode) VALUES (@id, @city, @zipcode)");</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.525.1">    Comm.Parameters.Add(new SQLParameter("@id", idActor);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.526.1">    Comm.Parameters.Add(new SQLParameter("@city", "Vannes"));</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.527.1">    Comm.Parameters.Add(new SQLParameter("@zipcode", "56000"));</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.528.1">    Comm.Execute();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.529.1">    transac.Commit();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.530.1">} catch (Exception ex) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.531.1">    transac.Rollback();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.532.1">    throw new ApplicationException("Transaction was cancelled", ex);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.533.1">}</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.534.1">And I am not even talking about </span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.535.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.536.1">Data Definition Language</span></strong><span class="koboSpan" id="kobo.537.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.538.1">DDL</span></strong><span class="koboSpan" id="kobo.539.1">) commands to create the tables and columns, which would add many lines. </span><span class="koboSpan" id="kobo.539.2">MongoDB does not need any, as it is schemaless and collections are created as objects </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">are added.</span></span></p></li> </ul>
<p><span class="koboSpan" id="kobo.541.1">Again, there</span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.542.1"> are cases where SQL is needed. </span><span class="koboSpan" id="kobo.542.2">Reporting tools are very numerous using this grammar and it is good practice to expose SQL endpoint to access data, as it eases its consumption. </span><span class="koboSpan" id="kobo.542.3">Big data tools and even NoSQL databases have SQL endpoints. </span><span class="koboSpan" id="kobo.542.4">This is valuable as there are lots of people who are competent in using this way of interrogating data and computing complex aggregations. </span><span class="koboSpan" id="kobo.542.5">However, choosing a tabular database to store structured data just in order to be able to use a well-known query language is a problem, as it will cause lots of unwanted complexity. </span><span class="koboSpan" id="kobo.542.6">In your next data referential, please consider using NoSQL, as you will gain a lot of time with it. </span><span class="koboSpan" id="kobo.542.7">And if you know this kind of project will arrive next on your project portfolio, start getting training for your team. </span><span class="koboSpan" id="kobo.542.8">Only a few days are required to understand everything that is needed to be proficient with document-based NoSQL servers such as MongoDB, </span><a id="_idTextAnchor378"/><span class="koboSpan" id="kobo.543.1">and they are extremely well adapted to storing </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">business entities.</span></span></p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor379"/><span class="koboSpan" id="kobo.545.1">CQRS and event sourcing</span></h2>
<p><span class="koboSpan" id="kobo.546.1">While we </span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.547.1">are at it, you may also want to ditch your old data stream architectures where reading and writing are handled by the same process. </span><span class="koboSpan" id="kobo.547.2">After all, these two sets of operations are so different in their frequency (most </span><strong class="bold"><span class="koboSpan" id="kobo.548.1">Line Of Business</span></strong><span class="koboSpan" id="kobo.549.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.550.1">LOB</span></strong><span class="koboSpan" id="kobo.551.1">) applications have 80% of reads and 20% of writes), functions (no locks necessary for reading, consistency needed for writing), and performance (low importance for unique writing, very important for massive queries) that it sounds logical to </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">separate them.</span></span></p>
<p><span class="koboSpan" id="kobo.553.1">This is what </span><strong class="bold"><span class="koboSpan" id="kobo.554.1">Command and Query Responsibility Segregation</span></strong><span class="koboSpan" id="kobo.555.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.556.1">CQRS</span></strong><span class="koboSpan" id="kobo.557.1">) is about: it separates</span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.558.1"> the storage system receiving the commands for altering or creating the data from the system ready to answer queries on the same data. </span><span class="koboSpan" id="kobo.558.2">Event sourcing is closely associated with this architectural approach as it stores a series of business events generated by writing commands and lets the queries use this storage to get the aggregated results they need in a highly scalable way, thus allowing performance on </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">large data.</span></span></p>
<p><span class="koboSpan" id="kobo.560.1">In some way, CQRS could be thought of as a type of referential architecture between the distributed and the clone approaches. </span><span class="koboSpan" id="kobo.560.2">It does not separate data between applications with a criterion that is on the data itself, but rather on the kind of operation that is going to be performed on it (mainly, write or different kinds of reads). </span><span class="koboSpan" id="kobo.560.3">At the same time, the prepared reading servers can be considered as clones of the </span><em class="italic"><span class="koboSpan" id="kobo.561.1">single version of the truth</span></em><span class="koboSpan" id="kobo.562.1"> data. </span><span class="koboSpan" id="kobo.562.2">As their number can rise without any limit since the single version of the truth is in the main persistence, the performance can always be adjusted, however complex the queries and with high volumes </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.564.1">Again, this is not the place to discuss these subjects in detail but they had to be cited in a chapter about data referential and MDM, as they are th</span><a id="_idTextAnchor380"/><span class="koboSpan" id="kobo.565.1">e indisputable best approach to implementing </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">high-volume solutions.</span></span></p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor381"/><span class="koboSpan" id="kobo.567.1">One more step beyond databases – storing in memory</span></h2>
<p><span class="koboSpan" id="kobo.568.1">Let’s come back to our discussion about the origin of the tabular database system and even a bit before. </span><span class="koboSpan" id="kobo.568.2">Why</span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.569.1"> do we actually need database and storage systems? </span><span class="koboSpan" id="kobo.569.2">Mostly because hard disks can store more data than only RAM, and because databases would not fit in small amounts of RAM. </span><span class="koboSpan" id="kobo.569.3">Thus, it is necessary to have a system that is good at quickly putting data on disk (in order to keep it safe in case of hardware failure, the database first writes in the log files) and good at retrieving some parts of data from the disk and putting them back into memory for application use (this is the SQL part and, in particular, the role of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">SELECT</span></strong><span class="koboSpan" id="kobo.571.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">WHERE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.573.1"> keywords).</span></span></p>
<p><span class="koboSpan" id="kobo.574.1">Of course, this was a major problem when computers had 640 kilobytes of RAM and databases would need a few megabytes. </span><span class="koboSpan" id="kobo.574.2">But how about today? </span><span class="koboSpan" id="kobo.574.3">Sure, there are huge databases, but we commonly have databases with a few gigabytes only. </span><span class="koboSpan" id="kobo.574.4">And how about server RAM? </span><span class="koboSpan" id="kobo.574.5">Well, it is very common to have servers with tens of gigabytes, and it is easy to acquire online servers with 192 GB RAM. </span><span class="koboSpan" id="kobo.574.6">In this case, why is there a need for manipulating data in and out of the disks? </span><span class="koboSpan" id="kobo.574.7">Sure, SSD disks are some kind of memory, but they are still slower than RAM. </span><span class="koboSpan" id="kobo.574.8">Also, there is indeed this persistence under hardware failure that has to be taken care of. </span><span class="koboSpan" id="kobo.574.9">But how about the manipulation of data itself? </span><span class="koboSpan" id="kobo.574.10">Would the manipulation of queries into RAM not go </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">much quicker?</span></span></p>
<p><span class="koboSpan" id="kobo.576.1">In fact, it does and there is a rarely-used and scarcely-known technique called “object prevalence” that acts as an in-memory database. </span><span class="koboSpan" id="kobo.576.2">We are not talking about files stored in a RAM disk or a high-speed SSD, but having the data used directly in the object-oriented model of your application. </span><span class="koboSpan" id="kobo.576.3">How can we be sure not to lose any data if there is a hardware failure, you might ask? </span><span class="koboSpan" id="kobo.576.4">Well, exactly as a database does: by keeping a disk-based log of all the commands sent to the system. </span><span class="koboSpan" id="kobo.576.5">The difference then is that the reference model for manipulating data and extracting, filtering, and aggregating results is not on some tabular writing on the disk that has to be accompanied with indexes in order to improve performance, but directly in the RAM, and in a binary format that is the one directly used by your application, which means nothing can go faster. </span><span class="koboSpan" id="kobo.576.6">By doing so, requests in SQL are replaced by code in your language of choice – for example, C# with </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">LINQ queries.</span></span></p>
<p><span class="koboSpan" id="kobo.578.1">It is quite astonishing that object prevalence has never reached a wider audience but all the people I know who used it were convinced of its high value. </span><span class="koboSpan" id="kobo.578.2">Personally, when I need to implement a data referential that is limited in volume but has one of the following requirements, I always go for </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">this technology:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.580.1">High </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">performance required</span></span></li>
<li><span class="koboSpan" id="kobo.582.1">Very complex queries that would be hard to write </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">in SQL</span></span></li>
<li><span class="koboSpan" id="kobo.584.1">A data model that </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">evolves often</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.586.1">One of the best data referential implementations that I have participated in was on a project calculating advanced financial simulations and optimizing them with genetic algorithms; the performance boost was huge and the ability to write extremely complex cases of data manipulations made the whole project a clear win for the customer, who was surprised in the first test drives by the sheer velocity of the simulations – the old platform this one replaced provided results in minutes, whereas the new one responded in no more than a </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">few seconds.</span></span></p>
<p><span class="koboSpan" id="kobo.588.1">Another </span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.589.1">example of a successful implementation was in the handling of low-moving data such as country codes. </span><span class="koboSpan" id="kobo.589.2">In this particular example, people were not feeling great with the in-memory approach, even though data is safe in logs on the disk (and we even had a backup, as a third set of data for improved reassurance). </span><span class="koboSpan" id="kobo.589.3">So, testing this quite innovative approach with some data that they could easily feed back into the data referential made it more comfortable for a first try of the technology. </span><span class="koboSpan" id="kobo.589.4">The test went well, but the customer did not expand it to other data. </span><span class="koboSpan" id="kobo.589.5">Sadly, I do not know more examples of uses of this technology, which is a bit sad as the potential </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">was huge.</span></span></p>
<p><span class="koboSpan" id="kobo.591.1">Though this example may not be the best as this technology did not hit it off, the message still remains: in order to respect business/IT alignment, which is the best way to ensure long-term evolution, always favor a technology that closely fits your business needs and </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">data shape.</span></span></p>
<p><span class="koboSpan" id="kobo.593.1">In the last section of the book, we are going to talk again about time</span><a id="_idTextAnchor382"/><span class="koboSpan" id="kobo.594.1"> and how it influences what we do with data referential, in </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">our case.</span></span></p>
<h1 id="_idParaDest-219"><a id="_idTextAnchor383"/><span class="koboSpan" id="kobo.596.1">Patterns of data evolution in time</span></h1>
<p><span class="koboSpan" id="kobo.597.1">In </span><a href="B21293_04.xhtml#_idTextAnchor121"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.598.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.599.1">, we studied</span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.600.1"> the importance of time management in information systems, and one of the major impacts of time handling is on data. </span><span class="koboSpan" id="kobo.600.2">Data handled in MDM systems must be taken into account with the time factor, and we talked abundantly about data history mana</span><a id="_idTextAnchor384"/><span class="koboSpan" id="kobo.601.1">gement. </span><span class="koboSpan" id="kobo.601.2">But the very act of MDM should also be done according </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">to time.</span></span></p>
<h2 id="_idParaDest-220"><a id="_idTextAnchor385"/><span class="koboSpan" id="kobo.603.1">Data governance</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.604.1">Data governance</span></strong><span class="koboSpan" id="kobo.605.1"> is </span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.606.1">the act of establishing functional responsibilities around the management of data referential. </span><span class="koboSpan" id="kobo.606.2">Who is responsible for which reference data? </span><span class="koboSpan" id="kobo.606.3">Who can manipulate and clean the data? </span><span class="koboSpan" id="kobo.606.4">Who decides the evolution of the model? </span><span class="koboSpan" id="kobo.606.5">How are impacted teams and applications informed about changes? </span><span class="koboSpan" id="kobo.606.6">What business rules should be followed when manipulating the data? </span><span class="koboSpan" id="kobo.606.7">When should data be erased or archived? </span><span class="koboSpan" id="kobo.606.8">Those all are governance questions and they are always related to time. </span><span class="koboSpan" id="kobo.606.9">In particular, the responses have to be reviewed at regular periods, just like business processes, in order for the data to remain </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">under control.</span></span></p>
<p><span class="koboSpan" id="kobo.608.1">Data governance is mostly handled in the second layer of the Cigref map, which is the business capability map and usually contains a zone dedicated to reference data management. </span><span class="koboSpan" id="kobo.608.2">This is where you should draw the different data referentials, and store the detailed definition of the entities that are stored, along with the versions to prove compatibility between them or document incompatible changes. </span><span class="koboSpan" id="kobo.608.3">Here, you should also find at least the name and contact of two of the main data </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">governance roles:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.610.1">The data owner</span></strong><span class="koboSpan" id="kobo.611.1">: This </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.612.1">person is ultimately responsible for the quality and usability of the data inside the information system. </span><span class="koboSpan" id="kobo.612.2">They define all the business rules around the data: how it must be manipulated, who can access it, in which conditions, and </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">so on.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.614.1">The data steward</span></strong><span class="koboSpan" id="kobo.615.1">: Under </span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.616.1">the delegation of the data owner, this person is responsible for the daily maintenance of the data. </span><span class="koboSpan" id="kobo.616.2">Following data manipulation rules issued by the data owner, they clean data and ensure its availability and integrity, as well as the respect for </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">authorization rules.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.618.1">One of the obvious consequences of having data governance is that there is a clear responsibility for a given data referential. </span><span class="koboSpan" id="kobo.618.2">Having shared responsibility for a referential is a problem because there can be competing needs that evolve in an uncontrolled evolution of the entity’s format or the services provided. </span><span class="koboSpan" id="kobo.618.3">In the worst case scenario, the IT team does not know who to consider as the decider and implements both demands, making the data referential progressively harder to use and not fit for its purpose. </span><span class="koboSpan" id="kobo.618.4">Having no responsibility is even worse because, as the implementation belongs to the IT team, the technical people become, by default, the owners of the data, which may be the worst move ever as they do not have the best knowledge of the business stakes associated with the data. </span><span class="koboSpan" id="kobo.618.5">Sure, they basically know what the data is about (after all, we all know in a company what a customer is or a product) but again, the devil lies in the details, and when the IT team is in charge of defining data, no one should act surprised that organizations only support one address, or that there is no distinction between a product and an article. </span><span class="koboSpan" id="kobo.618.6">Such mistakes would never be made by a specialist in the subject, and we all know how destructive a bad entity definition can be. </span><span class="koboSpan" id="kobo.618.7">So leaving such business-driven decisions to the IT team because nobody wants to</span><a id="_idTextAnchor386"/><span class="koboSpan" id="kobo.619.1"> take ownership is a risky move and everyone should be warned </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">about this.</span></span></p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor387"/><span class="koboSpan" id="kobo.621.1">Progressive implementation of a unique referential</span></h2>
<p><span class="koboSpan" id="kobo.622.1">When </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.623.1">presenting</span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.624.1"> the distributed and consolidated data referential architectures, it has been stated that, sometimes, these intermediary steps toward a centralized referential (which, most of the time, is the ultimate goal) can cost as much as directly going to the target state because of hidden efforts or lesser-known shortcomings. </span><span class="koboSpan" id="kobo.624.2">On the contrary, there are times when directly addressing the final vision is impossible, and convergence toward this should be done in several progressive steps. </span><span class="koboSpan" id="kobo.624.3">This might be because the information system is so coupled that a violent move may destroy it; most of the time, the problem is with the human capacity to embrace change, and a progressive approach has to be followed for the organization itself to be able </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">to adjust.</span></span></p>
<p><span class="koboSpan" id="kobo.626.1">This has been the case for me in many situations where I consulted for companies who, in order to successfully manage their merger or acquisition of another company, needed to apply a merging program to the two information systems, incorporating them into a single system. </span><span class="koboSpan" id="kobo.626.2">This kind of thing generally takes years in big organizations (the quickest that I have ever witnessed was done in less than 18 months, but all flags were green, which rarely happens). </span><span class="koboSpan" id="kobo.626.3">As you will see in the following sections, these plans need numerous steps to </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">be realized.</span></span></p>
<p><span class="koboSpan" id="kobo.628.1">For privacy reasons, I will show a mix of two progressive transformations that I designed for a public customer (a fusion of two regional councils in France) and an agriculture cooperative that was born out of the merger of two giant entities in the West of France. </span><span class="koboSpan" id="kobo.628.2">Both of them needed to address the MDM of the individuals and legal entities that their information systems deal with (customers, agents, prospects, farmers, students, etc.). </span><span class="koboSpan" id="kobo.628.3">In order to simplify the diagrams, I will consider the starting point to be where the two entities each had a consolidated data referential, with some applications showing a clone referential pattern. </span><span class="koboSpan" id="kobo.628.4">This often happens when there are many applications needing referential data: the most important are directly plugged into the highest-level data referential application, and the secondary</span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.629.1"> applications are simply cloning what happens in their leading business application. </span><span class="koboSpan" id="kobo.629.2">In the following schema, I have also highly reduced the number of applications, again, for simplification reasons. </span><span class="koboSpan" id="kobo.629.3">I have not drawn the relationships between them and with other software in the information system, as they were mostly ERPs with </span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">much interoperability.</span></span></p>
<h3><span class="koboSpan" id="kobo.631.1">Step 1 – same infrastructure but no link</span></h3>
<p><span class="koboSpan" id="kobo.632.1">All this being </span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.633.1">said, the first step can be schematized </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">as this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer092">
<span class="koboSpan" id="kobo.635.1"><img alt="Figure 10.10 – Fusion of two MDM systems – step 1" src="image/Figure_10.10_B21293.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.636.1">Figure 10.10 – Fusion of two MDM systems – step 1</span></p>
<p><span class="koboSpan" id="kobo.637.1">The two companies have completely separate MDM systems, hence data referential for their “actors,” if this is the name we should use to describe the entities at play. </span><span class="koboSpan" id="kobo.637.2">Notice that most applications are different in each case, except for </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">App1</span></strong><span class="koboSpan" id="kobo.639.1">, which is a common ERP between the two companies (this does not mean it will be compatible, as versions may differ and customization definitely will, but this can make a good candidate to put things in common at some point). </span><span class="koboSpan" id="kobo.639.2">The very first step is, of course, to connect the two internal networks, even if everything that will be shown next could very well be applied by only communicating through </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">the Internet.</span></span></p>
<h3><span class="koboSpan" id="kobo.641.1">Step 2 – providing a common interface</span></h3>
<p><span class="koboSpan" id="kobo.642.1">The second</span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.643.1"> step was to provide all users in the new fusion entity with an API to </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">read actors:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer093">
<span class="koboSpan" id="kobo.645.1"><img alt="Figure 10.11 – Fusion of two MDM systems – step 2" src="image/Figure_10.11_B21293.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.646.1">Figure 10.11 – Fusion of two MDM systems – step 2</span></p>
<p><span class="koboSpan" id="kobo.647.1">Notice how symmetrical the diagram is: choosing a neutral pivotal format was of utmost importance, as using the proprietary format of one of the companies would have been a clear disadvantage to the other one (which would have to change all its connectors and mapping code) and this would have caused human problems, as tensions are always exacerbated during company fusions, particularly when they were previously competitors. </span><span class="koboSpan" id="kobo.647.2">We thus spent a lot of time crafting a nice pivotal format for the users, using the best data representations coming from both sides. </span><span class="koboSpan" id="kobo.647.3">At this step, not only is reading the sole operation available but no company can read the other’s data! </span><span class="koboSpan" id="kobo.647.4">You might wonder how useful this step is since the goal is to reach a unique MDM system for both companies and, for now, it does not change anything. </span><span class="koboSpan" id="kobo.647.5">In fact, it is indeed harder for no functional effect, but preparing a common pivotal format is the basis for adequately sharing data. </span><span class="koboSpan" id="kobo.647.6">Also, it provides a way for all new software functions that would be created during the fusion process to read actors in a standardized, fusion-ready way. </span><span class="koboSpan" id="kobo.647.7">This means we will not have to come back to these new applications, and this is much-appreciated news when you know hundreds of applications have to be dealt with in the whole project. </span><span class="koboSpan" id="kobo.647.8">Finally, it started the work on the mediation connectors (there again, this is the kind of thing that is best implemented in Apache Camel, or another flavor of enterprise integration patterns), which was an important piece of work, better started early in </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">the project.</span></span></p>
<h3><span class="koboSpan" id="kobo.649.1">Step 3 – merging data from the secondary source with the primary</span></h3>
<p><span class="koboSpan" id="kobo.650.1">From</span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.651.1"> now on, we will only represent the difference in streams from the point of view of company A, but the opposite is always true. </span><span class="koboSpan" id="kobo.651.2">The next step was to start obtaining some data from one information system and transferring it to the other. </span><span class="koboSpan" id="kobo.651.3">Again, this was very progressive: it was only done for the reading operations of the data for now and, as shown in the following diagram, the data was first read on the system of the person initiating the request, and then only completed with data “from the other side of the barrier.” </span><span class="koboSpan" id="kobo.651.4">At any time, the data from the originating side would win, except if the date of modification clearly showed that the data coming from the other information system </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">was fresher.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer094">
<span class="koboSpan" id="kobo.653.1"><img alt="Figure 10.12 – Fusion of two MDM systems – step 3" src="image/Figure_10.12_B21293.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.654.1">Figure 10.12 – Fusion of two MDM systems – step 3</span></p>
<p><span class="koboSpan" id="kobo.655.1">For this previous step to work, it was necessary to find a way to look for similar actors, for example, with their VAT number or other </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">business identifiers.</span></span></p>
<h3><span class="koboSpan" id="kobo.657.1">Step 4 – storing identifiers from the other source</span></h3>
<p><span class="koboSpan" id="kobo.658.1">Since this is a</span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.659.1"> complex operation to realize, once the correspondence was found, the technical identifier from one side was stored in the other, and vice versa, which will allow for quicker access next time. </span><span class="koboSpan" id="kobo.659.2">This was the first time the system would write in the MDM system, but this was limited to storing the identifier from the </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">other side:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer095">
<span class="koboSpan" id="kobo.661.1"><img alt="Figure 10.13 – Fusion of two MDM systems – step 4" src="image/Figure_10.13_B21293.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.662.1">Figure 10.13 – Fusion of two MDM systems – step 4</span></p>
<p><span class="koboSpan" id="kobo.663.1">However, this opened up</span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.664.1"> an entirely new approach to sharing data because, once the </span><em class="italic"><span class="koboSpan" id="kobo.665.1">write</span></em><span class="koboSpan" id="kobo.666.1"> authorizations were provided and the “external” identifier known, each side was able to share information with the </span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">other side.</span></span></p>
<h3><span class="koboSpan" id="kobo.668.1">Step 5 – sending information to the other side</span></h3>
<p><span class="koboSpan" id="kobo.669.1">Every time </span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.670.1">there was a change in the actor on one side, the other was informed. </span><span class="koboSpan" id="kobo.670.2">The receiving information system was free to deal with this information at its own pace, maybe doing nothing with it the first time, but then choosing which pieces of data were interesting and storing them, and so on. </span><span class="koboSpan" id="kobo.670.3">At this point, keeping the origin of the data change was necessary in order to not start a loop of information, sending back to the initial information system the event that the data changed because of its initial event. </span><span class="koboSpan" id="kobo.670.4">The diagram – once again represented only from A to B for simplicity reasons – was </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer096">
<span class="koboSpan" id="kobo.672.1"><img alt="Figure 10.14 – Fusion of two MDM systems – step 5" src="image/Figure_10.14_B21293.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.673.1">Figure 10.14 – Fusion of two MDM systems – step 5</span></p>
<p><span class="koboSpan" id="kobo.674.1">Now, since the initial write was started and information systems (and people) were starting to trust</span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.675.1"> each other better, the next step was to generalize the modification </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">of data.</span></span></p>
<h3><span class="koboSpan" id="kobo.677.1">Step 6 – centralizing the writing of data and extending the perimeter</span></h3>
<p><span class="koboSpan" id="kobo.678.1">This means</span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.679.1"> that both sides started to use the centralized API in writing and the implementation of this API was to push the data on both sides, in order for each information system to know about the latest data. </span><span class="koboSpan" id="kobo.679.2">Again, using the data depended on whether the </span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.680.1">receiving end knew the actor (or should record it) but, in some cases, data was simply ignored, for example, when this was about a change in a supplier that was only used in the other company. </span><span class="koboSpan" id="kobo.680.2">As for prospects, though, the data was shared because the commercial approach started to get unified between the two parts of the slowly emerging </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">fusion company.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer097">
<span class="koboSpan" id="kobo.682.1"><img alt="Figure 10.15 – Fusion of two MDM systems – step 6" src="image/Figure_10.15_B21293.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.683.1">Figure 10.15 – Fusion of two MDM systems – step 6</span></p>
<p><span class="koboSpan" id="kobo.684.1">The enterprise integration pattern used in the MOM implementation was a “duplicate message” one, sending the data pushed by the initial request in two similar messages to the mediation routes and waiting for both acknowledgment messages to come back in order to emit its own acknowledgment along the route it was called by, effectively creating a robust delivery of the change </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">both sides.</span></span></p>
<h3><span class="koboSpan" id="kobo.686.1">Step 7 – access unified</span></h3>
<p><span class="koboSpan" id="kobo.687.1">This was</span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.688.1"> the time when the old data referential started to act only as gatekeepers for the messages, checking that they were related to their side of the information system. </span><span class="koboSpan" id="kobo.688.2">But, since actors were now largely shared, this was not such an important feature, so some applications started to register their actors’ messages directly to the top </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">data referential:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer098">
<span class="koboSpan" id="kobo.690.1"><img alt="Figure 10.16 – Fusion of two MDM systems – step 7" src="image/Figure_10.16_B21293.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.691.1">Figure 10.16 – Fusion of two MDM systems – step 7</span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">App1</span></strong><span class="koboSpan" id="kobo.693.1"> (an ERP used on both sides) was a great candidate to start this new approach, as the mediation connector to it could directly be shared between the two information systems, making for the first common deployment, thus lowering the height of the “barrier.” </span><span class="koboSpan" id="kobo.693.2">Since this approach worked quite well, it was a kickstart for the rest of the applications and some dedicated connectors quickly appeared on the other application, which was easy since the common pivotal format had then evolved and was easier than the previous ones, also covering more </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">business cases.</span></span></p>
<h3><span class="koboSpan" id="kobo.695.1">Step 8 – eliminating unnecessary calls</span></h3>
<p><span class="koboSpan" id="kobo.696.1">The</span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.697.1"> situation rapidly evolved to something schematized as this, where the old MDM system basically had nothing more to do since all data was coming from the new </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">centralized one:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer099">
<span class="koboSpan" id="kobo.699.1"><img alt="Figure 10.17 – Fusion of two MDM systems – step 8" src="image/Figure_10.17_B21293.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.700.1">Figure 10.17 – Fusion of two MDM systems – step 8</span></p>
<p><span class="koboSpan" id="kobo.701.1">In addition, some</span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.702.1"> applications, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">App7</span></strong><span class="koboSpan" id="kobo.704.1">, had time to evolve and were able to directly take some JSON-representing actors without resorting to a mediation connector. </span><span class="koboSpan" id="kobo.704.2">Also, some applications started to be used in common between the two organizations (which clearly appeared more and more like becoming a single organization at this point), and </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">App4</span></strong><span class="koboSpan" id="kobo.706.1"> disappeared in favor of the common use </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">App6</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.710.1">Step 9 – removing unnecessary intermediate applications</span></h3>
<p><span class="koboSpan" id="kobo.711.1">Some “low strategy” applications </span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.712.1">remained under the control of business applications such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">App3</span></strong><span class="koboSpan" id="kobo.714.1">, but this was not a problem as their parent application was now under the main data referential and would deal with the change of format for them. </span><span class="koboSpan" id="kobo.714.2">These applications did not see any change in the system, which was great for their users, who were not impacted at all by the otherwise major change. </span><span class="koboSpan" id="kobo.714.3">The resulting information system started to look like </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer100">
<span class="koboSpan" id="kobo.716.1"><img alt="Figure 10.18 – Fusion of two MDM systems – step 9" src="image/Figure_10.18_B21293.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.717.1">Figure 10.18 – Fusion of two MDM systems – step 9</span></p>
<p><span class="koboSpan" id="kobo.718.1">Since </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">App6</span></strong><span class="koboSpan" id="kobo.720.1"> was used by all teams, the barrier between the two formerly separated companies went </span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.721.1">one more step down, reaching a point where it was not a problem, as it only divided some secondary business applications used in some corner cases by a dedicated team on activities that were not part of the fusion process. </span><span class="koboSpan" id="kobo.721.2">There was now a unique centralized MDM system, with a few important applications acting as local referential for actors on which secondary applications would clone some parts of data. </span><span class="koboSpan" id="kobo.721.3">This took many years in total but the objectives were reached: merging the actors used by both sides and doing this in </span><a id="_idTextAnchor388"/><span class="koboSpan" id="kobo.722.1">such a progressive way that the business was never affected by </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">technical choices.</span></span></p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor389"/><span class="koboSpan" id="kobo.724.1">Keeping an eye on dogma and useless complexity</span></h2>
<p><span class="koboSpan" id="kobo.725.1">I hope I have convinced you in this chapter (and in this book in general) to keep a critical eye on technologies and practices for which their use sounds obvious. </span><span class="koboSpan" id="kobo.725.2">As with SQL databases for data referential storage, or hard disk-based data manipulation, there are lots of preconceived approaches in the development itself that do not fit the problem very well when you think purely in business/IT </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">alignment terms.</span></span></p>
<p><span class="koboSpan" id="kobo.727.1">Just one example is data validation. </span><span class="koboSpan" id="kobo.727.2">In most programming languages, validators are associated with fields or properties of data entities, through attributes, for example, in C#. </span><span class="koboSpan" id="kobo.727.3">This approach is, in my opinion, very wrong and has proved several times in my practice to be a real pain as one will almost always find a particular case where these validating attributes are not correct. </span><span class="koboSpan" id="kobo.727.4">In the case of business identifiers, product owners would sometimes insist on the fact that no entity should ever be created without such a value, and then, within a year or so, realize that there is this particular case where the identifier is not known yet and we should still have the entity in the system. </span><span class="koboSpan" id="kobo.727.5">This can, for example, be the case with a medical patient database where the product owner will assure you that an entity without a social security number would make no sense as it is absolutely mandatory before even considering providing medication to them… After insisting on putting a strict </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">NOT NULL</span></strong><span class="koboSpan" id="kobo.729.1"> validator on this for data quality reasons, the same person may come back a few months later, when the database is in production and a major impact change would have a huge cost, telling you that they forgot the particular case of a newborn that should be given drugs but they do not have a social security </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">number yet.</span></span></p>
<p><span class="koboSpan" id="kobo.731.1">In this particular example, I have personally taken the habit of never describing any entity attribute as mandatory, as only the context of its use makes it mandatory or not. </span><span class="koboSpan" id="kobo.731.2">And it is so easy to add a business rule or a form behavior blocking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">null</span></strong><span class="koboSpan" id="kobo.733.1"> value that it really is not a problem to not put it on the entity itself. </span><span class="koboSpan" id="kobo.733.2">On the other hand, sorting out the mess when this mandatory characteristic has been implemented down the lowest levels of your information system is such a pain and a cause of errors that it is, in my opinion, never justified to call a field “mandatory” (except the one exception for a technical identifier, as there is otherwise no way to univocally retrieve an entity </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">once created).</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.735.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.736.1">I really like it when I read articles such as </span><a href="https://jonhilton.net/why-use-blazor-edit-forms/"><span class="koboSpan" id="kobo.737.1">https://jonhilton.net/why-use-blazor-edit-forms/</span></a><span class="koboSpan" id="kobo.738.1">, where the author questions there being “too much magic” in the technology exposed. </span><span class="koboSpan" id="kobo.738.2">Generally, there is, indeed, and such critical eyes are the best reads one can have on a given technology, rather than the numerous blog articles that simply explain how to use a function without digging into when it is useful and when it is actually more of a danger than a real advantage. </span><span class="koboSpan" id="kobo.738.3">This article really has a great point of view on validation included in forms and </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">data definitions.</span></span></p>
<p><span class="koboSpan" id="kobo.740.1">The same goes for cardinalities as for the identifiers cited previously, by the way: if you do not have the absolute, definitive, and fully responsible engagement of your product owner that an attribute should be with a zero or one cardinality, always make it as an array with </span><em class="italic"><span class="koboSpan" id="kobo.741.1">N</span></em><span class="koboSpan" id="kobo.742.1"> cardinality. </span><span class="koboSpan" id="kobo.742.2">What is the worst that could happen? </span><span class="koboSpan" id="kobo.742.3">The arrays always being filled with only one item? </span><span class="koboSpan" id="kobo.742.4">Well, that does not really matter, does it? </span><span class="koboSpan" id="kobo.742.5">A developer complaining that, on all these occasions, they must type </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">deliveryAddresses[0]</span></strong><span class="koboSpan" id="kobo.744.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">deliveryAddress</span></strong><span class="koboSpan" id="kobo.746.1">? </span><span class="koboSpan" id="kobo.746.2">Show them how to create a property in the language they used and it will be sorted out. </span><span class="koboSpan" id="kobo.746.3">As far as the GUI is concerned, we will simply display a single piece of information for as long as we do not have a use case corresponding to handling several values in the array. </span><span class="koboSpan" id="kobo.746.4">Only when this new business case appears, where we need to handle several pieces of data, will we adjust the GUI with a list instead of a single text zone, for example. </span><span class="koboSpan" id="kobo.746.5">But the great thing about this approach is that this will be done smoothly, as the previously unique data will simply become the first of the list, and much more importantly, all the clients of the API will remain compatible and will not be broken by this new use. </span><span class="koboSpan" id="kobo.746.6">They will even be able to continue using only the first piece of data in the list as long as they do not want to use the other ones and stick to the old behavior. </span><span class="koboSpan" id="kobo.746.7">Since all clients and the server can advance at their own pace on the business change, we know we have a </span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">low coupling.</span></span></p>
<p><span class="koboSpan" id="kobo.748.1">This extends to many other technical approaches that are supposed to help the business but, in the end, can hinder it. </span><span class="koboSpan" id="kobo.748.2">To name just a last example, most of the technical approaches to data robustness actually go against the business concepts. </span><span class="koboSpan" id="kobo.748.3">The outbox pattern (</span><a href="https://microservices.io/patterns/data/transactional-outbox.html"><span class="koboSpan" id="kobo.749.1">https://microservices.io/patterns/data/transactional-outbox.html</span></a><span class="koboSpan" id="kobo.750.1">), for example, should only be used when eventual consistency is not an option. </span><span class="koboSpan" id="kobo.750.2">But when you know that even banks have always used eventual consistency (and will definitely go on doing so in the future), that limits the usefulness of such techniques quite a lot. </span><span class="koboSpan" id="kobo.750.3">Of course, understanding the business in depth is less fun than using the latest technology or pattern that will drop your rate of transaction errors to a bare minimum. </span><span class="koboSpan" id="kobo.750.4">But it is the only way to win in the </span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">long term.</span></span></p>
<p><span class="koboSpan" id="kobo.752.1">So, once again, because this is such an important message, </span><strong class="bold"><span class="koboSpan" id="kobo.753.1">think of the business functions first and then find the technology that adapts to it</span></strong><span class="koboSpan" id="kobo.754.1">. </span><span class="koboSpan" id="kobo.754.2">In order to do so, the easiest way is to imagine what would happ</span><a id="_idTextAnchor390"/><span class="koboSpan" id="kobo.755.1">en in the real world between business actors if there were no </span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">computers involved.</span></span></p>
<h1 id="_idParaDest-223"><a id="_idTextAnchor391"/><span class="koboSpan" id="kobo.757.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.758.1">In this chapter, the principles of MDM have been applied and implementation techniques exposed, not only from the architectural point of view but also with technical choices that may prove useful when constructing a data referential. </span><span class="koboSpan" id="kobo.758.2">The main behaviors of such server applications have been covered and their evolution in time has been described with a few examples. </span><span class="koboSpan" id="kobo.758.3">This should make you quite knowledgeable about how to implement your own </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">data referential.</span></span></p>
<p><span class="koboSpan" id="kobo.760.1">We will come back to the subject of MDM in </span><a href="B21293_15.xhtml#_idTextAnchor548"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.761.1">Chapter 15</span></em></span></a><span class="koboSpan" id="kobo.762.1">, where we will go down to the lowest level of implementation, with actual lines of code and the design and development of two data referential implementations in C#, in order to deal with authors and with books, respectively. </span><span class="koboSpan" id="kobo.762.2">This will be the final piece where we will join the principles of service management and APIs learned about in </span><a href="B21293_08.xhtml#_idTextAnchor271"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.763.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.764.1">, the domain-driven design of the entities shown in </span><a href="B21293_09.xhtml#_idTextAnchor318"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.765.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.766.1">, and the architecture approaches described in the </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">present chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.768.1">But before we reach this point, we will study the two other parts of an ideal information system, just like we did here for the MDM part. </span><span class="koboSpan" id="kobo.768.2">The next chapter is about business process modeling and how we can use </span><strong class="bold"><span class="koboSpan" id="kobo.769.1">BPMN</span></strong><span class="koboSpan" id="kobo.770.1"> (short for, </span><strong class="bold"><span class="koboSpan" id="kobo.771.1">Business Process Modeling Notation</span></strong><span class="koboSpan" id="kobo.772.1">) and BPMN engines in order to implement business processes inside our information systems. </span><span class="koboSpan" id="kobo.772.2">Some other subjects such as middleware, no-code/low-code approaches, and orchestration versus choreography will be exposed in the next chapter </span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">as well.</span></span></p>
</div>
</body></html>