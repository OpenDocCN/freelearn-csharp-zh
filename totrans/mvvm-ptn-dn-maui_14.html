<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-218"><a id="_idTextAnchor238"/>14</h1>
<h1 id="_idParaDest-219"><a id="_idTextAnchor239"/>Troubleshooting and Debugging Tips</h1>
<p>Congratulations on making it this far in your journey to mastering the MVVM pattern in .NET MAUI! By now, you’ve learned about the intricacies of data binding, dependency injection, converters, and various other components that make up your <em class="italic">Recipes!</em> app. However, as any seasoned developer will tell you, even the most experienced experts encounter roadblocks from time to time.</p>
<p>MVVM, with all its benefits, can sometimes feel like navigating a complex maze. When you encounter issues, it’s not always obvious where to find the root cause or how to fix it. That’s where this chapter comes in. In this short but invaluable chapter, we’ll shine a light on common pitfalls and challenges you may face during your MVVM journey.</p>
<p>We’ll explore three areas where issues often tend to occur:</p>
<ul>
<li>Common data binding issues</li>
<li>Services and Dependency Injection pitfalls</li>
<li>Frequent custom control and converter problems</li>
</ul>
<p>Let’s get started on our journey through these common stumbling blocks. By the end of this chapter, you’ll be better equipped to troubleshoot and conquer the challenges that MVVM in .NET MAUI may throw your way.</p>
<h1 id="_idParaDest-220"><a id="_idTextAnchor240"/>Technical requirements</h1>
<p>To ensure you’re in sync with the upcoming content, make your way to our GitHub repository at <a href="https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter14">https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter14</a>. Kick off with the materials in the <code>Start</code> folder. And remember, if you’re ever in need of a consolidated reference, the <code>Finish</code> folder holds the final, refined code at the chapter’s close.</p>
<h1 id="_idParaDest-221"><a id="_idTextAnchor241"/>Common data binding issues</h1>
<p>One of the cornerstones<a id="_idIndexMarker919"/> of the MVVM pattern is data binding. It forms the link between your View and ViewModel, ensuring seamless communication between them. While data binding offers powerful capabilities, it’s also an area where developers often face challenges. This section aims to shed light on common data binding and ViewModel issues and how to troubleshoot them:</p>
<ul>
<li><strong class="bold">Typos and mismatched names</strong>: One of the simplest yet surprisingly common issues developers encounter is typos or mismatched property names. A small typo in your XAML markup or ViewModel code can disrupt the entire data binding process.</li>
<li><code>OneWay</code>, <code>TwoWay</code>, and <code>OneTime</code>, each with its own purpose, as we’ve seen in <a href="B20941_04.xhtml#_idTextAnchor069"><em class="italic">Chapter 4</em></a>, <em class="italic">Data Binding in .NET MAUI</em>. Using the wrong mode can lead to unexpected behavior in your app.</li>
<li><code>int</code> to a property of type <code>Color</code> on a UI control won’t work, despite XAML supporting implicit type conversion in certain cases.</li>
<li><code>PropertyChanged</code> events. What happens when these events don’t trigger as expected? The View will not be updated to reflect the changes in the ViewModel’s data.</li>
<li><code>ObservableCollection</code>. Make sure your collections update correctly and avoid the pitfall of inadvertently assigning a new <code>ObservableCollection</code>.</li>
<li><code>ListView</code> or <code>CollectionView</code>, keep in mind that each item in the collection creates its own data binding scope. This means that when attempting to bind a property or command that resides in the ViewModel rather than the individual item, you’ll need to use techniques such as relative or element binding to correctly reference the desired context.</li>
<li><strong class="bold">Data binding in behaviors</strong>: Behaviors exist outside the visual tree, which means they do not have the same capability for locating ancestors as other UI elements do.</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">Some of these pitfalls, such as typos in property names and binding incompatible data types, can be avoided by leveraging compiled bindings, as stipulated in <a href="B20941_04.xhtml#_idTextAnchor069"><em class="italic">Chapter 4</em></a>, <em class="italic">Data Binding in .</em><em class="italic">NET MAUI</em>.</p>
<p>As you can see, a lot of issues<a id="_idIndexMarker920"/> related to data binding can arise. Luckily, some of them aren’t that hard to spot and fix, as long as you know where to look. Let’s start off by looking at some tools in Visual Studio.</p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor242"/>Checking the Output and XAML Binding Failures window</h2>
<p>With both the <strong class="bold">Output</strong> window and <strong class="bold">XAML Binding Failures</strong> window<a id="_idIndexMarker921"/> in Visual Studio, typos or mismatched<a id="_idIndexMarker922"/> property names<a id="_idIndexMarker923"/> can easily<a id="_idIndexMarker924"/> be spotted. Here’s how:</p>
<ol>
<li>Let’s first introduce two faulty data binding statements in our code. On <code>RecipesOverviewPage</code>, update the <code>Image</code> and <code>Label</code> elements in the <code>CollectionView</code>’s <code>ItemTemplate</code>, as shown here:<pre class="source-code">
&lt;CollectionView.ItemTemplate&gt;
    &lt;DataTemplate&gt;
        ...
            &lt;Image
                Aspect="AspectFill"
                HorizontalOptions="Fill"
                <strong class="bold">Source="{Binding IsFavorite}"</strong>
                VerticalOptions="Fill" /&gt;
            ...
            &lt;Label
                Grid.Row="1"
                Margin="20,5,20,40"
                FontSize="16"
                HorizontalOptions="Fill"
                HorizontalTextAlignment="Start"
                MaxLines="2"
                <strong class="bold">Text="{Binding Titel}"</strong>
                TextColor="Black"
                VerticalOptions="Center" /&gt;
        ...
    &lt;/DataTemplate&gt;
&lt;/CollectionView.ItemTemplate&gt;</pre></li> <li>Run the app. While the app<a id="_idIndexMarker925"/> is running, head<a id="_idIndexMarker926"/> over to Visual Studio<a id="_idIndexMarker927"/> and open up the <strong class="bold">Output</strong> window. If it’s not already open, you can open<a id="_idIndexMarker928"/> it through <strong class="bold">Debug</strong> | <strong class="bold">Windows</strong> | <strong class="bold">Output</strong>. Notice the following:<pre class="source-code">
<strong class="bold">[0:] Microsoft.Maui.Controls.Xaml.Diagnostics.Binding</strong>
<strong class="bold">Diagnostics: Warning: 'False' cannot be converted to</strong>
<strong class="bold">type 'Microsoft.Maui.Controls.ImageSource'</strong>
<strong class="bold">[0:] Microsoft.Maui.Controls.Xaml.Diagnostics.Binding</strong>
<strong class="bold">Diagnostics: Warning: 'Titel' property not found on</strong>
<strong class="bold">'Recipes.Client.Core.ViewModels.RecipeListItemView</strong>
<strong class="bold">Model', target property: 'Microsoft.Maui</strong>
<code>bool</code> value cannot be converted to an <code>ImageSource</code> type. The second warning signals that a property named <code>Titel</code> cannot be found on the <code>RecipeListItemViewModel</code>. That, of course, is a typo!</p></li> <li>Alternatively, let’s have a look at the <strong class="bold">XAML Binding Failures</strong> window in Visual Studio. This can be opened through <strong class="bold">Debug</strong> | <strong class="bold">Windows</strong> | <strong class="bold">XAML Binding Failures</strong>. <em class="italic">Figure 14</em><em class="italic">.1</em> shows what this window looks like:</li>
</ol>
<div><div><img alt="Figure 14.1: XAML Binding Failures window" height="303" src="img/B20941_14_01.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1: XAML Binding Failures window</p>
<p class="list-inset">This window gives us the same information as the <strong class="bold">Output</strong> window. Additionally, it shows extra information such as where the failing binding statement is located and how many times this issue has occurred. The best thing about this window? When clicking on an item in this list, Visual Studio will open the XAML file where the faulty binding statement is located and will put the pointer on the exact data binding statement that contains the error.</p>
<p>Whenever you have<a id="_idIndexMarker929"/> a binding failure<a id="_idIndexMarker930"/> in your application, the <strong class="bold">XAML Binding Failures</strong> window and the <strong class="bold">Output</strong> window in Visual Studio<a id="_idIndexMarker931"/> will provide information<a id="_idIndexMarker932"/> about what went wrong. The <strong class="bold">XAML Binding Failures</strong> window, especially, provides immediate insight into typos, missing properties, or data type issues. Always keep an eye on this window when developing your views.</p>
<p>Another way to troubleshoot or debug data binding issues is by creating and leveraging a specialized converter. Let’s have a look!</p>
<h2 id="_idParaDest-223"><a id="_idTextAnchor243"/>Debugging with a DoNothingConverter</h2>
<p>A <code>DoNothingConverter</code> is an invaluable tool <a id="_idIndexMarker933"/>for debugging. By placing it in your binding pipeline, you can inspect<a id="_idIndexMarker934"/> the values being passed during the binding process. If you see unexpected values or none at all, it can help pinpoint where the breakdown occurs. Here’s the implementation of the <code>DoNothingConverter</code>:</p>
<pre class="source-code">
public class DoNothingConverter : IValueConverter
{
    public object Convert(object value,
        Type targetType, object parameter,
        CultureInfo culture)
    {
        // Break here to inspect value during debugging
        return value;
    }
    public object ConvertBack(object value,
        Type targetType, object parameter,
        CultureInfo culture)
    {
        // Break here to inspect value during debugging
        return value;
    }
}</pre> <p>To add and use this converter in your binding statements, follow these steps:</p>
<ol>
<li>Add a <code>DoNothingConverter</code> to the <code>Resources</code> of the page where you want to debug a binding statement. Here’s how<a id="_idIndexMarker935"/> we can add<a id="_idIndexMarker936"/> it to <code>RecipesOverviewPage</code>:<pre class="source-code">
&lt;ContentPage
    x:Class="Recipes.Mobile.RecipesOverviewPage"
    ...
    <strong class="bold">xmlns:conv="clr-namespace:</strong>
<strong class="bold">      Recipes.Mobile.Converters"</strong>
    ... &gt;
    &lt;ContentPage.Resources&gt;
        ...
        <strong class="bold">&lt;conv:DoNothingConverter</strong>
<strong class="bold">            x:Key="doNothingConverter" /&gt;</strong>
    &lt;/ContentPage.Resources&gt;
    ...
&lt;/ContentPage&gt;</pre></li> <li>Add the converter to the binding statement you want to debug, as shown here:<pre class="source-code">
&lt;Image
    ...
    <strong class="bold">Source="{Binding IsFavorite,</strong>
<strong class="bold">    Converter={StaticResource doNothingConverter}}"</strong>
    VerticalOptions="Fill" /&gt;
...
&lt;Label
    ...
    <strong class="bold">Text="{Binding Titel,</strong>
<strong class="bold">    Converter={StaticResource doNothingConverter}}"</strong>
    TextColor="Black"
    VerticalOptions="Center" /&gt;</pre></li> <li>Insert a breakpoint in the <code>Convert</code> or <code>ConvertBack</code> method of the <code>DoNothingConverter</code>.</li>
<li>If the breakpoint is hit during runtime, it indicates a successful binding to an existing property on the ViewModel. You’ll notice that the breakpoint in the <code>Convert</code> method will not be hit for the <code>Titel</code> binding as this property doesn’t exist.</li>
<li>If the breakpoint isn’t hit on subsequent updates of the property value, check the binding mode of the statement and ensure that the <code>PropertyChanged</code> method is triggered when the property gets updated.</li>
<li>When the breakpoint<a id="_idIndexMarker937"/> is hit, you can easily inspect the bound<a id="_idIndexMarker938"/> value and compare it to your expectations.</li>
<li>You can also examine the <code>targetType</code> parameter, which represents the type of the target property. Keep in mind that while XAML supports implicit type conversion in certain cases, it’s essential to be aware of the specific conversions supported.</li>
<li>The <code>ConvertBack</code> method should be called when the property on the UI controls is updated and the binding mode is set to <code>TwoWay</code> or <code>OneWayToSource</code>. If you expect this to work but the <code>ConvertBack</code> method is not called, check the binding statement’s binding mode.</li>
</ol>
<p>By following these steps and utilizing the <code>DoNothingConverter</code> tool, you can effectively troubleshoot<a id="_idIndexMarker939"/> data binding issues<a id="_idIndexMarker940"/> in your MVVM application.</p>
<p>Let’s discuss another cause of potential data binding issues: collections.</p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor244"/>Troubleshooting collections</h2>
<p>When working with<a id="_idIndexMarker941"/> collections, especially <code>ObservableCollection</code>, developers frequently<a id="_idIndexMarker942"/> encounter challenges related to updates and bindings.</p>
<p>If you’re using an <code>ObservableCollection</code> or any collection implementing the <code>INotifyCollectionChanged</code> interface, it’s usually assigned once during the initialization of your ViewModel. Here’s an important nuance to keep in mind: the setter for this property doesn’t trigger the <code>PropertyChanged</code> event. Instead, when you add or remove items from the collection, it triggers the <code>CollectionChanged</code> event on the collection instance. This event, in turn, updates the bound control, assuming it supports binding to <code>ObservableCollection</code>. To verify whether a specific control works well with the <code>INotifyCollectionChanged</code> interface, consult the control’s documentation.</p>
<p>However, there’s a critical point to be aware of: if the <code>ObservableCollection</code> is assigned anew, the binding will effectively be <em class="italic">lost</em>, unless, of course, the <code>PropertyChanged</code> event is properly raised. This means that if you reassign the entire collection with a new instance of <code>ObservableCollection</code>, you need to ensure that the <code>PropertyChanged</code> event is correctly triggered. To check whether this event is effectively raised, you can utilize the <code>DoNothingConverter</code>.</p>
<p>In contrast, when you’re working with a collection that doesn’t implement <code>INotifyCollectionChanged</code> (as in the case of a standard <code>List</code> or similar collections), adding or removing items won’t be automatically detected by the UI layer. In this scenario, the <code>PropertyChanged</code> event must be explicitly triggered when items are added to or removed from the collection. Consequently, the entire list will be re-rendered in the UI when you make changes.</p>
<p>When troubleshooting issues related to collections, pay close attention to whether you’re using <code>ObservableCollection</code> or non-observable collections, and ensure that you trigger the appropriate events to keep your ViewModel and UI in sync. Understanding these dynamics will help you navigate the complexities of collections in your MVVM application more effectively and prevent potential issues.</p>
<p>When working with collections, remember that you don’t need to trigger a <code>PropertyChanged</code> event on the collection itself when a property of an item within the collection changes. Instead, the key lies in raising the <code>PropertyChanged</code> event on the instance of the specific item that underwent modification. This ensures that the UI is notified of changes at the item level and reflects the updated state accurately. In essence, you’re focusing the update<a id="_idIndexMarker943"/> event precisely where it matters, minimizing unnecessary updates<a id="_idIndexMarker944"/> to the entire collection.</p>
<h2 id="_idParaDest-225"><a id="_idTextAnchor245"/>The data binding pitfall on Behaviors</h2>
<p>It’s very easy to oversee<a id="_idIndexMarker945"/> this while writing XAML, but relative source binding<a id="_idIndexMarker946"/> won’t work on Behaviors. That is because Behaviors exist outside the visual tree. In fact, a Behavior can even be reused by multiple UI elements, hence a relative source binding won’t be able to retrieve a parent object. When applying relative source binding to a Behavior, your app will crash, preceded by an exception of type <code>System.InvalidOperationException</code>. The exception states the following: <strong class="bold">Operation is not valid due to the current state of the object</strong>. This exception alongside this message should be an indication that there is a faulty data binding statement defined on a Behavior. There will be no further indication in the exception or in the <strong class="bold">Output</strong> window whatsoever. The only thing you can do is systematically go through the Behaviors in your code and look at their binding statements.</p>
<p>In many cases, the relative source binding can be replaced by element binding, as demonstrated here:</p>
<pre class="source-code">
&lt;!-- RelativeSource binding fails on Behaviors! --&gt;
&lt;toolkit:IconTintColorBehavior
    TintColor="{Binding IsFavorite,
    <strong class="bold">Source={RelativeSource AncestorType={x:Type local:</strong>
<code>RelativeSource</code> binding in the <code>IcontTintColorBehavior</code>. This can be bypassed<a id="_idIndexMarker947"/> by leveraging element binding, as shown<a id="_idIndexMarker948"/> in the next code block:</p>
<pre class="source-code">
&lt;ContentView
    ...
    <strong class="bold">x:Name="root"</strong>&gt;
    ...
        &lt;toolkit:IconTintColorBehavior
            TintColor="{Binding IsFavorite,
            <strong class="bold">Source={x:Reference root}</strong>,
            Converter=...}" /&gt;
    ...
&lt;/ContentView&gt;</pre> <p>Next, let’s discuss the things to look out for when workin<a id="_idTextAnchor246"/><a id="_idTextAnchor247"/>g with Dependency Injection.</p>
<h1 id="_idParaDest-226"><a id="_idTextAnchor248"/>Services and Dependency Injection pitfalls</h1>
<p>In your MVVM journey, DI plays<a id="_idIndexMarker949"/> a crucial role in providing essential functionality to your application. However, even in the world of DI, there can be pitfalls waiting to catch you off guard. This section is dedicated to unveiling the most common pitfalls and equipping you with the knowledge to navigate them effectively.</p>
<h2 id="_idParaDest-227"><a id="_idTextAnchor249"/>Unable to resolve service for type</h2>
<p>A <code>System.InvalidOperationException</code> stating <code>RecipesOverviewViewModel</code> in the DI container:</p>
<div><div><img alt="Figure 14.2: InvalidOperationException thrown" height="514" src="img/B20941_14_02.jpg" width="1089"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2: InvalidOperationException thrown</p>
<p>The exception gives you all the information you need as it clearly states what type is missing while trying to create a particular type.</p>
<p>Registering the missing<a id="_idIndexMarker951"/> dependency in the <code>MauiProgram</code> class (or anywhere you do your registrations) should fix the issue.</p>
<p>Let’s have a look at another common exception in the context of DI.</p>
<h2 id="_idParaDest-228"><a id="_idTextAnchor250"/>No parameterless constructor defined for type</h2>
<p>A <code>System.MissingMethodException</code> can be thrown in the following<a id="_idIndexMarker952"/> scenario:</p>
<ul>
<li>Shell is used to perform navigation</li>
<li>The BindingContext (a ViewModel) of a page is injected through the page’s constructor</li>
<li>The page isn’t registered in the DI container</li>
</ul>
<p>As long as a page doesn’t have any dependencies that need to be injected through the constructor, it doesn’t need to be registered in the DI container, as its default constructor is being used by Shell to instantiate the page. However, when the page has one or more dependencies, we need to register it in the DI container. That way, Shell can ask the container<a id="_idIndexMarker953"/> to resolve an instance of the needed page.</p>
<p>Registering the page in the DI container solves this issue.</p>
<p>A much more subtle pitfall when it comes to DI is not registering the services appropriately. Let’s have a look.</p>
<h2 id="_idParaDest-229"><a id="_idTextAnchor251"/>Incorrect service registration</h2>
<p>In the context of DI, one common pitfall<a id="_idIndexMarker954"/> stems from improperly registering services, leading to issues that can affect <a id="_idTextAnchor252"/><a id="_idTextAnchor253"/>your application’s functionality:</p>
<ul>
<li><strong class="bold">Resource intensiveness</strong>: If you register a service as transient when it should be a singleton, you may encounter resource-intensive behavior. This occurs because a new instance of the service is created every time it’s requested. For services that involve resource-intensive operations, such as establishing database connections or managing file handles, this frequent creation can lead to performance bottlenecks and resource exhaustion. Such issues can significantly impact your applica<a id="_idTextAnchor254"/><a id="_idTextAnchor255"/>tion’s performance and stability.</li>
<li><strong class="bold">Unintended shared state</strong>: Conversely, if you mistakenly register a service as a singleton when it should be transient, you may inadvertently introduce an unintended shared state. In this scenario, changes made to the service’s state or properties affect all parts of your application that depend on that service. This shared state can lead to unpredictable behavior and make debugging challenging, as the source of the problem may not be immediately apparent. It’s crucial to align the service’s registration with its intended usage to avoid such pitfalls.</li>
</ul>
<p>To mitigate these issues, carefully consider the intended scope and usage of each service during registration. Ensure that services requiring a single shared instance across your application are registered as singletons, while services that should have unique instances for each request are registered as transient. By making informed decisions about service registration, you can prevent these common pitfalls and ensure your application functions<a id="_idIndexMarker955"/> as intended.</p>
<p>In the final section, let’s have a look at common problems around custom controls and value converters.</p>
<h1 id="_idParaDest-230"><a id="_idTextAnchor256"/>Frequent custom control and converter problems</h1>
<p>Most of the issues<a id="_idIndexMarker956"/> that arise when working with custom controls regularly have to do with bindable properties. Often, a small typo or a little oversight might cause your custom control to not react as expected or to display the wrong data.</p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor257"/>Troubleshooting bindable properties</h2>
<p>On a custom control, there is a lot of ceremony<a id="_idIndexMarker957"/> needed to define bindable properties. It’s very easy to make a mistake<a id="_idIndexMarker958"/> that is very hard to spot when troubleshooting. Here are a couple of things to look out for:</p>
<ul>
<li>The <code>propertyName</code> parameter in the <code>Create</code> method: Make sure the <code>propertyName</code> parameter matches the exact naming of the property:<pre class="source-code">
public static readonly BindableProperty
  IsFavoriteProperty =
    BindableProperty.Create(<strong class="bold">nameof(IsFavorite)</strong>, …);
public bool <strong class="bold">IsFavorite</strong>
{
    ...
}</pre><p class="list-inset">As this code sample shows, it is advised to use the <code>nameof</code> expression to prevent typos!</p></li> <li>The <code>returnType</code> parameter in the <code>Create</code> method: The second parameter of the <code>BindableProperty</code>’s <code>Create</code> method is the <code>returnType</code>, which must match the type of the property:<pre class="source-code">
public static readonly BindableProperty
  IsFavoriteProperty =
    BindableProperty.Create(nameof(IsFavorite),
    <strong class="bold">typeof(bool)</strong>, …);
public <strong class="bold">bool</strong> IsFavorite
{
    ...
}</pre></li> <li>The <code>declaringType</code> parameter<a id="_idIndexMarker959"/> in the <code>Create</code> method: This parameter should be the type of the class<a id="_idIndexMarker960"/> where the property is defined:<pre class="source-code">
public partial class <strong class="bold">FavoriteControl</strong> : ContentView
{
    public static readonly BindableProperty
      IsFavoriteProperty =
            BindableProperty.Create(...
                <strong class="bold">typeof(FavoriteControl)</strong>,...);
public bool IsFavorite
{
    ...
}</pre></li> <li>It’s also important to make sure the getter and setter of the property call the <code>GetValue</code> and <code>SetValue</code>, passing in the correct <code>BindableProperty</code>:<pre class="source-code">
public static readonly BindableProperty <strong class="bold">IsFavoriteProperty</strong> = ...
public bool IsFavorite
{
    get =&gt; (bool)GetValue(<strong class="bold">IsFavoriteProperty</strong>);
    set =&gt; SetValue(<strong class="bold">IsFavoriteProperty</strong>, value);
}</pre></li> </ul>
<p>Whenever there is a discrepancy between the provided values in the <code>BindableProperty</code>’s <code>Create</code> method and the values on the control itself, or when the property doesn’t get or set the value<a id="_idIndexMarker961"/> correctly on the <code>BindableProperty</code>, the bindable property<a id="_idIndexMarker962"/> will not work as expected. So, it’s crucial to double-check these values!</p>
<h2 id="_idParaDest-232"><a id="_idTextAnchor258"/>Binding to the BindingContext</h2>
<p>As already stipulated in <a href="B20941_11.xhtml#_idTextAnchor182"><em class="italic">Chapter 11</em></a>, <em class="italic">Creating MVVM-Friendly Controls,</em> it is crucial that custom controls don’t depend<a id="_idIndexMarker963"/> on their <code>BindingContext</code>! The reason is that you can’t control that, as it is inherited from the parent the custom control is used on. Instead, you should<a id="_idIndexMarker964"/> only bind to the (bindable) properties that you’ve defined on the control itself. This can easily be achieved by leveraging relative or element binding, just like we did with the <code>FavoriteControl</code>:</p>
<pre class="source-code">
&lt;Image
        HeightRequest="{Binding HeightRequest,
            <strong class="bold">Source={x:Reference icon}</strong>}"
        IsVisible="{Binding IsInteractive,
            <strong class="bold">Source={RelativeSource AncestorType={x:Type</strong>
<strong class="bold">                local:FavoriteControl}}</strong>}"
        ... /&gt;</pre> <p>Any binding statements on a custom control that don’t have an explicit source set will bind to the <code>BindingContext</code> of the parent, which we don’t control. When a custom control works in one place but not in the other, chances are high that there is some binding going on that is not relative<a id="_idIndexMarker965"/> to the control itself. So, always double-check<a id="_idIndexMarker966"/> the binding statements in your custom control!</p>
<p>Finally, let’s have a quick look at the issues that might arise when working with value converters.</p>
<h2 id="_idParaDest-233"><a id="_idTextAnchor259"/>Value converter issues</h2>
<p>Converters play a crucial<a id="_idIndexMarker967"/> role in data transformation<a id="_idIndexMarker968"/> within your app. However, their logic might not always behave as expected. It’s a seemingly trivial issue, but one that is frequently underestimated. The solution? Simple yet powerful: write unit tests! In <a href="B20941_13.xhtml#_idTextAnchor223"><em class="italic">Chapter 13</em></a>, <em class="italic">Unit Testing,</em> we’ve highlighted how easy it is to unit test value converters. Paying attention to the logic within converters, testing them rigorously, and handling special cases will ensure that your converters perform reliably.</p>
<h1 id="_idParaDest-234"><a id="_idTextAnchor260"/>Summary</h1>
<p>Now that we’ve reached the end of this short chapter, I hope you’ve gained valuable insights and tips for effectively troubleshooting issues that can arise in an MVVM context. Remember, the road to mastering MVVM is an ongoing journey, and troubleshooting and debugging are indispensable companions on this path. These challenges, though sometimes frustrating, are valuable teachers that will deepen your understanding and proficiency in MVVM. Embrace them as opportunities to grow, and in doing so, you’ll become a more proficient and confident MVVM developer. Your journey doesn’t end here; it evolves with each issue you resolve.</p>
<p>As we wrap up this final chapter, I want to extend my heartfelt congratulations to you for completing this book’s journey into the world of MVVM in .NET MAUI. Throughout this book, you’ve delved into the intricacies of the MVVM pattern, explored the capabilities of .NET MAUI, and built your very own <em class="italic">Recipes!</em> app.</p>
<p>Once again, congratulations on your accomplishment, and may your MVVM and .NET MAUI journey continue to be rewarding and filled with exciting projects!</p>
<h1 id="_idParaDest-235"><a id="_idTextAnchor261"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the following resource:</p>
<p><em class="italic">XAML data binding </em><em class="italic">diagnostics</em>: <a href="https://learn.microsoft.com/en-us/visualstudio/xaml-tools/xaml-data-binding-diagnostics?view=vs-2022">https://learn.microsoft.com/en-us/visualstudio/xaml-tools/xaml-data-binding-diagnostics?view=vs-2022</a></p>
</div>
</div></body></html>