- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Best Practices in Coding C# 12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are the software architect on a project, it is your responsibility
    to define and/or maintain a coding standard that will direct the team to program
    according to the expectations of the company. This chapter covers some of the
    **best practices** in coding that will help developers like you program safe,
    simple, and maintainable software. It also includes tips and tricks for coding
    in **C#**. Although coding can be considered an art, writing understandable code
    is closer to a philosophy. In this chapter, we also discuss practices that you,
    as a software architect, need to propagate to your developers, with techniques
    and tools for code analysis, so that you have well-written code for your projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How the complexity of your code can affect performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of using a version control system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing safe code in C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET 8 tips and tricks for coding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying well-written code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C# 12** was launched together with **.NET 8**. However, the practices presented
    here can be used in many versions of .NET, since they refer to the basics of programming
    C#. By the end of the chapter, you will be able to define which tools you are
    going to incorporate into your software development life cycle to facilitate code
    analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires, at least, the Visual Studio 2022 free *Community Edition*.
  prefs: []
  type: TYPE_NORMAL
- en: The simpler your code, the better a programmer you are
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For many people, a good programmer is one who writes complex code. However,
    the evolution of maturity in software development means there is a different way
    of thinking about it. Complexity does not mean a good job; it means poor code
    quality. Some incredible scientists and researchers have confirmed this theory
    and emphasized that professional code needs to be focused on time, high quality,
    and budget.
  prefs: []
  type: TYPE_NORMAL
- en: Even when you have a complex scenario on your hands, if you reduce ambiguities
    and clarify the process of what you are coding, especially by using good names
    for methods and variables, which contribute to making your code “self-documented”
    and respect SOLID principles (**S**ingle Responsibility, **O**pen/Close, **L**iskov
    Substitution, **I**nterface Segregation, and **D**ependency Inversion), you will
    turn complexity into simple code.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you want to write good code, you need to keep the focus on how to do
    it, considering you are not the only one who will read it later. This is a good
    tip that changes the way you write code. This is how we will discuss each point
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your understanding of the importance of writing good code is aligned with
    the idea of simplicity and clarity while writing it, you should look at the Visual
    Studio tool known as **Code Metrics**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tela de celular com publicação numa rede social  Descrição gerada automaticamente](img/B19820_04_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Calculating code metrics in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Code Metrics** tool will deliver metrics that will give you insights
    regarding the quality of the software you are delivering. The metrics that the
    tool provides can be found at this link: [https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values](https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values).'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have run the code metrics analysis, you will need to interpret each
    metric presented. The following subsections focus on describing how a **maintainability
    index**, **cyclomatic complexity**, **depth of inheritance**, **class coupling**,
    and the **number of lines of code** are useful in some real-life scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability index
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The maintainability index represents a number from 0 to 100, which indicates
    how easy it is to maintain code – the easier the code, the higher the index. Easy
    maintenance is one of the key points to keeping software in good health. It is
    obvious that any software will require changes in the future since change is inevitable.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, consider refactoring your code to elevate the maintainability
    index if it currently has a low score. Writing classes and methods dedicated to
    a single responsibility, avoiding duplicate code, and limiting the number of lines
    of code of each method are examples of how you can improve the maintainability
    index.
  prefs: []
  type: TYPE_NORMAL
- en: Cyclomatic complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The creator of the cyclomatic complexity metric is Thomas J. McCabe. He defines
    the complexity of a software function according to the number of **code paths**
    available (**graph nodes)**. The more paths you have, the more complex your function
    is. McCabe considers that each function must have a complexity score of less than
    10\. That means that if the code has more complex methods, you must refactor it,
    transforming parts of the code into separate methods. There are some real scenarios
    where this behavior is easily detected:'
  prefs: []
  type: TYPE_NORMAL
- en: Loops inside loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lots of consecutive `if-else` statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`switch` with code processing for each case inside the same method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance, look at the first version of this method for processing different
    responses to a credit card transaction. As you can see, the cyclomatic complexity
    is bigger than the number considered by McCabe as a basis. The reason why this
    happens is because of the number of `if-else` statements inside each case of the
    main switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you calculate the code metrics of this code, you will find a bad result when
    it comes to cyclomatic complexity, as you can see in the following screenshot.
    A cyclomatic complexity number above 10 indicates that the code is difficult to
    read, and a developer will probably have trouble maintaining it in a future code
    change.
  prefs: []
  type: TYPE_NORMAL
- en: '![Interface gráfica do usuário, Aplicativo  Descrição gerada automaticamente](img/B19820_04_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: High level of cyclomatic complexity'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to reinforce that the purpose of the code from this example
    is not the focus here. The point here is to show you the number of improvements
    that can be made to write better code:'
  prefs: []
  type: TYPE_NORMAL
- en: The options from `switch-case` could be written using `Enum`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each `case` processing can be done:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a specific method.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In a specific class, inheriting the action from the superclass, using the polymorphism
    concept.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In a specific class, implementing an interface to define a contract.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`switch-case` can be substituted with `Dictionary<Enum, Method>` or by using
    the `switch` expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By refactoring this code with the preceding techniques, the result is a piece
    of code that is much easier to understand, as you can see in the following code
    snippet of its main method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using the `switch` expression available since C# 8.0, the code can be even simpler!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The full code can be found in the GitHub repository of this chapter at [https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E)/tree/main/ch04
    and demonstrates how lower-complexity code can be achieved. The following screenshot
    shows these results according to Code Metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B19820_04_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Cyclomatic complexity reduction after refactoring'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, there is a considerable reduction
    in complexity after refactoring. In *Chapter 5*, *Implementing Code Reusability
    in C# 12*, we will discuss the importance of refactoring for code reuse. The reason
    we are doing this here is the same – we want to eliminate duplication. It is important
    to remember that when you are refactoring code, you are writing it in a better
    way while respecting the input and output data that this code will process.
  prefs: []
  type: TYPE_NORMAL
- en: The key point here is that with the applied techniques, our understanding of
    the code increased and the complexity index decreased, thus proving the importance
    of cyclomatic complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Depth of inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This metric represents the number of classes inherited by the one that is being
    analyzed. The more classes you have inherited, the worse the metric will be. This
    is like class coupling and indicates how difficult it is to change the code of
    this class without impacting other ones, which neglects the Open/Close principle
    stated by SOLID. For instance, the following screenshot shows four inherited classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagrama  Descrição gerada automaticamente](img/B19820_04_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Depth of inheritance sample'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see in the following screenshot that the deepest class has the worst
    metric, considering there are three other classes that can change its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B19820_04_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Depth of inheritance metric'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance is one of the basic object-oriented analysis principles. However,
    it can sometimes be bad for your code in that it can cause dependencies. So, if
    it makes sense to do so, consider using composition or aggregation instead of
    inheritance, as we will explain in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Class coupling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you connect too many classes in a single class, obviously you will get
    tight coupling, and changing a participant causes unintended consequences in others.
    For sure, this can cause bad maintenance of your code, resulting in bugs that
    will make you spend more time trying to deliver a great solution. For instance,
    refer to *Figure 4.6*. It shows a design where aggregation has been performed
    a lot. There is no sense to the code itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagrama  Descrição gerada automaticamente](img/B19820_04_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Class coupling example'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have calculated the code metrics for the preceding design, you will
    see that the number of class coupling instances for the `ProcessData()` method,
    which calls `ExecuteTypeA()`, `ExecuteTypeB()`, and `ExecuteTypeC()`, equals three:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B19820_04_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Class coupling metric'
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft suggests that the maximum number of class coupling instances should
    be nine, as presented at [https://learn.microsoft.com/en-us/visualstudio/code-quality/code-metrics-class-coupling?view=vs-2022](https://learn.microsoft.com/en-us/visualstudio/code-quality/code-metrics-class-coupling?view=vs-2022).
  prefs: []
  type: TYPE_NORMAL
- en: With composition/aggregation being a better practice than inheritance, and since
    you will decouple code written from your class, the use of interfaces will solve
    class coupling problems. For instance, the same code with the following design
    will give you a better result. Although the interface is not strictly required
    for this example, its usage enables us to evolve the solution for other **execution
    types** without impacting the classes already written, since you are not using
    inheritance to solve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_04_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Reducing class coupling'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that using the interface in the design will allow you to increase the
    number of execution types without increasing the class coupling of the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_04_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Class coupling results after applying aggregations'
  prefs: []
  type: TYPE_NORMAL
- en: As a software architect, you must design your solution to have more cohesion
    than coupling. The literature indicates that good software has low coupling and
    high cohesion. In software development, high cohesion indicates that each class
    has its methods and data, with good relationships between them. Conversely, low
    coupling indicates that classes are not closely and directly connected. This is
    a basic principle that can guide you to a better architectural model.
  prefs: []
  type: TYPE_NORMAL
- en: Number of lines of code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This metric is useful in terms of making you understand the size of the code
    you are dealing with. There is no way to connect the number of lines of code and
    complexity, since the number of lines is not indicative of that. Conversely, the
    number of lines of code does show the software size and software design. For instance,
    if you have too many lines of code in a single class (more than 1,000 lines of
    code – 1 KLOC), this indicates that it is a bad design. Besides, if a class has
    too many methods, it obviously violates the Single Responsibility principle from
    SOLID.
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio 2022, this metric was divided into **lines of source code**
    and **lines of executable code**. The first indicates the exact number of source
    lines, including blank lines. Conversely, the second one estimates the number
    of executable code lines.
  prefs: []
  type: TYPE_NORMAL
- en: As a software architect, you have the objective of delivering to your programmers
    a list of best practices that will enable each of them to improve their techniques
    for developing good software. Make sure they know the exact impacts of not achieving
    good metric results in their code. The metrics presented above are certainly a
    great way to start to achieve this objective. But let us see how using a version
    control system can be the difference between amateur and professional software
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Using a version control system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may find this topic a bit obvious, but many people and companies still do
    not regard a version control system as an essential tool for software development.
    A common reason why version control systems are not considered a priority, particularly
    in some situations, is the belief that they are unnecessary for solo coding projects
    or for study purposes. You may think that a version control system is only needed
    by teams inside companies. The purpose of addressing this is to force you to understand
    our point. There is no architectural model or best practice that can save software
    development if you do not use a **version control system**.
  prefs: []
  type: TYPE_NORMAL
- en: In the last few years, we have been enjoying the advantages of online version
    control systems, such as Azure DevOps, GitHub, and Bitbucket. The fact is, you
    must have a version control system in your software development life cycle, and
    there is no reason not to have one anymore, since most providers offer free versions
    for small groups. Even if you develop by yourself, these tools are useful for
    tracking your changes, managing your software versions, and guaranteeing the consistency
    and integrity of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with version control systems in teams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The reason for using a version control system tool when you are alone is obvious.
    You want to keep your code safe. However, this kind of system was developed to
    solve team problems while writing code. For this reason, some features, such as
    branching and merging, were introduced to keep code integrity even in scenarios
    where the number of developers is quite large.
  prefs: []
  type: TYPE_NORMAL
- en: As a software architect, you will have to decide which branch strategy you will
    conduct in your team. Microsoft and GitHub suggest different ways to deliver that,
    and both are useful in some scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Information about how the Microsoft teams deal with DevOps can be found here:
    [https://learn.microsoft.com/en-us/devops/develop/how-microsoft-develops-devops](https://learn.microsoft.com/en-us/devops/develop/how-microsoft-develops-devops).
    The branching strategy presented in this article describes an approach where a
    branch is created for each release. They call it **the release flow**. The big
    difference here is that the master branch is not continuously deployed to production.'
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, GitHub describes its process at [https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/).
    This process is called **GitHub flow** and can be defined as a lightweight, branch-based
    workflow, where each development is created in a specific branch that will be
    reviewed by collaborators as soon as a pull request is created for feedback. As
    soon as the pull request is approved, the new code is merged to a master branch,
    so you can delete the development branch created before.
  prefs: []
  type: TYPE_NORMAL
- en: It is your choice; decide on the one that best fits your needs, but we do want
    you to understand that you need to have a strategy for controlling your code.
    In *Chapter 8*, *Understanding DevOps Principles and CI/CD*, we will discuss this
    in more detail. But now, let us see how to write safe code using C# so that you
    can develop a list of best practices to be shared with your developers.
  prefs: []
  type: TYPE_NORMAL
- en: Writing safe code in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# can be considered a safe programming language by design. Unless you force
    it, there is no need for pointers, and memory release is, in most cases, managed
    by the garbage collector. Even so, some care should be taken so that you can get
    better and safer results from your code. Let us have a look at some common practices
    to ensure safe code in C#.
  prefs: []
  type: TYPE_NORMAL
- en: try-catch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exceptions in coding are so frequent that you should have a way to manage them
    whenever they happen. `try-catch` statements are built to manage exceptions, and
    they are important for keeping your code safe. Be careful when they happen, since
    they can cause performance issues, as we discussed in *Chapter 2,* *Non-Functional
    Requirements*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a lot of cases where an application crashes, and the reason for that
    is the lack of using `try-catch`. The following code shows an example of the lack
    of usage of the `try-catch` statement. It is worth mentioning that this is just
    an example of understanding the concept of an exception thrown without correct
    treatment. Consider using `int.TryParse(textToConvert, out int result)` to handle
    cases where a parse is unsuccessful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Conversely, bad `try-catch` usage can cause damage to your code too, especially
    because you will not see the correct behavior of that code and may misunderstand
    the results provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows an example of an empty `try-catch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`try-catch` statements must be connected to logging solutions so that you can
    have a response from the system that will indicate the correct behavior and, at
    the same time, not cause application crashes. The following code shows an ideal
    `try-catch` statement with logging management. It is worth mentioning that specific
    exceptions should be caught whenever possible, since catching a general exception
    will hide unexpected exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It is very important to note that exceptions are, computationally speaking,
    expensive. No matter whether you are throwing them to indicate an error or catching
    them to manage errors, it takes a lot of computational processing. So, it is common,
    and preferable, to rely on a higher-level exception handler instead of trying
    to handle everything everywhere, as the code might become hard to reason about,
    particularly if there is not a good action to take when an exception happens.
    That means you may not handle the exceptions in every method, especially if you
    do not know what to do with them at that part of the code and you will throw it
    again to a higher-level handle. You should prioritize handling exceptions where
    meaningful actions can be taken.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is also worth mentioning that exception errors delivered to the
    end user can cause the feeling that bad software was delivered. As a software
    architect, you should conduct code inspections to define the best behavior for
    code. Instability in a system, like unexpected crashes and high-memory usage,
    is often connected to the lack of `try-catch` statements in code.
  prefs: []
  type: TYPE_NORMAL
- en: try-finally and using
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Memory leaks* can be considered one of the worst software behaviors. They
    cause instability, bad usage of computer resources, and undesired application
    crashes. C# tries to solve this with **Garbage Collector**, which automatically
    releases objects from memory as soon as it realizes an object can be freed. The
    trigger for Garbage Collector is well explained at [https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals](https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Objects that interact with I/O are the ones that generally are not managed
    by Garbage Collector: the filesystem, sockets, and so on. The following code is
    an example of the incorrect usage of a `FileStream` object because it thinks Garbage
    Collector will release the memory used, but it will not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides, it takes a while for Garbage Collector to interact with objects that
    need to be released, and sometimes, you may want to do it yourself. For both cases,
    the use of `try-finally` or `using` statements is the best practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows exactly how to deal with objects that are not managed
    by Garbage Collector. Both `try-finally` and `using` are implemented. As a software
    architect, you do need to pay attention to this kind of code. The lack of `try-finally`
    or `using` statements can cause huge damage to software behavior when it is running.
    It is worth mentioning that using code analysis tools, such as **Sonar Lint**
    and **Code Analysis**, will automatically alert you to these sorts of problems.
  prefs: []
  type: TYPE_NORMAL
- en: The IDisposable interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the same way that you will have trouble if you do not manage objects created
    inside a method with `try-finally`/`using` statements, objects created in a class
    that does not properly implement the `IDisposable` interface may cause memory
    leaks in your application. For this reason, when you have a class that deals with
    and creates objects, you should implement the `Disposable` pattern to guarantee
    the release of all resources created by the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B19820_04_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: IDisposable interface implementation'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once you have inserted the code, you need to follow the to-do instructions so
    that you have the correct pattern implemented.
  prefs: []
  type: TYPE_NORMAL
- en: As a software architect, you will be responsible not only for the architecture
    defined in a system but also for how this system performs in operation. Memory
    leaks and bad performance, in general, are caused by errors related to the `try-catch`
    strategy, a lack of `try-finally/using`, and wrong or no implementation of `IDisposable`.
    So be sure that your team knows how to deal with these techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have covered some important information about how to write safe code
    in C#, it would be nice to get some tips and tricks for coding in this programming
    language. Let us do so in the next topic of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: .NET 8 tips and tricks for coding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET 8 implements some good features that help us to write better code. One
    of the most useful things for having cleaner code is **dependency injection**
    (**DI**), which will be discussed in *Chapter 6*, *Design Patterns and .NET 8
    Implementation*. There are some good reasons for considering this. The first one
    is that you will only need to worry about disposing of the injected objects if
    you are the creator of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides, DI enables you to inject `ILogger`, a useful tool for debugging exceptions
    that will need to be managed by `try-catch` statements in your code. Furthermore,
    programming in C# with .NET 8 must follow the common good practices of any programming
    language. The following list shows some of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Classes, methods, and variables should have understandable names**: The name
    should explain everything that the reader needs to know. There should be no need
    for an explanatory comment unless these declarations are public.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Methods should not have high complexity levels**: Cyclomatic complexity should
    be checked so that methods do not have too many lines of code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Members must have the correct visibility**: As an object-oriented programming
    language, C# enables encapsulation with different visibility keywords. C# 9 has
    presented *init-only setters*, so you can create `init` property/index accessors
    instead of `set`, defining these members as read-only following the construction
    of the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Duplicate code should be avoided**: There is no reason for having duplicate
    code in a high-level programming language such as C#.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Objects should be checked before usage**: Since null objects can exist, code
    must have null type checking. It is worth mentioning that since C# 8, we have
    nullable reference types to avoid errors related to nullable objects. You can
    refer to [https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references](https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references)
    for more information about nullable reference types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constants and enumerators should be used**: A good way of avoiding magic
    numbers and text inside code is to transform this information into constants and
    enumerators, which generally are more understandable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unsafe code should be avoided**: Unsafe code enables you to deal with pointers
    in C#. Unless there is no other way to implement the solution, unsafe code should
    be avoided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**try-catch statements cannot be empty**: There is rarely a reason to use a
    `try-catch` statement without treatment in the `catch` area. Moreover, the caught
    exceptions should be as specific as possible, and not just an “exception,” to
    avoid swallowing unexpected exceptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dispose of the objects that you have created, if they are disposable**: Even
    for objects where Garbage Collector will take care of the disposed-of object,
    consider disposing of objects that you were responsible for creating yourself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**At least public methods should be commented**: Considering that public methods
    are the ones used outside your library, they must be explained for their correct
    external usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**switch-case statements must have a default treatment**: Since `switch-case`
    statements may receive an entrance variable unknown in some cases, the default
    treatment will guarantee that code will not break in such a situation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a software architect, you may consider a good practice of providing a code
    pattern for your developers that will be used to keep the style of code consistent
    as a team. You can also use this code pattern as a checklist for coding inspections,
    which will enrich software code quality.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying well-written code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not easy to identify whether code is well written. The best practices
    described so far can certainly guide you as a software architect to define a standard
    for your team. However, even with a standard, mistakes will happen, and you will
    probably find them only after code is in production. The decision to refactor
    code in production just because it does not follow all the standards you define
    is not an easy one to take, especially if the code in question works properly.
    Some people conclude that well-written code is simply code that works well in
    production. However, this can surely cause damage to the software’s life since
    developers might be influenced by that non-standard code.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, as a software architect, you need to find ways to enforce adherence
    to the coding standard you’ve defined. Luckily, nowadays, we have many options
    for tools that can help us with this task. They are called static code analysis
    tools, and using them provides a great opportunity to improve both the software
    developed and the team’s programming knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: The reason your developers will evolve with code analysis is that you start
    to disseminate knowledge between them during code inspections. The tools that
    we have now have the same purpose. Even better, with Roslyn, they do this task
    while you write the code. Roslyn is the compiler platform for .NET, and it enables
    you to develop some tools for analyzing code. These analyzers can check style,
    quality, design, and other issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, look at the following code. It does not make any sense, but you
    can still see that there are some mistakes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The idea of this code is to show you the power of some tools to improve the
    code you deliver. Let us study each of them in the next section, including how
    to set them up.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and applying tools that can evaluate C# code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The evolution of code analysis in Visual Studio is continuous. This means that
    Visual Studio 2022 certainly has more tools for this purpose than Visual Studio
    2019, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the issues that you (as a software architect) need to deal with is the
    *coding style of the team*. This certainly results in a better understanding of
    the code. For instance, if you go to the **Visual Studio Menu**, then **Tools
    -> Options**, and then, in the left-hand menu, **Text Editor -> C#**, you will
    find ways to deal with different code style patterns, and a bad coding style is
    even indicated as an error in the **Code Style** options, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_04_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: Code Style options'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot chnage that **Avoid unused parameters** was considered
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this change, the result of the compilation of the code presented at the
    beginning of the chapter is different, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19820_04_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.12: Code Style result'
  prefs: []
  type: TYPE_NORMAL
- en: You can export your coding style configuration and attach it to your project
    so that it will follow the rules you have defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another good tool that Visual Studio 2022 provides is **Analyze and Code Cleanup**.
    With this tool, you can set up some code standards that can clean up your code.
    For instance, in the following screenshot, it was set to remove unnecessary code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19820_04_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.13: Configure Code Cleanup'
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to run Code Cleanup is by selecting it with the help of a right-click
    in the **Solution Explorer** area, over the project where you want to run it.
    After that, this process will run in all the code files you have:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19820_04_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.14: Run Code Cleanup'
  prefs: []
  type: TYPE_NORMAL
- en: 'After solving the errors indicated by the **Code Style** and **Code Cleanup**
    tools, the sample code we are working on has some minimal simplifications, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It is worth mentioning that the preceding code has many improvements that still
    need to be addressed. Visual Studio enables you to add additional tools for the
    IDE by installing extensions to it. These tools can help you to improve your code
    quality, since some of them were built to perform code analysis. This section
    will list some free options so that you can decide on the one that best fits your
    needs. There are certainly other options and even paid ones. The idea here is
    not to indicate a specific tool but to give you an idea of their abilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install these extensions, you will need to find the **Extensions** menu
    in Visual Studio 2022\. Here is a screenshot of the **Manage Extensions** option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_04_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.15: Extensions in Visual Studio 2022'
  prefs: []
  type: TYPE_NORMAL
- en: There are many other great extensions that can improve the productivity and
    quality of your code and solutions. Search for them in this manager.
  prefs: []
  type: TYPE_NORMAL
- en: After you have selected the extension that will be installed, you will need
    to restart Visual Studio. Most of the extensions are easy to identify after installation,
    since they modify the behavior of the IDE. However, they need to be set in each
    developer environment. To resolve it, Visual Studio has introduced the option
    to include analyzers as NuGet packages, so all developers who work with the project
    will have their code analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: Applying extension tools to analyze code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the sample code delivered after the Code Style and Code Cleanup tools
    is better than the code we presented at the beginning of the chapter, it is clearly
    far removed from the best practices discussed so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, Microsoft has divided analyzers into three groups:'
  prefs: []
  type: TYPE_NORMAL
- en: Code style, as mentioned before
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code quality analyzers that are already included in .NET 5+ projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party analyzers that can be installed as a NuGet package or Visual Studio
    extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find an overview of source code analysis at [https://docs.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview](https://docs.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview).
  prefs: []
  type: TYPE_NORMAL
- en: Let us study how these third-party analyzers can be useful, using as a reference
    the **SonarAnalyzer** package.
  prefs: []
  type: TYPE_NORMAL
- en: Applying SonarAnalyzer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SonarAnalyzer is an open-source initiative from the Sonar Source community to
    detect bugs and quality issues while you code. There is support for C#, VB.NET,
    C, C++, and JavaScript. They also offer an extension called **SonarLint**. The
    great thing about this extension is that it comes with explanations for resolving
    detected issues, and that is why we think developers learn how to code well while
    using these tools.
  prefs: []
  type: TYPE_NORMAL
- en: This extension can point out mistakes and, even better, there is an explanation
    for each warning. This is useful not only for detecting problems but also for
    training developers in good coding practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Visual Studio 2022, the SonarLint extension is available. Besides that,
    you can also use the NuGet package, as we can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tela de computador com texto preto sobre fundo branco  Descrição gerada automaticamente](img/B19820_04_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.16: SonarAnalyzer.CSharp NuGet package'
  prefs: []
  type: TYPE_NORMAL
- en: The result produced is the same as the one we got using the SonarLint extension,
    but the good thing about this option is that any developer who needs to code for
    this project will get their code analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Texto  Descrição gerada automaticamente](img/B19820_04_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.17: SonarAnalyzer.CSharp analysis result'
  prefs: []
  type: TYPE_NORMAL
- en: As a software architect, you will always have to pay attention and take action
    to get projects unified with the same code standard, so the NuGet option may be
    useful for achieving this goal.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the final code after analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following the analysis of the two options presented, we have finally solved
    all the issues with the original code. Here is the final code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the preceding code is not only easier to understand but is also
    safer and able to consider different paths of programming, since the default for
    `switch-case` was programmed. This pattern was discussed earlier in this chapter,
    which brings us to the happy conclusion that best practices can easily be followed
    by using one (or all) of the options discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed some important tips for writing safe code. This
    chapter introduced a tool for analyzing code metrics so that you can manage the
    complexity and maintainability of the software you develop. To finish, we presented
    some good tips to guarantee that your software will not crash due to memory leaks
    and exceptions. In real life, a software architect will always be asked to solve
    this kind of problem.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter also recommended tools that can be used to apply the best practices
    of the coding we discussed. We looked at the Roslyn compiler, which enables code
    analysis while a developer codes.
  prefs: []
  type: TYPE_NORMAL
- en: You will find in *Chapter 21*, *Case Study*, a way to evaluate C# code prior
    to publishing an application, which implements code analysis during the Azure
    DevOps building process, using SonarCloud.
  prefs: []
  type: TYPE_NORMAL
- en: When you apply all the content you have learned in this chapter to your projects,
    you will find that code analysis will give you the opportunity to improve the
    quality of the code you deliver to your customers. This is a very important part
    of your role as a software architect.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about code reuse, which is an incredible
    technique to guarantee quality and velocity for your projects!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why do we need to care about maintainability?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is cyclomatic complexity?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List the advantages of using a version control system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the garbage collector?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the importance of implementing the `IDisposable` interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What advantages do we gain from .NET 8 when it comes to coding?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What makes it possible for a piece of software to be described as having well-written
    code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Roslyn?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is code analysis?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the importance of code analysis?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does Roslyn help with code analysis?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are Visual Studio extensions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What extension tools are available for code analysis?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are some books and websites where you will find more information about
    the topics of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Clean Code*: *A Handbook of Agile Software Craftmanship*, by Martin, Robert
    C. Pearson Education, 2012.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Art of Designing Embedded Systems*, by Jack G. Ganssle. Elsevier, 1999.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Refactoring*, by Martin Fowler. Addison-Wesley, 2018.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A Complexity Measure*, by Thomas J. McCabe. IEEE Trans. Software Eng. 2(4):
    308–320, 1976 ([https://dblp.uni-trier.de/db/journals/tse/tse2.html](https://dblp.uni-trier.de/db/journals/tse/tse2.html)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Code metrics information:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://blogs.msdn.microsoft.com/zainnab/2011/05/25/code-metrics-class-coupling/](https://blogs.msdn.microsoft.com/zainnab/2011/05/25/code-metrics-class-coupling/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Version control systems:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/](https://github.com/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://bitbucket.org/](https://bitbucket.org/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://azure.microsoft.com/en-us/services/devops/](https://azure.microsoft.com/en-us/services/devops/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Code branching techniques:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Logging fundamentals:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/aspnet/core/fundamentals/logging/](https://docs.microsoft.com/aspnet/core/fundamentals/logging/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What is new in CSharp?:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-11](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-11)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Source code analyzers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://marketplace.visualstudio.com/items?itemName=SonarSource.SonarLintforVisualStudio2019](https://marketplace.visualstudio.com/items?itemName=SonarSource.SonarLintforVisualStudio2019)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://marketplace.visualstudio.com/items?itemName=SonarSource.SonarLintforVisualStudio2022](https://marketplace.visualstudio.com/items?itemName=SonarSource.SonarLintforVisualStudio2022)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/dotnet/roslyn-analyzers](https://github.com/dotnet/roslyn-analyzers)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/visualstudio/ide/code-styles-and-code-cleanup](https://docs.microsoft.com/en-us/visualstudio/ide/code-styles-and-code-cleanup)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.sonarcloud.io/](https://docs.sonarcloud.io/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.guidgenerator.com/](https://www.guidgenerator.com/ )'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the authors, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code175081751210902046.png)'
  prefs: []
  type: TYPE_IMG
