- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Working with External APIs and Services
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä¸å¤–éƒ¨ API å’ŒæœåŠ¡ä¸€èµ·å·¥ä½œ
- en: Although an autonomous application can provide great value to its users, consuming
    external APIs and services can make it provide even greater value to those users
    by integrating the functionalities of the application with other applications!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: å°½ç®¡ä¸€ä¸ªè‡ªä¸»çš„åº”ç”¨ç¨‹åºå¯ä»¥ä¸ºç”¨æˆ·æä¾›å¾ˆå¤§çš„ä»·å€¼ï¼Œä½†é€šè¿‡å°†åº”ç”¨ç¨‹åºçš„åŠŸèƒ½ä¸å…¶ä»–åº”ç”¨ç¨‹åºé›†æˆï¼Œæ¶ˆè´¹å¤–éƒ¨ API å’ŒæœåŠ¡å¯ä»¥ä½¿å®ƒä¸ºè¿™äº›ç”¨æˆ·æä¾›æ›´å¤§çš„ä»·å€¼ï¼
- en: However, consuming external APIs and services creates new dependencies for your
    application. While this might make perfect sense, you have to know how to interact
    with these dependencies and how to integrate them into your application, so you
    donâ€™t couple your application too much to that external dependency and avoid having
    to change your applicationâ€™s code every time that dependency changes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œæ¶ˆè´¹å¤–éƒ¨ API å’ŒæœåŠ¡ä¸ºæ‚¨çš„åº”ç”¨ç¨‹åºåˆ›å»ºäº†æ–°çš„ä¾èµ–ã€‚è™½ç„¶è¿™å¬èµ·æ¥å¯èƒ½éå¸¸åˆç†ï¼Œä½†æ‚¨å¿…é¡»çŸ¥é“å¦‚ä½•ä¸è¿™äº›ä¾èµ–é¡¹äº¤äº’ä»¥åŠå¦‚ä½•å°†å®ƒä»¬é›†æˆåˆ°æ‚¨çš„åº”ç”¨ç¨‹åºä¸­ï¼Œè¿™æ ·æ‚¨å°±ä¸ä¼šä½¿åº”ç”¨ç¨‹åºè¿‡äºç´§å¯†åœ°è€¦åˆåˆ°å¤–éƒ¨ä¾èµ–ï¼Œå¹¶é¿å…æ¯æ¬¡ä¾èµ–é¡¹æ›´æ”¹æ—¶éƒ½éœ€è¦æ›´æ”¹åº”ç”¨ç¨‹åºçš„ä»£ç ã€‚
- en: 'More specifically, in this chapter, we will discuss the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: æ›´å…·ä½“åœ°è¯´ï¼Œåœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†è®¨è®ºä»¥ä¸‹å†…å®¹ï¼š
- en: The benefits of consuming external APIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¶ˆè´¹å¤–éƒ¨ API çš„å¥½å¤„
- en: Extending **Bookmarkr**â€™s capabilities by consuming an external API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: é€šè¿‡æ¶ˆè´¹å¤–éƒ¨ API æ‰©å±• **Bookmarkr** çš„åŠŸèƒ½
- en: The proper way in .NET to consume external APIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨ .NET ä¸­æ­£ç¡®æ¶ˆè´¹å¤–éƒ¨ API çš„æ–¹æ³•
- en: How to avoid tight coupling between our applicationâ€™s commands and the external
    API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚ä½•é¿å…åº”ç”¨ç¨‹åºçš„å‘½ä»¤ä¸å¤–éƒ¨ API ä¹‹é—´çš„ç´§å¯†è€¦åˆ
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æŠ€æœ¯è¦æ±‚
- en: The code for this chapter can be found in the GitHub repository accompanying
    this book, [https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter09](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter09)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ç« çš„ä»£ç å¯ä»¥åœ¨æœ¬ä¹¦é…å¥—çš„ GitHub ä»“åº“ä¸­æ‰¾åˆ°ï¼Œ[https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter09](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter09)
- en: Why consume external APIs?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆè¦æ¶ˆè´¹å¤–éƒ¨ APIï¼Ÿ
- en: When building your application, you have to consider multiple factors and sometimes
    implement multiple features that go well beyond your expertise.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ„å»ºæ‚¨çš„åº”ç”¨ç¨‹åºæ—¶ï¼Œæ‚¨å¿…é¡»è€ƒè™‘å¤šä¸ªå› ç´ ï¼Œæœ‰æ—¶è¿˜éœ€è¦å®ç°è¶…å‡ºæ‚¨ä¸“ä¸šé¢†åŸŸçš„å¤šä¸ªåŠŸèƒ½ã€‚
- en: Does that mean you should not build an application if you do not master every
    feature? No! Many applications rely on code developed by other people who are
    more skilled and experienced in a very specific area. These pieces of code are
    packaged as APIs and services so we can use (aka consume) them without having
    to understand every line of code they contain.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯å¦æ„å‘³ç€å¦‚æœæ‚¨ä¸æŒæ¡æ¯ä¸ªåŠŸèƒ½å°±ä¸åº”è¯¥æ„å»ºåº”ç”¨ç¨‹åºï¼Ÿä¸ï¼è®¸å¤šåº”ç”¨ç¨‹åºä¾èµ–äºç”±å…¶ä»–äººåœ¨éå¸¸å…·ä½“çš„é¢†åŸŸå†…æ›´ç†Ÿç»ƒå’Œæ›´æœ‰ç»éªŒçš„äººå¼€å‘çš„ä»£ç ã€‚è¿™äº›ä»£ç ç‰‡æ®µè¢«æ‰“åŒ…æˆ
    API å’ŒæœåŠ¡ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨ï¼ˆå³æ¶ˆè´¹ï¼‰å®ƒä»¬ï¼Œè€Œæ— éœ€ç†è§£å®ƒä»¬åŒ…å«çš„æ¯ä¸€è¡Œä»£ç ã€‚
- en: We have already come across this situation when we added logging into Bookmarkr.
    We didnâ€™t develop the logging engine ourselves. We instead relied on an existing
    service provided by an organization that knows how to do it (and do it well!).
    By relying on that service, our application was able to benefit from logging functionality
    without having to be experts in the logging business domain.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬åœ¨ Bookmarkr ä¸­æ·»åŠ æ—¥å¿—è®°å½•æ—¶ï¼Œæˆ‘ä»¬å·²ç»é‡åˆ°äº†è¿™ç§æƒ…å†µã€‚æˆ‘ä»¬æ²¡æœ‰è‡ªå·±å¼€å‘æ—¥å¿—è®°å½•å¼•æ“ã€‚ç›¸åï¼Œæˆ‘ä»¬ä¾èµ–äºä¸€ä¸ªç”±çŸ¥é“å¦‚ä½•åšï¼ˆå¹¶ä¸”åšå¾—å¾ˆå¥½ï¼ï¼‰çš„ç»„ç»‡æä¾›çš„æœåŠ¡ã€‚é€šè¿‡ä¾èµ–è¯¥æœåŠ¡ï¼Œæˆ‘ä»¬çš„åº”ç”¨ç¨‹åºèƒ½å¤Ÿä»æ—¥å¿—è®°å½•åŠŸèƒ½ä¸­å—ç›Šï¼Œè€Œæ— éœ€æˆä¸ºæ—¥å¿—è®°å½•ä¸šåŠ¡é¢†åŸŸçš„ä¸“å®¶ã€‚
- en: 'Now, I can hear your thoughts (yes, I can â€“ that is my sixth sense ğŸ˜Š). You
    are thinking that it doesnâ€™t seem that complicated to develop your own logging
    engine, and you might be right. This is a business decision: if it is part of
    your core business, then yes, it makes sense to invest time, resources, and money
    in developing, testing, and maintaining your own logging engine. But remember,
    while it might be cool to develop it, you will have to maintain it, and that is
    what hurts many organizations in the long run! You know what they sayâ€¦ You build
    it, you run it! ğŸ˜‰'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘å¯ä»¥å¬åˆ°ä½ çš„æƒ³æ³•ï¼ˆæ˜¯çš„ï¼Œæˆ‘å¯ä»¥â€”â€”è¿™æ˜¯æˆ‘çš„ç¬¬å…­æ„Ÿ ğŸ˜Šï¼‰ã€‚ä½ è®¤ä¸ºå¼€å‘è‡ªå·±çš„æ—¥å¿—è®°å½•å¼•æ“ä¼¼ä¹å¹¶ä¸å¤æ‚ï¼Œä½ å¯èƒ½æ˜¯å¯¹çš„ã€‚è¿™æ˜¯ä¸€ä¸ªå•†ä¸šå†³ç­–ï¼šå¦‚æœå®ƒæ˜¯æ‚¨æ ¸å¿ƒä¸šåŠ¡çš„ä¸€éƒ¨åˆ†ï¼Œé‚£ä¹ˆæ˜¯çš„ï¼ŒæŠ•å…¥æ—¶é—´ã€èµ„æºå’Œé‡‘é’±æ¥å¼€å‘ã€æµ‹è¯•å’Œç»´æŠ¤è‡ªå·±çš„æ—¥å¿—è®°å½•å¼•æ“æ˜¯æœ‰æ„ä¹‰çš„ã€‚ä½†è®°ä½ï¼Œè™½ç„¶å¼€å‘å®ƒå¯èƒ½å¾ˆé…·ï¼Œä½†æ‚¨å°†ä¸å¾—ä¸ç»´æŠ¤å®ƒï¼Œè¿™æ­£æ˜¯è®¸å¤šç»„ç»‡é•¿æœŸå—è‹¦çš„åŸå› ï¼ä½ çŸ¥é“ä»–ä»¬è¯´ä»€ä¹ˆâ€¦â€¦ä½ å»ºäº†å®ƒï¼Œä½ å°±å¾—è¿è¡Œå®ƒï¼
    ğŸ˜‰
- en: Also keep in mind that building your own â€œdependenciesâ€ (aka, services that
    are not part of your core business) is not always easy. An example of that is
    a payment gateway. There is a lot of regulation involved in building and offering
    such a service. If itâ€™s not your core business (in other words, if you are not
    Stripe or such a company), donâ€™t do it! Consume an existing service.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'By consuming external APIs and services, we can then focus on what we do best,
    and in our case, it is managing bookmarks! That is the key to consuming external
    APIs and services: having the ability to focus on our core business and delegating
    other concerns to whom those concerns are their core business.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: How to consume an external API
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET provides a way to interact with external APIs and services by abstracting
    the need to construct our own HTTP requests, handle the underlying networking
    details, send the request, and receive the response while performing serialization
    and deserialization and handling communication issues.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: So, in order to interact with these external APIs and services, .NET provides
    us with the `HttpClient` class. However, the proper way to deal with this class
    is through the `IHttpClientFactory` interface. This allows us to create and manage
    `HttpClient` instances for optimal performance and resource management.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of using IHttpClientFactory
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using `IHttpClientFactory` provides several advantages:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpMessageHandler` instances, which helps prevent issues such as socket exhaustion'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connection reuse**: It reuses underlying HTTP connections, improving performance'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resilience**: It adds resilience to transient faults'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpClient` instances'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bookmarkr: your bookmarks, anywhere!'
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, Bookmarkr has been managing our bookmarks locally. This means
    that we are tied to the physical boundaries of our computer.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: But what happens if we want to access these bookmarks from another computer?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: To make this happen, we will need to extend the capabilities of Bookmarkr beyond
    the local computer. To do this, we will make Bookmarkr call an external API that
    will be responsible for storing and retrieving our bookmarks.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: For that matter, we will add a new command called `sync` that will be responsible
    for synchronizing the local bookmarks with the ones stored by the external service.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: About the external service
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: When you consume an external service, you donâ€™t have to know its internals (aka,
    its architecture, technology stack, application code, and dependencies). This
    is in accordance with the encapsulation principle of object-oriented programming.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: All you need to know is how to send requests to it and how to interpret the
    responses it returns.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: However, since I know that you are curious to know more about it, I have provided
    the details of its architecture and its application and infrastructure code in
    the `appendixA-bookmarkr-syncr` branch of the GitHub repository.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Letâ€™s start by adding the new command!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The sync command
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following the project structure that we designed in the previous chapter, letâ€™s
    add a new folder named `Sync` under the `Commands` folder, and within this folder,
    letâ€™s add a new code file named `SyncCommand.cs`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: æŒ‰ç…§æˆ‘ä»¬åœ¨ä¸Šä¸€ç« ä¸­è®¾è®¡çš„é¡¹ç›®ç»“æ„ï¼Œè®©æˆ‘ä»¬åœ¨ `Commands` æ–‡ä»¶å¤¹ä¸‹æ·»åŠ ä¸€ä¸ªåä¸º `Sync` çš„æ–°æ–‡ä»¶å¤¹ï¼Œå¹¶åœ¨è¯¥æ–‡ä»¶å¤¹å†…æ·»åŠ ä¸€ä¸ªåä¸º `SyncCommand.cs`
    çš„æ–°ä»£ç æ–‡ä»¶ã€‚
- en: 'The startup code for this command is the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤å‘½ä»¤çš„å¯åŠ¨ä»£ç å¦‚ä¸‹ï¼š
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code is pretty straightforward and needs no explanation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ®µä»£ç ç›¸å½“ç›´æ¥ï¼Œæ— éœ€è§£é‡Šã€‚
- en: 'The synchronization process comprises the following steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: åŒæ­¥è¿‡ç¨‹åŒ…æ‹¬ä»¥ä¸‹æ­¥éª¤ï¼š
- en: The local bookmarks are sent by Bookmarkrâ€™s `sync` command to the external service
    (called BookmarkrSyncr).
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æœ¬åœ°ä¹¦ç­¾é€šè¿‡ Bookmarkr çš„ `sync` å‘½ä»¤å‘é€åˆ°å¤–éƒ¨æœåŠ¡ï¼ˆç§°ä¸º BookmarkrSyncrï¼‰ã€‚
- en: BookmarkrSyncr will then perform the synchronization between the local bookmarks
    it receives from Bookmarkr with the ones it has in its data store.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BookmarkrSyncr å°†æ‰§è¡Œä» Bookmarkr æ”¶åˆ°çš„æœ¬åœ°ä¹¦ç­¾ä¸å…¶æ•°æ®å­˜å‚¨ä¸­çš„ä¹¦ç­¾ä¹‹é—´çš„åŒæ­¥ã€‚
- en: BookmarkrSyncr will send the synchronized bookmarks back to the Bookmarkr `sync`
    commandâ€™s handler method.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BookmarkrSyncr å°†åŒæ­¥åçš„ä¹¦ç­¾å‘é€å› Bookmarkr `sync` å‘½ä»¤çš„å¤„ç†æ–¹æ³•ã€‚
- en: The `sync` commandâ€™s handler method will store the received bookmarks in the
    local data store. Keep in mind that if the application is dealing with large datasets
    or rate-limiting APIs, batching and retry techniques will be needed.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sync` å‘½ä»¤çš„å¤„ç†æ–¹æ³•å°†æ¥æ”¶åˆ°çš„ä¹¦ç­¾å­˜å‚¨åœ¨æœ¬åœ°æ•°æ®å­˜å‚¨ä¸­ã€‚è¯·æ³¨æ„ï¼Œå¦‚æœåº”ç”¨ç¨‹åºæ­£åœ¨å¤„ç†å¤§å‹æ•°æ®é›†æˆ–é€Ÿç‡é™åˆ¶ APIï¼Œåˆ™éœ€è¦æ‰¹å¤„ç†å’Œé‡è¯•æŠ€æœ¯ã€‚'
- en: 'So, the `sync` command needs to have a reference to `IHttpClientFactory`. Letâ€™s
    add this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œ`sync` å‘½ä»¤éœ€è¦å¼•ç”¨ `IHttpClientFactory`ã€‚è®©æˆ‘ä»¬æ·»åŠ è¿™ä¸ªï¼š
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this code, we are adding a `private` property of type `IHttpClientFactory`
    and we are injecting it through the constructor.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™æ®µä»£ç ä¸­ï¼Œæˆ‘ä»¬æ·»åŠ äº†ä¸€ä¸ªç±»å‹ä¸º `IHttpClientFactory` çš„ `private` å±æ€§ï¼Œå¹¶é€šè¿‡æ„é€ å‡½æ•°è¿›è¡Œæ³¨å…¥ã€‚
- en: 'We are then using it in the commandâ€™s method handler:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬åœ¨å‘½ä»¤çš„æ–¹æ³•å¤„ç†ç¨‹åºä¸­ä½¿ç”¨å®ƒï¼š
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code is pretty easy to understand and conforms to the synchronization process
    we described earlier.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ®µä»£ç å¾ˆå®¹æ˜“ç†è§£ï¼Œå¹¶ç¬¦åˆæˆ‘ä»¬ä¹‹å‰æè¿°çš„åŒæ­¥è¿‡ç¨‹ã€‚
- en: 'There is, however, one segment in that code that requires an explanation:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œä»£ç ä¸­æœ‰ä¸€ä¸ªéƒ¨åˆ†éœ€è¦è§£é‡Šï¼š
- en: We create an HTTP client from the `IHttpClientFactory` instance by relying on
    the named clients approach. As you can see, we are providing the name of the client
    configuration (here, `bookmarkrSyncr`) to the `CreateClient` method. We will get
    back to this configuration later.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬é€šè¿‡ä¾èµ–å‘½åå®¢æˆ·ç«¯æ–¹æ³•ä» `IHttpClientFactory` å®ä¾‹åˆ›å»ºä¸€ä¸ª HTTP å®¢æˆ·ç«¯ã€‚æ­£å¦‚ä½ æ‰€è§ï¼Œæˆ‘ä»¬å‘ `CreateClient`
    æ–¹æ³•æä¾›äº†å®¢æˆ·ç«¯é…ç½®çš„åç§°ï¼ˆåœ¨è¿™é‡Œï¼Œ`bookmarkrSyncr`ï¼‰ã€‚æˆ‘ä»¬ç¨åä¼šå›åˆ°è¿™ä¸ªé…ç½®ã€‚
- en: 'Next, we issue a `POST` request to the `sync` endpoint of the remote web service,
    passing the list of local bookmarks that have been previously serialized as JSON
    using an instance of the `StringContent` class:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å‘è¿œç¨‹ Web æœåŠ¡çš„ `sync` ç«¯ç‚¹å‘å‡ºä¸€ä¸ª `POST` è¯·æ±‚ï¼Œä¼ é€’ä¹‹å‰ä½¿ç”¨ `StringContent` ç±»å®ä¾‹åºåˆ—åŒ–ä¸ºæœ¬åœ°çš„ä¹¦ç­¾åˆ—è¡¨ï¼š
- en: If the request is successful, we deserialize the returned list of bookmarks
    (which represents the list of synchronized local and remote bookmarks) and we
    replace the local list of bookmarks with this new list
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœè¯·æ±‚æˆåŠŸï¼Œæˆ‘ä»¬å°†ååºåˆ—åŒ–è¿”å›çš„ä¹¦ç­¾åˆ—è¡¨ï¼ˆè¡¨ç¤ºåŒæ­¥çš„æœ¬åœ°å’Œè¿œç¨‹ä¹¦ç­¾åˆ—è¡¨ï¼‰ï¼Œå¹¶ç”¨è¿™ä¸ªæ–°åˆ—è¡¨æ›¿æ¢æœ¬åœ°ä¹¦ç­¾åˆ—è¡¨
- en: If the request is not successful, we display an error message corresponding
    to the returned HTTP status code
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœè¯·æ±‚ä¸æˆåŠŸï¼Œæˆ‘ä»¬å°†æ˜¾ç¤ºä¸€ä¸ªä¸è¿”å›çš„ HTTP çŠ¶æ€ç ç›¸å¯¹åº”çš„é”™è¯¯æ¶ˆæ¯
- en: 'In order to import the `IHttpClientFactory` interface, we need to reference
    the `Microsoft.Extensions.Http` NuGet package. As we already know by now, we can
    do this by typing this command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†å¯¼å…¥ `IHttpClientFactory` æ¥å£ï¼Œæˆ‘ä»¬éœ€è¦å¼•ç”¨ `Microsoft.Extensions.Http` NuGet åŒ…ã€‚æ­£å¦‚æˆ‘ä»¬ä¹‹å‰æ‰€çŸ¥é“çš„ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è¾“å…¥ä»¥ä¸‹å‘½ä»¤æ¥å®Œæˆï¼š
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Before we can use our new command, letâ€™s register it within the `Program` class!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æˆ‘ä»¬çš„æ–°å‘½ä»¤ä¹‹å‰ï¼Œè®©æˆ‘ä»¬åœ¨ `Program` ç±»ä¸­æ³¨å†Œå®ƒï¼
- en: Registering the sync command
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ³¨å†ŒåŒæ­¥å‘½ä»¤
- en: 'Letâ€™s register the `sync` command in the `Program` class. Itâ€™s only a matter
    of one line of code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬åœ¨ `Program` ç±»ä¸­æ³¨å†Œ `sync` å‘½ä»¤ã€‚è¿™åªéœ€è¦ä¸€è¡Œä»£ç ï¼š
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: But wait! Where did the `_clientFactory` variable come from?!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æ˜¯ç­‰ç­‰ï¼`_clientFactory` å˜é‡æ˜¯ä»å“ªé‡Œæ¥çš„ï¼Ÿï¼
- en: Well done! You spotted it! ğŸ˜Š
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: å¾ˆå¥½ï¼ä½ å‘ç°äº†ï¼ğŸ˜Š
- en: As you may have guessed, this is a reference to the `HttpClient` that we need
    to configure to make the magic happen. This is where we will talk about the named
    clients approach that we mentioned earlier.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚ä½ æ‰€çŒœï¼Œè¿™æ˜¯å¯¹éœ€è¦é…ç½®ä»¥å®ç°é­”æ³•çš„ `HttpClient` çš„å¼•ç”¨ã€‚è¿™å°±æ˜¯æˆ‘ä»¬å°†è®¨è®ºä¹‹å‰æåˆ°çš„å‘½åå®¢æˆ·ç«¯æ–¹æ³•çš„åœ°æ–¹ã€‚
- en: 'The `_clientFactory` variable is of type `IHttpClientFactory`. So, we first
    need to declare it within the `Main` method of the `Program` class:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will allow us later to retrieve a reference to it and pass it to the constructor
    of `SyncCommand` during its registration (as we saw earlier). We can retrieve
    that reference as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, letâ€™s register the HTTP client for the BookmarkrSyncr service. We
    do this within the `ConfigureServices` block as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Letâ€™s explain what this code does:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: A name (`bookmarkrSyncr`) is provided for the registered HTTP client. This is
    why we call this approach â€œ`named clients`â€. Notice that this is the same name
    that is passed to the `CreateClient` method in the `SyncCommand` class we saw
    earlier. This is how the appropriate HTTP client is selected.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then specify the base address for the service and a couple of request headers.
    Note that the base address does not specify the `sync` endpoint. It is specified
    when performing the request. This allows a web service to have different endpoints
    and for those endpoints to be invoked as needed without having to specify the
    base address over and over again.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About the base address
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the base address points to an external URL. I deployed
    the code of the BookmarkrSyncr service in App Service on Azure.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: I will keep this service up and running as long as I can but keep in mind that
    you have access to both its infrastructure and application code in the `appendixA-bookmarkr-syncr`
    branch if you need to redeploy it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Everything is now set up. We can run the program and see what happens.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Running the program
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run the program, we simply need to execute this command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The result will be as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 â€“ The sync command in action](img/B22400_09_01.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 â€“ The sync command in action
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Great, isnâ€™t it?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: If we list all available local bookmarks, we will notice that they have indeed
    been synchronized with the remote list of bookmarks.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: What about security?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: You may certainly have noticed that the web service can be used without any
    authentication. In other words, anonymous requests are allowed, which may be a
    security concern.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: You are totally right, and this is intentional for now as security will be addressed
    in [*Chapter 13*](B22400_13.xhtml#_idTextAnchor220) where we will see how we can
    authenticate users using a technique called â€œPersonal Access Tokens,â€ which resembles
    using API keys.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: The code works great but there is actually a drawback to it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the coupling between our application and the external dependency
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, although we applied the best practices of consuming
    external APIs, we created a coupling between our application and that dependencyâ€¦
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Notice that our application actually knows about the data type and structure
    that is returned by the API. This means that whenever this API changes, we will
    need to update our code accordingly.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: This also means that our application is responsible for handling the different
    HTTP codes that the API may return. Canâ€™t we abstract this complexity somewhere
    so that eventual changes are scoped to a small portion of our code?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Of course we can! And there is a pattern for that, which is called **Service
    Agent**.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: About the Service Agent pattern
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Service Agent pattern abstracts away the details of HTTP communication into
    a dedicated service, allowing other services (or, in our case, commands) to interact
    with external systems without directly dealing with HTTP requests and responses.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many benefits to the Service Agent pattern, among which are the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstraction**: It abstracts the complexity of HTTP communication, including
    constructing the HTTP request, handling the response, and managing errors'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encapsulation**: It encapsulates all the logic related to communicating with
    a specific external service or API'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusability**: Service Agent can be reused by multiple components or services
    within the application'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sync` command) from the communication logic (in Service Agent)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability**: Changes to the external API or communication protocol
    only need to be made in one place (Service Agent)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I believe that itâ€™s clear to you by now that our CLI application can greatly
    benefit from leveraging the Service Agent pattern. Letâ€™s now see how we can implement
    it!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Service Agent pattern
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This pattern is often implemented using `IHttpClientFactory` and named or typed
    `HttpClient` instances.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: We are already using these artifacts, so it will be quite straightforward for
    us to abstract the HTTP details away from the `sync` command and into a dedicated
    Service Agent class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The first step we will perform is to create a folder structure for Service Agents.
    Following the project structure we have laid out in the previous chapter, letâ€™s
    create a folder named `ServiceAgents` and a subfolder named `BookmarkrSyncrServiceAgent`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Within this subfolder, letâ€™s create two code artifacts: an interface file named
    `IBookmarkrSyncrServiceAgent.cs`, and a class file named `BookmarkrSyncrServiceAgent.cs`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code of the `IBookmarkrSyncrServiceAgent` interface:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This interface only exposes one operation, `SyncBookmarks`, which takes the
    list of local bookmarks (held by the Bookmarkr CLI application) and returns the
    synced list of bookmarks that includes the bookmarks from the remote web service,
    BookmarkrSyncr.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Letâ€™s now implement this interface:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you may have noticed, this implementation is reusing the code that was located
    in the body of the `Sync` commandâ€™s handler method, hence abstracting it from
    this method and encapsulating it into the Service Agent class.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, the code of this class does not need a lot of explanation.
    However, it is worth mentioning that in case of an unsuccessful request, we return
    an instance of `HttpRequestException` with the details about the issue.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to update the code of the `SyncCommand` class to abstract the
    use of `IHttpClientFactory` and use our new Service Agent instead. The updated
    code is the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éœ€è¦æ›´æ–°`SyncCommand`ç±»çš„ä»£ç ï¼Œä»¥æŠ½è±¡åŒ–`IHttpClientFactory`çš„ä½¿ç”¨ï¼Œå¹¶ä½¿ç”¨æˆ‘ä»¬æ–°çš„æœåŠ¡ä»£ç†ã€‚æ›´æ–°çš„ä»£ç å¦‚ä¸‹ï¼š
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code is quite simple and easy to read. What we did basically was replace
    the use of `IHttpClientFactory` with the use of `IBookmarkrSyncrServiceAgent`
    and remove all the code, in the `OnSyncCommand` method, that was dealing with
    the HTTP communication (which we abstracted away into the Service Agent class)
    by the call to the `Sync` method of the Service Agent. Hence, the `OnSyncCommand`
    method is also leaner, shrinking from 41 lines of code down to 16.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ®µä»£ç ç›¸å½“ç®€å•ä¸”æ˜“äºé˜…è¯»ã€‚æˆ‘ä»¬åŸºæœ¬ä¸Šæ˜¯ç”¨`IBookmarkrSyncrServiceAgent`çš„ä½¿ç”¨æ›¿æ¢äº†`IHttpClientFactory`çš„ä½¿ç”¨ï¼Œå¹¶é€šè¿‡è°ƒç”¨æœåŠ¡ä»£ç†çš„`Sync`æ–¹æ³•ï¼Œç§»é™¤äº†`OnSyncCommand`æ–¹æ³•ä¸­å¤„ç†HTTPé€šä¿¡çš„æ‰€æœ‰ä»£ç ï¼ˆæˆ‘ä»¬å°†å…¶æŠ½è±¡åˆ°æœåŠ¡ä»£ç†ç±»ä¸­ï¼‰ã€‚å› æ­¤ï¼Œ`OnSyncCommand`æ–¹æ³•ä¹Ÿæ›´åŠ ç²¾ç®€ï¼Œä»41è¡Œä»£ç ç¼©å‡åˆ°16è¡Œã€‚
- en: Note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„
- en: For your reference, we provide a copy of the `SyncCommand` class as it was before
    introducing the use of the Service Agent class. By doing so, you can easily compare
    the differences between the two implementations. Look for the file named `SyncCommand_NoServiceAgent.txt`
    in the `Commands/Sync` folder.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†æ‚¨çš„å‚è€ƒï¼Œæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªåœ¨å¼•å…¥ä½¿ç”¨æœåŠ¡ä»£ç†ç±»ä¹‹å‰çš„`SyncCommand`ç±»çš„å‰¯æœ¬ã€‚é€šè¿‡è¿™æ ·åšï¼Œæ‚¨å¯ä»¥è½»æ¾åœ°æ¯”è¾ƒä¸¤ç§å®ç°ä¹‹é—´çš„å·®å¼‚ã€‚åœ¨`Commands/Sync`æ–‡ä»¶å¤¹ä¸­æŸ¥æ‰¾åä¸º`SyncCommand_NoServiceAgent.txt`çš„æ–‡ä»¶ã€‚
- en: The final step is to register the Service Agent into the list of services in
    the `ConfigureServices` section of the `Program` class.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åä¸€æ­¥æ˜¯å°†æœåŠ¡ä»£ç†æ³¨å†Œåˆ°`Program`ç±»ä¸­çš„`ConfigureServices`éƒ¨åˆ†çš„æœåŠ¡åˆ—è¡¨ä¸­ã€‚
- en: 'As we have seen previously, this can be easily done by adding this line of
    code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬ä¹‹å‰çœ‹åˆ°çš„ï¼Œè¿™å¯ä»¥é€šè¿‡æ·»åŠ ä»¥ä¸‹ä»£ç è¡Œè½»æ¾å®Œæˆï¼š
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We need not forget to declare a variable for the Service Agent:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬éœ€è¦è®°ä½å£°æ˜ä¸€ä¸ªæœåŠ¡ä»£ç†çš„å˜é‡ï¼š
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we need to retrieve the instance of that Service Agent:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éœ€è¦æ£€ç´¢è¯¥æœåŠ¡ä»£ç†çš„å®ä¾‹ï¼š
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We pass it to the constructor of the `SyncCommand` class:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†å…¶ä¼ é€’ç»™`SyncCommand`ç±»çš„æ„é€ å‡½æ•°ï¼š
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Everything is now in place. Letâ€™s make sure that the application still works
    as expected.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€åˆ‡ç°åœ¨éƒ½å·²å°±ç»ªã€‚è®©æˆ‘ä»¬ç¡®ä¿åº”ç”¨ç¨‹åºä»ç„¶æŒ‰é¢„æœŸå·¥ä½œã€‚
- en: Rerunning the program
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: é‡æ–°è¿è¡Œç¨‹åº
- en: 'We can run the program the same way we did before, by typing this command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥åƒä¹‹å‰ä¸€æ ·è¿è¡Œç¨‹åºï¼Œé€šè¿‡è¾“å…¥ä»¥ä¸‹å‘½ä»¤ï¼š
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will get the exact same result, proving that the application still works
    as it is supposed to:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†å¾—åˆ°å®Œå…¨ç›¸åŒçš„ç»“æœï¼Œè¯æ˜åº”ç”¨ç¨‹åºä»ç„¶æŒ‰é¢„æœŸå·¥ä½œï¼š
- en: '![Figure 9.2 â€“ The sync command in action using the Service Agent](img/B22400_09_02.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾9.2 â€“ ä½¿ç”¨æœåŠ¡ä»£ç†æ‰§è¡ŒåŒæ­¥å‘½ä»¤](img/B22400_09_02.jpg)'
- en: Figure 9.2 â€“ The sync command in action using the Service Agent
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾9.2 â€“ ä½¿ç”¨æœåŠ¡ä»£ç†æ‰§è¡ŒåŒæ­¥å‘½ä»¤
- en: Awesome! By leveraging the Service Agent pattern, we have been able to provide
    a clean separation between the business logic and the details of HTTP communication.
    Hence, we can consume the BookmarkrSyncr web service in any other command (using
    the `BookmarkrSyncrServiceAgent` class), without this command having to deal with
    the HTTP communication details.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: å¤ªæ£’äº†ï¼é€šè¿‡åˆ©ç”¨æœåŠ¡ä»£ç†æ¨¡å¼ï¼Œæˆ‘ä»¬å·²ç»èƒ½å¤Ÿæä¾›ä¸šåŠ¡é€»è¾‘å’ŒHTTPé€šä¿¡ç»†èŠ‚ä¹‹é—´çš„æ¸…æ™°åˆ†ç¦»ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ä»»ä½•å…¶ä»–å‘½ä»¤ï¼ˆä½¿ç”¨`BookmarkrSyncrServiceAgent`ç±»ï¼‰ä¸­æ¶ˆè´¹`BookmarkrSyncr`ç½‘ç»œæœåŠ¡ï¼Œè€Œæ— éœ€è¿™ä¸ªå‘½ä»¤å¤„ç†HTTPé€šä¿¡ç»†èŠ‚ã€‚
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ‘˜è¦
- en: In this chapter, we learned how to extend the functionalities of Bookmarkr by
    consuming external APIs and services.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å­¦ä¹ äº†å¦‚ä½•é€šè¿‡æ¶ˆè´¹å¤–éƒ¨APIå’ŒæœåŠ¡æ¥æ‰©å±•Bookmarkrçš„åŠŸèƒ½ã€‚
- en: We explored the best practices of communicating with external dependencies,
    handling response data, codes, and errors, and designing that integration in a
    way that does not create a heavy coupling between the external dependency and
    our application, making it easy to replace that dependency over time if this proves
    necessary.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ¢è®¨äº†ä¸å¤–éƒ¨ä¾èµ–é¡¹é€šä¿¡çš„æœ€ä½³å®è·µï¼Œå¤„ç†å“åº”æ•°æ®ã€ä»£ç å’Œé”™è¯¯ï¼Œä»¥åŠä»¥ä¸åˆ›å»ºå¤–éƒ¨ä¾èµ–é¡¹å’Œæˆ‘ä»¬çš„åº”ç”¨ç¨‹åºä¹‹é—´ç´§å¯†è€¦åˆçš„æ–¹å¼è®¾è®¡è¯¥é›†æˆï¼Œè¿™æ ·å¦‚æœè¯æ˜è¿™æ˜¯å¿…è¦çš„ï¼Œå°±å¯ä»¥è½»æ¾æ›¿æ¢è¯¥ä¾èµ–é¡¹ã€‚
- en: In the next chapter, we will cover one of the key aspects of building applications,
    which is testing those applications.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å°†ä»‹ç»æ„å»ºåº”ç”¨ç¨‹åºçš„å…³é”®æ–¹é¢ä¹‹ä¸€ï¼Œå³æµ‹è¯•è¿™äº›åº”ç”¨ç¨‹åºã€‚
- en: Your turn!
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: è½®åˆ°ä½ äº†ï¼
- en: Following along with the provided code is a great way to learn through practice.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: è·Ÿéšæä¾›çš„ä»£ç æ˜¯ä¸€ç§å¾ˆå¥½çš„é€šè¿‡å®è·µå­¦ä¹ çš„æ–¹æ³•ã€‚
- en: A better way is by challenging yourself to achieve tasks. Hence, I challenge
    you to improve the Bookmarkr application by adding the following features.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªæ›´å¥½çš„æ–¹æ³•æ˜¯æŒ‘æˆ˜è‡ªå·±å®Œæˆä»»åŠ¡ã€‚å› æ­¤ï¼Œæˆ‘æŒ‘æˆ˜ä½ é€šè¿‡æ·»åŠ ä»¥ä¸‹åŠŸèƒ½æ¥æ”¹è¿›Bookmarkråº”ç”¨ç¨‹åºã€‚
- en: 'Task #1 â€“ adding SQLite as a data store'
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'ä»»åŠ¡ #1 â€“ æ·»åŠ SQLiteä½œä¸ºæ•°æ®å­˜å‚¨'
- en: Who said that APIs are the only external dependencies an application can rely
    on? Certainly not me! ğŸ˜Š
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Until now, our application has stored its bookmarks in memory. You will certainly
    agree with me that this is not an ideal solution as bookmarks will be lost as
    soon as the application terminates or restarts.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: You are asked to add a new dependency to the Bookmarkr application â€“ a **SQLite**
    database! This will allow bookmarks to be stored in a more permanent manner by
    Bookmarkr, making it more useful to our users ğŸ˜‰.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Why SQLite? You may askâ€¦
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLite is a versatile and lightweight database solution, designed to be both
    simple and easy to use while requiring minimal setup and administration. One of
    its most significant advantages is its portability: the entire database is stored
    in a single file, which makes it easy to move, back up, and distribute. Its self-contained
    nature also means that SQLite doesnâ€™t require a separate server process or system
    configuration, simplifying its deployment. That is why it is a great fit for CLI
    applications!'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Now, you will also need to modify the code of `BookmarkService` to retrieve
    bookmarks from and store bookmarks in the SQLite database.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Consider using the `Microsoft.Data.Sqlite` library for .NET, as it is a reliable
    and lightweight library. Consider adding migrations and ensuring thread-safe access
    for SQLite in concurrent CLI scenarios.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Task #2 â€“ retrieving the web page name based on its URL'
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until now, when adding a new bookmark, we had to pass both the web page name
    and URL.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to work with external dependencies, letâ€™s tweak the `link
    add` command so that it makes an HTTP request to retrieve the name of the web
    page to bookmark based on the provided URL. If the name canâ€™t be retrieved, we
    can then use the name that was passed as a command option.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: If the web page cannot be found, the bookmarkâ€™s name should be `Unnamed bookmark`.
    If the request takes more than 30 seconds, terminate it and also set the name
    to `Unnamed bookmark`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 4: Testing and Deployment'
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will explore the critical aspects of testing, packaging, and
    deploying CLI applications. You'll learn various strategies for testing CLI tools,
    including unit testing individual components. Next, you'll delve into packaging
    your CLI application for distribution, using the most commonly used mechanisms
    such as Docker, .NET Tool, and Winget. You'll understand how to specify entry
    points, define dependencies, and structure your project for optimal packaging.
    Finally, you'll explore deployment methods, learning how to distribute your CLI
    tool through package managers and ensure it works consistently across different
    environments.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B22400_10.xhtml#_idTextAnchor155)*, Testing CLI Applications*'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B22400_11.xhtml#_idTextAnchor185)*, Packaging and Deployment*'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
