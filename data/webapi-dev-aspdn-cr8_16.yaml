- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Error Handling, Monitoring, and Observability
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理、监控和可观察性
- en: 'In [*Chapter 4*](B18971_04.xhtml#_idTextAnchor170), we introduced how to use
    logging in ASP.NET Core web API applications. Logging is a critical part of application
    development that helps developers understand what’s happening in their applications.
    However, logging is not enough – we need more tools to monitor and observe how
    our application is running. In this chapter, we will explore the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B18971_04.xhtml#_idTextAnchor170)中，我们介绍了如何在ASP.NET Core Web API应用程序中使用日志记录。日志记录是应用程序开发的关键部分，它帮助开发者了解应用程序中发生的事情。然而，日志记录是不够的——我们需要更多的工具来监控和观察应用程序的运行情况。在本章中，我们将探讨以下主题：
- en: Error handling
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理
- en: Health checks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 健康检查
- en: Monitoring and observability
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控和可观察性
- en: After reading this chapter, you will be able to understand how to monitor ASP.NET
    Core web API applications. You will have gained knowledge of observability and
    **OpenTelemetry**, as well as how to use some tools, such as Prometheus and Grafana,
    to monitor applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 读完本章后，你将能够理解如何监控ASP.NET Core Web API应用程序。你将获得关于可观察性和**OpenTelemetry**的知识，以及如何使用一些工具，如Prometheus和Grafana，来监控应用程序。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code samples for this chapter can be found at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter16](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter16).
    You can use VS 2022 or VS Code to open the solutions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码示例可以在[https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter16](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter16)找到。你可以使用VS
    2022或VS Code打开解决方案。
- en: Error handling
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: When an exception occurs in an ASP.NET Core web API application, the application
    will throw an exception. If this exception is not handled, the application will
    crash and cause a 500 error. The response body will contain the stack trace of
    the exception. Displaying the stack trace to the client is acceptable during development.
    However, we should never expose the stack trace to the client in production. The
    stack trace contains sensitive information about the application that can be used
    by attackers to attack the application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当ASP.NET Core Web API应用程序中发生异常时，应用程序将抛出异常。如果这个异常没有被处理，应用程序将崩溃并导致500错误。响应体将包含异常的堆栈跟踪。在开发期间向客户端显示堆栈跟踪是可以接受的。然而，我们永远不应该在生产环境中向客户端暴露堆栈跟踪。堆栈跟踪包含有关应用程序的敏感信息，攻击者可以利用这些信息攻击应用程序。
- en: Handling exceptions
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理异常
- en: 'Let’s look at an example. The `MyWebApiDemo` sample application has a controller
    named `UsersController`, which has an action to get a user by their user ID. This
    action looks as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。`MyWebApiDemo`示例应用程序有一个名为`UsersController`的控制器，该控制器有一个根据用户ID获取用户的操作。这个操作如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is not advisable to use `First` in this instance as it will result in an
    exception being thrown if the user is not found in the collection. To illustrate
    how to handle exceptions in the application, we will use this example.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下不建议使用`First`，因为如果集合中没有找到用户，它将抛出一个异常。为了说明如何在应用程序中处理异常，我们将使用这个例子。
- en: 'Run the application and send a `GET` request to the `https://localhost:5001/users/100`
    endpoint. You can test it in the Swagger UI directly. The application will return
    a 500 error because no user with an ID of 100 will be found. The response body
    will look as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并向`https://localhost:5001/users/100`端点发送一个`GET`请求。你可以在Swagger UI中直接测试它。由于找不到ID为100的用户，应用程序将返回一个500错误。响应体将如下所示：
- en: '![Figure 16.1 – The response body contains the stack trace](img/B18971_16_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图16.1 – 响应体包含堆栈跟踪](img/B18971_16_01.jpg)'
- en: Figure 16.1 – The response body contains the stack trace
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1 – 响应体包含堆栈跟踪
- en: Regardless of whether the application is running in the development environment,
    the response body contains the stack trace. We should never show the stack trace
    for the production environment. Additionally, the response body is not a valid
    JSON payload, making it difficult for the client to parse it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 无论应用程序是在开发环境中运行，还是生产环境中运行，响应体都包含堆栈跟踪。我们永远不应该在生产环境中显示堆栈跟踪。此外，响应体不是一个有效的JSON有效负载，这使得客户端难以解析它。
- en: 'ASP.NET Core provides a built-in exception handling middleware to handle exceptions
    and return an error payload. The exception handling middleware can return a valid
    JSON payload to the client. This kind of JSON payload for error and exceptions
    is called **Problem Details** and is defined in RFC7807: [https://datatracker.ietf.org/doc/html/rfc7807](https://datatracker.ietf.org/doc/html/rfc7807).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 提供了一个内置的异常处理中间件来处理异常并返回错误负载。异常处理中间件可以向客户端返回有效的 JSON 负载。这种错误和异常的
    JSON 负载称为 **问题详情**，并在 RFC7807 中定义：[https://datatracker.ietf.org/doc/html/rfc7807](https://datatracker.ietf.org/doc/html/rfc7807)。
- en: 'A problem details object can have the following properties:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 问题详情对象可以有以下属性：
- en: '`type`: A URI reference that’s used to identify the problem type. This reference
    provides helpful documentation in a human-readable format, which can assist clients
    in understanding the error.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`: 用于标识问题类型的 URI 引用。此引用以人类可读格式提供有用的文档，可以帮助客户端理解错误。'
- en: '`title`: A summary that describes the problem’s type in a human-readable format.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`: 以人类可读格式描述问题类型的摘要。'
- en: '`status`: An HTTP status code generated by the original server to indicate
    the status of the problem.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`: 原始服务器生成的 HTTP 状态码，用于指示问题的状态。'
- en: '`detail`: A human-readable description of the problem.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detail`: 对问题的可读描述。'
- en: '`instance`: A URI reference that provides a specific occurrence of the problem,
    allowing for a more precise understanding of the issue.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instance`: 提供问题特定发生的 URI 引用，允许更精确地理解问题。'
- en: The client can parse the problem details object and display a user-friendly
    error message. This object can be extended to include additional information about
    the error, though the existing properties should be sufficient for most cases.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以解析问题详情对象，并显示友好的错误信息。此对象可以扩展以包含有关错误的附加信息，尽管现有属性对于大多数情况应该是足够的。
- en: 'To use the exception handling middleware, we need to create a controller to
    show the problem details. Create a new controller named `ErrorController` and
    add the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用异常处理中间件，我们需要创建一个控制器来显示问题详情。创建一个名为 `ErrorController` 的新控制器，并添加以下代码：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code comes from Microsoft’s official documentation: [https://learn.microsoft.com/en-us/aspnet/core/web-api/handle-errors](https://learn.microsoft.com/en-us/aspnet/core/web-api/handle-errors).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码来自微软的官方文档：[https://learn.microsoft.com/en-us/aspnet/core/web-api/handle-errors](https://learn.microsoft.com/en-us/aspnet/core/web-api/handle-errors)。
- en: 'There are several things to note in the `ErrorController` class:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ErrorController` 类中有几点需要注意：
- en: The controller is marked with the `[ApiExplorerSettings(IgnoreApi = true)]`
    attribute. This attribute is used to hide this endpoint from the OpenAPI specification
    and Swagger UI.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器被标记为 `[ApiExplorerSettings(IgnoreApi = true)]` 属性。此属性用于从 OpenAPI 规范和 Swagger
    UI 中隐藏此端点。
- en: The controller has two actions. The first action is used to show a detailed
    error message in the development environment, so it provides the route `/error-development`
    that shows the stack trace of the exception. The second action is used to show
    a generic error message in the production environment, so it provides the `/error`
    route that has no additional information about the exception.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器有两个操作。第一个操作用于在开发环境中显示详细的错误信息，因此它提供了显示异常堆栈跟踪的 `/error-development` 路由。第二个操作用于在生产环境中显示通用的错误信息，因此它提供了没有关于异常的额外信息的
    `/error` 路由。
- en: In the actions, we use the `IExceptionHandlerFeature` interface to get the exception
    information. The `IExceptionHandlerFeature` interface is a feature containing
    the exception of the original request to be examined by an exception handler.
    We can log the exception information or return it to the client.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在操作中，我们使用 `IExceptionHandlerFeature` 接口来获取异常信息。`IExceptionHandlerFeature` 接口是一个包含要由异常处理器检查的原请求异常的功能。我们可以记录异常信息或将它返回给客户端。
- en: 'Next, we need to register the exception handling middleware in the application.
    Open the `Program.cs` file and call the `UseExceptionHandler` method to add the
    exception handling middleware:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在应用程序中注册异常处理中间件。打开 `Program.cs` 文件并调用 `UseExceptionHandler` 方法来添加异常处理中间件：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For the development environment, we can use the /`error-development` endpoint
    to show the detailed error message. For the production environment, we can use
    the /`error` endpoint to show the generic error message. It is a good practice
    to hide the stack trace in the production environment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发环境，我们可以使用 `/`error-development` 端点来显示详细的错误消息。对于生产环境，我们可以使用 `/`error` 端点来显示通用错误消息。在生产环境中隐藏堆栈跟踪是一个好的做法。
- en: 'Run the application and send a `GET` request to the `https://localhost:5001/users/100`
    endpoint. The application will return a 500 error. The response body will look
    as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并向 `https://localhost:5001/users/100` 端点发送一个 `GET` 请求。应用程序将返回一个 500 错误。响应体将如下所示：
- en: '![Figure 16.2 – The response body contains the problem details alongside the
    stack trace in the development environment](img/B18971_16_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图16.2 – 响应体包含开发环境中的问题详情和堆栈跟踪](img/B18971_16_02.jpg)'
- en: Figure 16.2 – The response body contains the problem details alongside the stack
    trace in the development environment
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2 – 响应体包含开发环境中的问题详情和堆栈跟踪
- en: The response body now contains a problem details JSON payload. It also contains
    the stack trace of the exception for troubleshooting in the development environment.
    The client can parse the response body and display a user-friendly error message.
    Meanwhile, the response headers contain the `Content-Type` header with a value
    of `application`/`problem+json`. This indicates that the response body is a problem
    details JSON payload.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 响应体现在包含一个问题详情 JSON 负载。它还包含开发环境中用于故障排除的异常堆栈跟踪。客户端可以解析响应体并显示一个用户友好的错误消息。同时，响应头包含一个值为
    `application`/`problem+json` 的 `Content-Type` 头。这表明响应体是一个问题详情 JSON 负载。
- en: 'If you run the application in the production environment, the response body
    will not contain the stack trace of the exception. The response body will look
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在生产环境中运行应用程序，响应体将不会包含异常的堆栈跟踪。响应体将如下所示：
- en: '![Figure 16.3 – The response body contains a general error message in the production
    environment](img/B18971_16_03.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图16.3 – 生产环境中的响应体包含一个通用错误消息](img/B18971_16_03.jpg)'
- en: Figure 16.3 – The response body contains a general error message in the production
    environment
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3 – 生产环境中的响应体包含一个通用错误消息
- en: The default problem details object can be extended to include additional information
    about the error. We will discuss how to customize the problem details in the next
    section.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 默认问题详情对象可以被扩展以包含有关错误的附加信息。我们将在下一节中讨论如何自定义问题详情。
- en: Model validation
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型验证
- en: When a client sends a request to the application, the application needs to validate
    the request. For example, when a user updates their profile, the `Email` property
    must be a valid email address. If the value of the `Email` property is invalid,
    the application should return an HTTP 400 response with a problem details object
    that contains the validation error message.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端向应用程序发送请求时，应用程序需要验证该请求。例如，当用户更新其个人资料时，`电子邮件` 属性必须是一个有效的电子邮件地址。如果 `电子邮件`
    属性的值无效，应用程序应返回一个包含验证错误消息的问题详情对象的 HTTP 400 响应。
- en: 'ASP.NET Core offers a built-in model validation feature to validate the request
    model. This feature is enabled using validation attributes, which are defined
    in the `System.ComponentModel.DataAnnotations` namespace. The following table
    outlines some available validation attributes:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 提供了一个内置的模型验证功能来验证请求模型。此功能通过使用在 `System.ComponentModel.DataAnnotations`
    命名空间中定义的验证属性来启用。以下表格概述了一些可用的验证属性：
- en: '| Attribute name | Description |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 属性名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Required` | Specifies that a data field is required |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `必需` | 指定数据字段是必需的 |'
- en: '| `Range` | Specifies that a numeric field must be in a specified range |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `范围` | 指定一个数值字段必须在指定的范围内 |'
- en: '| `StringLength` | Specifies the minimum and maximum length of a `string` field
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `字符串长度` | 指定字符串字段的最低和最高长度 |'
- en: '| `EmailAddress` | Specifies that a data field must be a valid email address
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `电子邮件地址` | 指定数据字段必须是一个有效的电子邮件地址 |'
- en: '| `RegularExpression` | Specifies that a data field must match the specified
    regular expression |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `正则表达式` | 指定数据字段必须匹配指定的正则表达式 |'
- en: '| `Url` | Specifies that a data field must be a valid URL |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `URL` | 指定数据字段必须是一个有效的 URL |'
- en: Table 16.1 – Common model validation attributes
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 表16.1 – 常见模型验证属性
- en: 'We can apply these validation attributes as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下应用这些验证属性：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the application and send a `POST` request to the `/users` endpoint with
    an invalid request body, like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并向`/users`端点发送一个无效请求体`POST`请求，如下所示：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The application will return an HTTP 400 response with a problem details object,
    as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将返回一个包含问题详情对象的HTTP 400响应，如下所示：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this way, the client can parse the response body and display a user-friendly
    error message so that the user can correct the input.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，客户端可以解析响应体并显示一个用户友好的错误消息，以便用户可以纠正输入。
- en: Using FluentValidation to validate models
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用FluentValidation验证模型
- en: 'The previous section discussed the use of built-in validation attributes. However,
    these have certain limitations:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节讨论了使用内置验证属性的使用。然而，这些属性存在某些限制：
- en: The validation attributes are tightly coupled with the model. The models are
    polluted with validation attributes.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证属性与模型紧密耦合。模型被验证属性污染。
- en: The validation attributes cannot validate complex validation rules. If one property
    has dependencies on other properties, or the validation needs external services,
    the validation attributes cannot handle this.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证属性无法验证复杂的验证规则。如果一个属性依赖于其他属性，或者验证需要外部服务，验证属性无法处理这种情况。
- en: To solve these problems, we can use `FluentValidation` to validate the models.
    `FluentValidation` is a popular open-source library for building strongly typed
    validation rules, allowing us to separate the validation logic from the models.
    It also supports complex validation rules.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，我们可以使用`FluentValidation`来验证模型。`FluentValidation`是一个流行的开源库，用于构建强类型验证规则，允许我们将验证逻辑与模型分离。它还支持复杂的验证规则。
- en: 'To use `FluentValidation`, we need to install the `FluentValidation.AspNetCore`
    NuGet package. Run the following command in the terminal to install the package:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`FluentValidation`，我们需要安装`FluentValidation.AspNetCore` NuGet包。在终端中运行以下命令来安装包：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Important note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Previously, `FluentValidation` provided a separate package for ASP.NET Core
    named `FluentValidation.AspNetCore`. However, this package is deprecated. It is
    recommended to use the `FluentValidation` package directly and use manual validation
    instead of using the ASP.NET Core validation pipeline. This is because the ASP.NET
    Core validation pipeline does not support asynchronous validation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，`FluentValidation`为ASP.NET Core提供了一个名为`FluentValidation.AspNetCore`的单独包。然而，此包已弃用。建议直接使用`FluentValidation`包，并使用手动验证而不是使用ASP.NET
    Core验证管道。这是因为ASP.NET Core验证管道不支持异步验证。
- en: 'Next, we need to create a validator for the `User` model. Create a new class
    named `UserValidator` and add the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为`User`模型创建一个验证器。创建一个名为`UserValidator`的新类，并添加以下代码：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we use fluent syntax to specify validation rules for
    each property. We can also create a custom rule for dependent properties. In this
    example, we’re creating a custom rule to validate the `Country` and `PhoneNumber`
    properties. If the country is New Zealand, we can create a custom rule that requires
    the phone number to start with 64\. This is just one example of how to validate
    properties that depend on other properties; built-in validation attributes cannot
    handle this type of validation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用流畅语法为每个属性指定验证规则。我们还可以为依赖属性创建自定义规则。在这个例子中，我们正在创建一个自定义规则来验证`Country`和`PhoneNumber`属性。如果国家是新西兰，我们可以创建一个自定义规则，要求电话号码以64开头。这只是一个如何验证依赖于其他属性的属性的示例；内置的验证属性无法处理此类验证。
- en: 'Next, we need to register the validator in the application. Add the following
    code to the `Program.cs` file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在应用程序中注册验证器。将以下代码添加到`Program.cs`文件中：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding code looks straightforward. But what if we have many validators?
    We can register all validators in a specific assembly. To do this, we need to
    install the `FluentValidation.DependencyInjectionExtensions` NuGet package. Run
    the following command in the terminal to install the package:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码看起来很简单。但如果我们有多个验证者怎么办？我们可以在一个特定的集合中注册所有验证者。为此，我们需要安装`FluentValidation.DependencyInjectionExtensions`
    NuGet包。在终端中运行以下命令来安装包：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we can register all validators, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以注册所有验证器，如下所示：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we can validate the model in the controller. Update the `Post` action,
    as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在控制器中验证模型。更新`Post`操作，如下所示：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we utilize the `ValidateAsync()` method to validate the
    model. If the model is invalid, we return an HTTP `400` response containing a
    problem details object that contains the associated validation error message.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们利用 `ValidateAsync()` 方法来验证模型。如果模型无效，我们返回一个包含包含相关验证错误消息的问题详情对象的HTTP
    `400` 响应。
- en: 'Send a `POST` request to the `/users` endpoint with the following payload:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `/users` 端点发送以下有效负载的 `POST` 请求：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The application will return a 400 error with the following problem details
    object:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将返回一个包含以下问题详情对象的400错误：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we can see, the custom validation rule is executed and the error message
    is returned to the client.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，自定义验证规则被执行，并将错误消息返回给客户端。
- en: "`FluentValidation` has more features than just built-in validation attributes.\
    \ If you have complex validation rules, you can consider using `FluentValidation`.\
    \ For more details, please refer to the official documentation: [https://docs.fluentvalidation.net/en/latest/index.html](https://docs.fluentvalidation.net/en/latest/index\uFEFF\
    .html)."
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: "`FluentValidation` 除了内置的验证属性外，还有更多功能。如果您有复杂的验证规则，可以考虑使用 `FluentValidation`。有关更多详细信息，请参阅官方文档：[https://docs.fluentvalidation.net/en/latest/index.html](https://docs.fluentvalidation.net/en/latest/index\uFEFF\
    .html)。"
- en: Health checks
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康检查
- en: To monitor the application, we need to know whether the application is running
    correctly or not. We can perform health checks to monitor the application. Normally,
    a health check is an endpoint that returns the health status of the application.
    This status can be *Healthy*, *Degraded*, or *Unhealthy*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了监控应用程序，我们需要知道应用程序是否正在正确运行。我们可以执行健康检查来监控应用程序。通常，健康检查是一个返回应用程序健康状态的端点。此状态可以是
    *Healthy*（健康）、*Degraded*（降级）或 *Unhealthy*（不健康）。
- en: A health check is a critical part of the microservice architecture. In the microservice
    architecture, one API service may have multiple instances and also have dependencies
    on other services. A load balancer or orchestrator can be used to distribute the
    traffic to different instances. If one instance is unhealthy, the load balancer
    or orchestrator can stop sending traffic to the unhealthy instance. For example,
    Kubernetes – a popular container orchestrator – can use health checks to determine
    whether a container is healthy or not. If a container is not live, Kubernetes
    will restart the container.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查是微服务架构的关键部分。在微服务架构中，一个API服务可能有多个实例，并且可能依赖于其他服务。可以使用负载均衡器或编排器将流量分发到不同的实例。如果某个实例不健康，负载均衡器或编排器可以停止向该不健康的实例发送流量。例如，Kubernetes
    – 一个流行的容器编排器 – 可以使用健康检查来确定容器是否健康。如果一个容器没有运行，Kubernetes将重新启动该容器。
- en: We won’t discuss the details of Kubernetes in this book. Instead, we will focus
    on how to implement health checks for Kubernetes in ASP.NET Core web API applications.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在本书中讨论Kubernetes的细节。相反，我们将专注于如何在ASP.NET Core Web API应用程序中实现Kubernetes的健康检查。
- en: Implementing a basic health check
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现基本健康检查
- en: 'ASP.NET Core provides a straightforward way to configure health checks. We
    can use the `AddHealthChecks` method to add health checks to the application.
    Open the `Program.cs` file and add the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 提供了一种简单直接的方式来配置健康检查。我们可以使用 `AddHealthChecks` 方法将健康检查添加到应用程序中。打开
    `Program.cs` 文件并添加以下代码：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code adds a basic health check to the application. The health
    check’s endpoint is `/healthcheck`. Run the application and send a `GET` request
    to the `/healthcheck` endpoint. If successful, the application will return a `200`
    response with `Healthy` in plain text in the response body.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码向应用程序添加了一个基本健康检查。健康检查的端点是 `/healthcheck`。运行应用程序并向 `/healthcheck` 端点发送 `GET`
    请求。如果成功，应用程序将返回一个包含纯文本 `Healthy` 的 `200` 响应。
- en: However, this health check is too simple. In the real world, a web API application
    may be more complex. It may have multiple dependencies, such as databases, message
    queues, and other services. We need to check the health status of these dependencies.
    If some core dependencies are unhealthy, the application should be unhealthy.
    Let’s see how to implement a more complex health check.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个健康检查过于简单。在现实世界中，一个Web API应用程序可能更复杂。它可能有多个依赖项，例如数据库、消息队列和其他服务。我们需要检查这些依赖项的健康状态。如果某些核心依赖项不健康，应用程序应该是不健康的。让我们看看如何实现一个更复杂的健康检查。
- en: Implementing a complex health check
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现复杂的健康检查
- en: 'A health check implementation class implements the `IHealthCheck` interface.
    The `IHealthCheck` interface is defined as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查实现类实现了`IHealthCheck`接口。`IHealthCheck`接口定义如下：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can create a custom health check implementation to ensure the proper functioning
    of our API. For instance, if the API depends on another service, we can create
    a health check implementation to verify the health status of the dependent service.
    If the dependent service is unhealthy, the API won’t be able to function correctly.
    Here is an example of a health check implementation:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个自定义的健康检查实现来确保我们的API正常运行。例如，如果API依赖于另一个服务，我们可以创建一个健康检查实现来验证依赖服务的健康状态。如果依赖服务不健康，API将无法正确运行。以下是一个健康检查实现的示例：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, we create a health check implementation to check the
    health status of the [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts)
    endpoint. If the endpoint returns a 200 response, the health check returns healthy.
    Otherwise, the health check returns unhealthy.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个健康检查实现来检查[https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts)端点的健康状态。如果端点返回200响应，健康检查返回健康。否则，健康检查返回不健康。
- en: 'Next, we need to register the health check implementation in the application.
    Open the `Program.cs` file and add the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在应用程序中注册健康检查实现。打开`Program.cs`文件并添加以下代码：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code is similar to the previous health check. First, we use the `AddHealthChecks`
    method to register the strongly typed health check implementation. Then, we use
    the `MapHealthCheck` method to map the `/other-service-health-check` endpoint
    to the health check implementation. We also use the `HealthCheckOptions` object
    to specify the name of the health check, which is used to filter the health checks.
    If we do not specify the name of the health check, all health check implementations
    will be executed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码与之前的健康检查类似。首先，我们使用`AddHealthChecks`方法注册强类型健康检查实现。然后，我们使用`MapHealthCheck`方法将`/other-service-health-check`端点映射到健康检查实现。我们还使用`HealthCheckOptions`对象指定健康检查的名称，该名称用于过滤健康检查。如果我们没有指定健康检查的名称，则将执行所有健康检查实现。
- en: Run the application and send a `GET` request to the `/other-service-health-check`
    endpoint. If the dependent service, `https://jsonplaceholder.typicode.com/posts`,
    is healthy, the application will return a 200 response with `Healthy` in plain
    text in the response body.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并向`/other-service-health-check`端点发送`GET`请求。如果依赖服务`https://jsonplaceholder.typicode.com/posts`是健康的，应用程序将返回一个包含响应体中纯文本`Healthy`的200响应。
- en: 'Sometimes, we need to check multiple dependent services. We can register multiple
    health check implementations with a specific tag, at which point we can use this
    tag to filter the health checks. The following code shows how to register multiple
    health check implementations:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要检查多个依赖服务。我们可以使用特定标签注册多个健康检查实现，此时我们可以使用此标签来过滤健康检查。以下代码展示了如何注册多个健康检查实现：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding code, we register three health check implementations with
    the same tag – that is, `other-service`. Now, we can use the tag to filter the
    health checks. The following code shows how to filter the health checks:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用相同的标签`other-service`注册了三个健康检查实现。现在，我们可以使用这个标签来过滤健康检查。以下代码展示了如何过滤健康检查：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Like the `Name` property, we can use the `Tags` property to filter the health
    checks. When we send a `GET` request to the `/other-services-health-check` endpoint,
    the application will return a `200 OK` response with `Healthy` in plain text in
    the response body if all dependent services are healthy. But if one of the dependent
    services is unhealthy, the health check will return a `503 Service Unavailable`
    response with `Unhealthy` in plain text in the response body.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Name`属性类似，我们可以使用`Tags`属性来过滤健康检查。当我们向`/other-services-health-check`端点发送`GET`请求时，如果所有依赖服务都健康，应用程序将返回一个包含响应体中纯文本`Healthy`的`200
    OK`响应。但如果其中一个依赖服务不健康，健康检查将返回一个包含响应体中纯文本`Unhealthy`的`503 Service Unavailable`响应。
- en: Important note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If the `MapHealthChecks()` method does not use the `HealthCheckOptions` parameter,
    the health check endpoint will run all registered health checks by default.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`MapHealthChecks()`方法没有使用`HealthCheckOptions`参数，默认情况下健康检查端点将运行所有已注册的健康检查。
- en: Implementing a database health check
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现数据库健康检查
- en: In the previous section, we discussed how to implement a health check for a
    dependent service. As databases are a common component of web API applications,
    this section will focus on how to implement a database health check.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了如何实现依赖服务的健康检查。由于数据库是 Web API 应用程序的一个常见组件，本节将重点介绍如何实现数据库健康检查。
- en: 'The approach to implementing a database health check is similar to what we
    covered in the previous section: we need to connect to the database and execute
    a simple query to check if the database is healthy. If you use EF Core to access
    the database, you can use the `Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore`
    package to implement a database health check. This package provides a health check
    implementation for EF Core, so we do not need to write the health check implementation
    ourselves. Run the following command in the terminal to install the package:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 实现数据库健康检查的方法与我们前面讨论的类似：我们需要连接到数据库并执行一个简单的查询来检查数据库是否健康。如果您使用 EF Core 访问数据库，可以使用
    `Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore` 包来实现数据库健康检查。此包为
    EF Core 提供了健康检查实现，因此我们不需要自己编写健康检查实现。在终端中运行以下命令来安装此包：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the sample project, we have an `InvoiceDbContext` class to access the database.
    The following code shows how to register the `InvoiceDbContext` class in the application:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例项目中，我们有一个 `InvoiceDbContext` 类来访问数据库。以下代码显示了如何在应用程序中注册 `InvoiceDbContext`
    类：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once you’ve done this, register the EF Core `DbContext` health check implementation,
    as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，注册 EF Core `DbContext` 健康检查实现，如下所示：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Similarly, assign a tag to the health check implementation so that we can filter
    the health checks. Then, we can map the health check endpoint to the health check’s
    implementation, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，为健康检查实现分配一个标签，以便我们可以过滤健康检查。然后，我们可以将健康检查端点映射到健康检查的实现，如下所示：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Run the application and send a `GET` request to the `/database-health-checks`
    endpoint. If the database is healthy, the application will return a `200 OK` response
    with `Healthy` in plain text in the response body. Additionally, you can register
    multiple health checks for different databases if necessary.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并向 `/database-health-checks` 端点发送一个 `GET` 请求。如果数据库健康，应用程序将返回一个包含纯文本中的
    `Healthy` 的 `200 OK` 响应。此外，如果需要，您可以注册多个健康检查以针对不同的数据库。
- en: Important note
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you are using other ORMs to access the database, you can create a custom
    health check implementation following the previous section. This can be done by
    executing a simple query, such as `SELECT 1`, to determine whether the database
    is functioning properly.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用其他 ORM 访问数据库，可以按照前面的章节创建一个自定义的健康检查实现。这可以通过执行一个简单的查询，例如 `SELECT 1`，来确定数据库是否正常运行。
- en: Understanding readiness and liveness
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解就绪性和活跃性
- en: In the previous sections, we discussed how to implement health checks for ASP.NET
    Core web API applications. In the real world, we may need to deploy the applications
    to a container orchestrator, such as Kubernetes. Kubernetes is a popular container
    orchestrator that can manage containerized applications, monitor health statuses,
    and scale up or down based on workload. Kubernetes uses the term **probe**, which
    is similar to health checks, to monitor the health status of the applications.
    While this book does not cover the details of Kubernetes, it will discuss how
    to implement Kubernetes probes in ASP.NET Core web API applications.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了如何为 ASP.NET Core Web API 应用程序实现健康检查。在现实世界中，我们可能需要将应用程序部署到容器编排器，例如
    Kubernetes。Kubernetes 是一个流行的容器编排器，可以管理容器化应用程序，监控健康状态，并根据工作负载进行扩展或缩减。Kubernetes
    使用术语 **probe**，类似于健康检查，来监控应用程序的健康状态。虽然本书没有涵盖 Kubernetes 的详细信息，但它将讨论如何在 ASP.NET
    Core Web API 应用程序中实现 Kubernetes 探针。
- en: 'Kubernetes has three types of probes: *readiness*, *liveness*, and *startup*.
    Let’s take a closer look:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 有三种类型的探针：*就绪性*、*活跃性*和*启动性*。让我们更深入地了解一下：
- en: '`liveness`: This probe indicates whether the application is running correctly.
    Kubernetes performs a `liveness` probe every few seconds. If the application does
    not respond to the `liveness` probe for a specified period, the container will
    be killed and Kubernetes will create a new one to replace it. The `liveness` probe
    can execute either an HTTP request, a command, or a TCP socket check. It also
    supports gRPC health checks.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`liveness`：这个探针表示应用程序是否运行正确。Kubernetes每隔几秒执行一次`liveness`探针。如果应用程序在指定时间内没有响应`liveness`探针，容器将被杀死，Kubernetes将创建一个新的容器来替换它。`liveness`探针可以执行HTTP请求、命令或TCP套接字检查。它还支持gRPC健康检查。'
- en: '`readiness`: This probe is used to determine whether the application is ready
    to receive traffic. Some applications need to perform some initialization tasks
    before they can receive traffic, such as connecting to the database, loading configuration,
    checking the dependent services, and so on. During this period, the application
    cannot receive traffic, but this does not mean that the application is unhealthy.
    Kubernetes should not kill the application and restart it. After the initialization
    is complete and all dependent services are healthy, the `readiness` probe will
    inform Kubernetes that the application is ready to receive traffic.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readiness`：这个探针用于确定应用程序是否准备好接收流量。一些应用程序在能够接收流量之前需要执行一些初始化任务，例如连接到数据库、加载配置、检查依赖的服务等。在此期间，应用程序不能接收流量，但这并不意味着应用程序不健康。Kubernetes不应该杀死应用程序并重启它。初始化完成后，所有依赖的服务都健康时，`readiness`探针将通知Kubernetes应用程序已准备好接收流量。'
- en: '`startup`: This probe is similar to the `readiness` probe. However, the difference
    is that the `startup` probe is only executed once the application starts. It is
    used to determine whether the application has completed the initialization process.
    If this probe is configured, the `liveness` and `readiness` probes will not be
    executed until the `startup` probe is successful.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startup`：这个探针与`readiness`探针类似。然而，区别在于`startup`探针只在应用程序启动后执行一次。它用于确定应用程序是否完成了初始化过程。如果配置了这个探针，`liveness`和`readiness`探针将不会执行，直到`startup`探针成功。'
- en: Configuring the probes incorrectly may cause cascading failures. For example,
    service A depends on service B and service B depends on service C. If the `liveness`
    probes are misconfigured incorrectly to check the dependent services when service
    C is unhealthy, service A and service B will be restarted, which does not solve
    the problem. This is a cascading failure. In this case, service A and service
    B should not be restarted. Instead, only service C should be restarted.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 配置探针不正确可能会导致级联故障。例如，服务A依赖于服务B，而服务B又依赖于服务C。如果`liveness`探针配置错误，在服务C不健康时检查依赖的服务，服务A和服务B将会被重启，但这并不能解决问题。这是一个级联故障。在这种情况下，服务A和服务B不应该被重启。相反，只需重启服务C即可。
- en: 'Here’s an example of a `liveness` HTTP probe configuration for Kubernetes:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个Kubernetes中`liveness` HTTP探针配置的示例：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the configuration, we define the following properties:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置中，我们定义了以下属性：
- en: '`path`, `port`, and `httpHeaders`: These properties are used to configure the
    HTTP request. In the preceding example, we specify a custom HTTP header called
    `Custom-Header` with a value of `X-Health-Check`. The application can use this
    HTTP header to identify whether the request is a health check request. If the
    request does not have this HTTP header, the application can deny the request.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`、`port`和`httpHeaders`：这些属性用于配置HTTP请求。在先前的例子中，我们指定了一个名为`Custom-Header`的自定义HTTP头，其值为`X-Health-Check`。应用程序可以使用这个HTTP头来识别请求是否为健康检查请求。如果请求没有这个HTTP头，应用程序可以拒绝该请求。'
- en: '`initialDelaySeconds`: This property is used to specify the number of seconds
    after the container has started before the first probe is executed. The default
    value is 0\. Do not use a high value for this property. You can use the `startup`
    probe to check the initialization of the application instead.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialDelaySeconds`：此属性用于指定容器启动后执行第一次探针之前需要等待的秒数。默认值为0。不要为这个属性使用一个很高的值。你可以使用`startup`探针来检查应用程序的初始化。'
- en: '`periodSeconds`: This property is used to specify the number of seconds between
    each probe. The default value is 10\. The minimum value is 1\. You can adjust
    this value based on your scenarios. Make sure Kubernetes can discover the unhealthy
    container as soon as possible.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`periodSeconds`: 这个属性用于指定每次探测之间的秒数。默认值是 10，最小值是 1。你可以根据你的场景调整这个值。确保 Kubernetes
    能够尽快发现不健康的容器。'
- en: '`timeoutSeconds`: This property is used to specify the number of seconds after
    which the probe times out. The default value is 1 and the minimum value is also
    1\. Make sure the probe is fast.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeoutSeconds`: 这个属性用于指定探测超时的秒数。默认值是 1，最小值也是 1。确保探测足够快。'
- en: '`successThreshold`: This property is used to determine the number of consecutive
    successful responses required for a probe to be considered successful after having
    previously failed. The value must be 1 for liveness probes.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`successThreshold`: 这个属性用于确定在探测之前失败后，需要连续成功响应的次数，才能认为探测成功。对于存活探测，这个值必须是 1。'
- en: '`failureThreshold`: This property is used to specify the number of consecutive
    failures for the probe to be considered failed after having succeeded. Do not
    use a high value for this property; otherwise, Kubernetes needs to wait a long
    time to restart the container.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`failureThreshold`: 这个属性用于指定探测在成功后连续失败的次数，才能被认为失败。不要为这个属性设置过高的值；否则，Kubernetes
    需要等待很长时间才能重启容器。'
- en: Keep in mind that the `liveness` probe should not depend on other services.
    In other words, do not check the health status of other services in the `liveness`
    probe. Instead, this probe should only check whether the application can respond
    to the request.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`liveness` 探测不应该依赖于其他服务。换句话说，不要在 `liveness` 探测中检查其他服务的健康状态。相反，这个探测应该只检查应用程序是否能够响应请求。
- en: 'An example of a `readiness` HTTP probe’s configuration is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个 `readiness` HTTP 探测配置的示例：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'There are a few different considerations for the `readiness` probe:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `readiness` 探测，有几个不同的考虑因素：
- en: '`successThreshold`: The default value is 1\. However, we can increase this
    value to make sure the application is ready to receive traffic.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`successThreshold`: 默认值是 1。然而，我们可以增加这个值以确保应用程序准备好接收流量。'
- en: '`failureThreshold`: After at least `failureThreshold` probes have failed, Kubernetes
    will stop sending traffic to the container. As the application may have temporary
    problems, we can allow a few failures before the application is considered unhealthy.
    However, do not use a high value for this property.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`failureThreshold`: 在至少有 `failureThreshold` 次探测失败后，Kubernetes 将停止向容器发送流量。由于应用程序可能存在暂时性问题，我们可以在认为应用程序不健康之前允许几次失败。然而，不要为这个属性设置过高的值。'
- en: 'If the application takes a long time to initialize, we can use the `startup`
    probe to check the initialization of the application. An example of a `startup`
    HTTP probe configuration is shown here:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序初始化需要很长时间，我们可以使用 `startup` 探测来检查应用程序的初始化。这里展示了 `startup` HTTP 探测配置的一个示例：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this configuration, the `startup` probe will be executed every 5 seconds,
    and the application will have a maximum of 150 seconds (5 * 30 = 150 seconds)
    to complete the initialization. `successThreshold` must be 1 so that once the
    `startup` probe is successful, the `liveness` and `readiness` probes will be executed.
    If the `startup` probe fails after 150 seconds (about 2 and a half minutes), Kubernetes
    will kill the container and start a new one. So, ensure that the `startup` probe
    has enough time to complete the initialization.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配置中，`startup` 探测将每 5 秒执行一次，应用程序将有最多 150 秒（5 * 30 = 150 秒）的时间来完成初始化。`successThreshold`
    必须是 1，这样一旦 `startup` 探测成功，`liveness` 和 `readiness` 探测将被执行。如果 `startup` 探测在 150
    秒后（大约 2 分半钟）失败，Kubernetes 将杀死容器并启动一个新的。因此，确保 `startup` 探测有足够的时间来完成初始化。
- en: Configuring Kubernetes probes is not a simple task. We need to consider many
    factors. For example, should we check the dependent services in the `readiness`
    probe? If the application can partially operate without a specific dependent service,
    it can be considered as degraded instead of unhealthy. In this case, if the application
    has mechanisms to handle transient failures gracefully, it might be acceptable
    to omit specific dependent services in the `readiness` probe. So, please consider
    your scenarios carefully; you may need a compromise when configuring the probes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 Kubernetes 探针不是一个简单的任务。我们需要考虑许多因素。例如，我们应该在`readiness`探针中检查依赖服务吗？如果应用程序在没有特定依赖服务的情况下可以部分运行，那么它应该被视为降级而不是不健康。在这种情况下，如果应用程序有处理短暂故障的机制，那么在`readiness`探针中省略特定依赖服务可能是可以接受的。所以，请仔细考虑您的场景；在配置探针时，您可能需要做出妥协。
- en: 'This section is not intended to cover all the details of Kubernetes probes.
    For more details, please refer to the following official documentation:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目的不是涵盖 Kubernetes 探针的所有细节。有关更多详细信息，请参阅以下官方文档：
- en: 'Kubernetes documentation: [https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/).'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 文档：[https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/)。
- en: "Health checks in ASP.NET Core: [https://learn.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks](https://learn.microsoft.com/en-us/aspnet/core/host-\uFEFF\
    and-deploy/health-checks)."
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: "ASP.NET Core 中的健康检查：[https://learn.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks](https://learn.microsoft.com/en-us/aspnet/core/host-\uFEFF\
    and-deploy/health-checks)。"
- en: Monitoring and observability
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控和可观测性
- en: In the real world, building an application is just the first step. We also need
    to monitor and observe how the application is performing. This is where the concept
    of *observability* comes in. In this section, we will discuss observability and
    how to use OpenTelemetry to monitor and observe applications.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，构建应用程序只是第一步。我们还需要监控和观察应用程序的性能。这就是**可观测性**概念出现的地方。在本节中，我们将讨论可观测性以及如何使用
    OpenTelemetry 来监控和观察应用程序。
- en: What is observability?
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是可观测性？
- en: In [*Chapter 4*](B18971_04.xhtml#_idTextAnchor170), we introduced logging in
    ASP.NET Core web API applications. We learned how to use the built-in logging
    framework to log messages to different logging providers. **Observability** is
    a more comprehensive concept than logging. Besides logging, observability allows
    us to gain a deeper understanding of how the application is performing. For instance,
    we can determine how many requests are processed in a given hour, what the request
    latency is, and how requests are handled by multiple services in a microservice
    architecture. All of these are part of observability.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B18971_04.xhtml#_idTextAnchor170)中，我们介绍了 ASP.NET Core Web API 应用程序中的日志记录。我们学习了如何使用内置的日志框架将消息记录到不同的日志提供者。**可观测性**是一个比日志更全面的概念。除了日志之外，可观测性还允许我们更深入地了解应用程序的性能。例如，我们可以确定在给定小时内处理了多少请求，请求的延迟是多少，以及如何在微服务架构中处理请求。所有这些都是可观测性的组成部分。
- en: 'In general, observability has three pillars:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，可观测性有三个支柱：
- en: '**Logs**: Logs are used to record what is happening within the application,
    such as incoming requests, outgoing responses, important business logic executions,
    exceptions, errors, warnings, and so on.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志**：日志用于记录应用程序内部发生的事情，例如传入请求、传出响应、重要的业务逻辑执行、异常、错误、警告等等。'
- en: '**Metrics**: Metrics are used to measure the performance of the application,
    such as the number of requests, the request latency, error rates, resource usage,
    and so on. These metrics can be used to trigger alerts when the application is
    not performing well.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指标**：指标用于衡量应用程序的性能，例如请求数量、请求延迟、错误率、资源使用情况等等。这些指标可以在应用程序表现不佳时触发警报。'
- en: '**Traces**: Traces are used to track the flow of requests across multiple services
    to identify where the time is spent or where the errors occur. This is especially
    useful in the microservice architecture.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪**：跟踪用于跟踪跨多个服务的请求流，以确定时间花费在哪里或错误发生在哪里。这在微服务架构中特别有用。'
- en: To summarize, observability is the practice of understanding the application’s
    internal state and operational characteristics by analyzing its logs, metrics,
    and traces. There are a few different ways to implement observability in ASP.NET
    Core web API applications – we can update the source code to add logging, metrics,
    and traces or use tools to monitor and observe the application without changing
    the code. In this section, we will discuss the first approach by using OpenTelemetry
    to implement observability in ASP.NET Core web API applications. This gives us
    more flexibility to customize the observability aspect.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，可观测性是通过分析应用程序的日志、指标和跟踪来理解其内部状态和操作特性的实践。在 ASP.NET Core web API 应用程序中实现可观测性有几种不同的方法——我们可以更新源代码以添加日志、指标和跟踪，或者使用工具来监控和观察应用程序而不改变代码。在本节中，我们将通过使用
    OpenTelemetry 来实现 ASP.NET Core web API 应用程序的可观测性来讨论第一种方法。这为我们提供了更多的灵活性来自定义可观测性方面。
- en: Using OpenTelemetry to collect observability data
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 OpenTelemetry 收集可观测性数据
- en: OpenTelemetry is a popular cross-platform, open-source standard for collecting
    observability data. It provides a set of APIs, SDKs, and tools to instrument,
    generate, collect, and export telemetry data so that we can analyze the application’s
    performance and behavior. It supports many platforms and languages, as well as
    popular cloud providers. You can find more details about OpenTelemetry at [https://opentelemetry.io/](https://opentelemetry.io/).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry 是一个流行的跨平台、开源标准，用于收集可观测性数据。它提供了一套 API、SDK 和工具，用于对应用程序进行仪器化、生成、收集和导出遥测数据，以便我们可以分析应用程序的性能和行为。它支持许多平台和语言，以及流行的云提供商。您可以在
    [https://opentelemetry.io/](https://opentelemetry.io/) 找到有关 OpenTelemetry 的更多详细信息。
- en: 'The .NET OpenTelemetry implementation consists of the following components:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: .NET OpenTelemetry 实现包括以下组件：
- en: '**Core API**: The core API is a set of interfaces and classes that define the
    OpenTelemetry API. It is a platform-independent API that can be used to instrument
    the application.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心 API**：核心 API 是一组接口和类，它定义了 OpenTelemetry API。这是一个平台无关的 API，可以用来对应用程序进行仪器化。'
- en: '**Instrumentation**: This is a set of libraries that can be used to collect
    instrumentation from the application. This component includes multiple packages
    for different frameworks and platforms, such as ASP.NET Core, gRPC, HTTP calls,
    SQL database operations, and so on.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪器化**：这是一组库，可以用来从应用程序中收集仪器化数据。该组件包括针对不同框架和平台的多达多个包，例如 ASP.NET Core、gRPC、HTTP
    调用、SQL 数据库操作等。'
- en: '**Exporters**: Exporters are used to export the collected telemetry data to
    different targets, such as console and **Application Performance Monitoring**
    (**APM**) systems, including Prometheus, Zipkin, and so on.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导出器**：导出器用于将收集到的遥测数据导出到不同的目标，例如控制台和 **应用程序性能监控**（**APM**）系统，包括 Prometheus、Zipkin
    等。'
- en: In [*Chapter 4*](B18971_04.xhtml#_idTextAnchor170), we introduced using *Serilog*
    and *Seq* to collect logs. In the next few sections, we will focus on how to use
    OpenTelemetry to collect metrics and traces. We will use *Prometheus* to collect
    metrics and *Grafana* to visualize the metrics. We will also use *Jaeger* to collect
    traces. All these tools are open-source. In addition, we will explore Azure Application
    Insights, a powerful APM system provided by Microsoft.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 4 章*](B18971_04.xhtml#_idTextAnchor170) 中，我们介绍了使用 *Serilog* 和 *Seq* 来收集日志。在接下来的几节中，我们将重点介绍如何使用
    OpenTelemetry 来收集指标和跟踪。我们将使用 *Prometheus* 来收集指标，并使用 *Grafana* 来可视化指标。我们还将使用 *Jaeger*
    来收集跟踪。所有这些工具都是开源的。此外，我们还将探索由微软提供的强大 APM 系统 Azure Application Insights。
- en: Integrating OpenTelemetry with ASP.NET Core web API applications
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 OpenTelemetry 集成到 ASP.NET Core web API 应用程序中
- en: 'In this section, we will explore how to use metrics in ASP.NET Core web API
    applications. In the sample project, we have an `InvoiceController` class to manage
    invoices. We want to know how many requests are executed and the duration of each
    request. We have several steps to perform:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何在 ASP.NET Core web API 应用程序中使用指标。在示例项目中，我们有一个 `InvoiceController`
    类来管理发票。我们想知道执行了多少个请求以及每个请求的持续时间。我们需要执行以下几个步骤：
- en: Define the metrics for these activities.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义这些活动的指标。
- en: Generate and collect instrumentation data.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成和收集仪器化数据。
- en: Visualize the data in a dashboard.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仪表板上可视化数据。
- en: 'To start, we need to install some NuGet packages using the following commands:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用以下命令安装一些 NuGet 包：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: These packages include the required .NET OpenTelemetry implementations. Note
    that at the time of writing, some packages did not have stable versions available,
    so we needed to use the `--prerelease` option to install the latest preview versions.
    If you are reading this book when the stable versions are available, you can omit
    the `--``prerelease` option.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包包括所需的 .NET OpenTelemetry 实现。请注意，在编写本文时，一些包没有提供稳定的版本，因此我们需要使用 `--prerelease`
    选项来安装最新的预览版本。如果您在稳定版本可用时阅读此书，可以省略 `--prerelease` 选项。
- en: 'Next, we must define the metrics. In this example, we want to know how many
    requests are executed for each action for the `/api/Invoices` endpoint. Create
    a new class named `InvoiceMetrics` in the `\OpenTelemetry\Metrics` folder. The
    following code shows how to define the metrics:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须定义指标。在这个例子中，我们想知道 `/api/Invoices` 端点每个操作执行了多少请求。在 `\OpenTelemetry\Metrics`
    文件夹中创建一个新的名为 `InvoiceMetrics` 的类。以下代码显示了如何定义指标：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `IMeterFactory` interface is registered in ASP.NET Core’s DI container by
    default and is used to create a meter. This meter, which is called `MyWebApiDemo.Invoice`,
    is used to record the metrics. Additionally, four counters are created to record
    the number of requests for each action. To facilitate this, four public methods
    are exposed to increment the counters.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`IMeterFactory` 接口默认注册在 ASP.NET Core 的 DI 容器中，并用于创建度量器。这个名为 `MyWebApiDemo.Invoice`
    的度量器用于记录指标。此外，还创建了四个计数器来记录每个操作的请求数量。为此，我们公开了四个公共方法来增加计数器。'
- en: 'The name of each metric must be unique. When we create a metric or a counter,
    it is recommended to follow the OpenTelemetry naming guidelines: [https://github.com/open-telemetry/semantic-conventions/blob/main/docs/general/metrics.md#general-guidelines](https://github.com/open-telemetry/semantic-conventions/blob/main/docs/general/metrics.md#general-guidelines).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 每个指标名称必须是唯一的。当我们创建一个指标或计数器时，建议遵循 OpenTelemetry 命名指南：[https://github.com/open-telemetry/semantic-conventions/blob/main/docs/general/metrics.md#general-guidelines](https://github.com/open-telemetry/semantic-conventions/blob/main/docs/general/metrics.md#general-guidelines)。
- en: 'Next, we need to register the metrics in the application. Add the following
    code to the `Program.cs` file:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在应用程序中注册指标。将以下代码添加到 `Program.cs` 文件中：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, we used the `AddOpenTelemetry()` method to register the
    OpenTelemetry services. The `ConfigureResource()` method registers the service
    name. Inside the `WithMetrics()` method, we use the `AddConsoleExporter()` method
    to add a console exporter. This console exporter is useful for local development
    and debugging. We also added three meters, including the ASP.NET Core hosting
    and Kestrel server, so that we can collect the metrics from the ASP.NET Core web
    API framework. Finally, we registered the `InvoiceMetrics` class in the dependency
    injection container as a singleton.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了 `AddOpenTelemetry()` 方法来注册 OpenTelemetry 服务。`ConfigureResource()`
    方法用于注册服务名称。在 `WithMetrics()` 方法内部，我们使用 `AddConsoleExporter()` 方法添加一个控制台导出器。这个控制台导出器对于本地开发和调试非常有用。我们还添加了三个度量器，包括
    ASP.NET Core 托管和 Kestrel 服务器，以便我们可以从 ASP.NET Core Web API 框架收集指标。最后，我们将 `InvoiceMetrics`
    类注册到依赖注入容器中作为一个单例。
- en: 'Next, we can use the `InvoiceMetrics` class to record the metrics. Open the
    `InvoiceController` class and call the `IncrementCreate()` method in the `Post`
    action, as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用 `InvoiceMetrics` 类来记录指标。打开 `InvoiceController` 类，在 `Post` 动作中调用 `IncrementCreate()`
    方法，如下所示：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The other actions are similar. Before we check the metrics in the console,
    we need to install the **dotnet-counters** tool, a command-line tool for viewing
    live metrics. Run the following command in the terminal to install the tool:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 其他操作类似。在我们检查控制台中的指标之前，我们需要安装 **dotnet-counters** 工具，这是一个用于查看实时指标的命令行工具。在终端中运行以下命令来安装该工具：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, we can use the `dotnet counters` command to view the metrics. We can
    check the metrics from `Microsoft.AspNetCore.Hosting` using the following command:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `dotnet counters` 命令来查看指标。我们可以使用以下命令检查 `Microsoft.AspNetCore.Hosting`
    的指标：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Run the application and send some requests to the `/api/Invoices` endpoint.
    You will see the following metrics:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并向 `/api/Invoices` 端点发送一些请求。您将看到以下指标：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, you can see the metrics for the HTTP actions, including the active requests
    and the request duration. You can use this tool to observe more performance metrics,
    such as CPU usage or the rate of exceptions being thrown in the application. For
    more information about this tool, please refer to the official documentation:
    [https://learn.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-counters](https://learn.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-counters).'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到HTTP操作的指标，包括活跃请求和请求持续时间。你可以使用这个工具来观察更多性能指标，例如CPU使用率或应用程序中抛出的异常率。有关此工具的更多信息，请参阅官方文档：[https://learn.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-counters](https://learn.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-counters)。
- en: 'To check the custom metrics via `InvoiceMetrics`, you need to specify the `--counters`
    option in the command, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过`InvoiceMetrics`检查自定义指标，你需要在命令中指定`--counters`选项，如下所示：
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output may look like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可能看起来像这样：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, you can see the metrics we defined in the `invoiceMetrics` class. Note
    that you can include multiple counters in the `--counters` option, separated by
    commas. For example, you can use the following command to check the metrics for
    both `Microsoft.AspNetCore.Hosting` and `MyWebApiDemo.Invoice`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们在`invoiceMetrics`类中定义的指标。请注意，你可以在`--counters`选项中包含多个计数器，用逗号分隔。例如，你可以使用以下命令来检查`Microsoft.AspNetCore.Hosting`和`MyWebApiDemo.Invoice`的指标：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the `InvoiceMetrics` class, we defined four counters. There are more types
    of instruments in OpenTelemetry, such as `Gauge`, `Histogram`, and others. Here
    are some of the different types of instruments that are available:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在`InvoiceMetrics`类中，我们定义了四个计数器。OpenTelemetry中还有更多类型的仪表，例如`Gauge`、`Histogram`等。以下是一些可用的不同类型仪表的示例：
- en: '`Counter`: A counter is used to track a value that can only increase over time
    – for example, the number of requests after the application starts.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Counter`: 计数器用于跟踪随时间只能增加的值——例如，应用程序启动后的请求数量。'
- en: '`UpDownCounter`: An up-down counter is similar to a counter, but it can increase
    or decrease over time. An example of this is the number of active requests. When
    a request starts, the counter increases by 1\. When the request ends, the counter
    decreases by 1\. It can also be used to monitor the size of a queue.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpDownCounter`: 上下载计数器类似于计数器，但它可以随时间增加或减少。一个例子是活跃请求数量。当请求开始时，计数器增加1。当请求结束时，计数器减少1。它还可以用来监控队列的大小。'
- en: '`Gauge`: A gauge measures a current value at a specific point in time, such
    as CPU usage or memory usage.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Gauge`: 仪表测量在特定时间点的当前值，例如CPU使用率或内存使用率。'
- en: '`Histogram`: A histogram measures the statistical distribution of values using
    aggregations. For example, a histogram can measure how many requests are processed
    longer than a specific duration.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Histogram`: 直方图通过聚合测量值的统计分布。例如，直方图可以测量处理时间超过特定持续时间的请求数量。'
- en: 'We can define more metrics to monitor the application. Define an `UpDownCounter`
    instrument to track how many active requests there are for the `/api/Invoices`
    endpoint. Update the `InvoiceMetrics` class, as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义更多指标来监控应用程序。定义一个`UpDownCounter`仪表来跟踪`/api/Invoices`端点有多少活跃请求。更新`InvoiceMetrics`类，如下所示：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, update the `InvoiceController` class so that it increments and decrements
    the counter. For simplicity, we’ll just call the `IncrementRequest()` and `DecrementRequest()`
    methods in the controller. In the real world, it is recommended to use an ASP.NET
    Core middleware to handle this. The following code shows how to update the `InvoiceController`
    class:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，更新`InvoiceController`类，以便它增加和减少计数器。为了简单起见，我们将在控制器中调用`IncrementRequest()`和`DecrementRequest()`方法。在现实世界中，建议使用ASP.NET
    Core中间件来处理此操作。以下代码展示了如何更新`InvoiceController`类：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'An example of `Histogram` is shown here:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了`Histogram`的一个例子：
- en: '[PRE39]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, update the `InvoiceController` class so that it records the request’s
    duration. Similarly, we can just use the `RecordRequestDuration()` method in the
    controller. The following code shows how to update the `InvoiceController` class:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，更新`InvoiceController`类，以便它记录请求的持续时间。同样，我们可以在控制器中仅使用`RecordRequestDuration()`方法。以下代码展示了如何更新`InvoiceController`类：
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here, we use a `Task.Delay()` method to simulate latency. Run the application
    and send some requests to the `/api/Invoices` endpoint. Then, check the metrics
    using the `dotnet-counters` tool. You will see the metrics, as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `Task.Delay()` 方法来模拟延迟。运行应用程序并向 `/api/Invoices` 端点发送一些请求。然后，使用 `dotnet-counters`
    工具检查指标。您将看到以下指标：
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding output, the histogram instruments are shown as `Percentile=50`,
    `Percentile=95`, and `Percentile=99`. This is the default configuration for the
    `dotnet-counters` tool. We can use other tools, such as Prometheus and Grafana,
    to provide more visualization options. We will discuss this in the next section.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，直方图仪器显示为 `Percentile=50`、`Percentile=95` 和 `Percentile=99`。这是 `dotnet-counters`
    工具的默认配置。我们可以使用其他工具，如 Prometheus 和 Grafana，提供更多的可视化选项。我们将在下一节中讨论这一点。
- en: Using Prometheus to collect and query metrics
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Prometheus 收集和查询指标
- en: '**Prometheus** is a widely used open-source monitoring system. Prometheus was
    originally developed by SoundCloud ([https://soundcloud.com/](https://soundcloud.com/)),
    then joined the Cloud Native Computing Foundation ([https://cncf.io/](https://cncf.io/))
    in 2016\. Prometheus is capable of collecting metrics from a variety of sources,
    including applications, databases, operating systems, and more. It also offers
    a powerful query language for querying the collected metrics, as well as a dashboard
    to visualize them.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**Prometheus** 是一个广泛使用的开源监控系统。Prometheus 最初由 SoundCloud ([https://soundcloud.com/](https://soundcloud.com/))
    开发，然后在 2016 年加入了 Cloud Native Computing Foundation ([https://cncf.io/](https://cncf.io/))。Prometheus
    能够从各种来源收集指标，包括应用程序、数据库、操作系统等。它还提供了一种强大的查询语言来查询收集的指标，以及一个仪表板来可视化它们。'
- en: In this section, we will use Prometheus to collect metrics from the ASP.NET
    Core web API application and visualize the metrics.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 Prometheus 从 ASP.NET Core web API 应用程序收集指标并可视化这些指标。
- en: 'To install Prometheus, navigate to the official website: [https://prometheus.io/download/](https://prometheus.io/download/).
    Download the latest version of Prometheus for your operating system.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Prometheus，请导航到官方网站：[https://prometheus.io/download/](https://prometheus.io/download/)。下载适用于您操作系统的最新版本的
    Prometheus。
- en: 'Next, we need to configure the ASP.NET web API application to export metrics
    for Prometheus. Install the `OpenTelemetry.Exporter.Prometheus.AspNetCore` package
    in the ASP.NET Core web API project using the following command:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置 ASP.NET web API 应用程序以导出 Prometheus 的指标。使用以下命令在 ASP.NET Core web API
    项目中安装 `OpenTelemetry.Exporter.Prometheus.AspNetCore` 包：
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, register the Prometheus exporter in the `Program.cs` file, as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `Program.cs` 文件中注册 Prometheus 导出器，如下所示：
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, we have two exporters: the console exporter and the Prometheus exporter.
    If you don’t need the console exporter, you can remove it. We’re also using the
    `MapPrometheusScrapingEndpoint()` method to map the `/metrics` endpoint for the
    Prometheus exporter. This endpoint is used by Prometheus to scrape metrics from
    the application.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有两个导出器：控制台导出器和 Prometheus 导出器。如果您不需要控制台导出器，您可以将其删除。我们还在使用 `MapPrometheusScrapingEndpoint()`
    方法将 Prometheus 导出器的 `/metrics` 端点进行映射。此端点由 Prometheus 用于从应用程序中抓取指标。
- en: Next, we need to configure Prometheus to collect metrics from the ASP.NET Core
    web API application. Find the port number of the ASP.NET Core web API application.
    In the sample project, we use port number 5125 for HTTP. You can find the relevant
    port numbers in the `launchSettings.json` file.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置 Prometheus 以从 ASP.NET Core web API 应用程序收集指标。找到 ASP.NET Core web API
    应用程序的端口号。在示例项目中，我们使用 HTTP 的端口号 5125。您可以在 `launchSettings.json` 文件中找到相关的端口号。
- en: 'Open the `prometheus.yml` file in the Prometheus folder. Add a job at the end
    of the file, as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Prometheus 文件夹中打开 `prometheus.yml` 文件。在文件末尾添加一个作业，如下所示：
- en: '[PRE44]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `scrape_interval` property is set to specify the interval at which metrics
    should be scrapped. For testing purposes, this can be set to 5 seconds so that
    you can view metrics immediately. However, in production scenarios, it is recommended
    to set this to a higher value, such as 15 seconds. Additionally, ensure that the
    `targets` property is set to the correct port number before saving the file.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`scrape_interval` 属性用于指定收集指标的时间间隔。出于测试目的，这可以设置为 5 秒，以便您可以立即查看指标。然而，在生产场景中，建议将其设置为更高的值，例如
    15 秒。此外，在保存文件之前，请确保 `targets` 属性已设置为正确的端口号。'
- en: 'If you use HTTPS for the ASP.NET Core web API application, you need to specify
    the `schema` property, as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为 ASP.NET Core web API 应用程序使用 HTTPS，则需要指定 `schema` 属性，如下所示：
- en: '[PRE45]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Run the application and send some requests to the `/api/Invoices` endpoint.
    Navigate to the `/metrics` endpoint; you will see the relevant metrics:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并向 `/api/Invoices` 端点发送一些请求。导航到 `/metrics` 端点；你将看到相关的指标：
- en: '![Figure 16.4 – Metrics for Prometheus](img/B18971_16_04.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图16.4 – Prometheus的指标](img/B18971_16_04.jpg)'
- en: Figure 16.4 – Metrics for Prometheus
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4 – Prometheus的指标
- en: 'Now, we can run Prometheus by executing the `prometheus.exe` file. In the output,
    you will find the following line:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过执行 `prometheus.exe` 文件来运行Prometheus。在输出中，你会找到以下行：
- en: '[PRE46]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This means that Prometheus is running on port `9090`. Navigate to `http://localhost:9090`.
    You will see the Prometheus dashboard, as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着Prometheus正在9090端口上运行。导航到 `http://localhost:9090`。你将看到Prometheus仪表板，如下所示：
- en: '![Figure 16.5 – Prometheus dashboard](img/B18971_16_05.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图16.5 – Prometheus仪表板](img/B18971_16_05.jpg)'
- en: Figure 16.5 – Prometheus dashboard
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5 – Prometheus仪表板
- en: 'Prometheus will start to scrape metrics from the ASP.NET Core web API application
    we configured in the `prometheus.yml` file. Click **Status** | **Targets** at
    the top. You will see the following page, which shows the status of the ASP.NET
    Core web API application:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus将开始从我们在 `prometheus.yml` 文件中配置的ASP.NET Core Web API应用程序中抓取指标。点击**状态**
    | **目标**在顶部。你将看到以下页面，其中显示了ASP.NET Core Web API应用程序的状态：
- en: '![Figure 16.6 – Prometheus targets](img/B18971_16_06.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图16.6 – Prometheus目标](img/B18971_16_06.jpg)'
- en: Figure 16.6 – Prometheus targets
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6 – Prometheus目标
- en: 'Click **Graph** in the top menu. You will see the following page, which shows
    the available metrics. Click the **Open Metrics Explorer** button (highlighted
    in *Figure 16**.7*) to open **Metrics Explorer**:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部菜单中点击**图形**。你将看到以下页面，其中显示了可用的指标。点击**打开指标探索器**按钮（如图16.7中突出显示），以打开**指标探索器**：
- en: '![Figure 16.7 – Prometheus Metrics Explorer](img/B18971_16_07.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图16.7 – Prometheus指标探索器](img/B18971_16_07.jpg)'
- en: Figure 16.7 – Prometheus Metrics Explorer
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7 – Prometheus指标探索器
- en: 'Choose one metric, such as `mywebapidemo_invoices_read_total`, and click the
    **Execute** button. Then, click the **Graph** tab; you will see the following
    page, which shows the metric graph:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个指标，例如 `mywebapidemo_invoices_read_total`，然后点击**执行**按钮。接着，点击**图形**标签；你将看到以下页面，其中显示了指标图形：
- en: '![Figure 16.8 – Prometheus graph](img/B18971_16_08.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图16.8 – Prometheus图形](img/B18971_16_08.jpg)'
- en: Figure 16.8 – Prometheus graph
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8 – Prometheus图形
- en: 'Prometheus provides a powerful query language to query the metrics. For example,
    we can use the following query to get the `mywebapidemo.invoices.read` counter
    per minute:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus提供了一个强大的查询语言来查询指标。例如，我们可以使用以下查询来获取每分钟的 `mywebapidemo.invoices.read`
    计数器：
- en: '[PRE47]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You will see the following graph:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下图形：
- en: '![Figure 16.9 – Requests per minute](img/B18971_16_09.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图16.9 – 每分钟请求数](img/B18971_16_09.jpg)'
- en: Figure 16.9 – Requests per minute
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.9 – 每分钟请求数
- en: 'The following query can get the requests that take longer than 100 milliseconds:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询可以获取超过100毫秒的请求：
- en: '[PRE48]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '*Figure 16**.10* shows the result:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16.10*显示了结果：'
- en: '![Figure 16.10 – Requests that take longer than 100 milliseconds](img/B18971_16_10.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图16.10 – 超过100毫秒的请求](img/B18971_16_10.jpg)'
- en: Figure 16.10 – Requests that take longer than 100 milliseconds
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10 – 超过100毫秒的请求
- en: 'This section provided a brief introduction to Prometheus. For more information
    about the querying language syntax, please refer to the official documentation:
    [https://prometheus.io/docs/prometheus/latest/querying/basics/](https://prometheus.io/docs/prometheus/latest/querying/basics/).'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 本节简要介绍了Prometheus。有关查询语言语法的更多信息，请参阅官方文档：[https://prometheus.io/docs/prometheus/latest/querying/basics/](https://prometheus.io/docs/prometheus/latest/querying/basics/)。
- en: Prometheus is a powerful tool for collecting and querying metrics. To gain better
    visualization of these metrics, Grafana can be used to create dashboards. In the
    following section, we will explore how to use Grafana to read metrics from Prometheus
    and create informative dashboards.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus是收集和查询指标的一个强大工具。为了更好地可视化这些指标，可以使用Grafana来创建仪表板。在下一节中，我们将探讨如何使用Grafana从Prometheus读取指标并创建信息丰富的仪表板。
- en: Using Grafana to create dashboards
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Grafana创建仪表板
- en: '**Grafana** is a popular opensource analytics and dashboarding tool. It can
    visualize metrics from multiple data sources, such as Prometheus, Elasticsearch,
    Azure Monitor, and others. Grafana can create beautiful dashboards to help us
    understand the application’s performance and behavior. In this section, we will
    use Grafana to create dashboards for the ASP.NET Core web API application.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**Grafana**是一个流行的开源分析和仪表板工具。它可以可视化来自多个数据源（如Prometheus、Elasticsearch、Azure Monitor等）的指标。Grafana可以创建美观的仪表板，帮助我们理解应用程序的性能和行为。在本节中，我们将使用Grafana为ASP.NET
    Core Web API应用程序创建仪表板。'
- en: 'Grafana also provides a managed service called **Grafana Cloud**. The free
    tier of Grafana Cloud has a limit of 10,000 metrics, 3 users, and 50 GB of logs.
    You can check the pricing here: [https://grafana.com/pricing/](https://grafana.com/pricing/).
    In this book, we will install Grafana locally. Download the latest version of
    Grafana from the official website: [https://grafana.com/oss/grafana/](https://grafana.com/oss/grafana/).
    Then, choose the version for your operating system.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Grafana还提供了一种名为**Grafana Cloud**的托管服务。Grafana Cloud的免费层限制为10,000个指标、3个用户和50
    GB的日志。你可以在此处查看定价：[https://grafana.com/pricing/](https://grafana.com/pricing/)。本书中，我们将本地安装Grafana。从官方网站下载Grafana的最新版本：[https://grafana.com/oss/grafana/](https://grafana.com/oss/grafana/)。然后，选择适合你操作系统的版本。
- en: 'Run Grafana by executing the `grafana-server.exe` file if you’re using Windows.
    You may see a Windows Security Alert dialog box. Click the **Allow** button to
    allow Grafana to communicate on these networks. You will find the following line
    in the output:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用Windows，通过执行`grafana-server.exe`文件来运行Grafana。你可能看到一个Windows安全警报对话框。点击**允许**按钮以允许Grafana在这些网络上进行通信。你将在输出中找到以下行：
- en: '[PRE49]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This means that Grafana is running on port `3000`. Navigate to `http://localhost:3000`.
    The default username and password are both `admin`. Once you’ve logged in, you
    will be prompted to change the password.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着Grafana正在端口`3000`上运行。导航到`http://localhost:3000`。默认用户名和密码都是`admin`。一旦登录，系统会提示你更改密码。
- en: Important note
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The default theme of Grafana is dark. If you prefer a light theme, you can change
    it by going to the **Preferences** page. We’re using the light theme in this book
    for better readability.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Grafana的默认主题是深色。如果你更喜欢浅色主题，你可以通过访问**首选项**页面来更改它。本书中使用浅色主题以提高可读性。
- en: 'Click the hamburger menu in the top-left corner, and then click **Connections**.
    This page shows the data sources that Grafana supports:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 点击左上角的汉堡菜单，然后点击**连接**。此页面显示了Grafana支持的数据源：
- en: '![Figure 16.11 – Grafana data sources](img/B18971_16_11.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图16.11 – Grafana数据源](img/B18971_16_11.jpg)'
- en: Figure 16.11 – Grafana data sources
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.11 – Grafana数据源
- en: 'Search for *Prometheus* and click on it. Then, click the **Create a Prometheus
    data source** button in the top-right corner. On the **Settings** page, we can
    configure the data source, as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索*Prometheus*并点击它。然后，点击右上角的**创建Prometheus数据源**按钮。在**设置**页面，我们可以配置数据源，如下所示：
- en: '![Figure 16.12 – Configuring the Prometheus data source](img/B18971_16_12.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图16.12 – 配置Prometheus数据源](img/B18971_16_12.jpg)'
- en: Figure 16.12 – Configuring the Prometheus data source
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.12 – 配置Prometheus数据源
- en: Use `http://localhost:9090` as the URL. Then, click the `Successfully queried
    the Prometheus API`. At this point, we can create dashboards to visualize the
    metrics.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`http://localhost:9090`作为URL。然后，点击`Successfully queried the Prometheus API`。此时，我们可以创建仪表板来可视化指标。
- en: 'Navigate to the **Dashboards** page and click the **New** button. From the
    drop-down list, click **New Dashboard**. You will be navigated to the new dashboard
    page. Click the **Add visualization** button, then choose Prometheus as the data
    source, as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到**仪表板**页面并点击**新建**按钮。从下拉列表中，点击**新建仪表板**。你将被导航到新的仪表板页面。点击**添加可视化**按钮，然后选择Prometheus作为数据源，如下所示：
- en: '![Figure 16.13 – Adding a visualization](img/B18971_16_13.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图16.13 – 添加可视化](img/B18971_16_13.jpg)'
- en: Figure 16.13 – Adding a visualization
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.13 – 添加可视化
- en: 'Then, we can use the query language to query the metrics. In the `mywebapidemo.invoices.read`
    requests for the `/``api/Invoices` endpoint:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用查询语言来查询指标。在`mywebapidemo.invoices.read`请求`/api/Invoices`端点：
- en: '![Figure 16.14 – Querying the metrics](img/B18971_16_14.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图16.14 – 查询指标](img/B18971_16_14.jpg)'
- en: Figure 16.14 – Querying the metrics
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.14 – 查询指标
- en: 'Click the **Run queries** button; you will see the following output in the
    panel:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**运行查询**按钮；你将在面板中看到以下输出：
- en: '![Figure 16.15 – Query result](img/B18971_16_15.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图16.15 – 查询结果](img/B18971_16_15.jpg)'
- en: Figure 16.15 – Query result
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.15 – 查询结果
- en: 'Then, click the **Apply** button; you will see the graph in the dashboard:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击**应用**按钮；您将在仪表板中看到图表：
- en: '![Figure 16.16 – Grafana dashboard](img/B18971_16_16.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图16.16 – Grafana仪表板](img/B18971_16_16.jpg)'
- en: Figure 16.16 – Grafana dashboard
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.16 – Grafana仪表板
- en: 'You can adjust the size of the dashboard as necessary. Feel free to add more
    dashboard panels to visualize the metrics. Before you leave the dashboard, click
    the **Save** button in the top-right corner to save it. You can also export the
    dashboard as a JSON file and import it later:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据需要调整仪表板的大小。请随意添加更多仪表板面板来可视化指标。在离开仪表板之前，请点击右上角的**保存**按钮以保存它。您还可以将仪表板导出为JSON文件并在以后导入：
- en: '![Figure 16.17 – Adding more panels](img/B18971_16_17.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图16.17 – 添加更多面板](img/B18971_16_17.jpg)'
- en: Figure 16.17 – Adding more panels
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.17 – 添加更多面板
- en: 'To simplify the process of creating Grafana dashboards, James Newton-King,
    the esteemed author of JSON.NET, has provided a Grafana dashboard template for
    ASP.NET Core web API applications. You can find the template here: [https://github.com/JamesNK/aspnetcore-grafana/blob/main/README.md](https://github.com/JamesNK/aspnetcore-grafana/blob/main/README.md).
    There are two dashboards in this repository:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化创建Grafana仪表板的过程，JSON.NET的尊敬作者James Newton-King提供了一份ASP.NET Core Web API应用程序的Grafana仪表板模板。您可以在以下位置找到模板：[https://github.com/JamesNK/aspnetcore-grafana/blob/main/README.md](https://github.com/JamesNK/aspnetcore-grafana/blob/main/README.md)。此存储库中有两个仪表板：
- en: '`ASP.NET Core.json`: This dashboard shows an overview of the ASP.NET Core web
    API application'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ASP.NET Core.json`：此仪表板显示了ASP.NET Core Web API应用程序的概述'
- en: '`ASP.NET Core Endpoint.json`: This dashboard shows the details for specific
    endpoints'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ASP.NET Core Endpoint.json`：此仪表板显示了特定端点的详细信息'
- en: 'Create a new dashboard and click the `ASP.NET Core.json` file or paste the
    content of the file into the textbox, as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的仪表板并点击`ASP.NET Core.json`文件或粘贴文件内容到文本框中，如下所示：
- en: '![Figure 16.18 – Importing the dashboard](img/B18971_16_18.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图16.18 – 导入仪表板](img/B18971_16_18.jpg)'
- en: Figure 16.18 – Importing the dashboard
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.18 – 导入仪表板
- en: 'Click the **Load** button. On the next page, choose the Prometheus data source
    and click the **Import** button. You will see the following dashboard:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**加载**按钮。在下一页上，选择Prometheus数据源并点击**导入**按钮。您将看到以下仪表板：
- en: '![Figure 16.19 – ASP.NET Core dashboard provided by James Newton-King](img/B18971_16_19.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图16.19 – James Newton-King提供的ASP.NET Core仪表板](img/B18971_16_19.jpg)'
- en: Figure 16.19 – Overview of the ASP.NET Core dashboard provided by James Newton-King
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.19 – James Newton-King提供的ASP.NET Core仪表板的概述
- en: This dashboard provides an overview of the ASP.NET Core web API application.
    Here, you can see the number of requests, the request’s duration, the number of
    active requests, and so on. You can also see the error rate, which is important
    for monitoring the application.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 此仪表板提供了ASP.NET Core Web API应用程序的概述。在这里，您可以查看请求数量、请求持续时间、活动请求数量等。您还可以看到错误率，这对于监控应用程序非常重要。
- en: '*Figure 16**.20* shows the **ASP.NET Core** **Endpoint** dashboard:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16.20*显示了**ASP.NET Core** **端点**仪表板：'
- en: '![Figure 16.20 – The ASP.NET Core Endpoint dashboard provided by James Newton-King](img/B18971_16_20.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图16.20 – James Newton-King提供的ASP.NET Core端点仪表板](img/B18971_16_20.jpg)'
- en: Figure 16.20 – Overview of the ASP.NET Core Endpoint dashboard provided by James
    Newton-King
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.20 – James Newton-King提供的ASP.NET Core端点仪表板的概述
- en: You can choose the endpoint from the drop-down list. Once you’ve done this,
    you will see the metrics for the endpoint. For example, *Figure 16**.20* shows
    the metrics for the `/``api/Invoices` endpoint.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从下拉列表中选择端点。一旦完成，您将看到端点的指标。例如，*图16.20*显示了`/api/Invoices`端点的指标。
- en: 'Grafana offers many options to customize dashboards. On any dashboard panel,
    you can click the three dots in the top-right corner and then click **Edit** to
    edit the panel. You can change the title, the visualization type, the query, and
    so on. You can also use the **Builder** or **Code** editor to edit the query,
    as shown in *Figure 16**.21* and *Figure 16**.22*, respectively. Here’s what the
    **Builder** editor looks like:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Grafana提供了许多选项来自定义仪表板。在任何仪表板面板上，您都可以点击右上角的三个点，然后点击**编辑**来编辑面板。您可以更改标题、可视化类型、查询等。您还可以使用**构建器**或**代码**编辑器来编辑查询，如图*图16.21*和*图16.22*所示。以下是**构建器**编辑器的样子：
- en: '![Figure 16.21 – Editing the query using the Builder editor](img/B18971_16_21.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![图16.21 – 使用构建器编辑器编辑查询](img/B18971_16_21.jpg)'
- en: Figure 16.21 – Editing the query using the Builder editor
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.21 – 使用Builder编辑器编辑查询
- en: 'Here’s what the **Code** editor looks like:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是**代码**编辑器的样子：
- en: '![Figure 16.22 – Editing the query using the Code editor](img/B18971_16_22.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![图16.22 – 使用代码编辑器编辑查询](img/B18971_16_22.jpg)'
- en: Figure 16.22 – Editing the query using the Code editor
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.22 – 使用代码编辑器编辑查询
- en: 'Grafana provides a better visualization of the metrics. You can learn more
    about Grafana by reading the official documentation: [https://grafana.com/docs/grafana/latest/.](https://grafana.com/docs/grafana/latest/.
    )'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Grafana提供了更好的指标可视化。你可以通过阅读官方文档了解更多关于Grafana的信息：[https://grafana.com/docs/grafana/latest/](https://grafana.com/docs/grafana/latest/)
- en: In the next section, we will explore how to use OpenTelemetry and Jaeger to
    collect traces.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用OpenTelemetry和Jaeger来收集追踪信息。
- en: Using Jaeger to collect traces
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Jaeger收集追踪信息
- en: Traces are important for understanding how requests are handled by the application.
    In a microservice architecture, a request will be handled by multiple services.
    Distributed tracing can be used to track the flow of requests across multiple
    services. In this section, we will learn about the basic concepts of distributed
    tracing and how to use OpenTelemetry and Jaeger to collect traces.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪对于理解应用程序如何处理请求非常重要。在微服务架构中，一个请求将由多个服务处理。分布式追踪可以用来跟踪请求在多个服务之间的流动。在本节中，我们将学习分布式追踪的基本概念以及如何使用OpenTelemetry和Jaeger来收集追踪信息。
- en: For example, in a microservice architecture, service A calls service B, and
    service B calls service C and service D. When a client sends a request to service
    A, the request will be passed through service B, service C, and service D. In
    this case, if any of these services fails to process the request, or the request
    takes too long to process, we need to know which service is responsible for the
    failure and which part of the request contributes to the latency or errors. Distributed
    tracing can give us the big picture of how the request is processed by these services.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个微服务架构中，服务A调用服务B，服务B调用服务C和服务D。当客户端向服务A发送请求时，请求将通过服务B、服务C和服务D传递。在这种情况下，如果这些服务中的任何一个无法处理请求，或者请求处理时间过长，我们需要知道哪个服务负责失败，以及请求的哪个部分导致了延迟或错误。分布式追踪可以给我们展示这些服务如何处理请求的全貌。
- en: 'We have not discussed microservice architecture in detail in this book. To
    demonstrate distributed tracing, we added two web API projects to the sample project.
    You can find a controller named `OrdersController` in the `MyWebApiDemo` project.
    In this controller, we can call the `Post` action to create an order. The `Post`
    action will call two external services:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中没有详细讨论微服务架构。为了演示分布式追踪，我们在示例项目中添加了两个Web API项目。你可以在`MyWebApiDemo`项目中找到一个名为`OrdersController`的控制器。在这个控制器中，我们可以调用`Post`操作来创建一个订单。`Post`操作将调用两个外部服务：
- en: '`CustomerService`: A service to check whether the customer exists'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CustomerService`：一个用于检查客户是否存在的服务'
- en: '`ProductService`: A service to check whether the product exists'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductService`：一个用于检查产品是否存在的服务'
- en: To create an order, we must ensure the customer ID is valid by calling the `/api/customers/{id}`
    endpoint of `CustomerService`. Additionally, we must verify that the products
    are valid by calling the `/api/products/{id}` endpoint of `ProductService`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个订单，我们必须通过调用`CustomerService`的`/api/customers/{id}`端点来确保客户ID有效。此外，我们还必须通过调用`ProductService`的`/api/products/{id}`端点来验证产品是否有效。
- en: Note that these services are for demonstration purposes only and should not
    be used for production purposes. As such, there is no real database access layer;
    instead, a static list is used to store the temporary data. Additionally, there
    is no consideration for transaction and concurrency management.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些服务仅用于演示目的，不应用于生产环境。因此，没有真正的数据库访问层；相反，使用静态列表来存储临时数据。此外，没有考虑事务和并发管理。
- en: 'First, let’s enable tracing in the `MyWebApiDemo` project. Open the `Program.cs`
    file and add the following code to the `MyWebApiDemo` project:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在`MyWebApiDemo`项目中启用追踪。打开`Program.cs`文件，并将以下代码添加到`MyWebApiDemo`项目中：
- en: '[PRE50]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the preceding code, we enabled tracing in our code using the `WithTracing`
    method. To further instrument our application, we added ASP.NET Core and HTTP
    client instrumentation. The HTTP client instrumentation is used to trace the HTTP
    calls to the external services. Finally, we added a console exporter to export
    the traces to the console.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`WithTracing`方法在我们的代码中启用了跟踪。为了进一步对应用程序进行检测，我们添加了ASP.NET Core和HTTP客户端检测。HTTP客户端检测用于跟踪对外部服务的HTTP调用。最后，我们添加了一个控制台导出器以将跟踪导出到控制台。
- en: 'Run the application and send some requests to the `api/orders` endpoint. You
    will see some tracing information in the terminal output:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并向`api/orders`端点发送一些请求。您将在终端输出中看到一些跟踪信息：
- en: 'In the console trace, you will find two important properties: `Activity.TraceId`
    and `Activity.SpanId`. The `Activity.TraceId` property is used to identify a trace,
    which is a collection of spans. A span is a unit of work in a trace. For example,
    if we send a `POST` request to the `api/Orders` endpoint to create an order, the
    application will call `ProductService` and `CustomerService`. Each call is a span.
    However, it is not convenient to search for a specific span in the console output.
    Next, we will use Jaeger to collect and visualize the traces.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台跟踪中，您将找到两个重要属性：`Activity.TraceId`和`Activity.SpanId`。`Activity.TraceId`属性用于标识一个跟踪，它是一系列跟踪的集合。跟踪中的一个单元是span。例如，如果我们向`api/Orders`端点发送`POST`请求以创建订单，应用程序将调用`ProductService`和`CustomerService`。每个调用都是一个span。然而，在控制台输出中搜索特定的span并不方便。接下来，我们将使用Jaeger来收集和可视化跟踪。
- en: '**Jaeger** is an open-source distributed tracing platform that is used to monitor
    and troubleshoot distributed workflows and identify performance bottlenecks. Jaeger
    was originally developed by Uber Technologies ([http://uber.github.io/](http://uber.github.io/))
    and joined the Cloud Native Computing Foundation in 2017.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jaeger**是一个开源的分布式追踪平台，用于监控和调试分布式工作流以及识别性能瓶颈。Jaeger最初由Uber Technologies开发（[http://uber.github.io/](http://uber.github.io/)），并于2017年加入云原生计算基金会。'
- en: 'Install Jaeger from the official website: [https://www.jaegertracing.io/download/](https://www.jaegertracing.io/download/).
    You can choose the version for your operating system or use the Docker image.
    In this book, we will use the executable binaries on Windows. Navigate to the
    Jaeger folder in the terminal and run the following command to start Jaeger:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 从官方网站安装Jaeger：[https://www.jaegertracing.io/download/](https://www.jaegertracing.io/download/)。您可以选择适合您操作系统的版本或使用Docker镜像。在本书中，我们将使用Windows上的可执行二进制文件。在终端导航到Jaeger文件夹，并运行以下命令以启动Jaeger：
- en: '[PRE51]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `jaeger-all-in-one` command is for quick local testing. It starts all the
    components of Jaeger, including the Jaeger UI, `jaeger-collector`, `jaeger-agent`,
    `jaeger-query`, and in-memory storage. The `--collector.otlp.enabled` option is
    used to specify that `jaeger-collector` should accept traces in OTLP format. In
    the output, you can find the following line, which indicates that Jaeger is receiving
    data from OTLP:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`jaeger-all-in-one`命令用于快速本地测试。它启动Jaeger的所有组件，包括Jaeger UI、`jaeger-collector`、`jaeger-agent`、`jaeger-query`和内存存储。`--collector.otlp.enabled`选项用于指定`jaeger-collector`应接受OTLP格式的跟踪。在输出中，您可以找到以下行，表明Jaeger正在接收OTLP格式的数据：'
- en: '[PRE52]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`jaeger-collector` utilizes port `4317` to receive data via the gRPC protocol
    and port `4318` via the HTTP protocol. This allows for efficient communication
    between `jaeger-collector` and other services.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`jaeger-collector`使用端口`4317`通过gRPC协议接收数据，通过端口`4318`通过HTTP协议接收。这允许`jaeger-collector`与其他服务之间进行高效通信。'
- en: 'Next, we need to configure the ASP.NET Core web API project so that it exports
    the OTLP traces to Jaeger. Open the `Program.cs` file and update the `WithTracing()`
    method, as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置ASP.NET Core Web API项目，以便将其OTLP跟踪导出到Jaeger。打开`Program.cs`文件并更新`WithTracing()`方法，如下所示：
- en: '[PRE53]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We use the `AddOtlpExporter` method to add the exporter for Jaeger. As a best
    practice, it is recommended to use the configuration system to set the URL, rather
    than hard-coding it. As an example, you can define it in the `appsettings.json`
    file.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`AddOtlpExporter`方法添加Jaeger的导出器。作为一个最佳实践，建议使用配置系统来设置URL，而不是硬编码。例如，您可以在`appsettings.json`文件中定义它。
- en: 'Restart the three applications and send some `POST` requests to the `/api/Orders`
    endpoint. Here is a payload example:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动三个应用程序并向`/api/Orders`端点发送一些`POST`请求。以下是一个有效载荷示例：
- en: '[PRE54]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Navigate to `http://localhost:16686/`; you will see the Jaeger UI. In the **Search**
    tab, choose **Service**, then **Operation**, and then click the **Find Traces**
    button. You will see the traces, as shown here:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到`http://localhost:16686/`；您将看到Jaeger UI。在**搜索**选项卡中，选择**服务**，然后**操作**，然后点击**查找跟踪**按钮。您将看到跟踪，如图所示：
- en: '![Figure 16.23 – Jaeger traces](img/B18971_16_23.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![图16.23 – Jaeger跟踪](img/B18971_16_23.jpg)'
- en: Figure 16.23 – Jaeger traces
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.23 – Jaeger跟踪
- en: 'Click on a trace to view its details:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 点击一个跟踪以查看其详细信息：
- en: '![Figure 16.24 – A trace’s details](img/B18971_16_24.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![图16.24 – 跟踪的详细信息](img/B18971_16_24.jpg)'
- en: Figure 16.24 – A trace’s details
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.24 – 跟踪的详细信息
- en: You will see that this request includes three spans. The parent is the inbound
    request, and it has two outbound requests to other services.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到这个请求包括三个跨度。父级是入站请求，并且它有两个指向其他服务的出站请求。
- en: We can enable traces in the dependent services to better understand how these
    requests are processed. Configure `ProductService` and `CustomerService` following
    the same methods. These traces should be sent to one Jaeger instance so that Jaeger
    can correlate the requests across different services.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在依赖服务中启用跟踪以更好地了解这些请求的处理方式。按照相同的方法配置`ProductService`和`CustomerService`。这些跟踪应发送到Jaeger的一个实例，以便Jaeger可以关联不同服务之间的请求。
- en: 'Check the Jaeger UI now. You will find that one `/api/Orders` call has five
    spans now:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查Jaeger UI。您会发现一个`/api/Orders`调用现在有五个跨度：
- en: '![Figure 16.25 – The traces across multiple services](img/B18971_16_25.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![图16.25 – 多个服务之间的跟踪](img/B18971_16_25.jpg)'
- en: Figure 16.25 – The traces across multiple services
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.25 – 多个服务之间的跟踪
- en: 'We can also check the latency for each span, as shown in *Figure 16**.26*:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检查每个跨度的时间延迟，如图16.26所示：
- en: '![Figure 16.26 – The latency for each span](img/B18971_16_26.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![图16.26 – 每个跨度的时间延迟](img/B18971_16_26.jpg)'
- en: Figure 16.26 – The latency for each span
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.26 – 每个跨度的时间延迟
- en: 'Using traces can help us understand how requests are handled by the application.
    We can also use traces to find performance bottlenecks. It is especially useful
    for microservice architectures. For more information about Jaeger, please refer
    to the official documentation: [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter16/MyWebApiDemo](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter16/MyWebApiDemo).'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 使用跟踪可以帮助我们了解应用程序如何处理请求。我们还可以使用跟踪来查找性能瓶颈。这对于微服务架构特别有用。有关Jaeger的更多信息，请参阅官方文档：[https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter16/MyWebApiDemo](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter16/MyWebApiDemo)。
- en: Next, we will recap logging and discuss how to propagate the trace context in
    the logs.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回顾日志记录并讨论如何在日志中传播跟踪上下文。
- en: Using HTTP logging
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用HTTP日志记录
- en: In [*Chapter 4*](B18971_04.xhtml#_idTextAnchor170), we discussed how to use
    the `ILogger` interface to log messages. Sometimes, we want to log the HTTP requests
    and responses for troubleshooting purposes. In this section, we will discuss HTTP
    logging.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章[章节4](B18971_04.xhtml#_idTextAnchor170)中，我们讨论了如何使用`ILogger`接口记录消息。有时，我们想要记录HTTP请求和响应以进行故障排除。在本节中，我们将讨论HTTP日志记录。
- en: 'Follow [*Chapter 4*](B18971_04.xhtml#_idTextAnchor170) to configure the logging
    system. You can use Serilog to send logs to Seq. To enable HTTP logging, we need
    to use the HTTP logging middleware. The middleware will log the inbound requests
    and outbound responses. The updated code is as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 按照第4章[章节4](B18971_04.xhtml#_idTextAnchor170)的说明配置日志系统。您可以使用Serilog将日志发送到Seq。要启用HTTP日志记录，我们需要使用HTTP日志记录中间件。中间件将记录入站请求和出站响应。更新的代码如下：
- en: '[PRE55]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the preceding code, we specify `HttpLoggingFields` to log all fields. Be
    careful when you use this option in production because it may potentially impact
    the performance and log sensitive information. We should not log **personally
    identifiable information** (**PII**) and any sensitive information. We’re using
    it for demonstration purposes only here.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们指定了`HttpLoggingFields`来记录所有字段。在生产环境中使用此选项时要小心，因为它可能会影响性能并记录敏感信息。我们不应记录**个人身份信息**（**PII**）和任何敏感信息。我们在这里仅用于演示目的。
- en: 'We can also update the `appsettings.json` file to specify the log levels. Add
    the following code to the `LogLevel` section of the `appsettings.json` file so
    that we can see information logs:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以更新`appsettings.json`文件以指定日志级别。将以下代码添加到`appsettings.json`文件中的`LogLevel`部分，以便我们可以看到信息日志：
- en: '[PRE56]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Configure the logging in the `CustomerService` and `ProductService` projects
    using the same methods.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的方法在 `CustomerService` 和 `ProductService` 项目中配置日志。
- en: 'Run the three applications and send some requests to the `/api/Orders` endpoint.
    You will see the following logs in the Seq dashboard:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 运行三个应用程序并向 `/api/Orders` 端点发送一些请求。您将在 Seq 仪表板中看到以下日志：
- en: '![Figure 16.27 – HTTP logging](img/B18971_16_27.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.27 – HTTP 日志记录](img/B18971_16_27.jpg)'
- en: Figure 16.27 – HTTP logging
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.27 – HTTP 日志记录
- en: In the logs, you will find details about the HTTP requests and responses. If
    you want to change the logging fields, you can change the `LoggingFields` property
    of `HttpLoggingOptions` in the `AddHttpLogging()` method. The `LoggingFields`
    property is an enum. You can choose `RequestPath`, `RequestQuery`, `RequestMethod`,
    `RequestStatusCode`, `RequestBody`, `RequestHeaders`, `ResponseHeaders`, `ResponseBody`,
    `Duration`, and so on. The `HttpLoggingOptions` class has other properties, such
    as `RequestHeaders`, `ResponseHeaders`, `RequestBodyLogLimit`, `ResponseBodyLogLimit`,
    and others. You can use these properties to configure the logging system.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志中，您将找到有关 HTTP 请求和响应的详细信息。如果您想更改日志字段，您可以在 `AddHttpLogging()` 方法中更改 `HttpLoggingOptions`
    的 `LoggingFields` 属性。`LoggingFields` 属性是一个枚举。您可以选择 `RequestPath`、`RequestQuery`、`RequestMethod`、`RequestStatusCode`、`RequestBody`、`RequestHeaders`、`ResponseHeaders`、`ResponseBody`、`Duration`
    等。`HttpLoggingOptions` 类还有其他属性，例如 `RequestHeaders`、`ResponseHeaders`、`RequestBodyLogLimit`、`ResponseBodyLogLimit`
    等。您可以使用这些属性来配置日志系统。
- en: 'Since we enabled HTTP logging for all requests, we can filter the logs by trace
    ID. Check the Jaeger UI and click on a trace. You will find the trace ID in the
    URL:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已为所有请求启用了 HTTP 日志记录，我们可以通过跟踪 ID 过滤日志。检查 Jaeger UI 并点击一个跟踪。您将在 URL 中找到跟踪
    ID：
- en: '![Figure 16.28 – The trace ID in Jaeger](img/B18971_16_28.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.28 – Jaeger 中的跟踪 ID](img/B18971_16_28.jpg)'
- en: Figure 16.28 – The trace ID in Jaeger
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.28 – Jaeger 中的跟踪 ID
- en: 'In the preceding screenshot, the trace ID is `8c7ab3bccf13135f27baf11c161e17ca`.
    Copy this trace ID and use the following query in the Seq dashboard:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，跟踪 ID 是 `8c7ab3bccf13135f27baf11c161e17ca`。复制此跟踪 ID 并在 Seq 仪表板中使用以下查询：
- en: '[PRE57]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Click the green **Go** button to filter the logs. You will see the logs for
    this trace:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 点击绿色的 **Go** 按钮，以过滤日志。您将看到此跟踪的日志：
- en: '![Figure 16.29 – Filtering the logs by trace ID](img/B18971_16_29.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.29 – 通过跟踪 ID 过滤日志](img/B18971_16_29.jpg)'
- en: Figure 16.29 – Filtering the logs by trace ID
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.29 – 通过跟踪 ID 过滤日志
- en: '*Figure 16**.29* provides a comprehensive view of all the logs for the trace,
    including HTTP requests and responses for three services. This is an invaluable
    resource for troubleshooting.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16.29* 提供了关于跟踪的所有日志的全面视图，包括三个服务的 HTTP 请求和响应。这对于故障排除是一个无价资源。'
- en: Using Azure Application Insights
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Azure 应用洞察
- en: In the preceding sections, we explored how to use OpenTelemetry to collect metrics
    and traces. We also discussed how to leverage open-source tools such as Prometheus,
    Grafana, Jaeger, and Seq to visualize the metrics, traces, and logs. Now, we’ll
    look at how to use Azure Application Insights to create a unified dashboard for
    monitoring an ASP.NET Core web API application.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了如何使用 OpenTelemetry 收集指标和跟踪信息。我们还讨论了如何利用 Prometheus、Grafana、Jaeger
    和 Seq 等开源工具来可视化指标、跟踪和日志。现在，我们将探讨如何使用 Azure 应用洞察为 ASP.NET Core Web API 应用程序创建一个统一的监控仪表板。
- en: 'Azure Application Insights is an extensible APM service for monitoring applications.
    It can collect and analyze logs, metrics, and traces from multiple sources. To
    follow this section, you need to have an Azure subscription. If you do not have
    one, you can create a free account here: [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 应用洞察是一个可扩展的应用程序性能管理（APM）服务，用于监控应用程序。它可以从多个来源收集和分析日志、指标和跟踪信息。要继续阅读本节，您需要拥有一个
    Azure 订阅。如果您还没有，您可以在以下链接创建一个免费账户：[https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
- en: 'Go to the Azure portal and create a new Application Insights resource. You
    can find the Application Insights service in the **Monitoring** category. Choose
    the **Application Insights** service and click the **Create** button. On the next
    page, you need to specify the resource group, name, region, and pricing tier,
    as shown in *Figure 16**.30*:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 Azure 门户并创建一个新的应用洞察资源。您可以在 **Monitoring**（监控）类别中找到应用洞察服务。选择 **Application
    Insights** 服务并点击 **Create**（创建）按钮。在下一页，您需要指定资源组、名称、区域和定价层，如图 *图 16.30* 所示：
- en: '![Figure 16.30 – Creating an Application Insights resource](img/B18971_16_30.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.30 – 创建应用洞察资源](img/B18971_16_30.jpg)'
- en: Figure 16.30 – Creating an Application Insights resource
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.30 – 创建Application Insights资源
- en: Once the Application Insights resource has been created, navigate to the **Overview**
    page. You will find the **Instrumentation Key** and **Connection String** values.
    **Instrumentation Key** is used to identify the Application Insights resource,
    while **Connection String** is used to connect to the Application Insights resource.
    We will use **Connection String** to configure the ASP.NET Core web API applications.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了Application Insights资源，请导航到**概述**页面。您将找到** instrumentation key**和**连接字符串**值。**instrumentation
    key**用于标识Application Insights资源，而**连接字符串**用于连接到Application Insights资源。我们将使用**连接字符串**来配置ASP.NET
    Core Web API应用程序。
- en: 'Open the `appsettings.json` file in the `MyWebApiDemo` project. Add the following
    setting:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MyWebApiDemo`项目中打开`appsettings.json`文件。添加以下设置：
- en: '[PRE58]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Please replace the connection string with your own value. This is for demonstration
    purposes only. It is recommended to use different Application Insights resources
    for different environments. This will ensure that metrics and traces are not mixed.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 请将连接字符串替换为您自己的值。这仅用于演示目的。建议为不同的环境使用不同的Application Insights资源。这将确保指标和跟踪不会混合。
- en: 'Next, we need to install the `Azure.Monitor.OpenTelemetry.AspNetCore` package
    using the following command:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用以下命令安装`Azure.Monitor.OpenTelemetry.AspNetCore`包：
- en: '[PRE59]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This package is used to export metrics and traces to Azure Application Insights.
    At the time of writing, the package was still in preview. If you are reading this
    book after the package has been released, you can omit the `--``prerelease` option.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 此包用于将指标和跟踪导出到Azure Application Insights。在撰写本文时，该包仍在预览中。如果您在包发布后阅读此书，可以省略`--prerelease`选项。
- en: 'Then, update the `Program.cs` file, as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，更新`Program.cs`文件，如下所示：
- en: '[PRE60]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This method will read the `APPLICATIONINSIGHTS_CONNECTION_STRING` setting from
    the configuration system and export the metrics and traces to Azure Application
    Insights.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将从配置系统中读取`APPLICATIONINSIGHTS_CONNECTION_STRING`设置并将指标和跟踪导出到Azure Application
    Insights。
- en: 'Configure the `CustomerService` and `ProductService` projects using the same
    methods. Run the three applications and send some `POST` requests to the `/api/Orders`
    endpoint. Then, navigate to the Application Insights resource in the Azure portal.
    You will see the following output:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的方法配置`CustomerService`和`ProductService`项目。运行三个应用程序并向`/api/Orders`端点发送一些`POST`请求。然后，导航到Azure门户中的应用程序洞察资源。您将看到以下输出：
- en: '![Figure 16.31 – Azure Application Insights](img/B18971_16_31.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![图16.31 – Azure Application Insights](img/B18971_16_31.jpg)'
- en: Figure 16.31 – Overview of Azure Application Insights
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.31 – Azure Application Insights概述
- en: 'You can find even more information about logs, metrics, and traces. Click the
    **Logs** tab; you will see the following page:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以找到有关日志、指标和跟踪的更多信息。点击**日志**选项卡；您将看到以下页面：
- en: '![Figure 16.32 – Azure Application Insights logs](img/B18971_16_32.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![图16.32 – Azure Application Insights日志](img/B18971_16_32.jpg)'
- en: Figure 16.32 – Azure Application Insights logs
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.32 – Azure Application Insights日志
- en: In *Figure 16**.32*, we use `requests | where url !contains "metrics"` to query
    the logs. This query will filter the logs that do not contain the `metrics` keyword.
    You can also use `traces` to query the traces.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图16.32*中，我们使用`requests | where url !contains "metrics"`来查询日志。此查询将过滤掉不包含`metrics`关键字的日志。您也可以使用`traces`来查询跟踪。
- en: 'The **Metrics** tab shows the available metrics, as follows:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '**指标**选项卡显示了可用的指标，如下所示：'
- en: '![Figure 16.33 – Azure Application Insights metrics](img/B18971_16_33.jpg)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![图16.33 – Azure Application Insights指标](img/B18971_16_33.jpg)'
- en: Figure 16.33 – Azure Application Insights metrics
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.33 – Azure Application Insights指标
- en: Here, you can find the metrics we defined for the `api/Invoices` endpoint. If
    you cannot see the metrics, send some requests to the `api/Invoices` endpoint
    and wait a few minutes.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以找到为`api/Invoices`端点定义的指标。如果您看不到指标，请向`api/Invoices`端点发送一些请求并等待几分钟。
- en: 'Click the **Application map** tab; you will see the following page:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**应用程序映射**选项卡；您将看到以下页面：
- en: '![Figure 16.34 – Azure Application Insights application map](img/B18971_16_34.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![图16.34 – Azure Application Insights应用程序映射](img/B18971_16_34.jpg)'
- en: Figure 16.34 – Overview of the Azure Application Insights application map
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.34 – Azure Application Insights应用程序映射概述
- en: '*Figure 16**.34* shows the requests flow across multiple services. You can
    also find the latency for each service.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16.34*显示了跨多个服务的请求流。您还可以找到每个服务的延迟。'
- en: 'Upon clicking any request in the diagram, you will see details such as the
    response time, dependency count, performance histogram, and dependencies, as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中点击任何请求，你将看到如下详细信息：响应时间、依赖项数量、性能直方图和依赖项：
- en: '![Figure 16.35 – Azure Application Insights request details](img/B18971_16_35.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![图16.35 – Azure Application Insights请求详情](img/B18971_16_35.jpg)'
- en: Figure 16.35 – Overview of Azure Application Insights request details
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.35 – Azure Application Insights请求详情概述
- en: 'Click the **Performance** tab; you will see the overall performance of the
    application:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**性能**选项卡；你将看到应用程序的整体性能：
- en: '![Figure 16.36 – Azure Application Insights performance](img/B18971_16_36.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![图16.36 – Azure Application Insights性能](img/B18971_16_36.jpg)'
- en: Figure 16.36 – Overview of Azure Application Insights performance
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.36 – Azure Application Insights性能概述
- en: 'Clicking on one operation, such as `POST api/Orders`, will allow you to view
    the performance of that operation. For further details, click the **xx Samples**
    button located under the **Drill into...** label in the bottom-right corner. You
    will see a list of all the requests for that operation on the right-hand side
    of the screen. Clicking on one of these requests will allow you to view the details
    of that request, including the request and response body, as shown in *Figure
    16**.37*:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 点击一个操作，例如`POST api/Orders`，将允许你查看该操作的性能。要获取更多详细信息，请点击位于屏幕右下角**钻入...**标签下的**xx样本**按钮。你将在屏幕右侧看到该操作的请求列表。点击这些请求之一将允许你查看该请求的详细信息，包括请求和响应体，如图**图16**.37所示：
- en: '![Figure 16.37 – Azure Application Insights end-to-end transaction details](img/B18971_16_37.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![图16.37 – Azure Application Insights端到端事务详情](img/B18971_16_37.jpg)'
- en: Figure 16.37 – Azure Application Insights end-to-end transaction details
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.37 – Azure Application Insights端到端事务详情
- en: In *Figure 16**.37*, you can see how the request is processed by multiple services,
    similar to what the Jaeger UI does.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图16**.37中，你可以看到请求是如何被多个服务处理的，这与Jaeger UI所做的工作类似。
- en: 'Azure Application Insights is a super powerful tool for monitoring applications.
    The benefits of using Azure Application Insights are as follows:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Application Insights是监控应用程序的超级强大工具。使用Azure Application Insights的好处如下：
- en: It is a managed service. You do not need to maintain the infrastructure.
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个托管服务。你不需要维护基础设施。
- en: It provides a unified dashboard for monitoring applications. You do not need
    to use multiple tools. Application Insights can provide a centralized view of
    the metrics, traces, and logs.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一个统一的仪表板来监控应用程序。你不需要使用多个工具。Application Insights可以提供指标、跟踪和日志的集中视图。
- en: It is easy to integrate with your applications. Configuring one connection string
    is much easier than configuring multiple tools.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它很容易与你的应用程序集成。配置一个连接字符串比配置多个工具要简单得多。
- en: It provides a powerful query language to query metrics, traces, and logs. You
    can use the query language to create custom dashboards.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一个强大的查询语言来查询指标、跟踪和日志。你可以使用查询语言来创建自定义仪表板。
- en: It offers more features, such as alerting, failure analysis, funnel analysis,
    user flows, and so on.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了更多功能，例如警报、故障分析、漏斗分析、用户流程等。
- en: 'Note that Azure Application Insights is not free. It is part of Azure Monitor,
    a comprehensive monitoring solution for enterprise applications. You can find
    its pricing here: [https://azure.microsoft.com/en-us/pricing/details/monitor/](https://azure.microsoft.com/en-us/pricing/details/monitor/).'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Azure Application Insights不是免费的。它是Azure Monitor的一部分，是面向企业应用程序的全面监控解决方案。你可以在这里找到其定价信息：[https://azure.microsoft.com/en-us/pricing/details/monitor/](https://azure.microsoft.com/en-us/pricing/details/monitor/)。
- en: Summary
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed monitoring and observability in ASP.NET Core web
    API applications. We explored how to handle errors and exceptions and return proper
    error responses. We also discussed how to implement health checks to determine
    the status of the application. Then, we learned about the basic concepts of observability,
    including logs, metrics, and traces, and how to integrate with OpenTelemetry and
    define custom metrics. We also explored some open-source tools, such as Prometheus,
    Grafana, Jaeger, and Seq, to collect and visualize metrics, traces, and logs.
    Finally, we introduced Azure Application Insights, a managed service for monitoring
    applications in one place.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 ASP.NET Core Web API 应用程序中的监控和可观察性。我们探讨了如何处理错误和异常，并返回适当的错误响应。我们还讨论了如何实现健康检查以确定应用程序的状态。然后，我们学习了可观察性的基本概念，包括日志、指标和跟踪，以及如何与
    OpenTelemetry 集成并定义自定义指标。我们还探索了一些开源工具，例如 Prometheus、Grafana、Jaeger 和 Seq，用于收集和可视化指标、跟踪和日志。最后，我们介绍了
    Azure Application Insights，这是一种用于在单一位置监控应用程序的托管服务。
- en: Monitoring and observability are complex topics that require a deeper understanding
    of distributed systems and microservice architecture. In this chapter, we only
    introduced the basic concepts. To gain a more comprehensive understanding of these
    topics, further study is necessary.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 监控和可观察性是复杂的话题，需要更深入地理解分布式系统和微服务架构。在本章中，我们仅介绍了基本概念。为了更全面地理解这些主题，还需要进一步的学习。
- en: In the next chapter, we will explore advanced topics related to architecture
    and design patterns. These include **domain-driven design** (**DDD**), clean architecture,
    and cloud-native patterns such as CQRS, resilience patterns, and more. This will
    provide you with a comprehensive overview of the various approaches to architecture
    and design.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨与架构和设计模式相关的先进主题。这些包括**领域驱动设计**（**DDD**）、清洁架构以及云原生模式，如 CQRS、弹性模式等。这将为您提供一个关于各种架构和设计方法的全面概述。
