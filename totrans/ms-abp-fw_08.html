<html><head></head><body>
		<div id="_idContainer051">
			<h1 id="_idParaDest-120"><em class="italic"><a id="_idTextAnchor177"/>Chapter 6</em>: Working with the Data Access Infrastructure</h1>
			<p>Almost all business applications use a kind of database system. We typically implement data access logic to read data from and write data to a database. We also need to deal with database transactions to ensure consistency in the data source.</p>
			<p>In this chapter, we will learn how to work with the data access infrastructure of ABP Framework, which provides abstractions for data access by implementing <strong class="bold">Repository</strong> and <strong class="bold">Unit of Work</strong> (<strong class="bold">UoW</strong>) patterns. Repositories provide a standard way to perform common database operations for your <strong class="bold">entities</strong>. The UoW system automates database connections and transaction management to ensure a use case (typically, a <strong class="bold">HyperText Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) request) is atomic; this means all operations done in the request are successful together or rolled back together in any error.</p>
			<p>You will see how to define your entities based on ABP Framework's pre-built base entity classes. Then, you will learn how to insert, update, delete, and query entities in the database using the repositories. You will also understand the UoW system to control transaction scopes in your application.</p>
			<p>ABP Framework can work with any database system, while it provides built-in integration packages with <strong class="bold">Entity Framework Core</strong> <strong class="bold">(EF Core)</strong> and <strong class="bold">MongoDB</strong>. You will learn how to use EF Core with ABP Framework by defining your <strong class="source-inline">DbContext</strong> class, mapping your entities to database tables, implementing your repositories, and deploying different ways of loading related entities when you have an entity. You will also see how to use <strong class="bold">MongoDB</strong> as a second database provider option.</p>
			<p>This chapter covers ABP's fundamental data access infrastructure with the following topics:</p>
			<ul>
				<li>Defining entities</li>
				<li>Working with repositories</li>
				<li>EF Core integration</li>
				<li>MongoDB integration</li>
				<li>Understanding the UoW system</li>
			</ul>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor178"/>Technical requirements</h1>
			<p>If you want to follow and try the examples, you need to have an <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>)/editor installed (for example, Visual Studio) to build ASP.NET Core projects.</p>
			<p>You can download the code examples from the following GitHub repository:<span class="hidden"> </span><a href="https://github.com/PacktPublishing/Mastering-ABP-Framework">https://github.com/PacktPublishing/Mastering-ABP-Framework</a>.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor179"/>Defining entities</h1>
			<p>Entities are the main classes to define your domain model. If you are using a relational database, an entity is <a id="_idIndexMarker300"/>generally mapped to a database table. An <strong class="bold">object-relational mapper</strong> <strong class="bold">(ORM)</strong>, such as EF Core, provides abstractions to make you feel as though you are <a id="_idIndexMarker301"/>working with objects in your application code rather than database tables.</p>
			<p>ABP Framework standardizes defining entities by providing some interfaces and base classes. In the next sections, you will learn about ABP Framework's <strong class="source-inline">AggregateRoot</strong> and <strong class="source-inline">Entity</strong> base <a id="_idIndexMarker302"/>classes (and their variants), using single <strong class="bold">primary keys</strong> (<strong class="bold">PKs</strong>) and <strong class="bold">composite PKs</strong> (<strong class="bold">CPKs</strong>) with <a id="_idIndexMarker303"/>these classes and <a id="_idIndexMarker304"/>working with <strong class="bold">globally unique identifier</strong> (<strong class="bold">GUID</strong>) PKs. </p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor180"/>AggregateRoot classes</h2>
			<p>An <strong class="bold">aggregate</strong> is a cluster <a id="_idIndexMarker305"/>of objects (entities and value objects) bound <a id="_idIndexMarker306"/>together by an aggregate root object.</p>
			<p>Relational databases do not have a physical aggregate concept. Every entity is related to a separate database table, and <a id="_idIndexMarker307"/>an aggregate is spread into more than one table. You define relations with <strong class="bold">foreign keys</strong> (<strong class="bold">FKs</strong>). However, in document/object databases such as MongoDB, an aggregate is saved into a single collection by serializing it as a single document (a <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>)-like object). The aggregate <a id="_idIndexMarker308"/>root is mapped to the collection, and <a id="_idIndexMarker309"/>sub-entities are serialized within the aggregate root object. That means sub-entities don't have their collections and are always accessed over the aggregate root.</p>
			<p class="callout-heading">The Aggregate Concept</p>
			<p class="callout">We will cover the aggregate concept in <a href="B17287_10_Epub_AM.xhtml#_idTextAnchor316"><em class="italic">Chapter 10</em></a>, <em class="italic">DDD – The Domain Layer</em>, with all the details of this. For now, you can think of aggregate roots as the main (root) entities in your domain.</p>
			<p>In ABP Framework, you can define main entities and aggregate roots, by deriving from one of the <strong class="source-inline">AggregateRoot</strong> classes. <strong class="source-inline">BasicAggregateRoot</strong> is the most simple class for defining your aggregate roots.</p>
			<p>The following example entity class is derived from the <strong class="source-inline">BasicAggregateRoot</strong> class:</p>
			<p class="source-code">using System;</p>
			<p class="source-code">using System.Collections.Generic;</p>
			<p class="source-code">using Volo.Abp.Domain.Entities;</p>
			<p class="source-code">namespace FormsApp</p>
			<p class="source-code">{</p>
			<p class="source-code">    public class Form : BasicAggregateRoot&lt;Guid&gt;</p>
			<p class="source-code">    {</p>
			<p class="source-code">        public string Name { get; set; }</p>
			<p class="source-code">        public string Description { get; set; }</p>
			<p class="source-code">        public bool IsDraft { get; set; }</p>
			<p class="source-code">        public ICollection&lt;Question&gt; Questions { get; set; }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">BasicAggregateRoot</strong> just defines an <strong class="source-inline">Id</strong> property as the PK and takes the PK type as the generic parameter. In this example, the PK type of <strong class="source-inline">Form</strong> is <strong class="source-inline">Guid</strong>. You can use any type as <a id="_idIndexMarker310"/>the PK (for example, <strong class="source-inline">int</strong>, <strong class="source-inline">string</strong>, and so on), as long as the underlying database provider supports it.</p>
			<p>There are some other base classes to derive your aggregate roots from, as detailed here:</p>
			<ul>
				<li>The <strong class="source-inline">AggregateRoot</strong> class has additional properties to support optimistic concurrency and object extension features.</li>
				<li><strong class="source-inline">CreationAuditedAggregateRoot</strong> inherits from the <strong class="source-inline">AggregateRoot</strong> class and adds <strong class="source-inline">CreationTime</strong> (<strong class="source-inline">DateTime</strong>) and <strong class="source-inline">CreatorId</strong> (<strong class="source-inline">Guid</strong>) properties to store creation audit information.</li>
				<li><strong class="source-inline">AuditedAggregateRoot</strong> inherits from the <strong class="source-inline">CreationAuditedAggregateRoot</strong> class and adds <strong class="source-inline">LastModificationTime</strong> (<strong class="source-inline">DateTime</strong>) and <strong class="source-inline">LastModifierId</strong> (<strong class="source-inline">Guid</strong>)  properties to store modification audit information.</li>
				<li><strong class="source-inline">FullAuditedAggregateRoot</strong> inherits from the <strong class="source-inline">AuditedAggregateRoot</strong> class and adds <strong class="source-inline">DeletionTime</strong> (<strong class="source-inline">DateTime</strong>) and <strong class="source-inline">DeleterId</strong> (<strong class="source-inline">Guid</strong>) properties to store deletion audit information. It also adds <strong class="source-inline">IsDeleted</strong> (<strong class="source-inline">bool</strong>) by implementing the <strong class="source-inline">ISoftDelete</strong> interface, which makes the entity soft-delete.<p class="callout-heading">Optimistic Concurrency and Object Extension Features</p><p class="callout">These topics are not covered in this book. Please check the ABP Framework documentation if you need to use them.</p></li>
			</ul>
			<p>ABP automatically sets auditing properties. We will return to the audit logging and soft-delete topics in <a href="B17287_08_Epub_AM.xhtml#_idTextAnchor249"><em class="italic">Chapter 8</em></a>, <em class="italic">Using the Features and Services of ABP</em>.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor181"/>Entity classes</h2>
			<p><strong class="source-inline">Entity</strong> base classes <a id="_idIndexMarker311"/>are similar to <strong class="source-inline">AggregateRoot</strong> classes, but they are used for sub-collection entities rather than main (root) entities. For example, the <strong class="source-inline">Form</strong> aggregate root example in the previous section has a collection of questions. The <strong class="source-inline">Question</strong> class is <a id="_idIndexMarker312"/>derived from the <strong class="source-inline">Entity</strong> class and is shown in the following code snippet:</p>
			<p class="source-code">public class Question : Entity&lt;Guid&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">    public Guid FormId { get; set; }</p>
			<p class="source-code">    public string Title { get; set; }</p>
			<p class="source-code">    public bool AllowMultiSelect { get; set; }</p>
			<p class="source-code">    public ICollection&lt;Option&gt; Options { get; set; }</p>
			<p class="source-code">}</p>
			<p>As with the <strong class="source-inline">AggregateRoot</strong> class, the <strong class="source-inline">Entity</strong> class also defines an <strong class="source-inline">Id</strong> property of a given type. In this example, the <strong class="source-inline">Question</strong> entity also has a collection of options, where <strong class="source-inline">Option</strong> is another entity type.</p>
			<p>There are some other pre-defined base entity classes, such as <strong class="source-inline">CreationAuditedEntity</strong>, <strong class="source-inline">AuditedEntity</strong>, and <strong class="source-inline">FullAuditedEntity</strong>. They are similar to the audited aggregate root classes explained in the previous section.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor182"/>Entities with CPKs</h2>
			<p>Relational databases <a id="_idIndexMarker313"/>support CPKs, whereby your PK consists of a combination of multiple <a id="_idIndexMarker314"/>values. Composite keys are especially useful for relation <a id="_idIndexMarker315"/>tables with <strong class="bold">many-to-many</strong> relations.</p>
			<p>Assume that you want to set multiple managers for a form object and add a collection property to the <strong class="source-inline">Form</strong> class, as follows:</p>
			<p class="source-code">public class Form : BasicAggregateRoot&lt;Guid&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    public ICollection&lt;FormManager&gt; Managers { get; set; }</p>
			<p class="source-code">}</p>
			<p>You can then define a <strong class="source-inline">FormManager</strong> class deriving from the non-generic <strong class="source-inline">Entity</strong> cl<a id="_idTextAnchor183"/>ass, like this:</p>
			<p class="source-code">public class FormManager : Entity</p>
			<p class="source-code">{</p>
			<p class="source-code">    public Guid FormId { get; set; }</p>
			<p class="source-code">    public Guid UserId { get; set; }</p>
			<p class="source-code">    public Guid IsOwner { get; set; }</p>
			<p class="source-code">    public override object[] GetKeys()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        return new object[] {FormId, UserId};</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>When you inherit <a id="_idIndexMarker316"/>from the non-generic <strong class="source-inline">Entity</strong> class, you have to implement <a id="_idIndexMarker317"/>the <strong class="source-inline">GetKeys</strong> method to return an array of the keys. In this way, ABP can use the CPK's value where it is needed. For this example, <strong class="source-inline">FormId</strong> and <strong class="source-inline">UserId</strong> are FKs to other tables, and they build the CPK of the <strong class="source-inline">FormManager</strong> entity.</p>
			<p class="callout-heading">CPKs for Aggregate Roots</p>
			<p class="callout"><strong class="source-inline">AggregateRoot</strong> classes also have non-generic versions for CPKs, while it is not so usual to set CPKs for aggregate root entities.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor184"/>The GUID PK</h2>
			<p>ABP mostly uses GUIDs as <a id="_idIndexMarker318"/>the PK type for pre-built entities. GUIDs are generally compared to auto-increment IDs (such as <strong class="source-inline">int</strong> or <strong class="source-inline">long</strong>, supported by relational databases). Here are some commonly known benefits of using GUIDs as the PK <a id="_idIndexMarker319"/>compared to auto-increment keys:</p>
			<ul>
				<li>GUIDs are naturally unique. This works well if you are building distributed systems, using a non-relational database, and need to split or merge tables or integrate external systems.</li>
				<li>GUIDs can be generated on the client side without needing a database round trip. In this way, the <a id="_idIndexMarker320"/>client code can know the PK value before saving the entity.</li>
				<li>GUIDs are impossible to guess, so they can be more secure in some cases (for example, if end users see the ID of an entity, they can't find the ID of another entity).</li>
			</ul>
			<p>GUIDs also have <a id="_idIndexMarker321"/>some disadvantages compared to auto-increment integer values, as follows:</p>
			<ul>
				<li>A GUID is 16 bytes in the storage, higher than <strong class="source-inline">int</strong> (4 bytes) and <strong class="source-inline">long</strong> (8 bytes).</li>
				<li>GUIDs are not sequential by nature, which causes performance problems on clustered indexes. However, ABP offers a solution to that problem.</li>
			</ul>
			<p>ABP provides the <strong class="source-inline">IGuidGenerator</strong> service, which generates sequential <strong class="source-inline">Guid</strong> values by default. While it generates sequential values, the values generated by the algorithm are still safe to be universal and random. Generating a sequential value solves the clustered index performance problem.</p>
			<p>If you manually set the <strong class="source-inline">Id</strong> value of an entity, always use the <strong class="source-inline">IGuidGenerator</strong> service; never use <strong class="source-inline">Guid.NewGuid()</strong>. If you don't set the <strong class="source-inline">Id</strong> value for a new entity and insert it into the database using a repository, the repository automatically sets it using the <strong class="source-inline">IGuidGenerator</strong> service.</p>
			<p class="callout-heading">GUID versus Auto-Increment</p>
			<p class="callout">GUID versus auto-increment PKs is <a id="_idIndexMarker322"/>a hot discussion in software development, and <a id="_idIndexMarker323"/>there is no clear winner. ABP works with any PK type, so you can make your own choice based on your requirements.</p>
			<p>We have now learned the basics of entity definitions and will explore best practices for entities in <a href="B17287_10_Epub_AM.xhtml#_idTextAnchor316"><em class="italic">Chapter 10</em></a>, <em class="italic">DDD – The Domain Layer</em>. But now, let's continue with the repositories to understand how to work with a database to persist our entities.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor185"/>Working with repositories</h1>
			<p>The <strong class="bold">Repository pattern</strong> is a common <a id="_idIndexMarker324"/>approach to abstract the data access <a id="_idIndexMarker325"/>code from the other services of your application. In the next sections, you will learn how to use ABP Framework's generic repositories for your entities to query or manipulate data in the database using pre-defined repository methods. You will also see how to create custom repositories when you need to extend the generic repositories and add your own repository methods to encapsulate your data access logic.</p>
			<p class="callout-heading">Integrating Database Providers</p>
			<p class="callout">Database provider integration should be done to use repositories. We will do this in the <em class="italic">EF Core integration</em> and <em class="italic">MongoDB integration</em> sections of this chapter.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor186"/>Generic repositories</h2>
			<p>Once you have <a id="_idIndexMarker326"/>an entity, you can directly inject and use the generic repository for <a id="_idIndexMarker327"/>that entity. Here is an example class that uses a repository:</p>
			<p class="source-code">using System;</p>
			<p class="source-code">using System.Collections.Generic;</p>
			<p class="source-code">using System.Threading.Tasks;</p>
			<p class="source-code">using Volo.Abp.DependencyInjection;</p>
			<p class="source-code">using Volo.Abp.Domain.Repositories;</p>
			<p class="source-code">namespace FormsApp</p>
			<p class="source-code">{</p>
			<p class="source-code">    public class FormService : ITransientDependency</p>
			<p class="source-code">    {</p>
			<p class="source-code">        private readonly IRepository&lt;Form, Guid&gt;                         _formRepository;</p>
			<p class="source-code">        public FormService(IRepository&lt;Form, Guid&gt;                       formRepository)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            _formRepository = formRepository;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        public async Task&lt;List&lt;Form&gt;&gt; GetDraftForms()</p>
			<p class="source-code">        {</p>
			<p class="source-code">            return await _formRepository</p>
			<p class="source-code">                .GetListAsync(f =&gt; f.IsDraft);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In this example, we've injected <strong class="source-inline">IRepository&lt;Form, Guid&gt;</strong>, the default generic repository for the <strong class="source-inline">Form</strong> entity. Then, we've used the <strong class="source-inline">GetListAsync</strong> method to get a filtered list of <a id="_idIndexMarker328"/>forms from the database. The generic <strong class="source-inline">IRepository</strong> interface <a id="_idIndexMarker329"/>has two generic parameters: entity type (<strong class="source-inline">Form</strong>, in this example) and PK type (<strong class="source-inline">Guid</strong>, in this example).</p>
			<p class="callout-heading">Repositories for Non-Aggregate Root Entities</p>
			<p class="callout">Generic repositories are only available for <em class="italic">aggregate root</em> entities by default because it is a best practice to access aggregates via aggregate root objects. However, it is possible to enable generic repositories for other entity types if you're using a relational database. We will see the configuration point in the <em class="italic">EF Core integration</em> section.</p>
			<p>Generic repositories provide many built-in methods to query, insert, update, and delete entities.</p>
			<h3>Inserting, updating, and deleting entities</h3>
			<p>The following methods can be used to manipulate data in the database:</p>
			<ul>
				<li><strong class="source-inline">InsertAsync</strong> is <a id="_idIndexMarker330"/>used to insert a new entity.</li>
				<li><strong class="source-inline">InsertManyAsync</strong> is used <a id="_idIndexMarker331"/>to insert multiple entities in a single call.</li>
				<li><strong class="source-inline">UpdateAsync</strong> is used <a id="_idIndexMarker332"/>to update an existing entity.</li>
				<li><strong class="source-inline">UpdateManyAsync</strong> is used <a id="_idIndexMarker333"/>to update multiple entities in a single call.</li>
				<li><strong class="source-inline">DeleteAsync</strong> is used <a id="_idIndexMarker334"/>to delete an existing entity.</li>
				<li><strong class="source-inline">DeleteManyAsync</strong> is used <a id="_idIndexMarker335"/>to insert multiple entities in a single call.<p class="callout-heading">About Asynchronous Programming</p><p class="callout">All repository methods are asynchronous. As a general principle in .NET, it is strongly suggested to write <a id="_idIndexMarker336"/>your application code with the <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> pattern wherever possible, because in .NET, mixing asynchronous code with synchronous code leads to potential deadlock, timeout, and scalability problems in your application that are not easy to detect and resolve.</p></li>
			</ul>
			<p>If you are using EF Core, these methods may not immediately perform an actual database operation because EF Core uses a change-tracking system. It saves changes only when you call the <strong class="source-inline">DbContext.SaveChanges</strong> method. ABP Framework's UoW system automatically calls the <strong class="source-inline">SaveChanges</strong> method when the current HTTP request successfully finishes. If you want to save changes into the database immediately, you can pass the <strong class="source-inline">autoSave</strong> parameter as <strong class="source-inline">true</strong> to the repository methods.</p>
			<p>The following example <a id="_idIndexMarker337"/>creates a new <strong class="source-inline">Form</strong> entity and immediately saves it to the database in the <strong class="source-inline">InsertAsync</strong> method:</p>
			<p class="source-code">var form = new Form(); // TODO: set the form properties</p>
			<p class="source-code">await _formRepository.InsertAsync(form, autoSave: true);</p>
			<p>Even if you save changes into the database, the changes may not be visible yet, depending on the transaction isolation level, and will be rolled back if the current transaction fails. We will cover the UoW system in the <em class="italic">Understanding the UoW system</em> section of this chapter.</p>
			<p>The <strong class="source-inline">DeleteAsync</strong> method has an extra overload to delete all the entities satisfying the given condition. The following <a id="_idIndexMarker338"/>example deletes all the draft forms in the database:</p>
			<p class="source-code">await _formRepository.DeleteAsync(form =&gt; form.IsDraft);</p>
			<p>You can also have a complex condition using logical operators such as <strong class="source-inline">&amp;&amp;</strong> and <strong class="source-inline">||</strong>.</p>
			<p class="callout-heading">About Cancellation Tokens</p>
			<p class="callout">All repository methods get an optional <strong class="source-inline">CancellationToken</strong> parameter. Cancellation tokens <a id="_idIndexMarker339"/>are used to cancel a database operation when needed. For example, if the user closes the browser window, there is no need to continue a long-running database query operation. Most of the time, you don't need to manually pass a cancellation token, since ABP Framework automatically captures and uses the cancellation token from the HTTP request when you don't explicitly pass it.</p>
			<h3>Querying a single entity</h3>
			<p>The following methods <a id="_idIndexMarker340"/>can be used to fetch a single entity:</p>
			<ul>
				<li><strong class="source-inline">GetAsync</strong>: Returns a single entity by its <strong class="source-inline">Id</strong> value or a predicate expression. Throws <strong class="source-inline">EntityNotFoundException</strong> if the requested entity was not found.</li>
				<li><strong class="source-inline">FindAsync</strong>: Returns a single entity by its <strong class="source-inline">Id</strong> value or a predicate expression. Returns <strong class="source-inline">null</strong> if the requested entity was not found.</li>
			</ul>
			<p>You should use the <strong class="source-inline">FindAsync</strong> method only if you have custom logic or fallback code, in case the given entity does not exist in the database. Otherwise, use <strong class="source-inline">GetAsync</strong>, which throws a well-known exception that causes the <strong class="source-inline">404</strong> status code to return to the client in an HTTP request.</p>
			<p>The following example uses the <strong class="source-inline">GetAsync</strong> method to query a <strong class="source-inline">Form</strong> entity with its <strong class="source-inline">Id</strong> value:</p>
			<p class="source-code">public async Task&lt;Form&gt; GetFormAsync(Guid formId)</p>
			<p class="source-code">{</p>
			<p class="source-code">    return await _formRepository.GetAsync(formId);</p>
			<p class="source-code">}</p>
			<p>Both methods have <a id="_idIndexMarker341"/>overloads to pass a predicate expression to query an entity with a given condition. The following example uses the <strong class="source-inline">GetAsync</strong> method to get a <strong class="source-inline">Form</strong> entity with its unique name:</p>
			<p class="source-code">public async Task&lt;Form&gt; GetFormAsync(string name)</p>
			<p class="source-code">{</p>
			<p class="source-code">    return await _formRepository</p>
			<p class="source-code">        .GetAsync(form =&gt; form.Name == name);</p>
			<p class="source-code">}</p>
			<p>Use these overloads only if you are expecting a single entity. If your query returns multiple entities, then they throw <strong class="source-inline">InvalidOperationException</strong>. For example, if form names are always <em class="italic">unique</em> in your system, you can find a form by name, as in this example. However, if your query may return multiple entities, use querying methods that return a list of entities.</p>
			<h3>Querying a list of entities</h3>
			<p>Generic repositories provide a lot of options to query entities from the database. The following methods <a id="_idIndexMarker342"/>can be used to get a list of entities directly:</p>
			<ul>
				<li><strong class="source-inline">GetListAsync</strong>: Returns all the entities or a list of entities satisfying the given condition</li>
				<li><strong class="source-inline">GetPagedListAsync</strong>: Used to query entities by paging</li>
			</ul>
			<p>The following code block shows how to get a list of forms filtered by the given name:</p>
			<p class="source-code">public async Task&lt;List&lt;Form&gt;&gt; GetFormsAsync(string name)</p>
			<p class="source-code">{</p>
			<p class="source-code">    return await _formRepository</p>
			<p class="source-code">        .GetListAsync(form =&gt; form.Name.Contains(name));</p>
			<p class="source-code">}</p>
			<p>I've passed a lambda expression to the <strong class="source-inline">GetListAsync</strong> method to get all the <strong class="source-inline">Form</strong> entities with <a id="_idIndexMarker343"/>the given <strong class="source-inline">name</strong> parameter's value contained in their names.</p>
			<p>These methods are simple but limited. If you want to write advanced queries, you can use <strong class="bold">Language-Integrated Query</strong> (<strong class="bold">LINQ</strong>) over the repositories.</p>
			<h3>Using LINQ over the repositories</h3>
			<p>Repositories provide <a id="_idIndexMarker344"/>the <strong class="source-inline">GetQueryableAsync()</strong> method, which returns an <strong class="source-inline">IQueryable&lt;TEntity&gt;</strong> object. You can then use this object to perform LINQ on the entities in the database.</p>
			<p>The following example uses a LINQ operation on the <strong class="source-inline">Form</strong> entities to get a list of forms filtered and ordered by their names:</p>
			<p class="source-code">public class FormService2 : ITransientDependency</p>
			<p class="source-code">{</p>
			<p class="source-code">    private readonly IRepository&lt;Form, Guid&gt;                         _formRepository;</p>
			<p class="source-code">    private readonly IAsyncQueryableExecuter                         _asyncExecuter;</p>
			<p class="source-code">    public FormService2(</p>
			<p class="source-code">        IRe<a id="_idTextAnchor187"/>pository&lt;Form, Guid&gt; formRepository,</p>
			<p class="source-code">        IAsyncQueryableExecuter asyncExecuter)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        _formRepository = formRepository;</p>
			<p class="source-code">        _asyncExecuter = asyncExecuter;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code">    public async Task&lt;List&lt;Form&gt;&gt;                                   GetOrderedFormsAsync(string name)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        var queryable = await                                           _formRepository.GetQueryableAsync();</p>
			<p class="source-code">        var query = from form in queryable</p>
			<p class="source-code">            where form.Name.Contains(name)</p>
			<p class="source-code">            orderby form.Name</p>
			<p class="source-code">            select form;</p>
			<p class="source-code">        return await _asyncExecuter.ToListAsync(query);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We've first obtained an <strong class="source-inline">IQueryable&lt;Form&gt;</strong> object, then written a LINQ query, and finally executed <a id="_idIndexMarker345"/>the query using the <strong class="source-inline">IAsyncQueryableExecuter</strong> service.</p>
			<p>An alternative way to write the previous query could be using LINQ extension methods, as follows:</p>
			<p class="source-code">var query = queryable</p>
			<p class="source-code">    .Where(form =&gt; form.Name.Contains(name))</p>
			<p class="source-code">    .OrderBy(form =&gt; form.Name);</p>
			<p>Having an <strong class="source-inline">IQueryable</strong> object provides you with all the power of LINQ. You can even make joins between multiple <strong class="source-inline">IQueryable</strong> objects obtained from different repositories.</p>
			<p>Using the <strong class="source-inline">IAsyncQueryableExecuter</strong> service may seem strange to you. You may expect to call the <strong class="source-inline">ToListAsync</strong> method directly on the query object, like so:</p>
			<p class="source-code">return await query.ToListAsync();</p>
			<p>Unfortunately, <strong class="source-inline">ToListAsync</strong> is an extension method defined by EF Core (or MongoDB, if you are using it) and located inside the <strong class="source-inline">Microsoft.EntityFrameworkCore</strong> NuGet package. If referencing that package from your application <a id="_idIndexMarker346"/>layer is not a problem for you, then you can directly use these asynchronous extension methods in your code. However, if you want to keep your application layer ORM-independent, ABP's <strong class="source-inline">IAsyncQueryableExecuter</strong> service provides the necessary abstraction.</p>
			<h3>IRepository async extension methods</h3>
			<p>ABP Framework <a id="_idIndexMarker347"/>provides all the standard async LINQ extension methods for the <strong class="source-inline">IRepository</strong> interface: <strong class="source-inline">AllAsync</strong>, <strong class="source-inline">AnyAsync</strong>, <strong class="source-inline">AverageAsync</strong>, <strong class="source-inline">ContainsAsync</strong>, <strong class="source-inline">CountAsync</strong>, <strong class="source-inline">FirstAsync</strong>, <strong class="source-inline">FirstOrDefaultAsync</strong>, <strong class="source-inline">LastAsync</strong>, <strong class="source-inline">LastOrDefaultAsync</strong>, <strong class="source-inline">LongCountAsync</strong>, <strong class="source-inline">MaxAsync</strong>, <strong class="source-inline">MinAsync</strong>, <strong class="source-inline">SingleAsync</strong>, <strong class="source-inline">SingleOrDefaultAsync</strong>, <strong class="source-inline">SumAsync</strong>, <strong class="source-inline">ToArrayAsync</strong>, and <strong class="source-inline">ToListAsync</strong>. You can directly use any of these methods on a repository object.</p>
			<p>The following example uses the <strong class="source-inline">CountAsync</strong> method to get a count of forms where the name starts with <strong class="source-inline">"A"</strong>:</p>
			<p class="source-code">public async Task&lt;int&gt; GetCountAsync()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return await _formRepository</p>
			<p class="source-code">        .CountAsync(x =&gt; x.Name.StartsWith("A"));</p>
			<p class="source-code">}</p>
			<p>Notice that these extension methods are only available on the <strong class="source-inline">IRepository</strong> interface. If you want to use queryable extensions, you should still follow the approach explained in the previous section.</p>
			<h3>Generic repositories for entities with CPKs</h3>
			<p>If your entity has a CPK, you can't use the <strong class="source-inline">IRepository&lt;TEntity, TKey&gt;</strong> interface, since it gets <a id="_idIndexMarker348"/>a single PK (<strong class="source-inline">Id</strong>) type. In this case, you can use the <strong class="source-inline">IRepository&lt;TEntity&gt;</strong> interface.</p>
			<p>For example, you can use <strong class="source-inline">IRepository&lt;FormManag<a id="_idTextAnchor188"/>er&gt;</strong> to get managers of a given form, as follows:</p>
			<p class="source-code">public class FormManagementService : ITransientDependency</p>
			<p class="source-code">{</p>
			<p class="source-code">    private readonly IRepository&lt;FormManager&gt;                       _formManagerRepository;</p>
			<p class="source-code">    public FormManagementService(</p>
			<p class="source-code">        IRepository&lt;FormManager&gt; formManagerRepository)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        _formManagerRepository = formManagerRepository;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public async Task&lt;List&lt;FormManager&gt;&gt;                             GetManagersAsync(Guid formId)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        return await _formManagerRepository</p>
			<p class="source-code">            .GetListAsync(fm =&gt; fm.FormId == formId);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In this example, I've used the <strong class="source-inline">IRepository&lt;FormManager&gt;</strong> interface to perform a query for the <strong class="source-inline">FormManager</strong> entities.</p>
			<p class="callout-heading">Repositories for Non-Aggregate Root Entities</p>
			<p class="callout">As stated in the <em class="italic">Generic repositories</em> section of this chapter, you can't use <strong class="source-inline">IRepository&lt;FormManager&gt;</strong> by default, since <strong class="source-inline">FormManager</strong> is not an aggregate root entity. You normally want to get the <strong class="source-inline">Form</strong> aggregate root and access its <strong class="source-inline">Managers</strong> collection to get the form managers. However, if you are using EF Core, you can create default generic repositories for entities that are not aggregate roots. See the <em class="italic">EF Core integration</em> section to learn how to do this.</p>
			<p>One limitation of <a id="_idIndexMarker349"/>generic repositories without the <strong class="source-inline">TKey</strong> generic argument is that they don't have methods that get <strong class="source-inline">Id</strong> parameters because they can't know the <strong class="source-inline">Id</strong> type. However, you can still use LINQ to write any type of query you need.</p>
			<h3>Other generic repository types</h3>
			<p>You typically want to use the repository interfaces explained in the previous sections since they are the <a id="_idIndexMarker350"/>most feature-full repository types. However, there are some more limited repository types that can be useful in some scenarios, such as the following:</p>
			<ul>
				<li><strong class="source-inline">IBasicRepository&lt;TEntity, TPrimaryKey&gt;</strong> and <strong class="source-inline">IBasicRepository&lt;TEntity&gt;</strong> provide fundamental repository methods, but they don't support LINQ and <strong class="source-inline">IQueryable</strong> functionalities. You can use these repositories if your underlying database provider doesn't support LINQ or you don't want to leak LINQ queries into your application layer. In this case, you probably need to write custom repositories by inheriting from these interfaces and implement your queries with custom methods.</li>
				<li><strong class="source-inline">IReadOnlyRepository&lt;TEntity, TKey&gt;</strong>, <strong class="source-inline">IReadOnlyRepository&lt;TEntity&gt;</strong>, <strong class="source-inline">IReadOnlyBasicRepository&lt;Tentity, TKey&gt;</strong>, and <strong class="source-inline">IReadOnlyBasicRepository&lt;TEntity, TKey&gt;</strong> provide methods to fetch data but do not include any methods to manipulate the database.</li>
			</ul>
			<p>Generic repository methods are enough for most cases. However, you may still need to add custom methods to your repositories.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor189"/>Custom repositories</h2>
			<p>You can <a id="_idIndexMarker351"/>create custom repository interfaces and classes to access the <a id="_idIndexMarker352"/>underlying database provider <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>), encapsulate your LINQ expressions, call stored procedures, and so on.</p>
			<p>To create a custom repository, first, define a new repository interface. Repository interfaces are defined in the <strong class="source-inline">Domain</strong> project that comes with the startup template. You can inherit from one of the generic repository interfaces to include the standard methods in your repository interface. The code is illustrated in the following snippet:</p>
			<p class="source-code">public interface IFormRepository : IRepository&lt;Form, Guid&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">    Task&lt;List&lt;Form&gt;&gt; GetListAsync(</p>
			<p class="source-code">        string name,</p>
			<p class="source-code">        bool includeDrafts = false</p>
			<p class="source-code">    );</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">IFormRepository</strong> inherits from <strong class="source-inline">IRepository&lt;Form, Guid&gt;</strong> and adds a new method to get a list of forms with some filters. You can then inject <strong class="source-inline">IFormRepository</strong> into your services instead of the generic repository and use your custom methods. If you don't want to include the standard repository methods, just derive your interface from the <strong class="source-inline">IRepository</strong> (without any generic argument) interface. This is an empty interface that is used to identify your interface as a repository.</p>
			<p>Surely, we must implement the <strong class="source-inline">IFormRepository</strong> interface somewhere in our application. ABP startup templates provide integration projects for the underlying database provider, so we can implement custom repository interfaces in the database integration project. We will implement that interface for EF Core and MongoDB in the next sections.</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor190"/>EF Core integration</h1>
			<p>Microsoft's EF Core is the de facto ORM for .NET, with which you can work with major database providers, such <a id="_idIndexMarker353"/>as SQL Server, Oracle, MySQL, PostgreSQL, and Cosmos DB. It is the default database provider when you create a new ABP solution using the ABP <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>).</p>
			<p>The startup template <a id="_idIndexMarker354"/>uses <em class="italic">SQL Server</em> by default. If you prefer another <strong class="bold">database management system</strong> (<strong class="bold">DBMS</strong>), you can specify the <strong class="source-inline">-dbms</strong> parameter while creating a new solution, like so:</p>
			<p class="source-code">abp new DemoApp -dbms PostgreSQL</p>
			<p><strong class="source-inline">SqlServer</strong>, <strong class="source-inline">MySQL</strong>, <strong class="source-inline">SQLite</strong>, <strong class="source-inline">Oracle</strong>, and <strong class="source-inline">PostgreSQL</strong> are directly supported.</p>
			<p class="callout-heading">Other Databases</p>
			<p class="callout">You can refer to ABP's documentation to learn about up-to-date supported database options and how to switch to another database provider that the ABP CLI does not support <a id="_idIndexMarker355"/>out of the box: <a href="https://docs.abp.io/en/abp/latest/Entity-Framework-Core-Other-DBMS">https://docs.abp.io/en/abp/latest/Entity-Framework-Core-Other-DBMS</a>.</p>
			<p>In the next sections, you will learn how to configure the DBMS (although it is already done in the <a id="_idIndexMarker356"/>startup template), define a <strong class="source-inline">DbContext</strong> class, and register to the <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>) system. Then, you will see how to map your entities to database tables, using Code First Migrations and creating custom repositories for your entities. Finally, we will explore different ways of loading related data for an entity.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor191"/>Configuring the DBMS</h2>
			<p>We <a id="_idIndexMarker357"/>use <strong class="source-inline">AbpDbContextOptions</strong> to configure the DBMS in the <strong class="source-inline">ConfigureServices</strong> method of our module. The following example configures using SQL Server as the DBMS:</p>
			<p class="source-code">Configure&lt;AbpDbContextOptions&gt;(options =&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">    options.UseSqlServer();</p>
			<p class="source-code">});</p>
			<p>Surely, the <strong class="source-inline">UseSqlServer()</strong> method call will be different if you've preferred a different DBMS. We don't <a id="_idIndexMarker358"/>need to set the connection string since it is automatically obtained from the <strong class="source-inline">ConnectionStrings:Default</strong> configuration. You can check the <strong class="source-inline">appsettings.json</strong> file in your project to see and change the connection string.</p>
			<p>We've configured the DBMS but haven't defined a <strong class="source-inline">DbContext</strong> object, which is necessary to work with the database in EF Core.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor192"/>Defining DbContext</h2>
			<p><strong class="source-inline">DbContext</strong> is the main object in EF Core that you interact with the database. You normally create a <a id="_idIndexMarker359"/>class inheriting from <strong class="source-inline">DbContext</strong> to create your own <strong class="source-inline">DbContext</strong>. With ABP Framework, we are inheriting from <strong class="source-inline">AbpDbContext</strong> instead.</p>
			<p>Here is an example of a <strong class="source-inline">DbContext</strong> class definition with ABP Framework:</p>
			<p class="source-code">using Microsoft.EntityFrameworkCore;</p>
			<p class="source-code">using Volo.Abp.EntityFrameworkCore;</p>
			<p class="source-code">namespace FormsApp</p>
			<p class="source-code">{</p>
			<p class="source-code">    public class FormsAppDbContext :                                 AbpDbContext&lt;FormsAppDbContext&gt;</p>
			<p class="source-code">    {</p>
			<p class="source-code">        public DbSet&lt;Form&gt; Forms { get; set; }</p>
			<p class="source-code">        public FormsAppDbContext(</p>
			<p class="source-code">            DbContextOptions&lt;FormsAppDbContext&gt; options)</p>
			<p class="source-code">            : base(options)</p>
			<p class="source-code">        {</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">FormsAppDbContext</strong> inherits from <strong class="source-inline">AbpDbContext&lt;FormsAppDbContext&gt;</strong>. <strong class="source-inline">AbpDbContext</strong> is a generic class and takes the <strong class="source-inline">DbContext</strong> type as a generic parameter. It also <a id="_idIndexMarker360"/>forces us to create a constructor, as shown here. We can then add <strong class="source-inline">DbSet</strong> properties for our entities. It is essential to add <strong class="source-inline">DbSet</strong> properties since ABP can create default generic repositories only for the entities with <strong class="source-inline">DbSet</strong> properties defined.</p>
			<p>Once we've defined <strong class="source-inline">DbContext</strong>, we should register it with the DI system to use it in our application.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor193"/>Registering DbContext with DI</h2>
			<p>The <strong class="source-inline">AddAbpDbContext</strong> extension method is used to register <strong class="source-inline">DbContext</strong> classes with the DI system. You <a id="_idIndexMarker361"/>can use this method inside the <strong class="source-inline">ConfigureServices</strong> method of your module (it is inside the <strong class="source-inline">EntityFrameworkCore</strong> project in the startup solution), as shown in the following code block:</p>
			<p class="source-code">public override void ConfigureServices(</p>
			<p class="source-code">    ServiceConfigurationContext context)</p>
			<p class="source-code">{</p>
			<p class="source-code">    context.Services.AddAbpDbContext&lt;FormsAppDbContext&gt;              (options =&gt;</p>
			<p class="source-code">    {</p>
			<p class="source-code">        options.AddDefaultRepositories();</p>
			<p class="source-code">    });</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">AddDefaultRepositories()</strong> is used to enable default generic repositories for your entities <a id="_idIndexMarker362"/>related to that <strong class="source-inline">DbContext</strong>. It enables generic repositories only for <a id="_idIndexMarker363"/>aggregate root entities by default because, in <strong class="bold">domain-driven design</strong> (<strong class="bold">DDD</strong>), sub-entities should always be accessed over the aggregate root. You can set the optional <strong class="source-inline">includeAllEntities</strong> parameter to <strong class="source-inline">true</strong> if you want to use repositories for other entity types too, as illustrated here:</p>
			<p class="source-code">options.AddDefaultRepositories(includeAllEntities: true);</p>
			<p>With this option, you can inject the <strong class="source-inline">IRepository</strong> service for any entity in your application code.</p>
			<p class="callout-heading">The includeAllEntities Option in the Startup Template</p>
			<p class="callout">The ABP startup template sets the <strong class="source-inline">includeAllEntities</strong> option to <strong class="source-inline">true</strong> because developers working on relational databases are used to querying from all database tables. If you want to apply DDD principles strictly, you should always use the aggregate roots to access sub-entities. In this case, you can remove this option from the <strong class="source-inline">AddDefaultRepositories</strong> method call.</p>
			<p>We've seen how to register the <strong class="source-inline">DbContext</strong> class. We can inject and use <strong class="source-inline">IRepository</strong> interfaces for all your entities in your <strong class="source-inline">DbContext</strong> class. However, we should first configure the EF Core mappings for the entities.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor194"/>Configuring entity mappings</h2>
			<p>EF Core is an object-to-relational <a id="_idIndexMarker364"/>mapper that maps your entities to database tables. We can configure the details of those mappings in two ways, as outlined here:</p>
			<ul>
				<li>Using data annotation attributes on your entity class</li>
				<li>Using Fluent API inside by overriding the <strong class="source-inline">OnModelCreating</strong> method</li>
			</ul>
			<p>Using data annotation attributes makes your domain layer EF Core-dependent. If that's not a problem for you, you can simply use these attributes by following EF Core's documentation. In this book, I will use the Fluent API approach.</p>
			<p>To use the Fluent API approach, you can override the <strong class="source-inline">OnModelCreating</strong> method in your <strong class="source-inline">DbContext</strong> class, as shown in the following code block:</p>
			<p class="source-code">public class FormsAppDbContext : AbpDbContext&lt;FormsAppDbContext&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    protected override void OnModelCreating(ModelBuilder             builder)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        base.OnModelCreating(builder);</p>
			<p class="source-code">        // TODO: configure entities...</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>When you <a id="_idIndexMarker365"/>override the <strong class="source-inline">OnModelCreating</strong> method, always call <strong class="source-inline">base.OnModelCreating()</strong> since ABP also performs default configurations inside that method, necessary to properly use ABP features such as audit logs and data filters. Then, you can use the <strong class="source-inline">builder</strong> object to perform your configurations.</p>
			<p>For example, we can configure the mapping for the <strong class="source-inline">Form</strong> class defined in this chapter, as follows:</p>
			<p class="source-code">builder.Entity&lt;Form&gt;(b =&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">    b.ToTable("Forms");</p>
			<p class="source-code">    b.ConfigureByConvention();</p>
			<p class="source-code">    b.Property(x =&gt; x.Name)</p>
			<p class="source-code">        .HasMaxLength(100)</p>
			<p class="source-code">        .IsRequired();</p>
			<p class="source-code">    b.HasIndex(x =&gt; x.Name);</p>
			<p class="source-code">});</p>
			<p>Calling the <strong class="source-inline">b.ConfigureByConvention()</strong> method is important here. It configures the base properties of your <a id="_idIndexMarker366"/>entity if it is derived from ABP's pre-defined <strong class="source-inline">Entity</strong> or <strong class="source-inline">AggregateRoot</strong> classes. The remaining configuration code is pretty clean and standard, and you can learn all the details from EF Core's documentation.</p>
			<p>Here is another example that configures a relation between entities:</p>
			<p class="source-code">builder.Entity&lt;Question&gt;(b =&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">    b.ToTable("FormQuestions");</p>
			<p class="source-code">    b.ConfigureByConvention();</p>
			<p class="source-code">    b.Property(x =&gt; x.Title)</p>
			<p class="source-code">        .HasMaxLength(200)</p>
			<p class="source-code">        .IsRequired();</p>
			<p class="source-code">    b.HasOne&lt;Form&gt;()</p>
			<p class="source-code">        .WithMany(x =&gt; x.Questions)</p>
			<p class="source-code">        .HasForeignKey(x =&gt; x.FormId)</p>
			<p class="source-code">        .IsRequired();</p>
			<p class="source-code">});</p>
			<p>In this example, we are defining the relation between the <strong class="source-inline">Form</strong> and <strong class="source-inline">Question</strong> entities: a form can have many questions, while a question always belongs to a single form.</p>
			<p>The configuration we've made ensures that EF Core knows how to read and write entities to the database tables. However, related tables in the database should also be available. You can definitely create a database and the tables inside it manually. Then, in every change to your entities, you manually reflect the related changes in the database schema. However, it is hard to keep your entities and database tables in sync in this way. It is also tedious and error-prone to make them all manual, especially when you have <a id="_idIndexMarker367"/>multiple environments (such as development and production).</p>
			<p>Fortunately, there is a better way: Code First Migrations. EF's Code First Migrations system provides an efficient way to incrementally update the database schema to keep it in sync with your entity model. We've already used the Code First Migration system in <a href="B17287_03_Epub_AM.xhtml#_idTextAnchor044"><em class="italic">Chapter 3</em></a>, <em class="italic">Step-By-Step Application Development</em>. You can refer to that chapter to learn how to add a new database migration and apply it in the database.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor195"/>Implementing custom repositories</h2>
			<p>We created an <strong class="source-inline">IFormRepository</strong> interface in the <em class="italic">Custom repositories</em> part of the <em class="italic">Working with repositories</em> section <a id="_idIndexMarker368"/>in this chapter. Now, it's time to implement this repository interface using EF Core.</p>
			<p>You can implement the repository<a id="_idTextAnchor196"/> inside the EF Core integration project of your solution, like this:</p>
			<p class="source-code">public class FormRepository :</p>
			<p class="source-code">    EfCoreRepository&lt;FormsAppDbContext, Form, Guid&gt;,</p>
			<p class="source-code">    IFormRepository</p>
			<p class="source-code">{</p>
			<p class="source-code">    public FormRepository(</p>
			<p class="source-code">        IDbContextProvider&lt;FormsAppDbContext&gt;                           dbContextProvider)</p>
			<p class="source-code">        : base(dbContextProvider)</p>
			<p class="source-code">    { }</p>
			<p class="source-code">    public async Task&lt;List&lt;Form&gt;&gt; GetListAsync(</p>
			<p class="source-code">        string name, bool includeDrafts = false)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        var dbContext = await GetDbContextAsync();</p>
			<p class="source-code">        var query = dbContext.Forms</p>
			<p class="source-code">            .Where(f =&gt; f.Name.Contains(name));</p>
			<p class="source-code">        if (!includeDrafts)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            query = query.Where(f =&gt; !f.IsDraft);</p>
			<p class="source-code">        }</p>
			<p class="source-code">        return await query.ToListAsync();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This class is derived from ABP's <strong class="source-inline">EfCoreRepository</strong> class. In this way, we are inheriting all the <a id="_idIndexMarker369"/>standard repository methods. The <strong class="source-inline">EfCoreRepository</strong> class gets three generic parameters: the <strong class="source-inline">DbContext</strong> type, the entity type, and the PK type of the entity class.</p>
			<p><strong class="source-inline">FormRepository</strong> also implements <strong class="source-inline">IFormRepository</strong>, which defines a custom <strong class="source-inline">GetListAsync</strong> method. We get the <strong class="source-inline">DbContext</strong> instance to use all the power of the EF Core API in this method.</p>
			<p class="callout-heading">Tip about WhereIf</p>
			<p class="callout">Conditional filtering is a widely used pattern, and ABP provides a nice <strong class="source-inline">WhereIf</strong> extension method that can simplify our code. </p>
			<p>We could rewrite the <strong class="source-inline">GetListAsync</strong> method, as shown in the following code block:</p>
			<p class="source-code">var dbContext = await GetDbContextAsync();</p>
			<p class="source-code">return await dbContext.Forms</p>
			<p class="source-code">    .Where(f =&gt; f.Name.Contains(name))</p>
			<p class="source-code">    .WhereIf(!includeDrafts, f =&gt; !f.IsDraft)</p>
			<p class="source-code">    .ToListAsync();</p>
			<p>Since we have <a id="_idIndexMarker370"/>the <strong class="source-inline">DbContext</strong> instance, we can use it to execute <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>) commands or stored procedures. The following method executes a raw SQL command to delete all draft forms:</p>
			<p class="source-code">public async Task DeleteAllDraftsAsync()</p>
			<p class="source-code">{</p>
			<p class="source-code">    var dbContext = await GetDbContextAsync();</p>
			<p class="source-code">    await dbContext.Database</p>
			<p class="source-code">        .ExecuteSqlRawAsync("DELETE FROM Forms WHERE                     IsDraft = 1");</p>
			<p class="source-code">}</p>
			<p class="callout-heading">Executing Stored Procedures and Functions</p>
			<p class="callout">You can refer to EF Core's documentation (<a href="https://docs.microsoft.com/en-us/ef/core">https://docs.microsoft.com/en-us/ef/core</a>) to learn how to <a id="_idIndexMarker371"/>execute stored procedures and functions.</p>
			<p>Once you <a id="_idIndexMarker372"/>implement <strong class="source-inline">IFormRepository</strong>, you can inject and use it instead of <strong class="source-inline">IRepository&lt;Form, Guid&gt;</strong>, as follows:</p>
			<p class="source-code">public class FormService : ITransientDependency</p>
			<p class="source-code">{</p>
			<p class="source-code">    private readonly IFormRepository _formRepository;</p>
			<p class="source-code">    public FormService(IFormRepository formRepository)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        _formRepository = formRepository;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code">    public async Task&lt;List&lt;Form&gt;&gt; GetFormsAsync(string               name)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        return await _formRepository</p>
			<p class="source-code">            .GetListAsync(name, includeDrafts: true);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This class uses the custom <strong class="source-inline">GetListAsync</strong> method of <strong class="source-inline">IFormRepository</strong>.</p>
			<p>Even if you implement a custom repository class for the <strong class="source-inline">Form</strong> entity, it is still possible to inject and use default generic repositories (for example, <strong class="source-inline">IRepository&lt;Form, Guid&gt;</strong>) for that entity. This is <a id="_idIndexMarker373"/>a good feature, especially if you start with generic repositories, then decide to create a custom repository later. You don't have to change your existing code that uses the generic repository.</p>
			<p>One potential problem may occur if you override a base method from the <strong class="source-inline">EfCoreRepository</strong> class and customize it in your repository. In this case, the services that use the generic repository reference will continue to use the non-overridden method. To prevent this fragmentation, use the <strong class="source-inline">AddRepository</strong> method while registering your <strong class="source-inline">DbContext</strong> with DI, as follows:</p>
			<p class="source-code">context.Services.AddAbpDbContext&lt;FormsAppDbContext&gt;(options =&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">    options.AddDefaultRepositories();</p>
			<p class="source-code">    options.AddRepository&lt;Form, FormRepository&gt;();</p>
			<p class="source-code">});</p>
			<p>With this configuration, the <strong class="source-inline">AddRepository</strong> method redirects generic repositories to your custom repository class.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor197"/>Loading related data</h2>
			<p>If your entity has navigation properties to other entities or has collections of other entities, then you'll frequently need to access those related entities while working with the main entity. For example, the <strong class="source-inline">Form</strong> entity introduced before has a collection of <strong class="source-inline">Question</strong> entities, and you may need to access the questions while working with a <strong class="source-inline">Form</strong> object.</p>
			<p>There are <a id="_idIndexMarker374"/>multiple <a id="_idIndexMarker375"/>ways <a id="_idIndexMarker376"/>to access related entities: <strong class="bold">explicit loading</strong>, <strong class="bold">lazy loading</strong>, and <strong class="bold">eager loading</strong>.</p>
			<h3>Explicit loading</h3>
			<p>Repositories <a id="_idIndexMarker377"/>provide <strong class="source-inline">EnsurePropertyLoadedAsync</strong> and <strong class="source-inline">EnsureCollectionLoadedAsync</strong> extension methods to load a navigation property or sub-collection explicitly.</p>
			<p>For example, we can explicitly load the questions of a form, as shown in the following code block:</p>
			<p class="source-code">public async Task&lt;IEnumerable&lt;Question&gt;&gt; GetQuestionsAsync(Form form)</p>
			<p class="source-code">{</p>
			<p class="source-code">    await _formRepository</p>
			<p class="source-code">        .EnsureCollectionLoadedAsync(form, f =&gt;                         f.Questions);</p>
			<p class="source-code">    return form.Questions;</p>
			<p class="source-code">}</p>
			<p>If we don't use <strong class="source-inline">EnsureCollectionLoadedAsync</strong> here, then the <strong class="source-inline">form.Questions</strong> collection might be empty. If we are not sure it is filled, we can use <strong class="source-inline">EnsureCollectionLoadedAsync</strong> to ensure it is loaded. The <strong class="source-inline">EnsurePropertyLoadedAsync</strong> and <strong class="source-inline">EnsureCollectionLoadedAsync</strong> methods do nothing if the related property or collection is already loaded, so calling them multiple times is not a problem for performance.</p>
			<h3>Lazy loading</h3>
			<p>Lazy loading is a feature of EF Core that loads related properties and collections when you first access them. Lazy loading is not <a id="_idIndexMarker378"/>enabled by default. If you want to enable it for your <strong class="source-inline">DbContext</strong>, follow these steps:</p>
			<ol>
				<li>Install the <strong class="source-inline">Microsoft.EntityFrameworkCore.Proxies</strong> NuGet package in your EF Core layer.</li>
				<li>Use the <strong class="source-inline">UseLazyLoadingProxies</strong> method while configuring <strong class="source-inline">AbpDbContextOptions</strong>, as follows:<p class="source-code">Configure&lt;AbpDbContextOptions&gt;(options =&gt;</p><p class="source-code">{</p><p class="source-code">    options.PreConfigure&lt;FormsAppDbContext&gt;(opts =&gt;</p><p class="source-code">    {</p><p class="source-code">        opts.DbContextOptions.UseLazyLoadingProxies();</p><p class="source-code">    });</p><p class="source-code">    options.UseSqlServer();</p><p class="source-code">});</p></li>
				<li>Be sure that the navigation properties and collection properties are virtual in your entities, as shown here:<p class="source-code">public class Form : BasicAggregateRoot&lt;Guid&gt;</p><p class="source-code">{</p><p class="source-code">    ...</p><p class="source-code">    public virtual ICollection&lt;Question&gt; Questions {           get; set; }</p><p class="source-code">    public virtual ICollection&lt;FormManager&gt; Owners {            get; set; }</p><p class="source-code">}</p></li>
			</ol>
			<p>When you enable lazy loading, you don't need to use explicit loading anymore.</p>
			<p>Lazy loading is a discussed concept of ORMs. Some developers find it useful and practical, while others <a id="_idIndexMarker379"/>suggest not using it in any way. I am drawn to not using it because it has some potential problems, such as these:</p>
			<ul>
				<li>Lazy loading can't use asynchronous programming because there is no way to access a property with the <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> pattern. So, it blocks the caller thread, which is a bad practice for throughput and scalability.</li>
				<li>You may have a <strong class="source-inline">1+N</strong> loading problem if you forget to eager-load the related data before using a <strong class="source-inline">foreach</strong> loop. <strong class="source-inline">1+N</strong> loading means you query a list of entities from the database with a single database operation (<strong class="source-inline">1</strong>), then perform a loop that accesses a navigation property (or a collection) of these entities. In this case, it lazy-loads <a id="_idIndexMarker380"/>the related property for each loop (<strong class="source-inline">N</strong> = count of the queried entities in the first database operation). So, you make a <strong class="source-inline">1+N</strong> database call, which dramatically drops your application performance. You should eager-load the related entities in such cases so that you make a single database in total.</li>
				<li>It makes it hard to predicate and optimize your code since you may not easily see when the related data is loaded from the database.</li>
			</ul>
			<p>I suggest going for a more controlled approach and using eager loading wherever possible.</p>
			<h3>Eager loading</h3>
			<p>Eager loading is a way of loading <a id="_idIndexMarker381"/>related data while first querying the main entity.</p>
			<p>Assume that you've created a custom repository method to load the related questions while getting a <strong class="source-inline">Form</strong> object from the database, as shown here:</p>
			<p class="source-code">public async Task&lt;Form&gt; GetWithQuestions(Guid formId)</p>
			<p class="source-code">{</p>
			<p class="source-code">    var dbContext = await GetDbContextAsync();</p>
			<p class="source-code">    return await dbContext.Forms</p>
			<p class="source-code">        .Include(f =&gt; f.Questions)</p>
			<p class="source-code">        .SingleAsync(f =&gt; f.Id == formId);</p>
			<p class="source-code">}</p>
			<p>If you create such custom repository methods, you can use the full EF Core API. However, if you are <a id="_idIndexMarker382"/>working with ABP's repositories and don't want to depend on EF Core in your application layer, you can't use EF Core's <strong class="source-inline">Include</strong> extension method (which is used to eager-load the related data). In this case, you have two options, which are discussed in the next sections.</p>
			<h4>IRepository.WithDetailsAsync</h4>
			<p>The <strong class="source-inline">WithDetailsAsync</strong> method <a id="_idIndexMarker383"/>of the <strong class="source-inline">IRepository</strong> returns <a id="_idIndexMarker384"/><a id="_idTextAnchor198"/>an <strong class="source-inline">IQueryable</strong> instance by including the given properties or collections, as follows:</p>
			<p class="source-code">public async Task EagerLoadDemoAsync(Guid formId)</p>
			<p class="source-code">{</p>
			<p class="source-code">    var queryable = await _formRepository</p>
			<p class="source-code">        .WithDetailsAsync(f =&gt; f.Questions);</p>
			<p class="source-code">    var query = queryable.Where(f =&gt; f.Id == formId);</p>
			<p class="source-code">    var form = await                                                 _asyncExecuter.FirstOrDefaultAsync(query);</p>
			<p class="source-code">    foreach (var question in form.Questions)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        //...</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">WithDetailsAsync(f =&gt; f.Questions)</strong> returns <strong class="source-inline">IQueryable&lt;Form&gt;</strong> with questions included, so we can safely loop through the <strong class="source-inline">form.Questions</strong> collection. <strong class="source-inline">IAsyncQueryableExecuter</strong> was explained before, in the <em class="italic">Generic repositories</em> section of this chapter. The <strong class="source-inline">WithDetailsAsync</strong> method can get more than one expression to include more than one property if you need it. <strong class="source-inline">WithDetailsAsync</strong> can't be used if you need nested includes (the <strong class="source-inline">ThenInclude</strong> extension method in EF Core). In this case, create a custom repository method.</p>
			<h4>The Aggregate pattern</h4>
			<p>The Aggregate pattern will be covered in depth in <a href="B17287_10_Epub_AM.xhtml#_idTextAnchor316"><em class="italic">Chapter 10</em></a>, <em class="italic">DDD – The Domain Layer</em>. However, to give a brief bit of information, an aggregate is considered a single unit; it is read and <a id="_idIndexMarker385"/>saved as a single unit with all sub-collections. That means you always load related questions while loading a form.</p>
			<p>ABP supports the aggregate pattern well and allows you to configure eager loading for an entity at a global point. We can write the following configuration inside the <strong class="source-inline">ConfigureServi<a id="_idTextAnchor199"/>ces</strong> method of our module class (in the <strong class="source-inline">EntityFrameworkCore</strong> project in your solution):</p>
			<p class="source-code">Configure&lt;AbpEntityOptions&gt;(options =&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">    options.Entity&lt;Form&gt;(orderOptions =&gt;</p>
			<p class="source-code">    {</p>
			<p class="source-code">        orderOptions.DefaultWithDetailsFunc = query =&gt;                   query</p>
			<p class="source-code">            .Include(f =&gt; f.Questions)</p>
			<p class="source-code">            .Include(f =&gt; f.Owners);</p>
			<p class="source-code">    });</p>
			<p class="source-code">});</p>
			<p>It is suggested to include all sub-collections. Once you configure the <strong class="source-inline">DefaultWithDetailsFunc</strong> method as shown, then the following will occur:</p>
			<ul>
				<li>Repository methods that return a single entity (such as <strong class="source-inline">GetAsync</strong>) will eager-load related entities by default unless you explicitly disable that behaviour by specifying the <strong class="source-inline">includeDetails</strong> parameter to <strong class="source-inline">false</strong> on the method call.</li>
				<li>Repository methods that return multiple entities (such as <strong class="source-inline">GetListAsync</strong>) will allow the eager loading of related entities, while they will not eager-load by default.</li>
			</ul>
			<p>Here are some examples.</p>
			<p>Get a single form with sub-collections included like this:</p>
			<p class="source-code">var form = await _formRepository.GetAsync(formId);</p>
			<p>Get a single form without sub-collections like this:</p>
			<p class="source-code">var form = await _formRepository.GetAsync(formId, includeDetails: false);</p>
			<p>Get a list of forms without sub-collections like this:</p>
			<p class="source-code">var forms = await _formRepository.GetListAsync(f =&gt; f.Name.StartsWith("A"));</p>
			<p>Get a list of forms with sub-collections included like this:</p>
			<p class="source-code">var forms = await _formRepository.GetListAsync(f =&gt; f.Name.StartsWith("A"), includeDetails: true);</p>
			<p>The Aggregate pattern simplifies your application code in most cases, while you can still fine-tune cases where you <a id="_idIndexMarker386"/>need performance optimization. Note that navigation properties (to other aggregates) are not used if you truly implement the Aggregate pattern. We will return to this topic again in <a href="B17287_10_Epub_AM.xhtml#_idTextAnchor316"><em class="italic">Chapter 10</em></a>, <em class="italic">DDD – The Domain Layer</em>.</p>
			<p>We've covered the essentials of using EF Core with ABP Framework. The next section will explain MongoDB integration, the other built-in database provider of ABP Framework.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor200"/>MongoDB integration</h1>
			<p>MongoDB is a popular non-relational <strong class="bold">document database</strong>, which stores data in JSON-like documents <a id="_idIndexMarker387"/>rather than traditional row-/column-based tables.</p>
			<p>The ABP CLI provides an option to create new applications using MongoDB, as shown here:</p>
			<p class="source-code">abp new FormsApp -d mongodb</p>
			<p>If you want to check and change the database connection string, you can look at the <strong class="source-inline">appsettings.json</strong> file of your application.</p>
			<p class="callout-heading">The MongoDB Client Package</p>
			<p class="callout">ABP uses the official <strong class="source-inline">MongoDB.Driver</strong> NuGet package for MongoDB integration.</p>
			<p>In the next chapters, you will learn <a id="_idIndexMarker388"/>how to work with ABP's <strong class="source-inline">AbpMongoDbContext</strong> class to define <strong class="source-inline">DbContext</strong> objects, perform object-mapping configurations, register <strong class="source-inline">DbContext</strong> objects with the DI system, and implement custom repositories when you want to extend the generic repositories for your entities.</p>
			<p>We begin the MongoDB integration by defining a <strong class="source-inline">DbContext</strong> class.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor201"/>Defining DbContexts</h2>
			<p>The MongoDB driver package doesn't have a <strong class="source-inline">DbContext</strong> concept like EF Core does. However, ABP introduces <a id="_idIndexMarker389"/>the <strong class="source-inline">AbpMongoDbContext</strong> class to provide a standard way to define and configure MongoDB integration. We need to define a class deriving from the <strong class="source-inline">AbpMongoD<a id="_idTextAnchor202"/>bContext</strong> base class, as follows:</p>
			<p class="source-code">public class FormsAppDbContext : AbpMongoDbContext</p>
			<p class="source-code">{</p>
			<p class="source-code">    [MongoCollection("Forms")]</p>
			<p class="source-code">    public IMongoCollection&lt;Form&gt; Forms =&gt;                           Collection&lt;Form();</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">MongoCollection</strong> attribute sets the collection name on the database side. It is optional and uses the driver's default value if you don't specify it. Defining a collection property on the <strong class="source-inline">FormsAppDbContext</strong> class is required to use the default generic repositories.</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor203"/>Configuring object mappings</h2>
			<p>While the MongoDB C# driver is not an ORM, it still maps your entities to collections in the database, and you may <a id="_idIndexMarker390"/>want to customize the mapping configuration. In this case, override the <strong class="source-inline">CreateModel</strong> method in your <strong class="source-inline">DbContext</strong> class like this:</p>
			<p class="source-code">protected override void CreateModel(IMongoModelBuilder builder)</p>
			<p class="source-code">{</p>
			<p class="source-code">    builder.Entity&lt;Form&gt;(b =&gt;</p>
			<p class="source-code">    {</p>
			<p class="source-code">        b.BsonMap.UnmapProperty(f =&gt; f.Description);</p>
			<p class="source-code">    });</p>
			<p class="source-code">}</p>
			<p>In this example, I've configured MongoDB so that it ignores the <strong class="source-inline">Description</strong> property of the <strong class="source-inline">Form</strong> entity <a id="_idIndexMarker391"/>while saving and retrieving data. Please refer to the documentation of the <strong class="source-inline">MongoDB.Driver</strong> NuGet package to learn about all configuration options.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor204"/>Registering DbContext with DI</h2>
			<p>Once you create <a id="_idIndexMarker392"/>and configure your <strong class="source-inline">DbContext</strong> class, it is registered with the DI system in the <strong class="source-inline">ConfigureServices</strong> method of your module class (typically in the MongoDB integration project of your solution). The following code snippet illustrates this:</p>
			<p class="source-code">public override void ConfigureServices(</p>
			<p class="source-code">    ServiceConfigurationContext context)</p>
			<p class="source-code">{</p>
			<p class="source-code">    context.Services.AddMongoDbContext&lt;FormsAppDbContext&gt;(</p>
			<p class="source-code">        options =&gt;</p>
			<p class="source-code">            {</p>
			<p class="source-code">                options.AddDefaultRepositories();</p>
			<p class="source-code">            });</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">AddDefaultRepositories()</strong> is used to enable default generic repositories for your entities related to that <strong class="source-inline">DbContext</strong>. You can then inject <strong class="source-inline">IRepository&lt;Form&gt;</strong> into your classes and start using your MongoDB database.</p>
			<p>The <strong class="source-inline">AddDefaultRepositories</strong> method enables default repositories only for aggregate root <a id="_idIndexMarker393"/>entities (the entity classes derived from the <strong class="source-inline">AggregateRoot</strong> class). Set <strong class="source-inline">includeAllEntities</strong> to <strong class="source-inline">true</strong> to enable default repositories for all entity types. However, it is strongly suggested to apply the Aggregate pattern while working with MongoDB. The Aggregate pattern will be covered in depth in <a href="B17287_10_Epub_AM.xhtml#_idTextAnchor316"><em class="italic">Chapter 10</em></a>, <em class="italic">DDD – The Domain Layer</em>.</p>
			<p>Default generic repositories are enough in most cases, but you may need to access the MongoDB API or abstract your queries into custom repository methods.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor205"/>Implementing custom repositories</h2>
			<p>We created <a id="_idIndexMarker394"/>an <strong class="source-inline">IFormRepository</strong> interface in the <em class="italic">Custom repositories</em> part of the <em class="italic">Working with repositories</em> section in this chapter. We can implement this repository interface using MongoDB.</p>
			<p>You ca<a id="_idTextAnchor206"/>n implement the repository inside the MongoDB integration project of your solution, like this:</p>
			<p class="source-code">using System;</p>
			<p class="source-code">using System.Collections.Generic;</p>
			<p class="source-code">using System.Threading.Tasks;</p>
			<p class="source-code">using MongoDB.Driver;</p>
			<p class="source-code">using MongoDB.Driver.Linq;</p>
			<p class="source-code">using Volo.Abp.Domain.Repositories.MongoDB;</p>
			<p class="source-code">using Volo.Abp.MongoDB;</p>
			<p class="source-code">namespace FormsApp</p>
			<p class="source-code">{</p>
			<p class="source-code">    public class FormRepository : </p>
			<p class="source-code">        MongoDbRepository&lt;FormsAppDbContext, Form, Guid&gt;, </p>
			<p class="source-code">        IFormRepository</p>
			<p class="source-code">    {</p>
			<p class="source-code">        public FormRepository(</p>
			<p class="source-code">            IMongoDbContextProvider&lt;FormsAppDbContext&gt;                       dbContextProvider)</p>
			<p class="source-code">            : base(dbContextProvider)</p>
			<p class="source-code">        { }</p>
			<p class="source-code">        // TODO: implement the GetListAsync method</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">FormRepository</strong> class is derived from ABP's <strong class="source-inline">MongoDbRepository</strong> class. In this way, we are inheriting <a id="_idIndexMarker395"/>all the standard repository methods. The <strong class="source-inline">MongoDbRepository</strong> class gets three generic parameters: the <strong class="source-inline">DbContext</strong> type, the entity type, and the PK type of the entity class.</p>
			<p>The <strong class="source-inline">FormRepository</strong> class<a id="_idTextAnchor207"/> should implement the <strong class="source-inline">GetListAsync</strong> method defined by the <strong class="source-inline">IFormRepository</strong> interface, as follows:</p>
			<p class="source-code">public async Task&lt;List&lt;Form&gt;&gt; GetListAsync(</p>
			<p class="source-code">    string name, bool includeDrafts = false)</p>
			<p class="source-code">{</p>
			<p class="source-code">    var queryable = await GetMongoQueryableAsync();</p>
			<p class="source-code">    var query = queryable.Where(f =&gt;                                 f.Name.Contains(name));</p>
			<p class="source-code">    if (!includeDrafts)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        query = queryable.Where(f =&gt; !f.IsDraft);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return await query.ToListAsync();</p>
			<p class="source-code">}</p>
			<p>I've used the LINQ API of the MongoDB driver in this example, but you can use alternative APIs by <a id="_idIndexMarker396"/>obtaining the <strong class="source-inline">IMongoCollection</strong> object, as illustrated in the following code snippet:</p>
			<p class="source-code">IMongoCollection&lt;Form&gt; formsCollection = await GetCollectionAsync();</p>
			<p>Now, you can inject <strong class="source-inline">IFormRepository</strong> instead of the generic <strong class="source-inline">IRepository&lt;Form, Guid&gt;</strong> repository into your services and use all the standard and custom repository methods.</p>
			<p>Even if you implement a custom repository class for the <strong class="source-inline">Form</strong> entity, it is still possible to inject and use default generic repositories (such as <strong class="source-inline">IRepository&lt;Form, Guid&gt;</strong>) for that entity. If you implement a custom repository, it is suggested to use the <strong class="source-inline">AddRepository</strong> method on the <strong class="source-inline">DbContext</strong> registration code, as illustrated in the following code snippet:</p>
			<p class="source-code">context.Services.AddMongoDbContext&lt;FormsAppDbContext&gt;(options =&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">    options.AddDefaultRepositories();</p>
			<p class="source-code">    options.AddRepository&lt;Form, FormRepository&gt;();</p>
			<p class="source-code">});</p>
			<p>In this way, generic default repositories will be redirected to your custom repository class. If you override a base method in your custom repository, they will also use your overload instead of the base method.</p>
			<p>We've learned how to use EF Core and MongoDB as the database provider. In the next section, we will understand the UoW system, making it possible to connect these databases and apply transactions.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor208"/>Understanding the UoW system</h1>
			<p>UoW is the main system that ABP uses to initiate, manage, and dispose of database connections and <a id="_idIndexMarker397"/>transactions. The UoW system is designed with the <strong class="bold">Ambient Context pattern</strong>. That means when we create a new UoW, it creates a <a id="_idIndexMarker398"/>scoped context that is participated by all the database operations performed in the current scope by sharing the same context and is considered a single transaction boundary. All the operations done in a UoW are committed (on success) or rolled back (on exception) together.</p>
			<p>While you can manually create UoW scopes and control the transaction properties, most of the time, it works seamlessly just as you desire. However, it provides some options if you change the default behavior.</p>
			<p class="callout-heading">UoW and Database Operations</p>
			<p class="callout">All database operations must be performed in a UoW scope since UoW is the way to manage database <a id="_idIndexMarker399"/>connections and transactions in ABP Framework. Otherwise, you get an exception indicating that.</p>
			<p>In the next sections, you will gain an understanding of how the UoW system works and customize it by configuring the options. I will also explain how to manually control the UoW system when the conventional system doesn't work for your use case.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor209"/>Configuring UoW options </h2>
			<p>With the default setup, in an ASP.NET Core application, an HTTP request is considered as the UoW scope. ABP starts <a id="_idIndexMarker400"/>a UoW at the beginning of the request and saves changes to the database if the request successfully finishes. It rolls back the UoW if the request fails because of an exception.</p>
			<p>ABP determines database transaction usage based on the HTTP request type. HTTP <strong class="source-inline">GET</strong> requests don't create a database transaction. UoW works anyway but doesn't use a database transaction in this case. All other HTTP request types (<strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, <strong class="source-inline">DELETE</strong>, and others) use a database transaction if you haven't configured them otherwise.</p>
			<p class="callout-heading">HTTP GET Requests and Transactions</p>
			<p class="callout">It is a best practice not to make database changes in <strong class="source-inline">GET</strong> requests. If you make multiple write operations in a <strong class="source-inline">GET</strong> request and somehow your request fails, your database state could be left in an inconsistent state because ABP doesn't create a database transaction for <strong class="source-inline">GET</strong> requests. In this case, either enable transactions for <strong class="source-inline">GET</strong> requests using  <strong class="source-inline">AbpUnitOfWorkDefaultOptions</strong> or manually control the UoW, as described in the next section.</p>
			<p>Use <strong class="source-inline">AbpUnitOfWorkDefaultOptions</strong> in the <strong class="source-inline">ConfigureServices</strong> method of your <a id="_idIndexMarker401"/>module (in the database integration project) if you want to change the UoW option<a id="_idTextAnchor210"/>s, as follows:</p>
			<p class="source-code">public override void ConfigureServices(</p>
			<p class="source-code">    ServiceConfigurationContext context)</p>
			<p class="source-code">{</p>
			<p class="source-code">    Configure&lt;AbpUnitOfWorkDefaultOptions&gt;(options =&gt;</p>
			<p class="source-code">    {</p>
			<p class="source-code">        options.TransactionBehavior =                                   UnitOfWorkTransactionBehavior.Enabled;</p>
			<p class="source-code">        options.Timeout = 300000; // 5 minutes</p>
			<p class="source-code">        options.IsolationLevel =                                      IsolationLevel.Serializable;</p>
			<p class="source-code">    });</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">TransactionBehavior</strong> can take the following three values:</p>
			<ul>
				<li><strong class="source-inline">Auto</strong> (default): Automatically determines using database transactions (transactions are enabled for non-<strong class="source-inline">GET</strong> <strong class="source-inline">HTTP</strong> requests)</li>
				<li><strong class="source-inline">Enabled</strong>: Always uses a database transaction, even for <strong class="source-inline">HTTP</strong> <strong class="source-inline">GET</strong> requests</li>
				<li><strong class="source-inline">Disabled</strong>: Never uses a database transaction</li>
			</ul>
			<p>The <strong class="source-inline">Auto</strong> behavior is the default value and is suggested for most applications. <strong class="source-inline">IsolationLevel</strong> is only valid for relational databases. ABP uses the default value of the underlying provider <a id="_idIndexMarker402"/>if you don't specify it. Finally, the <strong class="source-inline">Timeout</strong> option allows you to set a default timeout value for transactions as milliseconds. If a UoW operation doesn't complete in the given timeout value, a timeout exception is thrown.</p>
			<p>In this section, we've learned how to configure the default options across all UoWs. It is also possible to configure these values for an individual UoW if you manually control it.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor211"/>Manually controlling the UoW</h2>
			<p>For web applications, you rarely need to control the UoW system manually. However, for background <a id="_idIndexMarker403"/>workers or non-web applications, you may need to create UoW scopes yourself. You may also need to control the UoW system to create inner transaction scopes.</p>
			<p>One way to create a UoW scope is to use the <strong class="source-inline">[UnitOfWork]</strong> attribute on your method, like this:</p>
			<p class="source-code">[UnitOfWork(isTransactional: true)]</p>
			<p class="source-code">public async Task DoItAsync()</p>
			<p class="source-code">{</p>
			<p class="source-code">    await _formRepository.InsertAsync(new Form() { ... });</p>
			<p class="source-code">    await _formRepository.InsertAsync(new Form() { ... });</p>
			<p class="source-code">}</p>
			<p>The UoW system uses the Ambient Context pattern. If a surrounding UoW is already in place, your <strong class="source-inline">UnitOfWork</strong> attribute is ignored and your method participates in the surrounding UoW. Otherwise, ABP starts a new transactional UoW just before entering the <strong class="source-inline">DoItAsync</strong> method and commits the transaction if it doesn't throw an exception. The transaction is rolled back if that method throws an exception.</p>
			<p>If you want to fine-control the UoW system, you can inject and use the <strong class="source-inline">IUnitOfWorkManager</strong> service, as shown in the following code block:</p>
			<p class="source-code">public async Task DoItAsync()</p>
			<p class="source-code">{</p>
			<p class="source-code">    using (var uow = _unitOfWorkManager.Begin(</p>
			<p class="source-code">        requiresNew: true,</p>
			<p class="source-code">        isTransactional: true,</p>
			<p class="source-code">        timeout: 15000))</p>
			<p class="source-code">    {</p>
			<p class="source-code">        await _formRepository.InsertAsync(new Form() { });</p>
			<p class="source-code">        await _formRepository.InsertAsync(new Form() { });</p>
			<p class="source-code">        await uow.CompleteAsync();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In this example, we are starting a new transactional UoW scope with 15 seconds as the <strong class="source-inline">timeout</strong> parameter's value. With this usage (<strong class="source-inline">requiresNew: true</strong>), ABP always starts a new UoW even if <a id="_idIndexMarker404"/>there is a surrounding UoW. Always call the <strong class="source-inline">uow.CompleteAsync()</strong> method if everything goes right. You can use the <strong class="source-inline">uow.RollbackAsync()</strong> method if you want to roll back the current transaction.</p>
			<p>As mentioned before, UoW uses an ambient scope. You can access the current UoW anywhere in this scope, using the <strong class="source-inline">IUnitOfWorkManager.Current</strong> property. It can be <strong class="source-inline">null</strong> if there is no ongoing UoW.</p>
			<p>The following code snippet uses the <strong class="source-inline">SaveChangesAsync</strong> method with the <strong class="source-inline">IUnitOfWorkManager.Current</strong> property:</p>
			<p class="source-code">await _unitOfWorkManager.Current.SaveChangesAsync();</p>
			<p>We've saved all pending changes to the database. However, if that's a transactional UoW, these changes are also rolled back if you roll back the UoW or throw any exception in the UoW scope.</p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor212"/>Summary</h1>
			<p>In this chapter, we've learned how to work with databases using ABP Framework. ABP standardizes to define entities by providing base classes. It also helps to automatically track change times and the users changing entities, when you derive from audited entity classes.</p>
			<p>The repository system provides the fundamental functionalities to read and write entities. You can use LINQ over the repositories for advanced querying possibilities. Also, you can create custom repository classes to work with the underlying data provider directly, hide complex queries behind simple repository interfaces, call stored procedures, and so on.</p>
			<p>ABP is database-agnostic, but it provides integration packages with EF Core and MongoDB out of the box. ABP application startup templates come with one of these providers, whichever you prefer.</p>
			<p>EF Core is the de facto ORM for the .NET platform, and ABP supports EF Core as a first-class citizen. The application startup template is fine-tuned to configure your mappings and manage your database schema migrations while supporting a modular application structure.</p>
			<p>Finally, the UoW system provides a seamless way to manage database connections and transactions for us. It keeps the application code clean by automating these repeating tasks for us.</p>
			<p>Data access is a core requirement for any business application, and it is essential to understand the details of it. The next chapter will continue with the cross-cutting concerns required for every application, such as authorization, validation, and exception handling.</p>
		</div>
	</body></html>