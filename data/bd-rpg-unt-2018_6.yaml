- en: Inventory System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库存系统
- en: The inventory system is one of the most critical components of an RPG. It will
    be used to store all important game elements that the player will need in your
    game environment. This chapter will guide you on how to create a simple generic
    inventory system that can be utilized and extended as you see fit.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 库存系统是RPG中最关键的组件之一。它将用于存储玩家在游戏环境中需要的所有重要游戏元素。本章将指导您如何创建一个简单通用的库存系统，您可以按需利用和扩展。
- en: 'Here is a breakdown of the chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章的概述：
- en: Designing an inventory system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计库存系统
- en: Weighted inventory
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加权库存
- en: Determining item types
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定物品类型
- en: Creating an inventory item
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建库存物品
- en: Creating the prefab
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建预制件
- en: Adding an inventory item agent
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加库存物品代理
- en: Inventory items defined as prefabs
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将库存物品定义为预制件
- en: Designing an inventory interface
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计库存界面
- en: Creating the inventory UI framework
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建库存UI框架
- en: Designing a dynamic item viewer
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计动态物品查看器
- en: Adding a scroll view
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加滚动视图
- en: Adding elements to PanelItem and Scroll View
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向PanelItem和Scroll View添加元素
- en: Adding txtItemElement dynamically
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态添加txtItemElement
- en: Building the final inventory item UI
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建最终的库存物品UI
- en: Integrating the UI with the actual inventory system
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用户界面与实际库存系统集成
- en: Hooking the category buttons and displaying the data
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接分类按钮并显示数据
- en: Testing the inventory system
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试库存系统
- en: Inventory items and the player character
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库存物品和玩家角色
- en: Applying inventory items
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用库存物品
- en: How it looks
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它看起来如何
- en: There is a lot of work ahead of us in this chapter. Let's get started!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前有许多工作要做。让我们开始吧！
- en: Designing an inventory system
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计库存系统
- en: As with everything else we have discussed thus far, designing your **inventory
    system** will also be heavily dependent on your game. There are many different
    types of inventory system mechanics that you can study and choose based on its
    relevance to your game.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们迄今为止讨论的每一件事一样，设计您的**库存系统**也将严重依赖于您的游戏。有许多不同类型的库存系统机制可以研究并选择，这取决于其与您游戏的关联性。
- en: Weighted inventory
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加权库存
- en: I will be leaning towards implementing what is called the **weighted inventory**.
    In this type of inventory system, each item or piece of equipment is assigned
    a numerical value that represents the weight of the item. This, in return, is
    used to determine how much inventory the player can carry at any given time during
    game play. This makes sense for our RPG, if you think about it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我将倾向于实现所谓的**加权库存**。在这种类型的库存系统中，每个物品或装备都被分配一个数值，代表物品的重量。反过来，这个数值用于确定玩家在游戏过程中任何给定时间可以携带多少库存。如果您这么想，这对我们的RPG来说是有意义的。
- en: 'Consider the following as an example: assume you are a hiker who wants to climb
    Mount Ararat. The climb itself will take a certain amount of time. During the
    climb, you will need to carry with you the necessary equipment to complete the
    journey or climb. Realistically, there are several crucial items that you, as
    the hiker, will need to carry with you, such as those shown in the following list:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下内容为例：假设你是一名想要攀登阿勒山（Mount Ararat）的徒步者。攀登本身将花费一定的时间。在攀登过程中，你需要携带完成旅程或攀登所需的必要装备。从现实的角度来看，作为徒步者，你需要携带一些关键物品，如下列所示：
- en: Clothing
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服装
- en: Tents
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帐篷
- en: Sleeping bags
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 睡袋
- en: Boots
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鞋子
- en: Ice breakers
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打破僵局的物品
- en: Food
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 食物
- en: Light source
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光源
- en: Personal items
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个人物品
- en: Each one of the categories listed above has a specific weight associated to
    it in real life. Therefore, when you are planning your hike, you will need to
    plan ahead and see how you can meet your climbing needs, while in the meantime
    also reducing the amount of items and the total weight of the items you will need
    to carry on your back during the journey. The actual logistics are a little more
    involved, but you get the picture.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的每个类别在现实生活中都与特定的重量相关联。因此，在规划您的徒步旅行时，您需要提前规划，看看您如何满足攀登需求，同时在此期间减少需要携带在背上的物品数量和总重量。实际的物流要复杂一些，但您应该明白了。
- en: It is no different in our RPG. The player character can only carry a certain
    number of items and/or equipment with them for their journey. For instance, the
    player character cannot carry twenty different types of weapon at any given time!
    It would be just impossible, realistically speaking. So it would be a nice touch
    to put some realism into the game play.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的RPG游戏中，情况并无不同。玩家角色只能携带一定数量的物品和/或装备进行旅行。例如，玩家角色在任何时候都不能携带二十种不同的武器！从现实的角度来看，这是不可能的。因此，在游戏玩法中加入一些现实感将是一个很好的触点。
- en: Also, just like in real life, the heavier the equipment one has to carry, the
    more energy it will take. So, we can also incorporate such a system for our game.
    For instance, carrying too many weapons will have a major effect on the player
    character over a long period of time. First of all, it will reduce its speed and
    movement drastically; secondly, it can have a major impact on the health of the
    player. This is where your creativity and design skills will come into play. You
    are the master of the game, and you determine how you want to implement it!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，就像现实生活中一样，一个人携带的装备越重，所需的能量就越多。因此，我们也可以在我们的游戏中加入这样的系统。例如，携带过多的武器将对玩家角色在长时间内产生重大影响。首先，它将大大降低其速度和移动能力；其次，它可能对玩家的健康产生重大影响。这就是你的创造力和设计技能发挥作用的地方。你是游戏的主宰，你决定如何实现它！
- en: I am going to keep it simple for the sake of demonstration!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示的目的，我会保持简单！
- en: Determining item types
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定项目类型
- en: For starters, we will concentrate on some of the basic item types that we would
    like to define in our game, such as weapons, armor, and clothing. On top of this,
    we can also add health packets, potions, and collectibles.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将专注于在我们的游戏中定义的一些基本项目类型，例如武器、盔甲和服装。在此基础上，我们还可以添加健康包、药水以及可收集物品。
- en: We will create three new scripts named `BaseItem.cs`, `InventoryItem.c`, and
    `InventorySystem.cs`. The `BaseItem` class will hold the generic properties for
    all items, just like the `BaseCharacter` class we defined previously. The `InventoryItem`
    class will inherit the `BaseItem` class and define the item type.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建三个新的脚本，名为`BaseItem.cs`、`InventoryItem.c`和`InventorySystem.cs`。`BaseItem`类将包含所有项目的通用属性，就像我们之前定义的`BaseCharacter`类一样。`InventoryItem`类将继承`BaseItem`类并定义项目类型。
- en: 'A listing of `BaseItem.cs` is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`BaseItem.cs`的列表：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The main idea in the preceding code is `ItemCateogry`. At the moment, I have
    kept it to only five different types of category that the inventory would keep
    track of.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中的主要思想是`ItemCateogry`。目前，我将其保留为仅五种不同的类别，库存将跟踪这些类别。
- en: A category could have multiple item types. For instance, there are different
    types of weapons and so on.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类别可以包含多个项目类型。例如，有不同类型的武器等等。
- en: 'A listing of `InventoryItem.cs` is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`InventoryItem.cs`的列表：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code implements more properties or attributes for the items to
    be used in the inventory. For now, let's just keep it the way it is; we can always
    change it in the future.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码为库存中使用的项目实现了更多属性或属性。目前，我们只需保持现状；我们以后总是可以更改它。
- en: The next important script is the actual script that will be used to manage the
    inventory. There are many ways to implement the logic for the inventory system.
    Again keeping things simple, the current script will have five `List` datatypes
    of type `InventoryItem`, one for each item category.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要的脚本就是实际用于管理库存的脚本。实现库存系统逻辑的方法有很多。为了保持简单，当前的脚本将包含五种`List`数据类型，类型为`InventoryItem`，每种项目类别一个。
- en: 'A listing of `InventorySystem.cs` is as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`InventorySystem.cs`的列表：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We won''t have direct access to the lists that will be used to contain the
    inventory items. For now, we have implemented two functions, `AddItem()` and `DeleteItem()`,
    which will handle the two basics features of the inventory, adding an item to
    it and removing an item from it. These two functions will take an `InventoryItem` object,
    and based on `ItemCategory`, be added or removed from the appropriate list within
    the inventory, as shown in the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将无法直接访问将用于包含库存项目的列表。目前，我们已经实现了两个函数，`AddItem()`和`DeleteItem()`，它们将处理库存的两个基本功能，即向其中添加项目或从其中删除项目。这两个函数将接受一个`InventoryItem`对象，并根据`ItemCategory`将其添加或删除到库存中适当的列表中，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The basics are in place. Now we will need to integrate this with the `GameMaster.cs`
    script. To do so, we will need to create a new variable of type `InventorySystem`
    named `INVENTORY`, initialized in the `Awake()` function of the `GameMaster.cs`
    script.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施已经到位。现在我们需要将其与`GameMaster.cs`脚本集成。为此，我们需要在`GameMaster.cs`脚本的`Awake()`函数中创建一个名为`INVENTORY`的新变量，其类型为`InventorySystem`。
- en: 'The following listing illustrates just the new addition:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表仅展示了新增内容：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Notice that we are actually creating an `InventoryItem` object and inserting
    it into `InventorySystem` for testing purposes. Another great feature is that
    you can see `InventorySystem` during design time since we have serialized the
    classes and the fields. Take a look at the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们实际上正在创建一个`InventoryItem`对象并将其插入到`InventorySystem`中，用于测试目的。另一个很棒的功能是，由于我们已经序列化了类和字段，您可以在设计时看到`InventorySystem`。请看以下截图：
- en: '![](img/00114.gif)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00114.gif)'
- en: 'The preceding screenshot displays the inventory system as seen in the Inspector
    Window when you select the `GameMaster` object. When you run the game to test
    it, you will see the following update:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示了在您选择`GameMaster`对象时在检查器窗口中看到的库存系统。当您运行游戏进行测试时，您将看到以下更新：
- en: '![](img/00115.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00115.jpeg)'
- en: Notice how the data reflects appropriately in the inventory system, as expected!
    The CLOTHING list has increased its size to 1, and the `InventoryItem` object
    within the list is properly stored and displayed for testing and debugging. We
    have one clothing item named Testing, with the given description, a Strength of
    0.5, and a Weight of 0.2.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意数据如何如预期地在库存系统中适当反映！服装列表的大小已增加到1，列表中的`InventoryItem`对象被正确存储和显示以供测试和调试。我们有一个名为Testing的服装项目，具有给定的描述，力量为0.5，重量为0.2。
- en: So far, so good. Now we need to actually create the items that will be used
    to visually represent our inventory items! This is discussed in the following
    section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。现在我们需要实际创建用于视觉表示库存物品的项目！这将在下一节中讨论。
- en: Creating an inventory item
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建库存物品
- en: It is now time to actually create the items (assets) we are going to use for
    our inventory system. I will be creating one item type from each item category
    to keep things simple. This section will again be highly dependent on how you
    have modeled your character models. As discussed earlier in the book, in my particular
    model, all of the character's essential parts are embedded within the **fbx**.
    In this case, you will need to navigate down your model's hierarchy and extract
    the mesh for the specific armor or weapon, or anything else you will be using
    for the inventory.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是实际创建我们将用于库存系统的项目（资产）的时候了。我将从每个项目类别创建一个项目类型以保持简单。本节将再次高度依赖于您如何建模您的角色模型。正如本书前面所讨论的，在我的特定模型中，角色的所有基本部分都嵌入在**fbx**中。在这种情况下，您需要导航到您的模型层次结构并提取特定装甲或武器的网格，或者您将用于库存的任何其他东西。
- en: You can also use independent models representing your inventory items that may
    or may not be related to your character model's mesh. These items are just used
    for visual representation within the world, so that the player can pick them up.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用代表您的库存物品的独立模型，这些模型可能与您的角色模型网格相关或不相关。这些物品仅用于在世界上进行视觉表示，以便玩家可以捡起它们。
- en: '![](img/00116.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00116.jpeg)'
- en: Creating asset prefabs
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 创建资产预制件
- en: If you recall from the character customization scene, we had already gone through
    the model and identified the parts we wanted to have the player be able to enable
    or disable based on the selection they made through the interface.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得角色定制场景，我们已经通过了模型并确定了玩家可以通过界面选择启用或禁用的部分。
- en: Creating the prefab
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建预制件
- en: If you have not already done so, go ahead and create a folder in your Project
    Window named Prefabs. Within this folder, go ahead and create a new folder and
    name it InventoryItems, and then create a sub-folder named ShoulderPads. You are
    welcome to use a different naming and folder structure if you choose, as long
    as you are comfortable and it is organized for you to work with.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请在您的项目窗口中创建一个名为“Prefab”的文件夹。在此文件夹内，创建一个新的文件夹并命名为“InventoryItems”，然后创建一个名为ShoulderPads的子文件夹。如果您选择不同的命名和文件夹结构，只要您感到舒适并且它对您的工作是有组织的，您都可以这样做。
- en: 'To create a prefab, you simply need to take an existing GameObject that is
    present in the Scene Window and drag it into the Project Window. To keep things
    organized, we will be using the structure defined in the previous paragraph. So
    you will need to navigate to the ShoulderPads folder in the project window, and
    then simply drag one of the shoulder pad meshes from your model and drop it into
    the ShoulderPads folder. Take a look at the following screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个预制体，你只需要将存在于场景窗口中的现有GameObject拖入项目窗口。为了保持组织有序，我们将使用前面段落中定义的结构。所以你需要导航到项目窗口中的ShoulderPads文件夹，然后简单地将你的模型中的一个肩垫网格拖到ShoulderPads文件夹中。看看下面的屏幕截图：
- en: '![](img/00117.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00117.jpeg)'
- en: Creating asset prefabs
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 创建资产预制体
- en: Observe, when you create a prefab, the prefab will be an exact copy of the GameObject
    in the active scene! In this case, my mesh is disabled in the scene; therefore,
    when I create a prefab of the mesh, it will also be disabled! Since it is disabled,
    when you drag the newly created prefab into the scene as a new GameObject, it
    will be invisible; you will need to enable it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 观察一下，当你创建一个预制体时，该预制体将是活动场景中GameObject的精确副本！在这种情况下，我的网格在场景中是禁用的；因此，当我为网格创建预制体时，它也将被禁用！由于它是禁用的，当你将新创建的预制体作为新的GameObject拖入场景时，它将是不可见的；你需要启用它。
- en: Adding an inventory item agent
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加库存物品代理
- en: We need the means to interact with our inventory items. In order to do this,
    we will need to create a new script that will handle our interaction with the
    inventory items during game play. This will be coded in the `InventoryItemAgent.cs`
    script. At the moment, the script will just enable us to interact with the `InventoryItem`
    object through the IDE.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要与我们的库存物品进行交互的手段。为了做到这一点，我们需要创建一个新的脚本，该脚本将在游戏过程中处理我们与库存物品的交互。这将在`InventoryItemAgent.cs`脚本中编码。目前，这个脚本将使我们能够通过IDE与`InventoryItem`对象进行交互。
- en: 'A listing of the script is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本列表如下：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Very simply, in order for us to be able to interact with the GameObject, we
    would need to use a script that inherits *MonoBehaviour*. Go ahead and attach
    this script to your prefab. Now you can easily set up your inventory items visually.
    Take a look at the following screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单，为了我们能够与GameObject进行交互，我们需要使用一个继承自*MonoBehaviour*的脚本。现在将这个脚本附加到你的预制体上。现在你可以轻松地通过视觉设置你的库存物品。看看下面的屏幕截图：
- en: '![](img/00118.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00118.jpeg)'
- en: Inventory item agent
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 库存物品代理
- en: In the preceding screenshot, you can see that we have created a GameObject from
    the prefab and, using the InventoryItemAgent component, we have access to the
    properties of the InventoryItem object. Utilizing this concept, you can now create
    your prefabs for the different types of inventory item.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，你可以看到我们已经从一个预制体创建了一个GameObject，并且使用InventoryItemAgent组件，我们可以访问InventoryItem对象的属性。利用这个概念，你现在可以创建不同类型库存物品的预制体。
- en: If you are applying your changes in the scene window, make sure you apply them
    to the original prefab so that it keeps it in memory.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在场景窗口中应用更改，请确保你将它们应用到原始预制体上，以便将其保留在内存中。
- en: 'Caution: When you apply changes to a prefab, all instances of the prefab get
    updated with the new attributes.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当你对一个预制体应用更改时，所有预制体的实例都将更新为新属性。
- en: At the moment we have implemented an easy way to define our inventory items,
    but we still need to implement user interaction with the items. The logic for
    the interaction will be implemented in the `InventoryItemAgent.cs` script. First
    we need to identify who we are colliding with; in this case, we want to make sure
    it is the player that is going to collect the item. Second, we need to store the
    data in `GameMaster`, and also remove `GameObject` from the active scene. The
    last two parts will be handled by `GameMaster`, as you will see.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们已经实现了一种定义我们的库存物品的简单方法，但我们仍然需要实现用户与物品的交互。交互的逻辑将在`InventoryItemAgent.cs`脚本中实现。首先，我们需要确定我们与谁发生了碰撞；在这种情况下，我们想确保是玩家将要收集的物品。其次，我们需要在`GameMaster`中存储数据，并从活动场景中删除`GameObject`。最后两部分将由`GameMaster`处理，正如你将看到的。
- en: 'The new code listing for `InventoryItemAgent.cs` is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventoryItemAgent.cs`的新代码列表如下：'
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'I have created a new function in the `InventoryItem.cs` script called `CoptInventoryItem()`.
    This function is used to make a copy of one `InventoryItem` object into another
    one. The code for the newly added function in the `InventoryItem` class is as
    follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`InventoryItem.cs`脚本中创建了一个名为`CoptInventoryItem()`的新函数。此函数用于将一个`InventoryItem`对象复制到另一个对象中。`InventoryItem`类中新添加的函数的代码如下：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have already seen how to add an item to the inventory using `GameMaster`.
    However, we need to add a new function that will handle the destruction of `GameObjects`
    in our game. This is done by the `RPG_Destroy()` function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用`GameMaster`添加项目到库存中。然而，我们需要添加一个新函数来处理我们游戏中`GameObjects`的销毁。这是通过`RPG_Destroy()`函数完成的。
- en: You cannot use `Destroy()`, `DestroyImmediate()`, or `DestroyObject()` since
    they are part of all `GameObjects` in Unity. Therefore, be cautious of your naming
    convention within your own classes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Destroy()`、`DestroyImmediate()`或`DestroyObject()`是Unity中所有`GameObjects`的一部分，因此你不能使用它们。因此，请谨慎地在自己的类中使用命名约定。
- en: 'The listing of the new function is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 新函数的列表如下：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'One final component that needs to be added to your prefabs representing the
    inventory items is a *Collider*. Take a look at the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 需要添加到代表库存物品的预制件中的最后一个组件是一个*碰撞器*。请看下面的截图：
- en: '![](img/00119.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00119.jpeg)'
- en: Mesh collider
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 网格碰撞器
- en: 'I used a Mesh Collider to keep things simple. A collider can be added by selecting
    the Add Component | Physics | Mesh Collider from the Inspector Window, as shown
    in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了一个网格碰撞器来简化事物。可以通过从检查器窗口中选择“添加组件 | 物理 | 网格碰撞器”来添加碰撞器，如下面的截图所示：
- en: '![](img/00120.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00120.jpeg)'
- en: Inventory items defined as prefabs
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义为预制件的库存物品
- en: 'The following figure shows some of the inventory item prefabs I have created
    for demonstration purposes:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了为演示目的创建的一些库存物品预制件：
- en: '![](img/00121.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00121.jpeg)'
- en: Inventory prefab sample
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 库存预制件样本
- en: The key for all of this to work is to make sure that your prefabs have the `InventoryItemAgent.cs`
    script as well as a `Collider` component attached to the prefabs. Then you will
    need to provide the inventory item data through the IDE uniquely identifying each
    one.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切能够工作的关键是要确保你的预制件具有`InventoryItemAgent.cs`脚本以及附加到预制件上的`Collider`组件。然后你需要通过IDE提供独特的库存项目数据，以标识每个项目。
- en: 'The following table lists the data for each inventory item defined:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了每个定义的库存物品的数据：
- en: '| **Prefab** | **Name** | **Description** | **Category** | **Strength** | **Weight**
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **预制件** | **名称** | **描述** | **类别** | **强度** | **重量** |'
- en: '| Helmet | HL01 | Brass Helmet with Two Horns | Armor | 0.2 | 0.2 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 头盔 | HL01 | 带有两个角的黄铜头盔 | 防具 | 0.2 | 0.2 |'
- en: '|  | HL02 | Brass Helmet Face Protection | Armor | 0.3 | 0.25 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '|  | HL02 | 黄铜头盔（面部防护） | 防具 | 0.3 | 0.25 |'
- en: '|  | HL03 | Bronze Helmet Protecting Face | Armor | 0.3 | 0.3 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|  | HL03 | 青铜头盔（保护面部） | 防具 | 0.3 | 0.3 |'
- en: '|  | HL04 | Bronze Helmet | Armor | 0.2 | 0.25 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '|  | HL04 | 青铜头盔 | 防具 | 0.2 | 0.25 |'
- en: '| Shield | SL01 | Iron Shield | Armor | 0.3 | 0.3 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 盾牌 | SL01 | 铁盾 | 防具 | 0.3 | 0.3 |'
- en: '|  | SL02 | Wooden Shield | Armor | 0.2 | 0.2 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '|  | SL02 | 木盾 | 防具 | 0.2 | 0.2 |'
- en: '| Shoulder Pads | SP01 | Shoulder Pad 01 | Armor | 0.1 | 0.2 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 肩部护甲 | SP01 | 肩部护甲01 | 防具 | 0.1 | 0.2 |'
- en: '|  | SP02 | Shoulder Pad 02 | Armor | 0.1 | 0.2 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '|  | SP02 | 肩部护甲02 | 防具 | 0.1 | 0.2 |'
- en: '|  | SP03 | Shoulder Pad 03 | Armor | 0.15 | 0.25 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '|  | SP03 | 肩部护甲03 | 防具 | 0.15 | 0.25 |'
- en: '|  | SP04 | Shoulder Pad 04 | Armor | 0.2 | 0.25 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|  | SP04 | 肩部护甲04 | 防具 | 0.2 | 0.25 |'
- en: '| Weapons | Axe1 | Single Head | Weapon | 0.2 | 0.1 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 武器 | Axe1 | 单头斧 | 武器 | 0.2 | 0.1 |'
- en: '|  | Axe2 | Double Head | Weapon | 0.25 | 0.2 |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '|  | Axe2 | 双头斧 | 武器 | 0.25 | 0.2 |'
- en: '|  | Club1 | Wooden Club | Weapon | 0.2 | 0.1 |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '|  | Club1 | 木棍 | 武器 | 0.2 | 0.1 |'
- en: 'Again, the data is arbitrary: you decide what best suits your game and game
    design. Usually, you will have a table that would be loaded with such information,
    and your game manager will handle preloading it at runtime from the server.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，数据是任意的：你决定什么最适合你的游戏和游戏设计。通常，你将有一个表格，该表格将加载此类信息，并且你的游戏管理器将在运行时从服务器中预加载它。
- en: Designing an inventory interface
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计库存界面
- en: It is now time to think about how we are going to visualize the inventory during
    game play. Creating a user interface for any game is a challenging task. You need
    to have a balanced approach about the amount of information you want to display
    on the screen at playtime, without interfering with the game play. In the meantime,
    you want to make sure that the player has the most crucial and important information
    necessary to complete their mission to hand.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候考虑我们如何在游戏过程中可视化库存了。为任何游戏创建用户界面都是一个具有挑战性的任务。你需要对在游戏时间显示的信息量有一个平衡的方法，同时不干扰游戏玩法。同时，你想要确保玩家手头有完成他们任务所必需的最关键和最重要的信息。
- en: 'With that said, let''s look at how we can design a simple user interface to
    enable the player with the basics of interacting with the inventory system. Here
    is a list of minimum features that the player should be able to perform:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们看看我们如何设计一个简单的用户界面，使玩家能够与库存系统进行基本的交互。以下是一个玩家应该能够执行的最小功能列表：
- en: Display the inventory at any time during game play
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在游戏过程中任何时间都可以显示库存
- en: Navigate based on category
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据类别导航
- en: See what items are listed under each category
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看每个类别下列出的物品
- en: Be able to remove an item from the inventory
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够从库存中移除物品
- en: Be able to consume an item from the inventory
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够从库存中消耗物品
- en: See what inventory items are already in use by the player
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看玩家已经使用的库存物品
- en: The preceding list will give us a good start for implementing our inventory
    interface. Let's start by identifying the categories that will need to be displayed.
    The categories are defined as an **enum** named `ItemCategory` in the `BaseItem`
    class.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表将为我们实现库存界面提供一个良好的起点。让我们首先确定需要显示的类别。这些类别在`BaseItem`类中定义为名为`ItemCategory`的枚举。
- en: 'We have the following: weapons, armor, clothing, health, and potion. Take a
    look at the following screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下几种：武器、盔甲、服装、健康和药水。请查看以下截图：
- en: '![](img/00122.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00122.jpeg)'
- en: 'The preceding screenshot shows a concept I am leaning towards for the implementation
    of the inventory interface. The interface can be constructed by utilizing the
    following UI elements:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了我在实现库存界面时所倾向于的一个概念。界面可以通过以下UI元素构建：
- en: Buttons
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮
- en: Panels
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面板
- en: Text
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本
- en: Images
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片
- en: Each category will have a button, and there will be one main panel containing
    the list of items per category, as illustrated in the preceding diagram. Each
    item will be contained in its own panel, which will contain an image of the inventory
    item, the item description, and two buttons that can be used to add or remove
    the item from the inventory system.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类别将有一个按钮，将有一个包含每个类别物品列表的主要面板，如图中所示。每个物品都将包含在其自己的面板中，该面板将包含库存物品的图片、物品描述以及两个按钮，可以用来将物品添加到或从库存系统中移除。
- en: Creating the inventory UI framework
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建库存UI框架
- en: Let's start by first implementing the initial framework for our inventory system
    graphical interface. In the main scene of your project, go ahead and create a
    new *Canvas* GameObject if you have not done so already.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从实现我们的库存系统图形界面的初始框架开始。在你的项目主场景中，如果你还没有这样做，请创建一个新的*Canvas* GameObject。
- en: To do so, right-click on the Hierarchy *Window,* and select UI | Panel. This
    will automatically create a Canvas GameObject and a Panel UI Element as a child
    to the canvas.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，右键单击层次结构*窗口，然后选择UI | 面板。这将自动创建一个Canvas GameObject和一个作为画布子项的Panel UI元素。
- en: Rename this panel PanelInventory. This will be the main panel that will contain
    everything else. Now, let's go ahead and start building the buttons that will
    represent our main categories.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将此面板重命名为PanelInventory。这将是一个包含所有其他内容的主体面板。现在，让我们开始构建代表我们主要类别的按钮。
- en: Similarly, right-click on the PanelInventory GameObject and select UI | Button.
    This will make sure that the newly created button becomes a child of the PanelInventory.
    If, for whatever reason, this is not the case in the Hierarchy Window after the
    creation of the button(s), simply drag the newly created button(s) under the PanelInventory
    panel. Do this for all five categories. Rename the buttons appropriately, such
    as butWeaponsCategory and so on.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，右键单击PanelInventory GameObject，然后选择UI | 按钮。这将确保新创建的按钮成为PanelInventory的子项。如果在创建按钮（s）后，在层次结构窗口中由于任何原因这不是这种情况，只需将新创建的按钮（s）拖到PanelInventory面板下。为所有五个类别都这样做。适当地重命名按钮，例如butWeaponsCategory等等。
- en: 'Change the caption of the button so that it reflects the button''s function.
    Also, rename the Text element to something like the following: txtWeaponsCategory
    and so on. Take a look at the following screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 更改按钮的标题，使其反映按钮的功能。同时，将文本元素重命名为类似以下的内容：txtWeaponsCategory等等。查看以下截图：
- en: '![](img/00123.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00123.jpeg)'
- en: Inventory UI
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 库存UI
- en: 'Finally, add a new Panel element to the PanelInventory again, by selecting
    the PanelInventory GameObject and right-clicking and selecting UI | Panel. Rename
    the newly created panel to PanelCategory. Take a look at the following screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，再次在PanelInventory中添加一个新的Panel元素，通过选择PanelInventory GameObject并右键点击选择UI |
    Panel。将新创建的面板重命名为PanelCategory。查看以下截图：
- en: '![](img/00124.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00124.jpeg)'
- en: Your inventory user interface should look something like the preceding screenshot.
    Before we get more involved, let's go ahead and hook up some of the basics for
    showing and hiding the inventory interface for the player. To do this, we will
    need to modify the `UiController.cs`*,* `GameLevelController.cs`, and also the
    `GameMaster.cs` scripts.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你的库存用户界面应该看起来像前面的截图。在我们进一步深入之前，让我们先为显示和隐藏玩家库存界面的一些基本操作建立连接。为此，我们需要修改`UiController.cs`、`GameLevelController.cs`和`GameMaster.cs`脚本。
- en: 'I will not be listing the whole source file as we will do this later on in
    the chapter. The changes for each script for now are as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会列出整个源文件，因为我们将在本章的后面部分进行。目前每个脚本的更改如下：
- en: '`UiController.cs`: Added a new function named `DisplayInventory()` and a new
    variable to reference the inventory canvas named `InventoryCanvas`. See the following
    code:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UiController.cs`: 添加了一个名为`DisplayInventory()`的新函数和一个名为`InventoryCanvas`的新变量，用于引用库存画布。请看以下代码：'
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`GameLevelController.cs`: Updated the `OnlevelWasLoaded()` function to assign
    the `uiController` GameObject to the `GameMaster` instance, if one is present.
    See the following code:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameLevelController.cs`: 更新了`OnlevelWasLoaded()`函数，将`uiController` GameObject分配给`GameMaster`实例（如果存在）。请看以下代码：'
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`GameMaster.cs`: Modified the `Update()` function to check and see if the J
    key was pressed and released. This in turn toggled a Boolean variable to see if
    we are supposed to show or hide the inventory interface. See the following code:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameMaster.cs`: 修改了`Update()`函数，以检查J键是否被按下和释放。这会切换一个布尔变量，以查看我们是否应该显示或隐藏库存界面。请看以下代码：'
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you test your scene from the main menu, you will be able to test out the
    interface and toggle it on and off.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从主菜单测试场景，你将能够测试界面并切换其开关。
- en: Don't forget that you will need to disable the Canvas for the inventory system
    during design time, or at runtime when the game loads initially.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，在设计时或在游戏最初加载时，你需要禁用库存系统的Canvas。
- en: Designing a dynamic item viewer
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计动态物品查看器
- en: The next challenge for us is to create a method to dynamically populate the
    inventory items and displaying them properly on the user interface. We are going
    to use two new UI elements that we have not used before. We will be using a s*croll
    view* to give us the ability to scroll through the items when needed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的挑战是创建一种方法，以动态填充库存物品并在用户界面上正确显示它们。我们将使用两个之前未曾使用过的新UI元素。我们将使用一个*滚动视图*来提供在需要时滚动浏览物品的能力。
- en: Let's first get the scroll view set up and look at how to add a simple UI prefab
    to the scroll view. Once this is done, we can go ahead and enhance the UI prefab
    to handle what we have outlined in the previous section.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先设置好滚动视图，并查看如何将一个简单的UI预制件添加到滚动视图中。一旦完成，我们就可以继续增强UI预制件，以处理上一节中概述的内容。
- en: Adding a scroll view
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加滚动视图
- en: 'The next few screenshots will illustrate how to add a scroll view functionality
    to your user interface:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几个截图将展示如何将滚动视图功能添加到你的用户界面中：
- en: '![](img/00125.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00125.jpeg)'
- en: Adding a scroll view
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 添加滚动视图
- en: 'Go to the scene where you have created your Inventory UI, and select the *PanelCategory*
    in the *Canvas*. Right-click and select *UI | Scroll View* to add a scroll view
    UI element. Take a look at the following screenshot:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 前往你创建库存UI的场景，然后在*Canvas*中选择*PanelCategory*。右键点击并选择*UI | 滚动视图*以添加一个滚动视图UI元素。查看以下截图：
- en: '![](img/00126.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00126.jpeg)'
- en: Adding Scroll View
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 添加滚动视图
- en: You should now have a scroll view UI element with associated children under
    your *PanelCategory* panel. The children will be *Viewport*, *Scrollbar Horizontal*,
    and *Scrollbar Vertical*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该在 *PanelCategory* 面板下拥有一个带有相关子元素的滚动视图 UI 元素。这些子元素将是 *Viewport*、*Scrollbar
    Horizontal* 和 *Scrollbar Vertical*。
- en: Make your adjustment to the scroll view UI element before you delete the children.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除子元素之前，调整滚动视图 UI 元素的设置。
- en: 'We are going to make some modifications to the default scroll view. Go ahead
    and delete the following from *Scroll View:* the *Scrollbar Horizontal*, *Scrollbar
    Vertical*, and the *Viewport* child elements. After you are done, your screen
    should look something like the preceding screenshot. Now take a look at the following
    screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对默认的滚动视图进行一些修改。请从 *Scroll View:* 中删除以下内容：*Scrollbar Horizontal*、*Scrollbar
    Vertical* 和 *Viewport* 子元素。完成后，你的屏幕应该看起来像上一张截图。现在请看以下截图：
- en: '![](img/00127.jpeg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00127.jpeg)'
- en: Layout adjustment
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 布局调整
- en: 'Next, we need to add a Panel element as a child to our Scroll View. Go ahead
    and select the scroll view, right-click, and select UI | Panel. Rename the newly
    added panel PanelItem. We need to add two layout components to our PanelItem.
    To do this, select PanelItem, and from the Inspector Window select Add Component
    | Layout | Vertical Layout Group, and once more select Add Component | Layout
    | Content Size Filter. Take a look at the following screenshot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将一个面板元素作为子元素添加到我们的 Scroll View 中。请选择滚动视图，右键单击，并选择 UI | Panel。将新添加的面板重命名为
    PanelItem。我们需要向 PanelItem 添加两个布局组件。为此，选择 PanelItem，从检查器窗口中选择添加组件 | 布局 | 垂直布局组，然后再次选择添加组件
    | 布局 | 内容大小过滤器。请看以下截图：
- en: '![](img/00128.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00128.jpeg)'
- en: Layout adjustment
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 布局调整
- en: Go ahead and modify the following attributes under the Vertical Layout Group
    components. Set the Left, Right, Top, and Bottom Padding to 3\. Set the Spacing
    to 0, change the Child Alignment to Upper Left, and set the Child Force Expand
    to True for both Width and Height.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在垂直布局组组件下进行以下属性的修改。将左、右、上、下内边距设置为 3，将间距设置为 0，将子元素对齐方式更改为左上角，并将子元素强制扩展设置为 True（宽度和高度）。
- en: For the Content Size Filter component, set the Horizontal Fit to Unconstrained
    and the Vertical Fit to Min Size.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内容大小过滤器组件，将水平适配设置为非约束，将垂直适配设置为最小大小。
- en: Finally, in the Rect Transform component, change the Anchor Point to Top Center,
    and modify the Pos Y to -10.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 Rect Transform 组件中，将锚点设置为顶部居中，并将 Pos Y 修改为 -10。
- en: At this point we have the basic framework in place. The next step it to populate
    our newly created ScrollView!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经建立了基本框架。下一步是填充我们新创建的 ScrollView！
- en: Adding elements to PanelItem and Scroll View
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向 PanelItem 和 Scroll View 添加元素
- en: For starters, let's go ahead and add a *Text* element under the `PanelItem`
    panel. Again select the `PanelItem` element and right-click and select UI | Text.
    Next select the text element and rename it to `txtItemElement`. We need to add
    a new component to the Text element, from the Inspector Window go ahead and select
    Add Component | Layout | Layout Element.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在 `PanelItem` 面板下添加一个 *Text* 元素。再次选择 `PanelItem` 元素，右键单击并选择 UI | Text。然后选择文本元素，将其重命名为
    `txtItemElement`。我们需要向文本元素添加一个新的组件，从检查器窗口中选择添加组件 | 布局 | 布局元素。
- en: 'Modify the Min Height attribute of the Layout Element component to 20\. Take
    a look at the following screenshot:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将布局元素组件的 Min Height 属性修改为 20。请看以下截图：
- en: '![](img/00129.jpeg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00129.jpeg)'
- en: Modification
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 修改
- en: 'The preceding screenshot illustrates the setup of the `InventoryItem` element
    and UI. Now take a look at the following screenshot:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图展示了 `InventoryItem` 元素和 UI 的设置。现在请看以下截图：
- en: '![](img/00130.jpeg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00130.jpeg)'
- en: Adding an inventory item
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 添加库存项目
- en: 'We need a means to access and modify the Text attribute of the new `Text` UI
    element. In order to do this, we need to create a new script called InventoryItemUI.cs.
    The code will just have a public variable that will reference the `Text` element.
    The listing is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个方法来访问和修改新 `Text` UI 元素的 Text 属性。为了做到这一点，我们需要创建一个新的脚本，名为 InventoryItemUI.cs。代码将只有一个公共变量，它将引用
    `Text` 元素。代码如下：
- en: '[PRE12]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Finally, drag and drop the `Text` element from the hierarchy window into the
    TextItemElement attribute of the InventoryItemUI component attached to the txtItemElement
    object. Refer to the preceding screenshot.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将层次窗口中的 `Text` 元素拖放到 txtItemElement 对象附加的 InventoryItemUI 组件的 TextItemElement
    属性中。参看上一张截图。
- en: The script is used to self-reference. We will use it to modify the text component
    of the `Text` UI element.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本用于自引用。我们将用它来修改`Text` UI元素的文本组件。
- en: Now we will need to create a Prefab of the txtItemElement by dragging and dropping
    it into a designated folder. I have created a new folder under my Prefabs folder
    named it *UI* and have created the prefab in that folder. Refer to the preceding
    screenshot.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要通过拖放它到指定的文件夹来创建txtItemElement的Prefab。我在我的Prefab文件夹下创建了一个名为*UI*的新文件夹，并在该文件夹中创建了Prefab。参考前面的截图。
- en: You can now delete the txtItemElement from the Hierarchy Window under the PanelItem
    object. We will be adding them dynamically during runtime.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以从层次结构窗口下的PanelItem对象中删除txtItemElement。我们将在运行时动态添加它们。
- en: There is one last configuration you will need to do before we move forward.
    You will need to add a `Mask` component to the `ScrollView` UI element. Select
    the Scroll View from the Hierarchy Window, and from the Inspector Window select
    Add Component | UI | Mask. After the addition of the Mask component, make sure
    that the Show Mask Graphics attribute is *unchecked*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，你还需要进行一项最后的配置。你需要在`ScrollView` UI元素上添加一个`Mask`组件。从层次结构窗口中选择滚动视图，从检查器窗口中选择添加组件
    | UI | 遮罩。在添加遮罩组件后，确保Show Mask Graphics属性是*未选中*的。
- en: Adding txtItemElement dynamically
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态添加txtItemElement
- en: 'Now it is time to add our inventory item placeholder dynamically to the `PanelItem`
    UI element. To do so, we will use the `UiController.cs` script. Go ahead and open
    up the script and add the following variable to the class:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们的库存项目占位符动态添加到`PanelItem` UI元素中。为此，我们将使用`UiController.cs`脚本。打开脚本并添加以下变量到类中：
- en: '[PRE13]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the designer, you will need to assign the `PanelItem` UI element from the
    *Canvas* GameObject and the `txtItemElement` prefab from the prefab folder.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计器中，你需要从*Canvas*游戏对象分配`PanelItem` UI元素，以及从预制件文件夹中的`txtItemElement`预制件。
- en: Next, we are going to modify the `Update()` function so that when we press the
    H key on the keyboard, it will go ahead and instantiate a new `InventoryItemElement`
    and make it a child element of the `PanelItem` object.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将修改`Update()`函数，以便当我们按下键盘上的H键时，它会创建一个新的`InventoryItemElement`实例，并将其作为`PanelItem`对象的子元素。
- en: 'The listing of the code is as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 代码列表如下：
- en: '[PRE14]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code listing simply instantiates the prefab and makes it a child
    of the `PanelItem` element. We are also changing the caption of the element and
    placing it with a timestamp to see the uniqueness of each UI element.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码列表仅实例化了预制件并将其作为`PanelItem`元素的子元素。我们还在元素上更改了标题，并放置了一个时间戳以查看每个UI元素的唯一性。
- en: 'The outcome is shown in the following screenshot:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如以下截图所示：
- en: '![](img/00131.jpeg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00131.jpeg)'
- en: Inventory view
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 库存视图
- en: At this point, we have put together the main elements to have our inventory
    interface list items dynamically and be able to scroll through them.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经组装了主要元素，以便我们的库存界面可以动态列出项目，并且能够滚动浏览它们。
- en: Building the final inventory item UI
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建最终的库存项目UI
- en: To create the actual Inventory Item user interface, we are going to need to
    use several UI elements. We will need a panel to be the container of the item.
    Within the *Panel*, we are going to need to use an *Image*, a *Text*, and two
    *Button* UI elements.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建实际的库存项目用户界面，我们需要使用几个UI元素。我们需要一个面板作为项目的容器。在*Panel*中，我们需要使用一个*Image*、一个*Text*和两个*Button*
    UI元素。
- en: 'Note: I will not be going through the steps of how to put the panel together.
    You should know how to create user interfaces by now.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我将不会讲解如何组装面板的步骤。你现在应该知道如何创建用户界面。
- en: Just make sure that you add the *Layout Element* component and *Inventory Item
    UI* script to the panel that will be the base for the inventory item.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你将*Layout Element*组件和*Inventory Item UI*脚本添加到将成为库存项目基础的面板中。
- en: '![](img/00132.jpeg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00132.jpeg)'
- en: Panel containing inventory item UI elements
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 包含库存项目UI元素的面板
- en: The following figure illustrates the UI component that has been developed for
    displaying the inventory item. Since the UI component has been modified, we also
    have to update the `InventoryItemUI.cs` script to contain a reference to all of
    the new UI elements in the *Panel*.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了为显示库存项目而开发的UI组件。由于UI组件已修改，我们还需要更新`InventoryItemUI.cs`脚本，以包含对*Panel*中所有新UI元素的引用。
- en: 'The listing of the new `InventoryItemUi.cs` is as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`InventoryItemUi.cs`的列表如下：
- en: '[PRE15]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We also need to update the `UiController.cs` script to handle the new prefab
    accordingly.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新`UiController.cs`脚本以相应地处理新的预制件。
- en: 'The listing for the new UI prefab in `UiController.cs` is as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 新UI预制件在`UiController.cs`中的列表如下：
- en: '[PRE16]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding listing , the main concept I want to point out is the implementation
    of the `onClick()` event handler for the buttons within the prefab.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，我想指出的主要概念是预制件中按钮的`onClick()`事件处理器的实现。
- en: Since we are dynamically generating our UI, and hence the buttons, we need to
    be able to trigger the `onClick()` function somehow; this is done by adding a
    listener, as shown in the code.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在动态生成我们的UI，因此按钮，我们需要能够以某种方式触发`onClick()`函数；这通过添加监听器来完成，如代码所示。
- en: For now, when you click the AddButton button, you will get an output on the
    Console Window with the appropriate caption. When you click the DeleteButton button,
    you will get another output on the Console Window, with the appropriate caption.
    Then the item will be destroyed, that is, removed from the inventory.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，当你点击AddButton按钮时，你将在控制窗口中看到带有适当标题的输出。当你点击DeleteButton按钮时，你将在控制窗口中看到另一个输出，带有适当的标题。然后，物品将被销毁，即从库存中移除。
- en: Integrating the UI with the actual inventory system
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将UI与实际库存系统集成
- en: We have seen and implemented the concepts necessary to make our inventory system
    UI work properly. Now it is time to actually fill the user interface with the
    actual data that is stored in `GameMaster`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到并实现了使我们的库存系统UI正常工作的必要概念。现在，是时候用存储在`GameMaster`中的实际数据填充用户界面了。
- en: Hooking the category buttons and displaying the data
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将类别按钮挂钩并显示数据
- en: 'Using the `UiController.cs` script, we are going to create five new methods
    that will handle the proper visualization of our inventory system. We are going
    to add the following five functions:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`UiController.cs`脚本，我们将创建五个新方法来处理我们库存系统的适当可视化。我们将添加以下五个函数：
- en: '`DisplayWeaponsCategory()`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DisplayWeaponsCategory()`'
- en: '`DisplayArmourCategory()`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DisplayArmourCategory()`'
- en: '`DisplayClothingCategory()`'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DisplayClothingCategory()`'
- en: '`DisplayHealthCategory()`'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DisplayHealthCategory()`'
- en: '`DisplayPotionsCategory()`'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DisplayPotionsCategory()`'
- en: We also need to clear the existing inventory items from the panel when the user
    switches from one category to the next. This will require a private function named
    `ClearInventoryItemPanel()`, which will just do that.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户从一个类别切换到下一个类别时，我们还需要从面板中清除现有的库存物品。这需要名为`ClearInventoryItemPanel()`的私有函数，它只会做这件事。
- en: 'The listing for the new `UiController.cs` script is as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`UiController.cs`脚本的列表如下：
- en: '[PRE18]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We also had to some modifications to the `InventorySystem.cs` script to make
    it possible for us to access properties storing the data more easily.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须对`InventorySystem.cs`脚本进行一些修改，以便我们更容易访问存储数据的属性。
- en: 'The new listing of the script is as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的新列表如下：
- en: '[PRE19]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that I have removed the code from the `Update()` function in the `UiController.cs`
    script as it was only for testing purposes.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我已经从`UiController.cs`脚本中的`Update()`函数中删除了代码，因为它是仅用于测试目的的。
- en: Testing the inventory system
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试库存系统
- en: 'For testing purposes, I have placed a number of the inventory item prefabs
    created earlier in this chapter. Take a look at the following screenshot:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，我在本章中创建的一些库存物品预制件中放置了一些。看看下面的截图：
- en: '![](img/00133.jpeg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00133.jpeg)'
- en: Inventory items to be collected
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要收集的库存物品
- en: 'Start the game from the main menu and go through the character customization
    scene to save the character player and start the game. Once you are in the playable
    scene, go ahead and collect a few of the items that have been placed throughout
    the scene. Take a look at the following screenshot:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 从主菜单开始游戏，并通过角色定制场景保存角色玩家并开始游戏。一旦你进入可玩场景，就继续收集场景中放置的一些物品。看看下面的截图：
- en: '![](img/00134.jpeg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00134.jpeg)'
- en: Item inserted into inventory - 1
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 存入库存的物品 - 1
- en: 'Notice in the following screenshot that I have selected the `_GameMaster` GameObject
    to display the Inventory data in the Inspector Window:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下截图，我已经选择了`_GameMaster`游戏对象，在检查器窗口中显示库存数据：
- en: '![](img/00135.jpeg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00135.jpeg)'
- en: Item inserted into inventory - 2
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 存入库存的物品 - 2
- en: 'We have picked up two weapon types and two armor types. The weapons items we
    have picked up are: Axe 2\. The armor items we have picked up are: Leg Plate,
    SP1, Knee Pad, and SP3, as indicated in the Inspector Window. Take a look at the
    following screenshot:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经选择了两种武器类型和两种盔甲类型。我们选择的武器物品是：斧头2。我们选择的盔甲物品包括：腿甲、SP1、护膝和SP3，如检查器窗口中所示。请看下面的截图：
- en: '![](img/00136.jpeg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00136.jpeg)'
- en: Item inserted into inventory - 3
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 插入到库存中的物品 - 3
- en: 'Notice that in the Game Window, when we bring up the Inventory Window for display
    and click the weapons button, we get two listings. The listings display the proper
    data for each inventory item in the category. Take a look at the following screenshot:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在游戏窗口中，当我们打开用于显示的库存窗口并点击武器按钮时，我们会得到两个列表。这些列表显示了每个库存物品在类别中的正确数据。请看下面的截图：
- en: '![](img/00137.jpeg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00137.jpeg)'
- en: Armour category
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 盔甲类别
- en: 'To illustrate the `onClick()` event for the add button, please see the following
    screenshot from the Console Window:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要说明添加按钮的`onClick()`事件，请参阅以下来自控制台窗口的截图：
- en: '![](img/00138.jpeg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00138.jpeg)'
- en: Inventory item properties
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 库存物品属性
- en: 'To list the armor items in the inventory, we will click the armour button.
    The following screenshot displays the items in the armour category in the inventory
    based on our data:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要在库存中列出盔甲物品，我们将点击盔甲按钮。以下截图显示了基于我们的数据的库存中盔甲类别的物品：
- en: '![](img/00139.jpeg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00139.jpeg)'
- en: We have come a long way. Let's take a moment to put things in perspective.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经走了很长的路。让我们花点时间来审视一下。
- en: 'We first created the following scripts to lay the foundation for our inventory
    system in the game:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了以下脚本，为我们在游戏中的库存系统奠定基础：
- en: '`BaseItem.cs`'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseItem.cs`'
- en: '`InventoryItem.cs`'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventoryItem.cs`'
- en: '`InventoryItemAgent.cs`'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventoryItemAgent.cs`'
- en: '`InventorySystem.cs`'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventorySystem.cs`'
- en: The next step was to create the prefabs for each inventory item and add them
    to the `InventoryItemAgent.cs` script. This in turn allowed us to assign the necessary
    data to identify the prefab as an inventory item during game play.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建每个库存物品的预制件并将它们添加到`InventoryItemAgent.cs`脚本中。这反过来又允许我们在游戏过程中将必要的数据分配给预制件，以将其识别为库存物品。
- en: Next, we started work on the design and development of the user interface for
    the inventory system. We created a sketch of how we would like the inventory window
    to look  and implemented the framework using the build in UI architecture.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始设计和开发库存系统的用户界面。我们绘制了我们希望库存窗口看起来如何的草图，并使用内置的UI架构实现了框架。
- en: Slowly adding to the UI and applying different concepts and new elements, we
    built the final user interface for the inventory system.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步添加到UI并应用不同的概念和新元素，我们构建了库存系统的最终用户界面。
- en: Finally, we used the prefabs to test the complete addition and removal of the
    inventory items from the user interface.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用预制件来测试从用户界面中完全添加和删除库存物品。
- en: The next challenge we face is how to actually apply the inventory items to the
    player character.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们面临的下一个挑战是如何实际将库存物品应用到玩家角色上。
- en: Inventory items and the player character
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库存物品和玩家角色
- en: Now that we have seen how to create the inventory system, we need to be able
    to utilize it during game play to apply changes to our player character. In this
    section, we will examine how to do just that!
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何创建库存系统，我们需要能够在游戏过程中使用它来对我们的玩家角色应用更改。在本节中，我们将探讨如何做到这一点！
- en: 'Here are some of the new features we need to work on:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们需要工作的新功能之一：
- en: Applying a selected inventory item to the player character
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将选定的库存物品应用到玩家角色上
- en: Performing accounting on both the player character and the inventory system
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对玩家角色和库存系统进行会计处理
- en: Updating the game state accordingly
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据情况更新游戏状态
- en: Applying inventory items
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用库存物品
- en: We need to make some design decisions on how we are going to handle applying
    the inventory items to the player character, and in turn how the system will handle
    the event. For instance, let's assume the player character has acquired several
    weapons; let's say Weapons A, B, and C.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在如何处理将库存物品应用到玩家角色上以及系统如何处理该事件方面做出一些设计决策。例如，让我们假设玩家角色已经获得了几件武器；比如说武器A、B和C。
- en: Let's also assume that initially, the player does not have any active weapons.
    Now, the player selects to activate Weapon A. For this scenario, we would just
    use the inventory item data and activate Weapon A for the player, taking into
    consideration all of the accounting that comes with the weapon.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再假设，最初，玩家没有任何激活的武器。现在，玩家选择激活武器A。对于这种情况，我们只需使用库存物品数据并激活武器A，同时考虑到武器带来的所有会计问题。
- en: Now, the player wants to change his/her weapon to Weapon B because it is more
    powerful and they will need it to defeat the boss. Since the player already has
    Weapon A active, what are we going to do with it before we activate Weapon B?
    Do we put it back into the game world, or do we put it back into our inventory
    for later use?
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，玩家想要将他的/她的武器换成武器B，因为它更强大，他们需要它来击败Boss。由于玩家已经激活了武器A，在我们激活武器B之前，我们该如何处理它？我们是将其放回游戏世界，还是将其放回我们的库存中以便以后使用？
- en: In our case, once you have an item in the inventory, it will stay with you until
    you actually delete it from the inventory, in which case it will be destroyed.
    We need to make a few code modifications, and also some prefab modifications,
    to have everything working together.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，一旦你在库存中有物品，它将一直陪伴你，直到你实际上从库存中删除它，在这种情况下，它将被销毁。我们需要进行一些代码修改，以及一些预制体修改，以确保一切协同工作。
- en: Let's start with the `InventoryItem.cs` script. We are going to add new data
    to store the type of the inventory item. This is necessary because we have a category,
    and within the category we have different types of items. This is especially true
    for the Armour category! For instance, we have a Helmet, a Shield, a Shoulder
    Pad, and so on.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`InventoryItem.cs`脚本开始。我们将添加新的数据来存储库存物品的类型。这是必要的，因为我们有一个类别，在类别中我们有不同类型的物品。这对盔甲类别尤其如此！例如，我们有头盔、盾牌、肩垫等等。
- en: 'The code listing is as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 代码列表如下：
- en: '[PRE20]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When you make the update to your script, make sure to go back into the IDE
    and select the proper type for each prefab we have created, to represent your
    inventory items. Take a look at the following screenshot:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当你更新你的脚本时，确保回到IDE并选择我们创建的每个预制体的正确类型，以表示你的库存物品。看看下面的截图：
- en: '![](img/00140.jpeg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00140.jpeg)'
- en: Inventory item type field
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 库存物品类型字段
- en: You will need to update the Type field for each prefab you have created for
    your inventory items.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要更新你为库存物品创建的每个预制体的类型字段。
- en: We also need to update the `PlayerCharacter.cs` script. We are going to make
    the original data variables private and create public properties to access them.
    This way, if we need to perform any extra work prior to, or after, setting or
    getting the property value, we can do so easily.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新`PlayerCharacter.cs`脚本。我们将使原始数据变量为私有，并创建公共属性来访问它们。这样，如果我们需要在设置或获取属性值之前或之后执行任何额外的工作，我们可以轻松地做到这一点。
- en: 'The listing for the `PlayerCharacter.cs` script is as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerCharacter.cs`脚本的列表如下：'
- en: '[PRE21]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The next code modification will be on the `BarbarianCharacterCustomization.cs`
    script. Since this script has been used in the character customization scene,
    we can utilize the same script and expand it to apply the visual changes to our
    player character. But before we can utilize this script, we will need to copy
    the actual component from the `Base` GameObject defined in our character customization
    scene, and paste it into the `PC_C6` GameObject representing our player character!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码修改将是在`BarbarianCharacterCustomization.cs`脚本上。由于这个脚本已经在角色定制场景中使用过，我们可以利用这个脚本并将其扩展以应用于我们的玩家角色。但在我们能够利用这个脚本之前，我们需要从我们在角色定制场景中定义的`Base`GameObject中复制实际的组件，并将其粘贴到代表我们的玩家角色的`PC_C6`GameObject中！
- en: When you copy a component using the gear menu in the *Inspector Window*, all
    the configurations, links, and references stay intact! When you paste the component,
    again using the gear menu in the *Inspector Window*, you will have an exact copy
    of the component. This will eliminate the need for us to rewire all of the GameObjects
    to their references in the script.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用“检查器窗口”中的齿轮菜单复制组件时，所有配置、链接和引用都保持完整！再次使用“检查器窗口”中的齿轮菜单粘贴组件时，你将得到组件的精确副本。这将消除我们重新布线所有GameObject到脚本中引用的需要。
- en: 'The following two screenshots illustrate the copy of the component from the
    `_Base` GameObject to the `PC_C6` GameObject:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个截图说明了从`_Base`GameObject到`PC_C6`GameObject的组件复制过程：
- en: '![](img/00141.jpeg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00141.jpeg)'
- en: Using the gear icon to copy and paste a component
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用齿轮图标复制和粘贴组件
- en: 'The `_Base` GameObject has the customization script attached to it, as illustrated
    in the preceding screenshot, copying the values from the `_Base` GameObject to
    transfer over to PC-C6 object. Take a look at the following screenshot:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述截图所示，`_Base`游戏对象上附加了定制脚本，将值从`_Base`游戏对象复制并传输到PC-C6对象。看看下面的截图：
- en: '![](img/00142.jpeg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00142.jpeg)'
- en: Using the gear icon to copy and paste a component
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用齿轮图标复制和粘贴组件
- en: This works because the script is actually referencing the different parts of
    the `PC_C6` GameObject hierarchy in the first place. The difference was that it
    used to be attached to the `_Base` GameObject for the customization.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为脚本实际上首先引用了`PC_C6`游戏对象层次结构的不同部分。区别在于它以前是附加到用于定制的`_Base`游戏对象上的。
- en: 'Note: Can they both be active at the same time, in the same scene, at this
    point? Yes! However, if you have the time, you might want to redo your UI event
    triggers to use the `PC_CC` GameObject, and then you can remove the `BarbarianCharacterCustomization.cs`
    script from the `_Base` GameObject.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：它们现在可以在同一场景中同时激活吗？是的！然而，如果你有时间，你可能想重新设计你的UI事件触发器以使用`PC_CC`游戏对象，然后你可以从`_Base`游戏对象中移除`BarbarianCharacterCustomization.cs`脚本。
- en: Now we actually need to modify the `BarbarianCharacterCustomization.cs` script
    to activate the different parts of the player character model using the data it
    will receive from the `GameMaster.cs` script.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们实际上需要修改`BarbarianCharacterCustomization.cs`脚本，以便使用从`GameMaster.cs`脚本接收到的数据激活玩家角色模型的不同部分。
- en: 'A partial listing of the `CharacterCustomization.cs` script is as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`CharacterCustomization.cs`脚本的局部列表如下：'
- en: '[PRE22]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: I have not listed the whole script as it would take many pages. But the basic
    concept is to overload the `SetXXXXX()` functions so that they will perform the
    necessary tasks based on the parameters coming in, as for the preceding example, `PlayerCharacter.WeaponType`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有列出整个脚本，因为这会占用很多页面。但基本概念是重载`SetXXXXX()`函数，以便它们根据传入的参数执行必要的任务，就像前面的例子`PlayerCharacter.WeaponType`一样。
- en: 'The next script that needs to be modified is the `UiController.cs` script.
    This is where we will modify the five functions we created previously, to actually
    apply the changes to the player character. Let''s look at one of the functions
    that have been modified, without listing the whole code, as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个需要修改的脚本是`UiController.cs`脚本。这是我们之前创建的五个函数将实际应用于玩家角色的地方。让我们看看已经被修改的一个函数，不列出整个代码，如下所示：
- en: '[PRE23]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice that we are also saving the *item* from the `foreach` loop into the `invItem.item`
    variable. This is important, to make sure the `OnClick()` listener is picking
    up the current `InventoryItem` variable from the list.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还将从`foreach`循环中保存的`*item*`放入`invItem.item`变量中。这很重要，以确保`OnClick()`监听器能够从列表中获取当前的`InventoryItem`变量。
- en: The bulk of the work is done in `onClick.AddListener()` for each button. We
    basically set the selected weapon using `GameMaster.instance` to store, and then
    we are calling the `PlayerWeaponChanged()` function to handle some more features.
    This will be demonstrated in the next code listing.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分工作是在每个按钮的`onClick.AddListener()`中完成的。我们基本上使用`GameMaster.instance`设置选定的武器以存储，然后调用`PlayerWeaponChanged()`函数来处理更多功能。这将在下一个代码列表中演示。
- en: You will need to handle each add button listener in a similar fashion, based
    on how you have designed and implemented your code and your prefabs.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要以类似的方式处理每个添加按钮监听器，这取决于你如何设计和实现你的代码以及你的预制件。
- en: 'Finally, we are going to make some modifications to the `GameMaster.cs` script.
    The listing is as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将对`GameMaster.cs`脚本进行一些修改。列表如下：
- en: '[PRE24]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The only function I want you to take a note of is the `PlayerArmourChanged()` function.
    It is because of this function that we have to add the new *Type* data variable
    and datatype to the `InventoryItem` class. Take a look at the following code:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我要你注意的唯一函数是`PlayerArmourChanged()`函数。正是因为这个函数，我们才需要在`InventoryItem`类中添加新的`*Type*`数据变量和数据类型。看看下面的代码：
- en: '[PRE25]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We have a lot of different types of armor, and we needed a way to distinguish
    between them. Based on the armor type, we would then call the appropriate function
    to activate them on the player character.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多不同类型的盔甲，我们需要一种方法来区分它们。根据盔甲类型，然后调用适当的函数在玩家角色上激活它们。
- en: How it looks
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 看起来是这样的
- en: This chapter was a bit involved with regard to configuring your GameObjects
    and prefabs, and, more importantly, the code that went along to glue everything
    together. I have tried to keep things as simple as possible. Having said that,
    there are a few items that we have not discussed and incorporated in the chapter—the
    topics relating to leveling up, XP, and Quests. If you truly study and understand
    the Inventory System, you can very easily drive and expand it to cover all other
    parts. Unfortunately, we won't be able to implement everything in one book.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 本章在配置GameObject和预制件方面有些复杂，更重要的是，与之相关的代码，用于将所有这些粘合在一起。我已经尽量使事情尽可能简单。话虽如此，我们本章没有讨论和包含一些项目——与升级、经验和任务相关的话题。如果您真正学习和理解了库存系统，您可以非常容易地驱动和扩展它以涵盖所有其他部分。不幸的是，我们无法在一本书中实现所有内容。
- en: 'Following is a screenshot illustrating the player character prior to picking
    up the inventory items placed on the level. Notice that `INVENOTRY` is empty in
    the `GameMaster` object. Also, there are no selected items in the `PC-C6` object:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个截图，展示了在玩家拾取放置在关卡上的物品之前的玩家角色。注意，在`GameMaster`对象中`INVENOTRY`是空的。同样，在`PC-C6`对象中也没有选中的物品：
- en: '![](img/00143.jpeg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00143.jpeg)'
- en: Player character data
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家角色数据
- en: 'After I move the player character to pick up the inventory items, I will use
    the hot-key programmed to bring up the inventory window. In my case, the J key.
    The following screenshot captures the interaction:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在我将玩家角色移动到拾取库存物品之后，我将使用编程的热键来打开库存窗口。在我的情况下，是J键。以下截图捕捉了交互：
- en: '![](img/00144.jpeg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00144.jpeg)'
- en: Player Character Data Inventory
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家角色数据库存
- en: Now, let's look at how things change when we apply a few of the inventory items
    to the player character. You can see the changes applied in the preceding screenshot,
    in the inventory collection.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看当我们将一些库存物品应用到玩家角色上时，事情会有怎样的变化。您可以在前面的截图中的库存集合中看到所应用的变化。
- en: Summary
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: There is a lot covered in this chapter. The core of the chapter was to create
    a usable inventory system. We began the chapter by discussing weighted inventories,
    and gave a brief overview of the concept. We then determined the item types we
    are going to be using for our game.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了大量的内容。本章的核心是创建一个可用的库存系统。我们本章开始时讨论了加权库存，并简要概述了该概念。然后我们确定了我们将为游戏使用的项目类型。
- en: We created the scripts `BaseItem.cs`, `InventoryItem.cs`, and `InventorySystem.cs`.
    These scripts were then utilized as a starting point to design and develop our
    inventory. We then updated the `GameMaster.cs` script, to test the basics of the
    newly created scripts and be able to view the data within the Unity IDE by serializing
    the attributes. We did this by instantiating an `InventoryItem` and inserting
    it into the `InventorySystem`, and validated the operation visually through the
    IDE.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了`BaseItem.cs`、`InventoryItem.cs`和`InventorySystem.cs`脚本。然后，我们将这些脚本用作设计和发展我们库存的起点。接着，我们更新了`GameMaster.cs`脚本，以测试新创建的脚本的基本功能，并通过序列化属性在Unity
    IDE中查看数据。我们通过实例化一个`InventoryItem`并将其插入到`InventorySystem`中来实现这一点，并通过IDE直观地验证了操作。
- en: The next step was to actually create the inventory item prefabs. This section
    covered how to navigate and find your customizable inventory items if your model
    included everything on the actual fbx model, how to extract it from the model,
    and how to convert it into a prefab for later use. Then we created a new script,
    called `InventoryItemAgent.cs`, which was attached to every prefab created to
    represent an inventory item. This script basically gives us the ability to set
    the data for each inventory item from within the IDE. Very useful! We also had
    to attach a collider to each prefab, to handle collision and trigger a pick-up
    call when the player collides with the object.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实际创建库存物品预制件。本节介绍了如果您的模型包括了实际的fbx模型上的所有内容，如何导航和找到可定制的库存物品，如何从模型中提取它，以及如何将其转换为预制件以供以后使用。然后我们创建了一个新的脚本，称为`InventoryItemAgent.cs`，它被附加到每个创建的预制件上，以表示库存物品。这个脚本基本上让我们能够在IDE中设置每个库存物品的数据。非常有用！我们还必须将一个碰撞器附加到每个预制件上，以处理碰撞并在玩家与对象碰撞时触发拾取调用。
- en: Once we had the basics in place, we started looking at how to design and implement
    the user interface for our inventory system. We discussed the categories that
    we want to represent, as well as how the items within each category will be listed/displayed
    for the player during game play. We implemented the initial framework for the
    inventory window and integrated it with the game.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们建立了基础，我们就开始考虑如何设计和实现库存系统的用户界面。我们讨论了想要表示的分类，以及每个分类中的项目在游戏过程中如何列出/显示给玩家。我们实现了库存窗口的初始框架，并将其与游戏集成。
- en: Now we are ready to discuss how to create a dynamic item viewer that can be
    populated during runtime and represent the inventory items we have collected correctly.
    We introduced some new user interface concepts, such as scroll view and how to
    utilize layouts in our interface. We did a quick test with a simple placeholder
    to just display the name of the item. Once we got the mechanics working, we implemented
    the main inventory item control panel and converted it into a prefab, to be instantiated
    at runtime when needed.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备讨论如何创建一个动态的项目查看器，它可以在运行时填充，并正确表示我们收集的库存项目。我们介绍了一些新的用户界面概念，例如滚动视图以及如何在我们的界面中利用布局。我们用一个简单的占位符进行了快速测试，仅显示项目的名称。一旦我们使机制正常工作，我们就实现了主要的库存项目控制面板，并将其转换为预制件，以便在需要时在运行时实例化。
- en: Finally, we worked on the integration of the inventory system with the inventory
    UI, with the GameMaster and player character, to have the final implementation.
    This required that we update and modify more scripts.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们着手将库存系统与库存用户界面以及游戏大师和玩家角色集成，以实现最终的实现。这需要我们更新和修改更多的脚本。
- en: By the end of the chapter, you have a fully functional inventory system that
    can be expanded as needed.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将拥有一个功能齐全的库存系统，可以根据需要扩展。
