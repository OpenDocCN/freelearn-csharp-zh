- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optimizing the Game Using Unity’s Profiler, Frame Debugger, and Memory Profiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to [*Chapter 9*](B22017_09_split_000.xhtml#_idTextAnchor139) of your
    Unity game development journey, where we will explore optimizing game performance
    using Unity’s Profiler, Frame Debugger, and Memory Profiler. In this chapter,
    we will learn how to identify and address performance bottlenecks, optimize rendering,
    and manage memory efficiently. We’ll cover Unity’s profiling tools, dive into
    performance optimization techniques such as physics, audio, AI, and scripting
    optimizations, and delve into memory management and optimization, including Memory
    Profiler usage and asset importing optimizations. Mastering these skills will
    ensure smooth gameplay and an immersive player experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Unity profiling tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance optimization techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management and optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need to install the following to follow along with me in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Primary IDE – Visual Studio 2022**: The tutorials and code samples have been
    crafted using Visual Studio 2022\. Ensure it’s installed so that you can follow
    along seamlessly. Feel free to explore Rider or other IDEs if you prefer, though
    the instructions are tailored for Visual Studio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unity version 2022.3.13**: Download and install Unity, choosing version 2022.3.13
    for optimal compatibility with the provided content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found at: [https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2009](https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2009).'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Unity profiling tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to Unity’s profiling tools! These tools are essential for understanding
    and improving the performance of our games. They provide valuable insights into
    how our games are running and help us optimize them for a smoother experience
    across different devices and platforms.
  prefs: []
  type: TYPE_NORMAL
- en: So, why do we need to utilize profiling tools? Profiling tools are invaluable
    assets in the quest for optimization, which is the process of fine-tuning our
    games to run as efficiently as possible. These tools act as our detective companions
    in the world of game development, helping us investigate and identify areas where
    our game might be slowing down or using too much memory. By using these tools,
    we can make targeted improvements to our game’s performance, ensuring that players
    have a seamless and enjoyable gaming experience.
  prefs: []
  type: TYPE_NORMAL
- en: So, what does optimization mean in game development? Optimization is the process
    of making our games run as efficiently as possible, involving finding ways to
    reduce unnecessary computations, minimize memory usage, and improve rendering
    performance. Just like a well-organized city ensures smooth traffic flow and efficient
    resource management, optimization ensures that our game’s code and graphics work
    together harmoniously to deliver a captivating experience to players. This optimization
    is crucial because it directly impacts the player’s experience. No one wants to
    play a game that lags, stutters, or crashes unexpectedly. By optimizing our games,
    we can ensure that they run smoothly on a variety of hardware configurations,
    providing players with a consistent and enjoyable gaming experience across different
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Unity’s profiling tools in depth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unity’s profiling tools offer a comprehensive suite of features to help us understand
    and improve our game’s performance. The Profiler allows us to analyze CPU and
    GPU usage in real time, giving us valuable insights into where optimizations are
    needed. The Frame Debugger, on the other hand, helps us visualize how our game’s
    graphics are rendered.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, we’ll take a closer look at each of these profiling
    tools and learn how to use them effectively to optimize our games. So, let’s get
    ready to dive into the world of Unity profiling!
  prefs: []
  type: TYPE_NORMAL
- en: The Profiler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Profiler in Unity is like a helpful detective for your game. It checks how
    the game is doing – for example, how much the computer is thinking (CPU), how
    the graphics are doing (GPU), and how much memory is used. It’s like a tool to
    catch issues and make your game work better.
  prefs: []
  type: TYPE_NORMAL
- en: 'To open the Profiler, go to **Window** | **Analysis** | **Profiler**. A new
    window will appear, as shown in *Figure 9**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – The Profiler](img/B22017_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – The Profiler
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve opened the Profiler, let’s dive into how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the functionality of Unity’s Profiler
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Profiler in Unity works by continuously monitoring different aspects of
    your game’s performance while it’s running. It collects data on CPU usage, GPU
    usage, memory allocation, rendering performance, and more, allowing us to gain
    insights into how our game is utilizing system resources.
  prefs: []
  type: TYPE_NORMAL
- en: When you open the Profiler in Unity, it displays a variety of graphs and charts
    that visualize this data in real time. These graphs show metrics such as CPU usage
    over time, memory usage by different components of the game, and the time it takes
    to render each frame.
  prefs: []
  type: TYPE_NORMAL
- en: The Profiler gathers this data by instrumenting your game code with profiling
    markers. These markers track the time it takes for specific functions and operations
    to execute, allowing us to identify performance bottlenecks and areas for optimization.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the Profiler shows a spike in CPU usage during gameplay, we
    can use the Profiler’s **Call Stacks** view to pinpoint which functions are consuming
    the most CPU time. It can then analyze the code within those functions to identify
    inefficiencies or areas for optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if the Profiler detects excessive memory usage, we can use the memory
    allocation view to identify where memory is being allocated and deallocated in
    the code. This can help identify memory leaks or inefficient memory usage patterns
    that may be impacting performance.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the Profiler in Unity provides us with valuable insights into our game’s
    performance, allowing us to identify and address issues that could impact the
    player experience. By using the Profiler effectively, we can optimize our games
    to run smoothly and efficiently on a variety of platforms and devices.
  prefs: []
  type: TYPE_NORMAL
- en: In Unity, optimizing the performance of your game is crucial for delivering
    a smooth and immersive player experience. The Unity Profiler is a powerful tool
    that offers insights into various aspects of your game’s performance through its
    diverse modules, each focusing on different areas of analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main modules of the Unity Profiler are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CPU Profiler**: This module monitors the CPU usage of your game during runtime.
    It helps identify performance bottlenecks related to scripting, physics calculations,
    rendering, and other CPU-intensive tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GPU Profiler**: The GPU Profiler focuses on monitoring the GPU usage of your
    game. It provides information about rendering performance, including the time
    spent on drawing calls, shaders, and graphics-related computations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory Profiler**: This module tracks memory usage in your game, including
    allocations, deallocations, and memory leaks. It helps identify areas where memory
    is being used inefficiently or where resources are not managed properly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Audio Profiler**: The Audio Profiler monitors the performance of audio-related
    operations in your game, such as playing audio clips, mixing audio channels, and
    processing audio effects. It helps optimize audio performance and troubleshoot
    any issues related to audio playback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Physics Profiler**: This module focuses on analyzing the performance of physics
    calculations in your game. It provides insights into the time spent on physics
    simulations, collisions, rigid body dynamics, and other physics-related computations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UI Profiler**: The UI Profiler is specifically designed to analyze the performance
    of **user interface** (**UI**) elements in your game. It helps identify UI-related
    bottlenecks, such as layout calculations, rendering overhead, and event handling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network Profiler**: The Network Profiler monitors network activity in your
    game, including data transmission, latency, and network-related events. It helps
    optimize network performance and troubleshoot issues related to multiplayer networking
    or online gameplay.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rendering Profiler**: This module focuses on analyzing rendering performance
    in your game. It provides insights into rendering overhead, draw calls, batching,
    and other graphics-related optimizations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collectively, these modules provide a comprehensive view of your game’s performance,
    allowing you to identify and address performance issues effectively. By using
    the Unity Profiler’s various modules, we can optimize our games for better performance,
    smoother gameplay, and enhanced player experiences.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on the CPU Profiler and learn how to use it to
    identify performance related to the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: The CPU Profiler module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CPU Profiler module is an essential tool in Unity for analyzing the performance
    of your game. It provides a detailed breakdown of where your game spends its time
    during runtime, including areas such as rendering, scripting, and animation. This
    section delves into various aspects of the CPU Profiler module, covering chart
    categories, the module details pane, live settings, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Chart categories
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The **CPU Usage** Profiler module’s chart categorizes the time spent on the
    game’s main thread into nine categories. These categories are **Rendering**, **Scripts**,
    **Physics**, **Animation**, **GarbageCollector**, **VSync**, **Global Illumination**,
    **UI**, and **Others**. By understanding the distribution of time across these
    categories, we can pinpoint areas of improvement and optimize our game’s performance
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'By understanding each part and its role or impact, we can easily pinpoint the
    problem areas in scripts or animations. This allows us to focus our work on addressing
    these specific issues. You can refer to *Figure 9**.2* for the charts and their
    defined colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – CPU module](img/B22017_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – CPU module
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following table, I have listed each category, along with common activities
    that may occur within it, indicating the time spent or the impact on performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Category** | **Activities Performed in** **Real Time** |'
  prefs: []
  type: TYPE_TB
- en: '| Rendering | Processing data for the GPU and waiting for GPU operations. It
    includes tasks such as rendering meshes, handling shaders, managing textures,
    and other graphics-related computations. |'
  prefs: []
  type: TYPE_TB
- en: '| Scripts | `MonoBehaviour` update methods and coroutine executions. It involves
    executing script code, handling game logic, and managing interactions between
    game objects. |'
  prefs: []
  type: TYPE_TB
- en: '| Physics | Executing physics simulations and related processes. including
    collision detection, rigid body interactions, joint handling, and other physics-related
    calculations. |'
  prefs: []
  type: TYPE_TB
- en: '| Animation | Animation system processing and performance considerations, including
    processing keyframes, blend trees, animation state transitions, and other animation-related
    tasks. |'
  prefs: []
  type: TYPE_TB
- en: '| GarbageCollector | Garbage collection and memory allocation activities, which
    include memory allocation, deallocating unused memory, managing object life cycles,
    and optimizing memory usage. |'
  prefs: []
  type: TYPE_TB
- en: '| VSync | Waiting for vertical synchronization activities. This includes syncing
    the frame rate of the game with the refresh rate of the display, ensuring smooth
    and tear-free rendering. |'
  prefs: []
  type: TYPE_TB
- en: '| Global Illumination | Global illumination includes calculations related to
    lighting in scenes, such as lightmap baking, real-time GI computations, light
    probes, and reflection probes. |'
  prefs: []
  type: TYPE_TB
- en: '| UI | UI activities involve rendering and interactive elements, such as canvases,
    text elements, buttons, panels, and other UI components. |'
  prefs: []
  type: TYPE_TB
- en: '| Others | These are additional CPU activities that are not part of the other
    categories. This can include various engine tasks, editor-related activities,
    audio processing, networking tasks, and other miscellaneous computations that
    occur during runtime but don’t fit into the defined categories. |'
  prefs: []
  type: TYPE_TB
- en: Understanding the activities within each category allows us to target specific
    areas based on our optimization requirements for the project.
  prefs: []
  type: TYPE_NORMAL
- en: Module details pane
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You have the option to display the selected frame in three different views,
    allowing you to discern how to switch between them, as shown in *Figure 9**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Views dropdown](img/B22017_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Views dropdown
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand how these views work:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Timeline**: This view provides an overview of time distribution across different
    threads on a single time axis, aiding visualization of parallel execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hierarchy**: This view groups timing data by internal hierarchical structure,
    offering detailed insights into function calls and memory allocations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Raw Hierarchy**: This is similar to the **Hierarchy** view but provides additional
    details about performance warnings and thread groupings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we’re aware of the available views in the Profiler, we can switch between
    them to gain a better understanding of how the frame operates.
  prefs: []
  type: TYPE_NORMAL
- en: Using Live settings while profiling
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The “Live” setting in the Unity CPU Profiler provides a dynamic and immediate
    view of performance metrics as we interact with our game, enabling efficient on-the-fly
    analysis and optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s enable Live settings and see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: Enable the Live setting in the CPU Profiler module before you start recording.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we interact with our game and trigger different events, the Profiler immediately
    displays real-time information about the current frame in the details pane.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can see how each action affects CPU usage, memory allocation, and other performance
    metrics instantly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This real-time feedback allows us to identify performance bottlenecks quickly,
    make adjustments on the fly, and see the impact of optimizations immediately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also enable the **Show Full Scripting Method Names** option to display
    the full method names. This can be particularly useful when you’re dealing with
    complex scripts or when you need precise visibility into the functions being executed.
    You can enable this option through the settings, as shown in *Figure 9**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Show Full Scripting Method Names](img/B22017_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Show Full Scripting Method Names
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into the practical part, it’s essential to understand common Profiler
    markers.
  prefs: []
  type: TYPE_NORMAL
- en: Common markers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unity’s code is instrumented with various Profiler markers, offering insights
    into performance-critical tasks and areas of optimization. By leveraging these
    markers, we can identify bottlenecks and streamline performance-critical operations,
    enhancing the overall efficiency and responsiveness of our games.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity’s code is marked with numerous Profiler indicators that offer insights
    into the performance of your game. These markers are invaluable for identifying
    bottlenecks and optimizing your code. Let’s delve into the main categories of
    Profiler markers and their functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Main thread** **base markers**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main thread base markers serve to differentiate between time spent on your
    game and time devoted to Editor and Profiler tasks. These markers are crucial
    for understanding the timing of frames on the main thread. Here are some examples:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**PlayerLoop**: Contains samples originating from your game’s main loop. When
    targeting the Editor while the Player is active, **PlayerLoop** samples the nest
    under **EditorLoop**.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EditorLoop** (Editor-only marker): Contains samples from the Editor’s main
    loop when profiling a player in the Editor. **EditorLoop** samples indicate time
    spent rendering and running the Editor alongside the Player.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Profiler.CollectEditorStats** (Editor-only marker): Includes samples related
    to collecting statistics for active Profiler modules. These samples provide insight
    into the overhead that’s incurred by the Player when collecting module statistics.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Editor-only markers**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Certain markers exclusively appear when profiling in Unity Editor, offering
    insights into Editor-specific activities such as security checks and Prefab-related
    tasks. Here is an example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**GetComponentNullErrorWrapper**: A marker exclusive to the Unity Editor, aiding
    in identifying null component usage'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MonoBehaviour` update methods and coroutine executions. Here is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BehaviourUpdate**: Contains all samples of **MonoBehaviour.Update** methods'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rendering and** **VSync markers**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These markers reveal CPU activities related to processing data for the GPU
    and waiting for GPU operations to complete. Here is an example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**WaitForTargetFPS**: Indicates the time spent waiting for the targeted FPS
    specified by **Application.targetFrameRate**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backend** **scripting markers**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These markers highlight scripting backend activities, aiding in troubleshooting
    issues related to garbage collection and memory allocation. Here is an example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**GC.Alloc**: Represents an allocation in the managed heap, subject to automatic
    garbage collection'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multithreading markers**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These markers focus on thread synchronization and the Job System, offering
    information about parallel processing and sync points. Here is an example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Idle**: Contains samples indicating the length of time a Worker Thread remains
    inactive'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Physics markers**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Physics markers provide insights into the execution of physics simulations
    and related processes such as collision detection and joint handling. Here is
    an example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Physics.FetchResults**: Contains samples that collect the results of the
    physics simulation from the physics engine'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Animation markers**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These markers pertain to the Animation system, offering details on animation
    processing stages and performance considerations. Here is an example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Director.PrepareFrame**: Schedules and awaits **Director.PrepareFrameJob**
    jobs, evaluating the state machines for active Animator components'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance warnings**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The CPU Profiler identifies common performance issues and displays warnings
    to alert developers, helping them optimize their code effectively. Here is an
    example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Animation.DestroyAnimationClip**: Indicates a performance issue with calls
    related to destroying **AnimationClips**, triggering resource-intensive operations'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With a thorough understanding of these Profiler markers, we can pinpoint performance
    bottlenecks and optimize our Unity games for enhanced efficiency and responsiveness.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about common markers in the official Unity documentation:
    [https://docs.unity3d.com/Manual/profiler-markers.html](https://docs.unity3d.com/Manual/profiler-markers.html).'
  prefs: []
  type: TYPE_NORMAL
- en: By becoming familiar with the common markers, we’ve seen that they prove to
    be invaluable tools in our optimization journey. They allow us to concentrate
    on specific areas efficiently, ensuring that our efforts are both effective and
    precise.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the profiling process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s discuss general tips for the profiling process, including how to identify
    bottlenecks and gain a better understanding of the entire process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Profiling is most effective when it’s used at three specific times:'
  prefs: []
  type: TYPE_NORMAL
- en: Establish a baseline by profiling before implementing major changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Track changes during development and ensure they do not negatively impact performance
    or exceed resource budgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After development, profile again to confirm that the changes that have been
    made have achieved the desired improvements in performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid profiling until you identify issues in your game. Additionally, refrain
    from excessive profiling; determine the required frame rate for your game. Each
    frame should adhere to a time budget aligned with your target **frames per second**
    (**FPS**). For instance, a game aiming for 30 FPS should consume less than 33.33
    ms per frame (1,000 ms divided by 30 FPS). Similarly, targeting 60 FPS allows
    for 16.66 ms per frame.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Achieving the most precise profiling outcomes necessitates running and profiling
    builds directly on the intended target devices.Top of Form
  prefs: []
  type: TYPE_NORMAL
- en: Identifying bottlenecks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should determine whether your game is CPU- or GPU-bound so that you can
    focus your optimization efforts correctly. For instance, note that while VSync
    is optional on all platforms, it’s typically enabled on mobile devices and may
    contribute to CPU time waiting.
  prefs: []
  type: TYPE_NORMAL
- en: '**VSync**, short for **Vertical Synchronization**, is a graphics technology
    that synchronizes the frame rate of a game with the refresh rate of the monitor
    or display device. This synchronization prevents issues such as screen tearing,
    where parts of different frames appear on the screen simultaneously, leading to
    a visually jarring experience. VSync ensures that each frame is displayed in full
    before the next frame is rendered, creating a smoother and more visually pleasing
    experience for the player.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The performance of a project is determined by the chip or thread that requires
    the most time to process. This area is where optimization efforts should be concentrated.
    For instance, consider a game with a target frame time budget of 16.66 ms with
    VSync enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: If the CPU frame time (excluding VSync) is 10 ms and the GPU time is 12 ms,
    there’s no issue as both are within budget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the CPU frame time is 20 ms and the GPU time is 12 ms, the CPU performance
    needs to be optimized as the GPU won’t benefit from optimization. Consider transferring
    some CPU tasks to the GPU.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the CPU frame time is 8 ms and the GPU time is 20 ms, focus on optimizing
    the GPU workload as it is GPU-bound.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If both the CPU and GPU times are at 20 ms, you’re bound by both and need to
    optimize them below 16.66 ms to achieve a frame rate of 60 FPS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll learn more about CPU- and GPU-bound issues in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: CPU-bound issues
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It’s considered a CPU-bound issue when the CPU time exceeds the allocated time
    budget. Let’s walk through an example to illustrate how to identify and resolve
    such issues using the Profiler. Utilizing the **Timeline** and **Hierarchy** views
    in the Profiler helps us gain a clearer understanding of the specific issue. Refer
    to *Figure 9**.5* for detailed information on a spike frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – A spike frame](img/B22017_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – A spike frame
  prefs: []
  type: TYPE_NORMAL
- en: The `gfx.waitForCommandsFromMainThread` marker indicates a potential bottleneck
    on the main thread that affects overall performance. This occurs when the render
    thread waits for commands from the main thread, suggesting that tasks or commands
    that are being processed on the CPU are taking longer. Consequently, the game
    experiences a CPU-bound issue, causing delays in rendering. Addressing these bottlenecks
    and optimizing CPU-bound issues can significantly enhance game performance and
    responsiveness.
  prefs: []
  type: TYPE_NORMAL
- en: Identify the CPU bottleneck by analyzing which thread is the most active. Profiling
    helps pinpoint bottlenecks accurately for focused optimization. Guesswork can
    lead to ineffective optimizations or even worsen performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary threads for identifying performance issues typically include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The main thread**: This thread handles game logic and script execution, including
    tasks related to physics, animation, UI, and rendering. It accounts for a significant
    portion of the processing time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The render thread**: This thread is responsible for processing scene elements
    during rendering, such as camera culling, depth sorting, and draw call batching.
    It converts Unity’s scene representation into specific graphics API calls for
    GPU rendering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The job worker threads**: These threads utilize the C# Job System to offload
    specific tasks onto separate Worker Threads, reducing the main thread’s workload.
    Various Unity systems, such as physics, animation, and rendering, also leverage
    the Job System for improved performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to identify any loops in your code where spikes occur, determine what
    is causing the high CPU usage or prolonged processing time, and investigate if
    it corresponds to a common marker in the Profiler. Understanding the meaning of
    these markers helps you address the issue effectively. Optimize your code based
    on your findings, monitor the Profiler again after applying fixes, and continue
    this iterative process until you achieve your target frame rate.
  prefs: []
  type: TYPE_NORMAL
- en: GPU-bound issues
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If your game experiences prolonged activity in Profiler markers such as `Gfx
    WaitForPresentOnGfxThread`, indicating idle time for the render thread, and simultaneously
    shows markers such as `Gfx PresentFrame` or `<GraphicsAPIName> WaitForLastPresent`,
    it suggests a GPU-bound scenario. In this context, GPU-boundness is characterized
    by heavy GPU utilization and potential delays in frame rendering and presentation.
  prefs: []
  type: TYPE_NORMAL
- en: If your game appears to be heavily using the GPU, you can use the Frame Debugger
    to quickly examine the batches of draw calls that are sent to the GPU. I’ll discuss
    this tool in more detail in the next section. However, it’s essential to note
    that while the Frame Debugger provides insights into scene construction, it doesn’t
    offer specific GPU timing details. So, you can switch between the Profiler and
    the Frame Debugger to fix any issues related to GPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore the factors that can lead to GPU performance issues in our projects.
    The following are some common issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Complex particle systems with a high number of particles or intricate behaviors
    can impact GPU performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-time reflections or refractions, particularly in scenes with many reflective
    surfaces, can be GPU-intensive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shader permutations or shader variants for different materials or effects can
    increase GPU workload, especially if they’re not managed efficiently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic weather or environmental effects, such as rain, fog, or dynamic skies,
    can add GPU overhead if they’re not optimized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic Occlusion culling and visibility calculations can affect GPU performance,
    especially in scenes with complex geometry or many moving objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High screen resolutions, especially 4K displays or retina displays on mobile
    devices, can put a heavy load on the GPU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some useful tips while using the Profiler:'
  prefs: []
  type: TYPE_NORMAL
- en: Turn off the **VSync** and **Others** categories in the **CPU Usage** Profiler
    module. The **VSync** marker indicates periods of inactivity in the CPU’s main
    thread, and hiding these markers can enhance the clarity of your profiling analysis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disable **VSync** in your project build to gain a clear understanding of the
    interactions between the main thread, render thread, and GPU. Profiling a build
    with **VSync** disabled can simplify the interpretation of profiler data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be mindful of when to conduct profiling in either Play mode or Editor mode.
    Utilize Play mode for profiling game performance and Editor mode for monitoring
    Unity Editor processes. Profiling the Editor can aid in identifying performance
    bottlenecks and improving productivity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opt for profiling in the Editor when you need to quickly iterate on resolving
    performance issues. After identifying problems, use Play mode profiling to efficiently
    iterate on changes and validate solutions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing graphics performance and identifying rendering bottlenecks in Unity
    becomes streamlined and efficient with the powerful capabilities of the Frame
    Debugger tool. We’ll dive deeper into this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The Frame Debugger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Frame Debugger is a powerful tool that’s used for analyzing and debugging
    the rendering process of a frame in your game. It allows you to inspect each step
    involved in rendering, such as draw calls, batching, textures, and materials.
    This tool is crucial for optimizing graphics performance and identifying rendering
    bottlenecks.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can open the **Frame Debugger** tool from the **Window** | **Analysis**
    | **Frame** **Debugger** menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Frame Debugger](img/B22017_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Frame Debugger
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve learned how to open the Frame Debugger, let’s explore how it
    works and what it does.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how the Frame Debugger operates
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Frame Debugger works by intercepting and analyzing the rendering commands
    that are sent to the graphics API (for example, DirectX or OpenGL). It captures
    information about each draw call, including the shaders, textures, materials,
    and meshes involved. This captured data is then presented in a visual interface,
    allowing developers to inspect and understand the rendering pipeline of a frame.
  prefs: []
  type: TYPE_NORMAL
- en: The Frame Debugger operates in real time, meaning you can pause the game in
    Play mode, analyze the current frame’s rendering, and make optimizations on the
    fly.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the key functions of the Frame Debugger
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The primary functions of the Frame Debugger are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Capturing and displaying each draw call that’s made during the rendering process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing how objects are batched together for optimized rendering performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing details about the shaders, textures, materials, and meshes that are
    used in rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying render targets and offscreen render textures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s explore the Frame Debugger. This is what the **Frame Debugger** window
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – The Frame Debugger window has been enabled](img/B22017_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – The Frame Debugger window has been enabled
  prefs: []
  type: TYPE_NORMAL
- en: 'After enabling the Frame Debugger, the game will pause, and you’ll be able
    to view all graphics-related details for that frame. This includes every draw
    call from the initial black screen to the current scene. In Unity 2022, which
    is the version we’re using, the Frame Debugger features an **Output / Mesh** section
    with two tabs: one displaying the full output or current state of the graphics/scene,
    and the other showing the drawn mesh, such as the example of a palm tree in this
    instance. You can see this mesh in *Figure 9**.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Mesh Preview](img/B22017_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Mesh Preview
  prefs: []
  type: TYPE_NORMAL
- en: 'The details about each draw call will be presented in a separate section that
    contains important information such as **RenderTarget**, **Vertices**, **Indices**,
    and **Used Shader**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – The Details section](img/B22017_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – The Details section
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, the Frame Debugger includes sections for the used **Textures**,
    **Vectors**, **Floats**, and other sections, as shown in *Figure 9**.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – The other sections in the Frame Debugger](img/B22017_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – The other sections in the Frame Debugger
  prefs: []
  type: TYPE_NORMAL
- en: Once you have identified the contents of the frame, the optimization process
    depends on employing specific strategies and techniques tailored to the unique
    aspects of each game. Addressing issues requires thorough research to pinpoint
    areas for optimization, and this process often involves iterative steps to achieve
    optimal performance. One of the most important ways to reduce draw calls is to
    use batching. Let’s take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: Draw call batching
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Draw call batching refers to a technique that’s used for optimizing draw calls
    by merging meshes, allowing Unity to render them in fewer draw calls. Unity offers
    two default draw call batching methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Static batching**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this process, Unity combines and renders static GameObjects together.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Static batching in Unity refers to the process of optimizing draw calls by
    combining meshes either at build time or during runtime. When using static batching,
    it’s essential to ensure that certain criteria are met for GameObjects to be eligible
    for static batching:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The GameObject must be active
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It should have a **Mesh Filter** component that is enabled and references a
    mesh with a vertex count greater than 0
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The GameObject should also have a **Mesh Renderer** component that is enabled
    and uses a material without a shader that disables batching
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Meshes that are to be batched together must share the same vertex attributes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When utilizing static batching, Unity allows the entire batch of meshes to be
    transformed collectively, such as moving, rotating, or scaling them as a single
    entity. However, transformations cannot be applied to individual meshes within
    the batch.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It’s worth noting that enabling read/write access for the mesh is necessary
    to use runtime static batching effectively. Overall, static batching is a useful
    technique for optimizing draw calls and improving performance in Unity projects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Dynamic batching**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic batching is a process where Unity combines small meshes by transforming
    their vertices on the CPU and grouping similar vertices, ultimately rendering
    them in a single draw call.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To enable dynamic batching for meshes in Unity, follow these steps:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Navigate to **Edit** | **Project Settings** | **Player**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Other Settings** section, activate the **Dynamic** **Batching** option.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Unity will automatically group moving meshes into a single draw call if they
    meet the specified criteria.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Dynamic batching in Unity doesn’t work on GameObjects with mirrored transformations
    in their **Transform** components. For instance, if one GameObject has a scale
    of 1 and another has a scale of -1, Unity cannot batch them together.Top of Form
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In general, Unity combines draw calls for GameObjects using identical materials,
    so it’s crucial to maximize batching efficiency by sharing materials among multiple
    GameObjects. If you have two material assets that are almost identical except
    for their textures, consider merging the textures into a single, larger texture
    within the same atlas. This allows you to use a single material asset instead
    of two. When accessing shared material properties from a C# script, ensure that
    you use `Renderer.sharedMaterial` instead of `Renderer.material`. Using `Renderer.material`
    creates a duplicate of the material, preventing Unity from batching draw calls
    for that renderer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the additional methods you can utilize to decrease the number
    of draw call batches:'
  prefs: []
  type: TYPE_NORMAL
- en: Use Occlusion culling to eliminate objects that are hidden behind foreground
    elements and minimize overdraw. Keep in mind that this may increase CPU processing,
    so use the Profiler to evaluate the impact of transferring the workload from GPU
    to CPU.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Employ GPU instancing to reduce batches, particularly for numerous objects that
    share the same mesh and material. Limiting the number of models in your scene
    can enhance performance, and with careful implementation, you can create a complex
    scene without repetitiveness.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leverage the SRP Batcher to decrease GPU setup between draw calls by grouping
    **Bind** and **Draw** GPU commands. To maximize SRP batching benefits, utilize
    multiple Materials but restrict them to a few compatible shader variants, such
    as the **Lit** and **Unlit** shaders in the **Universal Render Pipeline** (**URP**)
    and **High Definition Render Pipeline** (**HDRP**), minimizing variations between
    keyword combinations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing these techniques can significantly enhance rendering performance and
    streamline the development process in Unity games.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s explore the optimization techniques for various categories in any
    game to improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: Performance optimization techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will delve into the crucial aspects of performance optimization
    techniques in Unity. Performance optimization plays a pivotal role in ensuring
    that your game runs smoothly, utilizes system resources efficiently, and delivers
    a seamless experience to players. By implementing optimization techniques, analyzing
    performance data, and adopting efficient scripting practices, developers can significantly
    enhance their game’s performance and overall quality. Let’s explore these skills
    in detail to understand how they contribute to creating high-performance games
    in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: The following subsections cover key areas for optimization techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Physics and collisions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To boost the performance and efficiency of physics and collisions in Unity,
    strategic optimization techniques play a crucial role. Here, we’ll explore two
    such techniques and detail their respective problems, solutions, examples, and
    outcomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Collision** **layer masking**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Problem**: There are unnecessary collision checks between objects that don’t
    interact with each other, leading to wasted computational resources.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: Use collision layer masking to specify which layers should interact
    with each other, avoiding unnecessary collision checks.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How it works**: Assign different layers to objects based on their interaction
    requirements. Configure the physics settings to only enable collisions between
    specific layers that need to interact.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example**: Let’s consider a 2D platformer game where the player character
    interacts with enemies, collectibles, and environmental obstacles. By assigning
    different layers to these objects (for example, Player, Enemy, Collectible, and
    Obstacle), you can configure the physics settings to enable collisions only between
    specific layers. Here’s an example:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Player layer interacts with the Enemy and Obstacle layers but not with the
    Collectible layer
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Enemy layer interacts with the Player and Obstacle layers but not with the
    Collectible layer
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Collectible layer does not interact with the Player, Enemy, or Obstacle
    layers:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Physics settings](img/B22017_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Physics settings
  prefs: []
  type: TYPE_NORMAL
- en: In your scripts, when performing collision checks using raycasts or collider
    triggers, you can apply layer masks to filter out unnecessary collisions. For
    instance, when you’re checking for enemy collisions, you can specify a layer mask
    that includes only the Enemy layer, ignoring collisions with collectibles or obstacles.
  prefs: []
  type: TYPE_NORMAL
- en: '**Result**: A reduced number of collision checks and improved performance by
    eliminating unnecessary physics calculations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Unity, optimizing physics and collisions through collision layer masking
    involves strategically assigning layers, configuring physics settings, and applying
    layer masks to streamline collision checks and enhance performance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplified** **collision detection**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Problem**: Full physics calculations for collision detection on objects that
    don’t require realistic physical interactions can be resource-intensive.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: Use triggers as simplified collision detection for non-essential
    objects.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How it works**: Triggers in Unity are collider components that detect when
    another collider enters or exits their volume without physically colliding with
    them. They are ideal for scenarios where you need to detect interactions without
    simulating physical forces.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example**: In a game where collectible coins are scattered around the level,
    instead of using rigid body-based collisions for the coins, you can attach trigger
    colliders to them. When the player’s character overlaps with a coin’s trigger
    collider, you can handle the collection logic without the need for full physics
    calculations.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Result**: Using triggers reduces the computational overhead associated with
    physics calculations for objects that only require collision detection without
    physical responses. This leads to improved performance, especially in scenarios
    with a large number of non-essential objects.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This technique is beneficial for optimizing performance in scenarios where objects
    do not require detailed physics interactions but still need basic collision detection
    functionality. By using simplified collision detection methods, you can conserve
    computational resources and improve overall performance in your Unity project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Audio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Optimizing audio in Unity is crucial for maintaining a smooth and immersive
    gameplay experience. Let’s explore an advanced technique to reduce memory usage
    and improve audio performance in your game:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Audio** **compression technique**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Problem**: Large audio files can consume significant memory, leading to performance
    issues.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: Compress audio files using formats such as Ogg Vorbis or MP3
    to reduce memory usage without compromising quality. You can learn more about
    Unity’s importing settings by referring to the official Unity documentation at
    https://docs.unity3d.com/Manual/class-AudioClip.html#:~:text=Whenever%20importing%20a%20file%2C%20Unity,to%20the%20original%20as%20possible:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Imported audio settings](img/B22017_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Imported audio settings
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**: Compressing background music and sound effects in a game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Result**: Reduced memory footprint, faster loading times, and smoother gameplay.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By employing advanced audio optimization techniques such as compression and
    streaming, you can significantly enhance your game’s performance while maintaining
    high-quality audio output.
  prefs: []
  type: TYPE_NORMAL
- en: UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I covered this topic in detail in [*Chapter 5*](B22017_05.xhtml#_idTextAnchor074),
    *Designing Optimized User Interfaces with C# for Unity Games*. You can check it
    out for more details. Optimizing UI is a crucial part of performance, especially
    in mobile games, as it directly impacts user experience and device resource utilization.
  prefs: []
  type: TYPE_NORMAL
- en: Networking and multiplayer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Optimizing networking and multiplayer functionality in Unity games is crucial
    for ensuring smooth gameplay experiences across various devices and player interactions.
    Here, we’ll explore key techniques and strategies for enhancing networking performance
    and implementing effective multiplayer mechanics in Unity games:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Latency** **compensation techniques**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Problem**: Latency can cause delays in multiplayer games, leading to synchronization
    issues and gameplay inconsistencies.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: Implement latency compensation techniques to mitigate the effects
    of network latency on gameplay. This depends on the networking solution you have
    implemented. You can refer to their documentation for specific networking solutions,
    such as Photon.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example**: Use techniques such as client-side prediction, interpolation,
    and lag compensation to predict and smooth out the movement of networked objects
    based on input and network data.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Results**: Improved responsiveness and synchronization in multiplayer games,
    reducing the impact of network latency on player experience and enhancing gameplay
    smoothness.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network** **object pooling**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Problem**: Excessive instantiation and destruction of networked objects can
    lead to network congestion and performance issues.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: Implement network object pooling to reuse existing networked
    objects instead of creating and destroying them frequently.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example**: In a multiplayer game, instead of instantiating and destroying
    bullets each time they are fired, use an object pool to recycle bullets. When
    a bullet is no longer needed, it is returned to the pool and can be reused later.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Results**: Reduced network overhead and improved performance due to fewer
    object instantiations and destructions, leading to smoother gameplay experiences.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These techniques are instrumental in optimizing networking within Unity games
    as they effectively minimize network overhead, enhance data transmission efficiency,
    and contribute to a more satisfying multiplayer experience for players. The effectiveness
    of these optimizations, however, is contingent upon the specific networking solution
    that’s implemented within the game.
  prefs: []
  type: TYPE_NORMAL
- en: AI and pathfinding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Effective AI and pathfinding techniques are pivotal for creating immersive
    and engaging gameplay experiences in Unity games. We’ll explore two key solutions:
    A* (A-star) pathfinding and hierarchical pathfinding, along with behavior trees
    and state machines, to optimize AI navigation and behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using** **behavior trees**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Problem**: Inefficient pathfinding algorithms can lead to high computational
    overhead and slow performance, especially in complex game environments with dynamic
    obstacles.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example**: Implementing the A* algorithm in Unity using the NavMesh system.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How it works**: A* is a popular pathfinding algorithm that efficiently finds
    the shortest path between two points on a graph or grid. In Unity, the NavMesh
    system utilizes A* for AI navigation, allowing agents to navigate dynamic environments
    while avoiding obstacles.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Result**: Improved AI navigation performance, reduced computational cost,
    and smoother movement of AI agents in complex game scenes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using state machines for** **AI behavior**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Problem**: AI behaviors lacking realism and diversity can result in predictable
    and monotonous gameplay experiences.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example**: Implementing state machines for AI character behaviors.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How it works**: State machines model AI behaviors as a set of states, transitions,
    and actions. Each state represents a specific behavior or condition, and transitions
    define how AI agents switch between states based on environmental stimuli or internal
    variables.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s a simplified structure of a state machine for AI behavior:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**State interface/class**:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Enter**: The method that’s called when entering the state'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Update**: The method that’s called during each update cycle while in the
    state'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exit**: The method that’s called when exiting the state'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concrete states**:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Idle State**: This represents the AI being idle, with its own **Enter**,
    **Update**, and **Exit** methods specific to idle behavior.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attack State**: Represents the AI attacking, with its own **Enter**, **Update**,
    and **Exit** methods specific to attack behavior'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Other states as needed, each with their own behavior methods
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State** **machine manager**:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Current State**: Keeps track of the AI’s current state'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Change State**: This method transitions the AI from one state to another
    by updating the **Current** **State** variable'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Update**: The method to be called in each update cycle, which, in turn, calls
    the **Update** method of the current state'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usage**:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Initialize the AI with an initial state (for example, **Idle State**)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: During each update cycle, call the **Update** method of the state machine manager
    to execute the behavior of the current state
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When conditions change (for example, the AI detects an enemy), use the **Change
    State** method to switch to the appropriate state (for example, **Attack State**)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This structure outlines the components and their relationships in a state machine
    for AI behavior. You can implement this structure in any programming language
    by creating classes/interfaces for states, implementing a manager to handle state
    transitions, and integrating them into your AI system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Result**: Modular and organized AI behavior design, easier debugging and
    maintenance of AI logic, and improved adaptability to changing game conditions.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Build size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Efficient build size is crucial for delivering optimized and polished Unity
    games to players. Let’s explore a technique known as build size reduction through
    asset compression to enhance build efficiency:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Build** **size reduction**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Problem**: Large build sizes can lead to longer download times and increased
    storage requirements for players.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: Implement asset compression techniques such as texture compression,
    audio compression, and code stripping to reduce the overall size of the build.
    For texture compression, it’s recommended to use dimensions that are powers of
    two, such as 64x64\. This approach is beneficial for compression, resulting in
    reduced memory usage and a smaller final build size.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example**: Use texture compression formats such as ETC2 for Android builds
    and ASTC for iOS builds to significantly reduce the size of texture assets without
    compromising quality. The size of the texture is shown in the following figures:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Before using the compression format](img/B22017_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – Before using the compression format
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – After using a compression format](img/B22017_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – After using a compression format
  prefs: []
  type: TYPE_NORMAL
- en: '**Result**: Reduced build size, faster download times, and improved performance
    on devices with limited storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Optimizing rendering is essential for delivering visually stunning games while
    maintaining optimal performance. Let’s explore two powerful techniques: a **level
    of detail** (**LOD**) system for efficient mesh rendering and Occlusion Culling
    to minimize unnecessary rendering, resulting in enhanced performance and visual
    quality:'
  prefs: []
  type: TYPE_NORMAL
- en: '**LOD system**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Problem**: High-poly models and complex scenes can lead to performance issues,
    especially on lower-end devices.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: Implement a LOD system where objects have multiple versions with
    varying levels of detail. The system switches to lower-detail versions as objects
    move farther from the camera, reducing the rendering workload.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example**: Use Unity’s **LOD Group** component to create LOD levels for meshes,
    ensuring smooth transitions between LOD levels based on camera distance. Ensure
    that you have the necessary meshes ready by either requesting them from artists,
    utilizing assets from the asset store, or creating them manually if you possess
    the skills. It’s important to create low-poly meshes from the original ones to
    optimize performance:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.15 – The LOD Group component](img/B22017_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – The LOD Group component
  prefs: []
  type: TYPE_NORMAL
- en: '**Result**: Improved performance by reducing the number of polygons that are
    rendered without compromising visual quality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Occlusion culling**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Problem**: Rendering off-screen objects consumes resources and affects performance,
    even though they are not visible to the player.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: Use Occlusion culling to prevent objects that are occluded by
    other objects or not within the player’s view frustum from being rendered.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example**: Configure Occlusion culling volumes in Unity to define areas where
    Occlusion culling should be applied, optimizing rendering by skipping occluded
    objects:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.16 – The camera before the starting line](img/B22017_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – The camera before the starting line
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17 – The camera after the starting line](img/B22017_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.17 – The camera after the starting line
  prefs: []
  type: TYPE_NORMAL
- en: '**Result**: Reduced rendering workload, improved frame rates, and enhanced
    overall performance, especially in complex scenes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Efficient scripting practices are crucial for optimizing game performance and
    ensuring smooth gameplay experiences. Let’s explore two powerful techniques: object
    pooling for efficient object management and coroutine optimization to enhance
    coroutine performance, resulting in improved overall game performance and responsiveness.'
  prefs: []
  type: TYPE_NORMAL
- en: Object pooling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s consider a solution for object pooling:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Instantiating and destroying objects frequently during gameplay
    can lead to performance overhead due to memory allocation and garbage collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: Implement object pooling, where a set of pre-allocated objects
    is reused instead of you having to instantiate and destroy them repeatedly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ObjectPoolManager` and understand its functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following code block, the `ObjectPoolManager` class is responsible for
    handling all operations related to the pooled objects. To make it accessible from
    other scripts, we will implement it as a singleton:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This script uses a static `Instance` property to implement the singleton pattern
    for `ObjectPoolManager`. It also includes an `Awake` method to ensure that only
    one instance of `ObjectPoolManager` exists in the scene and persists between scene
    changes if needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the following code block, I will continue implementing the logic related
    to the object pooling by `GetPooledObject` and `ReturnToPool` functions of the
    objects:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s an explanation for each part:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**private Dictionary<string, Queue<GameObject>> objectPools = new Dictionary<string,
    Queue<GameObject>>();**: This line declares a private dictionary named **objectPools**
    that stores object pools based on their names. Each name corresponds to a queue
    of GameObjects.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**public GameObject GetPooledObject(string objectName)**: This method retrieves
    an object from the object pool based on its name. It checks if an object pool
    with the given name exists and if there are available objects in the pool. If
    available, it dequeues an object, activates it, and returns it. If no object is
    available, it logs a warning and returns null.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**public void ReturnToPool(string objectName, GameObject obj)**: This method
    returns an object to the object pool based on its name. It deactivates the object
    and enqueues it back into the corresponding object pool queue.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lastly, I’ll create a function to instantiate pooled objects from other scripts,
    as demonstrated in the following code block:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s an explanation of the `CreateObjectPool` method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**public void CreateObjectPool(GameObject prefab, int poolSize, string objectName)**:
    This method creates an object pool for a specific prefab with a given pool size
    and object name. It checks if an object pool with the same name already exists.
    If not, it creates a new queue in the dictionary and instantiates objects based
    on the prefab to populate the pool.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example of how to use this manager:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Result**: Reduced memory overhead, improved performance, and smoother gameplay
    experience, especially in scenarios with frequent object creation and destruction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coroutine optimization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let’s consider a solution for coroutine optimization:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Using coroutines extensively without optimization can lead to
    performance issues, especially when you’re dealing with long-running or frequent
    coroutines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: Optimize coroutines by employing techniques such as using **WaitForSeconds**
    instead of **WaitForSecondsRealtime**, minimizing **WaitForSeconds** calls, and
    avoiding nested coroutines where possible. Additionally, consider defining or
    caching **WaitForSeconds** instances to avoid creating new instances each time
    the coroutine is executed, which can improve memory efficiency. The following
    code block shows an example of how to define **WaitForSeconds**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Example**: Refactor coroutine-heavy scripts to reduce the number of coroutine
    instances, optimize yield instructions, and use alternatives such as **InvokeRepeating**
    for repetitive tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Result**: Improved performance by reducing coroutine overhead, smoother gameplay,
    and better frame rates, especially in complex scenes with many coroutines running
    simultaneously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We now know about some common issues and their appropriate solutions. In the
    next section, we’ll move on and learn how to optimize memory.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management and optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory profiling in Unity involves utilizing tools such as the Memory Profiler
    module and package to analyze and optimize memory usage, allowing us to identify
    areas for improvement and enhance overall performance. You’ll learn more about
    the Memory Profiler package in this section.
  prefs: []
  type: TYPE_NORMAL
- en: You can analyze memory usage in your Unity application through two methods.
    First, the Memory Profiler module provides essential insights into memory usage,
    highlighting areas where your application consumes memory. Second, by integrating
    the Memory Profiler package into your project, you gain access to an enhanced
    **Memory Profiler** window within Unity Editor. This advanced tool allows for
    more detailed analysis, including storing and comparing snapshots to identify
    memory leaks and examining memory layouts to detect fragmentation issues.
  prefs: []
  type: TYPE_NORMAL
- en: The Memory Profiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Memory Profiler in Unity is a tool that’s used for analyzing and optimizing
    memory usage in Unity projects. It helps us understand how our game uses memory
    and identify areas where memory can be optimized.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to install this package into your project. Go to the **Package Manager**
    window and select **Memory Profiler**, as shown in *Figure 9**.18*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18 – Installing the Memory Profiler package](img/B22017_09_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.18 – Installing the Memory Profiler package
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait for Unity to finish installing the Memory Profiler package, then open
    it from the **Window** | **Analysis** | **Memory Profiler** menu. If this is your
    first time using it in your project, an empty window will open, as shown in *Figure
    9**.19*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.19 – The Memory Profiler panel](img/B22017_09_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.19 – The Memory Profiler panel
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve learned how to open the Memory Profiler, let’s explore how it
    works and what it does.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how the Memory Profiler operates
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Memory Profiler works by monitoring and recording memory allocations and
    usage in real time while your Unity project is running. It tracks various metrics,
    such as heap size, memory allocations by type, instance counts, and memory leaks.
    It provides a detailed breakdown of memory usage, allowing developers to pinpoint
    areas of high memory consumption and potential memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the key functions of the Memory Profiler
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The primary functions of the Memory Profiler are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tracks memory allocations**: The Memory Profiler tracks memory allocations
    made by your game, including heap memory, object instances, and resource usage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identifies memory leaks**: It helps identify memory leaks by highlighting
    objects that are not properly disposed of or released from memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analyzes memory usage by type**: You can see a breakdown of memory usage
    by different types of objects, scripts, textures, and other assets in your project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Provides instance counts**: The Memory Profiler shows how many instances
    of each object type are currently in memory, helping you understand memory consumption
    patterns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Offers insights into resource usage**: It provides insights into how resources
    such as textures, audio clips, and other assets contribute to memory usage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s learn how to use the Memory Profiler.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Memory Profiler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the Memory Profiler, it’s crucial to consider and adhere
    to the memory limitations of your target devices in multiplatform development.
    Design scenes and levels within the specified memory budget for each device to
    ensure optimal performance based on hardware capabilities. Setting clear limits
    and guidelines helps maintain compatibility across platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Memory Profiler package offers comprehensive memory analysis capabilities.
    Utilize it to store and compare snapshots for identifying memory leaks and optimizing
    your application’s memory layout. Unlike the Memory Profiler module, this package
    extends its functionality to include managed memory analysis, snapshot saving,
    comparison, and detailed memory content exploration with visual breakdowns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.20 – The Summary tab in the Memory Profiler](img/B22017_09_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.20 – The Summary tab in the Memory Profiler
  prefs: []
  type: TYPE_NORMAL
- en: The **Summary** tab provides an overview of the memory status in the chosen
    snapshot(s).
  prefs: []
  type: TYPE_NORMAL
- en: Once you click on any area of the summary, further details about it will appear
    in the right-hand panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another tab we should consider is **Unity Objects**, which showcases Unity
    objects that are utilizing memory, along with their respective allocations in
    native and managed memory, and the combined total. You can utilize this data to
    spot duplicate memory entries or pinpoint objects with significant memory usage.
    You can also utilize the search bar to filter entries in the table based on your
    specified text. This can be seen in *Figure 9**.21*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.21 – The Unity Objects tab in the Memory Profiler](img/B22017_09_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.21 – The Unity Objects tab in the Memory Profiler
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, The **All Of Memory** tab is exclusive to **Single Snapshot** mode,
    providing a comprehensive breakdown of all tracked memory in the snapshot. It
    visualizes memory usage, showcasing sizable portions managed either by Unity or
    the platform. This tab is instrumental in discerning non-Unity-related memory
    consumption and uncovering potential memory issues not evident in the **Unity**
    **Objects** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.22 – The All Of Memory tab in the Memory Profiler](img/B22017_09_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.22 – The All Of Memory tab in the Memory Profiler
  prefs: []
  type: TYPE_NORMAL
- en: 'You can identify optimization candidates by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a snapshot by referring to the instructions for opening snapshots.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Access the **Unity** **Objects** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the table is sorted in descending order, which is the default setting
    in the **Memory Profiler** window. If the sort order has been changed, select
    the **Total Size** column header to revert to descending order for this process.
    This arrangement highlights objects with the highest memory usage at the top of
    the table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can search through the results in one of two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Expand groups to view individual objects within each group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider enabling the **Flatten hierarchy** property to exclusively display
    individual objects in the table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re uncertain about which objects might use excessive memory, leave the
    **Flatten hierarchy** property disabled and inspect the groups to identify the
    largest objects. Enable this property if most assets are understood but there’s
    a suspicion of a few outliers consuming too much memory.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, enable the **Show Potential Duplicates Only** property to identify
    objects flagged by the Memory Profiler as potential duplicates. Utilize the **References**
    component and **Selection Details** component for detailed insights into these
    objects. This information helps differentiate expected duplicates, such as multiple
    instances of a Prefab in a scene, from problematic duplicates, such as unintentionally
    created objects or instances not disposed of correctly by Unity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some considerations when it comes to memory profiling:'
  prefs: []
  type: TYPE_NORMAL
- en: Use different memory usage based on settings such as quality levels, graphics
    tiers, and AssetBundle variants, especially on more powerful devices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quality Level** and **Graphics** settings can impact the size of RenderTextures
    that are used for shadow maps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolution scaling affects screen buffers, RenderTextures, and post-processing
    effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Texture quality settings influence the size of all textures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum LOD can impact models and other elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AssetBundle variants such as HD and SD versions can result in different asset
    sizes based on the device’s specifications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The target device’s screen resolution affects the dimensions of RenderTextures
    that are utilized for post-processing effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The supported Graphics API can affect shader sizes based on API-specific variants.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content generated dynamically during gameplay, such as procedural levels, can
    significantly impact memory usage. Monitor the memory footprint of dynamically
    generated assets to ensure efficient memory management.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conduct thorough testing on target devices with varying specifications, screen
    resolutions, and hardware configurations to identify and address memory issues
    specific to each platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By considering these aspects and conducting comprehensive memory profiling,
    you can optimize memory usage across different platforms, ensuring optimal performance
    and resource utilization in your Unity projects.
  prefs: []
  type: TYPE_NORMAL
- en: One effective method to improve memory optimization in Unity is by optimizing
    the import settings for assets.
  prefs: []
  type: TYPE_NORMAL
- en: Importing models
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Importing models is a critical aspect of 3D game development, and optimizing
    this process can significantly enhance memory usage and overall performance. In
    this section, we’ll explore key settings, as shown in *Figure 9**.**23*, that
    can be adjusted to achieve these optimizations effectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.23 – The model’s settings](img/B22017_09_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.23 – The model’s settings
  prefs: []
  type: TYPE_NORMAL
- en: '**Mesh Compression** is a setting that determines the level of compression
    that’s applied to imported mesh data. It affects the file size of the mesh asset
    and can impact both memory usage and rendering performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Options**: Unity provides three options for **Mesh Compression**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Off**: No compression is applied, resulting in larger file sizes but potentially
    better rendering performance.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low**: Applies a basic compression algorithm to reduce file size while still
    maintaining visual quality. This is suitable for many cases as it doesn’t have
    a significant impact on rendering performance.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Medium/High**: Utilizes more advanced compression techniques to further reduce
    file size. However, higher compression levels may lead to slightly lower rendering
    performance due to additional decompression overhead.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Best practices**: Use **Mesh Compression** judiciously based on the specific
    requirements of your game. For complex models or those with intricate details,
    consider using **Low** compression to balance file size reduction with rendering
    performance. Test different compression levels to find the optimal balance for
    your project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Read/Write Enabled** setting determines whether the mesh data can be
    accessed and modified at runtime. Enabling this setting allows scripts to read
    and modify mesh properties during gameplay:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Impact on performance and memory**: Enabling Read/Write for a mesh increases
    memory usage because the mesh data needs to be stored in a format that allows
    runtime modifications. However, it can also provide flexibility for dynamic mesh
    operations, such as deformation or procedural mesh generation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Best practices**: Only enable Read/Write for meshes that require runtime
    modifications. For static meshes that do not change during gameplay, leave this
    setting disabled to reduce memory overhead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Optimize Mesh** setting determines whether Unity applies additional optimizations
    to the imported mesh data to improve rendering performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Effect on performance and memory**: Enabling **Optimize Mesh** allows Unity
    to perform optimizations such as vertex welding, which reduces the number of vertices
    in the mesh without significantly affecting visual quality. This can lead to improved
    rendering performance by reducing the workload on the GPU.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Best practices**: Enable **Optimize Mesh** for meshes that can benefit from
    vertex reduction without compromising visual fidelity. This is particularly useful
    for models with redundant or overlapping vertices as it can significantly reduce
    memory usage and enhance rendering performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Setting the **Animation Type** option to **None** for a static game object
    in the **Rig** tab can have a positive impact on both performance and memory usage.
    When you choose **None**, Unity skips any processing related to animation rigging
    and does not allocate resources for animation-related calculations during runtime.
    This can be seen in *Figure 9**.24*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.24 – The Rig tab in the model settings](img/B22017_09_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.24 – The Rig tab in the model settings
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how setting **Animation Type** to **None** can affect performance
    and memory.
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance impact**:'
  prefs: []
  type: TYPE_NORMAL
- en: By setting **Animation Type** to **None**, Unity avoids processing animation
    data and calculations for the game object. This reduces the workload on the CPU
    and GPU, especially during the rendering and animation playback phases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since there are no animation updates to perform, Unity can optimize the rendering
    pipeline by skipping unnecessary computations related to bone transformations,
    blend shapes, or animation state updates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This optimization can lead to smoother frame rates and improved overall performance,
    particularly for static objects that do not require any animation functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory impact**:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting **Animation Type** to **None** also has a memory-saving benefit. Unity
    does not allocate memory for storing animation clips, rigging data, or animation-related
    components (for example, Animator or Animation Controller) for game objects with
    this setting applied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This reduction in memory usage can be significant, especially for scenes with
    multiple static objects or large models that do not need animation features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By minimizing memory allocation for animation-related resources, you free up
    more memory for other game assets and reduce the overall memory footprint of your
    Unity project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Best practices**:'
  prefs: []
  type: TYPE_NORMAL
- en: Set **Animation Type** to **None** for static game objects or models that do
    not require animation functionality. This is particularly effective for environment
    props, static scenery elements, or architectural models.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For dynamic objects that require animation, such as characters or interactive
    elements, choose the appropriate **Animation Type** based on their animation requirements
    (for example, **Generic**, **Humanoid**, **Legacy**, and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regularly review and optimize animation settings for each game object to ensure
    efficient use of resources and improved performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, setting **Animation Type** to **None** for static game objects can
    be a beneficial optimization strategy as it reduces both CPU/GPU workload and
    memory usage in your Unity project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, when considering the **Anim. Compression** option in the **Animation**
    tab of model settings in Unity, choosing between **Optimal Compression** or **Keyframe
    Reduction** can indeed have an impact on both performance and memory usage. This
    can be seen in *Figure 9**.25*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.25 – The Animation tab in the model settings](img/B22017_09_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.25 – The Animation tab in the model settings
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how each option affects your project.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optimal Compression**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance impact**: **Optimal Compression** aims to reduce the size of
    animation clips while preserving visual quality. This can result in improved performance
    during runtime, especially for devices with limited processing power or memory
    bandwidth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory impact**: By compressing animation data efficiently, **Optimal Compression**
    reduces the memory footprint of animation clips. This can be beneficial for projects
    with many animations or large animation files, leading to lower memory usage and
    better resource management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keyframe Reduction**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance impact**: **Keyframe Reduction** focuses on minimizing the number
    of keyframes in animation clips while maintaining smooth motion. This can lead
    to improved performance by reducing the computational overhead of interpolating
    between keyframes during animation playback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory impact**: While **Keyframe Reduction** can help save memory by reducing
    the data needed for animation playback, it may not be as efficient in terms of
    memory optimization as **Optimal Compression**. However, it can still contribute
    to lowering the overall memory usage of animation clips.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Best practices**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Optimal Compression**: Use **Optimal Compression** for animations that require
    a balance between file size reduction and visual quality. It’s suitable for a
    wide range of animations and can offer significant memory and performance benefits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keyframe Reduction**: Consider **Keyframe Reduction** for animations where
    reducing the number of keyframes won’t significantly impact visual fidelity. This
    option can be particularly useful for repetitive or simple animations, helping
    to streamline memory usage and improve playback performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Choosing the** **right option**:'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate the animation requirements of your project and choose the compression
    option that best suits your needs. **Optimal Compression** is generally recommended
    for most scenarios due to its balanced approach to reducing file size and memory
    usage while maintaining visual quality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regularly test animations with different compression settings to find the optimal
    balance between performance, memory usage, and visual fidelity for your specific
    project requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, both **Optimal Compression** and **Keyframe Reduction** in the
    **Anim. Compression** option can impact performance and memory in Unity. Choose
    the compression setting that aligns with your project’s animation complexity,
    visual quality standards, and target platform capabilities to achieve the best
    results.
  prefs: []
  type: TYPE_NORMAL
- en: 'To automate this process, we can create an asset `PostProcessor` script, which
    is an editor script that allows us to set default settings for importing assets.
    The following is an example code block demonstrating a `CustomMeshPostProcessor`
    class that achieves the desired default settings when importing meshes. Simply
    create this script and place it in the `Editor` folder of your project. Once implemented,
    the script will automatically apply these settings when importing new models.
    Feel free to customize it and add more settings as needed for your game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Overall, optimizing the import settings for models in Unity is crucial for achieving
    efficient memory usage and overall performance in your game. By carefully configuring
    these settings and following best practices, you can significantly enhance the
    user experience while maintaining optimal resource utilization.
  prefs: []
  type: TYPE_NORMAL
- en: Importing textures
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The topic of importing textures is highly impactful in optimizing both game
    and memory performance, with notable effects extending to UI performance as well.
    The available settings are shown in *Figure 9**.26*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.26 – Texture settings](img/B22017_09_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.26 – Texture settings
  prefs: []
  type: TYPE_NORMAL
- en: When importing textures into Unity, two key settings that can impact performance
    and memory usage are **Read/Write** and **GenerateMipMaps**. Let’s delve into
    each setting and understand their effects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Read/Write**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance impact**: Enabling **Read/Write** allows scripts to access and
    modify texture data at runtime. While this flexibility can be beneficial for certain
    features, such as dynamic texture updates or procedural generation, it comes with
    a performance cost. Each texture marked as **Read/Write** consumes additional
    memory and may require more processing power during runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory impact**: Textures with **Read/Write** enabled occupy more memory
    compared to those without this option. This is because Unity allocates space for
    both the texture data and an additional copy that can be modified at runtime.
    As a result, enabling **Read/Write** for multiple textures can lead to increased
    memory usage, especially on resource-constrained platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GenerateMipMaps**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance impact**: Generating MipMaps creates a series of pre-calculated
    texture levels (MipMaps) that improve rendering quality and performance. However,
    this process requires additional computational resources during texture import
    or runtime generation, impacting loading times and initial performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory impact**: Including MipMaps increases the memory footprint of textures
    since each MipMap level adds to the total texture size. While MipMaps enhance
    rendering performance by providing optimized texture sampling at different distances,
    they also consume more memory, especially for large textures with numerous MipMap
    levels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Best practices**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Read/Write**: Only enable **Read/Write** for textures that require runtime
    modification or dynamic updates. For static textures used as sprites, backgrounds,
    or UI elements, disable **Read/Write** to conserve memory and improve performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GenerateMipMaps**: Use **GenerateMipMaps** for textures that will benefit
    from improved rendering quality and performance, such as textures used for 3D
    models or distant terrain. Consider the trade-off between enhanced visual fidelity
    and increased memory usage when deciding whether to include MipMaps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Choosing the** **right settings**:'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate the specific requirements of each texture in your project. Enable **Read/Write**
    and **GenerateMipMaps** judiciously based on whether the texture needs runtime
    modification and whether MipMaps are necessary for optimized rendering.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regularly monitor the memory usage and performance impact of textures with different
    settings to optimize resource utilization and maintain efficient runtime behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, managing **Read/Write** and **GenerateMipMaps** settings when
    you’re importing textures into Unity is crucial for balancing performance, memory
    usage, and visual quality. Selecting the appropriate settings based on the intended
    usage of each texture helps optimize resource allocation and enhances overall
    application performance.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect to consider is compression settings, which vary based on the
    target platform, each with its unique configurations. While specific platform
    settings are extensive and platform-dependent, there are some general tips for
    optimizing compression.
  prefs: []
  type: TYPE_NORMAL
- en: '**Maximum size**:'
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the maximum size of textures determines their dimensions upon import.
    Higher resolutions offer better visual quality but consume more memory. Consider
    the device’s capabilities and the texture’s intended use to strike a balance between
    quality and performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Best practice**: Set the maximum size based on the target platform and the
    texture’s role in the game. Use lower resolutions for background elements or distant
    objects to conserve memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resize algorithm**:'
  prefs: []
  type: TYPE_NORMAL
- en: The resize algorithm dictates how textures are scaled when their dimensions
    exceed the maximum size. Different algorithms may impact image quality and memory
    usage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Best practice**: Choose an algorithm that suits the texture type. Use sharper
    algorithms for detailed textures and smoother ones for gradients or patterns to
    preserve quality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Format**:'
  prefs: []
  type: TYPE_NORMAL
- en: Texture format determines how the image data is stored, impacting compression,
    memory usage, and visual fidelity. Common formats include PNG, JPG, and TGA, each
    with its compression levels and quality trade-offs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Best practice**: Select a format based on the texture’s content and usage.
    Use PNG for lossless quality, JPG for photographic textures with compression,
    and TGA for high-quality images with transparency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compression**:'
  prefs: []
  type: TYPE_NORMAL
- en: Compression methods reduce texture size and memory footprint. Unity offers options
    such as **Normal Quality**, **High Quality**, and **Low Quality** for compression,
    each affecting image quality and memory usage differently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Best practice**: Choose compression settings based on performance requirements
    and visual standards. Use higher-quality compression for critical textures and
    lower quality for background or non-critical elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Crunch compression**:'
  prefs: []
  type: TYPE_NORMAL
- en: Crunch compression is an additional method to further reduce texture file sizes
    while maintaining acceptable quality. It’s beneficial for optimizing memory usage,
    especially on resource-constrained platforms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Best practice**: Enable crunch compression for textures where file size reduction
    is crucial, such as UI elements or frequently used textures. Balance the compression
    level to preserve visual quality while minimizing memory impact.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, these settings may vary in impact based on the platform, so testing
    and iteration are key. Regularly monitor memory usage and performance metrics
    to fine-tune texture settings for optimal results on each target platform.
  prefs: []
  type: TYPE_NORMAL
- en: By carefully configuring importing settings, you can reduce memory usage and
    improve overall performance in your Unity project.
  prefs: []
  type: TYPE_NORMAL
- en: Another crucial technique for memory optimization in Unity is utilizing sprite
    atlases.
  prefs: []
  type: TYPE_NORMAL
- en: Sprite Atlases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sprite Atlases in Unity are essential tools for optimizing memory and performance,
    especially for UI elements. They allow you to combine multiple sprites into a
    single image, reducing draw calls and texture memory usage. Let’s learn how to
    use Sprite Atlases effectively while considering their best practices and impact
    on memory and performance.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Sprite Atlas
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have the **2D Sprite** package installed in your project via **Package
    Manager**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your **Project** tab, right-click and select **Create** | **2D** | **Sprite
    Atlas**, as shown in *Figure 9**.27*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.27 – Sprite Atlas](img/B22017_09_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.27 – Sprite Atlas
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you’ve enabled the **Sprite Packer** option in **Edit** | **Project
    Settings** | **Editor** so that you can start using this package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable **Sprite Packer**, as shown in *Figure 9**.28*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.28 – Enabling Sprite Packer in Project Settings](img/B22017_09_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.28 – Enabling Sprite Packer in Project Settings
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the sprite atlas, navigate to it to begin adding textures. Click
    on the **+** sign to select individual textures or a folder containing textures.
    Then, click on **Pack Preview** to combine them into an atlas file, as shown in
    *Figure 9**.29*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.29 – Sprite Atlas settings](img/B22017_09_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.29 – Sprite Atlas settings
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some best practices you should consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Merge frequently used sprites into a single Sprite Atlas to minimize draw calls
    and enhance performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the packing options in the **Sprite Packer** window to optimize how sprites
    are packed within the atlas, minimizing wasted space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid including excessively large sprites or unnecessary sprites in the atlas
    to keep the atlas’ size manageable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sprite Atlases have an impact on memory and performance. Let’s take a closer
    look:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory**: Sprite Atlases help conserve memory by reducing the number of individual
    textures that are loaded into memory. However, be mindful of the total size of
    the Sprite Atlas as it still occupies memory based on its dimensions and content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Sprite Atlases improve performance by reducing the number
    of draw calls required to render UI elements. This is especially beneficial for
    complex UIs with numerous sprites.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sprite Atlases primarily affect UI elements in terms of memory and performance.
    They are designed to optimize the rendering of 2D graphics, so their impact on
    other aspects of your game, such as 3D models or audio, is minimal. However, for
    UI-heavy games or applications, properly utilizing Sprite Atlases can significantly
    enhance performance and memory management.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we embarked on a journey to optimize our game’s performance
    using Unity’s powerful profiling tools. Building upon the skills we’ve already
    acquired, we delved into an introduction to Unity profiling tools, reinforcing
    our ability to identify performance bottlenecks and apply optimization techniques
    to significantly enhance our game’s performance. This chapter further deepened
    our understanding of memory management and optimization, guiding us on how to
    effectively manage memory usage and optimize memory performance in our game. Through
    practical exercises and insights, we solidified our mastery of the Profiler, Frame
    Debugger, and Memory Profiler, ensuring that our game runs smoothly and efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Looking ahead to [*Chapter 10*](B22017_10.xhtml#_idTextAnchor157), we will discover
    a treasure trove of tips and tricks to enhance our Unity development skills using
    C#. The next chapter focuses on productivity-boosting shortcuts, advanced techniques
    and workflows, and troubleshooting common challenges in Unity development. We
    will learn how to utilize shortcuts for efficient development, apply advanced
    techniques to enhance our game development processes, and troubleshoot and find
    solutions to common challenges we may encounter. This chapter will equip us with
    valuable insights that we can implement to improve our workflow, overcome challenges,
    and unlock new possibilities in Unity game development using C#.
  prefs: []
  type: TYPE_NORMAL
