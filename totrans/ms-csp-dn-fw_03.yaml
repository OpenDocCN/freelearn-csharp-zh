- en: Chapter 3. Advanced Concepts of C# and .NET
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 C#和.NET的高级概念
- en: We've seen how the C# language evolved in early versions, 2.0 and 3.0, with
    important features, such as generics, lambda expressions, the LINQ syntax, and
    so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了C#语言在早期版本（2.0和3.0）中的演变，包括泛型、lambda表达式、LINQ语法等重要特性。
- en: Starting with version 4.0, some common and useful practices were eased into
    the language (and framework libraries), especially everything related to synchronicity,
    execution threads, parallelism, and dynamic programming. Finally, although versions
    6.0 and 7.0 don't include game-changing improvements, we can find many new aspects
    intended to simplify the way we write code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从4.0版本开始，一些常见且有用的实践被引入到语言（和框架库）中，特别是与同步性、执行线程、并行性和动态编程相关的一切。最后，尽管6.0和7.0版本没有包含颠覆性的改进，但我们仍然可以发现许多旨在简化我们编写代码方式的新的方面。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: 'New features in C# 4: covariance and contravariance, tuples, lazy initialization,
    Dynamic programming, the `Task` object and asynchronous calls.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 4的新特性：协变和逆协变、元组、延迟初始化、动态编程、`Task`对象和异步调用。
- en: The async/await structure (belongs to C# 5).
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步/await结构（属于C# 5）。
- en: 'What''s new in C# 6.0: string interpolation, Exception filters, the `NameOf`
    operator, null-conditional operator, auto-property initializers, static using,
    expression bodied methods and index initializers.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 6.0的新特性：字符串插值、异常过滤器、`NameOf`运算符、空条件运算符、自动属性初始化器、静态using、表达式主体方法和索引初始化器。
- en: 'News in C# 7.0: Binary Literals, Digit Separators, Local Functions, Type switch,
    Ref Returns, Tuples, Out var, Pattern Matching, Arbitrary async returns and Records.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 7.0的新特性：二进制字面量、数字分隔符、局部函数、类型切换、引用返回、元组、Out var、模式匹配、任意异步返回和记录。
- en: C# 4 and .NET framework 4.0
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 4和.NET框架4.0
- en: 'With the release of Visual Studio 2010, new versions of the framework showed
    up, although that was the last time they were aligned (to date). C# 5.0 is linked
    to Visual Studio 2012 and .NET framework 4.5, and C# 6, appeared in Visual Studio
    2015 and was related to a new (not too big) review of .NET framework: 4.6\. The
    same happens to C#7, although this is aligned with Visual Studio 2017.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Visual Studio 2010的发布，框架的新版本出现了，尽管那是它们最后一次对齐（截至目前）。C# 5.0与Visual Studio 2012和.NET框架4.5相关联，C#
    6在Visual Studio 2015中出现，并与.NET框架的新（不是很大）审查相关：4.6。C# 7的情况也是如此，尽管它与Visual Studio
    2017对齐。
- en: 'Just to clarify things, I''m including a table that shows the whole evolution
    of the language and the frameworks aligned to them along with the main features
    and the corresponding version of Visual Studio:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清问题，我包括了一个表格，展示了语言及其框架的整个演变过程，包括主要特性和相应的Visual Studio版本：
- en: '| C# version | .NET version | Visual Studio | Main features |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| C#版本 | .NET版本 | Visual Studio | 主要特性 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| C# 1.0 | .NET 1.0 | V. S. 2002 | Initial |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| C# 1.0 | .NET 1.0 | V. S. 2002 | 初始版本 |'
- en: '| C# 1.2 | .NET 1.1 | V. S. 2003 | Minor features and fixes. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| C# 1.2 | .NET 1.1 | V. S. 2003 | 小特性和修复。|'
- en: '| C# 2.0 | .NET 2.0 | V. S. 2005 | Generics, anonymous methods, nullable types,
    iterator blocks. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| C# 2.0 | .NET 2.0 | V. S. 2005 | 泛型、匿名方法、可空类型、迭代器块。|'
- en: '| C# 3.0 | .NET 3.5 | V. S. 2008 | Anonymous types, var declarations (implicit
    typing), lambdas, extension methods, LINQ, expression trees. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| C# 3.0 | .NET 3.5 | V. S. 2008 | 匿名类型、var声明（隐式类型）、lambda表达式、扩展方法、LINQ、表达式树。|'
- en: '| C# 4.0 | .NET 4.0 | V. S. 2010 | Delegate and interface generic variance,
    dynamic declarations, argument improvements, tuples, lazy instantiation of objects.
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| C# 4.0 | .NET 4.0 | V. S. 2010 | 委托和接口泛型方差、动态声明、参数改进、元组、对象的延迟实例化。|'
- en: '| C# 5.0 | .NET 4.5 | V. S. 2012 | Async/await for asynchronous programming
    and some other minor changes. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| C# 5.0 | .NET 4.5 | V. S. 2012 | 异步编程的Async/await和一些其他小改动。|'
- en: '| C# 6.0 | .NET 4.6 | V. S. 2015 | Roslyn services and a number of syntax simplification
    features. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| C# 6.0 | .NET 4.6 | V. S. 2015 | Roslyn服务以及一系列语法简化特性。|'
- en: '| C# 7.0 | .NET 4.6 | V. S. 2017 | Syntatic "sugar", extended support for tuples,
    Pattern Matching, and some minor features. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| C# 7.0 | .NET 4.6 | V. S. 2017 | 语法糖，对元组的扩展支持，模式匹配和一些小特性。|'
- en: '*Table 1: Alignment of C#, .NET, and Visual Studio versions*'
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*表1：C#、.NET和Visual Studio版本的对齐*'
- en: So, let's start with delegate and interface generic variance, usually called
    covariance and contravariance.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从委托和接口泛型方差开始，通常称为协变和逆协变。
- en: Covariance and contravariance
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协变和逆协变
- en: As more developers adopted the previous techniques shown in [Chapter 2](part0018.xhtml#aid-H5A41
    "Chapter 2. Core Concepts of C# and .NET"), *Core Concepts of C# and .NET*, new
    necessities came up and new mechanisms appeared to provide flexibility were required.
    It's here where some already well-known principles will apply (there were theoretical
    and practical approaches of compilers and authors, such as Bertrand Meyer).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 随着越来越多的开发者采用了[第2章](part0018.xhtml#aid-H5A41 "第2章。C#和.NET的核心概念")中展示的先前技术，新的需求出现了，需要新的机制来提供灵活性。正是在这里，一些已经众所周知的原则将适用（有关于编译器和作者的理論和实际方法，例如Bertrand
    Meyer）。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Luca Cardelli* explains as far back as in 1984 the concept of variant in OOP
    (refer to *A semantics of multiple inheritance* by Luca Cardelli ([http://lucacardelli.name/Papers/Inheritance%20(Semantics%20of%20Data%20Types).pdf](http://lucacardelli.name/Papers/Inheritance%20(Semantics%20of%20Data%20Types).pdf)).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*Luca Cardelli* 从1984年就开始解释面向对象编程（OOP）中的变体概念（参见Luca Cardelli的*《多重继承的语义》*，[http://lucacardelli.name/Papers/Inheritance%20(Semantics%20of%20Data%20Types).pdf](http://lucacardelli.name/Papers/Inheritance%20(Semantics%20of%20Data%20Types).pdf)）。'
- en: Meyer referred to the need for generic types in the article *Static Typing*
    back in 1995 (also available at [http://se.ethz.ch/~meyer/publications/acm/typing.pdf](http://se.ethz.ch/~meyer/publications/acm/typing.pdf)),
    indicating that *for safety, flexibility, and efficiency, the proper combination*
    (he's talking about static and dynamic features in a language) *is, I believe,
    static typing and dynamic binding*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Meyer在1995年的文章*《静态类型》*中提到了对泛型类型的需求（也可在[http://se.ethz.ch/~meyer/publications/acm/typing.pdf](http://se.ethz.ch/~meyer/publications/acm/typing.pdf)找到），指出*为了安全、灵活和高效，适当的组合*（他谈论的是语言中的静态和动态特性）*我认为是静态类型和动态绑定*。
- en: 'In other seminal work, nowadays widely used, *ACM A.M. Turing Award* winner
    *Barbara Liskov* published his famous *Substitution Principle*, which states that:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他具有开创性意义的工作中，如今广泛使用，ACM A.M. Turing Award获奖者*Barbara Liskov*发表了其著名的*替换原则*，该原则指出：
- en: '"In a computer program, if S is a subtype of T, then objects of type T may
    be replaced with objects of type S (i.e., objects of type S may substitute objects
    of type T) without altering any of the desirable properties of that program (correctness,
    task performed, etc.)."'
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “在计算机程序中，如果S是T的子类型，那么T类型的对象可以被S类型的对象替换（即，S类型的对象可以替代T类型的对象），而不会改变该程序的所有期望属性（正确性、执行的任务等）。”
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some ideas about covariance and contra-variance are explained in an excellent
    explanation published by Prof. Miguel Katrib and Mario del Valle in the already
    extinct *dotNetMania* magazine. However, you can find it (in Spanish) at [https://issuu.com/pacomarin3/docs/dnm_062](https://issuu.com/pacomarin3/docs/dnm_062).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 关于协变和逆协变的某些想法在由Miguel Katrib教授和Mario del Valle在已经停刊的*dotNetMania*杂志上发表的出色解释中得到了解释。然而，你可以在[https://issuu.com/pacomarin3/docs/dnm_062](https://issuu.com/pacomarin3/docs/dnm_062)（西班牙语）中找到它。
- en: 'In short, this means that if we have a type, `Polygon`, and two subtypes, `Triangle`
    and `Rectangle`, which inherit from the former, the following actions are valid:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这意味着如果我们有一个类型，`Polygon`，以及两个继承自前者的子类型，`Triangle`和`Rectangle`，以下操作是有效的：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The concept of variance is related to situations where you can use classes,
    interfaces, methods, and delegates defined over a type `T` instead of the corresponding
    elements defined over a subtype or super-type of `T`. In other words, if `C<T>`
    is a generic entity of type `T`, can I substitute it for another of type `C<T1>`
    or `C<ST>`, `T1` being a subtype of `T` and `ST` a super-type of `T`?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的概念与以下情况相关，即你可以使用在类型`T`上定义的类、接口、方法和委托，而不是在`T`的子类型或超类型上定义的相应元素。换句话说，如果`C<T>`是类型`T`的泛型实体，我能用另一个类型的`C<T1>`或`C<ST>`来替换它吗？其中`T1`是`T`的子类型，`ST`是`T`的超类型。
- en: Note that in the proposal, basically, the question arises where can I apply
    Liskov's substitution principle and expect correct behavior?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在提案中，基本上，问题出现在哪里我可以应用Liskov替换原则并期望得到正确的行为？
- en: This capability of some languages is called (depending on the direction of the
    inheritance) covariance for the subtypes, and its counterpart, contravariance.
    These two features are absolutely linked to parametric polymorphism, that is,
    generics.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种某些语言的能力被称为（根据继承的方向）子类型的协变和其对立面逆协变。这两个特性与参数多态性绝对相关，即泛型。
- en: 'In versions 2.0 and 3.0 of the language, these features were not present. If
    we write the following code in any of these versions, we will not even get to
    compile it, since the editor itself will notify us about the problem:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在语言的 2.0 和 3.0 版本中，这些功能并不存在。如果我们在这任何版本中编写以下代码，甚至无法编译它，因为编辑器本身会通知我们问题：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Even before compiling, we will be advised that it''s not possible to convert
    a triangle into a polygon, as shown in the following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至在编译之前，我们就会收到通知，无法将三角形转换为多边形，如下面的截图所示：
- en: '![Covariance and contravariance](img/image00454.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![协变和逆变](img/image00454.jpeg)'
- en: 'In the previous example, the solution is easy when we use C# 4.0 or higher:
    we can convert the `triangles` assignment to `List<Polygon>` by calling the generic
    type converter for `List` just by adding a simple call:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，当我们使用 C# 4.0 或更高版本时，解决方案很简单：我们可以通过调用 `List` 的泛型类型转换器，只需添加一个简单的调用，将 `triangles`
    赋值转换为 `List<Polygon>`：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, LINQ extensions come to our rescue, since several converters were
    added to collections in order to provide them with these type of convenient manipulations,
    which simplify the use object's hierarchies in a coherent manner.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，LINQ 扩展为我们提供了帮助，因为已经向集合中添加了几个转换器，以便提供这种方便的操作，这简化了以连贯方式使用对象层次结构。
- en: Covariance in interfaces
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接口中的协变
- en: 'Consider this code, where we change the defined polygons identifier as type
    `IEnumerable<Polygon>`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，其中我们更改定义的多边形标识符为类型 `IEnumerable<Polygon>`：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This doesn''t lead to a compilation error because the same ideas are applied
    to interfaces. To allow this, the generic parameter of interfaces such as `IEnumerable<T>`
    is used only as an out value. In such cases, it''s interesting to take a look
    at the definition using the **Peek Definition** option (available on the editor''s
    context menu for any type):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会导致编译错误，因为相同的想法也应用于接口。为了允许这样做，接口的泛型参数，如 `IEnumerable<T>`，仅用作输出值。在这种情况下，查看定义时使用
    **Peek Definition** 选项（在编辑器的上下文菜单中可用于任何类型）是很有趣的：
- en: '![Covariance in interfaces](img/image00455.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![接口中的协变](img/image00455.jpeg)'
- en: In turn, the `IEnumerable` interface only defines the `GetEnumerator` method
    in order to return an iteration mechanism to go through a collection of `T` types.
    It's only used to return `T` by means of the `Current` property and nothing else.
    So, there's no danger of the possible manipulation of elements in an incorrect
    manner.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`IEnumerable` 接口仅定义了 `GetEnumerator` 方法，以便返回一个遍历 `T` 类型集合的迭代机制。它仅通过 `Current`
    属性返回 `T`，没有其他操作。因此，不存在以错误方式操作元素的风险。
- en: In other words, according to our example, there's no way you can use an object
    of type `T` and place a rectangle where a triangle is expected because the interface
    specifies that `T` is used only in an exit context; it's used as a return type.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，根据我们的例子，你无法使用类型为 `T` 的对象，在期望三角形的地方放置一个矩形，因为接口指定 `T` 只能在退出上下文中使用；它用作返回类型。
- en: 'You can see the definition of this in Object Browser, asking for `IEnumerator<T>`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Object Browser 中看到这个定义，要求 `IEnumerator<T>`：
- en: '![Covariance in interfaces](img/image00456.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![接口中的协变](img/image00456.jpeg)'
- en: 'It''s not the same situation, though, when you use another interface, such
    as `IList`, which allows the user to change a type once it is assigned in the
    collection. For instance, the following code generates a compilation error:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你使用另一个接口，如 `IList`，它允许用户在集合中分配后更改类型时，情况就不同了。例如，以下代码会生成编译错误：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the code is just the same as earlier, only changing the type
    of generic interface used for the `polygons3` assignment. Why? Because the definition
    of `IList` includes an indexer that you could use to change the internal value,
    as Object Explorer shows.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码与之前相同，只是更改了用于 `polygons3` 赋值的泛型接口类型。为什么？因为 `IList` 的定义包括一个索引器，你可以用它来更改内部值，如
    Object Explorer 所示。
- en: 'Like any other indexer, the implementation provides a way to change a value
    in the collection by a direct assignment. This means that we can write this code
    to provoke a breach in the hierarchy of classes:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他索引器一样，实现提供了一种通过直接赋值来更改集合中值的方法。这意味着我们可以编写以下代码来引发类层次结构的破坏：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Notice the definition of interface `IList<T>`: `this[int]` is read/write, as
    the next capture shows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意接口 `IList<T>` 的定义：`this[int]` 是读写，如以下捕获所示：
- en: '![Covariance in interfaces](img/image00457.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![接口中的协变](img/image00457.jpeg)'
- en: This is due to the ability to set an item in the collection to another value
    once it is created, as we can see in the preceding screenshot.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为一旦创建集合中的项，就可以将其设置为另一个值，正如我们可以在前面的截图中所看到的。
- en: It's worth noting that this `out` specification is only applicable when using
    the interface. `Types` derived from `IEnumerable<T>` (or any other interface that
    defines an `out` generic parameter) are not obliged to fulfill this requirement.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，此 `out` 指定仅在使用接口时适用。从 `IEnumerable<T>`（或任何定义了 `out` 泛型参数的其他接口）派生的 `Types`
    不必满足此要求。
- en: Furthermore, this covariance is only applicable to reference types when using
    references' conversion statements. That's the reason why we cannot assign `IEnumerable<int>`
    to `IEnumerable<object>`; such conversion implies boxing (the heap and the stack
    are implicated), so it's not a pure reference conversion.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，此协变仅在使用引用的转换语句时适用于引用类型。这就是为什么我们不能将 `IEnumerable<int>` 赋值给 `IEnumerable<object>`；这种转换意味着装箱（堆和栈都受到影响），因此它不是一个纯引用转换。
- en: Covariance in generic types
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泛型类型中的协变
- en: Covariance can be extended to generic types and used with predefined delegates
    (remember, those delegates supplied by the Framework Factory that can be of types
    `Action`, `Predicate`, and `Func`).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 协变可以扩展到泛型类型，并与预定义的委托一起使用（记住，这些由框架工厂提供的委托可以是 `Action`、`Predicate` 和 `Func` 类型）。
- en: 'To place a simple code that shows this feature, observe the following declaration:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要放置一个展示此功能的简单代码，请观察以下声明：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we''re assigning a list of delegates of type `Rectangle` to an enumerable
    of delegates of type `Polygon`. This is possible because three characteristics
    play their role:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将类型为 `Rectangle` 的委托列表赋值给类型为 `Polygon` 的可枚举委托。这是可能的，因为三个特性发挥了作用：
- en: '`Rectangle` is assignable to `Polygon` for Substitution Principle'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据替换原则，`Rectangle` 可以赋值给 `Polygon`。
- en: '`Func<Rectangle>` is assignable to `Func<Polygon>` due to covariance in the
    generic `out T` parameter of `Func<T>`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 `Func<T>` 的泛型 `out T` 参数中的协变，`Func<Rectangle>` 可以赋值给 `Func<Polygon>`。
- en: Finally, `IEnumerable<Func<Rectangle>>` is assignable to `IEnumerable<Func<Polygon>>`
    due to a covariance extension over the generic type `out T` of `IEnumerable`
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，由于 `IEnumerable<Func<Rectangle>>` 可以赋值给 `IEnumerable<Func<Polygon>>`，这是由于
    `IEnumerable` 的泛型类型 `out T` 的协变扩展。
- en: Note that the mentioned Substitution Principle should not be mistaken with the
    convertible character of some types (especially, primitive or basic types).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，提到的替换原则不应与某些类型（特别是原始或基本类型）的可转换性混淆。
- en: 'To illustrate this feature, just think of the following definitions:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个特性，只需考虑以下定义：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The second sentence generates a compilation error because although there is
    an implicit conversion from `int` to `double`, such conversion is considered for
    covariance, since this is only applicable to inheritance relations between types,
    and that is not the case with `int` and `double` types because none of them inherits
    from the other.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第二句话会生成编译错误，因为尽管存在从 `int` 到 `double` 的隐式转换，但这种转换被认为是协变的，因为这只适用于类型之间的继承关系，而 `int`
    和 `double` 类型之间没有继承关系，因为它们都不继承自对方。
- en: Covariance in LINQ
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LINQ 中的协变
- en: Another situation in which covariance is important shows up when using some
    of the operators defined by the LINQ syntax. This happens, for instance, with
    the `Union` operator.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 协变在以下情况下也很重要，即使用 LINQ 语法定义的一些运算符。例如，这种情况出现在 `Union` 运算符中。
- en: 'In previous versions, consider that you try to code something like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的版本中，考虑你尝试编写如下代码：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you code something like the preceding code, you will get a compilation error,
    which doesn't happen from version 4.0 onward. This is because in the renewed definition,
    parameters of operator `Union` use the mentioned covariance, since they are of
    type `IEnumerable<T>`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写类似于前面的代码，你会得到一个编译错误，但从版本 4.0 开始就不会发生这种情况。这是因为在新定义中，运算符 `Union` 的参数使用了提到的协变，因为它们是
    `IEnumerable<T>` 类型。
- en: 'However, it''s not possible to compile something like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不可能编译如下代码：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is because the compiler indicates that there's no definition of `Union`
    and the best method overload, `Queryable.Union<Program.Rectangle> (IQueryable<Program.Rectangle>,
    IEnumerable<Program.Rectangle>)`, requires a receiver of type `IQueryable<Program.Rectangle>`,
    as shown in the upcoming screenshot.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为编译器指示没有 `Union` 的定义，最佳方法重载 `Queryable.Union<Program.Rectangle> (IQueryable<Program.Rectangle>,
    IEnumerable<Program.Rectangle>)` 需要一个类型为 `IQueryable<Program.Rectangle>` 的接收者，如即将显示的截图所示。
- en: 'This can be avoided this time by means of helping the compiler understand our
    purpose via generics:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这次可以通过帮助编译器理解我们的目的来避免这种情况，通过泛型：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Observe the way in which the **Error List** window describes the error, justifying
    it in terms of proper source code elements and their definitions and capabilities
    (see the following screenshot):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 观察一下**错误列表**窗口如何描述错误，它从适当的源代码元素及其定义和能力方面进行解释（见以下截图）：
- en: '![Covariance in LINQ](img/image00458.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![LINQ中的协方差](img/image00458.jpeg)'
- en: Contravariance
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逆变
- en: The case of contravariance is different and usually a bit more difficult to
    understand. To comprehend things through a known example, let's remember the `IComparer<T>`
    interface that we used in the previous chapter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 逆变的情况不同，通常理解起来也稍微困难一些。为了通过一个已知的例子来理解事物，让我们回忆一下我们在上一章中使用的`IComparer<T>`接口。
- en: 'We used an implementation of `IComparer<T>` to compare collections of types
    `Customer` and `Provider` indistinctly:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`IComparer<T>`的实现来无区别地比较`Customer`和`Provider`类型的集合：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this way, we can compare both types as long as the `Customer` and `Provider`
    classes implement the `IPersonBalance` interface.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，只要`Customer`和`Provider`类实现了`IPersonBalance`接口，我们就可以比较这两种类型。
- en: 'In previous (to C# 4.0) versions of the language, consider that you tried to
    use a similar code to compare polygons and triangles, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在语言之前的（到C# 4.0）版本中，考虑一下你尝试使用类似的代码来比较多边形和三角形的情况，如下所示：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You will then get an error indicating the usual: there''s no conversion between
    `Triangle` and `Polygon`, while there''s really no risk in receiving these types
    since no change will happen; they will only be used to compare the entities.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到一个错误提示，通常是这样的：`Triangle`和`Polygon`之间没有转换，而实际上接收这些类型真的没有风险；它们只会被用来比较实体。
- en: In this case, the inheritance arrow goes upside down—from the specific to the
    generic—and since both are of type `Polygon`, the comparison should be possible.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，继承箭头是倒置的——从具体到泛型——并且由于两者都是`Polygon`类型，比较应该是可能的。
- en: 'Starting from version 4.0 of C#, this was changed. The new definition of the
    `IComparer` interface defines another `in` modifier for the `T` operator, using
    the **Peek Definition** feature when you right-click on the declaration:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 4.0版本开始，这发生了变化。`IComparer`接口的新定义为`T`操作符定义了另一个`in`修饰符，当你在声明上右键单击时使用**预览定义**功能：
- en: '![Contravariance](img/image00459.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![逆变](img/image00459.jpeg)'
- en: 'As you can see, the definition indicates that parameter `T` is contravariant:
    you can use the type you specified or any type that is less derived, that is,
    any antecessor of the type in the inheritance chain.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，定义表明参数`T`是逆变的：您可以使用指定的类型或任何更少派生的类型，即继承链中的任何祖先类型。
- en: In this case, the `in` modifier specifies this possibility and indicates to
    the compiler that type `T` can only be used in entry contexts, such as what happens
    here because the purpose of `T` is to specify the type of entry arguments `x`
    and `y`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`in`修饰符指定了这个可能性，并指示编译器类型`T`只能用于入口上下文，如这里发生的情况，因为`T`的目的就是指定入口参数`x`和`y`的类型。
- en: 'Tuples: a remembrance'
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组：一个回忆
- en: 'From very early times, programming languages try to express the idea of tuples,
    first embodied in the COBOL language. Later, Pascal followed it up with the concept
    of record: a special type of data structure that, unlike arrays, collects data
    types of different natures in order to define a particular structure, such as
    a customer or a product.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从很早的时候起，编程语言就试图表达元组的概念，首先体现在COBOL语言中。后来，Pascal通过记录的概念跟进：一种特殊的数据结构，与数组不同，它收集不同性质的数据类型，以便定义特定的结构，例如客户或产品。
- en: Let's also remember that the C language itself provided structures (structs)
    enhanced into objects in the C++ evolution. Usually, every field of this structure
    represents a characteristic of the whole, so it makes more sense to access its
    value through a meaningful description instead of using its position (like in
    arrays).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们记住，C语言本身在C++的发展过程中提供了结构（structs），这些结构被增强为对象。通常，这个结构的每个字段都代表整体的一个特征，因此通过一个有意义的描述来访问其值比使用其位置（如数组中那样）更有意义。
- en: 'This idea was also related to the database relational model, so it was particularly
    suitable to represent these entities. With objects, functionalities are added
    to recreate fragments of real object properties that are required to be represented
    in an application: the object model.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法也与数据库的关系模型相关，因此特别适合表示这些实体。使用对象，可以添加功能来重新创建需要在应用程序中表示的真实对象属性片段：对象模型。
- en: Then, in the interest of reusability and adaptability, OOP started promoting
    objects to hide parts of its state (or the whole state) as a means to preserve
    its internal coherence. *Methods of a class should only have the purpose of maintaining
    the internal logic of its own state*, said a theoretician at the beginning of
    an OOP class in a well-known university whose name I don't want to remember. We
    can admit that, exceptions aside, this assertion is true.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了提高可重用性和适应性，面向对象编程开始推广对象，以隐藏其状态的一部分（或全部状态）作为保持其内部一致性的手段。一位在知名大学开设面向对象编程课程的理论家说：“类的方法应该只具有维护其自身状态内部逻辑的目的”，我不记得这位理论家的名字。我们可以承认，除了例外情况，这个说法是正确的。
- en: If there are parts of the state that can be abstracted (in math terms, you could
    say that they constitute a pattern), they are candidates for a higher class (abstract
    or not), so reusability starts with these common factors.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态的一部分可以被抽象化（用数学术语来说，可以说它们构成一个模式），那么它们就是更高类（抽象或不抽象）的候选者，因此可重用性从这些共同因素开始。
- en: Along this evolution, the concept of tuple got lost in a way, ceding all the
    land to the concept of object, and programming languages (with some notable exceptions,
    mainly in the area of functional languages) ceased to have their own notation
    in order to work with tuples.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演变过程中，元组的概念在某种程度上丢失了，所有的土地都让给了对象的概念，编程语言（除了一些值得注意的例外，主要在函数式语言领域）不再有它们自己的符号来处理元组。
- en: However, practice has shown that not all work with data requires the wearing
    of uniform objects. Perhaps one of the most obvious situations shows up when querying
    data from a database—the way we've seen in LINQ queries. Once the filtered data
    meets certain requirements, we only need some components (which is known as a
    projection in the jargon of databases, as we've tested in previous examples).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实践表明，并非所有与数据相关的工作都需要使用统一的对象。也许最明显的情况出现在从数据库查询数据时——正如我们在LINQ查询中看到的那样。一旦过滤后的数据满足某些要求，我们只需要一些组件（这在数据库术语中被称为投影，正如我们在前面的例子中所测试的那样）。
- en: This projections are nothing but anonymous objects, which don't deserve to be
    predefined, since they're usually handled in a single procedure.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这些投影不过是匿名对象，它们不值得预先定义，因为它们通常在单个过程中处理。
- en: 'Tuples: implementation in C#'
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组：C#中的实现
- en: The implementation of tuples in .NET 4 is based on the definition (`mscorlib.dll`
    assembly and the `System` namespace) of eight generic classes `Tuple<>` with different
    number of type parameters to represent tuples of different cardinalities (it's
    also called arity).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 4中元组的实现基于八个泛型类`Tuple<>`的定义（`mscorlib.dll`程序集和`System`命名空间），这些类具有不同数量的类型参数，用于表示不同基数（也称为arity）的元组。
- en: As a complement to this family of generic classes, eight overloads of the `Create`
    method in the `Tuple` class are provided, converting it into a factory of many
    possible variations of these types. In order to deliver resources for the creation
    of longer tuples, the eighth tuple in the list can also be a tuple itself, allowing
    it to grow as required.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个泛型类家族的补充，`Tuple`类提供了`Create`方法的八个重载，将其转换为一个多种可能变体的工厂。为了提供创建更长的元组所需资源，列表中的第八个元组本身也可以是一个元组，允许它按需增长。
- en: 'The following code shows the implementation of one of these methods. Thus,
    to create tuples, we can take advantage of a more concise notation and write this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了这些方法之一的具体实现。因此，为了创建元组，我们可以利用更简洁的表示法，并编写如下：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We''ll discover how the Intellisense system of Visual Studio warns us about
    the structure generated by this declaration and how it is interpreted by the editor:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将发现Visual Studio的Intellisense系统如何警告我们关于由这种声明生成的结构，以及它是如何被编辑器解释的：
- en: '![Tuples: implementation in C#](img/image00460.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![元组：C#中的实现](img/image00460.jpeg)'
- en: 'So, we can express it in this simple way instead of using the following, more
    explicit code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以用这种方式简单地表达，而不是使用以下更明确的代码：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Since tuples can hold elements of any kind, it is alright to declare a tuple
    of a variety of types:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于元组可以持有任何类型的元素，因此声明一个多种类型的元组是完全可以的：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is similar to what we would do when defining the elements of an object''s
    state, and we can be sure that the compiler will infer its different types, as
    shown in the following screenshot:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于我们定义对象状态元素时所做的，我们可以确信编译器将推断出其不同的类型，如下面的屏幕截图所示：
- en: '![Tuples: implementation in C#](img/image00461.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![元组：C# 中的实现](img/image00461.jpeg)'
- en: This usage becomes obvious when comparing it with a typical record in the database's
    table, with the ability of vertically selecting the members (fields, if you want)
    that we need. We're going to see an example of comparing tuples with anonymous
    types.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当与数据库表中典型的记录进行比较时，这种用法变得明显，因为它能够垂直选择我们需要的成员（字段，如果你愿意），我们将看到比较元组与匿名类型的一个示例。
- en: 'Tuples: support for structural equality'
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组：支持结构相等性
- en: With the tuples .NET classes (and, therefore, their bodies treated by reference),
    comparing two tuples with the `==` operator is referential; that is, it relies
    on memory addresses where the compared objects reside; therefore, it returns `false`
    for two different objects-tuples even if they store identical values.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 .NET 的元组类（因此，它们的主体通过引用处理），使用 `==` 操作符比较两个元组是引用性的；也就是说，它依赖于比较对象所在的内存地址；因此，即使它们存储了相同的数据，也会返回
    `false`。
- en: However, the `Equals` method has been redefined in order to establish equality
    based on the comparison of the values of each pair of corresponding elements (the
    so-called structural equality), which is desired in most tuple's applications
    and which is also the default semantics for the comparison of tuples' equality
    in the F# language.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Equals` 方法已被重新定义，以便根据比较每一对对应元素的值（所谓的结构相等性）来建立相等性，这在大多数元组应用中是期望的，并且在 F# 语言中比较元组相等性的默认语义也是这样的。
- en: Note that the implementation of structural equality for tuples has its peculiarities,
    starting with the fact that tuples with a tupled eighth member have to be accessed
    in a recursive manner.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，元组的结构相等性实现有其特殊性，首先是从具有元组第八成员的元组必须以递归方式访问的事实开始。
- en: Tuples versus anonymous types
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组与匿名类型
- en: For the case of projections, tuples adapt perfectly and allow us to get rid
    of anonymous types. Imagine that we want to list three fields of a given `Customers`
    table (say, their `Code`, `Name`, and `Balance` fields from dozens of possible
    fields), and we need to filter them by their `City` field.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于投影的情况，元组适应得很好，并允许我们摆脱匿名类型。想象一下，我们想要列出给定 `Customers` 表的三个字段（比如说，从可能的数十个字段中选择它们的
    `Code`、`Name` 和 `Balance` 字段），并且我们需要通过它们的 `City` 字段进行过滤。
- en: 'If we assume that we have a collection of customers named `Customers`, it''s
    easier to write a method in this manner:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设我们有一个名为 `Customers` 的客户集合，以这种方式编写方法更容易：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So, the method returns `IEnumerable<Tuple<int, string, double>>`, which we can
    refer where required, having extra support from the Intellisense engine and making
    it very easy to iterate and present in the output.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，该方法返回 `IEnumerable<Tuple<int, string, double>>`，我们可以在需要时引用它，并从 Intellisense
    引擎获得额外支持，这使得迭代和输出非常容易。
- en: 'To test this feature, I''ve generated a random name list from the site ([http://random-name-generator.info/](http://random-name-generator.info/))
    named `ListOfNames.txt` in order to have a list of random customer names, and
    I have populated the rest of fields with random values so that we have a list
    of customers based on the following class:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个功能，我从网站（[http://random-name-generator.info/](http://random-name-generator.info/)）生成了一份随机名称列表，命名为
    `ListOfNames.txt`，以便有一个随机客户名称列表，并且我用随机值填充了其余字段，以便我们有一个基于以下类的客户列表：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are quite a lot of random name generators you can find on the Internet,
    besides the ones mentioned previously. You can just configure them (they allow
    a certain degree of tuning) and save the results in a text file within Visual
    Studio. Only, remember that the copy and paste operation will most likely include
    a Tab code (`\t`) separator.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前提到的那些，你可以在互联网上找到相当多的随机名称生成器。你只需配置它们（它们允许一定程度的调整）并将结果保存到 Visual Studio 中的文本文件中。只是记住，复制粘贴操作很可能会包含制表符代码（`\t`）分隔符。
- en: 'In the `TuplesDemo` class, which holds the entry point, the following code
    is defined:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含入口点的 `TuplesDemo` 类中，定义了以下代码：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With this structure, everything works fine, and there''s no need to use anonymous
    objects, as we can see in the Console output:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种结构，一切正常，我们不需要使用匿名对象，正如我们在控制台输出中看到的那样：
- en: '![Tuples versus anonymous types](img/image00462.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![元组与匿名类型](img/image00462.jpeg)'
- en: The only imperfection comes from the way we make references to `Balance` members,
    since they lose the type names, so we have to reference them by the identifiers
    `Item1`, `Item2`, and so on (this has been improved in version C# 7 where tuples'
    members can have identifiers).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的不完美之处在于我们引用`Balance`成员的方式，因为它们失去了类型名称，所以我们不得不通过标识符`Item1`、`Item2`等来引用它们（在C#
    7版本中已经得到了改进，元组的成员可以具有标识符）。
- en: But even so, this is an advantage with respect to the previous approach, and
    we have more control over the generated members coming out of the LINQ query.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 即使如此，这相对于之前的方法仍然是一个优点，并且我们对LINQ查询生成的成员有了更多的控制。
- en: Lazy initialization and instantiation
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒加载和实例化
- en: 'To finish this review on the most important features appearing in C# 4.0, I''d
    like to cover a new way of the instantiation of objects, named lazy initialization.
    The official documentation defines lazy objects and lazy initialization of an
    object, indicating that its creation is deferred until it is first used. (Note,
    here, that both terms are synonymous: initialization and instantiation).'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成对C# 4.0中出现的重要功能的回顾，我想介绍一种新的对象实例化方式，称为懒加载。官方文档定义了懒对象和对象的懒初始化，指出其创建被延迟到首次使用时。注意，这里两个术语是同义的：初始化和实例化。
- en: This reminds us that *Lazy initialization is primarily used to improve performance,
    avoid wasteful computation, and reduce program memory requirements*. Typically,
    this happens when you have an object that takes some time to create (like a connection)
    or, for any reason, might produce a bottleneck.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这提醒我们，*懒加载主要用于提高性能、避免浪费的计算和减少程序内存需求*。通常，这发生在您有一个需要一些时间来创建的对象（如连接）或由于任何原因可能会产生瓶颈的情况。
- en: Instead of creating the object in the usual way, .NET 4.0 introduces `Lazy<T>`,
    which defers the creation effectively, allowing evident performance improvements,
    as we'll see in the following demo.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与通常创建对象的方式不同，.NET 4.0引入了`Lazy<T>`，它有效地延迟了创建，从而允许明显的性能提升，我们将在以下演示中看到。
- en: 'Let''s use the previous code, but this time, we double the method for the creation
    of customers by adding a lazy version of it. To be able to prove it more accurately,
    we introduce a delay in the constructor of the `Customer` class, so it finally
    looks like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用之前的代码，但这次，我们通过添加一个懒加载版本的它来加倍创建客户的方法。为了更准确地证明这一点，我们在`Customer`类的构造函数中引入了延迟，所以它最终看起来是这样的：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note two main differences: first, the constructor forces a delay of a tenth
    of a second for every call. Second, the new way to create the `Customer` list
    (`getCustomersLazy`) is declared as `List<Lazy<Customer>>`. Besides, every call
    to the constructor comes from a lambda expression associated with the `Lazy<Customer>`
    constructor.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意两个主要差异：首先，构造函数强制每个调用延迟十分之一秒。其次，创建`Customer`列表的新方法（`getCustomersLazy`）被声明为`List<Lazy<Customer>>`。此外，每个对构造函数的调用都来自与`Lazy<Customer>`构造函数关联的lambda表达式。
- en: 'In the `Main` method, this time, we don''t need to present the results; we
    only need to present the time elapsed for the creation of `Customers` using both
    approaches. So, we modified it in the following way:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Main`方法中，这次，我们不需要展示结果；我们只需要展示使用两种方法创建`Customers`所花费的时间。因此，我们按照以下方式修改了它：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With these changes, the same class is called, and the same sentences are also
    used in creation, only changed to be lazy in the first creation process. By the
    way, you can change the order of creation (calling the non-lazy routine in the
    first place) and check whether there''s no meaningful change in performance: the
    lazy structure executes almost instantly (hardly some more than 100 milliseconds,
    which is the time forced by `Thread.Sleep(100)` in the initial creation of `Customer`).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，相同的类被调用，相同的句子也被用于创建，只是在第一次创建过程中改为懒加载。顺便说一句，您可以更改创建的顺序（首先调用非懒加载例程）并检查性能是否没有实质性变化：懒加载结构几乎立即执行（几乎没有超过100毫秒，这是在`Customer`的初始创建中由`Thread.Sleep(100)`强制的时间）。
- en: 'The difference, as you can see in the following screenshot, can be significant:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在以下屏幕截图中所见，这种差异可能是显著的：
- en: '![Lazy initialization and instantiation](img/image00463.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![懒加载和实例化](img/image00463.jpeg)'
- en: So, a new and useful solution for certain scenarios that appeared in version
    4.0 of the framework becomes especially interesting when delaying the creation
    of objects can produce big differences in time for the initial presentation of
    the data.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当延迟对象的创建可以在数据初始展示时产生很大的时间差异时，框架4.0版本中出现的新颖且有用的解决方案变得特别有趣。
- en: Dynamic programming
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态规划
- en: One of the most requested features by programmers was the ability to create
    and manipulate objects without the restrictions imposed by static typing, since
    there are many daily situations in which this possibility offers a lot of useful
    options.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员最请求的功能之一是能够在没有静态类型强加的限制下创建和操作对象，因为有许多日常情况中这种可能性提供了很多有用的选项。
- en: However, let's not mistake the dynamic features offered by C# 4.0 with the concept
    of Dynamic Programming in general computer science, in which the definition refers
    to the case where a problem is divided into smaller problems, and the optimal
    solution for each of these cases is sought, with the program being able to access
    each of these smaller solutions at a later time for optimal performance.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不要将C# 4.0提供的动态特性与计算机科学中的一般动态规划概念混淆，其中定义指的是将问题分解为更小的问题，并寻求每个这些情况的最佳解决方案，程序能够在稍后时间访问这些较小的解决方案以获得最佳性能。
- en: In the context of .NET Framework, though, C# 4.0 introduced a set of features
    linked to a new namespace (`System.Dynamic`) and a new reserved word, `dynamic`,
    which allows the declaration of elements that get rid of the type-checking feature
    we've seen so far.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在.NET Framework的背景下，C# 4.0引入了一系列与新的命名空间（`System.Dynamic`）和新的保留字`dynamic`相关的特性，这允许声明摆脱了我们迄今为止所见的类型检查功能的元素。
- en: Dynamic typing
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态类型
- en: 'Using the `dynamic` keyword, we can declare variables that are not checked
    in compilation time but can be resolved at runtime. For instance, we can write
    the following declaration without any problems (at the time of writing):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dynamic`关键字，我们可以声明在编译时未经检查但在运行时可以解决的变量。例如，我们可以写出以下声明而不会出现任何问题（在撰写本文时）：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this code, `o` has been declared in an static way as dynamic, which is a
    type supported by the compiler. This code compiles even without knowing what `UnknownMethod`
    means or whether it exists at execution time. If the method doesn''t exist, an
    exception will be thrown. Concretely, due the dynamic binding nature of the process,
    a `Microsoft.CSharp.RuntimeBinder.RuntimeBinderException` comes up, as we see
    when we misspell a call to the `ToUpper()` method in a string (we''ll explain
    the code snippet a bit later):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`o`被声明为静态的动态类型，这是编译器支持的一种类型。即使不知道`UnknownMethod`的含义或它在执行时是否存在，此代码也能编译。如果方法不存在，将抛出异常。具体来说，由于过程的动态绑定特性，会出现`Microsoft.CSharp.RuntimeBinder.RuntimeBinderException`异常，正如我们在拼写字符串中的`ToUpper()`方法调用时看到的那样（我们稍后会解释代码片段）：
- en: '![Dynamic typing](img/image00464.jpeg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![动态类型](img/image00464.jpeg)'
- en: 'When this kind of declaration appeared, there was some confusion related to
    the differences with declaring the previous sentence, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种声明出现时，与之前声明的差异引起了一些混淆，如下所示：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The difference here is that we have to know previously that a type `T` exists
    and it has a method called `UnknownMethod`. In this case, the casting operation
    ensures that an IL code is generated to guarantee that the `p` reference is conformant
    with the `T` type.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的不同之处在于我们必须事先知道存在一个类型`T`，并且它有一个名为`UnknownMethod`的方法。在这种情况下，类型转换操作确保生成IL代码以保证`p`引用符合`T`类型。
- en: In the first case, the compiler cannot emit the code to call `UnknownMethod`
    because it doesn't even know whether such a method exists. Instead, it emits a
    dynamic call, which will be handled by another, new execution engine called **Dynamic
    Language Runtime**, or **DLR**.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，编译器无法生成调用`UnknownMethod`的代码，因为它甚至不知道是否存在这样的方法。相反，它生成一个动态调用，这将由另一个新的执行引擎处理，称为**动态语言运行时**（**DLR**）。
- en: 'The role of DLR, among others, is also to infer the corresponding type, and
    from that point, treat dynamic objects accordingly:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: DLR（动态语言运行时）的作用之一也是推断相应的类型，并从那时起相应地处理动态对象：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'So, this that means we can not only use the value of `dyn`, but also its properties
    and methods like what the previous code shows, behaving in the way that''s expected,
    and showing that `dyn` is a type string object and presenting the results in Console,
    just as if we have declared `dyn` as `string` from the beginning:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这意味着我们不仅可以使用`dyn`的值，还可以像前面的代码所示，使用其属性和方法，以预期的行为表现，并显示`dyn`是一个类型字符串对象，并在控制台中展示结果，就像我们一开始就声明了`dyn`为`string`一样：
- en: '![Dynamic typing](img/image00465.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![动态类型](img/image00465.jpeg)'
- en: Perhaps you remember the reflection characteristics we mentioned in [Chapter
    1](part0015.xhtml#aid-E9OE2 "Chapter 1. Inside the CLR"), *Inside the CLR*, and
    are wondering why we need this if many of the features available in this manner
    can be also managed with reflection programming.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你还记得我们在[第1章](part0015.xhtml#aid-E9OE2 "第1章。CLR内部")中提到的反射特性，*CLR内部*，并且想知道为什么我们需要它，因为许多以这种方式可用的特性也可以通过反射编程来管理。
- en: 'To make a comparison, let''s quickly remember how this possibility would look
    like (let''s say we want to read the `Length` property):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行比较，让我们快速回顾一下这种可能性会是什么样子（比如说我们想要读取`Length`属性）：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For this scenario, we get the same output that we expect, and technically,
    the performance penalty is dismissible:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种场景，我们得到了我们预期的相同输出，并且从技术上讲，性能损失是可以忽略不计的：
- en: '![Dynamic typing](img/image00466.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![动态类型](img/image00466.jpeg)'
- en: It seems that both results are the same, although the way in which we get them
    is quite different. However, besides the boilerplate involved in reflection techniques,
    DLR is more efficient, and we also have the possibility of personalizing dynamic
    invocations.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来这两个结果是一样的，尽管我们得到它们的方式完全不同。然而，除了反射技术中涉及到的样板代码之外，DLR（动态语言运行时）更高效，我们还有可能个性化动态调用。
- en: 'It''s true that it might seem contradictory for experienced static typing programmers:
    we lose the Intellisense linked to it, and the dynamic keyword forces the editor
    behind to understand that methods and properties accompanying such types will
    present themselves as dynamic as well. Refer to the tooltip shown in the next
    screenshot:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有经验的静态类型程序员来说，这可能会显得有些矛盾：我们失去了与之关联的Intellisense，动态关键字迫使编辑器背后的理解，伴随此类类型的方法和属性也将以动态的方式呈现。请参考下一张截图所示的提示信息：
- en: '![Dynamic typing](img/image00467.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![动态类型](img/image00467.jpeg)'
- en: Part of the flexibility of this feature comes from the fact that any reference
    type can be converted into dynamic, and this can be done (via `Boxing`) with any
    value type.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特性的部分灵活性来自于任何引用类型都可以转换为动态类型，并且这可以通过（通过装箱）与任何值类型一起完成。
- en: However, once we have established our dynamic object to be of a type (such as
    `String`, in this case), the dynamism ends there. I mean, you cannot use other
    kinds of resources apart from those available in the definition of the `String`
    class.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦我们确定我们的动态对象为某种类型（例如，在本例中的`String`），动态性就到此为止。我的意思是，你不能使用除`String`类定义中可用的资源之外的其他类型的资源。
- en: The ExpandoObject object
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ExpandoObject`对象'
- en: One of the additions linked to this dynamic feature of the language is something
    called `ExpandoObject`, which—as you might have figured out by the name—allows
    you to expand an object with any number of properties of any type, keeping the
    compiler quiet and behaving in a similar way as it would happen when coding in
    real dynamic languages, such as JavaScript.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 与这种语言的动态特性相关联的添加之一是称为`ExpandoObject`的东西，正如你可能从其名称中推测出的那样——它允许你使用任何类型和任何数量的属性来扩展一个对象，让编译器保持安静，并以类似在真实动态语言（如JavaScript）中编码的方式表现。
- en: 'Let''s look at how we can use one of these `ExpandoObject` object to create
    an object that grows in a totally dynamic way:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用这些`ExpandoObject`对象之一来创建一个以完全动态的方式增长的对象：
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As the preceding code shows, it is not just that we can expand the object with
    new properties of the type we want; we can even nest objects inside each other.
    There''s no problem at runtime, as this screenshot shows in the Console output:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们不仅可以扩展对象以包含我们想要的类型的新属性；我们甚至可以在对象内部嵌套其他对象。正如这个截图在控制台输出中所示，在运行时没有问题：
- en: '![The ExpandoObject object](img/image00468.jpeg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![ExpandoObject对象](img/image00468.jpeg)'
- en: Actually, these dynamic features can be used in conjunction with other generic
    characteristics we've already seen, since the declaration of generic dynamic objects
    is also allowed in this context.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这些动态特性可以与我们已经看到的其他泛型特性结合使用，因为在此上下文中也允许声明泛型动态对象。
- en: 'To prove this, we can create a method that builds `ExpandoObjects` containing
    some information about Packt Publishing books:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，我们可以创建一个方法，该方法构建包含有关Packt Publishing书籍信息的`ExpandoObjects`：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that everything is declared as dynamic: the method itself and the arguments
    passed to it as well. Later on, we can use generic collections with these objects,
    as shown in the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一切都是动态声明的：方法本身以及传递给它的参数。稍后，我们可以使用泛型集合与这些对象一起使用，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Everything works as expected. Internally, `ExpandoObject` behaves like `Dictionary<string,
    object>`, where the name of the field added dynamically is the key (of type `String`),
    and the value is an object of any kind. So, in the previous code, the `Find` method
    of the `List` collection works correctly, finds the object we''re looking for,
    and retrieves the title to show it the console:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都按预期工作。内部，`ExpandoObject`表现得像`Dictionary<string, object>`，其中动态添加的字段名称是键（类型为`String`），值是任何类型的对象。因此，在前面的代码中，`List`集合的`Find`方法工作正常，找到我们正在寻找的对象，并检索标题以在控制台显示：
- en: '![The ExpandoObject object](img/image00469.jpeg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![The ExpandoObject object](img/image00469.jpeg)'
- en: There are some other dynamic features, but we will deal with some of them in
    the chapter dedicated to Interop, where we'll examine the possibilities of an
    interaction between a C# application and other applications in the OS, including
    Office applications and—generally speaking—any other application that implements
    and exposes a Type library.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他的动态特性，但我们将在这本关于互操作性的章节中处理其中的一些，我们将探讨C#应用程序与其他操作系统中的应用程序之间的交互可能性，包括Office应用程序以及通常所说的任何实现了并公开了类型库的其他应用程序。
- en: Optional and named parameters
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选和命名参数
- en: The declaration of optional parameters had been requested by programmers a long
    time ago, especially considering that it's a feature that was present in Visual
    Basic .NET since the beginning.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前，程序员就要求声明可选参数，特别是考虑到这是一个从Visual Basic .NET开始就存在的特性。
- en: 'The way the Redmond team implemented this is simple: you can define a constant
    value associated with a parameter as long as you locate the parameter at the end
    of the parameters'' list. Thus, we can define one of those methods in this way:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 红mond团队实现这种方式很简单：只要将参数定位在参数列表的末尾，就可以定义与参数关联的常量值。因此，我们可以以这种方式定义这些方法之一：
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Thus, optional parameters are characterized by being given an initial value.
    In this way, if the `RepeatStringOptional` method is called with only one argument,
    the `text` parameter is initialized with the passed value, so it will never be
    null. The IDE itself reminds us of such a situation when writing a call to the
    method.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可选参数的特点是赋予一个初始值。这样，如果只传递一个参数调用`RepeatStringOptional`方法，`text`参数将使用传递的值初始化，因此它永远不会为null。IDE本身在编写方法调用时提醒我们这种情况。
- en: '![Optional and named parameters](img/image00470.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![Optional and named parameters](img/image00470.jpeg)'
- en: Remember that by convention, any element enclosed in square brackets is considered
    optional in computer science definitions.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，按照惯例，在计算机科学定义中，任何括在方括号内的元素都被认为是可选的。
- en: 'As a variant of the previous feature, we can also provide an argument with
    name using the `function_name (name: arg)` syntax pattern. The same structural
    pattern of optional arguments is followed; that is, if we pass a named argument
    to a function, it has to be placed after any other positional argument, although
    within the named parameters section their relative order does not matter.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '作为之前特性的变体，我们还可以使用`function_name (name: arg)`语法模式提供一个带有名称的参数。遵循相同的可选参数结构模式；也就是说，如果我们向函数传递一个命名参数，它必须放在任何其他位置参数之后，尽管在命名参数部分它们的相对顺序并不重要。'
- en: The Task object and asynchronous calls
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Task对象和异步调用
- en: 'Although it is not part of the language itself, a **Base Class Library** (**BCL**)
    feature is worth mentioning in this chapter, as it is one of the most important
    innovations in this version of the framework. Up until this point, building and
    executing threads was something that was covered mainly in two forms: using the
    objects provided by the `System.Thread` namespace (available since version 1.0
    of the framework) and from version 3.0, using the `BackgroundWorker` object, which
    was a wrapper on top of a functionality available in `System.Thread` to facilitate
    the creation of these objects.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是语言本身的一部分，但本章中值得提及的一个**基类库**（**BCL**）功能是，它是框架本版本中最重要的创新之一。直到这一点，构建和执行线程主要涉及两种形式：使用`System.Thread`命名空间提供的对象（自框架版本1.0以来可用）和从版本3.0开始，使用`BackgroundWorker`对象，它是`System.Thread`中可用功能的一个包装，以简化这些对象的创建。
- en: The latter was primarily used in long duration processes, when a feedback was
    required during execution (progress bars, among others). It was a first attempt
    to ease thread programming, but since the new `Task` object came up, most of these
    scenarios (and many others, implying parallel or thread running processes) are
    mainly coded in this way.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 后者主要用于长时间运行的过程，在执行过程中需要反馈（进度条等）。这是第一次尝试简化线程编程，但自从新的`Task`对象出现以来，大多数这些场景（以及许多其他涉及并行或线程运行过程的情况）主要是以这种方式编写的。
- en: 'Its usage is simple (especially when compared to previous options). You can
    declare a `Task` non-generic object and associate it with any method with the
    help of an `Action` delegate, as the IDE suggests when creating a new task by
    calling its constructor:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 它的使用很简单（尤其是与之前的选项相比）。您可以使用`Action`委托将`Task`非泛型对象与任何方法关联起来，正如IDE在通过调用其构造函数创建新任务时建议的那样：
- en: '![The Task object and asynchronous calls](img/image00471.jpeg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![任务对象和异步调用](img/image00471.jpeg)'
- en: 'So, if we have a slow method and we have no special requirements about the
    type returned (so it can be non-generic), it''s possible to call it in a separate
    thread by writing the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们有一个慢速方法，并且我们没有对返回类型有特殊要求（因此它可以是非泛型的），我们可以通过编写以下代码在单独的线程中调用它：
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Note a few details in this code: first, the argument is passed by reference.
    This means that the value of `theString` is changed by `SlowMethod`, but no return
    type is provided because the method should fit the signature of an `Action` (no
    return type); thus, to access the modified value, we pass it by reference and
    include in our `SlowMethod` code how to modify it.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下代码中的几个细节：首先，参数是通过引用传递的。这意味着`theString`的值会被`SlowMethod`改变，但由于该方法应该符合`Action`的签名（没有返回类型），因此没有提供返回类型；因此，为了访问修改后的值，我们需要通过引用传递，并在我们的`SlowMethod`代码中包含如何修改它的方法。
- en: The other main point is that we need to wait until `SlowMethod` finishes before
    trying to access `theString` (observe that the method is forced to take 3 seconds
    to complete by calling `Thread.Sleep(3000)`. Otherwise, execution would continue
    and the value accessed would be just the original empty string. In between, it's
    possible to perform other actions, such as printing a message in the console.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个主要点是，我们需要等待`SlowMethod`完成后再尝试访问`theString`（注意，方法通过调用`Thread.Sleep(3000)`被强制执行3秒钟以完成。否则，执行将继续，访问的值将是原始的空字符串。在此期间，可以执行其他操作，例如在控制台打印消息。
- en: 'A generic variation of this object is also provided when we need `Task` to
    operate with a given type. As long as we define a variable of type `Task<T>`,
    the IDE changes the tooltip to remind us that in this case, a delegate of type
    `Func<T>` should be provided instead of `Action`, as is the case. You can compare
    this screenshot with the previous one:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要`Task`与给定类型一起操作时，也提供了该对象的泛型变体。只要我们定义一个`Task<T>`类型的变量，IDE就会更改工具提示以提醒我们，在这种情况下，应该提供`Func<T>`类型的委托而不是`Action`，正如情况所示。您可以比较此截图与之前的截图：
- en: '![The Task object and asynchronous calls](img/image00472.jpeg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![任务对象和异步调用](img/image00472.jpeg)'
- en: 'However, in the following code, we adopt the more common approach of creating
    the generic Task object by calling the `StartNew<T>` method available in the `Factory`
    object of `Task<T>`, so we can simplify the former example in this manner:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在下面的代码中，我们采用了更常见的通过调用`Task<T>`的`Factory`对象中可用的`StartNew<T>`方法来创建泛型`Task`对象的方法，这样我们就可以以这种方式简化前面的示例：
- en: '[PRE30]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, this time we don't need an intermediate variable to store the
    return value, and the `Task<T>` definition allows you to create a `Task` object
    of almost any type.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这次我们不需要一个中间变量来存储返回值，`Task<T>`定义允许您创建几乎任何类型的`Task`对象。
- en: There's much more about tasks and related features, such as parallel execution,
    asynchronous calls, and so on, so we'll go deeper into all this in [Chapter 12](part0078.xhtml#aid-2ACBS2
    "Chapter 12. Performance"), *Performance*, which we dedicate to performance and
    optimization, so take this as a very brief introduction to the subject.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 关于任务和相关功能（如并行执行、异步调用等）的内容还有很多，所以我们将更深入地探讨所有这些内容，在[第12章](part0078.xhtml#aid-2ACBS2
    "第12章。性能")，*性能*中，我们专门讨论性能和优化，所以把这当作对这个主题的非常简短的介绍。
- en: 'C# 5.0: async/await declarations'
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'C# 5.0: async/await 声明'
- en: 'In order to enhance the possibilities of creation and the management of asynchronous
    processes and to simplify the code even more, version 5.0 of C# introduced a couple
    of new reserved words in order to facilitate the insertion of asynchronous calls
    without having to implement an extra method to receive the results: the couple
    of words are `async`/`await` (one cannot be used without the other).'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增强创建和管理异步过程的可能性，并进一步简化代码，C# 5.0版本引入了几个新的保留字，以便在不实现额外方法接收结果的情况下插入异步调用：这两个词是`async`/`await`（一个不能没有另一个使用）。
- en: 'When a method is marked as `async`, the compiler will check for the presence
    of another sentence prefixed with the `await` keyword. Although we write the method
    as a whole, the compiler fragments (internally) the method into two parts: the
    one where the `async` keyword appears initially, and the rest counting from the
    line in which `await` is used.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法被标记为`async`时，编译器会检查是否存在另一个以`await`关键字为前缀的句子。虽然我们整体编写方法，但编译器（内部）将方法分成两部分：`async`关键字首次出现的地方，以及从使用`await`的行开始的其余部分。
- en: At execution time, as soon as the `await` sentence is found, the execution flow
    returns to the calling method and executes the sentences that follow, if any.
    As soon as the slow process returns, execution continues with the rest of sentences
    located next to the awaited statement.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行时，一旦找到`await`语句，执行流程就会返回到调用方法并执行后续的语句（如果有）。一旦慢速过程返回，执行将继续进行到等待语句旁边的其余语句。
- en: 'We can view a brief initial sample of how it works in a transformation of the
    previous example (as I mentioned in relation with tasks, this topic will also
    be covered with more detail in the chapter dedicated to performance):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简要地查看一下它如何在前一个示例的转换中工作（正如我在与任务相关的内容中提到的，这个主题将在专门讨论性能的章节中更详细地介绍）：
- en: '[PRE31]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that I'm just writing the same code with a different syntax. When the execution
    flow reaches the first line of `SlowMethod` (marked as `await`), it launches another
    execution thread and returns to the thread in the calling method (`Main`). Consequently,
    we can see the `Awaiting for SlowMethod` message before the `Finished at` indication
    located at the end.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我只是在不同的语法下写相同的代码。当执行流程到达`SlowMethod`（标记为`await`）的第一行时，它启动另一个执行线程并返回到调用方法（`Main`）的线程。因此，我们可以在`Finished
    at`指示符之前看到`Awaiting for SlowMethod`消息。
- en: 'The output it is quite clear, as shown in the following screenshot:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 输出非常清晰，如下面的屏幕截图所示：
- en: '![C# 5.0: async/await declarations](img/image00473.jpeg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![C# 5.0: async/await 声明](img/image00473.jpeg)'
- en: Of course, as we indicated in relation with the `Task` object, there's much
    more to this than what is expressed here in this ephemeral introduction, and we'll
    cover this in [Chapter 10](part0055.xhtml#aid-1KEEU1 "Chapter 10. Design Patterns"),
    *Design Patterns*. But for now, we can have an idea about the benefits and simplification
    provided by this code construct.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，正如我们在与`Task`对象相关的内容中指出的，这里所表达的内容远不止这些，我们将在[第10章](part0055.xhtml#aid-1KEEU1
    "第10章。设计模式")，*设计模式*中详细讨论这一点。但到目前为止，我们可以了解这种代码结构提供的优势和简化。
- en: What's new in C# 6.0
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 6.0的新特性
- en: Some pretty interesting features appeared in this version of the language, in
    many cases, linked to everyday problems and suggestions of developers worldwide.
    Also, as stated in Table 1 of this chapter, the really huge, meaningful improvement
    comes from a set of functionalities linked to Roslyn Services, which provide a
    different bunch of possibilities related to the editing and compiling features
    of the IDE. We will cover these in [Chapter 8](part0044.xhtml#aid-19UOO2 "Chapter 8. Open
    Source Programming"), *Open Source Programming*.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个语言版本中出现了许多相当有趣的功能，在许多情况下，这些功能与日常问题和全球开发者的建议相关联。此外，正如本章表 1 中所述，真正巨大、有意义的改进来自于与
    Roslyn 服务相关的一系列功能，这些功能为 IDE 的编辑和编译功能提供了一组不同的可能性。我们将在第 8 章[开源编程](part0044.xhtml#aid-19UOO2
    "第 8 章。开源编程")中介绍这些内容。
- en: However, Roselyn is not the only interesting option that appeared in C# 6.0\.
    There are a number of minor but very useful and syntactic "sweets" this version
    includes, which help the coder write more succinct expressions and reduce the
    occurrence of bugs. Let's start with something called string interpolation.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Roselyn 并不是 C# 6.0 中出现的唯一有趣选项。这个版本包括了许多小但非常有用且语法上的“甜点”，这些“甜点”有助于程序员编写更简洁的表达式并减少错误的发生。让我们从一个叫做字符串插值的东西开始。
- en: String interpolation
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串插值
- en: String interpolation is a way to simplify string expressions that contain C/C++
    style interpolation. For instance, instead of writing the classic `Console.Write("string
    {0}", data)` composition, we can now express this by simply including the identifier
    inside curly brackets, so the previous expression would become `$"string {data}"`
    as far as we precede the string with the `$` symbol in order to make it work.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串插值是一种简化包含 C/C++ 风格插值的字符串表达式的途径。例如，我们不再需要编写经典的 `Console.Write("string {0}",
    data)` 组合，现在我们可以通过简单地包括标识符在花括号内来表示这一点，因此前面的表达式将变为 `$"string {data}"`，前提是我们用 `$`
    符号在字符串前导，以便使其生效。
- en: Note that we can mix the `@` symbol with `$` given that the `$` symbol goes
    before the `@` symbol.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以将 `@` 符号与 `$` 符号混合使用，因为 `$` 符号在 `@` 符号之前。
- en: Moreover, you can use the `{}` area to include a C# expression that will be
    correctly evaluated at runtime and converted into a string by calling the `ToString`
    method so that it's not limited to identifiers. Thus, we can even include file
    I/O operations—like we do in the following code—and get the results.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以使用 `{}` 区域包含一个将在运行时正确评估并由调用 `ToString` 方法转换为字符串的 C# 表达式，这样它就不限于标识符。因此，我们甚至可以包括文件
    I/O 操作——就像我们在以下代码中所做的那样——并获得结果。
- en: 'To test this, I have a text file (`TextFile.txt`) with a line of content, which
    is presented in the output accompanied by a string literal in a single line of
    code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个，我有一个包含一行内容的文本文件（`TextFile.txt`），该内容在输出中由单行代码中的字符串字面量伴随展示：
- en: '[PRE32]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you can see in the next capture, expressions inside the curly braces are
    totally evaluated and the result inserted in the output string:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在下图中可以看到的，花括号内的表达式将被完全评估，并将结果插入到输出字符串中：
- en: '![String interpolation](img/image00474.jpeg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![字符串插值](img/image00474.jpeg)'
- en: This technique, besides simplifying expressions, can be used easily in conjunction
    with other new C# 6.0 features, such as Exception filters.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术除了简化表达式外，还可以轻松地与其他新的 C# 6.0 功能结合使用，例如异常过滤器。
- en: Exception filters
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常过滤器
- en: Another addition refers to exceptions. Exception filters provide a way to personalize
    any occurred exception depending on a condition that can be coded using any valid
    C# expression, which should be located next to the new `when` sub-clause that
    might follow any `Catch` clause now.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个新增功能是关于异常的。异常过滤器提供了一种根据可以使用任何有效 C# 表达式编写的条件来个性化任何发生的异常的方法，该表达式应位于现在可能跟随任何
    `Catch` 子句的新 `when` 子句旁边。
- en: In the previous code, let's suppose that we want to create a conditional test
    for an exception that doesn't have much to do with the exception itself (or maybe
    it does, but that's not the case here). Or, we can even suppose that we want to
    catch a situation related to an external state, such as the system's date/time
    or what have you.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，假设我们想要为不与异常本身有很大关系的异常创建一个条件测试（或者也许它确实有关系，但这里不是这种情况）。或者，我们甚至可以假设我们想要捕捉与外部状态相关的某种情况，比如系统的日期/时间等。
- en: 'The following code catches a situation in which the previous file exists but
    produces an exception on Saturdays, to say something bizarre. We can modify the
    code in this way:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码捕捉到一种情况，即前一个文件存在，但在周六会产生异常，以表达一些奇怪的事情。我们可以这样修改代码：
- en: '[PRE33]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This possibility provides us with new ways to catch exceptions linked to conditions
    that don't belong (necessarily) to the exception context but to any other situation;
    just consider that the expression can be much more complex than that in the demo
    code.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: The nameof operator
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `nameof` operator is a contextual keyword with a syntax similar to `typeof`,
    which yields the name of any program element (usually, an identifier). Or, if
    you want, it converts the filename variable of the previous example into filename.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: This approach offers several advantages. First, if we need the name of such
    an element, no reflection technique is required. Besides, the compiler is going
    to guarantee that whatever we pass as an argument to the operator is a valid element;
    also, it integrates with the editor's Intellisense and behaves better in some
    refactoring scenarios.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s useful in try-catch structures as well, for example, when indicating
    the reason for a failure specifying the name of the element that causes the exception
    and even in attributes, as the "official" example of MSDN suggests (refer to [https://msdn.microsoft.com/en-us/library/dn986596.aspx](https://msdn.microsoft.com/en-us/library/dn986596.aspx)):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The null-conditional operator
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This operator is the latest member of the family of features designed to deal
    with null values in C#. Since version 1.0, we could, of course, check (`value
    == null`) within a conditional statement to avoid undesired failures.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, `Nullable` types arrived (remember, appending a ? symbol to a variable
    declaration allows it to be null, and these types include a Boolean `HasValue`
    property to check this situation):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When a conversion is required, the `TryParse` method of many basic types allows
    us to check for valid values (not only null).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'As language evolved, new ways of dealing with null values kept coming up. In
    C# 4.0, one of the most useful things was the null-coalescing operator. It works
    a bit like the ? operator: it locates itself between two elements to check for
    nullability, and if the left-hand side is not null, it returns it; otherwise,
    it returns the right-hand side operand. It''s so simple that it even lets you
    mix it with string interpolation in this way:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We get the expected result in the console:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '![The null-conditional operator](img/image00475.jpeg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
- en: So, the previous code writes `Unspecified` in the console, since `str` is null.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Now in C# 6.0, we have another ability: the null conditional operator, or null
    propagation operator (or even, the `Elvis` operator, as it''s called by some members
    of the C# team, assuming that the two lower points are a couple of eyes and the
    higher part of the question mark the toupee!), which can be inserted in an expression,
    and it stops evaluating the right-hand side of the expression if the value of
    the `adorned` element with the operator is not present. Let''s understand this
    better through an expression:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: If we want to print out the length of the `str` string in the previous case,
    we can simply add another Console sentence, such as `Console.WriteLine(str.Length.ToString());`.
    The problem is that it would provoke an exception when trying to access the `Length`
    property of `str`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在之前的案例中打印出`str`字符串的长度，我们可以简单地添加另一个控制台语句，例如`Console.WriteLine(str.Length.ToString());`。问题是，当尝试访问`str`的`Length`属性时，它将引发异常。
- en: 'To fix this, we can use this operator in very simple way:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以非常简单地使用这个操作符：
- en: '[PRE37]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: By including the null conditional `?` operator, the `Length` property is not
    even accessed, so there's no exception, and we will get the expected output (an
    empty string, in this case).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 通过包含空条件`?`操作符，甚至不会访问`Length`属性，因此不会抛出异常，我们将得到预期的输出（在这种情况下是一个空字符串）。
- en: 'Let''s put everything together in a block of code so that we compare different
    behaviors for null and non-null strings:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把所有内容都放在一个代码块中，以便比较空字符串和非空字符串的不同行为：
- en: '[PRE38]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This code compiles with no problems and generates the following output:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码编译没有问题，并生成以下输出：
- en: '![The null-conditional operator](img/image00476.jpeg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![空条件操作符](img/image00476.jpeg)'
- en: 'Observe the fifth entry: no value is presented because no evaluation has been
    made of the `Length` of `str`. There are numerous cases in which this is just
    the operator we need: it could be checking a null delegate before invocation or
    inserting it right before any common `ToString` call for usual conversions.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 观察第五项：没有显示值，因为没有对`str`的`Length`进行评估。有许多情况下这正是我们需要的操作符：它可能是检查在调用之前为null的委托，或者是在任何常见的`ToString`调用之前插入它。
- en: Auto-property initializers
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动属性初始化器
- en: Auto-property initializers are another improvement that helps manage immutable
    properties (those that once given a value, don't change along the life of the
    application).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 自动属性初始化器是另一个改进，有助于管理不可变属性（那些一旦赋予值，在应用程序的生命周期中不会改变的属性）。
- en: In preceding versions, declaring read-only properties was kind of redundant.
    You had to declare the read-only backup private field and take care of its initialization
    and, later, provide an explicit implementation of such property (instead of using
    the common auto-properties). Finally, to access the value, a property-get member
    was included. This was the way good practices recommended you to create this particular
    type of data.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的版本中，声明只读属性有点多余。你必须声明只读的备份私有字段，并负责其初始化，然后，提供该属性的显式实现（而不是使用常见的自动属性）。最后，为了访问值，包括一个属性获取成员。这是良好实践推荐你创建此类特定类型数据的方式。
- en: 'This is also why auto-properties are so handy. For example, if our application
    captures the current username and operating system version of the machine, it''s
    installed in a pair of read-only properties. It suffices to indicate this in the
    following manner:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么自动属性如此方便的原因。例如，如果我们的应用程序捕获了机器上安装的当前用户名和操作系统版本，它可以通过一对只读属性来表示。以下方式足以表明这一点：
- en: '[PRE39]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'So, we''re using a more concise syntax to express the same idea and obtain
    the same results as what we achieved with the classical approach:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们使用更简洁的语法来表达相同的概念，并得到与经典方法相同的结果：
- en: '![Auto-property initializers](img/image00477.jpeg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![自动属性初始化器](img/image00477.jpeg)'
- en: Static using declarations
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态using声明
- en: Another way to simplify syntax is based on the idea of extending directives
    in the code to make them capable of referencing static members of the .NET Framework
    and using them in the same way as we use other declarations mentioned in a `using`
    directive.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种简化语法的方法是基于在代码中扩展指令的想法，使它们能够引用.NET Framework的静态成员，并以与我们使用`using`指令中提到的其他声明相同的方式使用它们。
- en: 'That is, we can include a declaration like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们可以包含如下声明：
- en: '[PRE40]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'From this point, any reference to a member of the `Math` class can be done
    directly without an indication of the namespace (and the static class) it belongs
    to:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，对`Math`类成员的任何引用都可以直接进行，无需指明它所属的命名空间（以及静态类）：
- en: '[PRE41]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that we're using string interpolation all over the demos, since the simplification
    it allows is very useful, especially for these console-type snippets (I omitted
    the output in this case, you can figure it out...).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在整个演示中使用了字符串插值，因为它允许的简化非常实用，特别是对于这些控制台类型的片段（在这种情况下，我省略了输出，你可以自己想出来...）。
- en: 'Moreover, there''s another typical case in which this functionality is important:
    when we use `Enum` members. Most of the time, we already know the possible values,
    so if we are indicating a typical `Enum`, such as the day of the week, we can
    indicate the corresponding `Enum` type as a static:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个典型的场景，其中这种功能很重要：当我们使用`Enum`成员时。大多数时候，我们已经知道可能的值，所以如果我们指示一个典型的`Enum`，比如一周中的某一天，我们可以将相应的`Enum`类型作为静态的：
- en: '[PRE42]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, use it just like earlier (remember, the number of `Enum` types in .NET
    is quite large):'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，就像之前一样使用它（记住，.NET中`Enum`类型数量相当庞大）：
- en: '[PRE43]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We even keep things more generic, using the `nameof` operator we already saw:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至使事物更加通用，使用了之前看到的`nameof`运算符：
- en: '[PRE44]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'So, we would still get the expected output, though expressed in a much more
    generic way:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们仍然会得到预期的输出，尽管以更通用的方式表达：
- en: '![Static using declarations](img/image00478.jpeg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![静态使用声明](img/image00478.jpeg)'
- en: 'Since the demo is a Console application, even Console can be referenced in
    this way; so, consider that we want to change the colors of the output in the
    Console instead of writing something like this:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 由于演示是一个控制台应用程序，甚至控制台也可以以这种方式引用；所以，假设我们想要改变控制台输出的颜色，而不是编写如下内容：
- en: '[PRE45]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can put it all together in much simpler way (of course, some developers
    may argue that this is a matter of syntactic tastes.). At the top of the code,
    we declare the following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一种更简单的方式将这些内容整合在一起（当然，一些开发者可能会争论说这是一个语法品味的问题）。在代码的顶部，我们声明以下内容：
- en: '[PRE46]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, the rest is all simplified:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，其余部分都简化了：
- en: '[PRE47]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The expected output is presented in a tuned Console this time:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这次预期的输出以调整过的控制台形式呈现：
- en: '![Static using declarations](img/image00479.jpeg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![静态使用声明](img/image00479.jpeg)'
- en: Expression bodied methods
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式主体方法
- en: 'When coding lambda expressions, we''ve seen that we could omit the curly braces
    used to indicate the body of a method in order to simplify the code. Now, we can
    do something similar in methods, allowing us to express overriding in a simpler
    way. Consider this example code:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写lambda表达式时，我们已经看到我们可以省略表示方法体的花括号，以简化代码。现在，我们可以在方法中做类似的事情，允许我们以更简单的方式表达重写。考虑以下示例代码：
- en: '[PRE48]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Overriding the `ToString()` method is expressed using a simpler manner that
    contains string interpolation. It's pretty readable and concise, and it works
    just the same as it did in previous versions. (I also omitted the output, but
    you can easily infer it).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串插值表达的重写`ToString()`方法更加简单易读，并且与之前的版本工作方式相同。（我也省略了输出，但您可以轻松推断出来）。
- en: 'The same idea is valid to declare calculated properties in a class, for example.
    If we need to complete the previous class with a calculated property that returns
    a Boolean indicating whether the `FullName` member is longer that 12 characters
    (we call it `FullNameFits`), we can write this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的想法也适用于在类中声明计算属性，例如。如果我们需要在之前的类中添加一个计算属性，该属性返回一个布尔值，指示`FullName`成员是否超过12个字符（我们称之为`FullNameFits`），我们可以这样写：
- en: '[PRE49]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you can see, this becomes much more concise and expressive than it was before
    this version.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这比之前的版本更加简洁和表达性强。
- en: Index initializers
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引初始化器
- en: 'Let''s, finally, mention another feature related to initializers. Until now,
    when initializing index setters, we had to do it in separate statements. To put
    this in context, now if we have to initialize an array of values that coincides
    with certain numbers that are already well known, as is the case with Web Errors
    Dictionary (that is, 404-Not Found, and so on), we can define it in this way (all
    in one sentence):'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们提一下与初始化器相关的一个新特性。到目前为止，当我们初始化索引设置器时，我们必须在单独的语句中完成。为了更好地理解这一点，现在如果我们需要初始化一个与某些已知数字相对应的值数组，例如Web错误字典（即404-未找到等），我们可以这样定义（全部在一个句子中）：
- en: '[PRE50]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: So, right in the initialization process, we define the keys required (or, at
    least, initially required) regardless of whether they have to be changed later
    or not.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在初始化过程中，我们定义了所需的键（或者至少最初所需的键），无论它们是否需要在以后进行更改。
- en: In all, we can say the C# new features in version 6.0 is not very deep and significant,
    especially when compared to version 4.0, to mention just one. However, they're
    quite useful and they reduce the required code on many scenarios in which the
    programmer already knows the structure to write well enough so as to get rid of
    some of the verbosity connected to some programming structures.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们可以说C# 6.0版本的新特性并不非常深入和显著，尤其是与4.0版本相比，仅举一例。然而，它们非常有用，并且在许多情况下可以减少程序员需要编写的代码量，前提是程序员已经足够了解结构，可以很好地编写代码，从而消除一些与某些编程结构相关的冗余。
- en: What's new in C# 7.0
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 7.0的新特性是什么
- en: First of all, you have to keep in mind that to work with the new features proposed
    by version 7.0 of the language, you will need to have Visual Studio 2017 (any
    version, including the Community Edition) or Visual Studio Code with the OmniSharp
    Extension (C# plugin), which also allows to use the language in other popular
    editors like Vim, Emacs, Sublime, Atom, Brackets, and so on.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须记住，为了使用语言7.0版本提出的新特性，你需要拥有Visual Studio 2017（任何版本，包括社区版）或带有OmniSharp扩展（C#插件）的Visual
    Studio Code，这也允许你在其他流行的编辑器中使用语言，如Vim、Emacs、Sublime、Atom、Brackets等。
- en: Once you have that ready, C# 7 features will be available in the IDE and we
    can start playing with these additions. Also, it's important to note that Microsoft
    is encouraging the contributors of the coming versions of the language to deploy
    new features in a faster path, although including a smaller set of new features.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你准备好了，C# 7的特性将在IDE中可用，我们可以开始尝试这些新增功能。此外，值得注意的是，微软正在鼓励语言未来版本的贡献者以更快的路径部署新特性，尽管包括的新特性集合较小。
- en: 'Actually, this version does not include something as foundational to the language
    as LINQ or async/await. C# 7 adds extra syntactic sugar in some cases, except
    its most powerful features: the new support for tuples and deconstructions.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个版本并没有包括像LINQ或async/await这样对语言基础至关重要的特性。C# 7在某些情况下添加了额外的语法糖，除了其最强大的特性：对元组和解构的新支持。
- en: Let's start with the "syntactic sugar."
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从“语法糖”开始。
- en: Binary literals and digit separators
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二进制字面量和数字分隔符
- en: 'You can express binary numbers as literals directly in the definition of the
    type that holds them, like this, for example:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接在持有它们的类型的定义中表达二进制数，例如：
- en: '[PRE51]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: But when declared in this form, you can easily end up with long expressions
    difficult to evaluate and assess at first sight. That's why we now have a new
    language feature called digit separators.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 但当以这种形式声明时，你可能会得到难以评估和评估的长表达式。这就是为什么我们现在有一个名为数字分隔符的新语言特性。
- en: That means you can include any number of underscore symbols located in any position
    inside a number literal and it will be interpreted correctly by the compiler.
    In this manner, it becomes easier to read the values.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以在数字字面量中的任何位置包含任意数量的下划线符号，编译器会正确地解释它们。以这种方式，它使得读取值变得更加容易。
- en: 'This is valid for any type of number literal, as it happens in the sixth entry
    in the next code:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于任何类型的数字字面量，就像在下一代码的第六项中发生的那样：
- en: '[PRE52]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In case we want to check the automatic conversion to integers, we can test
    the result quite easily, adding a couple of lines:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要检查自动转换为整数的操作，我们可以很容易地测试结果，添加几行代码：
- en: '[PRE53]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This produces the following output in the console:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台产生以下输出：
- en: '![Binary literals and digit separators](img/image00480.jpeg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![二进制字面量和数字分隔符](img/image00480.jpeg)'
- en: Pattern matching and switch statements
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式匹配和switch语句
- en: 'In many cases, we need to check the value of a variable marked as `out`. Remember
    that in order to use `out`, the variable has to be initialized first. To illustrate
    this situation, consider the following code, in which a function has to evaluate
    whether a string parameter passed to it can be interpreted as an integer or not:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们需要检查标记为`out`的变量的值。记住，为了使用`out`，变量必须首先初始化。为了说明这种情况，考虑以下代码，其中函数必须评估传递给它的字符串参数是否可以解释为整数：
- en: '[PRE54]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As you can see, we have to declare and initialize the `i` variable before we
    can retrieve the resulting value from the conversion and double it (in case it
    is an `int`).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们必须在从转换中检索结果并将其加倍（如果它是`int`类型）之前声明和初始化`i`变量。
- en: 'How about avoiding the previous declaration and having `i` declared and initialized
    inside the `if` statement? That''s what we can do now with out inline declarations:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 那么避免之前的声明，并在`if`语句中声明和初始化`i`怎么样？我们现在可以用内联声明来做这件事：
- en: '[PRE55]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We have a more concise, elegant way of expressing the same idea. We're checking
    whether `s` matches the `int` pattern and, if it does, declaring and assigning
    the resulting value in a single expression.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有更简洁、优雅的方式来表达相同的思想。我们正在检查`s`是否匹配`int`模式，如果是，则在单个表达式中声明和分配结果值。
- en: Another way to use pattern matching is within the `switch` statements, which
    have also been extended with more patterns to evaluate the value passed to it.
    Actually, you can now switch on anything, not just primitive types such as `int`
    or `string`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模式匹配的另一种方式是在`switch`语句中，这些语句也通过更多的模式来扩展以评估传递给它的值。实际上，你现在可以切换任何东西，而不仅仅是`int`或`string`这样的原始类型。
- en: 'Let''s see it in some code:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一些代码中看看：
- en: '[PRE56]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The previous function assumes it is going to receive an object and has to do
    the following:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数假设它将接收一个对象，并必须执行以下操作：
- en: If the object is null or different from an `int` or a string, return a string
    value indicating so
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象为null或与`int`或字符串不同，则返回一个表示此情况的字符串值
- en: If the object is an `int` or if it is an string convertible to an `int`, duplicate
    its value and return it
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象是`int`或是一个可以转换为`int`的字符串，则复制其值并返回它
- en: It it is a string not convertible to an `int`, add a prefix and return it
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它是一个无法转换为`int`的字符串，则添加前缀并返回它
- en: As per the preceding code, now you can indicate pattern matching to check whatever
    the value is, and we can even combine similar situations, such as checking for
    an `int` or for a string containing an `int` in sequential `case` statements.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的代码，现在你可以指示模式匹配来检查任何值，我们甚至可以在连续的`case`语句中组合类似的情况，例如检查`int`或包含`int`的字符串。
- en: Observe the use of `when` in the string pattern matching, which plays the role
    of an `if`, really.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 观察字符串模式匹配中使用`when`的情况，它实际上扮演了`if`的角色。
- en: Finally, if it is a string but it's not convertible, we use the prefix procedure.
    These two features are syntactic sugar (as they call it), but they're pretty expressive
    and help in simplifying type checking and complex checking situations such as
    the one coded here.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果它是一个字符串但无法转换，我们使用前缀过程。这两个特性是语法糖（正如他们所说的），但它们相当具有表现力，有助于简化类型检查和复杂的检查情况，如这里编写的代码。
- en: Tuples
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组
- en: 'In the section named *Tuples: implementation in C#*, we saw how to declare
    and use tuples using the `Tuple` class, and, also, some of the drawbacks linked
    to that early version or these objects.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在名为*元组：C#中的实现*的部分，我们看到了如何使用`Tuple`类声明和使用元组，以及与早期版本或这些对象相关的一些缺点。
- en: 'Now, in C# 7, tuples reach a new dimension. You no longer have to use the `Tuple`
    class to declare tuples, and thanks to pattern matching, the compiler is perfectly
    comfortable with declarations that include a tuple syntax next to a `var` definition
    or use a tuple as the return type of a method (allowing us to return more than
    a value, without requiring out parameters):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在C# 7中，元组达到了一个新的维度。你不再需要使用`Tuple`类来声明元组，多亏了模式匹配，编译器对包含元组语法和`var`定义的声明或使用元组作为方法返回类型的声明感到非常舒适（允许我们返回多个值，而无需使用输出参数）：
- en: '[PRE57]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The previous declaration is now understood by the compiler, as the next capture
    shows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的声明现在被编译器理解，如下一个捕获所示：
- en: '![Tuples](img/image00481.jpeg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![元组](img/image00481.jpeg)'
- en: That makes the use of the `Tuple` class unnecessary and also it makes much natural
    to work with these types. Besides, we had to use the members `Item1`, `Item2`,
    and so on to access the values of the tuple. Now we can give descriptive names
    to each member of the tuple to clarify its purpose (such as `n` and `s` in this
    sample).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得使用`Tuple`类变得不必要，并且使得与这些类型一起工作更加自然。此外，我们不得不使用`Item1`、`Item2`等成员来访问元组的值。现在我们可以给元组的每个成员赋予描述性的名称，以阐明其目的（如本示例中的`n`和`s`）。
- en: Another advantage is that you can return a tuple in a function. Let's follow
    an adapted version of the official demo that PM Mads Torgersen usually presents
    to explain this feature.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优点是可以在函数中返回一个元组。让我们跟随PM Mads Torgersen通常用来解释这个特性的官方演示的改编版本。
- en: 'Imagine that we want to know how many items there are inside the initial declaration
    of `binNumbers` and also perform a sum of all its members, in the same function.
    We could write a method like this:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们想要知道`binNumbers`的初始声明中有多少项，并且在同一函数中对其所有成员进行求和。我们可以编写一个类似这样的方法：
- en: '[PRE58]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, invoke the method and present the results in this way:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，调用该方法并以这种方式展示结果：
- en: '[PRE59]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We obtain the expected results. But let's go through the code to view the details
    of the implementation.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了预期的结果。但让我们查看代码以查看实现的细节。
- en: 'First, the return value of the function is a tuple and its members, named accordingly,
    which makes the calling code more readable. Also, the internal `result` variable
    is defined and initialized with the tuple syntax: a list of comma-separated values,
    optionally prefixed with a name for clarity.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，函数的返回值是一个元组，其成员按相应命名，这使得调用代码更易读。此外，内部`result`变量被定义并使用元组语法初始化：一系列以逗号分隔的值，可选地以名称作为前缀以提高清晰度。
- en: The return value is then assigned to the `res` variable, which can use the named
    parameters to output them in the console using string interpolation.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将返回值分配给`res`变量，它可以使用命名参数在控制台使用字符串插值输出它们。
- en: Decomposition
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分解
- en: Decomposition is a characteristic that allows us to deconstruct or decompose
    an object into its parts, or some of its parts.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 分解是一种特性，允许我们将对象分解为其部分，或其部分。
- en: 'For instance, in the declaration of the `res` variable, we could even avoid
    the use of `res` by declaring the named members of the tuple, to obtain exactly
    the same results:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在`res`变量的声明中，我们甚至可以通过声明元组的命名成员来避免使用`res`，以获得完全相同的结果：
- en: '[PRE60]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As you can see, we can have access to the required returning values, but there's
    no need to hold them in a named variable; thus, we say that the resulting value
    has been "decomposed" into its forming parts.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们可以访问所需的返回值，但不需要将它们保存在命名变量中；因此，我们说结果值已经被“分解”为其构成部分。
- en: Of course, in this case, we're taking advantage that the type to deconstruct
    is a tuple already. What about other objects? You can deconstruct any object as
    long as it has a `Deconstruct` method defined or you create an extension method
    with that name.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这种情况下，我们利用的是要解构的类型已经是一个元组。那么其他对象呢？只要对象定义了`Deconstruct`方法，或者你创建了一个同名扩展方法，你就可以解构任何对象。
- en: 'Let''s say we want to be able to decompose a `DateTime` value. Of course, there''s
    no `Deconstruct` method defined inside the `DateTime` object, but we can create
    one pretty easily:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要能够分解一个`DateTime`值。当然，`DateTime`对象内部没有定义`Deconstruct`方法，但我们可以非常容易地创建一个：
- en: '[PRE61]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Once we have that definition accessible, we could "extract" those values from
    the current time with a sentence like this:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了可访问的定义，我们就可以用这样的句子“提取”当前时间的值：
- en: '[PRE62]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'And we would get the output shown in the following capture, which also shows
    the previous calculation on the number or items in the array and its sum:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会得到以下捕获中显示的输出，它还显示了数组中元素的数量及其总和的计算：
- en: '![Decomposition](img/image00482.jpeg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![分解](img/image00482.jpeg)'
- en: Local functions
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 局部函数
- en: JavaScript programmers are used to passing functions as parameters and returning
    functions as a return value. That's not available in C#, except for the functionality
    available through lambda expressions that we saw in the previous chapter.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript程序员习惯于将函数作为参数传递，并将函数作为返回值。在C#中，这不可用，除非是通过我们在上一章中看到的lambda表达式提供的功能。
- en: Local functions are not that, but they allow us to declare a function that is
    local to another closing function, with the ability to access the variables defined
    in the upper function. Therefore, they are local to the function in which they
    are declared.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 局部函数并不是这样，但它们允许我们声明一个局部于另一个封闭函数的函数，并且能够访问上层函数中定义的变量。因此，它们是在它们声明的函数中局部化的。
- en: Go back to our demo of `ProcessArray` and imagine you want to separate the code
    inside the `ForEach` loop aside in another function, but you want to modify the
    values directly (without the `out` references).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`ProcessArray`演示，假设你想要将`ForEach`循环内部的代码分离到另一个函数中，但你想直接修改这些值（而不是使用`out`引用）。
- en: 'You could rewrite the process with an inside function of this kind with the
    following syntax:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用以下语法重写这种类型的内部函数的过程：
- en: '[PRE63]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This time, we go through the collection using a `ForEach` loop and, inside the
    loop, we call the local function `ProcessItem`, which has access to the result
    members.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们使用`ForEach`循环遍历集合，并在循环内部调用局部函数`ProcessItem`，该函数可以访问结果成员。
- en: In which cases do these inside functions make sense? One case would be when
    a helper method is only going to be used inside a single function, like in this
    case.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在哪些情况下这些内部函数才有意义？一个情况是当一个辅助方法只会在单个函数内部使用，就像在这个例子中一样。
- en: Ref return values
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值引用
- en: Finally, let's learn a bit about these feature, which is only partially available,
    since they plan to extend it along the quick-path-release cadence of the language
    they announced in Connect(); 2016 event.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们了解一下这些特性，它们目前只部分可用，因为它们计划在Connect(); 2016活动宣布的语言快速路径发布周期中扩展它。
- en: The idea is that in the same way you can pass values by reference, now you can
    return reference values and even store values in reference variables.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是，与你可以通过引用传递值一样，现在你可以返回引用值，甚至可以将值存储在引用变量中。
- en: 'The Mads Torgersen code mentioned previously includes the following (self-explaining)
    code, to see how we would declare such a function a how we could use it:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的Mads Torgersen代码包括以下（自解释）代码，以了解我们如何声明这样的函数以及我们如何使用它：
- en: '[PRE64]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the code, the function is marked with `ref` right before declaring the return
    type (`int`). Later, after declaring an array of numbers, the function is called
    with a 7 as the first parameter.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，函数在声明返回类型（`int`）之前用`ref`标记。后来，在声明一个数字数组之后，函数以7作为第一个参数被调用。
- en: The value 7 occupies the fifth position in the array, so its order number is
    4\. But since the returned value is stored as `ref`, a subsequent assignment of
    9 changes that value inside the array to 9\. That's why the final sentence prints
    9.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 值7占据了数组的第五个位置，因此它的顺序号是4。但由于返回值被存储为`ref`，随后的赋值9将数组中的该值更改为9。这就是为什么最终语句打印出9的原因。
- en: In all, perhaps the changes included in this last version of the language are
    not as meaningful as there were those in versions 2, 3, or 4 of the language,
    but even so, they facilitate the programmer's tasks in some situations.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，也许这个语言最新版本中包含的变化并不像语言2、3或4版本中的变化那样有意义，但即便如此，它们在某些情况下也简化了程序员的任务。
- en: Summary
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We saw the most renowned features included in recent versions of the C# language
    and .NET Framework from their 4.0 versions.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了C#语言和.NET Framework最近版本中包含的最著名特性。
- en: We covered the C# 4.0 version, with a review of Delegate and Interface generic
    variance (covariance and contravariance), dynamic declarations, argument improvements,
    tuples and Lazy Instantiation of objects, which implied important changes in expressiveness
    and the power of the C# language.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回顾了C# 4.0版本，包括对委托和接口泛型方差（协变和逆协变）、动态声明、参数改进、元组和对象的延迟实例化进行了回顾，这些意味着C#语言的表述能力和功能发生了重要变化。
- en: Then, we gave a brief introduction to the `async/await` structure as a means
    to simplify asynchronous calls by coding the two parts usually required in only
    one method.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们简要介绍了`async/await`结构，作为一种通过将通常需要的两部分代码合并到单一方法中来简化异步调用的手段。
- en: Next, we did a review of the most important features included in version C#
    6.0, which is mainly based on new ways to reduce verbosity in the language.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们对包含在C# 6.0版本中的最重要的功能进行了回顾，该版本主要基于在语言中减少冗余的新方法。
- en: Finally, we've seen the most important features added to the recently published
    version 7.0, which are mainly based on syntactic sugar to make expressions more
    meaningful and the new pattern matching features which make the use of tuples
    a very feasible option in many common situations.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了最近发布的7.0版本中添加的最重要特性，这些特性主要基于语法糖来使表达式更有意义，以及新的模式匹配特性，这使得在许多常见情况下使用元组变得非常可行。
- en: In the next chapter, we'll do a comparison of languages, including the F# and
    TypeScript support in Visual Studio as well as provide some prospects about their
    use in the future.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将比较不同的语言，包括Visual Studio中的F#和TypeScript支持，并提供一些关于它们未来使用的展望。
