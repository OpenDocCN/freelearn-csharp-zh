- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw while reading the book, there are many data structures with many
    configuration variants. Thus, **choosing a proper data structure is not an easy
    task**, which could have a significant impact on the performance of the developed
    solution. Even the topics mentioned in this book form quite a long list of described
    data structures. For this reason, it is a good idea to classify them in some way.
  prefs: []
  type: TYPE_NORMAL
- en: Within this chapter, the described data structures are grouped into linear and
    non-linear categories. Each element in a **linear data structure** can be logically
    adjacent to the following or the previous element. In the case of a **nonlinear
    data structure**, a single element can be logically adjacent to numerous others,
    not necessarily only one or two.
  prefs: []
  type: TYPE_NORMAL
- en: As it is the last chapter of the book, we will also summarize all of the gathered
    knowledge. Each data structure will be presented with a brief description, and
    some of them will be also shown with illustrations to help you remember this information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Classification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last word
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I will start with a classification of the data structures shown already in the
    book. The classification divides all structures into linear and non-linear ones.
  prefs: []
  type: TYPE_NORMAL
- en: A **linear data structure** means that **each element can be logically adjacent
    to the following or the previous element**. There are several data structures
    that follow this rule, such as arrays, lists, stacks, and queues. Of course, you
    should also take care of various subtypes of the mentioned data structures, such
    as four variants of a linked list, which is a subtype of a list.
  prefs: []
  type: TYPE_NORMAL
- en: A **non-linear data structure** indicates that **a single element can be logically
    adjacent to numerous others, not necessarily only one or two**. They can be freely
    distributed throughout the memory. Of course, graph-based data structures, including
    trees, are included in this group. Trees include binary trees, tries, and heaps,
    while a binary search tree is a subtype of a binary tree. In a similar way, you
    can describe the relationships of other data structures presented and explained
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mentioned classification is presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Classification of data structures into linear and non-linear
    ones](img/B18069_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Classification of data structures into linear and non-linear ones
  prefs: []
  type: TYPE_NORMAL
- en: Do you remember all of the data structures shown in the book? Due to the high
    number of described topics, it is a good idea to take a look at the following
    data structures once again. The associated algorithms will be mentioned, as well.
    The remaining part of this chapter is a brief summary with information about some
    real-world applications.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start with an `int`, `string`, or a user-defined class. The important
    assumption is that the number of elements in an array cannot be changed after
    initialization. Moreover, arrays belong to **random access data structures**.
    This means that you can use indices to get access to the first, the middle, the
    *n*-th, or the last element from the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can benefit from a few variants of arrays – namely, **single-dimensional**,
    **multi-dimensional**, and **jagged arrays**, also referred to as an **array of
    arrays**. All of these variants are shown in the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Variants of arrays](img/B18069_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Variants of arrays
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of applications for arrays and, as a developer, you have probably
    already used this data structure many times. In this book, you saw how you can
    use it to store various data, such as the **names of months**, the **multiplication
    table**, or even a **map of a game**. In the last case, you created a two-dimensional
    array with the same size as a map, where each element specified a certain type
    of terrain, such as grass.
  prefs: []
  type: TYPE_NORMAL
- en: There are many algorithms that perform operations on arrays. However, one of
    the most common tasks is sorting an array to arrange its elements in the correct
    order, either ascending or descending. This book focuses on seven algorithms,
    namely **selection sort**, **insertion sort**, **bubble sort**, **merge sort**,
    **Shell sort**, **quicksort**, and **heap sort**. Each of them was described and
    presented in the illustration, as well as written in the C# code, together with
    a detailed explanation.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next group of data structures are `ArrayList`), as well as its generic (`List`)
    and sorted (`SortedList`) variants. The latter can be understood as a collection
    of key-value pairs, always sorted by keys.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few other variants of lists, including a `LinkedList`). You can
    quite easily extend it to behave as any circular linked list, either as a circular
    singly or circular doubly linked list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Various variants of lists are shown in the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Variants of lists](img/B18069_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Variants of lists
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of applications for the lists to solve diverse problems in various
    kinds of applications. In this book, you saw how to utilize the list to store
    some floating-point values and calculate the average value, how to use this data
    structure to create a simple **database of people**, and how to develop an automatically
    sorted **address book**. Moreover, you prepared an exemplary application that
    allows a user to **read the book** by changing the pages, as well as a game, in
    which the user **spins the wheel** with random power. The wheel rotates slower
    and slower until it stops. Then, the user can spin it again, from the previous
    stop position, which illustrates a circular linked list.
  prefs: []
  type: TYPE_NORMAL
- en: Stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18069_05.xhtml#_idTextAnchor165), *Stacks and Queues*, focused
    on stacks and queues. Now, let’s recap a `Stack` class is available, as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The illustration of a stack is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Illustration of a stack](img/B18069_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Illustration of a stack
  prefs: []
  type: TYPE_NORMAL
- en: A stack has many real-world applications. One of the mentioned examples is related
    to a **pile of many plates**, each placed on top of the other. You can only add
    a new plate at the top of the pile, and you can only get a plate from the top
    of the pile. You cannot remove the seventh plate without taking the previous six
    from the top, and you cannot add a plate to the middle of the pile. You also saw
    how to use a stack to **reverse a word** and how to apply it to solve the mathematical
    game **Tower of Hanoi**. That’s not all, because applications of stacks are much
    broader, such as for calculating mathematical expressions provided in the **reverse**
    **Polish notation**.
  prefs: []
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another leading subject of [*Chapter 5*](B18069_05.xhtml#_idTextAnchor165),
    *Stacks and Queues*, was a `Queue` class is available for you, as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The illustration of a queue is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Illustration of a queue](img/B18069_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Illustration of a queue
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to use a **priority queue**, which extends the concept of
    a queue by setting the priority for each element. Thus, the dequeue operation
    returns the element with the highest priority, which was added earliest to the
    queue. When all elements with the highest priority are dequeued, the priority
    queue handles elements with the next highest priority and dequeues such elements
    from those added earliest.
  prefs: []
  type: TYPE_NORMAL
- en: Another variant of a queue is a **circular queue**, also called a **ring buffer**,
    which was also presented and explained in the book. Here, a queue forms a circle,
    internally uses an array, and the maximum number of elements that can be placed
    inside the queue is limited. You specify indices for front and rear elements in
    this case.
  prefs: []
  type: TYPE_NORMAL
- en: There are many real-world applications of a queue. For example, a queue can
    be used to represent a **line of people** waiting in a shop at a checkout. New
    people stand at the end of the line, and the next person is taken to the checkout
    from the beginning of the line. You are not allowed to choose a person from the
    middle and serve them. Moreover, you saw a few examples of the solution of a **call
    center**, where there are many clients and one consultant, many clients and many
    consultants, or many clients (with different plans, either standard or priority
    support) and only one consultant, who answers the waiting calls. Another group
    of queue applications was shown while presenting **graph-based algorithms**. A
    queue was used in the **breadth-first search** algorithm for traversing a graph
    or for searching for a given value in a graph. A priority queue was applied in
    **Dijkstra’s algorithm** for searching the shortest path in a graph.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The topic of [*Chapter 6*](B18069_06.xhtml#_idTextAnchor195), *Dictionaries
    and Sets*, was related to dictionaries and sets. First, let’s recap a **dictionary**,
    which allows **mapping keys to values and performing fast lookups**. A dictionary
    uses a hash function and can be understood as a collection of pairs, each consisting
    of a key and a value.
  prefs: []
  type: TYPE_NORMAL
- en: There are two built-in versions of a dictionary – non-generic (`Hashtable`)
    and generic (`Dictionary`). The sorted variant of a dictionary (`SortedDictionary`)
    is available, as well. All of them were described in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mechanism of a hash table is presented in the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Illustration of mapping keys to particular values](img/B18069_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Illustration of mapping keys to particular values
  prefs: []
  type: TYPE_NORMAL
- en: Due to the great performance of the hash table, such a data structure is frequently
    used in many real-world applications, such as for **associative arrays**, **database
    indices**, or **cache systems**. Within this book, you saw how to create a **phone
    book** to store entries where a person’s name is a key and a phone number is a
    value. Among other examples, you developed an application that helps employees
    of shops **find the location** of where a product should be placed, and you applied
    the sorted dictionary to create a simple **encyclopedia**, where a user can add
    entries.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another data structure from [*Chapter 6*](B18069_06.xhtml#_idTextAnchor195),
    *Dictionaries and Sets*, is a **set**, which is a **collection of distinct objects
    without duplicated elements and without any particular order**. Therefore, you
    can only get to know whether a given element is in the set or not. The sets are
    strictly connected with mathematical models and operations, such as **union**,
    **intersection**, **subtraction**, and **symmetric difference**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exemplary sets, storing data of various types, are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Illustration of sets with integer and string values](img/B18069_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Illustration of sets with integer and string values
  prefs: []
  type: TYPE_NORMAL
- en: While developing applications in the C# language, you can benefit from high-performance
    set-related operations provided by the `HashSet` class. As an example, you saw
    how to create a system that handles **one-time promotional coupons** and allows
    you to check whether the scanned one was already used. Another example was the
    **reporting service** for the system of a SPA center with four swimming pools.
    By using sets, you calculated statistics, such as the number of visitors to a
    pool, the most popular pool, and the number of people who visited at least one
    pool.
  prefs: []
  type: TYPE_NORMAL
- en: Trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next topic is about **trees**, which were the subject of [*Chapter 7*](B18069_07.xhtml#_idTextAnchor233),
    *Variants of Trees*. A tree consists of **nodes** with one **root**. The root
    contains no **parent** node, while all other nodes do. Moreover, each node can
    have any number of **child nodes**. The child nodes of the same parent can be
    called **siblings**, while a node without children is called a **leaf**.
  prefs: []
  type: TYPE_NORMAL
- en: 'An exemplary tree is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Illustration of a tree](img/B18069_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Illustration of a tree
  prefs: []
  type: TYPE_NORMAL
- en: A tree is a data structure that is great for the representation of various data,
    such as the **structure of a company**, divided into a few departments, where
    each has its own structure. You also saw an example where a tree was used to arrange
    a **simple quiz** consisting of a few questions and answers, which are shown depending
    on the previously taken decisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally speaking, each node in a tree can contain any number of children.
    However, in the case of **binary trees**, a node cannot contain more than two
    children – that is, it can contain no child nodes, or only one or two. However,
    there are no rules about relationships between the nodes. The exemplary binary
    trees are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Illustration of a binary tree and a binary search tree](img/B18069_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – Illustration of a binary tree and a binary search tree
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use a **binary search tree** (**BST**), the next rule is introduced.
    It states that, for any node, the values of all nodes in its left subtree must
    be smaller than its value, and that the values of all nodes in its right subtree
    must be greater than its value. The exemplary BST is presented on the right-hand
    side of the preceding illustration.
  prefs: []
  type: TYPE_NORMAL
- en: Another group of trees is called **self-balancing trees**, which keep a tree
    balanced all the time while adding and removing nodes. Their application is very
    important because it allows you to form the correctly arranged tree, which has
    a positive impact on performance. There are several variants of self-balancing
    trees, but **AVL trees** and **red-black trees** (**RBTs**) are some of the most
    popular.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the tree applications is related to processing strings, such as for
    `a` to `z`). When you go from the root to each node, you receive a string, which
    is either a saved word or its substring, as presented in the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Illustration of a trie](img/B18069_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – Illustration of a trie
  prefs: []
  type: TYPE_NORMAL
- en: 'A **heap** is another subtype of a tree and exists in many variants, including
    a **binary heap**. It contains two versions – namely, **min-heap** and **max-heap**.
    For each of them, the additional property must be satisfied. For the min-heap,
    the value of each node must be greater than or equal to the value of its parent
    node. Thus, the root node contains the smallest value. For the max-heap, the value
    of each node must be less than or equal to the value of its parent node. Therefore,
    the root node always contains the largest value. The exemplary binary heaps are
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Illustration of a min-heap and max-heap](img/B18069_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – Illustration of a min-heap and max-heap
  prefs: []
  type: TYPE_NORMAL
- en: A heap is a convenient data structure for implementing a **priority queue**.
    Another interesting application is the sorting algorithm, named **heap sort**,
    which was presented and explained in the chapter regarding arrays and sorting.
  prefs: []
  type: TYPE_NORMAL
- en: Graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18069_08.xhtml#_idTextAnchor296), *Exploring Graphs*, was related
    to **graphs** – a very popular data structure with a broad range of applications.
    As a reminder, a graph is a data structure that consists of **nodes** and **edges**.
    Each edge connects two nodes. There are a few variants of edges in a graph, such
    as undirected and directed, as well as unweighted and weighted. A graph can be
    represented as an adjacency list or as an adjacency matrix.'
  prefs: []
  type: TYPE_NORMAL
- en: All of these topics were described in the book, together with the problem of
    graph **traversal** with breadth-first search and depth-first search algorithms,
    finding the **minimum spanning tree** with Kruskal’s and Prim’s algorithms, **node
    coloring**, and **finding the shortest path** in a graph with Dijkstra’s algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exemplary graphs are shown in the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Illustration of graphs](img/B18069_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – Illustration of graphs
  prefs: []
  type: TYPE_NORMAL
- en: A graph data structure is commonly used in various applications. It is also
    a great way to represent diverse data, such as the **structure of friends** available
    on a social media site. Here, the nodes can represent contacts, while edges represent
    relationships between people. Thus, you can easily check whether two contacts
    know each other or how many people should be involved to arrange a meeting between
    two particular people.
  prefs: []
  type: TYPE_NORMAL
- en: Another common application of graphs involves the problem of **finding a path**.
    As an example, you can use a graph to find a path between two points in the city,
    taking into account the distance or time necessary for driving. You can use a
    graph to represent a map of a city, where nodes are intersections and edges represent
    roads. You can assign weights to edges to indicate the necessary distance or time
    for driving a given road.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other applications related to graphs. For instance, the minimum
    spanning tree can be used to create a **plan of connections between buildings**
    to supply all of them with a telecommunication cable at the smallest cost. The
    node coloring problem was used in the book for **coloring voivodeships** on a
    map of Poland according to the rule that two voivodeships that have common borders
    cannot have the same color. Another shown example involves Dijkstra’s algorithm
    for finding **the shortest path in a game map**, taking into account various obstacles.
  prefs: []
  type: TYPE_NORMAL
- en: The last word
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You just reached the end of the last chapter of the book. First, the classification
    of data structures was presented, taking into account linear and non-linear data
    structures. In the first group, you can find arrays, lists, stacks, and queues,
    while the second group involves graphs and their subtypes, including trees and
    heaps. In the following part of this chapter, the diversity of applications of
    various data structures was taken into account. You saw a short summary of each
    described data structure, as well as information about some problems that can
    be solved with the use of a particular data structure, such as a queue or a graph.
    To make the content easier to understand, as well as to remind you of the various
    topics from the previous chapters, the summary was equipped with brief descriptions
    and illustrations of data structures.
  prefs: []
  type: TYPE_NORMAL
- en: In the introduction to this book, I invited you to start your adventure with
    data structures and algorithms. While reading the following chapters, writing
    hundreds of lines of code, and debugging, you had a chance to familiarize yourself
    with various data structures, starting with arrays and lists, through stacks,
    queues, dictionaries, and sets, and ending with trees and graphs. I hope that
    this book is only the first step in your long, challenging, and successful adventure
    with data structures and algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: I would like to thank you for reading this book. If you have any questions or
    problems regarding the described content, please do not hesitate to contact me
    directly using the contact information shown at [https://marcin.com](https://marcin.com).
    While visiting my website, you can also find answers to many questions that you
    can ask during your development career. Please also tell me what topics are missing
    from this book that you want to learn about for the next edition of this book
    or from another of my books. I really hope that you will benefit from the presented
    content. I would like to wish you all the best in your career as a software developer,
    and I hope that you have many successful projects! I will be very happy if you
    let me know about your great projects, especially if they are inspired by the
    content of this book. Good luck and keep in touch!
  prefs: []
  type: TYPE_NORMAL
