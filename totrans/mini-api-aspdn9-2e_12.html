<html><head></head><body>
  <div id="_idContainer071">
   <h1 class="chapter-number" id="_idParaDest-144">
    <a id="_idTextAnchor174">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     12
    </span>
   </h1>
   <h1 id="_idParaDest-145">
    <a id="_idTextAnchor175">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Caching Strategies for Enhanced Performance
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     It’s been frequently mentioned how minimal APIs should be just that, minimal.
    </span>
    <span class="koboSpan" id="kobo.3.2">
     For the most part, this minimalism has been based on minimizing real estate – trying to keep the visible footprint of our code on the page as minimal as possible.
    </span>
    <span class="koboSpan" id="kobo.3.3">
     But minimalism in APIs also extends to the resource footprint, meaning that, where possible, we should minimize the strain put on the system by overusing database/network connections
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.4.1">
      and CPU.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     Enhancing the performance of APIs through minimalism is the goal, and this can be achieved in part
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.6.1">
      by caching.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.7.1">
     When data is cached, it is stored following its first use for reuse in future operations.
    </span>
    <span class="koboSpan" id="kobo.7.2">
     By doing this, we can reduce the latency or overhead incurred when fetching
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.8.1">
      that data.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.9.1">
     In this chapter, we’re going to cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.10.1">
      main topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.11.1">
      Introduction to caching in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.12.1">
       minimal APIs
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.13.1">
      In-memory
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.14.1">
       caching techniques
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.15.1">
      Distributed
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.16.1">
       caching strategies
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.17.1">
       Response caching
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-146">
    <a id="_idTextAnchor176">
    </a>
    <span class="koboSpan" id="kobo.18.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.19.1">
     Visual Studio 2022 or Visual Studio Code will be required to run the code in this chapter.
    </span>
    <span class="koboSpan" id="kobo.19.2">
     You will also need SQL Server 2022 installed on your system, with a working database you can query as an example.
    </span>
    <span class="koboSpan" id="kobo.19.3">
     It is recommended that you complete
    </span>
    <a href="B20968_09.xhtml#_idTextAnchor143">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.20.1">
        Chapter 9
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.21.1">
     before this chapter so that you have the example employee database configured
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.22.1">
      for use.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.23.1">
     The code for this chapter is available in the GitHub repository
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.24.1">
      at:
     </span>
    </span>
    <a href="https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.25.1">
       https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.26.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.27.1">
     This chapter demonstrates distributed caching strategies that require an in-memory caching provider – in this example’s case, Redis.
    </span>
    <span class="koboSpan" id="kobo.27.2">
     Installing Redis is not within the scope of this book, but documentation on how to install Redis or host it in Azure can be found at
    </span>
    <a href="https://learn.microsoft.com/en-us/azure/azure-cache-for-redis/quickstart-create-redis">
     <span class="koboSpan" id="kobo.28.1">
      https://learn.microsoft.com/en-us/azure/azure-cache-for-redis/quickstart-create-redis
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.29.1">
      and
     </span>
    </span>
    <a href="https://redis.io/docs/latest/operate/oss_and_stack/install/install-redis/">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.30.1">
       https://redis.io/docs/latest/operate/oss_and_stack/install/install-redis/
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.31.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.32.1">
     The way to use Redis on your local Windows machine would be to install it through
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.33.1">
      Windows Subsystem for Linux
     </span>
    </strong>
    <span class="koboSpan" id="kobo.34.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.35.1">
      WSL
     </span>
    </strong>
    <span class="koboSpan" id="kobo.36.1">
     ) and
    </span>
    <a id="_idIndexMarker477">
    </a>
    <span class="koboSpan" id="kobo.37.1">
     host it on your local WSL instance.
    </span>
    <span class="koboSpan" id="kobo.37.2">
     More information on installing WSL can be found
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.38.1">
      here:
     </span>
    </span>
    <a href="https://learn.microsoft.com/en-us/windows/wsl/install">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.39.1">
       https://learn.microsoft.com/en-us/windows/wsl/install
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.40.1">
      .
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-147">
    <a id="_idTextAnchor177">
    </a>
    <span class="koboSpan" id="kobo.41.1">
     Introduction to caching in minimal APIs
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.42.1">
     APIs execute operations, and operations (usually) rely on data or state.
    </span>
    <span class="koboSpan" id="kobo.42.2">
     Data needs to be retrieved or calculated as it either exists
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.43.1">
      at rest
     </span>
    </em>
    <span class="koboSpan" id="kobo.44.1">
     (i.e., in a database or in a remote file location) or it exists as
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.45.1">
      data in use
     </span>
    </em>
    <span class="koboSpan" id="kobo.46.1">
     (i.e., data that is yet to be calculated to produce
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.47.1">
      other data).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.48.1">
     Whichever way we look at it, there is overhead in retrieving data, whether it is retrieved as-is or whether it is the result of a computation.
    </span>
    <span class="koboSpan" id="kobo.48.2">
     Caching
    </span>
    <a id="_idIndexMarker478">
    </a>
    <span class="koboSpan" id="kobo.49.1">
     aims to reduce that overhead by making use of data or state that has already been produced from its
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.50.1">
      original source.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.51.1">
     It could be argued that computing is so fast now that the overhead should be minimal to the point that caching is no longer needed.
    </span>
    <span class="koboSpan" id="kobo.51.2">
     This would, however, be woefully inaccurate.
    </span>
    <span class="koboSpan" id="kobo.51.3">
     Looking at a single operation in isolation, such as retrieving a record from a SQL database, may seem extremely quick, but at scale, the benefits of caching become
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.52.1">
      more apparent.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.53.1">
     Let’s take a working example of how caching can be beneficial.
    </span>
    <span class="koboSpan" id="kobo.53.2">
     A start-up has built a system that can be used to send alerts to mobile devices, accessible via a minimal API.
    </span>
    <span class="koboSpan" id="kobo.53.3">
     They must ensure that requests are allowed to be processed by calling clients, so they require an API key to be sent in the request headers for validation during
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.54.1">
      each request.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.55.1">
     To validate the key, the start-up’s developers decided to outsource the key validation to a cloud company that manages the key and the encryption algorithms to be used – hosting an API itself for this purpose.
    </span>
    <span class="koboSpan" id="kobo.55.2">
     The start-up is charged per request for validating
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.56.1">
      the key.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.57.1">
     In the early days, the cost of validating keys went relatively unnoticed because they had a low number of sporadic requests.
    </span>
    <span class="koboSpan" id="kobo.57.2">
     However, as soon as their business started to grow, so did the number of requests.
    </span>
    <span class="koboSpan" id="kobo.57.3">
     Soon, they had a scary invoice from their cloud partner for a huge amount of API validations, charged
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.58.1">
      per request.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.59.1">
     Caching
    </span>
    <a id="_idIndexMarker479">
    </a>
    <span class="koboSpan" id="kobo.60.1">
     could have been used to mitigate the cost of validating API keys.
    </span>
    <span class="koboSpan" id="kobo.60.2">
     An initial request could be made to validate the key, and then the result could be cached.
    </span>
    <span class="koboSpan" id="kobo.60.3">
     From then on, when requests using that key are received, there would be an initial check against the cache first.
    </span>
    <span class="koboSpan" id="kobo.60.4">
     If there is a record in the cache that validates the key, there is no need to call the paid API to validate it.
    </span>
    <span class="koboSpan" id="kobo.60.5">
     Each cached record has an expiration date, meaning that it can be refreshed by calling the paid API again.
    </span>
    <span class="koboSpan" id="kobo.60.6">
     This dramatically reduces the financial effects of validating
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.61.1">
      API keys.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.62.1">
     We’ve established that caching is good for performance, reducing latency, and supporting overall application scalability, but what type of caching should we use?
    </span>
    <span class="koboSpan" id="kobo.62.2">
     To answer this, we will explore three key caching methods available in minimal API development: in-memory caching, distributed caching, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.63.1">
      response caching.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-148">
    <a id="_idTextAnchor178">
    </a>
    <span class="koboSpan" id="kobo.64.1">
     In-memory caching techniques
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.65.1">
     Out of the various caching techniques supported by ASP.NET Core,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.66.1">
      in-memory caching
     </span>
    </strong>
    <span class="koboSpan" id="kobo.67.1">
     is
    </span>
    <a id="_idIndexMarker480">
    </a>
    <span class="koboSpan" id="kobo.68.1">
     probably the
    </span>
    <a id="_idIndexMarker481">
    </a>
    <span class="koboSpan" id="kobo.69.1">
     simplest.
    </span>
    <span class="koboSpan" id="kobo.69.2">
     This type of caching stores its contents in the memory of the machine hosting the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.70.1">
      minimal API.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.71.1">
     The implementation of the cache is based on
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.72.1">
      IMemoryCache
     </span>
    </strong>
    <span class="koboSpan" id="kobo.73.1">
     , included within the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.74.1">
      Microsoft.Extensions.Caching.Memory
     </span>
    </strong>
    <span class="koboSpan" id="kobo.75.1">
     package, which is usually included by default in ASP.NET
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.76.1">
      Core projects.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.77.1">
     Like other core services,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.78.1">
      IMemoryCache
     </span>
    </strong>
    <span class="koboSpan" id="kobo.79.1">
     is available using dependency injection, so we can quite easily inject it as needed within various areas of a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.80.1">
      minimal API.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.81.1">
     Using this cache type, we can store an object, which is our minimal requirement, but we can also very easily specify an expiration time, which is a best practice as periodically recycling the cache keeps it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.82.1">
      running smoothly.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.83.1">
     Let’s explore a simple example within a minimal API.
    </span>
    <span class="koboSpan" id="kobo.83.2">
     I’m going to use the API project from
    </span>
    <a href="B20968_09.xhtml#_idTextAnchor143">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.84.1">
        Chapter 9
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.85.1">
     (which is available on GitHub) as a foundation for this example project.
    </span>
    <span class="koboSpan" id="kobo.85.2">
     Our aim is to mitigate the latency and overhead incurred when communicating with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.86.1">
      a database.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.87.1">
     In this API, we have an endpoint that allows clients to get an employee with a specific ID.
    </span>
    <span class="koboSpan" id="kobo.87.2">
     The API will use Entity Framework to run a SQL query against the database, returning the result in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.88.1">
      request response.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.89.1">
     Using an
    </span>
    <a id="_idIndexMarker482">
    </a>
    <span class="koboSpan" id="kobo.90.1">
     in-memory cache, we
    </span>
    <a id="_idIndexMarker483">
    </a>
    <span class="koboSpan" id="kobo.91.1">
     can add some optimization logic to this operation.
    </span>
    <span class="koboSpan" id="kobo.91.2">
     Here are the steps we are going to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.92.1">
      work through:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.93.1">
      Run the operation as requested, fetching the data from
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.94.1">
       the database.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.95.1">
      Check the in-memory cache to see whether the employee with this ID is
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.96.1">
       currently cached.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.97.1">
      If it isn’t, add the retrieved employee to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.98.1">
       the cache.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.99.1">
      Return the employee in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.100.1">
       request response.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.101.1">
      Create a request for the same employee (
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.102.1">
       same ID).
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.103.1">
      Get the employee from the cache instead of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.104.1">
       the database.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.105.1">
      Return the cached employee to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.106.1">
       the client.
      </span>
     </span>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.107.1">
     Before we can achieve this goal, we need to reference
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.108.1">
      IMemoryCache
     </span>
    </strong>
    <span class="koboSpan" id="kobo.109.1">
     in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.110.1">
      the project.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.111.1">
     First, add
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.112.1">
      IMemoryCache
     </span>
    </strong>
    <span class="koboSpan" id="kobo.113.1">
     to the dependency injection container
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.114.1">
      in
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.115.1">
       Program.cs
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.116.1">
      :
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.117.1">
builder.Services.AddMemoryCache();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.118.1">
     Then, you can create the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.119.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.120.1">
     endpoint, injecting this
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.121.1">
      IMemoryCache
     </span>
    </strong>
    <span class="koboSpan" id="kobo.122.1">
     object along
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.123.1">
      with
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.124.1">
       DapperService
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.125.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.126.1">
app.MapGet(
    "/employees/{id}",
    async (int id,
           [FromServices] DapperService dapperService,
           IMemoryCache memoryCache) =&gt;
{
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.127.1">
     Now that you have a cache, you can add code for retrieving values
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.128.1">
      from it:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.129.1">
if(memoryCache.TryGetValue(id, out var result))
{
    return result;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.130.1">
     By first running a check, we can avoid unnecessary execution of code and get the required object to the client much quicker, also avoiding a call into the database
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.131.1">
      via Dapper.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.132.1">
     Assuming that the item doesn’t exist, we will use our original logic of looking up the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.133.1">
      Employee
     </span>
    </strong>
    <span class="koboSpan" id="kobo.134.1">
     record from the database using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.135.1">
      DapperService
     </span>
    </strong>
    <span class="koboSpan" id="kobo.136.1">
     .
    </span>
    <span class="koboSpan" id="kobo.136.2">
     However, instead of returning the item straight away, we will first add it to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.137.1">
      the cache:
     </span>
    </span>
   </p>
   <pre class="source-code">
<strong class="source-inline"><span class="koboSpan" id="kobo.138.1">  var employee = await dapperService.GetEmployeeById(id);</span></strong>
<strong class="source-inline"><span class="koboSpan" id="kobo.139.1">  memoryCache.Set&lt;Employee&gt;(employee.Id, employee);</span></strong></pre>
   <p>
    <span class="koboSpan" id="kobo.140.1">
     This works well but, ideally, we don’t want this to stay in the cache forever.
    </span>
    <span class="koboSpan" id="kobo.140.2">
     It’s a good idea to refresh the cache periodically because data may change, and we want to ensure we are getting the most up-to-date data where possible while balancing this with reducing latency from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.141.1">
      database transactions.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.142.1">
     We can strike this
    </span>
    <a id="_idIndexMarker484">
    </a>
    <span class="koboSpan" id="kobo.143.1">
     balance by imposing an expiration on cached objects.
    </span>
    <span class="koboSpan" id="kobo.143.2">
     This needs to be done
    </span>
    <a id="_idIndexMarker485">
    </a>
    <span class="koboSpan" id="kobo.144.1">
     after the retrieval of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.145.1">
      Employee
     </span>
    </strong>
    <span class="koboSpan" id="kobo.146.1">
     object but before it is added to the cache.
    </span>
    <span class="koboSpan" id="kobo.146.2">
     Let’s set an expiry of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.147.1">
      30
     </span>
    </strong>
    <span class="koboSpan" id="kobo.148.1">
     seconds as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.149.1">
      an example:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.150.1">
var cacheEntryOptions = new MemoryCacheEntryOptions()
    .SetSlidingExpiration(TimeSpan.FromSeconds(30));</span></pre>
   <p>
    <span class="koboSpan" id="kobo.151.1">
     By creating an instance of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.152.1">
      MemoryCacheEntryOptions
     </span>
    </strong>
    <span class="koboSpan" id="kobo.153.1">
     , we have defined some cache configuration parameters that can be passed into the cache when we add a new object to it.
    </span>
    <span class="koboSpan" id="kobo.153.2">
     Update the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.154.1">
      cache.Set()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.155.1">
     method to include
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.156.1">
      this parameter:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.157.1">
memoryCache.Set&lt;Employee&gt;(
    employee.Id,
    employee,
    cacheEntryOptions);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.158.1">
     Your endpoint
    </span>
    <a id="_idIndexMarker486">
    </a>
    <span class="koboSpan" id="kobo.159.1">
     should now
    </span>
    <a id="_idIndexMarker487">
    </a>
    <span class="koboSpan" id="kobo.160.1">
     look
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.161.1">
      like this:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.162.1">
            app.MapGet("/employees/{id}",
            async (int id,
                   [FromServices] DapperService
                   dapperService, IMemoryCache memoryCache)
                   =&gt;
            {
                if(memoryCache.TryGetValue(id,
                    out var result))
                {
                    return result;
                }
                var employee = await
                    dapperService.GetEmployeeById(id);
                var cacheEntryOptions = new
                    MemoryCacheEntryOptions()
                        .SetSlidingExpiration(
                            TimeSpan.FromSeconds(30));
                memoryCache.Set&lt;Employee&gt;(
                    employee.Id,
                    employee,
                    cacheEntryOptions);
                return Results.Ok(employee);
            });</span></pre>
   <p>
    <span class="koboSpan" id="kobo.163.1">
     There you go!
    </span>
    <span class="koboSpan" id="kobo.163.2">
     You’ve successfully introduced caching to your minimal API endpoint
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.164.1">
      using
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.165.1">
       IMemoryCache
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.166.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.167.1">
     In-memory caching is
    </span>
    <a id="_idIndexMarker488">
    </a>
    <span class="koboSpan" id="kobo.168.1">
     most likely the default caching strategy when starting an API project, but if
    </span>
    <a id="_idIndexMarker489">
    </a>
    <span class="koboSpan" id="kobo.169.1">
     your system has growth in adoption, then scalability and high availability will become increasingly important measurements of success.
    </span>
    <span class="koboSpan" id="kobo.169.2">
     When looking to scale, distributed caching strategies can be adopted with the use of a reputable caching framework.
    </span>
    <span class="koboSpan" id="kobo.169.3">
     Let’s look at one of the most famous caching
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.170.1">
      technologies, Redis.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-149">
    <a id="_idTextAnchor179">
    </a>
    <span class="koboSpan" id="kobo.171.1">
     Distributed caching strategies
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.172.1">
     A
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.173.1">
      distributed caching strategy
     </span>
    </strong>
    <span class="koboSpan" id="kobo.174.1">
     uses
    </span>
    <a id="_idIndexMarker490">
    </a>
    <span class="koboSpan" id="kobo.175.1">
     methods such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.176.1">
      IMemoryCache
     </span>
    </strong>
    <span class="koboSpan" id="kobo.177.1">
     within an architecture that supports scalability.
    </span>
    <span class="koboSpan" id="kobo.177.2">
     In contrast to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.178.1">
      IMemoryCache
     </span>
    </strong>
    <span class="koboSpan" id="kobo.179.1">
     , distributed caching
    </span>
    <a id="_idIndexMarker491">
    </a>
    <span class="koboSpan" id="kobo.180.1">
     involves a connection between the ASP.NET application hosting your minimal API and the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.181.1">
      caching provider.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.182.1">
     In this example, the caching provider I will be
    </span>
    <a id="_idIndexMarker492">
    </a>
    <span class="koboSpan" id="kobo.183.1">
     using
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.184.1">
      is
     </span>
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.185.1">
       Redis
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.186.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.187.1">
     Redis is an in-memory caching provider that can also be used as an in-memory database.
    </span>
    <span class="koboSpan" id="kobo.187.2">
     It is available as an open source product for installation on-premises or in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.188.1">
      the cloud.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.189.1">
     For the purposes of this demonstration, I installed Redis on an Ubuntu machine as a basic service.
    </span>
    <span class="koboSpan" id="kobo.189.2">
     I then updated the Redis configuration so that Redis binds to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.190.1">
      0.0.0.0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.191.1">
     , listening on the default port of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.192.1">
      6379
     </span>
    </strong>
    <span class="koboSpan" id="kobo.193.1">
     .
    </span>
    <span class="koboSpan" id="kobo.193.2">
     This should only be relevant to you if your Redis service is running on a separate machine like
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.194.1">
      mine is.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.195.1">
     With a Redis instance available, I can add the required NuGet packages to the API project for interacting with Redis as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.196.1">
      a cache.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.197.1">
     Add the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.198.1">
      NRedisStack
     </span>
    </strong>
    <span class="koboSpan" id="kobo.199.1">
     package to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.200.1">
      the project:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.201.1">
dotnet add package NRedisStack</span></pre>
   <p>
    <span class="koboSpan" id="kobo.202.1">
     We will still be interacting with the cache in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.203.1">
      Program.cs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.204.1">
     , so we need to reference namespaces from
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.205.1">
       NRedisStack
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.206.1">
      here:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.207.1">
using StackExchange.Redis;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.208.1">
     Now, we can update the endpoint for retrieving employees by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.209.1">
      Id
     </span>
    </strong>
    <span class="koboSpan" id="kobo.210.1">
     with a new cache, replacing the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.211.1">
      IMemoryCache
     </span>
    </strong>
    <span class="koboSpan" id="kobo.212.1">
     implementation
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.213.1">
      with Redis.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.214.1">
     We start by
    </span>
    <a id="_idIndexMarker493">
    </a>
    <span class="koboSpan" id="kobo.215.1">
     creating
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.216.1">
      ConfigurationOptions
     </span>
    </strong>
    <span class="koboSpan" id="kobo.217.1">
     , which can be passed as
    </span>
    <a id="_idIndexMarker494">
    </a>
    <span class="koboSpan" id="kobo.218.1">
     a parameter when connecting to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.219.1">
      Redis instance:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.220.1">
ConfigurationOptions options = new ConfigurationOptions
{
    EndPoints = { { "REDIS IP", 6379 } },
};
ConnectionMultiplexer redis =
    ConnectionMultiplexer.Connect(options);
IDatabase db = redis.GetDatabase();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.221.1">
     Following this, we should now have a Redis connection that can be referenced in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.222.1">
      db
     </span>
    </strong>
    <span class="koboSpan" id="kobo.223.1">
     variable.
    </span>
    <span class="koboSpan" id="kobo.223.2">
     Next, we will add the equivalent logic for caching from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.224.1">
      IMemoryCache
     </span>
    </strong>
    <span class="koboSpan" id="kobo.225.1">
     example, where we first check for a cache entry with a key (the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.226.1">
      Employee
     </span>
    </strong>
    <span class="koboSpan" id="kobo.227.1">
     ID as a string, in this case) and return that if it exists, returning the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.228.1">
      Employee
     </span>
    </strong>
    <span class="koboSpan" id="kobo.229.1">
     instance from the cache if
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.230.1">
      it does:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.231.1">
var employeeIdKey = id.ToString();
var cachedEmployee = db.StringGet(employeeIdKey);
if (cachedEmployee.HasValue)
{
    return Results.Ok(
       JsonSerializer.Deserialize&lt;Employee&gt;(cachedEmployee)
    );
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.232.1">
     When calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.233.1">
      StringGet()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.234.1">
     to retrieve a relevant entry from Redis, if it doesn’t exist already, an object will be returned with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.235.1">
      HasValues
     </span>
    </strong>
    <span class="koboSpan" id="kobo.236.1">
     set to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.237.1">
      false
     </span>
    </strong>
    <span class="koboSpan" id="kobo.238.1">
     .
    </span>
    <span class="koboSpan" id="kobo.238.2">
     Assuming that the Redis cache doesn’t contain the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.239.1">
      Employee
     </span>
    </strong>
    <span class="koboSpan" id="kobo.240.1">
     record we’re looking for, we fetch it from the database and
    </span>
    <a id="_idIndexMarker495">
    </a>
    <span class="koboSpan" id="kobo.241.1">
     cache it before
    </span>
    <a id="_idIndexMarker496">
    </a>
    <span class="koboSpan" id="kobo.242.1">
     returning it to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.243.1">
      the client:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.244.1">
var employee = await dapperService.GetEmployeeById(id);
db.StringSet(
    employeeIdKey,
    JsonSerializer.Serialize(employee));</span></pre>
   <p>
    <span class="koboSpan" id="kobo.245.1">
     Please note that Redis doesn’t natively support the insertion of strongly typed .NET objects, so we need to convert the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.246.1">
      Employee
     </span>
    </strong>
    <span class="koboSpan" id="kobo.247.1">
     object to a JSON string through serialization when saving it and deserialize it from a JSON string to an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.248.1">
      Employee
     </span>
    </strong>
    <span class="koboSpan" id="kobo.249.1">
     object when
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.250.1">
      retrieving it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.251.1">
     Your updated Redis-connected endpoint should now look
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.252.1">
      like this:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.253.1">
app.MapGet(
    "/employees/{id}",
    async (int id,
           [FromServices] DapperService dapperService) =&gt;
{
    ConfigurationOptions options = new ConfigurationOptions
        {
          EndPoints = { { "192.168.2.8", 6379 } },
        };
        ConnectionMultiplexer redis =
            ConnectionMultiplexer.Connect(options);
        IDatabase db = redis.GetDatabase();
        var employeeIdKey = id.ToString();
        var cachedEmployee = db.StringGet(employeeIdKey);
        if (cachedEmployee.HasValue)
        {
            return Results.Ok(
                JsonSerializer.Deserialize&lt;Employee&gt;(
                    cachedEmployee));
        }
        var employee = await
            dapperService.GetEmployeeById(id);
        return Results.Ok(employee);
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.254.1">
     Implementing a cache in a separately hosted environment using something such as Redis has introduced more flexibility to our minimal API.
    </span>
    <span class="koboSpan" id="kobo.254.2">
     I encourage you to take this simple example further by creating a generic service that can facilitate the interactions between ASP.NET and the Redis cache so that you are ultimately decoupling the API from its caching system.
    </span>
    <span class="koboSpan" id="kobo.254.3">
     In the future, should you wish to move away from Redis to a different caching
    </span>
    <a id="_idIndexMarker497">
    </a>
    <span class="koboSpan" id="kobo.255.1">
     technology, you need to be able to do this without affecting the original
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.256.1">
      API
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker498">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.257.1">
      code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.258.1">
     We’ve covered two examples of caching strategies so far.
    </span>
    <span class="koboSpan" id="kobo.258.2">
     Let’s wrap up with a third technique, focusing on the caching of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.259.1">
      request responses.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-150">
    <a id="_idTextAnchor180">
    </a>
    <span class="koboSpan" id="kobo.260.1">
     Response caching
    </span>
   </h1>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.261.1">
      Response caching
     </span>
    </strong>
    <span class="koboSpan" id="kobo.262.1">
     works
    </span>
    <a id="_idIndexMarker499">
    </a>
    <span class="koboSpan" id="kobo.263.1">
     within the same logical principles as the previous two caching
    </span>
    <a id="_idIndexMarker500">
    </a>
    <span class="koboSpan" id="kobo.264.1">
     strategies, but instead of caching database objects in memory, it caches responses at the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.265.1">
      HTTP level.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.266.1">
     Like
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.267.1">
      IMemoryCache
     </span>
    </strong>
    <span class="koboSpan" id="kobo.268.1">
     , minimal APIs can leverage ASP.NET’s native middleware by enabling response caching as a feature
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.269.1">
      in
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.270.1">
       Program.cs
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.271.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.272.1">
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddResponseCaching();
var app = builder.Build();
app.UseResponseCaching();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.273.1">
     Once enabled, response caching is very simple to add to a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.274.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.275.1">
     endpoint.
    </span>
    <span class="koboSpan" id="kobo.275.2">
     We can add
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.276.1">
      HttpContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.277.1">
     to the parameters, and then, whenever we have the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.278.1">
      Employee
     </span>
    </strong>
    <span class="koboSpan" id="kobo.279.1">
     object and are ready to return it, we can set the response to be cached for a certain amount of time, meaning that requesting the same data within that time will simply return the cached HTTP response
    </span>
    <a id="_idIndexMarker501">
    </a>
    <span class="koboSpan" id="kobo.280.1">
     instead of
    </span>
    <a id="_idIndexMarker502">
    </a>
    <span class="koboSpan" id="kobo.281.1">
     touching
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.282.1">
      the database:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.283.1">
    app.MapGet(
        "/employees/{id}",
        async (int id,
               [FromServices] DapperService dapperService,
               HttpContext context) =&gt;
    {
        var employee = await
            dapperService.GetEmployeeById(id);
        context.Response.GetTypedHeaders().CacheControl =
            new Microsoft.Net.Http.Headers
                .CacheControlHeaderValue()
    {
        Public = true,
        MaxAge = TimeSpan.FromSeconds(60)
    };
        context.Response.Headers[Microsoft.Net.Http.Headers
            .HeaderNames.Vary] =
                new string[] { "Accept-Encoding" };
        return Results.Ok(employee);
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.284.1">
     As you can see, this is a
    </span>
    <a id="_idIndexMarker503">
    </a>
    <span class="koboSpan" id="kobo.285.1">
     remarkably straightforward way to cache frequent responses, and the
    </span>
    <a id="_idIndexMarker504">
    </a>
    <span class="koboSpan" id="kobo.286.1">
     expiry time can, of course, be adjusted as needed.
    </span>
    <span class="koboSpan" id="kobo.286.2">
     You could even combine the caching approaches, having an in-memory cache that retrieves the data and then caching
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.287.1">
      the response.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.288.1">
     With three working examples of caching in a minimal API under our belt, let’s review what we’ve learned in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.289.1">
      this chapter.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-151">
    <a id="_idTextAnchor181">
    </a>
    <span class="koboSpan" id="kobo.290.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.291.1">
     In this chapter, we have explored caching using three different strategies: ASP.NET in-memory, distributed, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.292.1">
      response caching.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.293.1">
     We started by defining caching as a concept, relating it to the context of minimal APIs, before exploring a hypothetical scenario of a company looking to save on the cost of retrieving data via APIs with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.294.1">
      a cache.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.295.1">
     Following this, we explored the ASP.NET native method of caching in memory, learning about
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.296.1">
      IMemoryCache
     </span>
    </strong>
    <span class="koboSpan" id="kobo.297.1">
     and how it can be implemented within an endpoint to limit the overhead produced by database transactions.
    </span>
    <span class="koboSpan" id="kobo.297.2">
     We also learned how to make cached
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.298.1">
      data expire.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.299.1">
     Then, we took this knowledge and expanded on it, following similar caching principles within a distributed cache in the form
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.300.1">
      of Redis.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.301.1">
     Finally, we reviewed an example of response caching, allowing us to take frequently sent requests and bypass the database by resending a previously sent
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.302.1">
      HTTP request.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.303.1">
     In the next chapter, we will explore the best practices you can observe to increase the readibility, scalibility and maintainability of your
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.304.1">
      minimal APIs.
     </span>
    </span>
   </p>
  </div>
 

  <div class="Content" id="_idContainer072">
   <h1 id="_idParaDest-152" lang="en-US" xml:lang="en-US">
    <a id="_idTextAnchor182">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     Part 4 - Best Practices, Design, and Deployment
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.2.1">
     In the final part, we shift our focus to the principles of robust API design and deployment.
    </span>
    <span class="koboSpan" id="kobo.2.2">
     You’ll learn about best practices for shipping production-ready minimal APIs, as well as strategies for testing and maintaining compatibility across
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.3.1">
      different environments.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.4.1">
     This part has the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.5.1">
      following chapters:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <a href="B20968_13.xhtml#_idTextAnchor183">
      <em class="italic">
       <span class="koboSpan" id="kobo.6.1">
        Chapter 13
       </span>
      </em>
     </a>
     <span class="koboSpan" id="kobo.7.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.8.1">
       Best Practices for Minimal API Resiliency
      </span>
     </em>
    </li>
    <li>
     <a href="B20968_14.xhtml#_idTextAnchor200">
      <em class="italic">
       <span class="koboSpan" id="kobo.9.1">
        Chapter 14
       </span>
      </em>
     </a>
     <span class="koboSpan" id="kobo.10.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.11.1">
       Unit Testing
      </span>
     </em>
     <em class="italic">
      <span class="koboSpan" id="kobo.12.1">
       , Compatibility, and Deployment of Minimal APIs
      </span>
     </em>
    </li>
   </ul>
  </div>
  <div>
   <div id="_idContainer073">
   </div>
  </div>
  <div>
   <div id="_idContainer074">
   </div>
  </div>
  <div>
   <div id="_idContainer075">
   </div>
  </div>
  <div>
   <div id="_idContainer076">
   </div>
  </div>
  <div>
   <div id="_idContainer077">
   </div>
  </div>
  <div>
   <div class="Basic-Graphics-Frame" id="_idContainer078">
   </div>
  </div>
  <div>
   <div class="Basic-Graphics-Frame" id="_idContainer079">
   </div>
  </div>
  <div>
   <div id="_idContainer080">
   </div>
  </div>
  <div>
   <div id="_idContainer081">
   </div>
  </div>
  <div>
   <div class="Basic-Graphics-Frame" id="_idContainer082">
   </div>
  </div>
 </body></html>