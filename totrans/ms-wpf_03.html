<html><head></head><body>
        

                            
                    <h1 class="header-title">Writing Custom Application Frameworks</h1>
                
            
            
                
<p>In this chapter, we will investigate application frameworks and the benefits that they can bring us. We find out the differences between providing this functionality via base classes and interfaces and also discover other ways to build functionality into our frameworks. We will then use this newfound knowledge to begin to construct our own application framework to streamline our future application development. The chapter will finish off by inspecting a variety of techniques to ensure that our applications maintain the essential Separation of Concerns that MVVM provides.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What is an application framework?</h1>
                
            
            
                
<p>In the simplest terms, an application framework is comprised of a library of classes that, together, provide the most common functionality required by an application. By using an application framework, we can vastly reduce the amount of work and time that is required to create the various parts of the application. In short, they support the future development of the application.</p>
<p>In typical three-tier applications, the framework often extends through all layers of the application; the <strong>Presentation Layer</strong>, the <strong>Business Layer</strong>, and the <strong>Data Access Layer</strong>. In a WPF application using the MVVM pattern, we can, therefore, see aspects of the application framework in all three components of the pattern; the Models, the View Models, and the Views.</p>
<p>Apart from the obvious benefits of the reduced production times and effort involved in creating our application components, application frameworks also provide many additional benefits. Typical application frameworks promote reusability, which is one of the core aims of <strong>Object-Oriented Programming</strong> (<strong>OOP</strong>). They do this by providing generic interfaces and/or base classes that can be used to define the various application components.</p>
<p>By reusing these application framework interfaces and base classes, we also instill a sense of uniformity and consistency throughout the application. Furthermore, as these frameworks generally provide additional functionality, or services, the developers working on the application can save further time when requiring this particular functionality.</p>
<p>Concepts like modularity, maintainability, testability, and extensibility can also be realized by using an application framework. These frameworks often come with the ability to run individual components independently of each other and this fits WPF and the MVVM pattern extremely well. Additionally, application frameworks can also supply patterns of implementation to further simplify the process of constructing new application components.</p>
<p>Different frameworks are created for different technologies and WPF already have a few publicly available. Some are relatively lightweight, like the <strong>MVVM Light Toolkit</strong> and the <strong>WPF Application Framework</strong> (<strong>WAF</strong>), while others are more heavyweight, like <strong>Caliburn.Micro</strong> and the now open source <strong>Prism</strong>. While it is likely that you may have used one or more of these frameworks at work, instead of investigating these in this chapter, we'll look at how to create our own lightweight custom framework, that will implement just the features that we need.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Encapsulating common functionality</h1>
                
            
            
                
<p>Probably the most commonly used interface in any WPF application would be the <kbd>INotifyPropertyChanged</kbd> interface, as it is required to correctly implement data binding. By providing an implementation of this interface in our base class, we can avoid having to repeatedly implement it in every single View Model class. It is, therefore, a great candidate for inclusion in our base class. There are a number of different ways to implement it depending on our requirements, so let's take a look at the most basic first:</p>
<pre>public virtual event PropertyChangedEventHandler PropertyChanged; 
 
protected virtual void NotifyPropertyChanged(string propertyName) 
{ 
  if (PropertyChanged != null)  
    PropertyChanged(this, new PropertyChangedEventArgs(propertyName)); 
} </pre>
<p>In all forms of this implementation, we first need to declare the <kbd>PropertyChanged</kbd> event. This is the event that will be used to notify the various binding sources and targets of changes to the data bound values in our application. Note that this is the only requirement of the <kbd>INotifyPropertyChanged</kbd> interface. There is no <kbd>NotifyPropertyChanged</kbd> method that we have to implement, so you may well come across differently named methods that perform the same functionality.</p>
<p>Of course, without the method, just implementing the event would do nothing. The basic idea of this method is that as usual, we first check for <kbd>null</kbd>, and then raise the event, passing the raising class instance as the <kbd>sender</kbd> parameter and the name of the property that changed in the <kbd>PropertyChangedEventArgs</kbd>. We have already seen that the null conditional operator in C# 6.0 provides us with a shorthand notation for this:</p>
<pre>PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); </pre>
<p>Note that the declared access modifier on this method is <kbd>protected</kbd>, to ensure that all View Models that derive from this base class will have access to it, while non-deriving classes will not. Furthermore, the method is also marked as <kbd>virtual</kbd>, so that the derived classes can override this functionality if required. In the View Models, this method would be called from a property like this:</p>
<pre>private string name = string.Empty; 
 
public string Name 
{ 
  get { return name; } 
  set 
  { 
    if (name != value) 
    { 
      name = value; 
      NotifyPropertyChanged("Name"); 
    } 
  } 
} </pre>
<p>However, a new attribute was added in .NET 4.5, that gives us a shortcut to use with this implementation. The <kbd>CallerMemberNameAttribute</kbd> class enables us to automatically obtain the name of the method caller, or more specifically in our case, the name of the property that called the method. We can use it with an optional input parameter with a default value, like this:</p>
<pre>protected virtual void NotifyPropertyChanged( 
  [CallerMemberName]string propertyName = "") 
{ 
  PropertyChanged?.Invoke(this, 
    new PropertyChangedEventArgs(propertyName)); 
} </pre>
<p>The calling property can then be simplified to this:</p>
<pre>public string Name 
{ 
  get { return name; } 
  set { if (name != value) { name = value; NotifyPropertyChanged(); } } 
} </pre>
<p>It's worth noting at this point that in .NET 4.5.3, another improvement to calling the most basic implementation of this method was introduced. The <kbd>nameof</kbd> operator also enables us to avoid using strings to pass the property name, as passing strings can be error prone. This operator basically converts the name of a property, variable, or method to a string at compile time, so the end result is exactly the same as passing the string, but less error prone when renaming definitions. Using the preceding property as an example, let's see how this operator is used:</p>
<pre>NotifyPropertyChanged(nameof(Name)); </pre>
<p>There are also other tricks that we can employ too. For example, we often need to notify the Framework that more than one property value has changed at once. Visualize a scenario where we have two properties named <kbd>Price</kbd> and <kbd>Quantity</kbd>, and a third property named <kbd>Total</kbd>. As you can imagine, the value of the <kbd>Total</kbd> property will come from the calculation of the <kbd>Price</kbd> value multiplied by the <kbd>Quantity</kbd> value:</p>
<pre>public decimal Total 
{ 
  get { return Price * Quantity; } 
} </pre>
<p>However, this property has no setter, <em>so where should we call the</em> <kbd>NotifyPropertyChanged</kbd> <em>method from?</em> The answer is simple. We need to call it from <em>both</em> of the constituent property setters, as they can both affect the resulting value of this property.</p>
<p>Traditionally, we would have to call the <kbd>NotifyPropertyChanged</kbd> method once for each constituent property and once for the <kbd>Total</kbd> property. However, it is possible to rewrite our implementation of this method to enable us to pass multiple property names to it in a single call. For this, we can make use of the <kbd>params</kbd> keyword to enable any number of input parameters:</p>
<pre>protected void NotifyPropertyChanged(params string[] propertyNames) 
{ 
  if (PropertyChanged != null) 
  { 
    foreach (string propertyName in propertyNames) 
    { 
      PropertyChanged(this, new PropertyChangedEventArgs(propertyName)); 
    } 
  } 
} </pre>
<p>When using the <kbd>params</kbd> keyword, we need to declare an array type input parameter. However, this array merely holds the input parameters and we do not need to supply an array when calling this method. Instead, we provide any number of input parameters of the same type and they will be implicitly added to the array. Going back to our example, this enables us to call the method like this:</p>
<pre>private decimal price = 0M; 
 
public decimal Price 
{ 
  get { return price; } 
  set  
  {  
    if (price != value)  
    { 
      price = value;  
      NotifyPropertyChanged(nameof(Price), nameof(Total));  
    } 
  } 
} </pre>
<p>We therefore have a variety of different ways to implement this method, depending on what suits our requirements. We can even add a number of overloads of the method to provide the users of our framework with more choices. We'll see a further enhancement to this method later, but for now, let's see what our <kbd>BaseViewModel</kbd> class might look like so far:</p>
<pre>using System.ComponentModel; <br/>using System.Runtime.CompilerServices;<br/>namespace CompanyName.ApplicationName.ViewModels 
{ 
  public class BaseViewModel : INotifyPropertyChanged 
  { 
    #region INotifyPropertyChanged Members 
 
    public event PropertyChangedEventHandler PropertyChanged; 
 
    protected virtual void NotifyPropertyChanged(<br/>      params string[] propertyNames) <br/>    { 
      if (PropertyChanged != null) 
      { 
        foreach (string propertyName in propertyNames)  
        { 
          PropertyChanged(this, 
            new PropertyChangedEventArgs(propertyName)); 
        } 
      } 
    } 
 
    protected virtual void NotifyPropertyChanged( 
      [CallerMemberName]string propertyName = "") 
    { 
      PropertyChanged?.Invoke(this, 
        new PropertyChangedEventArgs(propertyName)); 
    } 
 
    #endregion 
  } 
} </pre>
<p>To summarize, we started with an interface that declared a single event. The interface itself provides no functionality and in fact, we as the implementers, have to provide the functionality, in the form of the <kbd>NotifyPropertyChanged</kbd> method and the calling of that method each time a property value changes. But the reward for doing this is that the UI controls are listening and responding to those events and so, by implementing this interface, we have gained this additional data binding capability.</p>
<p>However, we can provide functionality in our application framework in a number of different ways. The two main ways are through the use of base classes and interfaces. The main difference between these two approaches relate to the amount of development that the users of our framework will have to accomplish in order to create the various application components.</p>
<p>When we use interfaces, we are basically supplying a contract that the developers will have to honor, by providing the implementation themselves. However, when we use base classes, we are able to provide that implementation for them. So generally, base classes provide ready-written functionality, whereas interfaces rely on the developers to provide some or all of that functionality for themselves.</p>
<p>We've just seen an example of implementing an interface in our View Model base class. Let's now take a look at what else we can encapsulate in our other framework base classes and compare the differences between providing features or functionality in base classes and interfaces. Let's turn our attention to our Data Model classes now.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">In base classes</h1>
                
            
            
                
<p>We have seen that in a WPF application, it is essential for us to have an implementation of the <kbd>INotifyPropertyChanged</kbd> interface in our View Model base class. Likewise, we will also need a similar implementation in our Data Model base class. Remember that when Data Models are mentioned here, we are discussing the business Model classes that are combined with the View Model properties and functionality from the second application structure example in <a href="b2021d5b-c625-4403-9609-724ff89b9e0c.xhtml">Chapter 1</a>, <em>A Smarter Way of Working with WPF</em>.</p>
<p>All of these <kbd>DataModel</kbd> classes will need to extend their base class because they will all need to have access to its <kbd>INotifyPropertyChanged</kbd> implementation. As we progress through the chapters in this book, we will see more and more reasons why we need separate base classes for our Data Models and View Models. For example, let's imagine that we want to provide these Data Models with some simple auditing properties and investigate what our base class might look like:</p>
<pre>using System; 
using System.ComponentModel;<br/>using System.Runtime.CompilerServices;<br/> 
namespace CompanyName.ApplicationName.DataModels 
{ 
  public class BaseDataModel : INotifyPropertyChanged 
  { 
    private DateTime createdOn; 
    private DateTime? updatedOn; 
    private User createdBy, updatedBy; 
 
    public DateTime CreatedOn 
    { 
      get { return createdOn; } 
      set { createdOn = value; NotifyPropertyChanged(); } 
    } 
 
    public User CreatedBy 
    { 
      get { return createdBy; } 
      set { createdBy = value; NotifyPropertyChanged(); } 
    } 
 
    public DateTime? UpdatedOn 
    { 
      get { return updatedOn; } 
      set { updatedOn = value; NotifyPropertyChanged(); } 
    } 
 
    public User UpdatedBy 
    { 
      get { return updatedBy; } 
      set { updatedBy = value; NotifyPropertyChanged(); } 
    } 
 
    #region INotifyPropertyChanged Members 
     
    ...
     
    #endregion 
  } 
} </pre>
<p>Here, we see our auditing properties, along with the hidden <kbd>INotifyPropertyChanged</kbd> implementation that we saw earlier. For now, let's keep the implementation the same as that of the <kbd>BaseViewModel</kbd> class. Note that using this particular base class would result in all derived classes getting access to these properties, whether they needed them or not.</p>
<p>We might then decide to declare another base class, so that we can have one that provides access to our implementation of the <kbd>INotifyPropertyChanged</kbd> interface and one that extends that base class and adds the new auditable properties shown earlier. In this way, all derived classes can make use of the <kbd>INotifyPropertyChanged</kbd> interface implementation and the classes that require the auditable properties as well can be derived from the second base class:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-2103 image-border" src="img/3683da7b-cf5e-4248-9817-6c312b354894.png" style="width:39.33em;height:16.92em;"/></p>
<p>For this basic example, we seem to have solved our problem. If these auditable properties were the only properties that we wanted to provide to our derived classes, then this would not be such a bad situation. However, an average a framework will typically provide far more than this.</p>
<p>Let's now imagine that we wanted to provide some basic undo capability. We'll see an example of this later in this chapter, but for now we'll keep this simple. Without actually specifying the required members of this new base class, let's just think about this first.</p>
<p>Now we have a situation where we already have two different base classes and we want to provide some further functionality. <em>Where should we declare our new properties?</em> We could derive from either one, or indirectly, from both of the existing base classes, as shown in the following diagram, in order to create this new <em>synchronizable</em> base class:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-2104 image-border" src="img/fb648ff4-7899-45fe-8384-951ca879067f.png" style="width:39.83em;height:17.00em;"/></p>
<p>So now, we could have four different base classes that the developers, that use our framework could extend. There could be some confusion as to exactly which base class they need to extend, but overall, this situation is still just about manageable. However, imagine if we want to provide some additional properties or functionality in one or more levels of base class.</p>
<p>In order to enable every combination of functionality from these base classes, we could end up with as many as eight separate base classes. Each additional level of functionality that we provide will either double the total number of base classes that we have, or mean that the developers sometimes have to derive from a base class with functionality or properties that they do not require. Now that we have uncovered a potential problem of utilizing base classes, let's see if declaring interfaces can help with this situation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Through interfaces</h1>
                
            
            
                
<p>Going back to our auditing example, we could have declared these properties in an interface instead. Let's see what this might look like:</p>
<pre>using System; 
 
namespace CompanyName.ApplicationName.DataModels.Interfaces 
{ 
  public interface IAuditable 
  { 
    DateTime CreatedOn { get; set; } 
 
    User CreatedBy { get; set; } 
 
    DateTime? UpdatedOn { get; set; } 
 
    User UpdatedBy { get; set; } 
  } 
} </pre>
<p>Now, if a developer requires these properties, they can implement this interface as well as extending the Data Model base class:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-2105 image-border" src="img/de114e5f-d44f-454d-bf16-834b289774d7.png" style="width:40.75em;height:17.50em;"/></p>
<p>Let's see an example of this in code now:</p>
<pre>using System; 
using CompanyName.ApplicationName.DataModels.Interfaces; 
 
namespace CompanyName.ApplicationName.DataModels 
{ 
  public class Invoice : BaseDataModel, IAuditable 
  { 
    private DateTime createdOn; 
    private DateTime? updatedOn; 
    private User createdBy, updatedBy; 
 
    public DateTime CreatedOn 
    { 
      get { return createdOn; } 
      set { createdOn = value; NotifyPropertyChanged(); } 
    } 
 
    public User CreatedBy 
    { 
      get { return createdBy; } 
      set { createdBy = value; NotifyPropertyChanged(); } 
    } 
 
    public DateTime? UpdatedOn 
    { 
      get { return updatedOn; } 
      set { updatedOn = value; NotifyPropertyChanged(); } 
    } 
 
    public User UpdatedBy 
    { 
      get { return updatedBy; } 
      set { updatedBy = value; NotifyPropertyChanged(); } 
    } 
  } 
} </pre>
<p>Initially then, it seems as though this could be a better way to go, but let's continue to investigate the same scenario that we looked at with the base classes. Let's now imagine that we want to provide the same basic undo capability using interfaces. We didn't actually investigate which members would be required for this, but it will require both properties and methods.</p>
<p>This is where the interface approach starts to break down somewhat. We can ensure that implementers of our <kbd>ISynchronization</kbd> interface have particular properties and methods, but we have no control over their implementation of those methods. In order to provide the ability to undo changes, we need to provide the actual implementation of these methods, rather than just the required scaffolding.</p>
<p>If this was left up to the developers to implement each time they used the interface, they might not implement it correctly, or perhaps they might implement it differently in different classes and break the consistency of the application. Therefore, to implement some functionality, it seems as though we really do need to use some kind of base class.</p>
<p>However, we also have a third option that involves a mix of the two approaches. We could implement some functionality in a base class, but instead of deriving our Data Model classes from it, we could add a property of that type to them, so that they can still access its public members.</p>
<p>We could then declare an interface that simply has a single property of the type of this new base class. In this way, we would be free to add the different functionality from different base classes to just the classes that require them. Let's look at an example of this:</p>
<pre>public interface IAuditable 
{ 
  Auditable Auditable { get; set; } 
} </pre>
<p>This <kbd>Auditable</kbd> class would have the same properties as those in the previous <kbd>IAuditable</kbd> interface shown in the preceding code. The new <kbd>IAuditable</kbd> interface would be implemented by the Data Model classes by simply declaring a property of type <kbd>Auditable</kbd> :</p>
<pre>public class User : IAuditable 
{ 
  private Auditable auditable; 
 
  public Auditable Auditable 
  { 
    get { return auditable; } 
    set { auditable = value; } 
  } 
   
  ... 
} </pre>
<p>It could be used by the framework, for example, to output the names of each user and when they were created into a report. In the following example, we use the <strong>Interpolated Strings</strong> syntax that was introduced in C# 6.0 for constructing our string. It's like the <kbd>string.Format</kbd> method, but with the method call replaced with a <kbd>$</kbd> sign and the numerical format items replaced with their related values:</p>
<pre>foreach (IAuditable user in Users) 
{ 
  Report.AddLine($"Created on {user.Auditable.CreatedOn}" by<br/>    {user.Auditable.CreatedBy.Name});<br/>}</pre>
<p>Most interestingly, as this interface could be implemented by many different types of object, the preceding code could also be used with objects of different types. Note this slight difference:</p>
<pre>List&lt;IAuditable&gt; auditableObjects = GetAuditableObjects(); 
foreach (IAuditable user in auditableObjects) 
{ 
  Report.AddLine($"Created on {user.Auditable.CreatedOn}" by<br/>    {user.Auditable.CreatedBy.Name});
} </pre>
<p>It's worth pointing out this useful ability to work with objects of different types is not limited to interfaces. This can also be achieved just as easily with base classes. Imagine a View that enabled the end user to edit a number of different types of object.</p>
<p>If we added a property named <kbd>PropertyChanges</kbd>, that returned details of changed properties, into the <kbd>BaseSynchronizableDataModel</kbd> class that we will see later, in the <em>Constructing a custom application framework</em> section, we could use this very similar code to display a confirmation of the changes from each object back to the user:</p>
<pre>List&lt;BaseSynchronizableDataModel&gt; baseDataModels = GetBaseDataModels();
foreach (BaseSynchronizableDataModel baseDataModel in baseDataModels) 
{ 
  if (baseDataModel.HasChanges)  
    FeedbackManager.Add(baseDataModel.PropertyChanges); 
} </pre>
<p>We have a number of choices when it comes to encapsulating pieces of pre-packaged functionality into our Data Model classes. Each of these methods that we have investigated so far have strengths and weaknesses. If we're sure that we want some pre-written functionality in every one of our Data Model classes, like that of the <kbd>INotifyPropertyChanged</kbd> interface, then we can simply encapsulate it in a base class and derive all of our Model classes from that.</p>
<p>If we just want our Models to have certain properties or methods that can be called from other parts of the framework, but are not concerned with the implementation, then we can use interfaces. If we want some combination of the two ideas, then we can implement a solution using the two methods together. It is up to us to choose the solution that best fits the requirements in hand.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">With Extension Methods</h1>
                
            
            
                
<p>There is a further method of providing additional functionality to the developers of our application that was mentioned when investigating the application structures in the <a href="b799e8cf-97d3-44e5-927a-c02c42d343fc.xhtml">Chapter 2</a>, <em>Debugging WPF Applications</em>. It is through the use of Extension Methods. If you are not familiar with this amazing .NET feature, Extension Methods enable us to write methods that can be used on objects that we did not create.</p>
<p>At this stage, it's worth pointing out that we don't generally write Extension Methods for classes that we have declared. There are two main reasons for this. The first is that we created these classes and so we have access to their source code and can therefore simply declare new methods in these classes directly.</p>
<p>The second reason is that there will be a reference to our <kbd>Extensions</kbd> project added to most other projects, including our <kbd>DataModels</kbd> project, so that they can all take advantage of the extra capabilities. Therefore, we can't add references to any of our other projects into the <kbd>Extensions</kbd> project, because it would create circular dependencies.</p>
<p>You are probably aware of Extension Methods already, although perhaps inadvertently, as most of the <strong>LINQ</strong> methods are Extension Methods. Once declared, they can be used just like the ordinary methods that were declared within the various classes that we are extending, although they are differentiated by having different icons in the Visual Studio IntelliSense display:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-2162 image-border" src="img/b025a8dd-5545-49ef-9722-864eaca65af2.png" style="width:27.08em;height:6.08em;"/></p>
<p>The basic principle when declaring them is to have a static class, where each method has an extra input parameter prefixed with the <kbd>this</kbd> keyword, that represents the object being extended. Note that this extra input parameter must be declared first in the parameter list and that it will not be visible in IntelliSense when calling the method on an instance of an object.</p>
<p>Extension Methods are declared as static methods, but are typically called using instance method syntax. A simple example should help to clarify this situation. Let's imagine that we want to be able to call a method on each item in a collection. In fact, we'll see an example of this being used in our <kbd>BaseSynchronizableCollection</kbd> class later in this chapter, but now, let's see how we can do this:</p>
<pre>using System; 
using System.Collections.Generic; 
 
namespace CompanyName.ApplicationName.Extensions 
{ 
  public static class IEnumerableExtensions 
  { 
    public static void ForEach&lt;T&gt;(this IEnumerable&lt;T&gt; collection,
      Action&lt;T&gt; action) 
    { 
      foreach (T item in collection) action(item); 
    } 
  } 
} </pre>
<p>Here, we see the <kbd>this</kbd> input parameter that specifies the instance of the target type that this Extension Method is called on. Remember that this won't appear in the parameter list in IntelliSense in Visual Studio, unless it is called through the static class itself, as shown in the following code:</p>
<pre>IEnumerableExtensions.ForEach(collection, i =&gt; i.RevertState()); </pre>
<p>Inside this method, we simply iterate through the collection items, calling the <kbd>Action</kbd> specified by the <kbd>action</kbd> input parameter and passing in each item as its parameter. After adding a <kbd>using</kbd> directive to the <kbd>CompanyName.ApplicationName.Extensions</kbd> namespace, let's see how this method is more usually called:</p>
<pre>collection.ForEach(i =&gt; i.PerformAction()); </pre>
<p>So, you can now see the power of Extension Methods and the benefits that they can bring us. If some functionality that we want is not already provided by a certain class in the .NET Framework, then we can simply add it. Take this next example.</p>
<p>Here is an Extension Method that has been sorely missed from the existing LINQ Extension Methods. As with the other LINQ methods, this one also works on the <kbd>IEnumerable&lt;T&gt;</kbd> interface and, therefore, also any collection that extends it:</p>
<pre>public static IEnumerable&lt;TSource&gt; DistinctBy&lt;TSource, TKey&gt;( 
  this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector) 
{ 
  HashSet&lt;TKey&gt; keys = new HashSet&lt;TKey&gt;(); 
  foreach (TSource element in source) 
  { 
    if (keys.Add(keySelector(element))) yield return element; 
  } 
} </pre>
<p>Let's first look at the declaration of this method. We can see that our source collection will be of type <kbd>TSource</kbd>. Note that this is exactly the same as if the generic type parameter were named <kbd>T</kbd>, like in our other examples, except that this provides a little more detail as to the use of this type parameter. This naming has come from the <kbd>Enumerable.OrderBy&lt;TSource, TKey&gt;</kbd> method, where type <kbd>TSource</kbd> parameter represents our source collection.</p>
<p>Next, we notice that the method name is suffixed by two generic type parameters; first, the <kbd>TSource</kbd> parameter, and then the <kbd>TKey</kbd> parameter. This is because we require two generic type parameters for the input parameter of type <kbd>Func&lt;TSource, TKey&gt;</kbd>. If you're not familiar with the <kbd>Func&lt;T, TResult&gt;</kbd> delegate, as Microsoft calls it, it simply encapsulates any method that has a single input parameter of type <kbd>T</kbd> and returns a value of type <kbd>TResult</kbd>, or, in our case, <kbd>TKey</kbd>.</p>
<p>"<em>Why are we using this</em> <kbd>Func&lt;T, TResult&gt;</kbd> <em>delegate</em>?", I hear you asking. Well, it's simple really; using this class, we can provide the developers with an object of the same type as those in the source collection and the ability to select a member of that class, in particular, the property that they want to perform the distinct query on. Before looking at the rest of this method, let's see it in use:</p>
<pre>IEnumerable&lt;User&gt; distinctUsers = Users.DistinctBy(u =&gt; u.Id);</pre>
<p>Let's envisage that we had a collection of <kbd>User</kbd> objects that had all purchased items. This collection could contain the same <kbd>User</kbd> object more than once, if they purchased more than one item. Now, let's imagine that we wanted to compile a collection of unique users from the original collection, so as not to send multiple bills to people that ordered multiple items. This method would return a single member for each distinct <kbd>Id</kbd> value.</p>
<p>Referring back to the source code for this method, the <kbd>User</kbd> class represents the <kbd>TSource</kbd> parameter and this is shown in the Lambda expression in the example as the <kbd>u</kbd> input parameter. The <kbd>TKey</kbd> parameter is determined by the type of the class member that is selected by the developer, in this case, by the <kbd>Guid</kbd> <kbd>Id</kbd> value. This example could be written slightly differently to make it clearer:</p>
<pre>IEnumerable&lt;User&gt; distinctUsers = Users.DistinctBy((User user) =&gt; user.Id);</pre>
<p>So, our <kbd>Func&lt;TSource, TKey&gt;</kbd> can be seen here, with a <kbd>User</kbd> input parameter and a <kbd>Guid</kbd> return value. Now, let's focus on the magic of our method. We see a <kbd>HashSet</kbd> of type <kbd>Guid</kbd> in our case being initialized. This type of collection is essential to this method, as it allows only unique values to be added.</p>
<p>Next, we iterate through our source collection, of type <kbd>User</kbd> in this case, and attempt to add the relevant property value of each item in the collection into the <kbd>HashSet</kbd>. In our case, we're adding the values of the identities of each <kbd>User</kbd> object into this <kbd>HashSet</kbd>.</p>
<p>If the identity value is unique and the <kbd>HashSet&lt;T&gt;.Add</kbd> method returns <kbd>true</kbd>, we yield, or return that item from our source collection. The second and each subsequent time that a used <kbd>Id</kbd> value is read, it is rejected. This means that only the first items with unique identity values are returned from this method. Note that in this example, we are not interested in the purchases, but in the unique users that made them.</p>
<p>We've now managed to create our very own LINQ-style Extension Method. However, not all of our Extension Methods need to be so ground breaking. Often, they can be used to simply encapsulate some commonly used functionality.</p>
<p>In a way, we can use them as simple convenience methods. Take a look at the following example that is used in the <em>With Converters</em> section later in this chapter:</p>
<pre>using System;<br/>using System.ComponentModel;<br/>using System.Reflection;<br/><br/>namespace CompanyName.ApplicationName.Extensions 
{ 
  public static class EnumExtensions 
  { 
    public static string GetDescription(this Enum value) 
    { 
      FieldInfo fieldInfo = value.GetType().GetField(value.ToString()); 
      if (fieldInfo == null) return Enum.GetName(value.GetType(), value); 
      DescriptionAttribute[] attributes = (DescriptionAttribute[])
        fieldInfo.GetCustomAttributes(typeof(DescriptionAttribute), false); 
      if (attributes != null &amp;&amp; attributes.Length &gt; 0)  
        return attributes[0].Description; 
      return Enum.GetName(value.GetType(), value); 
    } 
  } 
} </pre>
<p>In this method, we attempt to get the <kbd>FieldInfo</kbd> object that relates to the instance of the relevant enumeration provided by the <kbd>value</kbd> input parameter. If the attempt fails, we simply return the name of the particular instance. If we succeed however, we then use the <kbd>GetCustomAttributes</kbd> method of that object, passing the type of the <kbd>DescriptionAttribute</kbd> class, to retrieve an array of attributes.</p>
<p>If we have declared a value in the <kbd>DescriptionAttribute</kbd> of this particular enumeration instance, then it will always be the first item in the attribute array. If we have not set a value, then the array will be empty and we return the name of the instance instead. Note that as we used the base <kbd>Enum</kbd> class in this method, we are able to call this method on any enumeration type.</p>
<p>When creating these methods, it should be noted that there is no requirement to put them into separate classes that are split by type, as we have done here. There are no specified naming conventions either and, in fact, it is also totally viable to put all of your Extension Methods into a single class. However, if we have a large number of Extension Methods of a particular type, then it can help with maintenance to have this separation.</p>
<p>Before moving on, let's take a look at one final example of these Extension Methods. One of the most useful traits of an Extension Method is the ability to add new or missing functionality to existing classes from the .NET Framework. For example, let's see how we can replicate Linq and define a simple <kbd>Count</kbd> method for the <kbd>IEnumerable</kbd> class:</p>
<pre>public static int Count(this IEnumerable collection) 
{ 
  int count = 0; 
  foreach (object item in collection) count++; 
  return count; 
} </pre>
<p>As we can see, this method requires little explanation. It literally just counts the number of items in the <kbd>IEnumerable</kbd> collection and returns that value. As simple as it is, it proves to be useful, as we'll see in a later example. Now that we have investigated Extension Methods, let's turn our attention to another way of building further abilities into our framework, this time focusing on the Views component.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">In UI controls</h1>
                
            
            
                
<p>One another common way to include functionality in an application framework is to encapsulate it into custom controls. In doing so, we can expose the required functionality using Dependency Properties, while hiding the implementation details. This is also another great way to promote reusability and consistency throughout the application. Let's take a look at a simple example of a <kbd>UserControl</kbd> that wraps the functionality of the <kbd>System.Windows.Forms.FolderBrowserDialog</kbd> control:</p>
<pre>&lt;UserControl   
  x:Class="CompanyName.ApplicationName.Views.Controls.FolderPathEditField" 
   
  
  &gt; 
  &lt;TextBox Name="FolderPathTextBox" 
    Text="{Binding FolderPath, RelativeSource={RelativeSource 
    AncestorType={x:Type Controls:FolderPathEditField}}, FallbackValue='', 
    UpdateSourceTrigger=PropertyChanged}" Cursor="Arrow" 
    PreviewMouseLeftButtonUp="TextBox_PreviewMouseLeftButtonUp" /&gt; 
&lt;/UserControl&gt; </pre>
<p>This simple <kbd>UserControl</kbd> just contains a textbox with its <kbd>Text</kbd> property data bound to the <kbd>FolderPath</kbd> Dependency Property that is declared in our control's code behind. Remember that it is perfectly acceptable to use the code behind of a <kbd>UserControl</kbd> for this purpose when using MVVM. Note that we have used a <kbd>RelativeSource</kbd> binding here because nothing has been set to this control's <kbd>DataContext</kbd> property. We'll find out much more about data binding in <a href="2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml">Chapter 4</a>, <em>Becoming Proficient with Data Binding</em>, but for now, let's continue.</p>
<p>You may notice that we have attached a handler for the <kbd>PreviewMouseLeftButtonUp</kbd> event in the code behind and as no business-related code is being used there, this is also perfectly acceptable when using MVVM. The only other notable code here is that we set the <kbd>Cursor</kbd> property to show an arrow when users mouse over our control. Let's now take a look at the code behind of the  <kbd>UserControl</kbd> and see how the functionality is encapsulated:</p>
<pre>using System; 
using System.Windows; 
using System.Windows.Controls; 
using System.Windows.Input; 
using FolderBrowserDialog = System.Windows.Forms.FolderBrowserDialog; 
 
namespace CompanyName.ApplicationName.Views.Controls 
{ 
  public partial class FolderPathEditField : UserControl 
  { 
    public FolderPathEditField() 
    { 
      InitializeComponent(); 
    } 
 
    public static readonly DependencyProperty FolderPathProperty =       
      DependencyProperty.Register(nameof(FolderPath),        
      typeof(string), typeof(FolderPathEditField), 
      new FrameworkPropertyMetadata(string.Empty, 
      FrameworkPropertyMetadataOptions.BindsTwoWayByDefault)); 
 
    public string FolderPath 
    { 
      get { return (string)GetValue(FolderPathProperty); } 
      set { SetValue(FolderPathProperty, value); } 
    } 
 
    public static readonly DependencyProperty OpenFolderTitleProperty =       
      DependencyProperty.Register(nameof(OpenFolderTitle), 
      typeof(string), typeof(FolderPathEditField), 
      new FrameworkPropertyMetadata(string.Empty, 
      FrameworkPropertyMetadataOptions.BindsTwoWayByDefault)); 
 
    public string OpenFolderTitle 
    { 
      get { return (string)GetValue(OpenFolderTitleProperty); } 
      set { SetValue(OpenFolderTitleProperty, value); } 
    } 
 
    private void TextBox_PreviewMouseLeftButtonUp(object sender,  
      MouseButtonEventArgs e) 
    { 
      if (((TextBox)sender).SelectedText.Length == 0 &amp;&amp;  
        e.GetPosition(this).X &lt;= ((TextBox)sender).ActualWidth -  
        SystemParameters.VerticalScrollBarWidth)  
        ShowFolderPathEditWindow(); 
    } 
 
    private void ShowFolderPathEditWindow() 
    { 
      string defaultFolderPath = string.IsNullOrEmpty(FolderPath) ?         
        Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments)  
        : FolderPath; 
      string folderPath = ShowFolderBrowserDialog(defaultFolderPath); 
      if (string.IsNullOrEmpty(folderPath)) return; 
      FolderPath = folderPath; 
    } 
 
    private string ShowFolderBrowserDialog(string defaultFolderPath) 
    { 
      using (FolderBrowserDialog folderBrowserDialog = <br/>        new FolderBrowserDialog())
      {<br/>        folderBrowserDialog.Description = OpenFolderTitle;<br/>        folderBrowserDialog.ShowNewFolderButton = true;<br/>        folderBrowserDialog.SelectedPath = defaultFolderPath;<br/>        folderBrowserDialog.ShowDialog();<br/>        return folderBrowserDialog.SelectedPath;<br/>      }<br/>    }<br/>  }<br/>} </pre>
<p>We start with our <kbd>using</kbd> directives and see an example of a using alias directive. In this case, we don't want to add a normal <kbd>using</kbd> directive for the <kbd>System.Windows.Forms</kbd> assembly because it contains many UI-related classes that have names that clash with those in the required <kbd>System.Windows</kbd> assembly.</p>
<p>To avoid these conflicts, we can create an alias for the single type that we are interested in using from that assembly. To clarify, Microsoft decided not to reinvent the wheel, or, in this case, the <kbd>FolderBrowserDialog</kbd> control, in the <kbd>System.Windows</kbd> assembly, and so we need to add a reference to the <kbd>System.Windows.Forms</kbd> assembly and use the one from there.</p>
<p>Looking at this class, we see that much of this code is taken up with the declarations of the Dependency Properties of the control. We have the <kbd>FolderPath</kbd> property that will hold the file path of the folder that is selected from the <kbd>Windows.Forms</kbd> control, and the <kbd>OpenFolderTitle</kbd> property that will populate the title bar of the <kbd>FolderBrowserDialog</kbd> window when displayed.</p>
<p>Next, we see the <kbd>TextBox_PreviewMouseLeftButtonUp</kbd> event handler that handles the <kbd>PreviewMouseLeftButtonUp</kbd> event of the single <kbd>TextBox</kbd> element in our control. In this method, we first verify that the user is not selecting text from, or scrolling, the <kbd>TextBox</kbd> control and then, if <kbd>true</kbd>, we call the <kbd>ShowFolderPathEditWindow</kbd> method.</p>
<p>In order to verify that the user is not selecting text, we simply check the length of the <kbd>SelectedText</kbd> property of the <kbd>TextBox</kbd> control. In order to confirm that the user is not scrolling the <kbd>TextBox</kbd> control, we compare the relative horizontal position of the user's click with the length of the <kbd>TextBox</kbd> element minus the width of its vertical scroll bar to ensure that their mouse is not over the scroll bar, if present.</p>
<p>The <kbd>ShowFolderPathEditWindow</kbd> method first prepares to display the <kbd>Windows.Forms</kbd> control. It sets the <kbd>defaultFolderPath</kbd> variable to either the current value of the <kbd>FolderPath</kbd> property, if one is set, or the current user's <kbd>Documents</kbd> folder, using the <kbd>Environment.GetFolderPath</kbd> method and the <kbd>Environment.SpecialFolder.MyDocuments</kbd> enumeration.</p>
<p>It then calls the <kbd>ShowFolderBrowserDialog</kbd> method to launch the actual <kbd>FolderBrowserDialog</kbd> control and retrieve the selected folder path. If a valid folder path is selected, we set its value to the data bound <kbd>FolderPath</kbd> property directly, but note that we could have set it in other ways.</p>
<p>It would be very easy to add an <kbd>ICommand</kbd> property to our control in order to return the selected folder path instead of using this direct assignment. This could be useful in cases where we don't want the data bound value to be set instantly; for example, if the control was used in a child window that needed a confirmation button to be clicked before the data bound value could be updated.</p>
<p>The <kbd>ShowFolderBrowserDialog</kbd> method wraps the use of the <kbd>FolderBrowserDialog</kbd> class in a <kbd>using</kbd> statement, to ensure that it is disposed of, once it has been used. It utilizes the <kbd>defaultFolderPath</kbd> variable and the <kbd>OpenFolderTitle</kbd> property when setting up the actual <kbd>FolderBrowserDialog</kbd> control. Note that this <kbd>OpenFolderTitle</kbd> property is simply here to demonstrate how we can expose the required properties from the <kbd>FolderBrowserDialog</kbd> element in our control. In this way, we can encapsulate the use of the <kbd>Windows.Forms</kbd> control and assembly within our control.</p>
<p>Note that we could have added extra Dependency Properties to enable the users of our framework to have further control over the settings in the <kbd>FolderBrowserDialog</kbd> control. In this basic example, we simply hardcoded a positive value for the <kbd>FolderBrowserDialog.ShowNewFolderButton</kbd> property, but we could have exposed that as another property.</p>
<p>We could have also added a browse button and maybe even a clear button to clear the selected folder value. We could have then added additional <kbd>bool</kbd> Dependency Properties to control whether those buttons should be displayed or not. There are many other ways that we could improve this control, but it still demonstrates how we can encapsulate functionality into our Views components. We'll see another View-related way to capture little snippets of functionality in the following section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">With converters</h1>
                
            
            
                
<p>Converters are yet another way that we can package up useful functionality in our framework. We've already seen a useful example of the <kbd>IValueConverter</kbd> interface in <a href="b799e8cf-97d3-44e5-927a-c02c42d343fc.xhtml">Chapter 2</a>, <em>Debugging WPF Applications</em>, but while that was a very simple example, converters can actually be very versatile.</p>
<p>Long before Microsoft introduced their <kbd>BooleanToVisibilityConverter</kbd> class, developers had to create their own versions. We often need to convert the <kbd>UIElement.Visibility</kbd> enumeration to or from a variety of different types, and so it is a good idea to start with a <kbd>BaseVisibilityConverter</kbd> class that can serve multiple converter classes. Let's see what that entails:</p>
<pre>using System.Windows; 
using System.Windows.Data; 
 
namespace CompanyName.ApplicationName.Converters 
{ 
  public abstract class BaseVisibilityConverter 
  { 
    public enum FalseVisibility { Hidden, Collapsed } 
 
    protected Visibility FalseVisibilityValue { get; set; } = 
      Visibility.Collapsed; 
 
    public FalseVisibility FalseVisibilityState 
    { 
      get { return FalseVisibilityState == Visibility.Collapsed ?              
        FalseVisibility.Collapsed : FalseVisibility.Hidden; }
      set { FalseVisibilityState = value == FalseVisibility.Collapsed ?
        Visibility.Collapsed : Visibility.Hidden; } 
    } 
 
    public bool IsInverted { get; set; } 
  } 
} </pre>
<p class="mce-root">This converter requires one value to represent the visible value and as there is only one corresponding value in the <kbd>UIElement.Visibility</kbd> enumeration, that will clearly be the <kbd>Visibility.Visible</kbd> instance. It also requires a single value to represent the invisible value.</p>
<p>As such, we declare the <kbd>FalseVisibility</kbd> enumeration with the two corresponding values from the <kbd>UIElement.Visibility</kbd> enumeration and the <kbd>FalseVisibilityValue</kbd> property to enable users to specify which value should represent the false state. Note that the most commonly used <kbd>Visibility.Collapsed</kbd> value is set as the default value.</p>
<p>Users can set the <kbd>FalseVisibilityState</kbd> property when using the control and this sets the protected <kbd>FalseVisibilityValue</kbd> property internally. Finally, we see the indispensable <kbd>IsInverted</kbd> property that is optionally used to invert the result. Let's see what our <kbd>BoolToVisibilityConverter</kbd> class looks like now:</p>
<pre>using System; 
using System.Globalization; 
using System.Windows; 
using System.Windows.Data; 
 
namespace CompanyName.ApplicationName.Converters 
{ 
  [ValueConversion(typeof(bool), typeof(Visibility))] 
  public class BoolToVisibilityConverter : BaseVisibilityConverter,  
    IValueConverter 
  { 
    public object Convert(object value, Type targetType,  
      object parameter, CultureInfo culture) 
    { 
      if (value == null || value.GetType() != typeof(bool))  
        return DependencyProperty.UnsetValue; 
      bool boolValue = IsInverted ? !(bool)value :(bool)value;
      return boolValue ? Visibility.Visible : FalseVisibilityValue; 
    } 
 
    public object ConvertBack(object value, Type targetType,  
      object parameter, CultureInfo culture) 
    { 
      if (value == null || value.GetType() != typeof(Visibility))  
        return DependencyProperty.UnsetValue; 
      if (IsInverted) return (Visibility)value != Visibility.Visible; 
      return (Visibility)value == Visibility.Visible; 
    } 
  } 
} </pre>
<p>We start by specifying the data types involved in the implementation of the converter in the <kbd>ValueConversion</kbd> attribute. This helps tools to know what types are being used in the converter, but also makes it clear to the users of our framework. Next, we extend our <kbd>BaseVisibilityConverter</kbd> base class and extend the required <kbd>IValueConverter</kbd> interface.</p>
<p>In the <kbd>Convert</kbd> method, we first check the validity of our <kbd>value</kbd> input parameter, if valid, we convert it to a <kbd>bool</kbd> variable, taking the <kbd>IsInverted</kbd> property setting into consideration. We return the <kbd>DependencyProperty.UnsetValue</kbd> value for invalid input values. Finally, we resolve the output value from this <kbd>bool</kbd> variable to either the <kbd>Visibility.Visible</kbd> instance, or the value of the <kbd>FalseVisibilityValue</kbd> property.</p>
<p>In the <kbd>ConvertBack</kbd> method, we also check the validity of our <kbd>value</kbd> input parameter first. We return the <kbd>DependencyProperty.UnsetValue</kbd> value for invalid input values again, otherwise we output a <kbd>bool</kbd> value that specifies whether the input parameter of type <kbd>Visibility</kbd> is equal to the <kbd>Visibility.Visible</kbd> instance, while again taking the value of the <kbd>IsInverted</kbd> property into consideration.</p>
<p>Note that use of the <kbd>IsInverted</kbd> property enables users to specify that elements should become visible when the data bound <kbd>bool</kbd> value is <kbd>false</kbd>. This can be incredibly useful when we want to have one object visible upon a certain condition and another object hidden dependent upon the same condition. We can declare two converters from this class like this:</p>
<pre>xmlns:Converters="clr-namespace:CompanyName.ApplicationName.Converters; 
  assembly=CompanyName.ApplicationName.Converters" 
... 
&lt;Converters:BoolToVisibilityConverter x:Key="BoolToVisibilityConverter" /&gt; 
&lt;Converters:BoolToVisibilityConverter  
  x:Key="InvertedBoolToVisibilityConverter" IsInverted="True" /&gt; </pre>
<p>As stated, we often need to convert to and from the <kbd>UIElement.Visibility</kbd> enumeration from a variety of different types. Let's now look at an example of a conversion to and from the <kbd>Enum</kbd> type. The principle is the same as the last example, where a single data bound value represents the <kbd>Visibility.Visible</kbd> instance and all other values represent the hidden or collapsed state:</p>
<pre>using System; 
using System.Globalization; 
using System.Windows; 
using System.Windows.Data; 
 
namespace CompanyName.ApplicationName.Converters 
{ 
  [ValueConversion(typeof(Enum), typeof(Visibility))] 
  public class EnumToVisibilityConverter : BaseVisibilityConverter,  
    IValueConverter
  { 
    public object Convert(object value, Type targetType,  
      object parameter, CultureInfo culture) 
    { 
      if (value == null || (value.GetType() != typeof(Enum) &amp;&amp;     
        value.GetType().BaseType != typeof(Enum)) ||  
        parameter == null) return DependencyProperty.UnsetValue; 
      string enumValue = value.ToString(); 
      string targetValue = parameter.ToString(); 
      bool boolValue = enumValue.Equals(targetValue,  
        StringComparison.InvariantCultureIgnoreCase); 
      boolValue = IsInverted ? !boolValue : boolValue; 
      return boolValue ? Visibility.Visible : FalseVisibilityValue; 
    } 
 
    public object ConvertBack(object value, Type targetType,  
      object parameter, CultureInfo culture) 
    { 
      if (value == null || value.GetType() != typeof(Visibility) ||
        parameter == null) return DependencyProperty.UnsetValue; 
      Visibility usedValue = (Visibility)value; 
      string targetValue = parameter.ToString(); 
      if (IsInverted &amp;&amp; usedValue != Visibility.Visible)  
        return Enum.Parse(targetType, targetValue); 
      else if (!IsInverted &amp;&amp; usedValue == Visibility.Visible)  
        return Enum.Parse(targetType, targetValue); 
      return DependencyProperty.UnsetValue; 
    } 
  } 
} </pre>
<p>Again, we start by specifying the data types involved in the implementation of the converter in the <kbd>ValueConversion</kbd> attribute. In the <kbd>Convert</kbd> method, we first check the validity of our <kbd>value</kbd> input parameter, if valid, we convert it to the <kbd>string</kbd> representation of the value. This particular class uses the <kbd>parameter</kbd> input parameter to pass the specified enumeration instance that will represent the visible value, and so it is set to the <kbd>targetValue</kbd> variable as a <kbd>string</kbd>.</p>
<p>We then create a <kbd>bool</kbd> value by comparing the current enumeration instance with the target instance. Once we have our <kbd>bool</kbd> value, the last two lines replicate those in the <kbd>BoolToVisibilityConverter</kbd> class.</p>
<p>The <kbd>ConvertBack</kbd> method implementation is somewhat different. Logically speaking, we are unable to return the correct enumeration instance for a hidden visibility, as it could be any value except the visible value passed through the <kbd>parameter</kbd> input parameter.</p>
<p>As such, we are only able to return that specified value if the element is visible and the <kbd>IsInverted</kbd> property is <kbd>false</kbd>, or if it is not visible and the <kbd>IsInverted</kbd> property is <kbd>true</kbd>. For all other input values, we simply return the <kbd>DependencyProperty.UnsetValue</kbd> property to state that there is no value.</p>
<p>Another incredibly useful thing that converters can do is to convert individual enumeration instances to particular images. Let's look at an example that relates to our <kbd>FeedbackManager</kbd>, or, more accurately, the <kbd>Feedback</kbd> objects that get displayed. Each <kbd>Feedback</kbd> object can have a particular type that is specified by the <kbd>FeedbackType</kbd> enumeration, so let's look at that first:</p>
<pre>namespace CompanyName.ApplicationName.DataModels.Enums 
{ 
  public enum FeedbackType 
  { 
    None = -1, 
    Error, 
    Information, 
    Question, 
    Success, 
    Validation, 
    Warning 
  } 
} </pre>
<p>To make this work, we obviously need a suitable image for each enumeration instance, except for the <kbd>None</kbd> instance. Our images will reside in a folder named Images in the root folder of the startup project:</p>
<pre>using CompanyName.ApplicationName.DataModels.Enums;<br/>using System; 
using System.Globalization; 
using System.Windows; 
using System.Windows.Data; 
using System.Windows.Media; 
 
namespace CompanyName.ApplicationName.Converters 
{ 
  [ValueConversion(typeof(FeedbackType), typeof(ImageSource))] 
  public class FeedbackTypeToImageSourceConverter : IValueConverter 
  { 
    public object Convert(object value, Type targetType,  
      object parameter, CultureInfo culture) 
    { 
      if (!(value is FeedbackType feedbackType) || <br/>        targetType != typeof(ImageSource)) <br/>        return DependencyProperty.UnsetValue; 
      string imageName = string.Empty; 
      switch ((FeedbackType)value) 
      { 
        case FeedbackType.None: return null; 
        case FeedbackType.Error: imageName = "Error_16"; break;
        case FeedbackType.Success: imageName = "Success_16"; break; 
        case FeedbackType.Validation:
        case FeedbackType.Warning: imageName = "Warning_16"; break; 
        case FeedbackType.Information: imageName = "Information_16"; break; 
        case FeedbackType.Question: imageName = "Question_16"; break; 
        default: return DependencyProperty.UnsetValue; 
      } 
      return $"pack://application:,,,/CompanyName.ApplicationName; 
        component/Images/{ imageName }.png"; 
    } 
 
    public object ConvertBack(object value, Type targetType,  
      object parameter, CultureInfo culture) 
    { 
      return DependencyProperty.UnsetValue; 
    } 
  } 
} </pre>
<p>Once again, we start by specifying the data types involved in the converter in the <kbd>ValueConversion</kbd> attribute. In the <kbd>Convert</kbd> method, we use C# 6.0 Pattern Matching to check the validity of our <kbd>value</kbd> input parameter and to cast it to a <kbd>FeedbackType</kbd> instance, if valid. We then use that in a <kbd>switch</kbd> statement, to generate the relevant image name for each enumeration instance.</p>
<p>If an unknown instance is used, we return the <kbd>DependencyProperty.UnsetValue</kbd> value. In all other cases, we use String Interpolation to build up the full file path of the relevant image and then return it from the converter as the converted value. As the <kbd>ConvertBack</kbd> method in this converter has no valid use, it is not implemented and simply returns the <kbd>DependencyProperty.UnsetValue</kbd> value.</p>
<p>You may have noticed that we specified type <kbd>ImageSource</kbd> in the <kbd>ValueConversion</kbd> attribute, but we returned a <kbd>string</kbd>. This is possible because XAML uses the relevant type converter to convert the <kbd>string</kbd> into an <kbd>ImageSource</kbd> object automatically for us. Exactly the same thing occurs when we set an <kbd>Image.Source</kbd> property with a <kbd>string</kbd> in XAML.</p>
<p>As with other parts of our framework, we can make our converters even more useful, when we combine functionality from other areas. In this particular example, we utilize one of the Extension Methods that was shown earlier in this chapter. To remind you, the <kbd>GetDescription</kbd> method will return the value of the <kbd>DescriptionAttribute</kbd> that is set on each enumeration instance.</p>
<p>The <kbd>DescriptionAttribute</kbd> enables us to associate any <kbd>string</kbd> value with each of our enumeration instances, so this is a great way to output a user-friendly description for each instance. An example of this would be as follows:</p>
<pre>using System.ComponentModel;<br/><br/>public enum BitRate 
{ 
  [Description("16 bits")] 
  Sixteen = 16, 
  [Description("24 bits")] 
  TwentyFour = 24, 
  [Description("32 bits")] 
  ThirtyTwo = 32, 
} </pre>
<p>In this way, instead of displaying the names of the instances in a <kbd>RadioButton</kbd> control, for example, we could display the more humanized descriptions from these attributes. Let's have a look at this converter class now:</p>
<pre>using System; 
using System.Globalization; 
using System.Windows; 
using System.Windows.Data; 
using CompanyName.ApplicationName.Extensions; 
 
namespace CompanyName.ApplicationName.Converters 
{ 
  [ValueConversion(typeof(Enum), typeof(string))] 
  public class EnumToDescriptionStringConverter : IValueConverter 
  { 
    public object Convert(object value, Type targetType,  
      object parameter, CultureInfo culture) 
    { 
      if (value == null || (value.GetType() != typeof(Enum) &amp;&amp;  
        value.GetType().BaseType != typeof(Enum)))  
        return DependencyProperty.UnsetValue; 
      Enum enumInstance = (Enum)value; 
      return enumInstance.GetDescription(); 
    } 
 
    public object ConvertBack(object value, Type targetType,  
      object parameter, CultureInfo culture) 
    { 
      return DependencyProperty.UnsetValue; 
    } 
  } 
} </pre>
<p>As we're now accustomed to doing, we start by specifying the data types used in the converter in the <kbd>ValueConversion</kbd> attribute. In the <kbd>Convert</kbd> method, we again check the validity of our <kbd>value</kbd> input parameter and return the <kbd>DependencyProperty.UnsetValue</kbd> value if it is invalid.</p>
<p>If it is valid, we cast it to a <kbd>Enum</kbd> instance and then use the power of our Extension Method to return the value from each instance's <kbd>DescriptionAttribute</kbd>. In doing so, we are able to expose this functionality to our Views and to enable the users of our framework to utilize it directly from the XAML. Now that we have a general understanding of the various ways that we can encapsulate functionality into our framework, let's focus on starting construction of our base classes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Constructing a custom application framework</h1>
                
            
            
                
<p>There will be different requirements for different components, but typically, the properties and functionality that we build into our Data Model base classes will be utilized and made more useful by our other base classes, so let's start by looking at the various Data Model base classes first.</p>
<p>One thing that we need to decide is whether we want any of our Data Model base classes to be generic or not. The difference can be subtle, but important. Imagine that we want to add some basic undo functionality into a base class. One way that we can achieve this would be to add an object into the base class that represents the unedited version of the Data Model. In an ordinary base class, it would look like this:</p>
<pre>public abstract class BaseSynchronizableDataModel : BaseDataModel 
{ 
  private BaseSynchronizableDataModel originalState; <br/><br/>  public BaseSynchronizableDataModel OriginalState<br/>  { 
    get { return originalState; } 
    private set { originalState = value; } 
  } 
} </pre>
<p>In a generic base class, it would look like this:</p>
<pre>public abstract class BaseSynchronizableDataModel&lt;T&gt; : BaseDataModel 
{ 
  private T originalState; 
 
  public T OriginalState 
  { 
    get { return originalState; } 
    private set { originalState = value; } 
  } 
} </pre>
<p>To make this property more useful, we'll need to add some further methods. First, we'll see the non-generic versions:</p>
<pre>public abstract void CopyValuesFrom(BaseSynchronizableDataModel dataModel); <br/> 
public virtual BaseSynchronizableDataModel Clone() <br/>{<br/>  BaseSynchronizableDataModel clone = <br/>    Activator.CreateInstance(this.GetType()) as BaseSynchronizableDataModel;<br/>  clone.CopyValuesFrom(this);<br/>  return clone;<br/>}<br/><br/>public abstract bool PropertiesEqual(BaseSynchronizableDataModel dataModel);</pre>
<p>Now, let's look at the generic versions:</p>
<pre>public abstract void CopyValuesFrom(T dataModel); 
 
public virtual T Clone() 
{ 
  T clone = new T(); 
  clone.CopyValuesFrom(this as T); 
  return clone; 
} 
 
public abstract bool PropertiesEqual(T dataModel); </pre>
<p>The last few members of this base class would be the same for both versions:</p>
<pre>public bool HasChanges 
{ 
  get { return originalState != null &amp;&amp; !PropertiesEqual(originalState); } 
} 
 
public void Synchronize() 
{ 
  originalState = this.Clone(); 
  NotifyPropertyChanged(nameof(HasChanges)); 
} 
 
public void RevertState() 
{ 
  Debug.Assert(originalState != null, "Object not yet synchronized."); 
  CopyValuesFrom(originalState); 
  Synchronize(); 
  NotifyPropertyChanged(nameof(HasChanges)); 
} </pre>
<p>We started with the <kbd>OriginalState</kbd> property which holds the unedited version of the Data Model. After that, we see the abstract <kbd>CopyValuesFrom</kbd> method that the developers will need to implement and we'll see an example of that implementation shortly. The <kbd>Clone</kbd> method simply calls the <kbd>CopyValuesFrom</kbd> method in order to perform a deep clone of the Data Model.</p>
<p>Next, we have the abstract <kbd>PropertiesEqual</kbd> method that the developers will need to implement in order to compare each property in their classes with those from the <kbd>dataModel</kbd> input parameter. Again, we'll see this implementation shortly, but you may be wondering why we don't just override the <kbd>Equals</kbd> method, or implement the <kbd>IEquatable.Equals</kbd> method for this purpose.</p>
<p>The reason why we don't want to use either of those methods is because they, along with the <kbd>GetHashCode</kbd> method, are used by the WPF Framework in various places and they expect the returned values to be immutable. As our object's properties are very much mutable, they cannot be used to return the values for those methods. Therefore, we have implemented our own version. Now, let's return to the description of the remainder of this code.</p>
<p>The <kbd>HasChanges</kbd> property is the property that we would want to data bind to a UI control to indicate whether a particular object had been edited. The <kbd>Synchronize</kbd> method sets a deep clone of the current Data Model to the <kbd>originalState</kbd> field and, importantly, notifies the WPF Framework of a change to the <kbd>HasChanges</kbd> property. This is done because the <kbd>HasChanges</kbd> property has no setter of its own and this operation will affect its value.</p>
<p>It is very important that we set a cloned version to the <kbd>originalState</kbd> field, rather than simply assigning the actual object reference to it. This is because we need to have a completely separate version of this object to represent the unedited version of the Data Model. If we simply assigned the actual object reference to the <kbd>originalState</kbd> field, then its property values would change along with the Data Model object and render it useless for this feature.</p>
<p>The <kbd>RevertState</kbd> method first checks that the Data Model has been synchronized and then copies the values back from the <kbd>originalState</kbd> field to the Model. Finally, it calls the <kbd>Synchronize</kbd> method to specify that this is the new, unedited version of the object and notifies the WPF Framework of a change to the <kbd>HasChanges</kbd> property.</p>
<p>So, as you can see, there are not many differences between these two versions of the base class. In fact, the differences can be seen more clearly in the implementation of the derived classes. Let's now focus on their implementations of the example abstract methods, starting with the non-generic versions:</p>
<pre>public override bool PropertiesEqual(BaseClass genreObject) 
{
  Genre genre = genreObject as Genre;<br/>  if (genre == null) return false; 
  return Name == genre.Name &amp;&amp; Description == genre.Description; 
} 
 
public override void CopyValuesFrom(BaseClass genreObject) 
{ 
  Debug.Assert(genreObject.GetType() == typeof(Genre), "You are using  
    the wrong type with this method."); 
  Genre genre = (Genre)genreObject; 
  Name = genre.Name; 
  Description = genre.Description; 
} </pre>
<p>Before discussing this code, let's first see the generic implementations:</p>
<pre>public override bool PropertiesEqual(Genre genre) 
{ 
  return Name == genre.Name &amp;&amp; Description == genre.Description; 
} 
 
public override void CopyValuesFrom(Genre genre) 
{ 
  Name = genre.Name; 
  Description = genre.Description; 
} </pre>
<p>At last, we can see the difference between using generic and non-generic base classes. Without using generics, we have to use base class input parameters, which will need to be cast to the appropriate type in each of the derived classes before we can access their properties. Attempting to cast inappropriate types causes Exceptions, so we generally try to avoid these situations.</p>
<p>On the other hand, when using a generic base class, there is no need to cast, as the input parameters are already of the correct type. In short, generics enable us to create type-safe Data Models and avoid duplicating type specific code. Now that we have seen the benefit of using generic classes, let's take a pause from generics for a moment and look at this base class a bit closer.</p>
<p>Some of you may have noticed that the only places where the WPF Framework is notified of changes to our <kbd>HasChanges</kbd> property is in the <kbd>Synchronize</kbd> and <kbd>RevertState</kbd> methods. However, in order for this functionality to work properly, we need to notify the framework every time the values of any properties are changed.</p>
<p>We could rely on the developers to call the <kbd>NotifyPropertyChanged</kbd> method, passing the <kbd>HasChanges</kbd> property name each time they call it for each property that changes, but if they forgot to do this, it could lead to errors that could be difficult for them to track down. Instead, a better solution would be for us to override the default implementation of the <kbd>INotifyPropertyChanged</kbd> interface from the base class and notify changes to the <kbd>HasChanges</kbd> property for them each time it is called:</p>
<pre>#region INotifyPropertyChanged Members 
 
protected override void NotifyPropertyChanged( 
  params string[] propertyNames) 
{ 
  if (PropertyChanged != null) 
  { 
    foreach (string propertyName in propertyNames) 
    { 
      if (propertyName != nameof(HasChanges)) PropertyChanged(this,  
        new PropertyChangedEventArgs(propertyName)); 
    } 
    PropertyChanged(this, 
      new PropertyChangedEventArgs(nameof(HasChanges))); 
  } 
} 
 
protected override void NotifyPropertyChanged( 
  [CallerMemberName]string propertyName = "") 
{ 
  if (PropertyChanged != null) 
  { 
    if (propertyName != nameof(HasChanges)) PropertyChanged(this, 
      new PropertyChangedEventArgs(propertyName)); 
    PropertyChanged(this, 
      new PropertyChangedEventArgs(nameof(HasChanges))); 
  } 
} 
 
#endregion </pre>
<p>The first method will raise the <kbd>PropertyChanged</kbd> event, passing the name of the <kbd>HasChanges</kbd> property just once, regardless of how many property names were passed to the method. The second method also performs a check to ensure that it will refrain from raising the event with the <kbd>HasChanges</kbd> property name more than once, so these implementations remain efficient.</p>
<p>Now, our base class will work as expected and the <kbd>HasChanges</kbd> property will correctly update when other properties in the Data Model classes are changed. This technique can also be utilized in other scenarios; for example, when validating our property values, as we'll see later in <a href="549ddd97-63f4-4e6c-8df3-6455ede31a4c.xhtml">Chapter 9</a>, <em>Implementing Responsive Data Validation</em>. For now though, let's return to see what else we can achieve with generics.</p>
<p>Another area where generics are often used relates to collections. I'm sure that you're all aware that we tend to use the <kbd>ObservableCollection&lt;T&gt;</kbd> class in WPF applications because of its <kbd>INotifyCollectionChanged</kbd> and <kbd>INotifyPropertyChanged</kbd> implementations. It is customary, but not essential, to extend this class for each type of Data Model class that we have:</p>
<pre>public class Users : ObservableCollection&lt;User&gt; </pre>
<p>However, instead of doing this, we can declare a <kbd>BaseCollection&lt;T&gt;</kbd> class that extends the <kbd>ObservableCollection&lt;T&gt;</kbd> class and adds further functionality into our framework for us. The users of our framework can then extend this class instead:</p>
<pre>public class Users : BaseCollection&lt;User&gt; </pre>
<p>One really useful thing that we can do is to add a generic property of type <kbd>T</kbd> into our base class, that which will represent the currently selected item in a data bound collection control in the UI. We could also declare some delegates to notify developers of changes to either selection or property values. There are so many shortcuts and helper methods that we can provide here, dependent on requirements, so it's worth spending some time investigating this. Let's take a look at a few possibilities:</p>
<pre>using System.Collections.Generic; 
using System.Collections.ObjectModel; 
using System.ComponentModel; 
using System.Linq; 
using System.Runtime.CompilerServices; 
using CompanyName.ApplicationName.Extensions; 
 
namespace CompanyName.ApplicationName.DataModels.Collections 
{ 
  public class BaseCollection&lt;T&gt; :  
    ObservableCollection&lt;T&gt;, INotifyPropertyChanged 
    where T : class, INotifyPropertyChanged, new() 
  { 
    protected T currentItem; 
 
    public BaseCollection(IEnumerable&lt;T&gt; collection) : this() 
    { 
      foreach (T item in collection) Add(item); 
    } 
 
    public BaseCollection(params T[] collection) :  
      this(collection as IEnumerable&lt;T&gt;) { } 
 
    public BaseCollection() : base() 
    { 
      currentItem = new T(); 
    } 
 
    public virtual T CurrentItem 
    { 
      get { return currentItem; } 
      set 
      { 
        T oldCurrentItem = currentItem; 
        currentItem = value; 
        CurrentItemChanged?.Invoke(oldCurrentItem, currentItem); 
        NotifyPropertyChanged(); 
      } 
    } 
 
    public bool IsEmpty 
    { 
      get { return !this.Any(); } 
    } 
 
    public delegate void ItemPropertyChanged(T item,  
      string propertyName); 
 
    public virtual ItemPropertyChanged CurrentItemPropertyChanged  
      { get; set; } 
 
    public delegate void CurrentItemChange(T oldItem, T newItem);
     
    public virtual CurrentItemChange CurrentItemChanged { get; set; } 
 
    public T GetNewItem() 
    { 
      return new T(); 
    } 
 
    public virtual void AddEmptyItem() 
    { 
      Add(new T()); 
    } 
 
    public virtual void Add(IEnumerable&lt;T&gt; collection) 
    { 
      collection.ForEach(i =&gt; base.Add(i)); 
    } 
 
    public virtual void Add(params T[] items) 
    { 
      if (items.Length == 1) base.Add(items[0]); 
      else Add(items as IEnumerable&lt;T&gt;); 
    } 
 
    protected override void InsertItem(int index, T item) 
    { 
      if (item != null) 
      { 
        item.PropertyChanged += Item_PropertyChanged; 
        base.InsertItem(index, item); 
        if (Count == 1) CurrentItem = item; 
      } 
    } 
 
    protected override void SetItem(int index, T item) 
    { 
      if (item != null) 
      { 
        item.PropertyChanged += Item_PropertyChanged; 
        base.SetItem(index, item); 
        if (Count == 1) CurrentItem = item; 
      } 
    } 
 
    protected override void ClearItems() 
    { 
      foreach (T item in this)  
        item.PropertyChanged -= Item_PropertyChanged; 
      base.ClearItems(); 
    } 
 
    protected override void RemoveItem(int index) 
    { 
      T item = this[index]; 
      if (item != null) item.PropertyChanged -= Item_PropertyChanged; 
      base.RemoveItem(index); 
    } 
 
    public void ResetCurrentItemPosition() 
    { 
      if (this.Any()) CurrentItem = this.First(); 
    } 
 
    private void Item_PropertyChanged(object sender,  
      PropertyChangedEventArgs e) 
    { 
      if ((sender as T) == CurrentItem) <br/>        CurrentItemPropertyChanged?.Invoke(currentItem, e.PropertyName); 
      NotifyPropertyChanged(e.PropertyName); 
    } 
 
    #region INotifyPropertyChanged Members 
     
    ... 
     
    #endregion 
  } 
} </pre>
<p>There's quite a lot to digest here, so let's go over each part carefully. We start with our private member of type <kbd>T</kbd> that will back our <kbd>CurrentItem</kbd> property. We then find a few overloads of the constructor that enable us to initialize our collection from either a collection, or any number of input parameters of the relevant type.</p>
<p>Next, we see the <kbd>CurrentItem</kbd> property from <a href="b2021d5b-c625-4403-9609-724ff89b9e0c.xhtml">Chapter 1</a>, <em>A Smarter Way of Working with WPF</em>, again, but now with some further context. If a class has subscribed to the <kbd>CurrentItemChanged</kbd> property, we will call the delegate from here, passing both the new and old values of the current item. The <kbd>IsEmpty</kbd> property is just an efficient convenience property for our developers to call when they need to know whether the collection has any content or not.</p>
<p>After this, we see the collection delegates and the relevant property wrappers that enable the developers that will use our framework to make use of them. Next, we see the convenient <kbd>GetNewItem</kbd> and <kbd>AddEmptyItem</kbd> methods, which both generate a new item of the <kbd>T</kbd> generic type parameter, before returning or adding them to the collection, respectively. This is the reason that we needed to add the <kbd>new()</kbd> generic type constraint to the class definition; this type constraint specifies that the generic type used must have a parameterless constructor.</p>
<p>And now we reach the various <kbd>Add</kbd> methods of the collection; note that every way to add an item to the collection must be handled, so that we can attach our <kbd>Item_PropertyChanged</kbd> handler to the <kbd>PropertyChanged</kbd> event of each added item to ensure consistent behavior.</p>
<p>We therefore call our <kbd>Add</kbd> methods from all other overloads and helper methods and call the base <kbd>Collection.Add</kbd> method from there. Note that we actually attach our handler inside the protected <kbd>InsertItem</kbd> method, as this overridden method is called from the <kbd>Add</kbd> methods in the <kbd>Collection</kbd> class.</p>
<p>Likewise, the protected <kbd>SetItem</kbd> method will be called by the <kbd>Collection</kbd> class when items are set using the index notation, so we must handle that too. Similarly, when items are removed from the collection, it is equally, if not more, important to remove the reference to our event handler from each object. Failing to do so can result in memory leaks, as the reference to the event handler can keep the Data Model objects from being disposed by the garbage collector.</p>
<p>As such, we also need to handle every method of removing objects from our collection. To do this, we override a few more protected methods from the <kbd>Collection</kbd> base class. The <kbd>ClearItems</kbd> method will be called internally when users call the <kbd>Clear</kbd> method on our collection. Equally, the <kbd>RemoveItem</kbd> method will be called when users call any of the public removal methods, so it is the optimal place to remove our handler.</p>
<p>Skipping the <kbd>ResetCurrentItemPosition</kbd> method for now, at the bottom of the class, we reach the <kbd>Item_PropertyChanged</kbd> event handling method. If the item that has had the property changed is the current item in the collection, then we raise the <kbd>ItemPropertyChanged</kbd> delegate that is connected with the <kbd>CurrentItemPropertyChanged</kbd> property.</p>
<p>For every property change notification, regardless of whether the item is the current item or not, we then raise the <kbd>INotifyPropertyChanged.PropertyChanged</kbd> event. This enables developers that use our framework to be able to attach a handler to the <kbd>PropertyChanged</kbd> event directly on our collections and to be able to discover when any property has been changed on any of the items in the collection.</p>
<p>You may also have noticed a few places in the collection class code where we set the value of the <kbd>CurrentItem</kbd> property. The option chosen here is to always select the first item in the collection automatically, but it would be a simple change to have the last item selected instead, for example. As always, these kinds of details will depend on your specific requirements.</p>
<p>Another benefit of declaring these base collection classes is that we can utilize the properties and extend the functionality that is built into our base Data Model classes. Thinking back to the simple example of our <kbd>BaseSynchronizableDataModel</kbd> class, let's see what we could add into a new base collection class to improve this functionality.</p>
<p>Before we can do this however, we need to be able to specify that the objects in our new collection have implemented the properties and methods from the <kbd>BaseSynchronizableDataModel</kbd> class. One option would be to declare our new collection class like this:</p>
<pre>public class BaseSynchronizableCollection&lt;T&gt; : BaseCollection&lt;T&gt;  
  where T : BaseSynchronizableDataModel&lt;T&gt; </pre>
<p>However, in C#, we can only extend a single base class, while we are free to implement as many interfaces as we like. A more preferable solution would therefore be for us to extract the relevant synchronization properties from our base class into an interface, and then add that to our base class definition:</p>
<pre>public abstract class BaseSynchronizableDataModel&lt;T&gt; : 
  BaseDataModel, ISynchronizableDataModel&lt;T&gt; 
  where T : BaseDataModel, ISynchronizableDataModel&lt;T&gt;, new() </pre>
<p>We could then specify this new generic constraint on our new collection class like this:</p>
<pre>public class BaseSynchronizableCollection&lt;T&gt; : BaseCollection&lt;T&gt;  
  where T : class, ISynchronizableDataModel&lt;T&gt;, new() </pre>
<p>Note that any other generic constraints that are placed on the <kbd>BaseSynchronizableDataModel</kbd> class will also need to be added to the <kbd>where T</kbd> part of this declaration. If, for example, we needed to implement another interface in the base class and we did not add the same constraint for the <kbd>T</kbd> generic type parameter in the base collection class, then we would get a compilation error when attempting to use instances of our base class as the <kbd>T</kbd> parameter. Let's now look at this new base class:</p>
<pre>using System.Collections.Generic; 
using System.ComponentModel; 
using System.Linq; 
using CompanyName.ApplicationName.DataModels.Interfaces; 
using CompanyName.ApplicationName.Extensions; 
 
namespace CompanyName.ApplicationName.DataModels.Collections 
{ 
  public class BaseSynchronizableCollection&lt;T&gt; : BaseCollection&lt;T&gt;  
    where T : class, ISynchronizableDataModel&lt;T&gt;,  
    INotifyPropertyChanged, new() 
  { 
    public BaseSynchronizableCollection(IEnumerable&lt;T&gt; collection) :  
      base(collection) { } 
 
    public BaseSynchronizableCollection(params T[] collection) :  
      base(collection as IEnumerable&lt;T&gt;) { } 
 
    public BaseSynchronizableCollection() : base() { } 
 
    public virtual bool HasChanges 
    { 
      get { return this.Any(i =&gt; i.HasChanges); } 
    } 
 
    public virtual bool AreSynchronized 
    { 
      get { return this.All(i =&gt; i.IsSynchronized); } 
    } 
 
    public virtual IEnumerable&lt;T&gt; ChangedCollection 
    { 
      get { return this.Where(i =&gt; i.HasChanges); } 
    } 
 
    public virtual void Synchronize() 
    { 
      this.ForEach(i =&gt; i.Synchronize()); 
    } 
 
    public virtual void RevertState() 
    { 
      this.ForEach(i =&gt; i.RevertState()); 
    } 
  } 
} </pre>
<p>While remaining simple, this base collection class provides some powerful functionality. We start off with the class declaration, with its generic type constraints that are inherited from both our target <kbd>T</kbd> type classes and our <kbd>BaseCollection&lt;T&gt;</kbd> class. We've then implemented the constructor overloads and passed initialization duties straight to the base class.</p>
<p>Note that had we wanted to attach an additional level of event handlers to our collection items, we would follow the pattern from the base class, rather than calling the base class constructors in this way.</p>
<p>The <kbd>HasChanges</kbd> property can be used as a flag to detect whether any item in the collection has any changes or not. This would typically be tied to the <kbd>canExecute</kbd> parameter of a save command, so that the save button would become enabled when any item in the collection had been edited and disabled if the changes were undone.</p>
<p>The <kbd>AreSynchronized</kbd> property simply specifies whether the items in the collection have all been synchronized or not, but the real beauty of this class is in the <kbd>ChangedCollection</kbd> property. Using a simple LINQ filter, we return only the items from the collection that have changes. Imagine a scenario where we enable the user to edit multiple items at once. With this property, our developers could extract just the items that they need to save from the collection with zero effort.</p>
<p>Finally, this class provides one method to enable the synchronization of all of the items in the collection at once and another to undo the changes of all of the edited items in the collection likewise. Note the use of the custom <kbd>ForEach</kbd> Extension Method in these last two methods; if you remember from the earlier <em>With Extension Methods</em> section, it enables us to perform an action on each item in the collection.</p>
<p>Through the use of the properties and methods of our Data Model base classes by other parts of our framework, we are able to extend their functionality further. While building composite functionality from different components in this way is generally optional, it can also be necessary, as we'll see later in the book.</p>
<p>The more common functionality that we can build into our application framework base classes, the less work the developers that use our framework will have to do when developing the application. However, we must plan carefully and not force the developers to have unwanted properties and methods in order to extend a particular base class that has some other functionality that they do want.</p>
<p>Typically, there will be different requirements for different components. The Data Model classes will generally have more base classes than View Models because they play a bigger role than View Models. The View Models simply provide the Views with the data and functionality that they require. However, the Data Model classes contain the data, along with validation, synchronization, and possibly animation methods and properties. With this in mind, let's look again at the View Model base class.</p>
<p>We have already seen that we will need an implementation of the <kbd>INotifyPropertyChanged</kbd> interface in our base class, <em>but what else should we implement?</em> If every View will be providing some specific functionality, such as saving and deleting items for example, then we can also add commands straight into our base class and abstract methods that each derived View Model class will have to implement:</p>
<pre>public virtual ICommand Refresh 
{ 
  get 
  { 
    return new ActionCommand(action =&gt; RefreshData(),  
      canExecute =&gt; CanRefreshData());  
  } 
} 
 
protected abstract void RefreshData(); 
 
protected abstract bool CanRefreshData(); </pre>
<p>Again, it is important to declare this command as being virtual, in case the developers need to provide their own, different implementation of it. An alternative to this arrangement would be to just add abstract properties for each command, so that the individual implementations would be completely up to the developers:</p>
<pre>public abstract ICommand Save { get; } </pre>
<p>While on the subject of commands, you may remember our basic implementation of <kbd>ActionCommand</kbd> from <a href="b2021d5b-c625-4403-9609-724ff89b9e0c.xhtml">Chapter 1</a>, <em>A Smarter Way of Working with WPF</em>. At this point, it is worth taking a short detour to investigate this further. Note that while the basic implementation shown works well most of the time, it can catch us out occasionally and we may notice that a button hasn't become enabled when it should have.</p>
<p>Let's look at an example of this. Imagine that we have a button in our UI that opens a folder for the user to view files from and is enabled when a certain condition is met in the <kbd>ICommand.CanExecute</kbd> method. Let's say that this condition is that the folder should have some content. After all, there's no point in opening an empty folder for the user.</p>
<p>Now, let's imagine that this folder will be filled when the user performs some other operation in the UI. The user clicks the button that starts this folder-filling function and the application begins to fill it. At the point that the filling function is complete and the folder now holds some content, the open folder button should become enabled, as its associated command's <kbd>CanExecute</kbd> condition is now <kbd>true</kbd>.</p>
<p>Nevertheless, the <kbd>CanExecute</kbd> method won't be called at that point and why should it? The button and, indeed, the <kbd>CommandManager</kbd> class has no idea that this background process was occurring and that the condition of the <kbd>CanExecute</kbd> method has now been met. Luckily, we have a couple of options to address this situation.</p>
<p>One option is to raise the <kbd>CanExecuteChanged</kbd> event manually to make the data bound command sources recheck the output of the <kbd>CanExecute</kbd> method and update their enabled state accordingly. To do this, we could add another method into our <kbd>ActionCommand</kbd> class, but we would have to rearrange a few things first.</p>
<p>The current implementation doesn't store any references to the event handlers that get attached to the <kbd>CanExecuteChanged</kbd> event. They're actually being stored in the <kbd>CommandManager</kbd> class, as they're just passed straight through for the <kbd>RequerySuggested</kbd> event to handle. In order to be able to raise the event manually, we'll need to store our own references to the handlers and, to do that, we'll need an <kbd>EventHandler</kbd> object:</p>
<pre>private EventHandler eventHandler; </pre>
<p>Next, we'll need to add the references to the handlers that get attached and remove those that get detached, while still passing references of them through to the <kbd>RequerySuggested</kbd> event of the <kbd>CommandManager</kbd>:</p>
<pre>public event EventHandler CanExecuteChanged 
{ 
  add 
  { 
    eventHandler += value; 
    CommandManager.RequerySuggested += value; 
  } 
  remove 
  { 
    eventHandler -= value; 
    CommandManager.RequerySuggested -= value; 
  } 
} </pre>
<p>The final change to our <kbd>ActionCommand</kbd> class is to add the method that we can call to raise the <kbd>CanExecuteChanged</kbd> event when we want the command sources of the UI controls to retrieve the new <kbd>CanExecute</kbd> value and update their enabled states:</p>
<pre>public void RaiseCanExecuteChanged() 
{ 
  eventHandler?.Invoke(this, new EventArgs()); 
} </pre>
<p>We are now able to raise the <kbd>CanExecuteChanged</kbd> event whenever we need to, although we'll also need to change our use of the <kbd>ActionCommand</kbd> class to do so. Whereas previously, we were simply returning a new instance each time its getter was called, we'll now need to keep a reference to each command that we want to have this ability:</p>
<pre>private ActionCommand saveCommand = null; 
   
...
   
public ICommand SaveCommand 
{ 
  get { return saveCommand ?? (saveCommand =  
    new ActionCommand(action =&gt; Save(), canExecute =&gt; CanSave())); } 
} </pre>
<p>If you are unfamiliar with the <kbd>??</kbd> operator shown in the preceding code, it is known as the <strong>null-coalescing operator</strong> and simply returns the left-hand operand if it is not <kbd>null</kbd>, or the right-hand operand if it is. In this case, the right-hand operand will initialize the command and set it to the <kbd>saveCommand</kbd> variable. Then, to raise the event, we call the new <kbd>RaiseCanExecuteChanged</kbd> method on our <kbd>ActionCommand</kbd> instance when we have completed our operation:</p>
<pre class="mce-root">private void ExecuteSomeCommand() 
{ 
  // Perform some operation that fulfills the canExecute condition
  // then raise the CanExecuteChanged event of the ActionCommand 
  saveCommand.RaiseCanExecuteChanged(); 
} </pre>
<p>While our method is built into the <kbd>ActionCommand</kbd> class, at times we may not have access to the particular instance that we need to raise the event on. It should therefore be noted at this point that there is another, more direct way that we can get the <kbd>CommandManager</kbd> class to raise its <kbd>RequerySuggested</kbd> event.</p>
<p>In these cases, we can simply call the <kbd>CommandManager.InvalidateRequerySuggested</kbd> method. We should also be aware that these methods of raising the <kbd>RequerySuggested</kbd> event will only work on the UI thread, so care should be taken when using them with asynchronous code. Now that our short command-related detour is complete, let's return to take a look at what other common functionality we might want to put into our View Model base class.</p>
<p>If we have chosen to use generic base classes for our Data Models, then we can take advantage of that in our <kbd>BaseViewModel</kbd> class. We can provide generic methods that utilize members from these generic base classes. Let's take a look at some simple examples:</p>
<pre>public T AddNewDataTypeToCollection&lt;S, T&gt;(S collection)  
  where S : BaseSynchronizableCollection&lt;T&gt; 
  where T : BaseSynchronizableDataModel&lt;T&gt;, new() 
{ 
  T item = collection.GetNewItem(); 
  if (item is IAuditable)
    ((IAuditable)item).Auditable.CreatedOn = DateTime.Now; 
  item.Synchronize(); 
  collection.Add(item); 
  collection.CurrentItem = item; 
  return item; 
} 
 
public T InsertNewDataTypeToCollection&lt;S, T&gt;(int index, S collection)  
  where S : BaseSynchronizableCollection&lt;T&gt;  
  where T : BaseSynchronizableDataModel&lt;T&gt;, new() 
{ 
  T item = collection.GetNewItem(); 
  if (item is IAuditable)  
    ((IAuditable)item).Auditable.CreatedOn = DateTime.Now; 
  item.Synchronize(); 
  collection.Insert(index, item); 
  collection.CurrentItem = item; 
  return item; 
} 
 
public void RemoveDataTypeFromCollection&lt;S, T&gt;(S collection, T item)  
  where S : BaseSynchronizableCollection&lt;T&gt;  
  where T : BaseSynchronizableDataModel&lt;T&gt;, new() 
{ 
  int index = collection.IndexOf(item); 
  collection.RemoveAt(index); 
  if (index &gt; collection.Count) index = collection.Count; 
  else if (index &lt; 0) index++; 
  if (index &gt; 0 &amp;&amp; index &lt; collection.Count &amp;&amp; 
    collection.CurrentItem != collection[index]) 
    collection.CurrentItem = collection[index]; 
} </pre>
<p>Here, we see three simple methods that encapsulate more common functionality. Note that we must specify the same generic type constraints that are declared on our bass classes. Failure to do so would either result in compilation errors or us not being able to use our Data Model classes with these methods.</p>
<p>The <kbd>AddNewDataTypeToCollection</kbd> and <kbd>InsertNewDataTypeToCollection</kbd> methods are almost identical and start by creating a new item of the relevant type using the <kbd>GetNewItem</kbd> method of our generic <kbd>BaseSynchronizableCollection</kbd> class. Next, we see another use for our <kbd>IAuditable</kbd> interface. In this case, we set the <kbd>CreatedOn</kbd> date of the new item if it implements this interface.</p>
<p>Because we declared the generic type constraint on the <kbd>T</kbd>-type parameter that specifies that it must be, or extend, the <kbd>BaseSynchronizableDataModel</kbd> class, we are able to call the <kbd>Synchronize</kbd> method to synchronize the new item. We then add the item to the collection and set it as the value of the <kbd>CurrentItem</kbd> property. Finally, both methods return the new item.</p>
<p>The last method performs the opposite action; it removes an item from the collection. Before doing so, it checks the item's position in the collection and sets the <kbd>CurrentItem</kbd> property to the next item if possible, or the next nearest item if the removed item was the last item in the collection.</p>
<p>Once again, we see how we can encapsulate commonly used functionality into our base class and save the users of our framework both time and effort in reimplementing this functionality in each View Model class. We can package up any common functionality that we require in this manner. Having now seen several examples of providing functionality in our base classes, let's now turn our attention to providing separation between the components of our framework.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Separating the Data Access Layer</h1>
                
            
            
                
<p>Now that we've had a look at providing a variety of functionality through our base classes and interfaces, let's investigate how we can provide the Separation of Concerns that is crucial when using the MVVM pattern. Once again, we turn to the humble interface to help us achieve this. Let's view a simplified example:</p>
<pre>using System; 
using CompanyName.ApplicationName.DataModels; 
 
namespace CompanyName.ApplicationName.Models.Interfaces 
{ 
  public interface IDataProvider 
  { 
    User GetUser(Guid id); 
 
    bool SaveUser(User user); 
  } 
} </pre>
<p>We start off with a very simple interface. Of course, real applications will have a great many more methods than this, but the principle is the same, regardless of the complexity of the interface. So here, we just have a <kbd>GetUser</kbd> and a <kbd>SaveUser</kbd> method that our <kbd>DataProvider</kbd> classes need to implement. Now, let's look at the <kbd>ApplicationDataProvider</kbd> class:</p>
<pre>using System; 
using System.Data.Linq; 
using System.Linq; 
using CompanyName.ApplicationName.DataModels; 
using CompanyName.ApplicationName.Models.Interfaces; 
 
namespace CompanyName.ApplicationName.Models.DataProviders 
{ 
  public class ApplicationDataProvider : IDataProvider 
  { 
    public ApplicationDataContext DataContext 
    { 
      get { return new ApplicationDataContext(); } 
    } 
 
    public User GetUser(Guid id) 
    { 
      DbUser dbUser = DataContext.DbUsers.SingleOrDefault(u =&gt; u.Id == id);  
      if (dbUser == null) return null; 
      return new User(dbUser.Id, dbUser.Name, dbUser.Age); 
    } 
 
    public bool SaveUser(User user) 
    { 
      using (ApplicationDataContext dataContext = DataContext) 
      { 
        DbUser dbUser = 
          dataContext.DbUsers.SingleOrDefault(u =&gt; u.Id == user.Id); 
        if (dbUser == null) return false; 
        dbUser.Name = user.Name; 
        dbUser.Age = user.Age; 
        dataContext.SubmitChanges(ConflictMode.FailOnFirstConflict); 
        return true; 
      } 
    } 
  } 
} </pre>
<p>This <kbd>ApplicationDataProvider</kbd> class uses some simple LINQ to SQL to query and update a database for the <kbd>User</kbd> specified by the <kbd>id</kbd> value provided. That means that this particular implementation of the interface requires a connection to a database. We want to avoid having this dependency when testing our application, so we'll need another implementation of the interface to use for testing purposes. Let's take a look at our mock implementation now:</p>
<pre>using System; 
using CompanyName.ApplicationName.DataModels; 
using CompanyName.ApplicationName.Models.Interfaces; 
 
namespace Test.CompanyName.ApplicationName.Models.DataProviders 
{ 
  public class MockDataProvider : IDataProvider 
  { 
    public User GetUser(Guid id) 
    { 
      return new User(id, "James Smith", 25); 
    } 
 
    public bool SaveUser(User user) 
    { 
      return true; 
    } 
  } 
} </pre>
<p>In this <kbd>MockDataProvider</kbd> implementation of the <kbd>IDataProvider</kbd> interface, we can see that the data is just manually mocked. In fact, it just returns the one single <kbd>User</kbd> from the <kbd>GetUser</kbd> method and always returns <kbd>true</kbd> from the <kbd>SaveUser</kbd> method, so it's fairly useless.</p>
<p>In a real-world application, we would either utilize a mocking framework, or manually mock up some more substantial testing data. Still, this will suffice for the point that we are focusing on here. Now that we've seen the classes involved, let's look at how they might be used.</p>
<p>The idea is that we have some sort of <kbd>DataController</kbd> class or classes that sit between the <kbd>IDataProvider</kbd> interface and the View Model classes. The View Model classes request data from the <kbd>DataController</kbd> class and, in turn, it requests data through the interface.</p>
<p>It therefore mirrors the methods of the interface and typically introduces some extra functionality, such as feedback handling for example. Let's see what our simplified <kbd>DataController</kbd> class looks like:</p>
<pre>using System; 
using CompanyName.ApplicationName.DataModels; 
using CompanyName.ApplicationName.Models.Interfaces; 
 
namespace CompanyName.ApplicationName.Models.DataControllers 
{ 
  public class DataController 
  { 
    private IDataProvider dataProvider; 
 
    public DataController(IDataProvider dataProvider) 
    { 
      DataProvider = dataProvider; 
    } 
 
    protected IDataProvider DataProvider 
    { 
      get { return dataProvider; } 
      private set { dataProvider = value; } 
    } 
 
    public User GetUser(Guid id) 
    { 
      return DataProvider.GetUser(id); 
    } 
 
    public bool SaveUser(User user) 
    { 
      return DataProvider.SaveUser(user); 
    } 
  } 
} </pre>
<p>As we can see, the <kbd>DataController</kbd> class has a private member variable of type <kbd>IDataProvider</kbd>, which is populated in its constructor. It is this variable that is used to access the application data source. When the application is running, an instance of our <kbd>ApplicationDataProvider</kbd> class is used to instantiate the <kbd>DataController</kbd> class, and so our actual data source is used:</p>
<pre>DataController dataController = 
  new DataController(new ApplicationDataProvider()); </pre>
<p>However, when we are testing our application, we can use an instance of our <kbd>MockDataProvider</kbd> class to instantiate the <kbd>DataController</kbd> class instead, thereby eliminating our dependency on the actual data source:</p>
<pre>DataController dataController = new DataController(new MockDataProvider());</pre>
<p>In this way, we can swap out the code that provides the data for the View Models, while keeping the rest of the code unchanged. This enables us to test the code in the View Models without having to be connected to our actual data storage device. In the next section, we'll see better ways to initialize these classes, but for now, let's see what else our <kbd>DataController</kbd> class could do for us.</p>
<p>Interfaces become more useful when they are used by parts of the application framework, other than the implementing classes. Apart from than defining some auditing properties and having the possibility of outputting their values, our earlier <kbd>IAuditable</kbd> interface example is not overly useful. We could however, extend its functionality further in our <kbd>DataController</kbd> class by automatically updating its values. We'll need to add some more members to achieve this:</p>
<pre>using CompanyName.ApplicationName.DataModels.Interfaces; 
    
... 
    
public User CurrentUser { get; set; } 
    
... 
    
private void SetAuditUpdateFields&lt;T&gt;(T dataModel) where T : IAuditable 
{ 
  dataModel.Auditable.UpdatedOn = DateTime.Now; 
  dataModel.Auditable.UpdatedBy = CurrentUser; 
  return dataModel; 
} </pre>
<p>We first need to add a property of type <kbd>User</kbd> that we will use to set the value of the current user of the application. This can be set as new users login to the application. Next, we need a method to update the "<em>updated</em>" values of our <kbd>IAuditable</kbd> interface. Again, we add a generic type constraint to ensure that only objects that implement our interface can be passed into this method. The result of this is that the developers that use our application framework can easily update these values:</p>
<pre>public bool SaveUser(User user) 
{ 
  return DataProvider.SaveUser(SetAuditUpdateFields(user)); 
} </pre>
<p>We could add a similar method to set the "<em>created</em>" audit properties when adding new objects:</p>
<pre>public bool AddUser(User user) 
{ 
  return DataProvider.AddUser(SetAuditCreateFields(user)); 
} 
    
... 
    
private void SetAuditCreateFields&lt;T&gt;(T dataModel) where T : IAuditable 
{ 
  dataModel.Auditable.CreatedOn = DateTime.Now; 
  dataModel.Auditable.CreatedBy = CurrentUser; 
  return dataModel; 
} </pre>
<p>Continuing this example, we could extend the constructor of our <kbd>DataController</kbd> class to accept a <kbd>User</kbd> input parameter that we can use to set our <kbd>CurrentUser</kbd> property with:</p>
<pre>public DataController(IDataProvider dataProvider, User currentUser) 
{ 
  DataProvider = dataProvider; 
  CurrentUser = currentUser; 
} </pre>
<p>We could then expose our data source to our View Models through their base class using a <kbd>CurrentUser</kbd> property in the <kbd>StateManager</kbd> class and the <kbd>DependencyManager</kbd> class that we'll see in the following sections:</p>
<pre>protected DataController Model 
{ 
  get { return new DataController( 
    DependencyManager.Instance.Resolve&lt;IDataProvider&gt;(), 
    StateManager.CurrentUser); } 
} </pre>
<p>Essentially, anything, that we need to do to the data coming from our application data source can be achieved in a single <kbd>DataController</kbd> class. However, if we require several different modifications, then we could alternatively create several controller classes and chain them together, with each performing their separate tasks in turn.</p>
<p>As they could all implement the same methods, they could all potentially implement the same interface:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-2363 image-border" src="img/23988467-63fb-4345-b6a8-a037bc9ad54c.png" style="width:54.00em;height:18.75em;"/></p>
<p>We'll see an example of this in <a href="506906a3-83cb-4b51-9ac5-3c00e650198a.xhtml">Chapter 10</a>, <em>Completing That Great User Experience</em>, but now that we have a good idea on how best to setup our application data source connections to provide the separation required by the MVVM pattern, we can focus on the next way of building functionality into our framework. Let's move on to discover how we can plug more complex and/or specialized functionality into our framework.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Providing services</h1>
                
            
            
                
<p>The job of the base classes and interfaces in our application framework are to encapsulate functionality that is commonly used by our View Models and Data Models. When the required functionality is more complex, or when it involves particular resources, or external connections, we implement it in separate service, or manager classes. For the remainder of this book, we will refer to these as manager classes. In larger applications, these are typically provided in a separate project.</p>
<p>Encapsulating them in a separate project enables us to reuse the functionality from these classes in our other applications. Which classes we use in this project will depend on the requirements of the application that we're building, but it will often include classes that provide the ability to send emails, to access the end user's hard drive, to export data in various formats, or to manage global application state for example.</p>
<p>We will investigate a number of these classes in this book, so that we have a good idea of how to implement our own custom manager classes. The most commonly used of these classes can normally be accessed directly from the base View Model class via properties. There are a few different ways that we can expose these classes to the View Models, so let's examine them.</p>
<p>When a manager class is used often, and for short durations each time, we can expose a new instance of them each time, as follows:</p>
<pre>public FeedbackManager FeedbackManager 
{ 
  get { return new FeedbackManager(); }  
} </pre>
<p>However, if a manager class is required for the life of the application because it must remember a particular state or configuration, for example, then we typically use the <kbd>static</kbd> keyword in one way or another. The simplest option would be to declare a normal class, but expose it via a static property:</p>
<pre>private static StateManager stateManager = new StateManager(); 
   
...
    
public static StateManager StateManager 
{ 
  get { return stateManager; }  
} </pre>
<p>An alternative method of having one and only one instance of a class being instantiated and having it stay alive for as long as the application is running is for us to use the Singleton pattern. While it was all the rage twenty or so years ago, it has unfortunately recently fallen foul of more modern programming principles, such as the likes of SOLID, which states that each class should have a single responsibility.</p>
<p>The Singleton pattern breaks this principle as it serves whatever purpose we design it for, but it is also responsible for instantiating itself and maintaining a single access point. Before discussing the merits and pitfalls of this pattern further, let's take a look at how we might implement it in our manager class:</p>
<pre>namespace CompanyName.ApplicationName.Managers 
{ 
  public class StateManager 
  { 
    private static StateManager instance; 
 
    private StateManager() { } 
 
    public static StateManager Instance 
    { 
      get { return instance ?? (instance = new StateManager()); } 
    } 
    
    ...
  } 
} </pre>
<p>Note that it can be implemented in a variety of ways, but this particular way uses lazy initialization, where the instance is not instantiated until it is first referenced via the <kbd>Instance</kbd> property. Using the <kbd>??</kbd> operator again, the <kbd>Instance</kbd> property getter can be read as "return the one and only instantiated instance if it is not <kbd>null</kbd>, or, if it is, instantiate the one and only instance and then return it." The significant part of this pattern is that as there is no public constructor and, therefore, the class cannot be externally instantiated, this property is the sinlgle way to access the internal object.</p>
<p>However, this is the very part that causes trouble for some developers, as this makes inheritance impossible with these classes. In our case though, we won't need to extend our <kbd>StateManager</kbd> class, so that is not a concern for us. Others may point to the problem that exposing this Singleton class, as shown in the following code, will tightly couple it to the base View Model class that it is declared in:</p>
<pre>public StateManager StateManager 
{ 
  get { return StateManager.Instance; }  
} </pre>
<p>While this is true, what harm is that with this class? Its purpose is to maintain the state of user settings, common or default values, and values for UI display and operation statuses. It contains no resources and no real reason to avoid using it when running unit tests, so in this case, the tight coupling is inconsequential. In this regard, the Singleton pattern continues to be a useful tool in the right situations, but we should certainly be aware of its pitfalls all the same.</p>
<p>However, if a particular manger class does utilize resources or creates some form of connection with the outside world, for example, like an <kbd>EmailManager</kbd> would, then we will need to create an interface for it to maintain our Separation of Concerns. Remember that interfaces enable us to disconnect the actual application components and replace them with mock components while testing. In these cases, we have to expose the functionality in the base classes slightly differently:</p>
<pre>private IEmailManager emailManager; 
 
...
     
public BaseViewModel(IEmailManager emailManager) 
{ 
  this.emailManager = emailManager; }  
} 
    
...
    
public IEmailManager EmailManager 
{ 
  get { return emailManager; }  
} </pre>
<p>The general idea here is for us to have no direct contact with the manager class in hand, instead accessing its functionality through the interface methods and properties. By doing this, we are able to decouple the manager class from the View Models that use it and therefore enable them to be used independently of each other. Note that this is a very simple example of Dependency Injection.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing Dependency Injection</h1>
                
            
            
                
<p>Dependency injection is a well-known design pattern that aids in decoupling various components of an application. If one class uses another class to perform some functionality internally, then the class that is internally used becomes a dependency of the class that uses it. It cannot achieve its objectives without it. In some cases, this is not a problem, but in others, it can represent a huge problem.</p>
<p>For example, let's imagine that we have a <kbd>FeedbackManager</kbd> class that is responsible for providing operational feedback to the end users. In that class, we have a <kbd>FeedbackCollection</kbd> instance that holds the <kbd>Feedback</kbd> objects that are currently being displayed to the current user. Here, the <kbd>Feedback</kbd> objects are a dependency of the <kbd>FeedbackCollection</kbd> instance and that, in turn, is a dependency of the <kbd>FeedbackManager</kbd> class.</p>
<p>These objects are all tightly coupled, which is usually a bad thing in software development. However, they are also tightly related by necessity. A <kbd>FeedbackCollection</kbd> object would be useless without the <kbd>Feedback</kbd> objects, as would the <kbd>FeedbackManager</kbd> object.</p>
<p>In this particular case, these objects require this coupling to make them useful together. This is called composition, where the individual parts form a whole, but do little on their own, so it really is no problem for them to be connected in this way.</p>
<p>On the other hand, let's now contemplate the connection between our View Models and our DAL. Our View Models will definitely need access to some data, so it would at first seem to make sense to encapsulate a class in our View Models that provides the data that it requires.</p>
<p>While that would certainly work, it would unfortunately result in the DAL class becoming a dependent of the View Model class. Moreover, it would permanently couple our View Model component to the DAL and break the Separation of Concerns that MVVM provides. The kind of connection that we require in this situation is more like aggregation, where the individual parts are useful on their own.</p>
<p>In these cases, we want to be able to use the individual components separately and to avoid any tight coupling between them. Dependency Injection is a tool that we can use to provide this separation for us. In the absolute simplest terms, Dependency Injection is implemented through the use of interfaces. We've already seen some basic examples of this in the <kbd>DataController</kbd> class from the <em>Separating the Data Access Layer</em> section, and the <kbd>EmailManager</kbd> example from the previous section.</p>
<p>However, they were very basic examples and there are a variety of ways of improving them. Many application frameworks will provide the ability for developers to use Dependency Injection to inject the dependencies into their classes and we can do the same with ours. In its simplest form, our <kbd>DependencyManager</kbd> class will simply need to register the dependencies and provide a way to resolve them when required. Let's take a look:</p>
<pre>using System; 
using System.Collections.Generic; 
 
namespace CompanyName.ApplicationName.Managers 
{ 
  public class DependencyManager 
  { 
    private static DependencyManager instance; 
    private static Dictionary&lt;Type, Type&gt; registeredDependencies =  
      new Dictionary&lt;Type, Type&gt;(); 
 
    private DependencyManager() { } 
 
    public static DependencyManager Instance 
    { 
      get { return instance ?? (instance = new DependencyManager()); } 
    } 
 
    public int Count 
    { 
      get { return registeredDependencies.Count; } 
    } 
 
    public void ClearRegistrations() 
    { 
      registeredDependencies.Clear(); 
    } 
 
    public void Register&lt;S, T&gt;() where S : class where T : class  
    { 
      if (!typeof(S).IsInterface) throw new ArgumentException("The S 
        generic type parameter of the Register method must be an
        interface.", "S"); 
      if (!typeof(S).IsAssignableFrom(typeof(T))) throw  
        new ArgumentException("The T generic type parameter must be a 
        class that implements the interface specified by the S generic
        type parameter.", "T"); 
      if (!registeredDependencies.ContainsKey(typeof(S)))  
        registeredDependencies.Add(typeof(S), typeof(T)); 
    } 
 
    public T Resolve&lt;T&gt;() where T : class 
    { 
      Type type = registeredDependencies[typeof(T)]; 
      return Activator.CreateInstance(type) as T; 
    } 
 
    public T Resolve&lt;T&gt;(params object[] args) where T : class 
    { 
      Type type = registeredDependencies[typeof(T)]; 
      if (args == null || args.Length == 0)  
        return Activator.CreateInstance(type) as T; 
      else return Activator.CreateInstance(type, args) as T; 
    } 
  } 
} </pre>
<p>You may have noticed that we are using the Singleton pattern again for this class. In this case, it again fits our requirements exactly. We want one, and only one, instance of this class to be instantiated and we want it to stay alive for as long as the application is running. When testing, it is used to inject our mock dependencies into the View Models, so it is part of the framework that enables our Separation of Concerns.</p>
<p>The <kbd>Count</kbd> property and the <kbd>ClearRegistrations</kbd> method are more useful for testing than when running the application and the real action goes on in the <kbd>Register</kbd> and <kbd>Resolve</kbd> methods. The <kbd>Register</kbd> method registers the interface type represented by the <kbd>S</kbd> generic type parameter, with the concrete implementation of that interface represented by the <kbd>T</kbd> generic type parameter.</p>
<p>As the <kbd>S</kbd> generic type parameter must be an interface, an <kbd>ArgumentException</kbd> is thrown at runtime if the type parameter class supplied is not one. A further check is performed to ensure that the type specified by the <kbd>T</kbd> generic type parameter actually implements the interface specified by the <kbd>S</kbd> generic type parameter, and a further <kbd>ArgumentException</kbd> is thrown if the check fails.</p>
<p>The method then verifies the fact that the type parameter provided is not already in the <kbd>Dictionary</kbd> and adds it if it is unique in the collection. Therefore, in this particular implementation, we can only specify a single concrete implementation for each supplied interface. We could change this to either update the stored reference if an existing type was passed again, or even to store multiple concrete types for each interface. It all depends on the application requirements.</p>
<p>Note the generic type constraint declared on this method that ensures that the type parameters will at least be classes. Unfortunately, there is no such constraint that would allow us to specify that a particular generic type parameter should be an interface. However, this type of parameter validation should be used where possible, as it helps the users of our framework to avoid using these methods with inappropriate values.</p>
<p>The <kbd>Resolve</kbd> methods use some simple reflection to return the concrete implementations of the interface types represented by the generic type parameters used. Again, note the generic type constraints declared by these two methods, that specify that the type used for type <kbd>T</kbd> parameter must be a class. This is to prevent the <kbd>Activator.CreateInstance</kbd> methods from throwing an <kbd>Exception</kbd> at runtime, if a type that could not be instantiated were used.</p>
<p>The first overload can be used for classes without any constructor parameters, and the second has an additional <kbd>params</kbd> input parameter to pass the parameters to use when instantiating classes that require constructor parameters.</p>
<p>The <kbd>DependencyManager</kbd> class can be set up during application startup, using the <kbd>App.xaml.cs</kbd> file. To do this, we first need to find the following <kbd>StartupUri</kbd> property setting in the <kbd>Application</kbd> declaration at the top of the <kbd>App.xaml</kbd> file:</p>
<pre>StartupUri="MainWindow.xaml" </pre>
<p>We then need to replace this <kbd>StartupUri</kbd> property setting with the following <kbd>Startup</kbd> property setting:</p>
<pre>Startup="App_Startup" </pre>
<p>In this example, <kbd>App_Startup</kbd> is the name of the initialization method that we want to be called at startup. Note that as the WPF Framework is no longer starting the <kbd>MainWindow</kbd> class, it is now our responsibility to do so:</p>
<pre>using System.Windows; 
using CompanyName.ApplicationName.Managers; 
using CompanyName.ApplicationName.ViewModels; 
using CompanyName.ApplicationName.ViewModels.Interfaces; 
 
namespace CompanyName.ApplicationName 
{ 
  public partial class App : Application 
  { 
    public void App_Startup(object sender, StartupEventArgs e) 
    { 
      RegisterDependencies(); 
      new MainWindow().Show(); 
    } 
 
    private void RegisterDependencies() 
    { 
      DependencyManager.Instance.ClearRegistrations(); 
      DependencyManager.Instance.Register&lt;IDataProvider,  
        ApplicationDataProvider&gt;(); 
      DependencyManager.Instance.Register&lt;IEmailManager, EmailManager&gt;(); 
      DependencyManager.Instance.Register&lt;IExcelManager, ExcelManager&gt;(); 
      DependencyManager.Instance.Register&lt;IWindowManager, WindowManager&gt;();
    } 
  } 
}  </pre>
<p>When we want to inject these dependencies into a View Model in the application at runtime, we could use the <kbd>DependencyManager</kbd> class like this:</p>
<pre>UsersViewModel viewModel =  
  new UsersViewModel(DependencyManager.Instance.Resolve&lt;IEmailManager&gt;(),
  DependencyManager.Instance.Resolve&lt;IExcelManager&gt;(),  
  DependencyManager.Instance.Resolve&lt;IWindowManager&gt;()); </pre>
<p>The real beauty of this system is that when testing our View Models, we can register our mock manager classes instead. The same preceding code will then resolve the interfaces to their mock concrete implementations, thereby freeing our View Models from their actual dependencies:</p>
<pre>private void RegisterMockDependencies() 
{ 
  DependencyManager.Instance.ClearRegistrations(); 
  DependencyManager.Instance.Register&lt;IDataProvider, MockDataProvider&gt;();
  DependencyManager.Instance.Register&lt;IEmailManager, MockEmailManager&gt;();  
  DependencyManager.Instance.Register&lt;IExcelManager, MockExcelManager&gt;(); 
  DependencyManager.Instance.Register&lt;IWindowManager, MockWindowManager&gt;(); 
} </pre>
<p>We've now seen the code that enables us to swap out our dependent classes with mock implementations when we are testing our application. However, we've also seen that not all of our manager classes will require this. So, what exactly represents a dependency? Let's take a look at a simple example involving a UI popup message box:</p>
<pre>using CompanyName.ApplicationName.DataModels.Enums; 
 
namespace CompanyName.ApplicationName.Managers.Interfaces 
{ 
  public interface IWindowManager 
  { 
    MessageBoxButtonSelection ShowMessageBox(string message, 
      string title, MessageBoxButton buttons, MessageBoxIcon icon); 
  } 
} </pre>
<p>Here, we have an interface that declares a single method. This is the method that the developers will call from the View Model classes when they need to display a message box in the UI. It will use a real <kbd>MessageBox</kbd> object during runtime, but that uses a number of enumerations from the <kbd>System.Windows</kbd> namespace.</p>
<p>We want to avoid interacting with these enumeration instances in our View Models, as that will require adding a reference to the <kbd>PresentationFramework</kbd> assembly and tie our View Models to part of our Views component.</p>
<p>We therefore need to abstract them from our interface method definition. In this case, we have simply replaced the enumerations from the <kbd>PresentationFramework</kbd> assembly with custom enumerations from our domain that merely replicate the original values. As such, there is little point in showing the code for these custom enumerations here.</p>
<p>While it's never a good idea to duplicate code, it's an even worse idea to add a UI assembly like the <kbd>PresentationFramework</kbd> assembly to our <kbd>ViewModels</kbd> project. By encapsulating this assembly within the <kbd>Managers</kbd> project and converting its enumerations, we can expose the functionality that we need from it without tying it to our View Models:</p>
<pre>using System.Windows; 
using CompanyName.ApplicationName.Managers.Interfaces; 
using MessageBoxButton =  
  CompanyName.ApplicationName.DataModels.Enums.MessageBoxButton; 
using MessageBoxButtonSelection =  
  CompanyName.ApplicationName.DataModels.Enums.MessageBoxButtonSelection; 
using MessageBoxIcon =  
  CompanyName.ApplicationName.DataModels.Enums.MessageBoxIcon; 
 
namespace CompanyName.ApplicationName.Managers 
{ 
  public class WindowManager : IWindowManager 
  { 
    public MessageBoxButtonSelection ShowMessageBox(string message,  
      string title, MessageBoxButton buttons, MessageBoxIcon icon) 
    { 
      System.Windows.MessageBoxButton messageBoxButtons; 
      switch (buttons) 
      { 
        case MessageBoxButton.Ok: messageBoxButtons =  
          System.Windows.MessageBoxButton.OK; break; 
        case MessageBoxButton.OkCancel: messageBoxButtons =
          System.Windows. MessageBoxButton.OkCancel; break; 
        case MessageBoxButton.YesNo: messageBoxButtons =  
          System.Windows.MessageBoxButton.YesNo; break; 
        case MessageBoxButton.YesNoCancel: messageBoxButtons =           
          System.Windows.MessageBoxButton.YesNoCancel; break; 
        default: messageBoxButtons =
          System.Windows.MessageBoxButton.OKCancel; break; 
      } 
      MessageBoxImage messageBoxImage; 
      switch (icon) 
      { 
        case MessageBoxIcon.Asterisk:  
          messageBoxImage = MessageBoxImage.Asterisk; break; 
        case MessageBoxIcon.Error:  
          messageBoxImage = MessageBoxImage.Error; break; 
        case MessageBoxIcon.Exclamation:  
          messageBoxImage = MessageBoxImage.Exclamation; break; 
        case MessageBoxIcon.Hand:  
          messageBoxImage = MessageBoxImage.Hand; break; 
        case MessageBoxIcon.Information:  
          messageBoxImage = MessageBoxImage.Information; break; 
        case MessageBoxIcon.None:  
          messageBoxImage = MessageBoxImage.None; break; 
        case MessageBoxIcon.Question:  
          messageBoxImage = MessageBoxImage.Question; break; 
        case MessageBoxIcon.Stop:           
          messageBoxImage = MessageBoxImage.Stop; break; 
        case MessageBoxIcon.Warning: 
          messageBoxImage = MessageBoxImage.Warning; break;
        default: messageBoxImage = MessageBoxImage.Stop; break; 
      } 
      MessageBoxButtonSelection messageBoxButtonSelection =  
        MessageBoxButtonSelection.None; 
      switch (MessageBox.Show(message, title, messageBoxButtons,
        messageBoxImage)) 
      { 
        case MessageBoxResult.Cancel: messageBoxButtonSelection =  
          MessageBoxButtonSelection.Cancel; break; 
        case MessageBoxResult.No: messageBoxButtonSelection =  
          MessageBoxButtonSelection.No; break; 
        case MessageBoxResult.OK: messageBoxButtonSelection =  
          MessageBoxButtonSelection.Ok; break; 
        case MessageBoxResult.Yes: messageBoxButtonSelection =  
          MessageBoxButtonSelection.Yes; break; 
      } 
      return messageBoxButtonSelection; 
    } 
  } 
} </pre>
<p>We start with our <kbd>using</kbd> directives and see further examples of using alias directives. In this case, we created some enumeration classes with the same names as those from the <kbd>System.Windows</kbd> namespace. To avoid the conflicts that we would have caused by adding a standard <kbd>using</kbd> directive for our <kbd>CompanyName.ApplicationName.DataModels.Enums</kbd> namespace, we add aliases to enable us to work with just the types from our namespace that we require.</p>
<p>After this, our <kbd>WindowManager</kbd> class simply converts the UI-related enumeration values to and from our custom enumerations, so that we can use the functionality of the message box, but not be tied to its implementation. Imagine a situation where we need to use this to output an error message:</p>
<pre>WindowManager.ShowMessageBox(errorMessage, "Error", MessageBoxButton.Ok, 
  MessageBoxIcon.Error); </pre>
<p>When execution reaches this point, a message box will pop up, displaying an error message with an error icon and heading. The application will freeze at this point while waiting for user feedback and, if the user does not click a button on the popup, it will remain frozen indefinitely. If execution reaches this point during a unit test and there is no user to click the button, then our test will freeze indefinitely and never complete.</p>
<p>In this example, the <kbd>WindowManager</kbd> class is dependent upon having a user present to interact with it. Therefore, if the View Models used this class directly, they would also have the same dependency. Other classes might have a dependency on an email server, database, or other type of resource, for example. These are the types of classes that View Models should only interact with via interfaces.</p>
<p>In doing so, we provide the ability to use our components independently from each other. Using our <kbd>IWindowManager</kbd> interface, we are able to use our <kbd>ShowMessageBox</kbd> method independently of the end users. In this way, we are able to break the user dependency and run our unit tests without them. Our mock implementation of the interface can simply return a positive response each time and the program execution can continue unheeded:</p>
<pre>using CompanyName.ApplicationName.DataModels.Enums; 
using CompanyName.ApplicationName.Managers.Interfaces; 
 
namespace Test.CompanyName.ApplicationName.Mocks.Managers 
{ 
  public class MockWindowManager : IWindowManager 
  { 
    public MessageBoxButtonSelection ShowMessageBox(string message,  
      string title, MessageBoxButton buttons, MessageBoxIcon icon) 
    { 
      switch (buttons) 
      { 
        case MessageBoxButton.Ok: 
        case MessageBoxButton.OkCancel:  
          return MessageBoxButtonSelection.Ok; 
        case MessageBoxButton.YesNo: 
        case MessageBoxButton.YesNoCancel:  
          return MessageBoxButtonSelection.Yes; 
        default: return MessageBoxButtonSelection.Ok; 
      } 
    } 
  } 
} </pre>
<p>This simple example shows another method of exposing functionality from a source to our View Models, but without it becoming a dependency. In this way, we can provide a whole host and variety of capabilities to our View Models, while still enabling them to function independently.</p>
<p>We now have the knowledge and tools to build functionality into our application framework in many different ways, yet our probe into application frameworks is still not quite complete. One other essential matter is that of connecting our Views with our View Models. We'll need to decide how the users of our framework should do this, so let's look at some choices.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Connecting Views with View Models</h1>
                
            
            
                
<p>In WPF, there are several ways to connect our Views to their data sources. We've all seen examples of the simplest method of a View setting its <kbd>DataContext</kbd> property to itself in its code behind:</p>
<pre>public partial class MainWindow : Window 
{ 
  public MainWindow() 
  { 
    InitializeComponent(); 
    DataContext = this; 
  } 
} </pre>
<p>However, this should only ever be used for quick demonstrations and never in our real-world applications. If we need to data-bind to properties declared in a View's code behind, let's say for a particular custom <kbd>UserControl</kbd>, then we should use <kbd>RelativeSource</kbd> bindings instead. We'll find out more about this in <a href="2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml">Chapter 4</a>, <em>Becoming Proficient with Data Binding</em>, but for now, let's continue looking at the alternative ways to connect the Views with their data sources.</p>
<p>The next simplest method utilizes the data templating Model that is built into the WPF Framework. This topic will also be covered in much more detail in <a href="2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml">Chapter 4</a>, <em>Becoming Proficient with Data Binding</em>, but, in short, a <kbd>DataTemplate</kbd> is used to inform the WPF Framework how we want it to render data objects of a particular type. The simple example shows how we could define the visual output of our <kbd>User</kbd> objects:</p>
<pre>&lt;DataTemplate DataType="{x:Type DataModels:User}"&gt; 
  &lt;TextBlock Text="{Binding Name}" /&gt; 
&lt;/DataTemplate&gt; </pre>
<p>In this example, the <kbd>DataType</kbd> property specifies which type of object this relates to and therefore, which properties the containing XAML bindings have access to. Keeping it simple for now, we just output the name of each <kbd>User</kbd> in this <kbd>DataTemplate</kbd>. When we data-bind one or more <kbd>User</kbd> objects to a UI control that is within the scope of this <kbd>DataTemplate</kbd>, they will each be rendered by the WPF Framework as a <kbd>TextBlock</kbd> that specifies their name.</p>
<p>When the rendering engine of the WPF Framework comes across a custom data object, it looks for a <kbd>DataTemplate</kbd> that has been declared for its type and, if it finds one, it renders the object according to the XAML contained within the relevant template. This means that we can create a <kbd>DataTemplate</kbd> for our View Model classes that simply specifies their related View classes as the rendering output:</p>
<pre>&lt;DataTemplate DataType="{x:Type ViewModels:UsersViewModel}"&gt; 
  &lt;Views:UsersView /&gt; 
&lt;/DataTemplate&gt; </pre>
<p>In this example, we have specified that when the WPF Framework sees an instance of our <kbd>UserViewModel</kbd> class, it should render it as one of our <kbd>UserView</kbd> classes. At this point, it will set our View Model instance to the <kbd>DataContext</kbd> property of the related View implicitly. The only downside to this method is minimal, and is that we have to add a new <kbd>DataTemplate</kbd> to our <kbd>App.xaml</kbd> file for each of our View-View Model pairs.</p>
<p>This method of connection works View Model first, where we supply the View Model instance and the WPF Framework takes care of the rest. In these cases, we typically use a <kbd>ContentControl</kbd> that has its <kbd>Content</kbd> property data bound to a <kbd>ViewModel</kbd> property, which the application View Models are set to. The WPF Framework notes the type of the View Model that is set and renders it according to its specified <kbd>DataTemplate</kbd>:</p>
<pre>private BaseViewModel viewModel; 
 
public BaseViewModel ViewModel 
{ 
  get { return viewModel; } 
  set { viewModel = value; NotifyPropertyChanged(); } 
} 
    
... 
    
ViewModel = new UserViewModel(); 
    
...
     
&lt;ContentControl Content="{Binding ViewModel}" /&gt; </pre>
<p>This is the preferred version of View to View Model connections for many, as the WPF Framework is left to take care of most of the details. However, there is another way to construct these connections that adds a layer of abstraction to the process.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Locating View Models</h1>
                
            
            
                
<p>For this method, we need to create interfaces for each of our View Models. It's called View Model Location and it's fairly similar to the Dependency Injection example that we have already seen. In fact, we could even use our existing <kbd>DependencyManager</kbd> to achieve a similar result. Let's take a quick look at that first:</p>
<pre>DependencyManager.Instance.Register&lt;IUserViewModel, UserViewModel&gt;();
     
...
     
public partial class UserView : UserControl 
{ 
  public UserView() 
  { 
    InitializeComponent(); 
    DataContext = DependencyManager.Instance.Resolve&lt;IUserViewModel&gt;(); 
  } 
} 
    
...
     
&lt;Views:UsersView /&gt; </pre>
<p>In this example, we associate the <kbd>IUserViewModel</kbd> interface with the <kbd>UserViewModel</kbd> concrete implementation of that interface in some initialization code and later, resolve the dependency, before setting it as the View's <kbd>DataContext</kbd> value. After declaring our Views in the XAML, they automatically hook themselves up to their related View Models at runtime.</p>
<p>This method of connecting Views to View Models works View first, where we declare the View and it instantiates its own View Model and sets its own <kbd>DataContext</kbd>. The downside with this method is that we have to create an interface for all of our View Models and register and resolve each of them using the <kbd>DependencyManager</kbd>.</p>
<p>The main difference between this implementation and that of a View Model Locator is that a locator provides a level of abstraction from our Singleton class, which enables us to indirectly instantiate our View Models from the XAML, without using the code behind. They also have a little extra specific functionality that enables dummy data to be used at design time. Let's take a look at the simplest possible example:</p>
<pre>using CompanyName.ApplicationName.Managers; 
using CompanyName.ApplicationName.ViewModels; 
using CompanyName.ApplicationName.ViewModels.Interfaces; 
 
namespace CompanyName.ApplicationName.Views.ViewModelLocators 
{ 
  public class ViewModelLocator 
  { 
    public IUserViewModel UserViewModel 
    { 
      get { return DependencyManager.Instance.Resolve&lt;IUserViewModel&gt;(); } 
    } 
  } 
} </pre>
<p>Here, we have a very basic View Model Locator that simply locates a single View Model. It is important that this View Model class has an empty constructor so that it can be instantiated from the XAML. Let's see how we can do this:</p>
<pre>&lt;UserControl x:Class="CompanyName.ApplicationName.Views.UserView" 
   
   
  xmlns:ViewModelLocators="clr-namespace:  
    CompanyName.ApplicationName.Views.ViewModelLocators" 
  Height="30" Width="300"&gt; 
  &lt;UserControl.Resources&gt; 
    &lt;ViewModelLocators:ViewModelLocator x:Key="ViewModelLocator" /&gt; 
  &lt;/UserControl.Resources&gt; 
  &lt;UserControl.DataContext&gt; 
    &lt;Binding Path="UserViewModel" 
      Source="{StaticResource ViewModelLocator}" /&gt; 
  &lt;/UserControl.DataContext&gt; 
  &lt;TextBlock Text="{Binding User.Name}" /&gt; 
&lt;/UserControl&gt; </pre>
<p>As a side note, you may have noticed that our <kbd>ViewModelLocator</kbd> class has been declared in the <kbd>Views</kbd> project. The location of this class is not very important, but it must have references to both the <kbd>ViewModels</kbd> and the <kbd>Views</kbd> projects, and this severely limits the number of projects in which it can reside. Typically, the only projects that will have access to the classes from both of these projects will be the <kbd>Views</kbd> project and the startup project.</p>
<p>Getting back to our example, an instance of the <kbd>ViewModelLocator</kbd> class is declared in the View's <kbd>Resources</kbd> section and this will only work if we have a parameterless constructor (including the default parameterless constructor that is declared for us if we do not explicitly declare a constructor). Without a parameterless constructor, we will receive an error in the Visual Studio designer.</p>
<p>Our View sets its own <kbd>DataContext</kbd> property in XAML this time, using a binding path to the <kbd>UserViewModel</kbd> property from our <kbd>ViewModelLocator</kbd> resource. The property then utilizes our <kbd>DependencyManager</kbd> to resolve the concrete implementation of the <kbd>IUserViewModel</kbd> interface and return it for us.</p>
<p>There are other benefits to using this pattern as well though. One problem often faced by WPF developers is that the Visual Studio WPF Designer cannot resolve the interfaces that are used to back their concrete implementations, nor can it access the application data sources during design time. The result of this is that the designer does not typically display data items that cannot be resolved.</p>
<p>One thing that we can do with our <kbd>ViewModelLocator</kbd> resource is to provide mock View Models that have dummy data returned from their properties that we can use to help visualize our Views as we construct them. To achieve this, we can make use of the <kbd>IsInDesignMode</kbd> Attached Property from the <kbd>DesignerProperties</kbd> .NET class:</p>
<pre>public bool IsDesignTime 
{ 
  get { return 
    DesignerProperties.GetIsInDesignMode(new DependencyObject()); } 
} </pre>
<p>The <kbd>DependencyObject</kbd> object here is required by the Attached Property and, in fact, is the object that is being checked. As all objects supplied here would return the same value, we are free to use a new one each time. If we are concerned that this property will be called more frequently than the garbage collector, we could opt to use a single member instead, just for this purpose:</p>
<pre>private DependencyObject dependencyObject = new DependencyObject(); 
 
public bool IsDesignTime 
{ 
  get { return DesignerProperties.GetIsInDesignMode(dependencyObject); } 
} </pre>
<p>However, if we need a <kbd>DependencyObject</kbd> object just for this purpose, then we could simplify things further by extending our <kbd>ViewModelLocator</kbd> class from the <kbd>DependencyObject</kbd> class and use itself as the required parameter. Of course, this would mean that our class would inherit unwanted properties, so some might prefer to avoid doing this. Let's see how we could use this property to provide the WPF Designer with mock data at design time:</p>
<pre>using System.ComponentModel; 
using System.Windows; 
using CompanyName.ApplicationName.Managers; 
using CompanyName.ApplicationName.ViewModels; 
using CompanyName.ApplicationName.ViewModels.Interfaces; 
 
namespace CompanyName.ApplicationName.Views.ViewModelLocators 
{ 
  public class ViewModelLocator : DependencyObject 
  { 
    public bool IsDesignTime 
    { 
      get { return DesignerProperties.GetIsInDesignMode(this); } 
    } 
 
    public IUserViewModel UserViewModel 
    { 
      get 
      { 
        return IsDesignTime ? new MockUserViewModel() :  
          DependencyManager.Instance.Resolve&lt;IUserViewModel&gt;();  
      } 
    } 
  } 
} </pre>
<p>If you look at our <kbd>UserViewModel</kbd> property, you'll see the value that we return is now dependent upon the value of the <kbd>IsDesignTime</kbd> property. If we are in design time, for example, when the View file is open in the WPF Designer, then the <kbd>MockUserViewModel</kbd> class will be returned. At runtime, however, the concrete implementation of our <kbd>IUserViewModel</kbd> interface that we registered with the <kbd>DependencyManager</kbd> will be returned instead.</p>
<p>The <kbd>MockUserViewModel</kbd> class will typically hardcode some mock data and return it from its properties when requested. In this manner, the WPF Designer will be able to visualize the data for the developers or designers while they build the Views.</p>
<p>However, each View will require a new property in our locator class and we'll need to copy this conditional operator statement from the preceding code for each. As always in OOP, there is a further abstraction that we could make to hide that implementation away from the developers that will use our framework. We could create a generic base class for our View Model Locator:</p>
<pre>using System.ComponentModel; 
using System.Windows; 
using CompanyName.ApplicationName.Managers; 
 
namespace CompanyName.ApplicationName.Views.ViewModelLocators 
{ 
  public abstract class BaseViewModelLocator&lt;T&gt; : DependencyObject  
    where T : class 
  { 
    private T runtimeViewModel, designTimeViewModel; 
 
    protected bool IsDesignTime 
    { 
      get { return DesignerProperties.GetIsInDesignMode(this); } 
    } 
 
    public T ViewModel 
    { 
      get { return IsDesignTime ?  
        DesignTimeViewModel : RuntimeViewModel; } 
    } 
 
    protected T RuntimeViewModel 
    { 
      get { return runtimeViewModel ??  
        (runtimeViewModel = DependencyManager.Instance.Resolve&lt;T&gt;()); } 
    } 
 
    protected T DesignTimeViewModel 
    { 
      set { designTimeViewModel = value; } 
      get { return designTimeViewModel; } 
    } 
  } 
} </pre>
<p>We start by declaring an abstract class that takes a generic type parameter, which represents the interface type of the View Model that we are trying to locate. Once again, note the generic type constraint declared on the generic type parameter that specifies that the type used must be a class. This is now required because this class calls the <kbd>Resolve</kbd> method of the <kbd>DependencyManager</kbd> class and that has the same constraint declared upon it.</p>
<p>We have two internal members of the relevant type of View Model interface that back the properties with the same names. There's one for our runtime View Model and one for our design time View Model. The third View Model property of the same type is the one that we will data-bind to from Views and it uses our <kbd>IsDesignTime</kbd> property to determine which View Model to return.</p>
<p>A nice touch in this class is that it does a lot of the connection work for the developers. They don't need to concern themselves with the implementation of the <kbd>IsDesignTime</kbd> property, and this base class will even attempt to automatically resolve the concrete View Model dependency for the runtime View Model property. Therefore, the developer need only declare the following code for each View Model to take advantage of this functionality:</p>
<pre>using CompanyName.ApplicationName.ViewModels; 
using CompanyName.ApplicationName.ViewModels.Interfaces; 
 
namespace CompanyName.ApplicationName.Views.ViewModelLocators 
{ 
  public class UserViewModelLocator : BaseViewModelLocator&lt;IUserViewModel&gt; 
  { 
    public UserViewModelLocator() 
    { 
      DesignTimeViewModel = new MockUserViewModel(); 
    } 
  } 
} </pre>
<p>It could be set up in the UI with very little difference to our original locator version:</p>
<pre>&lt;UserControl x:Class="CompanyName.ApplicationName.Views.UserView" 
  ... 
  &lt;UserControl.Resources&gt; 
    &lt;Locators:UserViewModelLocator x:Key="ViewModelLocator" /&gt; 
  &lt;/UserControl.Resources&gt; 
  &lt;UserControl.DataContext&gt; 
    &lt;Binding Path="ViewModel" Source="{StaticResource ViewModelLocator}" /&gt; 
  &lt;/UserControl.DataContext&gt; 
  ... 
&lt;/UserControl&gt; </pre>
<p>Note that although this should work automatically in newer versions of Visual Studio, you may need to provide a helping hand to the WPF Designer in older versions. The <kbd>mc:Ignorable</kbd> attribute specifies which XAML namespace prefixes encountered in a markup file may be ignored by an XAML processor and the <kbd>d</kbd> XAML namespace is used by the Designer, so we can specify a <kbd>DataContext</kbd> location to it directly at design time:</p>
<pre><br/><br/>mc:Ignorable="d" d:DataContext="{Binding ViewModel, <br/>  Source={StaticResource ViewModelLocator}}"</pre>
<p>While there is a clear benefit to this arrangement, as always, we have to weigh up whether the cost of any such abstractions will be worth the benefits. For some, the cost of extracting an interface, declaring a mock version of it to use at design time, and creating a View Model Locator for each View Model will definitely be worth the benefit of designing Views that visualize their data.</p>
<p>For others, it simply won't be worth it. Each time we add a level of abstraction, we have more work to achieve to arrive at the same end goal. We need to decide whether each abstraction is viable in our own situations and build our application frameworks accordingly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>We've now investigated the benefit of having an application framework and started constructing our own. We've discovered a variety of different ways to encapsulate our required functionality into our framework and know which situations to use each in. After exploring a number of manager classes, we have also begun to expose functionality from external sources, but without being tied to them.</p>
<p>We've managed to maintain and improve the Separation of Concerns that our application requires and should now be able to detach the various application components and run them independently of each other. We are also able to provide our View designers with mock data at design time, while maintaining loose coupling at runtime.</p>
<p>In the next chapter, we will thoroughly examine the essential topic of data binding, one of the very few requirements of the MVVM pattern. We'll comprehensively cover the wide variety of binding syntax, both long and short hand notation, discover why bindings fail to work at certain times, and get a better understanding of how to display our data exactly the way we want.</p>


            

            
        
    </body></html>