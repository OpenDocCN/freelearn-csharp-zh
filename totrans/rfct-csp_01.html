<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor015"/>1</h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Technical Debt, Code Smells, and Refactoring</h1>
<p>New software projects start out clean and optimistic, but quickly grow in complexity and difficulty to maintain until the code is difficult to understand, brittle to change, and impossible to test.</p>
<p>If you’ve worked with code for any length of time, chances are you’ve come across code like this. In fact, if you’ve been in development for even a little bit of time, it’s likely you’ve <em class="italic">written</em> code you now regret.</p>
<p>It could be that the code is hard to read or understand. Maybe the code is inefficient or prone to errors. Perhaps the code was built under a certain set of business assumptions that later changed. Maybe the code simply no longer conforms to the standards you and your team have agreed to. Whatever the reason, bad code feels like it is practically everywhere in codebases of any significant size or age.</p>
<p>This code litters our software projects and reduces our development speed, causes us to introduce bugs, and generally makes us less happy and productive as software engineers.</p>
<p>In this book, we’ll talk about how technical debt arises and what we can do about it through the process of refactoring, guided by tests and code analysis.</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Understanding technical debt and legacy code</li>
<li>Identifying code smells</li>
<li>Introducing refactoring</li>
</ul>
<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Understanding technical debt and legacy code</h1>
<p>While computer science education, books, tutorials, and online courses all focus on creating new projects from scratch, the reality is that almost all development jobs you’ll have will center around understanding, maintaining, and expanding pre-existing code that may not meet your current standards.</p>
<p>This pre-existing code is referred to as <strong class="bold">legacy code</strong>. You almost always inherit some amount of legacy code when joining a new <a id="_idIndexMarker000"/>project. This can be a large amount of code for pre-existing projects or a smaller set of libraries your code must work with.</p>
<p>There are many different definitions of the term <em class="italic">legacy code</em>. One that stands out to me from my readings is Michael C. Feather’s definition, in <em class="italic">Working Effectively with Legacy Code</em>, that legacy code is <em class="italic">code </em><em class="italic">without tests</em>.</p>
<p>While I like Michael’s definition and believe testing is critically important, as we’ll see in <em class="italic">Part 2</em> of this book, I personally define legacy code as follows:</p>
<p><em class="italic">Legacy code refers to any pre-existing code that would be implemented significantly differently were it </em><em class="italic">rewritten today.</em></p>
<p>One key factor in legacy code is that it is <em class="italic">code you don’t currently fully understand</em> and as a result, its presence causes some degree of anxiety and apprehension.</p>
<p>This anxiety you feel when<a id="_idIndexMarker001"/> maintaining old systems is a prime symptom of something called <strong class="bold">technical debt</strong>.</p>
<p>Simply put, technical debt is <em class="italic">the negative effect of legacy code on future </em><em class="italic">development efforts</em>.</p>
<p>In other words, legacy code has a certain amount of inherent <em class="italic">risk</em> that bad things will happen when the code is modified. These bad things could be bugs that are introduced due to the brittleness of the pre-existing code (or our lack of understanding of it), slower development speed, or even catastrophic issues such as critical bugs or security breaches from out-of-date security practices or deprecated dependencies.</p>
<p>What’s worse is that technical debt will only grow over time – particularly if left unchecked.</p>
<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Where technical debt comes from</h2>
<p>Before we<a id="_idIndexMarker002"/> move on, I want to address a common point of confusion I see in organizations: technical debt is not the same thing as bad code.</p>
<p>Certainly, some of the technical debt we have in our systems may be simply poor-quality code. It could be that an inexperienced developer wrote it and didn’t properly benefit from code review by other developers. Sometimes, projects are in a rush and the team didn’t have time to write the code properly to begin with, and never got to go back and clean it up.</p>
<p>Sometimes, “quick and dirty” code written for prototypes makes it into production applications when “throwaway prototypes” get hastily promoted to actual production applications, as we’ll explore in <a href="B21324_15.xhtml#_idTextAnchor316"><em class="italic">Chapter 15</em></a><em class="italic">: Communicating </em><em class="italic">Technical Debt</em>.</p>
<p>Of course, there are other causes of technical debt as well.</p>
<p>Sometimes, the development team is under the impression that they are building software to accomplish a specific task and then that task changes as business needs evolve and new information is discovered. In these cases, teams often don’t start over with the code they were writing. They simply evolve the old code to suit the new task at hand. The result is code that works but isn’t ideally suited for the new task.</p>
<p>This change in <a id="_idIndexMarker003"/>requirements is normal and even expected in software development environments. Modern software development occurs in an agile manner where requirements and plans naturally evolve over time and understanding them up-front is virtually impossible.</p>
<p>Even if development teams understood requirements perfectly and wrote perfect code, this code will eventually become a form of technical debt due to the changing nature of software engineering.</p>
<p>In software development, tools and libraries change over time. At the time of writing, <strong class="bold">.NET 8</strong> and <strong class="bold">C# 12</strong> are the<a id="_idIndexMarker004"/> latest ways to run C# code, but these technologies will go out of support<a id="_idIndexMarker005"/> at some point in the future only to be replaced by newer versions.</p>
<p>Even entire ways of thinking about software can change. Over the last twenty years, organizations have <a id="_idIndexMarker006"/>shifted<a id="_idIndexMarker007"/> from having their own on-premises servers to using cloud hosting on <strong class="bold">Azure</strong>, <strong class="bold">AWS</strong>, or <strong class="bold">Google Cloud</strong>. Even the very nature of what a server is has changed with<a id="_idIndexMarker008"/> technologies, including containerization<a id="_idIndexMarker009"/> technologies such<a id="_idIndexMarker010"/> as <strong class="bold">Docker</strong>, <strong class="bold">platform as a service</strong> (<strong class="bold">PaaS</strong>) offerings such <a id="_idIndexMarker011"/>as <strong class="bold">Azure App Services</strong>, and serverless <a id="_idIndexMarker012"/>computing offerings <a id="_idIndexMarker013"/>such as <strong class="bold">Azure Functions</strong> and <strong class="bold">AWS Lambda</strong>.</p>
<p>Nowadays, newer AI technologies<a id="_idIndexMarker014"/> such as <strong class="bold">ChatGPT</strong> and <strong class="bold">GitHub Copilot Chat</strong> are <a id="_idIndexMarker015"/>poised to change what it even means to be a software developer, and this only underscores how much constant change is at the heart of the software engineering industry.</p>
<p class="callout-heading">Change in software projects</p>
<p class="callout">In software development, change is a constant and can be unpredictable and sudden. All this change leads to code that was once considered perfect to later be considered a significant risk to the ongoing success of the business.</p>
<p>In other words, technical debt is<a id="_idIndexMarker016"/> to some degree or another an unavoidable part of software development. Thankfully, you can take some steps to reduce the rate at which it accumulates (as we’ll discuss in <em class="italic">Part 2</em> of this book). Fortunately, we can detect technical debt through its symptoms, or “smells.”</p>
<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Identifying code smells</h1>
<p>So, how do you know<a id="_idIndexMarker017"/> whether your code has issues?</p>
<p>How do you know whether food has spoiled, clothing needs to be washed, or a diaper needs changing? It turns out that it just smells bad.</p>
<p>There are some metrics about what constitutes “good” and “bad” code, and we’ll explore them in <a href="B21324_12.xhtml#_idTextAnchor259"><em class="italic">Chapter 12</em></a><em class="italic">: Code Analysis in Visual Studio</em> and <a href="B21324_16.xhtml#_idTextAnchor341"><em class="italic">Chapter 16</em></a><em class="italic">: Adopting Code Standards</em>. Smelly code can be subjective to some degree or another. A developer who wrote a section of code or frequently modifies that portion of code may find the code to be more tolerable than a developer encountering the code for the first time.</p>
<p>While not all pieces of technical debt are identical, it turns out that many pieces of legacy code share a set of common symptoms.</p>
<p>These symptoms are commonly referred to as “code smells” and can include the following:</p>
<ul>
<li>It’s difficult to understand what it does or <em class="italic">why</em> it does it</li>
<li>You or people on your team avoid working with it</li>
<li>It’s slower to modify than other areas or tends to break when modified</li>
<li>It’s hard to test or debug</li>
</ul>
<p>New code starts out good and pristine, but real code that lives in a business setting evolves over time as more capabilities are required and additional features and fixes are introduced. As that happens, code that was once nice and neat starts to accumulate code smells.</p>
<p>Not all code is <a id="_idIndexMarker018"/>created equal, and not all code lasts as long as other pieces of code. Certainly, there are things we can do to make our code more resilient (as we’ll see in <a href="B21324_08.xhtml#_idTextAnchor173"><em class="italic">Chapter 8</em></a><em class="italic">: Avoiding Code Anti-Patterns with SOLID</em>). However, at some point in time, your nice and shiny new code will start to get smelly and will need to be cleaned up through a process called refactoring.</p>
<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Introducing refactoring</h1>
<p><strong class="bold">Refactoring</strong> is <a id="_idIndexMarker019"/>one of those words that doesn’t make a lot of sense to newer programmers, but here’s a simple definition:</p>
<p><em class="italic">Refactoring is the act of changing the shape or form of code without changing its functionality </em><em class="italic">or behavior</em>.</p>
<p>There are two key concepts here:</p>
<ul>
<li>The first concept is that refactoring is an effort to improve the maintainability of existing code. Sometimes, restructuring means introducing a new variable, method, or class. Other times, refactoring simply changes how individual lines of code are arranged or which language features are used. Even something as simple as renaming a variable could be considered a small act of refactoring.</li>
<li>The second concept in this definition is that refactoring does not alter the <em class="italic">behavior</em> of the code in question. Refactoring is a structural change done to bring some piece of technical merit without altering the existing behavior of your code. If a method typically returned a certain value before you refactored it and now it returns a different value, that is a <em class="italic">change</em> and not a refactoring.</li>
</ul>
<p>Refactoring also should provide some benefit to the engineering team. The code resulting from refactoring should be easier to understand, less likely to break when changed, and have less technical debt and fewer code smells than the starting code did.</p>
<p>Every line of code the development team produces should have a business value. Refactoring is no different, except the business value it produces should be more maintainable code with fewer issues and delays arising from its presence.</p>
<p>Sometimes, we try to improve our code through refactoring and we accidentally introduce new behavior – typically in the form of new bugs. This makes our refactoring become an unintentional change in the software that can result in emergency fixes to restore code to a working state.</p>
<p>Breaking code while refactoring can be a critical problem and a significant barrier to being allowed to perform refactored code in the future, which in turn can allow technical debt to thrive.</p>
<p>In <em class="italic">Part 2</em> of this book, we’ll explore ways of safely <a id="_idIndexMarker020"/>refactoring your code so that you don’t accidentally introduce bugs, while in <em class="italic">Part 4</em>, we’ll discuss getting organizational buy-in to refactor your code, and what to do when a defect does arise out of your refactoring efforts.</p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Refactoring tools in Visual Studio</h2>
<p>Thankfully, all editions of <strong class="bold">Visual Studio</strong> now<a id="_idIndexMarker021"/> include refactoring tools built into the editor that allow you to quickly perform a set of common refactorings in a reliable and repeatable manner.</p>
<p>In <a href="B21324_02.xhtml#_idTextAnchor026"><em class="italic">Chapter 2</em></a><em class="italic">: Introduction to Refactoring</em> and the remaining chapters in <em class="italic">Part 1</em>, we’ll see a number of refactorings in<a id="_idIndexMarker022"/> action. Here’s a preview of some of the refactoring <a id="_idIndexMarker023"/>options Visual Studio provides the user:</p>
<div><div><img alt="Figure 1.1 – Visual Studio Quick Actions context menu showing a set of refactoring operations" src="img/B21324_01_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Visual Studio Quick Actions context menu showing a set of refactoring operations</p>
<p>Tool-assisted refactorings such as<a id="_idIndexMarker024"/> these are fantastic for a few <a id="_idIndexMarker025"/>reasons:</p>
<ul>
<li>They are fast and efficient</li>
<li>They are reliable and repeatable</li>
<li>They <em class="italic">rarely</em> introduce defects</li>
</ul>
<p class="callout-heading">Caution</p>
<p class="callout">Note that I use the word <em class="italic">rarely</em> when talking about bugs introduced by refactoring tools. There are a few rare scenarios where using the built-in refactoring tools without thinking about their actions may introduce bugs into your application. We’ll talk specifically about those areas as we encounter them in the following chapters.</p>
<p>Over the rest of <em class="italic">Part 1</em>, we’ll explore using these tools to quickly and effectively refactor your C# applications and talk about the types of scenarios in which you might use each one of these.</p>
<p>With all that our tools can do, it is important to remember that these tools are just one way of refactoring code. Often, the most effective ways of removing code smells involve a combination of writing code yourself and using the built-in refactoring tools.</p>
<p>Refactoring’s key <a id="_idIndexMarker026"/>value is the long-term health of an organization, but <a id="_idIndexMarker027"/>many obstacles to refactoring can come from the organization itself. To help illustrate the practical aspects of refactoring in a real organization, each chapter will involve a case study from a fictitious organization. Some chapters will focus entirely on code from the case study while others, such as this chapter, will conclude with a dedicated case study section. These case study sections illustrate the concepts of the chapter applied to a fictitious organization.</p>
<p>Let’s meet our first case study section and see how technical debt and legacy code affect a typical company.</p>
<h1 id="_idParaDest-23"><a id="_idTextAnchor022"/>Case study – Cloudy Skies Airlines</h1>
<p>The rest<a id="_idIndexMarker028"/> of this book will follow code examples from an airline called <strong class="bold">Cloudy Skies Airlines</strong>, or <strong class="bold">Cloudy Skies</strong> for short. Through these examples, we should be able to see how technical debt and refactoring can apply to a “real” organization and its software.</p>
<p class="callout-heading">Note</p>
<p class="callout">Cloudy Skies is a fictitious airline company created for this book for teaching purposes only. Any resemblance to any real company is purely coincidental. Additionally, I have never worked in aviation, so the code examples presented in the book are likely significantly different from actual software systems used in the industry.</p>
<p>Cloudy Skies is an airline that’s been around for the past 50 years and currently operates a little over 500 jets in its fleet, serving around 70 cities in its region.</p>
<p>Twenty years ago, the airline made a major move and started replacing its aging software systems with custom in-house applications built by its development team. Cloudy Skies chose to use .NET and C#. The initial systems performed well and resulted in increased developer productivity and high-performance software applications, so Cloudy Skies continued to migrate its applications to .NET.</p>
<p>As time went by, the airline and its systems grew. The engineering team at Cloudy Skies was once held in high esteem as the pride and joy of the organization and a key to its future.</p>
<p>However, management has been somewhat frustrated by its engineering team over the past few years. Some of its key complaints include the following:</p>
<ul>
<li>Product managers are frustrated by large estimates for seemingly simple changes to existing systems, and a growing amount of time between software releases due to long implementation times and numerous bugs.</li>
<li>The Quality Assurance department has been overwhelmed by a growing number of bugs present in the software, a tendency for the same things to break repeatedly, and bugs appearing in seemingly unrelated areas when changes occur in other parts of the application.</li>
</ul>
<p>For its part, the engineering team feels overwhelmed by the code it’s working with. Strategic initiatives have been pushed aside for years while the organization has the team focus on urgent changes or tight deadlines for new releases. As a result, nobody has had time to address the growing amount of technical debt the team is facing.</p>
<p>The Cloudy Skies codebase is constantly growing in complexity to account for each new feature or “special case” added to the system. This complexity in turn makes the application harder to test, understand, and modify, which has led to difficulties in onboarding new developers and some experienced developers leaving the organization.</p>
<p>Out of frustration after several severe delays and high-profile bugs, Cloudy Skies brings in a new engineering manager and empowers the team to make changes to ensure the airline can stay efficient and effective in the years to come.</p>
<p>This engineering manager determines that the primary cause of these problems is technical debt and that targeted refactoring of the most critical areas throughout the suite of applications could significantly reduce risk and improve the team’s effectiveness going forward.</p>
<p>To its <a id="_idIndexMarker029"/>credit, management agrees and allows the team to allocate resources to pay down technical debt and improve the maintainability of the code through refactoring.</p>
<p>Throughout the rest of this book, we’ll follow aspects of this fictitious team’s journey in paying down technical debt and paving the way to a better future through refactoring.</p>
<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>Summary</h1>
<p>Legacy code is an unavoidable byproduct of the forces of time and constant change that are present in software development projects. This legacy code becomes a breeding ground for technical debt, which threatens our productivity as developers and the quality of our software.</p>
<p>While technical debt can arise due to a number of reasons, refactoring is the cure. Refactoring reworks existing code into a more maintainable and less risky form, reducing our technical debt and helping us control our legacy code.</p>
<p>The more you understand the causes and effects of technical debt in your code, the better you’ll find yourself equipped to explain technical debt to others in your organization, advocate for refactoring, and avoid things that cause your code to decline in effectiveness over time.</p>
<p>In the next chapter, we’ll explore refactoring in more depth by walking through a set of targeted changes to improve a piece of sample code from the Cloudy Skies Airlines codebase.</p>
<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>Questions</h1>
<ol>
<li>What is the difference between technical debt and legacy code?</li>
<li>What are some causes of technical debt?</li>
<li>What are some of the effects of technical debt?</li>
<li>Is it possible to avoid technical debt?</li>
<li>Is it possible to get to a point where your code cannot be refactored further?</li>
</ol>
<h1 id="_idParaDest-26"><a id="_idTextAnchor025"/>Further reading</h1>
<p>You can find more information about technical debt, legacy code, and refactoring at the following URLs:</p>
<ul>
<li><em class="italic">Defining Technical </em><em class="italic">Debt</em>: <a href="https://killalldefects.com/2019/12/23/defining-technical-debt/">https://killalldefects.com/2019/12/23/defining-technical-debt/</a></li>
<li><em class="italic">Identify Technical </em><em class="italic">Debt</em>: <a href="https://learn.microsoft.com/en-us/training/modules/identify-technical-debt/">https://learn.microsoft.com/en-us/training/modules/identify-technical-debt/</a><a href="https://learn.microsoft.com/en-us/training/modules/identify-technical-debt/ "/></li>
<li><em class="italic">The True Cost of Technical </em><em class="italic">Debt</em>: <a href="https://killalldefects.com/2019/11/09/the-true-cost-of-technical-debt/">https://killalldefects.com/2019/11/09/the-true-cost-of-technical-debt/</a><a href="https://killalldefects.com/2019/11/09/the-true-cost-of-technical-debt/ "/></li>
<li><em class="italic">Code </em><em class="italic">refactoring</em>: <a href="https://en.wikipedia.org/wiki/Code_refactoring">https://en.wikipedia.org/wiki/Code_refactoring</a></li>
</ul>
</div>
</body></html>