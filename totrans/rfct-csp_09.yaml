- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Unit Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we’ve seen, testing is incredible and can give you the freedom to effectively
    refactor your code in relative safety. Sometimes, code is written in a way that
    makes testing difficult and you need a few more tools. In this chapter, we’ll
    explore a handful of popular .NET libraries that can improve the readability of
    your tests and give you more options for testing code – including those tricky
    classes with complex data or dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating readable tests with Shouldly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating test data with Bogus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking dependencies with Moq and NSubstitute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pinning tests with Snapper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experimenting with Scientist .NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter is available from GitHub at https://github.com/PacktPublishing/Refactoring-with-CSharp
    in the `Chapter09` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Libraries change with new releases and some of these changes may cause issues
    with code in this chapter. Because of this, here are the exact names and versions
    of the libraries that are used in this chapter at the time of writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bogus 34.0.2**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FluentAssertions 6.11.0**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Moq 4.20.2**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NSubstitute 5.0.0**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scientist 2.0.0**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shouldly 4.2.1**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Snapper 2.4.0**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating readable tests with Shouldly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 6*](B21324_06.xhtml#_idTextAnchor133), we saw how the `Assert`
    class is used to verify the behavior of existing classes through code such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code verifies that `passengerCount` is equal to `35` and fails the test
    if it is a different number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, this code has two problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Assert methods take in the expected value first and the actual value second.
    This is different than how most people think about things and can lead to confusing
    test failure messages, as we saw in [*Chapter 6*](B21324_06.xhtml#_idTextAnchor133).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code doesn’t read incredibly well in English, which can slow you down as
    you are reading tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several open-source libraries address this issue by providing an alternative
    syntax for writing assertions in unit tests through sets of extension methods
    they introduce.
  prefs: []
  type: TYPE_NORMAL
- en: The most popular of these libraries are FluentAssertions and Shouldly. While
    FluentAssertions is by far the more popular library, I find Shouldly to read more
    naturally, so we’ll start with that.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at installing Shouldly and getting started with its syntax before
    looking at a similar example with FluentAssertions.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Shouldly NuGet package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shouldly is not a library that is included by default in any project template
    built into Visual Studio. Because of this, we need to add it to our project.
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio, we use a **package manager** called **NuGet Package Manager**
    to install external dependencies from package sources such as the one at [nuget.org](http://nuget.org).
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve programmed in JavaScript, this concept is very similar to JavaScript
    package managers such as Yarn or NPM. While other package managers download the
    code and have you compile it, NuGet downloads *compiled* versions of external
    code and allows your code to reference things defined in those projects without
    slowing your build process.
  prefs: []
  type: TYPE_NORMAL
- en: To install a package, right-click on the `Chapter9Tests` project in **Solution
    Explorer** and choose **Manage** **NuGet Packages**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, click on the `Shouldly` in the search bar. Your search results should
    look something like those in *Figure 9**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – NuGet Package Manager showing results for Shouldly](img/B21324_09_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – NuGet Package Manager showing results for Shouldly
  prefs: []
  type: TYPE_NORMAL
- en: You should see an entry named Shouldly by Jake Ginnivan et al. in the list on
    the left. Select it by clicking on it. The details on the right will then list
    information about this package, including its license terms and dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Always check the author and the exact name of the package you are looking for
    as many have similar names.
  prefs: []
  type: TYPE_NORMAL
- en: Using the **Version** dropdown in the details area on the right, you can choose
    the specific version of the library to install. Usually, it’s fine to leave this
    as the latest stable version, but occasionally, you may need to select a prior
    version for compatibility purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click **Install**, Shouldly and anything it depends on will automatically
    be downloaded and installed into your project. When installing packages, a window
    may open showing you various license terms or dependencies, such as those shown
    in *Figure 9**.2*. Read these carefully, especially if you are using a library
    in your workplace:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Dependencies needed to install Shouldly](img/B21324_09_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Dependencies needed to install Shouldly
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have Shouldly installed, let’s learn how to work with it.
  prefs: []
  type: TYPE_NORMAL
- en: Writing readable assertions with Shouldly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `PassengerTests.cs`, there’s an existing `PassengerFullNameShouldBeAccurate`
    test that instantiates a `Passenger` object, grabs the value out of the object’s
    `FullName` field, and makes sure the resulting name matches the expected value,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using Shouldly, we can make this assertion a lot more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s add a `Usings.cs` file by adding a `using` for Shouldly at the
    end of that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This `global using` directive allows you to work with things in the Shouldly
    namespace anywhere in the `Chapter9Tests` project. Put another way, it is the
    equivalent of if every file in the project had a `using Shouldly;` statement at
    the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have Shouldly installed and its namespace imported, we can rewrite
    the assertion from earlier by using one of the many extension methods provided
    by Shouldly, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, Shouldly adds a `ShouldBe` extension method to the `string`, allowing
    us to call this method in a very readable way. This code is functionally equivalent
    to `Assert.Equal`, but it is significantly more readable. Additionally, you are
    far less likely to confuse which parameter is the expected value versus the actual
    value under this way of working with things.
  prefs: []
  type: TYPE_NORMAL
- en: Shouldly has a wide variety of extension methods, including `ShouldBe`, `ShouldNotBe`,
    `ShouldBeGreaterThan`/`ShouldBeLessThan`, `ShouldContain`, `ShouldNotBeNull`/`ShouldBeNull`,
    `ShouldStartWith`/`ShouldEndWith`, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, let’s look at a more complex test written without Shouldly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code uses `FlightScheduler` to schedule a flight using the Bogus library,
    which we’ll discuss later in this chapter. Once a flight has been scheduled, the
    code gets all the flights and asserts that the resulting collection is not null,
    has only one item, and the flight we scheduled is in that collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code isn’t too bad, but I still prefer the Shouldly version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In general, I find the Shouldly library to have more consistent parameter ordering
    and result in more readable tests. Because of this, I find myself more productive
    and use Shouldly wherever I can.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, I’d encourage you to take the starting code for this chapter
    and convert the various tests so that they use Shouldly instead of standard assertions.
    Feel free to experiment with other assertions as you go. This chapter’s final
    code uses Shouldly if you want to check your answers.
  prefs: []
  type: TYPE_NORMAL
- en: Before we see what else Shouldly can do, let’s look at FluentAssertions, a popular
    library fulfilling a similar role as Shouldly.
  prefs: []
  type: TYPE_NORMAL
- en: Writing readable assertions with FluentAssertions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FluentAssertions does the same thing that Shouldly does, but the approach of
    its syntax is less oriented on calling single methods like Shouldly’s `ShouldContain`.
    Instead, FluentAssertions prefers chaining together several method calls to produce
    a similar result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a test of the baggage pricing system as an illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This code creates `BaggageCalculator` and then sends a series of factors to
    that calculator’s `CalculatePrice` method before performing its assertions via
    the `Should().Be(60m)` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Before we explore this in more depth, I should point out that, like Shouldly,
    FluentAssertions does not come pre-installed. You’ll need to install FluentAssertions
    with NuGet Package Manager, the same way you did earlier for Shouldly. You’ll
    also need to add a `using FluentAssertions;` statement to your code file to see
    the FluentAssertions extension methods.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve established how to get started with FluentAssertions, let’s take
    a closer look at that `result.Should().Be(60m)` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Most actions in FluentAssertions flow out of the `Should` methods. Notice that
    there are multiple `Should` methods in FluentAssertions, with each one related
    to a specific type of data you might work with.
  prefs: []
  type: TYPE_NORMAL
- en: These `Should` methods return a strongly-typed object such as `NumericAssertions<decimal>`
    in the case of the calculator assertions. These assertion objects contain various
    constraint methods, allowing you to do targeted assertions such as `Be`, `NotBe`,
    `BeLessThan`, `BePositive`, `BeOneOf`, and others.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few advantages to the FluentAssertions approach:'
  prefs: []
  type: TYPE_NORMAL
- en: It’s easier to find assertion methods since they all go through `Should()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constraint methods allow you to combine assertions such as `result.Should().BePositive().And.BeInRange(50,
    70)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately, FluentAssertions has a slightly higher learning curve and is
    a little more verbose than Shouldly, which might result in slightly less readable
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, it’s up to you and your team as to what style you prefer, but both
    Shouldly and FluentAssertions can significantly improve the readability of your
    tests and your enjoyment of the test writing experience.
  prefs: []
  type: TYPE_NORMAL
- en: Before we introduce our next new library, let’s talk about one more thing Shouldly
    can do that might be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Testing performance with Shouldly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the reasons people find themselves refactoring code is to look for ways
    of improving the performance of code that is known to be slow.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you are following **Test-Driven Development** (**TDD**) and are investigating
    code that takes an unacceptably long time to iterate through a list of items.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in TDD is to write a failing test, so you now need to write a
    test that fails if the performance of a method is too slow.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll talk about reasons why you might not want to write a test around performance
    in a bit, but let’s explore how you would go about testing performance first.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to fail tests involving code that performs too slowly, you’d need
    to be able to measure how long that code took to run. To do that, you could create
    a `Stopwatch` object, start it, stop it, and then verify the duration of that
    watch, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will fail if it takes more than 100 milliseconds (0.1 seconds) to
    run `ScheduleFlight`, but this approach has a couple of disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: There’s a lot of setup code required for this approach. In this case, over half
    of the test method is devoted to `Stopwatch`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test waits for the method to complete before the test is failed. If it takes
    10 seconds to complete the method, the test waits the full time. This is inefficient
    because once the 100-millisecond threshold is crossed, the test will never pass.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Shouldly gives us a more compact `Should.CompleteIn` method that solves both
    problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This code creates an action to schedule the flight that Shouldly will invoke
    as part of the test. This action isn’t invoked until it is passed into the `Should.CompleteIn`
    method, which also requires a maximum amount of time to allow the method to run.
  prefs: []
  type: TYPE_NORMAL
- en: When Shouldly runs your action, it tracks the elapsed time internally and will
    cancel your action and fail the test once that threshold is reached. This results
    in more compact test code that won’t take longer than the maximum allowable amount
    of time.
  prefs: []
  type: TYPE_NORMAL
- en: So, now that we know how to write simple performance tests using Shouldly or
    plain old .NET with `Stopwatch`, let’s talk about why you might not want to do
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Good tests should be fast and result in a repeatable result. Tests will be run
    by a variety of machines in a variety of different circumstances, such as when
    the processor has relatively little work to do or when the processor is completely
    overloaded. Tests may also be run in isolation or parallel, alongside, other tests.
    Additionally, with .NET, it is normal to see variations in performance from run
    to run.
  prefs: []
  type: TYPE_NORMAL
- en: All these things mean that performance testing is going to be more chaotic than
    you like and the maximum allowable duration is something you should consider carefully.
    If your tests are run in a **continuous integration/continuous delivery** (**CI/CD**)
    pipeline (which they should be, as we’ll talk about in *Part 4* of this book),
    it’s likely that the build machine’s CPU and memory characteristics look nothing
    like a developer workstation. To combat this, you may need to pick a significantly
    higher number than you normally would to avoid random failures due to a slow test
    environment. On the other hand, if you make your timeout too long, you won’t detect
    legitimate performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: My general stance is that performance testing is something that should rarely
    ever be codified into unit tests due to the chaotic nature of performance metrics
    and the wide variety of machines that might run tests. Instead, I tend to prefer
    periodic profiling using a dedicated tool such as **Visual Studio Enterprise**
    or **JetBrains dotTrace** for those areas that are truly critical to performance.
  prefs: []
  type: TYPE_NORMAL
- en: That said, there is value in performance tests, but you may spend more time
    than you’d expect finding a good maximum test duration number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move on to another library that makes your life easier when testing:
    **Bogus**.'
  prefs: []
  type: TYPE_NORMAL
- en: Generating test data with Bogus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B21324_06.xhtml#_idTextAnchor133), I mentioned that tests are
    a form of documentation that explains how your system should work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping that in mind, look at the following test, which tests the interaction
    of the `Passenger` and `BoardingProcessor` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A lot of setup is needed in the *Arrange* phase before `BuildMessage` can be
    called. But what aspects of that setup are important? Which parts of the `Passenger`
    object contribute to that person being allowed to board versus being told to wait?
  prefs: []
  type: TYPE_NORMAL
- en: While it’s important to create test objects that look accurate, mixing irrelevant
    properties with vital properties can lead to difficulties interpreting what’s
    important about test data or why a test should pass instead of fail.
  prefs: []
  type: TYPE_NORMAL
- en: Bogus is a library that generates realistic random data of different types.
    Bogus helps solve this problem by giving you a good way of generating random data
    for those less critical parts of your objects.
  prefs: []
  type: TYPE_NORMAL
- en: This has the simultaneous benefit of focusing your attention on the more critical
    portions of your tests while also generating random data to test your assertion
    that the values in the other properties truly don’t matter.
  prefs: []
  type: TYPE_NORMAL
- en: Like the other libraries in this chapter, Bogus must be installed via NuGet
    and then referenced in a `using` `Bogus;` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the *Arrange* section of the earlier test using Bogus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you’ve likely noticed, this code is significantly different than the earlier
    code. It uses a `Faker<Passenger>` object from Bogus that will generate a different
    random `Passenger` object every time the `Generate()` method is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'These `Passenger` objects will use Bogus’ library of random data to generate
    reasonable test data, as shown in *Figure 9**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – A randomized passenger with somewhat realistic values](img/B21324_09_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – A randomized passenger with somewhat realistic values
  prefs: []
  type: TYPE_NORMAL
- en: The way this works is that you can set rules that `Faker` will follow when it
    sees a given property using the `RuleFor` method.
  prefs: []
  type: TYPE_NORMAL
- en: Using `RuleFor`, you can specify the property you want to program a response
    to in the first argument and then specify a function to get a value in the second
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, the `RuleFor(p => p.Email, f => f.Person.Email)` line has two
    function parameters. The first one uses `p` to represent the `Passenger` object
    and focuses on that object’s `Email` property. The second parameter takes in a
    `Faker` instance as `f` and the function may choose to use it to generate a value
    that `Faker` will use when generating a person.
  prefs: []
  type: TYPE_NORMAL
- en: '`Faker` contains many different types of data, from fake company names to ZIP
    codes to product names, IP addresses, and even absurd things such as hacker speak
    and “rants” such as reviews.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you look closely at the data `Faker` generates, it doesn’t always make
    sense. For example, *Figure 9**.3* listed the person as living in Larsonland,
    Minnesota with a postal code of 78950 and a country of “Cocos (Keeling) Islands.”
    Individually, these things are fine, but these different properties conflict wildly
    with one another.
  prefs: []
  type: TYPE_NORMAL
- en: If you need your data to make sense, you’ll need to write more nuanced rules
    for how these properties interact. Despite these limitations, Bogus gives you
    a great way of adding randomness to your code for the inconsequential data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, when using Bogus, you’ll create your `Faker` instance in a separate
    method or the test constructor, which simplifies your code significantly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how this approach minimizes Bogus’ role in things and focuses your attention
    on how the randomly generated person is further configured. This helps you see
    that the important factors for someone not boarding the plane yet are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: They are in a higher boarding group than the current group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are not military
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They do not need help boarding the plane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bogus isn’t just for tests. For example, I’ve used Bogus successfully for prototyping
    user interfaces and generating data for small game projects. However, Bogus is
    a valuable addition to your testing toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to look at ways of isolating dependencies with a pair of mocking
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking dependencies with Moq and NSubstitute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve looked at a few libraries that improve the readability of your
    tests. In this section, we’ll look at **mocking frameworks** and see how libraries
    can help you more effectively test your code.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the need for mocking libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s discuss why mocking frameworks are necessary by revisiting the `FlightBookingManager`
    example we introduced in the previous chapter while discussing dependency injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, this class requires `IEmailClient` when `FlightBookingManager` is created.
    The client is then stored in the `_email` field and this is later used to send
    a message when a flight is booked. Passing in `IEmailClient` as a parameter to
    the constructor is an example of dependency injection and allows our class to
    work with anything that implements the `IEmailClient` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, it also means that to test the class, we must provide an implementation
    of `IEmailClient`, even if we’re not explicitly testing something email-related.
  prefs: []
  type: TYPE_NORMAL
- en: Since we generally don’t want to send emails when unit testing our code, that
    means we’d need a separate implementation of `IEmailClient`. We could make one
    by declaring a class and implementing the `IEmailClient` interface with a minimal
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say that `IEmailClient` was defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You could create a `TestEmailClient` that meets this requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, the implementation of the test client is very simple and does the minimum
    possible needed to compile the code, which in this case is returning true, indicating
    a message was successfully sent. This type of class is sometimes called a **test
    double**, a **test stub**, or simply a **mock object**. These names are due to
    these classes looking like real implementations for testing purposes without having
    all their functionality. In this chapter, I will refer to these as mock objects
    since that will help mocking frameworks make more sense later.
  prefs: []
  type: TYPE_NORMAL
- en: 'This lets us write a test using the `TestEmailClient` mock object we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can safely test a flight without sending an email by providing `TestEmailClient`
    instead of a real email client.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, mock objects have their drawbacks. Let’s say we wanted to write
    another test that verifies that trying to book a seat that’s already occupied
    doesn’t send an email. In that case, we’d need to create another mock object with
    a different implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we’d want to fail the test if the `SendMessage` method was called,
    so that method should throw an exception or use the `Assert.Fail` method to cause
    the test to fail, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let’s consider a more nuanced example. Let’s say you want to verify that the
    `BookFlight` method calls the `SendMessage` method on its `IEmailClient` one time
    and one time only.
  prefs: []
  type: TYPE_NORMAL
- en: We could test this by building a specialized mock object that had a counter
    of all the times it was called, but that’s yet more complexity in our test code
    that we don’t necessarily need. If the definition of what’s in `IEmailClient`
    ever changes, all our mock objects that implement that interface will also need
    to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Because so many tests need mock objects and each test tests something slightly
    different, writing and maintaining mock objects manually can be a lot of work.
    This is the core problem that mocking libraries exist to solve.
  prefs: []
  type: TYPE_NORMAL
- en: While there are several popular mocking libraries in .NET, the most popular
    for many years has been Moq. We’ll explore Moq next before looking at an alternative.
  prefs: []
  type: TYPE_NORMAL
- en: Creating mock objects with Moq
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Moq, pronounced either “Mock” or “Mock-you” in the words of its creator, *is
    a mocking library built around using LINQ to create, configure, and verify the
    behavior of* *mock objects*.
  prefs: []
  type: TYPE_NORMAL
- en: Just like the other libraries in this chapter, you’ll need to install Moq from
    NuGet Package Manager and import it into your file via a `using` `Moq;` statement.
  prefs: []
  type: TYPE_NORMAL
- en: With Moq, you don’t create mock objects on your own; instead, you tell Moq the
    interface you want to implement or the class you want to inherit and Moq automatically
    creates an object that meets these requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s revisit our flight booking test from earlier in this chapter using Moq:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we instantiate a `Mock` instance named `clientMock` that will create a
    new mock object in the form of `IEmailClient`. We then call the `Object` property
    on `clientMock` and the Moq library automatically generates an object that implements
    `IEmailClient` in the simplest way possible.
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t care how the email client works in this example, this is all
    we need to do to generate a simple mock object that we can pass to `FlightBookingManager`.
    Not only is this less code, but we can stay in the test method while defining
    our mock object, and if the definition for `IEmailClient` ever changes, we don’t
    need to update the mock object since Moq takes care of that for us.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there’s a lot more that Moq can do, so let’s see how you can use
    it to configure how your mock objects behave.
  prefs: []
  type: TYPE_NORMAL
- en: Programming Moq return values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, methods on Moq’s mock objects will return the default value for
    that type. For example, a method returning a `bool` object would return `false`,
    and a method returning an `int` object would return `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you need Moq to return something different. In these cases, you
    can set up your mock object by calling Moq’s `Setup` method. For example, if you
    needed the `SendMessage` method to return `true` instead of `false` for any value
    that was passed in, you could write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `Setup` method requires you to tell it what method or property you
    are configuring. Since we’re configuring the `SendMessage` method, we specify
    it in the arrow function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, Moq needs to know when it should apply this rule. You can program your
    mock objects to reply differently based on different parameters, so you could
    have a `Setup` call for different parameter values to the same method.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we want the method to always return `true`, regardless of what
    is passed in, so we specify that with Moq’s `It.IsAny` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Before we finish our discussion of Moq, we’ll look at a final example and teach
    you how to verify how many times a given method was called on your mock objects.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying Moq calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you want to test the behavior of a method and verify that calling
    one method causes it to call something on another object. Moq lets you do this
    by verifying that a method has been called a specific number of times.
  prefs: []
  type: TYPE_NORMAL
- en: This can include verifying that a method wasn’t called, which can be helpful
    for cases like the example we discussed earlier involving making sure emails aren’t
    sent out in cases where a seat couldn’t be reserved.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, we can call Moq’s `Verify` methods, as shown in the following
    case, which verifies that an email was sent once and only once when booking a
    flight:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we call `Verify` on our `Mock` instance to verify that the `SendMessage`
    method was called exactly one time with the passenger’s email address and any
    email body. If the method wasn’t called or was called multiple times, this will
    fail our test.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, this one `Verify` line protects us from cases where the system
    didn’t email the user when it should have, as well as cases where it might have
    sent too many emails.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the code calls `VerifyNoOtherCalls`. This method will cause the test to
    fail if some other method on our `IEmailClient` was called that was not verified
    by a previous `Verify` statement. This can be handy for ensuring that the code
    is not doing unexpected things with the objects you provide it.
  prefs: []
  type: TYPE_NORMAL
- en: A note on verifying behavior
  prefs: []
  type: TYPE_NORMAL
- en: The developer community has historically been divided on whether it is good
    practice to verify that calling code calls some other piece of code in your unit
    tests. The argument against verifying the behavior of your tests is that it shouldn’t
    matter how a method implements something if it produces the right results. The
    counter-argument is that sometimes, the desired result of your method is the callout
    to the external code, such as our code here, which calls the `SendMessage` call.
    You and your team will need to decide when it is appropriate to use `Verify` in
    your tests.
  prefs: []
  type: TYPE_NORMAL
- en: Moq can seem complex to work with initially, but you don’t need to use all its
    features to benefit from it. As we saw earlier, just using Moq to generate simple
    mock objects can save you significant work in maintaining a growing number of
    manually created mock objects over time.
  prefs: []
  type: TYPE_NORMAL
- en: You won’t always need to use Moq’s `Setup` or `Verify` methods, but they’re
    very helpful when you want them.
  prefs: []
  type: TYPE_NORMAL
- en: For years, Moq has been the dominant mocking library in .NET, but recently,
    NSubstitute has been gaining popularity. This results in a higher likelihood that
    you may encounter it in the workplace as a substitute for Moq. Let’s explore NSubstitute
    briefly and see how it accomplishes similar things to Moq using a different syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking with NSubstitute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NSubstitute is a similar mocking library to Moq, but its approach is to avoid
    arrow functions where possible and prefer code that looks more like standard method
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: Like other libraries in this chapter, you’ll need to install NSubstitute via
    NuGet Package Manager and then import it via a `using` `NSubstitute;` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have NSubstitute installed and imported, you can use it in code, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note how NSubstitute’s `Substitute.For` returns the object you’re creating instead
    of creating an object like `Mock<IEmailClient>` did with Moq. This change makes
    your code a little simpler to work with but also means you now need to call methods
    like `Received()` and `DidNotReceive()` to get access to the method to verify.
  prefs: []
  type: TYPE_NORMAL
- en: In general, NSubsitute is very similar to Moq but with a simpler syntax. This
    simplicity has its advantages, particularly in code readability and a lowered
    learning curve for new developers. Unfortunately, this sometimes comes at the
    price of NSubstitute not having the full range of features you’re used to with
    Moq.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve explored mocking libraries, let’s move on to completely different
    types of unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Pinning tests with Snapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s say you’ve inherited some complex legacy code that returns an object with
    a lot of properties. Some of these properties may, in turn, contain other complex
    objects with their own nest of properties. You’re just starting to work with this
    code and need to make a change, but there aren’t any tests in place and you’re
    not even sure what properties are important to verify.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve seen this scenario a few times now and can attest that a special testing
    library called Snapper is a fantastic solution to this problem.
  prefs: []
  type: TYPE_NORMAL
- en: What Snapper does is it creates a snapshot of an object and stores it to disk
    in a JSON file. When Snapper next runs, it generates another snapshot and then
    compares it to the snapshot it stored previously. If the snapshots differ at all,
    Snapper will fail the test and alert you to that problem.
  prefs: []
  type: TYPE_NORMAL
- en: Snapper and Jest
  prefs: []
  type: TYPE_NORMAL
- en: For those of you with a JavaScript background, Snapper was inspired by the snapshot
    testing capabilities found in JavaScript’s Jest testing library.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what a sample test looks like with Snapper.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, first, we install Snapper via NuGet and add a `using` `Snapper;` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we’ll write a test against a complex object, `FlightManifest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we call `ShouldMatchSnapshot` to verify that the object matches the current
    snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will generate the snapshot the first time, but subsequent runs will compare
    the object’s snapshot to the stored snapshot. If the resulting snapshot is different,
    you’ll see a test failure with details about the difference, such as the one that
    occurs when a passenger’s name is changed, as shown in *Figure 9**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – A failing snapshot test showing the difference between two properties](img/B21324_09_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – A failing snapshot test showing the difference between two properties
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you’ll add new properties or realize that the stored snapshot was
    based on buggy data and you’ll want to update your snapshots. You can do this
    by temporarily adding an `UpdateSnapshots` attribute to your test method, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: After this, re-run your test to update the stored snapshot, then remove the
    `UpdateSnapshots` attribute. This final step is important because the test with
    `UpdateSnapshots` included will never fail a snapshot test but rather replace
    the snapshot every time.
  prefs: []
  type: TYPE_NORMAL
- en: Snapshot testing is not for every project and not for every team. It is a very
    useful broad safety net that you can include as the first test for complex return
    values, but it is far less useful as a test that documents the behavior of a system.
    Additionally, snapshot tests can be very brittle and cause tests to fail for trivial
    things such as modified dates being different between two otherwise identical
    sets of data.
  prefs: []
  type: TYPE_NORMAL
- en: Still, I find that Snapper and snapshot testing can be an appropriate opening
    move while trying to bring tests to particularly complex areas of legacy systems.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s close this chapter out with a similar library that helps you compare
    several different implementations with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Experimenting with Scientist .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scientist .NET is a library built by GitHub for scientifically refactoring the
    critical parts of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say you have a portion of your application that is vital to what the business
    does but has a significant amount of technical debt. You want to refactor it,
    but you’re afraid of breaking anything and your existing tests are not sufficient
    to address those fears, but you’re not sure what tests you need to add. In your
    estimation, the only thing that will let you feel good about your new code is
    to see how it does in production.
  prefs: []
  type: TYPE_NORMAL
- en: This is what Scientist .NET helps with. Scientist .NET lets you deploy your
    new code alongside the legacy code it hopes to replace and compares the results
    of the two pieces of code. Alternatively, Scientist .NET can be used in unit tests
    to verify that the old version of a component and the new version of the component
    achieves the same results.
  prefs: []
  type: TYPE_NORMAL
- en: This concept will hopefully be a bit clearer in a moment. Let’s jump into a
    specific example that looks at replacing `LegacyManifestGenerator` with `RewrittenManifestGenerator`.
  prefs: []
  type: TYPE_NORMAL
- en: Like before, we’ll need to install the Scientist package from NuGet and then
    add a `using GitHub;` statement to the top of our file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s look at the science experiment comparing the two manifest generators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: That’s a lot of code, so let’s unpack everything here bit by bit.
  prefs: []
  type: TYPE_NORMAL
- en: First, the `Scientist.Science<FlightManifest>` line tells Scientist you’re starting
    a new experiment that will return `FlightManifest`. In this example, we’re ignoring
    this result value, but in a production scenario, you might assign the result to
    a variable and work with it after the call to the Scientist.
  prefs: []
  type: TYPE_NORMAL
- en: Scientist requires you to name every experiment in the first parameter to the
    `Science` call because you may be performing multiple experiments. This experiment
    is simply named “Manifest.”
  prefs: []
  type: TYPE_NORMAL
- en: Next, the Scientist requires an action to configure the experiment you’re about
    to perform. You might configure a few things, but here, we’re specifying four
    different things that we’ll talk about in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: First, we call the `Use` method to tell the experiment what to use as the result
    of the call to the `Scientist.Science`. This should be the legacy implementation
    of the system you’re looking at replacing.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to give Scientist one or more alternative implementations to consider
    and compare against the “control” version in the legacy system. We do this via
    a `Try` method that looks very similar to the `Use` method, but it represents
    the experimental version.
  prefs: []
  type: TYPE_NORMAL
- en: 'What Scientist does with these two versions is it makes the call to both implementations,
    compares the two results, and sends metrics on to something called a result publisher.
    This process is illustrated in *Figure 9**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Scientist .NET performing an experiment](img/B21324_09_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Scientist .NET performing an experiment
  prefs: []
  type: TYPE_NORMAL
- en: Scientist always returns the result of the legacy version defined during `Use`,
    so your new implementation will not impact the existing logic and you’ll be able
    to identify cases where the new and old implementations do not match. This allows
    you to verify your new logic’s behavior without risking any logic bugs impacting
    end users.
  prefs: []
  type: TYPE_NORMAL
- en: Once you are satisfied that your new implementation is without issues, you can
    remove Scientist and the legacy implementation from your code and use the new
    implementation in their place.
  prefs: []
  type: TYPE_NORMAL
- en: For Scientist to tell if two results are equivalent, it needs to know how to
    compare them. You can configure this with the `Compare` method, which takes in
    a function that will return a `bool` object indicating if the two objects should
    be considered equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, our code sets `ThrowOnMismatches` to `true`. You can set this property
    in Scientist to have it throw an exception when the experiment and the control
    do not match for a given input. This is only intended for use in unit tests like
    our code here and is not intended for use if you’re using Scientist in a production
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, you would implement Scientist’s `IResultPublisher` interface and set
    `Scientist.ResultPublisher` equal to your custom result publisher. This would
    allow you to report mismatches to a database, App Insights on Azure, or some other
    mechanism you might consider using to capture these mismatches. Getting into result
    publishers is outside the scope of this book, but see the *Further reading* section
    in this chapter for more resources.
  prefs: []
  type: TYPE_NORMAL
- en: Scientist .NET is a complex solution you won’t use frequently, but it allows
    you to compare how two different implementations of an algorithm perform against
    a variety of inputs, either in a unit testing scenario or in a production application.
    I’ve personally seen Scientist .NET enable teams to collect the data they needed
    to successfully refactor highly complex code without impacting end users.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that when you run an experiment in Scientist, both the
    original version in your `Use` statement and any experiments you defined in the
    `Try` calls will be called. This means that if your code has any side effects
    such as inserting into a database or sending an email, these things will occur
    twice. This might result in duplicate rows being inserted into a database or duplicate
    emails being sent.
  prefs: []
  type: TYPE_NORMAL
- en: You can potentially avoid this downside by providing the experimental versions
    of mock objects as their dependencies instead of real versions of a database client
    or an email provider.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw several different open-source libraries that can improve
    the readability and capabilities of your tests.
  prefs: []
  type: TYPE_NORMAL
- en: Shouldly and FluentAssertions give you the readable syntax for writing assertions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bogus allows you to generate randomized test data for values that don’t matter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moq and NSubstitute help you isolate dependencies and provide alternative implementations
    for testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Snapper and Scientist .NET help catch issues where complex objects change in
    subtle ways.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not every project will benefit from each of these libraries. However, knowing
    the tools at your disposal will help you as you refactor and maintain your code
    and expand your tests.
  prefs: []
  type: TYPE_NORMAL
- en: While it’s possible to do all the things in this chapter without using these
    libraries, all of these libraries represent established community projects dedicated
    to solving specific technical concerns.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll close out this section of this book with a discussion
    of defensive coding practices using modern C#.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What areas of your test code could be more readable? Are there any libraries
    in this chapter that might help?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do mocking libraries such as Moq and NSubstitute help in testing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you see any areas of your code where the complexity is high enough that Snapper
    or Scientist .NET might be able to help?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find more information about the libraries discussed in this chapter
    at these URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Shouldly*: [https://github.com/shouldly/shouldly](https://github.com/shouldly/shouldly)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*FluentAssertions*: [https://fluentassertions.com/](https://fluentassertions.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Bogus*: [https://github.com/bchavez/Bogus](https://github.com/bchavez/Bogus)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Moq*: [https://github.com/moq/moq](https://github.com/moq/moq)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*NSubstitute*: https://nsubstitute.github.io/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Snapper*: [https://github.com/theramis/Snapper](https://github.com/theramis/Snapper)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Scientist .**NET*: [https://github.com/scientistproject/Scientist.net](https://github.com/scientistproject/Scientist.net)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
