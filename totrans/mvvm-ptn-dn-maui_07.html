<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer058">
<h1 class="chapter-number" id="_idParaDest-117"><a id="_idTextAnchor119"/>7</h1>
<h1 id="_idParaDest-118"><a id="_idTextAnchor120"/>Dependency Injection, Services, and Messaging</h1>
<p>As we continue building our <em class="italic">Recipes!</em> app using .NET MAUI, we want to make the most of the MVVM design pattern. MVVM is great for keeping our code organized and also promotes industry-standard practices that make our code base more maintainable and testable. In this chapter, we will focus on two critical concepts that are central to a solid MVVM architecture: <strong class="bold">Dependency</strong> <strong class="bold">Injection </strong>(<strong class="bold">DI</strong>) and <strong class="bold">messaging</strong>. DI promotes separation of concerns and allows our code to be much more testable. Messaging helps us keep different parts of our code from getting tangled up with each other. It allows different areas of our app to talk to each other in a loosely coupled way. Both concepts are extremely important to ensure that our MVVM architecture truly <span class="No-Break">stands out.</span></p>
<p>Let’s take a look at what this <span class="No-Break">chapter covers:</span></p>
<ul>
<li>Inversion of Control through <span class="No-Break">Dependency Injection</span></li>
<li>Registering, resolving, and <span class="No-Break">injecting services</span></li>
<li><span class="No-Break">Messaging</span></li>
</ul>
<p>By the end of this chapter, you’ll have a good understanding of these concepts as we implement them in our <em class="italic">Recipes!</em> app. So, let’s go ahead and get <span class="No-Break">into it.</span></p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor121"/>Technical requirements</h1>
<p>Throughout this chapter, we will be enhancing the functionality of the <em class="italic">Recipes!</em> app. All the resources, including additional classes and code required for the topics covered in this chapter, are available on GitHub at <a href="https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter07">https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter07</a>. To follow along with this chapter’s content, you can start with the provided <strong class="source-inline">Start</strong> folder. It contains the initial code and necessary classes specific to this chapter. This code serves as the foundation, building upon what we have learned in the previous chapters. If you want to reference or compare the completed code, including all the code written throughout this chapter, you can find it in the <span class="No-Break"><strong class="source-inline">Finish</strong></span><span class="No-Break"> folder.</span></p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor122"/>Inversion of Control through Dependency Injection</h1>
<p><strong class="bold">Inversion of Control</strong> (<strong class="bold">IoC</strong>) is a<a id="_idIndexMarker476"/> programming <a id="_idIndexMarker477"/>principle where the control over certain aspects of a program’s flow is handed over from the main code to a framework or a container. In simple terms, instead of a component being responsible for managing its dependencies and life cycle, these responsibilities are inverted or delegated to an external controller. This approach is particularly useful for creating modular and <span class="No-Break">flexible systems.</span></p>
<p>In a typical software design without IoC, a class that requires certain functionalities from other classes would create or manage these dependent objects within itself. With IoC, this creation and management is handled by an external component, hence inverting <span class="No-Break">the control.</span></p>
<p>IoC can be achieved through various methods such as DI, Factory Pattern, Service Locator, and more. Among these, DI is the most commonly used method in the context <span class="No-Break">of MVVM.</span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor123"/>Dependency Injection</h2>
<p>DI, a specific form<a id="_idIndexMarker478"/> of IoC, involves injecting the dependencies of an object (such as services or components) into the object by an external entity rather than having the object create them. This is typically done through <span class="No-Break">the constructor.</span></p>
<p>Using DI brings a lot of advantages. Let’s take <span class="No-Break">a look:</span></p>
<ul>
<li><strong class="bold">Separation of concerns</strong>: Each<a id="_idIndexMarker479"/> component or class focuses on its core responsibility. The creation and life cycle management of its dependencies are <span class="No-Break">handled externally.</span></li>
<li><strong class="bold">Testability</strong>: DI makes it much easier to test components by allowing mock dependencies to be injected. This is crucial because, in unit testing, you want to isolate the component being tested and not have to worry about the dependencies. For example, if a ViewModel depends on a service that fetches data, you can inject a mock data service that simulates data retrieval without actually hitting a database or API. This makes tests faster, repeatable, and <span class="No-Break">more reliable.</span></li>
<li><strong class="bold">Reusability and maintainability</strong>: Components become more reusable and maintainable because they are not tightly coupled with <span class="No-Break">their dependencies.</span></li>
<li><strong class="bold">Flexibility</strong>: It becomes<a id="_idIndexMarker480"/> easier to change or swap implementations of dependencies without altering the <span class="No-Break">dependent class.</span></li>
</ul>
<p>By allowing dependencies to be injected from the outside, DI supports the creation of more loosely coupled code. This not only results in a more maintainable and scalable system but is also highly advantageous for testing. Through the injection of mock or stub implementations during testing, you can focus on testing the functionality of individual components in isolation, without the complexity and unpredictability of the <span class="No-Break">entire system.</span></p>
<p>The ability to inject different implementations is one of the powerful aspects of DI and is central to creating<a id="_idIndexMarker481"/> robust and <span class="No-Break">flexible architectures.</span></p>
<p>Remember, back in <a href="B20941_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">What Is the MVVM Design Pattern?,</em> where we had a <strong class="source-inline">MainPageViewModel</strong> and its constructor accepted an interface called <strong class="source-inline">IQuoteService</strong>? Let’s have <span class="No-Break">a look:</span></p>
<pre class="source-code">
public class MainPageViewModel : INotifyPropertyChanged
{
    private readonly IQuoteService quoteService;
    public MainPageViewModel(<strong class="bold">IQuoteService quoteService</strong>)
    {
        this.quoteService = quoteService;
    }
...
}</pre> <p>This is a textbook example of DI. <strong class="source-inline">MainPageViewModel</strong> should not be responsible for retrieving the “quote of the day.” Instead, this should be the responsibility of another class. <strong class="source-inline">MainPageViewModel</strong> is dependent on an instance of a class that implements <strong class="source-inline">IQuoteService</strong> for that functionality. However, instead of directly creating or managing an instance of this service, it receives the instance through its constructor. This is what’s <a id="_idIndexMarker482"/>known as <strong class="bold">constructor injection</strong>. By accepting the <strong class="source-inline">IQuoteService</strong> dependency through its constructor, <strong class="source-inline">MainPageViewModel</strong> adheres to the principle<a id="_idIndexMarker483"/> of <strong class="bold">separation of concerns</strong>. This principle asserts that a class should only be concerned with its core responsibility and not the responsibilities of its dependencies. In this case, the <strong class="source-inline">MainPageViewModel</strong> class’s responsibility is to provide data for the view, while the responsibility to fetch the actual data is delegated <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">IQuoteService</strong></span><span class="No-Break">.</span></p>
<p>Here, <strong class="source-inline">MainPageViewModel</strong> has no knowledge about where the class implementing the <strong class="source-inline">IQuoteService</strong> interface comes from, how it’s instantiated, or how its life cycle is managed. It simply receives an instance and uses it. This makes the ViewModel independent from the concrete implementation of the <strong class="source-inline">IQuoteService</strong> interface and it can be any class that implements <span class="No-Break">this interface.</span></p>
<p>This <strong class="bold">decoupling</strong> opens <a id="_idIndexMarker484"/>up a lot of flexibility. Say, for instance, that the way we retrieve quotes changes in the<a id="_idIndexMarker485"/> future. Maybe we initially fetch the quotes from a static file, but later decide to retrieve them from a remote API instead. Because our ViewModel isn’t directly tied to a specific implementation of the <strong class="source-inline">IQuoteService</strong> interface, we can just create a new class that implements it and fetch data from the API. We can then inject this new class into our ViewModel without having to change any code inside <strong class="source-inline">MainPageViewModel</strong> itself. The ViewModel is only concerned with the fact it has a class implementing the <strong class="source-inline">IQuoteService</strong> interface to work with, not the details of how it accomplishes <span class="No-Break">its tasks.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">While it’s common to see DI used with interfaces, it’s not a strict requirement. Interfaces are popular in DI because they promote loose coupling. However, abstract classes or even concrete classes can be injected as well. The choice depends on the specific needs of your application and your <span class="No-Break">design goals.</span></p>
<p>The advantage of this decoupling becomes even more evident when it comes to testing. Let’s say we want to write unit tests for <strong class="source-inline">MainPageViewModel</strong>. To make these tests reliable, we need to ensure they’re not affected by the unpredictability of external dependencies. With DI, we can easily achieve this by creating a mock implementation of <strong class="source-inline">IQuoteService</strong> that returns controlled data, perfect for testing scenarios. This way, we can test all aspects of <strong class="source-inline">MainPageViewModel</strong> in isolation, without any unpredictable <a id="_idIndexMarker486"/>behavior from <span class="No-Break">external dependencies.</span></p>
<p>Let’s see DI in action and have a look at how we can register, resolve, and <span class="No-Break">inject dependencies.</span></p>
<h1 id="_idParaDest-122"><a id="_idTextAnchor124"/>Registering, resolving, and injecting services</h1>
<p>.NET MAUI comes with built-in support for DI. It has been designed with DI in mind, which allows for easier configuration and management of services that your application relies on. By providing out-of-the-box support for DI, .NET MAUI enables developers to leverage the concept of DI and IoC to make their code more maintainable and more loosely coupled. As the MVVM pattern benefits tremendously from DI and IoC, it shows again that MVVM and .NET MAUI are a <span class="No-Break">perfect match!</span></p>
<p>The <strong class="source-inline">Microsoft.Extensions.DependencyInjection</strong> namespace is where .NET MAUI gets its default implementation for DI. However, it’s important to note that .NET MAUI is DI container agnostic, which means you’re not limited to the default. If you prefer a third-party DI container, you’re free to replace the default with your preferred choice. Let’s see how we can register services using .NET MAUI’s default <span class="No-Break">DI implementation.</span></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor125"/>Registering services</h2>
<p>.NET MAUI hosts a DI <a id="_idIndexMarker487"/>container and makes it accessible throughout your application. When your application starts, you have the opportunity to configure the services that will be available for injection. This is done using the <strong class="source-inline">Services</strong> property of the <strong class="source-inline">MauiAppBuilder</strong> instance. If you have worked with ASP.NET before, then you already know how this works. Through the <strong class="source-inline">Services</strong> property, we can set up services for use throughout <span class="No-Break">your application.</span></p>
<p>The <strong class="source-inline">Services</strong> property on <strong class="source-inline">MauiAppBuilder</strong> is of type <strong class="source-inline">IServiceCollection</strong>, which is a framework-provided interface for a collection of service descriptors. It provides methods to register services in the container. In the following example, the <strong class="source-inline">AddSingleton</strong> method is used to register <strong class="source-inline">QuoteService</strong> as a Singleton service for the <span class="No-Break"><strong class="source-inline">IQuoteService</strong></span><span class="No-Break"> interface:</span></p>
<pre class="source-code">
public static MauiApp CreateMauiApp()
{
    var builder = MauiApp.CreateBuilder();
    ...
    <strong class="bold">builder.Services.AddTransient&lt;IQuoteService,</strong>
<strong class="bold">      QuoteService&gt;();</strong>
    ...
    return builder.Build();
}</pre> <p>The preceding code shows how we can associate a concrete implementation (<strong class="source-inline">QuoteService</strong>) with an interface (<strong class="source-inline">IQuoteService</strong>). As a consequence, when the app’s <strong class="source-inline">IServiceProvider</strong> needs to<a id="_idIndexMarker488"/> resolve an instance of a class that implements the <strong class="source-inline">IQuoteService</strong>, it will create (or reuse) an instance of the <strong class="source-inline">QuoteService</strong> class. <strong class="source-inline">IServiceProvider</strong> represents a service container, which is a collection of service registrations. It’s essentially the object that is responsible for resolving and providing instances of services, which were registered through the associated <strong class="source-inline">IServiceCollection</strong>, when they are needed. Registering a concrete implementation for a particular interface allows us to decouple the implementation from the actual usage in our code. It’s good practice to code against interfaces and not against implementations and this is exactly what we can <span class="No-Break">achieve here.</span></p>
<p>However, in the <a id="_idIndexMarker489"/>case of ViewModels or other classes that don’t necessarily have an associated interface, we can register them directly, as the following <span class="No-Break">snippet shows:</span></p>
<pre class="source-code">
builder.Services.AddTransient&lt;MainPageViewModel&gt;();</pre> <p>When we do this, every time an instance of <strong class="source-inline">MainPageViewModel</strong> is requested from the DI container, it will provide an instance of the class and manage its <span class="No-Break">life cycle.</span></p>
<p>Services can be registered in different ways, depending on their <span class="No-Break">intended lifetimes:</span></p>
<ul>
<li><strong class="bold">Transient</strong>: Transient services are created each time they’re requested from the container. This lifetime works best for lightweight, stateless services. In theory, Transient services take up more memory because a new instance is created every time the service is requested. However, because each instance can be garbage-collected as soon as it’s no longer in use, this memory can be <span class="No-Break">reclaimed quickly.</span></li>
<li><strong class="bold">Singleton</strong>: Singleton services are created once, and the same instance is used throughout the application’s lifetime. This works best for stateful services that need to maintain consistency across the app, or for heavy services that would be expensive to create multiple times. Singleton services take up the least amount of memory because only one instance is ever created. However, because the same instance is used throughout the entire application, it stays in memory for as long as the application <span class="No-Break">is running.</span></li>
<li><strong class="bold">Scoped</strong>: Scoped services are created once per scope. However, in a .NET MAUI application, this is similar to Singleton since there is generally only <span class="No-Break">one scope.</span></li>
</ul>
<p>Choosing between these lifetimes depends entirely on the specific needs of the service. If your service is stateless and lightweight, a Transient lifetime might be appropriate. If your service needs to maintain state across the entire application, or if it’s expensive to create, a Singleton lifetime might be the best option. Choosing the right lifetime for your services is important. It can affect how your app behaves and performs, so think about it carefully. In my experience, I usually choose Transient as much as possible for my services. I do this because I aim to keep my services simple and without state. This way, they use memory more efficiently since they’re removed as soon as they’re not needed. Also, it helps to avoid problems that can come up when a shared state is changed in different places, especially in multi-threaded situations. But remember, there’s no one-size-fits-all solution <a id="_idIndexMarker490"/>here. Each service is unique and so is your app. Depending on what your service does and what your app needs, you might have to choose a different lifetime. That’s why it’s key to understand these concepts and make smart choices for your <span class="No-Break">specific app.</span></p>
<p>Let’s see how we can resolve and inject these <span class="No-Break">registered services.</span></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor126"/>Resolving and injecting services</h2>
<p>DI containers, such<a id="_idIndexMarker491"/> as the one built into .NET MAUI, are <a id="_idIndexMarker492"/>capable of resolving not only direct dependencies but also <span class="No-Break">nested dependencies.</span></p>
<p>In essence, when an instance of a class or service is being resolved by the container, all of its dependencies, and the dependencies of those dependencies, are automatically resolved and injected as well. This forms a complete object graph where every class has its <span class="No-Break">dependencies satisfied.</span></p>
<p>If a particular class has a dependency that needs to be injected, it is as simple as defining the dependency as a parameter of the class’s constructor. That’s exactly what we did with <strong class="source-inline">MainPageViewModel</strong>: it has a constructor that requires an instance of a class implementing the <span class="No-Break"><strong class="source-inline">IQuoteService</strong></span><span class="No-Break"> interface.</span></p>
<p class="callout-heading">Which constructor does the DI container use?</p>
<p class="callout">As the DI container can instantiate classes for us, you might wonder which constructor it uses when the class has multiple constructors. The answer is pretty simple: it uses the constructor with the most parameters that it can resolve. If there are two or more constructors with the same number of parameters the DI container can resolve, or when no constructor is found for which all dependencies could be resolved, an exception will <span class="No-Break">be thrown.</span></p>
<p>We are also able to resolve services on the fly, so long as we get a hold of the app’s <strong class="source-inline">IServiceProvider</strong> container. This interface exposes a <strong class="source-inline">GetService&lt;T&gt;</strong> method that we can call to get an instance of a class that was associated with the provided generic type parameter. The following code block shows how we can create a static <strong class="source-inline">ServiceProvider</strong> class that we could use to access the services container from anywhere in <span class="No-Break">our app:</span></p>
<pre class="source-code">
public static class ServiceProvider
{
    public static TService GetService&lt;TService&gt;()
        =&gt; Current.GetService&lt;TService&gt;();
    public static IServiceProvider Current
        =&gt;
#if WINDOWS10_0_17763_0_OR_GREATER
        MauiWinUIApplication.Current.Services;
#elif ANDROID
        MauiApplication.Current.Services;
#elif IOS || MACCATALYST
       MauiUIApplicationDelegate.Current.Services;
#else
      null;
#endif
}</pre> <p>So, instead of instantiating a <strong class="source-inline">MainPageViewModel</strong> in the code behind the <strong class="source-inline">MainPage_MVVM</strong> class, and needing to manually provide an instance of a class that<a id="_idIndexMarker493"/> implements IQuoteService, we <a id="_idIndexMarker494"/>can do <span class="No-Break">the following:</span></p>
<pre class="source-code">
public MainPage_MVVM()
{
    InitializeComponent();
    BindingContext = <strong class="bold">ServiceProvider</strong>
<strong class="bold">        .GetService&lt;MainPageViewModel&gt;();</strong>
}</pre> <p>Because we have registered <strong class="source-inline">MainPageViewModel</strong> as a service and <strong class="source-inline">QuoteService</strong>, which we associated with the <strong class="source-inline">IQuoteService</strong> interface, the <strong class="source-inline">GetService</strong> method will return an instance of <strong class="source-inline">MainPageViewModel</strong>, which is instantiated by injecting an instance of the <strong class="source-inline">QuoteService</strong> class through its constructor. This <strong class="source-inline">ServiceProvider</strong> class can be very helpful to resolve instances of classes on the fly from the DI container. However, for this particular example, we could take this a step further and avoid the need to manually resolve an instance of <strong class="source-inline">MainPageViewModel</strong>. We can achieve this by adding an instance of <strong class="source-inline">MainPageViewModel</strong> as a dependency to the <strong class="source-inline">MainPage_MVVM</strong> class, as <span class="No-Break">shown here:</span></p>
<pre class="source-code">
public MainPage_MVVM(<strong class="bold">MainPageViewModel vm</strong>)
{
    InitializeComponent();
    <strong class="bold">BindingContext = vm;</strong>
}</pre> <p>The following code snippet shows how we can register the <strong class="source-inline">MainPage_MVVM</strong> class <span class="No-Break">as well:</span></p>
<pre class="source-code">
builder.Services.AddTransient&lt;MainPage_MVVM&gt;();</pre> <p>In this sample app, we’re using .NET MAUI Shell for navigation. This allows an instance of a page to be dynamically resolved during the navigation process. So, when we navigate to the <strong class="source-inline">MainPage_MVVM</strong> page, the DI container springs into action. It resolves an instance of the <strong class="source-inline">MainPage_MVVM</strong> page and all of <span class="No-Break">its dependencies.</span></p>
<p class="callout-heading">What is .NET MAUI Shell?</p>
<p class="callout">In <a href="B20941_08.xhtml#_idTextAnchor132"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Navigation in MVVM</em>, we will dive much deeper into the aspects of navigation<a id="_idIndexMarker495"/> and .NET <span class="No-Break">MAUI Shell.</span></p>
<p>Now that we’ve got a taste of DI with the <em class="italic">Quote of the Day</em> app, let’s take things up a notch by applying what we’ve learned to our feature-rich <em class="italic">Recipes!</em> app. This will allow us to delve<a id="_idIndexMarker496"/> deeper<a id="_idIndexMarker497"/> into DI and see how it can be skillfully utilized in a more complex project. So, roll up your sleeves, and let’s get cooking with DI in the <span class="No-Break"><em class="italic">Recipes!</em></span><span class="No-Break"> app.</span></p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor127"/>Applying Dependency Injection</h2>
<p>So far, in the ViewModels<a id="_idIndexMarker498"/> in our <em class="italic">Recipes!</em> app we have been working with hard-coded data. Now, it’s time to breathe more life into our application by introducing services that can fetch and manage data dynamically. The <strong class="source-inline">Begin</strong> directory in the GitHub repository for this chapter presents some updates and additional code that includes new service interfaces such as <strong class="source-inline">IRecipeService</strong>, <strong class="source-inline">IFavoritesService</strong>, and <strong class="source-inline">IRatingsService</strong>, along with their respective implementations. These services will play crucial roles in our application: the <strong class="source-inline">IRecipeService</strong> interface defines a contract for a service that will load and manage recipe data. Similarly, <strong class="source-inline">IFavoritesService</strong> outlines the rules for a service that will handle the user’s favorite recipes, and the <strong class="source-inline">IRatingsService</strong> interface does the same for a service managing recipe ratings. As we move forward, we’ll explore how to use these services within the MVVM architecture and how DI brings it all together in a clean, <span class="No-Break">manageable manner.</span></p>
<p>To introduce DI in our <em class="italic">Recipes!</em> app, we need to make sure that, unlike what we have been doing up until now, we don’t initialize ViewModels in the code-behind ourselves. Instead, these ViewModels <a id="_idIndexMarker499"/>need to be injected and assigned to the page’s <strong class="source-inline">BindingContext</strong>. Let’s have a look at this before we update <span class="No-Break">the ViewModels.</span></p>
<h3>Adding dependencies to pages</h3>
<p>To add the dependency<a id="_idIndexMarker500"/> of a particular ViewModel to a page, we simply need to add the type of ViewModel as a parameter to the constructor. Also, we need to make sure that both the page and the ViewModel are registered in the <span class="No-Break">DI container:</span></p>
<ol>
<li>Head over to the code-behind of <strong class="source-inline">RecipesOverviewPage</strong> and add a parameter of type <strong class="source-inline">RecipeOverviewViewModel</strong> to the page’s constructor, as shown in the <span class="No-Break">following snippet:</span><pre class="source-code">
public RecipesOverviewPage(RecipesOverviewViewModel
  viewModel)
{
    InitializeComponent();
    BindingContext = viewModel;
}</pre></li> <li>Next, we need to make sure the <strong class="source-inline">RecipesOverviewPage</strong> and <strong class="source-inline">RecipeOverviewViewModel</strong> classes are registered with the DI container. Only then can the DI container resolve <strong class="source-inline">RecipesOverviewPage</strong> and resolve its dependency, an instance of <strong class="source-inline">RecipesOverviewViewModel</strong>. Head over to <strong class="source-inline">MauiProgram</strong> and add the following lines <span class="No-Break">of code:</span><pre class="source-code">
public static MauiApp CreateMauiApp()
{
    var builder = MauiApp.CreateBuilder();
    builder
        .UseMauiApp&lt;App&gt;()
    ...
    <strong class="bold">builder.Services</strong>
<strong class="bold">        .AddTransient&lt;RecipesOverviewPage&gt;();</strong>
    <strong class="bold">builder.Services</strong>
<strong class="bold">        .AddTransient&lt;RecipesOverviewViewModel&gt;();</strong>
    ...
}</pre></li> <li>Similarly, we need to<a id="_idIndexMarker501"/> do the same for <strong class="source-inline">RecipeDetailPage</strong> and <strong class="source-inline">RecipeRatingDetailPage</strong>: add their respective ViewModels as dependencies by including them as parameters. This is what it looks like <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">RecipesOverviewPage</strong></span><span class="No-Break">:</span><pre class="source-code">
public RecipesOverviewPage(
    RecipesOverviewViewModel viewModel)
{
    InitializeComponent();
    BindingContext = viewModel;
}</pre><p class="list-inset">And likewise, for <strong class="source-inline">RecipeRatingDetailPage</strong>, we must do the following, where we want to <span class="No-Break">inject </span><span class="No-Break"><strong class="source-inline">RecipeRatingsDetailViewModel</strong></span><span class="No-Break">:</span></p><pre class="source-code">public RecipeRatingDetailPage(
    RecipeRatingsDetailViewModel viewModel)
{
    InitializeComponent();
    BindingContext = viewModel;
}</pre></li> <li>Now, just like we did before, let’s register these additional pages and their ViewModels in the<a id="_idIndexMarker502"/> DI container within the <span class="No-Break"><strong class="source-inline">MauiProgram</strong></span><span class="No-Break"> class:</span><pre class="source-code">
public static MauiApp CreateMauiApp()
{
    var builder = MauiApp.CreateBuilder();
    builder
        .UseMauiApp&lt;App&gt;()
    ...
    builder.Services
        .AddTransient&lt;RecipesOverviewPage&gt;();
    builder.Services
        .AddTransient&lt;RecipesOverviewViewModel&gt;();
    <strong class="bold">builder.Services</strong>
<strong class="bold">        .AddTransient&lt;RecipeDetailPage&gt;();</strong>
<strong class="bold">    builder.Services</strong>
<strong class="bold">        .AddTransient&lt;RecipeDetailViewModel&gt;();</strong>
<strong class="bold">    builder.Services</strong>
<strong class="bold">        .AddTransient&lt;RecipeRatingDetailPage&gt;();</strong>
<strong class="bold">    builder.Services</strong>
<strong class="bold">        .AddTransient&lt;RecipeRatingsDetailViewModel&gt;();</strong>
...
}</pre></li> </ol>
<p>With these modifications in place, we’ve successfully implemented the foundational elements of DI in our <em class="italic">Recipes!</em> app. By registering the pages and their corresponding ViewModels with the DI container, we’ve ensured that whenever these components are needed, they can be easily resolved and provided by the DI container. Moreover, by injecting the ViewModels into our pages through their constructors, we’ve shifted the responsibility of creating and managing ViewModel instances away from the pages themselves and toward the DI container. This sets up a more flexible and maintainable structure for our application, paving the way for us to further enhance it with additional services <span class="No-Break">and</span><span class="No-Break"><a id="_idIndexMarker503"/></span><span class="No-Break"> functionality.</span></p>
<p>Now, let’s take a closer look at the specific changes we need to make to our ViewModels to fully <span class="No-Break">incorporate DI.</span></p>
<h3>Adding dependencies to ViewModels</h3>
<p>We no longer <a id="_idIndexMarker504"/>want our ViewModels to contain <a id="_idIndexMarker505"/>hard-coded data, nor do we want them to be responsible for retrieving data. So, let’s introduce some dependencies to <span class="No-Break">our ViewModels:</span></p>
<ol>
<li>At the very top of the <strong class="source-inline">RecipesOverviewViewModel</strong> class, we can start by removing the <strong class="source-inline">items</strong> field. We’re moving away from hard-coded data and will use services to fetch <span class="No-Break">data instead.</span></li>
<li>The following code snippet shows how we introduce two fields to this class: <strong class="source-inline">recipeService</strong>, which is of type <strong class="source-inline">IRecipeService</strong>, and <strong class="source-inline">favoritesService</strong>, which is of <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">IFavoritesService</strong></span><span class="No-Break">:</span><pre class="source-code">
private readonly IRecipeService recipeService;
private readonly IFavoritesService favoritesService;</pre><p class="list-inset">These services will take responsibility for loading the recipes on this page and displaying whether they are favorited by the user or not. Both of these services are dependencies that will be injected into <span class="No-Break">the ViewModel.</span></p></li> <li>This code block shows exactly how these dependencies can get injected through the constructor of <span class="No-Break">the ViewModel:</span><pre class="source-code">
public RecipesOverviewViewModel(
    <strong class="bold">IRecipeService recipeService</strong>,
    <strong class="bold">IFavoritesService favoritesService</strong>)
{
    <strong class="bold">this.recipeService = recipeService;</strong>
    <strong class="bold">this.favoritesService = favoritesService;</strong>
    Recipes = new ();
    TryLoadMoreItemsCommand =
        new AsyncRelayCommand(TryLoadMoreItems);
    NavigateToSelectedDetailCommand =
        new AsyncRelayCommand
          (NavigateToSelectedDetail);
    LoadRecipes(7, 0);
}</pre><p class="list-inset">By defining <a id="_idIndexMarker506"/>these<a id="_idIndexMarker507"/> two parameters in the constructor for <strong class="source-inline">RecipesOverviewViewModel</strong>, the DI container will attempt to resolve instances for both when creating a <strong class="source-inline">RecipesOverviewViewModel</strong>. The resolved instances are then passed as parameters to the constructor, where we can assign them to the fields we <span class="No-Break">created earlier.</span></p></li> <li>When we examine the <strong class="source-inline">LoadRecipes</strong> method, we can see how we utilize these services to load the data <span class="No-Break">we need:</span><pre class="source-code">
private async Task LoadRecipes(int pageSize, int page)
{
    var loadRecipesTask =
        <strong class="bold">recipeService.LoadRecipes(pageSize, page);</strong>
    var loadFavoritesTask =
        <strong class="bold">favoritesService.LoadFavorites();</strong>
   ...
}</pre><p class="list-inset">The ViewModel doesn’t concern itself with where these recipes or favorites are coming from. It only trusts that the injected services – <strong class="source-inline">recipeService</strong> and <strong class="source-inline">favoritesService</strong> – adhere to the specified interfaces and deliver the required functionality. The exact implementation is abstracted away from the ViewModel, highlighting one of the main benefits <span class="No-Break">of DI.</span></p></li> <li>Head over to <strong class="source-inline">RecipeDetailViewModel</strong>. In this class, we also want to remove all hard-coded data: <strong class="source-inline">Title</strong>, <strong class="source-inline">Allergens</strong>, <strong class="source-inline">Calories</strong>, and so on. And while we are at it, we should update the properties to “full” properties that trigger the <strong class="source-inline">PropertyChanged</strong> event. This is needed because the data on the ViewModel <a id="_idIndexMarker508"/>will be<a id="_idIndexMarker509"/> loaded asynchronously, so it won’t be there when the page is being rendered. As a result, the <strong class="source-inline">PropertyChanged</strong> event for each property needs to be triggered when the data is loaded to reflect the loaded values on the UI. The following snippet shows some of the <span class="No-Break">updated properties:</span><pre class="source-code">
string _title;
public string Title
{
    get =&gt; _title;
    set =&gt; SetProperty(ref _title, value);
}
string[] _allergens = new string[0];
public string[] Allergens
{
    get =&gt; _allergens;
    set =&gt; SetProperty(ref _allergens, value);
}
int? _calories;
public int? Calories
{
    get =&gt; _calories;
    set =&gt; SetProperty(ref _calories, value);
}</pre></li> <li>Now is also the time to update the binding mode on the label, which shows the recipe’s title. Up until now, this was defined as a <strong class="source-inline">OneTime</strong> binding, but as we now load the data of the recipe after the ViewModel is set as the <strong class="source-inline">BindingContext</strong> of the <strong class="source-inline">RecipeDetailPage</strong>, we need to make sure the updated<a id="_idIndexMarker510"/> value is<a id="_idIndexMarker511"/> shown on the screen as well. Let’s update the binding mode to <strong class="source-inline">OneWay</strong> so that when the <strong class="source-inline">PropertyChanged</strong> event is triggered after the value of the <strong class="source-inline">Title</strong> property is set, the binding engine updates the value on the UI. The following snippet shows the <span class="No-Break">updated label:</span><pre class="source-code">
&lt;Label
    FontAttributes="Bold"
    FontSize="22"
    Text="{Binding Path=Title, <strong class="bold">Mode=OneWay</strong>}"
    VerticalOptions="Center" /&gt;</pre></li> <li>Let’s update the constructor of <strong class="source-inline">RecipeDetailViewModel</strong> so that it accepts an instance of <strong class="source-inline">IRecipeService</strong>, <strong class="source-inline">IFavoritesService</strong>, and <strong class="source-inline">IRatingsService</strong>, as <span class="No-Break">shown here:</span><pre class="source-code">
public RecipeDetailViewModel(
    IRecipeService recipeService,
    IFavoritesService favoritesService,
    IRatingsService ratingsService)
{
    this.recipeService = recipeService;
    this.favoritesService  = favoritesService;
    this.ratingsService = ratingsService;
...
}</pre></li> <li>These services (<strong class="source-inline">recipeService</strong>, <strong class="source-inline">favoritesService</strong>, and <strong class="source-inline">ratingsService</strong>) are <strong class="source-inline">readonly</strong> fields that we should define in the ViewModel, as demonstrated in the <span class="No-Break">following snippet:</span><pre class="source-code">
private readonly IRecipeService recipeService;
private readonly IFavoritesService favoritesService;
private readonly IRatingsService ratingsService;</pre></li> <li>The following<a id="_idIndexMarker512"/> code<a id="_idIndexMarker513"/> block shows <strong class="source-inline">LoadRecipe</strong>, which accepts the ID of the recipe to load as a parameter. This method uses the injected services to load all relevant data for <span class="No-Break">this ViewModel:</span><pre class="source-code">
private async Task LoadRecipe(string recipeId)
{
    var loadRecipeTask =
        <strong class="bold">recipeService.LoadRecipe(recipeId);</strong>
    var loadIsFavoriteTask =
        <strong class="bold">favoritesService.IsFavorite(recipeId);</strong>
    var loadRatingsTask =
        <strong class="bold">ratingsService.LoadRatingsSummary(recipeId);</strong>
    await Task.WhenAll(loadRecipeTask,
        loadRecipeTask, loadRatingsTask);
    if(loadRecipeTask.Result is not null)
        MapRecipeData(
            loadRecipeTask.Result,
            loadRatingsTask.Result,
            loadIsFavoriteTask.Result);
}</pre><p class="list-inset">The three async tasks that retrieve <strong class="source-inline">RecipeDetailDto</strong>, <strong class="source-inline">RatingsSummaryDto</strong>, and the <strong class="source-inline">bool</strong> value indicating whether the recipe is a favorite or not are launched in parallel. Through the <strong class="source-inline">Task.WhenAll</strong> method, we wait for all<a id="_idIndexMarker514"/> three to complete. Beyond <a id="_idIndexMarker515"/>this point, the <strong class="source-inline">Result</strong> property of the tasks holds the retrieved data. This data is then mapped to the ViewModel through the <span class="No-Break"><strong class="source-inline">MapRecipeData</strong></span><span class="No-Break"> method.</span></p></li> <li>In the next chapter, <a href="B20941_08.xhtml#_idTextAnchor132"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Navigation in MVVM</em>, we’ll have a look at how we can pass the ID of the selected recipe from <strong class="source-inline">RecipesOverviewViewModel</strong> to <strong class="source-inline">RecipeDetailViewModel</strong> to load the recipe details of the chosen recipe. For now, let’s add the following snippet at the end of the ViewModel’s constructor to load the details of the recipe with an ID <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">3</strong></span><span class="No-Break">:</span><pre class="source-code">
LoadRecipe("3");</pre></li> <li>Finally, we also need to update <strong class="source-inline">RecipeRatingsDetailViewModel</strong>. As before, we want to remove all hard-coded data and update the constructor so that it accepts an instance of a class that implements <strong class="source-inline">IRecipeService</strong> and one that implements the <strong class="source-inline">IRatingsService</strong> interface. The following snippet shows the updated constructor, where we also deleted the initialization of both the <strong class="source-inline">Reviews</strong> and <span class="No-Break"><strong class="source-inline">GroupedReviews</strong></span><span class="No-Break"> properties:</span><pre class="source-code">
public RecipeRatingsDetailViewModel(
    IRecipeService recipeService,
    IRatingsService ratingsService)
{
    this.recipeService = recipeService;
    this.ratingsService = ratingsService;
    ...
}</pre></li> <li>The <strong class="source-inline">Reviews</strong> property can be removed and we should make sure the <strong class="source-inline">RecipeTitle</strong> property calls the <strong class="source-inline">PropertyChanged</strong> event when it is being updated. Again, like we did previously, we must do this because the data is loaded asynchronously and we must notify the UI about the updated values. The following code block shows the updated <strong class="source-inline">RecipeTitle</strong> property, which uses the <strong class="source-inline">SetProperty</strong> method of the <strong class="source-inline">ObservableObject</strong> class to assign the value <a id="_idIndexMarker516"/>and trigger the <strong class="source-inline">PropertyChanged</strong> event. It also shows the <a id="_idIndexMarker517"/>fields that we added, to which we assign the injected dependencies in <span class="No-Break">the constructor:</span><pre class="source-code">
public class RecipeRatingsDetailViewModel :
  ObservableObject
{
    private readonly IRatingsService ratingsService;
    private readonly IRecipeService recipeService;
    string _recipeTitle = string.Empty;
    public string RecipeTitle
    {
        get =&gt; _recipeTitle;
        set =&gt; SetProperty(ref _recipeTitle, value);
    }
    …
}</pre></li> <li>Let’s also add the <strong class="source-inline">LoadData</strong> method, which accepts the ID of the recipe we want to load the rating for. It uses the injected services to dynamically load the data <a id="_idIndexMarker518"/>needed <a id="_idIndexMarker519"/>in this ViewModel. Let’s take <span class="No-Break">a look:</span><pre class="source-code">
private async Task LoadData(string recipeId)
{
    var recipeTask =
        <strong class="bold">recipeService.LoadRecipe(recipeId);</strong>
    var ratingsTask =
        <strong class="bold">ratingsService.LoadRatings(recipeId);</strong>
    await Task.WhenAll(recipeTask, ratingsTask);
    RecipeTitle =
        recipeTask.Result?.Name ?? string.Empty;
    GroupedReviews = ratingsTask.Result
        ...
        .ToList();
}</pre></li> <li>For now, let’s call the <strong class="source-inline">LoadData</strong> method from the constructor so that it loads some data when we initialize <span class="No-Break">the ViewModel:</span><pre class="source-code">
LoadData("3");</pre></li> </ol>
<p>With all the updates<a id="_idIndexMarker520"/> done on the ViewModels, let’s<a id="_idIndexMarker521"/> finish up by registering the services that our updated ViewModels now have <span class="No-Break">as dependencies.</span></p>
<h3>Registering services</h3>
<p>Now that <a id="_idIndexMarker522"/>our ViewModels have some dependencies, we have to make sure these dependencies get registered so that the DI container can <span class="No-Break">resolve them.</span></p>
<p>Registering the required dependencies is done again in the <strong class="source-inline">MauiProgram</strong> class. The following snippet shows how we register <strong class="source-inline">FavoritesService</strong>, which is <span class="No-Break">very straightforward:</span></p>
<pre class="source-code">
builder.Services.AddSingleton&lt;IFavoritesService,
  FavoritesService&gt;();</pre> <p>We intentionally register <strong class="source-inline">FavoritesService</strong> as a Singleton because this particular implementation stores the user’s favorites in memory. If we were to register it as Transient, a new instance would be created each time it’s injected as a dependency, which would result in the favorites not persisting between page navigations. It’s worth noting, however, that keeping favorites in memory isn’t ideal, but for the sake of this example, it will serve our purpose. In a real-life scenario, we would want the favorites to be persisted in an (online) <span class="No-Break">data store.</span></p>
<p>Registering <strong class="source-inline">RecipeService</strong> involves a slightly more complex process. The reason for this is that the constructor of <strong class="source-inline">RecipeService</strong> requires a <strong class="source-inline">Task</strong> property that returns a stream to a JSON file that holds all the recipe information. This is shown in the constructor <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">RecipeService</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
public RecipeService(Task&lt;Stream&gt; recipesJsonStreamTask)
{
    this.recipesJsonStreamTask = recipesJsonStreamTask;
}</pre> <p>We can’t register <strong class="source-inline">RecipeService</strong> in the same way we did with <strong class="source-inline">FavoritesService</strong> or other services we registered in earlier examples. This is because the DI container needs to know what parameter to pass to the constructor. In previous examples, it was straightforward: we just specified the concrete type that we wanted to associate with an interface or base class, or with the type itself. The container could then create an instance of the concrete class by invoking its default constructor or injecting other <span class="No-Break">resolved dependencies.</span></p>
<p>However, in the case of <strong class="source-inline">RecipeService</strong>, the required parameter for creating an instance isn’t something we plan to register, meaning it cannot be resolved by the DI container. To tackle scenarios like this, the <strong class="source-inline">AddTransient</strong>, <strong class="source-inline">AddSingleton</strong>, and <strong class="source-inline">AddScoped</strong> methods provide an overload. This overload lets us pass in a function that returns an instance of the type we want to associate with the given base type. This function is invoked every time the associated type needs to be resolved. What’s more, the function’s parameter is <strong class="source-inline">IServiceProvider</strong> itself, allowing us to resolve any additional dependencies if necessary. The following code block shows how we can register <strong class="source-inline">RecipeService</strong>, using the overloaded function, while passing in a function that creates an instance of <span class="No-Break">this class:</span></p>
<pre class="source-code">
builder.Services.AddTransient&lt;IRecipeService&gt;(
    serviceProvider =&gt; new RecipeService( FileSystem.
      OpenAppPackageFileAsync("recipedetails.json")));</pre> <p>The passed-in<a id="_idIndexMarker523"/> function will be invoked every time an object of <strong class="source-inline">IRecipeService</strong> needs to be resolved by the DI container. However, as the <strong class="source-inline">AddSingleton</strong> method was used, the function would be invoked only once. This means that in this specific use case, registering the service as a Singleton could be a sensible decision as it would ensure that the JSON file only gets read once, keeping the recipes in memory, and thereby optimizing the <span class="No-Break">application’s performance.</span></p>
<p>The same thing goes for the registration of <strong class="source-inline">RatingsService</strong>. Just like <strong class="source-inline">RecipeService</strong>, this class will also read from a local file to get the ratings. So, as before, we want to register this service using the overloaded <strong class="source-inline">AddTransient</strong> method, as <span class="No-Break">shown here:</span></p>
<pre class="source-code">
builder.Services.AddSingleton&lt;IRatingsService&gt;(
    serviceProvider =&gt; new RatingsService( FileSystem.
       OpenAppPackageFileAsync("ratings.json")));</pre> <p>Once all these services have been registered, we can go ahead and run the <em class="italic">Recipes!</em> app. Our code now leverages DI, a practice that greatly enhances the modularity and testability of our application. By injecting dependencies, we decouple concrete classes with interfaces or base classes, allowing us to change or swap underlying implementations without affecting dependent classes. In the context of the MVVM pattern, DI allows us to provide ViewModels with the necessary services to handle their tasks, such as data fetching or business logic, without hard-coding these dependencies, promoting a clean separation of concerns. Moreover, we have even taken this concept a step further by using DI to inject ViewModels directly into our views, further emphasizing the flexibility and versatility this practice provides in our app <span class="No-Break">development process.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">While we’ve primarily discussed constructor-based DI in .NET MAUI, it’s worth mentioning that in broader contexts, dependencies can also be injected via properties or methods. However, such methods are not natively supported in .NET MAUI. The essence of DI is providing the class with its dependencies, irrespective of the method. Constructor injection is often preferred for clarity, but the technique that’s used might vary based on the platform and the <span class="No-Break">design goals.</span></p>
<p>DI plays a crucial <a id="_idIndexMarker524"/>role in keeping our application’s components decoupled. Next, we’ll delve into another mechanism that promotes decoupling in <span class="No-Break">our application.</span></p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor128"/>Messaging</h1>
<p>Messaging is a <a id="_idIndexMarker525"/>software architectural pattern that facilitates communication between different parts of an application. In the context of .NET MAUI and MVVM architecture, messaging is typically used to send notifications between loosely coupled components, such as between ViewModels, or from a Model to a ViewModel. This decouples the components and promotes a more modular and maintainable <span class="No-Break">code base.</span></p>
<p>The concept of messaging is especially useful when data needs to be passed or events need to be communicated between parts of your application that do not have a direct relationship. Instead of tightly coupling these parts by having them directly call each other, you can use a messaging system where one part sends a message that any interested part of your application can receive and <span class="No-Break">react to.</span></p>
<p>This pattern is a form<a id="_idIndexMarker526"/> of the <strong class="bold">Observer</strong> pattern, where an object, named the <strong class="bold">Subject</strong>, maintains a list of its dependents, called <strong class="bold">Observers</strong>, and notifies them automatically of any state changes, typically by calling one of their methods. Similarly, in MVVM, messaging is used to communicate between decoupled components of the application: any object in your application, including a ViewModel, a service, or a model class or service can send a message, and any other class that is subscribed to that particular type of message will be <a id="_idIndexMarker527"/>notified and can <span class="No-Break">react accordingly.</span></p>
<p class="callout-heading">About MessagingCenter</p>
<p class="callout"><strong class="source-inline">MessagingCenter</strong>, originally <a id="_idIndexMarker528"/>introduced in Xamarin.Forms as a mechanism for loosely-coupled communication between components, is present but marked as obsolete in .NET MAUI. While it’s retained in .NET 8 for transition scenarios, its use <span class="No-Break">is discouraged!</span></p>
<p>Typically, in the context of MVVM, as shown in the following figure, the messaging system itself maintains a list of observers and handles passing messages from senders to <span class="No-Break">appropriate receivers:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer057">
<img alt="Figure 7.1: Messaging overview" height="568" src="image/B20941_07_01.jpg" width="1161"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1: Messaging overview</p>
<p>One notable challenge with the messaging pattern is its inherent opacity: it can be difficult to determine which parts of the application are subscribing to a particular message. This lack of transparency can lead to unforeseen side effects when altering the code and makes the code base more challenging to navigate and debug. When I do use messaging, I use it with caution. Keeping messages minimal and focused on a specific task can help mitigate this challenge. Another potential risk of using messaging is inadvertently causing memory leaks. This can occur when an object subscribes to a message but never unsubscribes. If this happens, the messaging system continues to hold a reference to the subscriber object, preventing it from being garbage collected even if there are no other references to it in the application. Over time, this can lead to increased memory usage and can eventually degrade the performance of <span class="No-Break">the application.</span></p>
<p>This issue is particularly important in the context of MVVM, where ViewModels might subscribe to messages<a id="_idIndexMarker529"/> during their initialization and then get replaced by new ViewModels as the user navigates through the application. If these ViewModels don’t unsubscribe from the messages when they’re no longer in use, they will stay in <span class="No-Break">memory indefinitely.</span></p>
<p>That’s where <strong class="source-inline">WeakReferenceMessenger</strong> <span class="No-Break">comes in.</span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor129"/>WeakReferenceMessenger</h2>
<p>The MVVM <a id="_idIndexMarker530"/>Toolkit, which we discussed earlier, provides us with a robust messenger implementation called <strong class="source-inline">WeakReferenceMessenger</strong>. Designed with MVVM applications in mind, this messenger ensures we can enjoy the benefits of messaging without worrying about potential <span class="No-Break">memory leaks.</span></p>
<p>Unlike a traditional messenger, which holds strong references to its subscribers, <strong class="source-inline">WeakReferenceMessenger</strong> holds weak references. This means it doesn’t prevent its subscribers from being garbage collected. So, even if you forget to unsubscribe, the garbage collector can still clean up your ViewModel when it’s no longer in use, preventing <span class="No-Break">memory leaks.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">In this section, we’ll be using <strong class="source-inline">WeakReferenceMessenger</strong> from the MVVM Toolkit as our messaging system. However, it’s important to note that other messaging systems are available as well. While we’re focusing on <strong class="source-inline">WeakReferenceMessenger</strong>, the core concepts we’ll be discussing here – such as sending and receiving messages – apply to most messaging systems. Always remember to study and understand the specific messaging system you’re working with to make the most of its features and avoid <span class="No-Break">potential pitfalls.</span></p>
<p><strong class="source-inline">WeakReferenceMessenger</strong> uses a type-based messaging system. This means that when you send a <a id="_idIndexMarker531"/>message, you specify a message type and only the recipients that have subscribed to that specific type will receive the message. The message type is typically defined as a class, and the message data is stored as properties of <span class="No-Break">that class.</span></p>
<p>To send a message, you must use the <strong class="source-inline">Send</strong> method, passing in the message object and, optionally, a sender and target. The messenger will then deliver the message to all the registered recipients for the specified message type. To receive messages, a class needs to register with the messenger by calling the <strong class="source-inline">Register</strong> method, specifying the message type it wishes to receive, and providing a callback method that will be invoked when a message of that type <span class="No-Break">is sent.</span></p>
<p>Let’s take a <a id="_idIndexMarker532"/>look at how we can update our code and make it more loosely coupled by <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">WeakReferenceMessenger</strong></span><span class="No-Break">.</span></p>
<h3>Updating the number of servings</h3>
<p>Through<a id="_idIndexMarker533"/> messaging, ViewModels can communicate with each other in a loosely coupled manner. As an example, let’s take a look at <strong class="source-inline">IngredientsListViewModel</strong>. When updating the value of the <strong class="source-inline">NumberOfServings</strong> property, we loop through all elements in the <strong class="source-inline">Ingredients</strong> collection (which are <strong class="source-inline">RecipeIngredientViewModel</strong> objects) and call their <strong class="source-inline">UpdateServings</strong> method, passing in the <span class="No-Break">updated value:</span></p>
<pre class="source-code">
public int NumberOfServings
{
    get =&gt; _numberOfServings;
    set
    {
        if (SetProperty(ref _numberOfServings, value))
        {
            <strong class="bold">Ingredients</strong>
<strong class="bold">                .ForEach(i =&gt; i.UpdateServings(value));</strong>
        }
    }
}</pre> <p>This approach is tightly coupled since the property knows about the implementation details of other objects, specifically <strong class="source-inline">RecipeIngredientViewModel</strong>. Also, it doesn’t adhere well to the <strong class="bold">Single Responsibility Principle</strong>: <em class="italic">the property doesn’t only concern itself; it is also responsible for updating the values of </em><span class="No-Break"><em class="italic">other properties.</em></span></p>
<p>So, let’s introduce <span class="No-Break">messaging here!</span></p>
<ul>
<li>As <strong class="source-inline">WeakReferenceMessenger</strong> is a type-based messaging system, we must create a new type that we can send and subscribe to whenever the number of servings is being updated by the user. Right-click the <strong class="bold">Recipes.Client.Core</strong> project, select <strong class="bold">Add</strong> | <strong class="bold">New Folder</strong>, and name <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">Messages</strong></span><span class="No-Break">.</span></li>
<li>Right-click the <strong class="bold">Messages</strong> folder, select <strong class="bold">Add</strong> | <strong class="bold">Class…</strong>, and name <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">ServingsChangedMessage</strong></span><span class="No-Break">.</span></li>
</ul>
<p>Although <strong class="source-inline">WeakReferenceMessenger</strong> can send messages of any type, there are some base message classes you might want to inherit from. In this case, we could inherit from the generic <strong class="source-inline">CommunityToolkit.Mvvm.Messaging.Messages.ValueChanged</strong> class because that is exactly what <strong class="source-inline">ServingsChangedMessage</strong> <span class="No-Break">is for.</span></p>
<p>The following code block shows the implementation of <span class="No-Break">this class:</span></p>
<pre class="source-code">
using CommunityToolkit.Mvvm.Messaging.Messages;
namespace Recipes.Client.Core.Messages;
public class ServingsChangedMessage :
    ValueChangedMessage&lt;int&gt;
{
    public ServingsChangedMessage(int value)
        : base(value)
    { }
}</pre> <p>We can now <a id="_idIndexMarker534"/>go ahead and update the <strong class="source-inline">NumberOfServings</strong> method on the <strong class="source-inline">IngredientsListViewModel</strong> class. Instead of looping over every item in the ingredients list and calling its <strong class="source-inline">UpdateServings</strong> method, we can now send <strong class="source-inline">ServingsChangedMessage</strong>, as <span class="No-Break">shown here:</span></p>
<pre class="source-code">
public int NumberOfServings
{
    get =&gt; _numberOfServings;
    set
    {
        if (SetProperty(ref _numberOfServings, value))
        {
            <strong class="bold">WeakReferenceMessenger.Default.Send(</strong>
<strong class="bold">                new ServingsChangedMessage(value));</strong>
        }
    }
}</pre> <p>Sending a message is as easy as calling the <strong class="source-inline">Send</strong> method on an instance of <strong class="source-inline">WeakReferenceMessenger</strong>, passing the message you want <span class="No-Break">to send.</span></p>
<p>Finally, we need to update <strong class="source-inline">RecipeIngredientViewModel</strong>. This class will need to subscribe to <strong class="source-inline">ServingsChangedMessage</strong> so that it can react to it. Registering to a type of message is done by calling the generic <strong class="source-inline">Register</strong> method on <strong class="source-inline">WeakReferenceMessenger</strong>. As a type parameter, you need to pass in the type of message you want to listen to. Here is one way to register to <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">ServingsChangedMessage</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
public RecipeIngredientViewModel(...)
{
...
    WeakReferenceMessenger.Default
    .Register&lt;ServingsChangedMessage&gt;(this, (r, m) =&gt;
    ((RecipeIngredientViewModel)r)
    .UpdateServings(m.Value));
}</pre> <p>The first parameter<a id="_idIndexMarker535"/> of the <strong class="source-inline">Register</strong> method is the recipient of the message, which in our case will be the class itself. The second parameter is the handler that gets invoked when the message is received. The first parameter of the handler is the receiver and the second one is the message itself. The passed-in receiver allows the Lambda expression to not capture <strong class="source-inline">this</strong>, which improves performance. It might also be a good idea to update the access modifier of the <strong class="source-inline">UpdateServings</strong> method to <strong class="source-inline">private</strong> as no public access to this method is <span class="No-Break">needed anymore.</span></p>
<p>With this updated implementation, the <strong class="source-inline">NumberOfServings</strong> property in <strong class="source-inline">IngredientsListViewModel</strong> no longer needs to know about the <strong class="source-inline">RecipeIngredientViewModel</strong> objects. Instead, it simply sends a message when its value changes. The <strong class="source-inline">RecipeIngredientViewModel</strong> objects, which are subscribed to these messages, can update their state accordingly. This decouples the two classes and ensures that each is only responsible for managing its own state, adhering to the single responsibility principle and separation <span class="No-Break">of concerns.</span></p>
<p>In the following <a id="_idIndexMarker536"/>example, we’ll have a look at the fact that messaging isn’t only valuable between ViewModels. A service might also send messages that ViewModels can <span class="No-Break">respond to.</span></p>
<h3>Keeping favorites in sync</h3>
<p>In the <em class="italic">Recipes!</em> app, the <strong class="source-inline">RecipesOverviewPage</strong> displays<a id="_idIndexMarker537"/> all recipes, and users can mark favorites on the <strong class="source-inline">RecipeDetailPage</strong>. However, without reloading <strong class="source-inline">RecipesOverviewPage</strong>, newly favorited recipes aren’t highlighted. Given that the recipes database isn’t frequently updated, constant page reloads would be overkill and could be bad for the <span class="No-Break">user experience.</span></p>
<p>A more efficient strategy involves using messaging. When a recipe is favorited, a message is dispatched. The individual <strong class="source-inline">RecipeListItemViewModel</strong>s contained within <strong class="source-inline">RecipesOverviewViewModel</strong> subscribe to this message, and upon receiving it, they update their favorite status in real time. This approach prevents unnecessary data fetches, thereby enhancing the app’s performance and responsiveness. Let’s see what we need to do to make <span class="No-Break">this work:</span></p>
<ol>
<li>First, let’s add a new message type. Right-click the <strong class="bold">Messages</strong> folder in the <strong class="bold">Recipes.Client.Core</strong> project, select <strong class="bold">Add</strong> | <strong class="bold">Class…</strong>, and enter <strong class="source-inline">FavoriteUpdateMessage</strong> as the <span class="No-Break">class name.</span></li>
<li>Add the following code to the <span class="No-Break"><strong class="source-inline">FavoriteUpdateMessage</strong></span><span class="No-Break"> class:</span><pre class="source-code">
public class FavoriteUpdateMessage
{
    public string RecipeId { get; }
    public bool IsFavorite { get; }
    public FavoriteUpdateMessage(string recipeId,
        bool isFavorite)
    {
        RecipeId = recipeId;
        IsFavorite = isFavorite;
    }
}</pre><p class="list-inset">This class holds two properties, <strong class="source-inline">RecipeId</strong> and <strong class="source-inline">IsFavorite</strong>, so that with this message, we can signal which recipe has been marked or removed as <span class="No-Break">a favorite.</span></p></li> <li>The following<a id="_idIndexMarker538"/> code block shows how we can send this <strong class="source-inline">FavoriteUpdateMessage</strong> from the <strong class="source-inline">FavoritesService</strong> whenever a recipe is added as <span class="No-Break">a favorite:</span><pre class="source-code">
public Task Add(string id)
{
    if(!favorites.Contains(id))
    {
        favorites.Add(id);
<strong class="bold">        WeakReferenceMessenger.Default.Send(</strong>
<strong class="bold">            new FavoriteUpdateMessage(id, true));</strong>
    }
    return Task.CompletedTask;
}</pre></li> <li>Similarly, when a recipe is removed as a favorite, a <strong class="source-inline">FavoriteUpdateMessage</strong> can be sent, as <span class="No-Break">shown here:</span><pre class="source-code">
public Task Remove(string id)
{
    if (favorites.Contains(id))
    {
        favorites.Remove(id);
        <strong class="bold">WeakReferenceMessenger.Default.Send(</strong>
<strong class="bold">            new FavoriteUpdateMessage(id, false));</strong>
    }
    return Task.CompletedTask;
}</pre></li> <li>The final step involves subscribing to this message in <strong class="source-inline">RecipeListItemViewModel</strong>. This ensures that when a <strong class="source-inline">FavoriteUpdateMessage</strong> arrives, the <strong class="source-inline">IsFavorite</strong> property can be updated accordingly. Unlike the previous example, where we defined a message handler <a id="_idIndexMarker539"/>using the <strong class="source-inline">Register</strong> method, we’ll use a different approach this time by implementing the <strong class="source-inline">IRecipient</strong> interface. Here’s how we can <span class="No-Break">do this:</span><pre class="source-code">
public class RecipeListItemViewModel :
    ObservableObject,
    <strong class="bold">IRecipient&lt;FavoriteUpdateMessage&gt;</strong>
{
...
    public RecipeListItemViewModel(...)
    {
        ...
        <strong class="bold">WeakReferenceMessenger.Default.Register(this);</strong>
    }
    <strong class="bold">void IRecipient&lt;FavoriteUpdateMessage&gt;</strong>
<strong class="bold">        .Receive(FavoriteUpdateMessage message)</strong>
    {
        if (message.RecipeId == Id)
        {
            IsFavorite = message.IsFavorite;
        }
    }
}</pre><p class="list-inset">By implementing the <strong class="source-inline">CommunityToolkit.Mvvm.Messaging.IRecipient&lt;TMessage&gt;</strong> interface, where <strong class="source-inline">TMessage</strong> is <strong class="source-inline">FavoriteUpdateMessage</strong> in this case, we’re specifying the type of message we want to handle. Implementing this interface allows us to call the <strong class="source-inline">Register</strong> method of <strong class="source-inline">WeakReferenceMessenger</strong> and pass the class itself as the only parameter. The interface requires us to implement the <strong class="source-inline">Receive</strong> method, which is invoked when a message of the specified type <span class="No-Break">is received.</span></p></li> </ol>
<p>Through the <a id="_idIndexMarker540"/>updated code, a message is dispatched whenever a user adds or removes a recipe as a favorite. Instances of <strong class="source-inline">RecipeListItemViewModel</strong> are set to listen for this message and update their <strong class="source-inline">IsFavorite</strong> property accordingly. As a result, when the user navigates back from a detail page, where the favorite status was updated, the refreshed status is immediately visible on the overview page – all without reloading <span class="No-Break">any data.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">While <strong class="source-inline">WeakReferenceMessenger</strong> provides a robust solution for many messaging scenarios, it’s important to use it with caution when dealing with a large number of listeners. Always monitor the performance and behavior of your application, especially when dispatching messages to thousands of listeners, and consider optimizing or reevaluating your design <span class="No-Break">if necessary.</span></p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor130"/>Summary</h1>
<p>In this chapter, we delved into two pivotal topics in the architecture of modern applications: DI and messaging. First, we explored DI, a technique for achieving loose coupling between objects and their dependencies. In the context of the MVVM pattern, we utilized this technique to inject services and other dependencies into our ViewModels, enhancing their testability <span class="No-Break">and maintainability.</span></p>
<p>The latter part of this chapter focused on messaging, another integral component in MVVM applications for promoting decoupled communication between components. We examined <strong class="source-inline">WeakReferenceMessenger</strong> provided by the MVVM Toolkit, which facilitates loose coupling in <span class="No-Break">the application.</span></p>
<p>In essence, this chapter aimed to reinforce the importance of loose coupling in software design, showcasing how both DI and messaging contribute significantly to the creation of maintainable and <span class="No-Break">testable applications.</span></p>
<p>In the upcoming chapter, we’ll delve deep into the intricacies of navigation in .NET MAUI and how we can integrate navigation into our <span class="No-Break">MVVM architecture.</span></p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor131"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the <span class="No-Break">following resources:</span></p>
<ul>
<li>Dependency <span class="No-Break">injection: </span><a href="https://learn.microsoft.com/dotnet/architecture/maui/dependency-injection"><span class="No-Break">https://learn.microsoft.com/dotnet/architecture/maui/dependency-injection</span></a></li>
<li>MVVM Toolkit <span class="No-Break">messenger: </span><a href="https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/messenger"><span class="No-Break">https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/messenger</span></a></li>
</ul>
</div>
</div></body></html>