- en: Tabula Rasa – Approaching an Application with TDD in Mind
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tabula Rasa – 以TDD的心态处理应用程序
- en: It might seem a daunting task to develop an entire application with **Test-Driven
    Development** (**TDD**). Until now, all of the examples have been relatively small.
    The functions and methods have had a tiny, limited scope. How does TDD translate
    when developing full-fledged applications? Quite well, actually.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一个完整的应用程序似乎是一项艰巨的任务，特别是使用**测试驱动开发**（**TDD**）。到目前为止，所有的例子都相对较小。函数和方法具有微小、有限的范围。TDD在开发完整的应用程序时是如何转换的？实际上，相当不错。
- en: 'Topics discussed in this chapter include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的主题包括：
- en: Yak shaving
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yak shaving
- en: Big design up front
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 早期大设计
- en: YAGNI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YAGNI
- en: Test small
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试要小
- en: Devil's advocate
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶魔的辩护者
- en: Where to begin
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从哪里开始
- en: The best place to begin is at the beginning. Before a developer can start coding,
    they must know what the goal of the program is. What is the purpose of the application?
    Without a clear understanding of the problem that they are attempting to solve,
    it can be difficult to get started. At the very least, it is ill-advised to begin
    without some kind of plan.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的开始方式就是从开始的地方开始。在开发者开始编码之前，他们必须知道程序的目标是什么。应用程序的目的是什么？如果没有对试图解决的问题有清晰的理解，那么开始可能会很困难。至少，在没有某种计划的情况下开始是不明智的。
- en: The sooner you start to code, the longer the program will take.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你开始编码越早，程序就会越晚完成。
- en: – Roy Carlson, University of Wisconsin
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: – 罗伊·卡尔森，威斯康星大学
- en: Have you ever started a craft project without any objective in mind? How did
    you know what it was you were making? Did the project turn out well? If it did,
    you more than likely picked a direction at some point and set out to achieve a
    goal. You may have even had to start over or make adjustments along the way in
    order to complete the project.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有在没有目标的情况下开始一个手工艺项目？你是如何知道你要做什么的？项目结果如何？如果结果不错，你很可能在某个时候选择了一个方向，并开始实现目标。你可能甚至不得不从头开始或途中进行调整，以便完成项目。
- en: Now, imagine starting the same craft project with the desired result defined
    ahead of time. Perhaps you wanted to make a drawing. Maybe you developed a set
    of plans.It isn't until a clear understanding is achieved before you start the
    physical act of beginning the project. In this example, the likelihood of success
    is much greater. The chance for stumbling blocks along the way are minimized.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下在事先定义好期望结果的情况下开始同一个手工艺项目。也许你想要画一幅画。也许你制定了一套计划。直到你开始实际开始项目的物理行动之前，你都不会有清晰的理解。在这个例子中，成功的可能性要大得多。在过程中遇到障碍的机会最小化。
- en: Does this mean that all questions need to be asked ahead of time? Should all
    answers be obtained before you begin? Certainly not. Sometimes just a cursory
    understanding of a problem is enough to get started. But, the clearer the objectives,
    the better the likelihood of developing the proper solution.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着所有问题都需要提前提出？在开始之前是否应该获得所有答案？当然不是。有时，对问题只有肤浅的了解就足以开始。但是，目标越明确，开发正确解决方案的可能性就越大。
- en: Yak shaving
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Yak shaving
- en: In the examples provided in previous chapters, you may have noticed there was
    a lot of moving around of code that didn't seem to have any immediate benefit.
    In TDD, especially at the beginning of a project, some work must be done that
    doesn't seem to make much sense. Tests are written that do nothing more than prove
    the existence of a class or method. The code is refactored in a way that only
    pushes hard-coded values into another dependency. This means that more files are
    created, and you may find yourself writing a significant amount of helper classes.
    All of these activities are referred to as yak shaving.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章提供的示例中，你可能已经注意到有很多代码的移动，这些代码似乎没有立即的益处。在TDD中，尤其是在项目的初期，有些工作看起来似乎没有太多意义。编写的测试除了证明类或方法的存在之外，没有做更多的事情。代码重构的方式只是将硬编码的值推入另一个依赖项。这意味着会创建更多的文件，你可能会发现自己正在编写大量的辅助类。所有这些活动都被称为“剃羊毛”。
- en: Yak shaving has two meanings that pertain to software development. The first
    and the one to be avoided is writing things that aren't needed as a means of procrastination.
    The second is the act of doing all the things that must be done to prepare the
    code. The difference between the two is a fine line. The side of the line you
    are on is determined by your intent in writing your code. Are you avoiding the
    code that you should be writing or are you laying the groundwork for efficient
    and effective software development using TDD?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: “剃羊毛”有两个与软件开发相关的含义。第一个也是需要避免的是，为了拖延而编写不需要的东西。第二个是指完成所有必须做的事情来准备代码的行为。两者之间的区别是细微的。你站在哪一边取决于你编写代码的意图。你是避免编写应该写的代码，还是使用TDD来为高效和有效的软件开发打下基础？
- en: In our case, as discussed in earlier chapters, we are either laying the groundwork
    for future tests, or we are implementing a known technique for preventing writer's
    block in our tests. Sometimes, the process of preparing an application for being
    tested can take quite a while.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，正如前面章节所讨论的，我们要么在为未来的测试打下基础，要么在测试中实施防止写作障碍的已知技术。有时，为测试准备应用程序的过程可能需要相当长的时间。
- en: When working in a legacy application, you could spend the better part of a week
    simply creating factories, adding interfaces to existing classes, writing test
    doubles, or doing safe refactoring techniques. All of these activities can help
    to improve testability and ensure a smooth testing experience. It is important
    to avoid getting carried away with these activities though.  We only want to do
    them as a means of driving the next test forward.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当在遗留应用程序中工作时，你可能需要花费一周的大部分时间来创建工厂、向现有类添加接口、编写测试替身或进行安全的重构技术。所有这些活动都有助于提高可测试性和确保测试体验的顺畅。然而，避免沉迷于这些活动是很重要的。我们只想通过这些活动来推动下一个测试的进行。
- en: Big design up front
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大规模设计
- en: It used to be common practice to have a lengthy, and expensive, **Software Development
    Life Cycle** (**SDLC**). Large teams were assembled. Meetings were scheduled and
    discussions had, ad nauseam. Requirements were gathered and documents were created
    which consumed reams of paper that would fill the filing cabinets of each and
    every team member. A design for the system would often be democratically assembled
    and a plan laid out for the system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，拥有一个漫长且昂贵的**软件开发生命周期**（**SDLC**）是一种常见的做法。组建了大型团队。会议被安排，讨论无休止地进行。收集需求并创建文档，这些文档消耗了大量的纸张，足以填满每个团队成员的档案柜。系统的设计通常是通过民主方式组装的，并为系统制定了一个计划。
- en: Once management and/or executive teams were satisfied, development could start.
    This long and cumbersome process often meant that budgets had already been significantly
    depleted with the cost of everyone’s time in the planning stages. If for some
    reason, a flaw in the design was discovered during the development cycle, change
    orders and a slew of meetings would often occur.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦管理层和/或执行团队满意，开发就可以开始了。这个漫长而繁琐的过程通常意味着预算已经因为规划阶段的每个人时间成本而大幅减少。如果在开发周期中发现设计中的缺陷，通常会发出变更订单和一系列会议。
- en: Should the requirements change due to a change in markets or other external
    conditions it could potentially derail an entire program. If the SDLC did not
    allow for quick adaptation to change and rapid course correction, it would often
    spell doom for the entire project. Worse, if the change were significant enough
    it could render the need for the application obsolete.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于市场变化或其他外部条件的变化而导致需求发生变化，这可能会使整个项目偏离轨道。如果软件开发生命周期（SDLC）不允许快速适应变化和快速调整方向，那么这通常会给整个项目带来灾难。更糟糕的是，如果变化足够大，它可能会使应用程序的需求变得过时。
- en: Unfortunately, developing software in this manner was quite costly and would
    end in failure more often than success. The cost of change was too great and the
    resulting disruption was often detrimental to the process. These days software
    projects are more likely to be developed in some sort of Agile fashion.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，以这种方式开发软件成本很高，而且失败的可能性比成功要大。变化的成本太高，由此产生的干扰往往对过程有害。如今，软件项目更有可能以某种敏捷的方式进行开发。
- en: A clean slate
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一张干净的画布
- en: So where do we begin a new application with TDD? Starting with TDD in mind is
    really no different from beginning any software development project. A developer
    must have some idea as to the goal of the application. The basic requirements
    should be understood. Just as we grow our application with tests, the requirements
    should grow with time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何使用TDD开始一个新的应用？带着TDD的想法开始实际上与开始任何软件开发项目没有太大区别。开发者必须对应用的目标有一个大致的了解。基本需求应该被理解。就像我们通过测试来扩展应用一样，需求应该随着时间的推移而增长。
- en: One bite at a time
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一口一口吃
- en: How do you eat an elephant? One bite at a time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你怎么吃大象？一口一口吃。
- en: It is a massive undertaking to try to define and develop a monolithic application
    all at once. If you were tasked with creating Facebook you might not know where
    to begin. But, if you break the application down into logical portions such as
    *Login*, *User Dashboard*, and *News Feed*, it becomes much more manageable.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一次性定义和开发一个单体应用是一项庞大的任务。如果你被分配去创建Facebook，你可能不知道从哪里开始。但是，如果你将应用分解为逻辑部分，例如*登录*、*用户仪表板*和*新闻源*，它就会变得更容易管理。
- en: Minimum Viable Product
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小可行产品
- en: Each definition of work should be broken down into small deliverables. The concept
    of a **Minimum Viable Product** can apply to all aspects of our code. As the requirements
    for the monolithic application are broken down into manageable chunks, it might
    be possible to start coding. If a programming task is small enough to take only
    a couple of hours to complete, it's quite difficult to deliver something that
    wildly misses the mark.  However, if a change is required, feedback should be
    given, and adjustments can be made quickly.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个工作定义都应该分解成小的可交付成果。**最小可行产品**的概念可以应用到我们代码的各个方面。随着单体应用的需求被分解成可管理的块，可能开始编码。如果一个编程任务只需要几个小时就能完成，那么很难交付一个完全偏离目标的东西。然而，如果需要变更，应该提供反馈，并且可以快速进行调整。
- en: Different mindset
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的思维方式
- en: As an application is being developed with a view towards TDD, you should take
    the same approach to small deliverables. Write a little test, write just enough
    code to make it pass, then refactor. If you're constantly running your test suite,
    or better yet, you are using a continuous test runner such as NCrunch, your feedback
    cycles should be quite quick indeed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用以TDD为导向进行开发时，你应该对小的可交付成果采取同样的方法。写一点测试，写足够的代码使其通过，然后重构。如果你一直在运行测试套件，或者更好的是，你正在使用像NCrunch这样的持续测试运行器，你的反馈周期确实应该非常快。
- en: Never leave an ignored test, or ignore more than one test at a time.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要留下未关注的测试，或者一次不要忽略超过一个测试。
- en: If a test begins to fail during the development cycle it should be easy to recover.
    The code just written must be at fault. Pause the current effort and evaluate.
    Is the change necessary? Does the failing test need to change? *Skip* (xUnit)
    or *Ignore* (MSTest) your current test, if needed. Fix the code and resume by
    un-ignoring your test. Never leave an ignored test, or ignore more than one test
    at a time. Doing so will only risk the test (or worse, tests) never being completed,
    fixed, or recovered. An ignored test has no value. If a test is un-ignored at
    a later date by you or someone else and is now (or still) failing, it may be difficult
    to determine if the test is valid and indicates a true failure, or invalid and
    possibly sending you on a wild goose chase. Make sure your tests are valid, accurate,
    and provide value.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在开发周期中测试开始失败，应该很容易恢复。刚刚编写的代码就是问题所在。暂停当前的工作并评估。这个变更是否必要？失败的测试是否需要更改？如果需要，可以*跳过*（xUnit）或*忽略*（MSTest）当前的测试。修复代码，然后通过取消忽略测试来继续。永远不要留下未关注的测试，或者一次不要忽略超过一个测试。这样做只会增加测试（或者更糟，多个测试）永远不会完成、修复或恢复的风险。一个被忽略的测试没有任何价值。如果测试在以后被你或其他人取消忽略，并且现在（或仍然）失败，可能很难确定测试是否有效并指示真正的失败，或者无效并可能让你走上歧途。确保你的测试是有效、准确并提供价值的。
- en: YAGNI – you aren't gonna need it
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: YAGNI - 你不需要它
- en: 'At times, you might be compelled to write some code because you think you''ll
    need it. It''s just a simple method. If you have a table full of data you''ll
    probably need a `GetAll` method and a `GetById` method. A word of caution here:
    don''t write any code until you have a true need for it. The more code that is
    written, the more code needs to be maintained. If you write code that you think
    you might need, but never actually use, you''ve wasted effort. Worse yet, you''ve
    introduced code that must be maintained until or unless it is removed.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能会被迫编写一些代码，因为你认为你需要它。这只是一个简单的方法。如果你有一张满载数据的数据表，你可能需要一个`GetAll`方法和一个`GetById`方法。在这里提醒一下：在没有真正需求之前，不要编写任何代码。编写的代码越多，需要维护的代码就越多。如果你编写了你认为可能需要但从未实际使用的代码，你就浪费了努力。更糟糕的是，你引入了必须维护直到或除非它被删除的代码。
- en: Don't write code in anticipation of a future need. This is wasteful and often
    costly to develop and maintain.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 不要为了未来的需求而编写代码。这是浪费的，并且通常开发和维护成本高昂。
- en: Test small
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试小规模
- en: One of the most important things to consider when doing TDD is the size and
    scope of your tests. TDD is an exercise in fully understanding the problem you
    are trying to solve and being able to break the solution up into as many tiny
    little pieces as possible.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行TDD时，要考虑的最重要的事情之一是测试的大小和范围。TDD是一项完全理解你试图解决的问题的练习，并且能够尽可能地将解决方案分解成尽可能多的微小部分。
- en: 'As an example, let us consider something simple: an application to manage a
    list of items that need to be done. How can we break up the use cases for this
    application?'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，让我们考虑一些简单的事情：一个管理需要完成的项目列表的应用程序。我们如何将这个应用程序的使用案例分解？
- en: First, using what we discussed with yak shaving, we can verify that the application
    even exists.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用我们讨论的剃羊毛方法，我们可以验证应用程序是否存在。
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, verify that you are able to retrieve a listing of items to be done.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，验证你是否能够检索待办事项的列表。
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Devil's advocate
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 魔鬼的代言人
- en: We will continue to demonstrate testing small, but already we have hit our next
    example. Playing devil's advocate is a useful technique in many circumstances.
    The way that we play devil's advocate in TDD is by imagining the simplest, and
    possibly most erroneous, approach to making the test pass. We want to force the
    test to make the code right instead of writing the code that we believe to be
    correct. For instance, in this case the desire is to make the test that was just
    written pass by adding an *Items* list. But the test doesn't require that at this
    point. It only requires that Items exists as a property on the class. There is
    no designation of a type in the test. So, to play devil's advocate, make the test
    pass by using *Object* as the type and setting the `Items` object to a simple
    non-null value.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续展示小规模的测试，但已经触及了下一个例子。在许多情况下，充当魔鬼的代言人是一种有用的技巧。在TDD中，我们通过想象使测试通过的最简单、可能也是最错误的方法来充当魔鬼的代言人。我们希望迫使测试使代码正确，而不是编写我们认为正确的代码。例如，在这种情况下，我们的目标是使刚刚编写的测试通过添加一个*Items*列表。但在这个阶段，测试并不需要这一点。它只要求Items作为类的一个属性存在。测试中没有指定类型。因此，为了充当魔鬼的代言人，使用*Object*作为类型，并将`Items`对象设置为简单的非空值。
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Okay, now all the tests pass but that clearly isn''t a proper solution. Thinking
    small steps, we could force the implementation to have a count, surely that will
    require it to be a list of *Todos*. Add the following to the last test:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在所有测试都通过了，但这显然不是一个合适的解决方案。从小处着手，我们可以迫使实现有一个计数，这肯定需要它是一个*Todos*列表的集合。在最后一个测试中添加以下内容：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To make that pass, `Items` must change:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使它通过，`Items`必须改变：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Remember what we discussed about the SOLID principles in [Chapter 4](part0142.html#47DFS0-d186949d2da74f5c95dd1712efae1195),
    *What to Know Before Getting Started*. We want to use interface segregation and
    limit ourselves only to the interface we need. We don't need the full `IList`
    interfaces capability so we don't need to use it. All that is needed is the ability
    to iterate over a collection of items. The simplest interface for doing this is
    `IEnumerable`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们在[第4章](part0142.html#47DFS0-d186949d2da74f5c95dd1712efae1195)“开始之前要知道什么”中讨论的SOLID原则。我们希望使用接口隔离，并限制自己只使用所需的接口。我们不需要完整的`IList`接口功能，因此不需要使用它。所需的是能够遍历项目集合的能力。为此，最简单的接口是`IEnumerable`。
- en: 'We still have a problem though: we are using an `Object` as our enumerable
    type. We want to use only a specific class. Let''s fix that now. Modify the last
    test one more time to include a type assertion.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然有一个问题：我们正在使用`Object`作为我们的可枚举类型。我们只想使用一个特定的类。现在让我们解决这个问题。修改最后一个测试，包括一个类型断言。
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, update the class, shown as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更新类，如下所示：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we added what seemed to be a fairly small test and ended up
    creating a property, assigning a default value, and creating a class. Can you
    think of any way we could have made this smaller?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们添加了一个看似相当小的测试，最终创建了一个属性，分配了一个默认值，并创建了一个类。你能想到任何方法可以使这个更小吗？
- en: Our next test might verify that the Todo items start as empty, but if we think
    back to the laws of TDD, the first law is to write a failing test. Right now,
    if we wrote a test that verified `Items` to be empty we would expect that test
    to pass. So, what test should we write?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的测试可能将验证待办事项项开始时是空的，但如果我们回顾TDD（测试驱动开发）的法则，第一条法则是编写一个失败的测试。目前，如果我们编写一个验证`Items`为空的测试，我们会期望这个测试通过。那么，我们应该编写什么样的测试呢？
- en: The test we have decided to write next is a test to verify a means to add a
    Todo item.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定编写下一个测试，以验证添加待办事项项的方法。
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Up to this point, we have been taking steps that would likely resemble the same
    steps you would take in normal development, cutting giant swathes of functionality
    into the code. This is the first test where we stop before we have actually achieved
    valuable functionality. This is part of taking those small steps though. We could
    deploy the application right now. It wouldn't be very useful but we do have that
    option. If we had reached the end of our sprint, the product owner might request
    that, in order to deploy as soon as possible, we hard-code in some Todo items
    just so something is available in the UI.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在采取一些可能与你正常开发中采取的步骤相似的步骤，将大量功能切割到代码中。这是第一个在我们真正实现有价值功能之前就停止的测试。这是采取那些小步骤的一部分。我们目前可以部署这个应用。它不会很有用，但我们确实有这个选项。如果我们已经到达了冲刺的终点，产品负责人可能会要求为了尽快部署，我们硬编码一些待办事项，以便在UI中提供一些内容。
- en: Our next test seems to be fairly straightforward. We will verify that we can
    actually add a Todo using our new method. There is a catch though because this
    test is testing functionality and not general class structure. We suggest having
    a test class specifically for this method.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的测试看起来相当直接。我们将验证我们是否真的可以使用我们的新方法添加一个待办事项。但是有一个问题，因为这个测试是在测试功能而不是通用类结构。我们建议为这个方法创建一个专门的测试类。
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, that really was a flying leap off a cliff. That one test nearly changed
    all of our application code. We just completely changed the implementation of
    `Items`, and we added code to the `AddTodo` method. Is there a way that we could
    have broken those into two or more steps? We still have a lot to do with this
    application, and we will cover some of it. But, before we go on, write down the
    next few tests that you think you would write. Try not to skip this exercise because
    breaking up functionality into small chunks like this is one of the areas where
    most developers struggle when learning TDD.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这真是一个从悬崖上飞扑下来的跳跃。那个测试几乎改变了我们应用的所有代码。我们完全改变了`Items`的实现，并在`AddTodo`方法中添加了代码。我们能否将这些分成两个或更多步骤？我们还有许多事情要做，我们将会覆盖其中的一些。但在我们继续之前，写下你认为你会编写的下一个几个测试。尽量别跳过这个练习，因为将功能分解成这样的小块是大多数开发者学习TDD时遇到的最大难题之一。
- en: We are going to temporarily pause the forward progress of this sample application
    because we have already begun to work ourselves into a corner. To prevent getting
    blocked, we should be testing negative cases first.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将暂时暂停这个示例应用的进度，因为我们已经陷入了一个困境。为了防止受阻，我们应该首先测试负案例。
- en: Test negative cases first
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首先测试负案例
- en: What does it mean to test negative cases first? In many computer games, especially
    role-playing games, it is common for the game designers to make it very difficult
    to win the game if you simply go straight to the boss. Instead, you must make
    side quests, make wrong turns, and get lost in the story before you can fight
    the boss. Testing is no different. Before the problem can be solved, we must first
    handle bad input, prevent exceptions, and resolve conflicts in the business requirements.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要测试负案例意味着什么？在许多电脑游戏中，尤其是在角色扮演游戏中，游戏设计师通常会设计得非常困难，如果你直接去挑战Boss，就很难赢得游戏。相反，你必须完成支线任务，走错路，在故事中迷失方向，才能与Boss战斗。测试也是如此。在问题得到解决之前，我们必须首先处理不良输入，防止异常，并解决业务需求中的冲突。
- en: In the Todo application, we mistakenly flew through and added an item to the
    Todo list without verifying that the item was valid. Now, the sprint is over and
    our user interface developers are mad at us because they do not know what to do
    with a Todo item that has no details at all. What we should have done is handle
    the cases where we receive bad data first. Let's rewind and temporarily skip the
    test we just made.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在Todo应用程序中，我们错误地快速通过了添加一个项目到Todo列表，而没有验证该项目是否有效。现在，冲刺已经结束，我们的用户界面开发者对我们很生气，因为他们不知道如何处理一个没有任何详细信息的Todo项目。我们应该做的首先是处理我们收到的不良数据的情况。让我们回放并暂时跳过我们刚刚制作的测试。
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The test we need to write now should go above the test that was just ignored,
    but in the same file. Remembering that we need to have small test increments,
    we can write a test that guards against the simplest bad data, `null`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要编写的测试应该放在刚刚忽略的测试之上，但仍在同一个文件中。记住我们需要有小的测试增量，我们可以编写一个测试来防止最简单的坏数据，即`null`。
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that we have removed the code that was in place for `AddTodo`. We could
    have left the code in place, but at this point it is clutter and there is currently
    no test that forces that code to be present. Sometimes, when you ignore a test,
    it is easier to remove the functionality that test was verifying instead of working
    around the functionality. There are times when the clutter could restrict your
    refactoring efforts and could result in worse code. Don't be afraid to delete
    code for tests that are being skipped, and don't be afraid to delete skipped tests
    that make their way into source control.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经移除了`AddTodo`中现有的代码。我们本可以保留这些代码，但在这个阶段，它们只是杂乱无章，而且目前没有测试强制要求这些代码存在。有时，当你忽略一个测试时，删除该测试所验证的功能性代码比绕过它更容易。有时，杂乱无章可能会限制你的重构努力，并导致更糟糕的代码。不要害怕删除被跳过的测试代码，也不要害怕删除进入源代码控制中的被跳过的测试。
- en: One other issue that we encountered when making this change is that the `AddTodoExists`
    method defined earlier in the `TodoApplicationTests` class is now failing. This
    test was a yak shaving test to start with and does not add any real value to the
    test suite, so just remove it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这个更改时，我们遇到的一个其他问题是，之前在`TodoApplicationTests`类中定义的`AddTodoExists`方法现在失败了。这个测试最初是一个剃须测试，并没有给测试套件增加任何真正的价值，所以直接移除它。
- en: Now that we have the null case covered by our method, what is the next thing
    that could go wrong? Thinking about it, are there any required fields for a Todo?
    We should probably make sure the Todo has a title or description at least before
    we add it to the list.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经用我们的方法覆盖了空值情况，接下来可能出错的是什么？思考一下，Todo是否需要必填字段？在我们将其添加到列表之前，我们可能需要确保Todo至少有一个标题或描述。
- en: First, before we can verify that the field has been populated, we need to verify
    that the field exists on the model. Writing model tests might seem a bit like
    overkill to you, but we find that having these tests helps to better define the
    application for others coming into it. They also provide a good attachment point
    for field validation tests later on when your business decides that the description
    field of a Todo has a maximum length of 255 characters. Let's create a new class
    for the Todo model tests.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们能够验证字段已被填充之前，我们需要验证该字段存在于模型上。编写模型测试可能看起来有点过度，但我们发现这些测试有助于更好地定义应用程序，供其他人进入。它们还提供了一个良好的附加点，用于稍后当业务决定Todo的描述字段最大长度为255个字符时的字段验证测试。让我们为Todo模型测试创建一个新的类。
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, there is no real assert for this type of test. Simply verifying
    that we can set the description value without throwing an error will suffice.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这类测试没有真正的断言。只需验证我们能否设置描述值而不抛出错误就足够了。
- en: Now that we have a description field, we can verify that it is required.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了描述字段，我们可以验证它是必需的。
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We are long overdue for some refactoring and this is a good place to pause our
    testing efforts and refactor. We would like to move the model validation into
    the model. Let's create a quick test for a validation method on the Todo model
    and then move that logic into the `Todo` class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经很久没有重构了，这是一个暂停我们的测试工作并进行重构的好地方。我们希望将模型验证移动到模型中。让我们为待办模型上的验证方法创建一个快速测试，然后将该逻辑移动到`Todo`类中。
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, at least for the moment, we want to move our validation logic over from
    the Todo list into the model. In creating the validation test and moving the logic,
    we have caused our yak shaving test to fail. The test is failing because, although
    the required method exists, it is throwing an exception because we have not populated
    the description of our Todo. We will have to remove this test as it no longer
    adds value.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，至少目前，我们想把我们的验证逻辑从待办事项列表移动到模型中。在创建验证测试和移动逻辑的过程中，我们导致我们的剃羊毛测试失败。测试失败是因为，尽管存在必需的方法，但它抛出了异常，因为我们没有填充我们的待办事项的描述。我们将不得不移除这个测试，因为它不再增加价值。
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Finally, the tests we needed to write before we could make the refactoring change
    we wanted to make are complete. Now we can simply replace the exception logic
    dealing with model validation in the `TodoList` class with a call to `Validate`
    on the model.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在进行我们想要的重构更改之前需要编写的测试已经完成。现在我们可以简单地用对模型上的`Validate`的调用替换`TodoList`类中处理模型验证的异常逻辑。
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This change should have no effect on our tests or our resulting logic. We are
    simply relocating the validation code. There are many more validations that could
    happen. Can you think of a few that might be valuable?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改对我们的测试或我们的结果逻辑不应有任何影响。我们只是在重新定位验证代码。可能还有更多的验证可以发生。你能想到一些可能很有价值的验证吗？
- en: It is now time to add back in our skipped test, with some minor modifications
    to pass validation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候添加回我们跳过的测试，并进行一些小的修改以通过验证。
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When testing is painful
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当测试变得痛苦时
- en: There may come a time when you may encounter some pain. Perhaps you've forced
    yourself into a corner with your design. Maybe you're unsure what the next, most
    interesting test would be. Sure, you didn't mean to, but conceivably you could
    have taken too great a leap between tests. Whatever the case may be, there may
    come a time when testing becomes painful.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能你可能会遇到一些痛苦。也许你因为你的设计而把自己逼到了角落。也许你不确定下一个最有趣的测试会是什么。当然，你并不是故意的，但可能你在测试之间跳得太大了。无论情况如何，可能有一段时间，测试会变得痛苦。
- en: A spike
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个尖峰
- en: If you find that you're stuck or you're debating between options on how to proceed,
    it might be beneficial to run a spike. A spike is a means with which you can investigate
    an idea. Give yourself a time-limit or some other limiting metric. Once sufficient
    knowledge or insight has been gained by the exercise, throw away the results.
    The purpose of the spike is not to walk away with working code. The goal should
    be to gain understanding and provide a better idea of a path forward.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己陷入了困境，或者在你如何继续前进的选项之间犹豫不决，运行一个尖峰可能会有所帮助。尖峰是一种你可以用来调查想法的手段。给自己设定一个时间限制或其他限制性指标。一旦通过练习获得了足够的知识或洞察力，就丢弃结果。尖峰的目的不是带走可工作的代码。目标应该是获得理解，并为前进的道路提供一个更好的想法。
- en: Assert first
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首先断言
- en: At times, you may know the next test you want to write without being quite sure
    how to start. If this happens, start with *Assert* to determine the expected result.
    With the expectation defined, set out to make the actual value match the expected
    value. You might want to take this approach more often to assure that you’re only
    writing enough code to make the desired test pass.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能知道你想要编写的下一个测试，但并不完全确定如何开始。如果发生这种情况，从*断言*开始，以确定预期的结果。一旦定义了期望，就着手使实际值与期望值相匹配。你可能更愿意经常采取这种方法，以确保你只编写足够的代码来使所需的测试通过。
- en: Stay organized
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持组织
- en: Remember, tests are the first consumer of your application. The best and most
    accurate documentation you can provide is a thorough and well-maintained set of
    tests. Within your test suite, create folders, nested classes, or utilize features
    of your test framework to make your tests more readable. Remember, if you do encounter
    a test failure at a later date, a descriptive test name and proper assertion will
    go a long way in describing how the result came to be.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，测试是应用程序的第一个消费者。你可以提供的最好和最准确的文档是一套全面且维护良好的测试。在你的测试套件中，创建文件夹、嵌套类或利用测试框架的功能来使你的测试更易于阅读。记住，如果你在以后遇到测试失败，一个描述性的测试名称和适当的断言将有助于描述结果是如何产生的。
- en: Use `Describe` to better organize your JavaScript tests. Nest multiple levels
    by using more than one `Describe` within your tests.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Describe`来更好地组织你的JavaScript测试。通过在测试中使用多个`Describe`来嵌套多个层级。
- en: Breaking down Speaker Meet
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解构Speaker Meet
- en: 'The Speaker Meet application started with a simple goal: connecting technology
    speakers, communities, and conferences. The idea was simple but could evolve into
    broad complexity. It was decided at an early stage to start small and add features
    if and when it made sense. New ideas should be able to be implemented and tested
    with little effort. If an idea turned out to be the wrong direction for the site,
    the new functionality could easily be removed and abandoned. Start simply and
    release small features for quick feedback.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Speaker Meet应用始于一个简单的目标：连接技术演讲者、社区和会议。这个想法很简单，但可能会演变成广泛的复杂性。在早期阶段，决定从小处着手，并在有需要时添加功能。新想法应该能够以最小的努力实现和测试。如果一个想法被证明是网站错误的方向，新的功能可以轻松删除并放弃。简单开始，快速发布小功能以获取反馈。
- en: Three main sections of the initial site were defined as *Speakers*, *Communities*,
    and *Conferences*. Each would need to have a listing of all speakers/communities/conferences,
    provide a way to view details about a selected item, and provide a way to search
    items based on a predefined set of criteria. This would be the Minimum Viable
    Product for the initial release.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 初始网站定义了三个主要部分：*演讲者*、*社区*和*会议*。每个部分都需要列出所有演讲者/社区/会议，提供查看选定项目详细信息的方式，并提供基于预定义标准搜索项目的方式。这将是初始发布的最小可行产品。
- en: Speakers
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演讲者
- en: In the beginning, it was decided that speakers would be the initial focus. Speakers
    would contain a name, email address, technology selections, and location. *Gravatar*
    would be used to provide an avatar. Future enhancements that were excluded from
    the Minimum Viable Product include a list of talks, travel distance, and ratings.
    By focusing on this limited functionality, initial feedback can be collected and
    future effort can be directed appropriately.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在一开始，决定演讲者将是首要的关注点。演讲者将包含姓名、电子邮件地址、技术选择和位置。*Gravatar*将用于提供头像。未来不包括在最小可行产品中的增强功能包括演讲列表、旅行距离和评分。通过关注这一有限的功能，可以收集初始反馈，并将未来的努力适当引导。
- en: Communities
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 社区
- en: The secondary focus of the Speaker Meet application revolved around technology
    communities. Meetups and user groups are typically run by dedicated volunteers
    that are always looking for new and interesting speakers for their meetings. The
    main goal of the community section of the website is to define a name, location,
    meeting day/times, and technology selections of member communities.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Speaker Meet应用次要的关注点围绕在技术社区。Meetup和用户组通常由专门的志愿者运营，他们总是在寻找新的和有趣的演讲者来参加他们的会议。网站社区部分的主要目标是定义成员社区的名字、位置、会议日期/时间以及技术选择。
- en: Conferences
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会议
- en: Technology conferences are the third and final focus of the Speaker Meet site.
    Conferences have similar requirements to communities, in that they require a name,
    location, dates, and technology selections. They differ primarily in size, scope,
    and dates. User groups typically will have one meeting per month where one speaker
    may present to a small crowd. Conferences typically occur once a year, from one
    to many days, with many speakers presenting to many more attendees.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 技术会议是Speaker Meet网站的第三和最后一个关注点。会议在要求上与社区相似，即它们需要名称、位置、日期和技术选择。它们主要在规模、范围和日期上有所不同。用户组通常每月举行一次会议，一位演讲者可能向一小群人发表演讲。会议通常每年举行一次，持续一到多天，有多个演讲者向更多的参与者发表演讲。
- en: Technical requirements
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The technologies to be used for this project were decided early on, based on
    the knowledge and experience of the team. JavaScript and ReactJS were to be utilized
    for the front-end website. The back-end would utilize C# and WebAPI with .NET
    Core, Entity Framework, and SQL Server. All would be hosted in Azure. Knowing
    these technical requirements before coding starts goes long way towards defining
    parts of your system.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的技术选择是在团队的知识和经验基础上早期决定的。前端网站将使用JavaScript和ReactJS。后端将使用C#和WebAPI，以及.NET
    Core、Entity Framework和SQL Server。所有这些都将托管在Azure上。在编码开始之前就了解这些技术需求对于定义你的系统部分大有裨益。
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Now, you should have a basic understanding of Yak shaving and how it might help
    you get started. You've been cautioned about *Big design up front* and creating
    things that you might not need in anticipation of a time when they might be needed
    (YAGNI). Be sure to test small, play devil's advocate, and test negative cases.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该对Yak shaving（剃牛毛）及其如何帮助你开始有所了解。你已经被告诫要避免*前期大设计*和为了可能需要某个功能而提前创建可能不需要的东西（YAGNI）。确保测试小部分，扮演魔鬼的代言人，并测试负面情况。
- en: In [Chapter 6](part0205.html#63G3A0-d186949d2da74f5c95dd1712efae1195), *Approaching
    the Problem*, the three sections of the Speaker Meet site will be discussed in
    much greater detail. More effort will be put into breaking down these initial
    statements into meaningful requirements and manageable units of work.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](part0205.html#63G3A0-d186949d2da74f5c95dd1712efae1195)“解决问题”中，将更详细地讨论演讲者见面网站的三个部分。将投入更多努力将这些初始声明分解成有意义的需求和可管理的作业单元。
