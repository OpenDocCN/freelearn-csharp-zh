- en: Building the Initial Framework – Laying the Foundation of the Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建初始框架 – 为应用程序奠定基础
- en: In the last chapter, we talked about REST, its characteristics, and how it is
    implemented in ASP.NET Core. We will go ahead with that knowledge and set up the
    environment to develop an application in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了 REST，它的特性以及如何在 ASP.NET Core 中实现它。我们将在此基础上继续，并在本章中设置环境以开发应用程序。
- en: We will start building the basic framework of the app. We will understand each
    and every HTTP verb, how they work, and their implementation paradigms in ASP.NET
    Core Web API. Before all that, we will have a quick look at SOAP and how it is
    different from REST.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始构建应用程序的基本框架。我们将了解每个 HTTP 动词，它们是如何工作的，以及它们在 ASP.NET Core Web API 中的实现范例。在所有这些之前，我们将快速查看
    SOAP 以及它与 REST 的不同之处。
- en: While we walk though the verbs, we will explore a very easy-to-use tool to analyze
    the HTTP requests and responses.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遍历动词时，我们将探索一个非常易于使用的工具来分析 HTTP 请求和响应。
- en: 'We will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: All about web services (REST and SOAP)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于所有网络服务（REST 和 SOAP）的内容
- en: Running the development server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行开发服务器
- en: REST verbs and status codes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST 动词和状态码
- en: Implementation of verbs in ASP.NET Core Web API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core Web API 中实现动词
- en: Examples using Postman
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Postman 的示例
- en: SOAP versus REST
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOAP 与 REST
- en: Single-page application model with REST API
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 REST API 的单页应用程序模型
- en: Service-oriented architecture (SOA) overview with REST
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 REST 的面向服务架构 (SOA) 概述
- en: SOAP
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOAP
- en: '**Simple Object Access Protocol** (**SOAP**) is an XML-based messaging protocol
    for exchanging information among computers. SOAP relies on application layer protocols,
    most often **Hypertext Transfer Protocol** (**HTTP**) or **Simple Mail Transfer
    Protocol** (**SMTP**), for message negotiation and transmission. As we are talking
    about HTTP, which is installed and runs on every operating system, web services
    implementing SOAP can be called from any platform using any language.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单对象访问协议**（**SOAP**）是一种基于 XML 的消息协议，用于在计算机之间交换信息。SOAP 依赖于应用层协议，通常是 **超文本传输协议**（**HTTP**）或
    **简单邮件传输协议**（**SMTP**），用于消息协商和传输。由于我们正在讨论 HTTP，它是安装在每台操作系统上并运行的，因此实现 SOAP 的网络服务可以从任何平台使用任何语言调用。'
- en: SOAP structure
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOAP 结构
- en: 'We already know that a SOAP message is an XML document, but let''s have a better
    look by way of a diagram:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道 SOAP 消息是一个 XML 文档，但让我们通过图表更好地了解它：
- en: '![](img/ad718f4f-5d99-4e2e-893e-eb665dc02a08.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad718f4f-5d99-4e2e-893e-eb665dc02a08.png)'
- en: 'The following is a description of the components from the preceding diagram:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面图表中组件的描述：
- en: '**Envelope**: Mandatory element of SOAP message structure. Defines the start
    and the end of the message.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信封**：SOAP 消息结构的必需元素。定义消息的开始和结束。'
- en: '**Header**: Optional element of the SOAP message. It contains information regarding
    the SOAP message that can be used to process the data.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部**：SOAP 消息的可选元素。它包含有关 SOAP 消息的信息，可用于处理数据。'
- en: '**Body**: This is the main part, which contains the actual message in XML structure.
    Obviously, it is a mandatory element.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正文**：这是主要内容，它包含实际的 XML 结构中的消息。显然，这是一个必需的元素。'
- en: '**Fault**: If any errors occur while processing the SOAP message, an optional
    Fault element can be used to provide information about them.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误**：如果在处理 SOAP 消息时发生任何错误，可以使用可选的 Fault 元素来提供有关这些错误的信息。'
- en: You must be thinking who exactly told us to follow this type of structure. Well,
    there is an organization named W3 that proposes standards for particular technologies.
    They have done the same for the SOAP structure.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道是谁确切地告诉我们遵循这种结构。好吧，有一个名为 W3 的组织为特定技术提出标准。他们为 SOAP 结构做了同样的事情。
- en: You can easily find details about the SOAP envelope at [http://www.w3.org/2001/12/soap-envelope](http://www.w3.org/2001/12/soap-envelope).
    Likewise, you can see details about SOAP encoding and data types at [http://www.w3.org/2001/12/soap-encoding](http://www.w3.org/2001/12/soap-encoding).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以轻松地在 [http://www.w3.org/2001/12/soap-envelope](http://www.w3.org/2001/12/soap-envelope)
    上找到有关 SOAP 封装的详细信息。同样，您可以在 [http://www.w3.org/2001/12/soap-encoding](http://www.w3.org/2001/12/soap-encoding)
    上查看有关 SOAP 编码和数据类型的详细信息。
- en: Whatever we discuss about the structure of the SOAP message is defined by the
    W3 organization. However, this organization constantly investigates ways to optimize
    structures and bring in more robust specifications from time to time. So, we have
    to update with the latest specifications provided by them and implement them accordingly.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关于 SOAP 消息结构的讨论是由 W3 组织定义的。然而，这个组织不断研究优化结构，并时不时地引入更稳健的规范。因此，我们必须根据他们提供的最新规范进行更新并相应地实施。
- en: 'The following block depicts the general structure of a SOAP message:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的块描述了 SOAP 消息的一般结构：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The receiver is notified about the whole SOAP message with the indication of
    an envelope. What this means is, if the message received by the client has an
    envelope inside it, then the message is completely received and the client can
    parse and use it for further processing. Thus, the SOAP envelope plays the role
    of packaging the whole message.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接收者通过一个封包的指示来通知整个 SOAP 消息。这意味着，如果客户端收到的消息中包含一个封包，那么消息已经完全接收，客户端可以解析并用于进一步处理。因此，SOAP
    封包在包装整个消息方面发挥着作用。
- en: Important points about SOAP
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于 SOAP 的重要点
- en: 'The following are some important points about SOAP:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于 SOAP 的重要点：
- en: '`Envelope` in every SOAP message has the root position and that is mandatory
    for all SOAP messages.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 SOAP 消息中的 `Envelope` 都具有根位置，这是所有 SOAP 消息的强制性要求。
- en: Exactly one body element should be present inside one SOAP envelope.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个 SOAP 封包内部应该只有一个主体元素。
- en: The `Header` element is an optional element. However, if that is present, then
    there should be only one `Header` element.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Header` 元素是一个可选元素。然而，如果存在，那么应该只有一个 `Header` 元素。'
- en: The `Header` must appear as the first child of the envelope, before the body
    element.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Header` 必须作为封包的第一个子元素出现，在主体元素之前。'
- en: The `ENV` namespace prefix and the `Envelope` element are used in order to build
    one SOAP envelope. (Refer to the following example.)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ENV` 命名空间前缀和 `Envelope` 元素来构建一个 SOAP 封包。（参考以下示例。）
- en: The `encodingStyle` attribute defines the data types used in the document. This
    gives a generalization of the data types that appear in the message. If this attribute
    appears on any SOAP element, it will apply the encoding rules to the element's
    contents and all child elements.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encodingStyle` 属性定义了文档中使用的数据类型。这为消息中出现的所有数据类型提供了一个概括。如果此属性出现在任何 SOAP 元素上，它将应用编码规则到该元素的内容和所有子元素。'
- en: 'The following is an example of a v1.2-compliant SOAP message:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个符合 v1.2 规范的 SOAP 消息的示例：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: SOAP with HTTP POST
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOAP 通过 HTTP POST
- en: The `Authors` mentioned in the HTTP header is actually the URL of the controller
    or program to be invoked that have a `POST` action method inside it. Everything
    is hosted at [www.packtpub.com](http://www.packtpub.com).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP 头部中提到的 `Authors` 实际上是包含一个 `POST` 动作方法的控制器或程序的 URL，所有内容都托管在 [www.packtpub.com](http://www.packtpub.com)。
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: REST
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST
- en: REST is an architectural style for providing standards between computer systems
    on the web, so that systems can communicate with each other easily. Services compliant
    to the REST style are often called RESTful services.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: REST 是一种网络计算机系统之间的架构风格，以便系统可以轻松地相互通信。符合 REST 风格的服务通常被称为 RESTful 服务。
- en: Let's talk about a few important constraints of a web service when it is tagged
    as RESTful.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下当 Web 服务被标记为 RESTful 时的一些重要约束。
- en: Server and client are independent
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器和客户端是独立的
- en: With REST, there is no restriction or dependency between server and client.
    Both can be independent of each other. It's just the URL by which the client understands
    the service. The code for a web service on a server can be modified without caring
    about the clients that are associated with it and vice versa.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REST 中，服务器和客户端之间没有限制或依赖。两者都可以相互独立。这只是客户端理解服务的 URL。服务器上 Web 服务的代码可以修改，而不必关心与之关联的客户端，反之亦然。
- en: This kind of separation helps the client/server architecture to breathe freely
    without any hurdles. Therefore, designing the application and separating its core
    business logic becomes easy. What I mean by that is simple. Designing the app
    can be done using client-side technologies and the RESTful web service is invoked
    wherever there is a necessity for business-related operations in a database.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分离有助于客户端/服务器架构在没有障碍的情况下自由呼吸。因此，设计应用程序和分离其核心业务逻辑变得容易。我的意思是，可以使用客户端技术来设计应用程序，而
    RESTful 网络服务则在需要数据库中的业务相关操作的地方被调用。
- en: However, keeping both server and client modular and separate depends on one
    condition and that is the format of the messages they send and receive. Both of
    them should be aware of the message format to send and receive.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，保持服务器和客户端模块化和分离取决于一个条件，那就是他们发送和接收的消息格式。他们都应该知道发送和接收的消息格式。
- en: As the user interface is separated from the business-and data-storage-related
    operations, flexibility and scalability can be improved by simplifying the server
    components. Moreover, the separation allows each component to evolve independently.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户界面与业务和数据存储相关的操作分离，可以通过简化服务器组件来提高灵活性和可扩展性。此外，这种分离允许每个组件独立发展。
- en: REST endpoints are exposed by certain URLs. Different clients can connect using
    the URL, then perform the action intended and get the response back.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: REST端点通过特定的URL暴露。不同的客户端可以使用URL进行连接，然后执行预期的操作并获取响应。
- en: In this book, we will build a small e-commerce web service with minimal operations,
    where a user can use a cart and make orders. These operations will be exposed
    using endpoints. As we discussed, endpoints can be easily consumed from different
    types of clients including mobile apps, web apps, server-side code, and so on.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将构建一个具有最小操作的简单电子商务Web服务，用户可以使用购物车并下订单。这些操作将通过端点公开。正如我们讨论的那样，端点可以很容易地从不同类型的客户端中消费，包括移动应用、Web应用、服务器端代码等。
- en: Statelessness
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无状态
- en: The concept is very easy to understand. In a server/client architecture, the
    server needs to know which client is requesting data from it and, accordingly,
    it decides what to send and what not to send.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念非常容易理解。在服务器/客户端架构中，服务器需要知道哪个客户端正在请求它的数据，相应地，它决定发送什么以及不发送什么。
- en: However, REST systems are stateless. That means the server does not need to
    know anything about the client's state and vice versa. That would eventually remove
    the overhead on the server to identify the client each time a request comes in.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，REST系统是无状态的。这意味着服务器不需要知道任何关于客户端状态的信息，反之亦然。这最终会减少服务器在每次请求到来时识别客户端的开销。
- en: But now the question is, how do the client and server interact? The answer is
    through appropriate messages. Suppose a user wants to see one order detail. It
    would simply ask the server by sending the ID of the order and the server would
    return the order details in either `.json` or `.xml` format, which can be easily
    parsed by the client. Every message has the required information for how to deal
    with that.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在的问题是，客户端和服务器是如何交互的？答案是通过对适当的消息进行交互。假设一个用户想查看一个订单的详细信息。它只需通过发送订单ID来向服务器请求，服务器就会以`.json`或`.xml`格式返回订单详情，这些格式可以很容易地被客户端解析。每条消息都有处理该消息所需的所有信息。
- en: These constraints (along with a few other constraints such as *caching*, *layered
    system*, *uniform interface*, and *code on demand*) when implemented on a web
    service help RESTful applications achieve reliability, optimized performance,
    and scalability. The reason being that components can be managed independently,
    updated flawlessly, and reused without affecting the system as a whole.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些约束（以及一些其他约束，如*caching*、*layered system*、*uniform interface*和*code on demand*）在Web服务上实现时，有助于RESTful应用程序实现可靠性、优化性能和可扩展性。原因在于组件可以独立管理、完美更新且无需影响整个系统即可重用。
- en: Let's look at exactly how communication takes place between the server and client
    in the next section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中具体看看服务器和客户端之间是如何进行通信的。
- en: Setting up the environment
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境
- en: Before we explore the communication mechanism, let's first set up the development
    environment. We will use Visual Studio 2017 for our examples.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索通信机制之前，让我们首先设置开发环境。我们将使用Visual Studio 2017作为我们的示例。
- en: 'Open Visual Studio and undertake our favorite step, File | New | Project, which
    opens up a dialog window with available templates, as shown in the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Visual Studio并执行我们最喜欢的步骤，文件 | 新建 | 项目，这将打开一个包含可用模板的对话框窗口，如以下截图所示：
- en: '![](img/942c014e-419a-4f13-ad2a-952404753a71.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/942c014e-419a-4f13-ad2a-952404753a71.png)'
- en: Select ASP.NET Core Web Application as shown in the preceding screenshot. Don't
    forget to select .NET Core in the left-hand side panel. Everything looks cool
    now.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 选择如前截图所示的ASP.NET Core Web应用程序。别忘了在左侧面板中选择.NET Core。现在一切看起来都很酷。
- en: Let's click OK and then we will land on another dialog where we can select more
    templates related to our web app. Obviously, we will click on Web API and then
    click OK.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们点击“确定”，然后我们将进入另一个对话框，在那里我们可以选择更多与我们的Web应用相关的模板。显然，我们将点击“Web API”，然后点击“确定”。
- en: '![](img/65a05503-18af-4f76-85b3-7546b4c189b5.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/65a05503-18af-4f76-85b3-7546b4c189b5.png)'
- en: 'The project is created. Beautifully, it has crafted all the necessary components
    and created an example controller for us named `ValuesController` as shown in
    the following screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 项目已创建。美丽的是，它已经为我们构建了所有必要的组件，并创建了一个名为`ValuesController`的示例控制器，如下面的截图所示：
- en: '![](img/970fa804-0df1-455c-b192-a74719363e49.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/970fa804-0df1-455c-b192-a74719363e49.png)'
- en: Now, here is one interesting fact. Notice that the `ValuesController` class
    inherits the `Controller` base class. If you were familiar with Web API in ASP.NET
    before Core, you might know that the base class was `ApiController` instead. The
    reason behind this change is to have a uniformity between API and MVC structures.
    `Controller` was the base class in ASP.NET MVC. Now in ASP.NET Core, both MVC
    and Web API templates inherit the same base class. With ASP.NET Core, MVC and
    Web API are merged into one programming model.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里有一个有趣的事实。注意，`ValuesController`类继承自`Controller`基类。如果你在ASP.NET Core之前熟悉Web
    API，你可能会知道基类是`ApiController`。这种变化的原因是为了在API和MVC结构之间保持一致性。`Controller`是ASP.NET
    MVC中的基类。现在在ASP.NET Core中，MVC和Web API模板都继承自相同的基类。在ASP.NET Core中，MVC和Web API被合并为一个编程模型。
- en: Running the application
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: To make sure everything is working fine, let's run the application.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保一切正常工作，让我们运行应用程序。
- en: '![](img/069f0012-8421-4563-8ce5-29f9cfcbdd07.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/069f0012-8421-4563-8ce5-29f9cfcbdd07.png)'
- en: Let's discuss what has just happened in the following sections.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下部分讨论刚才发生的事情。
- en: What's cooking here?
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这里在做什么？
- en: Notice the URL, `localhost:57571/api/values`, which sends the request to `ValuesController`
    because the route defined over the controller is `[Route("api/[controller]")]`.
    By convention, the controller name is always appended with the text *Controller*.
    Thus `api/values` hits `ValuesController`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意URL，`localhost:57571/api/values`，它将请求发送到`ValuesController`，因为控制器上定义的路由是`[Route("api/[controller]")]`。按照惯例，控制器名称总是附加文本*Controller*。因此`api/values`命中`ValuesController`。
- en: 'Now the question is, how it returns `value1` and `value2`. That is because
    we directly accessed the URL through the browser, which ultimately sent a `GET`
    request to the controller. As the controller already has a `Get` method, it got
    executed. The `Get` method is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，它是如何返回`value1`和`value2`的。这是因为我们直接通过浏览器访问了URL，最终发送了一个`GET`请求到控制器。由于控制器已经有一个`Get`方法，它被执行了。`Get`方法如下：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method returns an array of strings, which is printed in the browser. For
    understanding, the URL format is already there above the method *(*`api/values`*)*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个字符串数组，它在浏览器中打印出来。为了理解，URL格式已经在方法上方了（`*``api/values`*`*`）。
- en: Interesting facts
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有趣的事实
- en: 'Let''s experiment with a few things now. You will get a very good insight into
    what happens behind the scenes:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试一些事情。你会对幕后发生的事情有一个很好的了解：
- en: 'Add another method, `Get12()`, to the controller and remove the `[HttpGet]`
    method:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器中添加另一个方法，`Get12()`，并移除`[HttpGet]`方法：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What do you think the output would be? It''s interesting. Here is the output:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为输出会是什么？很有趣。以下是输出：
- en: '![](img/dea1eca8-9d5a-4494-a68d-97c3e164e9e2.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dea1eca8-9d5a-4494-a68d-97c3e164e9e2.png)'
- en: That means it found two `GET` methods and it was not able to decide which one
    to execute. Note that neither of them is decorated by an attribute, such as `[HttpGet]`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它找到了两个`GET`方法，并且它无法决定执行哪一个。注意，它们中没有一个被属性装饰，例如`[HttpGet]`。
- en: 'Now let''s plan to bring back the attribute and test what happens. However,
    we will decorate the new `Get12` method and leave the old `Get` method intact
    with the attribute commented. So, the code would be:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们计划恢复属性并测试会发生什么。然而，我们将装饰新的`Get12`方法，并保持旧的`Get`方法带有注释的属性不变。因此，代码将是：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s have a quick look at what we did to the output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下我们对输出做了什么：
- en: '![](img/44d0405c-533e-4096-99f8-ab9938248849.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/44d0405c-533e-4096-99f8-ab9938248849.png)'
- en: Clear enough! The `Get12` method was executed and the reason for this was that
    we explicitly told it that it was the `Get` method by way of the `[HttpGet]` attribute.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰明了！`Get12`方法被执行了，这是因为我们通过`[HttpGet]`属性明确告诉它是`Get`方法。
- en: 'More fun can be experienced by adding an attribute to both of the methods:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过向两个方法中添加一个属性，可以体验到更多的乐趣：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Can you guess the output? Yes, it is the same as we saw when we had both methods
    without the attribute **AmbiguousActionException** as shown in the following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到输出结果吗？是的，它与我们之前看到的情况相同，当时我们有两个不带属性的方法，并且出现了 **AmbiguousActionException**
    异常，如下面的截图所示：
- en: '![](img/dea1eca8-9d5a-4494-a68d-97c3e164e9e2.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dea1eca8-9d5a-4494-a68d-97c3e164e9e2.png)'
- en: 'Finally, let''s have another method named `HelloWorld()` with the attribute
    along with the existing ones. Let''s remove the attributes from the other ones:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们再添加一个名为 `HelloWorld()` 的方法，并带有属性以及现有的属性。让我们从其他方法中移除属性：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Perfect! Let''s see the output. It''s Hello World in the browser:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！让我们看看输出结果。在浏览器中显示的是：Hello World
- en: '![](img/9de3bc08-6ea3-4602-aed1-01ebf59429fc.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9de3bc08-6ea3-4602-aed1-01ebf59429fc.png)'
- en: Conclusions
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'The following conclusions can be made from the preceding observation. Note
    that we are talking about `GET` requests with the URL `api/values`, which means
    we are talking about all nonparameterized action methods in the controller. While
    reading the following points, ignore methods with parameters or other attributes:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的观察中可以得出以下结论。请注意，我们正在讨论 URL 为 `api/values` 的 `GET` 请求，这意味着我们正在讨论控制器中所有非参数化动作方法。在阅读以下要点时，请忽略带有参数或其他属性的方法：
- en: When we access a particular Web API controller without any parameters (for example,
    `api/values`), action methods with the `[HttpGet]` attribute are searched first
    from the controller.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们不带任何参数访问特定的 Web API 控制器（例如，`api/values`）时，控制器中首先会搜索带有 `[HttpGet]` 属性的动作方法。
- en: If an attribute is not mentioned in nonparameterized methods, then the .NET
    Core runtime will get confused when selecting one action method for the request.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在非参数化方法中没有提到属性，那么当 .NET Core 运行时在选择请求的一个动作方法时会感到困惑。
- en: There is no restriction on the naming convention of the action method. As long
    as it is the only method with no `[HttpGet]` attribute or the only method with
    an `[HttpGet]` attribute, it would be perfectly executed when `GET request` comes
    to the API.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作方法的命名规范没有限制。只要它是唯一一个没有 `[HttpGet]` 属性的方法，或者唯一一个具有 `[HttpGet]` 属性的方法，当 `GET
    请求` 到达 API 时，它就会被完美执行。
- en: Request and response
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求和响应
- en: Now that we have had a quick look at the demo `ValuesController`, let's examine
    exactly how the client sends the request and how it receives the response.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经快速浏览了 `ValuesController` 的演示，让我们确切地看看客户端是如何发送请求以及它是如何接收响应的。
- en: 'A REST request generally consists of the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 REST 请求通常由以下内容组成：
- en: '**HTTP verb:** This denotes what kind of operation the requests want to perform
    on the server.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP 动词:** 这表示请求想要在服务器上执行的操作类型。'
- en: '**Header:** This element of the REST request allows the client to pass more
    information about the request.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Header:** REST 请求的这个元素允许客户端传递更多关于请求的信息。'
- en: '**URL:** The actual path to the resource that the REST request wants to operate
    on.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URL:** REST 请求要操作的资源的实际路径。'
- en: '**Body:** The body can contain extra data related to a resource to identify
    or update it. This is optional though.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Body:** 主体可以包含与资源相关的额外数据，用于标识或更新资源。这是可选的。'
- en: HTTP verbs
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 动词
- en: 'The following are basic HTTP verbs used while requesting a REST system for
    resource interaction:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在请求 REST 系统进行资源交互时使用的基本 HTTP 动词：
- en: '**GET:** Used to retrieve a specific resource by its identity or a collection
    of resources'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET:** 用于通过其标识符或资源集合检索特定资源'
- en: '**POST:** Used to create/insert a new resource'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**POST:** 用于创建/插入新资源'
- en: '**PUT:** Used to update a specific resource by its identity'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PUT:** 用于通过其标识符更新特定资源'
- en: '**DELETE:** Used to remove a specific resource by its identity'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DELETE:** 用于通过其标识符删除特定资源'
- en: Let's try to explore the request/response mechanism in REST for these verbs
    one by one. We will try to design an e-commerce application with basic operations.
    In the first phase, we will work on products, which is the core of these types
    of apps.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一探索 REST 中这些动词的请求/响应机制。我们将尝试设计一个具有基本操作的商业应用程序。在第一阶段，我们将处理产品，这是这些类型应用程序的核心。
- en: Postman
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Postman
- en: To test the API, we can use a very easy-to-use tool named *Postman*. It can
    be downloaded from: [https://www.getpostman.com/](https://www.getpostman.com/).
    Please download and open it. We will see how to send requests through Postman
    and analyze responses we get from Web API in the next section.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试 API，我们可以使用一个非常易于使用的工具，名为 *Postman*。它可以从：[https://www.getpostman.com/](https://www.getpostman.com/)
    下载。请下载并打开它。我们将在下一节中看到如何通过 Postman 发送请求，并分析我们从 Web API 收到的响应。
- en: GET
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GET
- en: 'I will add another controller called `ProductsController`. For now, let''s
    have a simple action method, `GET`, which will return some products. The products
    are hard-coded in the action method for now. The method will look like the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我将添加另一个名为 `ProductsController` 的控制器。目前，让我们有一个简单的动作方法 `GET`，它将返回一些产品。目前，这些产品在动作方法中是硬编码的。该方法看起来如下：
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `[Route]` attribute is provided with a well-defined template of  `"api/[Controller]"`.
    Here, the controller name is `ProductsController`. When we request using the URL
    `api/Products`, the framework will search for a controller with that route defined
    on it. The `[Controller]` placeholder is a special naming convention that will
    be replaced with the text (name of controller) `Products` at runtime. However,
    you can directly write the fully qualified template with the controller name,
    such as `[Route (api/Products)]`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`[路由]` 属性提供了一个定义良好的模板 `"api/[控制器]"`。在这里，控制器名称是 `ProductsController`。当我们使用 URL
    `api/Products` 进行请求时，框架将搜索具有该路由定义的控制器。`[控制器]` 占位符是一个特殊的命名约定，将在运行时替换为文本（控制器名称）`Products`。然而，您可以直接编写带有控制器名称的完全限定模板，例如
    `[Route (api/Products)]`。'
- en: 'So, this `GET` method will return us three products with their details. The `Product`
    class can be designed, like the following, with a constructor to build *Product*
    objects:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个 `GET` 方法将返回三个产品及其详细信息。`Product` 类可以设计如下，具有一个用于构建 *Product* 对象的构造函数：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We are done. Let''s do a `GET request` through *Postman* to analyze the request
    and response mechanism in REST. For a `GET request`, it''s simple. Just open Postman.
    Then follow the steps mentioned in the following screenshot:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了。让我们通过 *Postman* 进行 `GET 请求` 来分析 REST 中的请求和响应机制。对于 `GET 请求`，很简单。只需打开 Postman。然后按照以下截图中的步骤操作：
- en: '![](img/619271a2-f6d7-4240-a326-96f485df93d3.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/619271a2-f6d7-4240-a326-96f485df93d3.png)'
- en: Executing GET request in Postman
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Postman 中执行 GET 请求
- en: In **Step-1**, just paste the URL, which is `http://localhost:57571/api/products`
    for our example. Everything else is already set for a `GET` request. You can see
    the request type to the left of the URL box, which is `GET`. That means the current
    request will be a `GET` request. Hit the Send button as shown in **Step-2**.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **步骤-1** 中，只需粘贴 URL，即我们示例中的 `http://localhost:57571/api/products`。其他所有内容都已为
    `GET 请求` 设置好。您可以看到 URL 框左边的请求类型，它是 `GET`。这意味着当前请求将是一个 `GET` 请求。按如下所示的 **步骤-2**
    中的发送按钮。
- en: 'The response is a list of products shown inside the section at the bottom.
    It''s in `.json` format. Please refer to the following screenshot, which displays
    the response of the `GET` request:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 响应是在底部部分显示的产品列表。它以 `.json` 格式呈现。请参考以下截图，它显示了 `GET` 请求的响应：
- en: '![](img/17867f88-93d2-46ef-987f-2ce009fa1106.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/17867f88-93d2-46ef-987f-2ce009fa1106.png)'
- en: Now that you have had a pleasant look at how `GET` works, let's analyze what
    happens behind the scenes. The client, which is *Postman* here, sends an HTTP
    request and gets a response in return. While sending requests it also specifies
    the Request Headers, and the server, in return, sends the Response Headers.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经愉快地了解了 `GET` 的工作原理，让我们分析幕后发生了什么。客户端（在这里是 *Postman*），发送 HTTP 请求并得到响应。在发送请求时，它还指定了请求头部，而服务器作为回报，发送响应头部。
- en: 'HTTP Headers enable the client and server to both send and receive additional
    information with the request and response respectively. This decides the exact
    behavior of the HTTP transaction. You can refer to the following resources to
    learn more about the headers. We will have a quick look at the headers in the
    next section:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 头部允许客户端和服务器分别在与请求和响应交互时发送和接收额外的信息。这决定了 HTTP 事务的确切行为。您可以参考以下资源来了解有关头部的更多信息。我们将在下一节中快速查看头部：
- en: '[https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)'
- en: '[https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)'
- en: 'In Postman, you can click on Code**,** as shown in the following screenshot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Postman 中，您可以点击 **代码**，如下面的截图所示：
- en: '![](img/7a7fe2db-4d7b-4326-90bf-a2365cae80ee.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a7fe2db-4d7b-4326-90bf-a2365cae80ee.png)'
- en: 'Clicking on this link will open one modal that will show you the HTTP Request
    Headers sent to the server to serve the request. Check out the following screenshot
    of the modal, which clearly mentions the Request Type as `GET`, `Host` as the
    URL of the API, and then other headers such as `Cache-Control` and `Postman-Token`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 点击此链接将打开一个模态窗口，显示发送到服务器的 HTTP 请求头以处理请求。查看以下模态窗口的截图，其中清楚地说明了请求类型为 `GET`，`Host`
    为 API 的 URL，然后是其他头信息，如 `Cache-Control` 和 `Postman-Token`：
- en: '![](img/9d077605-65eb-4f0c-b7d7-b6d2cbe02ff6.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9d077605-65eb-4f0c-b7d7-b6d2cbe02ff6.png)'
- en: Want to know what the *jQuery* code snippet looks like for this `GET` call?
    It's super-easy with Postman. Click on Code on the main screen, then from the
    drop-down menu containing languages, select *jQuery*. (See the following screenshot.)
    Moreover, you can get code in different languages by selecting from the drop-down
    list. Happy copying!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 想要知道此 `GET` 调用的 *jQuery* 代码片段是什么样子吗？使用 Postman 非常简单。在主屏幕上点击代码，然后从包含语言的下拉菜单中选择
    *jQuery*。（见以下截图。）此外，您还可以通过从下拉列表中选择来获取不同语言的代码。复制愉快！
- en: '![](img/e9a0b8cb-9885-4c77-a57e-17f420a0974a.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e9a0b8cb-9885-4c77-a57e-17f420a0974a.png)'
- en: '*Response Header* is clearly shown on the main page, as shown in the following
    screenshot. Notice that there is a Status code mentioned, which is 200 OK in this
    case. So, what does this code signify?'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*响应头* 清楚地显示在主页面中，如下截图所示。注意，提到了状态码，在这种情况下是 200 OK。那么，这个代码代表什么意思呢？'
- en: Let's talk about it in the next section.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中讨论这个问题。
- en: '![](img/17c42408-1b22-4bdd-9665-6f0052afbb7d.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/17c42408-1b22-4bdd-9665-6f0052afbb7d.png)'
- en: Postman Response Headers
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Postman 响应头
- en: Status codes
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态码
- en: 'When a server returns responses, it includes status codes. These status codes
    inform the client how the request performed on the server. As a developer, you
    do not need to know every status code (there are many of them), but you should
    know the most common ones and how they are used:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器返回响应时，它包括状态码。这些状态码通知客户端请求在服务器上的执行情况。作为开发者，您不需要知道每个状态码（有很多），但您应该了解最常见的状态码及其用法：
- en: '| **Status Code** | **Explanation** |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **状态码** | **说明** |'
- en: '| 200 OK | Standard response for successful HTTP requests. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 200 OK | 对成功 HTTP 请求的标准响应。|'
- en: '| 201 CREATED | Standard response for an HTTP request when an item is successfully
    created. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 201 CREATED | 当成功创建项目时，对 HTTP 请求的标准响应。|'
- en: '| 204 NO CONTENT | Standard response for successful HTTP requests, if nothing
    is returned in the response body. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 204 NO CONTENT | 如果响应体中没有返回任何内容，对成功 HTTP 请求的标准响应。|'
- en: '| 400 BAD REQUEST | Request cannot be processed because of bad request syntax,
    excessive size, or another client error. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 400 BAD REQUEST | 由于请求语法错误、大小过大或其他客户端错误，请求无法处理。|'
- en: '| 403 FORBIDDEN | Client does not have permission to access the requested resource.
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 403 FORBIDDEN | 客户端没有权限访问请求的资源。|'
- en: '| 404 NOT FOUND | Resource could not be found at this time. It might have been
    deleted, or does not exist yet. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 404 NOT FOUND | 资源当前无法找到。它可能已被删除，或者尚不存在。|'
- en: '| 500 INTERNAL SERVER ERROR | This response comes whenever there is a failure
    or exception happens while processing the server side codes. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 500 INTERNAL SERVER ERROR | 当在处理服务器端代码时发生失败或异常时，此响应出现。|'
- en: 'Some status codes are (by default) expected from the server for the following
    HTTP verbs:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下 HTTP 动词，服务器默认期望从服务器返回一些状态码：
- en: '`GET`: Returns 200 OK'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`: 返回 200 OK'
- en: '`POST`: Returns 201 CREATED'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`: 返回 201 CREATED'
- en: '`PUT`: Returns 200 OK'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`: 返回 200 OK'
- en: '`DELETE`: Returns 204 NO CONTENT if the operation failed'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`: 如果操作失败，返回 204 NO CONTENT'
- en: We already saw how API returned 200 OK for the `GET` request. As we move forward
    with other verbs, we will explore the responses returned with the codes mentioned
    previously.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 API 如何对 `GET` 请求返回 200 OK。随着我们继续使用其他动词，我们将探索之前提到的代码返回的响应。
- en: ASP.NET Core HTTP attributes
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core HTTP 属性
- en: According to the *Internet Engineering Task Force (IETF) RFC-7231* document
    ([https://tools.ietf.org/html/rfc7231](https://tools.ietf.org/html/rfc7231)), ASP.NET
    Core has implemented seven HTTP attributes out of the eight HTTP verbs listed.
    The only exclusion in the framework, from the list of verbs, is the HTTP TRACE
    verb.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 *互联网工程任务组 (IETF) RFC-7231* 文档 ([https://tools.ietf.org/html/rfc7231](https://tools.ietf.org/html/rfc7231))，ASP.NET
    Core 实现了八种 HTTP 动词中的七种 HTTP 属性。框架中从动词列表中排除的唯一一个是 HTTP TRACE 动词。
- en: 'Following is the complete list of HTTP verb attributes that are provided in
    ASP.NET Core:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 ASP.NET Core 中提供的完整 HTTP 动词属性列表：
- en: '`HttpGetAttribute`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpGetAttribute`'
- en: '`HttpPostAttribute`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpPostAttribute`'
- en: '`HttpPutAttribute`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpPutAttribute`'
- en: '`HttpDeleteAttribute`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpDeleteAttribute`'
- en: '`HttpHeadAttribute`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpHeadAttribute`'
- en: '`HttpPatchAttribute`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpPatchAttribute`'
- en: '`HttpOptionsAttribute`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpOptionsAttribute`'
- en: As the verb name is attached with the attribute, it is very obvious that they
    will be used for their respective verbs. These attributes help the framework to
    understand what action method is associated with what verb. With that in mind,
    it can decide which one to execute when a request comes for the controller.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于动词名称与属性相关联，很明显它们将用于各自的动词。这些属性帮助框架理解哪个动作方法与哪个动词相关联。考虑到这一点，当控制器收到请求时，它可以决定执行哪个方法。
- en: Another important attribute for routing is also provided by the framework, named
    `RouteAttribute`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 框架还提供了一个对路由也很重要的属性，名为`RouteAttribute`。
- en: 'There are a few more attributes used for the parameters of action methods to
    help recognize parameters passed to the API action from different places of the
    request such as URL, Body, and so on. Following are some attributes present in
    the framework for the action parameters:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 动作方法的参数还有一些其他属性，用于帮助识别从请求的不同位置（如URL、Body等）传递给API动作的参数。以下是一些框架中用于动作参数的属性：
- en: '`FromServicesAttribute`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FromServicesAttribute`'
- en: '`FromRouteAttribute`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FromRouteAttribute`'
- en: '`FromQueryAttribute`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FromQueryAttribute`'
- en: '`FromBodyAttribute`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FromBodyAttribute`'
- en: '`FromFormAttribute`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FromFormAttribute`'
- en: POST
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POST
- en: POST is used to create a resource. In our case, we will try to create a product
    using a POST request to the server. Before doing that, we will make a few changes
    to our project. You can find all related code on GitHub ([https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core](https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core)),
    so don't worry at all!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`POST`来创建资源。在我们的例子中，我们将尝试使用POST请求向服务器创建产品。在这样做之前，我们将对我们的项目做一些修改。你可以在GitHub上找到所有相关代码（[https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core](https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core)），所以请放心！
- en: 'Why wait then? Let''s write the Post method as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 那还等什么？让我们按照以下方式编写Post方法：
- en: '[PRE10]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The action method calls `CreateProductAsync` of the related service and checks
    if the operation was successful. If successful, it sends back `201`, else `500`.
    Note that to send back the correct status code, we are leveraging the `IActionResult`.
    This interface has a large set of subclasses that are accessible via the `Controller`
    class. Since we inherit from the `Controller` base class, we can easily use methods
    such as `StatusCode` to return our intended status according to the operation
    we performed on the resource.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 动作方法调用相关服务的`CreateProductAsync`方法，并检查操作是否成功。如果成功，则返回`201`，否则返回`500`。请注意，为了返回正确的状态码，我们正在利用`IActionResult`接口。这个接口有一组大量的子类，可以通过`Controller`类访问。由于我们继承了`Controller`基类，我们可以轻松地使用如`StatusCode`等方法，根据我们对资源的操作返回我们期望的状态。
- en: In the previous section, we mentioned that on `POST` success, we should get
    201 CREATED and on failure, it should send a generalized 500 Internal Server Error
    response. That is what the code does.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们提到，在`POST`请求成功时，我们应该收到201 CREATED状态码，而在失败时，应该发送一个通用的500内部服务器错误响应。这正是代码所做的事情。
- en: 'There is another interesting thing, that is: `Created($"api/products/{product.Id}",
    product)`. This is a method inside the `Controller` class which assigns the URL
    to the location and 201 to the status code of the response. Don''t believe me!?
    Okay, let me prove it by way of *Postman*, right away.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的事情是：`Created("api/products/{product.Id}", product)`。这是`Controller`类中的一个方法，它将URL分配给位置，并将201分配给响应的状态码。你不信吗？好吧，让我立即通过*Postman*来证明这一点。
- en: 'Have a look at the following screenshot taken from the *Postman* request screen:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下是从*Postman*请求屏幕中捕获的截图：
- en: '![](img/63d0c202-8c23-4619-8af2-04c5a66798fb.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/63d0c202-8c23-4619-8af2-04c5a66798fb.png)'
- en: Notice that we passed the data for a product as JSON and after creating the
    product, the API returned us the status code as 201 Created and the URL of the
    new product created, which is api/products/1\. What that means is that when you
    run this URL as a `GET` request, you will receive the newly created product details.
    Simple, isn't it?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们以JSON格式传递了产品的数据，创建产品后，API返回了201 Created状态码和创建的新产品的URL，即api/products/1。这意味着，当你以`GET`请求运行此URL时，你会收到新创建的产品详情。简单，不是吗？
- en: As you can see, the datatype of the passed product details is JSON, but the
    question is, who told the server that it is in that format? Well, that's the request
    header `content-type` set with value `application/json`. You can see that in the
    last screenshot. A default encoding of `charset=utf-8` is appended by *Postman*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，传递的产品详情的数据类型是 JSON，但问题是，谁告诉服务器它是以那种格式存储的？嗯，那是请求头 `content-type` 设置的值为 `application/json`。您可以在最后一张截图中看到。默认编码为
    `charset=utf-8`，由 *Postman* 添加。
- en: However, interestingly, how come *Postman* knew that we wanted the datatype
    content to be JSON? It can't set it automatically. I told it to do that.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有趣的是，*Postman* 如何知道我们想要的数据类型内容是 JSON？它不能自动设置。我告诉它这样做。
- en: 'The option to set any type of request header is just below the URL textbox.
    Refer to the following screenshot, which shows that I have set the `content-type`
    header:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在 URL 文本框下方有设置任何类型请求头的选项。参看以下截图，它显示了我已经设置了 `content-type` 头：
- en: '![](img/ae9c588d-6399-4589-9ff3-7d9b78150004.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae9c588d-6399-4589-9ff3-7d9b78150004.png)'
- en: 'For the previously mentioned `GET` request, which returns the product details
    by ID, we can design the action method as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于之前提到的 `GET` 请求，该请求通过 ID 返回产品详情，我们可以设计如下操作方法：
- en: '[PRE11]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we are providing a template argument of `"{id}"` to `[HttpGet]`. This
    will make sure that one HTTP Get route such as `api/orders/1` is available—where
    the ID is a variable passed to the `GET` request.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为 `[HttpGet]` 提供了一个模板参数 `"{id}"`。这将确保有一个 HTTP Get 路由，例如 `api/orders/1`
    可用——其中 ID 是传递给 `GET` 请求的变量。
- en: We have a service called `ProductService` which is implementing the interface
    `IProductService` and through the constructor of the controller, the service (dependency)
    is injected, which is called *dependency injection*. With .NET Core, it's very
    easy to handle dependencies with the built-in *inversion of control container*.
    If you are not getting what I am talking about, then I would highly recommend
    going through my other book on this topic, *Dependency Injection in .NET Core *([https://www.packtpub.com/application-development/dependency-injection-net-core-20](https://www.packtpub.com/application-development/dependency-injection-net-core-20)).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为 `ProductService` 的服务，它实现了 `IProductService` 接口，并且通过控制器的构造函数，服务（依赖项）被注入，这被称为
    *依赖注入*。在 .NET Core 中，使用内置的 *控制反转容器* 处理依赖项非常容易。如果您不明白我在说什么，那么我强烈建议您阅读我关于这个主题的另一本书，*Dependency
    Injection in .NET Core* ([https://www.packtpub.com/application-development/dependency-injection-net-core-20](https://www.packtpub.com/application-development/dependency-injection-net-core-20))。
- en: PUT
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PUT
- en: The HTTP PUT verb is idempotent. This means that the first HTTP PUT request
    with a certain payload will impact the server and the resource. It will update
    the resource specified by ID. However, subsequent HTTP PUT requests with the same
    payload would result in the same response as the first one.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP PUT 动词是幂等的。这意味着第一个带有特定有效负载的 HTTP PUT 请求将影响服务器和资源。它将更新由 ID 指定的资源。然而，随后的带有相同有效负载的
    HTTP PUT 请求将产生与第一个请求相同的响应。
- en: 'Consider the following example where we will update one product:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，我们将更新一个产品：
- en: '[PRE12]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `[HttpPut]` attribute is supplied with a template of `{id}` similar to what
    we had in `[HttpGet]`. In the case of `PUT`, it would get the ID from the URL
    and the `Product` object from the body of the request, which is specified by the `[FromBody]`
    attribute as we did in the case of `POST` in the previous section.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`[HttpPut]` 属性提供了一个类似于 `[HttpGet]` 中的模板 `{id}`。在 `PUT` 的情况下，它将从 URL 中获取 ID，并从请求体中获取
    `Product` 对象，这由 `[FromBody]` 属性指定，正如我们在上一节中 `POST` 的情况所做的那样。'
- en: When the ID and the product object is tied with the arguments, the method body
    starts execution, which in turn calls the service method `UpdateProductAsync`
    with the same parameters. That method would return a Boolean based on whether
    the update was successful. If everything was successful, we would return 200 OK
    by calling the `OK()` method, otherwise a 500 Internal Server Error would be given
    if an error occurred.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当 ID 和产品对象与参数绑定时，方法体开始执行，这反过来又调用服务方法 `UpdateProductAsync` 并传递相同的参数。该方法将根据更新是否成功返回一个布尔值。如果一切顺利，我们将通过调用
    `OK()` 方法返回 200 OK，否则如果发生错误，将给出 500 内部服务器错误。
- en: 'Let me show you the screenshot from Postman:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我向您展示 Postman 的截图：
- en: '![](img/85d426a0-14ac-4d18-b9ff-b713b5490480.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85d426a0-14ac-4d18-b9ff-b713b5490480.png)'
- en: Another status code, 301 Moved Permanently, can be returned if the `PUT` request
    comes with an ID that has expired, meaning the product passed in the request body
    is not associated with the ID. To identify this condition, we need to add business
    logic accordingly, and if we can verify whether the ID is related to the product
    or not. If not, we can simply return 301 Moved Permanently with the new URL where
    the product actually exists currently.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `PUT` 请求附带一个已过期的 ID，可以返回另一个状态码，301 Moved Permanently，这意味着请求体中的产品与 ID 不相关。为了识别这种条件，我们需要相应地添加业务逻辑，并且如果我们能够验证
    ID 是否与产品相关，如果不相关，我们可以简单地返回 301 Moved Permanently，并附带产品实际当前存在的新的 URL。
- en: DELETE
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DELETE
- en: Ideally, a `DELETE` request should delete the resource. Once the operation is
    successful, we can send a 200 OK status code by calling the `OK()` method.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，一个 `DELETE` 请求应该删除资源。一旦操作成功，我们可以通过调用 `OK()` 方法发送 200 OK 状态码。
- en: 'Refer to the following code block:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下代码块：
- en: '[PRE13]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice the `DeleteOrderAsync` method, which is provided with the ID of the product
    to delete. Now, you can return a Boolean from that method, which will indicate
    whether the operation was successful or not. If you don't find any product for
    that ID, simply return `false`.  Then, we will decide what to return to the client
    accordingly.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `DeleteOrderAsync` 方法，它提供了要删除的产品 ID。现在，你可以从该方法返回一个布尔值，这将指示操作是否成功。如果你找不到该
    ID 的任何产品，只需返回 `false`。然后，我们将根据情况决定向客户端返回什么。
- en: If you return `false`, `NoContent()` can be used to return status code *204*.
    If the resource is already deleted and the client is requesting the same, then
    the server will return a status code 204 No Content. That means the server is
    not able to find the requested resource as it does not exist anymore.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你返回 `false`，可以使用 `NoContent()` 返回状态码 *204*。如果资源已经被删除且客户端请求相同的内容，那么服务器将返回状态码
    204 No Content。这意味着服务器无法找到请求的资源，因为它已经不存在了。
- en: 'Have a look at the Postman screenshot. See the Status code is *200 OK* for
    a successful delete:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下 Postman 截图。看到状态码是 *200 OK* 表示删除成功：
- en: '![](img/8f1cd17b-a04c-43da-9af4-aa519632813f.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f1cd17b-a04c-43da-9af4-aa519632813f.png)'
- en: SOAP versus REST
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOAP 与 REST 对比
- en: 'Following are some key differences between SOAP and REST:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 SOAP 和 REST 之间的一些关键区别：
- en: '| **SOAP** | **REST** |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| **SOAP** | **REST** |'
- en: '| It is an XML-based message protocol. | It is an architectural style. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 它是一个基于 XML 的消息协议。 | 它是一种架构风格。 |'
- en: '| WSDL is used for communication between client and server.  | XML or JSON
    is used to send and receive data between client and server. |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| WSDL 用于客户端和服务器之间的通信。  | XML 或 JSON 用于客户端和服务器之间发送和接收数据。 |'
- en: '| Services are invoked by calling the RPC method. | Services expose endpoints
    via URLs. |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 服务通过调用 RPC 方法被调用。 | 服务通过 URL 暴露端点。 |'
- en: '| Response is easily readable by a human. | Response is readable in the form
    of plain XML or JSON. |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 响应易于人类阅读。 | 响应以纯 XML 或 JSON 的形式可读。 |'
- en: '| Data transfer occurs over HTTP. It leverages protocols such as SMTP, FTP,
    and so on. | REST data transfer occurs over HTTP only. |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 数据传输通过 HTTP 进行。它利用 SMTP、FTP 等协议。 | REST 数据传输仅通过 HTTP 进行。 |'
- en: '| It is difficult to call a SOAP service from JavaScript. | It is very easy
    to call a REST service from JavaScript. |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 从 JavaScript 调用 SOAP 服务比较困难。 | 从 JavaScript 调用 REST 服务非常容易。 |'
- en: Single-page application model
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单页应用程序模型
- en: Traditionally, in a web application, the client requests the server for a web
    page. Then, the server responds to the client with the requested HTML page after
    validating and authenticating the request, if necessary. The next request to the
    server might occur when a user hits some link on the page, submits a form, and
    so on. The server again processes the request and sends back the response with
    another HTML page.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，在 Web 应用程序中，客户端请求服务器提供网页。然后，服务器在必要时验证和认证请求后，向客户端响应请求的 HTML 页面。下一个请求可能发生在用户点击页面上的某个链接、提交表单等情况。服务器再次处理请求，并返回另一个
    HTML 页面的响应。
- en: Don't you think instead of getting the whole HTML page (which would be mostly
    the same look and feel as the last loaded page), we should just get the data we
    need and update the currently loaded page itself without posting back to the server?
    Yes, modern web development works in that regard. Today, we just need data from
    the server on demand using Ajax. After receiving the data, we will just update
    the UI with JavaScript or a client-side framework such as Angular.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你难道不认为我们不应该获取整个HTML页面（这将会与最后加载的页面外观和感觉基本相同），而应该只获取我们所需的数据，并更新当前加载的页面本身，而不需要向服务器发送回帖？是的，现代Web开发在这方面就是这样工作的。今天，我们只需要根据需要从服务器获取数据使用Ajax。在收到数据后，我们只需使用JavaScript或客户端框架（如Angular）更新UI。
- en: This is what we call a **s****ingle-page application** (**SPA**). On the first
    request to the server, the server responds with the entire page for the app. Unlike
    traditional web apps, subsequent requests won't ask for an HTML page, rather they
    will ask for data using Ajax requests where the type of content is usually JSON.
    After getting data, the browser has to update only the portion of the page that
    has changed instead of reloading the entire page again. The SPA definitely improves
    user experiences by responding quickly to user actions on the same page because
    reloading the page takes away a user's attention for a moment.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们所说的**单页面应用**（SPA）。在第一次向服务器请求时，服务器会响应整个应用页面。与传统Web应用不同，后续请求不会要求获取HTML页面，而是会使用Ajax请求获取数据，其中内容类型通常是JSON。在获取数据后，浏览器只需更新页面中已更改的部分，而不是重新加载整个页面。SPA通过快速响应用户在相同页面上的操作，无疑提高了用户体验，因为重新加载页面会暂时分散用户的注意力。
- en: However, implementing SPA is not so easy as we have to be sure that we are showing
    fresh data on the page whenever needed. Here, emerging technologies, such as ASP.NET
    Web API, and JavaScript frameworks, such as AngularJS and CSS3 come in handy when
    designing SPAs.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实现单页面应用（SPA）并不像我们想象的那么简单，我们必须确保在需要时页面上显示的是最新数据。在这里，当设计SPA时，新兴技术，如ASP.NET
    Web API，以及JavaScript框架，如AngularJS和CSS3，都派上了用场。
- en: Your application can call different endpoints of the REST API to do certain
    tasks and update the UI after getting responses without reloading the page.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序可以调用REST API的不同端点来完成特定任务，并在收到响应后更新UI，而无需重新加载页面。
- en: Service-oriented architecture
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向服务架构
- en: Like SPA, Web API plays an important role in **service-oriented architecture**
    (**SOA**). As the name suggests, it is an architecture methodology that deals
    with separation of responsibility from a business-oriented point of view into
    independent services. Often, these independent services or components can be designed
    using RESTful Web APIs.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 与SPA一样，Web API在面向服务架构（SOA）中扮演着重要的角色。正如其名所示，它是一种从业务导向的角度处理责任分离的架构方法，将其分解为独立的服务。通常，这些独立的服务或组件可以使用RESTful
    Web API进行设计。
- en: Consider an e-commerce application that would have different components such
    as ordering, billing, payment processing, customer profile management, and so
    on. Each of these components has its own business logic and can be implemented
    independently.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个电子商务应用，它可能包含不同的组件，如订单、账单、支付处理、客户资料管理等。这些组件各自有自己的业务逻辑，并且可以独立实现。
- en: 'The following diagram represents a pictorial view of such an application having
    independent components:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示了这样一个具有独立组件的应用程序的图示：
- en: '![](img/caf5879a-a824-4cf6-a707-2668eeace98e.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/caf5879a-a824-4cf6-a707-2668eeace98e.png)'
- en: To make them independent, RESTful APIs can be exposed for these components,
    which can be easily consumed by any client/application including other components
    as well, as long as they satisfy the authentication and authorization.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使它们独立，可以为这些组件公开RESTful API，这些API可以很容易地被任何客户端/应用程序消费，包括其他组件，只要它们满足认证和授权要求。
- en: 'Following is a pictorial representation of a monolithic or traditional application
    architecture versus SOA. It''s perfectly clear how SOA introduces reusable components
    for the same business application. Moreover, implementing them with Web API brings
    the capability to expose that to outside for consumption by any application:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个单体或传统应用架构与面向服务架构（SOA）的图示。它清楚地说明了SOA如何为同一业务应用引入可重用组件。此外，通过Web API实现它们，可以使其对外暴露，供任何应用程序（包括其他组件）消费，只要它们满足认证和授权要求：
- en: '![](img/b0c2ee14-34e7-4937-b027-18e9b449c2dd.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b0c2ee14-34e7-4937-b027-18e9b449c2dd.png)'
- en: SOA implementation is beyond the scope of this book because there is a lot of
    stuff about Web API we need to explore in the next chapters. Whatever we do with
    the application in this book would use one Web API, but you can separate them
    out to build a more scalable architecture.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书接下来几章需要探索许多关于 Web API 的内容，因此 SOA 的实现超出了本书的范围。无论我们在本书的应用程序中做什么，都会使用一个 Web
    API，但你可以将它们分离出来以构建一个更可扩展的架构。
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started with some basic knowledge of SOAP and then we moved towards REST
    gradually.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一些基本的 SOAP 知识开始，然后逐渐转向 REST。
- en: This chapter shed some light on the fundamental REST building blocks and how
    they actually work. We explored the different status codes returned by widely
    used HTTP verbs.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要介绍了 REST 的基本构建块及其实际工作原理。我们探讨了广泛使用的 HTTP 动词返回的不同状态码。
- en: To explore the request and response cycles of Web API, you can use Postman,
    where you not only have control over what is being sent and received, but also
    the ability to get code for different languages in order to consume the API.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索 Web API 的请求和响应周期，你可以使用 Postman，在这里你不仅能够控制发送和接收的内容，还能获取不同语言的代码以便消费 API。
- en: ASP.NET Core attributes can be tied to controller action methods to make them
    more expressive and manageable in terms of routing and arguments.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 属性可以绑定到控制器操作方法，使它们在路由和参数方面更具表达性和可管理性。
- en: '*Single-page applications* can be easily designed using client-side technologies
    and consuming ASP.NET Core Web APIs so that pages can be updated as soon as responses
    are received to have a smooth user experience.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*单页应用程序* 可以通过使用客户端技术并消费 ASP.NET Core Web API 来轻松设计，以便在接收到响应后立即更新页面，从而提供流畅的用户体验。'
- en: Web APIs can be plugged into the s*ervice-oriented architecture* to have a modular
    design that improves scalability. By separating different critical components
    of the whole architecture with the help of APIs, it leaves us in a better position
    to reuse the components in different applications and expose them to the world
    so that they can be consumed by anyone.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Web API 可以集成到面向服务的架构中，以实现模块化设计，从而提高可扩展性。通过使用 API 将整个架构的不同关键组件进行分离，我们能够更好地在不同的应用程序中重用这些组件，并将它们暴露给世界，以便任何人都可以消费。
- en: In the next chapter, we will look at the important parts of the Web API architecture
    related to authentication.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨与身份验证相关的 Web API 架构的重要部分。
