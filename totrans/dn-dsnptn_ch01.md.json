["```cs\n    Class Test \n    { \n      <------ Static (Class Level) Variables ---------------> \n      <------ Instance (Object Level) Variables ------------> \n      <------ Private Methods ------------------------------> \n      <------ Public Methods -------------------------------> \n    } \n\n```", "```cs\n    // Chap1_01.cs \n    using System; \n    using System.Collections; \n    class Temp \n    { \n      public static void Main(String [] args) { \n      //---- accumulate command line arguments to  \n      //---- to a list \n      ArrayList a = new ArrayList(); \n      for(int i=0; i< args.Length; ++i) \n        a.Add(Convert.ToDouble(args[i])); \n      //----- aggregate value to a variable (sum) \n      double sum = 0.0; \n      foreach(double at in a) \n        sum = sum + at; \n      //------------ Compute the Average \n      double ar = sum/a.Count; \n      //------------ Spit value to the console \n      //------------ Wait for a Key  \n      Console.WriteLine(ar); \n      Console.Read(); \n    } \n  } \n\n```", "```cs\n    // -- Chap1_02.cs \n    using System; \n    using System.Collections; \n using System.Collections.Generic;public delegate double    \n    Del(List<double> pa); \n    class Temp \n    { \n      public static void Main(String [] args) { \n      //----- Use a Generic List (List<T> ) \n      //----- to accumulate command line arguemnts \n      List<double> a = new List<double>(); \n      for(int i=0; i< args.Length ; ++ i ) \n      a.Add(Convert.ToDouble(args[i])); \n      //--- Define a anonymous delegate and assign \n      //--- to the variable temp \n      //--- The delegate aggregates value and  \n      //--- compute average \n Del temp = delegate(List<double> pa ) { \n        double sum = 0.0; \n        foreach( double at in pa ) \n          sum = sum + at; \n        return sum/pa.Count; \n      }; \n      //---- invoke the delegate \n      //---- and wait for the key \n      Console.WriteLine(temp(a)); \n      Console.Read(); \n     } \n   } \n\n```", "```cs\n    //--- Chap1_03.cs \n    using System; \n    using System.Collections; \n    using System.Collections.Generic; \n using System.Linq; \n    class Temp { \n      public static void Main(String [] args) { \n      //---- leverage type inference feature to assign \n      //---- a List<T> and accumulate values to that list \n      var a = new List<double>(); \n      for(int i=0; i< args.Length ; ++ i ) \n        a.Add(Convert.ToDouble(args[i])); \n      //----- Define a Lambda function which passes \n      //----- through the value.  \n Func<double,double> ar2 = (x => x ); \n //------ use the Sum function available with List<T> \n //------ to compute the average \n      var ar = a.Sum(ar2 )/a.Count; \n      //------ Spit the value to the console \n      Console.WriteLine(ar); \n      Console.Read(); \n    } \n  } \n\n```", "```cs\n    // Chap1_04.cs \n    using System; \n    using System.Collections.Generic; \n    using System.Linq; \n    using System.Text; \n using System.Dynamic; \n\n    namespace TestVS \n    { \n      class DynamicClass : DynamicObject \n    { \n      //---- underlying container for storing  \n      //---- Ibject memebers \n      private Dictionary<string, Object> props = \n      new Dictionary<string, object>(); \n\n      public DynamicClass() { } \n\n      //------- Retrieve value from a member \n      public override bool TryGetMember(GetMemberBinder binder,  \n      out object result){ \n        string name = binder.Name.ToLower(); \n        return props.TryGetValue(name, out result); \n      } \n      public override bool TrySetMember(SetMemberBinder binder, \n      object value){ \n        props[binder.Name.ToLower()] = value; \n        return true; \n      } \n    } \n\n    class Program{ \n      static void Main(string[] args){ \n dynamic dc = new DynamicClass(); \n        //--------- Adding a property \n        dc.hell = 10; \n        //--------read back the property... \n        Console.WriteLine(dc.hell); \n        //------- Creating an Action delegate... \n        Action<int> ts = new Action<int>( delegate(int i ) { \n          Console.WriteLine(i.ToString()); \n        }); \n        //------------Adding a method.... \n        dc.rs = ts; \n        //----------- invoking a method.... \n        dc.rs(100); \n        Console.Read(); \n      } \n    } \n  } \n\n```", "```cs\n    using System; \n    using System.Collections.Generic; \n    using System.Linq; \n    using System.Text; \n    using System.Dynamic;  \n\n    namespace TestVS \n    { \n      class Program \n    { \n      static void Main(string[] args){ \n dynamic ds = new ExpandoObject();\n //---- Adding a property \n        ds.val = 20; \n        Console.WriteLine(ds.val); \n        //---- Assign a new value to the \"val\" property \n        //-----This is possible because of dynamic typing  \n        ds.val = \"Hello World...\"; \n        Console.WriteLine(ds.val); \n        //---------------- Wait for the Keyboard input \n        Console.Read(); \n      } \n    } \n  } \n\n```", "```cs\n    //-- Chap1_05.cs \n    using System; \n    using System.IO; \n using System.Threading.Tasks; \n\n    class Program \n    { \n      static void Main() { \n        //--- Create a Task to Start processing \n        Task task = new Task(ProcessCountAsync); \n task.Start();\n task.Wait(); \n        Console.ReadLine(); \n      } \n\n static async void ProcessCountAsync() \n    { \n      // Start the HandleFile method. \n      Task<int> task = HandleFileAsync(@\".\\WordCount.txt\"); \n      // \n      // -------- One can do some lengthy processing here \n      //  \n      int x = await task; \n      Console.WriteLine(\"Count: \" + x); \n    } \n\n static async Task<int> HandleFileAsync(string file) \n    { \n      int count = 0; \n      using (StreamReader reader = new StreamReader(file)) \n      { \n        string v = await reader.ReadToEndAsync(); \n        count += v.Length; \n      } \n      return count; \n    } \n  } \n\n```", "```cs\n    //--Chap1_06.cs \n    using System; \n\n    class SingleInstance \n    { \n      private int value = 10; \n      //----- In the case of Singleton Pattern, we make our \n      //----- ctor private to avoid instantiating the object using \n      //----- the new keyword \n      private SingleInstance() { } \n\n      //----- The static method acts as a mechanism to expose \n      //------ the internal instance \n      public static SingleInstance Instance {  \n        get {  \n          return Nested.instance; \n        }  \n      } \n\n      private class Nested \n      { \n        static Nested() { } \n        internal static readonly SingleInstance instance \n        = new SingleInstance(); \n      } \n      public void Increment() \n      { \n        value++; \n      } \n      public int Value { get { return value; } } \n    } \n\n    public class SingletonExample \n    { \n      public static void Main(String[] args) \n    { \n      SingleInstance t1 = SingleInstance.Instance; \n      SingleInstance t2 = SingleInstance.Instance; \n      t1.Increment(); \n      if (t1.Value == t2.Value) \n        Console.WriteLine(\"SingleTon Object\"); \n    } \n  } \n\n```"]