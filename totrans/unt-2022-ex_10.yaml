- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polishing the Player’s Actions and Enemy Behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B18347_06.xhtml#_idTextAnchor116), we added a ranged weapon
    shooting mechanic in an optimized way using Unity’s new **object** **pooling**
    **API**.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will continue to add some much-needed polish to the player
    character with visual effects! We’ll also create some enemy **non-player character**
    (**NPC**) variants and finish up the chapter by introducing enemy behavior through
    a state pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Polishing with **Shader Graph** and **Trail Renderer**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enemy Prefabs and variants – Configuring with **Scriptable** **Objects** (**SOs**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing basic enemy behavior using a **finite state** **machine** (**FSM**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be able to quickly add some visual effect
    polish to the game’s sprites using a custom shader and make several enemy variants
    configured with varying properties and simple state-based behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Download the assets from the following GitHub link to follow along in this chapter
    with the same artwork created for the project in the book.
  prefs: []
  type: TYPE_NORMAL
- en: To follow along with your own artwork, you’ll need to create similar artwork
    using Adobe Photoshop or a graphics program that can export layered Photoshop
    PSD/PSB files (e.g., Gimp, MediBang Paint, Krita, and Affinity Photo).
  prefs: []
  type: TYPE_NORMAL
- en: You can download the complete project on GitHub at [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example).
  prefs: []
  type: TYPE_NORMAL
- en: Polishing with Shader Graph and Trail Renderer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To really sell the game experience to the player, we can employ some easy-to-execute
    visual polish. Thankfully, Unity provides visual effect features through some
    built-in components and includes relevant features as part of its render pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’ll look at adding a few simple effects to the player, bullet projectile,
    and the overall visual look.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling post-processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To take advantage of any of the effects we’ll be implementing in this section,
    we’ll first want to enable **post-processing** as it applies to the **Universal
    RP** (**URP**) (reminder: this is the render pipeline we are working with).'
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, the effects we’ll be making will use **high dynamic range** (**HDR**)
    color values that will work with a post-processing bloom effect to make our 2D
    lights and parts of our sprite assets glow.
  prefs: []
  type: TYPE_NORMAL
- en: HDR color | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: HDR color values offer a wider range of luminosity than standard colors, resulting
    in more accurate depictions of color and brightness, more vibrant colors, improved
    support for bloom and glow effects, and reduced banding.
  prefs: []
  type: TYPE_NORMAL
- en: 'High dynamic range: [https://docs.unity3d.com/Manual/HDR.xhtml](https://docs.unity3d.com/Manual/HDR.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: For a look at what’s to come in the following sections, as seen in *Figure 7**.1*,
    we’ll apply **Vignette** to the screen and add **Bloom** to make the white parts
    of the bullet sprite glow (exaggerated for clarity).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we can’t make the bullet glow with **Bloom** alone, so we’ll cover
    how to accomplish this, plus **Vignette**, in the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Post-processing effects applied to the scene](img/B18347_07_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Post-processing effects applied to the scene
  prefs: []
  type: TYPE_NORMAL
- en: A word of caution
  prefs: []
  type: TYPE_NORMAL
- en: Some post-processing effects are performance-heavy and are not suitable for
    all distribution platforms (mobile in particular), so pay attention to your **frames
    per second** (**FPS**) stats when adding new effects!
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable post-processing in our game, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: For the camera in the current scene, select **Main Camera** in the **Hierarchy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the **Rendering** section (refer to *Figure 7**.1*), enable **Post Processing**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `Assets/Settings` folder and select the `UniversalRP` asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the **Quality** section, enable **HDR**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have post-processing enabled, we can start adding **volume overrides**
    that will work with the effects we’ll be adding to our objects. To do that, we’ll
    need to add a volume to our scene and add the volume overrides by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the **Scene Hierarchy**, use the **Create** menu and select **Volume**
    | **Global Volume**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `Global Volume` object still selected, in the Inspector, on the `Volume`
    component’s `Volume Profile` asset. This will create an asset file named `Global
    Volume Profile` in a subfolder with the same name as your scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With a profile assigned, we now see a new **Add Override** button (refer to
    *Figure 7**.1*). Click it and select **Post Processing** | **Vignette**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the checkbox to the left of **Intensity** to enable it, then raise the
    value to see the *screen-edge-darkening* effect in both **Scene** and **Game**
    views.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, repeat adding another override, but this time select `1` – pixels in the
    scene with a brightness lower than this value will not have the effect applied
    by URP. The default value is `0.9` (which is great in most cases), but I’ve decided
    to give almost any object the potential to contribute glow to the overall look,
    so I raised it slightly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable `1.15` to make things glow pretty good as an initial visual check, but
    I will be dialing this down later, I’m sure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Post-processing and full-screen effects: [https://docs.unity3d.com/2022.3/Documentation/Manual/PostProcessingOverview.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/PostProcessingOverview.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Post-processing in the Universal Render Pipeline: [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4015.0/manual/integration-with-post-processing.xhtml](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4015.0/manual/integration-with-post-processing.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: Now that things look more cinematic and have the potential to emit some cool
    glow effects, let’s finally set up our bullet Prefab sprite!
  prefs: []
  type: TYPE_NORMAL
- en: Applying glow to the bullet with Shader Graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You previously saw how we added a secondary texture to a sprite when we added
    sprite Normal maps in [*Chapter 4*](B18347_04.xhtml#_idTextAnchor079) (for giving
    a pseudo-3D effect to sprites).
  prefs: []
  type: TYPE_NORMAL
- en: We’ll now use a `1`, which will be possible by using an HDR color value).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 7**.2*, you can see the artwork for the bullet as well as the bullet’s
    **emission map** – a black-and-white image where the white areas define parts
    that will be emissive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Emission map for bullet sprite](img/B18347_07_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Emission map for bullet sprite
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the screenshot, we’ve created an emission map named `bullet1_emission`
    that represents only the swirly lines of the bullet sprite. Going back to the
    `bullet 1` sprite, select it so that we can add the emission map as a secondary
    texture by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the sprite’s **Import Options** section in the Inspector, click the **Sprite**
    **Editor** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Secondary Textures** from the **Sprite Editor** drop-down menu (top-left
    corner of the window).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Secondary Texture** dialog, click the plus (**+**) button to add a
    new texture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `_Emission` in the **Name** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **bullet1_emission** sprite from the **Project** window into the **Texture**
    field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Apply** button to save the changes (or simply close the window and
    choose **Save**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a refresher, you can refer to [*Chapter 4*](B18347_04.xhtml#_idTextAnchor079),
    *Figure 4**.2*, for an example of the **Secondary** **Texture** dialog.
  prefs: []
  type: TYPE_NORMAL
- en: With our sprite ready to go, we can move on to creating a new shader for applying
    our effect.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new Shader Graph 2D material
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating custom shaders used to be complicated by hand-coding them in a special
    shader language, but **Shader Graph** allows custom shaders to be authored visually
    in real time using a node-based system, making the process more accessible to
    artists and developers alike.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use **Shader Graph** to create and connect nodes visually to build out
    our emission shader. Note that this shader can be the basis for any number of
    materials we can use to make different sprites with emission maps glow!
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting started with Shader Graph: [https://docs.unity3d.com/Packages/com.unity.shadergraph%4014.0/manual/Getting-Started.xhtml](https://docs.unity3d.com/Packages/com.unity.shadergraph%4014.0/manual/Getting-Started.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go ahead and create this glow shader now with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a new `root` folder in the `Assets/Shaders`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a shader graph in the new folder by using the `SpriteEmission_Unlit`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, open the **Shader Editor** by clicking the **Open Shader Editor** button
    in the Inspector or double-clicking on the asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The custom sprite shader we’re going to create is actually pretty simple and
    will only require a few nodes, as seen in the completed shader in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Shader Graph sprite emission shader](img/B18347_07_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Shader Graph sprite emission shader
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s construct this shader by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, starting in the **Blackboard** (*A* in *Figure 7**.3*) using the plus
    (**+**) button, add the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MainTex` and `_MainTex` (these fields are assigned in the **Graph Inspector**
    indicated by *B* in *Figure 7**.3*), then drag in the bullet sprite as the **Default**
    texture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that it is essential that **Reference** is spelled correctly since this
    is what the shader uses internally for the texture reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Emission` and `_Emission` (note this is what we previously used as the name
    for the emission map secondary texture in the **Sprite Editor**), then drag in
    the **Bullet Emission Map** sprite as the **Default** texture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Color` and `_Color`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These properties will be exposed in the Inspector so that we can assign values.
    `_MainTex` and `_Emission` will be obtained from the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create and connect the nodes that make up this simple shader:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click anywhere and select **Create Node** from the pop-up menu (or just
    press the spacebar).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start typing to search for the desired node to add. In our case, start typing
    `sample texture 2d` and select it from the list under **Input** | **Texture**.
    Let’s add two of these texture nodes – we’ll need one for **MainTex** and one
    for **Emission** (refer to *Figure 7**.3* as a reference).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s complete the **MainTex** path first. Create an **Add** node next and
    then make the following connections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**MainTex(T2)** à **[SampleTexture2D] Texture(T2)** | **RGBA(4)** à **[Add]
    A(4)** | **Out(4)** à **[****Fragment] SpriteColor(4)**'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: A node is indicated as **[Node]**, connecting lines are shown by à (clicking
    and dragging on the little circles on the nodes), and input/output is displayed
    by | (input on the left side, output on the right side).
  prefs: []
  type: TYPE_NORMAL
- en: 'Complete the **Emission** path next by using the second **SampleTexture2D**
    node we previously added. Create a **Multiply** node and make the following connections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Emission(T2)** à **[SampleTexture2D] Texture(T2)** | **R(1)** à **[Multiply]
    A(4)** | **Out(4)** à**[Add] A(4)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we’ll finish up the shader by connecting the **Color** property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Color(4)** à **[Multiply] B(4)** | **Out(4)** à **[****Add] B(4)**'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the completed shader graph
  prefs: []
  type: TYPE_NORMAL
- en: 'For the completed sprite emission shader, visit the project GitHub repo here:
    [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Shaders](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Shaders)'
  prefs: []
  type: TYPE_NORMAL
- en: Before we can apply our fancy new emission shader to our bullet Prefab, we’ll
    have to create a new **material** based on this shader – that’s how it works.
    Rendering in Unity (and most digital content creation software) is performed with
    materials, shaders, and textures, each contributing their part to what the end
    user sees on screen.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Graphics: [https://docs.unity3d.com/2022.3/Documentation/Manual/Graphics.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/Graphics.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new material based on this new shader graph we just created by right-clicking
    on the shader asset named `SpriteEmission_Unlit` in the `Assets/Shaders` folder
    of the **Project** window, then follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to `Bullet 1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, create a new folder at `Assets/Materials` and move the material into that
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the material to the bullet sprite by first opening the `Bullet 1` Prefab
    (either in the scene or in **Prefab Mode**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the bullet sprite visible in the scene view, drag the `Bullet 1` material
    from the **Project** window and onto the sprite. Unity provides a visual indicator
    for what the new material would look like if applied to the sprite before you
    commit to releasing the mouse button (a pretty neat trick; this also works the
    same for assigning materials to 3D objects).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, this is where the magic happens. Select the `bullet1` sprite in the **Hierarchy**
    to show its Inspector, expand the **Material** section at the bottom, and then
    click on the color picker (note that you should exit **Prefab Mode** because post-processing
    is not visible there). Then, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Color** field to an appropriate glow color and then kick up the **Intensity**
    value for the desired amount of glow (as seen in *Figure 7**.4*, but remember
    that the post-processing **Bloom** effect’s **Intensity** value is also at work
    here).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is the final result of our efforts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Bullet material HDR color setting](img/B18347_07_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Bullet material HDR color setting
  prefs: []
  type: TYPE_NORMAL
- en: We are looking good – yay!
  prefs: []
  type: TYPE_NORMAL
- en: Bonus activity
  prefs: []
  type: TYPE_NORMAL
- en: Add a material based on the **SpriteEmission_Unlit** shader for both the player
    character and weapon!
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from our simple shader, it doesn’t take much effort to pump up
    the visuals of your games in Unity! For another quick win on the game’s visuals,
    let’s add a subtle light effect to the player character to make it pop out in
    the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a 2D light to the player
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a very quick and easy effect to add but with a huge payoff. All we’re
    going to do here is add a **2D light** as a child of **Player**. With the light
    parented to **Player** – and within the **Prefab** **Hierarchy** – it will be
    *attached* to the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use these steps to add the light:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the root object of the `Player` Prefab in the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Working with Prefabs
  prefs: []
  type: TYPE_NORMAL
- en: 'A reminder for working with Prefabs: if you add the **Light** object in **Prefab
    Mode** (by double-clicking on the Prefab in the **Project** window), you won’t
    be able to visualize changes to the light settings. You can, however, enter the
    **Prefab Isolation** mode in the scene by clicking the chevron icon (*>*) in the
    **Hierarchy** window and still be able to visualize changes. Lastly, you can modify
    the Prefab directly in the scene but just remember to apply **Overrides** to save
    changes to the Prefab.'
  prefs: []
  type: TYPE_NORMAL
- en: From the menu, select **Light** | **Spot** **Light 2D**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Adjust the values to your liking. Referring to *Figure 7**.5*, these are the
    settings I used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Positioned the light on the chest of the character
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0.6`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1.5` (*Inner*), `7` (*Outer*)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0.01` (just add a touch here for a small contribution to the environment lighting)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3` (*Distance*)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The before and after can be seen in *Figure 7**.5*. Notice how the player pops
    out of the environment on the right, whereas things look rather flat on the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Making the player pop out with a 2D light](img/B18347_07_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Making the player pop out with a 2D light
  prefs: []
  type: TYPE_NORMAL
- en: That was easy! Let’s gain another quick win with an additional visual effect
    that is simple to add!
  prefs: []
  type: TYPE_NORMAL
- en: Polishing is easy with Trail Renderer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Trail Renderer` component creates, well, a trail following a moving object.
    It’s a great way to add more impactful movement to things, and it can be as subtle
    or over the top as you wish by adjusting only a few settings.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll get right to it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a trail to Prefabs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Follow these steps to add a trail to our bullet:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Bullet 1** Prefab for editing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Create** menu and add **Effects** | **Trail** (parented to the root
    as a sibling of the **bullet1** sprite).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Adjust the values to give a nice trailing effect! Here are the values I used
    as a starting point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`(0.0, 0.2)`, `(0.5, 0.0)` – using this curve will ensure that the trail doesn’t
    extend to be too long'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0.2`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`35` to `0`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Package/Universal RP/Runtime/Materials`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lighting** = **Off** (cast shadows)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These settings, and the results, can be seen in *Figure 7**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Visualizing Trail Renderer component on bullet Prefab](img/B18347_07_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Visualizing Trail Renderer component on bullet Prefab
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget that you’ll also have to set the `Bullet 1` Prefab’s sprite renderer,
    the ground, and foreground/background sorting layers.
  prefs: []
  type: TYPE_NORMAL
- en: Clearing trails for pooled Prefabs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Trail Renderer` component creates a trail of polygons behind the bullet
    GameObject (that’s how the trail is rendered), which will still be there even
    if the GameObject is deactivated in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s a problem for us because that’s exactly what we’re doing with object
    pooling: deactivating the GameObject projectile when it’s returned to the pool.'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the `Trail Renderer` component provides a `Clear()` method for
    clearing the trail. All we need to do is call this method when we initialize the
    projectile, and voilà! Problem solved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `ProjectileBase` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’re simply using `TryGetComponent<TrailRenderer>()` to see if a `TrailRenderer`
    component has been added to the GameObject and only returning a reference to it,
    with an `out` parameter, if it exists. If the component does not exist, then an
    allocation will not be made, unlike with `GetComponent()`.
  prefs: []
  type: TYPE_NORMAL
- en: We use an `if` statement to evaluate the `bool` return value from `TryGetComponent()`,
    so only if we have a `Trail Renderer` component on the projectile will the `Clear()`
    method be called (essentially, resetting it).
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**Component.TryGetComponent**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Component.TryGetComponent.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Component.TryGetComponent.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to enable post-processing and add effect overrides
    such as **Vignette** and **Bloom**, making our bullet glow and our player pop
    with light. We finished up with an easy-peasy trail effect on our bullet as well!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll add a configurable enemy character and variants of the same.
  prefs: []
  type: TYPE_NORMAL
- en: Enemy Prefabs and variants – Configuring with SOs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of a GameObject that has to live in a scene, we can create a file-based
    asset that can be referenced from any GameObject, including Prefabs, anywhere
    in the game, called an SO.
  prefs: []
  type: TYPE_NORMAL
- en: This being a single asset reference means no additional allocations are needed,
    and the same values are used no matter how many objects in the scene are spawned
    that reference it. Pretty cool!
  prefs: []
  type: TYPE_NORMAL
- en: An SO, as a small and efficient data container, also allows the separation of
    data from the code that consumes it. Data can be updated from backend cloud systems
    without recompiling the code or building a new distribution of the entire game.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to respond to data changes for games in production – where an issue
    affecting players may need to be solved quickly – is an excellent application
    of SOs.
  prefs: []
  type: TYPE_NORMAL
- en: Others have used SOs for middleware components and even fully decoupled event
    systems that are designer-friendly because they allow configuration at design
    time in the Editor (that is, a developer is not required to wire up new events
    between objects, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Unity has also built complete game architecture based on SOs in its *Open Projects*
    development program. And there would be something amiss if I didn’t mention Ryan
    Hipple’s (Schell Games) now infamous *Game Architecture with Scriptable Objects*
    talk at Unite Austin 2017 (link provided in the *Additional material – Unity documentation*
    callout box), where he describes how SOs can be used for building more extensible
    systems and data patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Additional material | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'ScriptableObject: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-ScriptableObject.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-ScriptableObject.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Projects: [https://unity.com/open-projects](https://unity.com/open-projects)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unite Austin 2017 - Game Architecture with Scriptable Objects: [https://youtu.be/raQ3iHhE_Kk](https://youtu.be/raQ3iHhE_Kk)'
  prefs: []
  type: TYPE_NORMAL
- en: With that bit of introduction out of the way, we’ll go on now to create our
    first SO and use it to configure the traits of our enemies.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an enemy Prefab with configurations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An SO is created in a similar way to a `MonoBehaviour` script with some exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: The SO must inherit from `ScriptableObject` instead of `MonoBehaviour`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It cannot be attached to a GameObject (as a component). Instead, it is saved
    as a file asset and referenced by components as a field exposed in the Inspector.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not receive all of the same Unity message events that a `MonoBehaviour`
    script does (missing, most notably, are `Start()`, `Update()`, and `FixedUpdate()`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can create new custom assets based on the `ScriptableObject` class by using
    `CreateAssetMenu`. In contrast, `MonoBehaviour` can only be configured in the
    scene and saved as a Prefab (it can then be edited in the **Prefab Mode**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *script template* for a new enemy configuration data SO asset would look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see the `[CreateAssetMenu()]` attribute that will create a new
    menu entry in the Editor to facilitate making new file assets based on this `EnemyConfigData`
    SO.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going to the **Project** window and selecting **Create** | **ScriptableObjects**
    | **EnemyConfigData**, we can create multiple enemy configuration assets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Create ScriptableObjects asset menu](img/B18347_07_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – Create ScriptableObjects asset menu
  prefs: []
  type: TYPE_NORMAL
- en: The member fields declared for `Speed`, `AttackRange`, `FireRange`, and so on
    provide configurable data for different types of enemies. There aren’t any currently
    defined in the previous code, but you can also create methods (for encapsulating
    fields, returning calculations, helper methods, and ticks as examples).
  prefs: []
  type: TYPE_NORMAL
- en: Create a new script named `EnemyConfigData` in a new `Assets/Scripts/Data` folder
    using the preceding `ScriptableObject` template.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the adventure game, and referring to our **Game Design Document**
    (**GDD**) in [*Chapter 4*](B18347_04.xhtml#_idTextAnchor079), *Table 4.3*, we’ll
    introduce two kinds of enemy characters (including the dull and uninteresting
    *maintenance robot*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and create two enemy configuration data assets named `Enemy A Config`
    and `Enemy B Config` in a new `Assets/Data` folder with some default values assigned
    to give each robot unique characteristics, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Multiple assets for enemy configurations](img/B18347_07_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – Multiple assets for enemy configurations
  prefs: []
  type: TYPE_NORMAL
- en: As you can also conclude from the preceding screenshot, the evil alien plant
    entity has had its way with the maintenance robots, which are now under its control!
    No – not that exactly, but I’ve already imported and set up the enemy actors we’ll
    be applying the configuration data to.
  prefs: []
  type: TYPE_NORMAL
- en: The process to import, rig, create a Prefab, add **inverse kinematics**(**IK**),
    and then add animation is the same workflow we performed for the player character.
    To revisit this workflow, return to the *Setting up the player character with
    PSD Importer* section of [*Chapter 5*](B18347_05.xhtml#_idTextAnchor096).
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and create Prefabs of the two enemies – **Enemy A** and **Enemy B**
    – using the artwork provided in the GitHub project repo; create your own, or cheat
    and download the already completed enemy Prefabs from the project repo (preferably,
    don’t choose this last option, as you’ll need the practice).
  prefs: []
  type: TYPE_NORMAL
- en: Adventure game 2D art assets
  prefs: []
  type: TYPE_NORMAL
- en: 'To follow along in this chapter, download the art assets from the project GitHub
    repo here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Art-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Art-Assets)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whew! Now that we have enemy Prefabs, we can add a component that will utilize
    the enemy configuration data. Create a new script named `EnemyController` in the
    `Assets/Scripts` folder – note that we’re back to creating a `MonoBehaviour` script
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: By now, this simple script should make a lot of sense to you. We added a field
    declaration named `_config` and of the type `EnemyConfigData`. We gave it an explicit
    protection keyword of `private` for the accessor so that no other script can reach
    it but added the `[SerializeField]` attribute so that we can make an assignment
    in the Inspector.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve the configuration in the following screenshot, drag the `EnemyConfigData`
    script to the `Enemy B` Prefab (on the root object), then drag the `Enemy B Config
    ScriptableObject` asset in the `Assets/Data` folder to the `EnemyController` component.
    We’ve just added variable configuration data to our enemy! Repeat for `Enemy A`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Enemy B configuration](img/B18347_07_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – Enemy B configuration
  prefs: []
  type: TYPE_NORMAL
- en: To quickly access the `ScriptableObject` asset for editing the values, double-click
    on the `ScriptableObject` asset reference assigned to the **Config** field. Alternatively,
    you can open a **Focused Inspector** by right-clicking on the asset in the **Project**
    window and selecting **Properties**.
  prefs: []
  type: TYPE_NORMAL
- en: This way, you can view and edit the data without the Inspector changing to other
    selected objects/assets as you work (an example of this can be seen in *Figure
    7**.8* with both of the enemy configurations open).
  prefs: []
  type: TYPE_NORMAL
- en: Opening a **Focused Inspector** is also an alternative to locking the Inspector
    to a single object, which you can do by clicking the little lock icon at the top
    right of the **Inspector** window (as shown in *Figure 7**.9*).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our enemy characters, let’s see how to easily add some variation
    by extending upon these base Prefabs with Prefab Variants!
  prefs: []
  type: TYPE_NORMAL
- en: Creating an enemy variant for alternate enemy types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When Unity finally added native support for **Nested Prefabs** (circa Unity
    2018.3), it also included a great new feature called **Prefab Variants**, which
    are extremely useful for having a unique set of variations that are all based
    on the same basic Prefab properties.
  prefs: []
  type: TYPE_NORMAL
- en: A base Prefab will have all the basic behaviors required by the object, and
    then several variations can be created that override properties to make changes
    to the behavior or appearance of the object.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, using an enemy Prefab as an example, assigning a unique set of
    configuration values through an `EnemyConfigData` asset overrides the base Prefab.
    This may also include changes in color, artwork, or components.
  prefs: []
  type: TYPE_NORMAL
- en: We accomplish varying the configuration data by creating additional `EnemyConfigData`
    assets for each of the different enemy characteristics we’re looking to have in
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '*Prefab* *Variants*: [https://docs.unity3d.com/2022.3/Documentation/Manual/PrefabVariants.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/PrefabVariants.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Prefab Variant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s create a variation of the `Enemy B` Prefab with an increased difficulty
    level for the player by making it move faster, shoot further, and have a quicker
    rate of fire by shortening the cooldown period.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, let’s take these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll duplicate the `Enemy B Config EnemyConfigData` asset file in the
    `Assets/Data` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `Enemy B Config` asset in the `Enemy B` `Config Difficult`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: On the new asset, adjust the values for `70`, `60`, and `60`, respectively).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, change to the `Assets/Prefabs` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `Enemy B` Prefab, then select `Enemy` `B Difficult`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: With the new variant selected and the `Assets/Data` folder and drag the `Enemy
    B Config Difficult` asset to the `EnemyController` component.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have an `Enemy B` Prefab with different SO configuration data assigned
    to it, but the remainder of the enemy object is exactly the same since we only
    overrode the field assignment.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7**.10* shows what our new enemy Prefab variant looks like in the Editor
    with the difficult enemy configuration SO data assigned: *A* is the difficult
    enemy Prefab, *B* shows that this Prefab has a `Base` Prefab it is a variant of,
    and *C* shows the SO **Config** field assignment override:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Difficult Enemy B Prefab Variant setup](img/B18347_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – Difficult Enemy B Prefab Variant setup
  prefs: []
  type: TYPE_NORMAL
- en: We can repeat this process for creating different types of enemies or any other
    type of Prefab that we’ll use in the game. Think about maybe having the maintenance
    robots start the game without any plant infestation and then gradually build up
    the infestation as the game progresses. We can use Prefab Variants for the different
    stages by simply overriding the art assets. Prefab Variants can make progressive
    changes to art easy to achieve!
  prefs: []
  type: TYPE_NORMAL
- en: By using the SO to override the configuration data, we have separated the data
    from the Prefab asset (including various components, art assets, sound, effects,
    and so on). The SO data is a small object that can be updated outside of having
    to edit the Prefab, which makes things more accessible to designers and non-programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if only the data needs to change, then it’s a tiny update that can be
    pushed to games in production without having to push the entire Prefab asset.
  prefs: []
  type: TYPE_NORMAL
- en: From this section, having a set of enemies with unique variations is great,
    but it would be even better if they had some behavior based on their configuration
    data!
  prefs: []
  type: TYPE_NORMAL
- en: The next section will look at adding behavior to the enemy robots.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing basic enemy behavior using an FSM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B18347_02.xhtml#_idTextAnchor041), we briefly introduced the
    State Pattern, so we’ll now look at how to implement this design pattern for keeping
    the state of our enemy characters. Expressly, using an FSM, we can declare the
    fixed set of states (that is, finite) our enemy can be in at any given time –
    and the FSM is only going to do precisely these things.
  prefs: []
  type: TYPE_NORMAL
- en: The first implementation of our FSM will not adhere to SOLID principles very
    well, but it will hopefully be a simple enough introduction that will make sense
    practically. We can also use it as an example to point out any flaws with the
    approach and later refactor it to something better.
  prefs: []
  type: TYPE_NORMAL
- en: I should note that maybe we won’t refactor it later… sometimes a simple approach
    is all that is required, and refactoring for the sake of refactoring is just wasted
    effort where that time could be better spent on tightening up the core game mechanic
    instead, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Programming patterns
  prefs: []
  type: TYPE_NORMAL
- en: 'Finite state machine explained: [https://www.freecodecamp.org/news/finite-state-machines/](https://www.freecodecamp.org/news/finite-state-machines/)'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by having a look at which states – or behaviors – we want for our
    enemy characters.
  prefs: []
  type: TYPE_NORMAL
- en: State Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Referring back to our GDD in [*Chapter 4*](B18347_04.xhtml#_idTextAnchor079),
    *Table 4.1*, where we loosely defined the behaviors of our enemy during engagement
    with the player, we can derive the following minimum states being required: **Idle**,
    **Patrol**, **Attack**, **Dead**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can take those states and design a UML state diagram for our enemy
    behaviors. Conditions for determining when to change between the states are also
    defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Enemy behavior State Model](img/B18347_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – Enemy behavior State Model
  prefs: []
  type: TYPE_NORMAL
- en: 'Referring to the diagram and using the conditions to determine when to transition
    from one state to another, we can observe the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The default starting state is **Idle**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While in the **Idle** state, we will transition to **Patrol** when a timer expires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While in the **Patrol** state, we will transition back to **Idle** when a timer
    expires (for example, **Idle** --> **Patrol** --> **Idle** --> **Patrol**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While in the **Idle** or **Patrol** state, we will transition to **Attack**
    when the player is in range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While in the **Attack** state, we will go back to **Patrol** when the player
    moves out of range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will transition from any state to **Dead** when health is zero
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know which states we need and which conditions change state, we
    can move on to coding up this thing!
  prefs: []
  type: TYPE_NORMAL
- en: A simple FSM pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll make our first FSM using enums for defining our finite states and code
    the state-changing logic within the `EnemyController` class. This code is similar
    to what you’ll likely run across in projects for beginners because it’s easy to
    understand and simple to work with (and, as mentioned previously, may be all that
    is required).
  prefs: []
  type: TYPE_NORMAL
- en: But it does have some limitations and drawbacks. The first one is that the state
    machine is integral to the `EnemyController` class, violating the **Single Responsibility**
    **Principle** (**SRP**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we have defined the FSM states from our State Model in the `public
    enum State {}` declaration line. Our FSM can only be in one of these defined states.
    Then, we’ll use the `_currentState` variable to keep track of our current state.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s skip down to the `ChangeState()` method, where we can see we’ll call it
    by passing in a `State` to set it as the current state of the FSM (that is, transition
    to a different state). In `Start()`, you can see how we call `ChangeState(State.Idle)`
    to set our initial (default) state for **Enemy** to **Idle**.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, in the `Update()` method (called every frame update), we have a `switch`
    statement that has an implementation for each state declared in the `State` enum.
    When `_currentState` is equal to one of the defined enum states, we *do stuff*
    – you can relate the `switch` statement to a block of `if`, `else if`, `else if`
    statements (but it’s undoubtedly more readable for when we don’t need to test
    expressions for ranges of values or conditions).
  prefs: []
  type: TYPE_NORMAL
- en: switch (C#)
  prefs: []
  type: TYPE_NORMAL
- en: A **switch** statement is a *selection control* statement that tests an expression
    (similar to an **if** statement) and executes the matching block of code defined
    by the cases (and as terminated by the **break** statement). A default case can
    be defined if there is no match for the expression.
  prefs: []
  type: TYPE_NORMAL
- en: I don’t necessarily have a problem with this oversimplified approach to a State
    Pattern, but the `switch` statement quickly gets ugly. With many states, it can
    start getting hard to manage, as we’ll see when we start adding conditions and
    behaviors to it, but at least it doesn’t rely on an arbitrary number of Boolean
    variables to attempt and maintain some form of state (and without having to wrangle
    two of those variables becoming true simultaneously – yikes!).
  prefs: []
  type: TYPE_NORMAL
- en: One problem with the enum-based approach that breaks the *O* in SOLID (`EnemyController`
    class (that is, closed for modification). Preferably, we’d like only to change
    the affected state’s code and not touch anything else!
  prefs: []
  type: TYPE_NORMAL
- en: Code that functions and has nothing to do with the state should not have to
    be retested (for example, acceptance and regression testing) or, in a team environment,
    even be code reviewed while committing the modification for the state to the **version
    control** **system** (**VCS**).
  prefs: []
  type: TYPE_NORMAL
- en: At the very least, this enum-based approach provides a structure that makes
    the code more readable than without it, and it’s simple to include the State Pattern
    without first having to write boilerplate code for the state machine.
  prefs: []
  type: TYPE_NORMAL
- en: You may be able to imagine how we could extend this State Pattern by encapsulating
    all of a particular state’s behaviors (and data) into a single class. If so, great!
    If not, no worries, since we’ll tackle refactoring this FSM later on in [*Chapter
    13*](B18347_13.xhtml#_idTextAnchor256)!
  prefs: []
  type: TYPE_NORMAL
- en: Okay – with the caveats out of the way, let’s change some states!
  prefs: []
  type: TYPE_NORMAL
- en: Changing state behaviors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have our finite set of states defined and coded in our simple FSM
    pattern, you may wonder how we add in the conditions for changing state. Wonder
    no more – it’s pretty simple!
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by adding the required fields and assigning default values to evaluate
    our conditions for the first two states.
  prefs: []
  type: TYPE_NORMAL
- en: Idle and patrol behaviors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Referring to the **State Model** in *Figure 7**.11*, let’s have the enemy patrol
    a path between two positions (we’ll define in the level) after remaining idle
    (stationary) for a specific time. Then, after patrolling for a particular time,
    we’ll have our enemy return to idling, and repeat the process indefinitely while
    the enemy is not attacking the player or, well, is dead.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, let’s first add two variables to our `EnemyConfigData` SO that will
    specify our times for how long the enemy will idle and patrol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Don’t forget that you can override these default time values in the Editor by
    selecting the `Enemy B Config` asset in the `Assets/Data` folder and changing
    the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, back in the `EnemyController` class, we’ll need a way to track when we
    changed into a state to calculate the time elapsed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We’ve added the `_timeStateStart` float variable that we set to the current
    game time in the `ChangeState()` method (which has been changed to a body block
    from an expression body). Calling the `ChangeState()` method provides a way for
    us to do things *on the state entered* rather than just setting the `_currentState`
    variable directly to the new state we’re transitioning to (which doesn’t afford
    us the option).
  prefs: []
  type: TYPE_NORMAL
- en: 'With the required fields and assigned values now set up, we can proceed to
    evaluate the conditions for changing to/from the **Idle** and **Patrol** states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, we have a new `if` block that evaluates
    the current time, `Time.time`, minus the time we transitioned into the current
    state, `_timeStateStart`. If the difference is greater than or equal to our configured
    time to remain idle, `_config.TimeIdle`, then call the `ChangeState()` method
    to transition to the **Patrol** state. Easy-peasy!
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we will evaluate transitioning from `_configTimePatrol` value (that
    is, how long the enemy should patrol for). And now, you may be wondering: how
    do we make the enemy character actually patrol?'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the `EnemyController` class, but instead of doing that again, and getting
    too far away from Single Responsibility, let’s at least abstract the behaviors
    into their own classes.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll therefore define behaviors via an interface so that we can swap out the
    behavior code, should we need or want to change it without modifying the class
    that implements it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, create a new C# script named `IBehaviorPatrolWaypoints` in the `Assets/Scripts/Interfaces`
    folder and add the following interface declaration for a *patrol* *waypoints behavior*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that we’ve declared two points in the level that will create
    the path the enemy will patrol between as `WaypointPatrolLeft` and `WaypointPatrolRight`.
    We’ll place an empty GameObject at each position in the level and assign their
    references to these fields in the Inspector.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help visualize the concept of a patrol path better, referring to the following
    diagram, the dots (blue) represent the waypoints (that is, the empty GameObjects),
    and the dashed line (orange) represents the patrol path created from the waypoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Waypoints and patrol path](img/B18347_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – Waypoints and patrol path
  prefs: []
  type: TYPE_NORMAL
- en: (Spoiler… players should hide in the square area (green) just south of the wall
    to avoid patrolling agents’ gaze. Look out!)
  prefs: []
  type: TYPE_NORMAL
- en: Back to the code, we then have an `Init()` method that will be called from the
    implementing class that will pass in (or, you might say, *inject*) the required
    dependencies the behavior needs to function as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Last is the declaration for the `TickPhysics()` method that will be called by
    the implementing class’s `FixedUpdate()` method to perform the actual function
    of moving the enemy between the waypoints (using physics).
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the `EnemyController` class now, let’s create a variable of type `IBehaviorPatrolWaypoints`.
    We’ll obtain the reference to an instance of it – which should exist as a sibling
    component on the `EnemyController` object – by using `TryGetComponent()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is how we can swap out behaviors with other behaviors of the same type
    without modifying the implementing class. By using Unity’s `GetComponent()` architecture
    – which allows a form of `MonoBehaviour`) that implement `IBehaviorPatrolWaypoints`
    and obtain the component instance via the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Composition (OOP)
  prefs: []
  type: TYPE_NORMAL
- en: '**Composition** is usually referred to as a *has-a-relationship* and is achieved
    by a class using instance variable(s) that refer to another object (of a class
    or another class). The term *combining* is also used to describe composition in
    **object-oriented programming** (**OOP**) because it deals with bringing multiple
    objects together to achieve an outcome.'
  prefs: []
  type: TYPE_NORMAL
- en: Since `IBehaviorPatrolWaypoints` is simply a behavior that moves the object
    it is added to between two points, and it doesn’t explicitly have to be used on
    the enemy, it can be used on any object we want to have this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay – for the last part of implementing the behavior, we’ll need to have the
    `TickPhysics()` method tied into the `FixedUpdate()` method of the `EnemyController`
    class so that it can perform its behavioral function. And we do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: What we have here again, same as in `Update()`, is having to check the current
    state we are in before calling the `tick` method for the current behavior to execute
    (that is, more code smell since the state check is occurring in multiple places
    in the class).
  prefs: []
  type: TYPE_NORMAL
- en: Code smell
  prefs: []
  type: TYPE_NORMAL
- en: A **code smell** refers to source code that is a *quick-to-spot indicator* for
    deeper or interesting problems that may exist within the code base. These are
    not bugs nor errors but violations of fundamental principles that decrease the
    quality of the code base. By nature, they are unquantifiable and subjective to
    the developer’s experience.
  prefs: []
  type: TYPE_NORMAL
- en: If `_currentState` is `Patrol`, then call `_behaviorPatrol?.TickPhysics()`.
    We used the `null` conditional operator (`?.`) on the behavior variable (an interface)
    in case the enemy object was not implemented with an `IBehaviorPatrolWaypoint`
    component. You may prefer, however, not to use `?.` and let it throw an error
    while playtesting in the Editor to validate the object configuration. It’s up
    to you how you prefer to work (this would commonly be referred to as *developer
    style*).
  prefs: []
  type: TYPE_NORMAL
- en: Null conditional operator (?.) and Unity objects
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that null propagation is incompatible with Unity objects because Unity
    overrides the null comparison operator (to properly return null for objects that
    were destroyed but not yet garbage collected). Your IDE should provide a warning
    when attempting to use the **?.** operator on Unity objects (if not, then get
    a new IDE). The correct approach would be to simply use a null comparison. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'NO'
  prefs: []
  type: TYPE_NORMAL
- en: '**_player?.Jump();**'
  prefs: []
  type: TYPE_NORMAL
- en: 'YES'
  prefs: []
  type: TYPE_NORMAL
- en: '**if (_player !=** **null)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**_player.Jump();**'
  prefs: []
  type: TYPE_NORMAL
- en: The final step for fully implementing the behavior is to create a class that
    implements `IBehaviorPatrolWaypoints` and contains the movement logic. I’ll present
    the completed code later in [*Chapter 13*](B18347_13.xhtml#_idTextAnchor256),
    when we refactor and extend upon the enemy behavior logic, but for now, I’m going
    to challenge you to create the script yourself!
  prefs: []
  type: TYPE_NORMAL
- en: 'To give you a hint, take a look at how we added movement to the player (remember
    – use physics; don’t manipulate the transform position directly!) and start with
    this class declaration for a new component script named `PatrolWaypoints`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can cheat. I mean, take a peek now at the final code in the GitHub
    project files for the book here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch7/Unity%20Project/Assets/Scripts/Behaviors](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch7/Unity%20Project/Assets/Scripts/Behaviors).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll implement every other behavior in the same fashion, adding on a new state
    conditional check within each method that requires processing for the current
    state, as well as doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring an instance variable and using `GetComponent()` to obtain the reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing the behavior instance and providing required dependencies via its
    `Init()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a call to its `TickPhysics()` method to `FixedUpdate()` to perform its
    function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimization note
  prefs: []
  type: TYPE_NORMAL
- en: With our base class – **EnemyController**, in this case – implementing the behaviors,
    it means none of our behaviors needs to have its own **FixedUpdate()** Unity message
    event being registered and called; so, having a **tick** method being called instead
    is a bit more efficient as it reduces the interop overhead (C# code being called
    from the C++ engine code) – and it could certainly add up if we have many enemies!
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, however, this is, in fact, getting ugly with the enum-based
    State Pattern. For now, let’s continue with setting up the condition for transitioning
    to the **Attack** state.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior for attacking the player
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll need some additional references for the **Attack** behavior – specifically,
    the player. After all, you can’t attack what you can’t see.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B18347_04.xhtml#_idTextAnchor079), we assigned the `Player`
    tag to our `Player` object in the Inspector to determine if it was the player
    that interacted with a collision event. Well, we’re going to use the tag again
    now, but differently.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the tag as a parameter for the `FindWithTag()` method to obtain a
    reference to our `Player` object in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**FindWithTag**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/GameObject.FindWithTag.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/GameObject.FindWithTag.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of assigning the reference to a field exposed in the Inspector, we need
    to get the `Player` reference dynamically because our enemy Prefabs may be spawned
    into the scene at runtime. Hence, it’s impossible to make that assignment (scene
    references cannot be made in file-based assets such as Prefabs and SOs).
  prefs: []
  type: TYPE_NORMAL
- en: 'Still within `EnemyController`, once we have the reference to `Player`, let’s
    check the distance to the player and change the state to **Attack** if the player
    is within our arbitrary range value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We first declare a `_player` variable to hold the GameObject reference to the
    `Player` object. Then, in `Awake()`, we assign the player found in the scene by
    using `FindWithTag()` and passing in our previously declared string constant,
    `Tags.Player`.
  prefs: []
  type: TYPE_NORMAL
- en: Optimization note
  prefs: []
  type: TYPE_NORMAL
- en: '**FindWithTag()** is a slow command, but we’ll do it in **Awake()** to get
    the reference to Player before gameplay stats (i.e., caching the reference). Generally,
    you wouldn’t want to do this during gameplay because it’s slow, and definitely
    not in **Update()** since that is called every frame!'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add the `IsPlayerInRange()` method for calculating the distance to
    the `Player` object using advanced trigonometric geometry mathematics! Nah – you
    can already see in the previous code that we simply use the `Vector2.Distance()`
    method and pass in the current position of both `Enemy` and `Player` to get a
    float value of the distance between them. Easy-peasy!
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we used the `return` keyword to stop the code in a method from executing
    further. Here, we’re doing the same thing (sort of; in this case, it’s the last
    statement), but because the method signature for `IsPlayerInRange()` is declared
    as `bool` and not `void`, we need to return a bool value, the result of evaluating
    the distance returned from `Vector2.Distance()` being less than or equal to (`<=`)
    the specified `rangeAttack` value.
  prefs: []
  type: TYPE_NORMAL
- en: Question
  prefs: []
  type: TYPE_NORMAL
- en: Is the **EnemyController** class the best place to declare the **IsPlayerInRange()**
    method? Does this follow the SRP? If we need to change the logic for calculating
    the player distance, will it negatively affect other code?
  prefs: []
  type: TYPE_NORMAL
- en: While you ponder that, I’ll leave it right where it is in **EnemyController**
    (for now?).
  prefs: []
  type: TYPE_NORMAL
- en: 'And, finally, with our dependencies now in place, let’s wire up the condition
    for transitioning into and out of the **Attack** state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If we refer back to the `is [player] in range` condition and transition to the
    **Attack** state if so.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll do this by adding to our `Change state?` `if` block, so we add `IsPlayerInRange()`
    and pass in the `AttackRange` value configured for this enemy object. If within
    range, boom: `ChangeState(State.Attack)`!'
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, in the `!`) to the `IsPlayerInRange()` call to reverse the result
    (the logical `not` operator returns `false` if the result is `true`) – which changes
    the evaluation from *is player in range* to *is player not* *in range*.
  prefs: []
  type: TYPE_NORMAL
- en: Not shown in the preceding code (for brevity), but the `IsPlayerInRange()` condition
    check (just as our State Model says it should).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s see how we handle our final state from our State Model: the **Dead**
    state (that is, in fact, quite final).'
  prefs: []
  type: TYPE_NORMAL
- en: Dead state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The enemy would now be able to attack the player while in range – we’ll look
    at implementing the exact attack behavior in the following chapter, [*Chapter
    8*](B18347_08.xhtml#_idTextAnchor151), when the player attacks and immobilizes
    the infected robot enemy; however, we can, for now, provide a **Dead** state to
    handle that.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we change to this state, we’ll simply destroy the **Enemy** GameObject
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using `Destroy()` like this is fine since we can still add *on-death* effects
    to the enemy using its `OnDestroy()` Unity message event.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**MonoBehaviour.OnDestroy**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.OnDestroy.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.OnDestroy.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: The condition, however, needs to be checked outside the `switch` statement because
    we want to check for some health value becoming zero all the time – no matter
    the current state. We can do this by adding an `if` statement after the `switch`
    statement – the `switch` section is only for processing the current state!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Don’t worry too much about the `_health` variable at the moment; we’re going
    to implement health and damage systems in [*Chapter 8*](B18347_08.xhtml#_idTextAnchor151).
    As you can see in the preceding code, we’re simply checking if this enemy’s health
    equals or dips below zero and changing to the **Dead** state if so.
  prefs: []
  type: TYPE_NORMAL
- en: This section introduced you to the State Pattern, a State Model UML diagram,
    and setting up a simple FSM for managing different states based on the State Model
    for our enemy characters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added some polish to the shooting and player character by
    introducing URP post-processing, **Shader Graph**, 2D lights, and the **Trail
    Renderer** effect. Phew! Having these features out of the box with Unity allows
    us to add visual quality to our games with little effort.
  prefs: []
  type: TYPE_NORMAL
- en: We continued by adding some configurable enemy characters to the game by creating
    two enemy Prefabs and assigning unique configuration variables to each via the
    ScriptableObject assets. The enemy objects were then given behavior by implementing
    the State Pattern to introduce basic behavior with an FSM and evaluate conditions
    for transitioning between states.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll complete the adventure game by adding health and
    damage systems for enemies that we’ll spawn into the level, implement the attack
    mechanics with additional weapon types, create a simple quest system for collecting
    key objects for solving the entryway puzzle, and introduce a new event system
    for keeping our code loosely coupled.
  prefs: []
  type: TYPE_NORMAL
