- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XAML and Fluent C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at how .NET MAUI applications are created using
    a markup language for the user interface and C# for all the logic.
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI programs are (typically) written in two languages. One is C#, which
    is used for all the logic, and the other is **XAML** (pronounced *zamel*, to rhyme
    with camel), which is used for the layout and creation of controls. As you’ll
    see, the use of XAML is optional. You can create your layout and controls all
    in C#, but most people don’t. However, that may be changing (more and more of
    the Microsoft Learn documentation shows both ways).
  prefs: []
  type: TYPE_NORMAL
- en: When might you choose to use C#?
  prefs: []
  type: TYPE_NORMAL
- en: There are a few reasons to use C# instead of XAML, not least that you know C#
    and don’t want to bother learning XAML. If you do this, however, you’ll find it
    difficult to read other people’s code, as most existing `Xamarin.Forms` (the precursor
    to .NET MAUI) apps are written with XAML.
  prefs: []
  type: TYPE_NORMAL
- en: Using C# can assist in those situations where the design should change based
    on some condition (such as the type of data you get at runtime). But there are
    other ways to handle that with XAML as explained in [*Chapter 11*](B19723_11.xhtml#_idTextAnchor216),
    *Advanced Topics*.
  prefs: []
  type: TYPE_NORMAL
- en: This book will show C# for some pages, but the focus will be on XAML.
  prefs: []
  type: TYPE_NORMAL
- en: All of the Microsoft documentation is at least in XAML; only some is in C# and
    some is in Fluent C# (a topic we’ll take up later in this chapter). Nearly all
    **Xamarin.Forms** applications and samples use XAML and, for that reason alone,
    it is worth learning. More important, XAML is a highly expressive declarative
    markup language that makes creating layouts and controls if not easy, then at
    least manageable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the structure of XAML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code-behind and event handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the layout options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the UI in C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio version 17.5 or later (it’s best to update to the latest version)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The source code covered in this chapter can be found in the GitHub repository:
    [https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/XAMLAndCSharp](https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/XAMLAndCSharp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the structure of XAML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XAML files have the `.xaml` extension, for example, `MainPage.xaml`, in the
    out-of-the-box program as shown in [*Chapter 1*](B19723_01.xhtml#_idTextAnchor016).
    Let’s examine this file to explore XAML for its layout and declaration of controls.
  prefs: []
  type: TYPE_NORMAL
- en: Just an overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will only scratch the surface of creating XAML layout and controls.
    [*Chapter 4*](B19723_04.xhtml#_idTextAnchor054) and [*Chapter 5*](B19723_05.xhtml#_idTextAnchor092)
    will cover the details on controls and layouts, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: A .NET MAUI page that is written in XAML will have a name in the format `MyName.xaml`,
    and associated with that page will be a code-behind page (explained shortly) in
    the format `MyName.xaml.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the XAML page is a declaration that this file is, in reality,
    an XML-type file. That declaration must be at the very top of every `.``xaml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different types of pages (also called views). The most common is
    `ContentPage`, and here `MainPage` is created as `ContentPage` using this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As part of the declaration of `ContentPage`, we identify two namespaces (`xmlns`).
    The first namespace is unnamed and is for .NET MAUI itself. The second namespace,
    named `x`, is for XAML.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the class that this XAML file is part of is `ForgetMeNotDemo.View.MainPage`.
  prefs: []
  type: TYPE_NORMAL
- en: The first part (`ForgetMeNotDemo.View`) is the namespace, and `MainPage` is
    the name of the class. The `View` part is added to indicate the folder under the
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Associated with every `.xaml` page is a code-behind page, as mentioned earlier.
    It is possible to put the logic of your program in the code-behind, which is what
    we will do for this chapter (in the next chapter, we’ll look at an alternative
    that is better for testing). In any case, there are a few things that must go
    in the code-behind, as you’ll see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The code-behind file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every XAML file has an associated code-behind page whose name is in the format
    `<pagename>.xaml.cs`. Thus, the code-behind for this page is `MainPage.xaml.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code-behind file is typically (and correctly) named after the class (that
    is, the `MainPage` class will be in `MainPage.xaml` and `MainPage.xaml.cs`). The
    namespace is explicitly declared in the file and should follow the folder structure.
    Thus, if the namespace is `ForgetMeNotDemo`/`MainPage`, then we’d expect `MainPage.cs`
    to have the `ForGetMeNotDemo` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this is a partial class. In .NET MAUI, all UI classes are marked
    partial. Notice also that the class indicates that it is `ContentPage`, which
    is consistent with what we saw in the XAML.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to defining classes, you can use XAML to create the layout of the
    page, that is, where things go in relation to one another. XAML provides a number
    of layout options as described next.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the layout options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Returning to `MainPage.xaml`, the first thing we see below `ContentPage` is
    a `ScrollView` layout element. This is a layout that essentially says that anything
    contained in `ScrollView` can (surprise!) scroll.
  prefs: []
  type: TYPE_NORMAL
- en: 'A layout contains other layouts and controls. It does this just as it’s done
    in XML, which is with opening and closing tags. Here is the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A page can have only one element. Typically, that element is a layout, and since
    layouts can contain other layouts and controls, an entire hierarchy can be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The top four elements in `MainPage.xaml` (out of the box) are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Why is this code different from what is in the repo?
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code is what you get out of the box. In this chapter, we will
    enhance this code, and the repo reflects the finished version as of the end of
    the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take this one element at a time. We’ve already discussed the first element,
    `ScrollView`, so let’s start with the next, that is, `VerticalStackLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: VerticalStackLayout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside `ScrollView` is `VerticalStackLayout`. As the name implies, this layout
    holds things stacked one on top of another. Here, we have defined three properties
    for `VerticalStackLayout`: `Spacing`, `Padding`, and `VerticalOptions`. Now, `VerticalStackLayout`
    has dozens of properties and methods. We will learn more about this in [*Chapter*
    *5*](B19723_05.xhtml#_idTextAnchor092)*, Layouts*.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Spacing` determines the amount of vertical space there is between each of
    the contained elements. Here, `Spacing` is set to `25` **device-independent units**
    (**DIPs**). Using DIPs means that you can define the size for one device (phone,
    Windows, and so on) and have it look as you intend on all other devices. At least
    that’s the theory. As a good friend once said, “In theory, theory and practice
    are the same. But in practice, they never are.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second property is `Padding`. This is one of the ways you can control the
    position and alignment of your controls. The second principal way is with `Margins`.
    This tells you the distance from the nearest other element (or from the edge of
    the page), whereas `Padding` tells you the size of the buffer around the current
    element, as shown in *Figure 3**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Padding and Margin'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.1_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Padding and Margin
  prefs: []
  type: TYPE_NORMAL
- en: '`Padding` is written in the format *left*, *top*, *right*, *bottom*. A `Padding`
    value of (`20`,`10`,`5`,`0`) would have a padding on the left of `20` DIPs, `10`
    on the top, `5` on the right, and no DIPs on the bottom. If the top and bottom
    are the same, they can be combined. The same is true for the right and left. Thus,
    as we have here, `Padding = "30,0"`, which means that the left and right will
    have a padding of `30` but there will be no padding on the top and bottom.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final property in `VerticalStackLayout` is `VerticalOptions`, which indicates
    where to place `VerticalStackLayout` with respect to its container (in this case,
    `ScrollView`). The options for this are based on an enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Center*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*End*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Fill*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Start*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This enumeration is used with a number of different layouts and controls. For
    now, it is enough to know that *Start* means *top* for vertical layouts and *far
    left* for horizontal. Similarly, *End* means *far right* for horizontal and *bottom*
    for vertical. We’ll return to these values later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The third element of the page is an `Image` element, which in this case has
    four properties. The first is the source (where to find the image). The second
    is called `SemanticProperties.Description`. **Semantic properties** are added
    to assist those who use screen readers.
  prefs: []
  type: TYPE_NORMAL
- en: You cannot set the height directly (it is read only), but you can set `HeightRequest`,
    which we have done here to `200` DIPs. .NET MAUI will try to provide that height
    depending on your other settings on the page and the available space. Finally,
    we set `HorizontalOptions` to `Center` so that we center the image on the horizontal
    axis.
  prefs: []
  type: TYPE_NORMAL
- en: Label
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we see `Label`. In this case, it too has four properties. The first is
    the text to display on the label. The second is, again, for screen readers, indicating
    the organizational structure (here the label is at the top level). The third property
    is `FontSize`. There are a couple of ways to set `FontSize`, as we’ll see in [*Chapter
    4*](B19723_04.xhtml#_idTextAnchor054), but here we are using DIPs. Finally, once
    again, we set `HorizontalOptions` to `Center`.
  prefs: []
  type: TYPE_NORMAL
- en: If you scroll down the page, you’ll see there is another `Label` and a `Button`
    control (which does pretty much what you’d guess).
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom, you will see the close for `VerticalStackLayout`, then the close
    for `ScrollView`, and finally the close for `ContentPage` itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The XAML thus provides a highly structured approach to describing the layout.
    Here is the complete XAML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This page opens by declaring `ContentPage` (the most common type of page) and
    defines the namespace and name of the page (which will be reflected in the code-behind
    as well). It then declares two standard namespaces (using `xmlns`), the first
    for .NET MAUI and the second for the XAML markup.
  prefs: []
  type: TYPE_NORMAL
- en: We see `ScrollView`, and inside of that, we see `VerticalStackLayout`, which
    is set to use padding and spacing and to be centered vertically. We’ll review
    these properties as we go along.
  prefs: []
  type: TYPE_NORMAL
- en: '`VerticalStackout` contains four controls: an image, two labels, and a button.
    Each of these controls has its own properties. You do not have to be concerned
    about these properties now; they are explained later. The takeaway here is that
    layouts can contain layouts and controls. They stack like Ukrainian dolls, one
    within the other (though controls do not contain controls).'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Each `ContentPage` can have only one layout, but that layout can contain other
    layouts (as we see here), and so that is not a troublesome problem.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that due to the size restriction of the printed page, some text will
    wrap to the next line.
  prefs: []
  type: TYPE_NORMAL
- en: You can even do this in Visual Studio by going to **Tools** | **Options** |
    **C#** | **General** and checking the box for **Word wrap**. If you do this, I
    recommend also checking **Show visual glyphs for word wrap**, which makes reading
    the code easier. While you are there, you may want to check **Line numbers**,
    which can come in very handy, especially when tracking down compile errors. These
    options are shown in *Figure 3**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Setting Word wrap and Line numbers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.2_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Setting Word wrap and Line numbers
  prefs: []
  type: TYPE_NORMAL
- en: Now, when your line of code is too wide to display, it will wrap and you’ll
    see a small arrow on the right side indicating that the line has continued, as
    shown in *Figure 3**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Visual Studio word wrap'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.3_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Visual Studio word wrap
  prefs: []
  type: TYPE_NORMAL
- en: When something happens such as the user clicking a button, an event is raised.
    The event is handled in the code-behind, which we’ll review next.
  prefs: []
  type: TYPE_NORMAL
- en: Events versus commands
  prefs: []
  type: TYPE_NORMAL
- en: Starting in the next chapter, we will stop working with events and switch to
    commands. Commands are handled in the ViewModel, which makes them easier to test.
    For now, for convenience, we’ll handle events and we’ll do so in the code-behind.
  prefs: []
  type: TYPE_NORMAL
- en: Code-behind and event handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We see in the `Button` control listed next that there is a `Clicked` property
    that points to a `OnCounterClicked` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This method (`onCounterClicked`) is found in the code-behind file, `MainPage.xaml.cs`.
    All `EventArgs` (or a class derived from `EventArgs`). By convention, the `EventArgs`
    parameter is named `e`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case (and most cases), we don’t care about the sender and the simple
    `EventArgs` (as used here) is empty and serves only as a base class for derived
    classes that provide additional information to the event handler (thus you might
    have a type derived from `EventArgs` that provides information that the event
    handler needs):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The event handler name matches the event handler identified in the XAML.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This handler’s job is only to update the text on the button each time the button
    is clicked. Finally, it uses the `SemanticScreenReader Announce` method to show
    that text, again for screen readers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The count instance field is declared at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: InitializeComponent
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the constructor calls `InitializeComponent`. This will be true in
    the code-behind file of every XAML file. It is the job of `InitializeComponent`
    to initialize all the elements of the page.
  prefs: []
  type: TYPE_NORMAL
- en: When we get to [*Chapter 4*](B19723_04.xhtml#_idTextAnchor054), you’ll see that
    we try to minimize the contents of the code-behind file, principally to facilitate
    the creation of unit tests. At that point, we’ll substitute commands for our events,
    but let’s hold off on that for now.
  prefs: []
  type: TYPE_NORMAL
- en: While nearly all the Microsoft documentation and all the existing sample code
    uses XAML for markup, it is possible to create layouts and views in C#. In fact,
    in recent years, more and more of the Microsoft documentation shows both.
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI Community Toolkit
  prefs: []
  type: TYPE_NORMAL
- en: This section requires the .NET MAUI Community Toolkit that you added as a NuGet
    package in the previous chapter. The Community Toolkit is actually part of a set
    of toolkits that are open source projects and supplement what is in the release
    version of .NET MAUI. They are created by community members who work closely with
    Microsoft developers. It is fair to assume that many of the Community Toolkit
    features will migrate into .NET MAUI properly over time. I would strongly urge
    you to use these toolkits, and this book does so.
  prefs: []
  type: TYPE_NORMAL
- en: If you can do it in XAML, you can do it in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Anything that can be declared in XAML can be declared in C#. Containment is
    managed by using the `children` property of an object. Event handlers must be
    registered on an instance of the control. That is, an event handler would be registered
    for a particular button, as you’ll see in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code we wrote in XAML converted to C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s quickly take a look at hooking up this new `MainPage`. To test this C#
    version, set the `ShellContent` element in `AppShell.xaml` to point to your new
    page like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Coming back to the XAML converted to C# code, let’s break it down for a better
    understanding. The numbers refer to the numbers in square brackets in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: We begin by adding a `using` statement for `CommunityToolkit`. We need this
    for the semantic hints, which are used by screen readers for people with limited
    or no eyesight. While a finished project should have these for every control,
    we won’t be using them in this book to save space and confusion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want to add a button, and that button will need an event handler (for the
    click event). In this example, the event handler for the `Clicked` event is at
    the bottom of the file. To add an event handler to our button, we must first define
    `Button`. We do this outside of the constructor and we set its properties [`2`].
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the very beginning of the constructor, we assign the event handler method
    to the `Clicked` event. As noted, that event handler method is at the bottom of
    the file, though of course it could be (and perhaps should be) in its own file
    [`3`].
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are now ready to create `VerticalStackLayout` and all the elements contained
    within the stack layout [`4`].
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These elements will be in the stack layout’s `Children` collection [`5`].
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that the semantic description is attached to the image using a fluent
    syntax [`6`].
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After all the other elements, we are ready to insert our button into the stack
    layout’s `Children` collection [`7`].
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ve put the event handler for the button at the bottom of this file, though
    you certainly could move it to a different file, probably in a different folder.
    If you do so, however, remember to add a `using` statement for that namespace
    [`8`].
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A note on comments
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a raging controversy in the industry about the use of comments in
    C# code. I take a rather extreme position: code should be almost completely self-explanatory.
    That is, if you use appropriate and descriptive names for variables, fields, methods,
    and so on, no comments should be needed. I’m not a fanatic about this; if the
    code is sufficiently complex, a comment here and there can be a big help, but
    comments *rust* and should be used sparingly. Thus, you will find few comments
    in the code, though we will walk through the code in some detail in the paragraphs
    that follow each listing.'
  prefs: []
  type: TYPE_NORMAL
- en: A recent addition to our tool set is the ability to use Fluent C#, which can
    make your C# code tighter and yet easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: C# versus Fluent C#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to using C# to create your pages, there is a new (as of Winter 2022)
    **Community Toolkit** for Fluent C#. This does not change the basic approach but
    can make creating C# pages cleaner and easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this, you’ll need to add the `CommunityToolkit.Maui.Markup` NuGet package.
    Refer to the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Getting the markup package from NuGet'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.4_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Getting the markup package from NuGet
  prefs: []
  type: TYPE_NORMAL
- en: The project is open source and can be examined (and extended!) at [https://github.com/communitytoolkit/Maui.Markup](https://github.com/communitytoolkit/Maui.Markup).
    The `ReadMe` file will get you started, though we’ll cover that material in this
    book as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need to do is to update `MauiProgram.cs` to add the toolkit
    to the builder using the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can and should chain `UseMauiCommunityToolkitMarkup` to `UseMauiCommunityToolkit`
    in the builder [`1`].
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can avoid writing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, you can chain all of that together and just write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This makes the code much cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: I will provide C# and Fluent C# examples throughout the book; although, as noted,
    the primary markup language we’ll use is XAML.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we examined the markup language XAML, which is used to create
    layouts and controls. We saw that anything that can be done in XAML can also be
    done in C#, and we saw that there are two ways to write that C#: the traditional
    declarative way and the newer fluent form.'
  prefs: []
  type: TYPE_NORMAL
- en: We examined a few important classes (`Button`, `Label`, `Image`, and so on)
    and how events can be handled in the code-behind class. I also hinted that code-behind
    event handlers will be replaced by commands and their implementation in the ViewModel
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 4*](B19723_04.xhtml#_idTextAnchor054), we’ll dive into the principal
    architecture for writing apps in .NET MAUI: **Model-View-ViewModel** (**MVVM**)
    and we’ll look at data binding. We’ll then explore a number of controls and how
    they can work together.'
  prefs: []
  type: TYPE_NORMAL
- en: Quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a sentence, what is XAML?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is XAML used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an alternative to using XAML?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we nest one layout inside another using C#?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an event handler?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If an event is declared in XAML, where is the event handler?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try it out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Time to start writing code!
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project named `ForgetMeNotJesse` (you might want to use your own
    name where I have put mine). Ideally, put that project under source control (see
    the *Technical requirements* section at the top of this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Use the .NET MAUI template to create your project, using the latest version
    of .NET (.NET 7 at the time of the writing of this book).
  prefs: []
  type: TYPE_NORMAL
- en: Run your program to make sure everything is set up correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Change `MainPage` so that clicking on the button updates a label below the button
    with the number of clicks (in addition to displaying it on the button itself).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the page is working as intended, create a new page and recreate your `MainPage`
    in C# rather than in XAML. To test it, remember to set the `ShellContent` element
    in `AppShell.xaml` to point to your new page like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you get stuck at any point, pull down the XAML and C# branch from the book’s
    repository and compare that solution with yours.
  prefs: []
  type: TYPE_NORMAL
