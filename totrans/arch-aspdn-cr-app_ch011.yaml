- en: 10 Logging patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you begin: Join our book community on Discord'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Qr code Description automatically generated](img/file46.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This chapter covers a .NET-specific feature and closes the *Designing for ASP.NET
    Core* section. The logging feature that comes with a few patterns is another building
    block that most applications need: built-in ASP.NET Core. We explore the system
    hands-on while not trying to master every aspect.Logging is a crucial aspect of
    application development and serves various purposes, such as debugging errors,
    tracing operations, analyzing usage, and more.The logging abstractions we explore
    here are another improvement of .NET Core over .NET Framework. Instead of relying
    on third-party libraries, the new, uniform system offers clean interfaces backed
    by a flexible and robust mechanism that helps implement logging into our applications.At
    the end of this chapter, you will understand what logging is and how to write
    application logs.In this chapter, we cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: About logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structured logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by exploring what logging is.
  prefs: []
  type: TYPE_NORMAL
- en: About logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Logging is the practice of writing messages into a log and cataloging information
    for later use. That information can be used to debug errors, trace operations,
    analyze usage, or any other reason we can come up with. Logging is a cross-cutting
    concern, meaning it applies to every piece of your application. We talk about
    layers in *Chapter 14*, *Layering and Clean Architecture*, but until then, let’s
    just say that a cross-cutting concern affects all layers and cannot be centralized
    in just one; it affects a bit of everything.A log is made up of log entries. We
    can view each log entry as an event that happened during the program’s execution.
    Those events are then written to the log. This log can be a file, a remote system,
    `stdout`, or a combination of multiple destinations.When creating a log entry,
    we must also think about the severity of that log entry. In a way, this severity
    level represents the type of message or the level of importance that we want to
    log. We can also use it to filter those logs. `Trace`, `Error`, and `Debug` are
    examples of log entry levels. Those levels are defined in the `Microsoft.Extensions.Logging.LogLevel`
    enum.Another important aspect of a log entry is how it is structured. You can
    log a single string. Everyone on your team could log single strings in their own
    way. But what happens when someone searches for information? Chaos ensues! There’s
    the stress of not finding what that person is looking for and the displeasure
    of the log’s structure, as experienced by that same person. One way to fix this
    is by using structured logging. It is simple yet complex; you must create a structure
    the program follows for all log entries. That structure could be more or less
    complex or be serialized into JSON. The important part is that the log entries
    are structured. We won’t get into this subject here, but if you must decide on
    a logging strategy, I recommend digging into structured logging first. If you
    are part of a team, then chances are someone else already did. If that’s not the
    case, you can always bring it up. Continuous improvement is a key aspect of life.We
    could write a whole book on logging, best logging practices, structured logging,
    and distributed tracing, but this chapter aims to teach you how to use .NET logging
    abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: Writing logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, the logging system is provider-based, meaning we must register one or
    more `ILoggerProvider` instances if we want our log entries to go somewhere. By
    default, when calling `WebApplication.CreateBuilder(args)`, it registers the Console,
    Debug, EventSource, and EventLog (Windows only) providers, but we can modify this
    list. You can add and remove providers if you need to. The required dependencies
    for using the logging system are also registered as part of this process.Before
    we look at the code, let’s learn how to create log entries, which is the objective
    behind logging. To create an entry, we can use one of the following interfaces:
    `ILogger`, `ILogger<T>`, or `ILoggerFactory`. Let’s take a look at them in more
    detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Interface** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `ILogger` | Base type that allows us to perform logging operations. |'
  prefs: []
  type: TYPE_TB
- en: '| `ILogger<T>` | Base type that allows us to perform logging operations. Inherit
    from the ILogger interface. The system uses the generic parameter `T` as the log
    entry’s *category* . |'
  prefs: []
  type: TYPE_TB
- en: '| `ILoggerFactory` | A factory interface that allows creating `ILogger` objects
    and specifying the category name manually as a string. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 10.1: the logging interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code represents the most commonly used pattern, which consists
    of injecting an `ILogger<T>` interface and storing it in an `ILogger` field before
    using it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `Service` class has a private `_logger` field. It takes an `ILogger<Service>`
    logger as a parameter and stores it in that field. It uses that field in the `Execute`
    method to write an information-level message to the log.The `IService` interface
    is very simple and only exposes a single `Execute` method for testing purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'I loaded a small library I created to test this out, providing additional logging
    providers for testing purposes. With that, we are creating a generic host (`IHost`)
    since we don’t need a `WebApplication` in our tests, then we configure it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the `Arrange` phase of the test, we create some variables, configure `IHost`,
    and get an instance of the `Service` class that we want to use to test the logging
    capabilities that we programmed.The highlighted code removes all providers using
    the `ClearProviders` method. Then it uses the `AddAssertableLogger` extension
    to add a new provider. The extension method comes from the library that we loaded.
    We could have added a new provider if we wanted, but I wanted to show you how
    to remove existing providers so we can start from a clean slate. That’s something
    you might need someday.
  prefs: []
  type: TYPE_NORMAL
- en: The library that I loaded is available on NuGet and is named `ForEvolve.Testing.Logging`,
    but you do not need to understand any of this to understand logging abstractions
    and examples.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the `Act` phase, we call the `Execute` method of our service. This method
    logs a line to the `ILogger` implementation that is injected upon instantiation.
    Then, we assert that the line was written in the `lines` list (that’s what `AssertableLogger`
    does; it writes to a `List<string>`). In an ASP.NET Core application, all that
    logging goes to the console by default. Logging is a great way to know what is
    happening in the background when running the application.The `Service` class is
    a simple consumer of an `ILogger<Service>`. You can do the same for any class
    you want to add logging support to. Change `Service` by that class name to have
    a logger configured for your class. That generic argument becomes the logger''s
    category name when writing log entries.Since ASP.NET Core uses a `WebApplication`
    instead of a generic `IHost`, here is the same test code using that construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'I highlighted the changes in the preceding code. In a nutshell, the extension
    methods used on the generic host have been replaced by `WebApplicationBuilder`
    properties like `Logging` and `Services`. Finally, the `Create` method creates
    a `WebApplication` instead of an `IHost`, exactly like in the `Program.cs` file.To
    wrap this up, these test cases allowed us to implement the most commonly used
    logging pattern in ASP.NET Core and add a custom provider to ensure we logged
    the correct information. Logging is essential and adds visibility to production
    systems. Without logs, you don’t know what is happening in your system unless
    you are the only one using it, which is very unlikely. You can also log what is
    happening in your infrastructure and run real-time security analysis on those
    log streams to quickly identify security breaches, intrusion attempts, or system
    failures. These subjects are out of the scope of this book, but having strong
    logging capabilities at the application level can only help your overall logging
    strategy.Before moving on to the next subject, let’s explore an example that leverages
    the `ILoggerFactory` interface. The code sets a custom category name and uses
    the created `ILogger` instance to log a message. This is very similar to the previous
    example. Here’s the whole code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code should look very familiar. Let’s focus on the highlighted
    lines, which relate to the current pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: We inject the `ILoggerFactory` interface into the `Service` class constructor
    (instead of an `ILogger<Service>`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create an `ILogger` instance with the `"` `My Service"` category name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We assign the logger to the `_logger` field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then use that `ILogger` from the `Execute` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a rule of thumb, I recommend using the `ILogger<T>` interface by default.
    If impossible, or if you need a more dynamic way of setting the category name
    for your log entries, leverage the `ILoggerFactory` instead. By default, when
    using `ILogger<T>`, the category name is the T parameter, which should be the
    name of the class creating log entries. The `ILoggerFactory` interface is more
    of an internal piece than something made for us to consume; nonetheless, it exists
    and satisfies some use cases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the preceding example, the `ITestOutputHelper` interface is part of the `Xunit.Abstractions`
    assembly. It allows us to write lines as *standard output* to the test log. That
    output is available in the Visual Studio Test Explorer.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that we have covered how to write log entries, it's time to learn how to
    manage their severity.
  prefs: []
  type: TYPE_NORMAL
- en: Log levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous examples, we used the `LogInformation` method to log information
    messages, but there are other levels as well, shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Level** | **Method** | **Description** | **Production** |'
  prefs: []
  type: TYPE_TB
- en: '| Trace | `LogTrace` | This is used to capture detailed information about the
    program, instrument execution speed, and debugging. You can also log sensitive
    information when using traces. | Disabled. |'
  prefs: []
  type: TYPE_TB
- en: '| Debug | `LogDebug` | This is used to log debugging and development information.
    | Disabled unless troubleshooting. |'
  prefs: []
  type: TYPE_TB
- en: '| Information | `LogInformation` | This is used to track the flow of the application.
    Normal events that occur in the system are often information-level events, such
    as the system started, the system stopped, and a user has signed in. | Enabled.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Warning | `LogWarning` | This is used to log abnormal behavior in the application
    flow that does not cause the program to stop, but that may need to be investigated;
    for example, handled exceptions, failed network calls, and accessing resources
    that do not exist. | Enabled. |'
  prefs: []
  type: TYPE_TB
- en: '| Error | `LogError` | This is used to log errors in the application flow that
    do not cause the application to stop. Errors must usually be investigated. Examples
    include the failure of the current operation and an exception that cannot be handled.
    | Enabled. |'
  prefs: []
  type: TYPE_TB
- en: '| Critical | `LogCritical` | This is used to log errors that require immediate
    attention and represent a catastrophic state. The program is most likely about
    to stop, and the integrity of the application might be compromised; for example,
    a hard drive is full, the server is out of memory, or the database is in a deadlocked
    state. | Enabled with some alerts that could be configured to trigger automatically.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 10.2: log entry levels'
  prefs: []
  type: TYPE_NORMAL
- en: 'As described in the preceding table, each log level serves one or more purposes.
    Those log levels tell the logger what severity a log entry is. Then, we can configure
    the system to log only entries of at least a certain level so we don’t fill out
    production logs with traces and debug entries, for example. In a project I led,
    we benchmarked multiple ways to log simple and complex messages using ASP.NET
    Core to build clear and optimized guidelines around that. We could not reach a
    fair conclusion when the messages were logged due to a large time variance between
    benchmark runs. However, we observed a constant trend when messages were not logged
    (*trace* logs with the minimum logging level configured to *debug*, for example).Based
    on that conclusion, I recommend logging the `Trace` and `Debug` messages using
    the following construct instead of interpolation, `string.Format`, or other means.
    That may sound strange to optimize for *not logging something*, but if you think
    about it, those log entries will be skipped in production, so optimizing them
    will save your production app a few milliseconds of computing time here and there.
    Moreover, it''s not harder or longer to do, so it''s just a good habit.Let’s look
    at the fastest way to *not write log entries*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When the log level is disabled, such as in production, you only pay the price
    of a method call because no processing is done on your log entries. On the other
    hand, if we use interpolation, the processing is done, so that one argument is
    passed to the `Log[Level]` method, leading to a higher cost in processing power
    for each log entry.Here’s an example of interpolation (a.k.a. what not to do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For warning and higher levels, you can keep the good habit and use the same
    technique or other methods because we know those lines will be logged anyway.
    Therefore, using interpolation in the code or letting the logger do it later should
    yield a similar result.
  prefs: []
  type: TYPE_NORMAL
- en: One last note. I suggest you don’t try to over-optimize your code before there
    is a need for that. The action of investing a lot of effort in optimizing something
    that does not need optimizing is known as **premature optimization**. The idea
    is to optimize just enough upfront and fix the performance when you find real
    issues.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that we know the log levels that .NET offers us, let’s look at the logging
    providers.
  prefs: []
  type: TYPE_NORMAL
- en: Logging providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To give you an idea of the possible built-in logging providers, here is a list
    from the official documentation (see the *Further reading* section at the end
    of this chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: Console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EventSource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EventLog (Windows only)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ApplicationInsights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a list of third-party logging providers, also from the official
    documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: elmah.io
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gelf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSNLog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KissLog.net
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log4Net
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NLog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PLogger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sentry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serilog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stackdriver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, if you need any of those or your favorite logging library is part of the
    preceding list, you know you can use it. If it is not, maybe it supports ASP.NET
    Core but was not part of the documentation when I consulted it.Next, let’s learn
    how to configure the logging system.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with most features of ASP.NET Core, we can configure logging. The default
    `WebApplicationBuilder` that do a lot for us, but in case we want to tweak the
    defaults, we can. On top of that, the system loads the `Logging` section of the
    configuration. That section is present, by default, in the `appsettings.json`
    file. Like all configurations, it is cumulative, so we can redefine part of it
    in another file or configuration provider.We won’t dig too deep into customization,
    but it is good to know that we can customize the minimum level of what we are
    logging. We can also use transformation files (such as `appsettings.Development.json`)
    to customize those levels per environment.For example, we can define our defaults
    in `appsettings.json`, then update a few for development purposes in `appsettings.Development.json`,
    change production settings in `appsettings.Production.json`, then change the staging
    settings in `appsettings.Staging.json`, and add some testing settings in `appsettings.Testing.json`.Before
    we move on, let’s take a peek at the default settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define default levels (using `Logging:LogLevel:Default`) and a custom
    level for each category (such as `Logging:LogLevel:Microsoft`) representing base
    namespaces. For example, from that configuration file, the minimum level is `Information`,
    while every item part of the `Microsoft` or `Microsoft.*` namespaces have a minimum
    level of `Warning`. That allows for removing noise when running the application.
    We can also leverage these configurations to debug certain parts of the application
    by lowering the log level to `Debug` or `Trace` for only a subset of items (items
    from one or more namespaces, for example).We can also filter what we want to log
    on a provider basis, using configuration or code. In the configuration file, we
    can change the default level of the console provider to `Trace`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We kept the same default values but added the `Logging:Console` section (see
    highlighted code) with a default `LogLevel` set to `Trace`. We can define as many
    settings as we need.Instead of configurations, we can use the `AddFilter` extension
    methods, as shown in the following experimental test code, or in conjunction with
    configurations.Here is the consumer class that logs data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding class is like other classes we used during the chapter but logs
    messages using two different levels: `Information` and `Warning`. Here is a test
    case in which we leverage the `AddFilter` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We created a generic host in the preceding test code and added three providers:
    the console and two test providers—one that logs to a list and another to the
    xUnit output. Then, we told the system to filter out everything that is not at
    least a `Warning` from `XunitTestOutputLoggerProvider` (see highlighted code);
    other providers are unaffected by that code.'
  prefs: []
  type: TYPE_NORMAL
- en: In the code, the `_output` member is a field of type `ITestOutputHelper`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We now know of two options to set the minimum logging levels:'
  prefs: []
  type: TYPE_NORMAL
- en: Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can tweak the way we configure our logging policies as needed. Code can be
    more testable, while configurations can be updated at runtime without redeploying.
    Moreover, with the cascading model, which allows us to override configuration,
    we can cover most use cases using configurations. The biggest downside of configuration
    is that writing strings in a JSON file is more error-prone than writing code (assuming
    you are not reverting to using strings there either).I usually stick with configurations
    to set those values, as they do not change often. If you prefer code, I’m unaware
    of any drawbacks, and it’s just a matter of preference; the configuration becomes
    code at some point.Next, let’s look at a brief example of structured logging.
  prefs: []
  type: TYPE_NORMAL
- en: Structured logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As stated at the beginning, structured logging can become very important and
    open opportunities. Querying a data structure is always more versatile than querying
    a single line of text. That is even more true if there is no clear guideline around
    logging, whether a line of text or a JSON-formatted data structure.To keep it
    simple, we leverage a built-in formatter (highlighted line below) that serializes
    our log entries into JSON. Here is the `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'That transforms the console to logging JSON. For example, every time we hit
    the `/` endpoint, the console displays the following JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Without that formatter, the usual output would have been:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Based on that comparison, it is more versatile to query the JSON logs programmatically
    than the `stdout` line.The biggest benefit of structured logging is improved searchability.
    You can run more precise queries at scale with a predefined data structure.Of
    course, if you are setting up a production system, you would probably want more
    information attached to such log items like the correlation ID of the request,
    optionally some information about the current user, the server’s name on which
    the code is running, and possibly more details depending on the application.You
    may need more than the out-of-the-box features to utilize structured logging fully.
    Some third-party libraries like Serilog offer those additional capabilities. However,
    defining the way to send plain text to the logger could be a start.Each project
    should dictate the needs and depth of each feature, including logging. Moreover,
    structured logging is a broader subject that merits studying independently. Nonetheless,
    I wanted to touch on this subject a bit, and hopefully, you learned enough about
    logging to get started.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, we delved into the concept of logging. We learned that logging
    is the practice of recording messages into a log for later use, such as debugging
    errors, tracing operations, and analyzing usage. Logging is essential, and ASP.NET
    Core offers us various ways to log information independently of third-party libraries
    while allowing us to use our favorite logging framework. We can customize the
    way the logs are written and categorized. We can use zero or more logging providers.
    We can also create custom logging providers. Finally, we can use configurations
    or code to filter logs and much more.Here is the default logging pattern to remember:'
  prefs: []
  type: TYPE_NORMAL
- en: Inject an `ILogger<T>`, where `T` is the type of the class into which the logger
    is injected. `T` becomes the category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save a reference of that logger into a `private readonly ILogger` field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use that logger in your methods to log messages using the appropriate log level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The logging system is a great addition to .NET Core compared to .NET Framework.
    It allows us to standardize the logging mechanism, making our systems easier to
    maintain in the long run. For example, suppose you want to use a new third-party
    library or even a custom-made one. In that case, you can load the provider into
    your `Program`, and the entire system will adapt and start using it without any
    further changes as long as you depend only on the logging abstractions. This is
    a good example of what well-designed abstractions can bring to a system.**Here
    are a few key takeaways**:'
  prefs: []
  type: TYPE_NORMAL
- en: Logging is a cross-cutting concern, affecting all layers of an application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A log comprises many log entries representing an event that occurred at runtime
    during the program's execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The severity of a log entry is important for filtering and prioritization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The severity levels are Trace, Debug, Information, Warning, Error, and Critical.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can configure the logging system to log only certain messages based on the
    severity level of each entry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structured logging can help maintain consistency and ease of searching within
    logs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The logging system in .NET is provider-based, allowing us to customize the default
    providers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use interfaces like ILogger, ILogger<T>, or ILoggerFactory to create
    log entries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter closes the second section of this book with ASP.NET Core at its
    center. We explore design patterns to create flexible and robust components in
    the next few chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at a few practice questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Can we write log entries to the console and a file at the same time?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it true that we should log the trace- and debug-level log entries in a production
    environment?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of structured logging?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we create a log entry in .NET?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a link to build upon what we learned in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Official docs] *Logging in .NET Core and ASP.NET Core*: [https://adpg.link/MUVG](https://adpg.link/MUVG)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Yes, you can configure as many providers as you want. One could be for the console,
    and another could append entries to a file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, you should not log trace-level entries in production. You should only log
    debug-level entries when debugging an issue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Structured logging maintains a consistent structure across all log entries,
    making searching and analyzing logs easier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can create a log entry using interfaces like `ILogger`, `ILogger<T>`, and
    `ILoggerFactory`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
