<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-69"><a id="_idTextAnchor070"/>3</h1>
<h1 id="_idParaDest-70"><a id="_idTextAnchor071"/>Best Approaches for Middleware</h1>
<p>Middleware is<a id="_idIndexMarker116"/> one of the most powerful concepts in ASP.NET Core. For legacy ASP.NET developers, <em class="italic">Middleware</em> is a relatively new term. Before middleware, there were HTTP handlers and modules, which required separate code to configure through a <code>web.config</code>. Middleware is now considered a first-class citizen in an ASP.NET application, making it easier to maintain in a single code base. First introduced in ASP.NET Core 1.0, the common request and response concepts are considered pipelines for your applications with the ability to control a request and response’s body. This opens up a number of possibilities to create amazing features for your ASP.NET Core web applications.</p>
<p>At the beginning of this chapter, we’ll examine how to use Middleware and some common built-in Middleware components found in almost every ASP.NET Core application. Next, we’ll examine the three request delegates (<code>Run</code>, <code>Map</code>, and <code>Use</code>) and explain what each is used for in the pipeline. We’ll also cover some ways to clean up your middleware and, finally, apply those concepts to building a simple middleware example.</p>
<p>In this chapter, we’ll cover the following main topics:</p>
<ul>
<li>Using Middleware</li>
<li>Common Practices for Middleware</li>
<li>Creating an Emoji Middleware Component</li>
</ul>
<p>By the end of this chapter, you’ll have learned how Middleware works, how to use request delegates and standards when writing your own Middleware, and understand how to create your own Middleware components.</p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor072"/>Technical requirements</h1>
<p>Since this is the first chapter (one of many to come since we’re in coding territory now) containing technical requirements, selecting your favorite editor that supports ASP.NET Core 7.0 or higher and C# code would be ideal. My top three editors are the following:</p>
<ul>
<li>Visual Studio (preferably 2022 or newer)</li>
<li>Visual Studio Code</li>
<li>JetBrains Rider</li>
</ul>
<p>The editor we’ll be using is Visual Studio 2022 Enterprise, but any version (Community or Professional) will work for this chapter.</p>
<p>The code for this chapter is located at Packt Publishing’s GitHub repository located here: <a href="https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices">https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices</a>.</p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor073"/>Using Middleware</h1>
<p>Middleware is <a id="_idIndexMarker117"/>software you configure at the beginning of your application when the application starts.  It’s important to note that the Middleware you add should be based on your application’s requirements. It’s not necessary to add every single component. Streamlining your Middleware pipeline is important, which we’ll discuss shortly.</p>
<p>It’s been said that the difference between a library and a framework is that a library is the code you call from your application, whereas a framework is structured a certain way to call your code. This is what Middleware has evolved into from earlier versions of ASP.NET.</p>
<p>In this section, we’ll present the common flow of a Middleware pipeline and how to control what happens in a middleware component. By the end of this section, you’ll understand how a middleware pipeline works.</p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor074"/>Understanding the Middleware Pipeline</h2>
<p>When your <a id="_idIndexMarker118"/>web application starts, Middleware is called and constructed once per <em class="italic">application lifetime</em>. Once the Middleware components are registered, they execute in a certain order. This order is important throughout the pipeline since each middleware component can rely on previously registered components.</p>
<p>For example, the Authentication component is important to configure before the Authorization component <a id="_idIndexMarker119"/>since we need to know who someone is before we can determine what they can do.</p>
<p>In <em class="italic">Figure 3</em><em class="italic">.1</em>, we can see what a standard Middleware pipeline consists of in a web application, which we’ll address next:</p>
<div><div><img alt="Figure 3.1 – Standard Middleware pipeline for an ASP.NET 8 Web Application" src="img/Figure_3.01_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Standard Middleware pipeline for an ASP.NET 8 Web Application</p>
<p>Each one of these <a id="_idIndexMarker120"/>components is optional, but some Middleware components are dependent on others. When a URL is requested by the user, the first Middleware component is hit. In this case, it’s <code>ExceptionHandler</code>. Once <code>ExceptionHandler</code> is done, the pipeline moves on to the next component, which is the HSTS component. As we move through each Middleware component, we eventually reach<a id="_idIndexMarker121"/> the endpoint. Once the endpoint is processed, the response is sent back through the Middleware pipeline in reverse order.</p>
<p>As mentioned at the start of this section, your Middleware depends on what your application requires when adding additional components. If your application is a <strong class="bold">Single-Page Application</strong> (<strong class="bold">SPA</strong>), the<a id="_idIndexMarker122"/> inclusion of the CORS, Static Files, and Routing Middleware would be important.</p>
<p>Each middleware component is responsible for either passing information on to the next component in line based on your configuration or terminating the process. If they decide to terminate the pipeline, they are called <em class="italic">terminal Middleware</em> components. They purposefully stop the middleware from processing any other requests and exit the pipeline.</p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor075"/>Using Request Delegates – Run, Use, and Map</h2>
<p>With <a id="_idIndexMarker123"/>everything we’ve discussed so far, you’re probably wondering how we create a pipeline.</p>
<p>The <a id="_idIndexMarker124"/>three request delegates available are the <code>Run</code>, <code>Use</code>, and <code>Map</code> extension methods. You’ve no doubt used them in your <code>Program.cs</code> code numerous times, but what’s the difference between the three of them?</p>
<h3>Run</h3>
<p>The <code>Run()</code> request <a id="_idIndexMarker125"/>delegate is<a id="_idIndexMarker126"/> strictly terminal middleware, meaning it will run and immediately quit the pipeline. It doesn’t contain a <code>next</code> parameter. It simply runs and immediately terminates the pipeline.</p>
<p>If we look at the following code, this will immediately terminate the pipeline from executing:</p>
<pre class="source-code">
app.Run(async context =&gt;
{
    await context.Response.WriteAsync("This will terminate the web         app.");
});</pre> <p>Notice <a id="_idIndexMarker127"/>there isn’t a <code>next</code> parameter introduced in the delegate. The preceding code will write<a id="_idIndexMarker128"/> the message <code>"This will terminate the web app."</code> to the browser and immediately terminate the pipeline.</p>
<h3>Use</h3>
<p>The <code>Use()</code> request delegate is<a id="_idIndexMarker129"/> used to chain multiple <a id="_idIndexMarker130"/>request delegates together in the pipeline.</p>
<p>The key to implementing a proper <code>Use</code> request delegate is the use of <code>await next.Invoke()</code>. <code>next.Invoke()</code> will execute the next middleware component in sequential order. Anything before this line will be processed on the request, and anything after this line will be processed on the response back to the user.</p>
<p>Let’s look at a code sample of two anonymous Middleware components in the following code snippet:</p>
<pre class="source-code">
app.Use(async (context, next) =&gt;
{
    await context.Response.WriteAsync("In the first middleware call.\        r\n");
    await context.Response.WriteAsync("Executing the next         Middleware...\r\n");
    await next();
    await context.Response.WriteAsync("In the first middleware call…on the return trip.\r\n");
});
app.Use(async (context, next) =&gt;
{
    await context.Response.WriteAsync("We're in the second middleware         call\r\n");
    await next();
    await context.Response.WriteAsync("On our way back from the second         middleware call\r\n");
});</pre> <p>This <a id="_idIndexMarker131"/>code<a id="_idIndexMarker132"/> creates the following output:</p>
<pre class="source-code">
In the first middleware call.
Executing the next Middleware...
We're in the second middleware call
On our way back from the second middleware call
In the first middleware call…on the return trip.</pre> <p>You’ll notice<a id="_idIndexMarker133"/> anything before the <code>next.invoke()</code> line of code is executed and then the execution moves on to the next Middleware in the order. Once we get to the end of the Middleware pipeline, we make the return trip back, which executes all of the code <em class="italic">after</em> each Middleware’s <code>await </code><code>next();</code> statement.</p>
<p>After each Middleware component is executed, the application runs and then returns in reverse order.</p>
<h3>Map</h3>
<p>The <code>Map()</code> request delegate<a id="_idIndexMarker134"/> is meant for branching the <a id="_idIndexMarker135"/>pipeline based on a certain request path or route. While this is for specific Middleware conditions, creating a new map is highly unlikely. It’s usually best to use pre-built Middleware components such as <code>.MapRazorPages()</code>, <code>.MapControllers()</code>, or any of the other <code>.MapXxxx()</code> methods. These methods already have pre-defined routes in place. Most routing occurs inside other extensions like the previously mentioned Middleware methods.</p>
<p>There is also a <code>MapWhen()</code> extension method for conditional middleware branching based <a id="_idIndexMarker136"/>on the result of a given predicate. For example, if you want to create a controlled maintenance page for your site, you could use a <a id="_idIndexMarker137"/>simple Boolean called <code>underMaintenance</code> and use it to display a simple message until your site is available again:</p>
<pre class="source-code">
app.MapWhen(_ =&gt; underMaintenance, ctx =&gt;
    ctx.Run(async context =&gt;
    {
        await context.Response
            .WriteAsync("We are currently under maintenance.");
    })
);</pre> <p>In the preceding code, we add our <code>.MapWhen()</code> delegate to use a specific Boolean to identify whether we are under maintenance or not. Notice we’re using the <code>.Run</code> delegate because we don’t want to continue any further down the Middleware pipeline. This approach is just one example of Middleware’s flexibility.</p>
<p class="callout-heading">Using Built-in Middleware Components</p>
<p class="callout">While <a id="_idIndexMarker138"/>you can create your own Middleware components, the best approach is to see whether a Middleware component exists from the large number of built-in components already available to you. The entire list is located at <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-7.0#built-in-middleware">https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-7.0#built-in-middleware</a>. This chart provides a description of each Middleware component and the location of where to place it in the Middleware pipeline. In addition to the built-in components, use NuGet to find innovative Middleware components as well.</p>
<p>In this section, we covered the middleware pipeline, learned how to use the request delegates and what each request delegate can do, and learned about all of the built-in middleware components available for ASP.NET web applications. In the next section, we’ll examine the common practices for using Middleware.</p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor076"/>Common Practices for Middleware</h1>
<p>In this section, we’ll <a id="_idIndexMarker139"/>review a number of common practices when writing your own middleware to keep everything running optimally in your web application. Let’s get started!</p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor077"/>Defer to Asynchronous</h2>
<p>When working with <a id="_idIndexMarker140"/>Middleware, we want to get the best performance possible so our users can begin working in the application. As more users continue to use the application, performance may suffer.</p>
<p>A synchronous operation is where code is executed and the application has to wait for it to finish, meaning it’s single-threaded and runs on the application’s main thread, but when an asynchronous operation is executed, it creates a new thread and lets the framework know what to call when it’s finished processing. This is signified through the <code>async</code>/<code>await</code> keywords.</p>
<p>For the majority of Middleware operations, it’s best to use asynchronous calls when applicable. This will increase Middleware (and application) performance along with better scalability and responsiveness.</p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor078"/>Prioritizing the Order</h2>
<p>One of the more<a id="_idIndexMarker141"/> important points of setting up your Middleware is to confirm everything is in the right order.</p>
<p>Compare your application’s requirements with the previous chart to identify what middleware components you need and what their correct order is for your web application.</p>
<p>For example, if you want to include a W3C Logging Middleware component (which is included in the built-in Middleware components from Microsoft), it has to be at the beginning of the pipeline to log any subsequent requests made throughout the application. Each component has its place in the pipeline.</p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor079"/>Consolidating existing Middleware</h2>
<p>When you <a id="_idIndexMarker142"/>create a new ASP.NET project, you’ll notice the collection of <code>app.UseXxx()</code> listed in <code>Program.cs</code>. While this is the “out-of-the-box” approach for preparing your pipeline, there are other ways to organize and register components for your application.</p>
<p>One approach is to use extension methods based on how you logically partition your uses into similar groupings while keeping the components in the same order.</p>
<p>One example would be to move all client Middleware into its own extension method called <code>.</code><code>UseClientOptions()</code>:</p>
<pre class="source-code">
public static class WebApplicationExtensions
{
    public static void UseClientOptions(this WebApplication app)
    {
        app.UseHttpsRedirection();
        app.UseStaticFiles();
    }
}</pre> <p>Now, the code in your <code>Program.cs</code> file contains one line, and you know exactly what the extension method does:</p>
<pre class="source-code">
app.UseClientOptions();</pre> <p>When using this approach, your <code>Program.cs</code> file is cleaner, well maintained, and contains fewer lines of code.</p>
<p>Other possible areas to partition are as follows:</p>
<ul>
<li><code>UseDataXxxxx()</code> – Centralized location for connection strings for your application</li>
<li><code>UseMapping()/UseRouting()</code> – Create a collection of routes for your application and APIs</li>
<li><code>RegisterDependencyInjection()</code> – Centralize the classes in a number of extension methods similar to this grouping approach, but partitioned by sections in your application – for example, <code>RegisterDIPayroll()</code> for registering classes pertaining to the Payroll section of the application</li>
</ul>
<p>While<a id="_idIndexMarker143"/> these are merely suggestions, the concept is to trim the size of the <code>Program.cs</code> file so other developers understand the approach with fewer lines of code, and it provides enough clarity for other developers to extend the technique further.</p>
<p>As a recommendation, include all of the important Middleware components upfront and confirm the application runs as expected, <em class="italic">then</em> perform your refactoring by creating your groups for consolidation. Remember, the order of Middleware components matters.</p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor080"/>Encapsulating your Middleware</h2>
<p>When creating <a id="_idIndexMarker144"/>your first middleware component, you may be tempted to create it and use it in this fashion:</p>
<pre class="source-code">
app.Use(async (context, next) =&gt;
{
    app.Logger.LogInformation("In our custom Middleware...");
    // Prepare work for when we write to the Response
    await next();
    // work that happens when we DO write to the response.
});</pre> <p>One problem with this approach is the preceding code can make your <code>Program.cs</code> file look a little messy if you have a large number of custom middleware components.</p>
<p>Once you have your custom component working, it’s better to encapsulate it into its own class for increased reusability. If we use our previous example, our new class would look like<a id="_idIndexMarker145"/> this:</p>
<pre class="source-code">
public class MyFirstMiddleware
{
    private readonly ILogger _logger;
    private readonly RequestDelegate _next;
    public MyFirstMiddleware(ILogger logger, RequestDelegate next)
    {
        _logger = logger;
        _next = next;
    }
    public async Task InvokeAsync(HttpContext context)
    {
        _logger.LogInformation("In our custom Middleware...");
        // Prepare work for when we write to the Response
        await _next(context);
        // work that happens when we DO write to the response.
    }
}</pre> <p>In this example, the <code>MyFirstMiddleware</code> component is a simple class that can contain only one method of <code>Invoke</code> or <code>InvokeAsync</code>. As mentioned before, we’ll use the <code>InvokeAsync</code> asynchronous method.</p>
<p>If you’re <a id="_idIndexMarker146"/>wondering how <code>ILogger</code> is passed in, ASP.NET Core has a number of classes automatically registered with its out-of-the-box dependency injection library. <code>ILogger</code> is one of those classes, so we don’t need to worry about passing it through to our <code>MyFirstMiddleware</code> component.</p>
<p>We can use our class in our <code>Program.cs</code> file like this:</p>
<pre class="source-code">
app.UseMiddleware&lt;MyFirstMiddleware&gt;();</pre> <p>However, since we’re good ASP.NET developers, we can definitely improve the code. Most middleware components have extension methods attached to them to make them easier to use (which we’ll add <a id="_idTextAnchor081"/>now with the following code):</p>
<pre class="source-code">
public static class MyFirstMiddlewareExtensions
{
    public static IApplicationBuilder UseMyFirstMiddleware(
        this IApplicationBuilder builder)
    {
        return builder.UseMiddleware&lt;MyFirstMiddleware&gt;();
    }
}</pre> <p>Our <code>Program.cs</code> file is much simpler and cleaner now:</p>
<pre class="source-code">
app.UseMyFirstMiddleware();</pre> <p>These simple practices make a developer’s life easier for reusability and encapsulation.</p>
<p>In this section, we covered a number of standard methods for writing maintainable and efficient Middleware by using asynchronous calls, prioritizing the order of your components, and consolidating the existing Middleware into extension methods. We also examined how to encapsulate components by creating classes and extension methods to make the code easier to read.</p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor082"/>Creating an Emoji Middleware Component</h1>
<p>With the rise<a id="_idIndexMarker147"/> of emoticons…sorry, emojis…in the 2000s, a number of legacy websites use the old-style of text-based emoticons instead of the more modern emojis. Legacy <strong class="bold">Content Management Systems</strong> (<strong class="bold">CMSs</strong>) must <a id="_idIndexMarker148"/>have a lot of these text-based characters in their content. To update a website’s content to replace all of these emoticons with proper emojis sounds extremely time-consuming.</p>
<p>In this section, we’ll apply our standards in creating an emoji Middleware component where, if it detects a text-based emoticon, it’ll convert it to a more modern emoji.</p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor083"/>Encapsulating the Middleware</h2>
<p>With this<a id="_idIndexMarker149"/> new Middleware component, we want to create it in its own class in <code>EmojiMiddleware.cs</code>.</p>
<p>Here is the first draft of our component:</p>
<pre class="source-code">
public class EmojiMiddleware
{
    private readonly ILogger _logger;
    private readonly RequestDelegate _next;
    public EmojiMiddleware(ILogger logger, RequestDelegate next)
    {
        _logger = logger;
        _next = next;
    }
    public async Task InvokeAsync(HttpContext context)
    {
        await _next(context);
    }
}
public static class EmojiMiddlewareExtensions
{
    public static IApplicationBuilder UseEmojiMiddleware(
        this IApplicationBuilder builder)
    {
        return builder.UseMiddleware&lt;EmojiMiddleware&gt;();
    }
}</pre> <p>While<a id="_idIndexMarker150"/> this isn’t very exciting, this boilerplate meets all of the previously-mentioned standards for building Middleware components, which include the following:</p>
<ul>
<li>An encapsulated Middleware component</li>
<li>Using Asynchronous methods (<code>InvokeAsync()</code>)</li>
<li>An extension method for reuse and readability</li>
</ul>
<p>We can now focus on the conversion process.</p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor084"/>Examining the Component’s Pipeline</h2>
<p>In <a id="_idIndexMarker151"/>Middleware, there are two ways to process a request and response: by using either streams or pipelines. While pipelines are the better option for high performance, we’ll focus on streams for our <code>EmojiMiddleware</code>. We’ll examine pipelines in a later chapter.</p>
<p>Our middleware stream is located in <code>HttpContext</code> through <code>HttpRequest.Body</code> and <code>HttpResponse.Body</code>. In our <code>Invoke</code> method, we conveniently pass in an <code>HttpContext</code>.</p>
<p>Our first order of business is to create the <code>EmojiStream</code>. This will accept a simple response stream and read it into memory. Once we have our HTML, we can search and replace our emoticons. We need a map to identify the text-based characters and what image to replace them in our HTML.</p>
<p>To make <a id="_idIndexMarker152"/>our life a little easier, we’ll inherit from the <code>Stream</code> base class and simply override specific methods to fit our needs. The only implementation our <code>EmojiStream</code> class needs is our text-based emoticons-to-emojis mapping and the <code>.Write()</code> method, as shown with the following code:</p>
<pre class="source-code">
public class EmojiStream: Stream
{
    private readonly Stream _responseStream;
    private readonly Dictionary&lt;string, string&gt; _map = new()
    {
        { ":-)", " :) " },
        { ":)", " :) " },
        { ";-)", " ;) " }
    };
    public EmojiStream(Stream responseStream)
    {
        ArgumentNullException.ThrowIfNull(responseStream);
        _responseStream = responseStream;
    }
    public override bool CanRead =&gt; _responseStream.CanRead;
    public override bool CanSeek =&gt; _responseStream.CanSeek;
    public override bool CanWrite =&gt; _responseStream.CanWrite;
    public override long Length =&gt; _responseStream.Length;
    public override long Position
    {
        get =&gt; _responseStream.Position;
        set =&gt; _responseStream.Position = value;
    }
    public override void Flush()
    {
        _responseStream.Flush();
    }
    public override int Read(byte[] buffer, int offset, int count)
    {
        return _responseStream.Read(buffer, offset, count);
    }
    public override long Seek(long offset, SeekOrigin origin)
    {
        return _responseStream.Seek(offset, origin);
    }
    public override void SetLength(long value)
    {
        _responseStream.SetLength(value);
    }
    public override void Write(byte[] buffer, int offset, int count)
    {
        var html = Encoding.UTF8.GetString(buffer, offset, count);
        foreach (var emoticon in _map)
        {
            if (!html.Contains(emoticon.Key)) continue;
            html = html.Replace(emoticon.Key, emoticon.Value);
        }
        buffer = Encoding.UTF8.GetBytes(html);
        _responseStream.WriteAsync(buffer, 0, buffer.Length);
    }
}</pre> <p>At the beginning of the code, we create our map of emoticons to look for in the HTML. The <code>EmojiStream</code> class is fairly common, except for the <code>WriteAsync()</code> method. We’ll grab the HTML using the <code>GetString()</code> method and search for each emoticon in the response. If we find one, we’ll replace it with an image tag and, finally, write the bytes back into the stream.</p>
<p>Since we’re focused on using streams in the Middleware, we’ll pass a stream into the constructor instead of creating a new instance.</p>
<p>With the <a id="_idIndexMarker153"/>middleware piece left, we can use the <code>EmojiStream</code> in our class:</p>
<pre class="source-code">
public class EmojiMiddleware
{
    private readonly RequestDelegate _next;
    public EmojiMiddleware(RequestDelegate next)
    {
        _next = next;
    }
    public async Task InvokeAsync(HttpContext context)
    {
        using var buffer = new MemoryStream();
        // Replace the context response with our buffer
        var stream = context.Response.Body;
        context.Response.Body = buffer;
        // Invoke the rest of the pipeline
        // if there are any other middleware components
        await _next(context);
        // Reset and read out the contents
        buffer.Seek(0, SeekOrigin.Begin);
        // Adjust the response stream to include our images.
        var emojiStream = new EmojiStream(stream);
        // Reset the stream again
        buffer.Seek(0, SeekOrigin.Begin);
        // Copy our content to the original stream and put it back
        await buffer.CopyToAsync(emojiStream);
        context.Response.Body = emojiStream;
    }
}</pre> <p>While our <a id="_idIndexMarker154"/>Middleware component takes a simple <code>RequestDelegate</code>, the majority of the component is in the <code>InvokeAsync()</code> method. First, we create a new stream for our response. Next, we replace the standard response with our own stream. When we are coming back from our endpoint, we create our <code>EmojiStream</code> instance and pass in our custom stream to the <code>Response.Body</code>.</p>
<p>Since <code>HttpContext</code> exposes <code>HttpRequest.Body</code> and <code>HttpResponse.Body</code> as streams, it’s easier to pass <code>HttpContext</code> into custom middleware components.</p>
<p>Of course, we can’t forget our extension method, which is shown here:</p>
<pre class="source-code">
public static class EmojiMiddlewareExtensions
{
    public static IApplicationBuilder UseEmojiMiddleware(
        this IApplicationBuilder builder)
    {
        return builder.UseMiddleware&lt;EmojiMiddleware&gt;();
    }
}</pre> <p>This extension method is considered a façade to hide the details of what our <code>EmojiStream</code> is doing behind the scenes. While we could use the <code>builder.UseMiddleware&lt;EmojiMiddleware&gt;()</code> syntax in our <code>Program.cs</code> file, the extension method cleans it up a bit, giving it a professional look.</p>
<p>The last thing <a id="_idIndexMarker155"/>required is to add the <code>EmojiMiddleware</code> to the pipeline in your <code>Program.cs</code> file:</p>
<pre class="source-code">
app.UseEmojiMiddleware();</pre> <p>After creating a brand new ASP.NET Core website, we’ll add the following HTML to the bottom of our Index page:</p>
<pre class="source-code">
&lt;div class="text-center"&gt;
    &lt;h2&gt;Smile, you're on candid camera. :-) :)&lt;/h2&gt;
    &lt;p&gt;It even works inside ;-) a paragraph.&lt;/p&gt;
&lt;/div&gt;</pre> <p>When we run the application without our middleware component, we have the following output (<em class="italic">Figure 3</em><em class="italic">.2</em>):</p>
<div><div><img alt=" Figure 3.2 – Before our EmojiMiddleware is added to the pipeline" src="img/Figure_3.02_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Figure 3.2 – Before our EmojiMiddleware is added to the pipeline</p>
<p>When we add our Emoji Middleware to our pipeline and run our application again, we receive the following output (<em class="italic">Figure 3</em><em class="italic">.3</em>):</p>
<div><div><img alt="Figure 3.3 – After our EmojiMiddleware is added to the pipeline" src="img/Figure_3.03_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – After our EmojiMiddleware is added to the pipeline</p>
<p>In this section, we built our first Middleware component by encapsulating the logic in a class, examined the <a id="_idIndexMarker156"/>components pipeline using streams, and used the Middleware component in a web application.</p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor085"/>Summary</h1>
<p>In this chapter, we have gained a solid understanding of the Middleware pipeline, its components, and best practices for using Middleware in ASP.NET Core. We also learned about common practices when using Middleware, such as always using asynchronous methods, prioritizing the order, consolidating your Middleware components into groups, and encapsulating your Middleware into classes. Knowing these Middleware concepts is key to creating maintainable and readable code.</p>
<p>Finally, we finished the chapter by creating a simple component to replace text with an image in a stream for the user.</p>
<p>In the next chapter, we’ll begin looking at applying security to new and existing applications.</p>
</div>
</body></html>