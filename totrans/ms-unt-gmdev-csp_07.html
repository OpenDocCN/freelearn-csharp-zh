<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-56"><a id="_idTextAnchor058" class="calibre6 pcalibre1 pcalibre"/>4</h1>
<h1 id="_idParaDest-57" class="calibre5"><a id="_idTextAnchor059" class="calibre6 pcalibre1 pcalibre"/>Implementing Engaging Game Mechanics Using C# in Unity</h1>
<p class="calibre3">Welcome to <a href="B22017_04.xhtml#_idTextAnchor058" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 4</em></a>, where we invite you into the dynamic world of game development. As you delve into this chapter, your journey will begin by exploring the foundational principles that drive successful game mechanics. This initial step involves an introduction to game mechanics, allowing you to grasp the essential concepts that form the backbone of captivating gameplay.</p>
<p class="calibre3">Following this, you’ll seamlessly transition into the realm of player behavior and AI before delving into the topics of challenge and reward systems. This journey unravels the art of crafting interactive and responsive gaming experiences.</p>
<p class="calibre3">By the end of this chapter, you’ll be equipped with not only theoretical insights but also practical skills to shape immersive gaming adventures in Unity using the power of C#.</p>
<p class="calibre3">In this chapter, we’re going to cover the following main topics:</p>
<ul class="calibre10">
<li class="calibre11">Introducing game mechanics</li>
<li class="calibre11">Implementing player behavior and AI logic using C#</li>
<li class="calibre11">Implementing challenge and reward systems using C#</li>
</ul>
<h1 id="_idParaDest-58" class="calibre5"><a id="_idTextAnchor060" class="calibre6 pcalibre1 pcalibre"/>Technical requirements</h1>
<p class="calibre3">You can access the code samples and project files on our dedicated GitHub repository: <a href="https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2004" class="calibre6 pcalibre1 pcalibre">https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2004</a>.</p>
<p class="calibre3">Clone or download the repository so that you have easy access to the code demonstrated in this chapter.</p>
<h1 id="_idParaDest-59" class="calibre5"><a id="_idTextAnchor061" class="calibre6 pcalibre1 pcalibre"/>Introducing game mechanics</h1>
<p class="calibre3"><strong class="bold">Game mechanics</strong> are <a id="_idIndexMarker226" class="calibre6 pcalibre1 pcalibre"/>the rules and systems that shape how a game is played. Think of them as the behind-the-scenes mechanisms that define the player’s experience. They are vital for crafting engaging gameplay, influencing everything from movement and combat to how a story unfolds. Successful games, such as <em class="italic">Mario</em> with its jumping mechanics, or <em class="italic">Tetris</em> with its block arrangement challenges, showcase how well-crafted mechanics can create memorable and enjoyable experiences for players.</p>
<p class="calibre3">Game mechanics go beyond just making a game work; they subtly tell stories by how players interact. Whether it’s in fighting games with complex combat or in platformers with puzzle-solving, these mechanics add to the overall story. When players follow the game’s rules, they’re not just watching; they become part of the story.</p>
<p class="calibre3">So, understanding and creating game mechanics is like becoming skilled at interactive storytelling. Each button that’s pressed or moved in the game helps the story move along, making every playthrough a unique and personal journey.</p>
<p class="calibre3">In the following section, we will talk about the essential principles you need to know about game mechanics.</p>
<h2 id="_idParaDest-60" class="calibre7"><a id="_idTextAnchor062" class="calibre6 pcalibre1 pcalibre"/>Essential principles of game mechanics</h2>
<p class="calibre3">Now, let’s get<a id="_idIndexMarker227" class="calibre6 pcalibre1 pcalibre"/> into the important stuff that makes games enjoyable. We’re talking about the basic rules that shape how players have fun. It’s all about finding the right balance, giving feedback, and making sure players feel in control. These simple things turn games into exciting adventures where every move adds to the fun.</p>
<h3 class="calibre9">Balance</h3>
<p class="calibre3"><strong class="bold">Balance</strong> in <a id="_idIndexMarker228" class="calibre6 pcalibre1 pcalibre"/>games is like ensuring everyone gets a fair shot at having fun. Picture a game where one character is super strong, making it impossible for others to enjoy. That wouldn’t be fair, right? Game developers work hard to create a balanced experience where each player or character has a chance to shine. Take <em class="italic">Overwatch</em>, for example. In this game, each hero boasts unique abilities, and no one is overwhelmingly powerful or weak. It’s this careful balance that ensures a level playing field, allowing everyone to have a good time and contribute to the game’s excitement.</p>
<p class="calibre3">Furthermore, balance<a id="_idIndexMarker229" class="calibre6 pcalibre1 pcalibre"/> goes beyond characters; it extends to the overall gameplay. Imagine a game with levels that are either too easy or impossibly hard – players would quickly lose interest. Achieving balance in challenges, difficulty, and rewards keeps players engaged. Games that strike this delicate balance provide a satisfying and enjoyable experience for players of all skill levels, making them want to keep playing and exploring what the game has to offer.</p>
<h3 class="calibre9">Feedback</h3>
<p class="calibre3">In the world of <a id="_idIndexMarker230" class="calibre6 pcalibre1 pcalibre"/>gaming, <strong class="bold">feedback</strong> is the game’s way of talking to you, letting you know how you’re doing. It’s like a pat on the back when you do something right or a gentle nudge when you could improve. In <em class="italic">Minecraft</em>, for instance, when you successfully mine resources, a satisfying sound accompanies the action. That sound is feedback, a small celebration telling you that you’ve accomplished a task.</p>
<p class="calibre3">Think about playing a racing game without any feedback – no cheering crowd, no speedometer ticking up – it would be a bit strange, right? Good feedback, whether it’s visual, auditory, or haptic, is essential for making players feel accomplished and guiding them through the game’s challenges.</p>
<p class="calibre3">Moreover, feedback extends to storytelling in games. Choices you make should have consequences, and the game should let you know how your decisions impact the story. Effective feedback creates a dynamic connection between the player and the game world, making every action feel meaningful. Whether it’s triumphant music after a successful quest or a subtle change in the environment based on your decisions, feedback adds depth to the gaming experience, ensuring players stay engaged and invested in the virtual world they’re exploring.</p>
<h3 class="calibre9">Player agency</h3>
<p class="calibre3"><strong class="bold">Player agency</strong> is like <a id="_idIndexMarker231" class="calibre6 pcalibre1 pcalibre"/>having a steering wheel in a game – you get to make choices and have control over your virtual adventure. In <em class="italic">The Elder Scrolls V: Skyrim</em>, this principal shines brightly. Right from the start, you decide who your character is going to be. Do you want to be a brave warrior, a sneaky thief, or a powerful wizard? The game doesn’t force you down a specific path; instead, it lets you carve out your own story.</p>
<p class="calibre3">This freedom <a id="_idIndexMarker232" class="calibre6 pcalibre1 pcalibre"/>to make choices extends beyond character creation. As you progress through the game, you encounter various quests and challenges, and here, again, player agency takes center stage. You can decide how to approach a situation – do you want to negotiate, fight, or sneak past enemies? Your choices influence not just the immediate outcome but also the overall story. Your version of <em class="italic">Skyrim</em> might be entirely different from someone else’s because player agency allows for diverse experiences.</p>
<p class="calibre3">Having player agency transforms a game into more than just a set path with predetermined outcomes. It transforms it into your story, where your decisions matter, and the game adapts to your choices. This sense of control and the ability to shape your unique adventure is what makes player agency a key principle in creating immersive and personally meaningful gaming experiences.</p>
<p class="calibre3">In the following section, we are going to understand the relationship between code and game mechanics.</p>
<h2 id="_idParaDest-61" class="calibre7"><a id="_idTextAnchor063" class="calibre6 pcalibre1 pcalibre"/>The connection between code and game mechanics</h2>
<p class="calibre3">Now, here’s the cool part – the code is what turns ideas into action in the game. It’s like a rulebook<a id="_idIndexMarker233" class="calibre6 pcalibre1 pcalibre"/> that tells the game what to do. If you want to create a game where players can shoot lasers, you’d write code to make it happen. So, the relationship between code and game mechanics is like a chef’s recipe for a delicious meal – the code guides the game to do exactly what we want.</p>
<p class="calibre3">Understanding these coding basics is like having the keys to the game-making kingdom. It allows you to bring your game ideas to life and create all sorts of cool stuff. Plus, the more you understand C#, the more you can make your games do awesome things. So, get ready to dive into the world of coding in this chapter – it’s not as tricky as it sounds, and it’s the secret sauce that makes games so much fun to play!</p>
<h1 id="_idParaDest-62" class="calibre5"><a id="_idTextAnchor064" class="calibre6 pcalibre1 pcalibre"/>Implementing player behavior and AI logic using C#</h1>
<p class="calibre3">In this section, we’ll be<a id="_idIndexMarker234" class="calibre6 pcalibre1 pcalibre"/> getting into how games <a id="_idIndexMarker235" class="calibre6 pcalibre1 pcalibre"/>are made, looking at how players act and how computer-controlled characters (we call it AI) think in games. Figuring out how players act and how game characters react is a big deal in making games fun. It’s like giving players a script to follow, just like actors in a play. Players bring the game to life, a bit like how actors make a story interesting. We’ll look at different types of games, checking out how players act in all sorts of situations, from big adventures to tactical fights.</p>
<p class="calibre3">Then, we’ll <a id="_idIndexMarker236" class="calibre6 pcalibre1 pcalibre"/>check out AI, the smart computer stuff that makes game enemies, friends, and other characters feel real. AI isn’t just code; it’s like<a id="_idIndexMarker237" class="calibre6 pcalibre1 pcalibre"/> magic that makes challenges exciting, enemies tricky, and friends helpful. We’ll explain the basic ideas behind this digital magic, kind of like understanding the cues a conductor gives to an orchestra, guiding all the actions and reactions in a game.</p>
<p class="calibre3">So, we’re on a journey to make player behavior and AI logic less mysterious using C# – a fancy way to talk to computers. You’ll be all set to make games that feel real, keeping players interested and making your game super exciting!</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Understanding player behavior design</strong>: In the realm of player behavior design, crafting a responsive<a id="_idIndexMarker238" class="calibre6 pcalibre1 pcalibre"/> game involves the fundamental aspect <a id="_idIndexMarker239" class="calibre6 pcalibre1 pcalibre"/>of <strong class="bold">health management</strong>. <strong class="bold">Health</strong>, being a universal concept for both players and enemies, is a core behavior that greatly influences the overall gaming experience. To achieve a modular and extensible system, we must introduce an <strong class="source-inline1">IHealth</strong> interface that encapsulates essential functions, such as tracking maximum health, current health, taking damage, and healing. By adopting this interface, we can establish a unified approach to health management that applies to both players and enemies. This not only streamlines the code base but also allows for easy expansion and modification as the game evolves.</li>
<li class="calibre11"><strong class="bold">Shooting mechanics</strong>: In <a id="_idIndexMarker240" class="calibre6 pcalibre1 pcalibre"/>addition to health, we’ll delve into shooting mechanics, a pivotal player behavior in a shooting game. Rather than a simplistic shooting script, we’ll opt for a modular approach, creating separate components for bullets, projectiles, and weapons. This modular design enables flexibility and scalability, making it easier to introduce new weapons, tweak projectile behaviors, and enhance overall gameplay dynamics.</li>
<li class="calibre11"><strong class="bold">Introduction to AI logic</strong>: Transitioning to AI logic, we’ll explore fundamental concepts that <a id="_idIndexMarker241" class="calibre6 pcalibre1 pcalibre"/>breathe life into in-game adversaries. Basic AI principles encompass understanding the role of AI in creating dynamic and challenging gameplay. The AI system becomes a crucial component in determining enemy behaviors, ranging from simple wandering to complex attack patterns. By delving into these concepts, we’ll gain insights into the decision-making processes that drive AI-controlled entities, contributing to the overall richness of the gaming experience.</li>
<li class="calibre11"><strong class="bold">Coding player behavior and AI</strong>: Moving from theory to practice, we’ll embark on <a id="_idIndexMarker242" class="calibre6 pcalibre1 pcalibre"/>the practical implementation of player behavior and AI logic using C# scripts. The <strong class="source-inline1">IHealth</strong> and <strong class="source-inline1">IDamage</strong> interfaces <a id="_idIndexMarker243" class="calibre6 pcalibre1 pcalibre"/>become the cornerstone for implementing health-related functionalities, ensuring a consistent and manageable approach across diverse game elements. The modular shooting system will take shape as we learn to handle bullets, projectiles, and weapons separately, promoting code reusability and maintainability.</li>
</ul>
<p class="calibre3">To reinforce learning, we’ll <a id="_idIndexMarker244" class="calibre6 pcalibre1 pcalibre"/>engage in hands-on demonstrations, showcasing the step-by-step creation of C# scripts for player behavior and <a id="_idIndexMarker245" class="calibre6 pcalibre1 pcalibre"/>AI logic in the subsequent sections. We’ll gain proficiency in designing and implementing responsive player behaviors, fostering an understanding of how to bring dynamic AI characters to life within the Unity game development environment.</p>
<p class="calibre3">Let’s start by writing the <code>IHealth</code> interface and establishing the fundamental logic for it.</p>
<h2 id="_idParaDest-63" class="calibre7"><a id="_idTextAnchor065" class="calibre6 pcalibre1 pcalibre"/>Writing the IHealth and IDamage interfaces</h2>
<p class="calibre3">In the following <a id="_idIndexMarker246" class="calibre6 pcalibre1 pcalibre"/>code block, we’ve introduced the <code>IHealth</code> interface, which incorporates properties for maximum and current health, along with essential functions for setting maximum health, inflicting damage, and facilitating healing. Here, we’ll create an interface to manage the health logic throughout the entire game. I’ve designed it so that it oversees the health of each entity once they implement this interface. This approach will simplify communication between entities and prove beneficial when we also create the <code>IDamage</code> interface. Implementing <code>IDamage</code> in components responsible for dealing damage will allow us to affect the <a id="_idIndexMarker247" class="calibre6 pcalibre1 pcalibre"/>health component seamlessly:</p>
<pre class="source-code">
namespace FusionFuryGame
{
    public interface IHealth
    {
        float MaxHealth { get; set; }   // Property for maximum health
        float CurrentHealth { get; set; }  // Property for current health
        void TakeDamage(float damage);  // Method to apply damage
        void SetMaxHealth();  // Method to set current health to max health
        void Heal();            // Method to apply healing
    }
}</pre> <p class="calibre3">Next, we will create the <code>IDamage</code> interface, which will feature a central function for dealing damage. Subsequent classes will implement this interface, handling damage calculations internally and conveying the resulting damage value to other classes, as demonstrated in the following code block:</p>
<pre class="source-code">
namespace FusionFuryGame
{
    public interface IDamage
    {
        float GetDamageValue();  // Method to retrieve the damage value
    }
}</pre> <p class="calibre3">Now, we must <a id="_idIndexMarker248" class="calibre6 pcalibre1 pcalibre"/>integrate the <code>IHealth</code> interface into the player. Therefore, we will generate the <code>PlayerHealth</code> component and affix it to the player’s <code>GameObject</code>. The <code>PlayerHealth</code> class will manage all functions related to the player’s health, including setting the maximum health and processing damage. When the player’s health falls to zero or below, the player dies. It’s designed as a separate class that you attach to the player’s GameObject, facilitating communication with enemies, as illustrated in the following code block:</p>
<pre class="source-code">
namespace FusionFuryGame
{
    public class PlayerHealth : MonoBehaviour, IHealth
    {
        public static UnityAction onPlayerDied = delegate { };
        public float startingMaxHealth = 100;  // Set a default starting maximum health for the player
        public float healInterval = 2f;  // Time interval for healing
        public float healAmount = 5f;    // Amount of healing per interval
        private WaitForSeconds healIntervalWait;  // Reusable WaitForSeconds instance
        private Coroutine healOverTimeCoroutine;
        public float MaxHealth { get; set; }
        public float CurrentHealth { get; set; }</pre> <p class="calibre3">In the <a id="_idIndexMarker249" class="calibre6 pcalibre1 pcalibre"/>preceding code, I’ve included the required variables related to the player’s health and healing. Additionally, a coroutine will ensure the player heals gradually within the <code>PlayerHealth</code> class:</p>
<pre class="source-code">
        void OnDestroy()
        {
            // Ensure to stop the healing coroutine when the object is destroyed
            if (healOverTimeCoroutine != null)
                StopCoroutine(healOverTimeCoroutine);
        }
        void Start()
        {
            SetMaxHealth();  // Set initial max health
            healIntervalWait = new WaitForSeconds(healInterval);
            StartHealingOverTime();
        }</pre> <p class="calibre3">Let’s take a look at the preceding code:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1">OnDestroy</strong>: This method ensures that the healing coroutine is stopped when the player object is destroyed to prevent memory leaks</li>
<li class="calibre11"><strong class="source-inline1">Start</strong>: This method initializes the player’s health parameters, sets their maximum health, creates a <strong class="source-inline1">WaitForSeconds</strong> instance for healing intervals, and starts the healing coroutine:</li>
</ul>
<pre class="source-code">
        public void TakeDamage(float damage)
        {
            // Implement logic to handle taking damage
            CurrentHealth -= damage;
            // Check for death or other actions based on health status
            if (CurrentHealth &lt;= 0) onPlayerDied.Invoke();
        }
        public void SetMaxHealth()
        {
            MaxHealth = startingMaxHealth;
        }
        public void Heal()
        {
            CurrentHealth += healAmount;
            CurrentHealth = Mathf.Min(CurrentHealth, MaxHealth);
        }
        private void StartHealingOverTime()
        {
            healOverTimeCoroutine = StartCoroutine(HealOverTime());
        }
        private IEnumerator HealOverTime()
        {
            while (true)
            {
                yield return healIntervalWait;
                Heal();
            }
        }
    }
}</pre> <p class="calibre3">Let’s break down the preceding code:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1">TakeDamage</strong>: This <a id="_idIndexMarker250" class="calibre6 pcalibre1 pcalibre"/>method handles the logic for deducting health from the player when they take damage. It also checks if the player’s health has reached zero, triggering the <strong class="source-inline1">onPlayerDied</strong> event if necessary.</li>
<li class="calibre11"><strong class="source-inline1">SetMaxHealth</strong>: This <a id="_idIndexMarker251" class="calibre6 pcalibre1 pcalibre"/>method sets the maximum health of the player to the specified starting maximum health value.</li>
<li class="calibre11"><strong class="source-inline1">Heal</strong>: This <a id="_idIndexMarker252" class="calibre6 pcalibre1 pcalibre"/>method restores the player’s health. It increments the current health by the specified healing amount and ensures that the player’s current health does not exceed the maximum health.</li>
<li class="calibre11"><strong class="source-inline1">StartHealingOverTime</strong>: This<a id="_idIndexMarker253" class="calibre6 pcalibre1 pcalibre"/> method initiates the healing coroutine that’s responsible for gradually restoring the player’s health over time.</li>
<li class="calibre11"><strong class="source-inline1">HealOverTime</strong>: This coroutine <a id="_idIndexMarker254" class="calibre6 pcalibre1 pcalibre"/>runs indefinitely, waiting for the specified healing interval and then invoking the <strong class="source-inline1">Heal</strong> method to restore the player’s health.</li>
</ul>
<p class="calibre3">Now, let’s examine the <code>PlayerCollision</code> component and understand how the player incurs damage. The following code block demonstrates the process of the player taking damage either directly <a id="_idIndexMarker255" class="calibre6 pcalibre1 pcalibre"/>from the enemy or from their projectiles. This class acts as a bridge between the player’s health component and the <code>IDamage</code> interface of the colliding object. We can utilize <code>PlayerHealth</code> and obtain damage through the <code>IDamage</code> interface by using the <code>OnCollisionEnter</code> method:</p>
<pre class="source-code">
namespace FusionFuryGame
{
    public class PlayerCollision : MonoBehaviour
    {
        private PlayerHealth playerHealth;
        private IDamage enemyDamage;
        private void Start()
        {
            playerHealth = GetComponent&lt;PlayerHealth&gt;();
        }
        private void OnCollisionEnter(Collision collision)
        {
            if (collision.gameObject.CompareTag("Enemy") || collision.gameObject.CompareTag("EnemyProjectile"))
            {
                if (collision.gameObject.TryGetComponent(out enemyDamage))
                {
                    playerHealth.TakeDamage(enemyDamage.GetDamageValue());
                }
            }
        }
    }
}</pre> <p class="calibre3">Now, let’s look <a id="_idIndexMarker256" class="calibre6 pcalibre1 pcalibre"/>at the<a id="_idIndexMarker257" class="calibre6 pcalibre1 pcalibre"/> different variables we used here:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1">private PlayerHealth playerHealth;</strong>: This is a reference to the <strong class="source-inline1">PlayerHealth</strong> component that’s attached to the same GameObject. This component manages the health of the player.</li>
<li class="calibre11"><strong class="source-inline1">private IDamage enemyDamage;</strong>: This is an interface reference for handling damage inflicted by enemies or enemy projectiles.</li>
<li class="calibre11"><strong class="source-inline1">Start</strong>: This method retrieves the <strong class="source-inline1">PlayerHealth</strong> component that’s attached to the same GameObject during initialization.</li>
<li class="calibre11"><strong class="source-inline1">OnCollisionEnter</strong>: This method is invoked automatically when a collision occurs that involves the GameObject. It checks if the collision involves an enemy or an enemy projectile by comparing tags. If the collision involves an enemy or an enemy projectile, it attempts to retrieve the <strong class="source-inline1">IDamage</strong> component from the colliding object using <strong class="source-inline1">TryGetComponent</strong>. If successful, it invokes the <strong class="source-inline1">TakeDamage</strong> method of the <strong class="source-inline1">PlayerHealth</strong> component to apply damage to the player’s health.</li>
</ul>
<p class="calibre3">Overall, this script handles collisions between the player character and enemy entities or enemy projectiles. Upon collision, it retrieves the damage value from the colliding object and applies it to the player’s health, ensuring proper damage management in the game.</p>
<p class="calibre3">In the next section, we will explore how the player engages in shooting enemies. However, before delving into that, we’ll implement a shoot system to ensure both the player and the enemy can make use of it.</p>
<h2 id="_idParaDest-64" class="calibre7"><a id="_idTextAnchor066" class="calibre6 pcalibre1 pcalibre"/>Implementing a shoot system</h2>
<p class="calibre3">In this <a id="_idIndexMarker258" class="calibre6 pcalibre1 pcalibre"/>section, we’ll create classes for shooting. Here, we’ll incorporate the <code>IDamage</code> interface into the <code>BaseProjectile</code> class, which serves as the foundation for all ammunition types. This allows us to compute the damage that will be applied to the health component.</p>
<p class="calibre3">In the following code block, we’re configuring the damage value, which will be calculated for the player or enemies. This is a general system that can be applied to all objects:</p>
<pre class="source-code">
namespace FusionFuryGame
{
    public abstract class BaseProjectile : MonoBehaviour, IDamage
    {
        private float damage;
        public virtual void SetDamageValue(float value)
        {
            damage = value;
        }
        public float GetDamageValue()
        {
            return damage;
        }
    }
}</pre> <p class="calibre3">Let’s look at the <a id="_idIndexMarker259" class="calibre6 pcalibre1 pcalibre"/>variables that were used here:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1">private float damage;</strong>: This variable stores the damage value associated with the projectile.</li>
<li class="calibre11"><strong class="source-inline1">public virtual void SetDamageValue(float value)</strong>: This method allows subclasses to set the damage value for the projectile. It takes a float parameter value representing the damage to be set. When called, it assigns the provided value to the damage variable. The <strong class="source-inline1">virtual</strong> keyword indicates that this method can be overridden by subclasses to provide specialized behavior if needed.</li>
<li class="calibre11"><strong class="source-inline1">GetDamageValue Method</strong>: This method retrieves the damage value of the projectile. It simply returns the value stored in the damage variable.</li>
</ul>
<p class="calibre3">Overall, this abstract class provides a blueprint for projectile objects in the game. Subclasses can inherit from this class and customize the behavior of projectiles by overriding the <code>SetDamageValue</code> method or adding additional functionality as needed. The <code>GetDamageValue</code> method allows other game components to access the damage value of projectiles when needed, enabling consistent damage handling throughout the game.</p>
<p class="calibre3">Next, we can create the <code>BaseWeapon</code> script, which is versatile enough to be utilized by both players and enemies, considering that enemies will also possess weapons. Each weapon will be associated with an attached projectile, allowing for the creation of various projectile types.</p>
<p class="calibre3">Additionally, there<a id="_idIndexMarker260" class="calibre6 pcalibre1 pcalibre"/> is the concept of <code>weaponPower</code>, a variable that varies from one weapon to another, influencing the applied damage. <code>muzzleTransform</code> serves as the point for shooting projectiles, and <code>projectileForce</code> dictates the movement of the projectile.</p>
<p class="calibre3">Lastly, we must define the <code>Shoot</code> function, as illustrated in the following code block:</p>
<pre class="source-code">
namespace FusionFuryGame
{
    public abstract class BaseWeapon : MonoBehaviour
    {
        [SerializeField] protected BaseProjectile attachedProjectile;
        [SerializeField] protected float weaponPower;
        [SerializeField] protected Transform muzzleTransform;
        [SerializeField] protected float projectileForce;
        public virtual void Shoot( float fireDamage)
        {
          // Instantiate the projectile from the object pool
          GameObject projectileObject = ObjectPoolManager.Instance.GetPooledObject(attachedProjectile.tag);
          if (projectileObject != null)
          {
            // Set the position of the projectile to the gun's muzzle position
            projectileObject.transform.position = muzzleTransform.position;
            // Get the rigid body component from the projectile
            Rigidbody projectileRb = projectileObject.GetComponent&lt;Rigidbody&gt;();
            if (projectileRb != null)
            {
               // Apply force to the projectile in the forward vector of the weapon
               projectileRb.AddForce(muzzleTransform.forward * projectileForce, ForceMode.Impulse);
               // Modify the fire damage by adding the current weapon's power
               float modifiedDamage = fireDamage + weaponPower;
               // Apply damage and other logic to the projectile (consider implementing IDamage interface)
               attachedProjectile.SetDamageValue(modifiedDamage);
            }
            else
            {
               // Handle if the projectile doesn't have a rigid body
               Debug.LogWarning("Projectile prefab is missing Rigidbody component.");
            }
          }
        }
    }
}</pre> <p class="calibre3">Let’s look at the <a id="_idIndexMarker261" class="calibre6 pcalibre1 pcalibre"/>serialized fields:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1">protected BaseProjectile attachedProjectile</strong>: This refers to the type of projectile attached to the weapon. It is serialized to allow assignment in Unity’s <strong class="bold">Inspector</strong> view.</li>
<li class="calibre11"><strong class="source-inline1">protected float weaponPower</strong>: This refers to the power of the weapon. It is serialized to allow for adjustments in the <strong class="bold">Inspector</strong> view.</li>
<li class="calibre11"><strong class="source-inline1">protected Transform muzzleTransform</strong>: This refers to the position where projectiles spawn, typically the muzzle of the weapon.</li>
<li class="calibre11"><strong class="source-inline1">protected float projectileForce</strong>: This refers to the force that’s applied to the projectile when it’s shot from the weapon.</li>
<li class="calibre11"><strong class="source-inline1">Shoot</strong>: This method is responsible for shooting the weapon. First, it attempts to get a pooled projectile object from Object Pool Manager. If a projectile object is retrieved, it sets its position to the muzzle of the weapon and adds force to propel it forward. This method also modifies the fire damage by adding the weapon’s power to it. Finally, it applies the modified damage and any other logic to the projectile, potentially by implementing an <strong class="source-inline1">IDamage</strong> interface.</li>
</ul>
<p class="calibre3">Overall, this abstract class provides a foundation for implementing different types of weapons in the game. Subclasses can inherit from this class to create specific weapon types and customize their behavior as needed. The <code>Shoot</code> method handles the spawning and firing of projectiles, allowing for flexible and dynamic weapon functionality.</p>
<p class="calibre3">The following code<a id="_idIndexMarker262" class="calibre6 pcalibre1 pcalibre"/> block provides an example of utilizing <code>BaseWeapon</code> with the <code>SimpleGun</code> class. We’re going to use it with the player for shooting enemies, so it will be used as the player’s weapon:</p>
<pre class="source-code">
namespace FusionFuryGame
{
    public class SimpleGun : BaseWeapon
    {
        public override void Shoot( float fireDamage)
        {
            base.Shoot( fireDamage );
            //Add here special logic for the gun if needed
        }
    }
}</pre> <p class="calibre3">Let’s break down the code:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1">SimpleGun</strong>: This class represents a specific type of gun in the game. It inherits from the <strong class="source-inline1">BaseWeapon</strong> class, indicating that it shares characteristics and functionality with other weapons but may have specialized behavior.</li>
<li class="calibre11"><strong class="source-inline1">Override Shoot</strong>:<ul class="calibre16"><li class="calibre11"><strong class="source-inline1">public override void Shoot(float fireDamage)</strong>: This method overrides the <strong class="source-inline1">Shoot</strong> method defined in the <strong class="source-inline1">BaseWeapon</strong> class</li><li class="calibre11">The <strong class="source-inline1">base.Shoot(fireDamage)</strong> statement calls the <strong class="source-inline1">Shoot</strong> method from the base class (<strong class="source-inline1">BaseWeapon</strong>), allowing the gun to perform the standard shooting behavior defined in the base class</li></ul></li>
</ul>
<p class="calibre3">In summary, the <code>SimpleGun</code> class extends the functionality of the <code>BaseWeapon </code>class by providing its own implementation of the <code>Shoot</code> method. This allows for specialized behavior while leveraging the common functionality provided by the base class.</p>
<p class="calibre3">Now, let’s present the <code>PlayerShoot</code> component, which encompasses the shooting logic. In this context, the <a id="_idIndexMarker263" class="calibre6 pcalibre1 pcalibre"/>player awaits input actions and possesses the current weapon. In <a href="B22017_06.xhtml#_idTextAnchor098" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 6</em></a>, which focuses on data handling, we’ll create scriptable objects for weapon statistics. This way, we can substitute the weapon’s power with the weapon’s stats, utilizing the power derived from it. We can also make different stats for the same weapon, as illustrated in the following code block:</p>
<pre class="source-code">
namespace FusionFuryGame {
    public class PlayerShoot : MonoBehaviour
    {
        public static UnityAction onFire = delegate { };
        [SerializeField] BaseWeapon currentWeapon;
        [SerializeField] private float fireDamage;
        [SerializeField] private float shootingInterval = 0.5f;  // Set the shooting interval in seconds
        private float timeSinceLastShot = 0f;
        private void Update()
        {
            timeSinceLastShot += Time.deltaTime;
        }
        private void OnEnable()
        {
            PlayerInput.onShoot += OnShootFire;
        }
        private void OnDisable()
        {
            PlayerInput.onShoot -= OnShootFire;
        }
        private void OnShootFire()
        {
            // Check if enough time has passed since the last shot
            if (timeSinceLastShot &gt;= shootingInterval)
            {
                // Shoot in the forward vector of the weapon and pass player power stat
                currentWeapon.Shoot(fireDamage);
                // Reset the timer
                timeSinceLastShot = 0f;
                // Invoke the onFire event
                onFire.Invoke();
            }
        }
    }
}</pre> <p class="calibre3"> Let’s break down the <a id="_idIndexMarker264" class="calibre6 pcalibre1 pcalibre"/>preceding code:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1">onFire Event</strong>:<ul class="calibre16"><li class="calibre11"><strong class="source-inline1">public static UnityAction onFire = delegate { };</strong>: This static event is triggered whenever the player fires a shot. Other scripts can subscribe to this event to perform actions when the player shoots.</li></ul></li>
<li class="calibre11"><strong class="bold">Serialized fields</strong>:<ul class="calibre16"><li class="calibre11"><strong class="source-inline1">currentWeapon</strong>: This field holds a reference to the current weapon the player is using</li><li class="calibre11"><strong class="source-inline1">fireDamage</strong>: This field represents the damage value of the player’s shots</li><li class="calibre11"><strong class="source-inline1">shootingInterval</strong>: This field specifies the time interval between consecutive shots</li></ul></li>
<li class="calibre11"><strong class="bold">Event subscriptions</strong>:<ul class="calibre16"><li class="calibre11"><strong class="source-inline1">OnEnable()</strong>: Subscribes the <strong class="source-inline1">OnShootFire</strong> method to the <strong class="source-inline1">onShoot</strong> event when the object is enabled</li><li class="calibre11"><strong class="source-inline1">OnDisable()</strong>: Unsubscribes the <strong class="source-inline1">OnShootFire</strong> method from the <strong class="source-inline1">onShoot</strong> event when the object is disabled</li></ul></li>
<li class="calibre11"><strong class="source-inline1">OnShootFire</strong>: This method is invoked when the player performs a shoot action (<strong class="source-inline1">onShoot event</strong>). It checks if enough time has passed since the last shot. If so, it triggers the <strong class="source-inline1">Shoot</strong> method of the current weapon, resets the shot timer, and invokes the <strong class="source-inline1">onFire</strong> event.</li>
</ul>
<p class="calibre3">Overall, the <code>PlayerShoot</code> class facilitates player shooting mechanics by controlling the shooting interval, managing events for shooting actions, and delegating the shooting logic to the current weapon.</p>
<p class="callout-heading">Note</p>
<p class="callout">Make sure that you assign distinct tags to projectiles associated with both the player and the enemies. This prevents conflicts when they collide with each other.</p>
<p class="calibre3">Currently, the <a id="_idIndexMarker265" class="calibre6 pcalibre1 pcalibre"/>player possesses the capability to both shoot and endure damage. In the following subsection, we will delve into the AI logic for our game.</p>
<h2 id="_idParaDest-65" class="calibre7"><a id="_idTextAnchor067" class="calibre6 pcalibre1 pcalibre"/>Delving into the AI logic</h2>
<p class="calibre3">Welcome to the world <a id="_idIndexMarker266" class="calibre6 pcalibre1 pcalibre"/>of <strong class="bold">AI logic</strong>! In this section, we’ll explore the algorithms and decision-making processes that bring intelligence to our game characters. We’ll discover how AI logic enhances navigation, strategy, and dynamic interactions, elevating the overall gaming experience. Join us as we unravel the secrets behind crafting smart behaviors for a more immersive virtual world. Plus, we’ll delve into the implementation of a finite state machine to create distinct states for all enemies, allowing seamless transitions between behaviors.</p>
<p class="calibre3"> In the upcoming steps, we’ll integrate the <code>NavMesh</code> package into our project. However, before delving into AI logic, it’s essential to include the navigation package in the project. Follow these steps to do so:</p>
<p class="callout-heading">Note</p>
<p class="callout">Before Unity 2022, navigation was pre-implemented; however, starting from Unity 2022, it must be added via Package Manager.</p>
<ol class="calibre15">
<li class="calibre11">Access <strong class="bold">Package Manager</strong> to install the <strong class="bold">AI Navigation</strong> package, as shown in <em class="italic">Figure 4</em><em class="italic">.1</em>:</li>
</ol>
<div><div><img alt="Figure 4.1 – Installing AI Navigation via Package Manager" src="img/B22017_04_01.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Installing AI Navigation via Package Manager</p>
<ol class="calibre15">
<li value="2" class="calibre11">Following the <a id="_idIndexMarker267" class="calibre6 pcalibre1 pcalibre"/>installation, you’ll notice a new menu that allows you to toggle the visibility of <strong class="bold">NavMesh</strong> surfaces and access other options concerning <strong class="bold">AI Navigation</strong>. This menu is integrated into the <em class="italic">scene toolbar</em>, as illustrated in <em class="italic">Figure 4</em><em class="italic">.2</em>:</li>
</ol>
<div><div><img alt="Figure 4.2 – The AI Navigation menu in the Scene view" src="img/B22017_04_02.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.2 – The AI Navigation menu in the Scene view</p>
<p class="callout-heading">Additional reading</p>
<p class="callout">You can explore the <strong class="bold">AI Navigation</strong> settings or find more information in the official Unity documentation: <a href="https://docs.unity3d.com/Packages/com.unity.ai.navigation@1.1/manual/index.html" class="calibre6 pcalibre1 pcalibre">https://docs.unity3d.com/Packages/com.unity.ai.navigation@1.1/manual/index.html</a>.</p>
<ol class="calibre15">
<li value="3" class="calibre11">To begin <a id="_idIndexMarker268" class="calibre6 pcalibre1 pcalibre"/>utilizing this feature, we’ll need to incorporate a <strong class="bold">NavMesh Surface</strong> property into the scene. You can choose this from the <strong class="bold">Create</strong> menu, as shown in <em class="italic">Figure 4</em><em class="italic">.3</em>:</li>
</ol>
<div><div><img alt="Figure 4.3 – Choosing NavMesh Surface from the Create menu" src="img/B22017_04_03.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Choosing NavMesh Surface from the Create menu</p>
<ol class="calibre15">
<li value="4" class="calibre11">Subsequently, <strong class="bold">NavMesh Surface</strong> will be included, at which point you can proceed to <strong class="bold">Bake</strong> the surface. This refers to the process of precomputing and storing navigation <a id="_idIndexMarker269" class="calibre6 pcalibre1 pcalibre"/>data for AI pathfinding, as demonstrated in <em class="italic">Figure 4</em><em class="italic">.4</em>:</li>
</ol>
<div><div><img alt="Figure 4.4 – The Bake action in the NavMeshSurface component" src="img/B22017_04_04.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.4 – The Bake action in the NavMeshSurface component</p>
<p class="callout-heading">Note</p>
<p class="callout">Before initiating the baking process, it’s crucial to remove the player and dynamic objects to prevent the creation of empty spaces in the resulting baking.</p>
<ol class="calibre15">
<li value="5" class="calibre11">You can also include additional AI agents by navigating to the <strong class="bold">Navigation</strong> tab under <strong class="bold">Window</strong> in the top bar. Choose <strong class="bold">AI</strong> and then <strong class="bold">Navigation</strong>, avoiding the <strong class="bold">Navigation (Obsolete)</strong> option, as illustrated in <em class="italic">Figure 4</em><em class="italic">.5</em>:</li>
</ol>
<div><div><img alt="Figure 4.5 – Selecting Navigation" src="img/B22017_04_05.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Selecting Navigation</p>
<ol class="calibre15">
<li value="6" class="calibre11">In the <strong class="bold">Navigation</strong> tab, you <a id="_idIndexMarker270" class="calibre6 pcalibre1 pcalibre"/>have the option to include more <strong class="bold">Agents</strong> with various settings, allowing for increased diversity in enemy behavior, as depicted in <em class="italic">Figure 4</em><em class="italic">.6</em>:</li>
</ol>
<div><div><img alt="Figure 4.6 – Adding more agents via the Navigation tab" src="img/B22017_04_06.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.6 – Adding more agents via the Navigation tab</p>
<ol class="calibre15">
<li value="7" class="calibre11">Additionally, you <a id="_idIndexMarker271" class="calibre6 pcalibre1 pcalibre"/>have the flexibility to introduce more <strong class="bold">Areas</strong>, providing variations in your gameplay. As shown in the following screenshot, you can designate areas as <strong class="bold">Walkable</strong>, <strong class="bold">Not Walkable</strong>, or even as <strong class="bold">Jump</strong> areas, tailoring them to the specific requirements of your game:</li>
</ol>
<div><div><img alt="Figure 4.7 – Areas in the Navigation tab" src="img/B22017_04_07.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.7 – Areas in the Navigation tab</p>
<ol class="calibre15">
<li value="8" class="calibre11">Now that we’ve familiarized ourselves with adding additional areas or agents, we won’t be <a id="_idIndexMarker272" class="calibre6 pcalibre1 pcalibre"/>making further modifications to them. I’ve mentioned them for informational purposes only. Now, let’s proceed with integrating AI into our game. To do so, we must attach the <strong class="bold">Nav Mesh Agent</strong> component to the enemies to enable navigation, as illustrated in <em class="italic">Figure 4</em><em class="italic">.8</em>. We have the flexibility to adjust values tailored to our game, such as changing the speed and when the AI will stop when the AI has reached its goal. For further details, please refer to the official <em class="italic">Unity documentation</em>:</li>
</ol>
<div><div><img alt="Figure 4.8 – The Nav Mesh Agent component for one of the enemies" src="img/B22017_04_08.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.8 – The Nav Mesh Agent component for one of the enemies</p>
<p class="calibre3">After installing the package, we’ll kick off the AI logic. We’ll begin by establishing the <code>BaseEnemy</code> class and <a id="_idIndexMarker273" class="calibre6 pcalibre1 pcalibre"/>laying down the foundation for the state system since we intend to construct a finite state machine.</p>
<p class="calibre3">Let’s start with the interface for states. The foundational structure is provided in the following code block:</p>
<pre class="source-code">
namespace FusionFuryGame
{
    public interface IEnemyState
    {
        void EnterState(BaseEnemy enemy);
        void UpdateState(BaseEnemy enemy);
        void ExitState(BaseEnemy enemy);
    }
}</pre> <p class="calibre3">Let’s take a closer look at this code:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1">void </strong><strong class="source-inline1">EnterState(BaseEnemy enemy)</strong>:<ul class="calibre16"><li class="calibre11">This method is responsible for setting up the initial conditions and behaviors when the enemy enters this state. It takes a <strong class="source-inline1">BaseEnemy</strong> object as a parameter, allowing us to access the enemy’s properties and methods.</li></ul></li>
<li class="calibre11"><strong class="source-inline1">void </strong><strong class="source-inline1">UpdateState(BaseEnemy enemy)</strong>:<ul class="calibre16"><li class="calibre11">This method is called repeatedly while the enemy is in this state. It defines the logic and actions that the enemy should perform during this state. Again, it takes a <strong class="source-inline1">BaseEnemy</strong> object as a parameter to manipulate the enemy’s behavior.</li></ul></li>
<li class="calibre11"><strong class="source-inline1">void </strong><strong class="source-inline1">ExitState(BaseEnemy enemy)</strong>:<ul class="calibre16"><li class="calibre11">This method is called when the enemy exits this state. It is responsible for cleaning up any resources or resetting any variables associated with this state. As with the other methods, it also accepts a <strong class="source-inline1">BaseEnemy</strong> object parameter.</li></ul></li>
</ul>
<p class="calibre3">By implementing<a id="_idIndexMarker274" class="calibre6 pcalibre1 pcalibre"/> this interface, different classes representing specific enemy states can define their unique behavior for entering, updating, and exiting those states. This approach allows for modular and organized management of enemy behavior, making it easier to add, remove, or modify states as needed within the game.</p>
<p class="calibre3">Let’s move on to creating enemy components, starting with: <code>EnemyHealth</code>. This component will integrate the <code>IHealth</code> interface and handle all health-related logic for enemies. Check out the following code block:</p>
<pre class="source-code">
    public class EnemyHealth : MonoBehaviour, IHealth
    {
        [SerializeField] float startingMaxHealth = 100;  // Set a default starting maximum health for the Enemy
        private float maxHealth;
        private float currentHealth;
        [SerializeField] float healAmount = 5f;    // Amount of healing per interval
        [SerializeField] float healInterval = 2f;  // Time interval for healing
        private WaitForSeconds healIntervalWait;  // Reusable WaitForSeconds instance
        private Coroutine healOverTimeCoroutine;
        public UnityAction onEnemyDied = delegate { };
        public float MaxHealth
        {
            get { return maxHealth; }
            set { maxHealth = value; }
        }
        public float CurrentHealth
        {
            get { return currentHealth; }
            set
            {
                currentHealth = Mathf.Clamp(value, 0, MaxHealth);
                if (currentHealth &lt;= 0)
                {
                    onEnemyDied.Invoke();
                }
            }
        }
        private void Start()
        {
            SetMaxHealth();  // Set initial max health
            healIntervalWait = new WaitForSeconds(healInterval);
            StartHealingOverTime();
        }
        public void SetMaxHealth()
        {
            MaxHealth = startingMaxHealth;
        }
        public void TakeDamage(float damage)
        {
            // Implement logic to handle taking damage
            CurrentHealth -= damage;
        }
        //we can also just heal in some states only
        public void Heal()
        {
            CurrentHealth += healAmount;
            CurrentHealth = Mathf.Min(CurrentHealth, MaxHealth);
        }
        private void StartHealingOverTime()
        {
            healOverTimeCoroutine = StartCoroutine(HealOverTime());
        }
        private IEnumerator HealOverTime()
        {
            while (true)
            {
                yield return healIntervalWait;
                Heal();
            }
        }
    }</pre> <p class="calibre3">Let’s understand <a id="_idIndexMarker275" class="calibre6 pcalibre1 pcalibre"/>the <code>EnemyHealth</code> component:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1">startingMaxHealth</strong>: Default starting maximum health for the enemy.</li>
<li class="calibre11"><strong class="source-inline1">healAmount</strong>: Amount of healing per interval</li>
<li class="calibre11"><strong class="source-inline1">healInterval</strong>: Time interval for healing</li>
<li class="calibre11"><strong class="source-inline1">healIntervalWait</strong>: Reusable <strong class="source-inline1">WaitForSeconds</strong> instance for healing</li>
<li class="calibre11"><strong class="source-inline1">healOverTimeCoroutine</strong>: Coroutine for healing over time</li>
<li class="calibre11"><strong class="source-inline1">maxHealth</strong>: Maximum health of the enemy</li>
<li class="calibre11"><strong class="source-inline1">currentHealth</strong>: Current health of the enemy</li>
<li class="calibre11"><strong class="source-inline1">TakeDamage(float damage)</strong>: Handles damage taken by the enemy</li>
<li class="calibre11"><strong class="source-inline1">SetMaxHealth()</strong>: Sets the maximum health of the enemy</li>
<li class="calibre11"><strong class="source-inline1">Heal()</strong>: Heals the enemy over time</li>
<li class="calibre11"><strong class="source-inline1">StartHealingOverTime()</strong>: Starts the coroutine for healing over time</li>
<li class="calibre11"><strong class="source-inline1">HealOverTime()</strong>: The coroutine method for healing over time</li>
</ul>
<p class="calibre3">Next up is <a id="_idIndexMarker276" class="calibre6 pcalibre1 pcalibre"/>the <code>EnemyAnimations</code> component, which is responsible for managing the animations of the enemy. Let’s delve into its code block:</p>
<pre class="source-code">
  public class EnemyAnimations : MonoBehaviour
  {
      private Animator animator;
      private void Start()
      {
          animator = GetComponent&lt;Animator&gt;();
      }
      public void StartAttackAnimations()
      {
          animator.SetBool("IsAttacking", true);
      }
      public void StopAttackAnimations()
      {
          animator.SetBool("IsAttacking", false);
      }
  }</pre> <p class="calibre3">Here, <code>StartAttackAnimations()</code> and <code>StopAttackAnimations()</code> manage attack animations.</p>
<p class="calibre3">Next, we’ll implement<a id="_idIndexMarker277" class="calibre6 pcalibre1 pcalibre"/> the collision logic for the enemy in the <code>EnemyCollision</code> class. This class will handle collisions with the player, allowing the enemy to take damage. Look at the following code block for details:</p>
<pre class="source-code">
    public class EnemyCollision : MonoBehaviour
    {
        private IDamage playerDamage;
        private EnemyHealth healthComponent;
        private void Start()
        {
            healthComponent = GetComponent&lt;EnemyHealth&gt;();
        }
        //we can also make layers for them and reduce calculations of collision in layer matrix in project settings
        private void OnCollisionEnter(Collision collision)
        {
            if (collision.gameObject.CompareTag("PlayerProjectile"))
            {
                if (collision.gameObject.TryGetComponent(out playerDamage))
                {
                    healthComponent.TakeDamage(playerDamage.GetDamageValue());
                }
            }
        }
    }</pre> <p class="calibre3"> Let’s look at <a id="_idIndexMarker278" class="calibre6 pcalibre1 pcalibre"/>what the <code>EnemyCollision</code> class does:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1">playerDamage</strong>: Represents the damage that’s inflicted by the player</li>
<li class="calibre11"><strong class="source-inline1">damage</strong>: Damage inflicted when the enemy collides with the player</li>
<li class="calibre11"><strong class="source-inline1">OnCollisionEnter(Collision collision)</strong>: Handles collisions with player projectiles</li>
</ul>
<p class="calibre3">The final component in the enemy’s logic is <code>EnemyShoot</code>. It’s responsible for firing projectiles using the attached weapon. Implement the <code>IDamage</code> interface here so that it will pass the damage value to the player. Refer to the following code block for details:</p>
<pre class="source-code">
    public class EnemyShoot : MonoBehaviour , IDamage
    {
        [SerializeField] float damage; //when the enemy collide with the player
        public BaseWeapon attachedWeapon;  // Reference to the attacted Weapon
        [SerializeField] float fireDamage; //when the enemy shoot the player
        public void FireProjectile()
        {
            attachedWeapon.Shoot(fireDamage);
        }
        public float GetDamageValue()
        {
            // You can implement more sophisticated logic here based on enemy stats
            return damage;
        }
    }</pre> <p class="calibre3">Let’s look at <a id="_idIndexMarker279" class="calibre6 pcalibre1 pcalibre"/>what <code>EnemyShoot</code> does:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1">fireDamage</strong>: Damage inflicted when the enemy shoots the player</li>
<li class="calibre11"><strong class="source-inline1">attachedWeapon</strong>: Reference to the attached weapon of the enemy</li>
<li class="calibre11"><strong class="source-inline1">FireProjectile()</strong>: Initiates the firing of the attached weapon</li>
<li class="calibre11"><strong class="source-inline1">GetDamageValue()</strong>: Retrieves the damage value</li>
</ul>
<p class="calibre3">Now, let’s create the <code>BaseEnemy</code> class is an abstract class that defines the basic functionality and attributes of an enemy in a game. It will utilize state machine logic and contain references for the shooting and animation components of the enemies. This class facilitates communication between different states of the enemy, making it suitable for use with all enemies:</p>
<pre class="source-code">
[RequireComponent(typeof(EnemyHealth) , typeof(EnemyAnimations) , typeof(EnemyShoot)) ]
    [RequireComponent(typeof(EnemyCollision))]
    public abstract class BaseEnemy : MonoBehaviour
    {
        public Transform player;
        [HideInInspector] public NavMeshAgent navMeshAgent;
        // Reference to the current state
        protected IEnemyState currentState;
        // Define the different states
        public IEnemyState wanderState;
        public IEnemyState idleState;
        public IEnemyState attackState;
        public IEnemyState deathState;
        public IEnemyState chaseState;
        public float attackRange = 5f;
        [SerializeField] internal float chaseSpeed;
        [SerializeField] internal float rotationSpeed;
        internal EnemyAnimations animationComponent;
        internal EnemyShoot shootComponent;
        internal EnemyHealth healthComponent;
        protected virtual void Start()
        {
            // Initialize states
            wanderState = new WanderState();
            idleState = new IdleState();
            attackState = new AttackState();
            chaseState = new ChaseState();
            deathState = new DeathState();
            // Set initial state
            currentState = wanderState;
            // Get references
            player = GameObject.FindGameObjectWithTag("Player").transform;
            navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();
            animationComponent = GetComponent&lt;EnemyAnimations&gt;();
            shootComponent = GetComponent&lt;EnemyShoot&gt;();
            healthComponent = GetComponent&lt;EnemyHealth&gt;();
            healthComponent.onEnemyDied += OnDied;
        }
        protected virtual void Update()
        {
            // Update the current state
            currentState.UpdateState(this);
        }</pre> <p class="calibre3">Let’s take a closer look <a id="_idIndexMarker280" class="calibre6 pcalibre1 pcalibre"/>at this code so that we understand it:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1">player</strong>: Reference to the player’s <strong class="source-inline1">Transform</strong> value</li>
<li class="calibre11"><strong class="source-inline1">navMeshAgent</strong>: Reference to the <strong class="source-inline1">NavMeshAgent</strong> component for navigation</li>
<li class="calibre11"><strong class="source-inline1">currentState</strong>: Reference to the current state of the enemy</li>
<li class="calibre11"><strong class="source-inline1">wanderState</strong>, <strong class="source-inline1">idleState</strong>, <strong class="source-inline1">attackState</strong>, <strong class="source-inline1">deathState</strong>, <strong class="source-inline1">chaseState</strong>: Different states of the enemy (wandering, idle, attacking, dead, and chasing, respectively)</li>
<li class="calibre11"><strong class="source-inline1">attackRange</strong>: The range within which the enemy can attack</li>
<li class="calibre11"><strong class="source-inline1">chaseSpeed</strong>: The speed at which the enemy chases the player</li>
<li class="calibre11"><strong class="source-inline1">rotationSpeed</strong>: The speed of rotation for the enemy</li>
<li class="calibre11"><strong class="source-inline1">Start()Method</strong>: Initializes states, sets the initial state, and gets references</li>
<li class="calibre11"><strong class="source-inline1">Update()Method</strong>: Updates the current state of the enemy</li>
</ul>
<p class="calibre3">Now, let’s delve into the <a id="_idIndexMarker281" class="calibre6 pcalibre1 pcalibre"/>state machine logic that’s responsible for transitioning between states:</p>
<pre class="source-code">
        public bool PlayerInSight()
        {
            Vector3 directionToPlayer = player.position - transform.position;
            float distanceToPlayer = directionToPlayer.magnitude;
            // Create a ray from the enemy's position towards the player
            Ray ray = new Ray(transform.position, directionToPlayer.normalized);
            RaycastHit hit;
            // Check if the ray hits something
            if (Physics.Raycast(ray, out hit, distanceToPlayer))
            {
                // Check if the hit object is the player
                if (hit.collider.CompareTag("Player"))
                {
                    // The player is in sight
                    return true;
                }
            }
            // No direct line of sight to the player
            return false;
        }
        public bool PlayerInRange()
        {
            Vector3 directionToPlayer = player.position - transform.position;
            float distanceToPlayer = directionToPlayer.magnitude;
            // Check if the player is within the attack range
            if (distanceToPlayer &lt;= attackRange)
            {
                // Calculate the angle between the enemy's forward direction and the direction to the player
                float angleToPlayer = Vector3.Angle(transform.forward, directionToPlayer.normalized);
                // Set a cone angle to define the attack range
                float attackConeAngle = 45f; // Adjust this value based on your game's requirements
                // Check if the player is within the cone angle
                if (angleToPlayer &lt;= attackConeAngle * 0.5f)
                {
                    // The player is in range and within the attack cone
                    return true;
                }
            }
            // Player is not within attack range or cone angle
            return false;
        }
        public bool IsIdleConditionMet()
        {
            return !PlayerInSight() &amp;&amp; !PlayerInRange();
        }
        public void TransitionToState(IEnemyState newState)
        {
            currentState?.ExitState(this);
            currentState = newState;
            currentState?.EnterState(this);
        }
           private void OnDied()
        {
            healthComponent.onEnemyDied -= OnDied;
            // Trigger death logic if health reaches zero
            TransitionToState(deathState);
        }
    }</pre> <p class="calibre3">To understand this <a id="_idIndexMarker282" class="calibre6 pcalibre1 pcalibre"/>code, let’s examine its functions:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1">PlayerInSight()</strong> and <strong class="source-inline1">PlayerInRange()</strong>: These functions check if the player is in sight or range, respectively</li>
<li class="calibre11"><strong class="source-inline1">IsIdleConditionMet()</strong>: Checks if the conditions for idling have been met</li>
<li class="calibre11"><strong class="source-inline1">TransitionToState()</strong>: Transitions to a new state</li>
<li class="calibre11"><strong class="source-inline1">OnDied()Method</strong>: Transitions to the death state</li>
</ul>
<p class="calibre3">Now, let’s move on to the states. First, we’ll implement <code>IEnemyStates</code> so that we can include the base methods. Then, in the subsequent code block, we’ll develop the logic for <code>IdleState</code>, detailing the actions the enemy will take in this state. <code>IdleState</code> is the default state for all enemies. Here, we simply check for the conditions of other states so that we can transition to them when their respective logic is met:</p>
<pre class="source-code">
   public class IdleState : IEnemyState
    {
        private float idleTime = 3f; // Set the duration for which the enemy stays idle
        private float timer; // Timer to track the idle time
        public void EnterState(BaseEnemy enemy)
        {
            timer = 0f;
        }
        public void ExitState(BaseEnemy enemy)
        {
            //Logic for Exit
        }
        public void UpdateState(BaseEnemy enemy)
        {
            // Logic to be executed while in the idle state
            timer += Time.deltaTime;
            if (timer &gt;= idleTime)
            {
                enemy.TransitionToState(enemy.wanderState);
            }
            else if (enemy.PlayerInSight())
            {
                enemy.TransitionToState(enemy.chaseState);
            }
            else if (enemy.PlayerInRange())
            {
                enemy.TransitionToState(enemy.attackState);
            }
        }
    }</pre> <p class="calibre3">Let’s take a closer<a id="_idIndexMarker283" class="calibre6 pcalibre1 pcalibre"/> look at the preceding code:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Variables</strong>:<ul class="calibre16"><li class="calibre11"><strong class="source-inline1">idleTime</strong>: This variable determines the duration for which the enemy remains idle</li><li class="calibre11"><strong class="source-inline1">timer</strong>: This variable tracks the elapsed time while the enemy is in the idle state</li></ul></li>
<li class="calibre11"><strong class="bold">Methods</strong>:<ul class="calibre16"><li class="calibre11"><strong class="source-inline1">EnterState(BaseEnemy enemy)</strong>: This method is called when the enemy enters the idle state. Here, it initializes the timer.</li><li class="calibre11"><strong class="source-inline1">ExitState(BaseEnemy enemy)</strong>: This method is called when the enemy exits the idle state. Currently, it’s empty, but you can add logic here if needed.</li><li class="calibre11"><strong class="source-inline1">UpdateState(BaseEnemy enemy)</strong>: This method is called every frame to update the state of the enemy. Here’s what happens:<ul class="calibre16"><li class="calibre11">The timer is incremented by the time elapsed since the last frame</li><li class="calibre11">If the idle time exceeds the specified duration (<strong class="source-inline1">idleTime</strong>), the enemy transitions to the wander state, indicating it’s ready to move around</li><li class="calibre11">If the enemy detects the player within its line of sight (<strong class="source-inline1">PlayerInSight()</strong>), it transitions to the chase state to pursue the player</li><li class="calibre11">If the player is within the attack range (<strong class="source-inline1">PlayerInRange()</strong>), the enemy transitions to the attack state to engage the player</li></ul></li></ul></li>
</ul>
<p class="calibre3">This code ensures <a id="_idIndexMarker284" class="calibre6 pcalibre1 pcalibre"/>that the enemy behaves as expected while in the idle state, transitioning to other states based on specific conditions, such as time elapsed and player proximity.</p>
<p class="calibre3">In the following class, <code>AttackState</code>, we also implement <code>IEnemyState</code> so that we can modify the base methods so that they fit the attack state. The attack state is the state that all enemies will enter when they are attacking the player. It includes logic for tracking the player’s position and firing projectiles toward the player, along with handling associated animations:</p>
<pre class="source-code">
    public class AttackState : IEnemyState
    {
        private float attackTimer;  // Timer to control the attack rate
        private float timeBetweenAttacks = 1.5f;  // Adjust as needed based on your game's requirements
        public void EnterState(BaseEnemy enemy)
        {
            enemy.animationsComponent.StartAttackAnimations();
            attackTimer = 0f;
        }
        public void UpdateState(BaseEnemy enemy)
        {
            LookAtPlayer(enemy);
            attackTimer += Time.deltaTime;
            if (attackTimer &gt;= timeBetweenAttacks)
            {
                AttackPlayer(enemy);
                attackTimer = 0f;  // Reset the timer after attacking
            }
        }
        public void ExitState(BaseEnemy enemy)
        {
            enemy.animationsComponent.StopAttackAnimations();
        }
        private void LookAtPlayer(BaseEnemy enemy)
        {
            Vector3 lookDirection = enemy.player.position - enemy.transform.position;
            lookDirection.y = 0;  // Keep the enemy's rotation in the horizontal plane
            Quaternion rotation = Quaternion.LookRotation(lookDirection);
            enemy.transform.rotation = Quaternion.Slerp(enemy.transform.rotation, rotation, Time.deltaTime * enemy.rotationSpeed);
        }
        private void AttackPlayer(BaseEnemy enemy)
        {
            enemy.shootComponent.FireProjectile();
        }
    }</pre> <p class="calibre3">Here’s an explanation <a id="_idIndexMarker285" class="calibre6 pcalibre1 pcalibre"/>for this code:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Methods</strong>:<ul class="calibre16"><li class="calibre11"><strong class="source-inline1">EnterState</strong>: Initializes the attack state, starts attack animations, and resets the attack timer.</li><li class="calibre11"><strong class="source-inline1">UpdateState</strong>: Checks if it’s time to attack based on the time between attacks. It ensures that the enemy is facing the player and initiates the attack if conditions are met.</li><li class="calibre11"><strong class="source-inline1">ExitState</strong>: Stops attack animations when exiting the state.</li><li class="calibre11"><strong class="source-inline1">LookAtPlayer</strong>: Calculates the direction to look at the player and smoothly rotates the enemy toward the player.</li><li class="calibre11"><strong class="source-inline1">AttackPlayer</strong>: Causes the enemy to perform an attack action, such as firing a projectile.</li></ul></li>
</ul>
<p class="calibre3">With that, you’ve learned how to create states, enabling you to effortlessly add more states so that you can tailor your game.</p>
<p class="calibre3">Now that we’ve established the interaction loop between the enemy and the player, allowing them to shoot<a id="_idIndexMarker286" class="calibre6 pcalibre1 pcalibre"/> at each other, the next step involves creating a prefab for each enemy – for instance, implementing the <code>ShooterEnemy</code> base class and adding this component to the respective <code>GameObject</code>, turning it into a prefab. Similarly, for projectiles, remember that it’s essential to modify tags based on whether they’re for the player or the enemy.</p>
<h1 id="_idParaDest-66" class="calibre5"><a id="_idTextAnchor068" class="calibre6 pcalibre1 pcalibre"/>Implementing challenge and reward systems using C#</h1>
<p class="calibre3">Challenges breathe life <a id="_idIndexMarker287" class="calibre6 pcalibre1 pcalibre"/>into the gaming experience, pulsating with excitement and unpredictability, guiding players through pivotal moments that require skill, strategy, and determination. These obstacles ensure players stay fully immersed in the gaming world, crafting a dynamic landscape that turns each gaming session into an adventure, complete with unexpected twists and turns.</p>
<p class="calibre3">In games such as <em class="italic">Dark Souls</em>, challenges manifest in the form of formidable enemies and intricate level designs. Players are tested on their combat skills and adaptability, creating an intense and rewarding experience. <em class="italic">Super Mario Bros.</em> introduces challenges through precise platforming, timing, and defeating enemies. Each level presents a new set of challenges, gradually increasing in complexity.</p>
<h2 id="_idParaDest-67" class="calibre7"><a id="_idTextAnchor069" class="calibre6 pcalibre1 pcalibre"/>Challenges versus missions/quests</h2>
<p class="calibre3">While <a id="_idIndexMarker288" class="calibre6 pcalibre1 pcalibre"/>challenges, missions, and quests share common ground in engaging players, they differ in their nature. <strong class="bold">Challenges</strong> often refer to specific obstacles or tasks that test a player’s abilities, such as completing a level within a time limit or defeating a powerful adversary. <strong class="bold">Missions and quests</strong>, on the other hand, are broader objectives that contribute to the game’s narrative and involve a series of tasks that may include challenges. The distinction lies in the focused, skill-testing nature of challenges, making them pivotal components of dynamic gameplay.</p>
<p class="calibre3">In <em class="italic">The Legend of Zelda: Breath of the Wild</em>, a challenge might involve solving a complex puzzle shrine and testing the player’s problem-solving skills. In contrast, a mission could be part of the game’s overarching narrative, such as rescuing a character or retrieving a special item. Challenges offer immediate, skill-based hurdles, while missions contribute to the overall progression and storytelling.</p>
<h2 id="_idParaDest-68" class="calibre7"><a id="_idTextAnchor070" class="calibre6 pcalibre1 pcalibre"/>Balancing difficulty levels for broad appeal</h2>
<p class="calibre3">Achieving a <a id="_idIndexMarker289" class="calibre6 pcalibre1 pcalibre"/>harmonious difficulty curve is essential to cater to players of varying skill levels. Balancing challenges ensures that both novice and experienced players find engagement without encountering excessive frustration. Games such as <em class="italic">Celeste</em> masterfully balance difficulty, starting with simple challenges and gradually introducing more complex ones, allowing players to grow alongside the game’s intricacies.</p>
<p class="calibre3">Successful games often employ techniques <a id="_idIndexMarker290" class="calibre6 pcalibre1 pcalibre"/>such as <strong class="bold">adaptive difficulty scaling</strong> or optional challenges to accommodate diverse player skill levels. This careful balance prevents discouragement for newcomers while providing a satisfying experience for seasoned players seeking greater challenges.</p>
<h2 id="_idParaDest-69" class="calibre7"><a id="_idTextAnchor071" class="calibre6 pcalibre1 pcalibre"/>Exploring reward systems</h2>
<p class="calibre3"><strong class="bold">Reward systems</strong> in<a id="_idIndexMarker291" class="calibre6 pcalibre1 pcalibre"/> gaming are like treasured prizes waiting for triumphant players after they’ve overcome tough challenges. These systems are closely linked to the<a id="_idIndexMarker292" class="calibre6 pcalibre1 pcalibre"/> challenge dynamics, acting as the driving force that propels players forward. Rewards come in various forms – power-ups, upgrades, or in-game currency, along with narrative progress and cosmetic items, each with its unique appeal.</p>
<p class="calibre3">In games such as <em class="italic">The Legend of Zelda</em>, conquering tricky dungeons or defeating tough bosses often rewards players with new tools or abilities to progress in the story. In RPGs such as <em class="italic">The Witcher 3</em>, completing side quests not only gives experience points and in-game money but also unlocks new storylines or equipment. The connection between challenges and rewards ensures that overcoming obstacles not only tests the player’s skills but also promises valuable incentives, boosting player engagement and satisfaction.</p>
<p class="calibre3">Successfully blending rewards into the gameplay loop ensures that challenges aren’t just hurdles but opportunities for growth. This fosters a sense of accomplishment and progression. Players are motivated to take on tougher challenges for the promise of more significant rewards, creating a satisfying gaming experience. The seamless integration of rewards makes the gaming journey fulfilling and enjoyable.</p>
<h2 id="_idParaDest-70" class="calibre7"><a id="_idTextAnchor072" class="calibre6 pcalibre1 pcalibre"/>C# implementation of challenges and rewards</h2>
<p class="calibre3">Moving from<a id="_idIndexMarker293" class="calibre6 pcalibre1 pcalibre"/> theory to practice, our C# implementation <a id="_idIndexMarker294" class="calibre6 pcalibre1 pcalibre"/>of challenges and rewards brings coding insights to life. With illustrative code snippets, you’ll gain hands-on experience, bringing challenges to life and rewarding players meaningfully. We’ll discuss the delicate balance that’s needed to keep players engaged and motivated, understanding how challenge difficulty correlates with the magnitude of rewards.</p>
<h3 class="calibre9">Introducing the challenge logic</h3>
<p class="calibre3">Let’s begin by <a id="_idIndexMarker295" class="calibre6 pcalibre1 pcalibre"/>establishing the foundational data structure for challenges. This can be seen in the following class. Every challenge will share this common set of data, simplifying runtime tracking and allowing prizes to be assigned:</p>
<pre class="source-code">
[Serializable]
 public class CommonChallengeData
 {
     public bool isCompleted;
     public RewardType rewardType; // Type of reward
     public int rewardAmount;      // Amount or value of the reward
     … other challenge Data
 }</pre> <p class="calibre3">Let’s proceed to the <code>BaseChallenge</code> class, which features the logic for starting and completing challenges. Refer to the following code block for details. All challenges will derive from this script, customizing their logic within its methods:</p>
<pre class="source-code">
public abstract class BaseChallenge : MonoBehaviour
 {
     public CommonChallengeData commonData;
     public abstract void StartChallenge();
     public abstract void CompleteChallenge();
 }</pre> <p class="calibre3">Let’s take a<a id="_idIndexMarker296" class="calibre6 pcalibre1 pcalibre"/> closer look:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1">public CommonChallengeData commonData</strong>: This is a public variable of the <strong class="source-inline1">CommonChallengeData</strong> type. It holds data that might be common across various types of challenges. It allows derived classes to access and modify shared challenge data.</li>
<li class="calibre11"><strong class="source-inline1">public abstract void StartChallenge()</strong>: This is an abstract method declaration without any implementation. It specifies that any class inheriting from <strong class="source-inline1">BaseChallenge</strong> must provide its own implementation for the <strong class="source-inline1">StartChallenge</strong> method. This method likely contains logic to initialize or begin the challenge.</li>
<li class="calibre11"><strong class="source-inline1">public abstract void CompleteChallenge()</strong>: Similar to <strong class="source-inline1">StartChallenge()</strong>, this is another abstract method that any derived class must implement. It is responsible for handling the completion of the challenge, which may involve updating the UI, awarding rewards, or triggering other game events.</li>
</ul>
<p class="calibre3">In summary, <code>BaseChallenge</code> serves as a template for creating different types of challenges in a game. It defines common functionality that all challenges should have, such as starting and completing the challenge, while allowing specific implementations to vary based on the type of challenge.</p>
<p class="calibre3">Let’s transition to <code>ChallengeManager</code>, a central entity that houses all challenges and takes on the responsibility of initiating challenges. Currently, it includes a dictionary for storing all challenge components by their respective types, encompassing all challenge types. It also features a method to commence challenges, which will be invoked by <code>LevelManager</code>.</p>
<p class="calibre3">Consequently, each level can have a designated challenge, and the manager maintains a reference to the <a id="_idIndexMarker297" class="calibre6 pcalibre1 pcalibre"/>current challenge. All of these functionalities are detailed in the following code script:</p>
<pre class="source-code">
    public class ChallengeManager : Singleton&lt;ChallengeManager&gt;
    {
        // Define different types of challenges
        public enum ChallengeType
        {
            EnemyWaves,
            TimeTrials,
            LimitedResources,
            NoDamageRun,
            AccuracyChallenge
        }
        public GenericDictionary&lt;ChallengeType, BaseChallenge&gt; challengeDictionary = new GenericDictionary&lt;ChallengeType, BaseChallenge&gt;();
        public void StartChallenge(ChallengeType challengeType)
        {
            if (challengeDictionary.TryGetValue(challengeType, out BaseChallenge challengeScript))
            {
                if (!challengeScript.commonData.isCompleted)
                {
                    SetCurrentChallenge(challengeScript);
                    currentChallenge.StartChallenge();
                }
                else
                {
                    Debug.Log("Challenge already completed!");
                }
            }
            else
            {
                Debug.LogError($"No challenge script found for ChallengeType {challengeType}");
            }
        }
        private BaseChallenge currentChallenge;
        private void SetCurrentChallenge(BaseChallenge challengeScript)
        {
            if (currentChallenge != null)
            {
                currentChallenge.CompleteChallenge();
            }
            currentChallenge = challengeScript;
        }
    }</pre> <p class="calibre3">Here’s an<a id="_idIndexMarker298" class="calibre6 pcalibre1 pcalibre"/> explanation of the <code>ChallengeManager</code> class:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1">public enum ChallengeType</strong>: This is an enumeration that defines different types of challenges available in the game. Each challenge type represents a specific kind of gameplay challenge, such as <strong class="source-inline1">EnemyWaves</strong>, <strong class="source-inline1">TimeTrials</strong>, <strong class="source-inline1">LimitedResources</strong>, <strong class="source-inline1">NoDamageRun</strong>, and <strong class="source-inline1">AccuracyChallenge</strong>.</li>
<li class="calibre11"><strong class="source-inline1">public GenericDictionary&lt;ChallengeType</strong>, <strong class="source-inline1">BaseChallenge&gt; challengeDictionary</strong>: This is a generic dictionary that maps <strong class="source-inline1">ChallengeType</strong> enum values to corresponding <strong class="source-inline1">BaseChallenge</strong> objects. It stores instances of different challenge scripts associated with their respective challenge types.</li>
<li class="calibre11"><strong class="source-inline1">public void StartChallenge(ChallengeType challengeType)</strong>: This method is responsible for starting a challenge of the specified type. It retrieves the corresponding challenge script from the dictionary based on the provided challenge type and then calls the <strong class="source-inline1">StartChallenge()</strong> method of the retrieved script.</li>
<li class="calibre11"><strong class="source-inline1">private BaseChallenge currentChallenge</strong>: This private field holds a reference to the currently active challenge. It is used to track and manage the state of the current challenge being played.</li>
<li class="calibre11"><strong class="source-inline1">private void </strong><strong class="source-inline1">SetCurrentChallenge(BaseChallenge challenge</strong><strong class="source-inline1">
Script)</strong>: This method sets the current challenge to the one provided as an argument. Before setting the new challenge, it ensures that any existing challenge is completed by calling its <strong class="source-inline1">CompleteChallenge()</strong> method.</li>
</ul>
<p class="calibre3">In summary, the <code>ChallengeManager</code> class facilitates the management and execution of different types <a id="_idIndexMarker299" class="calibre6 pcalibre1 pcalibre"/>of challenges in the game. It provides methods to start challenges, handle the completion of challenges, and track the current active challenge. The use of a singleton pattern ensures centralized control over challenge management operations.</p>
<p class="calibre3">Now, let’s shift our focus to the individual challenges. The following code block contains an example that implements the <code>BaseChallenge</code> class, integrating custom logic specific to the <code>Enemy Waves</code> challenge. When the challenge starts, enemies are spawned near the player. Additionally, it includes logic to reward the player upon completing the challenge. This is facilitated by the <code>RewardManager</code> class:</p>
<pre class="source-code">
    public class EnemyWavesChallenge : BaseChallenge
    {
        public int totalWaves = 5;  // Adjust as needed
        private int currentWave = 0;
        public override void StartChallenge()
        {
            if (!commonData.isCompleted)
            {
                StartCoroutine(StartEnemyWavesChallenge());
            }
            else
            {
                Debug.Log("Challenge already completed!");
            }
        }
        IEnumerator StartEnemyWavesChallenge()
        {
            while (currentWave &lt; totalWaves)
            {
                yield return StartCoroutine(SpawnEnemyWave());
                currentWave++;
            }
            CompleteChallenge();
        }
        public override void CompleteChallenge()
        {
            if (!commonData.isCompleted)
            {
                RewardManager.Instance.GrantReward(commonData);
                commonData.isCompleted = true;
            }
            else
            {
                Debug.Log("Challenge already completed!");
            }
        }
        IEnumerator SpawnEnemyWave()
        {
            // Adjust spawn positions, enemy types, and other parameters based on your game
            Debug.Log($"Spawning Wave {currentWave + 1}");
            yield return new WaitForSeconds(2f);
        }
    }</pre> <p class="calibre3">Here’s an <a id="_idIndexMarker300" class="calibre6 pcalibre1 pcalibre"/>explanation of the <code>EnemyWavesChallenge</code> class:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1">public int totalWaves = 5</strong>: This variable determines the total number of waves for the enemy challenge. Game designers can adjust this value to set the desired number of waves.</li>
<li class="calibre11"><strong class="source-inline1">private int currentWave = 0</strong>: This variable keeps track of the current wave during the challenge. It starts at <strong class="source-inline1">0</strong> and increments as waves are spawned.</li>
<li class="calibre11"><strong class="source-inline1">public override void StartChallenge()</strong>: This method overrides the <strong class="source-inline1">StartChallenge()</strong> method that’s inherited from the <strong class="source-inline1">BaseChallenge</strong> class. It initiates the enemy waves challenge if it’s not already completed. Inside this method, a coroutine named <strong class="source-inline1">StartEnemyWavesChallenge()</strong> is started to handle the wave spawning process.</li>
<li class="calibre11"><strong class="source-inline1">IEnumerator StartEnemyWavesChallenge()</strong>: This coroutine function manages the spawning of enemy waves. It runs until the current wave count reaches the total number of waves specified. Inside the loop, it waits for a wave to be spawned using the <strong class="source-inline1">SpawnEnemyWave()</strong> coroutine.</li>
<li class="calibre11"><strong class="source-inline1">public override void CompleteChallenge()</strong>: This method overrides the <strong class="source-inline1">CompleteChallenge()</strong> method from the base class. It grants rewards for completing the challenge using <strong class="source-inline1">RewardManager</strong> and marks the challenge as completed.</li>
<li class="calibre11"><strong class="source-inline1">IEnumerator SpawnEnemyWave()</strong>: This coroutine function represents the logic for spawning an enemy wave. Game designers can adjust spawn positions, enemy types, and other parameters to customize the wave spawning process. In <a id="_idIndexMarker301" class="calibre6 pcalibre1 pcalibre"/>this example, it logs a message indicating the wave being spawned and waits for a set duration before spawning the next wave.</li>
</ul>
<p class="calibre3">In summary, the <code>EnemyWavesChallenge</code> class defines a challenge where waves of enemies are spawned sequentially. It provides methods to start the challenge, spawn enemy waves, and handle the completion of the challenge by granting rewards. Game designers can customize the wave spawning process and adjust parameters according to the game’s requirements.</p>
<p class="calibre3">The previous example is just one of the challenges provided. You can find all the challenges in this book’s GitHub repository (see the <em class="italic">Technical requirements</em> section). Lastly, here’s <code>LevelManager</code>, which is tasked with assigning a suitable challenge for the current level:</p>
<pre class="source-code">
   public class LevelManager : Singleton&lt;LevelManager&gt;
   {
       public GenericDictionary&lt;int, ChallengeType&gt; levelChallengeMapping = new GenericDictionary&lt;int, ChallengeType&gt;();
       public int currentLevel;
       private void Start()
       {
           StartChallengeForCurrentLevel(currentLevel);
       }
       public void StartChallengeForCurrentLevel(int currentLevel)
       {
           if (levelChallengeMapping.TryGetValue(currentLevel, out ChallengeType challengeType))
           {
               // Start the challenge associated with the current level
               ChallengeManager.Instance.StartChallenge(challengeType);
           }
           else
           {
               Debug.LogError($"No challenge mapped for Level {currentLevel}");
           }
       }
   }</pre> <p class="calibre3">Here’s an <a id="_idIndexMarker302" class="calibre6 pcalibre1 pcalibre"/>explanation of the <code>LevelManager</code> class:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1">public GenericDictionary&lt;int</strong>, <strong class="source-inline1">ChallengeType&gt; levelChallengeMapping</strong>: This dictionary stores mappings between levels and their corresponding challenge types. The key represents the level number, and the value represents the type of challenge associated with that level.</li>
<li class="calibre11"><strong class="source-inline1">public int currentLevel</strong>: This variable stores the current level of the game.</li>
<li class="calibre11"><strong class="source-inline1">private void Start()</strong>: This method is called when the <strong class="source-inline1">LevelManager</strong> object is initialized. It automatically starts the challenge associated with the current level.</li>
<li class="calibre11"><strong class="source-inline1">public void StartChallengeForCurrentLevel(int currentLevel)</strong>: This method starts the challenge for the specified current level. It checks if a challenge has been mapped for the current level in the <strong class="source-inline1">levelChallengeMapping</strong> dictionary. If a mapping is found, it retrieves the associated challenge type and starts the corresponding challenge using <strong class="source-inline1">ChallengeManager</strong>.</li>
<li class="calibre11"><strong class="source-inline1">ChallengeManager.Instance.StartChallenge(challengeType)</strong>: This line of code invokes the <strong class="source-inline1">StartChallenge</strong> method of the <strong class="source-inline1">ChallengeManager</strong> singleton instance, passing the challenge type associated with the current level as an argument.</li>
</ul>
<p class="calibre3">In summary, the <code>LevelManager</code> class <a id="_idIndexMarker303" class="calibre6 pcalibre1 pcalibre"/>facilitates the initiation of challenges based on the current level of the game. It ensures that the correct challenge is started for each level by looking up the challenge type associated with the current level in the <code>levelChallengeMapping</code> dictionary and then invoking the <code>StartChallenge</code> method of the <code>ChallengeManager</code> singleton instance.</p>
<h3 class="calibre9">Implementing the reward system</h3>
<p class="calibre3">Now, let’s delve into<a id="_idIndexMarker304" class="calibre6 pcalibre1 pcalibre"/> the reward system, a crucial element in the gameplay flow that allows users to receive rewards. This feature is essential for user motivation and engagement</p>
<p class="calibre3">Here’s <code>RewardManager</code>, which is tasked with providing the user with rewards based on the challenge data. As we can see, it communicates with other managers to enable the user to receive specific rewards:</p>
<pre class="source-code">
    public class RewardManager : Singlton&lt;RewardManager&gt;
    {
        // Define different types of rewards
        public enum RewardType
        {
            PowerUp,
            UnlockableWeapon,
            ScoreMultiplier,
            SecretArea,
            Coins
        }
        public void GrantReward(CommonChallengeData commonData)
        {
            // Add code here to handle the specific reward type
            switch (commonData.rewardType)
            {
                case RewardType.PowerUp:
                    // Grant temporary power-up
                    break;
                case RewardType.UnlockableWeapon:
                    // Unlock a new weapon
                    break;
                case RewardType.ScoreMultiplier:
                    ApplyScoreMultiplier(commonData.rewardAmount);
                    break;
                case RewardType.SecretArea:
                    // Grant items found in a secret area
                    break;
                case RewardType.Coins:
                    GrantCoins(commonData.rewardAmount);
                    break;
            }
        }
        private void ApplyScoreMultiplier(int multiplier)
        {
            ScoreManager.Instance.ApplyMultiplier(multiplier);
            Debug.Log($"Score Multiplier Applied: {multiplier}x");
        }
        private void GrantCoins(int coinAmount)
        {
            CurrencyManager.Instance.AddCoins(coinAmount);
            Debug.Log($"Coins Granted: {coinAmount}");
        }
    }</pre> <p class="calibre3">Here’s an explanation of the <code>RewardManager</code> class:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1">public enum RewardType</strong>: This enumeration defines different types of rewards that can be granted to the player, such as power-ups, unlockable weapons, score multipliers, items found in secret areas, and coins.</li>
<li class="calibre11"><strong class="source-inline1">public void GrantReward(CommonChallengeData commonData)</strong>: This method is responsible for granting rewards to the player. It takes a <strong class="source-inline1">CommonChallengeData</strong> object as a parameter, which contains information about the type and amount of reward to be granted.</li>
<li class="calibre11"><strong class="source-inline1">switch (commonData.rewardType)</strong>: This switch statement checks the type of<a id="_idIndexMarker305" class="calibre6 pcalibre1 pcalibre"/> reward specified in the <strong class="source-inline1">CommonChallengeData</strong> object and executes the corresponding reward logic based on <strong class="source-inline1">RewardType</strong>.</li>
<li class="calibre11"><strong class="source-inline1">case RewardType.PowerUp</strong>: This case allows temporary power-ups to be granted to the player.</li>
<li class="calibre11"><strong class="source-inline1">case RewardType.UnlockableWeapon</strong>: This case allows new weapons to be unlocked for the player.</li>
<li class="calibre11"><strong class="source-inline1">case RewardType.ScoreMultiplier</strong>: This case applies a score multiplier to the player’s score by invoking the <strong class="source-inline1">ApplyScoreMultiplier</strong> method with the specified multiplier value.</li>
<li class="calibre11"><strong class="source-inline1">case RewardType.SecretArea</strong>: This case allows items to be found in secret areas.</li>
<li class="calibre11"><strong class="source-inline1">case RewardType.Coins</strong>: This case grants coins to the player by invoking the <strong class="source-inline1">GrantCoins</strong> method with the specified coin amount.</li>
<li class="calibre11"><strong class="source-inline1">private void ApplyScoreMultiplier(int multiplier)</strong>: This method applies a score multiplier to the player’s score by invoking the <strong class="source-inline1">ApplyMultiplier</strong> method of the <strong class="source-inline1">ScoreManager</strong> singleton instance.</li>
<li class="calibre11"><strong class="source-inline1">private void GrantCoins(int coinAmount)</strong>: This method adds coins to the player’s currency balance by invoking the <strong class="source-inline1">AddCoins</strong> method of the <strong class="source-inline1">CurrencyManager</strong> singleton instance.</li>
</ul>
<p class="calibre3">Overall, the <code>RewardManager</code> class provides a centralized mechanism for managing and granting various types of rewards to the player upon completing challenges.</p>
<p class="calibre3">The following code block contains <code>CurrencyManager</code>, which is responsible for overseeing in-game<a id="_idIndexMarker306" class="calibre6 pcalibre1 pcalibre"/> currency. However, the focus here is on a segment dedicated to adding coins to the player:</p>
<pre class="source-code">
   Public class CurrencyManager : Singlton&lt;CurrencyManager&gt;
   {
       private int currentCoins;
       public void AddCoins(int amount)
       {
           currentCoins += amount;
           Debug.Log($"Coins: {currentCoins}");
       }
   }</pre> <p class="calibre3">Here’s an explanation of the <code>CurrencyManager</code> class:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1">private int currentCoins</strong>: This variable stores the current number of coins the player has.</li>
<li class="calibre11"><strong class="source-inline1">public void AddCoins(int amount)</strong>: This method allows you to add coins to the player’s currency balance. It takes an integer parameter amount, representing the number of coins to add to the current balance.</li>
<li class="calibre11"><strong class="source-inline1">currentCoins += amount</strong>: This line increments the <strong class="source-inline1">currentCoins</strong> variable by the specified amount, effectively adding coins to the player’s balance.</li>
</ul>
<p class="calibre3">Overall, the <code>CurrencyManager</code> class provides a simple yet essential functionality for managing the player’s currency balance, specifically adding coins to their total balance.</p>
<p class="calibre3">The following code block contains <code>ScoreManager</code>, which is tasked with managing the player’s score and <a id="_idIndexMarker307" class="calibre6 pcalibre1 pcalibre"/>implementing a scoring multiplier:</p>
<pre class="source-code">
    public class ScoreManager : Singlton&lt;ScoreManager&gt;
    {
        private float currentScore;
        private int scoreMultiplier = 1;
        public void ApplyMultiplier(int multiplier)
        {
            scoreMultiplier *= multiplier;
        }
        private void ResetMultiplier()
        {
            scoreMultiplier = 1;
        }
        public void AddScore(int scoreValue)
        {
            // Adjust score based on the current multiplier
            currentScore += scoreValue * scoreMultiplier;
            Debug.Log($"Score: {currentScore}");
        }
    }</pre> <p class="calibre3">Here’s an explanation of<a id="_idIndexMarker308" class="calibre6 pcalibre1 pcalibre"/> the <code>ScoreManager</code> class:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1">private float currentScore</strong>: This variable stores the current score of the player.</li>
<li class="calibre11"><strong class="source-inline1">private int scoreMultiplier = 1</strong>: This variable represents the score multiplier, which starts at <strong class="source-inline1">1</strong> by default.</li>
<li class="calibre11"><strong class="source-inline1">public void ApplyMultiplier(int multiplier)</strong>: This method allows you to apply a score multiplier to the current score. It takes an integer parameter multiplier, which adjusts the score multiplier accordingly.</li>
<li class="calibre11"><strong class="source-inline1">*scoreMultiplier = multiplier</strong>: This line multiplies the existing score multiplier by the specified multiplier, effectively adjusting the score multiplier.</li>
<li class="calibre11"><strong class="source-inline1">private void ResetMultiplier()</strong>: This method resets the score multiplier to its default value of <strong class="source-inline1">1</strong>.</li>
<li class="calibre11"><strong class="source-inline1">public void AddScore(int scoreValue)</strong>: This method adds a specified score value to the player’s current score. It takes an integer parameter called <strong class="source-inline1">scoreValue</strong>, representing the score to add to the current score.</li>
<li class="calibre11"><strong class="source-inline1">currentScore += scoreValue * scoreMultiplier</strong>: This line adjusts the current score based on the score value and the current score multiplier. It multiplies the score value by the score multiplier and adds it to the current score.</li>
</ul>
<p class="calibre3">Overall, the <code>ScoreManager</code> class handles score calculations and updates, including applying multipliers and adding score values to the player’s total score.</p>
<p class="calibre3">This example <a id="_idIndexMarker309" class="calibre6 pcalibre1 pcalibre"/>highlights the vital relationship between challenges and the reward system in game development. Challenges provide engaging obstacles and objectives, fostering player interaction and progression. Integrated with the reward system, completing challenges becomes not just an accomplishment but a satisfying experience, offering incentives that motivate players. This dynamic interplay enhances the overall gaming experience, ensuring players remain engaged, motivated, and fulfilled throughout their journey in the game world.</p>
<p class="calibre3">In <a href="B22017_06.xhtml#_idTextAnchor098" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 6</em></a>, which focuses on data handling, I intend to introduce a save system that will store all pertinent data, encompassing the elements we’ve discussed so far. This chapter will delve into<a id="_idIndexMarker310" class="calibre6 pcalibre1 pcalibre"/> the specifics of implementing this system.</p>
<p class="calibre3">The provided scripts serve as demonstrations, and you can find the complete logic in this book’s GitHub repository.</p>
<h1 id="_idParaDest-71" class="calibre5"><a id="_idTextAnchor073" class="calibre6 pcalibre1 pcalibre"/>Summary</h1>
<p class="calibre3">In this chapter, we delved into essential Unity game development principles, specifically addressing game mechanics with a focus on C#. We underscored their significance in shaping engaging gameplay, encompassing aspects such as balance, feedback, and player agency. This provided you with practical skills in C# coding for implementing effective game mechanics. Transitioning to the next section, <em class="italic">Implementing player behavior and AI logic using C#</em>, we explored player behavior design and foundational AI concepts. Additionally, we emphasized the crucial role of challenges and reward systems in elevating the player experience and fostering engagement.</p>
<p class="calibre3">In <a href="B22017_05.xhtml#_idTextAnchor074" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 5</em></a><em class="italic">,</em> <em class="italic">Designing Optimized User Interfaces with C# for Unity Games</em>, you will delve into the domain of UI design principles and responsive UI elements. By mastering UI design techniques using C#, you’ll be able to craft visually appealing and immersive interfaces. This chapter aims to augment your skills in designing effective visual hierarchies, layouts, and responsive UI elements, ultimately contributing to an enhanced user experience, including optimized UI elements.</p>
<p class="calibre3">As you embark on this ongoing journey of skill-building, the upcoming chapter holds exciting challenges and discoveries. Happy coding!</p>
</div>
</body></html>