<html><head></head><body>
		<div><h1 id="_idParaDest-99" class="chapter-number"><a id="_idTextAnchor146"/>9</h1>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor147"/>Taking Advantage of the Dynamic Language Runtime</h1>
			<p>C# is a statically typed language, which means we take our code in text form and run it through a compiler, and it produces a binary that is then executed later. The code does not change after the compiler is done. Not all languages are like this; languages such as Ruby, Python, and JavaScript are dynamic languages and do not compile to binary before execution. They are interpreted at runtime, meaning that they can also change gradually during runtime. This is a very powerful trait.</p>
			<p>In this chapter, we will look into how we can make use of the dynamic language runtime part of the .NET runtime and create code dynamically and differently from how we’ve done it thus far.</p>
			<p>We will cover the following topics:</p>
			<ul>
				<li>Understanding the DLR</li>
				<li>Reasoning about a dynamic type</li>
				<li>Creating a DynamicObject and providing metadata</li>
			</ul>
			<p>By the end of the chapter, you will understand what the dynamic language runtime is and how you can make use of it to dynamically create types and reason about them.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor148"/>Technical requirements</h1>
			<p>The source code specific to the chapter can be found on GitHub (<a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter9">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter9</a>), and it builds on top of the <strong class="source-in ine">Fundamentals</strong> code that is found here: <a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals</a>.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor149"/>Understanding the DLR</h1>
			<p>The <strong class="bo d">Dynamic Language Runtime</strong> (<strong class="bo d">DLR</strong>) was<a id="_idIndexMarker297"/> introduced in .NET 4 back in 2010. It runs on top of the .NET runtime, <strong class="bo d">Common Language Runtime</strong> (<strong class="bo d">CLR</strong>), providing <a id="_idIndexMarker298"/>language services for dynamic languages such as Python and Ruby through the IronPython and IronRuby implementations. With the DLR, it is also possible to interop between the different languages, effectively making it possible to have C# and Python, Ruby, or any other dynamic language that is supported run side by side in the same process.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor150"/>The CLR at a glance</h2>
			<p>Before diving<a id="_idIndexMarker299"/> into <a id="_idIndexMarker300"/>the DLR, it’s helpful to understand the constraints it has to work with. The CLR is at the heart of everything .NET, which means that everything running has to abide by the rules of the CLR. That becomes very interesting when looking at the traits of the CLR.</p>
			<h3>Just-in-Time (JIT) compilation</h3>
			<p>The CLR <a id="_idIndexMarker301"/>compiles <a id="_idIndexMarker302"/>the <strong class="bo d">Intermediate Language</strong> (<strong class="bo d">IL</strong>) code into native <a id="_idIndexMarker303"/>code for the specific machine and operating system at runtime, using the JIT compiler. This process enables better optimization, faster execution, and cross-platform compatibility.</p>
			<h3>Automatic memory management</h3>
			<p>The CLR manages<a id="_idIndexMarker304"/> memory allocation and deallocation using garbage collection, which automatically frees up memory occupied by objects that are no longer in use. This helps prevent memory leaks and optimizes memory usage.</p>
			<h3>Type safety</h3>
			<p>The CLR ensures<a id="_idIndexMarker305"/> type safety by enforcing strict rules during code execution. This helps prevent invalid memory operations, such as accessing a memory location that has not been initialized or using an object of one type as another type.</p>
			<h3>Exception handling</h3>
			<p>The CLR provides <a id="_idIndexMarker306"/>a consistent and robust exception-handling mechanism across all .NET languages, allowing developers to handle runtime errors gracefully and maintain application stability.</p>
			<h3>Cross-language Interoperability</h3>
			<p>The CLR supports <a id="_idIndexMarker307"/>interoperability between .NET languages, allowing developers to use components written in different languages within the same application. This promotes code reusability and simplifies the development process.</p>
			<h3>Versioning and assembly management</h3>
			<p>The CLR manages <a id="_idIndexMarker308"/>the versioning of assemblies (compiled <a id="_idIndexMarker309"/>code units), helping to prevent issues such as “DLL hell,” where conflicting versions of shared libraries cause application instability. It also provides features such as side-by-side execution, allowing multiple versions of an assembly to coexist on the same system.</p>
			<h3>Reflection</h3>
			<p>The CLR enables<a id="_idIndexMarker310"/> developers to inspect and interact with metadata about types, objects, and assemblies at runtime. This allows dynamic type creation, method invocation, and other advanced programming techniques.</p>
			<h3>Debugging and profiling</h3>
			<p>The CLR <a id="_idIndexMarker311"/>provides<a id="_idIndexMarker312"/> integrated support for debugging and profiling .NET applications, enabling developers to diagnose and optimize code efficiently.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor151"/>The DLR building blocks</h2>
			<p>For any of the<a id="_idIndexMarker313"/> dynamic languages to work, the DLR needs to support a few things that are very different from the more static world of the CLR. The following traits are needed.</p>
			<h3>Dynamic type system</h3>
			<p>A dynamic<a id="_idIndexMarker314"/> runtime needs to be able to create types on the fly. A type is never static and should be able to be expanded on.</p>
			<h3>Dynamic dispatching of methods</h3>
			<p>A dynamic <a id="_idIndexMarker315"/>runtime should allow calling methods that aren’t known beforehand.</p>
			<h3>Dynamic code generation</h3>
			<p>A dynamic<a id="_idIndexMarker316"/> runtime should allow for code generation at runtime, allowing you to add code based on input or the result of other code dynamically. It should also allow you to modify code.</p>
			<p>From a CLR perspective, these types of traits seem very unaligned. The engineers at Microsoft extended the core functionality and put in place a dynamic runtime that works well with the CLR.</p>
			<p>From a metaprogramming perspective, the traits of a dynamic runtime are perfect. As part of the DLR, there is a collection of constructs and APIs that enables you to dynamically create types and also reason about any dynamic type that fulfills the traits we’re looking for.</p>
			<p>Since the .NET runtime itself is a static runtime and relies on well-known types with fixed members, the DLR needs to work with this constraint. The DLR, therefore, provides a set of classes and interfaces to represent dynamic objects, their properties, and operations, such as <strong class="source-in ine">IDynamicMetaObjectProvider</strong>, <strong class="source-in ine">DynamicMetaObject</strong>, <strong class="source-in ine">DynamicObject</strong>, and <strong class="source-in ine">ExpandoObject</strong>.</p>
			<p>For the DLR to work with dynamic languages, it needs a way to represent the language semantics. The DLR uses expression trees, which we looked at in more detail in <a href="B19418_07.xhtml#_idTextAnchor118"><em class="ita ic">Chapter 7</em></a>, <em class="ita ic">Reasoning about Expressions</em>, and <a href="B19418_08.xhtml#_idTextAnchor132"><em class="ita ic">Chapter 8</em></a>, <em class="ita ic">Building and Executing Expressions</em>. With the DLR comes a set of extensions to LINQ expressions that give us control flow, assignment, and other language-modeling nodes.</p>
			<p>From a compiler perspective, the C# compiler has a keyword called <strong class="source-in ine">dynamic</strong> that lets you say that a particular variable or argument is of a dynamic type. That tells the compiler to not evaluate any member accesses during compile time for the instance. Instead, it translates all this into the appropriate <strong class="source-in ine">Expression</strong> that will execute.</p>
			<p>To get started with leveraging the DLR and its dynamic capabilities, the easiest way is to use the <strong class="source-in ine">ExpandoObject</strong> type. <strong class="source-in ine">ExpandoObject</strong> provides a type that can be dynamically expanded on; it will hold anything you tell it to and can expand as you proceed:</p>
			<pre class="source-code">
dynamic person = new ExpandoObject();
person.FirstName = "Jane";
person.LastName = "Doe";</pre>
			<p>The code<a id="_idIndexMarker317"/> creates an instance of <strong class="source-in ine">ExpandoObject</strong> and then starts setting values on it. <strong class="source-in ine">ExpandoObject</strong> does not have <strong class="source-in ine">FirstName</strong> or <strong class="source-in ine">LastName</strong> as part of its type, but by setting them, the values will be there.</p>
			<p>Accessing these members will be the same; the compiler understands that <strong class="source-in ine">ExpandoObject</strong> is <strong class="source-in ine">dynamic</strong> and will try to bind to the members at runtime rather than at compile time. The following code will be completely valid:</p>
			<pre class="source-code">
Console.WriteLine($"{person.FirstName} {person.LastName}");</pre>
			<p>The result will be as expected:</p>
			<pre class="source-code">
Jane Doe</pre>
			<p><strong class="source-in ine">ExpandoObject</strong> does this by implementing the <strong class="source-in ine">IDynamicMetaObjectProvider</strong> interface. With <strong class="source-in ine">IDynamicMetaObjectProvider</strong>, it provides its own implementation of <strong class="source-in ine">DynamicMetaObject</strong> that really holds all the magic of doing the actual binding of the operations we tell it to do.</p>
			<p>The <strong class="source-in ine">ExpandoObject</strong> type also implements the <strong class="source-in ine">IDictionary&lt;string, object?&gt;</strong> interface, which is how it represents all the members given to it and also how it can dynamically grow. Through its implementation of <strong class="source-in ine">DynamicMetaObject</strong>, it basically just works on the internal dictionary. In fact, it is fully possible to work with <strong class="source-in ine">ExpandoObject</strong> as a dictionary if you want:</p>
			<pre class="source-code">
var person = new ExpandoObject() as IDictionary&lt;string, object?&gt;;
person["FirstName"] = "Jane";
person["LastName"] = "Doe";</pre>
			<p>If you’re using <strong class="source-in ine">dynamic</strong> for data objects, this can be really handy, as it gives you a simple way <a id="_idIndexMarker318"/>to reason about an object and its content and, at the same time, a convenient programming experience by treating it as a dynamic ob<a id="_idTextAnchor152"/>ject with properties.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor153"/>Call sites and binders</h2>
			<p>Whenever <a id="_idIndexMarker319"/>you want to perform an operation<a id="_idIndexMarker320"/> on a dynamic object – for instance, a<a id="_idIndexMarker321"/> get <a id="_idIndexMarker322"/>or set property or a method call – it goes through something called a <strong class="bo d">call site</strong>. A call site is effectively the location at runtime of the code that will execute. For compiled C#, this will be the memory location where the IL code typically resides. For other languages, such as Ruby or Python, this would be the location in the textual code. Every language has its own call site representation.</p>
			<p>The big difference between static languages and dynamic languages is that the static languages are compiled, and at runtime, they’re either executing some sort of intermediate language or actual machine language. Alternatively, a dynamic language will interpret code at runtime and execute the result. The benefit of a dynamic language then is that it can change its own code dynamically, obviously with the downside of a loss in performance.</p>
			<p>Once you have the location, or the call site, you can bind to the member and then perform the operation you want.</p>
			<p>There are binders for the typical operations you want to perform on an object – the get and set properties, invoke methods, indexing, and so on. Throughout the book, we’ve looked at the power of metadata and how we can reason about the running code; the DLR poses some challenges with this.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor154"/>Reasoning about a dynamic type</h1>
			<p>The DLR is very<a id="_idIndexMarker323"/> limited in <a id="_idIndexMarker324"/>what it is possible to reason about for a dynamic type. Primarily, the DLR is built to be able to host dynamic languages. Naturally with dynamic languages, you don’t really know what’s going on with a dynamic type, and it can change over time, so even though a member is already there, the DLR can’t provide you a reflective experience by giving you any details, such as type information, about the member.</p>
			<p>One thing we can do, however, is ask it what members it has. Every dynamic object implements an interface called <strong class="source-in ine">IDynamicMetaObjectProvider</strong>. On this, you can call the <strong class="source-in ine">GetMetaObject()</strong> method to get an object that allows us to interact with the dynamic object.</p>
			<p>Let’s look at <strong class="source-in ine">ExpandoObject</strong> with the following properties:</p>
			<pre class="source-code">
dynamic person = new ExpandoObject();
person["FirstName"] = "Jane";
person["LastName"] = "Doe";</pre>
			<p>Since <strong class="source-in ine">ExpandoObject</strong> does, in fact, implement <strong class="source-in ine">IDynamicMetaObjectProvider</strong>, we can ask it for its meta-object and then its members:</p>
			<pre class="source-code">
var provider = (person as IDynamicMetaObjectProvider)!;
var meta = provider.GetMetaObject(Expression.Constant(person));
var members = string.Join(',', meta.GetDynamicMemberNames());
Console.WriteLine(members);</pre>
			<p>Running this code will give you the following result:</p>
			<pre class="source-code">
FirstName,LastName</pre>
			<p>The code itself assumes it is <strong class="source-in ine">IDynamicMetaObjectProvider</strong> by casting it to a type, in order for us to call <strong class="source-in ine">GetMetaObject()</strong>. The <strong class="source-in ine">Expression</strong> we create represents the instance of the person that we’re getting the meta-object for. Then, we call <strong class="source-in ine">GetDynamicMemberNames()</strong>, which returns a collection of strings with all its member names.</p>
			<p>This is the extent of what it is possible to reason about.</p>
			<p>However, we can dynamically invoke the members, which comes in handy when you don’t know the shape of the object. It can be a bit challenging to invoke when you don’t really know what the object holds, and if you want to support everything, you’ll need fallback mechanisms, as the runtime will throw <strong class="source-in ine">RuntimeBinderException</strong> if it can’t bind the way you want to.</p>
			<p><strong class="source-in ine">DynamicMetaObject</strong> has a set of methods with all the binding you can do. These <em class="ita ic">bind</em> methods require an actual binder, which you can get from the call site. After bind, you will get a new <strong class="source-in ine">DynamicMetaObject</strong>. It is possible to use all of these things to get to the actual value, but let’s jump directly to the C# binder, get the binder we want, and use that instead.</p>
			<p>In the <strong class="source-in ine">Microsoft.CSharp.RuntimeBinder</strong> namespace, there is a class called <strong class="source-in ine">Binder</strong>. This<a id="_idIndexMarker325"/> class holds a set of <a id="_idIndexMarker326"/>static methods to get specific binders. The types of binders you can use are as follows:</p>
			<table id="table001-1" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-in ine">BinaryOperation</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Used for binary operations</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-in ine">Convert</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Used to convert to a specific type</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-in ine">GetIndex</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Used to get an index</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-in ine">GetMember</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Used to get a member’s value</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-in ine">Invoke</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Used to invoke a method</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-in ine">InvokeConstructor</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Used to invoke/construct a constructor</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-in ine">SetIndex</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Used to set an index</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-in ine">SetMember</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Used to set a member to a value</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-in ine">UnaryOperation</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Used for unary operations</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>Since the object we have only has properties, we will use the <strong class="source-in ine">GetMember</strong> binder to get the property value and, ultimately, the actual value through the call site:</p>
			<pre class="source-code">
foreach (var member in meta.GetDynamicMemberNames())
{
    var binder = Binder.GetMember(
        CSharpBinderFlags.None,
        member,
        person.GetType(),
        new[] {
          CSharpArgumentInfo.Create(CsharpArgumentInfoFlags
          .None, null) });
    var site = CallSite&lt;Func&lt;CallSite, object,
      object&gt;&gt;.Create(binder);
    var propertyValue = site.Target(site, person);
    Console.WriteLine($"{member} = {propertyValue}");
}</pre>
			<p>The code <a id="_idIndexMarker327"/>builds on the <strong class="source-in ine">meta</strong> instance<a id="_idIndexMarker328"/> we got from <strong class="source-in ine">GetMetaObject()</strong> and iterates through the member names returned by <strong class="source-in ine">GetDynamicMemberNames()</strong>. For each member, you can then get the binder for it – in our case, the <strong class="source-in ine">GetMember</strong> binder – passing default values to it with <strong class="source-in ine">member</strong> and the <strong class="source-in ine">person</strong> type.</p>
			<p>In the <strong class="source-in ine">System.Runtime.CompilerService</strong> namespace, you’ll find a class called <strong class="source-in ine">CallSite&lt;&gt;</strong>. This is a dynamic site type that can be used to create a call site for the binder dynamically. In our case, the dynamic site will be a delegate, <strong class="source-in ine">Func&lt;&gt;</strong>, that allows us to call it with <strong class="source-in ine">person</strong> and get a value back. The types going in and out are both <strong class="source-in ine">object</strong>, since the actual type is unknown.</p>
			<p>Running this code should give you this:</p>
			<pre class="source-code">
FirstName = Jane
LastName = Doe</pre>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">The code assumes that all members are properties, which can fail with <strong class="source-in ine">RuntimeBinder</strong><strong class="source-in ine">
Exception</strong>. If you need to support more member types, you would need to handle that exception and fall back to the ones you want to support.</p>
			<p>Another approach you could use is to use expressions. The <strong class="source-in ine">Expression</strong> class has a <strong class="source-in ine">Dynamic</strong> method that lets you pass in the binder and then create a <strong class="source-in ine">Lambda</strong> expression, which gives you a similar <strong class="source-in ine">Func&lt;&gt;</strong> delegate that can be invoked.</p>
			<p>The following gives you a method that can be called to create <strong class="source-in ine">Func&lt;&gt;</strong>, which we can call to get<a id="_idIndexMarker329"/> the <a id="_idIndexMarker330"/>values of members:</p>
			<pre class="source-code">
Func&lt;object, object&gt; BuildDynamicGetter(Type type, string propertyName)
{
    var binder = Binder.GetMember(
        CSharpBinderFlags.None,
        propertyName,
        type,
        new[] {
          CSharpArgumentInfo.Create(CsharpArgumentInfoFlags
          .None, null) });
    var rootParameter =
      Expression.Parameter(typeof(object));
    var binderExpression = Expression.Dynamic(binder,
      typeof(object), Expression.Convert(rootParameter,
      type));
    var getterExpression = Expression.Lambda&lt;Func&lt;object,
      object&gt;&gt;(binderExpression, rootParameter);
    return getterExpression.Compile();
}</pre>
			<p>The code gets the <strong class="source-in ine">GetMember</strong> binder and then creates <strong class="source-in ine">DynamicExpression</strong>, which involves a conversion of the instance we will pass to <strong class="source-in ine">object</strong>. Then, the code creates a <strong class="source-in ine">Lambda</strong> expression, which we then compile for more performant execution.</p>
			<p>This new method can then be used in the following way:</p>
			<pre class="source-code">
var firstNameExpression = BuildDynamicGetter(person.GetType(), "FirstName");
var lastNameExpression = BuildDynamicGetter(person.GetType(), "LastName");
Console.WriteLine($"{firstNameExpression(person)} {lastNameExpression(person)}");</pre>
			<p>The output of this would be as follows:</p>
			<pre class="source-code">
Jane Doe</pre>
			<p>Since the<a id="_idIndexMarker331"/> DLR itself is limited in <a id="_idIndexMarker332"/>discoverability and reasoning about what is there, it might be a good idea in some use cases to provide the metadata yourself, using other formats and appro<a id="_idTextAnchor155"/>aches.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor156"/>Creating DynamicObject and providing metadata</h1>
			<p>Sometimes, you <a id="_idIndexMarker333"/>don’t <a id="_idIndexMarker334"/>have the luxury of having your types represented in code. This could be if you’re calling an external API of some sort, be it a REST API, SOAP service, or similar. However, the third party you’re calling might have a representation of the type in a standard format, such as a WSDL or JSON schema.</p>
			<p>Even though dynamic objects can be very flexible, in the real world the shape of data tends to be stricter. So, instead of using <strong class="source-in ine">ExpandoObject</strong> for everything, you could represent these types with a custom dynamic object that gets its metadata from a well-known format. It’s very common today to use JSON as a data carrier, and it’s also common to represent the shape of data by leveraging JSON schemas. Let’s look at how that could be a provider of me<a id="_idTextAnchor157"/>tadata.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor158"/>Building a JSON schema type</h2>
			<p>Start by creating<a id="_idIndexMarker335"/> a folder called <strong class="source-in ine">Chapter9</strong>. Change into this folder in your command-line interface and create a new console project:</p>
			<pre class="source-code">
dotnet new console</pre>
			<p>We will rely on a third-party library, giving us an easy way of working with JSON schemas. Add the package to the project by running the following:</p>
			<pre class="source-code">
dotnet add package NJsonSchema</pre>
			<p>A JSON schema is a simple structure that describes a type, its properties, and the type of every property. It is, however, limited to the types available to JSON:</p>
			<ul>
				<li>String</li>
				<li>Number</li>
				<li>Boolean</li>
				<li>Array</li>
				<li>Object</li>
			</ul>
			<p>However, a JSON schema does support a concept of <em class="ita ic">format</em> that can be used as a sub-type for types. For instance, dates are not part of the JSON type system, but having a property of type <strong class="source-in ine">string</strong> and a format of type <strong class="source-in ine">date</strong> would allow you to support any type you want, since strings can hold anything.</p>
			<p>JSON schemas can also hold sub-schemas, which makes it possible to have strongly typed object definitions within an object.</p>
			<p>For this sample, we’re going to keep it very simple and stick with simple types.</p>
			<p>Add a file called <strong class="source-in ine">person.json</strong> to your project and add the following to it:</p>
			<pre class="source-code">
{
  „$schema": „http://json-schema.org/draft-04/schema#",
  "title": "Person",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "FirstName": {
      "type": "string"
    },
    "LastName": {
      "type": "string"
    },
    "Birthdate": {
      "type": "string",
      "format": "date"
    }
  }
}</pre>
			<p>In the JSON, you’ll find the <strong class="source-in ine">title</strong> property, which is the name of the type, and the <strong class="source-in ine">type</strong> property is set to <strong class="source-in ine">object</strong>, since it describes an object. The schema then contains three properties<a id="_idIndexMarker336"/> with the following types:</p>
			<table id="table002" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bo d">Property</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bo d">Type</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>FirstName</p>
						</td>
						<td class="No-Table-Style">
							<p>String</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>LastName</p>
						</td>
						<td class="No-Table-Style">
							<p>String</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Birthdate</p>
						</td>
						<td class="No-Table-Style">
							<p>Date</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 9.1 – A schema for a person</p>
			<p>Add a file called <strong class="source-in ine">JsonSchemaType.cs</strong>, and add the following code to it:</p>
			<pre class="source-code">
using System.Dynamic;
using NJsonSchema;
namespace Chapter9;
public class JsonSchemaType : DynamicObject
{
    readonly IDictionary&lt;string, object?&gt; _values = new
      Dictionary&lt;string, object?&gt;();
    readonly JsonSchema _schema;
    public JsonSchemaType(JsonSchema schema)
    {
        _schema = schema;
    }</pre>
			<p>The code creates a new type called <strong class="source-in ine">JsonSchemaType</strong> that inherits from the <strong class="source-in ine">DynamicObject</strong> type found in the <strong class="source-in ine">System.Dynamic</strong> namespace. This particular type is a helper type, created to make it easier to implement dynamic objects. To represent the actual content of the type, the code adds <strong class="source-in ine">Dictionary&lt;string, object?&gt;</strong>. This gives you the flexibility of putting anything into it, much like <strong class="source-in ine">ExpandoObject</strong> does. The reason for <strong class="source-in ine">object?</strong> as the value type is to allow anything and also make it<a id="_idIndexMarker337"/> explicit that we allow null values in it. The constructor takes a <strong class="source-in ine">JsonSchema</strong> type from the <strong class="source-in ine">NJsonSchema</strong> dependency you added earlier.</p>
			<h3>Validating properties</h3>
			<p>Since JSON <a id="_idIndexMarker338"/>schemas give you a full description of a type, its properties, and the types for the properties, it gives you an opportunity to validate the values being set on the object.</p>
			<p>Let’s introduce some basic validation into the object. Start by adding a new file that will give us an explicit exception describing the problem that can occur. Add a file called <strong class="source-in ine">InvalidTypeForProperty.cs</strong>, and add the following code to it:</p>
			<pre class="source-code">
public class InvalidTypeForProperty : Exception
{
    public InvalidTypeForProperty(string type, string
      property) : base($"Property '{property}' on '{type}'
      is invalid.")
    {
    }
}</pre>
			<p>The custom exception takes two properties – the name of the type that owns the errored property and then the actual property that was wrong. You could also include for good measure the type it was trying to set and what was expected, but to keep the sample simple, let’s just go with this.</p>
			<p>To do the actual validation, you’ll need something that translates from the .NET type to <strong class="source-in ine">JsonObjectType</strong>. Go back to the <strong class="source-in ine">JsonSchemaType.cs</strong> file and add a method that does the necessary translations from the .NET type to a <strong class="source-in ine">JsonObjectType</strong>. Add the following <a id="_idIndexMarker339"/>method to the <strong class="source-in ine">JsonSchemaType</strong> class:</p>
			<pre class="source-code">
JsonObjectType GetSchemaTypeFrom(Type type)
{
    return type switch
    {
        Type _ when type == typeof(string) =&gt;
          JsonObjectType.String,
        Type _ when type == typeof(DateOnly) =&gt;
          JsonObjectType.String,
        Type _ when type == typeof(int) =&gt;
          JsonObjectType.Integer,
        Type _ when type == typeof(float) =&gt;
          JsonObjectType.Number,
        Type _ when type == typeof(double) =&gt;
          JsonObjectType.Number,
        _ =&gt; JsonObjectType.Object
    };
}</pre>
			<p>The code uses a simple pattern matching and converts from the .NET type to <strong class="source-in ine">JsonObjectType</strong>. It defaults to <strong class="source-in ine">JsonObjectType.Object</strong> for anything it doesn’t have an explicit conversion for.</p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">This implementation is very simplistic and does not cover all the .NET types, and you should probably make it a bit more sophisticated for production. Hopefully, though, it gives you a general idea.</p>
			<p>Now that you<a id="_idIndexMarker340"/> have a way of converting from a CLR type to <strong class="source-in ine">JsonObjectType</strong>, you need a way to actually do the validation. Add the following method to the <strong class="source-in ine">JsonSchemaType</strong> class:</p>
			<pre class="source-code">
void ValidateType(string property, object? value)
{
    if (value is not null)
    {
        var schemaType = GetSchemaTypeFrom(
          value.GetType());
        if (!_schema.ActualProperties[property]
          .Type.HasFlag(schemaType))
        {
            throw new InvalidTypeForProperty(_schema.Title,
              property);
        }
    }
}</pre>
			<p>The code only validates a value if it is not null, since you wouldn’t be able to know its type unless it has a value. With the type, it gets the actual schema type and then checks whether or not the property has this type. <strong class="source-in ine">JsonObjectType</strong> is an enum of flags, and combinations are allowed, which is why you have to use the <strong class="source-in ine">HasFlag</strong> method. If it’s not the correct <a id="_idIndexMarker341"/>type, the code throws the <strong class="source-in ine">InvalidTypeForProperty</strong> exception.</p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">A tip here would be to also validate whether null is allowed or not. This information is also supported by JSON schemas. Some types also inherently don’t allow nulls, such as integers or Booleans, and you should probably not allow that.</p>
			<h3>Implementing getting and setting properties</h3>
			<p>With the<a id="_idIndexMarker342"/> constructor and validation in place, you’re now ready to override some of the default behavior of the <strong class="source-in ine">DynamicObject</strong> type. The <strong class="source-in ine">DynamicObject</strong> type offers a set of virtual methods that can be overridden for the different operations that can be performed, such as getting or setting properties and invoking methods.</p>
			<p>In this sample, we will focus primarily on properties. Add the following method to the <strong class="source-in ine">JsonSchemaType</strong> class:</p>
			<pre class="source-code">
public override bool TrySetMember(SetMemberBinder binder, object? value)
{
    if (!_schema.ActualProperties.ContainsKey(binder.Name))
    {
        return false;
    }
    ValidateType(binder.Name, value);
    _values[binder.Name] = value;
    return true;
}</pre>
			<p>The <strong class="source-in ine">TrySetMember</strong> signature takes <strong class="source-in ine">SetMemberBinder</strong>, which holds the information about the property being set. It also gets the value, which can be null. The code then first validates whether or not the property actually exists in the schema by looking into the <strong class="source-in ine">ActualProperties</strong> dictionary. If it does not exist, it immediately returns <strong class="source-in ine">false</strong>, and if you were to try to set an unknown property, you would then get <strong class="source-in ine">RuntimeBinderException</strong>. When the property exists, the code validates the type of the value. If the type is correct, the code then sets the value in its private dictionary.</p>
			<p>Once you have set a<a id="_idIndexMarker343"/> property, you also want to read it. Add the following method to the <strong class="source-in ine">JsonSchemaType</strong> class:</p>
			<pre class="source-code">
public override bool TryGetMember(GetMemberBinder binder, out object? result)
{
    if (!_schema.ActualProperties.ContainsKey(binder.Name))
    {
        result = null!;
        return false;
    }
    result = _values.ContainsKey(binder.Name)
        ? result = _values[binder.Name] : result = null!;
    return true;
}</pre>
			<p>Similar to the <strong class="source-in ine">TrySetMember</strong>, the code adds a check on whether or not the schema has the property. However, since this<a id="_idIndexMarker344"/> is a <strong class="bo d">get</strong> operation and the signature of the method dictates that the result should be given as an <strong class="source-in ine">out</strong> parameter, we need to explicitly set it to <strong class="source-in ine">null!</strong>. The code then checks whether the private dictionary contains a value for the property and returns it if it does or returns a <strong class="source-in ine">null!</strong> value if not.</p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">In a production system, you would typically not want to return just <strong class="source-in ine">null</strong> if the value is not set. It should be set to either the default value of the type or, if the JSON schema holds additional metadata with a default value, you should use that.</p>
			<p>As a <em class="ita ic">nice-to-have</em> feature, we want to allow this type to be converted to another type – in our case, <strong class="source-in ine">Dictionary&lt;string, object?&gt;</strong>.</p>
			<p>One of the methods that <strong class="source-in ine">DynamicObject</strong> provides that can be overridden is the <strong class="source-in ine">TryConvert</strong> method. This method will be called if an explicit cast is done from the type to a different<a id="_idIndexMarker345"/> target type. Add the following method to the <strong class="source-in ine">JsonSchemaType</strong> class:</p>
			<pre class="source-code">
public override bool TryConvert(ConvertBinder binder, out object? result)
{
    if (binder.Type.Equals(typeof(Dictionary&lt;string,
      object?&gt;)))
    {
        var returnValue = new Dictionary&lt;string,
          object?&gt;(_values);
        var missingProperties =
          _schema.ActualProperties.Where(_ =&gt;
          !_values.Any(kvp =&gt; _.Key == kvp.Key));
        foreach (var property in missingProperties)
        {
            object defaultValue = property.Value.Type
              switch
            {
                JsonObjectType.Array =&gt;
                  Enumerable.Empty&lt;object&gt;(),
                JsonObjectType.Boolean =&gt; false,
                JsonObjectType.Integer =&gt; 0,
                JsonObjectType.Number =&gt; 0,
                _ =&gt; null!
            };
            returnValue[property.Key] = defaultValue;
        }
        result = returnValue;
        return true;
    }
    return base.TryConvert(binder, out result);
}</pre>
			<p>The code only allows conversion to <strong class="source-in ine">Dictionary&lt;string, object?&gt;</strong>, so it checks for this first by looking at the <strong class="source-in ine">Type</strong> property of the <strong class="source-in ine">ConvertBinder</strong> type being passed in. It is a good practice to return values for all properties in the schema and not leave out any properties, and since all properties might be set, the code creates a new dictionary from the existing <strong class="source-in ine">_values</strong> dictionary and then finds any properties that are missing. For <a id="_idIndexMarker346"/>every property that is missing, it sets a default value.</p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">The default values have been simplified. As mentioned earlier, for production you should consider a more sophisticated approach to default values and look at possible additional metadata in the JSON schema.</p>
			<p>The last piece of the puzzle we want to add is the ability for outsiders to reason about what members are available. The <strong class="source-in ine">DynamicObject</strong> type gives us a method that can be overridden for this. Add the following method to the <strong class="source-in ine">JsonSchemaType</strong> class:</p>
			<pre class="source-code">
public override IEnumerable&lt;string&gt; GetDynamicMemberNames() =&gt; _schema.ActualProperties.Keys;</pre>
			<p>This method will be called by <strong class="source-in ine">DynamicMetaObject</strong> that <strong class="source-in ine">DynamicObject</strong> produces. <strong class="source-in ine">DynamicObject</strong> is also <strong class="source-in ine">IDynamicMetaObjectProvider</strong> and implements the <strong class="source-in ine">GetMetaObject()</strong> method.</p>
			<p><strong class="source-in ine">DynamicObject</strong> has more methods that can be overridden to invoke methods, perform binary<a id="_idIndexMarker347"/> operations, and so on. However, for this sample, we will focus on the data aspects with properties.</p>
			<h3>Using the schema infrastructure</h3>
			<p>What you’ve<a id="_idIndexMarker348"/> built so far is an infrastructure to work with JSON schemas, together with the DLR. Let’s take <strong class="source-in ine">JsonSchemaType</strong> out for a spin. Open the <strong class="source-in ine">Program.cs</strong> file and take out all its content. Add the following:</p>
			<pre class="source-code">
using NJsonSchema;
using Chapter9;
var schema = await JsonSchema.FromFileAsync("person.json");
dynamic personInstance = new JsonSchemaType(schema);
var personMetaObject = personInstance.GetMetaObject(Expression.Constant(personInstance));
var personProperties = personMetaObject.GetDynamicMemberNames();
Console.WriteLine(string.Join(',', personProperties));</pre>
			<p>The code reads the JSON schema from the <strong class="source-in ine">person.json</strong> file you created earlier. Then, it creates an instance of <strong class="source-in ine">JsonSchemaType</strong> and hands it the schema. Since <strong class="source-in ine">JsonSchemaType</strong> is a dynamic object, it implements <strong class="source-in ine">IDynamicMetaObjectProvider</strong>, and we can call the <strong class="source-in ine">GetMetaObject()</strong> method with the instance of the object and then get its members.</p>
			<p>When run, the code should produce the following:</p>
			<pre class="source-code">
FirstName,LastName</pre>
			<p>Setting and getting properties should work as expected:</p>
			<pre class="source-code">
personInstance.FirstName = "Jane";
Console.WriteLine($"FirstName : '{personInstance.FirstName}'");</pre>
			<p>Running the code should give you the following output:</p>
			<pre class="source-code">
FirstName : 'Jane'</pre>
			<p>Since the implementation of <strong class="source-in ine">JsonSchemaType</strong> supports default values for properties that have not been set, you can get a valid property without any problems:</p>
			<pre class="source-code">
Console.WriteLine($"LastName : '{personInstance.LastName}'");</pre>
			<p>The result of this should be the following:</p>
			<pre class="source-code">
LastName : ''</pre>
			<p>Converting this <a id="_idIndexMarker349"/>property to a dictionary should also work out of the box through an explicit cast:</p>
			<pre class="source-code">
var dictionary = (Dictionary&lt;string, object&gt;)personInstance;
Console.WriteLine(JsonSerializer.Serialize(dictionary));</pre>
			<p>The result of this should be the following:</p>
			<pre class="source-code">
{"FirstName":"Jane","LastName":null}</pre>
			<p>To test the validation, you can try to set the <strong class="source-in ine">LastName</strong> property to an unsupported type:</p>
			<pre class="source-code">
personInstance.LastName = 42;</pre>
			<p>The result of this should be the following:</p>
			<pre class="source-code">
Unhandled exception. Chapter9.InvalidTypeForProperty: Property 'LastName' on 'Person' is invalid.</pre>
			<p>The last thing we can do to verify that all is working as expected is to set a property that does not exist in the schema:</p>
			<pre class="source-code">
personInstance.FullName = "Jane Doe";</pre>
			<p>This should produce the following result:</p>
			<pre class="source-code">
Unhandled exception. Microsoft.CSharp.RuntimeBinder.RuntimeBinderException: 'Chapter9.JsonSchemaType' does not contain a definition for 'FullName'</pre>
			<p>Working with the <strong class="source-in ine">DynamicObject</strong> helper type eases the development of dynamic objects, as you don’t have to worry about the complexity of the moving parts and can focus on the<a id="_idIndexMarker350"/> actual shape and capabilities of the dynamic object you wan<a id="_idTextAnchor159"/>t to provide.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor160"/>Summary</h1>
			<p>This chapter explored the dynamic realm of the .NET runtime and how you can take advantage of it to create dynamic types that have its types defined outside of C# code. When working with third parties through APIs, this approach can be very handy. If you look at REST APIs and the OpenAPI standard, you’ll see extensive use of JSON schemas, and marrying the approach in this chapter with such standards can provide you a powerful mechanism to dynamically integrate with third parties, and at the same time, you can be strict about the shape.</p>
			<p>The DLR can be a powerful tool in your toolbox. It provides another approach to dynamically create types and code. Compared to generating intermediate language code, it can come across as more intuitive.</p>
			<p>One of the downsides of the DLR is that the types generated can be hard to work with in a modern IDE or code editor, as it does not know about the types and can’t offer services such as IntelliSense for members.</p>
			<p>Another aspect of using the DLR and a dynamic approach can be performance. It will not be as performant as generating intermediate language code. This is one of the trade-offs you will have to make, but for specific scenarios, that might not be an issue at all.</p>
			<p>In the next chapter, we will shift gears a little bit and look at how we can take advantage of some of the techniques we’ve discussed so far in the book and start thinking in terms of <strong class="bo d">convention </strong><strong class="bo d">over configuration</strong>.</p>
		</div>
	

		<div><h1 id="_idParaDest-110"><a id="_idTextAnchor161"/>Part 3:Increasing Productivity, Consistency, and Quality</h1>
			<p>In this part, you will see how metaprogramming can be used to improve code quality and leave you with a more maintainable and consistent code base. At the same time, this part gives you ideas on how techniques can improve the productivity of you and your developers. The different chapters touch on principles and software design patterns and how they can be used in real life.</p>
			<p>This part has the following chapters:</p>
			<ul>
				<li><a href="B19418_10.xhtml#_idTextAnchor162"><em class="ita ic">Chapter 10</em></a>, <em class="ita ic">Convention over Configuration</em></li>
				<li><a href="B19418_11.xhtml#_idTextAnchor177"><em class="ita ic">Chapter 11</em></a>, <em class="ita ic">Applying the Open-Closed Principle</em></li>
				<li><a href="B19418_12.xhtml#_idTextAnchor196"><em class="ita ic">Chapter 12</em></a>, <em class="ita ic">Go Beyond Inheritance</em></li>
				<li><a href="B19418_13.xhtml#_idTextAnchor206"><em class="ita ic">Chapter 13</em></a>, <em class="ita ic">Applying Cross-Cutting Concerns</em></li>
				<li><a href="B19418_14.xhtml#_idTextAnchor219"><em class="ita ic">Chapter 14</em></a>, <em class="ita ic">Aspect-Oriented Programming</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</body></html>