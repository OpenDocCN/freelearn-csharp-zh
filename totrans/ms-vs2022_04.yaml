- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Performance Optimization and Profiling
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能优化和性能分析
- en: In this chapter, we delve into the crucial aspect of ensuring that our code
    not only functions correctly but also runs efficiently. While writing code that
    works is essential, optimizing its performance is equally vital, especially in
    today’s fast-paced digital landscape where users expect swift and responsive applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨确保我们的代码不仅正确运行，而且运行高效的至关重要的方面。虽然编写能够工作的代码是必要的，但优化其性能同样重要，尤其是在当今快节奏的数字环境中，用户期望快速响应的应用程序。
- en: In the preceding chapters, we laid the groundwork by mastering unit testing,
    **test-driven development** ( **TDD** ), advanced debugging strategies, and code
    analysis. Now, we shift our focus to the optimization and profiling tools available
    within Visual Studio 2022, empowering ourselves to fine-tune our applications
    for optimal performance.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们通过掌握单元测试、**测试驱动开发**（**TDD**）、高级调试策略和代码分析，打下了基础。现在，我们将焦点转向Visual Studio
    2022中可用的优化和性能分析工具，以便我们能够对应用程序进行微调，以实现最佳性能。
- en: Throughout this chapter, we will explore various techniques and methodologies
    aimed at enhancing the speed, responsiveness, and resource efficiency of our software.
    We’ll begin by introducing the fundamentals of performance optimization and the
    importance of utilizing profiling tools to identify bottlenecks and areas for
    improvement.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨各种旨在提高软件速度、响应性和资源效率的技术和方法。我们将从介绍性能优化的基础和利用性能分析工具来识别瓶颈和改进区域的重要性开始。
- en: 'Key topics covered in this chapter include the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的关键主题包括以下内容：
- en: Introduction to performance optimization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能优化简介
- en: Utilizing Visual Studio profiling tools
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Visual Studio性能分析工具
- en: Analyzing CPU usage
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析CPU使用情况
- en: Memory profiling and optimization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存性能分析和优化
- en: Optimizing database interaction
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化数据库交互
- en: By mastering these concepts and techniques, we’ll learn how to pinpoint performance
    issues, optimize critical sections of our code base, and ensure that our applications
    deliver a seamless user experience under various workloads and conditions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通过掌握这些概念和技术，我们将学习如何定位性能问题，优化代码库的关键部分，并确保我们的应用程序在各种工作负载和条件下提供无缝的用户体验。
- en: Let’s begin our journey toward building faster, more efficient software together.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们共同踏上构建更快、更高效软件的旅程。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'While writing this chapter, I used the following version of Visual Studio:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本章时，我使用了以下版本的Visual Studio：
- en: Visual Studio Enterprise 2022 Version 17.12.0
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Enterprise 2022 版本 17.12.0
- en: Preview 1.0
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预览1.0
- en: The code files for this chapter can found at [https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch04](https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch04)
    .
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在[https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch04](https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch04)找到。
- en: Introduction to performance optimization
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能优化简介
- en: Performance optimization in software development involves refining an application
    to operate with maximum efficiency, minimizing resource consumption such as memory,
    CPU, and bandwidth. This process includes analyzing performance at various development
    stages, often focusing on enhancing efficiency once a stable version of the product
    has been established.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发中的性能优化涉及对应用程序进行精炼，使其以最大效率运行，最小化资源消耗，如内存、CPU和带宽。这个过程包括分析各个开发阶段的表现，通常在产品稳定版本确立后，会着重提高效率。
- en: The main step in our performance optimization process is *identifying bottlenecks*
    , as it allows us to pinpoint the specific areas of our code that are causing
    performance issues. **Bottlenecks** are points in our code where the execution
    slows down significantly, often due to resource constraints or inefficient algorithms.
    By identifying these bottlenecks, we can focus our optimization efforts on where
    they will have the most impact, leading to more efficient and faster applications.
    This targeted approach not only improves the performance of our application but
    also enhances the overall user experience by reducing load times and improving
    responsiveness. Furthermore, identifying bottlenecks early in the development
    process can prevent costly rework and delays, as it becomes more economical to
    address performance issues before they become entrenched in our application’s
    architecture. In essence, the ability to identify and address bottlenecks is a
    key skill for us as developers aiming to create high-performance applications,
    ensuring that our software runs smoothly and efficiently.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们性能优化过程中的主要步骤是*识别瓶颈*，因为这使我们能够确定代码中导致性能问题的具体区域。**瓶颈**是代码中执行速度显著减慢的点，通常是由于资源限制或效率低下的算法。通过识别这些瓶颈，我们可以将优化努力集中在最能产生影响的领域，从而实现更高效、更快的应用程序。这种有针对性的方法不仅提高了应用程序的性能，还通过减少加载时间和提高响应速度来增强整体用户体验。此外，在开发早期阶段识别瓶颈可以防止昂贵的返工和延误，因为在问题根深蒂固于我们应用程序的架构之前解决性能问题更为经济。本质上，识别和解决瓶颈的能力是我们作为开发者创造高性能应用程序的关键技能，确保我们的软件运行顺畅且高效。
- en: 'Performance optimization could be performed at different levels and offers
    different paths of exploration:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 性能优化可以在不同的层面上进行，并提供了不同的探索路径：
- en: At the design level, the architecture of the system plays a crucial role in
    its performance. Designing with performance in mind involves making strategic
    decisions about how the system interacts with hardware and network resources.
    For instance, reducing network latency can be achieved by minimizing network requests,
    ideally making a single request instead of multiple. This approach not only reduces
    the load on the network but also simplifies the application’s architecture, making
    it easier to maintain and scale.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设计层面，系统的架构在其性能中起着至关重要的作用。以性能为导向的设计涉及对系统如何与硬件和网络资源交互做出战略决策。例如，通过最小化网络请求可以降低网络延迟，理想情况下是一次请求而不是多次。这种方法不仅减少了网络负载，还简化了应用程序的架构，使其更容易维护和扩展。
- en: Implementation choices in the source code also have a significant impact on
    system optimization. Employing efficient coding practices is crucial for achieving
    system optimization. This includes avoiding unnecessary computations, which can
    significantly reduce the computational overhead of the application. For example,
    using **Language-Integrated Query** ( **LINQ** ) for data manipulation can lead
    to code that is more readable yet potentially more efficient than traditional
    loops. Additionally, utilizing C#’s asynchronous programming features, such as
    async and await, can help to improve the responsiveness of applications by allowing
    them to perform other tasks while waiting for long-running operations to complete.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码中的实现选择也对系统优化有重大影响。采用高效的编码实践对于实现系统优化至关重要。这包括避免不必要的计算，这可以显著减少应用程序的计算开销。例如，使用**语言集成查询**（**LINQ**）进行数据处理可以生成比传统循环更易读且可能更高效的代码。此外，利用C#的异步编程功能，如async和await，可以通过允许应用程序在等待长时间运行的操作完成时执行其他任务来提高应用程序的响应速度。
- en: The choice of algorithms and data structures is a critical factor in system
    performance. Efficient algorithms and data structures can significantly reduce
    the time complexity of operations, allowing the system to handle larger datasets
    and more complex tasks with ease. Ideally, algorithms should operate at constant
    (O(1)), logarithmic (O(log n)), linear (O(n)), or log-linear (O(n log n)) time
    complexities. Algorithms with quadratic complexity (O(n^2)) can struggle to scale
    efficiently, especially as the size of the dataset grows. Similarly, abstract
    data types, which encapsulate data and operations in a single entity, can be more
    efficient for system optimization compared to more complex data structures.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法和数据结构的选择是系统性能的关键因素。高效的算法和数据结构可以显著降低操作的时间复杂度，使系统能够轻松处理更大的数据集和更复杂的任务。理想情况下，算法应该以常数（O(1)）、对数（O(log
    n)）、线性（O(n)）或对数线性（O(n log n)）的时间复杂度运行。具有二次复杂度（O(n^2)）的算法在数据集规模增长时可能难以高效扩展。同样，封装数据和操作的抽象数据类型，与更复杂的数据结构相比，可能对系统优化更有效。
- en: Optimizing at the build level involves making decisions during the build process
    that can tailor the application for specific processor models or environments.
    This can include disabling unnecessary software features, which can reduce the
    size of the executable and improve its performance. Additionally, build-level
    optimizations can involve the use of compiler flags that enable specific optimizations,
    such as loop unrolling or function inlining, which can improve the efficiency
    of the generated code.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建级别进行优化涉及在构建过程中做出决策，这些决策可以使应用程序针对特定的处理器模型或环境进行定制。这可能包括禁用不必要的软件功能，从而减小可执行文件的大小并提高其性能。此外，构建级别的优化可能涉及使用编译器标志启用特定的优化，例如循环展开或函数内联，这可以提高生成代码的效率。
- en: You may have noticed that I categorized the algorithm by complexity using Big
    O notation; let’s take a refresher about this notation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我使用 Big O 表示法根据复杂度对算法进行了分类；让我们回顾一下这个表示法。
- en: Big O notation serves as a mathematical representation utilized to characterize
    the performance or complexity of algorithms, particularly concerning their runtime
    behavior with increasing input size.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Big O 表示法是一种数学表示，用于描述算法的性能或复杂度，特别是关于它们随着输入大小增加的运行时行为。
- en: Proficiency in understanding Big O notation holds significant importance for
    software engineers. It equips us with the ability to evaluate and contrast the
    efficiency of diverse algorithms. Consequently, we can make well-informed decisions
    regarding the selection of algorithms suitable for specific scenarios.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 Big O 表示法对于软件工程师来说非常重要。它使我们能够评估和对比不同算法的效率。因此，我们可以就选择适合特定场景的算法做出明智的决定。
- en: 'The following points outline the well-known Big O notations:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点概述了著名的 Big O 表示法：
- en: '**Constant time O(1)** : Execution time remains unchanged irrespective of input
    data'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常数时间 O(1)**：无论输入数据如何，执行时间保持不变'
- en: '**Logarithmic time O(log n)** : Complexity increases by one unit for each doubling
    of input data'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对数时间 O(log n)**：对于输入数据的每次加倍，复杂度增加一个单位'
- en: '**Linear time O(n)** : Execution time increases linearly with the size of the
    input data'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线性时间 O(n)**：执行时间随着输入数据大小的增加而线性增长'
- en: '**Log-linear time O(n log n)** : Complexity grows as a combination of linear
    and logarithmic'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对数线性时间 O(n log n)**：复杂度随着线性和对数的组合增长'
- en: '**Quadratic time O(n^2)** : Time taken is proportional to the square of the
    number of elements'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二次时间 O(n^2)**：所需时间与元素数量的平方成正比'
- en: '**Cubic time O(n^3)** : Execution time is proportional to the cube of the number
    of elements'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**立方时间 O(n^3)**：所需时间与元素数量的立方成正比'
- en: '**Exponential time O(2^n)** : Time doubles for every new element added'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指数时间 O(2^n)**：每增加一个新元素，时间翻倍'
- en: '**Factorial time O(n!)** : Complexity grows factorially based on the size of
    the dataset'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阶乘时间 O(n!)**：复杂度根据数据集的大小以阶乘方式增长'
- en: Now that we’ve explored the fundamental principles of performance optimization
    in software development, let’s delve into practical methods for identifying and
    addressing performance issues. Some invaluable tools for our endeavor are Visual
    Studio profiling tools. By leveraging the capabilities of these tools, we can
    gain deeper insights into our application’s performance and streamline the optimization
    process. Let’s examine how Visual Studio profiling tools can be effectively utilized
    to enhance the performance of our software applications.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经探讨了软件开发中性能优化的基本原理，让我们深入了解识别和解决性能问题的实际方法。在我们的努力中，Visual Studio 性能分析工具是一套宝贵的工具。通过利用这些工具的功能，我们可以更深入地了解应用程序的性能，并简化优化过程。让我们看看如何有效地利用
    Visual Studio 性能分析工具来提高我们的软件应用程序的性能。
- en: Utilizing Visual Studio profiling tools
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用 Visual Studio 性能分析工具
- en: Visual Studio profiling tools are a suite of performance measurement and diagnostic
    tools integrated into Visual Studio. In this section, we will explore how to use
    it and explore what tools are offered to explore and monitor our applications.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 性能分析工具是一套集成到 Visual Studio 中的性能测量和诊断工具。在本节中，我们将探讨如何使用它，并探索提供的工具以探索和监控我们的应用程序。
- en: To open the Performance Profiler, we go to **Debug** | **Performance Profiler**
    or press *Alt* + *F2* .
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开性能分析器，我们前往 **调试** | **性能分析器** 或按 *Alt* + *F2*。
- en: '![Figure 4.1 – Performance Profiler](img/B22218_04_1.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 性能分析器](img/B22218_04_1.jpg)'
- en: Figure 4.1 – Performance Profiler
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 性能分析器
- en: Before clicking on the **Start** button, let’s review the various options the
    Performance Analyzer feature offers us for profiling our applications.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在点击 **开始** 按钮之前，让我们回顾性能分析器功能提供的各种选项，以便对应用程序进行性能分析。
- en: Analyzing .NET asynchronous events
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析 .NET 异步事件
- en: .NET’s async and await features allow us to analyze the asynchronous events
    that are organized chronologically, displaying start time, end time, and duration,
    in a table of activities that occurred during our profiling session. Tasks are
    labeled in the **Name** column.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 的异步和 await 功能允许我们分析按时间顺序组织的事件，以表格形式显示活动发生时的开始时间、结束时间和持续时间。任务在 **名称** 列中标出。
- en: '![Figure 4.2 – .NET Async](img/B22218_04_2.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – .NET 异步](img/B22218_04_2.jpg)'
- en: Figure 4.2 – .NET Async
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – .NET 异步
- en: If a task isn’t complete within the collection session, an *Incomplete* label
    appears in the **End** **Time** column.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在收集会话期间任务未完成，**结束时间**列将出现一个 **不完整** 标签。
- en: To investigate a specific task or activity, we can right-click the row and select
    **Go To Source File** to see where in our code that activity happened.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要调查特定的任务或活动，我们可以右键单击该行并选择 **转到源文件**，以查看该活动发生在我们代码的哪个位置。
- en: Understanding the characteristics of async performance is crucial. While async
    methods are meant to enhance application responsiveness and scalability, they
    do introduce some overhead due to the state machine created by the compiler. However,
    this overhead is generally minimal and efficient for high-throughput scenarios.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 理解异步性能的特征至关重要。虽然异步方法旨在提高应用程序的响应性和可伸缩性，但它们确实由于编译器创建的状态机而引入了一些开销。然而，这种开销通常很小，对于高吞吐量场景来说效率很高。
- en: When comparing the performance of async versus sync code, we need to consider
    the nature of the operations being performed. For operations inherently asynchronous
    (such as **input/output** ( **I/O** )-bound operations), async methods can provide
    significant performance benefits by freeing up threads to handle other requests
    while waiting. However, for CPU-bound operations, the performance difference between
    async and sync methods may be negligible.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当比较异步代码与同步代码的性能时，我们需要考虑所执行操作的性质。对于本质上异步的操作（如 **输入/输出** ( **I/O** )-bound 操作），异步方法可以通过在等待时释放线程来处理其他请求，从而提供显著的性能优势。然而，对于
    CPU-bound 操作，异步和同步方法之间的性能差异可能微不足道。
- en: For effective performance monitoring of our application using .NET’s async and
    await features, we can utilize the **.NET Async** tool in Visual Studio for detailed
    analysis of asynchronous code execution. Additionally, external tools such as
    Stackify Retrace offer comprehensive monitoring capabilities for .NET applications,
    including support for async/await. Understanding the performance characteristics
    of async methods and the nature of the operations being performed is crucial for
    making informed decisions about when to employ async programming patterns.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地使用 .NET 的异步和等待功能监控我们的应用程序性能，我们可以利用 Visual Studio 中的 **.NET 异步** 工具进行异步代码执行的详细分析。此外，像
    Stackify Retrace 这样的外部工具为 .NET 应用程序提供全面的监控能力，包括对异步/等待的支持。了解异步方法的表现特性和执行操作的本质对于做出何时采用异步编程模式的明智决策至关重要。
- en: Monitoring with .NET Counters
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 .NET 计数器进行监控
- en: Visual Studio 2022 integrates the . **NET Counters** tool, which is an advanced
    feature that allows developers like us to visualize performance counters over
    time directly within the Visual Studio profiler. This tool proves to be particularly
    useful for monitoring and analyzing various metrics of .NET applications, such
    as CPU usage, garbage collector heap size, and any custom counters we might have
    implemented in our applications. This integration enables us to leverage the power
    of .NET Counters directly from within the Visual Studio environment, providing
    a more seamless and integrated experience for performance monitoring and analysis.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2022 集成了 **.NET Counters** 工具，这是一个高级功能，允许我们像我们这样的开发者直接在 Visual
    Studio 分析器中可视化性能计数器随时间的变化。此工具证明对于监控和分析 .NET 应用程序的各种指标（如 CPU 使用率、垃圾收集器堆大小以及我们可能在应用程序中实现的任何自定义计数器）特别有用。这种集成使我们能够直接从
    Visual Studio 环境中利用 .NET Counters 的功能，为性能监控和分析提供更流畅和集成的体验。
- en: 'Visual Studio 2022 enhanced the .NET Counters tool to support two innovative
    metrics: **UpDownCounter** and **ObservableCounter** . **UpDownCounter** enables
    real-time tracking of values with both incremental and decremental changes, which
    is ideal for monitoring dynamic values such as user interactions in web applications.
    On the other hand, **ObservableCounter** autonomously manages aggregated totals,
    offering customizable callback delegates for precise control. This feature can
    be particularly useful for optimizing server resources by efficiently managing
    active session totals.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2022 增强了 .NET 计数器工具以支持两个创新指标：**UpDownCounter** 和 **ObservableCounter**。**UpDownCounter**
    允许实时跟踪具有递增和递减变化的值，这对于监控如网络应用程序中的用户交互等动态值非常理想。另一方面，**ObservableCounter** 自动管理聚合总数，提供可定制的回调委托以实现精确控制。此功能可以通过有效管理活动会话总数来特别有用，从而优化服务器资源。
- en: Additionally, a filter flyout feature in the tool allows us to conveniently
    filter data points based on tags. This dynamic adjustment feature significantly
    enhances the flexibility and streamlining of monitoring dynamic values in our
    projects.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，工具中的过滤器弹出功能使我们能够方便地根据标签过滤数据点。此动态调整功能显著增强了我们在项目中监控动态值的灵活性和流程化。
- en: While collecting data, we can see live values of .NET Counters and view graphs
    of multiple counters simultaneously.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在收集数据时，我们可以看到 .NET 计数器的实时值，并同时查看多个计数器的图表。
- en: '![Figure 4.3 – .NET Counters](img/B22218_04_3.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – .NET 计数器](img/B22218_04_3.jpg)'
- en: Figure 4.3 – .NET Counters
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – .NET 计数器
- en: Once we stop collection, we get a detailed report showing minimum, maximum,
    and average values for each counter in the selected time range. This report provides
    us with a comprehensive overview of the performance metrics of our application,
    helping us identify and address performance bottlenecks more effectively.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们停止收集，我们就会得到一份详细的报告，显示所选时间范围内每个计数器的最小值、最大值和平均值。这份报告为我们提供了应用程序性能指标的综合概述，帮助我们更有效地识别和解决性能瓶颈。
- en: Tracking .NET Object Allocation
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪 .NET 对象分配
- en: The **.NET Object Allocation Tracking** tool proves particularly valuable for
    understanding allocation patterns in .NET code and optimizing an application’s
    memory usage by identifying the most memory-intensive methods. However, it’s important
    to note that while this tool can reveal where objects are allocated, it does not
    elucidate why an object remains in memory.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**.NET 对象分配跟踪** 工具对于理解 .NET 代码中的分配模式以及通过识别最占用内存的方法来优化应用程序的内存使用非常有价值。然而，需要注意的是，虽然此工具可以揭示对象分配的位置，但它并不能阐明对象为何保留在内存中。'
- en: We initiate the tool by clicking on the **Start** button, and the tool offers
    the **Start with collection paused** option before starting the profiler if we
    prefer to commence with data collection paused.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过点击**开始**按钮来启动工具，如果我们在开始分析器之前希望数据收集暂停，工具会提供**开始时收集暂停**选项。
- en: '![Figure 4.4 – Start analysis](img/B22218_04_4.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4 – 开始分析](img/B22218_04_4.jpg)'
- en: Figure 4.4 – Start analysis
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 开始分析
- en: This allows us to manually commence data collection by clicking the **Record**
    button in the diagnostic session view.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们通过在诊断会话视图中点击**记录**按钮手动开始数据收集。
- en: After executing the tool, we can halt the collection or close our application
    to review the data. The tool furnishes comprehensive memory allocation data, including
    the location of objects that are allocating memory and the amount of memory those
    objects are allocating. It also displays the number of objects that occupy memory
    within a specific allocation type or function, as well as the amount of memory
    consumed instead of the number of objects.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 执行工具后，我们可以停止收集数据或关闭我们的应用程序以审查数据。该工具提供了全面的内存分配数据，包括分配内存的对象的位置以及这些对象分配的内存量。它还显示了在特定分配类型或函数中占用内存的对象数量，以及消耗的内存量而不是对象数量。
- en: Additionally, the tool presents a **Collections** view, which illustrates how
    many objects were collected or retained during garbage collection, offering insights
    into garbage collection events such as the type of garbage collection, the reason
    for the event, and the size of the **large object heap** ( **LOH** ) and **pinned
    object heap** ( **POH** ) after the garbage collector was executed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，该工具还提供了一个**收集**视图，展示了在垃圾回收期间收集或保留的对象数量，为我们提供了有关垃圾回收事件（如垃圾回收类型、事件原因以及垃圾回收器执行后**大对象堆**（**LOH**）和**固定对象堆**（**POH**）的大小）的见解。
- en: Viewing the event
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看事件
- en: The **Events** **Viewer** tool allows us to examine the collected information
    after our application has stopped, like a post-mortem analysis. It displays a
    list of events such as module load, thread start, and system configuration, aiding
    in diagnosing our application’s performance within the Visual Studio profiler.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件查看器**工具允许我们在应用程序停止后检查收集到的信息，就像尸检分析一样。它显示了一个事件列表，如模块加载、线程启动和系统配置，有助于在Visual
    Studio分析器中诊断我们的应用程序性能。'
- en: To enable custom **Event Tracing for Windows** ( **ETW** ) events, we can instrument
    our code with custom events and configure them to appear in the Events Viewer.
    This involves setting up the provider’s name and GUID for our custom event code.
    For C# custom event code, we set the same provider’s name value that we used when
    declaring our event code, and for the native custom event code, we set the provider
    GUID based on the GUID for the custom event code. Once configured, these custom
    events will appear in the Events Viewer when we collect a diagnostics trace.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用自定义**Windows事件跟踪**（**ETW**）事件，我们可以使用自定义事件对代码进行操作，并配置它们在事件查看器中显示。这涉及到设置提供程序名称和GUID以用于我们的自定义事件代码。对于C#自定义事件代码，我们设置与声明事件代码时相同的提供程序名称值，而对于本地自定义事件代码，我们根据自定义事件代码的GUID设置提供程序GUID。一旦配置完成，这些自定义事件将在我们收集诊断跟踪时在事件查看器中显示。
- en: The Events Viewer can display up to 20,000 events at a time. To focus on specific
    events, we can filter the display by selecting the **Event** filter. Additionally,
    we can see the percentage of the total number of events that occurred for each
    provider, providing a breakdown of where our time is being spent. This filtering
    and breakdown help in identifying the most relevant events for our analysis.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 事件查看器一次可以显示多达20,000个事件。为了关注特定事件，我们可以通过选择**事件**过滤器来过滤显示。此外，我们还可以看到每个提供程序发生的总事件数的百分比，提供了我们时间花费的细分。这种过滤和细分有助于识别分析中最相关的事件。
- en: 'For example, to enable custom ETW events:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要启用自定义ETW事件：
- en: First, build our custom event code.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，构建我们的自定义事件代码。
- en: Then, in the **Performance Profiler** window (accessed via *Alt* + *F2* ), enable
    **Events Viewer** and select the **Settings** icon next to it.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在**性能分析器**窗口（通过*Alt* + *F2*访问），启用**事件查看器**并选择其旁边的**设置**图标。
- en: In the dialog box, enable the first row under **Additional Providers** and configure
    it according to our custom event code.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对话框中，启用**附加提供程序**下的第一行，并根据我们的自定义事件代码进行配置。
- en: For native custom event code, we set the **Provider GUID** value and leave the
    **Provider Name** value empty or use its default value.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于本机自定义事件代码，我们设置**提供者GUID**值，并将**提供者名称**值留空或使用其默认值。
- en: For C# custom event code, we set the same **Provider Name** value that we used
    when declaring our event code, leaving the **Provider GUID** empty. After configuration,
    our custom events will appear in the Events Viewer when we collect a diagnostics
    trace.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于C#的自定义事件代码，我们在声明事件代码时设置了相同的**提供者名称**值，并将**提供者GUID**留空。配置完成后，当我们收集诊断跟踪时，我们的自定义事件将出现在事件查看器中。
- en: This tool is particularly useful for us as developers looking to diagnose performance
    issues or understand the behavior of our applications in detail. It provides a
    comprehensive view of our application’s activity and performance metrics.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们这些希望诊断性能问题或详细了解应用程序行为的开发者来说，此工具特别有用。它为我们应用程序的活动和性能指标提供了一个全面的视图。
- en: Analyzing File I/O
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析文件I/O
- en: The **File IO** tool in Visual Studio is a powerful profiling tool designed
    to help us optimize our file I/O operations, thereby improving the performance
    of our applications. This tool is particularly useful for diagnosing slow loading
    times and inefficient data read or write patterns. It provides detailed information
    about file read and write operations during a profiling session, including the
    files accessed, the target process for each file, and aggregate information for
    each file. The tool also offers features such as the **Duplication Factor** ,
    which helps us identify whether more data is being read or written than necessary,
    indicating potential areas for optimization, such as caching results of file reads.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio中的**文件I/O**工具是一个强大的分析工具，旨在帮助我们优化文件I/O操作，从而提高我们应用程序的性能。此工具特别适用于诊断缓慢的加载时间和低效的数据读取或写入模式。它提供了在分析会话期间关于文件读取和写入操作的详细信息，包括访问的文件、每个文件的目标进程以及每个文件的汇总信息。该工具还提供诸如**重复因子**等功能，帮助我们确定是否读取或写入比必要更多的数据，这表明了潜在的优化区域，例如缓存文件读取的结果。
- en: The File IO tool provides file read and write information with files read during
    the profiling session. The files are autogenerated in a report after collection
    and arranged by their target process with aggregate information displayed. If
    we right-click on one of the rows, we can go to the source in our code. If an
    aggregate row was read multiple times, we can expand it to see the individual
    read operations for that file with its frequency, if they were read multiple times.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 文件I/O工具提供了在分析会话期间读取的文件读取和写入信息。收集后，文件会自动生成在报告中，并按其目标进程排列，显示汇总信息。如果我们右键单击其中一行，我们可以进入代码中的源。如果一个汇总行被读取多次，我们可以展开它以查看该文件的个别读取操作及其频率，如果它们被多次读取。
- en: Analyzing database performance
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析数据库性能
- en: The **Database Profiler** tool in Visual Studio is a feature designed to help
    us developers diagnose and optimize the performance of database operations within
    our applications. It proves particularly useful for applications that use .NET
    Core with either ADO.NET or Entity Framework Core, offering insights into database
    activities such as query execution times, the connection strings used, and where
    in the code these queries are being made. This tool is part of the Performance
    Profiler in Visual Studio and has been available since Visual Studio 2019 version
    16.3 onwards.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio中的**数据库分析器**工具是一个旨在帮助我们开发者诊断和优化应用程序中数据库操作性能的功能。它对于使用ADO.NET或Entity
    Framework Core的.NET Core应用程序特别有用，提供了关于数据库活动（如查询执行时间、使用的连接字符串以及这些查询在代码中的位置）的见解。此工具是Visual
    Studio中的性能分析器的一部分，自Visual Studio 2019版本16.3以来一直可用。
- en: Once we start the profiling session, we interact with our application as we
    would normally, performing actions that we suspect might be causing database performance
    issues. After completing our actions, we stop the collection in Visual Studio.
    The tool then processes the collected data and displays a table of the queries
    that occurred during our profiling session, along with a graph showing the timing
    and frequency of these queries. This information can help us identify long-running
    queries, inefficient connection strings, or other performance bottlenecks in our
    database operations.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始分析会话，我们就像平时一样与我们的应用程序交互，执行我们怀疑可能引起数据库性能问题的操作。完成我们的操作后，我们在Visual Studio中停止收集。然后，该工具处理收集到的数据，并显示在我们分析会话期间发生的查询表，以及显示这些查询的时序和频率的图表。这些信息可以帮助我们识别长时间运行的查询、低效的连接字符串或数据库操作中的其他性能瓶颈。
- en: Furthermore, the Database Profiler tool supports analyzing traces collected
    using dotnet trace, allowing us to collect data from anywhere .NET Core runs,
    including Linux, and analyze it in Visual Studio. This feature is particularly
    useful for diagnosing performance issues in environments where Visual Studio is
    not installed or for scripting the collection of performance traces.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，数据库分析工具支持分析使用dotnet trace收集的跟踪，允许我们从.NET Core运行的任何地方收集数据，包括Linux，并在Visual
    Studio中进行分析。这个特性特别适用于诊断在没有安装Visual Studio的环境中或用于脚本化性能跟踪收集的环境中的性能问题。
- en: In summary, the Database Profiler tool in Visual Studio is a powerful diagnostic
    tool for us developers working with .NET Core applications that interact with
    databases. It provides detailed insights into database operations, helping us
    identify and resolve performance issues more effectively.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Visual Studio中的数据库分析工具是我们这些与数据库交互的.NET Core应用程序的开发者强大的诊断工具。它提供了对数据库操作的详细洞察，帮助我们更有效地识别和解决性能问题。
- en: Instrumenting our .NET applications
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仪器化我们的.NET应用程序
- en: 'In Visual Studio, we utilize instrumentation tools for collecting precise call
    counts and call times, which are crucial for performance profiling and optimization.
    There are two main types of instrumentation methods available:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中，我们使用仪器工具来收集精确的调用次数和调用时间，这对于性能分析和优化至关重要。有两种主要的仪器方法可用：
- en: '**Static instrumentation** : This method involves modifying the program’s files
    before they run. We use a tool called VSInstr to insert instrumentation code into
    the application’s binaries. Static instrumentation is effective for collecting
    detailed timing data but can break strong name signing due to file modification.
    It also requires files to be deployed in a specific order, which can be cumbersome
    for complex programs.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态仪器**：这种方法涉及在程序运行之前修改程序的文件。我们使用名为VSInstr的工具将仪器代码插入到应用程序的二进制文件中。静态仪器对于收集详细的时序数据非常有效，但由于文件修改可能会破坏强名称签名。它还要求文件以特定的顺序部署，这对于复杂的程序来说可能很麻烦。'
- en: '**Dynamic instrumentation** : Introduced in Visual Studio 2022 version 17.5,
    this method does not alter the program’s files. Instead, it loads the files into
    memory and modifies them at runtime to collect instrumentation information. Dynamic
    instrumentation provides more accurate information, especially for smaller parts
    of the program, and allows for the investigation of specific code sections. It
    avoids the issue of breaking strong name signing since the instrumentation happens
    at runtime. This approach simplifies the process of finding and instrumenting
    files, especially in complex programs.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态仪器**：在Visual Studio 2022版本17.5中引入，这种方法不会修改程序的文件。相反，它将文件加载到内存中并在运行时修改它们以收集仪器信息。动态仪器提供了更准确的信息，特别是对于程序的小部分，并允许调查特定的代码部分。由于仪器在运行时发生，因此避免了破坏强名称签名的问题。这种方法简化了查找和仪器文件的过程，尤其是在复杂的程序中。'
- en: This tool is like the CPU Usage tool but focuses on wall clock time instead
    of CPU utilization, making it suitable for scenarios where understanding the execution
    time of functions is critical.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具类似于CPU使用工具，但专注于墙钟时间而不是CPU利用率，这使得它在理解函数执行时间至关重要的场景中适用。
- en: By using the aforementioned tools, we can gather valuable insights into our
    application’s performance.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用上述工具，我们可以收集关于我们应用程序性能的宝贵见解。
- en: However, to ensure optimal accuracy in our performance measurements, it’s advisable
    to profile our applications in the **Release** mode rather than the **Debug**
    mode. Debug builds can introduce additional overhead, potentially skewing our
    results.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了确保性能测量的最佳准确性，建议我们在**发布**模式下而不是**调试**模式下分析我们的应用程序。调试构建可能会引入额外的开销，从而可能歪曲我们的结果。
- en: When we find ourselves needing to inspect variable values or use breakpoints
    during analysis, we should consider leveraging the debugger-integrated tools found
    in the **Diagnostic Tools** window. These tools are tailored for such tasks and
    may offer a more suitable environment for our analysis.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在分析过程中需要检查变量值或使用断点时，我们应该考虑利用**诊断工具**窗口中找到的集成调试工具。这些工具针对此类任务进行了定制，可能为我们提供更适合的分析环境。
- en: To gain a holistic understanding of our application’s performance, we can take
    advantage of Visual Studio’s capability to utilize multiple profiling tools simultaneously.
    This approach allows us to examine our application’s performance from different
    perspectives, providing a more comprehensive analysis.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了全面了解我们应用程序的性能，我们可以利用Visual Studio同时利用多个分析工具的能力。这种方法允许我们从不同的角度检查应用程序的性能，提供更全面的分析。
- en: You may have noticed that I have missed three tools offered by the Profiler
    Performance tools. I will highlight them in the next sections, beginning with
    the CPU Usage analyzer.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我遗漏了Profiler性能工具提供的三个工具。我将在下一节中突出它们，首先是CPU使用情况分析器。
- en: Analyzing CPU Usage
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析CPU使用情况
- en: The **CPU Usage** tool in Visual Studio is designed to help us identify high
    CPU utilization and other related performance issues in our applications. It can
    be used for both local trace sessions and production environments, providing insights
    into where optimizations might be needed. To use the CPU Usage tool without the
    debugger, we should set the solution configuration to **Release** and select **Local
    Windows Debugger (or Local Machine)** as the deployment target. Under available
    tools, we select **CPU Usage** , and then we select **Start** .
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio中的**CPU使用情况**工具旨在帮助我们识别应用程序中的高CPU利用率和其他相关性能问题。它可以用于本地跟踪会话和生产环境，提供有关可能需要优化的地方的洞察。要使用CPU使用情况工具而不使用调试器，我们应该将解决方案配置设置为**发布**，并将部署目标选择为**本地Windows调试器（或本地计算机）**。在可用工具下，我们选择**CPU使用情况**，然后选择**启动**。
- en: If we enable the start with collection paused option, data collection will not
    begin until we select the **Record** button in the diagnostic session view. After
    the app starts, the diagnostic session begins, displaying CPU usage data. Once
    we’re finished collecting data, we select **Stop Collection** . The tool then
    analyzes the data and displays a report, which can be filtered and searched for
    specific threads or nodes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启用“启动时收集暂停”选项，数据收集将不会开始，直到我们在诊断会话视图中选择**记录**按钮。应用启动后，诊断会话开始，显示CPU使用数据。收集完数据后，我们选择**停止收集**。然后工具分析数据并显示报告，可以过滤和搜索特定线程或节点。
- en: The CPU Usage tool is particularly useful for diagnosing performance issues
    in our code base, identifying bottlenecks, and understanding CPU usage patterns.
    It provides automatic insights and various views of our data, enabling us to analyze
    and diagnose performance issues effectively. This tool is beneficial in production
    and difficult to debug at the moment but can be captured and analyzed using this
    tool to understand potential causes and suggest fixes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: CPU使用情况工具特别适用于诊断我们代码库中的性能问题，识别瓶颈，并理解CPU使用模式。它提供自动洞察和多种数据视图，使我们能够有效地分析和诊断性能问题。此工具在生产环境中很有益，但目前难以调试，但可以使用此工具捕获和分析数据，以了解潜在原因并提出修复建议。
- en: The CPU Usage tool is particularly useful for diagnosing slow-downs, process
    hangs, and identifying bottlenecks in your code base, making it an essential tool
    for optimizing application performance.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: CPU使用情况工具特别适用于诊断减速、进程挂起以及识别代码库中的瓶颈，使其成为优化应用程序性能的必备工具。
- en: When running this profiler tools spot the usage of CPU/second and collect traces
    generating a report with a graph to visualize the peak and valley of CPU usage.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此分析工具时，它会检测每秒的CPU使用情况并收集跟踪信息，生成一个包含图表的报告以可视化CPU使用的峰值和谷值。
- en: When we first start the CPU Usage toll, it will collect a large amount of data
    per second to analyze what is going on in our application, and by default, it’s
    set at **1000** samples/second.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次启动 CPU 使用率工具时，它将每秒收集大量数据以分析应用程序中的情况，默认设置为**1000**样本/秒。
- en: We can personalize the rate of the number of samples collected by second, by
    clicking on the gear at the right of the **CPU Usage** label in the profile console
    ( *Figure 4* *.1* ) before hitting the **Start** button. Depending on our needs,
    we can adjust the accuracy of their results and the data collection time.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过点击配置控制台**CPU 使用率**标签右侧的齿轮，在点击**开始**按钮之前，来个性化设置每秒收集样本的数量（*图 4.1*）。根据我们的需求，我们可以调整结果的准确性和数据收集时间。
- en: '![Figure 4.5 – The CPU Usage settings](img/B22218_04_5.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – CPU 使用率设置](img/B22218_04_5.jpg)'
- en: Figure 4.5 – The CPU Usage settings
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – CPU 使用率设置
- en: When we stop the collection or shut down our application, CPU usage tools generate
    reports. Initially, we land on the summary page, which displays a swim lane graph,
    the **Top Functions** section, and the **Hot** **Path** section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们停止收集或关闭我们的应用程序时，CPU 使用率工具会生成报告。最初，我们会进入摘要页面，该页面显示泳道图、**顶级函数**部分和**热点路径**部分。
- en: '![Figure 4.6 – The Summary page](img/B22218_04_6.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – 摘要页面](img/B22218_04_6.jpg)'
- en: Figure 4.6 – The Summary page
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 摘要页面
- en: Here, we can narrow down the potential bottleneck by right-clicking and dragging
    on the graph to surround the peak we want to focus on. By doing that, we effectively
    filter the graph by time.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以通过右键单击并拖动图形来包围我们想要关注的峰值，从而缩小潜在的瓶颈。通过这样做，我们实际上通过时间过滤了图形。
- en: 'By clicking on the **Open details…** link, we can digg deeper into the five
    other views:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击**打开详细信息…**链接，我们可以深入了解其他五个视图：
- en: '**Caller/Callee**'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用者/被调用者**'
- en: '**Call Tree**'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用树**'
- en: '**Modules**'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块**'
- en: '**Functions**'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数**'
- en: '**Flame Graph**'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**火焰图**'
- en: 'Let’s understand each of these in detail:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解每个部分：
- en: In the **Caller/Callee** view, we can observe the relationship between a selected
    function and the functions that called it ( **Calling Functions** ) as well as
    the functions it called ( **Called Functions** ). It offers insights into the
    total time taken by the selected function and its percentage of the overall app
    running time. Additionally, it provides information on the time spent exclusively
    in the function body ( **Function Body** ). This view helps us understand the
    impact of a function on the application’s performance and identify potential bottlenecks.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**调用者/被调用者**视图中，我们可以观察所选函数与其被调用的函数（**调用函数**）以及它调用的函数（**被调用函数**）之间的关系。它提供了关于所选函数所花费的总时间和其在整个应用程序运行时间中所占百分比的见解。此外，它还提供了关于仅在函数体中花费的时间（**函数体**）的信息。此视图有助于我们了解函数对应用程序性能的影响并识别潜在的瓶颈。
- en: '![Figure 4.7 – Caller/Callee](img/B22218_04_7.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 调用者/被调用者](img/B22218_04_7.jpg)'
- en: Figure 4.7 – Caller/Callee
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 调用者/被调用者
- en: The **Call Tree** view presents a hierarchical representation of the function
    calls in our application, starting from the top-level pseudo-node. It includes
    system and framework code (under an **[External Code]** node) as well as user-code
    methods.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用树**视图展示了我们应用程序中函数调用的层次结构表示，从顶级伪节点开始。它包括系统和框架代码（在**[外部代码**]节点下）以及用户代码方法。'
- en: '![Figure 4.8 – The Call Tree view](img/B22218_04_8.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 – 调用树视图](img/B22218_04_8.jpg)'
- en: Figure 4.8 – The Call Tree view
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 调用树视图
- en: This view is useful for understanding the sequence and nesting of function calls,
    aiding in the identification of the most CPU-intensive paths in our application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图有助于了解函数调用的顺序和嵌套，有助于识别应用程序中最占用 CPU 的路径。
- en: In the **Modules** view, we can see a list of modules containing functions,
    which can be particularly useful when analyzing external code.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**模块**视图中，我们可以看到包含函数的模块列表，这在分析外部代码时特别有用。
- en: '![Figure 4.9 – The Modules view](img/B22218_04_9.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9 – 模块视图](img/B22218_04_9.jpg)'
- en: Figure 4.9 – The Modules view
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 模块视图
- en: It helps us understand which modules are contributing the most to CPU usage,
    assisting in the identification of third-party libraries or system components
    that might be impacting performance.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 它帮助我们了解哪些模块对 CPU 使用率贡献最大，有助于识别可能影响性能的第三方库或系统组件。
- en: The **Functions** view lists all the functions in our application, sorted by
    their CPU usage. It provides detailed information such as **Total CPU** (the time
    spent by the function and any functions it called) and **Self CPU** (the time
    spent exclusively in the function body).
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数**视图列出了我们应用程序中的所有函数，按其 CPU 使用率排序。它提供了详细的信息，例如**总 CPU**（函数及其调用的任何函数所花费的时间）和**自
    CPU**（仅在函数体中花费的时间）。'
- en: '![Figure 4.10 – The Functions view](img/B22218_04_10.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10 – 函数视图](img/B22218_04_10.jpg)'
- en: Figure 4.10 – The Functions view
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 函数视图
- en: This view is essential for identifying the most resource-intensive functions
    in our application and focusing on optimization efforts.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这种视图对于识别我们应用程序中最资源密集型的功能并集中优化努力至关重要。
- en: A **flame graph** is a visualization that represents the call stack of our application
    over time. It helps in identifying hot paths, that is sequences of function calls
    that consume a significant amount of CPU time. The width of each function in the
    graph corresponds to the amount of CPU time it consumes, making it easier to spot
    performance bottlenecks. The **Flame Graph** view is particularly useful for understanding
    the overall CPU usage patterns of our application and pinpointing specific areas
    for optimization.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**火焰图**是一种表示我们应用程序随时间推移的调用栈的可视化。它有助于识别热点路径，即消耗大量 CPU 时间的函数调用序列。图中每个函数的宽度对应于它消耗的
    CPU 时间，这使得更容易发现性能瓶颈。**火焰图**视图特别有助于理解我们应用程序的整体 CPU 使用模式，并确定优化的具体区域。'
- en: '![Figure 4.11 – Flame Graph](img/B22218_04_11.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11 – 火焰图](img/B22218_04_11.jpg)'
- en: Figure 4.11 – Flame Graph
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 火焰图
- en: We can flip the view according to our preferences by using the **Flip Flame
    Graph** option and zooming in on our point of interest.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用**翻转火焰图**选项并放大我们的兴趣点来根据我们的偏好翻转视图。
- en: For debugging sessions, the CPU Usage tool can be accessed through the **Diagnostic
    Tools** window, which appears automatically unless turned off. We can select whether
    to see **CPU Usage** , **Memory Usage** , or both, with the **Select Tools** setting
    on the toolbar. The tool is enabled by default for CPU utilization analysis.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于调试会话，可以通过**诊断工具**窗口访问 CPU 使用率工具，该窗口默认自动出现，除非已关闭。我们可以通过工具栏上的**选择工具**设置选择是否查看**CPU
    使用率**、**内存使用率**或两者，工具默认启用以进行 CPU 利用率分析。
- en: When the debugger pauses, the CPU Usage tool in the **Diagnostic Tools** window
    collects information about the functions executing in our application, listing
    the functions performing work and providing a timeline graph for focusing on specific
    segments of the sampling session.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当调试器暂停时，**诊断工具**窗口中的 CPU 使用率工具会收集关于我们应用程序中正在执行的功能的信息，列出执行工作的功能，并提供一个时间线图，以便关注采样会话的特定部分。
- en: While CPU usage and memory usage are related, they do not have a direct correlation.
    The impact of one on the other depends on the specific tasks being performed by
    the applications running on the system. Monitoring both metrics is crucial for
    optimizing system performance and effectively managing energy consumption.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 CPU 使用率和内存使用率相关，但它们之间没有直接相关性。一个对另一个的影响取决于系统上运行的应用程序所执行的具体任务。监控这两个指标对于优化系统性能和有效管理能耗至关重要。
- en: Now that we’ve explored how to analyze CPU usage, let’s continue our journey
    by monitoring memory allocation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了如何分析 CPU 使用率，让我们继续我们的旅程，通过监控内存分配来继续前进。
- en: Memory profiling and optimization
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存分析和优化
- en: Just as a reminder, a memory leak occurs when a computer program mishandles
    memory allocations, leading to unreleased memory that is no longer needed. .NET
    applications are generally less vulnerable to memory leaks due to automatic garbage
    collection and the fact that .NET applications are written in managed code. This
    means that the runtime has control over memory allocation and deallocation. However,
    if we produce code with smells or misuse the disposable pattern, memory leaks
    can still occur.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，当计算机程序错误处理内存分配时，就会发生内存泄漏，导致不再需要的未释放内存。由于自动垃圾回收和.NET应用程序是用托管代码编写的，因此.NET应用程序通常不太容易发生内存泄漏。这意味着运行时控制内存分配和释放。然而，如果我们编写有问题的代码或误用可处置模式，内存泄漏仍然可能发生。
- en: In this section, we will explore how we can leverage Visual Studio to resolve
    memory leaks using the **Memory Usage** profiling tools and then the diagnostic
    tools available while debugging.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何利用 Visual Studio 通过使用**内存使用率**分析工具和调试期间可用的诊断工具来解决内存泄漏。
- en: Using the Memory Usage tools
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内存使用工具
- en: To find and resolve a memory leak, we can use the **Memory Usage** tool in Visual
    Studio. It is a robust profiling feature designed to monitor and analyze our application’s
    memory usage effectively. It supports various application types, including .NET,
    ASP.NET, C++, and mixed-mode applications. This versatile tool can be utilized
    both with and without the debugger, catering to different development scenarios.
    One of its key strengths lies in its ability to identify memory leaks and inefficient
    memory usage patterns.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到和解决内存泄漏，我们可以使用Visual Studio中的**内存使用**工具。这是一个强大的分析功能，旨在有效地监控和分析应用程序的内存使用情况。它支持各种应用程序类型，包括.NET、ASP.NET、C++和混合模式应用程序。这个多功能的工具可以在有和没有调试器的情况下使用，满足不同的开发场景。其关键优势之一在于其识别内存泄漏和低效内存使用模式的能力。
- en: During our diagnostic sessions, the Memory Usage tool provides a timeline graph
    illustrating memory fluctuations as our application runs. This graphical representation
    aids in pinpointing areas of our code that may be collecting or generating data
    inefficiently, potentially leading to memory leaks or excessive memory usage.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的诊断会话期间，内存使用工具提供了一个时间线图，显示了应用程序运行时的内存波动。这种图形表示有助于确定代码中可能收集或生成数据低效的区域，这可能导致内存泄漏或过度使用内存。
- en: '![Figure 4.12 – Memory usage graph](img/B22218_04_12.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图4.12 – 内存使用图](img/B22218_04_12.jpg)'
- en: Figure 4.12 – Memory usage graph
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12 – 内存使用图
- en: We can take detailed snapshots of our application’s memory state at different
    intervals using this tool. These snapshots can then be compared to pinpoint the
    root causes of memory issues. They showcase critical metrics such as the total
    number of objects and bytes in memory, along with the differences between consecutive
    snapshots.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个工具在不同的时间间隔内详细记录应用程序的内存状态快照。然后，我们可以将这些快照进行比较，以确定内存问题的根本原因。它们展示了关键指标，如内存中对象和字节数的总数，以及连续快照之间的差异。
- en: '![Figure 4.13 – The Memory Usage report types](img/B22218_04_13.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图4.13 – 内存使用报告类型](img/B22218_04_13.jpg)'
- en: Figure 4.13 – The Memory Usage report types
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13 – 内存使用报告类型
- en: We can delve deeper into these snapshots through detailed Memory Usage report
    views, gaining insights into the types and instances present in each snapshot
    or the variances between two snapshots.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过详细的内存使用报告视图深入了解这些快照，了解每个快照中存在的类型和实例，或两个快照之间的差异。
- en: Once data collection is stopped, the Memory Usage tool presents an overview
    page containing memory usage data. This overview helps us grasp the memory impact
    of our application and spot areas that could benefit from optimization.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦停止数据收集，内存使用工具将显示一个包含内存使用数据的概览页面。这个概览有助于我们了解应用程序的内存影响，并找出可能从优化中受益的区域。
- en: For more advanced analysis, the Memory Usage tool provides insights into various
    memory issues such as duplicate strings, sparse arrays, and event handler leaks,
    particularly beneficial for managed memory analysis.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更高级的分析，内存使用工具提供了对各种内存问题的洞察，如重复字符串、稀疏数组和事件处理器泄漏，特别是对于托管内存分析非常有用。
- en: '![Figure 4.14 – The Memory Usage report insights](img/B22218_04_14.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图4.14 – 内存使用报告洞察](img/B22218_04_14.jpg)'
- en: Figure 4.14 – The Memory Usage report insights
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14 – 内存使用报告洞察
- en: Leveraging these insights allows us to identify and resolve common memory problems
    more efficiently.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这些洞察，我们可以更有效地识别和解决常见的内存问题。
- en: Some scenarios could need to focus and dig deeper into some specific part of
    our code base, and for that, we can use the diagnostic tools available in debugging
    mode.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有些场景可能需要我们专注于深入挖掘代码库的某个特定部分，为此，我们可以使用调试模式下的诊断工具。
- en: Exploring Memory Usage while debugging
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在调试时探索内存使用情况
- en: 'For this part, I will create a small console app that you can retrieve on GitHub.
    The following code includes a **while** loop that fills a List of string with
    a large random string:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这部分，我将创建一个小的控制台应用程序，您可以在GitHub上检索。以下代码包含一个**while**循环，该循环将一个字符串列表填充为一个大随机字符串：
- en: '[PRE0]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code block, we begin by setting breakpoints in our application
    where we suspect the memory leak might be occurring. This could be at the start
    of a function or a region of code that we suspect is causing the memory leak.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们首先在我们的应用程序中设置断点，我们怀疑内存泄漏可能发生的地方。这可能是在函数的开始或我们怀疑导致内存泄漏的代码区域。
- en: For this example, since the code is straightforward, we will set breakpoints
    at the closing bracket of the loop.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，由于代码简单，我们将在循环的闭合括号处设置断点。
- en: Additionally, in more complex scenarios, we can utilize other profiler tools
    to identify suspect locations in our code base.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在更复杂的场景中，我们可以利用其他分析工具来识别代码库中的可疑位置。
- en: Next, we will use the **diagnostic tools** , and by default, it opens at the
    launch of the debugger. If not, you can reach it by navigating to the top bar
    menu and clicking **Debug** | **Windows** | **Show** **Diagnostic Tools** .
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 **诊断工具**，默认情况下，它会在调试器启动时打开。如果没有，您可以通过导航到顶部菜单并点击 **调试** | **窗口** |
    **显示** **诊断工具** 来访问它。
- en: '![Figure 4.15 – Diagnostic Tools](img/B22218_04_15.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.15 – 诊断工具](img/B22218_04_15.jpg)'
- en: Figure 4.15 – Diagnostic Tools
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 – 诊断工具
- en: In the **Diagnostic Tools** window, we retrieve the **Events** , **Process Memory**
    , and **CPU** usage graph. For our example, we will observe the **Process Memory**
    section, where memory usage increases as the loop iterates. Additionally, we can
    monitor the work of the garbage collector to assess its impact on memory allocation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **诊断工具** 窗口中，我们检索 **事件**、**进程内存** 和 **CPU** 使用图表。在我们的示例中，我们将观察 **进程内存** 部分，其中内存使用量随着循环迭代而增加。此外，我们还可以监控垃圾收集器的工作，以评估其对内存分配的影响。
- en: To analyze the heap stack, we can take a snapshot with the **Take Snapshot**
    option. This action will generate a report of the memory state at different intervals,
    as we observed in the profiler tools description previously.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要分析堆栈，我们可以使用 **获取快照** 选项进行快照。此操作将生成不同时间间隔的内存状态报告，正如我们在之前的分析工具描述中观察到的。
- en: '![Figure 4.16 – A Memory Usage snapshot](img/B22218_04_16.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.16 – 内存使用快照](img/B22218_04_16.jpg)'
- en: Figure 4.16 – A Memory Usage snapshot
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16 – 内存使用快照
- en: In *Figure 4* *.16* , we can observe that the **Heap Size** and number of **Objects**
    dangerously increase between our snapshots. This indicates poor deallocation,
    or in other words, a memory leak.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 4.16* 中，我们可以观察到在快照之间，**堆大小** 和 **对象** 的数量危险地增加。这表明分配不当，换句话说，就是内存泄漏。
- en: We can dig deeper by clicking on the **View Heap** option to explore **Object
    Type** by size and number.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过点击 **查看堆** 选项来深入了解，通过大小和数量探索 **对象类型**。
- en: '![Figure 4.17 – Memory Usage](img/B22218_04_17.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.17 – 内存使用](img/B22218_04_17.jpg)'
- en: Figure 4.17 – Memory Usage
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 – 内存使用
- en: Here, we can see that the cause of our memory leak is **List<String>** , which
    will never deallocate.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的内存泄漏原因是 **List<String>**，它永远不会释放。
- en: While CPU and memory can provide insight into the performance of our application,
    most of the latency observed in software comes from the database interactions
    and in the next section, we will see how to optimize them.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 CPU 和内存可以提供对我们应用程序性能的洞察，但软件中观察到的大多数延迟都来自数据库交互，在下一节中，我们将看到如何优化它们。
- en: Optimizing database interactions
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化数据库交互
- en: Visual Studio 2022 introduces a new analyzer tool named **Database Profiler**
    . It allows us to explore the database interactions in our application.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2022 引入了一个名为 **数据库分析器** 的新分析工具。它允许我们探索应用程序中的数据库交互。
- en: In this section, we will explore how to use the Database Profiler tools and
    how they can help us identify query optimization opportunities in our code base.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用数据库分析器工具以及它们如何帮助我们识别代码库中的查询优化机会。
- en: To open it, we go through **Performance Profiler** and select **Database** ,
    where we can combine it with **CPU Usage** for more insight.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开它，我们通过 **性能分析器** 选择 **数据库**，在那里我们可以将其与 **CPU 使用** 结合以获得更多信息。
- en: '![Figure 4.18 – Selecting the Database and CPU Usage tools](img/B22218_04_18.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.18 – 选择数据库和 CPU 使用工具](img/B22218_04_18.jpg)'
- en: Figure 4.18 – Selecting the Database and CPU Usage tools
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18 – 选择数据库和 CPU 使用工具
- en: When we click on the **Start** button, the profiler will launch our application
    and start collecting data. During this time, we can perform long-running actions
    on our application to identify the root cause of latency.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击 **启动** 按钮，分析器将启动我们的应用程序并开始收集数据。在此期间，我们可以在应用程序上执行长时间运行的操作，以确定延迟的根本原因。
- en: After clicking on the **Stop Collection** button, we launch the generation of
    the report.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在点击 **停止收集** 按钮后，我们将启动报告的生成。
- en: '![Figure 4.19 – Database report](img/B22218_04_19.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.19 – 数据库报告](img/B22218_04_19.jpg)'
- en: Figure 4.19 – Database report
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.19 – 数据库报告
- en: 'The database report will show us a table with information about queries executed;
    by default, it shows columns with the following information:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库报告将显示一个包含已执行查询信息的表格；默认情况下，它显示以下信息的列：
- en: The start time of the query
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询的开始时间
- en: The SQL code of the query
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询的SQL代码
- en: The duration of execution
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行持续时间
- en: The number of records affected
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受影响的记录数
- en: The number of records reads
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取的记录数
- en: In larger applications, we can incorporate multiple databases, such as when
    utilizing the **Command-Query Responsibility Segregation** ( **CQRS** ) pattern
    alongside database replication, for example. To help us in our investigation,
    we can display three more columns by right-clicking on the display one and checking
    which one we need.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在更大的应用程序中，我们可以集成多个数据库，例如在利用**命令查询责任分离**（**CQRS**）模式以及数据库复制时。为了帮助我们的调查，我们可以通过右键单击显示的列并检查我们需要哪一个来显示另外三个列。
- en: '![Figure 4.20 – Database report managing column](img/B22218_04_20.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.20 – 数据库报告管理列](img/B22218_04_20.jpg)'
- en: Figure 4.20 – Database report managing column
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.20 – 数据库报告管理列
- en: 'The additional columns are as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 附加的列如下：
- en: '**Database**'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库**'
- en: '**Connection String**'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接字符串**'
- en: '**Query Source** displaying the data provider used (EFCore, Dapper, ADO.NET,
    or Others)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询源**显示所使用的数据提供程序（EFCore、Dapper、ADO.NET或其他）'
- en: Coupling with the CPU Usage tools, we can easily zoom on the consuming period
    to examine query launch in this time.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 结合CPU使用工具，我们可以轻松地聚焦于消耗周期，以检查在此时间内的查询启动。
- en: '![Figure 4.21 – Database report time filtered](img/B22218_04_21.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.21 – 数据库报告时间筛选](img/B22218_04_21.jpg)'
- en: Figure 4.21 – Database report time filtered
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.21 – 数据库报告时间筛选
- en: When we identify a query that might catch our attention due to its long transaction
    duration or large number of associated queries, we could investigate.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们识别到一个可能因其长事务持续时间或大量相关查询而引起我们注意的查询时，我们可以进行调查。
- en: Finally, in the list of queries, we can easily jump into the code source for
    further investigations or even refactoring, by right-clicking on the row we are
    interested in and selecting **Go To** **Source File**
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在查询列表中，我们可以通过右键单击我们感兴趣的行并选择**转到****源文件**，轻松地跳入代码源进行进一步调查或甚至重构。
- en: '![Figure 4.22 – Go To Source File](img/B22218_04_22.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.22 – 转到源文件](img/B22218_04_22.jpg)'
- en: Figure 4.22 – Go To Source File
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.22 – 转到源文件
- en: 'The power of Visual Studio profiling tools lies in the ability to combine some
    of its tools for a comprehensive investigation. My advice is to utilize the three
    tools highlighted in this chapter: the Memory Usage, CPU Usage, and Database tools.
    This will help in quickly identifying issues such as queries that generate excessive
    memory allocation and CPU utilization, especially when working with **Object Relational
    Mapping** ( **ORMs** ), such as EF Core or Dapper, that need to instantiate objects
    to run queries.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio性能分析工具的强大之处在于能够结合其一些工具进行综合调查。我的建议是利用本章中突出显示的三个工具：内存使用、CPU使用和数据库工具。这将帮助我们快速识别诸如生成过多内存分配和CPU利用率的查询等问题，尤其是在使用**对象关系映射**（**ORMs**），如EF
    Core或Dapper，需要实例化对象以运行查询时。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter provided key insights to leverage Visual Studio profiling tools
    to aid in our investigation and optimization of performance bottlenecks, resulting
    in improved application performance.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了利用Visual Studio性能分析工具来帮助我们调查和优化性能瓶颈的关键见解，从而提高了应用程序的性能。
- en: Throughout this chapter, we’ve covered a range of topics, from understanding
    the fundamentals of performance optimization to utilizing Visual Studio’s profiling
    tools effectively. We’ve learned how to analyze CPU usage and identify memory
    and database bottlenecks to identify and optimize critical sections and our code
    base for improved performance.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了一系列主题，从理解性能优化的基础知识到有效地利用Visual Studio的性能分析工具。我们学习了如何分析CPU使用情况并识别内存和数据库瓶颈，以识别和优化关键部分和我们的代码库，以改善性能。
- en: As we conclude this chapter, we mark the end of the first part of our journey
    in mastering core development skills. From unit testing and TDD to advanced debugging
    strategies, code analysis, and now performance optimization and profiling, you
    have laid a solid foundation for your development journey.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章时，我们标志着掌握核心开发技能旅程的第一部分的结束。从单元测试和TDD到高级调试策略、代码分析和现在性能优化与剖析，你已经为你的开发旅程奠定了坚实的基础。
- en: In the upcoming chapters, we’ll continue to expand our horizons, delving into
    advanced topics such as multi-platform app UI development, advanced web development
    tools, machine learning integration, and advanced cloud integration and services.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将继续拓展我们的视野，深入探讨高级主题，如多平台应用UI开发、高级Web开发工具、机器学习集成以及高级云集成和服务。
- en: To start the second part, we will dive into the world of cross-platform development
    by exploring tools offered by Visual Studio for MAUI.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 开始第二部分，我们将通过探索Visual Studio为MAUI提供的工具，深入跨平台开发的世界。
- en: 'Part 2: Advancing Development Horizons'
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：拓展开发视野
- en: In this second part, we focus on expanding your development expertise with advanced
    techniques for building versatile applications leveraging Visual Studio. From
    multi-platform app UI development and advanced web tools to machine learning integration
    and cloud services, these chapters equip you with the skills to build modern,
    scalable, and intelligent applications, pushing the boundaries of your development
    capabilities.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本第二部分中，我们专注于通过利用Visual Studio的高级技术来扩展您的开发专业知识，构建多功能应用程序。从多平台应用UI开发到高级Web工具，再到机器学习集成和云服务，这些章节为您提供了构建现代、可扩展和智能应用程序的技能，推动您开发能力的边界。
- en: 'This part has the following chapters:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 5*](B22218_05.xhtml#_idTextAnchor092) , *Multi-Platform App UI Development*'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B22218_05.xhtml#_idTextAnchor092) ，*多平台应用UI开发*'
- en: '[*Chapter 6*](B22218_06.xhtml#_idTextAnchor112) , *Advanced Web Development
    Tools*'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B22218_06.xhtml#_idTextAnchor112) ，*高级Web开发工具*'
- en: '[*Chapter 7*](B22218_07.xhtml#_idTextAnchor124) , *Machine Learning Integration*'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B22218_07.xhtml#_idTextAnchor124) ，*机器学习集成*'
- en: '[*Chapter 8*](B22218_08.xhtml#_idTextAnchor132) , *Advanced Cloud Integration
    and Services*'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B22218_08.xhtml#_idTextAnchor132) ，*高级云集成和服务*'
