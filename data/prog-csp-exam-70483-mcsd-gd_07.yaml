- en: Implementing Exception Handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现异常处理
- en: Exception handling helps developers structure their programs in a way that helps
    them handle both expected and unexpected scenarios. Often, application logic may
    throw some form of unhandled exception, for example, a code block trying to write
    to a file on a system that ends up with a file with a use exception. Such scenarios
    can be handled if proper exception handling is in place.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理帮助开发者以有助于处理预期和意外情况的方式构建他们的程序。通常，应用程序逻辑可能会抛出某种未处理的异常，例如，尝试向一个系统中的文件写入代码块，最终导致文件使用异常。如果设置了适当的异常处理，这些场景是可以处理的。
- en: Exception handling uses the `try`, `catch`, and `finally` keywords to allow
    us to write code that may not succeed and can be handled when required, as well
    as to help us clean up resources once the `try` block has been executed. These
    exceptions can be thrown by CLR, .NET Framework, or by external libraries that
    are used in your code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理使用`try`、`catch`和`finally`关键字，使我们能够编写可能不会成功且在需要时可以处理的代码，以及帮助我们清理`try`块执行后的资源。这些异常可以由CLR、.NET
    Framework或您代码中使用的任何外部库抛出。
- en: 'In this chapter, we will try to understand how we can use, create, and throw
    exceptions by looking at the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过查看以下主题来尝试理解我们如何使用、创建和抛出异常：
- en: Exceptions and handling exceptions in code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码中的异常及其处理
- en: Compiler-generated exceptions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器生成的异常
- en: Custom exceptions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义异常
- en: After reading this chapter, you will be able to structure an application program
    and handle all sorts of exceptions that may be thrown from your application logic.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，您将能够构建应用程序程序并处理应用程序逻辑可能抛出的所有类型的异常。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The exercises in this chapter can be practiced using Visual Studio 2012 or above
    with .NET Framework 2.0 or newer. However, any new C# features from C# 7.0 and
    above require that you have Visual Studio 2017.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的练习可以使用Visual Studio 2012或更高版本以及.NET Framework 2.0或更高版本进行练习。然而，任何从C# 7.0及更高版本的新特性都需要您拥有Visual
    Studio 2017。
- en: If you don't have a license for any of the aforementioned products, you can
    download the community version of Visual studio 2017 from [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有上述任何产品的许可证，您可以下载Visual Studio 2017的社区版本，链接为[https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
- en: The same code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter07](https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter07).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的相同代码可以在GitHub上找到，链接为[https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter07](https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter07)。
- en: Exceptions and handling exceptions in code
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码中的异常及其处理
- en: Exceptions are types that are derived from the `System.Exception` class. We
    use the `try` block around statements that may throw an exception. When an exception
    occurs, control jumps to the `catch` statement, where CLR collects all the required
    stack trace information before terminating the program and displaying a message
    to the user. If exception handling is not done, the program just terminates with
    an error. While handling exceptions, it is important to understand that if we
    cannot handle an exception, we should not catch it. This ensures that the application
    will be in a known state. When you define a `catch` block, you define an exception
    variable that can be used to obtain more information, such as the origin of the
    exception, which line in the code threw this exception, the type of exception,
    and so on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是派生自`System.Exception`类的类型。我们使用`try`块包围可能抛出异常的语句。当发生异常时，控制权跳转到`catch`语句，在那里CLR收集所有必要的堆栈跟踪信息，然后终止程序并向用户显示消息。如果没有进行异常处理，程序将带错误终止。在处理异常时，重要的是要理解，如果我们无法处理异常，我们就不应该捕获它。这确保了应用程序将处于已知状态。当您定义一个`catch`块时，您定义一个异常变量，可以用来获取更多信息，例如异常的来源、代码中的哪一行抛出了这个异常、异常的类型等等。
- en: A programmer can create and throw exceptions from the application logic using
    the throw keyword. Each `try` block may or may not define the `finally` block,
    which will be executed whether an exception is thrown or not. This block helps
    us release resources that have been used in the code block. Alternatively, if
    you want a piece of code to execute in all scenarios, it can be placed in the
    `finally` block.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员可以使用 `throw` 关键字从应用程序逻辑中创建和抛出异常。每个 `try` 块可以定义也可以不定义 `finally` 块，无论是否抛出异常，该块都将执行。这个块帮助我们释放代码块中使用的资源。或者，如果您希望一段代码在所有情况下都执行，则可以将其放在
    `finally` 块中。
- en: In the upcoming sections, we will look at how we can use exceptions, the syntax
    of the `try`-`catch`-`finally` block, using the `finally` block, when we can dispose
    of unused objects, different types of system exceptions, and creating our own
    exceptions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨如何使用异常、`try`-`catch`-`finally` 块的语法、使用 `finally` 块、何时可以销毁未使用的对象、不同类型的系统异常以及创建我们自己的异常。
- en: Using exceptions
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异常
- en: As we mentioned previously, errors in C# programs are propagated at runtime
    using exceptions. When application code encounters an error, it throws an exception,
    which is then caught by another block of code that collects all the information
    about the exception and pushes it to the calling method, where the `catch` block
    was provided. A dialog box will be displayed by the system if you're using a generic
    exception handler for any uncaught exceptions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，C# 程序中的错误是通过异常在运行时传播的。当应用程序代码遇到错误时，它会抛出一个异常，然后由另一个代码块捕获，该代码块收集有关异常的所有信息并将其推送到调用方法，其中提供了
    `catch` 块。如果您使用的是通用异常处理程序，系统将显示一个对话框来显示任何未捕获的异常。
- en: 'In the following example, we are trying to parse an empty string into an `int`
    variable:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们尝试将一个空字符串解析为 `int` 变量：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When executed, the runtime throws a format exception with a message stating
    Input string was not in a correct format. As this exception wasn''t caught, we
    can see the generic handler displaying this error message in a dialog box:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，运行时会抛出一个格式异常，其消息指出输入字符串格式不正确。由于这个异常没有被捕获，我们可以看到通用处理程序在对话框中显示这个错误消息：
- en: '![](img/ba893895-c52d-4363-91ad-b06cd309b8ff.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba893895-c52d-4363-91ad-b06cd309b8ff.png)'
- en: 'Here are the exception''s details:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是异常的详细信息：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Each `catch` block defines an exception variable that gives us more information
    about the exception that is being thrown. The `exception` class defines multiple
    properties, all of which hold the following extra information:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `catch` 块定义了一个异常变量，它为我们提供了更多关于正在抛出的异常的信息。`exception` 类定义了多个属性，所有这些属性都包含以下额外信息：
- en: '| **Property** | **Description** |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** |'
- en: '| `Data` | Gets custom-defined details about the exception in a key/value pair
    collection. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `Data` | 获取关于异常的自定义详细信息，以键/值对集合的形式。 |'
- en: '| `HelpLink` | Gets or sets a help link related to an exception. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `HelpLink` | 获取或设置与异常相关的帮助链接。 |'
- en: '| `HResult` | Gets or sets `HRESULT`, a number value that is associated with
    the exception. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `HResult` | 获取或设置与异常关联的 `HRESULT`，这是一个数值。 |'
- en: '| `InnerException` | Gets the instance of the exception that triggered the
    exception. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `InnerException` | 获取触发异常的异常实例。 |'
- en: '| `Message` | Gets detailed information from the exception. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `Message` | 从异常中获取详细信息。 |'
- en: '| `Source` | Gets or sets the application/instance name or the object/variable
    that caused the error. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `Source` | 获取或设置导致错误的程序/实例名称或对象/变量。 |'
- en: '| `StackTrace` | Gets a call stack in a string format. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `StackTrace` | 以字符串格式获取调用堆栈。 |'
- en: '| `TargetSite` | Gets the method that triggered the exception. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `TargetSite` | 获取触发异常的方法。 |'
- en: 'Now, we will try to handle the format exception and see what each property
    will provide us with. In the following example, we have a `try` block where the
    string is being parsed into an integer and a `catch` block that is being used
    to catch the format exception. In the `catch` block, we are displaying all the
    properties of the exception that we''ve caught:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将尝试处理格式异常，并查看每个属性将提供给我们什么。在以下示例中，我们有一个 `try` 块，其中字符串被解析为整数，以及一个用于捕获格式异常的
    `catch` 块。在 `catch` 块中，我们显示了我们捕获的异常的所有属性：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We are trying to parse a string into an integer variable. However, this is
    not allowed, and so the system throws an exception. When we catch the exception,
    we are displaying each property of the exception to observe what it stores:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图将一个字符串解析为整数变量。然而，这是不允许的，因此系统抛出异常。当我们捕获异常时，我们正在显示异常的每个属性以观察它存储的内容：
- en: '![](img/aa6c6e08-4d29-47cc-8eb8-eea6dc13b351.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aa6c6e08-4d29-47cc-8eb8-eea6dc13b351.png)'
- en: Each exception is inherited from the `System.Exception` base case, which defines
    the type of exception and details all the properties that provide more information
    about the exception. When you need to throw an exception, you need to create an
    instance of the exception class, set all or some of these properties, and throw
    them using the `throw` keyword.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每个异常都是继承自`System.Exception`基类，它定义了异常的类型并详细说明了所有提供更多异常信息的属性。当你需要抛出异常时，你需要创建异常类的实例，设置所有或部分这些属性，并使用`throw`关键字抛出它们。
- en: 'You can have more than one `catch` block for a `try` block. During execution,
    when an exception is thrown, a specific `catch` statement that handles the exception
    executes first and any other generic `catch` statements are ignored. Therefore,
    it is important to organize your `catch` blocks by placing them in order, that
    is, from the most specific to the least specific:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个`try`块，你可以有多个`catch`块。在执行过程中，当抛出异常时，首先执行处理该异常的特定`catch`语句，而任何其他通用的`catch`语句都将被忽略。因此，按照从最具体到最不具体的顺序组织`catch`块是很重要的：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When the program executes, although there are multiple `catch` blocks present,
    the system identifies an appropriate `catch` block and consumes the exception.
    Due to this, you will see a `Format Exception caught` message in the output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序执行时，尽管存在多个`catch`块，系统会识别一个合适的`catch`块并消耗异常。因此，你会在输出中看到“捕获到格式异常”的消息：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `finally` block is checked before invoking a `catch` block. When using
    resources in a `try`-`catch` block, there is a chance that these resources will
    move to an ambiguous state and aren''t collected until the framework''s garbage
    collector is invoked. Such resources can be cleaned up by the programmer via the
    use of `finally` blocks:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`catch`块之前会检查`finally`块。当在`try-catch`块中使用资源时，这些资源可能会移动到一个模糊的状态，并且只有在框架的垃圾回收器被调用时才会被收集。程序员可以通过使用`finally`块来清理这些资源：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, the `finally` block was executed, but not before an exception
    was raised and caught using the respective `catch` block:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`finally`块被执行，但在抛出并捕获异常之前：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Although we had three different `catch` blocks, the format exception was executed
    and the `finally` block was executed after.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们有三不同的`catch`块，格式异常被执行，并且之后执行了`finally`块。
- en: Exception handling
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: Programmers partition application logic that may throw exceptions into a `try`
    block, followed by a `catch` block to handle these exceptions. An optional `finally`
    block, if present, is executed, regardless of whether an exception is thrown by
    a `try` block. You cannot just have a `try` block—it has to be accompanied by
    either a `catch` block or a `finally` block.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员将可能抛出异常的应用逻辑分区到`try`块中，随后是处理这些异常的`catch`块。如果存在，可选的`finally`块将执行，无论`try`块是否抛出异常。你不能只有一个`try`块——它必须由一个`catch`块或一个`finally`块伴随。
- en: In this section, we will look at different code blocks in order to understand
    the usage of the `try`-`catch` statement, the `try`-`finally` statement, and the
    `try`-`catch`-`finally` statement.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看不同的代码块，以便了解`try-catch`语句、`try-finally`语句和`try-catch-finally`语句的用法。
- en: 'You can use a `try`-`catch` statement without a `finally` block like so:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样使用没有`finally`块的`try-catch`语句：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The system also allows you to use a `try` block with a `finally` block—there''s
    no need for the `catch` exception. This is shown in the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 系统还允许你使用带有`finally`块的`try`块——不需要捕获异常。这在下述代码中显示：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Last but not least, there''s the `try`-`catch`-`finally` block:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，有`try-catch-finally`块：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A compile-time error is thrown if the runtime identifies incorrect syntax in
    a `try` block; for example, a `try` block without a `catch` or `finally` block
    during the compilation of the code. When you don''t provide a `catch` or `finally`
    block, the compiler puts a red mark next to the closing bracket of `try` and an
    error is thrown, as shown in the error list window in the following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行时在`try`块中识别到不正确的语法，则会抛出一个编译时错误；例如，在代码编译期间没有`catch`或`finally`块的`try`块。当你没有提供`catch`或`finally`块时，编译器会在`try`块的闭合括号旁边放置一个红色标记，并抛出一个错误，如下面的截图中的错误列表窗口所示：
- en: '![](img/1bedb9a2-e322-45ac-aa37-b0072f16f25a.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1bedb9a2-e322-45ac-aa37-b0072f16f25a.png)'
- en: Exception filters are a type of exception that's used to catch in a `catch`
    block. `System.Exception` is the base class for any exception type class. As this
    is the base class, it can hold any exception in the code. We use this when we
    have code that handles every exception or when we are throwing an exception while
    calling `method()`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 异常过滤器是一种用于在`catch`块中捕获的异常类型。`System.Exception`是任何异常类型类的基类。作为基类，它可以持有代码中的任何异常。我们使用它在我们有处理每个异常的代码或在我们调用`method()`时抛出异常时。
- en: We've already discussed that a `try` block can have multiple `catch` blocks
    with different exception filters. When the runtime evaluates the `catch` block,
    it takes a top-to-bottom approach and executes the most specific `catch` block
    that suits the exception that's been caught. If the `exception` filter in the
    `catch` block matches the exception that's been thrown or matches the base class
    of the exception that's been thrown, it's executed. As an exam tip, always remember
    to place the most specific `catch` statements on top and place the generic ones
    at the bottom.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过，一个`try`块可以有多个带有不同异常过滤器的`catch`块。当运行时评估`catch`块时，它采取自上而下的方法，并执行最适合已捕获异常的最具体的`catch`块。如果`catch`块中的`exception`过滤器与已抛出的异常匹配，或者与已抛出异常的基类匹配，则执行它。作为一个考试提示，始终记住将最具体的`catch`语句放在顶部，将通用的放在底部。
- en: Understanding the importance of exception handling helps you write proper code
    that handles every possible scenario and executes it without unexpected behavior
    occurring. For example, let's say your program is trying to open and write into
    a file and you receive an exception such as `File not found` or `File-in-Use`.
    Exception handling allows us to handle these scenarios. In the first case, the
    prompt asks the user to provide a correct filename, while in the second case,
    the prompt checks whether it is OK to create a new file.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 理解异常处理的重要性有助于你编写能够处理所有可能场景并执行而不会出现意外行为的正确代码。例如，假设你的程序正在尝试打开并写入一个文件，而你收到了一个如`文件未找到`或`文件正在使用中`的异常。异常处理使我们能够处理这些场景。在第一种情况下，提示会要求用户提供正确的文件名，而在第二种情况下，提示会检查是否可以创建一个新文件。
- en: 'In the following example, a `for` loop is throwing an index is out of range
    exception:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，一个`for`循环抛出了一个索引超出范围的异常：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The code handles it and displays a message on the screen before throwing it
    so that the invoking method can handle it, like so:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 代码处理它，并在抛出之前在屏幕上显示一条消息，以便调用方法可以处理它，如下所示：
- en: '![](img/3af8902a-b937-4084-8b0f-7993dbf386a7.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3af8902a-b937-4084-8b0f-7993dbf386a7.png)'
- en: 'However, our main program doesn''t handle the exception system. Instead, it
    uses the default and displays a dialog box:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的主程序不处理异常系统。相反，它使用默认设置并显示一个对话框：
- en: '![](img/691694c8-8895-4d6f-b177-50a9b4f6b3ad.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/691694c8-8895-4d6f-b177-50a9b4f6b3ad.png)'
- en: 'The `finally` block releases any variables or objects that were created in
    the `try` block. This block executes last and always runs if present:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally`块释放了在`try`块中创建的任何变量或对象。此块最后执行，如果存在则始终运行：'
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding example, we created a file object in a `try` block and tried
    to write some bytes to it. When the runtime completes the execution of the `try`
    block, it executes a `finally` block and releases the `file` object that was created
    in the `try` block.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们在`try`块中创建了一个文件对象，并尝试向其中写入一些字节。当运行时完成`try`块的执行后，它执行一个`finally`块并释放了在`try`块中创建的`file`对象。
- en: Compiler-generated exceptions
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器生成的异常
- en: 'Let''s go over a few runtime-generated exceptions that .NET Framework supports.
    The framework uses these exceptions on valid statements that are being executed.
    Then, based on their type, an exception from the following table is thrown. For
    example, if the compiler tries to execute a division operation and if the denominator
    is zero, `DividebyZeroException` is thrown:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下.NET Framework支持的几个运行时生成的异常。框架在执行有效语句时使用这些异常。然后，根据它们的类型，从以下表格中抛出相应的异常。例如，如果编译器尝试执行除法操作，并且如果除数为零，则会抛出`DividebyZeroException`异常：
- en: '| **Exception** | **Description** |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **Exception** | **描述** |'
- en: '| `ArithmeticException` | An exception that''s triggered while performing arithmetic
    operations can be caught. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `ArithmeticException` | 在执行算术操作时触发的异常可以被捕获。 |'
- en: '| `ArrayTypeMismatchException` | When the value and type of the array don''t
    match, this exception is thrown. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `ArrayTypeMismatchException` | 当数组的值和类型不匹配时，将抛出此异常。 |'
- en: '| `DivideByZeroException` | When an attempt to divide an integer value by zero
    is made, this exception is thrown. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `DivideByZeroException` | 当尝试将整数值除以零时，将抛出此异常。 |'
- en: '| `IndexOutOfRangeException` | When an array is accessed with an index outside
    of its boundaries, this exception is thrown. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `IndexOutOfRangeException` | 当使用超出其边界的索引访问数组时，将抛出此异常。 |'
- en: '| `InvalidCastException` | Converting a base type into an interface or derived
    type will cause this exception at runtime. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `InvalidCastException` | 在运行时将基类型转换为接口或派生类型将导致此异常。 |'
- en: '| `NullReferenceException` | When you try to access an object that is `null`,
    this exception is thrown. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `NullReferenceException` | 当你尝试访问一个`null`对象时，将抛出此异常。 |'
- en: '| `OutOfMemoryException` | When the available memory for CLR is utilized, the
    new operator throws such exceptions. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `OutOfMemoryException` | 当CLR可用内存被利用时，新操作符会抛出此类异常。 |'
- en: '| `OverflowException` | While performing a division operation, for example,
    if the output is long and you try to push it to `int`, this exception is thrown.
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `OverflowException` | 在执行除法操作时，例如，如果输出是长整型并且你尝试将其推送到`int`，则会抛出此异常。 |'
- en: '| `StackOverflowException` | Recursive calls usually cause such exceptions
    and indicate a very deep or infinite recursion. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `StackOverflowException` | 递归调用通常会导致此类异常，并指示非常深的或无限递归。 |'
- en: '| `TypeInitializationException` | If you try to instantiate an abstract class,
    for example, this exception is thrown. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `TypeInitializationException` | 如果你尝试实例化一个抽象类，例如，将抛出此异常。 |'
- en: Now that we've looked at compiler-generated exceptions, let's take a look at
    custom exceptions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了编译器生成的异常，让我们看看自定义异常。
- en: Custom exceptions
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义异常
- en: All exceptions are derived from the `System.Exception` class in .NET Framework.
    So, in a scenario where these predefined exceptions don't suit our requirements,
    the framework allows us to create our own exceptions by deriving our exception
    class from the `Exception` class.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所有异常都源自.NET Framework中的`System.Exception`类。因此，在这些预定义异常不符合我们的需求的情况下，框架允许我们通过从`Exception`类派生我们的异常类来创建自己的异常。
- en: 'In the following example, we are creating a custom exception and inheriting
    from the `Exception` class. We can use different constructors for this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们正在创建一个自定义异常，并从`Exception`类继承。我们可以为它使用不同的构造函数：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When you create your own exception class, derive from the `System.Exception`
    class, and implement the base class, you get four constructors; implementing the
    three mentioned is the best practice. In the first instance, the base class message
    property is initialized by default and a message is displayed. However, in the
    second and third scenarios, the method that's throwing this custom exception needs
    to pass these values.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建自己的异常类时，从`System.Exception`类派生，并实现基类，你将获得四个构造函数；实现这三个是最佳实践。在第一种情况下，基类消息属性默认初始化并显示一条消息。然而，在第二种和第三种情况下，抛出此自定义异常的方法需要传递这些值。
- en: Summary
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how we can use the exception class in a program,
    how we can create custom exceptions to meet our requirements, and different types
    of exceptions. We also learned about industry standards regarding how to plan
    and implement exceptions in an application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何在程序中使用异常类，如何创建自定义异常以满足我们的需求，以及不同类型的异常。我们还了解了有关如何在应用程序中规划和实现异常的行业标准。
- en: In the next chapter, we will understand types and how to create and consume
    types.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解类型以及如何创建和消费类型。
- en: Questions
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: C# supports `try` blocks without`catch` and `finally` blocks.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C# 支持使用 `try` 块而不带 `catch` 和 `finally` 块。
- en: 'True'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真的
- en: 'False'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假的
- en: '`catch` blocks need to be used in a most-generic-to-least-generic pattern.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`catch` 块需要按照从最通用到最通用的模式使用。'
- en: 'True'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真的
- en: 'False'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假的
- en: If present, a `finally` block always executes.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在，`finally` 块总是会执行。
- en: 'True'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真的
- en: 'False'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假的
- en: Answers
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: '**False**'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**假的**'
- en: '**False**'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**假的**'
- en: '**True**'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**真的**'
- en: Further reading
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'While implementing exception handling in your application code, it is important
    to understand industry standards. Please take a look at the following link to
    understand these best practices: [https://docs.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions](https://docs.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现应用程序代码中的异常处理时，理解行业标准非常重要。请查看以下链接以了解这些最佳实践：[https://docs.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions](https://docs.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions)。
