<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Core Concepts of C# and .NET" id="aid-H5A41"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Core Concepts of C# and .NET</h1></div></div></div><p>This chapter covers the core concepts of C# and .NET, starting from the initial version and principal motivations behind its creation, and covering also the new aspects of the language, that appeared in versions 2.0 and 3.0.</p><p>We'll illustrate all the main concepts with small code snippets, short enough to facilitate its understanding and easy reproduction.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">C# and its role in the Microsoft Development ecosystem</li><li class="listitem">Difference between strongly typed and weakly typed languages</li><li class="listitem">The evolution in versions 2.0 and 3.0</li><li class="listitem">Generics</li><li class="listitem">Lambda expressions</li><li class="listitem">LINQ</li><li class="listitem">Extension methods</li></ul></div><div class="section" title="C# – what's different in the language?"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec11"/>C# – what's different in the language?</h1></div></div></div><p>I had the chance to chat with <a id="id177" class="indexterm"/>Hejlsberg a couple of times about the C # language and what the initial purposes and requirements imposed in its creation were and which other languages inspired him or contributed to his ideas.</p><p>The first time we talked, in Tech-Ed 2001 (at Barcelona, Spain), I asked him about the principles of <span class="emphasis"><em>his</em></span> language and what makes it different from others. He first said that it was not only him who created the language, but also a group of people, especially <span class="emphasis"><em>Scott Wiltamuth</em></span>, <span class="emphasis"><em>Peter Golde</em></span>, <span class="emphasis"><em>Peter Sollich</em></span>, and <span class="emphasis"><em>Eric Gunnerson</em></span>.</p><div class="note" title="Note"><h3 class="title"><a id="note11"/>Note</h3><p>One of the first books ever published on the subject was, <span class="emphasis"><em>A Programmer's Introduction to C#</em></span>, <span class="emphasis"><em>Gunnerson's.E.</em></span>, APress, 2000).</p></div><p>About the principles, he mentioned this:</p><div class="blockquote"><blockquote class="blockquote"><p>"One of the key differences between C# and these other languages, particularly Java, is that we tried to stay much closer to C++ in our design. C# borrows most of its operators, keywords, and <a id="id178" class="indexterm"/>statements directly from C++. But beyond these more traditional language issues, one of our key design goals was to make the C# language component-oriented, to add to the language itself all of the concepts that you need when you write components. Concepts such as properties, methods, events, attributes, and documentation are all first-class language constructs."</p></blockquote></div><p>He stated also this:</p><div class="blockquote"><blockquote class="blockquote"><p>"When you write code in C#, you write everything in one place. There is no need for header files, IDL files (Interface Definition Language), GUIDs and complicated interfaces."</p></blockquote></div><p>This means that you can write code that is self-descriptive in this way given that you're dealing with a self-contained unit (let's remember the role of the manifest, optionally embedded in assemblies). In this mode, you can also extend existing technologies in a variety of ways, as we'll see in the examples.</p></div></div>
<div class="section" title="Languages: strongly typed, weakly typed, dynamic, and static" id="aid-I3QM1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec12"/>Languages: strongly typed, weakly typed, dynamic, and static</h1></div></div></div><p>The C# language is <a id="id179" class="indexterm"/>a strongly typed language: this means that any attempt to pass a wrong kind of parameter as an argument, or to <a id="id180" class="indexterm"/>assign a value to a variable that is not implicitly convertible, will generate a compilation error. This avoids many errors that only happen at runtime in other languages.</p><p>In addition, by dynamic, we <a id="id181" class="indexterm"/>mean those languages whose rules<a id="id182" class="indexterm"/> are applied at runtime, while static languages apply their rules at compile time. JavaScript or PHP are good examples of the former case, and C/C++ of the latter. If we make a graphic representation of this situation, we might come up with something like what is shown in the following figure:</p><div class="mediaobject"><img src="../Images/image00431.jpeg" alt="Languages: strongly typed, weakly typed, dynamic, and static"/></div><p style="clear:both; height: 1em;"> </p><p>In the figure, we can <a id="id183" class="indexterm"/>see that C# is clearly strongly typed, but it's much more dynamic than C++ or Scala, to mention a few. Of<a id="id184" class="indexterm"/> course, there are several criteria to catalog languages for their typing (weak versus strong) and for their dynamism (dynamic versus static).</p><p>Note that this has<a id="id185" class="indexterm"/> implications in the IDE as well. Editors can tell us which type is expected in every case, and if you use a dynamic <a id="id186" class="indexterm"/>declaration such as <code class="literal">var</code>, the right side of the equality (if any) will be evaluated, and we will be shown the calculated value for every declaration:</p><div class="mediaobject"><img src="../Images/image00432.jpeg" alt="Languages: strongly typed, weakly typed, dynamic, and static"/></div><p style="clear:both; height: 1em;"> </p><p>Even outside of the .NET world, Visual Studio's IDE is now able to provide strongly typed and Intellisense experiences when using languages such as TypeScript, a superset of JavaScript that transpiles (converts into) pure JavaScript but can be written using the same coding experience as what we would have in C# or any other .NET language.</p><p>It's available as a <a id="id187" class="indexterm"/>separate type of project, if <a id="id188" class="indexterm"/>you're curious about it, and the latest up-to-date version is TypeScript 2.0, and it was recently<a id="id189" class="indexterm"/> published (you can take a look at a detailed description of its new capabilities at <a class="ulink" href="https://blogs.msdn.microsoft.com/typescript/">https://blogs.msdn.microsoft.com/typescript/</a>).</p><p>As we'll see later in this <a id="id190" class="indexterm"/>chapter, Intellisense is key <a id="id191" class="indexterm"/>for the LINQ syntax, in which many expressions return a new (non-existing) type, which can be automatically assigned to the correct type by the compiler if we use a var declaration.</p><div class="section" title="The main differences"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>The main differences</h2></div></div></div><p>So, going back<a id="id192" class="indexterm"/> to the title, what made C# different? I'll point out five core points:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Everything is an object (we mentioned this in <a class="link" title="Chapter 1. Inside the CLR" href="part0015.xhtml#aid-E9OE2">Chapter 1</a>, <span class="emphasis"><em>Inside the CLR</em></span>). Other languages, such as Smalltalk, Lisp, among others, have done this earlier, but due to different reasons, the performance penalty was pretty hard.</li><li class="listitem">As you know, it's enough to take a look at the Object Explorer to be able to check where an object comes from. It's a good practice to check the very basic values, such as <code class="literal">int</code> or <code class="literal">String</code>, which are nothing but aliases of <code class="literal">System.Int32</code> and <code class="literal">System.String</code>, and both come from object, as shown in the following screenshot:<div class="mediaobject"><img src="../Images/image00433.jpeg" alt="The main differences"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">Using the Boxing and Unboxing techniques, any value type can be converted into an object, and the value of an object can be converted into a simple value type.</li><li class="listitem">These conversions are<a id="id193" class="indexterm"/> made by simply casting the type to an object (and vice versa) in this manner:<div class="informalexample"><pre class="programlisting">// Boxing and Unboxing
int y = 3; // this is declared in the stack
// Boxing y in a Heap reference z
// If we change z, y remains the same.
object z = y;
// Unboxing y into h (the value of
// z is copied to the stack)
int h = (int)z;</pre></div></li></ul></div><p>Using Reflection (the technique that allows you to read a component's metadata), an application can call itself or other applications, creating new instances of their containing classes.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">As a short demo, this simple code launches another instance of a WPF application (a very simple one with just one button, but that doesn't matter):<div class="informalexample"><pre class="programlisting">static short counter = 1;
private void btnLaunch_Click(object sender, RoutedEventArgs e)
{
  // Establish a reference to this window
  Type windowType = this.GetType();
  // Creates an instance of the Window
  object objWindow = Activator.CreateInstance(windowType);
  // cast to a MainWindow type
  MainWindow aWindow = (MainWindow)objWindow;
  aWindow.Title = "Reflected Window No: " + (++counter).ToString();
  aWindow.Show();
}</pre></div></li><li class="listitem">Now, every time we click on the button, a new instance of the window is created and launched, indicating its creation order in the title's window:<div class="mediaobject"><img src="../Images/image00434.jpeg" alt="The main differences"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">You can have access to other components through a technology called Platform Invoke, which means you can call operating systems' functions by importing the existing DLLs using the <code class="literal">DllImport</code> attribute:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">For instance, you<a id="id194" class="indexterm"/> can make an external program's window the child of your own window using the <code class="literal">SetParent</code> API, which is part of <code class="literal">User32.dll</code>, or you can control operating system events, such as trying to shut down the system while our application is still active.</li><li class="listitem">Actually, once the permissions are given, your application can call any function located in any of the system's DLL if you need access to native resources.</li><li class="listitem">The schema that gives us access to these resources looks like what is shown in the following figure:<div class="mediaobject"><img src="../Images/image00435.jpeg" alt="The main differences"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">If you want to try out some of these possibilities, the mandatory resource to keep in<a id="id195" class="indexterm"/> mind is <a class="ulink" href="http://www.PInvoke.net">http://www.PInvoke.net</a>, where you have most of the useful system APIs, with examples of how to use them in C#.</li><li class="listitem">These interoperation capabilities are extended to interactions with applications that admit Automation, such as those in the Microsoft Office Suite, AutoCAD, and so on.</li></ul></div></li><li class="listitem">Finally, unsafe code allows<a id="id196" class="indexterm"/> you to write inline C code with pointers, perform unsafe casts, and even pin down memory in order to avoid accidental garbage collection. However, unsafe does not mean that it is unmanaged. Unsafe code is deeply tied into the security system.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">There are many situations in which this is very useful. It might be an algorithm that's difficult to implement or a method whose execution is so CPU-intensive that performance penalties become unacceptable.</li></ul></div></li></ul></div><p>While all this is important, I was surprised by the fact that every event handler in C# (as also in other .NET languages) would have two and only two arguments. So, I asked Anders about it, and his answer was one of the most clear and logical ones that I've ever heard.</p></div></div>
<div class="section" title="The true reason for delegates"><div class="titlepage" id="aid-J2B82"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>The true reason for delegates</h1></div></div></div><p>It so happens that besides these architectural considerations that we've mentioned, there was another reason that was<a id="id197" class="indexterm"/> key to the design: ensuring that a .NET program would never produce a <span class="strong"><strong>BSOD</strong></span> (<span class="strong"><strong>Blue Screen of Death</strong></span>).</p><p>So, the team tackled the problem scientifically<a id="id198" class="indexterm"/> and made a statistical analysis of their causes (more than 70,000 of these screens were used in the analysis). It turned out that around 90% of the causes for this problem were due to drivers, and the only thing they could do was get serious with manufacturers, asking<a id="id199" class="indexterm"/> them to pass the <span class="strong"><strong>Hardware Compatibility List</strong></span> (<span class="strong"><strong>HCL</strong></span>) and little else.</p><div class="note" title="Note"><h3 class="title"><a id="note12"/>Note</h3><p>The current<a id="id200" class="indexterm"/> HCL page for Windows can be found at <a class="ulink" href="https://sysdev.microsoft.com/en-us/hardware/lpl/">https://sysdev.microsoft.com/en-us/hardware/lpl/</a>.</p></div><p>So, they had a remaining 10% problem due to their own software, but the big surprise was that instead of finding five or 10 core causes for these failures, the problem focused mainly on just two reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Pointer to functions that get lost, which I represent in the graphic by <span class="strong"><strong>p* -&gt; f(x)</strong></span></li><li class="listitem">Casting problems (trying to convert types passed to a function; failing could drive to unpredictable results)</li></ul></div><p>The results, expressed in a simple Gaussian curve, look like this:</p><div class="mediaobject"><img src="../Images/image00436.jpeg" alt="The true reason for delegates"/></div><p style="clear:both; height: 1em;"> </p><p>So, covering these two issues, more than 95% (or more) of the problems, were solved. The first goal was achieved: focusing on the problem and reducing it to the maximum.</p><p>At this point, he had to find a solution that could possibly resolve both issues. This is where the genius of this Danish man came in. He thought back to the origins of the two problems and realized that both cases were related to method calls. Given a twist and a return to rethink the foundations of General Information Theory in order to identify the specific problem within the theoretical model (the first pages of any book on the subject), we would find something like what is shown in this figure:</p><div class="mediaobject"><img src="../Images/image00437.jpeg" alt="The true reason for delegates"/></div><p style="clear:both; height: 1em;"> </p><p>But, wait! ...this is also the <a id="id201" class="indexterm"/>core architecture of the event system! So, there is a correspondence between the two schemas in the four elements implied:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Issuer</strong></span>: It is the method that makes<a id="id202" class="indexterm"/> the call</li><li class="listitem"><span class="strong"><strong>Receiver</strong></span>: Another<a id="id203" class="indexterm"/> class (or the same) responding in another method</li><li class="listitem"><span class="strong"><strong>Channel</strong></span>: It is the environment, replaced by<a id="id204" class="indexterm"/> a managed environment in .NET</li><li class="listitem"><span class="strong"><strong>Message</strong></span>: The information sent<a id="id205" class="indexterm"/> to the receiver</li></ul></div><p>Now, the second problem is solved: the model of the target is identified as a case of the general pattern of information theory as well as its parts: the channel and the information expected to be received.</p><p>What was missing? What has always been done in computer science to solve problems of direct calls? That would be calling in an intermediary. Or if you prefer otherwise, applying the fifth principle of the SOLID design: Dependency Inversion.</p><div class="note" title="Note"><h3 class="title"><a id="note13"/>Note</h3><p>We'll talk in more detail about dependency inversion when we cover <span class="emphasis"><em>Design patterns</em></span> in <a class="link" title="Chapter 10. Design Patterns" href="part0055.xhtml#aid-1KEEU1">Chapter 10</a>, <span class="emphasis"><em>Design Patterns</em></span>, but for now, suffice to say what the principle states (in short): modules should not depend on low-level modules or on details but on abstractions.</p></div><p>This is where the factor responsible for this solution comes in: the delegate. Calls are never made directly but always through the delegate, which is administered by CLR and will not attempt to call something that is not available (it's managed, remember). The function pointer problem is solved via the channel (and the elimination of function pointers, of course).</p><p>If you take a look at the<a id="id206" class="indexterm"/> official (Wikipedia's) article explaining this principle (<a class="ulink" href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">https://en.wikipedia.org/wiki/Dependency_inversion_principle</a>), you'll discover that the recommended solution of the pattern is to change from scenario 1 (at the left-hand side of the figure) to<a id="id207" class="indexterm"/> scenario 2 (at the right-hand side), in which it is proposed that the method that is called (in object B) inherits (implements) an interface to make sure that the call is realized with no risks:</p><div class="mediaobject"><img src="../Images/image00438.jpeg" alt="The true reason for delegates"/></div><p style="clear:both; height: 1em;"> </p><p>The solution to the second cause, as Hejlsberg said, <span class="emphasis"><em>seemed trivial, once turned above</em></span>. He just had to make the delegate's signature equal to the receiving method (remember, the same types of parameters and return value), and bid goodbye to the problems of casting, since CLR is strongly typed and the compiler (and even the IDE) will mark any violation of this principle, indicating that it won't compile.</p><p>This architecture avoids the problems of BSOD originated by these causes. Can we look at this structure in code? Sure. Actually, I'm pretty sure you have seen it often, only not from this point of view maybe.</p><p>Let's go back a second to the previous case with our Reflected window. And let's identify the protagonists. The emitter is clearly the <code class="literal">bntLaunch</code> button member, and the receiver is the previous code:</p><div class="informalexample"><pre class="programlisting">void btnLaunch_Click(object sender, RoutedEventArgs e)</pre></div><p>So, when we see the click's event handler method's definition, we also see two of the members of scenario 2: the sender (the emitter) and the information passed in (an instance of the <code class="literal">RoutedEventArgs</code> class).</p><p>Remember, a delegate in charge of the call should have the same signature as that in this method. Just right-click on the<a id="id208" class="indexterm"/> name of the method, <span class="strong"><strong>Search all references</strong></span>, and you'll find out where the connection between the method and the delegate is established (the usual syntax):</p><div class="informalexample"><pre class="programlisting">this.btnLaunch.Click += new System.Windows.RoutedEventHandler(this.btnLaunch_Click);</pre></div><p>So, the click member of <code class="literal">btnLaunch</code> is connected to the <code class="literal">btnLaunch_Click</code> method by means of a new instance of a delegate of type <code class="literal">RoutedEventHandler</code>. Once again, right-click on <span class="strong"><strong>RoutedEventHandler</strong></span> and select <span class="strong"><strong>Go to definition</strong></span> in order to take a look at the delegate's signature:</p><div class="informalexample"><pre class="programlisting">public delegate void RoutedEventHandler(object sender, RoutedEventArgs e);</pre></div><p>Voilà, the signature is exactly the same as the receiver. No more casting problems, and if the CLR does its work, no calls will be made unless the receiver method is not accessible. This is because only a kernel-level component can cause a BSOD, never a user mode component.</p><p>So, a delegate is a very special class that can be declared outside or inside any other class and has the ability to target any method as long as their signatures are compatible. The <code class="literal">+=</code> syntax also tell us something important: they are multicast. That is, they can target more than one method in a single call.</p><p>Let's place this in a scenario where we need to evaluate which numbers are divisible by another sequence of numbers. To put it simply, let's start with two methods, checking the divisibility by 2 and 3, respectively:</p><div class="informalexample"><pre class="programlisting">static List&lt;int&gt; numberList;
static List&lt;int&gt; divisibleNumbers = new List&lt;int&gt;();
private void CheckMod2(int x)
{
  if (x % 2 == 0) divisibleNumbers.Add(x);
}
private void CheckMod3(int x)
{
  if (x % 3 == 0) divisibleNumbers.Add(x);
}</pre></div><p>Now, we want to evaluate the list and fill a Listbox including those numbers that comply with the rules:</p><div class="informalexample"><pre class="programlisting">delegate void DivisibleBy(int number);
private void ClassicDelegateMethod()
{
  DivisibleBy ed = new DivisibleBy(CheckMod2);
  // Invocation of several methods (Multicasting)
  ed += CheckMod3;
  // Every call to ed generates a multicast sequence
  foreach (int x in numberList) { ed(x); }
}</pre></div><p>We declare a delegate, <code class="literal">DivisibleBy</code>, which receives a number and performs an action (later, we'll find that this is renamed to <code class="literal">Action</code>). So, the same delegate can call both methods in a sequence (note that this can make the sequence pretty long).</p><p>The delegate is invoked using another <a id="id209" class="indexterm"/>button that will call the following code when clicked:</p><div class="informalexample"><pre class="programlisting">// Generic delegate way
numberList = Enumerable.Range(1, 100).ToList();
ClassicDelegateMethod();
PrintResults("Numbers divisible by 2 and 3");</pre></div><p>Here, we don't include the implementation of <code class="literal">PrintResults</code>, which you can imagine and which is also included in the <code class="literal">Chapter02_02</code> demo. The following result is expected:</p><div class="mediaobject"><img src="../Images/image00439.jpeg" alt="The true reason for delegates"/></div><p style="clear:both; height: 1em;"> </p></div>
<div class="section" title="The evolution in versions 2.0 and 3.0"><div class="titlepage" id="aid-K0RQ2"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>The evolution in versions 2.0 and 3.0</h1></div></div></div><p>As we see, even<a id="id210" class="indexterm"/> from the very beginning, the Hejlsberg's team started with a complete, flexible, and modern platform, capable of being extended in many ways as technology evolves. This intention became clear since version 2.0.</p><p>The first actual fundamental <a id="id211" class="indexterm"/>change that took place in the language was the incorporation of Generics. Don Syme, who would later on lead the team that created the F# language, was very active and led this team as well, so it was ready for version 2.0 of the .NET Framework (not just in C# but in C++ and VB.NET as well).</p><div class="section" title="Generics"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Generics</h2></div></div></div><p>The purpose of generics <a id="id212" class="indexterm"/>was mainly to facilitate the creation of more reusable code (one of the principles of OOP, by the way). The name refers to a set of language features that allow <a id="id213" class="indexterm"/>classes, structures, interfaces, methods, and delegates to be declared and defined with unspecified or generic type parameters instead <a id="id214" class="indexterm"/>of specific types (see <a class="ulink" href="https://msdn.microsoft.com/en-us/library/ms379564(v=vs.80).aspx">https://msdn.microsoft.com/en-us/library/ms379564(v=vs.80).aspx</a>, for more details).</p><p>So, you can define members in a sort of abstract definition, and later on, at the time of using it, a real, concrete type will be applied.</p><p>The basic .NET classes (BCL) were enhanced in the <code class="literal">System</code> namespace and a new <code class="literal">System.Collections.Generic</code> namespace was created to support this new feature in depth. In addition, new support methods were added to ease the use of this new type, such as <code class="literal">Type.IsGenericType</code> (obviously, to check types), <code class="literal">Type.GetGenericArguments</code> (self-descriptive), and the very useful <code class="literal">Type.MakeGenericType</code>, which can create a generic type of any kind from a previous nonspecified declaration.</p><p>The following code uses the generic type definition for a Dictionary (<code class="literal">Dictionary&lt;,&gt;</code>) and creates an actual (build) type using this technique. The relevant code is the following (the rest, including the output to the console is included in <code class="literal">Demo_02_03</code>):</p><div class="informalexample"><pre class="programlisting">// Define a generic Dictionary (the
// comma is enough for the compiler to infer number of
// parameters, but we didn't decide the types yet.
Type generic = typeof(Dictionary&lt;,&gt;);
ShowTypeData(generic);

// We define an array of types for the Dictionary (Key, Value)
// Key is of type string, and Value is of -this- type (Program)
// Notice that types could be -in this case- of any kind
Type[] typeArgs = { typeof(string), typeof(Program) };

// Now we use MakeGenericType to create a Type representing
// the actualType generic type.
Type actualType = generic.MakeGenericType(typeArgs);
ShowTypeData(actualType);</pre></div><p>As you see, <code class="literal">MakeGenericType</code> expects an array of (concrete) types. Later on (not in the preceding code), we use <code class="literal">GetGenericTypeDefinition</code>, <code class="literal">IsGenericType</code>, and <code class="literal">GetGenericArguments</code> in order to introspect the resulting types and present the following output in the<a id="id215" class="indexterm"/> console:</p><div class="mediaobject"><img src="../Images/image00440.jpeg" alt="Generics"/></div><p style="clear:both; height: 1em;"> </p><p>So, we have different ways to declare generics with identical results as far as the operations in the code are concerned.</p><p>Obviously, manipulating already constructed generic types is not the only possibility, since one of the main goals of generics is to avoid casting operations by simplifying the work with collections. Up until version 2.0, collections could only hold basic types: integers, longs, strings, and so on, along with emulating different types of data structures, such as stacks, queues, linked lists, and so on.</p><p>Besides this, Generics have another big advantage: you can write methods that support working with different types of arguments (and return values) as long as you provide a correct way to handle all <a id="id216" class="indexterm"/>possible cases.</p><p>Once again, the notion of contract will be crucial here.</p><div class="section" title="Creating custom generic types and methods"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec18"/>Creating custom generic types and methods</h3></div></div></div><p>Other useful feature is the possibility to use custom generic types. Generic types and the support for optional values through the <code class="literal">System.Nullable&lt;T&gt;</code> type were, for many developers, two of the <a id="id217" class="indexterm"/>most important features included in version 2.0 of the language.</p><p>Imagine you have a <code class="literal">Customer</code> class, which your application manages. So, in different use cases, you will read collections of customers and perform operations with them. Now, what if you need an operation such as <code class="literal">Compare_Customers</code>? What would be the criteria to use in this case? Even worse, what if we would like to use the same criteria with different types of entities, such as <code class="literal">Customer</code> and <code class="literal">Provider</code>?</p><p>In these cases, some characteristics of generics come in handy. To start with, we can build a class that has an implementation of the <code class="literal">IComparer</code> interface, so we establish beyond any uncertainty what the criteria to be used is in order to consider customer <code class="literal">C1</code> bigger or smaller than customer <code class="literal">C2</code>.</p><p>For instance, if the criteria is only <code class="literal">Balance</code>, we can start with a basic <code class="literal">Customer</code> class, to which we add a static method in order to generate a list of random customers:</p><div class="informalexample"><pre class="programlisting">public class Customer
{
  public string Name { get; set; }
  public string Country { get; set; }
  public int Balance { get; set; }
  public static string[] Countries = { "US", "UK", "India", "Canada", 	    "China" };
  public static List&lt;Customer&gt; customersList(int number)
  {
    List&lt;Customer&gt; list = new List&lt;Customer&gt;();
    Random rnd = new Random(System.DateTime.Now.Millisecond);
    for (int i = 1; i &lt;= number; i++)
    {
      Customer c = new Customer();
      c.Name = Path.GetRandomFileName().Replace(".", "");
      c.Country = Countries[rnd.Next(0, 4)];
      c.Balance = rnd.Next(0, 100000);
      list.Add(c);
    }
    return list;
  }
}</pre></div><p>Then, we build another <code class="literal">CustomerComparer</code> class, which implements the <code class="literal">IComparer</code> interface. The difference is that this comparison method is a generic instantiation customized for the <code class="literal">Customer</code> objects, so we have the freedom of implementing this scenario just in the way that seems convenient for our logic.</p><p>In this case, we're using <code class="literal">Balance</code> as an ordering criteria, so that we would have the following:</p><div class="informalexample"><pre class="programlisting">public class CustomerComparer : IComparer&lt;Customer&gt;
{
  public int Compare(Customer x, Customer y)
  {
    // Implementation of IComparer returns an int
    // indicating if object x is less than, equal to or
    // greater than y.
    if (x.Balance &lt; y.Balance) { return -1; }
    else if (x.Balance &gt; y.Balance) return 1;
    else { return 0; } // they're equal
  }
}</pre></div><p>We can see that the criteria used to <a id="id218" class="indexterm"/>compare is just the one we decided for our business logic. Finally, another class, <code class="literal">GenericCustomer</code>, which implements an entry point of the application, uses both classes in this manner:</p><div class="informalexample"><pre class="programlisting">public class GenericCustomers
{
  public static void Main()
  {
    List&lt;Customer&gt; theList = Customer.customersList(25);
    CustomerComparer cc = new CustomerComparer();
    // Sort now uses our own definition of comparison
    theList.Sort(cc);
    Console.WriteLine(" List of customers ordered by Balance");
    Console.WriteLine(" " + string.Concat(Enumerable.Repeat("-", 36)));
    foreach (var item in theList)
    {
      Console.WriteLine(" Name: {0},  Country: {1}, \t Balance: {2}",
      item.Name, item.Country, item.Balance);
    }
    Console.ReadKey();
  }
}</pre></div><p>This produces an output of random customers order by their balance:</p><div class="mediaobject"><img src="../Images/image00441.jpeg" alt="Creating custom generic types and methods"/></div><p style="clear:both; height: 1em;"> </p><p>This is even better: we can change the method so that it supports both customers and providers indistinctly. To do this, we need to abstract a common property of both entities that we can use for comparison.</p><p>If our implementation of <code class="literal">Provider</code> has different or similar fields (but they're not the same), it doesn't matter as long as we have the common factor: a <code class="literal">Balance</code> field.</p><p>So we begin with a simple <a id="id219" class="indexterm"/>definition of this common factor, an interface called <code class="literal">IPersonBalance</code>:</p><div class="informalexample"><pre class="programlisting">public interface IPersonBalance
{
  int Balance { get; set; }
}</pre></div><p>As long as our <code class="literal">Provider</code> class implements this interface, we can later create a common method that's able to compare both objects, so, let's assume our <code class="literal">Provider</code> class looks like this:</p><div class="informalexample"><pre class="programlisting">public class Provider : IPersonBalance
{
  public string ProviderName { get; set; }
  public string ShipCountry { get; set; }
  public int Balance { get; set; }

  public static string[] Countries = { "US", "Spain", "India", "France", "Italy" };
  public static List&lt;Provider&gt; providersList(int number)
  {
    List&lt;Provider&gt; list = new List&lt;Provider&gt;();
    Random rnd = new Random(System.DateTime.Now.Millisecond);
    for (int i = 1; i &lt;= number; i++)
    {
      Provider p = new Provider();
      p.ProviderName = Path.GetRandomFileName().Replace(".", "");
      p.ShipCountry = Countries[rnd.Next(0, 4)];
      p.Balance = rnd.Next(0, 100000);
      list.Add(p);
    }
    return list;
  }
}</pre></div><p>Now, we rewrite the <code class="literal">Comparer</code> method to be a <code class="literal">GenericComparer</code> class, capable of dealing with both types of entities:</p><div class="informalexample"><pre class="programlisting">public class GenericComparer : IComparer&lt;IPersonBalance&gt;
{
  public int Compare(IPersonBalance x, IPersonBalance y)
  {
    if (x.Balance &lt; y.Balance) { return -1; }
    else if (x.Balance &gt; y.Balance) return 1;
    else { return 0; }
  }
}</pre></div><p>Note that in this implementation, <code class="literal">IComparer</code> depends on an interface, not on an actual class, and that this interface<a id="id220" class="indexterm"/> simply defines the common factor of these entities.</p><p>Now, our new entry point will put everything together in order to obtain an ordered list of random <code class="literal">Provider</code> classes that uses the common comparison method just created:</p><div class="informalexample"><pre class="programlisting">public static void Main()
{
  List&lt;Provider&gt; providerList = Provider.providersList(25);
  GenericComparer gc = new GenericComparer();
  // Sort now uses our own definition of comparison
  providerList.Sort(gc);
  Console.WriteLine(" List of providers ordered by Balance");
  Console.WriteLine(" " + ("").PadRight(36, '-'));
  foreach (var item in providerList)
  {
    Console.WriteLine(" ProviderName: {0}, S.Country: {1}, \t Balance: {2}",
    item.ProviderName, item.ShipCountry, item.Balance);
  }
  Console.ReadKey();
}</pre></div><p>In this way, we obtain an output like <a id="id221" class="indexterm"/>what is shown in the following figure (note that we didn't take much care of formatting in order to focus on the process):</p><div class="mediaobject"><img src="../Images/image00442.jpeg" alt="Creating custom generic types and methods"/></div><p style="clear:both; height: 1em;"> </p><p>The example shows how generics (and interfaces: also generic) come to our rescue in these types of situations, and—as we'll have the opportunity to prove when talking about implementations of design patterns—this is key to facilitating good practice.</p><p>So far, some of the most<a id="id222" class="indexterm"/> critical concepts behind generics have been discussed. In up coming chapters, we'll see how other aspects related to generics show up. However, the real power comes from joining these capabilities with two new features of the language: lambda expressions and the LINQ syntax.</p></div></div><div class="section" title="Lambda expressions and anonymous types"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>Lambda expressions and anonymous types</h2></div></div></div><p>For a bit, let's review what happens when we create a new, anonymous type by invoking the <code class="literal">new</code> operator, followed by a description of the object:</p><div class="informalexample"><pre class="programlisting">// Anonymous object
var obj = new { Name = "John", Age = 35 };</pre></div><p>The compiler correctly infers<a id="id223" class="indexterm"/> the non-declared type to be<a id="id224" class="indexterm"/> anonymous. Actually, if we use the disassembler tool we saw in the previous chapter, we'll discover how the compiler assigns a default name to this class (<code class="literal">f_AnonymousType0`2</code>):</p><div class="mediaobject"><img src="../Images/image00443.jpeg" alt="Lambda expressions and anonymous types"/></div><p style="clear:both; height: 1em;"> </p><p>Also, we can see that a<a id="id225" class="indexterm"/> special constructor has been created along with two private fields and two access methods (<code class="literal">get_Age</code> and <code class="literal">get_Name</code>).</p><p>These kind of <a id="id226" class="indexterm"/>objects are especially suitable when we deal with data coming from any source, and we filter the information vertically (that is, we don't require all fields but just a few, or maybe even one).</p><p>The resulting objects coming from such a query are not previously defined anywhere in our code, since every different query would required a customized definition.</p><div class="section" title="Lambda expressions"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec19"/>Lambda expressions</h3></div></div></div><p>With that in mind, a lambda<a id="id227" class="indexterm"/> expression is just an anonymous function, which is expressed in a different syntax that allows you to pass such a function as an argument, much in the style of functional programming languages, such as JavaScript.</p><p>In C# 3.0, lambda expressions<a id="id228" class="indexterm"/> appeared with a simplified syntax that uses a lambda operator (<code class="literal">=&gt;</code>). This operator divides the defined function into two parts: the arguments to the left and the body to the right; for example, take a look at this:</p><div class="informalexample"><pre class="programlisting">( [list of arguments] ) =&gt; { [list of sentences] }</pre></div><p>This admits certain variations, such as the omission of parenthesis in the list of arguments and the omission of curly brackets in the body as long as the compiler is able to infer the details, types involved, and so on.</p><p>Since the preceding declaration is a delegate's definition, we can assign it to any delegate's variable, and so we can express the condition used when finding the divisible numbers by 3 or 7 in a much neater way:</p><div class="informalexample"><pre class="programlisting">DivisibleBy3Or7 ed3 = x =&gt; ((x % 3 == 0) || (x % 7 == 0));</pre></div><p>That is, variable <code class="literal">ed3</code> is assigned a lambda expression that receives an element (an <code class="literal">int</code>, in this case) and evaluates the body function, which calculates the same numbers as we did earlier. Note that the body function is not enclosed in curly brackets because the definition is clear enough for the compiler.</p><p>So, operating in this manner, there is no need to declare separated methods, and we can even pass one of these expressions as an argument to a method that accepts it like many of the generic collections do.</p><p>At this point, we start to see the power of all this when used in conjunction with generic collections. From version 3.0 of .NET framework, generic collections include a bunch of methods that admit lambda expressions as arguments.</p><div class="section" title="It's all about signatures"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec05"/>It's all about signatures</h4></div></div></div><p>The .NET framework team, however, went<a id="id229" class="indexterm"/> a bit deeper. If you abstract the possible signatures behind any delegate, you can categorize them in three blocks depending on the return value:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Delegates with no return value (called actions and defined with the <code class="literal">Action</code> keyword)</li><li class="listitem">Delegates that return a Boolean (now called predicates, such as in logic, but defined with the <code class="literal">Func</code> keyword)</li><li class="listitem">The rest of delegates, returning any type (also defined with the <code class="literal">Func</code> keyword)</li></ul></div><p>So, these three reserved words became part of the C# syntax, and all the generic methods we find in collections will ask us for one of these three types of delegates. A simple look at one of these in Visual Studio will show us this situation:</p><div class="mediaobject"><img src="../Images/image00444.jpeg" alt="It's all about signatures"/></div><p style="clear:both; height: 1em;"> </p><p>The screenshot shows the definition of the <code class="literal">Where&lt;T&gt;</code> method. Just think about it: the idea is to allow us to filter collection data in a manner similar to how the <code class="literal">where</code> clause does in the SQL syntax. What we<a id="id230" class="indexterm"/> express in a <code class="literal">where</code> clause is a Boolean condition, just like in Mathematical Logic, a predicate is an assertion that is always evaluated to be <code class="literal">true</code> or <code class="literal">false</code>.</p><p>For instance, we can recode the previous scenario using <code class="literal">numberList</code> directly, with something like this:</p><div class="informalexample"><pre class="programlisting">// Method Where in generic lists
numberList = numberList.Where(x =&gt; ((x % 3 == 0) || (x % 7 == 0))) .ToList();</pre></div><p>Same results are obtained with much less plumbing, so we can focus more on the problem to be solved and less on the algorithm required.</p><p>Many more methods were added and immediately accepted by the programmer's community due to the productivity linked to them. For the case with no return values, the body code is supposed to act over something external to the method. In our example, it could be something like adding a number to the list of selected values.</p><p>In this way, we can handle more complex situations, such as the case where we need to calculate multiples of two numbers starting with a certain digit, such as in this code:</p><div class="informalexample"><pre class="programlisting">// We can create a more complex function including
// any number of conditions
Action&lt;int&gt; MultipleConditions = n =&gt;
{
  if ((n % 3 == 0) &amp;&amp; (n % 2 == 0))
  {
    if (n.ToString().StartsWith("5")) {
      selectedNumbers.Add(n);
    }
  }
};
numberList.ForEach(MultipleConditions);</pre></div><p>In this variation, we use the <code class="literal">ForEach</code> method, which receives an <code class="literal">Action</code> delegate argument, as we can see in the tooltip definition offered by the IDE's Editor:</p><div class="mediaobject"><img src="../Images/image00445.jpeg" alt="It's all about signatures"/></div><p style="clear:both; height: 1em;"> </p><p>How do these sentences translate into real code? It might be a bit surprising for the curious reader to take a look at the MSIL code produced by this code. Even a simple lambda expression can become more complex than one might think a priori.</p><p>Let's take a look at the<a id="id231" class="indexterm"/> syntax of our previous <code class="literal">x  =&gt;  x % 3 == 0</code> lambda expression that we have been using. The trick here is that (internally) this is converted to a tree expression, and if you assign that expression to a variable of type <code class="literal">Expression&lt;TDelegate&gt;</code>, the compiler generates the code to build an expression tree representing that lambda expression.</p><p>So, consider that we express the lambda in its alternative syntax using an <code class="literal">Expression</code> object, such as in this code:</p><div class="informalexample"><pre class="programlisting">Expression&lt;Func&lt;int, bool&gt;&gt; DivBy3 = x =&gt; (x % 3) == 0;</pre></div><p>Once compiled, you can check the disassembly code and find the equivalent in the MSIL code, which is made up of several declarations of individual expressions, as shown in the following screenshot (just a fragment of what is inside):</p><div class="mediaobject"><img src="../Images/image00446.jpeg" alt="It's all about signatures"/></div><p style="clear:both; height: 1em;"> </p><p>This equivalence becomes more evident if we translate the code of one of these expressions into its individual parts. The official MSDN documentation gives us the clue by comparing a simple lambda built using expressions with its generated parts. So, they start by saying something like this:</p><div class="informalexample"><pre class="programlisting">// Lambda defined as an expression tree.
Expression&lt;Func&lt;int, bool&gt;&gt; xTree = num =&gt; num &gt; 3 ;</pre></div><p>This is followed by the<a id="id232" class="indexterm"/> decomposition of this expression tree:</p><div class="informalexample"><pre class="programlisting">// Decompose the expression tree.
ParameterExpression param = (ParameterExpression)exprTree.Parameters[0];
BinaryExpression operation = (BinaryExpression)exprTree.Body;
ParameterExpression left = (ParameterExpression)operation.Left;
ConstantExpression right = (ConstantExpression)operation.Right;
// And print the results, just to check.
Console.WriteLine("Expression: {0} =&gt; {1} {2} {3}",
  param.Name, left.Name, operation.NodeType, right.Value);</pre></div><p>Well, the result of this decomposition is as follows:</p><div class="mediaobject"><img src="../Images/image00447.jpeg" alt="It's all about signatures"/></div><p style="clear:both; height: 1em;"> </p><p>This is equivalent to the lambda expression, but now we can see that internally, operating with the individual components of the tree is equivalent to the shorten lambda expression.</p></div></div></div><div class="section" title="The LINQ syntax"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec30"/>The LINQ syntax</h2></div></div></div><p>The goal of all this, besides <a id="id233" class="indexterm"/>making things easier for the way we deal with collections, is to<a id="id234" class="indexterm"/> facilitate data management. That means reading information from a source and converting it into a collection of objects of the desired type, thanks to these generic collections.</p><p>However, what if I want to express a query in a similar syntax to a SQL query? Or, simply, what if the complexity of the query doesn't make it easy to express it with the generic methods indicated so far?</p><p>The solution came in form <a id="id235" class="indexterm"/>of a new syntax, inherent to the C# (and other .NET languages), called <span class="strong"><strong>LINQ</strong></span> (<span class="strong"><strong>Language-Integrated Query</strong></span>). The official definition presents this extension as <span class="emphasis"><em>a set of features introduced in Visual Studio 2008 that extends powerful query capabilities to the language syntax of C#</em></span>. Specifically, the authors highlight this feature as something that takes the form of <span class="emphasis"><em>LINQ provider assemblies that enable the use of LINQ with .NET Framework collections, SQL Server databases, ADO.NET Datasets, and XML documents</em></span>.</p><p>So, we are given a new SQL-like syntax to generate any kind of query in such a way that the same sentence structure is<a id="id236" class="indexterm"/> valid for very different data sources.</p><p>Remember that previously, data queries had to be expressed as strings without type checking at compile time or any kind of IntelliSense support, and it was mandatory to learn a different query language depending on the type of data source: SQL databases, XML documents, Web services, and so on.</p><div class="section" title="LINQ syntax is based on the SQL language"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec20"/>LINQ syntax is based on the SQL language</h3></div></div></div><p>In this case, as Hejlsberg<a id="id237" class="indexterm"/> mentioned many times, they had to change the order of the clauses if they wanted to provide any kind of Intellisense, so a query of this type adopts the form of this:</p><div class="informalexample"><pre class="programlisting">var query = from [element] in [collection]
where [condition1 | condition2 ...]
select [new] [element];</pre></div><p>In this way, once the user specifies the source (a collection), Visual Studio is able to provide you with Intellisense for the rest of the sentence. For instance, in order to select a few numbers from a number list, such as the ones used in previous examples, we can write the following:</p><div class="informalexample"><pre class="programlisting">// generate a few numbers
var numbers = Enumerable.Range(50, 200);
// use of linq to filter
var selected = from n in numbers
  where n % 3 == 0 &amp;&amp; n % 7 == 0
  select n;
Console.WriteLine("Numbers divisible by 3 and 7 \n\r");
// Now we use a lambda (Action) to print out results
selected.ToList().ForEach(n =&gt; Console.WriteLine("Selected: {0} ", n));</pre></div><p>Note that we have used the <code class="literal">&amp;&amp;</code> operator to concatenate both conditions (we'll go further into this in a bit), and there is no problem with using the LINQ syntax in conjunction with lambda expressions. Furthermore, it is recommended that you express the query in the more suitable, readable, and maintainable way. Of course, the output is still what is expected:</p><div class="mediaobject"><img src="../Images/image00448.jpeg" alt="LINQ syntax is based on the SQL language"/></div><p style="clear:both; height: 1em;"> </p><p>The only condition required for the collection is that it should support <code class="literal">IEnumerable</code> or the generic <code class="literal">IEnumerable&lt;T&gt;</code> interfaces (or any other interface that inherits from it).</p><p>As you may expect, often, the <a id="id238" class="indexterm"/>collection is just a previously obtained collection of business logic objects as the result of a query to a database table.</p></div><div class="section" title="Deferred execution"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec21"/>Deferred execution</h3></div></div></div><p>However, there is a very important point to<a id="id239" class="indexterm"/> remember: the LINQ syntax itself uses a model called <span class="emphasis"><em>deferred execution</em></span> or <span class="emphasis"><em>lazy loaded</em></span>. This means that a query is not executed until the first bit of data is required by another sentence.</p><p>Anyway, we can force the execution by converting the resulting collection into a concrete collection, for example, by calling the <code class="literal">ToList()</code> method or requiring other data linked to the actual use of the collection, such as counting the number of rows returned.</p><p>This is something we can do by enclosing the LINQ query in parenthesis and applying the solicited operation (note that the value returned is automatically converted into the appropriate type), as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00449.jpeg" alt="Deferred execution"/></div><p style="clear:both; height: 1em;"> </p><p>In a similar way, we can order the <a id="id240" class="indexterm"/>resulting collection in an ascending (the default) or descending manner using the <code class="literal">ad-hoc</code> clause:</p><div class="informalexample"><pre class="programlisting">var totalNumbers = (from n in numbers
  where n % 3 == 0 &amp;&amp; n % 7 == 0
  orderby n descending
  select n).Count();</pre></div></div><div class="section" title="Joining and grouping collections"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec22"/>Joining and grouping collections</h3></div></div></div><p>In the same way as we<a id="id241" class="indexterm"/> mimic the syntax of SQL for other queries, it's<a id="id242" class="indexterm"/> perfectly possible to use other advanced features of the SQL language, such as grouping and joining several collections.</p><p>For the first case (grouping), the syntax is fairly simple. We just have to indicate the grouping factor using the group / by / into clause in this manner:</p><div class="informalexample"><pre class="programlisting">string[] words = { "Packt", "Publishing", "Editorial", "Books", "CSharp", "Chapter" };
var wordsGrouped = from w in words
group w by w[0] into groupOfWords
select new { FirstLetter = groupOfWords.Key, Words = groupOfWords };
Console.WriteLine(" List of words grouped by starting letter\n\r");
foreach (var indGroup in wordsGrouped)
{
  Console.WriteLine(" Starting with letter '{0}':", indGroup.FirstLetter);
  foreach (var word in indGroup.Words)
  {
    Console.WriteLine(" " + word);
  }
}</pre></div><p>Note that we use a nested loop to print the results (one for the groups of words and another for the words themselves). The previous code generates the following output:</p><div class="mediaobject"><img src="../Images/image00450.jpeg" alt="Joining and grouping collections"/></div><p style="clear:both; height: 1em;"> </p><p>For the case of joining, we use the <code class="literal">join</code> clause together with the <code class="literal">equals</code>, <code class="literal">as</code>, and <code class="literal">is</code> operators to express conditions for the junction.</p><p>A simple example could be<a id="id243" class="indexterm"/> the joining of two different sets of numbers in the search for <a id="id244" class="indexterm"/>common elements of any kind. Every set would express a unique condition and the join would establish the common factor.</p><p>For instance, starting with our selected numbers (divisible by 3 and 7), let's add another subset of those that start with 7:</p><div class="informalexample"><pre class="programlisting">var numbersStartingBy7 = from n in numbers
where n.ToString().StartsWith("7")
select n;</pre></div><p>Now, we have two different subsets with different conditions. We can find out which among them fulfills both conditions, expressing the requirement by means of a join between both subsets:</p><div class="informalexample"><pre class="programlisting">var doubleMultiplesBeg7 = from n in selected
join n7 in numbersStartingBy7
on n equals n7
select n;</pre></div><p>We find a total of five<a id="id245" class="indexterm"/> numbers that start with 7, both being multiples of 3 and 7, as shown<a id="id246" class="indexterm"/> in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00451.jpeg" alt="Joining and grouping collections"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Type projections"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec23"/>Type projections</h3></div></div></div><p>Another option (and a very interesting one) is the capability of projecting the required output to an<a id="id247" class="indexterm"/> anonymous type (inexistent), which is the result of a selection or which includes the creation of another calculated field.</p><p>We perform this action by creating the anonymous output type in the <code class="literal">select</code> declaration of the LINQ query, with the capability of naming the desired results the way we want (just like when we create another anonymous type). For instance, if we need another column indicating the even or odd character of the resulting numbers, we can add the following expression to the previous query like this:</p><div class="informalexample"><pre class="programlisting">var proj = from n in selected
join n7 in numbersStartingBy7 on n equals n7
select new { Num = n, DivBy2 = (n % 2 == 0) ? "Even" : "Odd" };</pre></div><p>What follows the <code class="literal">select</code> clause is an anonymous type composed of two fields, <code class="literal">Num</code> and <code class="literal">DivBy2</code>, using a simple <code class="literal">?</code> operator expression, which checks the integer division by 2, the same way we did it earlier. The results look like what is shown in the following output:</p><div class="mediaobject"><img src="../Images/image00452.jpeg" alt="Type projections"/></div><p style="clear:both; height: 1em;"> </p><p>Besides auxiliary <a id="id248" class="indexterm"/>operations like these, the LINQ syntax is especially useful when dealing with databases. Just think of the source collections as return values obtained by querying a valid data origin, which—in all cases—will implement the <code class="literal">IEnumerable</code> and/or <code class="literal">IQueryable</code> interfaces, which is what happens when we access a real database engine using Entity framework, for example.</p><p>We will cover database access in the upcoming chapters, so just keep in mind this methodology that will be applied when we query real data.</p></div></div><div class="section" title="Extension methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Extension methods</h2></div></div></div><p>Finally, we can extend existing classes' functionality. This means extending even the .NET Framework base types, such as <code class="literal">int</code> or <code class="literal">String</code>. This is a very useful feature, and it's performed in the way it is recommended by the documentation; no violation of basic principles of OOP occurs.</p><p>The procedure is fairly simple. We<a id="id249" class="indexterm"/> need to create a new public static top level (not nested) class containing a public static method with an initial argument declaration especially suited for the compiler to assume that the compiled code will be appended to the actual functionality of the type.</p><p>The procedure can be used with any class, either belonging to the .NET framework or a customized user or class.</p><p>Once we have the declaration, its usage is fairly simple, as shown in this code:</p><div class="informalexample"><pre class="programlisting">public static class StringExtension
{
  public static string ExtendedString(this string s)
  {
    return "{{ " + s + " }}";
  }
}</pre></div><p>Note that the first argument, referred with the <code class="literal">this</code> keyword, references the string to be used; so, in this example, we will call the method without any extra arguments (although we can pass as many<a id="id250" class="indexterm"/> arguments as we need for other extensions). To put it to work, we just have to add something like this:</p><div class="informalexample"><pre class="programlisting">Console.WriteLine("The word " + "evaluate".ExtendedString() + " is extended");</pre></div><p>We will get the extended output with the word enclosed in double brackets:</p><div class="mediaobject"><img src="../Images/image00453.jpeg" alt="Extension methods"/></div><p style="clear:both; height: 1em;"> </p></div></div>
<div class="section" title="Summary" id="aid-KVCC1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Summary</h1></div></div></div><p>In this chapter, we saw some of the most relevant enhancements made to the C# language in versions 2 and 3.</p><p>We started by reviewing the main differences between C# and other languages and understanding the meaning of strongly typed, in this case, together with the concepts of static and dynamic.</p><p>Then, we explained some of the main reasons behind the creation of the concept of delegates—absolutely crucial in .NET—and whose origins were motivated by very serious and solid architectural reasons. We also revised .NET usage in several common programming scenarios.</p><p>We followed this up with an examination of the generics feature that appeared in version 2.0 of the framework and analyzed some samples to illustrate some typical use cases, including the creation of custom generic methods.</p><p>From generics, we moved on to Lambda expressions, which appeared in the version that follows, allowing us to simplify calls to generic methods by passing anonymous methods expressed in a very elegant syntax.</p><p>Finally, we covered the LINQ syntax, which permits the implementation of complex queries to a collection in a way that strongly reminds you about the SQL syntax you surely know and use.</p><p>We ended with a simple extension method to check how we can use the existing functionality in order to extend its default methods in a way that suits our programming requirements without affecting the original definitions.</p><p>In the next chapter, we'll look at news and enhancements that appeared in the recent versions of the framework (4, 4.5, and 4.6), which include dynamic definitions, improved logical expressions, new operators, and so on.</p></div></body></html>