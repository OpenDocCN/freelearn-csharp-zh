- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Effective Game Data Handling and Management with C# in Unity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to [*Chapter 6*](B22017_06.xhtml#_idTextAnchor098), where we’ll delve
    into effective game data handling and management using C# in Unity. Through practical
    exploration, you’ll learn how to organize, store, and retrieve game data seamlessly.
    From understanding data organization and serialization to implementing save and
    load systems, you’ll be able to empower players to preserve their progress and
    craft dynamic, data-driven gameplay experiences. By the end of this chapter, you’ll
    have mastered the art of wielding C# for efficient game data management, unlocking
    endless possibilities for immersive gameplay. Let’s embark on this journey together,
    where mastery of game data opens doors to boundless creativity in game development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Data organization and serialization with C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating save and load systems using C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data-driven gameplay with C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you must have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unity version 2022.3.13**: Download and install Unity, choosing version **2022.3.13**
    for optimal compatibility with the provided content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Primary IDE – Visual Studio 2022**: The tutorials and code samples in this
    chapter have been crafted using Visual Studio 2022\. Ensure it’s installed so
    that you can follow along seamlessly. Feel free to explore Rider or other IDEs
    if you prefer, though note that the instructions that have been provided are tailored
    for Visual Studio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub repository for code samples**: You can access the code samples and
    project files for this chapter via this book’s dedicated GitHub repository: [https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2006](https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2006).
    Clone or download the repository so that you have easy access to the code provided
    in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data organization and serialization with C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll dive into data organization and serialization with C#
    in Unity. Here, we’ll learn how to manage game data efficiently. First, we’ll
    talk about picking the right data structures, such as arrays and lists, and how
    to make your own. Then, we’ll cover serialization, which helps save and load game
    data. Then, we’ll explore Unity’s options, such as **JavaScript Object Notation**
    (**JSON**) and **eXtensible Markup Language** (**XML**). By covering some simple
    examples, we’ll show you how to organize and save game data neatly using C#. Let’s
    start learning how to master game data management!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding data structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Selecting the appropriate data structure for storing information in your game
    involves considering factors such as the type of data, how frequently it will
    be accessed, and the operations you need to perform on that data. Here are some
    examples to illustrate how you can choose the right method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrays**: Use arrays when you have a fixed-size collection of elements of
    the same type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance, if you have a game with a set number of levels, as shown in the
    following code, you might use an array to store level data, such as scores or
    the completion status for each level:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Lists**: Lists are dynamic arrays that can grow or shrink in size at runtime.
    They are suitable when you need to add or remove elements frequently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, if you have a game with an inventory system where items can be
    added or removed dynamically, a list would be more appropriate. Take a look at
    the following code for an example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Dictionaries**: Dictionaries are useful when you need to associate keys with
    values. They are ideal for situations where you need to quickly look up values
    based on specific keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance, if you have a game with a leaderboard, you might use a dictionary
    to map player names to their scores, as shown here:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '**Custom data structures**: Sometimes, none of the built-in data structures
    are the perfect fit for your needs. In such cases, you can create custom data
    structures tailored to your specific requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, if you’re developing a complex RPG game, you might create a custom
    data structure to represent character attributes and abilities. The **Character**
    class is one such custom data structure:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: By carefully considering the nature of your data and the operations you need
    to perform, you can choose the most appropriate data structure for your game,
    ensuring optimal performance and efficient data management.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing game performance with proper data structure selection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the world of game creation, where speed and efficiency matter most, picking
    the right data structures is crucial. It helps game makers achieve smoother and
    faster gameplay, making their games more enjoyable for players.
  prefs: []
  type: TYPE_NORMAL
- en: 'Choosing the appropriate data structure can significantly benefit game performance
    in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Optimized memory usage**: Using the right data structure helps minimize memory
    usage, which is crucial for performance, especially in resource-intensive games.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, if your game only needs to store a fixed number of elements of
    the same type, using an array instead of a list can save memory because arrays
    have a fixed size.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Faster access and retrieval**: Certain data structures offer faster access
    and retrieval times, which can improve overall game responsiveness.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For instance, dictionaries provide constant-time lookups, making them ideal
    for scenarios where you need to quickly retrieve values based on keys, such as
    accessing player data in a leaderboard.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficient data manipulation**: Choosing the appropriate data structure can
    streamline data manipulation operations, leading to smoother gameplay experiences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists, for example, allow for efficient insertion and removal of elements, making
    them suitable for dynamic scenarios such as managing an inventory where items
    are frequently added or removed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced code readability and maintainability**: Using the right data structure
    can make your code more readable and maintainable, leading to easier debugging
    and future updates. Custom data structures tailored to your game’s specific needs
    can improve code organization and clarity, making it easier for you and other
    developers to understand and modify the code base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For instance, if your game includes challenges, you can design a custom class
    specifically for managing these challenges. Within this class, you can incorporate
    attributes such as a list of rewards and a unique identifier for each challenge.
    This approach enhances the readability of your code base.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced processing overhead**: Optimal data structures help reduce processing
    overhead, contributing to smoother gameplay and better overall performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, if your game needs to iterate through a collection of elements
    in a specific order, using a list instead of a dictionary can eliminate unnecessary
    key-value pair lookups, resulting in faster iteration times.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, selecting the appropriate data structure is critical for optimizing
    game performance as it helps minimize memory usage, improve access times, streamline
    data manipulation, enhance code readability, and reduce processing overhead. By
    understanding the characteristics and advantages of different data structures,
    game developers can design more efficient and responsive gameplay experiences
    for players.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming subsection, we’ll delve deeper into Unity’s serialization, exploring
    its role in efficiently saving and loading data.
  prefs: []
  type: TYPE_NORMAL
- en: Serialization in Unity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Serialization** is the process of converting complex objects or data structures
    into a format that can be easily stored or transmitted and then reconstructed
    later. In the context of Unity game development, serialization plays a crucial
    role in saving and loading game data. By serializing game objects and their properties,
    Unity can store them in a format that can be saved to disk or transferred over
    the network, allowing for persistence between sessions and enabling features such
    as saving games and networked multiplayer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Serialization is a fundamental aspect of game development for several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Persistence between sessions**: Serialization allows game state and player
    progress to be saved and loaded between gameplay sessions. This enables features
    such as saving and loading game progress, maintaining player inventories, and
    preserving game settings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network communication**: Serialization facilitates transmitting game data
    over the network, which is essential for multiplayer games, client-server architectures,
    and online features. By serializing game objects and messages, Unity can send
    data between clients and servers efficiently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data interchange**: Serialization allows data to be exchanged between different
    systems and platforms. For example, game data can be serialized into a standardized
    format such as JSON or XML, allowing it to be shared with other applications or
    integrated with web services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data persistence**: Serialization allows data to be stored in a structured
    format, such as files or databases, ensuring that it persists even when the game
    isn’t running. This is crucial for features such as saving and loading user preferences,
    high scores, and game configurations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By understanding the principles of serialization and mastering Unity’s serialization
    options, we can implement robust and flexible data management systems, enabling
    features such as save games, networked multiplayer, and data-driven gameplay mechanics.
    Serialization is a fundamental tool in our toolkit, empowering us to create immersive
    and dynamic gaming experiences across platforms and genres.
  prefs: []
  type: TYPE_NORMAL
- en: In Unity, serialization is seamlessly integrated into the engine’s workflow,
    allowing us to easily save and load game data using built-in APIs and utilities.
    Unity provides various serialization options, including JSON, XML, and binary
    serialization, each suited to different use cases and requirements. As we can
    see in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore the options that are available in Unity so that we can integrate
    them into our game. We’ll begin by defining each option and providing an example
    for better understanding. We’ll delve into each one and illustrate their usage.
  prefs: []
  type: TYPE_NORMAL
- en: JSON serialization and deserialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JSON is a lightweight data-interchange format that is commonly used for transmitting
    data between a server and a web application. In Unity, JSON serialization and
    deserialization are useful for scenarios where you need to exchange data with
    external systems or web services.
  prefs: []
  type: TYPE_NORMAL
- en: '*Example*: In the following code block, we’re utilizing Unity’s built-in system
    to serialize and deserialize data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: XML serialization and deserialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: XML is a versatile format that is used for data exchange and configuration settings.
    Unity supports XML serialization and deserialization, making it suitable for scenarios
    where you need to work with legacy systems or integrate with platforms that use
    XML as the data interchange format.
  prefs: []
  type: TYPE_NORMAL
- en: '*Example*: The following code block demonstrates how to serialize and deserialize
    data to and from XML.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To utilize this type of serialization, you must include the `using System.IO;`
    and `using System.Xml.Serialization;` namespaces, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look at the XML serialization and deserialization provided
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Serialization process**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serialization is the process of converting an object into a format that can
    be easily stored or transmitted and reconstructed later
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XmlSerializer** is a class provided by the .NET framework for serializing
    and deserializing objects to and from XML format'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XmlSerializer serializer = new XmlSerializer(typeof(MyClass));**: This line
    creates an instance of the **XmlSerializer** class that specifies the type of
    object (**MyClass**) to be serialized'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**StringWriter writer = new StringWriter();**: This line creates a **StringWriter**
    object, which is used to write XML content as a string'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**serializer.Serialize(writer, myObject);**: This line serializes the **myObject**
    instance of **MyClass** into XML format and writes it to **StringWriter**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**string xmlString = writer.ToString();**: This line converts the XML content
    written to **StringWriter** into a string representation and stores it in the
    **xmlString** variable'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deserialization process**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deserialization is the process of reconstructing an object from its serialized
    XML representation.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**StringReader reader = new StringReader(xmlString);**: This line creates a
    **StringReader** object, which is used to read XML content from a string.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**(MyClass)serializer.Deserialize(reader);**: This line deserializes the XML
    content from **StringReader** back into an object of the **MyClass** type. The
    **Deserialize** method of the **XmlSerializer** class is used for this purpose.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The deserialized object is then assigned to the **deserializedObject** variable,
    ready for use in the program.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, the provided code block demonstrates how to serialize an object
    of the `MyClass` type as an XML string and then deserialize the XML string back
    into an object of the same type using the `XmlSerializer` class in C#. This process
    allows objects to be easily persisted to storage or transmitted over a network
    in XML format and reconstructed later for use in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Binary serialization and deserialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Binary serialization and deserialization are ideal for scenarios where you need
    to save and load game data efficiently, such as implementing save games or storing
    configuration settings locally on the user’s device. Binary serialization provides
    a compact representation of data and faster read/write times compared to text-based
    formats such as JSON or XML.
  prefs: []
  type: TYPE_NORMAL
- en: '*Example*: The following code block shows how to serialize and deserialize
    data to and from binary format.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To utilize this type of serialization, you must include the `using System.IO;`
    and `using System.Runtime.Serialization.Formatters.Binary;` namespaces, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look at this code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Serialization process**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serialization is the process of converting an object into a format that can
    be easily stored or transmitted and reconstructed later
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BinaryFormatter** is a class provided by the .NET framework for serializing
    and deserializing objects to and from binary format'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BinaryFormatter formatter = new BinaryFormatter();**: This line creates an
    instance of the **BinaryFormatter** class, which is used for binary serialization'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MemoryStream stream = new MemoryStream();**: This line creates a **MemoryStream**
    object, which is used to store binary data in memory'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**formatter.Serialize(stream, myObject);**: This line serializes the **myObject**
    instance into binary format and writes it to **MemoryStream**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**byte[] binaryData = stream.ToArray();**: This line converts the binary data
    written to **MemoryStream** into a byte array, which can be easily stored or transmitted'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deserialization process**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deserialization is the process of reconstructing an object from its serialized
    binary representation.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**stream = new MemoryStream(binaryData);**: This line creates a new **MemoryStream**
    object, initialized with the binary data stored in the **binaryData** byte array.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**(MyClass)formatter.Deserialize(stream);**: This line deserializes the binary
    data from the **MemoryStream** back into an object of the **MyClass** type. The
    **Deserialize** method of the **BinaryFormatter** class is used for this purpose.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The deserialized object is then assigned to the **deserializedObject** variable,
    ready for use in the program.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, the preceding code block demonstrates how to serialize an object
    of the `MyClass` type to binary format and then deserialize the binary data back
    into an object of the same type using the `BinaryFormatter` class in C#. This
    process allows objects to be easily persisted to storage or transmitted over a
    network in binary format and reconstructed later for use in the application.
  prefs: []
  type: TYPE_NORMAL
- en: ScriptableObject serialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**ScriptableObjects** are Unity assets that allow you to store data in a serialized
    format and create custom editor interfaces for modifying that data in Unity Editor.
    They are useful for managing configuration settings, defining game parameters,
    and creating reusable components that can be shared across multiple game objects.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Example*: In the following code blocks, we will explore an example of scriptable
    object data. Then, we’ll demonstrate how to utilize serialization and deserialization
    with scriptable objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first code block contains a ScriptableObject that’s designed for game settings,
    encapsulating essential data relevant to the game’s operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For the second code block, the `SettingsManager` class contains a reference
    to the `GameSettings` data and includes functions for saving and loading settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look at the `SettingsManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **SaveSettings()** method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**public void** **SaveSettings() { ... }**: This method is responsible for
    saving the game settings to a file'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JsonUtility.ToJson(gameSettings)**: This method serializes the **gameSettings**
    object to JSON format'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System.IO.File.WriteAllText(...)**: This method writes the serialized JSON
    data to a file named **settings.json** in the persistent data path of the application'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **LoadSettings()** method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**public void LoadSettings() { ... }**: This method is responsible for loading
    the game settings from a file'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System.IO.File.Exists(...)**: This method checks if the **settings.json**
    file exists in the persistent data path'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System.IO.File.ReadAllText(...)**: This method reads the JSON data from the
    **settings.json** file'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JsonUtility.FromJson<GameSettings>(jsonSettings)**: This method deserializes
    the JSON data back into a **GameSettings** object and assigns it to the **gameSettings**
    variable'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, the `SettingsManager` class provides functionality to save and load
    game settings using JSON serialization and deserialization. It demonstrates basic
    file I/O operations in Unity for handling persistent data.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding ScriptableObjects, we have the flexibility to save them using XML
    or binary formats, and we can treat them as custom classes that encapsulate specific
    data.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, choosing the appropriate serialization and deserialization options
    in Unity depends on factors such as data interchange requirements, performance
    considerations, and integration with external systems. Understanding the strengths
    and limitations of each option allows developers to make informed decisions and
    implement efficient data management solutions in their Unity projects.
  prefs: []
  type: TYPE_NORMAL
- en: Having understood the importance of data organization, let’s consider the role
    save and load systems can play in a game’s management.
  prefs: []
  type: TYPE_NORMAL
- en: Creating save and load systems using C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Save and load systems play a pivotal role in managing game progress and ensuring
    seamless player experiences. In this section, we’ll delve into various methods,
    from basic **PlayerPrefs** to more robust file-based save systems, enabling us,
    as developers, to preserve and retrieve player data within Unity efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: PlayerPrefs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PlayerPrefs in Unity serve as a straightforward solution for storing key-value
    pairs, which is crucial for preserving simple game data. Understanding PlayerPrefs
    is fundamental for efficiently managing basic player preferences and progress
    within Unity projects. Operating as a key-value store, PlayerPrefs is specifically
    designed for storing player preferences and small data amounts between game sessions.
    Its simple interface facilitates setting and retrieving data, making it ideal
    for managing settings, user preferences, and basic game progress.
  prefs: []
  type: TYPE_NORMAL
- en: Usage tips
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s explore essential usage tips for maximizing the benefits of PlayerPrefs
    in Unity game development, including insights into data serialization, encryption,
    and security measures, as well as performance optimization techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data serialization**: While PlayerPrefs natively supports storing basic data
    types, such as integers, floats, and strings, more complex data structures require
    serialization. We can serialize custom data structures into a format that’s compatible
    with PlayerPrefs, enabling us to store and retrieve complex game data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encryption and security**: You can protect sensitive player data by implementing
    encryption mechanisms before storing them in PlayerPrefs. By encrypting PlayerPrefs
    data, we can safeguard against unauthorized access and protect player privacy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimizing performance**: PlayerPrefs access involves disk I/O operations,
    which can impact performance, especially in resource-intensive games. To mitigate
    performance overhead, batch PlayerPrefs operations where possible and minimize
    frequent read/write operations during gameplay.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorporating these usage tips will help us optimize PlayerPrefs usage, ensuring
    data security, performance efficiency, and effective handling of complex game
    data in Unity projects.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at an example demonstrating how to utilize PlayerPrefs for saving
    and loading data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this first code block, the `GameData` class is a custom class containing
    game data fields that must be saved and loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The second code block contains the save and load functions, which use PlayerPrefs
    with the `GameData` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look at the saving and loading functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SaveGame()**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This function is responsible for saving the game data.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It initializes a new instance of the **GameData** class, which likely contains
    fields representing various aspects of the game state.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The current game state is then captured and stored in the **GameData** instance.
    In this example, it appears to be capturing the player’s level and experience
    from a **PlayerController** singleton instance.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, the game data is serialized to JSON format using **JsonUtility.ToJson()**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the serialized JSON data is stored in **PlayerPrefs** using **PlayerPrefs.SetString()**
    with the **GameData** key, and **PlayerPrefs.Save()** is called to persist the
    changes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LoadGame()**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This function loads the saved game data.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: First, it checks if existing game data is stored in **PlayerPrefs** by using
    the **GameData** key alongside **PlayerPrefs.HasKey()**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is saved data, it retrieves the serialized JSON string from **PlayerPrefs**
    using **PlayerPrefs.GetString("GameData")**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The JSON data is then deserialized back into a **GameData** object using **JsonUtility.FromJson<GameData>()**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the loaded game data is applied to the game state. In this example,
    it seems to be setting the player’s level and experience back to their saved values.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, these functions provide a simple mechanism for saving and loading game
    data using PlayerPrefs, allowing for basic persistence of game state between sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve discussed the significant benefits of PlayerPrefs, let’s examine
    situations where it may not be the optimal choice.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the limitations and alternatives to PlayerPrefs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While PlayerPrefs offers convenience and simplicity for storing small amounts
    of data in Unity games, it also has several limitations and disadvantages that
    may prompt us to explore alternative solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Limited storage capacity**: PlayerPrefs has a limited storage capacity, making
    it unsuitable for storing large amounts of data or complex data structures. Attempting
    to store excessive data in PlayerPrefs can lead to performance issues and memory
    constraints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security concerns**: PlayerPrefs data is stored in plain text in the player’s
    registry (on Windows) or a **plist** file (on macOS and iOS), making it susceptible
    to tampering and unauthorized access. For applications that require enhanced security
    measures or compliance with data protection regulations, PlayerPrefs may not provide
    adequate protection for sensitive data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform dependencies**: PlayerPrefs storage locations and behavior may vary
    across different platforms and devices. This platform dependency can introduce
    inconsistencies and compatibility issues when deploying games to multiple platforms,
    requiring developers to implement platform-specific handling or alternative storage
    solutions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited data types**: PlayerPrefs supports a limited set of data types, including
    integers, floats, and strings. Complex data structures, arrays, or custom objects
    cannot be directly stored in PlayerPrefs without serialization and conversion,
    leading to additional complexity and potential performance overhead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistence challenges**: PlayerPrefs data is persisted across game sessions,
    but it may not persist across different devices or installations. Uninstalling
    or reinstalling the game, clearing application data, or switching devices can
    result in the loss of PlayerPrefs data, affecting player progress and preferences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance overhead**: Accessing PlayerPrefs involves disk I/O operations,
    which can introduce performance overhead, especially when reading or writing large
    amounts of data frequently. For applications that require high-performance data
    storage or real-time data access, PlayerPrefs may not meet performance requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to these limitations and considerations, we may opt for alternative data
    storage solutions, such as binary serialization, JSON serialization, database
    systems, or cloud-based storage services. These solutions offer greater flexibility,
    scalability, security, and performance for managing game data, especially in scenarios
    involving large datasets, complex data structures, or stringent security requirements.
    While PlayerPrefs remains a convenient option for simple data storage needs, we
    should carefully evaluate our requirements and consider alternative solutions
    when designing data management systems for Unity games.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Save System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the constantly changing world of game creation, the need for strong and flexible
    save systems becomes more and more clear. Enter the Custom Save System – a smart
    solution that’s designed to handle the complexities of data management with skill
    and effectiveness. Unlike usual methods, such as PlayerPrefs, the **Custom Save
    System** gives us a versatile set of tools, including encryption, options for
    saving to the cloud, and smooth integration with scriptable objects.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Save System features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s explore what features we can use in our custom save system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generic functionality**: The custom save system boasts generic functions
    for saving and loading data, allowing for seamless integration with various scriptable
    objects. With dynamic parameters and return values tailored to the specific needs
    of each data type, it ensures adaptability and versatility in data management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encryption and decryption**: Security is paramount in the world of game development.
    Leveraging encryption and decryption mechanisms, the Custom Save System ensures
    the confidentiality and integrity of sensitive player data. Through robust cryptographic
    algorithms, it guards against unauthorized access and tampering, fostering player
    trust and confidence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll kick things off by crafting ScriptableObjects to manage the system’s
    data. I’ll draft the `PlayerData` script, which will store essential player information,
    as demonstrated in the subsequent code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, I’ll craft a script for `GameSettings`, which will store relevant
    game data, as exemplified in the subsequent code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating these scripts, you can right-click, select `Data` and placing
    the instances inside it. Once you’ve done this, they’ll be structured similarly
    to the settings instance shown in *Figure 6**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Game Settings ScriptableObject instance](img/B22017_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Game Settings ScriptableObject instance
  prefs: []
  type: TYPE_NORMAL
- en: These data files have been provided for demonstration purposes only, allowing
    you to adjust them according to your project requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll proceed by creating a save manager script. However, before diving
    into that, we must integrate `2022.3.13`. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the top bar and open the **Window** menu, then select **Package
    Manager**. Click on the **Add** button located in the top-left corner. This action
    will prompt a menu to appear, as shown in *Figure 6**.2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Adding the package from the git URL in the Package Manager panel](img/B22017_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Adding the package from the git URL in the Package Manager panel
  prefs: []
  type: TYPE_NORMAL
- en: 'Paste [com.unity.nuget.newtonsoft-json](https://com.unity.nuget.newtonsoft-json)
    into the provided panel, then click **Add**, as depicted in *Figure 6**.3*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Adding the link for the git URL in the Package Manager panel](img/B22017_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Adding the link for the git URL in the Package Manager panel
  prefs: []
  type: TYPE_NORMAL
- en: Wait for the installation to finish and for Unity Editor to compile before creating
    the `SaveManager` script.
  prefs: []
  type: TYPE_NORMAL
- en: The SaveManager script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This script is the fundamental component that’s responsible for saving and
    loading data in our game. As mentioned earlier, this approach is not standard,
    but rather one method we’ll utilize for our game. Feel free to adopt this method
    or implement your own approach according to your needs. The following code block
    contains the `SaveManager` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look at the save and load methods that will be used from
    other scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SaveData**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saves a key-value pair to a file
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Loads existing data, updates or adds new data based on the key, and serializes
    the dictionary to JSON
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypts the JSON data and writes it to the file
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LoadData**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loads data from the save file based on the provided key
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Checks if the key exists in the dictionary and returns the corresponding value
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Logs a warning and returns **null** if the key doesn’t exist
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code block contains static methods that handle input/output operations
    to load and save game data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look at the previous code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '**LoadSavedData**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loads saved data from the file and returns it as a dictionary
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reads encrypted data, decrypts it, deserializes JSON into a dictionary, and
    returns it
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DeleteSaveData**: Deletes the save data file if it exists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following code block, we’re dealing with encryption and decryption to
    secure the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s consider the encryption methods (`EncryptData` and `DecryptData`):'
  prefs: []
  type: TYPE_NORMAL
- en: Encrypts and decrypts data using the **AES** encryption algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypts input data using the encryption key and **IV** (**EncryptData**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decrypts encrypted data using the same key and **IV** (**DecryptData**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this script, there’s a method called `SaveData` for saving data. It requires
    the data to be in string format, along with its corresponding key. We have opted
    to store the data in a dictionary of string and string, enabling us to easily
    manage loading and saving data for various files.
  prefs: []
  type: TYPE_NORMAL
- en: For loading, we’re decrypting the string data and then loading it.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, I’ve implemented **AES encryption** methods to secure the data
    during encryption and decryption processes. While the details of AES encryption
    are beyond the scope of this book, you’re encouraged to explore it further if
    you’re interested in learning about encryption techniques.
  prefs: []
  type: TYPE_NORMAL
- en: To facilitate the generation of keys and IV, I’ve prepared a helper script.
    You can utilize this script by attaching it to a GameObject within your scene.
    This script will enable you to create the necessary key and IV for encryption
    purposes. You can find the generated keys in the `SaveManager` script; there’s
    no need to repeat the creation process as it only occurs once.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can obtain the `KeyAndIVGenerator` script from the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an explanation of the `KeyAndIVGenerator` class:'
  prefs: []
  type: TYPE_NORMAL
- en: The **KeyAndIVGenerator** class contains a method named **GenerateKeyAndIV**,
    which is responsible for generating encryption keys and **initialization** **vectors**
    (**IVs**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the **GenerateKeyAndIV** method, the **KeyAndIVGenerator** class creates
    an instance of the **Aes** class using the **Aes.Create()** method, which represents
    the AES algorithm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, it calls the **GenerateKey()** and **GenerateIV()** methods on the **Aes**
    instance to generate a random encryption key and **IV**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After generating the key and **IV**, it converts them into base64 strings using
    the **Convert.ToBase64String()** method. **Base64** encoding is used for easy
    storage and usage of the key and **IV**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it logs the generated key and **IV** to the console using **Debug.Log()**
    for debugging purposes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Start** method is called when the **KeyAndIVGenerator** object is initialized,
    and it invokes the **GenerateKeyAndIV** method to generate the key and **IV**
    when the object starts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, this code block demonstrates how to generate encryption keys and `IV`
    values using the AES algorithm and convert them into `base64` strings for storage
    and usage. This is commonly used in cryptography for securing data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block provides an example of the `GameManager` script, which
    utilizes the save and load methods from `SaveManager` to manage the process of
    saving and loading `PlayerData` and `GameSettings`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s consider the Unity callback functions:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Start** method, it calls the **LoadGameData** function to load the
    player data and game settings when the game starts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **OnApplicationQuit** method is invoked when the application is about to
    quit, and it calls the **SaveGameData** function to save the player data and game
    settings before exiting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code block contains the logic for loading and saving data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look at the saving and loading functions:'
  prefs: []
  type: TYPE_NORMAL
- en: The **LoadGameData** function loads the player data and game settings from the
    save files using the **SaveManager.LoadData** method. If the data is not found,
    it creates new instances of **PlayerData** and **GameSettings**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **SaveGameData** function saves the player data and game settings to the
    save files using the **SaveManager.SaveData** method. It converts the data objects
    into JSON format using **JsonUtility.ToJson** before saving.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, this code block demonstrates a basic implementation of loading and
    saving game data using JSON serialization. It ensures that the player data and
    game settings are persisted across game sessions, allowing for a seamless gaming
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to save and load scriptable objects, the techniques
    of saving and loading to a file, encrypting using AES to protect the data, and
    how to generate encryption keys. Finally, we’ve practiced using these concepts
    practically.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to understand the benefits of using a custom approach over PlayerPrefs.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages over PlayerPrefs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While PlayerPrefs offers simplicity, the Custom Save System goes beyond its
    limitations, providing a variety of features and functionalities unmatched by
    traditional storage methods. By reducing performance overhead and improving data
    security, it marks a new era of data management in Unity game development.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, the Custom Save System represents innovation and creativity –
    a testament to the ongoing pursuit of excellence in game development. With its
    capacity to streamline data management, enhance security measures, and improve
    player experiences, it has become the cornerstone of modern game development practices,
    reshaping the landscape with each save.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to implement ScriptableObjects with the player
    progress part of our game while saving and loading data.
  prefs: []
  type: TYPE_NORMAL
- en: Data-driven gameplay with C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Data-driven design** is an approach to game development where game behavior,
    content, and configuration are defined and controlled by external data files rather
    than hardcoded into the game’s source code. This approach offers several benefits,
    including increased flexibility, easier content iteration, and enhanced maintainability.
    By separating game data from code, we can modify game behavior, tweak parameters,
    and add new content without requiring code changes, thus accelerating iteration
    cycles and empowering designers to experiment with gameplay mechanics.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin with one of the uses of ScriptableObjects for managing data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating data for stats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have the `PlayerMovement` script in our project, as shown in the following
    code block, which handles the player’s movement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can create a ScriptableObject that will contain the parameters of player
    movement, such as speed and force. Then, we can obtain a reference to that ScriptableObject.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block contains a ScriptableObject named `PlayerStats` that
    will store movement data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can utilize the `PlayerStats` ScriptableObject as a variable within
    the player movement script and substitute any previous logic that used the movement
    variables with the player stats accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We did this because we require a single reference for all movement parameters,
    and it will be convenient later to apply or adjust the stats from other scripts,
    such as special power-ups, without altering the code within the player movement
    script. We can directly modify the ScriptableObject, and it will impact the player’s
    movement.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, if we include items in our game, consolidating all data into individual
    ScriptableObjects for each type of item would streamline usage and modifications
    across all objects. Without directly referencing those objects, we can alter the
    data file, and it will impact all objects utilizing that data.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider another use for ScriptableObjects.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can utilize ScriptableObjects for player progression within challenges, allowing
    us to effectively track challenges and save the progress made.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will commence by migrating `CommonChallengeData` into a ScriptableObject,
    as demonstrated in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, upon completion of the challenge, we can utilize the save manager we
    previously established to store the challenge statistics. This can be seen in
    the `CompleteChallenge` function within `EnemyWavesChallenge` in the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We included the last line in the `CompleteChallenge` method to save the challenge
    data within the completion function of the challenge. Thus, before commencing
    the challenge, we will verify its completion status in the challenge manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we must utilize the data loading functionality from the `SaveManager`
    script within the `StartChallenge` function inside `ChallengeManager`, as illustrated
    in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is a straightforward method to transition existing code for utilizing ScriptableObjects
    or an improved data management approach. Furthermore, it integrates saving and
    loading functionalities to monitor challenge progress. While designing the system
    from scratch would offer a better data handling strategy, this system was constructed
    differently. We had the opportunity to modify it in this chapter, emphasizing
    the importance of adapting existing code bases. We’ll delve deeper into refining
    these skills in [*Chapter 7*](B22017_07.xhtml#_idTextAnchor112).
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, data-driven gameplay with C# offers a powerful framework for creating
    dynamic, customizable, and immersive gaming experiences. By embracing data-driven
    design principles, and leveraging ScriptableObjects for modular gameplay elements,
    we can build flexible, extensible, and engaging games that captivate players and
    stand the test of time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delved into concepts and techniques that are vital for efficient
    game development. We began by exploring the importance of data structures and
    their impact on game performance, emphasizing the significance of choosing the
    appropriate data structure for optimal results. Serialization in Unity took center
    stage as we navigated Unity’s serialization options, including XML, JSON, and
    binary serialization methods. We discussed the nuances of each serialization method
    and its suitability for different scenarios, laying the groundwork for robust
    data management in Unity projects.
  prefs: []
  type: TYPE_NORMAL
- en: We continued by doing a deep dive into PlayerPrefs and its limitations in Unity
    game development, paving the way for the Custom Save System. Through detailed
    discussions and practical examples, we unveiled the features and advantages of
    the Custom Save System over PlayerPrefs, highlighting its role in elevating data-driven
    gameplay experiences. The `SaveManager` Script emerged as a pivotal component,
    facilitating seamless data saving and loading operations with enhanced efficiency
    and flexibility. By leveraging C# and scriptableObjects, we are empowered to embrace
    data-driven gameplay mechanics and optimize the challenge system for enhanced
    user engagement and progression. Through meticulous exploration and hands-on learning,
    this chapter has equipped us with the knowledge and tools needed to master data
    organization and serialization in Unity with C#.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B22017_07.xhtml#_idTextAnchor112), we’ll dive into the realm
    of collaborative game development and version control systems. Building on our
    foundational knowledge, we’ll explore how to effectively contribute to existing
    code bases and collaborate within development teams using C#. From understanding
    version control systems to mastering code merging and conflict resolution techniques,
    we’ll equip ourselves with essential skills to navigate shared code repositories
    seamlessly. Through practical examples and step-by-step guidance, we’ll learn
    about the intricacies of collaborating with shared code repositories and maintaining
    code quality in a team environment. Join us as we delve deeper into the collaborative
    aspects of game development, paving the way for enhanced teamwork and code management
    practices.
  prefs: []
  type: TYPE_NORMAL
