- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing with REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we created a simple database and object ( **Car** )
    to interact with. In this chapter, we’ll look at the **Representation State Transfer**
    ( **REST** ) protocol and how it is used in APIs. REST is the most popular protocol
    for creating APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see how REST contributes to creating a client/server architecture,
    and with it, desirable separation of concerns. We will cover the following topics
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what REST is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at standard web protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first implementation of a REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What **Data Transfer Objects** ( **DTOs** ) are and how to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Postman as our frontend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the time you finish this chapter, you will understand the fundamentals of
    creating simple APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need **Visual Studio** , **AutoMapper** , and **Dapper**
    . Please see [*Chapter 1*](B21998_01.xhtml#_idTextAnchor013) , *Getting Started*
    , for how to obtain these. The code files for this chapter can be found in the
    GitHub repository here: [https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter03](https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter03)'
  prefs: []
  type: TYPE_NORMAL
- en: REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key concepts in REST is the separation of concerns. This idea will
    be familiar to you as a C# programmer. Here, we are separating the concerns of
    the server and the client.
  prefs: []
  type: TYPE_NORMAL
- en: The API can only respond to calls from the client, and cannot generate calls
    of its own. Note that within the logic of the API implementation, it is possible
    to call other APIs, but not back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: The server is in no way dependent on the design or implementation of the client.
  prefs: []
  type: TYPE_NORMAL
- en: Client/server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key to a REST application is that the API can be called by any type of
    client: web application, phone application, and so on. Further, the client can
    be located anywhere and there are no constraints on the architecture of the client.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The same is true for the backend, behind the API. Typically, this will be a
    database, but it can be any type of data storage: relational, object, in memory,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: One way to accomplish this, is to use the standard web protocols such as **GET**
    , **PUT** , and so forth. This approach is essential to REST. In fact, for many
    people this is the virtual definition of REST.
  prefs: []
  type: TYPE_NORMAL
- en: Using web protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In REST, we use the same verbs as we do in HTTP: **GET** , **PUT** , **POST**
    , and **DELETE** . In addition, the API returns standard web values to the client,
    for example, **404 (not found)** , **200 (success)** , **201 (created)** , and
    so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Each request from the client to the API will consist of an HTTP header, body,
    and meta-data. The client expresses which API is wanted by calling a URL, and
    passes needed data (e.g., the **id value for the requested entity** either in
    the URL or, if passing too much data for a URL, in the body of the request. For
    example, here is a POST to add a car to the backend database. Don’t worry about
    the syntax for now; rather, take a look at the URL and the body of the request
    in *Figure 3* *.1* .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Sending data for insertion](img/B21988_03_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Sending data for insertion
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the figure, we see the URL (https://localhost:7025/Car). This
    is the “address” of the API. Notice that the last part of the URL is *Car* . This
    is the name of the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Below the URL is a menu allowing you to see the parameters being sent, the Authorization
    any headers that go along as meta-data (see *Figure 3* *.2* ), the body that we
    see in *Figure 3* *.1* , any scripts to run before sending the request, tests
    to ensure we are getting back the right data (see [*Chapter 8*](B21998_08.xhtml#_idTextAnchor105)
    , *Advanced Topics* ), and any settings we need for the request.
  prefs: []
  type: TYPE_NORMAL
- en: The numbered lines 1-12 in the preceding figure are the body of this request.
    We are inserting a car into the database and so all the data for the insertion
    is here in JSON format. Notice that there is no ID; that will be assigned on the
    backend.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Headers](img/B21988_03_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Headers
  prefs: []
  type: TYPE_NORMAL
- en: These headers provide vital information to the server. They must be sent for
    each interaction because REST is inherently stateless.
  prefs: []
  type: TYPE_NORMAL
- en: Statelessness and caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REST APIs are stateless, so you must treat each call to the API as independent
    from all other calls.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you need state and you are on Azure, you’ll want a durable function,
    which is covered in [*Chapter 7*](B21998_07.xhtml#_idTextAnchor094) , *Azure*
    *Durable Functions* .
  prefs: []
  type: TYPE_NORMAL
- en: While you cannot maintain state between calls, the server can cache data for
    faster retrieval. This can significantly improve performance There are a number
    of platforms that can support REST APIs; the one we will focus on for this book,
    and the platform of choice for .NET, is ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative to REST is GraphQL. There are two problems this designed to
    solve: overfetching and underfetching. The user wants to send a single API call
    to the server. In order to do this, they must designate what data is needed. If
    a Car entity is requested, it may be that they don’t care at all about some of
    the features of the car but they get the entire car as part of the API. This is
    called overfetching. On the other hand, if they designate an API that only gets
    the type of car, this may be under fetching (they have to make a second call for
    the rest of what they need). GraphQL is designed to solve this problem, allowing
    the client to specify exactly which properties are requested.'
  prefs: []
  type: TYPE_NORMAL
- en: That said, the downside of GraphQL is that each API query must be hand-crafted
    to designate what is wanted.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, and other technical constraints, not the least of which is
    inertia, REST is by far the most popular way to write APIs and we will not cover
    GraphQL in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing REST in ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An API created in ASP.NET Core will typically have three major components:'
  prefs: []
  type: TYPE_NORMAL
- en: Controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There is an alternative to controller-based APIs known as Minimal APIs. We discuss
    this in brief towards the end of this chapter (refer to the *Minimal APIs* box).
    We do not cover Minimal APIs for the rest of the book as they have too many limitations.
  prefs: []
  type: TYPE_NORMAL
- en: When you invoke an API with a URL, that address is resolved to a controller.
    For example, using the URL we saw earlier, if you call https://localhost:7025/Car,
    you will invoke the **CarController** at that address. Note that ASP.NET uses
    “convention over configuration,” by which we mean that *by convention* , the part
    of the word Controller is left off the address but is implied. So in this case,
    **CarController** , the address just uses **Car** (leaving off Controller).
  prefs: []
  type: TYPE_NORMAL
- en: The job of the controller is to ensure that the user has been authenticated
    (it’s really them) and authorized (they have permission to take whatever action
    is invoked). The controller then assembles any needed data and passes it along
    to the Service. Typically, but not necessarily, this will be called **CarService**
    and will sit in a folder with other services.
  prefs: []
  type: TYPE_NORMAL
- en: The job of the Service is to handle any business logic and prepare the data
    to go into the database. It then passes the data to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the Service, the repository would typically be called **CarRepository**
    and would be located in a folder along with other repositories. The job of the
    repository is to interact with the underlying data storage (for example, a database).
  prefs: []
  type: TYPE_NORMAL
- en: Often, you will want to separate the properties of the database from the properties
    of an object to be sent through the API. For that, we use DTOs.
  prefs: []
  type: TYPE_NORMAL
- en: DTOs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is common to use DTOs to separate the representation of the structure of
    the database from a supporting **Plain Old C#** **Object** ( **POCO** )
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take an example from a relational database. Each row may have twelve columns
    but for a specific API request, only seven are needed. The DTO will be a class
    with seven properties, and we’ll use a tool ( **AutoMapper** ) to map the values
    in the seven columns to the seven properties.
  prefs: []
  type: TYPE_NORMAL
- en: Installing AutoMapper
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The easiest way to install **AutoMapper** is to download the NuGet packages,
    as shown in *Figure 3* *.3* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Installing AutoMapper](img/B21988_03_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Installing AutoMapper
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a bit of configuration for **AutoMapper** , but it is only done once.
    In **Program.cs** , add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to create the DTO class itself.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the DTO class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The POCO classes we’ve created directly track the columns in the database,
    as described earlier. The DTO class tracks some or all of these columns as properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once your DTO is in place, you need a way to map the properties in the DTO to
    the properties in the database (POCO) class. We can do that in a profile.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the profile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While we are here, let’s set up the profile file for the **Car** entity. The
    **AutoMapper** tool (no pun intended) provides a base class, **Profile** , that
    we will derive from.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called **CarProfile.cs** and put this code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice that for every member that we want to share between the DTO and the POCO
    class, there is an entry. At the bottom is **ReverseMap** , which, as you may
    have guessed, reverses the mapping (for example, it causes the map to go from
    **DTO > Car** to **Car >** **DTO** ).
  prefs: []
  type: TYPE_NORMAL
- en: We have taken care of the DTO; now we need to connect our POCO to the database.
    We’ll do that with Dapper.
  prefs: []
  type: TYPE_NORMAL
- en: Dapper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As noted earlier, we will use Dapper as our **Object Relational Model** ( **ORM**
    ). This will greatly simplify our interaction between the repository and the database.
    Dapper has its own syntax but it is very (very) close to SQL and the points of
    departure will be obvious.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Dapper
  prefs: []
  type: TYPE_NORMAL
- en: To install and use Dapper, please see their very straightforward and comprehensive
    instructions at [https://www.learndapper.com/](https://www.learndapper.com/)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, for example, is the Dapper code to get a car by ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can create more complex statements with conditional logic.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Dapper uses C# rather than SQL syntax except for the query itself. This makes
    interacting with the database much easier for C# programmers.
  prefs: []
  type: TYPE_NORMAL
- en: That is really all you need to know to get started creating your API. Let’s
    try inserting a car into the database using the API.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the SQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SQL (pronounced See-Quill) in the above example can almost be read as an
    English sentence. First, we use the keyword SELECT to indicate that we want to
    pick out and return a subset of the data in the Database.
  prefs: []
  type: TYPE_NORMAL
- en: Next comes the asterisk ( ***** ) which indicates that we want all the columns.
    The alternative is to list the columns we want.
  prefs: []
  type: TYPE_NORMAL
- en: '**From Cars C** indicates that we want the data to come from the **Cars** table,
    and that we will be using the alias **C** to refer to that table.'
  prefs: []
  type: TYPE_NORMAL
- en: The **Where** statement constrains the search to the criteria that follows it,
    in this case where the id of the car (using the alias C) matches the id we’re
    looking for. We then tack on “ **where is_deleted = 0** ” indicating that we only
    want entries that are not marked as deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Here is where Dapper comes in. We set up an array of parameters, and then
  prefs: []
  type: TYPE_NORMAL
- en: 'call: **QueryFirstOrDefaultAsync<Car>(sql, param);**'
  prefs: []
  type: TYPE_NORMAL
- en: This invokes the **QueryFirstOrDefault** method in dapper. We pass in the type
    of object we are looking for (Car) and then two parameters. For our purposes,
    the first will always be SQL, and the second will always be the name of the collection
    we created above (param).
  prefs: []
  type: TYPE_NORMAL
- en: We assign the result (in this case one car) to a variable, and return that value.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the constructor for this class will have interfaces passed
    in through Dependency Injection, and those parameters will be assigned to member
    variables (for example, _ **carService** ). If you are not familiar with Dependency
    Injection, please refer to the code in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together (inserting a car)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s put this together using controller, service, and repository to insert
    a car with Dapper and AutoMapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we’ve transformed the DTO to a database object ( **Car** ), which
    we then pass to the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to pass this car to the repository for storage in our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If we get a valid new car, we pass back the **newId value** , which we check
    for in the service. However, that is a lot of data we are passing to the API.
    We’ll look at solving that problem in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'A note on dependency injection: as you know, we pass in interfaces to our methods
    so that we can support dependency injection. This is set up in **Program.cs**
    , and the injection itself is automatic.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the body in Postman
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you can see, the data that we want to pass into the API will be too much
    for the query string, and so we will pass it into the body. We can signal this
    in the definition of the API by writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Every API call will have zero or more **FromQuery** , **FromUrl** , and **FromBody**
    attributes. In this case, we are just using **FromBody** . Our call through Postman
    is seen in *Figure 3* *.4* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Inserting a car](img/B21988_03_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Inserting a car
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are inserting all the properties of the car (except the ID value) as
    seen in the top window. To do this, we would adjust the SQL statement to take
    all the properties. Notice that the API returns the properties of the inserted
    car, including its **id** (bottom window). The return code will be **201** (created).
  prefs: []
  type: TYPE_NORMAL
- en: Since we are looking for the data in the body of the request, the URL is just
    the address of the controller.
  prefs: []
  type: TYPE_NORMAL
- en: We have inserted a single car, but I have pre-seeded the database with many
    more. Let’s use the API to see them.
  prefs: []
  type: TYPE_NORMAL
- en: Get all
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get a list of all the cars in the database, we begin in the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Warning: the following example shows calling the repository directly for illustration
    purposes. Shortly afterwards we will discuss the correct way to do this.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we call the repository directly. This is an alternative to calling the
    service, and is generally a bad practice, but I wanted to show how it is done.
    Notice that we include a Boolean parameter as to whether to return the deleted
    records as well.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, we would use a **Service** class for separation of concerns. The service
    class would contain the program logic and would sit between the controller and
    the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the repository, we build our **SqlBuilder** (as we saw earlier in the section
    on *Dapper* ) and obtain the records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take that one line at a time. The first line indicates that we will return
    a list of **Car** objects and the decision as to whether or not to return deleted
    records defaults to **false** .
  prefs: []
  type: TYPE_NORMAL
- en: We next create a **SqlBuilder** object and then set the **SqlTemplate** object
    to select everything from the car.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the **/**where**/** statement. This is a Dapper convention indicating
    that a **where** clause may be placed here.
  prefs: []
  type: TYPE_NORMAL
- en: We will now check to see whether the deleted records are to be included, and
    if not, we add a where clause using the builder we created on the first line.
  prefs: []
  type: TYPE_NORMAL
- en: We are ready to get the Database from the factory we created and then query
    the database, passing in the **RawSql** code created for use in the **SqlTemplate
    object** and the parameters. In this case, there are no parameters.
  prefs: []
  type: TYPE_NORMAL
- en: What we get back is an array of **Car** objects, which we return to the calling
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this, we set Postman to **Get** and the URL to https://localhost:7025/Car.
    Since no ID is provided, our code will get them all, as shown in *Figure 3* *.5*
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Getting all the cars in the database](img/B21988_03_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Getting all the cars in the database
  prefs: []
  type: TYPE_NORMAL
- en: Having inserted records, we may want to change one or another. To do that, we’ll
    want to use the **Put** verb.
  prefs: []
  type: TYPE_NORMAL
- en: Update
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Updating uses the HTTP **Put** verb. Let’s trace through how it is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'We return to the controller and add an **HttpPut** attribute. We then indicate
    that the contents will be in the body of the request (rather than the query) as
    we saw in the insert:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we can’t be certain that the record we want to update is still in the
    database, we put the call in a try block, and if we get an exception, we call
    **BadRequest** . Interestingly, if we succeed, we call **NoContent** as we are
    not adding anything to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As shown, from here we call the **carService** ’s **Update** method, passing
    in the car we want to update. Note that some programmers use **OK** rather than
    **NoContent** .
  prefs: []
  type: TYPE_NORMAL
- en: 'In the service, we’ll make sure we got a valid car **id value** and then call
    **UpsertAsync** , passing in the car. If we get back any **id** value except the
    original, we throw an exception; otherwise, we return the **Car** object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the **Upsert** method, we check to see whether this is a new car (insert)
    or an update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice, in the final two lines, that we obtain the **newId** value from the
    query and if it is **0** , we return the original car ID. Otherwise, we return
    the **newid** value from the car we inserted.
  prefs: []
  type: TYPE_NORMAL
- en: Soft delete
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the sake of completeness, let’s take a quick look at soft delete. You’ll
    remember that when the user asks to delete a record, rather than actually removing
    it from the database, we mark it as deleted (in the **is_deleted** column) so
    that we can obtain those records as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start back in the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**Delete** takes the ID of the car to mark as deleted and then calls the service.
    All the service does is make sure that the ID is valid and then call the repository
    to do the actual deletion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The code in the repo is dead simple. It gets the connection to the database
    and creates the query to set **is_deleted** to **1** . It then executes that query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you have a complete API for **Create, Read, Update, Delete**
    ( **CRUD** ) operations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you were introduced to using Dapper and AutoMapper, the latter
    for DTO objects. You also dove into the workings of the CRUD operations, using
    the typical three classes: controller, service, and repository.'
  prefs: []
  type: TYPE_NORMAL
- en: You saw that for simple operations, you can bypass the Service, but this is
    considered bad practice.
  prefs: []
  type: TYPE_NORMAL
- en: In an enterprise application, you will want to use DTOs to separate the layout
    of the database from the layout of the object being passed around. As we delve
    into the realm of enhancing API usability and understanding, the next chapter
    will highlight the significance of documenting your project with Swagger.
  prefs: []
  type: TYPE_NORMAL
- en: You try it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a simple database to track your music collection. Put this in a database
    and use Dapper and AutoMapper to implement the four CRUD operations. For this
    exercise, create DTOs that provide only a subset of the columns in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Minimal APIs
  prefs: []
  type: TYPE_NORMAL
- en: Minimal APIs offer an alternative way to create APIs without using Controllers.
    While they still allow for the injection of required services, they are primarily
    intended for smaller endpoints with minimal dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, Controllers come with a larger hierarchy of endpoint components
    to consider. This includes features such as versioning, controller naming, and
    manual route attributes, which can introduce extra boilerplate that may not always
    be necessary. Minimal APIs simplify this process by allowing you to declare and
    handle requests in a single expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, let’s reimplement the call to get all cars. Start with the code
    from [*Chapter 3*](B21998_03.xhtml#_idTextAnchor038) , then use the app variable
    to add calls to **MapGet** . The route will be **/car-minimal** , and the handler
    can remain the same as the **GetAll** method: a call to **ICarRepository.GetAll**
    . But how will we access the service interface without a constructor? Minimal
    APIs solve this by using parameter injection. Simply pass **ICarRepository carRepository**
    as an argument to the delegate for **MapGet** parameter, and use it to call the
    **.** **GetAll** method.'
  prefs: []
  type: TYPE_NORMAL
- en: Many different types can be injected into the handlers for Minimal APIs. Model-bound
    types are differentiated by applying attributes to individual parameters. Commonly
    used ones include **[FromRoute]** , **[FromBody]** , and **[FromServices]** .
    Additional special types include **HttpContext** , **HttpRequest** , **HttpResponse**
    , **IFormFile** , and a **Stream** of the request body. The full list is available
    in the official Microsoft documentation.
  prefs: []
  type: TYPE_NORMAL
