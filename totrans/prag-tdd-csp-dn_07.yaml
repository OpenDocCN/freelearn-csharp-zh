- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Pragmatic View of Domain-Driven Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Domain-driven design** (**DDD**) is a set of software design principles that
    are widely used in modern enterprise applications. They were bundled and made
    popular in 2003 by Eric Evans in his book *Domain-Driven Design*.'
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering how this is related to **test-driven development** (**TDD**).
    Is it because it is a similar-sounding acronym? The reality is that TDD and DDD
    work together where TDD covers the design from the client’s perspective and the
    quality, while DDD complements the rest of the design. You will hear the two terms
    used together in a conversation and in job specifications, and the reason for
    this will be clear by the end of *Part 2*, *Building an Application with TDD*.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is meant to be a primer on DDD, so you will have the foundation
    required to build a complete application using a combination of TDD and DDD.
  prefs: []
  type: TYPE_NORMAL
- en: DDD is a technical and a philosophical topic. Given the pragmatism of this book
    and the length of this chapter, our focus will be limited to the pragmatic aspect
    of DDD related to the application we are implementing in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with a sample application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring domains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting everything together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will understand the basic DDD terminology and
    be able to explain it to a colleague.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found at the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch07](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch07)'
  prefs: []
  type: TYPE_NORMAL
- en: Working with a sample application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need a sample application to demonstrate DDD concepts. The word *application*
    can have various meanings in your project. It can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A **single microservice** that is part of a larger application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **monolith application** that is a standalone application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will use a monolith application, as it is easier to explain the
    concept and the context will be clearer. So, we’ll focus on the specifics of DDD
    rather than diverging into a more complex architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a blog application as an example. A DDD-style blog application might
    look like this in Microsoft **Visual Studio** (**VS**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – A blog application in VS ](img/Figure_7.1_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – A blog application in VS
  prefs: []
  type: TYPE_NORMAL
- en: '**UQS** is our fictitious company’s initials, standing for **Unicorn Quality
    Solutions**. These projects have the following dependencies on each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Project dependencies ](img/Figure_7.2_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Project dependencies
  prefs: []
  type: TYPE_NORMAL
- en: 'Nothing special here: this is a set of regular project dependencies. Let’s
    dig into each project role.'
  prefs: []
  type: TYPE_NORMAL
- en: The application project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our solution communicates with the outside world, the clients, and the `Uqs.Blog.WebApi`
    project. This solution is using a RESTful Web API to communicate with the UI layer.
    This should make it easy for a browser-based UI layer, such as **React**, **Angular**,
    **Vue**, or **Blazor**, to exchange the data (in the form of contracts).
  prefs: []
  type: TYPE_NORMAL
- en: Also, it can act as a standalone API project that can be referred to as a *headless*
    blog, which is a fancy term to say that this is only a backend platform without
    a UI. Multiple UIs can interact with it, so it is not coupled to one UI.
  prefs: []
  type: TYPE_NORMAL
- en: This could be a standard ASP.NET Core Web API, similar to what we’ve used in
    the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B18370_02.xhtml#_idTextAnchor037), *Understanding Dependency
    Injection by Example*, and [*Chapter 3*](B18370_03.xhtml#_idTextAnchor066), *Getting
    Started with Unit Testing*, you’ve seen examples of `WeatherForecastingController`.
    In DDD terms, the controller was acting as an **application service**.
  prefs: []
  type: TYPE_NORMAL
- en: The contract objects project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To communicate with the outside world, your data should have a defined structure.
    This defined structure comprises classes, and it is in the `Uqs.Blog.Contract`
    project.
  prefs: []
  type: TYPE_NORMAL
- en: If this is a UI project, these contracts might be called **view models**, as
    they are models that are *bound* to the UI (the view) directly. Also, they might
    be called **data transportation objects** (**DTOs**) as they transport the data
    from the server to the clients. In API projects, they are usually referred to
    as **contracts**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put simply, if the RESTful APIs have an API that requests the full information
    of a post, with the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the contract might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is usually transferred in JSON. This is an example of the preceding C#
    contract being serialized as JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Contracts are not part of the DDD philosophy, but they are needed here to have
    a complete application.
  prefs: []
  type: TYPE_NORMAL
- en: The domain layer project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The components of this layer are in `Uqs.Blog.Domain`. This is where all the
    types related to the domain design live.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Dividing layers, naming projects, and arranging them based on layers is a highly
    opinionated process. There is no widespread industry standard of the best approach.
    So, consider my approach here as *an example* rather than *the way* to do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This layer contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Business logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our project resembles a similar design to this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – A design diagram for the application ](img/Figure_7.3_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – A design diagram for the application
  prefs: []
  type: TYPE_NORMAL
- en: This diagram represents our application; however, it’s worth noting that DDD
    is concerned with the backend, not the client.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will go through the constituents of DDD and we will start with the
    domain.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring domains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DDD is a collection of software design philosophies and best practices. There
    are a handful of books dedicated to DDD, and most of them are above 500 pages.
    So, we can talk a lot about DDD, but this book isn’t about DDD, so we will be
    brief.
  prefs: []
  type: TYPE_NORMAL
- en: DDD focuses on business logic and the interaction with the DB and the outside
    world and employs a set of practices for a robust software design. The word *domain*
    in DDD refers to a *business domain*, which can be car insurance, accounting,
    billing, banking, e-commerce, and others. DDD emphasizes the business domain,
    as per the term *domain-driven*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explore the architectural components that make the practical aspect
    of DDD.
  prefs: []
  type: TYPE_NORMAL
- en: Domain objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **domain object** is a representation of a real-life business entity. Exploring
    our blog project, the domain objects can be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – The classes and structs contributing to a blog domain ](img/Figure_7.4_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – The classes and structs contributing to a blog domain
  prefs: []
  type: TYPE_NORMAL
- en: You can see how the names of these types and the properties reflect the blog
    business. These entities generally map directly to relational database tables,
    so you have database tables for posts, authors, tags, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In a document database, the domain objects may or may not be the ones persisted
    directly into your collection.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: DDD doesn’t state that domain objects should be mapped to a relational DB table,
    but in practice, this is what happens as it is more practical to do it in this
    way, especially with the use of **object-relational mappers** (**ORMs**) such
    as **Hibernate** (**Java**) and **Entity Framework** (**.NET**).
  prefs: []
  type: TYPE_NORMAL
- en: You will often find words such as *models*, *business objects*, and *domain
    objects* used interchangeably to mean the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not all domain objects are created equal. DDD differentiates between two types
    of domain objects: entities and value objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Entities and value objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DDD distinguishes between objects that have their own identity, which are called
    `Id` property, but it stands for the plain English meaning of *identity*.
  prefs: []
  type: TYPE_NORMAL
- en: Value objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Value objects** represent typed values that have no conceptual identity.
    The most commonly used example of a value object is money. A £5 note (bill) doesn’t
    have an identity and if it is replaced by another £5 note, then nothing has changed.
    In other words, if two persons swapped £5 notes, then they have the same value,
    and we don’t have to worry about or track the notes.'
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: A £5 note is a value object unless the serial number of the note is important.
    This might be the case if this is part of a money-issuing project for the Bank
    of England. But in most cases, this is a value object.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are plenty of examples of what can be a value object. Here are a few:'
  prefs: []
  type: TYPE_NORMAL
- en: Dates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First names, as the first name on its own doesn’t make an identity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value objects are modeled in `Tag` struct.
  prefs: []
  type: TYPE_NORMAL
- en: Blog tags such as .NET, DDD, and TDD don’t require an ID. But for database storage,
    having an identifier might be more practical as it allows better management of
    tags.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: From a pure DDD approach, a tag should be a property in `Post`, not a standalone
    business object. However, what if there is a misspelling, and you wanted to fix
    it? What if you wanted to show the user a list of existing tags for autocomplete?
    Having it as an independent domain object and storing it in a standalone table
    or a container might lead to better performance and management.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, .NET developers rarely use structures unless they are building
    something low-level, such as performance optimization, and interacting with unmanaged
    resources. Usually, value objects are modeled with classes, which is not very
    DDD-compliant.
  prefs: []
  type: TYPE_NORMAL
- en: Entities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An object primarily defined by its identity is called an **entity**. It is a
    type of domain model that needs to be tracked over time and whose attributes are
    likely to change over time. A perfect example of this would be a person entity,
    which has a changeable email and home address but a fixed identity, which is the
    person herself/himself.
  prefs: []
  type: TYPE_NORMAL
- en: In our preceding blog example, `Post`, `Author`, `Comment`, and `Commenter`
    are entities.
  prefs: []
  type: TYPE_NORMAL
- en: '`Comment` is peculiar as some can argue that it is a value type! But what if
    it is editable? Then, its identity becomes important.'
  prefs: []
  type: TYPE_NORMAL
- en: Entities are represented as classes and records, and they definitely have an
    **identifier** (**ID**).
  prefs: []
  type: TYPE_NORMAL
- en: Entity versus value objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When designing your domain, it is important to understand the differences so
    that you pick the right design. Here are the major distinguishing aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lifespan**: Entities live in a continuum while value objects are created
    and destroyed with ease.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Immutability**: An object is said to be immutable if its value cannot change
    after creation. Entities are mutable while value objects are immutable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identifier**: Entity objects require an identifier while value objects don’t.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Classes or structs**: Entities use classes and adhere to the .NET reference
    type principles (stored in heap, passed by reference, and so on) while value types
    are structs (at least as DDD recommends), which adhere to the .NET value type
    principles (stored in stack, passed by value, and so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize, when we design our domain objects, they can be done as entities
    or value objects depending on whether they represent an identity.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Aggregates** are a group of classes that form one business aim. The previous
    blog classes set a distinguished business objective, which is managing a blog
    post. These classes form an aggregate.'
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The *aggregation* term that is used in **object-oriented programming** (**OOP**)
    and the **Unified Modeling Language** (**UML**) is not the same concept as the
    DDD aggregate.
  prefs: []
  type: TYPE_NORMAL
- en: An `Post` domain object.
  prefs: []
  type: TYPE_NORMAL
- en: Anemic models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we studied OOP, we learned that an object handles its own data and its
    behavior. So, if we have a class called `Person`, there might be a read-only property
    called `Email` in that class. Also, to set the email address, you will have a
    method that might be creatively called `void ChangeEmail(string email)`, which
    does some business logic and validations before setting the email. Our class,
    according to DDD, would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This class stores its own data. For example, the `Email` property is storing
    the email value and there is a behavior, which is represented by the `ChangeEmail`
    method, which is changing the stored `Email`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `Person` class earlier to an anemic version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the email has a setter, but how are validation and other business logic
    implemented if it is not within the class itself? The answer is that another class
    would be responsible, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this scenario, another class, `PersonService`, handles the behavior of the
    `Person` class, and the more the behavior of `Person` is outsourced to other classes,
    the more the `Person` class is anemic.
  prefs: []
  type: TYPE_NORMAL
- en: In an anemic model, the client interprets the purpose and use of the domain
    object, and the business logic ends up being implemented in other classes, similar
    to the preceding example. An anemic model is considered an *anti-pattern*, as
    it opposes the theories of OOP.
  prefs: []
  type: TYPE_NORMAL
- en: However, the *anti-pattern* of using anemic models in domain objects is very
    common between developers, as the practice of setting ORMs such as **Entity Framework**
    (**EF**) and other practicalities does clash with DDD best practices.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the book is taking the anemic model approach, as it is the dominant
    one in the market. It is more pragmatic and works well with ORMs.
  prefs: []
  type: TYPE_NORMAL
- en: Ubiquitous language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The word *ubiquitous*, pronounced as *yu-bikwitus*, means, according to the
    Cambridge Dictionary, *seeming to be everywhere*.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a DDD perspective, it means using well-known terminology in naming your
    domain objects similar to what the business people are using. In other words,
    do not invent your own terminology and follow the existing language: the business
    language.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach has a couple of clear advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Smoother conversation between the business stakeholders and the developers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New developers get on with the business logic and the code rapidly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I did use this in the blog example, where I used the terminology that is used
    in blogging. The same concept applies to projects of a larger size.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you have a general idea about domain objects and aggregates in DDD.
    In the next section, we will dig into a major DDD topic, which we will use extensively
    in *Part 2*, *Building an Application with TDD*, of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Services** in DDD are divided into three types, but we will focus on the
    **domain services** for now, and then we will discuss the other two later: **infrastructure
    services** and **application services**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A domain service is the unit within the DDD ecosystem where the business logic
    lives. A domain service has the following responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading domain objects through the help of repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying business logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persisting the domain objects with the help of repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to understand that the domain services are unaware of how the
    data is loaded from the storage medium and how it is stored. They only know how
    to request a data-loading or persistence operation through the help of data repositories.
    Repositories will be covered later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add some services for our blog project to help us with publishing posts,
    and retrieving and updating them.
  prefs: []
  type: TYPE_NORMAL
- en: Post management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have ever published a blog post or an online article, you will be familiar
    with this process. If you open a text editor to write a blog post, you will have
    to fill in the title, the content, and other fields, but you can also save without
    completing everything. It is okay to save without filling the required fields
    as you are still editing, but when you want to publish, everything should be completed.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start implementing the domain services required to manage a post.
  prefs: []
  type: TYPE_NORMAL
- en: Adding post service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Adding a new post will require the author’s ID but no other field. The code
    for this service can look as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: First, you’ll notice that I have dedicated a whole class, `AddPostService`,
    with a single method, `AddPost`. Some designs create a single service class such
    as `PostService` and add multiple business logic methods inside it. I opted for
    the single public method in a single class approach to respect the single-responsibility
    principle of **SOLID**.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have injected into the class two repositories that are needed for the business
    logic: the `author` and `post` repositories. For a reminder of DI, have a look
    at [*Chapter 2*](B18370_02.xhtml#_idTextAnchor037), *Understanding Dependency
    Injection by Example*.'
  prefs: []
  type: TYPE_NORMAL
- en: I implemented a business logic that checks whether a non-existent author is
    passed to the method. Also, if the author is locked from publishing, then I created
    a post and got back the created ID. I could have used `Guid` but the UI would
    want an integer.
  prefs: []
  type: TYPE_NORMAL
- en: The notable thing here is that the service did not know how `Author` was loaded.
    It might have been loaded from a relational DB, a document DB, an in-memory DB,
    or even a text file! The service delegated this knowledge to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: The service here focused on a single responsibility, which is the business logic
    for adding a new post. This is an example of the separation of concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Updating title service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The title of the blog can be up to 90 characters and can be updated at any
    time. This is sample code to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding logic is straightforward. What is new here is the way the service
    loaded the entity, then modified one of its properties, and then asked the repository
    to manage the update operation.
  prefs: []
  type: TYPE_NORMAL
- en: In both services, the business logic involved no knowledge of the data platform.
    This can be SQL Server, Cosmos DB, MongoDB, and so on. DDD refers to the libraries
    for these tools as *infrastructure*, so the services have no knowledge of the
    infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Application services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, we were describing the domain services. Application services provide
    the interaction with the outside world or the glue that allows a client to request
    something from your system.
  prefs: []
  type: TYPE_NORMAL
- en: A perfect example of an application service is an **ASP.NET** controller, where
    a controller can use domain services to provide a response to a **RESTful** request.
    Application services will typically use both domain services and repositories
    to deal with external requests.
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These are used to abstract technical concerns (cloud storage, service bus, email
    provider, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: We will be using services extensively in *Part 2*, *Building an Application
    with TDD*, of this book. So, I hope you got an idea of what they are. Later on,
    we will have an end-to-end project that will involve multiple services.
  prefs: []
  type: TYPE_NORMAL
- en: Service characteristics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are guidelines on how to build a service in DDD. We will go through a
    few of them here. However, I recommend going through the *Further reading* section
    at the end of this chapter if you would like to know more.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss stateless services, ubiquitous language, and using domain objects
    instead of services.
  prefs: []
  type: TYPE_NORMAL
- en: Stateless
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A service should not hold a state. Holding a state is akin to remembering data,
    which means, in plain English, persisting some business data in the fields or
    properties of a service class.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid maintaining a state in your service as it will complicate your architecture,
    and if you think that you need a state, then this is what repositories are for.
  prefs: []
  type: TYPE_NORMAL
- en: Use ubiquitous language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As always, use ubiquitous language. In the previous examples, we named the services
    and the methods following the business operations.
  prefs: []
  type: TYPE_NORMAL
- en: Use domain objects where relevant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: DDD is against anemic models, so it encourages the user to check whether a domain
    model can do the operation rather than having this done in a service.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, DDD would have encouraged us to have behavior (public methods)
    in `Post`. If we were to follow the DDD advice, our `Post` class would have looked
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that the setters for the properties are now private as only the methods
    within the class can set the properties. The second note is that the `UpdateTitle`
    method doesn’t need to get `Id` as a parameter as it has access to `Id` from within
    the class. It only requires the new title.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of this is that your class is not anemic and follows OOP principles.
    Obviously, we have not followed the DDD recommendation in our implementation and
    wrote the `UpdateTitle` method in the service class.
  prefs: []
  type: TYPE_NORMAL
- en: 'I did not do this to upset DDD practitioners, but for practical purposes! Let
    me list the potential problems that you may encounter in this approach while using
    EF, the main .NET ORM:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Post` class at runtime. This is not a common practice, and I am not even sure
    whether this is possible with non-hacky code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Post` from the database, it will be unable to set the properties, which renders
    EF useless.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distribution of business logic**: If the domain classes contain business
    logic, sometimes your business logic will be in services and sometimes it will
    be in domain objects rather than one or the other. In other words, it will be
    distributed in multiple classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are ways to make this work, but they aren’t worth the effort. Here, practicality
    doesn't meet the DDD theory, and this is why I opted to have anemic domain objects.
    The takeaway is that you know what DDD is advocating and the reason for that and
    you know why we are shifting from this practice.
  prefs: []
  type: TYPE_NORMAL
- en: Services do not care how data is loaded and persisted because it is the responsibility
    of the repositories, which naturally leads us to the next topic.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Repositories** are classes that belong to infrastructure. They understand
    the underlying storage platform and interact with the specifics of the data store
    system.'
  prefs: []
  type: TYPE_NORMAL
- en: They should not contain business logic, and they should only be concerned with
    loading and saving data.
  prefs: []
  type: TYPE_NORMAL
- en: Repositories are a way of achieving a single responsibility (as in SOLID’s single
    responsibility principle) by having the services and the domains responsible for
    business logic but not responsible for data persistence. DDD gives the data persistence
    responsibility to the repositories.
  prefs: []
  type: TYPE_NORMAL
- en: An example of a repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’ve seen this line of code previously in the `UpdateTitleService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we will show you a potential implementation of `GetById`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Dapper with SQL Server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Dapper** is a .NET library categorized under the term *micro-ORM*. It is
    very popular and used in **StackOverflow**.'
  prefs: []
  type: TYPE_NORMAL
- en: Dapper can be used to access a SQL Server DB, so assuming our blog DB is a SQL
    Server one, we will use Dapper to implement `GetById` of `PostRepository`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `Dapper` in any project, you can install it via `System.Data.SqlClient`
    NuGet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Usually, the repository classes have an interface counterpart to allow them
    to be injected into services. Notice that in our previous `PostService`, we have
    injected `IPostRepository`. The code shows how a repository works but it is not
    DI-compliant, however, it will be in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The `SqlConnection` class is an **ADO.NET** class, which allows you to manage
    a connection with a SQL Server DB.
  prefs: []
  type: TYPE_NORMAL
- en: '`Query()` is an extension method provided by Dapper. It allows you to issue
    a regular **T-SQL** query and map the results to an object.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Dapper with SQL Server and DI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you’ve noticed, we have not injected `SqlConnection` and we have directly
    instantiated it in the code. Obviously, this is not the best practice! Here is
    an implementation that utilizes injecting the connection object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`SqlConnection` implements `IDbConnection` and we can wire this in the DI section
    in our startup to inject the right object at runtime (*not shown here, as this
    is a fictitious sample*). The DI will take care of instantiating the connection
    object, so we don’t have to do it here.'
  prefs: []
  type: TYPE_NORMAL
- en: The `GetById` method uses Dapper’s ADO.NET extension methods to map the query
    results to a C# object. There are cleaner ways to achieve this, but I opted for
    the most readable one for this example.
  prefs: []
  type: TYPE_NORMAL
- en: Using other DBs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous example, we have used a SQL Server DB; however, any other database
    would do. The only implementation that is going to change is within the `PostRepository`
    class. The consumers of `IPostRepository` will not change.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapters, we will demonstrate end-to-end implementations that
    use SQL Server (with EF) and Cosmos DB.
  prefs: []
  type: TYPE_NORMAL
- en: EF and repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**EF** is .NET’s major ORM. An *ORM* is a term to say it loads your relational
    DB records into objects.'
  prefs: []
  type: TYPE_NORMAL
- en: EF provides a high level of abstraction that embodies multiple DDD patterns,
    most notably the repositories. When using EF, the repository pattern disappears
    in favor of EF and the code design becomes simpler.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, it is enough to know this. In [*Chapter 9*](B18370_09.xhtml#_idTextAnchor226),
    *Building an Appointment Booking App with Entity Framework and Relational DB*,
    we will have a complete implementation that includes EF with a fully working source
    code, which will clarify how things are done from end to end.
  prefs: []
  type: TYPE_NORMAL
- en: Putting everything together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is my favorite part. I have been providing little snippets here and there
    and, hopefully, now you can see the big picture of how everything is linked from
    a DDD point of view. I have included the snippets in the source code directory.
  prefs: []
  type: TYPE_NORMAL
- en: Solution Explorer view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What we’ve done in this project is a collection of snippets. Let’s have a look
    at them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – VS solution files from a DDD perspective ](img/Figure_7.5_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – VS solution files from a DDD perspective
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a recap of every item:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Contracts**: This is what the outside world sees. These contracts represent
    the shape of the data that will be exchanged between the backend and the client.
    The client should know the data elements of the contract, so it knows what to
    expect from your headless blog.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Entities**: They are the domain objects with identities.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Value Objects**: They are the domain objects that don’t require an identity.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Domain Objects**: This is the group of entities and value objects in your
    system.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Repositories**: These are the classes that will save and load your data from
    a data store (relational DB, document DB, file system, blog storage, and so on).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Domain Services**: This is where the business logic will live, and it will
    interact with the repositories for CRUD operations. These services are not exposed
    to the outside world.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`REST` request. Application services are exposed to the outside world.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It also happened that we only have a single aggregate, which is all our domain
    objects. A domain might have more than one aggregate. We also have `Post` as our
    aggregate root.
  prefs: []
  type: TYPE_NORMAL
- en: Architectural view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve seen a potential project and file structure for our DDD project and now,
    let’s have a look at it from a software design point of view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – A simplified software design view of DDD ](img/Figure_7.6_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – A simplified software design view of DDD
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s discuss this DDD-style system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application Services**: They interact with the clients and the domain services.
    They deliver the data to a client based on the contract and they deal with domain
    services directly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain Services**: They provide services to **Application Services**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infrastructure Services**: They provide services that are not part of the
    domain, such as fetching the ZIP code/postcode city.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aggregate**: Each aggregate contains several domain objects and has one aggregate
    root.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain Objects**: They are all the entities and value objects in all aggregates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I hope I was able to show you the foundation of the DDD design from the coding
    and projects structure and from an architectural view as well, although risking
    repeating the concepts twice.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are topics in DDD that I have omitted, as they don’t contribute directly
    to the rest of the book, such as bounded contexts, domain events, units of work,
    and others. I have provided additional resources in the *Further reading* section
    that will help you to explore the concepts further.
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed the basics of DDD and I am expecting this chapter to make
    you familiar with this concept, so we can use the terms such as *domain objects*,
    *domain services*, and *repositories* freely in later chapters without you raising
    an eyebrow. We have also seen sample code of the different constituents of DDD.
  prefs: []
  type: TYPE_NORMAL
- en: We have also seen where we will shift from DDD guidelines where it is more practical
    to do so and explained why.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will set a foundation for a complete project that will
    utilize all that you’ve learned so far, including DDD.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics discussed in this chapter, you can refer to
    the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Domain-Driven Design* by Eric Evans, Addison-Wesley (2003)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Implementing Domain-Driven Design* by Vaughn Vernon, Addison-Wesley (2013)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hands-On Domain-Driven Design with .NET Core* by Alexey Zimarev, Packt Publishing
    (2019)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Design a DDD-oriented microservice*: [https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/ddd-oriented-microservice](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/ddd-oriented-microservice)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Martin Fowler on DDD*: [https://martinfowler.com/bliki/DomainDrivenDesign.xhtml](https://martinfowler.com/bliki/DomainDrivenDesign.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Quickstart: Build a console app by using the .NET V4 SDK to manage Azure Cosmos
    DB SQL API account resources*: [https://docs.microsoft.com/en-us/azure/cosmos-db/sql/create-sql-api-dotnet-v4](https://docs.microsoft.com/en-us/azure/cosmos-db/sql/create-sql-api-dotnet-v4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dapper on GitHub*: [https://github.com/DapperLib/Dapper](https://github.com/DapperLib/Dapper)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
