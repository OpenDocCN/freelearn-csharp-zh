<html><head></head><body>
        

                            
                    <h1 class="header-title">Integration Techniques and Microservices</h1>
                
            
            
                
<p class="NormalPACKT">In the previous chapter, we developed microservices using a .NET monolithic application. These services are independent of each other and are located on different servers. What would be a better way to have inter-service communication, where one service interacts/communicates with the other? In this chapter, we will discuss the various patterns and methods that will help us foster this communication. We will cover the following topics:</p>
<ul>
<li>Communication between services</li>
<li>Styles of collaboration</li>
<li>Integration patterns</li>
<li>The API gateway</li>
<li>The event-driven pattern</li>
<li>Azure Service Bus</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Communication between services</h1>
                
            
            
                
<p>In the case of a .NET monolithic application, if there is a need to access third-party components or external services, we use the HTTP client or another client framework to access the resources. In<em> </em><a href="047f5d0b-a008-48e2-9c7f-c57c16e671f9.xhtml">Chapter 2</a>, <em>Implementing Microservices</em>, we developed the <strong>Product service</strong> in such a way that it would work independently. But this was not the case; we mandatorily required a few services to interact with each other.</p>
<p class="mce-root"/>
<p>So this is a challenge—having services communicate with each other. Both the <strong>Product service</strong> and <strong>Order service</strong> are hosted on separate servers. Both these servers are independent of each other, are based on <strong>REST</strong>, and have their own endpoints via which they communicate with each other (when a service interacts with another service and vice versa, we refer to it as an inter-service communication as well).</p>
<p>There are ways in which services communicate with each other; let's discuss them briefly:</p>
<ul>
<li>Synchronous: In this case, the client makes a request to the remote service (called a <strong>service</strong>) for a specific functionality and waits until it gets the response:</li>
</ul>
<div><img class="image-border" height="246" src="img/296fffe7-bfbc-4fc5-9f22-def20a1251a3.png" width="252"/></div>
<p class="CDPAlignLeft CDPAlign" style="padding-left: 60px">In the preceding diagram (pictorial view, not complete), you can see our different microservices communicate with each other. All our services are RESTful. They are based on the ASP.NET Core Web API. In the upcoming section, we will discuss in detail how exactly a service is called. This is known as the synchronous method, where clients have to wait for a response from the service. In this case, the client had to wait until it got a complete response.</p>
<ul>
<li>Asynchronous: In this,</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Styles of collaboration</h1>
                
            
            
                
<p>In the preceding section, we discussed two different modes of how services intercommunicate. These modes are nothing but styles of collaborations, which are as follows:</p>
<ul>
<li>Request/response: In this case, the client sends a request and waits for the response from the server. This is an implementation of synchronous communication. But it is not true that request/response is only an implementation of synchronous communication; we can use it for asynchronous communication as well.</li>
</ul>
<p style="padding-left: 60px">Let's consider an example to understand the concept. In <a href="047f5d0b-a008-48e2-9c7f-c57c16e671f9.xhtml">Chapter 2</a><em>,</em> <em>Implementing Microservices</em>, we developed <kbd>ProductService</kbd>. This service has the <kbd>GetProduct</kbd> method, which is synchronous. The client has to wait for a response whenever it calls this method:</p>
<pre style="padding-left: 60px">[HttpGet]<br/>[Route("GetProduct")]<br/>public IActionResult Get() =&gt; <br/>return new<br/>OkObjectResult(_productRepository.GetAll().ToViewModel());</pre>
<p style="padding-left: 60px">As per the preceding code snippet, whenever this method is called by the client (who is requesting this), they will have to wait for the response. In other words, they will have to wait until the <kbd>ToViewModel()</kbd> extension method is executed:</p>
<pre style="padding-left: 60px">[HttpGet]<br/>[Route("GetProductSync")]<br/>public IActionResult GetIsStillSynchronous()<br/>{<br/>   var task = Task.Run(async() =&gt; await<br/>   _productRepository.GetAllAsync());<br/>   return new OkObjectResult(task.Result.ToViewModel());<br/>}</pre>
<p style="padding-left: 60px">In the preceding code snippet, we can see that our method is implemented in such a way that whenever a client makes a request, they will have to wait until the <kbd>async</kbd> method is executed. Here, we call <kbd>async</kbd> in the <kbd>sync</kbd> way.</p>
<p style="padding-left: 60px">To make our code short, we added extension methods to the already existing code written in <a href="047f5d0b-a008-48e2-9c7f-c57c16e671f9.xhtml">Chapter 2</a>, <em>Implementing Microservices</em>:</p>
<pre style="padding-left: 60px">using System.Collections.Generic;<br/>using System.Linq;<br/>using FlixOne.BookStore.ProductService.Models;<br/><br/>namespace FlixOne.BookStore.ProductService.Helpers<br/>{<br/>   public static class Transpose<br/>   {<br/>      public static ProductViewModel ToViewModel(this Product<br/>      product)<br/>      {<br/>         return new ProductViewModel<br/>         {<br/>            CategoryId = product.CategoryId,<br/>            CategoryDescription = product.Category.Description,<br/>            CategoryName = product.Category.Name,<br/>            ProductDescription = product.Description,<br/>            ProductId = product.Id,<br/>            ProductImage = product.Image,<br/>            ProductName = product.Name,<br/>            ProductPrice = product.Price<br/>          };<br/>      } <br/>      public static IEnumerable&lt;ProductViewModel&gt;<br/>      ToViewModel(this IEnumerable&lt;Product&gt; products) =&gt;<br/>      products.Select(ToViewModel).ToList();<br/>   }<br/>}</pre>
<p style="padding-left: 60px">To sum up, we can say that the collaboration style request/response does not mean that it can be implemented only synchronously; we can use asynchronous calls for this as well.</p>
<ul>
<li>Event-based: The implementation of this collaborative style is purely asynchronous. This is a method of implementation in which clients that emit an event do not know exactly how to react.</li>
</ul>
<p style="padding-left: 60px">In the preceding section, we discussed <kbd>ProductService</kbd> in a synchronous manner. Let's look at an example of how users/customers can place an order; here is a pictorial overview of the functionality:</p>
<div><img class="image-border" height="320" src="img/333b8129-c5f2-4f51-b29f-2a5b4119fac0.png" width="384"/></div>
<p style="padding-left: 60px">The preceding diagram shows that the process of purchasing a book has a few main functions:        </p>
<ul>
<li style="list-style-type: none">
<ul>
<li>With the help of the search functionality, customers can find a specific book.</li>
<li>After getting the results for the searched book, customers can view the details of the book.</li>
<li>As soon as they proceed to <strong>Checkout</strong>, our system will make sure that the display (available books to purchase) shows the right quantity. For example, the available quantity is 10 copies of <em>Microservices for .NET</em> and the customer checks out with one book. In this case, the available quantity should now show nine copies.</li>
<li>The system will generate an invoice for the purchased book and send it to the customer, to their registered email.</li>
</ul>
</li>
</ul>
<p style="padding-left: 60px">Conceptually, this looks easy; however, when we talk about implementing microservices, we are talking about services that are hosted separately and have their own REST API, database, and so on. This is now sounding more complex. There are many aspects involved, for example, how a service will call or invoke another service upon a successful response from one or more services. This is where the event-driven architecture comes into the picture:</p>
<div><img class="image-border" height="301" src="img/d1af219a-eae1-4041-8674-bbdc855c2f58.png" width="265"/></div>
<p style="padding-left: 60px">In the preceding diagram, we can see that <strong>Invoice service</strong> and <strong>Product service</strong> are triggered when <strong>Order service</strong> is executed. These services further call internal asynchronous methods to complete their functionalities.</p>
<p>We are using Azure API management as our API gateway. In the upcoming sections, we will discuss this in detail.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Integration patterns</h1>
                
            
            
                
<p>Until now, we have discussed inter-service communication and have gone through the practical implementation of <kbd>ProductService</kbd> with the use of synchronous and asynchronous communication. We've also implemented microservices using different styles of collaboration. Our <em>FlixOne bookstore</em> (developed as per the microservice architectural style) required more interaction, therefore it required more patterns. In this section, we will discuss the implementation of various integration patterns required for our application.</p>
<p>The complete application of the <em>FlixOne bookstore</em> is available in <a href="bcd6e14a-bd2b-4964-94f4-dcf93cc9d756.xhtml">Chapter 10</a><em>, Creating a Complete Microservice Solution.</em></p>


            

            
        
    

        

                            
                    <h1 class="header-title">The API gateway</h1>
                
            
            
                
<p>In the <em>Styles of collaboration</em> section, we discussed two styles we can use to foster intercommunication between microservices. Our application is split into various microservices:</p>
<ul>
<li>Product service</li>
<li>Order service</li>
<li>Invoice service</li>
<li>Customer service</li>
</ul>
<p>In our <em>FlixOne bookstore</em> (user interface), we need to show a few details:</p>
<ul>
<li>Book title, author name, price, discount, and so on</li>
<li>Availability</li>
<li>Book reviews</li>
<li>Book ratings</li>
<li>Publisher ranking and so on</li>
</ul>
<p>Before we check out the implementation, let's discuss the API gateway.</p>
<p>The API gateway is nothing but an implementation of <strong>Backend For Frontend</strong> (<strong>BFF</strong>). Sam Newman introduced this pattern. It acts as a proxy between client applications and services. In our example, we are using <strong>Azure API management</strong> as our API gateway.</p>
<p>It is responsible for the following functionalities:</p>
<ul>
<li>Accepting API calls and routing them to your backends</li>
<li>Verifying API keys, JWT tokens, and certificates</li>
<li>Supporting Auth through Azure AD and the OAuth 2.0 access token</li>
<li>Enforcing usage quotas and rate limits</li>
<li>Transforming your API on the fly without code modifications</li>
<li>Caching backend responses wherever they are set up</li>
<li>Logging call metadata for analytics purposes</li>
</ul>
<p>Refer to <em>Azure API management</em> (<a href="https://social.technet.microsoft.com/wiki/contents/articles/31923.azure-create-and-deploy-asp-net-webapi-to-azure-and-manage-using-azure-api-management.aspx">https://social.technet.microsoft.com/wiki/contents/articles/31923.azure-create-and-deploy-asp-net-webapi-to-azure-and-manage-using-azure-api-management.aspx</a>) to learn more about the process of setting up the API Azure portal and working with REST APIs.</p>
<div><img class="image-border" height="201" src="img/7725c9c9-fe57-4d71-922c-f772ab138148.png" width="195"/></div>
<p>In the preceding diagram, we have different clients, such as a mobile and desktop application and a web application, that are using microservices. Here, Azure API management is working as an API gateway.</p>
<p>Our client does not know the actual server in which our services are located. The API gateway provides them with the address of its own server, and internally, it authenticates the request from clients with the use of a valid <kbd>Ocp-Apim-Subscription-Key</kbd>.</p>
<p>Our <kbd>ProductService</kbd> has a REST API. Refer to the following table:</p>
<table>
<tbody>
<tr>
<td>
<p><strong>API resource</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET /api/product</kbd></p>
</td>
<td>
<p>Gets a list of products</p>
</td>
</tr>
<tr>
<td><kbd>GET /api/product{id}</kbd></td>
<td>
<p>Gets a product</p>
</td>
</tr>
<tr>
<td><kbd>PUT /api/product{id}</kbd></td>
<td>
<p>Updates an existing product</p>
</td>
</tr>
<tr>
<td>
<p><kbd>DELETE /api/product{id}</kbd></p>
</td>
<td>
<p>Deletes an existing product</p>
</td>
</tr>
<tr>
<td><kbd>POST /api/product</kbd></td>
<td>
<p>Adds a new product</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>We have already created <kbd>ProductClient</kbd>, a .NET console application. It makes a request to Azure API management bypassing the subscription key. Here is the code snippet for this:</p>
<pre>namespace FlixOne.BookStore.ProductClient<br/>{<br/>   class Program<br/>   {<br/>      private const string ApiKey = "myAPI Key";<br/>      private const string BaseUrl = "http://localhost:3097/api";<br/>      static void Main(string[] args)<br/>      {<br/>         GetProductList("/product/GetProductAsync");<br/>         //Console.WriteLine("Hit ENTER to exit...");<br/>         Console.ReadLine();<br/>      }<br/>      private static async void GetProductList(string resource)<br/>      {<br/>         using (var client = new HttpClient())<br/>         {<br/>            var queryString =<br/>            HttpUtility.ParseQueryString(string.Empty);<br/><br/>            client.DefaultRequestHeaders.Add("Ocp-Apim-Subscription-<br/>            Key", ApiKey);<br/><br/>            var uri = $"{BaseUrl}{resource}?{queryString}";<br/><br/>            //Get asynchronous response for further usage<br/>            var response = await client.GetAsync(uri);<br/>            Console.WriteLine(response);<br/>          }<br/>       }<br/>    }<br/> }</pre>
<p>In the preceding code, our client is requesting a REST API to get all the products. Here a brief description of the terms that appear in the code:</p>
<table style="width: 728px;height: 468px">
<tbody>
<tr>
<td><kbd>BaseUrl</kbd></td>
<td>
<p>This is the address of the proxy server.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Ocp-Apim-Subscription-Key</kbd></p>
</td>
<td>
<p>This is a key assigned by API management to a specific product the client has opted for.</p>
</td>
</tr>
<tr>
<td><kbd>Resource</kbd></td>
<td>
<p>This is our API resource, which is configured over Azure API management. It will be different from our actual REST API resource.</p>
</td>
</tr>
<tr>
<td><kbd>Response</kbd></td>
<td>
<p>This refers to the response to a specific request, in our case the default JSON format.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Since we're using Azure API management as an API gateway, there are certain benefits we'll enjoy:</p>
<ul>
<li>We can manage our various APIs from a single platform, for example, <kbd>ProductService</kbd>, <kbd>OrderService</kbd>, and other services can be easily managed and called by many clients</li>
<li>Because we're using API management, it does not only provide us with a proxy server, but also provides the facility to create and maintain documentation for our APIs</li>
<li>It provides a built-in facility to define various policies for quota, output formats, and format conversions, such as XML to JSON or vice versa</li>
</ul>
<p>So, with the help of the API gateway, we can have access to some great features.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The event-driven pattern</h1>
                
            
            
                
<p>The microservice architecture has the database per service pattern, which means it has an independent database for every dependent or independent service:</p>
<ul>
<li>Dependent service: Our application would require a few external services (third- party services or components, and so on) and/or internal services (these are our own services) to work or function as expected. For instance, <strong>CHECKOUT-SERVICE</strong> requires <strong>CUSTOMER-SERVICE</strong>; also, <strong>CHECKOUT-SERVICE</strong> requires an external (third-party) service to verify a customer's identity (such as Aadhaar card ID in the case of Indian customers). Here, our <strong>CHECKOUT-SERVICE</strong> is a dependent service, as it requires two services (an internal service and external service) to function as expected. Dependent services do not work if any or all the services on which the service is dependent on do not work properly (there are a lot of reasons a service would not work, including network failure, unhandled exception, and so on).</li>
<li>Independent service: In our application, we have services that do not require any other service to work properly. Services that do not need any other service to work in order to function are called independent services; these services can be self-hosted. Our <strong>CUSTOMER-SERVICE</strong> does not require any other service to function properly, but other services may or may not require this service.</li>
</ul>
<p>The main challenge is to maintain business transactions to ensure data consistency across these services. For instance, when and how <strong>CUSTOMER-SERVICE</strong> would know that <strong>CHECKOUT-SERVICE</strong> has functioned; now it requires the functionality of <strong>CUSTOMER-SERVICE</strong>. There may be several services in an application (services may be self-hosted). In our case, when <strong>CHECKOUT-SERVICE</strong> is triggered and <strong>CUSTOMER-SERVICE</strong> is not invoked, then how will our application identify the customer’s details?</p>
<div><p>ASP.NET WebHooks can also be used for providing event notifications; refer to the WebHooks documentation for more information.</p>
</div>
<p>To overcome the related problems/challenges we've discussed (for <strong>CHECKOUT-SERVICE</strong> and <strong>CUSTOMER-SERVICE</strong>), we can use an event-driven pattern (or the eventual consistency approach) and use distributed transactions.</p>
<p>A document on MSDN (<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms681205(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms681205(v=vs.85).aspx</a>) says the following:</p>
<p>A distributed transaction is a transaction that updates data on two or more networked computer systems. Distributed transactions extend the benefits of transactions to applications that must update distributed data. Implementing robust distributed applications is difficult because these applications are subject to multiple failures, including failure of the client, the server, and the network connection between the client and server. In the absence of distributed transactions, the application program itself must detect and recover from these failures.</p>
<p>The following diagram describes an actual implementation of the event-driven pattern in our application, where <strong>PRODUCT-SERVICE</strong> subscribes to the events and <strong>Event-Manager</strong> manages all the events:</p>
<div><img class="image-border" height="224" src="img/fa3994cc-83d1-4f0e-a417-5d72d06fe3f0.png" width="492"/></div>
<p>In an event-driven pattern, we implement a service in such a way that it publishes an event whenever a service updates its data, and another service (dependent service) subscribes to this event. Now, whenever a dependent service receives an event, it updates its data. This way, our dependent services can get and update their data if required. The preceding diagram shows an overview of how services subscribe to and publish events. In the diagram, <strong>Event-Manager</strong> could be a program running on a service or a mediator helping you manage all the events of the subscribers and publishers.</p>
<p>It registers an event of the <strong>Publisher</strong> and notifies a <strong>Subscriber</strong> whenever a specific event occurs/is triggered. It also helps you to form a queue and wait for events. In our implementation, we will use Azure Service Bus queues for this activity.</p>
<p>Let's consider an example. In our application, this is how our services will publish and receive an event:</p>
<ul>
<li><strong>CUSTOMER-SERVICE</strong> performs a few checks for the users, namely login check, customer details check, and so on; after these necessary checks are conducted, the service publishes an event called <kbd>CustomerVerified</kbd>.</li>
<li><strong>CHECKOUT-SERVICE</strong> receives this event and, after performing the necessary operations, it publishes an event called <kbd>ReadyToCheckout</kbd>.</li>
<li><strong>ORDER-SERVICE</strong> receives this event and updates the quantity.</li>
<li>As soon as the checkout is performed, <strong>CHECKOUT-SERVICE</strong> publishes an event. Whatever result is received from the external service, either <kbd>CheckedoutSuccess</kbd> or <kbd>CheckedoutFailed</kbd>, it is used by <strong>CHECKOUT-SERVICE</strong>.</li>
<li>When <kbd>InventoryService</kbd> receives these events, it updates the data to make sure the exact item is added or removed.</li>
</ul>
<p>With the use of event-driven patterns, services can automatically update the database and publish an event.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Event sourcing</h1>
                
            
            
                
<p>This pattern helps us ensure that the service will publish an event whenever the state changes. In this pattern, we take a business entity (product, customer, and so on) as a sequence of state-changing events. The <strong>Event Store</strong> persists the events and these events are available for subscription or as other services. This pattern simplifies our tasks by avoiding the requirement to synchronize the data model and the business domain. It improves performance, scalability, and responsiveness.</p>
<ul>
<li>This simply defines an approach indicating how we can handle the various operations on our data by a sequence of events; these events are recorded in a store.</li>
<li>An event represents a set of changes made to the data, for example, <kbd>InvoiceCreated</kbd>.</li>
</ul>
<div><img class="image-border" height="234" src="img/83ac2541-af63-4f39-8f0b-498d655c9028.png" width="364"/></div>
<p>The preceding diagram describes how an event would work for <strong>ORDERSERVICE</strong>:</p>
<ul>
<li>The commands issue a book from the <strong>User Interface</strong> to be ordered</li>
<li><strong>ORDERSERVICE</strong> queries (from the <strong>Event Store</strong>) and populates the results with the <kbd>CreateOrder</kbd> event</li>
<li>Then, the command handler raises an event to order the book</li>
<li>Our service performs the related operations</li>
<li>Finally, the system appends the event to the event store</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Eventual consistency</h1>
                
            
            
                
<p>Eventual consistency is nothing but an implementation of the data consistency approach. This suggests implementation, so the system would be a scalable system with high availability.</p>
<p>A document on MSDN (<a href="https://msdn.microsoft.com/en-us/library/dn589800.aspx">https://msdn.microsoft.com/en-us/library/dn589800.aspx</a>) says the following:</p>
<p>"Eventual consistency is unlikely to be specified as an explicit requirement of a distributed system. Instead it is often a result of implementing a system that must exhibit scalability and high availability, which precludes most common strategies for providing strong consistency."</p>
<p>According to this distributed data, stores are subject to the CAP theorem. The CAP theorem is also known as Brewer's theorem. <strong>Consistency</strong>, <strong>Availability</strong>, <strong>(network) Partition tolerance</strong> (<strong>CAP</strong>). According to this theorem, in a distributed system, we can only choose two out of these three:</p>
<ul>
<li>Consistency</li>
<li>Availability</li>
<li>Partition tolerance</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Compensating transactions</h1>
                
            
            
                
<p>Compensating transactions provides a way to roll back or undo all the tasks performed in a series of steps. Suppose one or more services have implemented operations in a series and one or more of them have failed. What would be your next step then? Would you reverse all the steps or commit to a half-completed functionality?</p>
<p>In our case, in which a customer orders a book and <kbd>ProductService</kbd> marks the ordered book as sold temporarily, after the confirmation of the order, <kbd>OrderService</kbd> calls an external service for completing the payment process. If the payment fails, we would need to undo our previous tasks, which means we will have to check <kbd>ProductService</kbd> so it will mark the specific book as unsold.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Competing consumers</h1>
                
            
            
                
<p>Competing consumers provides a way to process messages for multiple concurrent consumers, so they receive these messages on the same channel. This application is meant for handling a large number of requests.</p>
<p>It can be implemented by passing a messaging system to another service (a consumer service), and it can be handled asynchronously, like so:</p>
<div><img class="image-border" height="224" src="img/22642a53-34b3-4d54-8c41-cf4a622ce690.png" width="530"/></div>
<p>This scenario can be implemented with the use of Azure Service Bus queues.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Azure Service Bus</h1>
                
            
            
                
<p>In the event-driven pattern, we discussed services publishing and subscribing events. We used an <strong>Event-Manager</strong> to manage all the events. In this section, we will see how Azure Service Bus manages events and provides the facility to work with microservices.</p>
<p>Azure Service Bus is an information delivery service. It is used to make communication easier between two or more components/services. In our case, whenever services need to exchange information, they will communicate using this service. Azure Service Bus plays an important role here. There are two main types of service provided by Azure Service Bus:</p>
<ul>
<li>Brokered communication: This service can also be called <strong>hired service</strong>. It works similarly to the postal service in the real world. Whenever a person wants to send messages/information, he/she can send a letter to another person. In this way, one can send various types of messages in the form of letters, packages, gifts, and so on. This type of messaging service ensures delivery of a message even when both the sender and receiver are not online at the same time. This is a messaging platform with components such as queues, topics, subscriptions, and so on.</li>
<li>Non-brokered communication: This is similar to making a phone call. In this case, the caller (sender) calls a person (receiver) without any confirmation indicating whether he/she will answer the call or not. In this way, the sender sends information, and it purely depends on the receiver to receive the communication and pass the message back to the sender.</li>
</ul>
<p style="padding-left: 90px">Take a look at the following diagram:</p>
<div><img class="image-border" height="295" src="img/ccf94a49-9fc8-4062-bae3-e9ddf4a8a767.png" width="549"/></div>
<p>The documentation on Microsoft Azure (<a href="https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-fundamentals-hybrid-solutions">https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-fundamentals-hybrid-solutions</a>) says:</p>
<p>"Service Bus is a multi-tenant cloud service, which means that the service is shared by multiple users. Each user, such as an application developer, creates a namespace, then defines the communication mechanisms she needs within that namespace."</p>
<p>The preceding diagram is a pictorial view of Azure Service Bus and it depicts four different communication mechanisms. Everyone has their own taste in terms of which it connects application:</p>
<ul>
<li>Queues: These allow one-directional communication, and act as brokers.</li>
<li>Topics: These provide one-directional communication where a single topic can have multiple subscriptions.</li>
<li>Relays: These provide bi-directional communication. They do not store messages (as queues and topics do). Relays pass messages to the destination application.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Azure queues</h1>
                
            
            
                
<p>Azure queues are nothing but cloud storage accounts that use Azure Table. They provide a way to queue a message between applications. In the upcoming sections, we will implement message queues, which is part of Azure Service Bus.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing an Azure Service Bus queue</h1>
                
            
            
                
<p>In this section, we will look at the actual implementation of an Azure Service Bus queue by creating the following:</p>
<ul>
<li>A Service Bus namespace</li>
<li>A Service Bus messaging queue</li>
<li>A console application to send a message to</li>
<li>A console application to receive a message</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Prerequisites</h1>
                
            
            
                
<p>We need the following to implement this solution:</p>
<ul>
<li>Visual Studio 2017 update 3 or later</li>
<li>A valid Azure subscription</li>
</ul>
<div><p>If you do not have an Azure subscription, you can get it for free by signing in here: <a href="https://azure.microsoft.com/en-us/free/">https://azure.microsoft.com/en-us/free/</a>.</p>
</div>
<p>If you have everything mentioned, you can start by following these steps:</p>
<ol>
<li>Log on to the Azure portal (<a href="https://portal.azure.com/">https://portal.azure.com/</a>).</li>
<li>In the left navigation bar, click on Service Bus. If unavailable, you can find it by clicking on More Services.</li>
</ol>
<p> </p>
<ol start="3">
<li>Click on Add:</li>
</ol>
<div><img class="image-border" height="409" src="img/71213eda-bd77-4603-9eb7-431638542d09.png" width="217"/></div>
<ol start="4">
<li>In the Create namespace dialog, enter a namespace, say, <kbd>flixone</kbd>. Select the pricing tier next: <kbd>Basic</kbd>, <kbd>Standard</kbd>, or <kbd>Premium</kbd>.</li>
<li>Select your Subscription.</li>
<li>Choose an existing resource or create a new one.</li>
<li>Select the location where you want to host the namespace.</li>
<li>Open a newly created namespace (we just created <kbd>flixone</kbd>).</li>
</ol>
<p> </p>
<ol start="9">
<li>Now click on Shared access policies.</li>
<li>Click on RootManageSharedAccessKey. Refer to the following screenshot:</li>
</ol>
<div><img class="image-border" height="440" src="img/f73bc19a-6d5c-400c-b757-89ba34977789.png" width="660"/></div>
<ol start="11">
<li>Click on Queues in the main dialog of the <kbd>flixone</kbd> namespace.</li>
<li>From the Policy: RootManageSharedAccessKey window, note the primary key connection string for further use. Refer to the following screenshot:</li>
</ol>
<div><img class="image-border" height="405" src="img/10cf14b5-942d-4621-ae5b-d3f4fec8e090.png" width="206"/></div>
<ol start="13">
<li>Click on Name to add a queue (say, <kbd>flixonequeue</kbd>), and click on Create (we're using REST values as default values). Refer to the following screenshot:</li>
</ol>
<div><img class="image-border" height="389" src="img/011610d4-9e56-4b85-80b9-7990d89dc4cd.png" width="209"/></div>
<p style="padding-left: 60px">The preceding image is of Create Queue dialog. In the Create Queue dialog we can create a queue for example in above image we are creating a queue with the name of floxonequeue. Queues can be verified by visiting the Queues dialog.</p>
<p>Now we are ready to create our sender and receiver applications for messages.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Sending messages to the queue</h1>
                
            
            
                
<p>In this section, we will create a console application that will actually send messages to the queue. To create this application, follow these steps:</p>
<ol>
<li>Create a new console application and name it <kbd>FlixOne.BookStore.MessageSender</kbd> using Visual Studio's new project (C#) template:</li>
</ol>
<div><img src="img/e272b2c4-8ecb-42f6-9eca-95c30afc5974.png"/></div>
<ol start="2">
<li>Add the NuGet package Microsoft Azure Service Bus by right-clicking on the project.</li>
</ol>
<ol start="3">
<li>Write the code to send the message to the queue, and your <kbd>Program.cs</kbd> file will contain the following <kbd>MainAsync()</kbd> method:</li>
</ol>
<pre style="padding-left: 60px"> private static async Task MainAsync()<br/> {<br/>    const int numberOfMessagesToSend = 10;<br/>    _client = new QueueClient(ConnectionString, QueueName);<br/>    WriteLine("Starting...");<br/>    await SendMessagesAsync(numberOfMessagesToSend);<br/>    WriteLine("Ending...");<br/>    WriteLine("Press any key...");<br/>    ReadKey();<br/>    await _client.CloseAsync();<br/> }</pre>
<p style="padding-left: 60px">In the preceding code, we are creating our queue client by providing <kbd>ConnectionString</kbd> and <kbd>QueueName</kbd> that we have already set in our Azure portal. It calls the <kbd>SendMessagesAsync()</kbd> method that accepts a parameter containing the count of the number of messages needed to be sent.</p>
<ol start="4">
<li>Create a <kbd>SendMessagesAsync()</kbd> method and add the following code:</li>
</ol>
<pre style="padding-left: 60px">private static async Task SendMessagesAsync(int numberOfMessagesToSend)<br/>{<br/>   try<br/>   {<br/>      for (var index = 0; index &lt; numberOfMessagesToSend; index++)<br/>       {<br/>          var customMessage = $"#{index}:<br/>          A message from FlixOne.BookStore.MessageSender.";<br/>          var message = new<br/>          Message(Encoding.UTF8.GetBytes(customMessage));<br/>          WriteLine($"Sending message: {customMessage}");<br/>          await _client.SendAsync(message);<br/>       }<br/>   }<br/>   catch (Exception exception)<br/>   {<br/>      WriteLine($"Weird! It's exception with message:<br/>      {exception.Message}");<br/>   }<br/>}</pre>
<ol start="5">
<li>Run the program and wait for a while. You will get the following:</li>
</ol>
<div><img height="175" src="img/82510dd4-ecba-4221-adfb-32e32a171306.png" width="708"/></div>
<ol start="6">
<li>Go to the Azure portal and then go to the created queue to check whether it displays a message. The below image is showing overview of flixonequeue where we can see Active Message Count etc.</li>
</ol>
<div><img src="img/5dc0366b-bb78-4c9c-abec-09dcaeb2c909.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding configuration settings</h1>
                
            
            
                
<p>In the previous example, we used constant values for both <kbd>ConnectionString</kbd> and <kbd>QueueName</kbd>. If we need to change these settings, we have to make changes to the code. But why should we make code changes for this small change? To overcome this situation, we have configuration settings. You can learn more about configuration at <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration</a>. In this section, we will add configurations with the help of the <kbd>IConfigurationRoot</kbd> of the <kbd>Microsoft.Extensions.Configuration</kbd> namespace.</p>
<ol>
<li>First of all, right-click on the project and click on Manage NuGet packages. Search for the <kbd>Microsoft.Extensions.Configuration</kbd> NuGet package. Refer to the following screenshot:</li>
</ol>
<div><img src="img/15c3fa44-c91d-4eae-806b-7c0dd52655b1.png"/></div>
<ol start="2">
<li>Now, locate and search for the <kbd>Microsoft.Extensions.Configuration.Json</kbd> NuGet package. Refer to the following screenshot:</li>
</ol>
<div><img src="img/7a9e843d-06bf-4de0-b9d6-507243a81bac.png"/></div>
<ol start="3">
<li>Add the following <kbd>ConfigureBuilder()</kbd> method to the <kbd>Program.cs</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">private static IConfigurationRoot ConfigureBuilder()<br/>{<br/>   return new ConfigurationBuilder()<br/>   .SetBasePath(Directory.GetCurrentDirectory())<br/>   .AddJsonFile("appsettings.json")<br/>   .Build();<br/>}</pre>
<ol start="4">
<li>Now, add the <kbd>appsettings.json</kbd> file to the project, and the following properties:</li>
</ol>
<pre style="padding-left: 60px">{<br/>   "connectionstring":<br/>   "Endpoint=sb://flixone.servicebus.windows.net/;<br/>   SharedAccessKeyName=<br/>   RootManageSharedAccessKey;SharedAccessKey=<br/>   BvQQcB5FhNxidcgEhhpuGmi/<br/>   XEqvGho9GmHH4yjsTg4=",<br/>   "QueueName": "flixonequeue"<br/>}</pre>
<ol start="5">
<li>Add the following code to the <kbd>main()</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">var builder = ConfigureBuilder();<br/>_connectionString = builder["connectionstring"];<br/>_queuename = builder["queuename"];</pre>
<ol start="4"/>
<p>After adding the preceding code, we added a way to get the <kbd>connectionstring</kbd> and <kbd>queuename</kbd> from the <kbd>.json</kbd> file. Now, if we need to change any of these fields, we do not need to make changes to the code files.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Receiving messages from the queue</h1>
                
            
            
                
<p>In this section, we will create a console application that will receive messages from the queue. To create this application, follow these steps:</p>
<ol>
<li>Create a new console application (C#) and name it <kbd>FlixOne.BookStore.MessageReceiver</kbd>.</li>
<li>Add the NuGet package for Azure Service Bus (as added in the previous application).</li>
<li>Write the code to receive messages from the Azure Bus Service queue, so your <kbd>program.cs</kbd> file contains the method <kbd>ProcessMessagesAsync()</kbd>:</li>
</ol>
<pre style="padding-left: 60px"> static async Task ProcessMessagesAsync(Message message,<br/> CancellationToken token)<br/> {<br/>    WriteLine($"Received message: #<br/>    {message.SystemProperties.SequenceNumber}<br/>    Body:{Encoding.UTF8.GetString(message.Body)}");<br/>    await _client.CompleteAsync<br/>    (message.SystemProperties.LockToken);<br/> }</pre>
<ol start="4">
<li>Run the application and look at the result. Refer to the following screenshot:</li>
</ol>
<div><img height="183" src="img/3f1c2b74-34a0-425f-a02f-83af7f56e1f5.png" width="456"/></div>
<ol start="5">
<li>The console window will display the message and its ID. Now, go to the Azure portal and verify the message. It should be zero. Refer to the following screenshot:</li>
</ol>
<div><img class="image-border" height="374" src="img/75afb60c-ebb1-45e2-9e9e-5d376a0966b0.png" width="649"/></div>
<p>The preceding example demonstrates how we can use the Azure Bus Service to send/receive messages for our microservices.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>Inter-service communication is possible with synchronous or asynchronous communication, which are styles of collaboration. Microservices should have asynchronous APIs. The API gateway is a proxy server that provides a way to allow various clients to interact with APIs. API management, as an API gateway, provides plenty of features to manage/host various RESTful APIs. There are various patterns that help us communicate with microservices. With the use of Azure Bus Service, we can easily manage and play with inter-service communication using the Azure Bus Service message queue; services can easily send or receive messages between themselves through this. Eventual consistency talks about scalable systems with high scalability, and it is proven by the CAP theorem.</p>
<p>In the next chapter, we will discuss various testing strategies to test an application and build on the microservice architectural style.</p>


            

            
        
    </body></html>