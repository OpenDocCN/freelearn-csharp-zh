<html><head></head><body>
		<div id="_idContainer024">
			<h1 id="_idParaDest-202" class="chapter-number"><a id="_idTextAnchor270"/>6</h1>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor271"/>Higher-Order Functions and Delegates</h1>
			<p>In this chapter, we’ll dive into higher-order functions and delegates in C#. These concepts are crucial in functional programming and will help you write more flexible and <span class="No-Break">maintainable code.</span></p>
			<p>Higher-order functions are simply functions that can take other functions as arguments or return a function. This might sound complex, but don’t worry; we’ll break it down with clear examples and explanations. Higher-order functions are a key part of functional programming, allowing you to write code that’s both more concise and <span class="No-Break">more expressive.</span></p>
			<p>Delegates in C# are closely related to higher-order functions. They are like variables for methods, allowing you to pass methods as arguments or store them as values. This chapter will help you understand how to use delegates to implement higher-order functions in the <span class="No-Break">following sections:</span></p>
			<ul>
				<li>Understanding <span class="No-Break">higher-order functions</span></li>
				<li>Delegates, actions, funcs, <span class="No-Break">and predicates</span></li>
				<li>Callbacks, events, and <span class="No-Break">anonymous methods</span></li>
				<li>Harnessing LINQ methods as <span class="No-Break">higher-order functions</span></li>
				<li>Case study – putting it <span class="No-Break">all together</span></li>
				<li>Best practices and <span class="No-Break">common pitfalls</span></li>
			</ul>
			<p>In keeping with the tradition of our previous chapters, we’ll start this one with a brief self-evaluation. Below are three tasks designed to test your understanding of the concepts that will be discussed in this chapter. If you hesitate or struggle with these tasks, I recommend that you pay close attention to this chapter. However, if you find them easy, it might be a good opportunity to focus on areas where your knowledge isn’t as strong. So, let’s look at the <span class="No-Break">tasks now.</span></p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor272"/>Task 1 – Sorting function</h1>
			<p>Write a program <a id="_idIndexMarker341"/>that uses a higher-order function to sort a list of towers in Steve’s game based on their damage output. The sorting function should be passed as <span class="No-Break">a delegate.</span></p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor273"/>Task 2 – Customized calculations</h1>
			<p>Create a method that takes an <strong class="source-inline">Action</strong> and a list of enemies. The <strong class="source-inline">Action</strong> should perform a <a id="_idIndexMarker342"/>calculation on each enemy’s health and print the result. Test your method using several different <strong class="source-inline">Action</strong>s, such as calculating damage taken from different <span class="No-Break">tower types.</span></p>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor274"/>Task 3 – Comparison</h1>
			<p>Implement <a id="_idIndexMarker343"/>a method that uses a <strong class="source-inline">Func</strong> delegate to compare two towers based on their range. The method should return the tower with the <span class="No-Break">longer rang<a id="_idTextAnchor275"/>e.</span></p>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor276"/>Understanding higher-order functions</h1>
			<p>In functional <a id="_idIndexMarker344"/>programming, a higher-order function is simply a function that does at least one of <span class="No-Break">the following:</span></p>
			<ul>
				<li>Takes one or more functions <span class="No-Break">as parameters</span></li>
				<li>Returns a function as <span class="No-Break">a result</span></li>
			</ul>
			<p>Yes, you heard it right! Higher-order functions treat functions as data, to be passed around like any other value. This leads to an unprecedented level of abstraction and <span class="No-Break">code reuse.</span></p>
			<p>Consider a video management system in a YouTube-like platform, where efficiently handling a large collection of videos is crucial. Instead of writing separate functions for each type of video filtering, we can utilize higher-order functions for a more elegant and reusable solution. A higher-order function can abstract the filtering logic, making the code more <a id="_idIndexMarker345"/>modular and maintainable. Here’s a <span class="No-Break">simplified example:</span></p>
			<pre class="source-code">
public Func&lt;Func&lt;Video, bool&gt;, IEnumerable&lt;Video&gt;&gt; FilterVideos(IEnumerable&lt;Video&gt; videos)
{
    return filter =&gt;
    {
        Console.WriteLine("Filtering videos...");
        var filteredVideos = videos.Where(filter).ToList();
        Console.WriteLine($"Filtered {filteredVideos.Count} videos.");
        return filteredVideos;
    };
}
// Usage
var allVideos = new List&lt;Video&gt; { /* Collection of videos */ };
var filterFunc = FilterVideos(allVideos);
var publicVideos = filterFunc(v =&gt; v.IsPublic);</pre>			<p>In this system, we have a collection of <strong class="source-inline">Video</strong> objects. We want to filter these videos based on different criteria such as visibility, length, or genre. To achieve this, we create a higher-order function called <strong class="source-inline">FilterVideos</strong>. This function takes a collection of videos and returns another function. The returned function is capable of filtering the videos based on a provided predicate – a function that defines the filtering criteria. This design allows us to easily create various filters without duplicating the filtering logic, thereby enhancing code reuse <span class="No-Break">and readabil<a id="_idTextAnchor277"/>ity.</span></p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor278"/>The power of higher-order functions in functional programming</h2>
			<p>Higher-order functions are a cornerstone of functional programming, offering robustness <a id="_idIndexMarker346"/>and flexibility. Their ability to treat functions as data, and the resulting abstraction and versatility, can be seen in various facets <span class="No-Break">of programming.</span></p>
			<p>The ability of higher-order functions to abstract and encapsulate behaviors is unparalleled, leading to significant code reuse. For instance, consider a scenario in a mobile tower defense game where we need various types of unit transformations. Instead of repeating transformation logic, we can abstract this through a higher-order function. Here’s an <span class="No-Break">illustrative example:</span></p>
			<pre class="source-code">
public Func&lt;Unit, Unit&gt; CreateTransformation&lt;T&gt;(Func&lt;Unit, T, Unit&gt; transform, T parameter)
{
    return unit =&gt; transform(unit, parameter);
}
// Usage
Func&lt;Unit, Unit&gt; upgradeArmor = CreateTransformation((unit, bonus) =&gt; unit.UpgradeArmor(bonus), 10);
Unit myUnit = new Unit();
Unit upgradedUnit = upgradeArmor(myUnit);</pre>			<p>In this example, <strong class="source-inline">CreateTransformation</strong> is a higher-order function that returns a new function, encapsulating the transformation behavior. It promotes code reuse and abstraction by providing a flexible way to apply different transformations to <span class="No-Break">game units.</span></p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor279"/>Creating versatile code with fewer errors</h2>
			<p>Higher-order functions also contribute to writing generic and versatile code, leading to fewer <a id="_idIndexMarker347"/>errors. By encapsulating a generic behavior, these functions reduce the amount of code written, which is then more frequently tested and less prone <span class="No-Break">to bugs.</span></p>
			<p>Consider a function for applying effects to units in a tower defense game. Using a higher-order function, we can pass different effects <span class="No-Break">as parameters:</span></p>
			<pre class="source-code">
public Func&lt;Unit, Unit&gt; ApplyEffect(Func&lt;Unit, Unit&gt; effect)
{
    return unit =&gt;
    {
        return effect(unit);
    };
}
// Usage
Func&lt;Unit, Unit&gt; applyFreeze = ApplyEffect(u =&gt; u.Freeze());
Unit enemyUnit = new Unit();
Unit affectedUnit = applyFreeze(enemyUnit);</pre>			<p>Here, <strong class="source-inline">ApplyEffect</strong> allows for various effects to be applied to game units, simplifying the code base and reducing <span class="No-Break">potential errors.</span></p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor280"/>Supporting a more declarative coding style</h2>
			<p>Higher-order <a id="_idIndexMarker348"/>functions foster a declarative style of coding. You describe what you want to achieve rather than how to achieve it, making code more readable <span class="No-Break">and maintainable.</span></p>
			<p>In the game effect example, we declaratively specify that we want to apply an effect to a unit. The specifics <a id="_idIndexMarker349"/>of how the effect is applied are abstracted within the <span class="No-Break"><strong class="source-inline">ApplyEffect</strong></span><span class="No-Break"> function.</span></p>
			<p>In conclusion, higher-order functions in functional programming are invaluable. They enable <a id="_idIndexMarker350"/>code reuse, reduce errors, and support a declarative coding style, making them a powerful tool in any <span class="No-Break">programmer’s<a id="_idTextAnchor281"/> toolkit.</span></p>
			<h1 id="_idParaDest-211"><a id="_idTextAnchor282"/>Delegates, actions, funcs, and predicates</h1>
			<p>Delegates are essentially type-safe function pointers, holding references to functions. This type of safety is crucial as it ensures that the function’s signature aligns with the delegate’s defined signature. Delegates enable methods to be passed as parameters, returned from functions, and stored in data structures, making them indispensable for event handling and other <span class="No-Break">dynamic functionalities.</span></p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor283"/>Delegates</h2>
			<p>Let’s apply <a id="_idIndexMarker351"/>the concept of delegates to a book publishing system. Imagine we need to notify different departments when a new book <span class="No-Break">is published.</span></p>
			<p>First, define a delegate matching the notification <span class="No-Break">function’s signature:</span></p>
			<pre class="source-code">
public delegate void BookPublishedNotification(string bookTitle);</pre>			<p>Next, create a class to manage book publishing that accepts a delegate in <span class="No-Break">its method:</span></p>
			<pre class="source-code">
public class BookPublishingManager
{
    public void PublishBook(string bookTitle, BookPublishedNotification notifyDepartments)
    {
        // Publishing logic here
        notifyDepartments(bookTitle);
    }
}</pre>			<p>Now, any function <a id="_idIndexMarker352"/>that matches the delegate’s signature can be passed into <strong class="source-inline">PublishBook</strong> and will be called when a new book <span class="No-Break">is published:</span></p>
			<pre class="source-code">
public void NotifyMarketingDepartment(string bookTitle)
{
    Console.WriteLine($"Marketing notified for the book: {bookTitle}");
}
// Usage
BookPublishingManager publishingManager = new BookPublishingManager();
publishingManager.PublishBook("Functional Programming in C# 12", NotifyMarketingDepartment);</pre>			<p>In this example, any function that matches the <strong class="source-inline">BookPublishedNotification</strong> delegate’s signature can be passed to <strong class="source-inline">PublishBook</strong> and will be invoked when a book is published. This demonstrates the flexibility and dynamism of delegates in a <span class="No-Break">practica<a id="_idTextAnchor284"/>l scenario.</span></p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor285"/>Actions</h2>
			<p>In functional <a id="_idIndexMarker353"/>programming, <strong class="source-inline">Actions</strong> are a type of delegate that does not return a value. They are ideal for executing methods that perform actions but do not need to return a result. This simplicity makes <strong class="source-inline">Actions</strong> a versatile tool in various <span class="No-Break">programming scenarios.</span></p>
			<p>Consider a mobile tower defense game where certain events, such as spawning enemies and triggering effects, do not require a return value. We can use an <strong class="source-inline">Action</strong> delegate to handle <span class="No-Break">these scenarios:</span></p>
			<pre class="source-code">
public class TowerDefenseGame
{
    public event Action&lt;string&gt; OnEnemySpawned;
    public void SpawnEnemy(string enemyType)
    {
        // Enemy spawning logic here
        OnEnemySpawned?.Invoke(enemyType);
    }
}
// Usage
TowerDefenseGame game = new TowerDefenseGame();
game.OnEnemySpawned += enemyType =&gt; Console.WriteLine($"Spawned {enemyType}");
game.SpawnEnemy("Goblin");</pre>			<p>In this <a id="_idIndexMarker354"/>example, <strong class="source-inline">OnEnemySpawned</strong> is an <strong class="source-inline">Action</strong> delegate used to notify when an enemy is spawned. The simplicity of <strong class="source-inline">Action</strong> delegates allows for clean and clear event handling in the <a id="_idTextAnchor286"/><span class="No-Break">game’s logic.</span></p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor287"/>Funcs</h2>
			<p><strong class="source-inline">Funcs</strong>, another <a id="_idIndexMarker355"/>kind of built-in delegate, are used when a return value is needed. They can have between 0 and 16 input parameters, with the last parameter type always being the <span class="No-Break">return type.</span></p>
			<p>In the context of the same tower defense game, imagine we need a function to calculate the score based on various game parameters. This is where <strong class="source-inline">Funcs</strong> <span class="No-Break">become useful:</span></p>
			<pre class="source-code">
public class TowerDefenseGame
{
    public Func&lt;int, int, double&gt; CalculateScore;
    public double GetScore(int enemiesDefeated, int towersBuilt)
    {
        return CalculateScore?.Invoke(enemiesDefeated, towersBuilt) ?? 0;
    }
}
// Usage
TowerDefenseGame game = new TowerDefenseGame();
game.CalculateScore = (enemiesDefeated, towersBuilt) =&gt; enemiesDefeated * 10 + towersBuilt * 5;
double score = game.GetScore(50, 10);</pre>			<p>Here, <strong class="source-inline">CalculateScore</strong> is a <strong class="source-inline">Func</strong> delegate, allowing for a flexible and customizable way to calculate <a id="_idIndexMarker356"/>the game’s score based on dynamic gameplay factors. <strong class="source-inline">Funcs</strong> provide a powerful way to define operations with return values, enhancing the flexibility and reusabili<a id="_idTextAnchor288"/>ty of <span class="No-Break">the code.</span></p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor289"/>Predicates</h2>
			<p><strong class="source-inline">Predicate&lt;T&gt;</strong> is a delegate <a id="_idIndexMarker357"/>that represents a method containing a set of criteria and checks whether the passed parameter meets those criteria. A predicate delegate method must take one input parameter and return a <span class="No-Break"><strong class="source-inline">bool</strong></span><span class="No-Break"> value.</span></p>
			<p>In a YouTube-like video management system, we might use <strong class="source-inline">Predicate&lt;Video&gt;</strong> to filter videos based on <span class="No-Break">certain criteria:</span></p>
			<pre class="source-code">
public class VideoManager
{
    IEnumerable&lt;Video&gt; _videos; // We assume it will be filled later
    public IEnumerable&lt;Video&gt; GetVideosMatching(Predicate&lt;Video&gt; criteria)
    {
        foreach (var video in _videos)
        {
            if (criteria(video))
            {
                yield return video;
            }
        }
    }
}
// Usage
VideoManager videoManager = new();
Predicate&lt;Video&gt; isPopular = video =&gt; video.Views &gt; 100000;
List&lt;Video&gt; popularVideos = videoManager.GetVideosMatching(isPopular);</pre>			<p>In this example, <strong class="source-inline">GetVideosMatching</strong> takes a <strong class="source-inline">Predicate&lt;Video&gt;</strong> delegate to filter videos. The <a id="_idIndexMarker358"/>method iterates through the list of videos and adds those meeting the criteria defined by the predicate to the result list. It could be written as a one-liner using <strong class="source-inline">Where</strong>, but using <strong class="source-inline">yield return</strong> makes it <span class="No-Break">more expressive.</span></p>
			<p>So, summarizing all we’ve learned about delegates, actions, funcs, and predicates, we can see <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Delegates</strong>: The foundational elements, allowing methods to be referenced and passed around, vital to creating <span class="No-Break">higher-order functions</span></li>
				<li><strong class="bold">Actions</strong>: Specialized delegates for methods that perform actions but don’t return values, simplifying <span class="No-Break">task encapsulation</span></li>
				<li><strong class="bold">Funcs</strong>: Delegates that return a result, useful for computations <span class="No-Break">and transformations</span></li>
				<li><strong class="bold">Predicates</strong>: A form of func always returning a Boolean, standardizing <span class="No-Break">condition checks</span></li>
			</ul>
			<p>These constructs collectively can enhance our programming, enabling code reuse, higher abstraction, and a flexible, <span class="No-Break">functional style.</span></p>
			<p>Let’s continue with even more exciting<a id="_idTextAnchor290"/> <span class="No-Break">constructs next.</span></p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor291"/>Callbacks, events, and anonymous methods</h1>
			<p>Callbacks are a pivotal concept in asynchronous and event-driven programming. They are essentially <a id="_idIndexMarker359"/>delegates that point to a method, allowing it to be called at a later time. This facilitates non-blocking code execution, crucial for <span class="No-Break">responsive applications.</span></p>
			<p>Imagine a <a id="_idIndexMarker360"/>book publishing system where we need to perform actions such as sending notifications after a book is published. Here, a callback can notify other <a id="_idIndexMarker361"/>parts of the system once the publishing process <span class="No-Break">is completed:</span></p>
			<pre class="source-code">
public delegate void BookPublishedCallback(string bookTitle);
public class BookPublishingManager
{
    public void PublishBook(string bookTitle, BookPublishedCallback callback)
    {
        // Book publishing logic here...
        callback(bookTitle);
    }
}
// Usage
BookPublishingManager manager = new BookPublishingManager();
manager.PublishBook("C# in Depth", title =&gt; Console.WriteLine($"{title} has been published!"));</pre>			<p>In this <a id="_idIndexMarker362"/>scenario, the callback is invoked after a book is published, providing <a id="_idIndexMarker363"/>a flexible and decoupled way of handling <a id="_idIndexMarker364"/><span class="No-Break">pos<a id="_idTextAnchor292"/>t-publishing processes.</span></p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor293"/>The role of delegates in events</h2>
			<p>Events, built on <a id="_idIndexMarker365"/>the publisher-subscriber model, are another <a id="_idIndexMarker366"/>powerful application of delegates. They allow objects to notify others about occurrences <span class="No-Break">of interest.</span></p>
			<p>The book publishing system can be further enhanced by using events, providing a more robust and flexible mechanism <span class="No-Break">for notifications:</span></p>
			<pre class="source-code">
public class BookPublishingManager
{
    public event Action&lt;string&gt; OnBookPublished;
    public void PublishBook(string bookTitle)
    {
        // Book publishing logic here...
        OnBookPublished?.Invoke(bookTitle);
    }
}
// Usage
BookPublishingManager manager = new BookPublishingManager();
manager.OnBookPublished += title =&gt; Console.WriteLine($"{title} has been published!");
manager.PublishBook("Advanced C# Programming");</pre>			<p>In this version, <strong class="source-inline">OnBookPublished</strong> is an event that subscribers can listen to. When a book is <a id="_idIndexMarker367"/>published, the event is raised, and all subscribed <a id="_idIndexMarker368"/>methods are invoked. This model enhances modularity and reduces coupling between the publishing logic <a id="_idTextAnchor294"/>and its <span class="No-Break">subsequent actions.</span></p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor295"/>Delegates and anonymous methods</h2>
			<p>Anonymous methods are methods that are not bound to a specific name. They are defined <a id="_idIndexMarker369"/>using the <strong class="source-inline">delegate</strong> keyword and can be used to create instances of a delegate. Anonymous methods provide a way to define methods in place where they are called, making your code more concise <span class="No-Break">and readable.</span></p>
			<p>Let’s create <a id="_idIndexMarker370"/>a simple anonymous method that filters a list of video objects based on a specific criterion, such as videos that are longer than a certain duration. We’ll use an anonymous method with the <strong class="source-inline">FindAll</strong> method to <span class="No-Break">accomplish this:</span></p>
			<pre class="source-code">
public class Video
{
    public string Title { get; set; }
    public int DurationInSeconds { get; set; }
}
List&lt;Video&gt; videos = new List&lt;Video&gt;
{
    new Video { Title = "Introduction to C#", DurationInSeconds = 300 },
    new Video { Title = "Advanced C# Techniques", DurationInSeconds = 540 },
    new Video { Title = "C# Functional Programming", DurationInSeconds = 420 }
};
List&lt;Video&gt; longVideos = videos.FindAll(delegate(Video video)
{
    return video.DurationInSeconds &gt; 450; // Filtering videos longer than 450 seconds
});
foreach (Video video in longVideos)
{
    Console.WriteLine(video.Title);  // Outputs titles of videos longer than 450 seconds
}</pre>			<p>In this example, <strong class="source-inline">delegate(Video video) {...}</strong> is an anonymous method used to define <a id="_idIndexMarker371"/>the criteria for the <strong class="source-inline">FindAll</strong> method, filtering videos based <a id="_idIndexMarker372"/>on their duration. This demonstrates how anonymous methods can be employed in practical scenarios such as filtering data in a video <span class="No-Break">management system.</span></p>
			<p>By leveraging delegates to create callbacks, handle events, and define anonymous methods, we gain a powerful set of tools that allow us to write more <a id="_idTextAnchor296"/>flexible and <span class="No-Break">maintainable code.</span></p>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor297"/>Harnessing LINQ methods as higher-order functions</h1>
			<p><strong class="bold">Language Integrated Query</strong> (<strong class="bold">LINQ</strong>) in C# integrates query capabilities into the language, functioning <a id="_idIndexMarker373"/>primarily through extension <a id="_idIndexMarker374"/>methods. These methods, adhering to functional programming principles, allow for concise and expressive data manipulation. We’ll explore how LINQ can be effectively used in different systems for data filtering,<a id="_idTextAnchor298"/> transformation, <span class="No-Break">and aggregation.</span></p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor299"/>Filtering</h2>
			<p>In a video <a id="_idIndexMarker375"/>management system, we might need to filter videos based on their view count. Using the <strong class="source-inline">Where</strong> method, we can easily <span class="No-Break">achieve this:</span></p>
			<pre class="source-code">
List&lt;Video&gt; videos = GetAllVideos();
 IEnumerable&lt;Video&gt; popularVideos = videos.Where(video =&gt; video.Views &gt; 100000);
foreach(var video in popularVideos)
{
    Console.WriteLine(video.Title);
}</pre>			<h2 id="_idParaDest-221"><a id="_idTextAnchor300"/>Data transformation</h2>
			<p>In a <a id="_idIndexMarker376"/>publishing system, converting book titles to uppercase for a uniform catalog display can be done using the <span class="No-Break"><strong class="source-inline">Select</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
List&lt;Book&gt; books = GetBooks();
var upperCaseTitles = books.Select(book =&gt; book.Title.ToUpper());
foreach(var title in upperCaseTitles<a id="_idTextAnchor301"/>)
{
    Console.WriteLine(title);
}</pre>			<h2 id="_idParaDest-222"><a id="_idTextAnchor302"/>Data aggregation</h2>
			<p>For a mobile <a id="_idIndexMarker377"/>tower defense game, calculating the average damage of all towers can be efficiently done using the <span class="No-Break"><strong class="source-inline">Average</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
double averageGrade = students.Average(student =&gt; student.Grade);
Console.WriteLine($"Average Grade: {averageGrade}");</pre>			<p>These examples showcase the power of LINQ as higher-order functions, demonstrating how they can be used to handle complex data operations in various real-world applications, making code more re<a id="_idTextAnchor303"/>adable, maintainable, <span class="No-Break">and enjoyable.</span></p>
			<h1 id="_idParaDest-223"><a id="_idTextAnchor304"/>Case study – putting it all together</h1>
			<p>Here, we’ll bring together all the elements we’ve discussed so far: higher-order functions, delegates, actions, funcs, predicates, and LINQ methods. We’ll provide a comprehensive, real-world example and analyze the code, step <span class="No-Break">by step.</span></p>
			<p>Imagine we are developing a mobile tower defense game. This game involves managing towers, handling enemy waves, and upgrading <span class="No-Break">tower capabilities.</span></p>
			<p>Here’s an outline of the classes <span class="No-Break">we’ll use:</span></p>
			<pre class="source-code">
public class Tower
{
    public string Type { get; set; }
    public int Damage { get; set; }
    public bool IsUpgraded { get; set; }
}
public class Game
{
    private List&lt;Tower&gt; _towers { get; set; }
    public IEnumerable&lt;Tower&gt; FilterTowers(Func&lt;Tower, bool&gt; predicate) { /* … */ }
    public event Action&lt;Tower&gt; TowerUpgraded;
    public void UpgradeTower(Tower tower) { /* … */ }
}</pre>			<p>The <strong class="source-inline">Tower</strong> class here <a id="_idIndexMarker378"/>represents the basic building block of the game – the towers. Each tower has a type, a damage level, and a status indicating whether it has been upgraded. This class is a cornerstone for the game’s mechanics, as different towers might have various effects and strategies associated <span class="No-Break">with them.</span></p>
			<p>The <strong class="source-inline">Game</strong> class acts <a id="_idIndexMarker379"/>as a central hub for managing the game’s logic. It contains a list of all towers in the game. The class demonstrates advanced functional <span class="No-Break">programming techniques:</span></p>
			<ul>
				<li>The <strong class="source-inline">FilterTowers</strong> method is a <a id="_idIndexMarker380"/>quintessential example of using higher-order functions in a real-world application. By accepting a <strong class="source-inline">Func&lt;Tower, bool&gt;</strong> as a predicate, it provides a flexible way to filter towers based on dynamic criteria, such as damage level, range, or upgrade status. This method makes use of LINQ, showcasing its power in simplifying data <span class="No-Break">manipulation tasks.</span></li>
				<li>The <strong class="source-inline">TowerUpgraded</strong> event, coupled with the <strong class="source-inline">UpgradeTower</strong> method, demonstrates <a id="_idIndexMarker381"/>the use of actions and delegates. This event-driven approach allows for reactive programming, where different parts of the game can respond to changes in tower states, such as triggering animations, sounds, or game<a id="_idTextAnchor305"/> logic updates when a tower <span class="No-Break">is upgraded.</span></li>
			</ul>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor306"/>Step-by-step walk-through and analysis of the code</h2>
			<p>Now, let’s add some logic to our me<a id="_idTextAnchor307"/>thods and write the code that <span class="No-Break">uses them:</span></p>
			<ol>
				<li><strong class="bold">FilterTowers method</strong>: The <strong class="source-inline">FilterTowers</strong> method uses a predicate (a <strong class="source-inline">Func</strong> that returns a <strong class="source-inline">bool</strong>) to select towers based on specific criteria, illustrating <a id="_idIndexMarker382"/>higher-order functions <span class="No-Break">and LINQ:</span><pre class="source-code">
public IEnumerable&lt;Tower&gt; FilterTowers(Func&lt;Tower, bool&gt; predicate)
{
    return _towers.Where(predicate);
}</pre><p class="list-inset">This approach allows for dynamic tower filtering, adapting to vari<a id="_idTextAnchor308"/>ous game scenarios and <span class="No-Break">player strategies.</span></p></li>				<li><strong class="bold">TowerUpgraded event</strong>: The <strong class="source-inline">TowerUpgraded</strong> event demonstrates how delegates <a id="_idIndexMarker383"/>facilitate event handling in <span class="No-Break">the game:</span><pre class="source-code">
public void UpgradeTower(Tower tower)
{
    if (!tower.IsUpgraded)
    {
        tower.IsUpgraded = true;
        TowerUpgraded?.Invoke(tower);
    }
}</pre><p class="list-inset">This mechanism is crucial for notifying different parts of the game about tower upgrad<a id="_idTextAnchor309"/>es and maintaining game <span class="No-Break">state consistency.</span></p></li>				<li><strong class="bold">Interacting with the game</strong>: Finally, let’s see how a user might interact with <span class="No-Break">the library:</span><pre class="source-code">
Game game = new Game();
// Filtering towers using a Predicate
var highDamageTowers = game.FilterTowers(tower =&gt; tower.Damage &gt; 50);
// Subscribing to events with anonymous methods
game.TowerUpgraded += tower =&gt; Console.WriteLine($"{tower.Type} was upgraded.");
// Upgrading a tower
var cannonTower = highDamageTowers.First();
game.UpgradeTower(cannonTower);</pre><p class="list-inset">In this snippet, we see the practical application of the game’s functional programming features. From filtering towers based on damage to handling tower upgrades, the code is concise, expressive, <span class="No-Break">and effective.</span></p></li>			</ol>
			<p>This case study demonstrates the use of predicates, events, delegates, and higher-order functions in a practical scenario. It showcases how functional programming principles can enhance the development and operation of a complex mobile game, leading to more efficient, expressive, and powerful programming. The integration of these concepts provides a solid foundation for bu<a id="_idTextAnchor310"/>ilding engaging and robust <span class="No-Break">game mechanics.</span></p>
			<h1 id="_idParaDest-225"><a id="_idTextAnchor311"/>Best practices and common pitfalls</h1>
			<p>This section takes a closer look at best practices when working with higher-order functions, delegates, actions, funcs, predicates, and LINQ. We’ll also discuss common mistakes that developers make and offer<a id="_idTextAnchor312"/> solutions on how to avoid <span class="No-Break">these pitfalls.</span></p>
			<p>Here are <a id="_idIndexMarker384"/>some best practices to use while working with <span class="No-Break">higher-order functions:</span></p>
			<ul>
				<li><strong class="bold">Aim for stateless functions</strong>: For consistency and predictability, strive to ensure that the functions you pass as arguments are stateless, meaning they don’t rely on or change the state of anything outside themselves. This makes them more predictable and less prone to <span class="No-Break">side effects.</span></li>
				<li><strong class="bold">Embrace immutability</strong>: One of the core principles of functional programming is immutability. When passing objects to your higher-order functions, consider whether they can be made immutable to ensure that the function doesn’t alter <span class="No-Break">their state.</span></li>
				<li><strong class="bold">Use descriptive names</strong>: As you are passing around functions, it’s easy to lose track of what each one does. Therefore, use descriptive names for your funct<a id="_idTextAnchor313"/>ions and parameters to <span class="No-Break">improve readability.</span></li>
			</ul>
			<p>Some of <a id="_idIndexMarker385"/>the common pitfalls are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Overuse of LINQ</strong>: While LINQ is a powerful tool, it can lead to performance issues if not used carefully. Particularly when working with large datasets, be aware that some LINQ operations, such as <strong class="source-inline">OrderBy</strong>, <strong class="source-inline">Reverse</strong>, and <strong class="source-inline">Count</strong>, may be costly. Always measure the performance of your queries and consider alternative approaches <span class="No-Break">if necessary.</span></li>
				<li><strong class="bold">Ignoring type safety with delegates</strong>: While delegates are powerful, they can also bypass type safety if not used with care. Always ensure the delegate signature matches the method it points to avoid <span class="No-Break">runtime errors.</span></li>
				<li><strong class="bold">Not handling null delegates</strong>: When invoking a delegate, it’s good practice to check it for null first or invoke it with the question mark. Failing to do this can result in <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">NullReferenceException</strong></span><span class="No-Break">:</span><pre class="source-code">
myDelegate?.Invoke();</pre></li>				<li><strong class="bold">Misuse of anonymous functions</strong>: Anonymous functions can lead to cleaner code, but they can also hide complexity and make code harder to test. If an anonymous <a id="_idIndexMarker386"/>function is more than a few lines long, or if it’s complex enough to require testing on its own, it should probably be a named <span class="No-Break">function instead.</span></li>
			</ul>
			<p>By following these best practices and avoiding common mistakes, you can write clean, efficient, and maintainable code, harnessing the power of func<a id="_idTextAnchor314"/>tional programming constructs to <span class="No-Break">the fullest.</span></p>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor315"/>Exercises</h1>
			<p>The theory and concepts are only half the learning journey. Now, it’s time to get your hands dirty with some practical exercises. This chapter provides a series of challenging problems to test your understanding of the concepts learned and to reinforce them. Following each problem, you’ll find a <a id="_idTextAnchor316"/>proposed solution with <span class="No-Break">detailed explanations.</span></p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor317"/>Exercise 1</h2>
			<p>Write a program that uses a higher-order function to sort a list of towers in Steve’s game based on their damage output. The sor<a id="_idTextAnchor318"/>ting function should be passed as <span class="No-Break">a delegate.</span></p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor319"/>Exercise 2</h2>
			<p>Create a method that takes an <strong class="source-inline">Action</strong> and a list of enemies. The <strong class="source-inline">Action</strong> should perform a calculation on each enemy’s health and print the result. Test your method using several different <strong class="source-inline">Action</strong>s, such as calcula<a id="_idTextAnchor320"/>ting damage taken from different <span class="No-Break">tower types.</span></p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor321"/>Exercise 3</h2>
			<p>Implement a method that uses a <strong class="source-inline">Func</strong> delegate to compare two towers based on their range. The method s<a id="_idTextAnchor322"/>hould retu<a id="_idTextAnchor323"/>rn the tower with the <span class="No-Break">longer range.</span></p>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor324"/>Solutions</h1>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor325"/>Exercise 1</h2>
			<p>Steve implemented a sorting function for towers using <span class="No-Break">a delegate:</span></p>
			<pre class="source-code">
public class Tower
{
     public string Name { get; set; }
     public int Damage { get; set; }
}
public delegate int CompareTowers(Tower a, Tower b);
public static void SortTowers(List&lt;Tower&gt; towers, CompareTowers compare)
{
     towers.Sort((x, y) =&gt; compare(x, y));
}
// Usage:
List&lt;Tower&gt; towers = new List&lt;Tower&gt;
{
     new Tower { Name = "Archer", Damage = 10 },
     new Tower { Name = "Cannon", Damage = 20 },
     new Tower { Name = "Mage", Damage = 15 }
};
SortTowers(towers, (a, b) =&gt; b.Damage.CompareTo(a.Damage)); // Sort descending
foreach (var tower in towers)
{
     Console.WriteLine($"{tower.Name}: {tower.Damage} damage");
}</pre>			<p>This solution creates a <strong class="source-inline">CompareTowers</strong> delegate that takes two <strong class="source-inline">Tower</strong> objects and returns an <strong class="source-inline">int</strong>. The <strong class="source-inline">SortTowers</strong> method then u<a id="_idTextAnchor326"/>ses this delegate to sort the list <span class="No-Break">of towers.</span></p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor327"/>Exercise 2</h2>
			<p>For enemy health calculations, Steve created <span class="No-Break">this method:</span></p>
			<pre class="source-code">
public class Enemy
{
     public string Name { get; set; }
     public int Health { get; set; }
}
public static void ProcessEnemies(List&lt;Enemy&gt; enemies, Action&lt;Enemy&gt; action)
{
     foreach (var enemy in enemies)
     {
                  action(enemy);
     }
}
// Usage:
List&lt;Enemy&gt; enemies = new List&lt;Enemy&gt;
{
     new Enemy { Name = "Goblin", Health = 50 },
     new Enemy { Name = "Orc", Health = 100 },
     new Enemy { Name = "Troll", Health = 200 }
};
// Calculate damage from arrow tower
ProcessEnemies(enemies, (e) =&gt; Console.WriteLine($"{e.Name} takes {e.Health * 0.1} damage from arrow tower"));
// Calculate damage from fire tower
ProcessEnemies(enemies, (e) =&gt; Console.WriteLine($"{e.Name} takes {e.Health * 0.2} damage from fire tower"));</pre>			<p>This solution iterates over a list of e<a id="_idTextAnchor328"/>nemies and applies the passed action <span class="No-Break">to each.</span></p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor329"/>Exercise 3</h2>
			<p>Here’s a solution to the <span class="No-Break">third problem:</span></p>
			<pre class="source-code">
public class Tower
{
     public string Name { get; set; }
     public int Range { get; set; }
}
public static Tower GetLongerRangeTower(Tower t1, Tower t2, Func&lt;Tower, Tower, Tower&gt; compare)
{
     return compare(t1, t2);
}
// Usage:
Tower archer = new Tower { Name = "Archer", Range = 50 };
Tower cannon = new Tower { Name = "Cannon", Range = 30 };
Tower longerRange = GetLongerRangeTower(archer, cannon, (a, b) =&gt; a.Range &gt; b.Range ? a : b);
Console.WriteLine($"{longerRange.Name} has the longer range of {longerRange.Range}");</pre>			<p>This solution uses a <strong class="source-inline">Func</strong> delegate to compare the ranges of<a id="_idTextAnchor330"/> two towers and returns the <span class="No-Break">longer-range one.</span></p>
			<p>Remember, while these solutions work, there may be other equally valid approaches. These exercises are about reinforcing the concepts learned and exploring different ways to <span class="No-Break">apply them.</span></p>
			<h1 id="_idParaDest-234"><a id="_idTextAnchor331"/>Summary</h1>
			<p>As we conclude this chapter on higher-order functions and delegates in the context of functional programming in C#, let’s pause to reflect on the key concepts we’ve delved into and anticipate what’s next on <span class="No-Break">our journey:</span></p>
			<ul>
				<li><strong class="bold">Higher-order functions</strong>: These functions, capable of receiving other functions as parameters or returning them, are foundational in promoting code reusability, abstraction, and a more declarative coding style. Their versatility enhances the expressiveness of our code, allowing us to write more <span class="No-Break">with less.</span></li>
				<li><strong class="bold">Delegates, actions, funcs, and predicates</strong>: Our exploration of these pivotal functional programming constructs revealed their unique roles and differences. We saw how they contribute to crafting versatile and reliable code, each playing a specific part in the broader <span class="No-Break">functional paradigm.</span></li>
				<li><strong class="bold">Delegates for callbacks, events, and anonymous methods</strong>: Delegates are the backbone of creating callbacks, managing events, and defining anonymous methods. They enable flexible, event-driven programming structures, crucial for responsive and <span class="No-Break">interactive applications.</span></li>
				<li><strong class="bold">LINQ as higher-order functions</strong>: We uncovered the immense power of the LINQ library in processing data collections. The emphasis was on how LINQ methods exemplify higher-order functions, offering elegant solutions for complex data manipulation <span class="No-Break">and querying.</span></li>
				<li><strong class="bold">Best practices and pitfalls</strong>: We rounded off with vital best practices for employing these concepts effectively and avoiding common mistakes. These insights are crucial for writing clean, efficient, and <span class="No-Break">maintainable code.</span></li>
			</ul>
			<p>In essence, this chapter has illuminated how the principles of functional programming can be effectively harnessed in C#. We’ve seen that by embracing these concepts, developers can achieve greater readability, maintainability, and robustness in <span class="No-Break">their code.</span></p>
			<p>As we turn the page to the next chapter, our journey into the depths of functional programming continues. We will delve into the intriguing world of functors and monads. These advanced concepts will unlock new levels of abstraction and composability for you. Stay tuned; it will <span class="No-Break">be interesting!</span></p>
		</div>
	</body></html>