<html><head></head><body>
		<div><h1 id="_idParaDest-64" class="chapter-number"><a id="_idTextAnchor063"/>3</h1>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor064"/>Writing Data to Relational and NoSQL Databases</h1>
			<p>After creating the first implementation of the service using minimal APIs, we build on that to read and write to databases. In this chapter, we will replace the in-memory repository built in <a href="B21217_02.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a> using <strong class="bold">Entity Framework Core</strong> (<strong class="bold">EF Core</strong>) to access a relational database – Microsoft SQL Server – and an Azure Cosmos DB NoSQL database using EF Core.</p>
			<p>You’ll create two libraries to access these databases, create EF Core context classes, specify the mappings from model classes, and configure the minimal APIs service to use one or the other database. After adding these changes, the games will be persisted and you can continue game runs when the service is restarted.</p>
			<p>In this chapter, you’ll be exploring these topics:</p>
			<ul>
				<li>Exploring the models for the data to be stored in the databases</li>
				<li>Creating and configuring an EF Core context to access Microsoft SQL Server</li>
				<li>Creating migrations to update the database schema</li>
				<li>Creating and configuring an EF Core context to access Azure Cosmos DB</li>
			</ul>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor065"/>Technical requirements</h1>
			<p>The code for this chapter can be found in the following GitHub repository: <a href="https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure">https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure</a>.</p>
			<p>The <code>ch03</code> source code folder contains the code samples for this chapter. The most important projects for this chapter are the following:</p>
			<ul>
				<li><code>Codebreaker.Data.SqlServer</code> – This is the new library to access Microsoft SQL Server.</li>
				<li><code>Codebreaker.Data.Cosmos</code> – This is the new library to access Azure Cosmos DB.</li>
				<li><code>Codebreaker.GamesAPIs</code> – This is the web API project created in the previous chapter. In this chapter, the <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>) container is updated to use .NET Aspire components to use SQL Server and Azure Cosmos DB.</li>
				<li><code>Codebreaker.GameAPIs.Models</code> – This project just has a minimal change in this chapter, adding a property to the <code>Game</code> class.</li>
				<li><code>Codebreaker.AppHost</code> – This project is updated with SQL Server and Azure Cosmos DB resources and forwarding configuration values.</li>
				<li><code>Codebreaker.ServiceDefaults</code> – This project is unchanged from the previous chapter.</li>
			</ul>
			<p>The <code>analyzer</code> library from the previous chapter is not included in this chapter. Here, we’ll just use the <code>CNinnovation.Codebreaker.Analyzers</code> NuGet package.</p>
			<p>If you worked through the previous chapter to create the models and implemented the minimal APIs project, you can continue from there. You can also copy the files from the <code>ch02</code> folder if you didn’t complete the previous work and start from there. <code>ch03</code> contains all the updates from this chapter.</p>
			<p>Other than a development environment, you need Microsoft SQL Server and Azure Cosmos DB. You don’t need an Azure subscription at this point. SQL Server is installed together with Visual Studio. You can also download the SQL Server 2022 Developer Edition instead. This is easy via <code>winget</code> (but you can also download and install Windows installer packages instead):</p>
			<pre class="console">
winget install Microsoft.SQLServer.2022.Developer</pre>
			<p>If you use a Mac, you can use a Docker image for SQL Server. In <a href="B21217_05.xhtml#_idTextAnchor110"><em class="italic">Chapter 5</em></a>, you can read more details on Docker and running SQL Server within a Docker container.</p>
			<p>For easy use of SQL Server and Azure Cosmos DB, Docker images are used in this chapter. You can also use SQL Server, which is installed together with Visual Studio, and the Azure Cosmos DB emulator instead.</p>
			<p>To run Azure Cosmos DB, an emulator to run it locally is available. You can install this NoSQL database emulator with the following command:</p>
			<pre class="console">
winget install Microsoft.Azure.CosmosEmulator</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">The Azure Cosmos emulator is only available on Windows. With Linux environments (and also on Windows and the Mac), you can use a Docker image to run the emulator. See <a href="https://learn.microsoft.com/en-us/azure/cosmos-db/how-to-develop-emulator">https://learn.microsoft.com/en-us/azure/cosmos-db/how-to-develop-emulator</a> for information on running the emulator. Read <a href="B21217_05.xhtml#_idTextAnchor110"><em class="italic">Chapter 5</em></a> for more information on Docker.</p>
			<p>To read and write your SQL Server data, within Visual Studio you can use SQL Server Object Explorer. Outside of Visual Studio, and with more functionality, use <strong class="bold">SQL Server Management Studio</strong> (<strong class="bold">SSMS</strong>), which can be installed with the following command:</p>
			<pre class="console">
winget install Microsoft.SQLServerManagementStudio</pre>
			<p>The projects of this chapter and how they relate to each other are shown in <em class="italic">Figure 3</em><em class="italic">.1</em> with a C4 component diagram. The <code>gamesAPI</code> and <code>models</code> components have been created in <a href="B21217_02.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a>. In this chapter, two projects for accessing SQL Server and Azure Cosmos DB databases will be added (<code>sqlDatabase</code> and <code>cosmosDatabase</code>). Depending on the configuration, the games API will use either the in-memory repository (created in <a href="B21217_02.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a>) or one of the other <code>IGamesRepository</code> implementations:</p>
			<div><div><img src="img/B21217_03_01.jpg" alt="Figure 3.1 – Projects"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Projects</p>
			<p>Let’s start exploring the project containing the models while making a small change to the models.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor066"/>Exploring the models for database mapping</h1>
			<p>When creating services, different <a id="_idIndexMarker113"/>models can be used for the database, the functionality, and the APIs. The database layer might have different requirements than the other layers. When creating a monolithic application, this usually is the case, but it also means that while maintaining the application and adding a field, all the different layers need to be touched and updated. When creating microservices with smaller scopes, there’s a good chance to use the same model with the database, the functionality of the application, and the APIs. This not only reduces maintenance costs but also improves performance in that not every layer creates new instances and copies the values around.</p>
			<p>With the sample application, the <code>Game</code> and <code>Move</code> types with their generic counterparts created in the previous chapter <a id="_idIndexMarker114"/>are not that simple, but it’s possible to use them directly with EF Core.</p>
			<p>Let’s look at the models and what must be mapped for the database, starting with the <code>Game</code> type:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Models/Game.cs</p>
			<pre class="source-code">
public class Game(
  Guid id,
  string gameType,
  string playerName,
  DateTime startTime,
  int numberCodes,
  int maxMoves)
{
  public Guid Id { get; <strong class="bold">private set;</strong> } = id;
  public string GameType { get; <strong class="bold">private set;</strong> } = gameType;
  public string PlayerName { get; <strong class="bold">private set;</strong> } = playerName;
  public DateTime StartTime { get; <strong class="bold">private set;</strong> } = startTime;
  // code removed for brevity
<strong class="bold">  public required IDictionary&lt;string, IEnumerable&lt;string&gt;&gt; FieldValues </strong>
<strong class="bold">    { get; init; }</strong>
<strong class="bold">  public required string[] Codes { get; init; }</strong>
<strong class="bold">  public ICollection&lt;Move&gt; Moves { get; } = new List&lt;Move&gt;();</strong>
  public override string ToString() =&gt; $"{Id}:{GameType} - 
<strong class="bold">    </strong>{StartTime}";
}</pre>
			<p>The <code>Game</code> class contains<a id="_idIndexMarker115"/> properties of type <code>Guid</code>, <code>string</code>, <code>DateTime</code>, <code>TimeSpan</code>, <code>int</code>, and <code>bool</code>. All these properties can easily be mapped to database columns. Just the size of the string needs to be configured. With SQL Server, the convention to map a string is <code>nvarchar(max)</code>. This can be reduced in size. What’s more interesting is the constructor.</p>
			<p>The class doesn’t define a parameterless constructor. While some tools require a parameterless constructor, both JSON serialization as well as EF Core nowadays don’t need one. EF Core supports constructors with parameters as long as the constructors map to simple properties – which is the case with the <code>Game</code> class. EF Core mapping supports properties with <code>get</code> and <code>set</code> accessors. If there’s just a <code>get</code> accessor available, the mapping will fail. A way around this is to use <code>private</code> fields. EF Core supports explicit mapping to fields. Another option is to use private <code>set</code> accessors – which are used with the <code>Game</code> class.</p>
			<p>Some other interesting members are available with the <code>Game</code> class: the <code>FieldValues</code> property is of type <code>IDictionary&lt;string, IEnumerable&lt;string&gt;&gt;</code>. The field values define the possible options the user can choose from. All games of one game type usually have the same field values, but this can change over time. We shouldn’t expect these values to always stay the same. The application might change the colors or shapes to choose from over time. So, we can’t just ignore the property to be stored – this should be stored with the game. As for this type, a default mapping is not available, so we need to add a conversion.</p>
			<p>The <code>Codes</code> property is of type string array. EF Core 8.0 supports built-in mapping of collections of primitive types; that is, a list of arrays, integers, strings, and more. With the built-in functionality, the collection is stored in the JSON format in a string table. This fits the purpose. The <code>Codes</code> property contains a list of a solution. With the color-based game types, this is a list of up to five colors; with the shape game type, one string of the collection consists of a shape and a color with a delimiter. Using a version older than EF Core 8, a custom conversion would be required. With EF Core 8, this will map with the default functionality.</p>
			<p>The <code>Moves</code> property is typically a relation with relational databases. Using SQL Server, we will use the <code>Moves</code> table to store every move. It would be possible to store moves with a JSON column, but we’ll <a id="_idIndexMarker116"/>use a separate table and query for moves if needed. Using a NoSQL database, it’s a natural way to store moves within the game.</p>
			<p>Let’s look into the <code>Move</code> type:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Models/Move.cs</p>
			<pre class="source-code">
public class Move(Guid id, int moveNumber)
{
<strong class="bold">  public Guid Id { get; private set; } = id;</strong>
<strong class="bold">  public int MoveNumber { get; private set; } = moveNumber;</strong>
<strong class="bold">  public required string[] GuessPegs { get; init; }</strong>
<strong class="bold">  public required string[] KeyPegs { get; init; }</strong>
  public override string ToString() =&gt; $"{MoveNumber}. " +
    $"{string.Join('#',GuessPegs)} : " +
    $"{string.Join('#', KeyPegs)}";
}</pre>
			<p>With the <code>Move</code> class, <code>GuessPegs</code> (the guess of the player for the move) and <code>KeyPegs</code> (the result from the analyzer) can be serialized similarly to the <code>Codes</code> property from the <code>Game</code> type. What’s more interesting here is what’s <em class="italic">not</em> here. That is, the absence of a foreign key property like <code>GameId</code> or a direct <code>Game</code> property to establish a relationship between the <code>Move</code> and <code>Game</code> types. While using the <code>Move</code> type so far, this relationship was not required. With EF Core, it’s also not required to add this relationship to the model. EF Core supports a feature <a id="_idIndexMarker117"/>named <strong class="bold">shadow properties</strong>. These properties are not part of the model but are stored within the database and can be accessed while using the EF Core context.</p>
			<p>Let’s summarize what needs to be done to map the <code>Game</code> and <code>Move</code> types with EF Core:</p>
			<ol>
				<li>For simple string properties, the size of the database string needs to be defined with SQL Server.</li>
				<li>The <code>FieldValues</code> property <a id="_idIndexMarker118"/>of type <code>IDictionary&lt;string, IEnumerable&lt;string&gt;&gt;</code> needs a <strong class="bold">value converter</strong>.</li>
				<li>The <code>Moves</code> property maps a collection to the <code>Move</code> type. With a relational database, <code>Move</code> objects should be stored in a separate <code>Moves</code> table. Because the <code>Move</code> type doesn’t <a id="_idIndexMarker119"/>define a primary key, <strong class="bold">shadow properties</strong> are needed.</li>
				<li>Using Azure Cosmos DB, the moves should be stored in the game JSON document.</li>
			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">EF Core supports mapping via conventions, annotations, and the fluent API. Conventions are provider-specific. For example, a .NET string mapping to <code>nvarchar(max)</code> is a convention. Using nullability, a non-nullable property maps to a required database column, while a nullable property is not required. Conventions are overridden using annotations. Annotations are attributes such as <code>[StringLength(20)]</code>,which not only can be used to validate user input but also to specify the column to be <code>nvarchar(20)</code>. Using the fluent API, annotations can be overridden. The fluent API offers most options and overrides all the other settings. We’ll use the fluent API in the next sections.</p>
			<p>Let’s define a mapping to work with these models, both with a relational database and NoSQL.</p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor067"/>Using EF Core with SQL Server</h1>
			<p>Let’s start with a relational<a id="_idIndexMarker120"/> database to store games and <a id="_idIndexMarker121"/>moves in multiple tables. We<a id="_idIndexMarker122"/> need to do the following:</p>
			<ol>
				<li>Create a class library project</li>
				<li>Create the EF Core context</li>
				<li>Customize the mapping of simple properties</li>
				<li>Create value conversions to map complex properties</li>
				<li>Define relations between games and moves</li>
				<li>Create shadow properties for the <code>Move</code> type</li>
				<li>Implement the<a id="_idIndexMarker123"/> repository contract</li>
				<li>Configure the application model with SQL Server</li>
				<li>Configure the <a id="_idIndexMarker124"/>DI container <a id="_idIndexMarker125"/>with the minimal APIs project</li>
			</ol>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor068"/>Creating a data class library using SQL Server</h2>
			<p>To create the class library project, you<a id="_idIndexMarker126"/> can use the .NET CLI as <a id="_idIndexMarker127"/>shown or use the class library project template from Visual Studio:</p>
			<pre class="console">
dotnet new classlib --framework net8.0 -o Codebreaker.Data.SqlServer</pre>
			<p>To access SQL Server with EF Core, add the <code>Microsoft.EntityFrameworkCore.SqlServer</code> NuGet package. This project also has a dependency on the <code>Codebreaker.GameAPIs.Models</code> project.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor069"/>Creating an EF Core context for SQL Server</h2>
			<p>The mapping to the database is <a id="_idIndexMarker128"/>specified with an EF Core context<a id="_idIndexMarker129"/> implemented with the <code>GamesSqlServerContext</code> class, as shown in the following code snippet:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Data.SqlServer/GamesSqlServerContext.cs</p>
			<pre class="source-code">
public class GamesSqlServerContext(DbContextOptions&lt;GamesSqlServerContext&gt; options) : <strong class="bold">DbContext</strong>(options), IGamesRepository
{
  protected override void OnModelCreating(ModelBuilder modelBuilder)
  {
<strong class="bold">    modelBuilder.HasDefaultSchema("codebreaker");</strong>
<strong class="bold">    modelBuilder.ApplyConfiguration(new GameConfiguration());</strong>
<strong class="bold">    modelBuilder.ApplyConfiguration(new MoveConfiguration());</strong>
    // code removed for brevity
  }
<strong class="bold">  public DbSet&lt;Game&gt; Games =&gt; Set&lt;Game&gt;();</strong>
<strong class="bold">  public DbSet&lt;Move&gt; Moves =&gt; Set&lt;Move&gt;();</strong>
  // code removed for brevity
}</pre>
			<p>An EF Core context class needs to derive from the <code>DbContext</code> base class. Using the context from a DI container, the <a id="_idIndexMarker130"/>connection string can be configured outside of the context. This requires using the constructor with the <code>DbContextOption</code> parameter, which needs to be forwarded to the base<a id="_idIndexMarker131"/> class.</p>
			<p>The <code>GamesSqlServerContext</code> class implements the <code>IGamesRepository</code> interface, which we defined in <a href="B21217_02.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a>, to be used by the <code>GamesService</code> class. In <a href="B21217_02.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a>, we implemented this interface with the <code>GamesMemoryRepository</code> in-memory repository class. The EF Core context class supports the repository pattern by implementing the same interface. This way, we can easily switch the in-memory repository by using <code>GamesSqlServerContext</code> instead.</p>
			<p>The overridden <code>OnModelCreating</code> method allows customization to map the model types to the database. With SQL Server, the default schema name is <code>dbo</code>. This is changed by invoking <code>modelBuilder.HasDefaultSchema</code>.</p>
			<p>To reduce the complexity of the <code>OnModelCreating</code> method, <code>GameConfiguration</code> and <code>MoveConfiguration</code> classes are created to customize the mapping with the <code>Game</code> and <code>Move</code> types.</p>
			<p>One more thing that’s required with<a id="_idIndexMarker132"/> the context class<a id="_idIndexMarker133"/> is for properties of type <code>DbSet&lt;TEntity&gt;</code> to allow using properties to access mapped database tables.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Creating the <code>codebreaker</code> solution had several iterations. One time, an abstract base class and generically derived class were used to support all the different game types. Using EF Core, it’s also possible to map inheritance, and this is also possible with the JSON serialization and the OpenAPI<a id="_idIndexMarker134"/> definition. EF Core can map an inheritance tree to a single table (<strong class="bold">table-per-hierarchy</strong> or <strong class="bold">TpH</strong>), to a table for every type (<strong class="bold">table-per-type </strong>or <strong class="bold">TpT</strong>), and a table <a id="_idIndexMarker135"/>for every<a id="_idIndexMarker136"/> concrete type (<strong class="bold">table-per-concrete-type</strong> or <strong class="bold">TpC</strong>).</p>
			<p class="callout">Instead of creating a complex class hierarchy for the model types to plan for future features that might be never needed, it often helps to have model types as simple as possible, depending on what’s required with the current version. A complex model design adds complexity in multiple places.</p>
			<p class="callout">The <code>Game</code> class as it is defined now fulfills requirements for a group of different <code>Game</code> types as data holders. Functionality is abstracted away and done from the <code>analyzers </code>library, which just uses a contract to access the game.</p>
			<p class="callout">As microservices are used in a<a id="_idIndexMarker137"/> smaller scope, the <strong class="bold">KISS</strong> principle (<strong class="bold">Keep It Simple, Stupid</strong>) can help not only reduce work that needs to be done but also increase performance.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/>Customizing the mapping of simple properties</h2>
			<p>The mapping of the <code>Game</code> class is specified with the <code>GameConfiguration</code> class. A configuration class that is applied <a id="_idIndexMarker138"/>using <code>ApplyConfiguration</code> with the context configuration needs to implement the <code>IEntityTypeConfiguration</code> generic interface:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Data.SqlServer/Configuration/GameConfiguration.cs</p>
			<pre class="source-code">
internal class GameConfiguration : IEntityTypeConfiguration&lt;Game&gt;
{
  public void Configure(EntityTypeBuilder&lt;Game&gt; builder)
  {
    builder.HasKey(g =&gt; g.Id);
    builder.Property(g =&gt; g.GameType).HasMaxLength(20);
    builder.Property(g =&gt; g.PlayerName).HasMaxLength(60);
    builder.Property(g =&gt; g.Codes).HasMaxLength(120);
    // code removed for brevity</pre>
			<p>With the implementation of this class, the key of the table is specified to map to the <code>Id</code> property. This would not be required, as convention defines that a property with the name <code>Id</code> or an ID prefixed with the class name maps to the primary key.</p>
			<p>The fluent API <code>HasMaxLength</code> property is used to change the database types for the <code>GameType</code> and <code>PlayerName</code> properties. The <code>Codes</code> property is not such a simple property but can still be limited to a size of 120 characters.</p>
			<p>This configuration for the <code>Games</code> table is applied by invoking <code>ApplyConfiguration</code> from the context configuration.</p>
			<p>The <code>MoveConfiguration</code> class specifies a similar configuration for the <code>GuessPegs</code> and <code>KeyPegs</code> properties:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Data.SqlServer/Configuration/MoveConfiguration.cs</p>
			<pre class="source-code">
internal class MoveConfiguration : IentityTypeConfiguration&lt;Move&gt;
{
  public void Configure(EntityTypeBuilder&lt;Move&gt; builder)
  {
    // code removed for brevity
    builder.Property(g =&gt; g.GuessPegs).HasMaxLength(120);
    builder.Property(g =&gt; g.KeyPegs).HasMaxLength(60);
  }
}</pre>
			<p>For the <code>Move</code> type, shadow properties <a id="_idIndexMarker139"/>will be specified later in the <em class="italic">Defining relations between games and </em><em class="italic">moves</em> section.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/>Creating value conversion to map complex properties</h2>
			<p>To allow mapping of types not directly supported by EF Core, value conversion can be used. The <code>FieldValues</code> property of type <code>IDictionary&lt;string, IEnumerable&lt;string&gt;&gt;</code> is not directly supported with the default mapping. With the game, the content of this value is <a id="_idIndexMarker140"/>not really that huge and also doesn’t need to be searched within. This allows us to map this to a <code>nvarchar</code>-type column.</p>
			<p>Different options are available for the implementation. We will use a different one with SQL Server and with Azure Cosmos DB, but both options could be used with any of these providers.</p>
			<p>Let’s look at an example of what the data looks like. Let’s imagine we have a dictionary such as the following with colors and shapes:</p>
			<pre class="source-code">
Dictionary&lt;string, IEnumerable&lt;string&gt;&gt; input = new ()
{
  { "colors", ["Red", "Green", "Blue"] },
  { "shapes", ["Rectangle", "Circle"] }
};</pre>
			<p>This should result in this string:</p>
			<pre class="source-code">
var expected = "colors:Red#colors:Green#colors:Blue#shapes:Rectangle#shapes:Circle";</pre>
			<p>Every value is prefixed with the key of the value. With the source repository, you’ll find a unit test to check for the<a id="_idIndexMarker141"/> implementation of this conversion.</p>
			<p>To convert this dictionary to a string, the <code>ToFieldsString</code> extension method is implemented:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Data.SqlServer/MappingExtensions.cs</p>
			<pre class="source-code">
public static class MappingExtensions
{
  public static string ToFieldsString(this IDictionary&lt;string, 
<strong class="bold">    </strong>IEnumerable&lt;string&gt;&gt; fields)
  {
    return string.Join('#',
      fields.SelectMany(
        key =&gt; key.Value
          .Select(value =&gt; $"{key.Key}:{value}")));
  }
  // code removed for brevity
}</pre>
			<p>With the implementation, using the LINQ <code>SelectMany</code> method, for every key in the dictionary, a value is created that’s prefixed by the key.</p>
			<p>The reverse functionality converts<a id="_idIndexMarker142"/> the string to a dictionary with the <code>FromFieldsString</code> method:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Data.SqlServer/MappingExtensions.cs</p>
			<pre class="source-code">
public static IDictionary&lt;string, IEnumerable&lt;string&gt;&gt; 
<strong class="bold">  </strong>FromFieldsString(this string fieldsString)
{
  Dictionary&lt;string, List&lt;string&gt;&gt; fields = new();
  foreach (var pair in fieldsString.Split('#'))
  {
    var index = pair.IndexOf(':');
    if (index &lt; 0)
    {
      throw new ArgumentException($"Field {pair} does not contain ':' 
      delimiter.");
    }
    var key = pair[..index];
    var value = pair[(index + 1)..];
    if (!fields.TryGetValue(key, out List&lt;string&gt;? List))
    {
      list = [];
      fields[key] = list;
    }
    list.Add(value);
  }
  return fields.ToDictionary(
    pair =&gt; pair.Key,
    pair =&gt; (IEnumerable&lt;string&gt;)pair.Value);
}</pre>
			<p>With the implementation, the complete string is first split using the <code>#</code> separator. Each resulting string contains a key <a id="_idIndexMarker143"/>and value separated with <code>:</code>. These results are added to a pair, to finally return a dictionary.</p>
			<p>These methods are now used with the configuration of the <code>Game</code> class:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Data.SqlServer/Configuration/GameConfiguration.cs</p>
			<pre class="source-code">
public void Configure(EntityTypeBuilder&lt;Game&gt; builder)
{
  // code removed for brevity
  builder.Property(g =&gt; g.FieldValues)
    .HasColumnName("Fields")
    .HasColumnType("nvarchar")
    .HasMaxLength(200)
<strong class="bold">    .HasConversion(</strong>
<strong class="bold">      convertToProviderExpression: fields =&gt; fields.ToFieldsString(),</strong>
<strong class="bold">      convertFromProviderExpression: fields =&gt; fields.</strong>
        <strong class="bold">FromFieldsString(),</strong>
<strong class="bold">      valueComparer: new ValueComparer&lt;IDictionary&lt;string, </strong>
        <strong class="bold">Ienumerable&lt;string&gt;&gt;&gt;(</strong>
<strong class="bold">        equalsExpression: (a, b) =&gt; a!.SequenceEqual(b!),</strong>
<strong class="bold">        hashCodeExpression: a =&gt; a.Aggregate(0, (result, next) =&gt; </strong>
          <strong class="bold">HashCode.Combine(result, next.GetHashCode())),</strong>
<strong class="bold">        snapshotExpression: a =&gt; a.ToDictionary(kv =&gt; kv.Key, kv =&gt; </strong>
<strong class="bold">        kv.Value)));</strong>
}</pre>
			<p>The column name and data<a id="_idIndexMarker144"/> type are specified using the fluent API’s <code>HasColumnName</code>, <code>HasColumnType</code>, and <code>HasMaxLength</code> properties. The <code>HasConversion</code> method is used to convert a type to be mapped to the database representation. This method has several overloads for different use cases. Here, the first parameter references an expression to convert the .NET property type to the database type, while the second parameter does the reverse. Here, we invoke the previously created extension methods. With the third parameter, an instance of the <code>ValueComparer</code> class is invoked. This is used to compare the value for equality.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor072"/>Defining relations between games and moves</h2>
			<p>With the relational database, the <code>Games</code> table has a relation to the <code>Moves</code> table. One game maps to a list of moves. To <a id="_idIndexMarker145"/>make this possible, with the <code>Moves</code> table a foreign key named <code>GameId</code> is defined to reference the primary key of the <code>Games</code> table:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Data.SqlServer/Configuration/MoveConfiguration.cs</p>
			<pre class="source-code">
internal class MoveConfiguration : IEntityTypeConfiguration&lt;Move&gt;
{
  public void Configure(EntityTypeBuilder&lt;Move&gt; builder)
  {
<strong class="bold">    builder.Property&lt;Guid&gt;("GameId");</strong>
    builder.Property(g =&gt; g.GuessPegs).HasMaxLength(120);
    builder.Property(g =&gt; g.KeyPegs).HasMaxLength(60);
  }
}</pre>
			<p>Using <code>EntityTypeBuilder</code> for the <code>Move</code> type, invoking the <code>Property</code> method creates a <code>Move</code> type doesn’t have a property with this name. If there’s not a property<a id="_idIndexMarker146"/> with the same name, specifying the type is required as done here using the generic parameter.</p>
			<p>The following code snippet maps this relationship to database tables:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Data.SqlServer/GameConfiguration.cs</p>
			<pre class="source-code">
public void Configure(EntityTypeBuilder&lt;Game&gt; builder)
{
  builder.HasKey(g =&gt; g.Id);
<strong class="bold">  builder.HasMany(g =&gt; g.Moves)</strong>
<strong class="bold">    .WithOne()</strong>
<strong class="bold">    .HasForeignKey("GameId");</strong>
  // code removed for brevity
}</pre>
			<p>EF Core supports one-to-one, one-to-many, and many-to-many relationships. With games and moves, a one-to-many relationship is defined with the <code>HasMany</code> and <code>WithOne</code> methods. The <code>HasForeignKey</code> method specifies the <code>GameId</code> value of the <code>Move</code> class to reference the ID of the game records.</p>
			<p>After defining the mapping from the classes to the tables, let’s implement the contract of the repository and add migrations to create the database.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor073"/>Implementing the repository contract</h2>
			<p>In the previous chapter, we<a id="_idIndexMarker147"/> defined the <code>IGamesRepository</code> interface and implemented it with an in-memory representation. Now, let’s implement this interface to read and write to the SQL <a id="_idIndexMarker148"/>Server database.</p>
			<h3>Adding and deleting games</h3>
			<p>Let’s add the implementation<a id="_idIndexMarker149"/> of the <code>AddGameAsync</code> and <code>DeleteGameAsync</code> methods <a id="_idIndexMarker150"/>of the contract to the <code>GamesSqlServerContext</code> class:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Data.SqlServer/GameSqlServerContext.cs</p>
			<pre class="source-code">
public async Task AddGameAsync(Game game, CancellationToken cancellationToken = default)
{
<strong class="bold">  Games.Add(game);</strong>
<strong class="bold">  </strong><strong class="bold">await SaveChangesAsync(cancellationToken);</strong>
}
public async Task&lt;bool&gt; DeleteGameAsync(Guid id, CancellationToken 
<strong class="bold">  </strong>cancellationToken = default)
{
  var affected = await Games
    .Where(g =&gt; g.Id == id)
<strong class="bold">    .ExecuteDeleteAsync(cancellationToken);</strong>
    return affected == 1;
}</pre>
			<p>With the <code>AddGameAsync</code> method, the passed <code>Game</code> object is added to the <code>Games</code> property of the EF Core context, which marks the entity as <em class="italic">added</em> with the change tracker. The <code>SaveChangesAsync</code> method creates <code>INSERT</code> statements in the database.</p>
			<p>The <code>DeleteGameAsync</code> method receives the game ID with the parameter. Here, the <code>ExecuteDeleteAsync</code> method is invoked on the record matching the ID. <code>ExecuteDeleteAsync</code> and <code>ExecuteUpdateAsync</code> methods, available since EF Core 7, don’t use tracking and directly execute <code>DELETE</code> and <code>UPDATE</code> statements. This increases performance when <a id="_idIndexMarker151"/>change tracking is not necessary. When the record was not found to be deleted, this method <a id="_idIndexMarker152"/>returns <code>false</code>.</p>
			<p>Starting a 6x4 game creates this SQL statement to store the game:</p>
			<pre class="source-code">
INSERT INTO [codebreaker].[Games] ([Id], [Codes], [Duration], [EndTime], [Fields], [GameType], [LastMoveNumber], [MaxMoves], [NumberCodes], [PlayerName], [StartTime], [Won])
      VALUES (@p0, @p1, @p2, @p3, @p4, @p5, @p6, @p7, @p8, @p9, @p10, @p11);</pre>
			<p>Let’s set a move with the next implementation.</p>
			<h3>Updating a game</h3>
			<p>When a move is set, some game<a id="_idIndexMarker153"/> information such as the last move number is updated as well. The implementation to add a move and update the game is shown here:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Data.SqlServer/GameSqlServerContext.cs</p>
			<pre class="source-code">
public async Task AddMoveAsync(Game game, Move move, CancellationToken cancellationToken = default)
{
<strong class="bold">  Moves.Add(move);</strong>
<strong class="bold">  Games.Update(game);</strong>
<strong class="bold">  await SaveChangesAsync(cancellationToken);</strong>
}</pre>
			<p>The <code>Move</code> object is added to the context with the <code>Add</code> method, and the <code>Game</code> object is added with the <code>Update</code> method. This way, the change tracker is configured in that invoking the <code>SaveChangesAsync</code> method<a id="_idIndexMarker154"/> creates SQL <code>UPDATE</code> and <code>INSERT</code> statements.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">By default, one invocation of <code>SaveChangesAsync</code> creates one transaction. If updating the game fails, there’s a rollback for updating the move. In case you need multiple <code>SaveChangesAsync</code> instances within one transaction, the easiest option to use is ambient transactions (using the <code>TransactionScope</code> class from the <code>System.Transactions</code> namespace).</p>
			<h3>Querying games</h3>
			<p>To retrieve games, we need to<a id="_idIndexMarker155"/> implement <code>Getxx</code> methods. Let’s start with <code>GetGameAsync</code> to get the game by using the game ID:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Data.SqlServer/GamesSqlServerContext.cs</p>
			<pre class="source-code">
public async Task&lt;Game?&gt; GetGameAsync(Guid id, CancellationToken cancellationToken = default)
{
<strong class="bold">  var game = await Games</strong>
<strong class="bold">    .Include("Moves")</strong>
<strong class="bold">    .TagWith(nameof(GetGameAsync))</strong>
<strong class="bold">    .SingleOrDefaultAsync(g =&gt; g.Id == id, cancellationToken);</strong>
  return game;
}</pre>
			<p>The <code>GetGameAsync</code> method uses the <code>SingleOrDefaultAsync</code> method to get either one or zero records. If the game ID is not found, <code>null</code> is returned. Behind the scenes, a query using <code>SELECT TOP(2)</code> is created to check if more than one record would be returned from this query. If this is the case, the <code>SingleOrDefaultAsync</code> method throws an exception.</p>
			<p>The <code>Include</code> method is <a id="_idIndexMarker156"/>used to create a query that includes moves that relate to the returned query. Here, the SQL <code>LEFT JOIN</code> statement is used to join multiple tables. EF Core writes all the queries and updates to the log output. To better see which output maps to which LINQ methods, the <code>TagWith</code> method can be used. This tag is shown as a title with the log output.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>TagWith</code> method is of great help with debugging and troubleshooting. Checking the log outputs to see SQL queries sent, the tag gives a fast way to see where this query was generated.</p>
			<p>The following snippet shows the log output from this query, including the title:</p>
			<pre class="source-code">
-- GetGameAsync
SELECT [t].[ Id], [t].[Codes], [t].[Duration], [t].[EndTime], [t].[Fields], [t].[GameType], [t].[LastMoveNumber], [t].[MaxMoves], [t].[NumberCodes], [t].[PlayerName], [t].[StartTime], [t].[Won], [m].[Id], [m].[GameId], [m].[GuessPegs], [m].[KeyPegs], [m].[MoveNumber]
FROM (
  SELECT TOP(2) [g].[Id], [g].[Codes], [g].[Duration], [g].[EndTime], [g].[Fields], [g].[GameType], [g].[LastMoveNumber], [g].[MaxMoves], [g].[NumberCodes], [g].[PlayerName], [g].[StartTime], [g].[Won]
  FROM [codebreaker].[Games] AS [g]
  WHERE [g].[Id] = @__Id_0
) AS [t]
LEFT JOIN [codebreaker].[Moves] AS [m] ON [t].[Id] = [m].[GameId]
ORDER BY [t].[Id]</pre>
			<p>To query by date, player name, or some <a id="_idIndexMarker157"/>other query option, pass the <code>GamesQuery</code> object to the <code>GetGamesAsync</code> method:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Data.SqlServer/GamesSqlServerContext.cs</p>
			<pre class="source-code">
public async Task&lt;IEnumerable&lt;Game&gt;&gt; GetGamesAsync(GamesQuery? gamesQuery, CancellationToken cancellationToken = default)
{
<strong class="bold">  IQueryable&lt;Game&gt; query = Games</strong>
<strong class="bold">    .TagWith(nameof(GetGamesAsync))</strong>
<strong class="bold">    .Include(g =&gt; g.Moves);</strong>
  if (gamesQuery.Date.HasValue)
  {
<strong class="bold">    DateTime begin = gamesQuery.Date.Value.ToDateTime(TimeOnly.</strong>
<strong class="bold">        MinValue);</strong>
<strong class="bold">    DateTime end = begin.AddDays(1);</strong>
<strong class="bold">    query = query.Where(g =&gt; g.StartTime &lt; end &amp;&amp; g.StartTime &gt; </strong>
<strong class="bold">      begin);</strong>
  }
  if (gamesQuery.PlayerName != null)
<strong class="bold">    query = query.Where(g =&gt; g.PlayerName == gamesQuery.PlayerName);</strong>
  if (gamesQuery.GameType != null)
<strong class="bold">    query = query.Where(g =&gt; g.GameType == gamesQuery.GameType);</strong>
  if (gamesQuery.Ended)
  {
<strong class="bold">    query = query.Where(g =&gt; g.EndTime != null)</strong>
<strong class="bold">      .OrderBy(g =&gt; g.Duration);</strong>
  }
  else
  {
<strong class="bold">    query = query.OrderByDescending(g =&gt; g.StartTime);</strong>
  }
<strong class="bold">  query = query.Take(MaxGamesReturned);</strong>
  return await query.ToListAsync(cancellationToken);
}</pre>
			<p>The implementation of this method uses the <code>IQueryable</code> variable to add different LINQ query methods. Depending on the values passed with the <code>GamesQuery</code> parameter, multiple <code>Where</code> methods <a id="_idIndexMarker158"/>are added, in addition to <code>OrderBy</code> or <code>OrderByDescending</code>, to define the order of the result. To not return all the games played, only the first 500 games based on the filter are returned.</p>
			<p>Calling this method passing the player’s name and a date results in this SQL query:</p>
			<pre class="source-code">
SELECT [t].[Id], [t].[Codes], [t].[Duration], [t].[EndTime], [t].[Fields], [t].[GameType], [t].[IsVictory], [t].[LastMoveNumber], [t].[MaxMoves], [t].[NumberCodes], [t].[PlayerIsAuthenticated], [t].[PlayerName], [t].[StartTime], [m].[Id], [m].[GameId], [m].[GuessPegs], [m].[KeyPegs], [m].[MoveNumber]
FROM (
  SELECT TOP(@__p_3) [g].[Id], [g].[Codes], [g].[Duration], [g].[EndTime], [g].[Fields], [g].[GameType], [g].[IsVictory], [g].[LastMoveNumber], [g].[MaxMoves], [g].[NumberCodes], [g].[PlayerIsAuthenticated], [g].[PlayerName], [g].[StartTime]
  FROM [codebreaker].[Games] AS [g]
  WHERE [g].[StartTime] &lt; @__end_0 AND [g].[StartTime] &gt; @__begin_1 AND [g].[GameType] = @__gamesQuery_GameType_2
  ORDER BY [g].[StartTime] DESC
) AS [t]
LEFT JOIN [codebreaker].[Moves] AS [m] ON [t].[Id] = [m].[GameId]
ORDER BY [t].[StartTime] DESC, [t].[Id]</pre>
			<p>The <code>Include</code> method results in a <code>LEFT JOIN</code> operation<a id="_idIndexMarker159"/> to access the <code>Moves</code> table. Because of the <code>Take</code> method, <code>SELECT TOP</code> is used. Multiple invocations of the LINQ <code>Where</code> method results in a <code>WHERE</code> clause.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor074"/>Configuring user secrets</h2>
			<p>To access the database, we need to retrieve some configuration values. Some of these configuration values are secrets that shouldn’t be part of the source code repository. During development time, you<a id="_idIndexMarker160"/> can use user secrets. User secrets are stored with the user profile.</p>
			<p>To initialize user secrets, use this .NET CLI command:</p>
			<pre class="console">
cd Codebreaker.AppHost
dotnet user-secrets init</pre>
			<p>This creates a <code>UserSecretsId</code> property in the project file. Because all user secrets are stored with the user profile, this string is used to differentiate the configurations with multiple applications.</p>
			<p>To set a configuration value with the secrets, use the <code>dotnet user-secrets </code><code>set</code> command:</p>
			<pre class="console">
dotnet user-secrets set Parameters:sql-password [enter the password]</pre>
			<p>With the SQL Server Docker container we use, there are some requirements for the password. Be aware that you can’t use simple passwords. Three of four sets need to match: uppercase letters, lowercase letters, base 10 digits, and symbols. You can check the log output to see if there’s an issue with the password.</p>
			<p>You can also use Visual Studio and a context menu with Visual Studio to configure user secrets.</p>
			<p>Be aware that the provider to read configuration values from user secrets by default is only used if the secret ID is configured <a id="_idIndexMarker161"/>and the application is running in the <code>Development</code> environment.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">User secrets cannot be used in production. The idea of user secrets is to not store secrets with a configuration file that’s pushed to a source code repository. Every developer working on this project needs to configure the configuration values for secrets. In production, you can use other services such as Azure Key Vault. This is covered in <a href="B21217_07.xhtml#_idTextAnchor162"><em class="italic">Chapter 7</em></a>.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>Configuring the application model with SQL Server</h2>
			<p>To run SQL Server, .NET Aspire <a id="_idIndexMarker162"/>makes it easy to<a id="_idIndexMarker163"/> run a Docker container. Just add this code to the application model in the <code>Codebreaker.AppHost</code> project:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
var builder = DistributedApplication.CreateBuilder(args);
<strong class="bold">var sqlServer = builder.AddSqlServer("sql", sqlPassword)</strong>
<strong class="bold">  .AddDatabase("CodebreakerSql", "codebreaker");</strong></pre>
			<p>The <code>AddSqlServer</code> method adds a SQL Server resource. Using this method, during development time, a Docker container is used. In <a href="B21217_05.xhtml#_idTextAnchor110"><em class="italic">Chapter 5</em></a>, we’ll get into the details of Docker and add more configuration with this SQL Server Docker container. The name of this resource is sql. Optionally, a password can be passed to the <code>AddSqlServer</code> method. If a configuration parameter value is set with the resource name postfixed with -<code>password</code> (as we did), this <code>password</code> is used. Otherwise a random <code>password</code> is generated.. The <code>AddDatabase</code> method adds a database to the resource with the first parameter, the name of the resource that is used as a name for the connection string name, and the database name.</p>
			<p>To allow us to dynamically decide between different game repositories, we use the <code>DataStore</code> configuration to <a id="_idIndexMarker164"/>decide between in-memory, SQL Server, and Azure Cosmos DB on the startup of the application:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/appsettings.json</p>
			<pre class="source-code">
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Aspire.Hosting.Dcp": "Warning"
    }
  },
<strong class="bold">  "DataStore": "SqlServer"</strong>
}</pre>
			<p>Depending on the database provider you want to use, change the value as needed.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><a href="B21217_07.xhtml#_idTextAnchor162"><em class="italic">Chapter 7</em></a>, <em class="italic">Flexible Configuration</em>, goes into the details of the <code>appsettings.json</code> file and environment-specific counterparts, as well as other options to store configuration values such as environmental variables, program arguments, and Azure App Configuration instances. In this chapter, all we need is to configure settings within <code>appsettings.json</code> as well as user secrets, which are covered with Azure Cosmos DB.</p>
			<p>The configuration value is <a id="_idIndexMarker165"/>retrieved with the startup of the <code>AppHost</code> project:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
<strong class="bold">string dataStore = builder.Configuration["DataStore"] ??</strong>
<strong class="bold">  "InMemory";</strong></pre>
			<p>In case the value is not <a id="_idIndexMarker166"/>configured, it defaults to the in-memory provider we created in the previous chapter.</p>
			<p>Now, we can change dependencies for the game APIs:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
builder.AddProject&lt;Projects.Codebreaker_GameAPIs&gt;("gameapis")
<strong class="bold">  .WithEnvironment("DataStore", dataStore)</strong>
<strong class="bold">  .WithReference(sqlServer);</strong>
// code removed for brevity</pre>
			<p>The <code>WithEnvironment</code> method creates an environment variable for the game APIs project with the <code>DataStore</code> key and the value that’s retrieved from the configuration. The <code>WithReference</code> method references the SQL Server resource and creates an environment variable for the connection string.</p>
			<p>Next, let’s configure the minimal <a id="_idIndexMarker167"/>APIs project to retrieve the configuration values from the <code>AppHost</code> project.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor076"/>Configuring the DI container with the minimal APIs project</h2>
			<p>After the mapping of the model to <a id="_idIndexMarker168"/>the database is completed and the resource dependencies are defined with the Aspire <code>AppHost</code> project, the DI container can be configured to use the EF Core context.</p>
			<p>The games API project needs a reference to the <code>Codebreaker.Data.SqlServer</code> project and the <code>Aspire.Microsoft.EntityFrameworkCore.SqlServer</code> NuGet package.</p>
			<p>The configuration for the <code>DataStore</code> is retrieved <a id="_idIndexMarker169"/>with the following code snippet:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/ApplicationServices.cs</p>
			<pre class="source-code">
public static void AddApplicationServices(this IHostApplicationBuilder builder)
{
  // code removed for brevity
<strong class="bold">  string? dataStore = builder.Configuration.</strong>
<strong class="bold">    GetValue&lt;string&gt;("DataStore");</strong>
  switch (dataStore)
  {
    case "SqlServer":
      ConfigureSqlServer(builder);
      break;
    default:
      ConfigureInMemory(builder);
      break;
  }
  builder.Services.AddScoped&lt;IGamesService, GamesService&gt;();
}</pre>
			<p>Depending on the retrieved configuration value for <code>DataStore</code>, we configure Azure Cosmos DB, SQL Server, or the in-memory repository that we implemented in the previous chapter.</p>
			<p>The configuration for SQL <a id="_idIndexMarker170"/>Server, which is called from the previous <code>switch/case</code> statement, is shown here:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/ApplicationServices.cs</p>
			<pre class="source-code">
static void ConfigureSqlServer(IHostApplicationBuilder builder)
{
  builder.<strong class="bold">AddDbContextObjectPool</strong>&lt;IGamesRepository, GamesSqlServerContext&gt;(options =&gt;
  {
<strong class="bold">    var connectionString = builder.Configuration.</strong>
<strong class="bold">    GetConnectionString("CodebreakerSql")</strong> ?? throw new 
<strong class="bold">    </strong>InvalidOperationException("Could not read SQL Server connection 
<strong class="bold">    </strong>string");
<strong class="bold">    options.UseSqlServer(connectionString);</strong>
<strong class="bold">    options.UseQueryTrackingBehavior(</strong>
<strong class="bold">    QueryTrackingBehavior.NoTracking);</strong>
  }
  <strong class="bold">builder.EnrichSqlServerDbContext&lt;GamesSqlServerContext&gt;();</strong>
}</pre>
			<p>Using the .NET Aspire SqlServer EF Core component, we can invoke the  <code>AddSqlServerDbContext</code> API to configure the EF Core context with .NET Aspire. However, this API doesn’t provide the level of flexibility we need for working with different database providers. Thus, instead, we configure the EF Core context using EF Core APIs such as <code>AddDbContext</code> and <code>AddDbContextPool</code> and add Aspire functionality by using <code>EnrichSqlServerDbContext</code>. The <code>AddDbContextObjectPool</code> method configures to use the SQL Server EF Core provider, passing the connection string, which is passed via the <code>AppHost</code> project and thus needs to match the name configured with the top-level statements in the AppHost project.</p>
			<p>Invoking the <code>UseQueryTrackingBehavior</code> method adds one interesting aspect when using EF Core. By default, all queries are tracked within the EF Core context to allow the context to know about changes. Within the API service, the context is newly created with every new HTTP request. Thus, keeping this tracking state for every context is not required. Adding and updating entities are explicitly marked with the <code>Add</code> and <code>Update</code> methods. Setting the query tracking behavior to <code>QueryTrackingBehavior.NoTracking</code> disables tracking with all queries (unless overwritten with a query using the <code>AsTracking</code> method) and thus reduces the overhead.</p>
			<p>Instead of turning tracking <a id="_idIndexMarker171"/>off by default, you can also use the option to turn tracking off with a single query using the <code>AsNoTracking</code> method.</p>
			<p>The <code>EnrichSqlServerDbContext</code> method adds health checks, logging, and telemetry configuration offered by the Aspire component. Logging and telemetry configuration are covered in <a href="B21217_11.xhtml#_idTextAnchor263"><em class="italic">Chapter 11</em></a>, and health checks are covered in <a href="B21217_12.xhtml#_idTextAnchor294"><em class="italic">Chapter 12</em></a>.</p>
			<p>As the mappings and the repository contract are implemented, we can now continue to create the database using migrations.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor077"/>Creating migrations with EF Core</h1>
			<p>Using EF Core, you can create the database <a id="_idIndexMarker172"/>with the <code>Database.EnsureCreatedAsync</code> context API method. However, this does not take schema changes into account. Over time, the <a id="_idIndexMarker173"/>database schema will change as new features are added – and it’s best to do this automatically.</p>
			<p><a href="B21217_08.xhtml#_idTextAnchor183"><em class="italic">Chapter 8</em></a> describes how to automatically publish services to testing and production environments. With this, updating the database is important as well. When the database schema changes, updates <a id="_idIndexMarker174"/>should be published to the environments. EF Core offers <strong class="bold">migrations</strong> to record all schema changes and update the <a id="_idIndexMarker175"/>database schema programmatically.</p>
			<p>Next, let’s do the following:</p>
			<ol>
				<li>Add the .NET EF Core tool</li>
				<li>Add the EF Core tool and create initial migrations</li>
				<li>Update the model and add migrations</li>
				<li>Update the database programmatically</li>
			</ol>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor078"/>Adding the .NET EF Core tool</h2>
			<p>If you don’t have the EF Core .NET <a id="_idIndexMarker176"/>command-line tool installed yet, you can install it with the <code>dotnet</code> CLI as a global or a local tool. Here, we install it as a local tool to have a specific version of this tool as part of the <code>Codebreaker.Data.SqlServer</code> project.</p>
			<p>To install local tools, a <code>tool-manifest</code> file first needs to be created:</p>
			<pre class="console">
cd Codebreaker.Data.SqlServer
dotnet new tool-manifest</pre>
			<p>With the <code>tool-manifest</code> template, the <code>dotnet new</code> command creates a <code>.config</code> directory with a <code>dotnet-tools.json</code> file. This manifest file will contain all the tools that should be installed when working on the project.</p>
			<p>As soon as this manifest file is available, we can install the <code>dotnet-ef</code> tool:</p>
			<pre class="console">
dotnet tool install dotnet-ef</pre>
			<p>This command configures this tool with the tool manifest file and installs it locally. In case you’ve installed another version of this tool globally, while the current directory of your command prompt is within the project folder, you use the tool version that’s specified with the tool manifest file.</p>
			<p>To get all the tools installed <a id="_idIndexMarker177"/>and configured with a tool manifest file, you can use the <code>tool </code><code>restore</code> command:</p>
			<pre class="console">
dotnet tool restore</pre>
			<p>The <code>restore</code> command can be practically used when you clone a repository containing a tool manifest file. Using <code>dotnet tool restore</code>, all tools specified with the project are restored.</p>
			<p>Let’s use this tool to create an initial migration for the actual context:</p>
			<pre class="console">
dotnet ef migrations add InitGames -s ..\Codebreaker.GameAPIs</pre>
			<p><code>migrations</code> is a command of the <code>dotnet ef</code> tool. Using <code>add</code>, a new migration is added with the name that follows the <code>add</code> command (here, <code>InitGames</code>). The <code>-s</code> (or <code>--startup-project</code>) option specifies the project where the EF Core context is configured with the DI container, and the connection string to the database is specified. This is a different project than the project where the EF Core context is implemented (<code>Codebreaker.Data.Cosmos</code> and <code>Codebreaker.Data.SqlServer</code>); that’s why this option is needed.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In case creating the migration fails, check the error message. An error could be that you failed to specify a mapping, and here the errors are very detailed. While working around issues, you can temporarily ignore the properties of the model to see if the error is really based on a property mapping.</p>
			<p>After a successful run of this tool, you’ll see a <code>Migrations</code> folder with the project. This folder contains a snapshot of the current state of the database, including all the table mappings, the property mappings, and the relations. This class is named based on the EF Core context suffixed by <code>ModelSnapshot</code>; for example, <code>GameSqlServerContextModelSnapshot</code>.</p>
			<p>Every time you add a new migration, the snapshot will be updated and a new <code>Migration</code>-derived class created that includes all the schema changes based on the previous migration. The migration is named with the migration name prefixed with the time. The generated class contains an <code>Up</code> method that will be invoked when the migration is applied to the SQL Server database and a <code>Down</code> method that will be invoked when the migration is <a id="_idIndexMarker178"/>dropped from the database.</p>
			<p>Next, we’ll use the <code>dotnet ef</code> tool to apply the migration to the database and create the database if it doesn’t exist yet. This can be done using the <code>dotnet ef database </code><code>update</code> command:</p>
			<pre class="console">
dotnet ef database update -s ..\Codebreaker.GameAPIs.</pre>
			<p>This command now uses the connection string from the startup project to apply migrations to the database. Using migrations to create the database, you’ll see all the games and moves tables created – along with the <code>_EFMigrationsHistory</code> table. Reading the content of this table, you’ll see all the migration names applied to the database.  This information is checked when doing another update to the database schema using migrations.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There are some cases where creating the database fails while creating the migration succeeds. Mapping errors can be the reason here as well. Checking the error message again gives good details on the reason for the failure.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>Creating or updating the database programmatically</h2>
			<p>Instead of using the command line to apply<a id="_idIndexMarker179"/> a migration, migrations can be started programmatically invoking the EF Core context with <code>context.Database.MigrateAsync</code>. Let’s implement this functionality with the <code>CreateOrUpdateDatabaseAsync</code> method, which is called from the application startup code for easy use of the solution:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/ApplicationServices.cs</p>
			<pre class="source-code">
<strong class="bold">public static async Task CreateOrUpdateDatabaseAsync(this WebApplication app)</strong>
{
  var dataStore = app.Configuration["DataStore"] ?? "InMemory";
  if (dataStore == "SqlServer")
  {
    try
    {
      using var scope = app.Services.CreateScope();
      var repo = scope.ServiceProvider.GetRequiredService&lt;IGamesRepository&gt;();
      if (repo is GamesSqlServerContext context)
      {
<strong class="bold">        await context.Database.MigrateAsync();</strong>
        app.Logger.LogInformation("SQL Server database updated");
      }
    }
    catch (Exception ex)
    {
      app.Logger.LogError(ex, "Error updating database");
      throw;
    }
  }
}</pre>
			<p>With the implementation, we check if the solution is configured to use SQL Server. In that case, the <code>MigrateAsync</code> method is invoked to update the database to the newest version.</p>
			<p>With the <code>codebreaker</code> solution, this is really convenient – running the solution, everything is ready, including the database. From a security standpoint, in the production environment, the service <a id="_idIndexMarker180"/>running should not have a database connection string that is allowed to change the schema. Instead, a separate program can be used to update the database. This could be invoked from a GitHub action with automatic deployment. Using the <code>dotnet ef</code> tool, you can even create a standalone application to update the database schema: <code>dotnet ef migrations bundle</code> creates an application with the .NET runtime included, thus you can start this application from clients who don’t have the .NET runtime installed. You can also create a SQL script to start the migration if this is the preferred option by the database administrator: <code>dotnet ef </code><code>migrations script</code>.</p>
			<p>Next, let’s make a change to the model that influences the database schema.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/>Updating the database schema</h2>
			<p>In <a href="B21217_09.xhtml#_idTextAnchor216"><em class="italic">Chapter 9</em></a>, we’ll differentiate<a id="_idIndexMarker181"/> anonymous from authenticated users. With this, game information will be stored when the game is played by an authenticated user. For this, we’ll add a <code>PlayerIsAuthenticated</code> flag to the <code>Game</code> class:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Models/Game.cs</p>
			<pre class="source-code">
public class Game(
  Guid id,
  string gameType,
  string playerName,
  DateTime startTime,
  int numberCodes,
  int maxMoves) : IGame
{
  public Guid Id { get; private set; } = id;
  public string GameType { get; private set; } = gameType;
  public string PlayerName { get; private set; } = playerName;
  <strong class="bold">public bool PlayerIsAuthenticated { get; set; } = false;</strong>
  // code removed for brevity</pre>
			<p>This new property is not defined to <a id="_idIndexMarker182"/>be ignored from the database. To update the database schema, we add a new migration:</p>
			<pre class="console">
cd Codebreaker.Data.SqlServer
dotnet ef migrations add AddPlayerIsAuthenticated -s ..\Codebreaker.GameAPIs</pre>
			<p>The new migration is named <code>AddPlayerIsAuthenticated</code>. This change updates the snapshot in the <code>Migrations</code> folder and adds a new migration, as shown in this code snippet:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Data.SqlServer/Migrations/ 20231225095931_AddPlayerIsAuthenticated.cs</p>
			<pre class="source-code">
public partial class AddPlayerIsAuthenticated : Migration
{
<strong class="bold">  </strong><strong class="bold">protected override void Up(MigrationBuilder migrationBuilder)</strong>
  {
<strong class="bold">    migrationBuilder.AddColumn</strong>&lt;bool&gt;(
      name: "PlayerIsAuthenticated",
      schema: "codebreaker",
      table: "Games",
      type: "bit",
      nullable: false,
      defaultValue: false);
    }
<strong class="bold">  protected override void Down(MigrationBuilder migrationBuilder)</strong>
  {
    <strong class="bold">migrationBuilder.DropColumn</strong>(
      name: "PlayerIsAuthenticated",
      schema: "codebreaker",
      table: "Games");
  }
}</pre>
			<p>With the <code>Up</code> method, updating a database from the previous version, the column is added to the database schema (<code>AddColumn</code>), and the <code>Down</code> method removes the column (<code>DropColumn</code>).</p>
			<p>During development, you might often <a id="_idIndexMarker183"/>update the schema and create many migrations. Before publishing a new version of the application, it’s a good idea to combine migrations into one. Just pay attention to the version installed in production or staging environments. You should keep the migrations already deployed. Migrations that have been used only in your development environment can be removed with <code>dotnet ef migrations remove</code> (possibly called multiple times to always remove the last migration) – and finally, one invocation of <code>dotnet ef migrations add &lt;Name of the migration&gt;</code>, which then creates one migration with all schema changes since the last migration.</p>
			<p>Now, let’s run the solution using SQL Server.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/>Running the application with SQL Server</h2>
			<p>Starting the host application <a id="_idIndexMarker184"/>now, not only <a id="_idIndexMarker185"/>the game APIs service is running, but also SQL Server in a Docker container, as shown in <em class="italic">Figure 3</em><em class="italic">.2</em>:</p>
			<div><div><img src="img/B21217_03_02.jpg" alt="Figure 3.2 – .NET Aspire resources with SQL Server"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – .NET Aspire resources with SQL Server</p>
			<p>You can access the OpenAPI endpoint description to start games. Make sure to check into the details of the games API service. Details give information about the resource, the endpoints, and the environment variables, as shown in <em class="italic">Figure 3</em><em class="italic">.3</em>:</p>
			<div><div><img src="img/B21217_03_03.jpg" alt="Figure 3.3 – Environment variables"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Environment variables</p>
			<p>With the environment variables set for this service, check <code>DataStore</code> and  <code>ConnectionStrings__CodebreakerSql</code>, which are set by the <code>AppHost</code> project.</p>
			<p>Try to play a game using the HTTP files. Verify how records are added to the SQL Server database. However, when you stop the project and run the application again, the database is created from a<a id="_idIndexMarker186"/> fresh state. With<a id="_idIndexMarker187"/> Docker, we need volumes to map storage outside of the Docker container. This is covered in <a href="B21217_05.xhtml#_idTextAnchor110"><em class="italic">Chapter 5</em></a>.</p>
			<p>After this, let’s move over to Azure Cosmos DB.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor082"/>Using EF Core with Azure Cosmos DB</h1>
			<p>With Azure Cosmos DB, Microsoft offers<a id="_idIndexMarker188"/> different databases with several APIs that make use of the same infrastructure. Most of these database offerings are NoSQL databases for different purposes. Azure Cosmos DB offers a JSON document store that<a id="_idIndexMarker189"/> can be accessed with the Mongo DB API. The Apache Cassandra API offers a wide column store where each row can have different columns. The Apache Gremlin query language can be used to access a graph version of the database. This is great to query for relations using vertices and edges. Azure Cosmos DB for PostgreSQL is a distributed high-performance relational database using the same infrastructure to read and write from a database network worldwide.</p>
			<p>For the <code>codebreaker</code> solution, we’ll use Azure Cosmos DB for NoSQL. Here, an EF Core provider is available. This allows us to use the same API as with SQL Server, but the mapping will be different.</p>
			<p>Writing the games and moves to Azure Cosmos DB, we need to do the following:</p>
			<ol>
				<li>Create a class library project</li>
				<li>Create the EF Core context</li>
				<li>Create a value converter to map complex types</li>
				<li>Create embedded entities</li>
				<li>Implement the repository contract</li>
				<li>Configure the application model</li>
				<li>Configure the DI container</li>
			</ol>
			<p>We created a SQL Server database when applying the migrations first. With Azure Cosmos DB, migrations are not available and are not needed. As JSON documents are stored, we are very flexible in the data to write. There<a id="_idIndexMarker190"/> is no concept of tables and relations between tables – we just store JSON documents within a container. One container can keep data of <a id="_idIndexMarker191"/>different kinds. A container can be used as a scaling unit, but you can also decide to specify the <a id="_idIndexMarker192"/>scaling with the complete database and share <strong class="bold">request units</strong> (<strong class="bold">RU/s</strong>) with different containers in a database.</p>
			<p>With containers, you also need to know about partitions. Partitions are used to scale containers for performance. Before specifying partitions, you need to know about some attributes of Azure Cosmos DB:</p>
			<ul>
				<li>A partition is limited to 20 GB storage. The size limit of a container is 1 TB.</li>
				<li>Writing to the database, a transaction can only span writing to a single partition. If different data should be written within a transaction, this data should use the same partition key.</li>
				<li>10,000 RU/s is the maximum limit for a partition. With a container, the limit is 1,000,000 RU/s (with serverless, the container RU/s limit is 20,000). For the best-performance parallel reading of data, different partition keys should be used.</li>
				<li>The maximum length of a partition key is 2048 bytes.</li>
				<li>The maximum size of one item to store is 2 MB.</li>
				<li>There’s no limit on the distinct values of partition keys.</li>
			</ul>
			<p>We will use the game ID for the partition key. Games are created and updated independently of other games. It’s not necessary to write multiple games within one transaction. Running Azure Cosmos DB with a multi-region write configuration allows us to create games from different Azure regions with high performance. This makes the <code>Id</code> value of the game a good candidate for the partition key.</p>
			<p>With this information, we’ll create a class library next.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor083"/>Creating a class library project for EF Core with NoSQL</h2>
			<p>Similar to creating a library for SQL <a id="_idIndexMarker193"/>Server, we use a library to access Azure Cosmos DB:</p>
			<pre class="console">
dotnet new classlib --framework net8.0 -o Codebreaker.Data.Cosmos</pre>
			<p>This library makes use of the <code>Microsoft.EntityFrameworkCore.Cosmos</code> NuGet package – and of course, a reference to the <code>Codebreaker.GameAPIs.Models</code> project is needed.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor084"/>Creating an EF Core context for Azure Cosmos DB</h2>
			<p>Let’s create a context class to access<a id="_idIndexMarker194"/> Azure Cosmos DB, as shown with<a id="_idIndexMarker195"/> the following code snippet:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Data.Cosmos/GamesCosmosContext.cs</p>
			<pre class="source-code">
public class GamesCosmosContext(DbContextOptions&lt;GamesCosmosContext&gt; optoins) : DbContext(options), IGamesRepository
{
  private const string PartitionKey = nameof(PartitionKey);
  private const string ContainerName = "GamesV3";
  private const string DiscriminatorValue = "GameV3";
  protected override void OnModelCreating(ModelBuilder modelBuilder)
  {
<strong class="bold">    modelBuilder.HasDefaultContainer(ContainerName);</strong>
<strong class="bold">    var gameModel = modelBuilder.Entity&lt;Game&gt;();</strong>
<strong class="bold">    gameModel.Property&lt;string&gt;(PartitionKey);</strong>
<strong class="bold">    gameModel.HasPartitionKey(PartitionKey);</strong>
<strong class="bold">    gameModel.HasKey(nameof(Game.Id), PartitionKey);</strong>
<strong class="bold">    gameModel.HasDiscriminator&lt;string&gt;("Discriminator")</strong>
<strong class="bold">      .HasValue&lt;Game&gt;(DiscriminatorValue);</strong>
    // code removed for brevity
  }
<strong class="bold">  public DbSet&lt;Game&gt; Games =&gt; Set&lt;Game&gt;();</strong>
<strong class="bold">  public static string ComputePartitionKey(Game game) =&gt; </strong>
<strong class="bold">    game.GameId.ToString();</strong>
<strong class="bold">  public void SetPartitionKey(Game game) =&gt;</strong>
<strong class="bold">    Entry(game).Property(PartitionKey).CurrentValue =</strong>
<strong class="bold">      ComputePartitionKey(game);</strong>
  // code removed for brevity</pre>
			<p>Similar to before, the custom context class derives from the <code>DbContext</code> base class and defines a constructor with context options, which allows us to configure the DI container with the connection string. The differences start now. With SQL Server, we defined the default schema name. This is not<a id="_idIndexMarker196"/> available with Azure Cosmos DB, but we can define the default container <a id="_idIndexMarker197"/>name using the <code>HasDefaultContainer</code> method. In case you have entities that should not be stored with the default container, these can be configured to use a different container with the help of the <code>ToContainer</code> method. The previously discussed partition key is configured by invoking the  <code>HasPartitionKey</code> method. Using the <code>SetPartitionKey</code> and <code>ComputePartitionKey</code> methods, the partition key is configured as a <strong class="bold">shadow property</strong> with the same value as the game ID.</p>
			<p>While <code>Id</code> is a good option for the partition key, other types that could be stored in the same container might not have an <code>Id</code> value. Thus, for the partition key, <code>PartitionKey</code> is used. With games, the <code>Id</code> value will be mapped to <code>PartitionKey</code>.</p>
			<p>Writing different object types to a <a id="_idIndexMarker198"/>single container requires the use of a discriminator value. By default, the discriminator value is the name of the class. By <a id="_idIndexMarker199"/>invoking the <code>HasDiscriminator</code> method, the default discriminator configuration is overridden by specifying the <code>Discriminator</code> shadow property. For <code>Game</code> types, the <code>GameV3</code> value is written. This allows us to differentiate game objects stored with incompatible new versions.</p>
			<p>Azure Cosmos DB stores JSON documents, thus only the <code>Game</code> type needs to be specified with a <code>DbSet</code> property, and not the <code>Move</code> type, as we did with SQL Server. Defining maximum sizes for string properties is not needed as well – there’s no schema describing this.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor085"/>Creating a value converter to convert complex types</h2>
			<p>In the SQL Server section, we converted the <code>Idictionary</code>-typed property, passing expressions to the <code>HasConversion</code> method to convert the dictionary to a string. The same could be done with Azure Cosmos DB, but <a id="_idIndexMarker200"/>now we’ll create a class deriving from <code>ValueConverter</code> and convert the dictionary to and from JSON, as shown in the following code snippet:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Data.Cosmos/Utilities/FieldValueValueConverter.cs</p>
			<pre class="source-code">
internal <strong class="bold">class FieldValueValueConverter : ValueConverter&lt;IDictionary&lt;string, IEnumerable&lt;string&gt;&gt;, string&gt;</strong>
{
  static string GetJson(IDictionary&lt;string, IEnumerable&lt;string&gt;&gt; 
<strong class="bold">    </strong>values) =&gt; return JsonSerializer.Serialize(values);
  static IDictionary&lt;string, IEnumerable&lt;string&gt;&gt; GetDictionary(string 
<strong class="bold">    </strong>json) =&gt; JsonSerializer.Deserialize&lt;IDictionary&lt;string, 
<strong class="bold">    </strong>IEnumerable&lt;string&gt;&gt;&gt;(json) ??
      new Dictionary&lt;string, IEnumerable&lt;string&gt;&gt;();
  public FieldValueValueConverter() : base(
    convertToProviderExpression: v =&gt; GetJson(v),
    convertFromProviderExpression: v =&gt; GetDictionary(v))
  { }
}</pre>
			<p>An EF Core value converter derives from the <code>ValueConverter</code> base class and specifies with the generic parameter what type to convert. With the <code>FieldValues</code> property, this is <code>IDictionary&lt;string, IEnumerable&lt;string&gt;&gt;</code>. The constructor of the base class<a id="_idIndexMarker201"/> requires parameters to convert to the database data type and to convert from the database data type. With the implementation, the <code>JsonSerializer</code> class from the <code>System.Text.Json</code> namespace is used to do the serialization and deserialization.</p>
			<p>An instance of this value converter is now passed to an overload of the <code>HasConversion</code> method with the <code>FieldValues</code> property configuration:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Data.Cosmos/GamesCosmosContext.cs</p>
			<pre class="source-code">
public class GamesCosmosContext(DbContextOptions&lt;GamesCosmosContext&gt; options) : DbContext(options), IGamesRepository
{
<strong class="bold">  private static FieldValueValueConverter s_fieldValueConverter = new();</strong>
<strong class="bold">  private static FieldValueComparer s_fieldValueComparer = new();</strong>
  protected override void OnModelCreating(ModelBuilder modelBuilder)
  {
    // code removed for brevity
<strong class="bold">    gameModel.Property(g =&gt; g.FieldValues)</strong>
<strong class="bold">      </strong><strong class="bold">.HasConversion(s_fieldValueConverter, s_fieldValueComparer);</strong>
  }</pre>
			<p>Similar to <code>FieldValueValueConverter</code>, a <code>FieldValueComparer</code> instance is created. Instances of these two types are created to pass to the <code>HasConversion</code> method.</p>
			<p>When creating the <a id="_idIndexMarker202"/>mapping for a relational database, much more was needed to configure. We reduced the code from the data context by creating configuration classes with every mapped table. This is not worthwhile doing here. The complete EF Core configuration, as well as the implementation of the repository interface, is done with the context class.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/>Creating embedded entities</h2>
			<p>What about the relationship between<a id="_idIndexMarker203"/> games and moves? EF Core defines the <code>OwnsOne </code>and <code>OwnsMany</code> methods to define an owned relationship. With a relational database, <code>OwnsOne</code> adds columns of the owned type to the owner type. With the Azure Cosmos DB provider, invoking <code>OwnsMany</code> from <code>gameModel</code> and referencing the <code>Moves</code> property, moves will be stored as JSON within the game.</p>
			<p>Since EF Core 7, this is the default behavior with related entity types with the Azure Cosmos DB provider. So, nothing needs to be configured to make this happen.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/>Implementing the repository contract</h2>
			<p>With the implementation of<a id="_idIndexMarker204"/> the repository, there are many similarities to the implementation with SQL Server, but because of the different storage, some changes are necessary. Here, we’ll concentrate on the differences:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Data.Cosmos/GamesCosmosContext.cs</p>
			<pre class="source-code">
public async Task AddGameAsync(Game game, CancellationToken cancellationToken = default)
{
<strong class="bold">  SetPartitionKey(game);</strong>
  Games.Add(game);
  await SaveChangesAsync(cancellationToken);
}</pre>
			<p>When adding or updating the game, the partition key needs to be set. Other than that, the code is the same as with SQL Server.</p>
			<p>There’s a difference in what happens at runtime. Instead of using SQL <code>INSERT</code> and <code>UPDATE</code> statements, the Azure Cosmos DB provider executes <code>CreateItem</code> and <code>ReplaceItem</code> functions. When you check the log output, you can see the number of RUs required for every statement done.</p>
			<p>The <code>GetGamesAsync</code> method defined previously also works with the Cosmos DB provider. This is the query created:</p>
			<pre class="source-code">
SELECT c
FROM root c
WHERE (((c["Discriminator"] = "Game") AND ((c["StartTime"] &lt; @__end_0) AND (c["StartTime"] &gt; @__begin_1))) AND (c["GameType"] = @__gamesQuery_GameType_2))
ORDER BY c["StartTime"] DESC
OFFSET 0 LIMIT @__p_3</pre>
			<p>Comparing this query to the query to the SQL Server database, with Cosmos DB, it’s a lot simpler: joining of tables is not required. An interesting part of this query is the filtering on <code>Discriminator</code>. By default, every object stored in a container has a <code>Discriminator</code> filter that includes the type name. This allows the storage of different documents in the container. Queries for a specific type include the <code>Discriminator</code> filter.</p>
			<p>In case you only store objects of the<a id="_idIndexMarker205"/> same type within one container, you can turn off storing with the <code>Discriminator</code> filter with the <code>HasNoDiscriminator</code> model definition method.</p>
			<p>Be aware that not all LINQ queries translate successfully from the Cosmos DB provider. For example, <code>Include</code> and <code>Join</code> methods are not translated. While the <code>Include</code> method was used with SQL Server to include the moves with a query for a game, with a JSON document where the moves are stored within a game, this is not required. As there are no tables with NoSQL, <code>Join</code> is usually not required as well. In case you want to combine a list of different object types, create two queries and combine the results with the caller.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor088"/>Configuring the application model with Azure Cosmos DB</h2>
			<p>With SQL Server, we’ve been using a<a id="_idIndexMarker206"/> Docker container for SQL Server. Using Azure Cosmos DB, a Docker container is available as well. However, with Cosmos DB, this is just an emulator and should not be used for production. In <a href="B21217_05.xhtml#_idTextAnchor110"><em class="italic">Chapter 5</em></a>, we’ll use the database running with Microsoft Azure.</p>
			<p>To add Azure resources to the <code>AppHost</code> project, we need to add the <code>Aspire.Hosting.Azure</code> NuGet package. Let’s add Azure Cosmos DB to the Aspire <code>AppHost</code> application model:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
<strong class="bold">var cosmos = builder.AddAzureCosmosDB("codebreakercosmos")</strong>
<strong class="bold">  .AddDatabase("codebreaker");</strong>
<strong class="bold">  .RunAsEmulator();</strong>
  builder.AddProject&lt;Projects.Codebreaker_GameAPIs&gt;("gameapis")
  .WithEnvironment("DataStore", dataStore)
<strong class="bold">  .WithReference(cosmos)</strong>
  .WithReference(sqlServer);</pre>
			<p>Invoking the <code>AddAzureCosmosDB</code> method registers the Azure Cosmos DB resource. <code>codebreakercosmos</code> is the resource name, which needs to be lowercase and is used as the connection string to the Azure Cosmos DB account. Here, the name of the database is not part of the connection string. The database is specified by invoking the <code>AddDatabase</code> method and defines the name of the database. The <code>RunAsEmulator</code> method specifies a Docker image to run the database within a Docker container, but only within the development <a id="_idIndexMarker207"/>environment. Similar to before, the Cosmos DB resource is referenced from the games API project, which forwards the connection string with the <code>codebreakercosmos</code> key to this project. Be aware it’s not the name passed to <code>AddDatabase</code> (which was the case with SQL Server) because the database name is not part of the connection string.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor089"/>Configuring the DI container</h2>
			<p>To configure the DI container with the <a id="_idIndexMarker208"/>games API project, we have to add the  <code>Aspire.Microsoft.EntityFrameworkCore.Cosmos</code> NuGet package to use this Aspire component. The configuration of the DI container was already prepared with the configuration of the relational database. All that’s needed now is to add the Cosmos DB EF Core context, as shown in the following code snippet:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameApis/ApplicationServices.cs</p>
			<pre class="source-code">
static void ConfigureCosmos(IHostApplicationBuilder builder)
{
  builder.<strong class="bold">AddDbContext</strong>&lt;IGamesRepository, GamesCosmosContext&gt;(options =&gt;
  {
    var connectionString = builder.Configuration.
      GetConnectionString("codebreakercosmos") ??
      throw new InvalidOperationException("Could not read Cosmos 
      connection string");
    options.UseCosmos(connectionString, "codebreaker");
    options.UseQueryTrackingBehavior(
    QueryTrackingBehavior.NoTracking);
  });
  builder.EnrichCosmosDbContext&lt;GamesCosmosContext&gt;();
}</pre>
			<p>The .NET Aspire Azure Cosmos<a id="_idIndexMarker209"/> DB EF Core component offers the <code>AddCosmosDbContext</code> method, but similar to before, because we need the registration of the <code>IGamesRepository</code> interface, we use the EF Core <code>AddDbContext</code> method and add the Aspire component features by invoking the <code>EnrichCosmosDbContext</code> method. The <code>UseCosmos</code> method registers to use the EF Core provider for Azure Cosmos DB and assigns the connection string that is passed from the application model definition.</p>
			<p>To create the database and the Cosmos DB container, we add the <code>else</code> part to the <code>CreateOrUpdateDatabaseAsync</code> method:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameApis/ApplicationServices.cs</p>
			<pre class="source-code">
public static async Task CreateOrUpdateDatabaseAsync(this WebApplication app)
{
  // code removed for brevity
  else if (dataStore == "Cosmos")
  {
    try
    {
      using var scope = app.Services.CreateScope();
      var repo = scope.ServiceProvider.
        GetRequiredService&lt;IGamesRepository&gt;();
      if (repo is GamesCosmosContext context)
      {
<strong class="bold">        bool created = await context.Database.EnsureCreatedAsync();</strong>
        app.Logger.LogInformation("Cosmos database created: 
          {created}", created);
      }
    }
    catch (Exception ex)
    {
        app.Logger.LogError(ex, "Error updating database");
      throw;
    }
  }
}</pre>
			<p>The <code>Database.EnsureCreatedAsync</code> method creates the database and the Azure Cosmos DB container with the partition key specified.</p>
			<p>Having the configuration in place, let’s <a id="_idIndexMarker210"/>start the application as before with SQL Server and check the stored games with your Azure Cosmos DB database while you set moves. Just make sure that the <code>DataStore</code> configuration is set to the correct database type. Using the HTTP files, don’t forget to use the returned game ID that is returned after creating the game.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor090"/>Summary</h1>
			<p>In this chapter, we changed to using persistent storage with the API service using a relational and a NoSQL database. We created the database context to map the <code>Game</code> and <code>Move</code> types to tables in a relational database and to a JSON document with a NoSQL database – both using EF Core.</p>
			<p>To select which database to use in your environment, if you have relational data with a fixed schema, select SQL Server. If the schema is not required in your scenario, and changes to the data happen often, a NoSQL database can be the best option.</p>
			<p>You learned about how to map objects and how to deal with special mapping requirements based on the object model. Using a relational database, you also learned how to create migrations to update the database schema and to initially create the database.</p>
			<p>You learned how to use database resources with the .NET Aspire application model specified with the <code>AppHost</code> project.</p>
			<p>Before starting the next chapter, it’s well deserved to play another game round. Just use the HTTP files to make your game run. With the state of the current implementation, the game can continue to run after you restart the service – the games and moves are persisted.</p>
			<p>In the next chapter, we create a library that can be used by client applications to invoke the web API so that it becomes more convenient to play the game.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor091"/>Further reading</h1>
			<p>To learn more about the topics discussed in this chapter, you can refer to the following links:</p>
			<ul>
				<li>Value conversions: <a href="https://learn.microsoft.com/ef/core/modeling/value-conversions">https://learn.microsoft.com/ef/core/modeling/value-conversions</a></li>
				<li>Inheritance with EF Core: <a href="https://learn.microsoft.com/ef/core/modeling/inheritance">https://learn.microsoft.com/ef/core/modeling/inheritance</a></li>
				<li>Owned entity types: <a href="https://learn.microsoft.com/ef/core/modeling/owned-entities">https://learn.microsoft.com/ef/core/modeling/owned-entities</a></li>
				<li>Transactions: <a href="https://learn.microsoft.com/ef/core/saving/transactions">https://learn.microsoft.com/ef/core/saving/transactions</a></li>
				<li>Migrations: <a href="https://learn.microsoft.com/ef/core/managing-schemas/migrations">https://learn.microsoft.com/ef/core/managing-schemas/migrations</a></li>
				<li>Azure Cosmos DB intro: <a href="https://learn.microsoft.com/azure/cosmos-db/introduction">https://learn.microsoft.com/azure/cosmos-db/introduction</a></li>
				<li>Limitations with the EF Core Cosmos provider: <a href="https://learn.microsoft.com/ef/core/providers/cosmos/limitations">https://learn.microsoft.com/ef/core/providers/cosmos/limitations</a></li>
				<li>.NET Aspire SqlServer EF Core component: <a href="https://learn.microsoft.com/en-us/dotnet/aspire/database/sql-server-entity-framework-component">https://learn.microsoft.com/en-us/dotnet/aspire/database/sql-server-entity-framework-component</a></li>
				<li>.NET Aspire Microsoft EF Core Cosmos DB component: <a href="https://learn.microsoft.com/en-us/dotnet/aspire/database/azure-cosmos-db-entity-framework-component">https://learn.microsoft.com/en-us/dotnet/aspire/database/azure-cosmos-db-entity-framework-component</a></li>
			</ul>
		</div>
	</body></html>