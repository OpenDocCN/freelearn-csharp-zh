<html><head></head><body>
		<div id="_idContainer042">
			<h1 id="_idParaDest-93" class="chapter-number"><a id="_idTextAnchor092"/>4</h1>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor093"/>Creating Libraries for Client Applications</h1>
			<p>With the updates from the last chapter, the Game API is available to use – including access to the database. In this chapter, we’ll create a .NET library that can be used by all .NET client applications to access the service. Instead of the need to create HTTP requests with every client application, we create a library that can <span class="No-Break">be shared.</span></p>
			<p>In this chapter, you’ll do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Create a library to send <span class="No-Break">HTTP requests</span></li>
				<li>Create a client console application to play a game using <span class="No-Break">the library</span></li>
				<li>Use the Microsoft Kiota tool to generate code based on the <span class="No-Break">OpenAPI document</span></li>
			</ul>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor094"/>Technical requirements</h1>
			<p>The code for this chapter can be found in the GitHub repository at <a href="https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure">https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure</a>. The source code folder <strong class="source-inline">ch04</strong> contains the code samples for <span class="No-Break">this chapter.</span></p>
			<p>The service implementation from the previous chapter is stored in the <strong class="source-inline">server</strong> folder. There’s just a small change to the previous chapter with the models. The models contain annotations (<strong class="source-inline">Required</strong>, <strong class="source-inline">MinLength</strong>, and <strong class="source-inline">MaxLength</strong> attributes). This information shows up in the OpenAPI document and can be used on creating the client. You can use the file <strong class="source-inline">Chapter04.server.sln</strong> to open and run the solution. You need to start the service when running the client application. Based on your preference, you need to configure SQL Server or Azure Cosmos DB as discussed in the previous chapter. You can also use the in-memory repository instead so that you don’t need to have a database running. Change the configuration with the <strong class="source-inline">appsettings.json</strong> file based on <span class="No-Break">your needs.</span></p>
			<p>The new code is in the <strong class="source-inline">client</strong> folder. Here, you will find <span class="No-Break">these projects:</span></p>
			<ul>
				<li><strong class="source-inline">Codebreaker.GameApis.Client</strong>: This is the new library that includes custom models and the <strong class="source-inline">GamesClient</strong> class, which sends HTTP requests to <span class="No-Break">the service</span></li>
				<li><strong class="source-inline">Codebreaker.Client.Console</strong>: This is a new console application that references the client library and can be used to play <span class="No-Break">the game</span></li>
				<li><strong class="source-inline">Codebreaker.GamesApis.Kiota</strong>: This is a client library that can be used as an alternative to <strong class="source-inline">Codebreaker.GameApis.Client</strong> with <span class="No-Break">generated code</span></li>
				<li><strong class="source-inline">Codebreaker.Kiota.Console</strong>: This is a console application that uses the Kiota <span class="No-Break">client library</span></li>
			</ul>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor095"/>Creating a library to create HTTP requests</h1>
			<p>With a microservices team, a good practice is when the team is not only responsible to develop the complete service including the database access code, but also at least one of the client applications. With traditional development teams, client and server development is often spread across different teams. The issue with that is that the client and service are best created in collaboration. Creating the client, you’ll find answers missing from the services API. Here, a fast communication between the client and service <span class="No-Break">developers helps.</span></p>
			<p>Creating a library for the client allows us to reuse this functionality from all .NET clients; you can create clients with any .NET client technology, such as Blazor, WinUI, .NET MAUI, and others. In this chapter, we will just create a console application, but you can find clients using Blazor, WinUI, .NET MAUI, WPF, and Platform Uno in the GitHub organization <span class="No-Break">at </span><a href="https://github.com/codebreakerapp"><span class="No-Break">https://github.com/codebreakerapp</span></a><span class="No-Break">.</span></p>
			<p>To create<a id="_idIndexMarker211"/> the library to be used by client applications, we do <span class="No-Break">the following:</span></p>
			<ol>
				<li>Create a library with multi-targeting support to support different .NET versions with <span class="No-Break">the clients</span></li>
				<li>Inject the <strong class="source-inline">HttpClient</strong> with the main class the client <span class="No-Break">interacts with.</span></li>
				<li>Send HTTP requests to the <span class="No-Break">games service.</span></li>
				<li>Create a NuGet package<a id="_idIndexMarker212"/> for <span class="No-Break">easier use.</span></li>
			</ol>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor096"/>Creating a library with multi-targeting support</h2>
			<p>We create the library<a id="_idIndexMarker213"/> for the client<a id="_idIndexMarker214"/> using the <span class="No-Break"><strong class="source-inline">dotnet</strong></span><span class="No-Break"> CLI:</span></p>
			<pre class="console">
dotnet new classlib --framework net8.0 -o Codebreaker.GameApis.Client</pre>
			<p>With this library, we need the model types for the data to transfer between the client and the service and a client class that does the HTTP requests to invoke the <span class="No-Break">services API.</span></p>
			<p>To support clients using different .NET versions, the library is configured with <span class="No-Break">multi-targeting support:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Client/Codebreaker.GameAPIs.Client.csproj</p>
			<pre class="source-code">
&lt;PropertyGroup&gt;
<strong class="bold">  &lt;TargetFrameworks&gt;net7.0;net8.0&lt;/TargetFrameworks&gt;</strong>
  &lt;!-- code removed for brevity --&gt;
&lt;/PropertyGroup&gt;</pre>
			<p>Instead of the default entry, <strong class="source-inline">TargetFramework</strong>, an <strong class="source-inline">s</strong> is appended to contain a list of frameworks. With multiple frameworks added, multiple binaries are added when creating a NuGet package. It might be okay for you to create a library with .NET 6, which can also be used from .NET 7 and .NET 8 clients. Using multiple frameworks you can create optimized code based on the <span class="No-Break">client version.</span></p>
			<p>An optimization is shown with the following <span class="No-Break">code snippet:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Client/Models/CreateGameRequest.cs</p>
			<pre class="source-code">
<strong class="bold">#if NET8_0_OR_GREATER</strong>
<strong class="bold">[JsonConverter(typeof(JsonStringEnumConverter&lt;GameType&gt;))]</strong>
<strong class="bold">#else</strong>
<strong class="bold">[JsonConverter(typeof(JsonStringEnumConverter))]</strong>
<strong class="bold">#endif</strong>
public enum GameType
{
    Game6x4,
    Game6x4Mini,
    Game8x5,
    Game5x5x4,
}</pre>
			<p>Generic attributes are new since C# 11. The generic type of the <strong class="source-inline">JsonStringEnumConverter</strong> is new with .NET 8. This generic version supports Native AOT compilation. The older version and the non-generic <strong class="source-inline">JsonStringEnumConverter</strong> uses reflection. Using the C# preprocessor directive <strong class="source-inline">#if</strong> and the predefined symbol <strong class="source-inline">NET8_0_OR_GREATER</strong>, different code gets compiled based on the <span class="No-Break">framework version.</span></p>
			<p>The models are mainly<a id="_idIndexMarker215"/> the same between the client <a id="_idIndexMarker216"/>and the service. Here, you might choose to move the models from the service-only library to a common library that is referenced both from the client and service applications. However, with client technologies, you might have other requirements based on validating and change notification. With the models of the client library, you can implement the interface <strong class="source-inline">INotifyPropertyChanged</strong>, which is used by different client technologies to update the user interface automatically if a change is notified. Later in this chapter, we’ll also create a library from the OpenAPI document created in <a href="B21217_02.xhtml#_idTextAnchor031"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, which can be another reason not to create a <span class="No-Break">shared library.</span></p>
			<p><strong class="source-inline">CreateGameRequest</strong> is the class we need to send the request when starting <span class="No-Break">the game:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Client/Models/CreateGameRequest.cs</p>
			<pre class="source-code">
[JsonConverter(typeof(JsonStringEnumConverter&lt;GameType&gt;))]
public enum GameType
{
  Game6x4,
  Game6x4Mini,
  Game8x5,
  Game5x5x4,
}
public record class CreateGameRequest(
  GameType,
  string PlayerName);</pre>
			<p>The <strong class="source-inline">CreateGameRequest</strong> contains<a id="_idIndexMarker217"/> the properties <strong class="source-inline">GameType</strong> and <strong class="source-inline">PlayerName</strong>, which are required<a id="_idIndexMarker218"/> to start the game. The <strong class="source-inline">GamesQuery</strong> class is used to send different query parameters to retrieve a filtered list of games based on <span class="No-Break">the query:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Client/Models/GamesQuery.cs</p>
			<pre class="source-code">
public record class GamesQuery(
  GameType? GameType = default,
  string? PlayerName = default,
  DateOnly? Date = default,
  bool? Ended = false)
{
  public string AsUrlQuery()
  {
    var queryString = "?";
    if (GameType != null)
    {
      queryString += $"gameType={GameType}&amp;";
    }
    if (PlayerName != null)
    {
      queryString += $"playerName={Uri.EscapeDataString(PlayerName)}&amp;";
    }
    // code removed for brevity
    queryString = queryString.TrimEnd('&amp;');
    return queryString;
  }
}</pre>
			<p>The <strong class="source-inline">AsUrlQuery</strong> method converts<a id="_idIndexMarker219"/> the properties of the record<a id="_idIndexMarker220"/> to create HTTP query parameters as specified with the games API service and returns the combined query string. You might think about adding this method to the <strong class="source-inline">Game</strong> class. The <strong class="source-inline">Game</strong> class just defines the structure of the data representing a game. The <strong class="source-inline">GamesQuery</strong> class controls how its data can be converted into a URL <span class="No-Break">query string.</span></p>
			<p>Additionally, <strong class="source-inline">CreateGameResponse</strong>, <strong class="source-inline">UpdateGameRequest</strong>, <strong class="source-inline">UpdateGameResponse</strong>, <strong class="source-inline">Game</strong>, and <strong class="source-inline">Move</strong> are needed with this library. Check these types with the <span class="No-Break">GitHub repo.</span></p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor097"/>Injecting the HttpClient class</h2>
			<p>The <strong class="source-inline">GamesClient</strong> class we create<a id="_idIndexMarker221"/> next is used to send requests to the games service. To use the <strong class="source-inline">HttpClient</strong> class, an object of this class can be injected. With the application using the library, this <strong class="source-inline">HttpClient</strong> needs to be configured with the base address (in <a href="B21217_09.xhtml#_idTextAnchor216"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, this will be extended <span class="No-Break">with authentication).</span></p>
			<p>The implementation of the constructor of the <strong class="source-inline">GamesClient</strong> class is shown in the following <span class="No-Break">code snippet:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Client/GamesClient.cs</p>
			<pre class="source-code">
public class GamesClient(HttpClient httpClient)
{
  private readonly HttpClient _httpClient = httpClient;
  private readonly JsonSerializerOptions _jsonOptions = new()
  {
    PropertyNameCaseInsensitive = true
  };
  // code removed for brevity</pre>
			<p>With the constructor of the <strong class="source-inline">GamesClient</strong>, the injected <strong class="source-inline">HttpClient</strong> instance is assigned to a variable, and <strong class="source-inline">JsonOptions</strong> is configured. ASP.NET Core maps properties on JSON serialization to lowercase. With the options as defined here, casing is ignored, so the lowercase map is transferred to <span class="No-Break">uppercase properties.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Don’t create a new instance of the <strong class="source-inline">HttpClient</strong> class with every request. Instead, injecting the client will shift the responsibility to creating instances to the calling application. With the dependency injection container, we’ll configure the <strong class="source-inline">HttpClient</strong> to be created from <span class="No-Break">a factory.</span></p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor098"/>Sending HTTP requests</h2>
			<p>Let’s send some requests<a id="_idIndexMarker222"/> to the service to retrieve information about games, start games, and <span class="No-Break">set moves.</span></p>
			<p>The first methods are used to retrieve <span class="No-Break">game information:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Client/GamesClient.cs</p>
			<pre class="source-code">
public async Task&lt;Game?&gt; GetGameAsync(bool id, CancellationToken cancellationToken = default)
{
  Game game = default;
  try
  {
    game = await <strong class="bold">_httpClient.GetFromJsonAsync&lt;Game&gt;(</strong>
<strong class="bold">      $"/games/{id}", _jsonOptions, cancellationToken);</strong>
  }
  catch (HttpRequestException ex) when (ex.StatusCode = 
  HttpStatusCode.NotFound)
  {
    return default;
  }
  return game;
}
public async Task&lt;IEnumerable&lt;Game&gt;&gt; GetGamesAsync(GamesQuery query, CancellationToken cancellationToken = default)
{
  IEnumerable&lt;Game&gt; games = (
    await <strong class="bold">_httpClient.GetFromJsonAsync&lt;IEnumerable&lt;Game&gt;&gt;(</strong>
<strong class="bold">      $"/games/{query.AsUrlQuery()}", _jsonOptions, </strong>
<strong class="bold">      cancellationToken))</strong> ?? Enumerable.Empty&lt;Game&gt;();
  return games;
}</pre>
			<p>The <strong class="source-inline">GetGameAsync</strong> method retrieves<a id="_idIndexMarker223"/> one game passing the identifier of the game. <strong class="source-inline">GetGamesAsync</strong> uses the previously created <strong class="source-inline">GamesQuery</strong> to create the URI for the service to send the HTTP GET request. <strong class="source-inline">GetFromJsonAsync</strong> is an extension method for the <strong class="source-inline">HttpClient</strong> class to send an HTTP GET request, checks for a successful status code using <strong class="source-inline">EnsureSuccessStatusCode</strong> with <strong class="source-inline">HttpResponseMessage</strong> (which throws an <strong class="source-inline">HttpRequestException</strong> if not successful), and uses the <strong class="source-inline">System.Text.Json</strong> deserializer to deserialize the stream from the response. When the <strong class="source-inline">game-id</strong> passed was not found, we want to return <strong class="source-inline">null</strong> instead of throwing an exception so this exception <span class="No-Break">is caught.</span></p>
			<p>Sending a request to start a game is implemented with the <span class="No-Break"><strong class="source-inline">StartGameAsync</strong></span><span class="No-Break"> method:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Client/GamesClient.cs</p>
			<pre class="source-code">
public async Task&lt;(Guid id, int numberCodes, int maxMoves, IDictionary&lt;string, string[]&gt; FieldValues)&gt;
  StartGameAsync(GameType gameType, string playerName, 
  CancellationToken cancellationToken = default)
{
  CreateGameRequest createGameRequest = new(_gameType, _playerName);
<strong class="bold">  var response = await _httpClient.PostAsJsonAsync("/games", </strong>
    <strong class="bold">createGameRequest, cancellationToken);</strong>
  response.EnsureSuccessStatusCode();
  var gameResponse = await response.Content.
    ReadFromJsonAsync&lt;CreateGameResponse&gt;(
    _jsonOptions, cancellationToken);
  if (gameResponse is null)
    throw new InvalidOperationException();
  return (gameResponse.Id, gameResponse.NumberCodes, gameResponse.
    MaxMoves, gameResponse.FieldValues);
}</pre>
			<p>The <strong class="source-inline">StartGamesAsync</strong> method sends an HTTP POST request<a id="_idIndexMarker224"/> after creating the data that should be sent with the HTTP body: <strong class="source-inline">CreateGameRequest</strong>. After receiving a success response, the <strong class="source-inline">ReadFromJsonAsync</strong> extension method deserializes the returned HTTP body and returns the methods result using <span class="No-Break">a tuple.</span></p>
			<p>To send a games move, the game is updated using an HTTP <span class="No-Break">PATCH request:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Client/GamesClient.cs</p>
			<pre class="source-code">
public async Task&lt;(string[] Results, bool Ended, bool IsVictory)&gt; SetMoveAsync(Guid id, string playerName, GameType gameType, int moveNumber, string[] guessPegs, CancellationToken cancellationToken = default)
{
  UpdateGameRequest updateGameRequest = new(id, gameType, playerName, 
    moveNumber)
  {
    GuessPegs = guessPegs
  };
<strong class="bold">  var response = await _httpClient.PatchAsJsonAsync($"/games/{id}", </strong>
    <strong class="bold">updateGameRequest, _jsonOptions, cancellationToken);</strong>
  response.EnsureSuccessStatusCode();
<strong class="bold">  var moveResponse = await response.Content.ReadFromJsonAsync&lt;UpdateGameResponse&gt;(_jsonOptions, cancellationToken)</strong>
    ?? throw new InvalidOperationException();
  (_, _, _, bool ended, bool isVictory, string[] results) = 
    moveResponse;
  return (results, ended, isVictory);
}</pre>
			<p>Sending an HTTP PATCH request is very similar to sending a POST request: the <strong class="source-inline">UpdateGameRequest</strong> object is created to send this JSON-serialized  information to the server. Receiving the result, the body<a id="_idIndexMarker225"/> is deserialized to an <span class="No-Break"><strong class="source-inline">UpdateGameResponse</strong></span><span class="No-Break"> object.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">With REST APIs, a HTTP PUT request is usually used to update a resource, while HTTP PATCH is used for a partial update. Here, the game resource is updated, but not by sending the complete game and just some <span class="No-Break">partial data.</span></p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/>Creating a NuGet Package</h2>
			<p>To create a NuGet package<a id="_idIndexMarker226"/> from the library, you can use the <span class="No-Break"><strong class="source-inline">dotnet</strong></span><span class="No-Break"> CLI:</span></p>
			<pre class="console">
cd Codebreaker.GameAPIs.Client
dotnet pack --configuration Release</pre>
			<p>To see the content of the NuGet package, you can rename it to <strong class="source-inline">zip</strong>. For easy use of this package, you can add it to a shared folder and configure the Visual Studio NuGet Package manager to reference this folder. You can also publish the package to Azure DevOps Artifacts. Referencing this, you can create a <span class="No-Break"><strong class="source-inline">nuget.config</strong></span><span class="No-Break"> file:</span></p>
			<pre class="console">
dotnet new nugetconfig</pre>
			<p>With the generated <strong class="source-inline">nuget.config</strong> file, you need to specify the shared folder or the link to your Azure DevOps <span class="No-Break">Artifacts feed.</span></p>
			<p>This is a <strong class="source-inline">nuget.config</strong> file created using <strong class="source-inline">dotnet new</strong> with one additional entry for a <span class="No-Break">custom feed:</span></p>
			<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;configuration&gt;
  &lt;packageSources&gt;
    &lt;clear /&gt;
    &lt;add key="nuget" value="https://api.nuget.org/v3/index.json" /&gt;
<strong class="bold">    </strong><strong class="bold">&lt;add key="custom" value="https://pkgs.dev.azure.com/</strong>
      <strong class="bold">MyOrganization/_packaging/MyFeed/nuget/v3/index.json" /&gt;</strong>
  &lt;/packageSources&gt;
&lt;/configuration&gt;</pre>
			<p>With this NuGet configuration file, the entry <strong class="source-inline">&lt;clear /&gt;</strong> removes all the default feeds. The <strong class="source-inline">nuget</strong> key with the first <strong class="source-inline">add</strong> element references the default feed of the NuGet server. Similarly, you can add custom feeds with other keys and links to the package feeds on <span class="No-Break">the server.</span></p>
			<p>For the Codebreaker solution, you can look for the NuGet package <strong class="source-inline">Cninnovation.Codebreaker.Client</strong>, which is available on the NuGet server. After making NuGet packages available on NuGet, a readme file, a license, and some more metadata should be added<a id="_idIndexMarker227"/> to the package. See further readings for <span class="No-Break">more information.</span></p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor100"/>Creating a client application</h1>
			<p>Having the library in place, let’s create<a id="_idIndexMarker228"/> a client application. A simple console application fulfils the purpose to play the game. With the sample application of this chapter, the NuGet packages <strong class="source-inline">Microsoft.Extensions.Hosting</strong>, <strong class="source-inline">Microsoft.Extensions.Http.Resiliency</strong>, and <strong class="source-inline">Spectre.Console.Cli</strong> are added. Navigate to the folder of the solution file before invoking <span class="No-Break">these commands:</span></p>
			<pre class="console">
dotnet new console –framework net8.0 -o Codebreaker.Console
cd Codebreaker.Console
dotnet add package Microsoft.Extensions.Hosting
dotnet add package Microsoft.Extensions.Http.Resilience
dotnet add package Spectre.Console.Cli
dotnet add reference ../Codebreaker.GameAPIs.Client</pre>
			<p><strong class="source-inline">Microsoft.Extensions.Hosting</strong> will be used for a dependency injection container and configuration support and <strong class="source-inline">Microsoft.Extensions.Http.Resilience</strong> is the package offering an <strong class="source-inline">HttpClientFactory</strong>. Of course, the library created previously needs to be referenced <span class="No-Break">as well.</span></p>
			<p>To interact with the user, you can<a id="_idIndexMarker229"/> use simple <strong class="source-inline">Console.ReadLine</strong> and <strong class="source-inline">Console.WriteLine</strong> statements. With the sample application available in the books GitHub repo, the NuGet package <strong class="source-inline">Spectre.Console.Cli</strong> is used. Just check the source code for <span class="No-Break">more information.</span></p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor101"/>Configuring the dependency injection container</h2>
			<p>The top-level statements<a id="_idIndexMarker230"/> of the application<a id="_idIndexMarker231"/> are shown with the following <span class="No-Break">code snippet:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Console/Program.cs</p>
			<pre class="source-code">
<strong class="bold">var builder = Host.CreateApplicationBuilder(args);</strong>
<strong class="bold">builder.Services.AddHttpClient&lt;GamesClient&gt;(client =&gt;</strong>
{
  <strong class="bold">string gamesUrl = builder.Configuration["GamesApiUrl"]</strong> ??<strong class="bold"> </strong>throw new 
    InvalidOperationException("GamesApiUrl not found");
  <strong class="bold">client.BaseAddress = new Uri(gamesUrl);</strong>
});
builder.Services.AddTransient&lt;Runner&gt;();
var app = builder.Build();
var runner = app.Services.GetRequiredService&lt;Runner&gt;();
await runner.RunAsync();</pre>
			<p>The <strong class="source-inline">CreateApplicationBuilder</strong> of the <strong class="source-inline">Host</strong> class configures<a id="_idIndexMarker232"/> the dependency injection<a id="_idIndexMarker233"/> container and has default configuration for the application configuration providers and the logging providers. The <strong class="source-inline">AddHttpClient</strong> extension method is implemented with the HttpClient factory. Here, the generic method overload is used to specify the <strong class="source-inline">GamesClient</strong> class that will receive the <strong class="source-inline">HttpClient</strong> injected as specified with the <strong class="source-inline">configureClient</strong> lambda expression. The <strong class="source-inline">BaseAddress</strong> of the <strong class="source-inline">HttpClient</strong> is configured to have the <strong class="source-inline">GamesApiUrl</strong> <span class="No-Break">configuration value.</span></p>
			<p>For the configuration, we create the <strong class="source-inline">appsettings.json</strong> <span class="No-Break">configuration file:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Console/appsettings.json</p>
			<pre class="source-code">
{
  "Logging": {
    "LogLevel": {
      "Default": "Warning"
    }
  },
  "GamesApiUrl": "http://localhost:9400"
}</pre>
			<p>The <strong class="source-inline">GamesApiUrl</strong> key is configured to contain<a id="_idIndexMarker234"/> the address of the Games API<a id="_idIndexMarker235"/> service. To not mess up logging with the console output for the game play, the log level is configured to only log warning, error, and critical <span class="No-Break">error messages.</span></p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/>Interacting with the user</h2>
			<p>The interaction<a id="_idIndexMarker236"/> with the user<a id="_idIndexMarker237"/> and the invocation of the service happens via the <strong class="source-inline">Runner</strong> class. Here, the previously created <strong class="source-inline">GamesClient</strong> is injected into the <span class="No-Break">primary constructor:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Console/Runner.cs</p>
			<pre class="source-code">
internal class Runner(GamesClient client)
{
  private readonly CancellationTokenSource _cancellationTokenSource = new();
  public async Task RunAsync()
  {
    bool ended = false;
    while (!ended)
    {
<strong class="bold">      var selection = Inputs.GetMainSelection();</strong>
      switch (selection)
      {
        case MainOptions.Play:
<strong class="bold">          await PlayGameAsync();</strong>
          break;
        case MainOptions.Exit:
          ended = true;
          break;
        case MainOptions.QueryGame:
<strong class="bold">          await ShowGameAsync();</strong>
          break;
        case MainOptions.QueryList:
<strong class="bold">          </strong><strong class="bold">await ShowGamesAsync();</strong>
          break;
        case MainOptions.Delete:
<strong class="bold">          await DeleteGameAsync();</strong>
          break;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }
  }
  // code removed for brevity
}</pre>
			<p>The <strong class="source-inline">RunAsync</strong> method first asks the user<a id="_idIndexMarker238"/> what to do next. The main options are to play<a id="_idIndexMarker239"/> a game, to show the status of a single game, to show a list of games, or to delete a game. This code snippet makes use of the <strong class="source-inline">Inputs</strong> class, which in turn uses the <strong class="source-inline">AnsiConsole</strong> class from the mentioned NuGet package <strong class="source-inline">Spectre.Console.Cli</strong>. With this, you get a nice console user interface, as shown in <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.1</em>, with easy selections. Depending on what you used for interacting with the user, your user interface might <span class="No-Break">look different.</span></p>
			<ol>
				<li>To run a game, first start the server before starting the client. With the client, select <strong class="bold">Play</strong> (<span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">).</span></li>
			</ol>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/B21217_04_01.jpg" alt="Figure 4.1 – Console output to select a main task"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Console output to select a main task</p>
			<ol>
				<li value="2">Next, select a game<a id="_idIndexMarker240"/> type (<span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.2</em>), for <a id="_idIndexMarker241"/><span class="No-Break">example, </span><span class="No-Break"><strong class="bold">Game6x4</strong></span><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/B21217_04_02.jpg" alt="Figure 4.2 – Selecting the game type"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Selecting the game type</p>
			<ol>
				<li value="3">Enter a player name (<span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.3</em>) and enter all the colors needed for a <span class="No-Break">single move.</span></li>
			</ol>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B21217_04_03.jpg" alt="Figure 4.3 – Entering the name and selecting the colors depending on the game type"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Entering the name and selecting the colors depending on the game type</p>
			<ol>
				<li value="4"><span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.4</em> shows the result<a id="_idIndexMarker242"/> of the move (here with three colors correct<a id="_idIndexMarker243"/> but in the wrong positions) and the start of the next move. Repeat this until you solve <span class="No-Break">the codes.</span></li>
			</ol>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B21217_04_04.jpg" alt="Figure 4.4 – Moving the result and the next move"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Moving the result and the next move</p>
			<p>The result of a successful move is shown in <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B21217_04_05.jpg" alt="Figure 4.5 – Game results"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Game results</p>
			<p>From there, you can repeat<a id="_idIndexMarker244"/> this to play another game or query for the list<a id="_idIndexMarker245"/> of games. From the list of games, you can get a game identifier and query for a single game passing <span class="No-Break">the identifier.</span></p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>Using Microsoft Kiota to create a client</h1>
			<p>Running the API service<a id="_idIndexMarker246"/> generating the<a id="_idIndexMarker247"/> OpenAPI document (this was done in <a href="B21217_02.xhtml#_idTextAnchor031"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>), we can leverage this information, and create the client code automatically. With the sample code of this chapter, the OpenAPI document is stored with the file <strong class="source-inline">gamesapi-swagger.json</strong>, which you can reference without starting <span class="No-Break">the service.</span></p>
			<p>One option with Visual Studio is to use <strong class="bold">Add</strong> | <strong class="bold">Connected Client</strong> and add a service reference to an OpenAPI document. But this option (at the time of this writing) has <span class="No-Break">some limitations:</span></p>
			<ul>
				<li>It still uses the Newtonsoft Json serializer, whereas the new <strong class="source-inline">System.Text.Json</strong> one is faster and uses <span class="No-Break">less memory</span></li>
				<li>The client implementation makes use of strings instead of streams, which can result in objects in the large <span class="No-Break">object heap</span></li>
			</ul>
			<p>As you’ve seen in this chapter, creating a custom library to create HTTP requests is not that hard and can be optimized for your <span class="No-Break">own domain.</span></p>
			<p>But now there’s another option<a id="_idIndexMarker248"/> that should be considered: Microsoft Kiota<em class="italic"> </em>(https://learn.microsoft.com/openapi/kiota/<span class="P---URL">)</span>. Microsoft Kiota is a command-line tool that offers code generation from the OpenAPI for several languages including Java, PHP, Python, Typescript, C#, and many others. Let’s give this <span class="No-Break">a chance.</span></p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor104"/>Installing Kiota</h2>
			<p>Kiota is available<a id="_idIndexMarker249"/> as a <strong class="source-inline">dotnet</strong> tool. We install this tool as part of the new library for another class <span class="No-Break">library project.</span></p>
			<p>The library is created with the following commands. Run these commands from the <span class="No-Break"><strong class="source-inline">solution</strong></span><span class="No-Break"> folder:</span></p>
			<pre class="console">
dotnet new classlib --framework net8.0 -o Codebreaker.GameApis.KiotaClient
cd Codebreaker.GameApis.KiotaClient
dotnet add package Microsoft.Kiota.Http.HttpClientLibrary
dotnet add package Microsoft.Kiota.Serialization.Json
dotnet add package Microsoft.Kiota.Serialization.Form
dotnet add package Microsoft.Kiota.Serialization.Multipart
dotnet add package Microsoft.Kiota.Serialization.Text</pre>
			<p>Using Kiota, we also need to add some Kiota NuGet packages for different serializers and a Kiota HTTP client library. The Kiota<a id="_idIndexMarker250"/> tool is installed with <span class="No-Break">the project:</span></p>
			<pre class="console">
dotnet new tool-manifest
dotnet tool install microsoft.openapi.kiota</pre>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor105"/>Generating Code with Kiota</h2>
			<p>After the Kiota tool is installed, we can<a id="_idIndexMarker251"/> generate the code using<a id="_idIndexMarker252"/> the OpenAPI document <strong class="source-inline">gamesapi-swagger.json</strong>. This file is available in the <span class="No-Break"><strong class="source-inline">ch04</strong></span><span class="No-Break"> folder:</span></p>
			<pre class="console">
dotnet kiota generate --openapi ..\..\gamesapi-swagger.json --output codebreaker --language CSharp --class-name GamesAPIClient --namespace-name Codebreaker.Client</pre>
			<p>Using these options, source code is generated using the referenced OpenAPI document <strong class="source-inline">gamesapi-swagger.json</strong>, the generated files are stored in the subdirectory <strong class="source-inline">codebreaker</strong>, C# is used for the code generation, the main class to do the HTTP requests is named <strong class="source-inline">GamesAPIClient</strong>, and the namespace for all the generated code <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">Codebreaker.Client</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Looking at the generated code, you’ll see that Kiota-generated code is not using the same coding convention as used in this book or as the .NET team is using. For example, the opening of curly braces is done in the same line as the method name, which is a convention used with many JavaScript programs. If you use Visual Studio, you can easily change this with the complete program using the context menu in Solution Explorer, navigating to <strong class="bold">Analyze and Code Cleanup</strong> | <strong class="bold">Run Code Cleanup</strong>. You might need to configure your preferences with code <span class="No-Break">cleanup first.</span></p>
			<p>The types created using Kiota<a id="_idIndexMarker253"/> are the models (using the <strong class="source-inline">schemas</strong> within OpenAPI) and request<a id="_idIndexMarker254"/> builders (using the <strong class="source-inline">paths</strong> where the requests are defined). Check the book repository for the generated <span class="No-Break">code files.</span></p>
			<h3>Exploring the Kiota-generated models</h3>
			<p>For all the requests<a id="_idIndexMarker255"/> and responses and all the types specified within the schemas, Kiota generates classes in the <strong class="source-inline">Models</strong> directory. Let’s have a look at the <span class="No-Break"><strong class="source-inline">CreateGameRequest</strong></span><span class="No-Break"> class:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GamesAPIs.KiotaClient/codebreaker/Models/CreateGameRequest.cs</p>
			<pre class="source-code">
public class CreateGameRequest : <strong class="bold">IParsable</strong>
{
  public Codebreaker.Client.Models.GameType? GameType { get; set; }
  public string? PlayerName { get; set; }
  public static CreateGameRequest 
    CreateFromDiscriminatorValue(IParseNode parseNode)
  {
    _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
    return new CreateGameRequest();
  }
  public virtual IDictionary&lt;string, Action&lt;IParseNode&gt;&gt; 
    <strong class="bold">GetFieldDeserializers</strong>()
  {
    return new Dictionary&lt;string, Action&lt;IParseNode&gt;&gt; {
      {"gameType", n =&gt; { GameType = n.GetEnumValue&lt;GameType&gt;(); } },
      {"playerName", n =&gt; { PlayerName = n.GetStringValue(); } },
    };
  }
  public virtual void <strong class="bold">Serialize</strong>(ISerializationWriter writer)
  {
    _ = writer ?? throw new ArgumentNullException(nameof(writer));
    writer.WriteEnumValue&lt;GameType&gt;("gameType", GameType);
    writer.WriteStringValue("playerName", PlayerName);
  }
}</pre>
			<p>The model types implement<a id="_idIndexMarker256"/> the <strong class="source-inline">IParsable</strong> interface. This is not the <strong class="source-inline">System.IParsable</strong> interface, but a version from the Kiota library in the namespace <strong class="source-inline">Microsoft.Kiota.Abstractions.Serialization</strong>. This interface defines instance members <strong class="source-inline">GetFieldDeserializers</strong> and <strong class="source-inline">Serialize</strong>. With this, Kiota offers an abstraction layer, which allows for the use of <span class="No-Break">different serializers.</span></p>
			<p>Another important aspect that needs mentioning is that all the properties of the model types are declared to be nullable. While EF Core supports nullability to map non-nullable members to be required in the database, this annotation is not used when generating the OpenAPI document using the minimal APIs. Adding the <strong class="source-inline">Required</strong> attribute to the models on the server adds <strong class="source-inline">required</strong>. Other annotations such as <strong class="source-inline">MaxLength</strong> and <strong class="source-inline">MinLength</strong> are mapped as well with <strong class="source-inline">maxLength</strong> and <strong class="source-inline">minLength</strong>, as you can see <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">gamesapi-swagger.json</strong></span><span class="No-Break">.</span></p>
			<p>However, many APIs don’t pay attention to nullability. With the OpenAPI definition too, it’s also not exlpicitly specified how strict nullability should be enforced. Depending on the context where the model is used, information can still be left out from the server, and the data is <span class="No-Break">not sent.</span></p>
			<p>Here is a discussion about the Kiota <span class="No-Break">implementation: </span><span class="No-Break">https://github.com/microsoft/kiota/issues/2594</span></p>
			<p>With the next major version<a id="_idIndexMarker257"/> of the OpenAPI specification, this might change. With the decisions made for the current Kiota implementation, Kiota is on the safe side to declare all the model properties as nullable, but this also means that we need to check <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break">.</span></p>
			<h3>Exploring the Kiota-generated request builders</h3>
			<p>The goal of request builders<a id="_idIndexMarker258"/> is to easily create requests. Let’s look at some of the <span class="No-Break">generated code:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GamesAPIs.KiotaClient/codebreaker/GamesAPIClient.cs</p>
			<pre class="source-code">
public class GamesAPIClient : <strong class="bold">BaseRequestBuilder</strong>
{
  public GamesRequestBuilder Games
  {
    get =&gt; new GamesRequestBuilder(PathParameters, RequestAdapter);
  }
  public GamesAPIClient(IRequestAdapter requestAdapter) : base(requestAdapter, "{+baseurl}", new Dictionary&lt;string, object&gt;())
  {
     ApiClientBuilder.
       RegisterDefaultSerializer&lt;JsonSerializationWriterFactory&gt;();
     ApiClientBuilder.
       RegisterDefaultSerializer&lt;TextSerializationWriterFactory&gt;();
     ApiClientBuilder.
       RegisterDefaultDeserializer&lt;JsonParseNodeFactory&gt;();
  // code removed for brevity
  }
}</pre>
			<p>All the request builders derive<a id="_idIndexMarker259"/> from the base class, <strong class="source-inline">BaseRequestBuilder</strong>. The <strong class="source-inline">GamesApiClient</strong> class, where the name was specified with the code generation, is the request builder that needs to be initiated to communicate with the Games API. In the constructor, you can see default serializers and deserializers<a id="_idIndexMarker260"/> configured. Here, Kiota gives <span class="No-Break">another flexibility.</span></p>
			<p>The <strong class="source-inline">Games</strong> property of <strong class="source-inline">GamesApiClient</strong> returns another request builder: <strong class="source-inline">GamesRequestBuilder</strong>. This builder is in the <strong class="source-inline">GamesRequestBuilder.cs</strong> <span class="No-Break">source file:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GamesAPIs.KiotaClient/codebreaker/Games/GamesRequestBuilder.cs</p>
			<pre class="source-code">
public class <strong class="bold">GamesRequestBuilder</strong> : BaseRequestBuilder
{
  <strong class="bold">public GamesItemRequestBuilder this[Guid position]</strong>
  {
    get
    {
      // code removed for brevity
      return new GamesItemRequestBuilder(urlTplParams, 
        RequestAdapter);
    }
  }
<strong class="bold">  public async Task&lt;List&lt;Game&gt;?&gt; GetAsync(Action&lt;RequestConfiguration</strong>
    <strong class="bold">&lt;GamesRequestBuilderGetQueryParameters&gt;&gt;? requestConfiguration = </strong>
    <strong class="bold">default, CancellationToken cancellationToken = default)</strong>
  {
    var requestInfo = ToGetRequestInformation(requestConfiguration);
    var collectionResult = await RequestAdapter.
      SendCollectionAsync&lt;Game&gt;(requestInfo, Game.
      CreateFromDiscriminatorValue, default, cancellationToken).
      ConfigureAwait(false);
    return collectionResult?.ToList();
  }
<strong class="bold">  public async Task&lt;CreateGameResponse?&gt; PostAsync(CreateGameRequest </strong>
    <strong class="bold">body, Action&lt;RequestConfiguration&lt;DefaultQueryParameters&gt;&gt;? </strong>
    <strong class="bold">requestConfiguration = default, CancellationToken </strong>
    <strong class="bold">cancellationToken = default)</strong>
  {
    // code removed for brevity
  }</pre>
			<p>This request builder is then used to invoke requests of the games API. Methods implemented by this request builder are <strong class="source-inline">GetAsync</strong> and <strong class="source-inline">PostAsync</strong>. The <strong class="source-inline">GetAsync</strong> method is used to retrieve a list of games with query parameters. <strong class="source-inline">PostAsync</strong> sends a POST request with the generated <span class="No-Break"><strong class="source-inline">CreateGameRequest</strong></span><span class="No-Break"> model.</span></p>
			<p>To get a single game, update a game by sending a game move, and delete a game, the games API needs a game identifier. With Kiota, this is solved by offering an indexer with <strong class="source-inline">GamesRequestBuilder</strong>, which in turn returns another request builder, <strong class="source-inline">GameItemsRequestBuilder</strong>. Here, a fluent API<a id="_idIndexMarker261"/> can be used to pass a game identifier and invoke the <strong class="source-inline">GetAsync</strong> and <span class="No-Break"><strong class="source-inline">PutAsync</strong></span><span class="No-Break"> methods.</span></p>
			<p>Let’s implement another console application to use this generated code in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/>Using the Kiota-generated code</h2>
			<p>The Kiota-generated code<a id="_idIndexMarker262"/> is used with the console application <strong class="source-inline">Codebreaker.KiotaConsole</strong>. With big parts, the code of this application is similar to the console application from before. Mainly the invocations to the service, which are done with the <strong class="source-inline">Runner</strong> class, are now replaced and the dependency injection container configuration <span class="No-Break">is changed.</span></p>
			<p>The HttpClient factory is no longer registered with the DI container, as shown in the following <span class="No-Break">code snippet:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.KiotaConsole/Program.cs</p>
			<pre class="source-code">
var builder = Host.CreateApplicationBuilder(args);
<strong class="bold">builder.Services.Configure&lt;RunnerOptions&gt;(options =&gt;</strong>
<strong class="bold">{</strong>
<strong class="bold">  </strong><strong class="bold">options.GamesApiUrl = builder.Configuration["GamesApiUrl"] ??</strong>
<strong class="bold">    throw new InvalidOperationException("GamesApiUrl not found");</strong>
<strong class="bold">});</strong>
builder.Services.AddTransient&lt;Runner&gt;();
var app = builder.Build();
var runner = app.Services.GetRequiredService&lt;Runner&gt;();
await runner.RunAsync();</pre>
			<p>Other than removing the code<a id="_idIndexMarker263"/> for the <strong class="source-inline">HttpClient</strong> configuration, the base address is now configured to supply values for the <strong class="source-inline">RunnerOptions</strong> class. This class just defines the <strong class="source-inline">GamesApiUrl</strong> property to specify the base address for the <span class="No-Break">games service.</span></p>
			<p>The constructor of the <strong class="source-inline">Runner</strong> class where the options are passed is shown in the next <span class="No-Break">code snippet:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.KiotaConsole/Runner.cs</p>
			<pre class="source-code">
internal class Runner
{
  private readonly GamesAPIClient _client;
  private readonly CancellationTokenSource _cancellationTokenSource = new();
  public Runner(IOptions&lt;RunnerOptions&gt; options)
  {
<strong class="bold">    AnonymousAuthenticationProvider authenticationProvider = new();</strong>
<strong class="bold">    HttpClientRequestAdapter adapter = new(authenticationProvider)</strong>
<strong class="bold">    {</strong>
<strong class="bold">      BaseUrl = options.Value.GamesApiUrl ?? throw new </strong>
        <strong class="bold">InvalidOperationException("Could not read GamesApiUrl")</strong>
<strong class="bold">    };</strong>
<strong class="bold">    _client = new GamesAPIClient(adapter);</strong>
  }</pre>
			<p>With the implementation<a id="_idIndexMarker264"/> of the <strong class="source-inline">Runner</strong> constructor, the <strong class="source-inline">GamesAPIClient</strong> class is instantiated. This class receives <strong class="source-inline">HttpClientRequestAdapter</strong>, which has the base address of the service configured. The constructor of <strong class="source-inline">HttpClientRequestAdapter</strong> receives an object implementing the <strong class="source-inline">IAuthenticationProvider</strong> interface. Here, <strong class="source-inline">AnonymousAuthenticationProvider</strong> is used as no authentication is needed. Kiota offers various <span class="No-Break">authentication providers.</span></p>
			<p>Sending a GET request with query parameters to get a list of games, you invoke the <strong class="source-inline">GetAsync</strong> method <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">GamesRequestBuilder</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.KiotaConsole/Runner.cs</p>
			<pre class="source-code">
private async Task ShowGamesAsync()
{
<strong class="bold">  var games = await _client.Games.GetAsync(config =&gt;</strong>
<strong class="bold">  {</strong>
<strong class="bold">    config.QueryParameters.Date = new Date(DateTime.Today);</strong>
<strong class="bold">  }, _cancellationTokenSource.Token);</strong>
  // code removed for brevity</pre>
			<p>The <strong class="source-inline">Games</strong> property returns the generated <strong class="source-inline">GamesRequestBuilder</strong>, which allows us to invoke the <strong class="source-inline">GetAsync</strong> method passing query parameters. Kiota offers its own <strong class="source-inline">Date</strong> type within the <strong class="source-inline">Microsoft.Kiota.Abstractions</strong> namespace, which represents the date-only<a id="_idIndexMarker265"/> part of <strong class="source-inline">DateTime</strong>. Today, .NET offers <strong class="source-inline">DateOnly</strong>, but this type is not available with .NET Standard 2.0, which is also supported <span class="No-Break">by Kiota.</span></p>
			<p>Starting a game is done by sending a POST request, as shown in the <span class="No-Break">next snippet:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.KiotaConsole/Runner.cs</p>
			<pre class="source-code">
private async Task PlayGameAsync()
{
  // code removed for brevity
<strong class="bold">  CreateGameRequest request = new()</strong>
<strong class="bold">  {</strong>
<strong class="bold">    PlayerName = playerName,</strong>
<strong class="bold">    GameType = gameType</strong>
<strong class="bold">  };</strong>
<strong class="bold">  </strong><strong class="bold">var response = await _client.Games.PostAsync(request, </strong>
    <strong class="bold">cancellationToken: _cancellationTokenSource.Token);</strong></pre>
			<p>Starting the game, the user input for the player name and the game type are assigned to the <strong class="source-inline">CreateGameRequest</strong> object. This model type is then passed with the invocation of the <strong class="source-inline">PostAsync</strong> method to start a game and to <span class="No-Break">receive </span><span class="No-Break"><strong class="source-inline">CreateGameResponse</strong></span><span class="No-Break">.</span></p>
			<p>Retrieving a single game passing the game identifier is shown in the next <span class="No-Break">code snippet:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.KiotaConsole/Runner.cs</p>
			<pre class="source-code">
private async Task ShowGameAsync()
{
  // code removed for brevity
<strong class="bold">  var game = await _client.Games[id.ToString()].GetAsync(</strong>
<strong class="bold">    cancellationToken: _cancellationTokenSource.Token);</strong>
  // code removed for brevity</pre>
			<p>Retrieving a single game, updating the game with a HTTP PATCH request, and deleting a game with the HTTP DELETE request all need the game identifier as the query parameter. To use this, Kiota offers an indexer passing <strong class="source-inline">game-id</strong> and continuing with a fluent API. To retrieve a single game, the <strong class="source-inline">GetAsync</strong> method is used. Patching and deleting games are <span class="No-Break">very similar.</span></p>
			<p>With this information, you can use the Kiota-generated code and write the implementation to update the game<a id="_idIndexMarker266"/> by sending a game move with the <span class="No-Break"><strong class="source-inline">PostAsync</strong></span><span class="No-Break"> method.</span></p>
			<p>Using the new client, you can run the game in the same way as <span class="No-Break">shown before!</span></p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor107"/>Summary</h1>
			<p>Working through this chapter, you’ll have a running client console application to run the game. We used the <strong class="source-inline">HttpClient</strong> class to send requests to the games service. To reuse this with different client technologies, we created a library. For efficient use of the <strong class="source-inline">HttpClient</strong> class, you learned to use the <span class="No-Break">HttpClient factory.</span></p>
			<p>Instead of implementing the models on your own, you learned using Microsoft Kiota to create code from the OpenAPI definition. With your own scenarios, you can now decide what’s the best option <span class="No-Break">for you.</span></p>
			<p>Before reading the next chapter, you can reuse this newly created library and create clients of your choice such as Blazor, WinUI, or .NET MAUI. While these frameworks are outside of the scope of this book, you can check <a href="https://github.com/codebreakerapp">https://github.com/codebreakerapp</a> for more <span class="No-Break">clients available.</span></p>
			<p>No matter what client you implement, before diving into the next chapter, it’s well deserved to play one more game—this time with your own created <span class="No-Break">client application.</span></p>
			<p>In the next chapter, the focus will be on the services again; we’ll host the service application (and another service) with a Docker container. This new service will also use the HTTP client created in <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor108"/>Further reading</h1>
			<p>To learn more about the topics discussed in this chapter, you can refer to the <span class="No-Break">following links:</span></p>
			<ul>
				<li><strong class="source-inline">HttpClient</strong> <span class="No-Break">guidelines: </span><span class="No-Break">https://learn.microsoft.com/dotnet/fundamentals/networking/http/httpclient-guidelines</span></li>
				<li>NuGet packages best <span class="No-Break">practices: </span><span class="No-Break">https://learn.microsoft.com/nuget/create-packages/package-authoring-best-practices</span></li>
				<li>The large object heap on Windows <span class="No-Break">systems:</span><span class="No-Break"><span class="P---URL"> </span></span><span class="No-Break">https://learn.microsoft.com/dotnet/standard/garbage-collection/large-object-heap</span></li>
				<li>Microsoft Kiota <span class="No-Break">documentation: </span><a href="https://learn.microsoft.com/openapi/kiota/"><span class="No-Break">https://learn.microsoft.com/openapi/kiota/</span></a></li>
				<li>Kiota GitHub <span class="No-Break">repository: </span><a href="https://github.com/microsoft/kiota"><span class="No-Break">https://github.com/microsoft/kiota</span></a></li>
			</ul>
		</div>
	

		<div id="_idContainer043" class="Content">
			<h1 id="_idParaDest-110" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor109"/>Part 2: Hosting and Deploying</h1>
			<p>This part focuses on essential aspects of hosting and deploying microservices. You will begin by gaining a comprehensive understanding of Docker fundamentals, such as creating Dockerfiles, building Docker images using the .NET CLI, and running Docker containers with .NET Aspire on your development environment. You will then proceed to publish Docker images to the Azure Container Registry, deploy them to the Azure Container Apps environment (based on Kubernetes), and incorporate Azure services like Azure App Configuration and Azure <span class="No-Break">Key Vault.</span></p>
			<p>Throughout this part, you will utilize Azure resources for local application execution, deploy applications to Azure using the Azure Developer CLI, and establish GitHub Actions for automated deployment to Azure upon code updates in the repository. To ensure seamless operation in both on-premises and Azure environments, authentication will be implemented with Azure Active Directory B2C and Microsoft Entra, alongside ASP.NET <span class="No-Break">Core Identities.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B21217_05.xhtml#_idTextAnchor110"><em class="italic">Chapter 5</em></a>, <em class="italic">Containerization of Microservices</em></li>
				<li><a href="B21217_06.xhtml#_idTextAnchor137"><em class="italic">Chapter 6</em></a>, <em class="italic">Microsoft Azure for Hosting Applications</em></li>
				<li><a href="B21217_07.xhtml#_idTextAnchor162"><em class="italic">Chapter 7</em></a><em class="italic">, Flexible Configuration</em></li>
				<li><a href="B21217_08.xhtml#_idTextAnchor183"><em class="italic">Chapter 8</em></a><em class="italic">, CI/CD – Publishing with GitHub Actions</em></li>
				<li><a href="B21217_09.xhtml#_idTextAnchor216"><em class="italic">Chapter 9</em></a><em class="italic">, Authentication and Authorization with Services and Clients</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer044">
			</div>
		</div>
		<div>
			<div id="_idContainer045">
			</div>
		</div>
		<div>
			<div id="_idContainer046">
			</div>
		</div>
		<div>
			<div id="_idContainer047">
			</div>
		</div>
		<div>
			<div id="_idContainer048">
			</div>
		</div>
		<div>
			<div id="_idContainer049" class="Basic-Graphics-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer050" class="Basic-Graphics-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer051">
			</div>
		</div>
		<div>
			<div id="_idContainer052">
			</div>
		</div>
		<div>
			<div id="_idContainer053" class="Basic-Graphics-Frame">
			</div>
		</div>
	</body></html>