- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying and Hosting Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After following a good development process, implementing good practices, and
    covering all the functionalities required for an application, it’s necessary to
    publish it in an environment. For this to be done successfully, it’s important
    to understand various concepts, practices, and application packaging models that
    go beyond the source material. In this chapter, we’ll discuss different approaches
    to hosting and deploying applications, as well as understand concepts related
    to **continuous integration and continuous deployment** ( **CI/CD** ) and containers.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 9 provides a robust configuration system that allows developers
    to manage configurations and behaviors effectively. This chapter will explore
    the importance of application configurations, how to manage them using the configuration
    system, and how to make your applications adaptive at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing to publish your application and host locally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing the solution in a cloud environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Docker principles and how to pack the application in a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the DevOps approach with CI/CD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, the following tools must be present in your development
    environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**An Azure subscription** : In this chapter, we’ll be creating resources in
    Microsoft Azure. To do this, if you haven’t already, you will need to have an
    Azure subscription so that you can access the platform. You can sign up for a
    subscription with limited credits to learn about the concepts presented in this
    chapter at [https://azure.microsoft.com/en-us/free](https://azure.microsoft.com/en-us/free)
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A Docker Hub account** : You will need to create an account on the Docker
    Hub website at [https://hub.docker.com](https://hub.docker.com) .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Azure Tools extension** : You will need to install the Azure Tools extension
    for Visual Studio Code from [https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-node-azure-pack](https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-node-azure-pack)
    . Once it’s been installed, log in with your Azure credentials.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code examples for this chapter can be found in this book’s GitHub repository:
    [https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter10](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter10)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing to publish your application and host locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Publishing an application is a natural process in the software development life
    cycle. After development and testing, the next step is to make the application
    available to users. This involves creating a deployable version of the application
    and configuring it in an environment where it can be accessed and used.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s understand the details of publishing applications while following various
    strategies, from manual to automated ones, using CI/CD. But before we do this,
    let’s understand some of the fundamentals, such as the importance of the publishing
    process.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of the publishing process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The publishing process transforms your application from source code into a deployable
    format. This process ensures that all dependencies, configurations, and compiled
    code are packaged together, making it easier to deploy and run the application
    in different environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The publishing process in ASP.NET Core 9 involves three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Restoring the package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compiling the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generating a publishable package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The publication package that’s generated may vary, depending on the type of
    application that’s developed. It may contain different files, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The application’s DLL files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party dependencies and libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static files (for example, JavaScript, CSS, and images)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration files (for example, **appsettings.json** )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executables for standalone deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand how this process works, follow the instructions provided in the
    *Technical requirements* section to download the example application from this
    book’s GitHub repository. This will be used as the basis for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s understand how to generate publishing packages.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a publishing package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve been working with the .NET platform CLI tool extensively throughout this
    book to create and run applications. The CLI tool also has a specific command
    for generating publishing packages for ASP.NET Core 9 projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **publish** command provides various options that allow us to configure
    the publication package’s output, as listed in *Table 10.1* :'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Option** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **<** **PROJECT>** | Specifies the project file to operate on. Defaults to
    the current directory if not specified. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **-** **c** , **--configuration** | Defines the build configuration ( **Debug**
    or **Release** ). Defaults to **Debug** . |'
  prefs: []
  type: TYPE_TB
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **-** **f** ,**--** **framework** | Specifies the target framework – for
    example, **net8.0** . |'
  prefs: []
  type: TYPE_TB
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **--** **runtime** | Publishes the application for a specific runtime (for
    example, **win-x64** , **linux-x64** , or **osx-x64** ). |'
  prefs: []
  type: TYPE_TB
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **-** **o** , **--output** | Specifies the output directory for the published
    files. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **--** **self-contained** | Publishes the application as a self-contained
    deployment, including the . NET runtime. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **--** **no-restore** | Disables the ability to restore project dependencies
    during the publish operation. Assumes restoration has already been done. It’s
    useful during CI/CD pipelines. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **--** **manifest** | Specifies one or more target manifests to calculate
    the set of packages to include in the published output. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **--** **version-suffix** | Sets the **$(VersionSuffix)** property value
    to use when building the project. Useful for prerelease versions. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Table 10.1 – dotnet publish CLI tool options
  prefs: []
  type: TYPE_NORMAL
- en: The use of each option will depend on each scenario. In our context, we’ll use
    the **<PROJECT>** , **-c** , **-o** , and, when necessary, **--** **no-restore**
    options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s generate a publishing package for the **UrlShortener** application.
    To do this, open your terminal or bash, access the previously downloaded application
    directory, and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will generate the **publish** package in the **published**
    folder. However, it’s important to understand the **-c** parameter in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **-c** option specifies the build configuration, and there are typically
    two main configurations: **Debug** and **Release** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Debug** configuration includes additional debug information and is optimized
    for debugging. When running the project locally with the **dotnet run** command,
    the default configuration is **Debug** , which allows the debugging process to
    be carried out.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Release** configuration is optimized for performance and does not include
    debug information. It’s typically used to deploy the application to production
    environments.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When accessing the **published** folder, we have to simulate the directory/file
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, there are several **.dll** files, which are the dependencies
    that the application uses, in addition to static files such as **wwwroot** and
    configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: The contents of this folder are exactly what should be published in an environment,
    be it locally or via a cloud provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'By accessing the **published** directory through the terminal and executing
    the following command, it’s possible to run the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The **UrlShorterner.dll** file is the executable for an ASP.NET Core 9 application.
    It’s possible to run the application through the **.dll** file on your development
    machine since the .NET SDK is installed. The SDK must not be installed on servers
    that will run the applications. For this, you only need to install **.** **NET
    Runtime** .
  prefs: []
  type: TYPE_NORMAL
- en: .NET Runtime
  prefs: []
  type: TYPE_NORMAL
- en: .NET Runtime is a software framework developed by Microsoft that provides a
    managed execution environment for running .NET applications. It includes the components
    needed to run .NET programs, manage memory, handle exceptions, and collect garbage.
    .NET Runtime is typically installed on servers and machines that run specific
    .NET applications. Unlike the .NET SDK, .NET Runtime has features for running
    applications rather than building and developing them. To learn more about .NET
    Runtime, go to [https://learn.microsoft.com/en-us/dotnet/core/introduction](https://learn.microsoft.com/en-us/dotnet/core/introduction)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'The .NET platform and ASP.NET Core 9 are portable, which means they can be
    run on different operating systems that have the SDK or .NET Runtime installed.
    *Table 10.2* shows the application servers that can be used in each of the most
    important operating systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operating System** | **Prerequisites** |'
  prefs: []
  type: TYPE_TB
- en: '| Linux |'
  prefs: []
  type: TYPE_TB
- en: .NET SDK/Runtime, Kestrel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional: Nginx/Apache, Hosting bundle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| macOS |'
  prefs: []
  type: TYPE_TB
- en: .NET SDK/Runtime, Kestrel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional: Nginx/Apache'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Windows |'
  prefs: []
  type: TYPE_TB
- en: .NET SDK/Runtime, Kestrel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional: IIS, NGINX, HTTP.sys, ASP.NET Core Hosting bundle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Table 10.2 – Web server options for ASP.NET Core 9 applications
  prefs: []
  type: TYPE_NORMAL
- en: Generating publication packages using the CLI tool is straightforward. We’ll
    follow this process while automating via CI/CD, something we’ll cover in the *Understanding
    the DevOps approach with* *CI/CD* section.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve learned how to generate publishing packages, it’s time to learn
    how to publish them in a cloud environment.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing the solution in a cloud environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The advantage of developing modern applications with ASP.NET Core 9 goes beyond
    the ability to use implementation best practices – it also encompasses the need
    to deliver high-quality solutions to application users.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve learned about the importance of using various features of the
    .NET platform, such as using the .NET CLI to compile applications and install
    support tools such as Entity Framework Core. We’ve also learned about the process
    of generating publishable packages that can be run both locally and in any other
    environment that uses . NET Runtime.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, it’s impossible not to work in a cloud environment.
    This offers us benefits such as elasticity, availability, security, and many other
    features that simplify the process of deploying, maintaining, and evolving applications
    through the continuous process of delivering value.
  prefs: []
  type: TYPE_NORMAL
- en: To learn how to publish the solution in a cloud environment, we’ll use Azure
    as our cloud provider.
  prefs: []
  type: TYPE_NORMAL
- en: Moving an ASP.NET Core 9 application to Azure allows developers to benefit from
    the dynamic capabilities provided by such a cloud provider while focusing on the
    application context and business objectives. Azure, through its diverse resources
    and services, allows applications to handle varied workloads, remain accessible
    to users, and stay protected against security threats.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the **UrlShortener** application that we worked on previously and in
    conjunction with the process of generating publishable packages, we’ll implement
    the benefits of Azure and publish this application in a cloud environment.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Azure app services and database resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Azure environment provides different types of resources for publishing applications,
    at different service levels and with varying publishing approaches.
  prefs: []
  type: TYPE_NORMAL
- en: For this application, we’ll use a resource called **App Service** , a **Platform-as-a-Service**
    ( **PaaS** ) offering provided by Azure that allows us to focus on our applications.
    App Service provides a great application server while also supplying us with a
    URL to access the published application.
  prefs: []
  type: TYPE_NORMAL
- en: You must have prepared your environment based on the information provided in
    the *Technical* *requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: Application services and PaaS
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure App Service is a fully managed PaaS that allows developers to build,
    deploy, and scale web applications, mobile backends, and RESTful APIs in the programming
    language of their choice, without the need for infrastructure management. App
    Service provides a prepared server, providing the runtime needed to run your applications.
    The PaaS approach is a cloud computing model that provides a complete development
    and deployment environment in the cloud, freeing developers from the need to deal
    with infrastructure. For more details, see the Azure App Service documentation:
    [https://docs.microsoft.com/en-us/azure/app-service/](https://docs.microsoft.com/en-us/azure/app-service/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Our goal will not be to exhaust all resource options available in the Azure
    environment since a separate book dedicated to this subject would be needed.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we’ll focus on publishing the **UrlShortener** application while using
    Azure App Service as the web host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to publish the application:'
  prefs: []
  type: TYPE_NORMAL
- en: Access the Azure portal ( [https://portal.azure.com](https://portal.azure.com)
    ).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the main screen, click on the **Create a resource** button, as shown in
    *Figure 10* *.1* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Creating a new Azure resource](img/B21788_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Creating a new Azure resource
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, select **Create** under the **Web App** resource, as shown in *Figure
    10* *.2* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Creating a new Web App resource](img/B21788_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Creating a new Web App resource
  prefs: []
  type: TYPE_NORMAL
- en: 'On the **Basics creation** screen of the new **Web App** resource, fill in
    the information provided in *Table 10.3* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Parameter** | **Value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Subscription** | Select your subscription. | A subscription is necessary
    to onboard the resources and related costs. |'
  prefs: []
  type: TYPE_TB
- en: '| **Resource Group** | Here, the value is **rg-aspnetcore8** . If this resource
    group doesn’t exist, click on **Create new link** below the **Resource Group**
    field and create it. | The resource is a logical group of resources in Azure.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Name** | **urlshortener.<your** **last name>** . | This parameter will
    be the URL of your application. Please keep it unique. |'
  prefs: []
  type: TYPE_TB
- en: '| **Publish** | **Code** . | App Service has different ways to host and publish
    applications. In this case, we’re using the **Code** option because we’ll publish
    the generated package. |'
  prefs: []
  type: TYPE_TB
- en: '| **Runtime stack** | **.NET** **9 (LTS)** . | This parameter defines the type
    of application that will be hosted on App Service. It supports .NET, Node.js,
    Java, PHP, and Python. |'
  prefs: []
  type: TYPE_TB
- en: '| **Operational System** | Linux. | Linux is a good option for many use cases.
    However, for this exercise, you can select Windows as well. The definition of
    the operating system depends on the requirements of the application. |'
  prefs: []
  type: TYPE_TB
- en: '| **Region** | **EastUS 2** | The region where App Service will be hosted.
    We’re using **East US 2** because the database we’ll be creating is not available
    in the East US region. |'
  prefs: []
  type: TYPE_TB
- en: '| **Linux Pan** | Leave as-is. | We’ll be creating a new service plan to host
    the application. The service plan is an important component of App Service. Depending
    on the pricing plan, the service plan can host more than one application. |'
  prefs: []
  type: TYPE_TB
- en: '| **Pricing plan** | **Basic B1** . | The **Basic B1** option is enough for
    this example. Keep in mind that if you select a different Pricing plan, you can
    be charged higher costs. |'
  prefs: []
  type: TYPE_TB
- en: '| **Zone redundancy** | Disabled. | This parameter is used in production environments
    where applications require a high-availability configuration. |'
  prefs: []
  type: TYPE_TB
- en: Table 10.3 – Basic parameters of the new Web App resource
  prefs: []
  type: TYPE_NORMAL
- en: '5. Click on the **Next: Database >** button.'
  prefs: []
  type: TYPE_NORMAL
- en: '6. Select the **Create a database** option and fill in the parameters as per
    *Figure 10* *.3* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Database server configuration](img/B21788_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Database server configuration
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, we’re configuring a database, which is necessary for the **URLShortener**
    application. We’ll use the Azure SQL Server resource since it provides a server
    where you can host different databases. For this example, we’re using just one
    database. However, if desired, other databases can be added later.
  prefs: []
  type: TYPE_NORMAL
- en: 7. Now, click on the **Monitor + Secure** tab and set the **Enable Application
    Insights** option to **No** .
  prefs: []
  type: TYPE_NORMAL
- en: This option aims to create a monitoring resource for the application. This is
    a best practice, especially for production resources. Therefore, at this stage,
    the objective is to publish the application; there’s no need for monitoring, something
    that can be added later.
  prefs: []
  type: TYPE_NORMAL
- en: 8. Next, click **Review and Create** . Then, click **Create** and wait for the
    resource to be created.
  prefs: []
  type: TYPE_NORMAL
- en: '9. On the review screen, in the **Database** section, you’ll see username and
    password information, as shown in *Figure 10* *.4* . Copy those details and keep
    them handy; we’ll need the password later to configure the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Database credentials](img/B21788_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Database credentials
  prefs: []
  type: TYPE_NORMAL
- en: 10. Finally, click **Create** and wait for the resource to be created.
  prefs: []
  type: TYPE_NORMAL
- en: '11. Once the resource has been created, click the **Go to resource** button,
    as shown in *Figure 10* *.5* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5: Resource created screen](img/B21788_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Resource created screen'
  prefs: []
  type: TYPE_NORMAL
- en: You will be redirected to the previously created **App Service** settings summary
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 10* *.6* , you’ll be able to see the **Default domain**
    URL that’s been made available so that you can access the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Default domain URL of the created application services](img/B21788_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Default domain URL of the created application services
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Default domain** URL is automatically created by Azure, according to
    the parameters defined when creating the application services and can be customized
    with a custom domain. We’ll keep the URL available and in operation. Upon clicking
    on the URL, you’ll be redirected to a page containing information similar to what’s
    shown in *Figure 10* *.7* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Default website content of the new application services](img/B21788_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Default website content of the new application services
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the server is up and running, but we must publish the application
    on Azure. However, before publishing the application, let’s configure the database.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Azure SQL Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While creating our application services, other resources were created, such
    as the database server and the database.
  prefs: []
  type: TYPE_NORMAL
- en: We need to configure the database so that we have the table we used in the application
    to persist the URLs.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the Entity Framework Core tool to update the database in the same
    way we did it locally. However, the database service that’s automatically created
    by Azure is publicly inaccessible for security reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we must make some configuration changes in advance so that we can
    manipulate the database. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the previously created resource group – that is, **rg-aspnetcore8** .
    You will be able to see a list of created resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for the **UrlshortenerDB** resource and access it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, in the **Settings** menu group, click **Connection Strings** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The connection string should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the **Password={your_password}** parameter. Replace this parameter with
    the password that you copied when you were creating your application services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the connection string from the **ADO.NET (SQL** **Authentication)** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, open the **appsettings.json** file of the **URLShortener** application
    and change the **DefaultConnection** property to the connection string you copied
    previously. The result will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the **appsettings.json** file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let’s configure access to the database server. To do this, go back to the
    **rg-aspnetcore8** resource group and click on the **urlshortener-db-server<your
    last** **name>** resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the main menu, go to **Security** | **Networking** and click on the **Add
    your client IPv4 address** option, as shown in *Figure 10* *.8* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Adding a firewall rule to access the private database of an
    IPv4 address](img/B21788_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Adding a firewall rule to access the private database of an IPv4
    address
  prefs: []
  type: TYPE_NORMAL
- en: This configuration will create a rule so that the database is only accessible
    via its current IP. Keep in mind that if your IP changes, you will have to perform
    these steps again to add the new IP.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, click **Save** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this, we’ve configured the application for the connection string of the
    database hosted in Azure and added a firewall rule so that the database can be
    accessed through our current IP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to update the database. To do this, access your operating system’s
    terminal and navigate to the **URLShortener** project directory. Then, run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the process to complete. To check whether the table was created correctly,
    in the Azure portal ( [https://portal.azure.com](https://portal.azure.com) ),
    access the **rg-aspnetcore9** resource group, then access the **UrlShortenerDB**
    resource. Click on the **Query Editor** menu and access the database with the
    credentials that were provided when you were creating the application service.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 10* *.9* , the new table has been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – The database tables that were created using Entity Framework
    Core migrations](img/B21788_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – The database tables that were created using Entity Framework Core
    migrations
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the benefits of using migrations through Entity Framework Core.
    By doing this, it’s possible to apply changes to a local database or server and
    maintain compliance with the application code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the database has been configured, it’s time to publish the application.
    We’ll do this through Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing an application with Visual Studio Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With all the prerequisites for hosting the application in Azure configured,
    it’s time to publish the application.
  prefs: []
  type: TYPE_NORMAL
- en: The process of publishing via Visual Studio Code or even with Visual Studio
    is quite straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Technical requirements* section, it was suggested that you install and
    configure the Azure Tools extension [(https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-node-azure-pack](https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-node-azure-pack)
    ). This extension makes the manual publishing process easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to publish the application version in the application services
    we created previously:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Access the **UrlShortener** application directory and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, click on the Azure Tools extension icon in Visual Studio Code, as shown
    in *Figure 10* *.10* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Azure Tools in Visual Studio Code](img/B21788_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – Azure Tools in Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: A list of subscriptions that are available to your user will be displayed. By
    expanding the subscription, we’ll be able to see the App Service resource and
    the resource that’s been created for the **UrlShortener** application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, right-click on the **urlshortener-<your last name>** application and select
    the **Deploy to Web App…** option, as shown in *Figure 10* *.11* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Deploying a web app using the Azure Tools extensions in Visual
    Studio Code](img/B21788_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – Deploying a web app using the Azure Tools extensions in Visual
    Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: You’ll be asked for some configuration details so that you can deploy. Just
    confirm the options that are provided and wait for the deployment process to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the publication process is complete, a notification similar to the one
    shown in *Figure 10* *.12* will be displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.12 – A notification stating that application deployment has been
    completed](img/B21788_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – A notification stating that application deployment has been completed
  prefs: []
  type: TYPE_NORMAL
- en: 'You can navigate to the published website by clicking the **Browse Website**
    button. You’ll see a result similar to the one shown in *Figure 10* *.13* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.13 – The URL Shortener application running on Azure](img/B21788_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – The URL Shortener application running on Azure
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can use the application that contains the short URL functionality directly
    in your Azure environment publicly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Azure Tools extension automates the process of publishing new application
    versions by running the following processes in the background:'
  prefs: []
  type: TYPE_NORMAL
- en: Restoring packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a publishing package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compressing the publishing package in **.** **zip** format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to the Azure environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the ZIP file containing the publication package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting the ZIP file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These steps are performed every time you choose to deploy using the Azure Tools
    extension. We’ll learn about another way to publish packages in a C/ICD model
    in the *Understanding DevOps approach with CI/CD* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Hosting solutions in cloud environments is a necessary activity today and several
    resources can help us with this task.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of each hosting resource and service layer will depend on the
    application requirements, as well as the team’s level of knowledge. There are
    cases where we can use strategies that allow us to host our applications in different
    environments, in a way that’s agnostic to the specific resources of cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, a strategy that’s often used in cloud-native applications is
    the containers strategy. We’ll learn about this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Docker principles and how to package the application in a
    container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, using a container strategy has become essential, especially for cloud-native
    applications. Containers provide a consistent environment for development, testing,
    and deployment, ensuring applications run smoothly regardless of where they’re
    deployed. When using containers, we practically have everything needed for the
    application to run in a given environment, with no need to install additional
    packages or runtimes.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have consistency, which is crucial for cloud environments such
    as Azure or any other cloud provider as they offer robust services to manage and
    scale containerized applications. As an analogy, the container strategy helps
    combat the behavior that generates the statement “ *It works on* *my machine.*
    ”
  prefs: []
  type: TYPE_NORMAL
- en: This phrase is true since the development environment has everything necessary
    to run an application. However, being agile in delivering value and having no
    dependencies for running applications, regardless of the environment, is one of
    the great advantages of containers. Before we create a container, let’s understand
    what they are.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what a container is
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A container is a self-contained executable software package that includes everything
    needed to run a piece of software. Containers are isolated from each other and
    the host system, providing a consistent runtime environment. This isolation ensures
    that the application behaves the same regardless of the environment in which it
    runs.
  prefs: []
  type: TYPE_NORMAL
- en: Containers provide a type of virtualization that’s different from what’s provided
    by traditional **virtual** **machines** ( **VMs** ).
  prefs: []
  type: TYPE_NORMAL
- en: VMs
  prefs: []
  type: TYPE_NORMAL
- en: VMs are software emulations of physical computers. Each VM runs a complete operating
    system, including its own kernel, and simulates all the hardware that the operating
    system requires. VMs run on a hypervisor, which manages multiple VMs on a single
    physical host.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10* *.14* shows some of the differences between containers and VMs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14 – Differences between containers and VMs](img/B21788_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – Differences between containers and VMs
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, containers don’t depend on a complete operating system for their
    execution, only on a runtime that shares a machine’s resources, such as networking
    and processing. However, they are executed independently and in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Containers offer several benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Portability** : Containers encapsulate all dependencies, making it easy to
    move applications between different environments without compatibility issues
    occurring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency** : They ensure that applications run consistently across development,
    testing, and production environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability** : They can easily be scaled up or down to handle varying loads,
    making them ideal for cloud environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficiency** : Containers share the kernel and host system resources efficiently,
    resulting in lower overhead compared to traditional VMs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be able to run a container, it’s necessary to use a runtime to manage it,
    as is the case with ASP.NET Core 9 applications. The most famous container runtime
    is **Docker** . We’ll understand its fundamentals in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Docker fundamentals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker is an open source platform that automates the process of deploying, scaling,
    and managing containerized applications, providing a simple and powerful way to
    build, ship, and operate containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker provides three components for managing containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Engine** : The runtime that manages containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker CLI** : The command-line interface used to interact with Docker'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Hub** : A cloud-based registry service for sharing and storing Docker
    images, similar to how we have GitHub for managing source code repositories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Through these tools, Docker provides mechanisms that allow us to manipulate
    the components that involve the container development strategy. In this case,
    containers have the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Images** : An image can be compared to a photo of a current version of your
    application, including everything needed to run your application. Images are the
    basis of containers and are created using a **Dockerfile** , which contains a
    set of instructions for building the image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Containers** : A container is a running instance of an image. We can relate
    an image to a class and a container to an instance of this class. Containers are
    created from images and run on Docker Engine. Each container is isolated from
    the others and has its own filesystem, CPU, memory, and process space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dockerfile** : A Dockerfile is a text document that contains a series of
    instructions on how to build a Docker image. It specifies the base image to use,
    the application code, dependencies, and any commands required to configure the
    environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container registry** : The container registry is a repository for storing
    and distributing images. Docker Hub is a popular public registry, though there
    are private registries such as Azure Container Registry available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The relationship between Docker components and their container structure is
    shown in *Figure 10* *.15* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15 – The relationship between Docker and its container components](img/B21788_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 – The relationship between Docker and its container components
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, Docker is the most used container solution, but there
    are other types of runtimes available that implement the same concepts presented
    here.
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 10.4* explains some of the container runtimes that are available on
    the market:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Runtime** | **Description** | **Website** |'
  prefs: []
  type: TYPE_TB
- en: '| **containerd** | The core runtime used by Docker and Kubernetes. It focuses
    on simplicity and portability. | [https://containerd.io/](https://containerd.io/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **CRI-O** | A lightweight runtime for Kubernetes that implements the Kubernetes
    **Container Runtime** **Interface** ( **CRI** ). | [https://cri-o.io/](https://cri-o.io/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **runc** | A CLI tool for spawning and running containers according to the
    OCI specification. | [https://github.com/opencontainers/runc](https://github.com/opencontainers/runc)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Podman** | A daemonless container engine that’s compatible with Docker.
    | [https://podman.io/](https://podman.io/) |'
  prefs: []
  type: TYPE_TB
- en: '| **LXC** | A traditional container runtime that provides a VM-like experience.
    | [https://linuxcontainers.org/](https://linuxcontainers.org/) |'
  prefs: []
  type: TYPE_TB
- en: '| **Kata** **Containers** | This runtime combines the security of VMs with
    the speed of containers by running lightweight VMs. | [https://katacontainers.io/](https://katacontainers.io/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Rancher** | Rancher Desktop provides container and Kubernetes management.
    | [https://rancherdesktop.io/](https://rancherdesktop.io/) |'
  prefs: []
  type: TYPE_TB
- en: Table 10.4 – Container runtime options
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, there are several options for running containers in environments
    and the use of each solution will depend on the requirements of each application
    and organization. However, it’s worth remembering that containers include images,
    other containers, a Dockerfile, and a container registry, all of which are used
    by runtimes.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can package the **UrlShortener** application in a container.
  prefs: []
  type: TYPE_NORMAL
- en: Packing the UrlShortener application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker Engine provides us with different types of resources and commands to
    manage containers. We’ll focus on the packaging process for the **UrlShortener**
    application and use the main features of a container, which include images, containers,
    and a container registry.
  prefs: []
  type: TYPE_NORMAL
- en: Before proceeding, make sure you’ve installed Docker Engine, as per the *Technical*
    *requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our packaging process will take place through the following flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16 – Container creation flow](img/B21788_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16 – Container creation flow
  prefs: []
  type: TYPE_NORMAL
- en: 'In Visual Studio Code, be sure to open the **UrlShortener** application and
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the root of the directory, create a file called **Dockerfile** . This file
    has no extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following content to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The preceding code is a bit long and seems complicated, so let’s understand
    each line of our **Dockerfile** :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Base image and initial configuration** : At this stage, we’re configuring
    a base image that contains the default configurations for running an ASP.NET Core
    9 application.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base** : This line specifies
    the base image of the final container, which uses the ASP.NET Core version 8.0
    runtime image from the **Microsoft Container Registry** ( **MCR** ). All Docker
    images start with a reference to a base image. The **AS base** tag names this
    stage **base** .'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WORKDIR /app** : This line sets the working directory within the container
    to **/app** . All subsequent commands will be executed in this directory.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EXPOSE 8080** : This line tells Docker that the container will listen on
    port **8080** at runtime. This is used for documentation purposes, as well as
    for configuring port mapping when running the container.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build stage** : The build stage will be an image that’s responsible for compiling
    the application. It will use an image that already has the .NET SDK installed
    as a base.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build** : This line uses the .NET
    SDK image version 8.0 from MCR to build the application. The **AS build** tag
    names this stage **build** .'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WORKDIR /src** : Sets the working directory to **/src** .'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**COPY ["UrlShortener.csproj", "MyApp/"]** : Copies the **UrlShortener.csproj**
    project file to the **MyApp/** directory in the container.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RUN dotnet restore "MyApp/UrlShortener.csproj"** : Restores the project dependencies
    specified in the **UrlShortener.csproj** file.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**COPY . ./MyApp** : Copies all the files from the current directory on the
    host to the **MyApp** directory in the container.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WORKDIR "/src/MyApp"** : Sets the working directory to **/src/MyApp** .'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RUN dotnet build "UrlShortener.csproj" -c Release -o /app/build** : Builds
    the project in **Release** configuration and outputs the build results to the
    **/** **app/build** directory.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Publish stage** : At this stage, the publication package is generated.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FROM build AS publish** : This line uses the build stage as the base for
    the publish stage.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RUN dotnet publish "UrlShortener.csproj" -c Release -o /app/publish** : This
    line publishes the project, which means it compiles the application, copies all
    the necessary files, and produces a deployable version of the application in the
    **/** **app/publish** directory.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Final stage** : The final stage takes the package that was generated by the
    previous configuration and runs it on an image containing the settings from the
    base image.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FROM base AS final** : Uses the base stage as the base for the final image.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WORKDIR /app** : Sets the working directory to **/app** .'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**COPY --from=publish /app/publish .** : Copies the contents of the **/app/publish**
    directory from the publish stage to the current directory ( **/app** ) in the
    final stage.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ENTRYPOINT ["dotnet", "UrlShortener.dll"]** : Sets the entry point for the
    container so that it can run the **dotnet UrlShortener.dll** command, which starts
    the ASP.NET Core application.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As explained previously, the code available in the **Dockerfile** file uses
    various stages to generate an image of the application.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker build stage is a phase of the Docker multi-stage build process where
    the application is compiled, dependencies are restored, and all the required files
    are prepared for deployment. In a multi-stage build, each stage can use a different
    base image and environment to perform specific tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The build stage typically uses a development image or SDK to compile and build
    the application, producing output artifacts that can be used in subsequent stages.
    This approach helps you create a clean, optimized final image that only contains
    the runtime dependencies and the application itself, without build tools or intermediate
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Docker multi-stage build
  prefs: []
  type: TYPE_NORMAL
- en: Docker’s multi-stage build process allows you to generate optimized images and
    uses container technology to compile and generate publishable applications. To
    learn more about this, go to [https://docs.docker.com/build/building/multi-stage/](https://docs.docker.com/build/building/multi-stage/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'When observing the flow of the multi-stage approach, we can automate the process
    of generating a Docker image by going through the package creation steps that
    we learned about previously. It’s possible to generate a Docker image without
    using the multi-stage process. In this case, it’s necessary to compile and generate
    the application package manually and, later, just copy the generated package into
    the image. This results in a **Dockerfile** file that looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: By doing this, the **Dockerfile** file will certainly be simpler. However, before
    generating the image, it’s necessary to execute the **docker build** and **docker
    publish** commands so that we can generate the application package that will be
    copied to the image.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the principles of generating a **Dockerfile** file, it’s
    time to generate an image.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a container image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To generate a Docker image, you need to run the **docker build** command. This
    command will execute the code described in the **Dockerfile** file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, open your terminal and, in the **UrlShortener** application directory,
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command compiles the image, which will be tagged, using the **-t**
    parameter, with the name **urlshortener:1.0** . The image tag works as the name
    of the image to be generated as is in **<** **name_lower_case>[:<version>]** form.
  prefs: []
  type: TYPE_NORMAL
- en: The version is optional. If it isn’t entered, Docker will use the latest version.
    However, it’s good practice to define a version for the image.
  prefs: []
  type: TYPE_NORMAL
- en: After defining the image tag, the context where the compilation process will
    be executed is informed of this. The context is defined by the **.** parameter,
    which indicates the local directory that contains the **Dockerfile** file. It’s
    important to keep in mind that the **build** command needs to know where the **Dockerfile**
    file is located so that it can be executed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the image generation process has run, run the following command to see
    the list of images on your computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing the preceding command, you’ll be able to view the list of images
    in your local container registry, as shown in *Figure 10* *.17* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17 – List of Docker images in the local container registry](img/B21788_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.17 – List of Docker images in the local container registry
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, there are three images:'
  prefs: []
  type: TYPE_NORMAL
- en: '**localhost/urlshortener:1.0** : This is the previously generated image that
    contains the application. The **localhost/** prefix before the image’s name represents
    the owner of the image – in this case, the local registry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mcr.microsoft.com/dotnet/sdk:8.0** and **mcr.microsoft.com/dotnet/aspnet:8.0**
    : These images represent the .NET SDK and .NET Runtime for compiling and running
    the application in a container, respectively. These images are automatically downloaded
    from Docker Hub. Note the **mcr.microsoft.com/dotnet** prefix, which refers to
    the owner of the images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, *Figure 10* *.17* shows the size of the images in MB. The application
    image is smaller than the other two. Containers must be optimized as they could
    affect the performance and startup of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Container images should be considered immutable – that is, each version is unique.
    This means that if there’s any change in the application, we must generate a new
    image with a different tag. It’s a best practice to follow this convention as
    it allows you to have control over the containers running on a server.
  prefs: []
  type: TYPE_NORMAL
- en: With the image generated, it’s time to run a container and test its operation.
  prefs: []
  type: TYPE_NORMAL
- en: Running a Docker container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run the Docker container from the previously generated image, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look at this command:'
  prefs: []
  type: TYPE_NORMAL
- en: It runs a new container from the **localhost/urlshortener:1.0** image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It runs the container in detached mode ( **-d** ), allowing it to run in the
    background.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It maps port **8899** on the host to port **8080** inside the container ( **-p
    8899:8080** ). This makes the application run on port **8080** inside the container
    that’s accessible via port **8899** on the host machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output of the successfully executed command will be a key that represents
    the container’s ID. To check whether the container is running, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'An output similar to the one shown in *Figure 10* *.18* will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.18 – Running containers](img/B21788_10_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.18 – Running containers
  prefs: []
  type: TYPE_NORMAL
- en: Now, open a browser of your choice and go to [**http://localhost:8899**](http://localhost:8899)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Connection string
  prefs: []
  type: TYPE_NORMAL
- en: 'If the application’s connection string has been configured for the database
    in Azure and you get a connection error when you access the application through
    the container, make sure you add your IP address, as presented in the *Configuring
    Azure SQL Server* section. You can also change the connection string by using
    environment variables in conjunction with the **docker run** command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**docker run -d -p 8899:8080 -e ConnectionStrings__DefaultConnection="Server=.;Database=UrlShortenerDB;user
    id=sa;** **password=P4sword123;Encrypt=False;" localhost/urlshortener:1.0**'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding command contains the **-e <** **EnvironmentVariable>=<value>**
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the **docker run** command several times for the same image while
    changing the host port on which the container will run. For example, the following
    commands will run two new containers of the same application on ports **9900**
    and **9910** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Currently, three different containers contain the same application running in
    your local environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish running the containers, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can obtain the container ID from the list of running containers by running
    the **docker** **ps** command.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Docker principles and how to package your ASP.NET Core 9 application
    in a container is very important for the modern software development model. Containers
    offer consistency, portability, and efficiency, making them ideal for cloud-native
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve learned, the use of containers is related to components such as images,
    which are generated according to the runtime and the published application. Later,
    the image that’s been used is made available through a public or private container
    registry. Finally, we can run different instances of an application that’s been
    published in a container registry through the use of an image, thus generating
    an executed application called a container.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll learn how to automate the process of publishing applications in
    a cloud environment.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the DevOps approach with CI/CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s common to talk about the DevOps culture in depth. Despite the term being
    a combination of two specific areas – that is, **development** ( **Dev** ) and
    **operations** ( **Ops** ) – this approach goes far beyond these two teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'The DevOps culture connects processes, people, and tools, all of which work
    together to generate value and provide continuous learning in the face of constant
    market needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.19 – The DevOps culture cycle](img/B21788_10_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.19 – The DevOps culture cycle
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10* *.19* represents this continuous flow of collaboration in different
    aspects involving the DevOps culture.'
  prefs: []
  type: TYPE_NORMAL
- en: Among the practices suggested in the DevOps culture, we have the CI/CD process,
    making development teams agile, eliminating dependencies, minimizing errors, and
    enabling continuous evolution and learning in teams.
  prefs: []
  type: TYPE_NORMAL
- en: CI and CD processes are commonly called pipelines because they represent a set
    of sequential instructions that allow new pipes or tasks to be added and reorganized
    in this flow.
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at the pipeline development model, let’s understand the fundamentals
    of CI and CD.
  prefs: []
  type: TYPE_NORMAL
- en: CI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CI is a development practice where developers regularly merge their code changes
    into a central repository, after which there are automated builds and testing.
  prefs: []
  type: TYPE_NORMAL
- en: Development teams are distributed remotely and require a central repository,
    usually based on Git. When new code is developed and changed, it’s synchronized
    or integrated into the local repository.
  prefs: []
  type: TYPE_NORMAL
- en: This process occurs asynchronously – that is, each developer synchronizes their
    code version at a different time to other developers. Then, the CI pipeline is
    executed, where the main objective is to detect integration problems in advance
    and then frequently integrate code changes and check them through automated tests.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10* *.20* shows a basic CI pipeline scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.20 – The CI pipeline flow](img/B21788_10_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.20 – The CI pipeline flow
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, *Figure 10* *.20* presents a flow that we’re already used to
    executing manually. Automating these processes brings several benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Early error detection** : By integrating code changes frequently, CI helps
    us identify and resolve errors and integration issues early in the development
    process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved code quality** : Automated tests are run on each integration, ensuring
    that code changes don’t break existing functionality and maintain code quality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Faster feedback cycle** : Developers receive immediate feedback on their
    code changes, allowing them to fix issues immediately and iterate quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved collaboration** : CI promotes collaboration between team members
    by integrating code changes from different developers into a shared repository,
    ensuring everyone is working with the latest code base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another great benefit of the CI process is the practice of performing a code
    review, which allows team members to analyze the code to be integrated and carry
    out reviews of good practices and whether unit tests have been written, for example.
  prefs: []
  type: TYPE_NORMAL
- en: The code review approach generates constant learning. However, despite being
    done manually, it’s extremely powerful for the evolution of teams and has support
    from CI so that no revisions are made to code that presents compilation errors
    or test failures. It’s a constant flow of learning, allowing teams to be proactive
    before they publish any version of an application to production environments.
  prefs: []
  type: TYPE_NORMAL
- en: Code review
  prefs: []
  type: TYPE_NORMAL
- en: 'A code review is a human review process in which one or more developers review
    code written by another developer. To learn more about this approach, take a look
    at the following GitHub article: [https://github.com/resources/articles/software-development/how-to-improve-code-with-code-reviews](https://github.com/resources/articles/software-development/how-to-improve-code-with-code-reviews)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: The CI pipeline is of great importance in the development flow as its main objective
    is to prepare an application package that follows the quality requirements defined
    by the development and business teams. As output, it delivers this package to
    the CD process, which executes the procedures for implementing this in one or
    more environments.
  prefs: []
  type: TYPE_NORMAL
- en: CD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CD is the next step after CI and automates the process of deploying applications
    to production environments.
  prefs: []
  type: TYPE_NORMAL
- en: The CD pipeline simulates what happens in CI, making it possible to add automated
    tests, among other processes, before the automatic deployment procedures are executed
    for new versions of applications in different environments, such as development,
    testing, and production.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10* *.21* shows the CD pipeline. It’s very similar to the one for CI,
    but it consists of different tasks and processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.21 – The CD pipeline flow](img/B21788_10_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.21 – The CD pipeline flow
  prefs: []
  type: TYPE_NORMAL
- en: While the CI pipeline generates a valid package based on the quality flow of
    the development process, the CD pipeline’s main objective is to obtain the package
    that’s been generated through the CI pipeline and distribute it in an on-premises
    or cloud environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CD pipeline brings the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Accelerated delivery** : CD enables faster delivery of new features and bug
    fixes, reducing time to market and improving customer satisfaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced deployment risk** : By deploying small, incremental changes, CD minimizes
    the risk associated with large, infrequent deployments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistent deployments** : Automated deployment processes ensure deployments
    are consistent and repeatable, reducing human error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved reliability** : Continuous monitoring and automated rollback mechanisms
    increase the reliability of the deployment process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although the CD pipeline is an automated process, which means it’s capable of
    publishing new versions of an application in different environments automatically,
    it’s possible to establish approval flows where those responsible for each environment
    can choose whether they approve a deployment. The act of approval triggers the
    automatic deployment flow or cancels it, depending on the need.
  prefs: []
  type: TYPE_NORMAL
- en: The approvals gate approach brings compliance benefits and allows teams to have
    full control of the deployment flow in certain environments.
  prefs: []
  type: TYPE_NORMAL
- en: Review deployments
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the delivery flow of each organization, there’s a need to review
    deployments, especially in production environments. This approach generates an
    automated communication process between the CD pipeline and reviewers. Tools such
    as GitHub, Azure DevOps, and GitLab, among others, have mechanisms that allow
    you to configure this approval flow. You can learn more about the deployment review
    process through GitHub Actions at [https://docs.github.com/en/actions/managing-workflow-runs/reviewing-deployments](https://docs.github.com/en/actions/managing-workflow-runs/reviewing-deployments)
    .
  prefs: []
  type: TYPE_NORMAL
- en: CI and CD are great approaches to automating processes so that our applications
    can be delivered to different environments constantly and with quality in mind.
    This is something that allows us to deliver new versions of applications several
    times on the same day, at the same time, and it helps us quickly provide corrections
    and rollbacks in those environments, if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll implement a CI/CD flow using GitHub Actions and learn
    how to automatically publish a Docker image in a container registry.
  prefs: []
  type: TYPE_NORMAL
- en: Automating with GitHub Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To demonstrate CI/CD in action, we’ll use GitHub Actions to automate the process
    of generating and publishing a Docker image from the **UrlShortener** application.
    Make sure you’ve installed everything mentioned in the *Technical requirements*
    section so that you can take advantage of the steps described here.
  prefs: []
  type: TYPE_NORMAL
- en: 'To automate the process of including CI/CD, we’ll have to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure secrets in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create GitHub Actions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Activate GitHub Actions with each push event that’s sent to the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a Docker image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish the created image to Docker Hub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the previously created Docker image on the local machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before you start automating, you must understand the basics of GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the fundamentals of GitHub Actions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GitHub Actions is an automation tool that’s built into GitHub that lets you
    create, manage, and run workflows directly in your repository.
  prefs: []
  type: TYPE_NORMAL
- en: Actions, as it’s commonly known, can be triggered by various events, such as
    code submission, pull request creation, or time triggers.
  prefs: []
  type: TYPE_NORMAL
- en: 'GitHub Actions can be created using the **YML/YAML** file structure located
    in the **.github/workflows** directory of this book’s GitHub repository. The basic
    structure of a workflow is represented at a high level in *Figure 10* *.22* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.22 – The basic structure of GitHub Actions](img/B21788_10_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.22 – The basic structure of GitHub Actions
  prefs: []
  type: TYPE_NORMAL
- en: YAML files
  prefs: []
  type: TYPE_NORMAL
- en: A **YAML Ain’t Markup Language** ( **YAML** ) file is a human-readable data
    standard that’s commonly used for configuration files and exchanging data between
    programming languages with different data structures. YAML files use indentation
    to denote structure, making them easy to read and write. It’s often used in scenarios
    where configuration needs to be human-readable and easily parsed by machines,
    such as in CI/CD pipelines, cloud provisioning files, and application configuration
    settings. In the context of GitHub Actions, YAML files define workflows that automate
    processes such as building, testing, and deploying applications. To learn more,
    visit [https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10* *.22* shows the main components that are part of the structure
    of GitHub Actions. Let’s take a closer look:'
  prefs: []
  type: TYPE_NORMAL
- en: '**workflow.yml** : A YAML file that defines the workflow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**on** : This specifies the events that trigger the workflow. Examples include
    **push** , **pull_request** , and **schedule** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**jobs** : Defines a set of jobs to be executed within the workflow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**build job** : A job named **build** running on **ubuntu-latest** . Here,
    **ubuntu-latest** is a type of agent or machine that will execute all the steps
    of a job. This machine is made available by GitHub itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This flow contains a series of steps:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Checkout code** : Uses the **actions/checkout@v2** action.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Set up .NET Core** : Uses the **actions/setup-dotnet@v2** action with .NET
    version **''8.0.x''** .'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build project** : Runs the **dotnet** **build** command.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Run tests** : Runs the **dotnet** **test** command.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub-hosted runners
  prefs: []
  type: TYPE_NORMAL
- en: On GitHub, agents are called runners and are available for Windows, Linux, and
    macOS.
  prefs: []
  type: TYPE_NORMAL
- en: Runners are a fundamental component for running GitHub Actions and are provisioned
    during a CI or CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about runners, visit [https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners/about-github-hosted-runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners/about-github-hosted-runners)
    .
  prefs: []
  type: TYPE_NORMAL
- en: With GitHub Actions, we have a multitude of possibilities for automating processes
    that aren’t restricted to CI/CD contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how GitHub Actions works, let’s start by configuring our repository
    and creating our first actions.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a GitHub repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To automate the process of creating and publishing a Docker image through GitHub
    Actions, it’s important to understand how the pipeline we’ll create works, as
    shown in *Figure 10* *.23* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.23 – Example of the GitHub Actions flow integrated with Docker
    Hub](img/B21788_10_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.23 – Example of the GitHub Actions flow integrated with Docker Hub
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we learned about the fundamentals of the container strategy when
    using Docker and used Docker’s build multi-stage approach to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: This multi-stage approach has all the necessary steps to generate an application
    package and, in the end, generate an image that’s ready to be used.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 10* *.23* , during the pipeline flow, some calls to Docker
    Hub are necessary. This is the public container registry that we used when we
    packaged the **URLShortener** application. However, we can generate a local image
    without the need to communicate with Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to publish a Docker image to a public or private container registry,
    authentication must be performed.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of Docker Hub, this authentication takes place using a username
    and password. Since this information is sensitive, we shouldn’t add it directly
    to a GitHub Actions YAML file, especially if the repository is public.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best practice is to manage these credentials securely using Secrets. So,
    follow these steps to add the necessary secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: Access your **ASP.NET-8.0-Core-Essentials** repository via your GitHub user.
    This should have been prepared as per the *Technical* *requirements* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, access the **Settings** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the side menu, access **Secrets and variables** | **Actions** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the center of the screen, click the **New repository** **secret** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Name** field to **DOCKER_HUB_USERNAME** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Secret** field, add your Docker Hub user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Add** **Secret** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, click on the **New repository** **secret** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Name** field to **DOCKER_HUB_PASSWORD** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Secret** field with your password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Add** **Secret** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Secrets will be accessed securely while we’re running GitHub Actions. Now, let’s
    create the CI/CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the CI/CD pipeline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we’ve learned how to manage Docker Hub credentials securely, something
    we’ll need to do so that we can authenticate through the pipeline and submit the
    newly generated image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still in the GitHub repository, access the **Actions** tab. As shown in *Figure
    10* *.24* , there are several readymade pipeline templates that suit different
    types of applications and are a great starting point for creating a pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.24 – GitHub Actions templates screen](img/B21788_10_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.24 – GitHub Actions templates screen
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we’ll click on the **set up a workflow yourself** link, as
    highlighted in *Figure 10* *.24* .
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll see an editor and a list of **Featured Actions** , as well as the file’s
    name, as shown in *Figure 10* *.25* :'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 10.2\uFEFF5 – GitHub Actions editor](img/B21788_10_25.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.25 – GitHub Actions editor
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10* *.25* shows three important areas of the GitHub Actions editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A** : This is where you can define the filename. Note the suggested directory
    structure. We’ll set the filename to **cicd-pipeline.yml** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**B** : This is where we’ll add the pipeline code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C** : The pipeline consists of tasks, called actions. These actions are abstractions
    for executing tasks related to a certain technology. The technical community shares
    different types of custom actions that we can use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the following code to the pipeline editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The hierarchical structure of YAML files is created using spaces. Therefore,
    nested elements define the hierarchy. If these spaces aren’t respected, the file
    won’t be valid. Let’s consider using two spaces for each item in the hierarchy,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look at this pipeline code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**on** : This defines how the action will be executed. In this case, every
    time there is an update or push in the main branch, this action will be triggered,
    executing the CI pipeline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jobs** : Jobs are processes that are executed sequentially. There might be
    jobs for **build** , **test** , **generate-package** , and more. Using **Jobs**
    allows us to have well-defined steps and dependencies between steps, thus creating
    the pipeline flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**build-and-deploy** : This is the definition for a job named **build-and-deloy**
    . The **name** parameter produces a more user-friendly description during pipeline
    execution, but the job’s name can be referenced in the pipeline flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Steps** : Steps are the tasks or actions that are performed in each Job.
    For this example, only two tasks need to be performed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**uses: actions/checkout@v4.1.7** : This is a native GitHub action that aims
    to clone the repository. The **checkout** action is necessary since runners are
    created on demand and don’t have the application’s source code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**name: Build and publish Docker image** : Here, we’re executing an inline
    action where we define a script to build and publish the Docker image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**docker build -t ${{ secrets.DOCKER_HUB_USERNAME }} /urlshortener:latest .**
    : This script builds the Docker image. Note the use of the secret containing the
    Docker Hub username. This is necessary so that we can tag the image with its owner
    – that is, the Docker Hub username. We’re using the **latest** label here to facilitate
    understanding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**echo ${{ secrets.DOCKER_HUB_PASSWORD }} | docker login -u ${{ secrets.DOCKER_HUB_USERNAME
    }} --password-stdin** : This command is executed in a Linux bash shell, which
    allows us to combine commands and execute other commands by obtaining input and
    output from previously executed commands. In this case, we’re writing the secret
    that contains the Docker Hub user’s password and sending the output as a parameter
    to the **docker login** command. This way, the secret won’t be exposed in the
    pipeline execution log. The **docker login** command is required for publishing
    new versions of images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**working-directory: ./Chapter-10/UrlShortener** : The directory containing
    the **Dockerfile** file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**docker push** : The **docker push** command submits the previously generated
    image to Docker Hub.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this, the pipeline has been configured and contains both the CI and CD
    pipelines, where a new version of the Docker image is published at the end of
    the pipeline. At this point, it’s time to run the created GitHub action.
  prefs: []
  type: TYPE_NORMAL
- en: Running the CI/CD pipeline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the pipeline editor, click the **Commit Changes** button. You’ll be taken
    to a new page where you must click **Commit Changes** once more. This is necessary
    since we’re creating a new file in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: When you commit these changes, the pipeline will be triggered automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Actions** tab; you’ll see the pipeline’s execution, as shown
    in *Figure 10* *.26* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.26 – Running the GitHub action](img/B21788_10_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.26 – Running the GitHub action
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the pipeline, the new image will be generated in Docker Hub,
    as shown in *Figure 10* *.27* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.27 – Container image published on Docker Hub by GitHub Actions](img/B21788_10_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.27 – Container image published on Docker Hub by GitHub Actions
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the new image on your local machine, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The new image will be downloaded, which means your application can be run on
    your local machine at [http://localhost:7777](http://localhost:7777) .
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve learned, GitHub Actions can automate tasks in environments for the
    purpose of CD. This brings agility and consistency and allows teams to act quickly
    in the face of the constant changes demanded by the market.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, any changes that are made to your repository and submitted to
    GitHub will automatically generate a new version of the container for your Docker
    Hub user.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions has several applications and, together with solutions developed
    in ASP.NET Core 9, it’s a powerful tool for creating high-quality applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about the fundamentals of working in a continuous
    flow of value delivery. We’ll explore how to attain a cloud-native application
    development mindset in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to publish ASP.NET Core 9 applications and generate
    a publishing package using the **dotnet** CLI tool. Furthermore, we learned how
    to publish an application in an Azure cloud environment and explored the fundamentals
    of Docker’s container strategy. Using the knowledge we’d acquired, we were able
    to learn how value delivery flows through DevOps practices such as CI and CD and
    benefits from automated processes via GitHub Actions. All the knowledge we’ve
    acquired in this chapter forms the basis for the next chapter, where we’ll learn
    about cloud-native development with ASP.NET Core 9.
  prefs: []
  type: TYPE_NORMAL
