- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Implementing Code Reusability in C# 12
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C# 12中实现代码重用
- en: '**Code reusability** is one of the most important topics in software architecture.
    This chapter aims to discuss ways to enable code reuse, as well as help you understand
    how .NET 8 solves the problem of managing and maintaining a reusable library.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码重用性**是软件架构中最重要的话题之一。本章旨在讨论实现代码重用的方法，以及帮助你理解.NET 8如何解决管理和维护可重用库的问题。'
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the principles of code reuse
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解代码重用的原则
- en: The advantages of working with .NET 8
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与.NET 8合作的优势
- en: Creating reusable libraries using .NET 8
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用.NET 8创建可重用库
- en: Although code reuse is an exceptional practice, as a software architect, you
    must be aware of when this is important for the scenario you are dealing with.
    Many good software architects agree that there is a lot of overengineering due
    to trying to make things reusable even though they are often single-use or not
    understood well enough, leading to unnecessary complexity and slowing down the
    development process.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码重用是一种例外做法，但作为一名软件架构师，你必须意识到在处理的具体场景中何时这是重要的。许多优秀的软件架构师认为，由于试图使事物可重用，尽管它们通常是单次使用或理解不够充分，导致不必要的复杂性和开发过程缓慢，这导致了大量的过度设计。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need the free Visual Studio 2022 Community Edition
    or above, with all the database tools installed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要安装免费Visual Studio 2022 Community Edition或更高版本，以及所有数据库工具。
- en: Understanding the principles of code reusability
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解代码重用的原则
- en: There is a single reason that you can always use to justify code reuse – you
    cannot spend your valuable time reinventing the wheel if it is already running
    well in other scenarios. That is why most engineering domains are based on reusability
    principles like modularity, standardization, abstraction, and documentation. Think
    about the light switches you have in your house. You can only change them without
    modifying other components of your house because it was built based on a standard,
    abstracting the idea of what a switch is according to a specification, providing
    modularity as a result.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以始终用来证明代码重用合理性的唯一理由是——如果你在其他场景中已经运行良好，你就不能浪费宝贵的时间去重新发明轮子。这就是为什么大多数工程领域都基于可重用性原则，如模块化、标准化、抽象和文档。想想你家里的开关。你只能更换它们，而不必修改你房子的其他部分，因为它是基于一个标准建造的，根据规范抽象出开关的概念，从而提供了模块化。
- en: Can you imagine the number of applications that can be made with the same interface
    components? The fundamentals of code reuse are the same. Again, it is a matter
    of planning a good solution so part of it can be reused later.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想象使用相同的界面组件可以制作出多少应用吗？代码重用的基本原则是一样的。再次强调，这关乎于规划一个良好的解决方案，以便其中一部分可以在以后重用。
- en: 'In software engineering, code reuse is one of the techniques that can bring
    a bunch of advantages to a software project, such as the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中，代码重用是能够给软件项目带来一系列优势的技术之一，例如以下这些：
- en: There is confidence in the software, considering that the reused piece of code
    was already tested in another application.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于重用的代码部分已经在另一个应用程序中经过测试，因此对软件有信心。
- en: There is more efficient usage of software architects and the senior team since
    they can be dedicated to solving this kind of problem.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件架构师和高级团队有更高效的利用方式，因为他们可以专注于解决这类问题。
- en: There is the possibility of bringing to the project a pattern that is already
    accepted by the market.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有可能将市场上已经接受的模式引入项目中。
- en: Development speed goes up due to the already-implemented components.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于已经实现了组件，开发速度会提高。
- en: Maintenance is easier.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护起来更简单。
- en: These aspects suggest that code reuse should be done whenever possible. However,
    creating reusable components does carry higher costs initially. That is why you
    need to focus on creating it in situations where you recognize that this piece
    of code will really be reused in the future or where you are trying to reuse code
    that has not been created as a component. It is your responsibility, as a software
    architect, to ensure the preceding advantages are utilized and, more than that,
    that you incentivize your team to enable reuse in the software they are creating.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方面表明，代码复用应该尽可能地进行。然而，创建可复用组件的初始成本会更高。这就是为什么你需要专注于在你能认识到这段代码将来真的会被复用的情况下创建它，或者在你试图复用尚未作为组件创建的代码的情况下。作为软件架构师，确保利用前面的优势是你的责任，而且更重要的是，激励你的团队在创建的软件中启用复用。
- en: In the next section, we will discuss what can be considered code reuse and what
    cannot. The main purpose of discussing it is to help you define a code reuse strategy
    that will transform the efficiency of your team.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论什么可以被认为是代码复用，什么不可以。讨论的主要目的是帮助你定义一个代码复用策略，这将改变你团队的效率。
- en: What code reuse is not
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码复用不是什么
- en: The first thing you must understand is that code reuse does not mean copying
    and pasting code from one class to another. Even if this code was written by another
    team or project, this does not indicate that you are properly working with reusability
    principles. Let us imagine a scenario that we will find in this book’s use case,
    the **WWTravelClub** evaluation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须理解的第一件事是，代码复用并不意味着从一个类复制粘贴代码到另一个类。即使这段代码是由另一个团队或项目编写的，这也不表明你正确地运用了复用原则。让我们想象一个场景，我们将在本书的使用案例中找到这个场景，即**WWTravelClub**评估。
- en: 'In this project scenario, you may want to evaluate different kinds of subjects,
    such as the **Package**, **DestinationExpert**, **City**, **Comments**, and so
    on. The process for getting the evaluation average is the same, no matter which
    subject you are referring to. Due to this, you may want to *enable* reuse by copying
    and pasting the code for each evaluation. The (bad) result will be something like
    this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目场景中，你可能想要评估不同类型的主题，例如**包**、**目的地专家**、**城市**、**评论**等等。无论你指的是哪个主题，获取评估平均值的流程都是相同的。正因为如此，你可能希望通过复制粘贴每个评估的代码来*启用*复用。结果可能如下所示：
- en: '![Diagram  Description automatically generated](img/B19820_05_01.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B19820_05_01.png)'
- en: 'Figure 5.1: Bad implementation – there is no code reuse here'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：糟糕的实现 – 这里没有代码复用
- en: In the preceding diagram, the process of calculating the evaluation average
    is decentralized, which means that the same code will be duplicated in different
    classes. This will cause a lot of trouble, especially if the same approach is
    used in other applications. For instance, if there is a new specification covering
    how you must calculate the average, or even if you just get a bug in the calculation
    formula, you will have to fix it in all instances of the code. If you do not remember
    to update it everywhere, you will possibly end up with an inconsistent implementation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，计算评估平均值的流程是分散的，这意味着相同的代码将在不同的类中重复。这将造成很多麻烦，尤其是在其他应用程序中也使用了相同的方法。例如，如果有一个新的规范涵盖了如何计算平均值，或者即使只是计算公式中出现了错误，你也必须修复所有代码实例。如果你忘记在所有地方更新它，你可能会得到不一致的实现。
- en: In the next section, we will reorganize this code to respect some principles
    that you, as a software architect, should follow to avoid the issues we have mentioned
    here.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将重新组织这段代码，以尊重一些你作为软件架构师应该遵循的原则，以避免我们在这里提到的问题。
- en: What code reuse is
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码复用是什么
- en: 'The solution to the problem mentioned in the previous section is quite simple:
    you must analyze your code and select the parts of it that would be good to decouple
    from your application.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 解决上一节中提到的问题的方案相当简单：你必须分析你的代码，并选择其中那些可以从你的应用程序中解耦的部分。
- en: 'The most compelling reason you should decouple them is related to how you are
    sure that this code can be reused in other parts of the application or even in
    another application. This is exactly what Andrew Hunt and David Thomas present
    as the DRY principle (don’t repeat yourself):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该解耦的最有力的理由与你如何确保这段代码可以在应用程序的其他部分或其他应用程序中复用有关。这正是Andrew Hunt和David Thomas提出的DRY原则（不要重复自己）：
- en: '![Diagram  Description automatically generated](img/B19820_05_02.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B19820_05_02.png)'
- en: 'Figure 5.2: An implementation focused on code reuse'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：专注于代码重用的实现
- en: 'The centralization of the code brings with it a different responsibility for
    software architects such as yourself. You must keep in mind that if there is a
    mistake or problem in this code, it can cause issues in many parts of the application
    or even other applications that use it. On the other hand, once you have this
    code tested and running, you will be able to reuse this code again in new projects
    with no worries. Besides, let’s remember the use case we are implementing here:
    you may want to evaluate different kinds of subjects, such as the **Package**,
    **DestinationExpert**, **City**, **Comments**, and so on. The process for getting
    the evaluation average is the same, no matter which subject you are referring
    to. What if you need to evolve the average calculation process? In the design
    now provided, you will have to change the code in a single class. Considering
    what we have already learned, we could also:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的集中化给你这样的软件架构师带来了不同的责任。你必须记住，如果这段代码中存在错误或问题，它可能会在应用程序的许多部分甚至使用它的其他应用程序中引起问题。另一方面，一旦你测试并运行了这段代码，你将能够无忧无虑地在新的项目中再次重用这段代码。此外，让我们记住我们在这里要实现的使用案例：你可能想要评估不同类型的主题，例如**包**、**目的地专家**、**城市**、**评论**等等。无论你指的是哪个主题，获取评估平均值的流程都是相同的。如果你需要进化平均计算过程呢？在设计现在提供的方案中，你将不得不在一个类中更改代码。考虑到我们已经学到的知识，我们还可以：
- en: Make a base class implementing the logic of the method.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个基类，实现方法的逻辑。
- en: Inherit all other classes from the newly created base class and eventually augment/modify
    the method’s behavior.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从新创建的基类继承所有其他类，并最终增强/修改方法的行为。
- en: Turn the inheritance into an association (as discussed in the previous chapter).
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将继承转换为关联（如前一章所述）。
- en: It is worth mentioning that the more you use the same code, the cheaper this
    development will become. Although it might seem like developing reusable code
    costs more initially, the more you use it, the more cost-effective and efficient
    the development process becomes over time. Cost needs to be mentioned because,
    in general, the concept of reusable software costs more in the beginning.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，你使用相同代码的次数越多，这种开发就越便宜。尽管最初开发可重用代码可能看起来成本更高，但随着使用次数的增加，开发过程在时间上变得越来越经济高效。需要提到成本，因为通常情况下，可重用软件的概念在开始时成本更高。
- en: Reusability in the development life cycle
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发生命周期中的可重用性
- en: If you understand that code reusability will take you to another level of coding,
    improving the way you write and use code, then it’s time to think about how to
    make this technique available in your development life cycle.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你理解代码的可重用性将带你进入另一个层次的编码，改善你编写和使用代码的方式，那么是时候考虑如何使这项技术在你的开发生命周期中变得可用。
- en: As a matter of fact, creating and maintaining a component library is not very
    easy due to the responsibility you will take on and the lack of good tools to
    support the search for existing components.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，由于你将承担的责任以及缺乏支持现有组件搜索的良好工具，创建和维护组件库并不容易。
- en: 'On the other hand, there are some practices that you may consider implementing
    in your software development process every time you initiate a new development:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有一些实践，你可能在每次启动新的软件开发时都考虑实施：
- en: '**Use** the already-implemented components from your user library, selecting
    features that need them in the software requirements specification.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用**用户库中已经实现的组件，选择在软件需求规范中需要它们的特性。'
- en: '**Identify** features in the software requirements specification that are candidates
    to be designed as library components.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**识别**软件需求规范中可以作为库组件设计的特性。'
- en: '**Modify** the specification, considering that these features will be developed
    using reusable components.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修改**规范，考虑到这些特性将使用可重用组件开发。'
- en: '**Design** the reusable components and be sure that they have the appropriate
    interfaces to be used in many projects.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计**可重用组件，并确保它们具有适用于许多项目的适当接口。'
- en: '**Build** the project architecture with the new component library version.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建**使用新组件库版本的项目架构。'
- en: '**Document** the component library version so that every developer and team
    knows about it.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录**组件库版本，以便每个开发者和团队都知道。'
- en: The *use-identify-modify-design-build* process is a technique that you may consider
    implementing every time you need to enable software reuse. As soon as you have
    the components you need to write for this library, you will need to decide on
    the technology that will provide these components.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用-识别-修改-设计-构建* 过程是一种你可能每次需要启用软件重用时都考虑实施的技术。一旦你有了为这个库编写所需的组件，你将需要决定提供这些组件的技术。'
- en: During the history of software development, there have been many approaches
    to enable code reuse, from **dynamic link libraries** (**DLLs**) to microservices,
    as we will discuss in *Chapter 11*, *Applying a Microservice Architecture to Your
    Enterprise Application*, in the *Microservices and the evolution of the concept
    of modules* section. The methodology explained in the section can be used by you,
    as a software architect, to implement this strategy to accelerate software development.
    Now, let us check how .NET 8 can help us with it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发的历史中，有许多方法可以实现代码重用，从 **动态链接库** (**DLLs**) 到微服务，正如我们将在第 11 章 *将微服务架构应用于企业应用程序*
    中的 *微服务和模块概念的演变* 节所讨论的。该节中解释的方法可以由你，作为软件架构师，用来实施此策略以加速软件开发。现在，让我们看看 .NET 8 如何帮助我们实现这一点。
- en: Using .NET 8 for code reuse
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 .NET 8 进行代码重用
- en: '**.NET** has evolved a lot since its first version. This evolution is related
    not only to the number of commands and performance issues but also to the supported
    platforms. As we discussed in *Chapter 1*, *Understanding the Importance of Software
    Architecture*, you can run C# .NET on billions of devices, even if they are running
    Linux, Android, macOS, or iOS. For this reason, .NET Standard was first announced
    together with .NET Core 1.0, but .NET Standard became particularly important with
    .NET Standard 2.0 when .NET Framework 4.7.2, .NET Core, and Xamarin became compatible
    with it.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**.NET** 自第一版以来已经发展了很多。这种演变不仅与命令数量和性能问题有关，还与支持的平台有关。正如我们在第 1 章 *理解软件架构的重要性*
    中所讨论的，你可以在运行 Linux、Android、macOS 或 iOS 的数十亿台设备上运行 C# .NET。因此，.NET Standard 首次与
    .NET Core 1.0 一起宣布，但随着 .NET Standard 2.0 的推出，.NET Framework 4.7.2、.NET Core 和
    Xamarin 与其兼容，.NET Standard 变得尤为重要。'
- en: The key point is that .NET Standard was not only a Visual Studio project. More
    than that, it was a formal specification available to all .NET implementations.
    As you can see in the following table, .NET Standard 2.0, which is recommended
    by Microsoft, covers everything in .NET. You can find a full .NET Standard overview
    at [https://docs.microsoft.com/en-us/dotnet/standard/net-standard](https://docs.microsoft.com/en-us/dotnet/standard/net-standard).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点在于 .NET Standard 不仅仅是一个 Visual Studio 项目。更重要的是，它是一个对所有 .NET 实现都适用的正式规范。正如你可以在下表中所见，由微软推荐的
    .NET Standard 2.0 覆盖了 .NET 中的所有内容。你可以在 [https://docs.microsoft.com/en-us/dotnet/standard/net-standard](https://docs.microsoft.com/en-us/dotnet/standard/net-standard)
    找到完整的 .NET Standard 概览。
- en: '| **.NET implementation** | **Version support** |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **.NET 实现** | **版本支持** |'
- en: '| .NET and .NET Core | 2.0, 2.1, 2.2, 3.0, 3.1, 5.0, 6.0, 7.0, 8.0 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| .NET 和 .NET Core | 2.0, 2.1, 2.2, 3.0, 3.1, 5.0, 6.0, 7.0, 8.0 |'
- en: '| .NET Framework 1 | 4.6.1 2, 4.6.2, 4.7, 4.7.1, 4.7.2, 4.8, 4.8.1 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| .NET Framework 1 | 4.6.1 2, 4.6.2, 4.7, 4.7.1, 4.7.2, 4.8, 4.8.1 |'
- en: '| Mono | 5.4, 6.4 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| Mono | 5.4, 6.4 |'
- en: '| Xamarin.iOS | 10.14, 12.16 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| Xamarin.iOS | 10.14, 12.16 |'
- en: '| Xamarin.Mac | 3.8, 5.16 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| Xamarin.Mac | 3.8, 5.16 |'
- en: '| Xamarin.Android | 8.0, 10.0 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| Xamarin.Android | 8.0, 10.0 |'
- en: '| Universal Windows Platform | 10.0.16299, TBD |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 通用 Windows 平台 | 10.0.16299, 待定 |'
- en: '| Unity | 2018.1 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| Unity | 2018.1 |'
- en: 'Table 5.1: .NET Standard 2.0 support'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '表 5.1: .NET Standard 2.0 支持'
- en: This indicates that if you build a class library that is compatible with this
    standard, you will be able to reuse it on any of the platforms presented. Think
    about how fast your development process could become if you plan to do this in
    all your projects.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，如果你构建一个与该标准兼容的类库，你将能够在所展示的任何平台上重用它。想想如果你在所有项目中都这样做，你的开发过程会变得多快。
- en: Obviously, some components are not included in .NET Standard, but its evolution
    is continuous. It is worth mentioning that Microsoft’s official documentation
    indicates that *the higher the version, the more APIs are available to you*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，一些组件不包括在 .NET Standard 中，但其演变是持续的。值得一提的是，微软的官方文档指出，*版本越高，可用的 API 越多*。
- en: The initiative of having a single framework for all platforms brought us to
    .NET 5\. Microsoft indicated that from .NET 5.0, the framework would run everywhere.
    The next question you, as a software architect, might have is *what is going to
    happen to .NET Standard?*
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让所有平台都使用单个框架的倡议，我们来到了.NET 5。微软指出，从.NET 5.0开始，框架将在任何地方运行。作为软件架构师的你可能会问，*.NET
    Standard将会怎样？*
- en: 'The answer to this question is well explained by Immo Landwerth at the dotnet
    blog: [https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/](https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/).
    The basic answer is that .NET 5.0 (and future versions) needs to be thought of
    as the foundation for sharing code moving forward. Considering .NET 8 is an **LTS**
    (**Long-Term Support**) version, we can now understand the framework as the best
    option to share code for new applications.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案在Immo Landwerth的dotnet博客中得到了很好的解释：[https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/](https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/)。基本的答案是，.NET
    5.0（以及未来的版本）需要被视为未来共享代码的基础。考虑到.NET 8是一个**LTS**（**长期支持**）版本，我们现在可以理解这个框架是分享新应用程序代码的最佳选择。
- en: Bearing this scenario in mind, it is time to check how to create reusable class
    libraries. So, let us move to the next topic.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这个场景，现在是时候检查如何创建可重用类库了。因此，让我们进入下一个主题。
- en: Creating a reusable class library
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建可重用类库
- en: 'If you want to make useful functionalities to be used by multiple applications,
    you will need to create a **class library** project. So, creating class libraries
    is the best way to reuse code using .NET. It is quite simple to create a **class
    library**. Basically, you need to choose the following project when creating the
    library:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建可以被多个应用程序使用的有用功能，你需要创建一个**类库**项目。因此，使用.NET创建类库是重用代码的最佳方式。创建**类库**相当简单。基本上，在创建库时，你需要选择以下项目：
- en: '![Texto  Descrição gerada automaticamente](img/B19820_05_03.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![Texto Descrição gerada automaticamente](img/B19820_05_03.png)'
- en: 'Figure 5.3: Creating a class library'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：创建类库
- en: 'Once you have concluded this part, you will notice that the project file keeps
    the information about the **target framework moniker** (**TFM**). The idea of
    the TFM is to define the set of APIs that will be available to the library. You
    can find a list of the available TFMs at [https://docs.microsoft.com/en-us/dotnet/standard/frameworks](https://docs.microsoft.com/en-us/dotnet/standard/frameworks):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了这部分，你会注意到项目文件会保留关于**目标框架标识符**（**TFM**）的信息。TFM的想法是定义将可用于库的API集合。你可以在[https://docs.microsoft.com/en-us/dotnet/standard/frameworks](https://docs.microsoft.com/en-us/dotnet/standard/frameworks)找到可用的TFM列表：
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As soon as your project is loaded, you can start coding the classes that you
    intend to reuse. The advantage of building reusable classes using this approach
    is that you will be able to reuse the written code in all the project types we
    checked previously. On the other hand, you will find out that some APIs that are
    available in .NET Framework do not exist in this type of project.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的项目加载完毕，你就可以开始编写你打算重用的类。使用这种方法构建可重用类的优点是，你将能够在之前检查的所有项目类型中重用所编写的代码。另一方面，你会发现一些在.NET
    Framework中可用的API，在这个类型的项目中并不存在。
- en: Considering that you already have the correct project type selected for creating
    reusable code, let us check how C# deals with code reuse in the next section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到你已经选择了正确的项目类型来创建可重用代码，让我们在下一节中看看C#是如何处理代码重用的。
- en: How does C# deal with code reuse?
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#是如何处理代码重用的？
- en: Considering you are writing class libraries using C#.NET, there are many approaches
    where **C#** helps us deal with code reuse. The ability to build libraries, as
    we did in the previous section, is one of them. One of the most important ones
    is the fact that the language is **object-oriented**. Besides this, it is also
    worth mentioning the facilities that generics brought to the C# language. This
    section will discuss object-oriented analysis and generics principles.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到你正在使用C#.NET编写类库，有许多方法中**C#**帮助我们处理代码重用。我们之前所做的那样构建库的能力是其中之一。其中最重要的一个事实是，这种语言是**面向对象的**。除此之外，还值得提到泛型为C#语言带来的便利。本节将讨论面向对象分析和泛型原则。
- en: Object-oriented analysis
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面向对象分析
- en: The object-oriented analysis approach gives us the ability to reuse code in
    different ways, from the facility of inheritance to the changeability of polymorphism.
    Complete adoption of object-oriented programming will let you implement abstraction
    and encapsulation, too.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象分析方法使我们能够以不同的方式重用代码，从继承的便利性到多态的可变性。完全采用面向对象编程将使您能够实现抽象和封装。
- en: It is important to mention that in *Chapter 4*, *Best Practices in Coding C#
    12*, we discuss how inheritance can cause complexity in your code. Although the
    following example presents a valid way to reuse code, consider using composition
    over inheritance in real-life applications.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要提到，在*第 4 章*，*C# 编码最佳实践 12*中，我们讨论了继承如何导致代码复杂化。尽管以下示例展示了一种有效的代码重用方法，但在实际应用中，考虑使用组合而非继承。
- en: 'The following diagram shows how using the object-oriented approach makes reuse
    easier. As you can see, there are different ways to calculate the grades of an
    evaluation, considering that you can be a basic or a prime user of this example
    system:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了使用面向对象方法如何使重用变得更加容易。正如您所看到的，考虑到您可以是该示例系统的基本用户或高级用户，计算评估成绩的方法有多种：
- en: '![](img/B19820_05_04.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_05_04.png)'
- en: 'Figure 5.4: Object-oriented case analysis'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：面向对象案例分析
- en: There are two aspects to be analyzed as code reuse in this design. The first
    is that there is no need to declare the properties in each child class since inheritance
    does it for you.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在此设计中，代码重用有两个方面需要分析。第一个方面是，由于继承会为您完成，因此不需要在每个子类中声明属性。
- en: 'The second is the opportunity to use polymorphism, enabling different behaviors
    for the same method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方面是使用多态的机会，它允许同一方法有不同的行为：
- en: '[PRE1]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding code, you can see the usage of the polymorphism principle,
    where the calculation of evaluation for prime users will increase by 20%. Now,
    look at how easy it is to call different objects inherited by the same class.
    Since the collection content implements the same interface, `IContentEvaluated`,
    it can have basic and prime users, too:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您可以看到多态原则的应用，其中高级用户的评估计算将增加 20%。现在，看看调用同一类继承的不同对象是多么容易。由于集合内容实现了相同的接口
    `IContentEvaluated`，它也可以有基本用户和高级用户：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Object-oriented adoption can be considered mandatory when using C#. However,
    more specific usage requires study and practice. You, as a software architect,
    should always incentivize your team to study object-oriented analysis. The more
    abstract abilities they have, the easier code reuse will become.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 C# 时，考虑面向对象的使用是强制性的。然而，更具体的用法需要学习和实践。作为软件架构师，您应该始终鼓励您的团队学习面向对象分析。他们越抽象的能力，代码重用就越容易。
- en: Generics
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泛型
- en: '**Generics** were introduced in C# in version 2.0 and are considered an approach
    that increases code reuse. It also maximizes type safety and performance.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**泛型**在 C# 2.0 版本中引入，被认为是一种提高代码重用的方法。它还最大限度地提高了类型安全和性能。'
- en: The basic principle of generics is that you can define in an interface, class,
    method, property, event, or even delegate a placeholder that will be replaced
    with a specific type later when one of the preceding entities is used. The opportunity
    you have with this feature is incredible since you can use the same code to run
    different generic versions of the type.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型的基本原理是，您可以在接口、类、方法、属性、事件或甚至委托中定义一个占位符，该占位符将在使用前述实体之一时被替换为特定类型。由于您可以使用相同的代码运行不同版本的泛型类型，因此您利用此功能的机会是难以置信的。
- en: 'The following code is a modification of `EvaluationService`, which was presented
    in the previous section. The idea here is to enable the generalization of the
    service, giving us the opportunity to define the goal of evaluation since its
    creation:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是对上一节中介绍的 `EvaluationService` 的修改。这里的想法是使服务通用化，从而在创建时就定义评估的目标：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This declaration indicates that any class that implements the `IContentEvaluated`
    interface can be used for this service. The new constraint indicates this class
    must have a public parameter-less default constructor.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此声明表明，任何实现 `IContentEvaluated` 接口的类都可以用于此服务。新的约束表明此类必须有一个公共的无参数默认构造函数。
- en: 'The service will be responsible for creating the evaluated content:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务将负责创建评估内容：
- en: '[PRE4]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It is worth mentioning that this code works because all the classes are in
    the same assembly. The result of this modification can be checked in the instance
    creation of the service:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这段代码之所以能工作，是因为所有类都在同一个程序集里。这次修改的结果可以在服务的实例创建中检查：
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The good news is that now, you have a generic service that will automatically
    instantiate the `list` object with the evaluations of the content you need. It’s
    worth mentioning that generics will obviously need more time dedicated to the
    first project’s construction. However, once the design is done, you will have
    good, fast, and easy-to-maintain code. This is what we call reuse!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，现在您有一个通用的服务，它将自动实例化您需要的`list`对象，并包含内容评估。值得一提的是，泛型显然需要更多时间来构建第一个项目。然而，一旦设计完成，您将拥有良好、快速且易于维护的代码。这就是我们所说的重用！
- en: What if the code is not reusable?
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果代码不可重用怎么办？
- en: 'In fact, any code can be reusable. The key point here is that the code you
    intend to reuse must be well-written and follow good patterns for reuse. There
    are several reasons why code should be considered not ready for reuse:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，任何代码都可以是可重用的。关键点在于，您打算重用的代码必须编写良好，并遵循良好的重用模式。有几个原因说明为什么代码应该被视为不可重用：
- en: '**The code has not been tested before**: Before reusing code, it is a good
    approach to guarantee that it works.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码之前未经过测试**：在重用代码之前，确保它能够正常工作是一个很好的方法。'
- en: '**The code is duplicated**: If you have duplicate code, you will need to find
    each place where it is used so you only have a single version of the code being
    reused. If you find different versions of the code duplicated, you will need to
    define the best version of it to be considered the reusable one, and, at the same
    time, you will need to retest every replacement of the duplicated code to guarantee
    that the functionality of the software remains the same.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码重复**：如果您有重复的代码，您需要找到它被使用的每个地方，以确保只有一个版本的代码被重用。如果您发现代码的不同版本被重复，您需要定义最佳版本作为可重用版本，同时您还需要重新测试所有替换的重复代码，以确保软件的功能保持不变。'
- en: '**The code is too complex to understand:** Code that is reused in many places
    needs to be written with simplicity to enable easy understanding.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码过于复杂，难以理解**：在许多地方被重用的代码需要以简洁的方式编写，以便易于理解。'
- en: '**The code has tight coupling**: This is a discussion related to composition
    versus inheritance when building separate class libraries. Classes (with interfaces)
    are usually much easier to reuse than base classes that can be inherited.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码有紧密耦合**：这是关于在构建单独的类库时，是使用组合还是继承的讨论。通常，具有接口的类比可以继承的基类更容易重用。'
- en: 'In any of these cases, considering a refactoring strategy can be a great approach.
    When you refactor code, you write it in a better way, guaranteeing the code standards,
    reducing complexity, and respecting the input and output data that this code will
    process. This enables more comprehensive and lower-cost changes to be made to
    the code when the time comes. Martin Fowler, in his book *Refactoring* of 2018,
    indicates some reasons why you should consider refactoring:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何这些情况下，考虑重构策略都可以是一个很好的方法。当您重构代码时，您会以更好的方式编写它，保证代码标准，减少复杂性，并尊重此代码将处理的数据输入和输出。这使您能够在适当的时候对代码进行更全面和成本更低的更改。马丁·福勒在他的2018年出版的《重构》一书中，指出了您应该考虑重构的一些原因：
- en: '**It improves software design**: The more expert your team becomes, the better
    the design will be. A better software design will not only deliver faster coding
    but also bring us the opportunity to process more tasks in less time.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它改善了软件设计**：随着团队的专业技能不断提高，设计将变得更好。更好的软件设计不仅会带来更快的编码速度，还会给我们带来在更短的时间内处理更多任务的机会。'
- en: '**It makes the software easier to understand**: Regardless of whether we are
    talking about juniors or seniors, good software needs to be understood by every
    developer in your team.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它使软件更容易理解**：无论我们是在谈论初级还是高级开发者，好的软件需要让团队中的每个开发者都能理解。'
- en: '**It helps us find bugs**: While you are refactoring, you are reviewing code.
    During this process, you will find business rules that may not have been well
    programmed, so you will probably find bugs. However, do not forget that the basis
    of refactoring is keeping the behavior, so be sure that it is the correct moment
    for fixing issues.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它帮助我们找到错误**：在重构代码的同时，您正在审查代码。在这个过程中，您可能会发现一些可能没有编写好的业务规则，因此您可能会发现错误。然而，不要忘记重构的基础是保持行为，所以请确保这是修复问题的正确时机。'
- en: '**It makes our program quicker**: The result of refactoring will be code that
    will enable faster development in the future.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**这使我们的程序更快**：重构的结果将是能够使未来开发更快的代码。'
- en: 'When refactoring, we can guarantee good results and minimize the errors that
    occur during the journey by following these steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在重构时，我们可以通过遵循以下步骤来保证良好的结果并最小化在过程中发生的错误：
- en: '**Be sure you have a set of tests to guarantee the correct processing**: This
    set of tests will eliminate the fear of breaking the code.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**务必确保有一套测试来保证正确的处理**：这套测试将消除破坏代码的恐惧。'
- en: '**Eliminate duplication**: Refactoring is a good opportunity to eliminate code
    duplication.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消除重复**：重构是消除代码重复的好机会。'
- en: '**Minimize complexity**: Given that one goal is to make the code more understandable,
    following the best practices of programming, as mentioned in *Chapter 4*, *Best
    Practices in Coding C# 12*, will help you reduce the complexity of the code.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小化复杂性**：鉴于一个目标是使代码更易于理解，遵循第 4 章中提到的编程最佳实践，即 *《C# 编程最佳实践 12》*，将有助于你减少代码的复杂性。'
- en: '**Clean up the design**: Refactoring is a good time to reorganize the design
    of your libraries, too. Do not forget to update them as well. This can be a great
    way to eliminate bugs and security issues.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清理设计**：重构是重新组织库的设计的好时机。不要忘记更新它们。这可以是一种消除错误和安全问题的极好方式。'
- en: As a software architect, you will receive many refactoring demands from your
    team. The incentive for refactoring must be continuous, but you must remind your
    team that refactoring without following the preceding steps might be risky once
    it may cause bugs during the process. So, it is your responsibility to ensure
    that refactoring happens in a way that both enables fast programming and reduces
    the impact of unnecessary bugs caused by the refactoring process, thus delivering
    real business value.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件架构师，你将收到来自你团队许多重构的要求。重构的激励必须是持续的，但你必须提醒你的团队，如果不遵循前面的步骤进行重构，可能会存在风险，一旦在过程中可能引起错误。因此，确保重构以既能够快速编程又能减少因重构过程引起的不必要错误的影响，从而提供真正的商业价值，这是你的责任。
- en: I have my libraries. How do I promote them?
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我有我的库。我该如何推广它们？
- en: 'Once you have made all the necessary effort to guarantee you have good libraries
    that can be reused in many of your projects, you will find another difficult situation
    arises when enabling reusability: it is not so easy to let programmers know you
    have libraries ready to reuse.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你付出了所有必要的努力来保证你拥有许多项目中可以重用的良好库，你将发现当启用可重用性时会出现另一个困难的情况：让程序员知道你有现成的库可供重用并不那么容易。
- en: There are some simple approaches to documenting a library. As we mentioned when
    we talked about the development life cycle, documenting is a good way to help
    developers take notice of the libraries they have. There are two examples of documenting
    reusable code that we would like to mention in the following subsections.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 记录库有一些简单的方法。正如我们在讨论开发生命周期时提到的，记录是帮助开发者注意他们拥有的库的好方法。在接下来的小节中，我们将提到两个记录可重用代码的例子。
- en: Documenting .NET libraries using DocFX
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 DocFX 记录 .NET 库
- en: 'DocFX is a good option for documenting a library using comments made in its
    code. By simply adding the `docfx.console` NuGet package, the tool allows you
    to create a task that will run once your library has been built:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: DocFX 是使用代码中的注释来记录库的好选择。通过简单地添加 `docfx.console` NuGet 包，这个工具允许你创建一个任务，一旦你的库构建完成就会运行：
- en: '![Interface gráfica do usuário, Texto  Descrição gerada automaticamente](img/B19820_05_05.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![用户界面，文本描述自动生成](img/B19820_05_05.png)'
- en: 'Figure 5.5: docfx.console NuGet library'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5：docfx.console NuGet 库
- en: 'The output of this compilation is a stylish static website that contains the
    documentation of your code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个编译的输出是一个包含你的代码文档的时尚静态网站：
- en: '![](img/B19820_05_06.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B19820_05_06.png]'
- en: 'Figure 5.6: DocFx result'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：DocFx 结果
- en: This website is useful because you can distribute the documentation to your
    team so that they can search for the libraries you have. You can check the customizations
    of the output and find more information about it at [https://dotnet.github.io/docfx/](https://dotnet.github.io/docfx/).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网站很有用，因为你可以将文档分发给你的团队，以便他们可以搜索你拥有的库。你可以检查输出的自定义设置，并在 [https://dotnet.github.io/docfx/](https://dotnet.github.io/docfx/)
    找到更多关于它的信息。
- en: Documenting a web API using Swagger
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Swagger 记录 Web API
- en: There is no doubt that a web API is one of the technologies that facilitates
    and promotes code reuse. For this reason, ensuring good documentation and, more
    than that, respecting a standard is good practice and indicates that you are up
    to date with the approach to delivering reusable APIs. To do this, we have **Swagger**,
    which respects the **OpenAPI Specification**.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，Web API 是促进和推动代码复用的技术之一。因此，确保良好的文档，更重要的是，尊重标准，是良好的实践，这表明你了解提供可重用 API 的方法。为此，我们有了
    **Swagger**，它遵循 **OpenAPI 规范**。
- en: The OpenAPI Specification is known as the standard for describing modern APIs.
    One of the most widely used tools for documenting APIs in an **ASP.NET Core Web
    API** is `Swashbuckle.AspNetCore`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI 规范被认为是描述现代 API 的标准。在 **ASP.NET Core Web API** 中，用于记录 API 的最广泛使用的工具之一是
    `Swashbuckle.AspNetCore`。
- en: The good thing about using the `Swashbuckle.AspNetCore` library is where you
    can set the **Swagger UI** viewer for your web API, which is a good, graphical
    way to distribute the APIs.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Swashbuckle.AspNetCore` 库的好处在于，你可以为你的 Web API 设置 **Swagger UI** 查看器，这是一种良好的、图形化的方式来分发
    API。
- en: We will learn how to use this library in ASP.NET Core web APIs in *Chapter 15*,
    *Applying Service-Oriented Architectures with .NET*. Until then, it is important
    to understand that this documentation will help not only your team but any developer
    who might use the APIs you are developing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 15 章“使用 .NET 应用服务架构”中学习如何在 ASP.NET Core Web API 中使用这个库。在此之前，了解这份文档不仅可以帮助你的团队，还可以帮助任何可能使用你正在开发的
    API 的开发者，这一点非常重要。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter aimed to help you understand the advantages of code reuse. It also
    gave you an idea about what code is not appropriate for reuse. This chapter also
    presented approaches for reusing and refactoring code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在帮助你了解代码复用的优势。它还让你对哪些代码不适合复用有了概念。本章还介绍了代码复用和重构的方法。
- en: Considering that technology without processes does not take you anywhere, a
    process was presented that helps enable code reuse. This process is related to
    using already completed components from your library, identifying features in
    the software requirements specification that are candidates to be designed as
    library components, modifying the specification considering these features, designing
    the reusable components, and building the project architecture with the new component
    library version.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到没有流程的技术无法带你走得更远，我们提出了一种帮助实现代码复用的流程。这个流程与使用库中已经完成的组件相关，识别软件需求规格说明中可以作为库组件设计的候选功能，根据这些功能修改规格，设计可重用组件，并使用新的组件库版本构建项目架构。
- en: Concluding this chapter, we presented .NET Standard libraries as an approach
    to reusing code for different C# platforms, indicating that .NET 8 and new versions
    allow the reuse of code across different platforms. This chapter also reinforced
    the principles of object-oriented programming when reusing code and presented
    generics as a sophisticated implementation to simplify the treatment of objects
    with the same characteristics.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的结尾，我们介绍了 .NET Standard 库作为在不同 C# 平台上复用代码的方法，指出 .NET 8 和新版本允许跨平台复用代码。本章还强化了在复用代码时面向对象编程的原则，并介绍了泛型作为一种复杂的实现方式，以简化具有相同特性的对象的处理。
- en: Questions
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Can copy-and-paste be considered code reuse? What are the impacts of this approach?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以将复制粘贴视为代码复用吗？这种方法的有哪些影响？
- en: How can you reuse code without copying and pasting it?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在不复制粘贴的情况下复用代码？
- en: Is there a process that can help with code reuse?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有没有可以帮助代码复用的流程？
- en: What is the difference between .NET Standard and .NET Core?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET Standard 和 .NET Core 之间的区别是什么？
- en: What are the advantages of creating a .NET Standard library?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 .NET Standard 库有哪些优势？
- en: How does object-oriented analysis help with code reuse?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 面向对象分析如何帮助代码复用？
- en: How do generics help with code reuse?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 泛型如何帮助代码复用？
- en: Will .NET Standard be replaced by .NET 6?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET Standard 将会被 .NET 6 取代吗？
- en: What are the challenges related to refactoring?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与重构相关的挑战有哪些？
- en: Further reading
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following are some books and websites where you will find more information
    about the topics covered in this chapter:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些书籍和网站，你可以在那里找到本章涵盖主题的更多信息：
- en: '*Clean Code: A Handbook of Agile Software Craftmanship* by Martin, Robert C.
    Pearson Education, 2012.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《敏捷软件开发工艺手册：Clean Code》*，作者：马丁，罗伯特·C·皮尔逊教育，2012年。'
- en: '*Clean Architecture: A Craftsman’s Guide to Software Structure and Design*
    by Martin, Robert C. Pearson Education, 2018.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《整洁架构：软件结构与设计的工匠指南》* 由 Martin，Robert C. Pearson Education 著，2018年。'
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* by Eric Gamma
    [et al.] Addison-Wesley, 1994.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《设计模式：可复用面向对象软件元素》* 由 Eric Gamma [等] 著，Addison-Wesley，1994年。'
- en: '*Design Principles and Design Patterns* by Robert C. Martin, 2000.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《设计原则与设计模式》* 由 Robert C. Martin 著，2000年。'
- en: '*Refactoring* by Martin Fowler, 2018.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《重构》* 由 Martin Fowler 著，2018年。'
- en: 'If you need more information about .NET Standard:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您需要更多关于 .NET Standard 的信息：
- en: '[https://devblogs.microsoft.com/dotnet/introducing-net-standard/](https://devblogs.microsoft.com/dotnet/introducing-net-standard/)'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/dotnet/introducing-net-standard/](https://devblogs.microsoft.com/dotnet/introducing-net-standard/)'
- en: '[https://www.packtpub.com/application-development/net-standard-20-cookbook](https://www.packtpub.com/application-development/net-standard-20-cookbook)'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/net-standard-20-cookbook](https://www.packtpub.com/application-development/net-standard-20-cookbook)'
- en: '[https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/](https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/)'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/](https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/)'
- en: '[https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/](https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/)'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/](https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/)'
- en: 'A great guide for programming using the generics concept: [https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/generics/](https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/generics/)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用泛型概念进行编程的绝佳指南：[https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/generics/](https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/generics/)
- en: 'Some links that may help you with the documentation of libraries and APIs:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些可能有助于您编写库和 API 文档的链接：
- en: '[https://dotnet.github.io/docfx/](https://dotnet.github.io/docfx/)'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://dotnet.github.io/docfx/](https://dotnet.github.io/docfx/)'
- en: '[https://github.com/domaindrivendev/Swashbuckle.AspNetCore](https://github.com/domaindrivendev/Swashbuckle.AspNetCore)'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/domaindrivendev/Swashbuckle.AspNetCore](https://github.com/domaindrivendev/Swashbuckle.AspNetCore)'
- en: '[https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger](https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger)'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger](https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger)'
- en: Learn more on Discord
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the authors, and learn about new releases – follow the QR code
    below:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的 Discord 社区——在那里您可以分享反馈、向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
- en: '![](img/QR_Code175081751210902046.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code175081751210902046.png)'
