

# 第九章：构建弹性的微服务

在 Saga 模式之后，我们可以欣赏到在我们的微服务应用程序中内置安全措施的价值。我们需要确保我们充分处理不可避免的故障。

我们不能假设我们的分布式微服务始终处于运行状态。我们也不能假设我们的支持性基础设施将是可靠的。这些考虑让我们必须预测失败的发生，无论是长期的还是短暂的。

长时间的中断可能是由服务器或服务的故障，或基础设施的一些通常很重要的部分引起的。这些通常更容易检测和缓解，因为它们对应用程序的运行时间有更明显的影响。瞬态故障的检测要困难得多，因为它们可能持续几秒钟到几分钟，通常与基础设施中的任何明显问题无关。一个服务响应时间多出 5 秒的情况也可以被视为瞬态故障。

非常重要的一点是，我们不仅要编写不会因为瞬态问题而破坏应用程序的代码，还要知道在遇到更严重的故障时何时中断该应用程序。这是衡量用户对我们应用程序体验的重要部分。

在本章中，我们将探讨在微服务架构中导航可能的故障时可以实施的多种场景和对策。

在阅读本章之后，我们将了解如何做以下事情：

+   构建弹性的微服务通信

+   实施缓存层

+   实施重试和断路器策略

# 技术要求

本章中使用的代码参考可以在项目仓库中找到，该仓库托管在 GitHub 上，网址为：[`github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch09`](https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch09)。

# 服务弹性的重要性

在我们进入技术解释之前，让我们尝试理解什么是弹性。单词*resilient*是*resiliency*的基础词，它指的是实体对负面因素的抵抗力。它指的是实体对不可避免的故障的反应能力以及实体能够抵抗未来故障的能力。

在我们的微服务架构的背景下，我们的实体是我们的服务，我们知道故障会发生。故障可能很简单，比如内部操作中的超时，通信丢失，或者服务的重要资源意外中断。

## 可能的故障场景及其处理方法

以我们的医疗预约系统为例，让我们假设我们的预约服务需要检索相关患者的详细信息。*预约服务*将对*患者服务*进行同步 HTTP 调用。在这个通信步骤中的步骤可能看起来像这样：

1.  *预约服务*向*患者服务*发起 HTTP 请求，传递患者 ID（`AppointmentsController.cs`）。

1.  *患者服务*接收 HTTP 请求并执行查询以查找患者的记录（`PatientsController.cs`）。

1.  *患者服务*以适当的数据响应*预约服务*。

到目前为止，我们已经从我们的*同步服务*通信流程中期待这种情况。然而，这是一个一切按预期工作的理想流程，根据你的基础设施，你可以保证每次都能达到一定的成功率。我们需要考虑的是平衡——流程可能被中断的少数几次，并且没有成功完成操作链。这可能是因为失败，或者我们可能只需要更多一点时间。也可能是因为我们需要提前结束调用，因为它花费了太长时间。

现在，让我们回顾一下在服务调用过程中出现失败的情况：

1.  *患者服务*向*预约服务*发起 HTTP 请求，传递患者 ID。

1.  *预约服务*响应了一个`BAD GATEWAY (502)`错误代码。

1.  当*患者服务*接收到`BAD GATEWAY`响应时，会立即抛出异常。

1.  用户收到错误消息。

在这种情况下，我们收到了预约服务调用提前终止的情况。`5xx`范围内的 HTTP 响应表明与预约服务相关的资源或服务器存在问题。这些`5xx`错误可能是临时的，立即的后续请求可能会成功。特别是`BAD GATEWAY`错误可能是由于服务器配置不良、代理服务器故障或当时对请求响应过多。

在解决这些问题时，有时我们可以重试请求，或者有一个备用的数据源。虽然我们将在本书的后面讨论重试逻辑，但我们探索使用某种形式的缓存层，使我们能够维护一个稳定的数据层，从中我们可以获取所需的信息。

让我们回顾一下如何实现一个缓存层来协助这个问题。

# 使用缓存和消息代理实现弹性

我们将深入探讨如何使用**重试策略**和**断路器模式**来使我们的服务具有弹性，但我们的微服务架构并不局限于这些方法。我们可以通过**缓存**和**消息代理**机制来支持服务的弹性。添加一个缓存层允许我们创建一个临时中间数据存储，这在尝试从当前离线的服务检索数据时非常有用。我们的消息代理有助于确保消息将被投递，这对于写操作尤其有用。

让我们讨论消息代理以及它们如何帮助我们实现弹性。

## 使用消息代理

**消息代理**提供了更高的数据交付保证，这增加了弹性。这是建立在消息代理不会长时间不可用的基础上的，一旦消息被放置在消息总线上，即使监听服务（或服务）离线，也不会有任何影响。正如我们之前讨论的，我们可以几乎保证数据将通过异步通信成功发布，因为消息代理被设计为保留信息，直到它被消费。

消息代理也支持重试逻辑，如果由于任何原因消息没有成功处理，它将被返回到队列以稍后处理。我们想要管理消息投递的重试次数，因此我们应该配置我们的消息代理将消息传输到*死信*队列，在那里我们存储*毒化*消息。

我们还需要考虑如何处理消息重复。如果由于某种原因我们没有立即处理发送到队列的消息，然后消息再次从重试中发送到队列，这种情况就会发生。这会导致队列中出现两次相同消息，并且不一定按正确顺序排列，或者一个接一个。我们必须确保我们的消息包含足够的信息，以便我们能够在消息消费者中充分开发冗余检查。

我们在前面章节中探讨了与消息代理的集成，因为我们讨论了服务之间的异步通信。现在，让我们探索实现缓存层。

## 使用缓存层

**缓存**可以是弹性策略中的一个宝贵部分。我们可以采用一种缓存策略，在服务离线时回退到这个缓存。这意味着我们可以将缓存层用作回退数据源，并给最终用户造成所有服务都在运行中的错觉。这个缓存将定期更新和维护，每次修改源服务数据库中的数据时都会进行。这将有助于保持缓存数据的更新。

当然，采用这种策略，我们需要接受可能存在过时数据的影响。如果源服务离线并且支持数据库正在更新（可能由其他作业进行），那么缓存最终会变成一个过时数据源。我们采取的确保其新鲜度的措施越多，我们引入的应用程序复杂性就越大。

尽管添加缓存层可能有利有弊，但我们能看到它将极大地增强我们的微服务应用程序，并减少用户可能看到的错误数量，这些错误源于短暂甚至长期的故障。

实现缓存层最有效的方法是作为分布式缓存。这意味着架构中的所有系统都将能够访问中央缓存，该缓存作为一个外部独立服务存在。这种实现可以提高速度并支持扩展。我们可以使用 Redis 缓存作为我们的分布式缓存技术，我们将研究如何将其集成到 ASP.NET Core 应用程序中。

## 使用 Redis 缓存

**Redis 缓存** 是一种流行的缓存数据库技术。它是一个开源的内存数据存储，也可以用作消息代理。它可以在本地机器上用于本地开发工作，但有时也会部署在中央服务器上以支持更分布式系统。Redis 缓存是一个键值存储，使用唯一的键来索引值，且没有两个值可以具有相同的键。这使得从这种类型的数据存储中存储和检索数据变得非常容易。除此之外，值可以存储在非常简单的数据类型中，如字符串、数字和列表，但 JSON 格式在更复杂的对象类型中更为流行。这样，我们可以在代码中序列化和反序列化这个字符串，并按需进行操作。

在云提供商如 Microsoft Azure 和 **Amazon Web Services**（**AWS**）上对 Redis 缓存也有广泛的支持。对于这个练习，您可以在本地安装 Redis 缓存，或者使用 **Docker** 容器。要开始在项目中使用 Redis 缓存，我们需要运行以下命令：

```cs
dotnet add package Microsoft.Extensions.Caching
  .StackExchangeRedis
```

然后，我们需要在我们的 `Program.cs` 文件中注册我们的缓存，如下所示：

```cs
// Register the RedisCache service
services.AddStackExchangeRedisCache(options =>
{
    options.Configuration = "Configuration.GetSection
        ("Redis")["ConnectionString"]
});
```

您可以在 `appsettings.json` 文件或应用程序密钥中配置连接字符串。它可能看起来像这样：

```cs
"Redis": {
  "ConnectionString": "CONNECTION_STRING_HERE"
}
```

这些步骤为我们的应用程序添加了缓存支持。现在，我们可以在应用程序中按需读取和写入缓存。通常，当数据被增强时，我们希望写入缓存——新数据应写入缓存——我们可以删除旧版本并为修改后的数据创建新版本；对于已删除的数据，我们也会从缓存中删除数据。

我们可以创建一个单一的 `CacheProvider` 接口和实现，作为我们所需缓存操作的包装器。我们的接口看起来像这样：

```cs
public interface ICacheProvider
{
    Task ClearCache(string key);
    Task<T> GetFromCache<T>(string key) where T : class;
    Task SetCache<T>(string key, T value,
      DistributedCacheEntryOptions options) where T :
        class;
}
```

我们的实现看起来像这样：

```cs
public class CacheProvider : ICacheProvider
{
    private readonly IDistributedCache _cache;
    public CacheProvider(IDistributedCache cache)
    {
        _cache = cache;
    }
    public async Task<T> GetFromCache<T>(string key) where
        T : class
    {
        var cachedResponse = await
            _cache.GetStringAsync(key);
        return cachedResponse == null ? null :
            JsonSerializer.Deserialize<T>(cachedResponse);
    }
    public async Task SetCache<T>(string key, T value,
        DistributedCacheEntryOptions options) where T :
            class
    {
        var response = JsonSerializer.Serialize(value);
        await _cache.SetStringAsync(key, response,
            options);
    }
    public async Task ClearCache(string key)
    {
        await _cache.RemoveAsync(key);
    }
}
```

这段代码允许我们与我们的分布式缓存服务交互，并根据其关联的键检索、设置或删除值。此服务可以在我们的 **控制反转**（**IoC**）容器中注册，并根据需要注入到我们的控制器和存储库中。

这里的想法是，当我们需要从缓存中读取值时，我们可以使用`GetFromCache`方法。键允许我们缩小到我们感兴趣的条目，而`T`泛型参数允许我们定义所需的数据类型。如果我们需要更新缓存中的数据，我们可以清除与适当键关联的缓存记录，然后使用`SetCache`将带有相关键的新数据放置进去。我们将解析新数据到 JSON，以确保我们不违反支持的数据类型，同时保持存储复杂数据的能力。当我们添加新数据时，我们只需调用`SetCache`并添加新数据。

我们还希望尽可能保持数据的 freshness。一个流行的模式是在数据输入或更新时清除缓存并创建一个新的条目。

我们可以在我们的应用程序中使用这些代码片段并实现一个缓存层来提高性能、弹性和稳定性。我们仍然面临在操作失败初始调用时重试操作的问题。在下一节中，我们将探讨我们如何实现我们的重试逻辑。

# 实现重试和断路器策略

服务失败有多种原因。对服务失败的典型响应是 HTTP 响应在*5xx*范围内。这些通常突出显示托管服务器的问题或服务所在网络的暂时中断。在发生故障时，我们不尝试确定故障的确切原因，我们需要添加一些安全措施来确保在发生此类错误时应用程序的连续性。

因此，我们应该在我们的服务调用中使用重试逻辑。如果返回错误代码，这些逻辑将自动重新提交初始请求，这可能足以让短暂错误自行解决，并减少初始错误可能对整个系统和操作产生的影响。在这个策略中，我们通常允许在每次请求尝试之间经过一段时间。这就是我们的重试策略的总结。

我们不希望在我们的重试中继续执行它们而没有某种形式的退出条件。如果目标服务保持无响应，这将类似于实现一个无限循环，并且无意中对我们自己的服务执行**拒绝服务**（**DoS**）攻击。因此，我们实现断路器模式，它充当我们服务调用的协调器。

我们需要实现一个**重试策略**，至少在得出明确的失败结论之前进行几次调用。这将使我们的服务更能抵抗潜在的短暂错误，并允许应用程序确保用户体验不会直接受到影响。现在，重试并不总是答案。在这里进行重试是有意义的，因为服务以明确的失败响应，我们决定再次尝试。我们需要决定重试次数过多，并相应地停止。

我们可以使用 **断路器模式** 来控制重试次数并设置将决定连接应保持打开并监听响应多长时间的参数。这种简单技术有助于减少重试次数，并更好地控制重试发生的方式。

*断路器* 位于客户端和服务器之间。在我们的微服务应用程序中，发起调用的服务是客户端，而接收请求的目标服务是服务器。最初，它允许所有调用通过。我们称这为 *关闭状态*。如果检测到错误，可能是错误响应或延迟响应，则 *断路器打开*。一旦断路器打开，后续调用将更快失败。这将缩短等待响应的时间。它将等待配置的超时时间，然后如果目标服务已恢复，将再次允许调用。如果没有改进，则断路器将中断传输。

使用这两种技术，我们既可以应对瞬时故障，又确保长期故障不会以糟糕的用户体验的形式出现。在 .NET Core 中，我们有 **Polly** 的优势，这是一个允许我们几乎原生支持重试和断路器策略并实现弹性 Web 服务调用的包。我们将在下一节中探讨将 Polly 集成到我们的应用程序中。

## Polly 重试策略

Polly 是一个框架，允许我们为我们的应用程序添加一层新的弹性。它作为两个服务之间的一个层，存储已发起请求的详细信息并监控响应时间及/或响应代码。它可以配置用于确定失败外观的参数，并且我们可以进一步配置我们希望采取的操作类型。这种操作可以是重试或请求的取消。

Polly 在 .NET Core 中方便可用，并且在全球范围内被广泛使用和信任。让我们回顾一下在应用程序中实现此框架并监控 *Patients API* 将对 *Documents API* 发起的调用的步骤。

要将其添加到我们的 .NET Core 应用程序中，并允许我们为我们的 `HttpClient` 对象编写扩展代码，我们首先通过 NuGet 添加这些包：

```cs
Install-Package Polly
Install-Package Microsoft.Extensions.Http.Polly
```

现在，在我们的 `Program.cs` 文件中，我们可以配置我们的针对 *Documents API* 的类型化 HTTP 客户端以使用我们为 Polly 定义的策略的扩展代码。在 `Program.cs` 文件中，我们可以定义类型化客户端的注册如下：

```cs
builder.Services.AddHttpClient<IDocumentService,
     DocumentService>()
.AddPolicyHandler(GetRetryPolicy());
```

我们已经为我们的 HTTP 客户端添加了一个策略处理器，因此它将自动为使用此客户端发出的所有调用调用。我们现在需要定义一个名为 `GetRetryPolicy()` 的方法来构建我们的策略：

```cs
static IAsyncPolicy<HttpResponseMessage> GetRetryPolicy()
        {
            return HttpPolicyExtensions
                .HandleTransientHttpError()
                .OrResult(r => !r.IsSuccessStatusCode)
                .Or<HttpRequestException>()
                .WaitAndRetryAsync(5, retryAttempt =>
                   TimeSpan.FromSeconds(Math.Pow(2,
                     retryAttempt)), (exception, timeSpan,
                         context) => {
                    // Add logic to be executed before each
                    retry, such as logging or
                      reauthentication
                });
        }
```

由于使用了构建器模式，这可能会显得有些复杂，但它很容易理解，并且足够灵活，可以定制以满足您的需求。首先，我们定义返回类型或方法为`IAsyncPolicy<HttpResponseMessage>`，这与我们的 HTTP 客户端调用返回的类型相对应。然后，我们允许策略观察瞬态 HTTP 错误，框架可以默认确定这些错误，并且我们可以通过添加更多条件来扩展这种逻辑，例如观察`IsSuccessStatusCode`的值，它返回操作成功或失败的`true`或`false`，或者如果返回了`HttpRequestException`。

这几个参数涵盖了 HTTP 响应的一般最坏情况。然后，我们设置重试的参数。我们希望最多重试 5 次，并且每次重试都应该在前一次调用后的 2 秒开始，以滚动间隔进行。这样，我们在每次重试之间允许一些时间。这就是*退避*的概念。

最后，我们可以定义在每次重试之间想要采取的操作。这可能包括一些错误处理或重新认证逻辑。

重试策略可能会对您的系统产生负面影响，尤其是在我们可能存在高并发和高资源竞争的情况下。我们需要确保我们有一个稳固的策略，并有效地定义我们的延迟和重试。回想一下，一个配置不当的重试策略可能会导致对您自己服务的 DoS 攻击，使应用程序面临重大的性能问题。

考虑到有可能实现某种可能以这种方式产生负面影响的方案，我们现在需要一个防御屏障来减轻这种风险，并在错误持续不断的情况下打破重试循环。最佳的防御策略是使用断路器，我们将使用 Polly 来配置它。

## 使用 Polly 的断路器策略

正如我们在本章中讨论的那样，我们应该处理那些需要较长时间才能解决的问题，并在我们得出结论，服务在比预期更长的时间内无响应时，定义一个放弃对服务重试调用的策略。

我们可以通过定义断路器策略并将其添加为 HTTP 处理程序到我们的客户端中，从使用 Polly 添加重试策略的代码继续。我们修改客户端在`Program.cs`文件中的注册，如下所示：

```cs
builder.Services.AddHttpClient<IDocumentService,
    DocumentService>().AddPolicyHandler(GetRetryPolicy())
.AddPolicyHandler(GetCircuitBreakerPolicy());
```

现在，我们可以添加`GetCircuitBreakerPolicy()`方法如下：

```cs
static IAsyncPolicy<HttpResponseMessage>
    GetCircuitBreakerPolicy()
{
    return HttpPolicyExtensions
        .HandleTransientHttpError()
        .CircuitBreakerAsync(5, TimeSpan.FromSeconds(30));
}
```

此策略定义了一个断路器，当连续发生`5`次重试失败时，它会打开电路。一旦达到这个阈值，电路将断开 30 秒，并自动失败所有后续调用，这些调用将被解释为 HTTP 失败响应。

在这两个策略到位后，您可以编排您的服务重试，并显著减少计划外停机对您的应用程序和最终用户体验的影响。断路器策略还增加了一层保护，以防止重试策略可能产生的任何潜在不利影响。

现在，让我们总结一下我们关于实现弹性网络服务所学到的东西。

# 摘要

本章内容帮助我们更加关注微服务应用程序中潜在失败的可能性。这些概念不仅帮助我们构建强大且稳定的网络服务，还极大地增强了它们之间的通信机制。

我们看到，服务中断并不总是由于初始网络服务的代码错误或数据库和服务器，我们还促进了服务间的通信，这导致了对网络、第三方服务和一般基础设施正常运行时间的更大依赖。这导致我们实施应急措施，以确保我们的应用程序尽可能为用户提供良好的体验。

我们探讨了提高服务可靠性的几种技术，例如使用 Redis Cache 等技术为我们的`GET`操作添加缓存层，为我们的写入操作使用消息代理，以及使用 Polly 等框架编写更健壮的代码。使用 Polly，我们探讨了如何自动重试服务调用，并使用断路器来防止这些重试过于宽松并引起其他问题。

由于服务可能会失败，我们需要重试方法，因此我们还需要一种方法来监控服务的健康状态，以便我们能够了解为什么重试不有效。这意味着我们需要引入*健康检查*，以便在服务基础设施出现故障时提醒我们。我们将在下一章中探讨这一点。
