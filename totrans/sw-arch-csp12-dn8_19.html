<html><head></head><body>
<div><h1 class="chapterNumber">19</h1>
<h1 class="chapterTitle" id="_idParaDest-376">Client Frameworks: Blazor</h1>
<p class="normal">In this chapter, you will learn how to implement presentation layers based on client technologies. Applications based on server technologies, like ASP.NET Core MVC, run all application layers on the server, thus also creating on the server the HTML that encodes the whole UI. Applications based on client technologies, instead, run the whole presentation layer on the client machine (mobile device, desktop computer, laptop, etc.) thus interacting with a server just to exchange data with the web API.</p>
<p class="normal">In other words, in an application based on client technology, the whole UI is created by code that runs on the user device, which also controls the whole user-application interaction. Both the business layer and the domain layer, instead, run on server machines to prevent users from violating business rules and authorization policies by hacking the code that runs on their devices.</p>
<p class="normal">In turn, applications based on client technologies can be classified as single-page applications, which benefit from web standards, or as native applications, which are tied to specific operating systems and the advantages of specific device peculiarities. </p>
<p class="normal">Single-page applications are based on JavaScript or WebAssembly and run in any browser. As an example of a single-page application, we will analyze the Blazor WebAssembly framework</p>
<p class="normal">Blazor WebAssembly applications are developed in C# and use many technologies we already analyzed in <em class="italic">Chapter 17</em>, <em class="italic">Presenting ASP.NET Core</em>, such as dependency injection and Razor. Therefore, we strongly recommend studying <em class="italic">Chapter 17</em>, <em class="italic">Presenting ASP.NET Core</em>, and <em class="italic">Chapter 18</em>, <em class="italic">Implementing Frontend Microservices with ASP.NET Core</em>, before reading this chapter.</p>
<p class="normal">As an example of native technologies, we will analyze native .NET MAUI Blazor, which is completely analogous to Blazor WebAssembly but instead of using browser WebAssembly, it uses .NET, which is compiled just in time into the assembly of the target device. Not being limited by browser restrictions, .NET MAUI Blazor can access all device features through adequate .NET libraries.</p>
<p class="normal">More specifically, in this chapter, you will learn about the following subjects:</p>
<ul>
<li class="bulletList">Comparison of the various types of client technologies</li>
<li class="bulletList">Blazor WebAssembly architecture</li>
<li class="bulletList">Blazor pages and components</li>
<li class="bulletList">Blazor forms and validation</li>
<li class="bulletList">Blazor advanced features, such as JavaScript interoperability, globalization, authentication, and more</li>
<li class="bulletList">Third-party tools for Blazor WebAssembly</li>
<li class="bulletList">.NET MAUI Blazor</li>
</ul>
<p class="normal">While there is also server-side Blazor, which runs on the server like ASP.NET Core MVC, this chapter discusses just Blazor WebAssembly and .NET MAUI Blazor, since the main focus of the chapter is client-side technology. Moreover, server-side Blazor can’t provide a performance that is comparable with other server-side technologies, like ASP.NET Core MVC, which we analyzed in <em class="italic">Chapter 17</em>, <em class="italic">Presenting ASP.NET Core</em>.</p>
<p class="normal">The first section summarizes and compares the various kinds of client technologies, while the remainder of the chapter discusses in detail Blazor WebAssembly and .NET MAUI Blazor.</p>
<h1 class="heading-1" id="_idParaDest-377">Technical requirements</h1>
<p class="normal">This chapter requires the free Visual Studio 2022 Community edition or better with all the database tools installed.</p>
<div><p class="normal">All concepts are clarified with simple example applications based on the WWTravelClub book use case you can find in the <em class="italic">Using client technologies</em> section of <em class="italic">Chapter 21</em>, <em class="italic">Case Study</em>.</p>
</div>
<p class="normal">The code for this chapter is available at <a href="https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E">https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E</a>.</p>
<h1 class="heading-1" id="_idParaDest-378">Comparison of the various types of client technologies</h1>
<p class="normal">This <a id="_idIndexMarker1307"/>section discusses the various types of client technologies:</p>
<ul>
<li class="bulletList">Single-page applications, which run in the browser with all browser restrictions</li>
<li class="bulletList">Progressive applications, which run in the browser but can be installed like usual applications and can overcome some browser restrictions (after user permission is granted)</li>
<li class="bulletList">Native applications, which are tied to a specific device/operating system but can take full advantage of all device/operating system features</li>
<li class="bulletList">Cross-platform technologies, which, like native applications, can take full advantage of all device features but are compatible with several devices/operating systems</li>
</ul>
<h2 class="heading-2" id="_idParaDest-379">Single-page applications</h2>
<p class="normal">There are<a id="_idIndexMarker1308"/> many reasons why web development has increased in recent decades, but the most basic one is the ability to deploy any new version of the application to many users at the same time. Moreover, the security policies that are automatically enforced by all browsers encourage the usage and diffusion of web applications.</p>
<p class="normal">So, a good question <a id="_idIndexMarker1309"/>here would be, why is web development not used today? The best answer would be a lack of connectivity. As a software architect, you need to be alert to this, as we discussed in <em class="italic">Chapter 2</em>, <em class="italic">Non-Functional Requirements</em>.</p>
<p class="normal">Sometimes, it is not only a matter of having connectivity or not. Sometimes, a big problem is instability, and don’t forget the difficulties you will encounter from unexpected scenarios that web apps will generate once they’re out in the world.</p>
<p class="normal">For instance, in the WWTravelClub case, there is a first user story that says: <em class="italic">“As a common user, I want to view promotional packages on the home page, so that I can easily find my next vacation.”</em> At first sight, you may determine that a web app is the only option, especially because there is also a system requirement that says: <em class="italic">“The system will run on the Windows, Linux, iOS, and Android platforms.”</em></p>
<p class="normal">However, imagine that a user browsed a lot of destinations and packages to find their perfect vacation, and they are going to reserve it when suddenly, the web application crashes because of a lack of web connectivity. In this situation, the user would lose all their browsing<a id="_idIndexMarker1310"/> effort and would be forced to start searching for the package from scratch once web connectivity is restored. The issue can <a id="_idIndexMarker1311"/>be overcome just with an application that is able to save its state instead of crashing when there are web connectivity issues. This way, the user can complete their task as soon as web connectivity is restored, without wasting whatever effort they had already put in before the web connectivity issue.</p>
<p class="normal">So maybe, for some parts of the solution, a native application with some data already downloaded would be a better option. However, the issue can also be solved with a particular kind of modern web application, progressive applications, which we will analyze in the next subsection.</p>
<h2 class="heading-2" id="_idParaDest-380">Progressive applications</h2>
<p class="normal">Progressive <a id="_idIndexMarker1312"/>web applications are single-page applications that run in the browser but can be installed like native applications. Moreover, they can run offline.</p>
<p class="normal">Progressive applications <a id="_idIndexMarker1313"/>are a new web standard that is supported by all mainstream browsers. If you require all the advantages of web applications, but you also need the ability to work offline like a native application, progressive web applications are the right choice for you.</p>
<p class="normal">However, keep in mind that progressive web applications can’t ensure the same performance and flexibility as native applications.</p>
<p class="normal">Blazor WebAssembly, as<a id="_idIndexMarker1314"/> we will describe in the next sections of this chapter, supports progressive web applications. Check<a id="_idIndexMarker1315"/> the <strong class="keyWord">Progressive Web Application</strong> checkbox that appears when you create a Blazor WebAssembly project. This is all you need to do to create a Blazor progressive web application.</p>
<p class="normal">If you ship your Blazor application as a progressive application, you overcome the problem of the initial download time (4-8 seconds), which is the main disadvantage of Blazor. </p>
<p class="normal">While progressive web applications are installed applications, they automatically update to the last available version, because each time they are launched, they verify if a more recent version is available, and if there is one, they automatically download it before running. That is, they have the advantage of automatically running the most recent available version that characterizes all classical web applications.</p>
<p class="normal">The option <a id="_idIndexMarker1316"/>to install the Blazor progressive web application is not available during development because this would interfere with the usual modification test cycle. Therefore, you need to publish your application to test its progressive application peculiarities.</p>
<p class="normal">It is worth<a id="_idIndexMarker1317"/> pointing out that progressive applications must be organized to take full advantage of their ability to work offline. Therefore, following repeated communication errors, the application should save all the data to be sent to the server in the browser’s local storage while waiting for a connection to be established successfully.</p>
<p class="normal">It is also possible to maintain the whole application state in a centralized service so that the user can serialize and save it to local storage before quitting the application. This way, when the application is offline, data to be sent to the server is not lost because it remains in the application state that is saved to disk.</p>
<p class="normal">When a progressive web application doesn’t fulfill your requirements because it is not able to use the specific device features you need, but you must support several different devices, you should consider cross-platform native applications, which have full access to all device features but can still support several hardware/software platforms. We will discuss them in the next subsection.</p>
<h2 class="heading-2" id="_idParaDest-381">Native applications</h2>
<p class="normal">Native <a id="_idIndexMarker1318"/>development <a id="_idIndexMarker1319"/>can be considered the beginning of UI development. There was no concept of sharing code between machines with diverse hardware when the idea of assigning software production to another person/company originally emerged.</p>
<p class="normal">This is the first good answer as to why we have good performance on native applications. We cannot forget that native apps run better just because they are near the hardware, most of the time connected to the OS directly or by using a framework, such as .NET. Be careful; we are not only talking about native mobile apps, but we are also discussing apps delivered in Windows, Linux, Mac, Android, or any other OS that can run apps.</p>
<p class="normal">Considering this scenario, the big question is – when do I have to use a native app? There are some <a id="_idIndexMarker1320"/>cases where this would be a good idea:</p>
<ul>
<li class="bulletList">There is no need to deploy on different platforms.</li>
<li class="bulletList">There is a huge connection to the hardware.</li>
<li class="bulletList">The performance provided by a web client is not acceptable.</li>
<li class="bulletList">The application needs device resources that can’t be accessed through a browser because of a browser’s security policies.</li>
<li class="bulletList">The place where the application will run has connectivity problems.</li>
<li class="bulletList">The worst case is the one where you need two things at the same time: better performance than a web client and different platforms. In this scenario, you will probably have to deliver two applications, and the way you have designed the backend of this solution will be extremely important for reducing maintenance and costs as regards development.</li>
</ul>
<p class="normal">The <a id="_idIndexMarker1321"/>decision between developing native or not can be difficult to take <a id="_idIndexMarker1322"/>without a <strong class="keyWord">proof of concept</strong> (<strong class="keyWord">POC</strong>). As a software architect, you should be the one to recommend this kind of POC.</p>
<p class="normal">Examples of native applications that you can develop with C# are the classical Windows Forms and Windows Presentation Foundation, which are specific to the Windows operating system. Also, there is Xamarin, a platform that allows for the development of applications that can be published on both Android and iOS.</p>
<h2 class="heading-2" id="_idParaDest-382">Cross-platform applications</h2>
<p class="normal">Although<a id="_idIndexMarker1323"/> performance can be a difficult requirement to achieve, in <a id="_idIndexMarker1324"/>many scenarios, due to the simplicity of the solution, this is not the Achilles’ heel of the application. Considering WWTravelClub, although it would be useful to have the offline experience mentioned before, the performance itself is not the most difficult one to achieve.</p>
<p class="normal">In these scenarios, cross-platform technologies make total sense. Among them, it is worth mentioning Xamarin.Forms and the new .NET MAUI, which can be published on Android, iOS, and Windows.</p>
<p class="normal">The advised choice of cross-platform application is .NET MAUI. However, at the moment, MAUI supports Windows and all <a id="_idIndexMarker1325"/>main mobile platforms but not Linux. Uno Platform (<a href="https://platform.uno/">https://platform.uno/</a>) also supports Linux together with all main mobile platforms but is not a Microsoft product maintained by Microsoft. Anyway, it can be downloaded as a Visual Studio extension.</p>
<p class="normal">In this chapter, we <a id="_idIndexMarker1326"/>will not analyze Uno or all the options offered by .NET MAUI but just .NET MAUI Blazor since it is very similar to Blazor WebAssembly. So, learning Blazor enables us to develop single-page applications, progressive applications, and cross-platform applications.</p>
<p class="normal">.NET MAUI Blazor is described in the <em class="italic">.NET MAUI Blazor</em> section of this chapter, while the next section describes the basics of Blazor WebAssembly architecture.</p>
<h1 class="heading-1" id="_idParaDest-383">Blazor WebAssembly architecture</h1>
<p class="normal">Blazor WebAssembly <a id="_idIndexMarker1327"/>uses the new WebAssembly browser feature to execute the .NET runtime in the browser. This way, it enables all developers to use the whole .NET code base and ecosystem in the implementation of applications capable of running in any WebAssembly-compliant browser. WebAssembly was conceived as a high-performance alternative to JavaScript. It is an assembly capable of running in a browser and obeying the same limitations as JavaScript code. This means that WebAssembly code, like JavaScript code, runs in an isolated execution environment that has very limited access to all machine resources.</p>
<p class="normal">WebAssembly differs from similar options from the past, like Flash and Silverlight, since it is an official W3C standard. More specifically, it became an official standard on December 5, 2019, so it is expected to have a long life. As a matter of fact, all mainstream browsers already support it.</p>
<p class="normal">However, WebAssembly doesn’t bring just performance with it; it also creates the opportunity to run whole code bases associated with modern and advanced object-oriented languages such as C++ (direct compilation), Java (bytecode), and C# (.NET) in browsers.</p>
<p class="normal">At the moment, Microsoft offers two frameworks that run .NET on top of WebAssembly, Blazor WebAssembly and Unity WebAssembly, which is the WebAssembly port of the Unity 3D graphic framework. Unity WebAssembly’s main purpose is the implementation of online video games that run in the browser, while <a id="_idIndexMarker1328"/>Blazor WebAssembly is a <strong class="keyWord">single-page application</strong> framework that uses .NET instead of JavaScript or TypeScript.</p>
<p class="normal">Before WebAssembly, presentation layers running in a browser could only be implemented in JavaScript, with all the problems associated with the maintenance of big code bases implemented in a language that is not strictly typed. However, we must consider that on one hand, the usage of TypeScript in part solves JavaScript’s lack of strict typing, and on the other hand, .NET brings with it the problem of the binary compatibility of modules implemented with different .NET versions.</p>
<p class="normal">Anyway, with <a id="_idIndexMarker1329"/>Blazor C#, developers can now implement complex applications in their favorite language, with all the comforts offered to this language by the C# compiler and Visual Studio.</p>
<p class="normal">Moreover, with Blazor, all .NET developers can use the full power of the .NET framework, with the only limitations imposed by the browser security policies, for the implementation of presentation layers that run in the browser and that share libraries and classes with all other layers that run on the server side.</p>
<p class="normal">The subsections that follow describe all the Blazor architectures. The first subsection explores the general concept of a single-page application, describing Blazor’s peculiarities.</p>
<h2 class="heading-2" id="_idParaDest-384">What is a single-page application?</h2>
<p class="normal">A <strong class="keyWord">single-page application</strong> (<strong class="keyWord">SPA</strong>) is an<a id="_idIndexMarker1330"/> HTML-based application, where the HTML is changed by code that runs in the browser instead of issuing a new request to the server and rendering a new HTML page from scratch. SPAs can simulate a multi-page experience by replacing complete page areas with new HTML.</p>
<p class="normal">SPA frameworks are frameworks explicitly designed for implementing SPAs. Before WebAssembly, all SPA frameworks were based on JavaScript. The most famous JavaScript-based SPA frameworks are Angular, React.js, and Vue.js.</p>
<p class="normal">All SPA frameworks provide ways to transform data into HTML to show to the user and rely on a module called <em class="italic">router</em> to simulate page changes. Typically, data fills in the placeholders of HTML templates and selects which parts of a template to render (<code class="inlineCode">if-like</code> constructs) and how many times to render it (<code class="inlineCode">for-like</code> constructs).</p>
<p class="normal">The Blazor template language is Razor, which we described in <em class="italic">Chapter 17</em>, <em class="italic">Presenting ASP.NET Core</em>.</p>
<p class="normal">In order to increase modularity, code is organized into components, which are a kind of virtual HTML tag that, once rendered, generates actual HTML markup. Like HTML tags, components have attributes, which are usually called parameters, and custom events. It is up to the developer to ensure that each component uses its parameters to create proper HTML and to ensure that it generates adequate events. Components can be used inside other components in a hierarchical fashion.</p>
<p class="normal">Components <a id="_idIndexMarker1331"/>can be associated with URLs in the application web domain, in which case they are called pages. These URLs can be used in the usual HTML links and following them leads to the upload of the page into an application area thanks to framework services called routers.</p>
<p class="normal">Some SPA frameworks also provide a predefined dependency injection engine in order to ensure better separation between components on one side and general-purpose services plus business code that runs in the browser on the other. Among the frameworks listed in this subsection, only Blazor and Angular have an out-of-the-box dependency injection engine.</p>
<p class="normal">In order to reduce the overall application file size, SPA frameworks based on JavaScript usually compile all JavaScript code in a few JavaScript files and then perform so-called tree-shaking, that is, the removal of all unused code. This technique sensibly reduces the application load time.</p>
<p class="normal">At the moment, instead, Blazor keeps all DLLs referenced by the main application separate and performs tree-shaking on each of them separately.</p>
<p class="normal">The next subsection describes the Blazor architecture. We challenge you to create a Blazor WebAssembly project called <code class="inlineCode">BlazorReview</code>, so you can inspect the code and the constructs explained throughout the chapter. To do this, select the <strong class="screenText">Blazor WebAssembly Standalone Application</strong><strong class="keyWord"> </strong>option when creating a new project. Make sure to select <strong class="screenText">Individual Accounts</strong> as the authentication type and ensure that the <strong class="screenText">Include sample pages</strong> checkbox is checked, as shown in the picture below.</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_19_01.png"/></figure>
<p class="packt_figref">Figure 19.1: Creating the BlazorReview application</p>
<p class="normal">If you start <a id="_idIndexMarker1332"/>the application, the application works properly, but if you try to log in, the following error message will appear: “There was an error trying to log you in: ‘Network Error’.” This is because you need to configure an identity-provider-authenticated user. As the default, the application is configured to use an OAuth-based identity provider web application. You need to just add the provider configuration data in a configuration file. We will look at this in more detail in the <em class="italic">Authentication and authorization</em> section.</p>
<h2 class="heading-2" id="_idParaDest-385">Loading and starting the application</h2>
<p class="normal">The folder<a id="_idIndexMarker1333"/> structure of a Blazor WebAssembly application always includes an <code class="inlineCode">index.html</code> static HTML page. In our <code class="inlineCode">BlazorReview</code> project, <code class="inlineCode">index.html</code> is in <code class="inlineCode">BlazorReview-&gt;wwwroot-&gt;index.html</code>. This page is the container where the <a id="_idIndexMarker1334"/>Blazor application will create its HTML. It contains an HTML header with a <code class="inlineCode">viewport meta</code> declaration, the title, and CSS for the application’s overall styling. The Visual Studio default project template adds an application-specific CSS file and Bootstrap CSS, with a neutral style. You can replace the default <a id="_idIndexMarker1335"/>Bootstrap CSS either with a customized style or a completely different CSS framework.</p>
<p class="normal">The body contains the code that follows:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;body&gt;
&lt;div id="app"&gt;
&lt;svg class="loading-progress"&gt;
&lt;circle r="40%" cx="50%" cy="50%" /&gt;
&lt;circle r="40%" cx="50%" cy="50%" /&gt;
&lt;/svg&gt;
&lt;div id="loading-progress-text"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id="blazor-error-ui"&gt;
        An unhandled error has occurred.
    &lt;a href="" class="reload"&gt;Reload&lt;/a&gt;
&lt;a class="dismiss"&gt; / &lt;/a&gt;
&lt;/div&gt;
&lt;script
src="img/AuthenticationService.js"&gt;
&lt;/script&gt;
&lt;script src="img/blazor.webassembly.js"&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p class="normal">The initial <code class="inlineCode">div</code> with the <code class="inlineCode">app</code> <code class="inlineCode">id</code> is where the application will place the code it generates. Any markup placed inside this <code class="inlineCode">div</code> will appear just while the Blazor application is loading and starting, then it will be replaced by the application-generated HTML. As the default, it contains an <code class="inlineCode">svg</code> image and text that shows the loading progress, which are both controlled by the JavaScript code that takes care of loading the framework. The loading animation is based on a CSS animation contained in the <code class="inlineCode">css/app.css</code> main application CSS file. However, you can replace both the default content and the CSS animation.</p>
<p class="normal">The second <code class="inlineCode">div</code> is normally invisible and appears only when Blazor intercepts an unhandled exception.</p>
<p class="normal"><code class="inlineCode">blazor.webassembly.js</code> contains the JavaScript part of the Blazor framework. Among other things, it takes care of downloading the .NET runtime, together with all application DLLs. More specifically, <code class="inlineCode">blazor.webassembly.js</code> downloads the <code class="inlineCode">blazor.boot.json</code> file, which lists all application files with their hashes. </p>
<p class="normal">Then, <code class="inlineCode">blazor.webassembly.js</code> downloads all resources listed in this file and verifies their hashes. All resources downloaded by <code class="inlineCode">blazor.webassembly.js</code> are created when the application is built or published. Loading <code class="inlineCode">blazor.webassembly.js</code> periodically updates the <code class="inlineCode">--blazor-load-percentage</code> and <code class="inlineCode">--blazor-load-percentage-text</code> CSS variables with the loading percentage in numeric format and as text, respectively.</p>
<p class="normal"><code class="inlineCode">AuthenticationService.js</code> is added only when the project enables authentication and takes care<a id="_idIndexMarker1336"/> of the <code class="inlineCode">OpenID Connect</code> protocol used by Blazor to exploit other identity providers, to get bearer tokens, which are the preferred authentication credentials for clients that interact with a server through web APIs.</p>
<p class="normal">Authentication is discussed in more detail in the <em class="italic">Authentication and authorization</em> subsection later on in this chapter, while bearer tokens are discussed in the <em class="italic">REST service authorization and authentication</em> section of <em class="italic">Chapter 15</em>, <em class="italic">Applying Service-Oriented Architectures with .NET</em>.</p>
<p class="normal">The Blazor application entry point is in the <code class="inlineCode">BlazorReview-&gt;Program.cs</code> file. This file doesn’t contain a class but just the code that must be executed when the application is launched:</p>
<pre class="programlisting code"><code class="hljs-code">var builder = WebAssemblyHostBuilder.CreateDefault(args);
builder.RootComponents.Add&lt;App&gt;("#app");
builder.RootComponents.Add&lt; HeadOutlet&gt;("head::after");
// Services added to the application
// Dependency Injection engine declared with statements like:
// builder.Services.Add...
await builder.Build().RunAsync();
</code></pre>
<p class="normal">In fact, the new Blazor WebAssembly project template takes advantage of this new way to define the application entry point that was introduced starting from .NET 7.</p>
<p class="normal"><code class="inlineCode">WebAssemblyHostBuilder</code> is a builder for creating a <code class="inlineCode">WebAssemblyHost</code>, which is a WebAssembly-specific implementation of the generic host discussed in the <em class="italic">Using generic hosts</em> subsection of <em class="italic">Chapter 11</em>, <em class="italic">Applying a Microservice Architecture to Your Enterprise Application</em> (you are encouraged to review that subsection). The first builder configuration instruction declares the Blazor root component (<code class="inlineCode">App</code>), which will contain the whole component tree, and specifies in which HTML tag of the <code class="inlineCode">index.html</code> page to place it (<code class="inlineCode">#app</code>). More specifically, <code class="inlineCode">RootComponents.Add</code> adds a hosted service that takes care of handling the whole Blazor component tree. We can run several Blazor WebAssembly user interfaces on the same HTML page by calling <code class="inlineCode">RootComponents.Add</code> several times, each time with a different HTML tag reference.</p>
<p class="normal">As the <a id="_idIndexMarker1337"/>default, just another root component is added, <code class="inlineCode">HeadOutlet</code>, and is placed immediately after the <code class="inlineCode">HTML Head</code> tag. It is used to dynamically change the <code class="inlineCode">index.html</code> title (the text shown in the browser tab). For more information on the <code class="inlineCode">HeadOutlet</code> component, see the <em class="italic">Modifying HTML &lt;head&gt; content from Blazor component</em>s subsection.</p>
<p class="normal"><code class="inlineCode">builder.Services</code> contains all the usual methods and extension methods to add services to the Blazor application dependency engine: <code class="inlineCode">AddScoped</code>, <code class="inlineCode">AddTransient</code>, <code class="inlineCode">AddSingleton</code>, and so on. Like in ASP.NET Core MVC applications (<em class="italic">Chapter 17</em>, <em class="italic">Presenting ASP.NET Core</em>, and <em class="italic">Chapter 18</em>, <em class="italic">Implementing Frontend Microservices with ASP.NET Core</em>), services are the preferred places to implement business logic and store shared state. While in ASP.NET Core MVC services were usually passed to controllers, in Blazor WebAssembly, they are injected into components.</p>
<p class="normal">The default project scaffolded by Visual Studio contains just two services, one for communicating with the server and the other for handling OAuth-based authentication. We will discuss both of them later on in this chapter.</p>
<p class="normal">The next subsection explains how the root <code class="inlineCode">App</code> component simulates page changes.</p>
<h2 class="heading-2" id="_idParaDest-386">Routing</h2>
<p class="normal">The root <code class="inlineCode">App</code> class <a id="_idIndexMarker1338"/>referenced by the host-building code is defined in the <code class="inlineCode">BlazorReview -&gt;App.razor</code> file. <code class="inlineCode">App</code> is a Blazor component, and like all Blazor components, it is defined in a file with a <code class="inlineCode">.razor</code> extension and uses Razor syntax enriched with component notation, that is, with HTML-like tags that represent other Blazor components. It contains the whole logic for handling application pages:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;CascadingAuthenticationState&gt;
&lt;Router AppAssembly="@typeof(App).Assembly"&gt;
&lt;Found Context="routeData"&gt;
&lt;AuthorizeRouteView RouteData="@routeData"
 DefaultLayout="@typeof(MainLayout)"&gt;
&lt;NotAuthorized&gt;
         @*Template that specifies what to show
           when user is not authorized *@
        &lt;/NotAuthorized&gt;
&lt;/AuthorizeRouteView&gt;
&lt;FocusOnNavigate RouteData="@routeData" Selector="h1"&gt;
&lt;/Found&gt;
&lt;NotFound Layout="@typeof(MainLayout)"&gt;
&lt;PageTitle&gt;Not found&lt;PageTitle&gt;
&lt;LayoutView Layout="@typeof(MainLayout)"&gt;
&lt;p&gt;Sorry, there's nothing at this address.&lt;/p&gt;
&lt;/LayoutView&gt;
&lt;/NotFound&gt;
&lt;/Router&gt;
&lt;/CascadingAuthenticationState&gt;
</code></pre>
<p class="normal">All tags in the preceding <a id="_idIndexMarker1339"/>code represent either components or particular component parameters, called templates. Components will be discussed in detail throughout the chapter. For the moment, imagine them as a kind of custom HTML tags that we can somehow define with C# and Razor code. Templates, instead, are parameters that accept Razor markup as values. Templates are discussed in the <em class="italic">Templates and cascading parameters</em> subsection later on in this section.</p>
<p class="normal">The <code class="inlineCode">CascadingAuthenticationState</code> component only has the function of passing authentication and authorization information to all components of the component tree that is inside of it. The Blazor project template generates it only if one chooses to add authorization during project creation.</p>
<p class="normal">The <code class="inlineCode">Router</code> component is the actual application router. It scans the assembly passed in the <code class="inlineCode">AppAssembly</code> parameter looking for components containing routing information, that is, for components that can work as pages. In the Blazor project template, the <code class="inlineCode">Router</code> component is passed the assembly that contains the class of the <code class="inlineCode">App</code> component, that is, the main application. Pages contained in other assemblies can be added through the <code class="inlineCode">AdditionalAssemblies</code> parameter, which accepts an <code class="inlineCode">IEnumerable</code> of assemblies.</p>
<p class="normal">After that, the router intercepts all page changes performed either by code or through the usual <code class="inlineCode">&lt;a&gt;</code> HTML tags that point to an address inside of the application base address. Navigation can be handled by code by requiring a <code class="inlineCode">NavigationManager</code> instance from dependency injection.</p>
<p class="normal">The <code class="inlineCode">Router</code> component has two templates, one for the case where a page for the requested URI is found (<code class="inlineCode">Found</code>), and the other for the case where it is not found (<code class="inlineCode">NotFound</code>). When the application uses authorization, the <code class="inlineCode">Found</code> template consists of the <code class="inlineCode">AuthorizeRouteView</code> components, which further distinguish whether the user is authorized to access the selected page or not. When the application doesn’t use authorization, the <code class="inlineCode">Found</code> template consists of the <code class="inlineCode">RouteView</code> component:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;RouteView RouteData="@routeData" DefaultLayout="@typeof(MainLayout)" /&gt;
</code></pre>
<p class="normal"><code class="inlineCode">RouteView</code> takes the<a id="_idIndexMarker1340"/> selected page and renders it inside the layout page specified by the <code class="inlineCode">DefaultLayout</code> parameter. This specification acts as a default since each page can override it by specifying a different layout page. In the Blazor project template, the default layout page is in the <code class="inlineCode">BlazorReview-&gt;Layout-&gt;MainLayout.razor</code> file.</p>
<p class="normal">Blazor layout pages work similarly to ASP.NET Core MVC layout pages, described in the <em class="italic">Reusing view code</em> subsection of <em class="italic">Chapter 17</em>, <em class="italic">Presenting ASP.NET Core</em>, the only difference being that the place to add the page markup is specified with <code class="inlineCode">@Body</code>:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;article class="content px-4"&gt;
      @Body
&lt;/article&gt;
</code></pre>
<p class="normal">If the application uses authorization, <code class="inlineCode">AuthorizeRouteView</code> works like <code class="inlineCode">RouteView</code>, but it also allows the specification of a template for a case where the user is not authorized:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;NotAuthorized&gt;
@if (!context.User.Identity.IsAuthenticated)
{
  &lt;RedirectToLogin /&gt;
}
else
{
  &lt;p role ="alert"&gt;You are not authorized to access this resource.&lt;/p&gt;
}
&lt;/NotAuthorized&gt;
</code></pre>
<p class="normal">If the user is not authenticated, the <code class="inlineCode">RedirectToLogin</code> component uses a <code class="inlineCode">NavigationManager</code> instance to move to the login logic page; otherwise, it informs the users that they haven’t got enough privileges to access the selected page.</p>
<p class="normal">Blazor WebAssembly also allows the lazy loading of assemblies to reduce the initial application loading time, but we will not discuss it here for lack of space. The <em class="italic">Further reading</em> section contains references to the official Blazor documentation.</p>
<p class="normal">As we will discuss in more detail later on in this chapter, the <code class="inlineCode">PageTitle</code> component enables the developer to set the page title that appears in the browser tabs. The <code class="inlineCode">FocusOnNavigate</code> component, instead, sets the HTML focus on the first HTML element that satisfies the CSS selector passed in its <code class="inlineCode">Selector</code> parameter, immediately after a page is navigated.</p>
<h1 class="heading-1" id="_idParaDest-387">Blazor pages and components</h1>
<p class="normal">In this section, you<a id="_idIndexMarker1341"/> will learn the fundamentals of Blazor components, including how to construct a component, the structure of components, how to attach <a id="_idIndexMarker1342"/>events to HTML tags, how to specify the components’ characteristics, and how to use other components within your components. We have divided the content into several subsections:</p>
<ul>
<li class="bulletList">Component structure</li>
<li class="bulletList">Templates and cascading parameters</li>
<li class="bulletList">Error handling</li>
<li class="bulletList">Events</li>
<li class="bulletList">Bindings</li>
<li class="bulletList">How Blazor updates HTML</li>
<li class="bulletList">Component lifecycle</li>
</ul>
<h2 class="heading-2" id="_idParaDest-388">Component structure</h2>
<p class="normal">Components are<a id="_idIndexMarker1343"/> the core of all main client frameworks. They are the key ingredient to building modular UI, whose parts are easily modifiable and reusable. In a few words, they are the graphical counterpart of classes. In fact, just like classes, they allow encapsulation and code organization. Moreover, the component architecture allows the formal definition of efficacious UI update algorithms, as we will see in the <em class="italic">How Blazor updates HTML</em> section of this chapter.</p>
<p class="normal">Components are defined in files with a <code class="inlineCode">.razor</code> extension. Once compiled, they become classes that inherit from <code class="inlineCode">ComponentBase</code>. Like all other Visual Studio project elements, Blazor components are available through the <strong class="screenText">Add New Item</strong> menu. Usually, components to be used as pages are defined in the <code class="inlineCode">Pages</code> folder, or in its subfolders, while other components are organized in different folders. Default Blazor projects add all their non-page components inside the <code class="inlineCode">Shared</code> folder, but you can organize them differently.</p>
<p class="normal">By default, pages are assigned a namespace that corresponds to the path of the folder they are in. Thus, for instance, in our example project, all pages that are in the <code class="inlineCode">BlazorReview-&gt;Pages</code> path are assigned to the <code class="inlineCode">BlazorReview.Pages</code> namespace. </p>
<p class="normal">However, you can change this default namespace with an <code class="inlineCode">@namespace</code> declaration placed in the declaration area that is at the top of the file. This area may also contain other <a id="_idIndexMarker1344"/>important declarations. The following is an example that shows all declarations:</p>
<pre class="programlisting code"><code class="hljs-code">@page "/counter"
@layout MyCustomLayout
@namespace BlazorReview.Pages
@using Microsoft.AspNetCore.Authorization
@implements MyInterface
@inherits MyParentComponent
@typeparam T
@attribute [Authorize]
@inject NavigationManager navigation
</code></pre>
<p class="normal">The first two directives make sense only for components that must work as pages, while all others may appear in any component. Below is a detailed explanation of each declaration:</p>
<ul>
<li class="bulletList">The <code class="inlineCode">@layout</code> directive, when specified, overrides the default layout page with another component.</li>
<li class="bulletList">The <code class="inlineCode">@page</code> directive defines the path of the page (<strong class="keyWord">route</strong>) within the application base URL. Thus, for instance, if our application runs at <code class="inlineCode">https://localhost:5001</code>, then the URL of this page will be <code class="inlineCode">https://localhost:5001/counter</code>. Page routes can also contain parameters, like in this example: <code class="inlineCode">/orderitem/{customer}/{order}</code>. Parameter names must match public properties defined as parameters by the components. The match is case-insensitive. Parameters will be explained later on in this subsection.</li>
<li class="bulletList">The string that instantiates each parameter is converted into the parameter type, and if this conversion fails, an exception is thrown. This behavior can be prevented by associating a type with each parameter, in which case, if the conversion to the specified type fails, the match with the page URL fails. Only elementary types are supported: <code class="inlineCode">/orderitem/{customer:int}/{order:int}</code>. As a default, parameters are obligatory; that is, if they are not found, the match fails and the router tries other pages. However, you can make parameters optional by post-fixing them with a question mark: <code class="inlineCode">/orderitem/{customer?:int}/{order?:int}</code>. If an optional parameter is not specified, the default for its type is used. </li>
<li class="bulletList">From version 6, parameters can also be extracted from the query string: <code class="inlineCode">/orderitem/{customer:int}?order=123</code>.</li>
<li class="bulletList"><code class="inlineCode">@namespace</code> overrides the default namespace of the component, while <code class="inlineCode">@using</code> is equivalent to the usual C# <code class="inlineCode">using</code>. The <code class="inlineCode">@using</code> declared in the special <code class="inlineCode">{project folder}-&gt;_Imports.razor</code> folder is automatically applied to all components.</li>
<li class="bulletList"><code class="inlineCode">@inherits</code> declares <a id="_idIndexMarker1345"/>that the component is a subclass of another component, while <code class="inlineCode">@implements</code> declares that it implements an interface.</li>
<li class="bulletList"><code class="inlineCode">@typeparam</code> is used if the component is a generic class and declares the name of the generic parameter. <code class="inlineCode">@typeparam</code> also allows the specification of generic constraints with the same syntax used in classes: <code class="inlineCode">@typeparam T where T: class</code>.</li>
<li class="bulletList"><code class="inlineCode">@attribute</code> declares any attribute applied to the component class. Property-level attributes are applied directly to properties defined in the code area, so they don’t need special notation. The <code class="inlineCode">[Authorize]</code> attribute, applied to a component class used as a page, prevents unauthorized users from accessing the page. It works exactly in the same way as when it is applied to a controller or to an action method in ASP.NET Core MVC.</li>
<li class="bulletList">Finally, the <code class="inlineCode">@inject</code> directive requires a type instance to the dependency injection engine and inserts it in the field declared after the type name; in the previous example, in the <code class="inlineCode">navigation</code> parameter.</li>
</ul>
<p class="normal">The middle part of the component file contains the HTML that will be rendered by the component with Razor markup, enriched with the possible invocation of child components.</p>
<p class="normal">The bottom part of the file is enclosed by an <code class="inlineCode">@code</code> construct and contains fields, properties, and methods of the class that implements the component:</p>
<pre class="programlisting code"><code class="hljs-code">@code{
 ...
 private string myField="0";
 [Parameter]
 public int Quantity {get; set;}=0;
 private void IncrementQuantity ()
 {
         Quantity++;
 }
 private void DecrementQuantity ()
 {
        Quantity--;
        if (Quantity&lt;0) Quantity=0;
 }
 ...
}
</code></pre>
<p class="normal">Public properties <a id="_idIndexMarker1346"/>decorated with the <code class="inlineCode">[Parameter]</code> attribute work as component parameters; that is, when the component is instantiated into another component, they are used to pass values to the decorated properties, and those values are passed to HTML elements in HTML markup:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;OrderItem Quantity ="2" Id="123"/&gt;
</code></pre>
<p class="normal">Values can also be passed to component parameters by page route parameters, or query string parameters that match the property name in a case-invariant match:</p>
<pre class="programlisting code"><code class="hljs-code">OrderItem/{id}/{quantity}
OrderItem/{id}?quantity = 123
</code></pre>
<p class="normal">However, the match with query string parameters is enabled only if the property is also decorated with the <code class="inlineCode">SupplyParameterFromQuery</code> attribute:</p>
<pre class="programlisting code"><code class="hljs-code">[Parameter]
[SupplyParameterFromQuery]
public int Quantity {get; set;}=0;
</code></pre>
<p class="normal">Component parameters can also accept complex types and functions:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;modal title='() =&gt; "Test title" ' ...../&gt;
</code></pre>
<p class="normal">If components are generic, they must be passed type values for each generic parameter declared with <code class="inlineCode">typeparam</code>:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;myGeneric T= "string"...../&gt;
</code></pre>
<p class="normal">However, often, the compiler is able to infer generic types from the types of other parameters.</p>
<p class="normal">Finally, the code enclosed in the <code class="inlineCode">@code</code> directive can also be declared in a partial class with the same name and namespace as the component:</p>
<pre class="programlisting code"><code class="hljs-code">public partial class Counter
{
  [Parameter]
  public int CurrentCounter {get; set;}=0;
  ...
  ...
}
</code></pre>
<p class="normal">Usually, these <a id="_idIndexMarker1347"/>partial classes are declared in the same folder as the component and with a filename equal to the component’s filename with a <code class="inlineCode">.cs</code> postfix added. Thus, for instance, the partial class associated with the <code class="inlineCode">counter.razor</code> component will be <code class="inlineCode">counter.razor.cs</code>.</p>
<p class="normal">Each component may also have an associated CSS file, whose name must be the name of the component file plus the <code class="inlineCode">.css</code> postfix. Thus, for instance, the CSS file associated with the <code class="inlineCode">counter.razor</code> component will be <code class="inlineCode">counter.razor.css</code>. The CSS contained in this file is applied only to the component and has no effect on the remainder of the page. This is called CSS isolation, and at the moment, it is implemented by adding a unique attribute to all component HTML roots. Then, all selectors of the component CSS file are scoped to this attribute so that they can’t affect other HTML.</p>
<p class="normal">Of course, we can also use global application CSS, and in fact, the Blazor template creates the <code class="inlineCode">wwwroot/css/app.css</code> file for this purpose.</p>
<p class="normal">When the Blazor application is packaged, either during a build or during its publication, all isolated CSS is processed and placed in a unique CSS file called <code class="inlineCode">&lt;assembly name&gt;.Client.styles.css</code>. That’s why the <code class="inlineCode">index.html</code> page of our <code class="inlineCode">BlazorReview</code> application contains the following CSS reference:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;head&gt;
    ...
    &lt;link href="BlazorReview.Client.styles.css" rel="stylesheet" /&gt;
&lt;/head&gt;
</code></pre>
<p class="normal">It is worth mentioning that isolated CSS can also be obtained with pure CSS techniques, or using the <strong class="keyWord">Sass</strong> language, which compiles with CSS.</p>
<p class="normal">Whenever a component decorates an <code class="inlineCode">IDictionary&lt;string, object&gt;</code> parameter with <code class="inlineCode">[Parameter(CaptureUnmatchedValues = true)]</code>, then all unmatched parameters inserted into the tag, that is, all parameters without a matching component property, are added to the <code class="inlineCode">IDictionary</code> as key-value pairs.</p>
<p class="normal">This feature provides an easy way to forward parameters to HTML elements or ­other child components contained in the component markup. For instance, if we have a <code class="inlineCode">Detail</code> component that displays a detail view of the object passed in its <code class="inlineCode">Value</code> parameter, we <a id="_idIndexMarker1348"/>can use this feature to forward all usual HTML attributes to the root HTML tag of the component, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;div  @attributes="AdditionalAttributes"&gt;
...
&lt;/div&gt;
@code{
 [Parameter(CaptureUnmatchedValues = true)]
 public Dictionary&lt;string, object&gt;
 AdditionalAttributes { get; set; }
 [Parameter]
 Public T Value {get; set;}
}
</code></pre>
<p class="normal">This way, usual HTML attributes added to the component tag, for instance, <code class="inlineCode">class</code>, are forwarded to the root <code class="inlineCode">div</code> of the components and used to style the component:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Detail Value="myObject" class="my-css-class"/&gt;
</code></pre>
<p class="normal">The next subsection explains how to pass markup-generating functions to components.</p>
<h2 class="heading-2" id="_idParaDest-389">Templates and cascading parameters</h2>
<p class="normal">Blazor works<a id="_idIndexMarker1349"/> by building a data structure called a <strong class="keyWord">render tree</strong>, which<a id="_idIndexMarker1350"/> is updated as the UI changes. At each change, Blazor locates the part of the HTML that must be rendered and uses the information contained in the <strong class="keyWord">render tree</strong> to update it.</p>
<p class="normal">The <code class="inlineCode">RenderFragment</code> delegate <a id="_idIndexMarker1351"/>defines a function that is able to add further markup to a specific position of the <strong class="keyWord">render tree</strong>. There is also <code class="inlineCode">RenderFragment&lt;T&gt;</code>, which accepts a further argument you can use to drive the markup generation. For instance, you can pass a <code class="inlineCode">Customer</code> object to <code class="inlineCode">RenderFragment&lt;T&gt;</code> so that it can render all the data for that specific customer.</p>
<p class="normal">You can define <code class="inlineCode">RenderFragment</code> or <code class="inlineCode">RenderFragment&lt;T&gt;</code> with C# code, but the simplest way is to define it in your components with Razor markup. The Razor compiler will take care of generating the proper C# code for you:</p>
<pre class="programlisting code"><code class="hljs-code">RenderFragment myRenderFragment = @&lt;p&gt;The time is @DateTime.Now.&lt;/p&gt;;
RenderFragment&lt;Customer&gt; customerRenderFragment =
(item) =&gt; @&lt;p&gt;Customer name is @item.Name.&lt;/p&gt;;
</code></pre>
<p class="normal">The<a id="_idIndexMarker1352"/> information <a id="_idIndexMarker1353"/>on the location to add the markup is passed in the <code class="inlineCode">RenderTreeBuilder</code> argument it receives as an argument. You can use <code class="inlineCode">RenderFragment</code> in your component Razor markup by simply invoking it as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">RenderFragment myRenderFragment = ...
  ...
&lt;div&gt;
  ...
  @myRenderFragment
  ...
&lt;/div&gt;
  ...
</code></pre>
<p class="normal">The position where you invoke <code class="inlineCode">RenderFragment</code> defines the location where it will add its markup, since the component compiler is able to generate the right <code class="inlineCode">RenderTreeBuilder</code> argument to pass to it. <code class="inlineCode">RenderFragment&lt;T&gt;</code> delegates are invoked as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">Customer myCustomer = ...
  ...
&lt;div&gt;
  ...
  @myRenderFragment(myCustomer)
  ...
&lt;/div&gt;
  ...
</code></pre>
<p class="normal">Being functions, render fragments can be passed to component parameters like all other types. However, Blazor has a specific syntax to make it easier to simultaneously define and pass render fragments to c<a id="_idIndexMarker1354"/>omponents: the <strong class="keyWord">template</strong> syntax. First, you define the parameters in your component:</p>
<pre class="programlisting code"><code class="hljs-code">[Parameter]
Public RenderFragment&lt;Customer&gt;CustomerTemplate {get; set;}
[Parameter]
Public RenderFragment Title {get; set;}
</code></pre>
<p class="normal">Then, when you call the customer, you can do the following:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Detail&gt;
&lt;Title&gt;
&lt;h5&gt;This is a title&lt;/h5&gt;
&lt;/Title&gt;
&lt;CustomerTemplate Context=customer&gt;
&lt;p&gt;Customer name is @customer.Name.&lt;/p&gt;
  &lt;/CustomerTemplate&gt;
&lt;/Detail&gt;
</code></pre>
<p class="normal">Each <code class="inlineCode">RenderFragment</code> parameter is <a id="_idIndexMarker1355"/>represented by a tag with the same <a id="_idIndexMarker1356"/>name as the parameter. You can place the markup that defines <code class="inlineCode">RenderFragment</code> inside of it. For the <code class="inlineCode">CustomerTemplate</code> that has a parameter, the <code class="inlineCode">Context</code> keyword defines the parameter name inside the markup. In our example, the chosen parameter name is <code class="inlineCode">customer</code>.</p>
<p class="normal">When a component has just one render fragment parameter, if it is named <code class="inlineCode">ChildContent</code>, the template markup can be enclosed directly between the opening and closing tags of the component:</p>
<pre class="programlisting code"><code class="hljs-code">[Parameter]
Public RenderFragment&lt;Customer&gt; ChildContent {get; set;}
……………
……………
&lt;IHaveJustOneRenderFragment Context=customer&gt;
  &lt;p&gt;Customer name is @customer.Name.&lt;/p&gt;
&lt;/IHaveJustOneRenderFragment&gt;
</code></pre>
<p class="normal">In order to familiarize ourselves with component templates, let’s modify the <code class="inlineCode">Pages-&gt;Weather.razor</code> page so that, instead of using <code class="inlineCode">foreach</code>, it uses a <code class="inlineCode">Repeater</code> component.</p>
<p class="normal">Let’s right-click on the <code class="inlineCode">Layout</code> folder, select <strong class="screenText">Add</strong> and then <strong class="screenText">Razor Component</strong>, and add a new <code class="inlineCode">Repeater.razor</code> component. Then, replace the existing code with this:</p>
<pre class="programlisting code"><code class="hljs-code">@typeparam T
@foreach(var item in Values)
{
  @ChildContent(item)
}
@code {
    [Parameter]
    public RenderFragment&lt;T&gt; ChildContent { get; set; }
    [Parameter]
    public IEnumerable&lt;T&gt; Values { get; set; }
}
</code></pre>
<p class="normal">The component is defined with a generic parameter so that it can be used with any <code class="inlineCode">IEnumerable</code>. Now<a id="_idIndexMarker1357"/> let’s replace the markup in the <code class="inlineCode">tbody</code> of the <code class="inlineCode">Weather.razor</code> component with this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Repeater Values="forecasts" Context="forecast"&gt;
&lt;tr&gt;
&lt;td&gt;@forecast.Date.ToShortDateString()&lt;/td&gt;
&lt;td&gt;@forecast.TemperatureC&lt;/td&gt;
&lt;td&gt;@forecast.TemperatureF&lt;/td&gt;
&lt;td&gt;@forecast.Summary&lt;/td&gt;
&lt;/tr&gt;
&lt;/Repeater&gt;
</code></pre>
<p class="normal">Since<a id="_idIndexMarker1358"/> the <code class="inlineCode">Repeater</code> component has just one template, and since we named it <code class="inlineCode">ChildContent</code>, we can place our template markup directly within the component open and close tags. Run it and verify that the page works properly. You have learned how to use templates and that markup placed inside a component defines a template.</p>
<p class="normal">An important predefined templated Blazor component is the <code class="inlineCode">CascadingValue</code> component. It renders the content placed inside of it with no changes, but passes a type instance to all its descendant components:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;CascadingValue Value="new MyOptionsInstance{...}"&gt;
……
&lt;/CascadingValue&gt;
</code></pre>
<p class="normal">All components placed inside of the <code class="inlineCode">CascadingValue</code> tag and all their descendant components can now capture the instance of <code class="inlineCode">MyOptionsInstance</code> passed in the <code class="inlineCode">CascadingValue</code> parameter. It is enough that the component declares a public or private property with a type that is compatible with <code class="inlineCode">MyOptionsInstance</code> and that decorates it with the <code class="inlineCode">CascadingParameter</code> attribute:</p>
<pre class="programlisting code"><code class="hljs-code">[CascadingParameter]
private MyOptionsInstance options {get; set;}
</code></pre>
<p class="normal">Matching is performed by type compatibility. If there’s ambiguity with other cascaded parameters with a compatible type, we can specify the <code class="inlineCode">Name</code> optional parameter of the <code class="inlineCode">CascadingValue</code> component and pass the same name to the <code class="inlineCode">CascadingParameter</code> attribute: <code class="inlineCode">[CascadingParameter("myUnique name")]</code>.</p>
<p class="normal">The <code class="inlineCode">CascadingValue</code> tag also has an <code class="inlineCode">IsFixed</code> parameter that should be set to <code class="inlineCode">true</code> whenever possible for performance reasons. In fact, propagating cascading values is very useful for passing options and settings, but it has a very high computational cost.</p>
<p class="normal">When <code class="inlineCode">IsFixed</code> is set<a id="_idIndexMarker1359"/> to <code class="inlineCode">true</code>, propagation is performed just <a id="_idIndexMarker1360"/>once, the first time that each piece of content involved is rendered, and then no attempt is made to update the cascaded value during the content’s lifetime. Thus, <code class="inlineCode">IsFixed</code> can be used whenever the pointer of the cascaded object is not changed during the content’s lifetime.</p>
<p class="normal">An example of a cascading value is the <code class="inlineCode">CascadingAuthenticationState</code> component we encountered in the <em class="italic">Routing</em> subsection, which cascades authentication and authorization information to all rendered components.</p>
<h2 class="heading-2" id="_idParaDest-390">Error handling</h2>
<p class="normal">As the <a id="_idIndexMarker1361"/>default, when an error in a component occurs, the exception is intercepted by the .NET runtime, which automatically makes visible the error code contained in <code class="inlineCode">index.html</code>:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;div id="blazor-error-ui"&gt;
        An unhandled error has occurred.
    &lt;a href="" class="reload"&gt;Reload&lt;/a&gt;
&lt;a class="dismiss"&gt; / &lt;/a&gt;
&lt;/div&gt;
</code></pre>
<p class="normal">However, component errors can be intercepted and handled locally by enclosing the component inside an <code class="inlineCode">ErrorBoundary</code> component. Below, the code of the <code class="inlineCode">Repeater</code> example in the previous subsection has been modified to locally handle errors that might occur in each row:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Repeater Values="forecasts" Context="forecast"&gt;
&lt;tr&gt;
&lt;ErrorBoundary&gt;
&lt;ChildContent&gt;
&lt;td&gt;@forecast.Date.ToShortDateString()&lt;/td&gt;
&lt;td&gt;@forecast.TemperatureC&lt;/td&gt;
&lt;td&gt;@forecast.TemperatureF&lt;/td&gt;
&lt;td&gt;@forecast.Summary&lt;/td&gt;
&lt;/ChildContent&gt;
&lt;ErrorContent&gt;
&lt;td colspan="4" class="my-error"&gt;Nothing to see here. Sorry!&lt;/td&gt;
&lt;/ErrorContent&gt;
&lt;/ErrorBoundary&gt;
&lt;/tr&gt;
&lt;/Repeater&gt;
</code></pre>
<p class="normal">The <a id="_idIndexMarker1362"/>standard code is placed in the <code class="inlineCode">ChildContent</code> template, while the <code class="inlineCode">ErrorContent</code> template is shown if there’s an error.</p>
<h2 class="heading-2" id="_idParaDest-391">Events</h2>
<p class="normal">Both HTML tags and <a id="_idIndexMarker1363"/>Blazor components use attributes/parameters to get input. HTML tags provide output to the remainder of the page through events, and Blazor allows C# functions to be attached to HTML <code class="inlineCode">on{event name}</code> attributes. The syntax is shown in the <code class="inlineCode">Pages-&gt;Counter.razor</code> component:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;p role="status"&gt;Current count: @currentCount&lt;/p&gt;
&lt;button class="btn btn-primary" @onclick="IncrementCount"&gt;Click me&lt;/button&gt;
@code {
private int currentCount = 0;
private void IncrementCount()
    {
        currentCount++;
    }
}
</code></pre>
<p class="normal">The function can also be passed inline as a lambda. Moreover, it accepts the C# equivalent of the usual <code class="inlineCode">event</code> argument. The <em class="italic">Further reading</em> section contains a link to the Blazor official documentation page that lists all supported events and their arguments.</p>
<p class="normal">Since Blazor components are designed as enhanced versions of HTML elements—with added capabilities—they can also have events. However, unlike standard HTML elements, both the features and implementations of these events in Blazor components are defined by the developer.</p>
<p class="normal">Blazor events enable components to return output, too. Component events are defined as parameters whose type is either <code class="inlineCode">EventCallBack</code> or <code class="inlineCode">EventCallBack&lt;T&gt;</code>. <code class="inlineCode">EventCallBack</code> is the type of component event with no arguments while <code class="inlineCode">EventCallBack&lt;T&gt;</code> is the type of component event with an argument of type <code class="inlineCode">T</code>. In order to trigger an event, say <code class="inlineCode">MyEvent</code>, the component calls:</p>
<pre class="programlisting code"><code class="hljs-code">await MyEvent.InvokeAsync()
</code></pre>
<p class="normal">or</p>
<pre class="programlisting code"><code class="hljs-code">await MyIntEvent.InvokeAsync(arg)
</code></pre>
<p class="normal">These calls execute the handlers bound to the events or do nothing if no handler has been bound.</p>
<p class="normal">Once defined, component<a id="_idIndexMarker1364"/> events can be used exactly in the same way as HTML element events, the only difference being that there is no need to prefix the event name with an <code class="inlineCode">@</code>, since <code class="inlineCode">@</code> in HTML events is needed to distinguish between the HTML attribute and the Blazor-added parameter with the same name:</p>
<pre class="programlisting code"><code class="hljs-code">[Parameter]
publicEventCallback MyEvent {get; set;}
[Parameter]
publicEventCallback&lt;int&gt; MyIntEvent {get; set;}
...
...
&lt;ExampleComponent
MyEvent="() =&gt; ..."
MyIntEvent = "(i) =&gt;..." /&gt;
</code></pre>
<p class="normal">Actually, HTML element events are also <code class="inlineCode">EventCallBack&lt;T&gt;</code> events. That is why both event types behave in exactly the same way. <code class="inlineCode">EventCallBack</code> and <code class="inlineCode">EventCallBack&lt;T&gt;</code> are structs, not delegates, since they contain a delegate, together with a pointer to the entity that must be notified that the event has been triggered. Formally, this entity is represented by a <code class="inlineCode">Microsoft.AspNetCore.Components.IHandleEvent</code> interface. Needless to say, all components implement this interface. The notification informs <code class="inlineCode">IHandleEvent</code> that a state change took place. State changes play a fundamental role in the way Blazor updates the page HTML. We will analyze them in detail in the next subsection.</p>
<p class="normal">For HTML elements, Blazor also provides the possibility to stop the event’s default action and the event bubbling by adding the <code class="inlineCode">:preventDefault</code> and <code class="inlineCode">:stopPropagation</code> directives to the attribute that specifies the event, like in these examples:</p>
<pre class="programlisting code"><code class="hljs-code">@onkeypress="KeyHandler" @onkeypress:preventDefault="true"
@onkeypress:stopPropagation  ="true"
</code></pre>
<h2 class="heading-2" id="_idParaDest-392">Bindings</h2>
<p class="normal">Often, a component <a id="_idIndexMarker1365"/>parameter value must be kept synchronized with an external variable, property, or field. The typical application of this kind of synchronization is an object property being edited in an input component or HTML tag. Whenever the user changes the input value, the object property must be updated coherently, and vice versa. The object property value must be copied into the component as soon as the component is rendered so that the user can edit it.</p>
<p class="normal">Similar scenarios are handled by parameter-event pairs. More specifically, from one side, the property is copied in the input component parameter. From the other side, each time the input changes value, a component event that updates the property is triggered. This way, property and input values are kept synchronized.</p>
<p class="normal">This scenario is so common and useful that Blazor has a specific syntax for simultaneously defining the event and copying the property value into the parameter. This simplified syntax requires that the event has the same name as the parameter involved in the interaction but with a <code class="inlineCode">Changed</code> postfix.</p>
<p class="normal">Suppose, for instance, that a component has a <code class="inlineCode">Value</code> parameter. Then, the corresponding event must be <code class="inlineCode">ValueChanged</code>. Moreover, each time the user changes the component value, the component must invoke the <code class="inlineCode">ValueChanged</code> event by calling <code class="inlineCode">await ValueChanged.InvokeAsync(arg)</code>. With this in place, a property called <code class="inlineCode">MyObject.MyProperty</code> can be synchronized with the <code class="inlineCode">Value</code> property with the syntax shown here:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;MyComponent @bind-Value="MyObject.MyProperty"/&gt;
</code></pre>
<p class="normal">The preceding syntax is called <code class="inlineCode">binding</code>. Blazor takes care of automatically attaching an event handler that updates the <code class="inlineCode">MyObject.MyProperty</code> property to the <code class="inlineCode">ValueChanged</code> event.</p>
<p class="normal">Bindings of HTML elements work in a similar way, but since the developer can’t decide the names of parameters and events, a slightly different convention must be used. First of all, there is no need to specify the parameter name in the binding, since it is always the HTML input <code class="inlineCode">value</code> attribute. Therefore, the binding is written simply as <code class="inlineCode">@bind="object.MyProperty"</code>. By default, the object property is updated on the <code class="inlineCode">change</code> event, but you can specify a different event by adding the <code class="inlineCode">@bind-event: @bind-event="oninput"</code> attribute.</p>
<p class="normal">Moreover, bindings <a id="_idIndexMarker1366"/>of HTML inputs try to automatically convert the input string into the target type. If the conversion fails, the input reverts to its initial value. This behavior is quite primitive since, in the event of errors, no error message is provided to the user, and the culture settings are not taken into account properly (HTML5 inputs use invariant culture but text input must use the current culture). We advise binding inputs only to string target types. Blazor has specific components for handling dates and numbers that should be used whenever the target type is not a string. We will describe these components in the <em class="italic">Blazor forms and validation</em> section.</p>
<p class="normal">In order to familiarize ourselves with events, let’s write a component that synchronizes the content of an input-type text when the user clicks a confirmation button. Let’s right-click on the <code class="inlineCode">Layout</code> folder and add a new <code class="inlineCode">ConfirmedText.razor</code> component. Then replace its code with this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;input type="text" @bind="Value" @attributes="AdditionalAttributes"/&gt;
&lt;button class="btn btn-secondary" @onclick="Confirmed"&gt;@ButtonText&lt;/button&gt;
@code {
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary&lt;string, object&gt; AdditionalAttributes { get; set; }
    [Parameter]
    public string Value {get; set;}
    [Parameter]
    public EventCallback&lt;string&gt; ValueChanged { get; set; }
    [Parameter]
    public string ButtonText { get; set; }
    async Task Confirmed()
    {
        await ValueChanged.InvokeAsync(Value);
    }
}
</code></pre>
<p class="normal">The <code class="inlineCode">ConfirmedText</code> component exploits the button-click event to trigger the <code class="inlineCode">ValueChanged</code> event. Moreover, the component uses <code class="inlineCode">@bind</code> to synchronize its <code class="inlineCode">Value</code> parameter with the HTML input. It is worth pointing out that the component uses <code class="inlineCode">CaptureUnmatchedValues</code> to forward all HTML attributes applied to its tag to the HTML input. This way, users of the <code class="inlineCode">ConfirmedText</code> component can style the input field by simply adding <code class="inlineCode">class</code> and/or <code class="inlineCode">style</code> attributes to the component tag.</p>
<p class="normal">Now, let’s use this component in the <code class="inlineCode">Pages-&gt;Index.razor</code> page by placing the following code at the end of <code class="inlineCode">Home.razor</code>:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;ConfirmedText @bind-Value="textValue" ButtonText="Confirm" /&gt;
&lt;p&gt;
    Confirmed value is: @textValue
&lt;/p&gt;
@code{
private string textValue = null;
}
</code></pre>
<p class="normal">If you run the<a id="_idIndexMarker1367"/> project and play with the input and its <strong class="screenText">Confirm</strong> button, you will see that each time the <strong class="screenText">Confirm</strong> button is clicked, not only are the input values copied in the <code class="inlineCode">textValue</code> page property but also the content of the paragraph that is behind the component is coherently updated.</p>
<p class="normal">We explicitly synchronized <code class="inlineCode">textValue</code> with the component with <code class="inlineCode">@bind-Value</code>, but what takes care of keeping <code class="inlineCode">textValue</code> synchronized with the content of the paragraph? The answer can be found in the next subsection.</p>
<h2 class="heading-2" id="_idParaDest-393">How Blazor updates HTML</h2>
<p class="normal">When we write the<a id="_idIndexMarker1368"/> content of a variable, property, or field in Razor markup with something like <code class="inlineCode">@model.property</code>, Blazor not only renders the actual value of the variable, property, or field when the component is rendered but tries also to update the HTML each time that this value changes, with a process<a id="_idIndexMarker1369"/> called <strong class="keyWord">change detection</strong>. Change detection is a feature of all the main SPA frameworks, but the way Blazor implements it is very simple and elegant.</p>
<p class="normal">The basic idea is that once all HTML has been rendered, changes may occur only because of code executed inside of events. That is why <code class="inlineCode">EventCallBack</code> and <code class="inlineCode">EventCallBack&lt;T&gt;</code> contain a reference to an <code class="inlineCode">IHandleEvent</code>. When a component binds a handler to an event, the Razor compiler creates an <code class="inlineCode">EventCallBack</code> or <code class="inlineCode">EventCallBack&lt;T&gt;</code>, passing its struct constructor the function bound to the event, and the component where the function was defined (<code class="inlineCode">IHandleEvent</code>).</p>
<p class="normal">Once the code of the handler has been executed, the Blazor runtime is notified that the <code class="inlineCode">IHandleEvent</code> might have changed. In fact, the handler code can only change the values of variables, properties, or fields of the component where the handler was defined. In turn, this triggers a change detection process rooted in the component. Blazor verifies which variables, properties, or fields used in the component Razor markup changed and updates the associated HTML.</p>
<p class="normal">If a changed<a id="_idIndexMarker1370"/> variable, property, or field is an input parameter of another component, then the HTML generated by that component might also need updates. Accordingly, another change detection process rooted in that component is recursively triggered.</p>
<p class="normal">The algorithm sketched previously discovers all relevant changes only if the following conditions are met:</p>
<ul>
<li class="bulletList">No component references data structures belonging to other components in an event handler.</li>
<li class="bulletList">All inputs to a component arrive through its parameters and not through method calls or other public members.</li>
</ul>
<p class="normal">When there is a change that is not detected because of the failure of one of the preceding conditions, the developer must manually declare the possible change of the component. This can be done by calling the <code class="inlineCode">StateHasChanged()</code> component method. Since this call might result in changes to the page’s HTML, its execution cannot take place asynchronously but must be queued in the HTML page’s UI thread. This is done by passing the function to be executed to the <code class="inlineCode">InvokeAsync</code> component method.</p>
<p class="normal">Summing up, the instruction to execute is <code class="inlineCode">await InvokeAsync(StateHasChanged)</code>.</p>
<p class="normal">The next subsection concludes the description of components with an analysis of their lifecycle and the associated lifecycle methods.</p>
<h2 class="heading-2" id="_idParaDest-394">Component lifecycle</h2>
<p class="normal">Each <a id="_idIndexMarker1371"/>component lifecycle event has an associated method. Some methods have both synchronous and asynchronous versions, some have just an asynchronous version, and some others have just a synchronous version.</p>
<p class="normal">The component lifecycle starts with parameters passed to the component being copied in the associated component properties. You can customize this step by overriding the following method:</p>
<pre class="programlisting code"><code class="hljs-code">public override async Task SetParametersAsync(ParameterView parameters)
{
  await ...
  await base.SetParametersAsync(parameters);
}
</code></pre>
<p class="normal">Typically, customization consists of the modification of additional data structures, so the base method is called to also perform the default action of copying parameters in the associated properties.</p>
<p class="normal">After that, there is the component initialization that is associated with the two methods:</p>
<pre class="programlisting code"><code class="hljs-code">protected override void OnInitialized()
{
    ...
}
protected override async Task OnInitializedAsync()
{
  await ...
}
</code></pre>
<p class="normal">They are <a id="_idIndexMarker1372"/>called once in the component lifetime, immediately after the component has been created and added to the render tree. Please place any initialization code there, and not in the component constructor, as this will improve component testability. This is because there, you have all parameters set and future Blazor versions might pool and reuse component instances.</p>
<p class="normal">If the initialization code subscribes to some events or performs actions that need a cleanup when the component is destroyed, implement <code class="inlineCode">IDisposable</code>, and place all the cleanup code in its <code class="inlineCode">Dispose</code> method. Whenever a component implements <code class="inlineCode">IDisposable</code>, Blazor calls its <code class="inlineCode">Dispose</code> method before destroying it.</p>
<p class="normal">After the component has been initialized, and each time a component parameter changes, the following two methods are called:</p>
<pre class="programlisting code"><code class="hljs-code">protected override async Task OnParametersSetAsync()
{
  await ...
}
protected override void OnParametersSet()
{
    ...
}
</code></pre>
<p class="normal">They are the right place to update data structures that depend on the values of the component parameters.</p>
<p class="normal">After that, the component is rendered or re-rendered. You can prevent component re-rendering after an update by overriding the <code class="inlineCode">ShouldRender</code> method:</p>
<pre class="programlisting code"><code class="hljs-code">protected override bool ShouldRender()
{
...
}
</code></pre>
<p class="normal">Letting a <a id="_idIndexMarker1373"/>component re-render only if you are sure its HTML code will change is an advanced optimization technique used in the implementation of component libraries.</p>
<p class="normal">The component rendering stage also involves the invocation of its children components. Therefore, component rendering is considered complete only after all its descendant components have completed their rendering too. When rendering is complete, the following methods are called:</p>
<pre class="programlisting code"><code class="hljs-code">protected override void OnAfterRender(bool firstRender)
{
    if (firstRender)
    {
    }
...
}
protected override async Task OnAfterRenderAsync(bool firstRender)
{
    if (firstRender)
    {
        await...
        ...
    }
    await ...
}
</code></pre>
<p class="normal">Since when the preceding methods are called, all component HTML has been updated and all children components have executed all their lifetime methods, the preceding methods are the right places for performing the following operations:</p>
<ul>
<li class="bulletList">Calling JavaScript functions that manipulate the generated HTML. JavaScript calls are described in the JavaScript interoperability subsection.</li>
<li class="bulletList">Processing information attached to parameters or cascaded parameters by descendant components. In fact, tab-like components and other components might need to register some of their subparts in the root component, so <a id="_idIndexMarker1374"/>the root component typically cascades a data structure where some children components can register. Code written in <code class="inlineCode">AfterRender</code> and <code class="inlineCode">AfterRenderAsync</code> can rely on the fact that all the parts have completed their registration.</li>
</ul>
<p class="normal">The next section describes Blazor tools for collecting user input.</p>
<h1 class="heading-1" id="_idParaDest-395">Blazor forms and validation</h1>
<p class="normal">Similar to all <a id="_idIndexMarker1375"/>major SPA frameworks, Blazor offers specific tools for processing user input while providing valid feedback to the user with error messages and immediate visual clues.</p>
<p class="normal">In classic HTML websites, HTML forms are used to collect input, validate it, and send it to the server. In client frameworks, data is not sent to the server by submitting forms, but forms retain their validation purpose. More specifically, they act as validation units, that is, as a container for inputs that must be validated together because they belong to a unique task. Accordingly, when a submit button is clicked, an overall validation is performed, and the system notifies of the result via events. This way, the developer can define what to do in case of errors and what actions to take when the user has successfully completed their input.</p>
<div><p class="normal">It is worth pointing out that validation performed on the client side doesn’t ensure data integrity because a malicious user could easily hack all client validation rules because they have full access to the client-side code in their browser. The purpose of client-side validation is just to provide immediate feedback to the user.</p>
</div>
<p class="normal">Accordingly, the<a id="_idIndexMarker1376"/> validation step must be repeated on the server side to enforce data integrity.</p>
<p class="normal">Both server-side and client-side validation can be performed with the same code shared between the Blazor client and the server. In fact, both the ASP.NET Core REST API and Blazor support validation based on validation attributes, so it is enough to share the same ViewModels equipped with validation attributes between the Blazor and server projects by putting them in a library that is referenced by both projects. ASP.NET Core validation is discussed in the <em class="italic">Server-side and client-side validation</em> section of <em class="italic">Chapter 17</em>, <em class="italic">Presenting ASP.NET Core</em>.</p>
<p class="normal">The whole<a id="_idIndexMarker1377"/> toolset is known as <strong class="keyWord">Blazor Forms</strong> and consists of a form component called <code class="inlineCode">EditForm</code>, various input components, a data annotation validator, a validation error summary, and validation error labels.</p>
<p class="normal"><code class="inlineCode">EditForm</code> takes care of orchestrating the state of all input components through an instance of the <code class="inlineCode">EditContext</code> class that is cascaded inside of the form. The orchestration comes from the interaction of both input components and the data annotation validator with this <code class="inlineCode">EditContext</code> instance. A validation summary and error message labels don’t take part in the orchestration but register to some <code class="inlineCode">EditContext</code> events to be informed about errors.</p>
<p class="normal"><code class="inlineCode">EditForm</code> must be passed the object whose properties must be rendered in its <code class="inlineCode">Model</code> parameter. It is worth pointing out that input components bound to nested properties are not validated, so <code class="inlineCode">EditForm</code> must be passed a flattened ViewModel. <code class="inlineCode">EditForm</code> creates a new <code class="inlineCode">EditContext</code> instance, passes the object received in its <code class="inlineCode">Model</code> parameter in its constructor, and cascades it so it can interact with the form content.</p>
<p class="normal">You can also directly pass an <code class="inlineCode">EditContext</code> custom instance in the <code class="inlineCode">EditContext</code> parameter of <code class="inlineCode">EditForm</code> instead of passing the object in its <code class="inlineCode">Model</code> parameter, in which case <code class="inlineCode">EditForm</code> will use your custom copy instead of creating a new instance. Typically, you do this when you need to subscribe to the <code class="inlineCode">EditContext</code> <code class="inlineCode">OnValidationStateChanged</code> and <code class="inlineCode">OnFieldChanged</code> events.</p>
<p class="normal">When <code class="inlineCode">EditForm</code> is submitted with a <strong class="keyWord">Submit</strong> button and there are no errors, the form invokes its <code class="inlineCode">OnValidSubmit</code> callback, where you can place the code that uses and processes the user input. If instead there are validation errors, they are displayed, and the form invokes its <code class="inlineCode">OnInvalidSubmit</code> callback.</p>
<p class="normal">The state of each input is reflected in some CSS classes that are automatically added to them, namely <code class="inlineCode">valid</code>, <code class="inlineCode">invalid</code>, and <code class="inlineCode">modified</code>. You can use these classes to provide adequate visual feedback to the user. The default Blazor template already provides some CSS for them.</p>
<p class="normal">Here is a typical form:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;EditForm Model="FixedInteger"OnValidSubmit="@HandleValidSubmit" &gt;
&lt;DataAnnotationsValidator /&gt;
&lt;ValidationSummary /&gt;
&lt;div class="form-group"&gt;
&lt;label for="integerfixed"&gt;Integer value&lt;/label&gt;
&lt;InputNumber @bind-Value="FixedInteger.Value"
 id="integerfixed" class="form-control" /&gt;
&lt;ValidationMessage For="@(() =&gt; FixedInteger.Value)" /&gt;
&lt;/div&gt;
&lt;button type="submit" class="btn btn-primary"&gt; Submit&lt;/button&gt;
&lt;/EditForm&gt;
</code></pre>
<p class="normal">The label is <a id="_idIndexMarker1378"/>a standard HTML label, while <code class="inlineCode">InputNumber</code> is a Blazor-specific component for number properties. <code class="inlineCode">ValidationMessage</code> is the error label that appears only in the event of a validation error. By default, it is rendered with a <code class="inlineCode">validation-message</code> CSS class. The property associated with the error message is passed in the <code class="inlineCode">for</code> parameter with a parameterless lambda, as shown in the example.</p>
<p class="normal">The <code class="inlineCode">DataAnnotationsValidator</code> component adds a validation based on the usual .NET validation attributes, such as <code class="inlineCode">RangeAttribute</code>, <code class="inlineCode">RequiredAttribute</code>, and so on. You can also write your custom validation attributes by inheriting from the <code class="inlineCode">ValidationAttribute</code> class.</p>
<p class="normal">You can provide custom error messages in the validation attributes. If they contain a <code class="inlineCode">{0}</code> placeholder, this will be filled with the property display name declared in a <code class="inlineCode">DisplayAttribute</code>, if one is found, otherwise with the property name.</p>
<p class="normal">Together with the <code class="inlineCode">InputNumber</code> component, Blazor also supports an <code class="inlineCode">InputText</code> component for <code class="inlineCode">string</code> properties, an <code class="inlineCode">InputTextArea</code> component for <code class="inlineCode">string</code> properties to be edited in an HTML <code class="inlineCode">textarea</code>, an <code class="inlineCode">InputCheckbox</code> component for <code class="inlineCode">bool</code> properties, and an <code class="inlineCode">InputDate</code> component that renders <code class="inlineCode">DateTime</code> and <code class="inlineCode">DateTimeOffset</code> as dates. They all work in exactly the same way as the <code class="inlineCode">InputNumber</code> component. No component is available for other HTML5 input types. In particular, no component is available for rendering time or date and time, or for rendering numbers with a <code class="inlineCode">range</code> widget.</p>
<p class="normal">If you need HTML5 inputs that are not available as Blazor input form components, you are left with the option of implementing them yourself or of using a third-party library that supports them.</p>
<p class="normal">You can implement rendering time or date and time by inheriting from the <code class="inlineCode">InputBase&lt;TValue&gt;</code> class and overriding the <code class="inlineCode">BuildRenderTree</code>, <code class="inlineCode">FormatValueAsString</code>, and <code class="inlineCode">TryParseValueFromString</code> methods. The sources of the <code class="inlineCode">InputNumber</code> component show how to do this: <a href="https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/Forms/InputNumber.cs">https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/Forms/InputNumber.cs</a>. You can also use the third-party libraries described in the <em class="italic">Third-party tools for Blazor WebAssembly</em> section.</p>
<p class="normal">Blazor also <a id="_idIndexMarker1379"/>has a specific component for rendering a <code class="inlineCode">select</code>, which works as in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;InputSelect @bind-Value="order.ProductColor"&gt;
&lt;option value=""&gt;Select a color ...&lt;/option&gt;
&lt;option value="Red"&gt;Red&lt;/option&gt;
&lt;option value="Blue"&gt;Blue&lt;/option&gt;
&lt;option value="White"&gt;White&lt;/option&gt;
&lt;/InputSelect&gt;
</code></pre>
<p class="normal">Starting from .NET 6, <code class="inlineCode">InputSelect</code> can also be bound to <code class="inlineCode">IEnnumerable&lt;T&gt;</code> properties, in which case it is rendered as a multi-select.</p>
<p class="normal">One can also render enumerations with a radio group thanks to the <code class="inlineCode">InputRadioGroup</code> and <code class="inlineCode">InputRadio</code> components, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;InputRadioGroup Name="color" @bind-Value="order.Color"&gt;
&lt;InputRadio Name="color" Value="AllColors.Red" /&gt; Red&lt;br&gt;
&lt;InputRadio Name="color" Value="AllColors.Blue" /&gt; Blue&lt;br&gt;
&lt;InputRadio Name="color" Value="AllColors.White" /&gt; White&lt;br&gt;
&lt;/InputRadioGroup&gt;
</code></pre>
<p class="normal">Finally, Blazor also offers an <code class="inlineCode">InputFile</code> component together with all the tools for processing and uploading the file. We will not cover this here, but the <em class="italic">Further reading</em> section contains links to the official documentation.</p>
<p class="normal">The next section describes Blazor tools for modifying the host page <code class="inlineCode">&lt;head&gt;</code> tag.</p>
<h2 class="heading-2" id="_idParaDest-396">Modifying HTML &lt;head&gt; content from Blazor components</h2>
<p class="normal">Since<a id="_idIndexMarker1380"/> the whole component tree is placed inside the body of the <code class="inlineCode">index.html</code> host page, the components markup has no direct access to the <code class="inlineCode">index.html</code> host page <code class="inlineCode">&lt;head&gt;</code> tag. Modifying the content of the <code class="inlineCode">&lt;head&gt;</code> tag is necessary when the developer would like to adapt the title shown in the browser tab to the actual Blazor page that is being displayed. In fact, this title is contained within the <code class="inlineCode">&lt;head&gt;</code> tag:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;head&gt;
&lt;title&gt;This is the title shown in the browser tab&lt;/title&gt;
    ...
&lt;/head&gt;
</code></pre>
<p class="normal">For this <a id="_idIndexMarker1381"/>reason, the .NET 6 version of Blazor introduced specific constructs for modifying the host page <code class="inlineCode">&lt;head&gt;</code> tag from inside Blazor components.</p>
<p class="normal">First of all, we must inform the Blazor application about how to reach the <code class="inlineCode">&lt;head&gt;</code> tag content. This is done in <code class="inlineCode">Program.cs</code> with the same technique used to specify the Blazor application root:</p>
<pre class="programlisting code"><code class="hljs-code">var builder = WebAssemblyHostBuilder.CreateDefault(args);
builder.RootComponents.Add&lt;App&gt;("#app");
// The line below adds support for modifying
// the &lt;head&gt; tag content
builder.RootComponents.Add&lt;HeadOutlet&gt;("head::after");
...
</code></pre>
<p class="normal">After that, each component can replace the HTML title by specifying the new string inside a <code class="inlineCode">PageTitle</code> component instance:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;PageTitle&gt;This string replaces the page title&lt;/PageTitle&gt;
</code></pre>
<p class="normal">Moreover, each component can append other HTML content to the <code class="inlineCode">&lt;head&gt;</code> tag by placing it inside a <code class="inlineCode">HeadContent</code> instance:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;HeadContent&gt;
&lt;meta name="description" content="This is a page description"&gt;
&lt;/HeadContent&gt;
</code></pre>
<p class="normal">In this section, you learned all that is needed to write a simple Blazor application that doesn’t exchange data with a server. The next section analyzes some advanced features and will enable you to interact with a server to handle authentication, authorization, and more.</p>
<h1 class="heading-1" id="_idParaDest-397">Blazor advanced features</h1>
<p class="normal">This section <a id="_idIndexMarker1382"/>provides short descriptions of various Blazor advanced features organized into subsections:</p>
<ul>
<li class="bulletList">References to components and HTML elements</li>
<li class="bulletList">JavaScript interoperability</li>
<li class="bulletList">Globalization and localization</li>
<li class="bulletList">Authentication and authorization</li>
<li class="bulletList">Communication with the server</li>
<li class="bulletList">AOT compilation</li>
</ul>
<p class="normal">Because of <a id="_idIndexMarker1383"/>a lack of space, we can’t give all the details of each feature, but the details are covered by links in the <em class="italic">Further reading</em> section. We start with how to reference components and HTML elements defined in Razor markup.</p>
<h2 class="heading-2" id="_idParaDest-398">References to components and HTML elements</h2>
<p class="normal">Sometimes, we<a id="_idIndexMarker1384"/> might need a reference to <a id="_idIndexMarker1385"/>a component in order to call some of its methods. This is the case, for instance, for a component that implements a modal window:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Modal @ref="myModal"&gt;
...
&lt;/Modal&gt;
...
&lt;button type="button" class="btn btn-primary"
   @onclick="() =&gt; myModal.Show()"&gt;
   Open modal
&lt;/button&gt;
...
@code{
private Modal  myModal {get; set;}
 ...
}
</code></pre>
<p class="normal">As the preceding example shows, references are captured with the <code class="inlineCode">@ref</code> directive. The same <code class="inlineCode">@ref</code> directive can also be used to capture references to HTML elements. HTML references have an <code class="inlineCode">ElementReference</code> type and are typically used to call JavaScript functions on HTML elements, as explained in the next subsection.</p>
<h2 class="heading-2" id="_idParaDest-399">JavaScript interoperability</h2>
<p class="normal">Since Blazor <a id="_idIndexMarker1386"/>doesn’t expose all JavaScript features to C# code, and since it is convenient to take advantage of the huge JavaScript code base, sometimes it is necessary to invoke JavaScript functions. Blazor allows this through the <code class="inlineCode">IJSRuntime</code> interface that can be injected into a component via dependency injection.</p>
<p class="normal">Once we have an <code class="inlineCode">IJSRuntime</code> instance, a JavaScript function that returns a value can be called as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">T result = await jsRuntime.InvokeAsync&lt;T&gt;(
   "&lt;name of JavaScript function or method&gt;", arg1, arg2....);
</code></pre>
<p class="normal">Functions <a id="_idIndexMarker1387"/>that do not return any argument can be invoked as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">await jsRuntime.InvokeAsync(
   "&lt;name of JavaScript function or method&gt;", arg1, arg2....);
</code></pre>
<p class="normal">Arguments can be either basic types or objects that can be serialized in JSON, while the name of the JavaScript function is a string that can contain dots that represent access to properties, sub-properties, and method names, such as the <code class="inlineCode">"myJavaScriptObject.myProperty.myMethod"</code> string.</p>
<p class="normal">Thus, for instance, we can save a string in the browser’s local storage with the following code:</p>
<pre class="programlisting code"><code class="hljs-code">await jsRuntime
    .InvokeVoidAsync("window.localStorage.setItem",
myLocalStorageKey, myStringToSave);
</code></pre>
<p class="normal">Arguments can also be <code class="inlineCode">ElementReference</code> instances captured with the <code class="inlineCode">@ref</code> directive, in which case they are received as HTML elements on the JavaScript side.</p>
<p class="normal">The JavaScript functions invoked must be defined either in the <code class="inlineCode">Index.html</code> file or in JavaScript files referenced in <code class="inlineCode">Index.html</code>.</p>
<p class="normal">If you are writing a component library with a Razor library project, JavaScript files can be embedded together with CSS files as resources in the DLL library. You just need to add a <code class="inlineCode">wwwroot</code> folder in the project root and place the needed CSS and JavaScript files in that folder or some subfolder of it. After that, these files can be referenced as follows:</p>
<pre class="programlisting code"><code class="hljs-code">_content/&lt;dll name&gt;/&lt;file path relative to wwwroot&gt;
</code></pre>
<p class="normal">Accordingly, if the filename is <code class="inlineCode">myJsFile.js</code>, the DLL name is <code class="inlineCode">MyCompany.MyLibrary</code>, and the file is placed in the <code class="inlineCode">js</code> folder inside <code class="inlineCode">wwwroot</code>, then its reference will be:</p>
<pre class="programlisting code"><code class="hljs-code">_content/MyCompany.MyLibrary/js/myJsFile.js
</code></pre>
<p class="normal">It is worth pointing out that all CSS files added to components (CSS isolation) we mentioned<a id="_idIndexMarker1388"/> earlier in this chapter are compiled into a unique CSS file that is added as a DLL resource. This file must be referenced in the <code class="inlineCode">index.html</code> page as:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;assembly name&gt;.Client.styles.css
</code></pre>
<p class="normal">If your JavaScript files are organized as ES6 modules, you can avoid referencing them in <code class="inlineCode">Index.html</code> and can load the modules directly, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">// _content/MyCompany.MyLibrary/js/myJsFile.js  JavaScript file
export function myFunction ()
{
...
}
...
//C# code
var module = await jsRuntime.InvokeAsync&lt;JSObjectReference&gt;(
    "import", "./_content/MyCompany.MyLibrary/js/myJsFile.js");
...
T res= await module.InvokeAsync&lt;T&gt;("myFunction")
</code></pre>
<p class="normal">In addition, instance methods of C# objects can be called from JavaScript code, by taking the following steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Say the C# method is called <code class="inlineCode">MyMethod</code>. Decorate the <code class="inlineCode">MyMethod</code> method with the <code class="inlineCode">[JSInvokable]</code> attribute.</li>
<li class="numberedList">Enclose the C# object in a <code class="inlineCode">DotNetObjectReference</code> instance and pass it to JavaScript with a JavaScript call:
        <pre class="programlisting code"><code class="hljs-code">var objRef = DotNetObjectReference.Create(myObjectInstance);
//pass objRef to JavaScript
....
//dispose the DotNetObjectReference
objRef.Dispose()
</code></pre>
</li>
<li class="numberedList">On the JavaScript side, say the C# object is in a variable called <code class="inlineCode">dotnetObject</code>. Then, we just need to invoke:
        <pre class="programlisting code"><code class="hljs-code">dotnetObject.invokeMethodAsync("&lt;dll name&gt;", "MyMethod", arg1, ...).
then(result =&gt; {...})
</code></pre>
</li>
</ol>
<p class="normal">The <strong class="keyWord">Awesome Blazor</strong> project (<a href="https://github.com/AdrienTorris/awesome-blazor">https://github.com/AdrienTorris/awesome-blazor</a>) lists a lot of <a id="_idIndexMarker1389"/>open-source projects that use JavaScript’s interoperability to build .NET wrappers for <a id="_idIndexMarker1390"/>well-known JavaScript libraries. There, you can find wrappers for 3D graphics JavaScript libraries, plot JavaScript libraries, and so on.</p>
<p class="normal">The next section explains how to handle contents and number/date localization.</p>
<h2 class="heading-2" id="_idParaDest-400">Globalization and localization</h2>
<p class="normal">As soon <a id="_idIndexMarker1391"/>as the Blazor application starts, both the application culture and the application UI culture are set to the browser culture. However, the developer can change both of them by assigning the chosen cultures to <code class="inlineCode">CultureInfo.DefaultThreadCurrentCulture</code> and <code class="inlineCode">CultureInfo.DefaultThreadCurrentUICulture</code>. Typically, the application lets the user choose one of its supported cultures, or it accepts the browser culture only if it is supported; otherwise, it <a id="_idIndexMarker1392"/>falls back to a supported culture. In fact, it is possible to support just a reasonable number of cultures because all application strings must be translated into all supported cultures.</p>
<p class="normal">If the application must support a single culture, this culture can be set once and for all in <code class="inlineCode">program.cs</code> after the host has been built but before the host is run.</p>
<p class="normal">This can be done by replacing await <code class="inlineCode">builder.Build().RunAsync()</code> with:</p>
<pre class="programlisting code"><code class="hljs-code">var host = builder.Build();
…
CultureInfo.DefaultThreadCurrentCulture = new CultureInfo(…);
CultureInfo.DefaultThreadCurrentUICulture = new CultureInfo(…);
…
await host.RunAsync();
</code></pre>
<p class="normal">If the application must support several languages, the code is similar, but the culture information must be taken from the browser’s local storage, where the user must be given the option to store it in some applications option page.</p>
<p class="normal">Once the <code class="inlineCode">CurrentCulture</code> is set, dates and numbers are automatically formatted according to the conventions of the chosen culture. For the UI culture, the developer must manually provide resource files with the translations of all application strings in all supported cultures. Blazor uses the same localization/globalization techniques, so please refer to the <em class="italic">ASP.NET Core globalization</em> section of <em class="italic">Chapter 17</em>, <em class="italic">Presenting ASP.NET Core</em>, for more details.</p>
<p class="normal">There are two ways to use resource files. With the first option, you create a resource file, say, <code class="inlineCode">myResource.resx</code>, and then add all language-specific files: <code class="inlineCode">myResource.it.resx</code>, <code class="inlineCode">myResource.pt.resx</code>, and so on. In this case, Visual Studio creates a static class named <code class="inlineCode">myResource</code> whose static properties are the keys of each resource file. These properties will automatically contain the localized strings corresponding to the current UI culture. You can use these static properties wherever you like, and you can use pairs composed of a resource type and a resource name to set the <code class="inlineCode">ErrorMessageResourceType</code> and <code class="inlineCode">ErrorMessageResourceName</code> properties of validation attributes or similar properties of other attributes. This way, the attributes will use an automatically localized string.</p>
<p class="normal">With the <a id="_idIndexMarker1393"/>second option, you add only language-specific resource files (<code class="inlineCode">myResource.it.resx</code>, <code class="inlineCode">myResource.pt.resx</code>, and so on). In this case, Visual Studio doesn’t create any class associated with the resource file, and you can use <a id="_idIndexMarker1394"/>resource files together with <code class="inlineCode">IStringLocalizer</code> and <code class="inlineCode">IStringLocalizer&lt;T&gt;</code> injected in components as you use them in ASP.NET Core MVC views (see the <em class="italic">ASP.NET Core globalization</em> section of <em class="italic">Chapter 17</em>, <em class="italic">Presenting ASP.NET Core</em>).</p>
<h2 class="heading-2" id="_idParaDest-401">Authentication and authorization</h2>
<p class="normal">In the <em class="italic">Routing</em> subsection, we discussed how the <code class="inlineCode">CascadingAuthenticationState</code> and <code class="inlineCode">AuthorizeRouteView</code> components prevent unauthorized users from accessing pages protected with an <code class="inlineCode">[Authorize]</code> attribute. Let’s go deeper into the details of how page authorization works.</p>
<p class="normal">In .NET applications, authentication <a id="_idIndexMarker1395"/>and authorization<a id="_idIndexMarker1396"/> information is usually contained in a <code class="inlineCode">ClaimsPrincipal</code> instance. In server applications, this instance is built when the user logs in, taking the required information from a database. In Blazor WebAssembly, such information must be provided by some remote server that takes care of SPA authentication too. Since there are several ways to provide authentication and authorization to a Blazor WebAssembly application, Blazor defines the <code class="inlineCode">AuthenticationStateProvider</code> abstraction.</p>
<p class="normal">Authentication and authorization providers inherit from the <code class="inlineCode">AuthenticationStateProvider</code> abstract class and override its <code class="inlineCode">GetAuthenticationStateAsync</code> method, which returns <code class="inlineCode">Task&lt;AuthenticationState&gt;</code>, where <code class="inlineCode">AuthenticationState</code> contains the authentication and authorization information. Actually, <code class="inlineCode">AuthenticationState</code> contains just a <code class="inlineCode">User</code> property with a <code class="inlineCode">ClaimsPrincipal</code>.</p>
<p class="normal">Once we’ve <a id="_idIndexMarker1397"/>defined a concrete implementation of <code class="inlineCode">AuthenticationStateProvider</code>, we must register it in the dependency<a id="_idIndexMarker1398"/> engine container in the application’s <code class="inlineCode">Program.cs</code> file:</p>
<pre class="programlisting code"><code class="hljs-code">builder.services.AddScoped&lt;AuthenticationStateProvider,
   MyAuthStateProvider&gt;();
</code></pre>
<p class="normal">We will return to the predefined implementations of <code class="inlineCode">AuthenticationStateProvider</code> offered by Blazor after having described how Blazor uses authentication and authorization information provided by a registered <code class="inlineCode">AuthenticationStateProvider</code>.</p>
<p class="normal">The <code class="inlineCode">CascadingAuthenticationState</code> component calls the <code class="inlineCode">GetAuthenticationStateAsync</code> method of the registered <code class="inlineCode">AuthenticationStateProvider</code> and cascades the returned <code class="inlineCode">Task&lt;AuthenticationState&gt;</code>. You can intercept this cascading value with a <code class="inlineCode">[CascadingParameter]</code> defined as follows in your components:</p>
<pre class="programlisting code"><code class="hljs-code">[CascadingParameter]
private Task&lt;AuthenticationState&gt; myAuthenticationStateTask { get; set; }
……
ClaimsPrincipal user = (await myAuthenticationStateTask).User;
</code></pre>
<p class="normal">However, Blazor applications typically use <code class="inlineCode">AuthorizeRouteView</code> and <code class="inlineCode">AuthorizeView</code> components to control user access to content.</p>
<p class="normal"><code class="inlineCode">AuthorizeRouteView</code> prevents access to pages if the user doesn’t satisfy the prescriptions of the page’s <code class="inlineCode">[Authorize]</code> attribute; otherwise, the content in the <code class="inlineCode">NotAuthorized</code> template is rendered. <code class="inlineCode">AuthorizeRouteView</code> also has an <code class="inlineCode">Authorizing</code> template that is shown while user information is being retrieved.</p>
<p class="normal"><code class="inlineCode">AuthorizeView</code> can be used within components to show the markup it encloses only to authorized users. It contains the same <code class="inlineCode">Roles</code> and <code class="inlineCode">Policy</code> parameters of the <code class="inlineCode">[Authorize]</code> attribute that you can use to specify the constraints the user must satisfy to access the content:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;AuthorizeView Roles="Admin,SuperUser"&gt;
//authorized content
&lt;/AuthorizeView&gt;
</code></pre>
<p class="normal"><code class="inlineCode">AuthorizeView</code> can also specify <code class="inlineCode">NotAuthorized</code> and an <code class="inlineCode">Authorizing</code> template:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;AuthorizeView&gt;
&lt;Authorized&gt;
    ...
  &lt;/Authorized&gt;
&lt;Authorizing&gt;
    ...
  &lt;/Authorizing&gt;
&lt;NotAuthorized&gt;
    ...
  &lt;/NotAuthorized&gt;
&lt;/AuthorizeView&gt;
</code></pre>
<p class="normal">If one adds<a id="_idIndexMarker1399"/> authorization while creating a Blazor <a id="_idIndexMarker1400"/>WebAssembly project, the following method call is added to the application dependency engine:</p>
<pre class="programlisting code"><code class="hljs-code">builder.Services.AddOidcAuthentication(options =&gt;
{
    // Configure your authentication provider options here.
// For more information, see https://aka.ms/blazor-standalone-auth
    builder.Configuration.Bind("Local", options.ProviderOptions);
});
</code></pre>
<p class="normal">This method adds an <code class="inlineCode">AuthenticationStateProvider</code> that extracts the user information from the authentication cookie of an OAuth provider. The OAuth protocol with the OAuth provider is performed with the help of the <code class="inlineCode">AuthenticationService.js</code> JavaScript file we saw in the <em class="italic">Loading and starting the application</em> subsection of this chapter. The OAuth provider endpoint returns user information in the form of a bearer token that can, then, also be used to authenticate communications with the server’s web API. Bearer tokens are described in detail in the <em class="italic">REST service authorization and authentication</em> and <em class="italic">ASP.NET Core service authorization</em> sections of <em class="italic">Chapter 15</em>, <em class="italic">Applying Service-Oriented Architectures with .NET</em>. Blazor WebAssembly communication is described in the next subsection.</p>
<p class="normal">The previous code takes the OAuth parameters from a configuration file you must add as <code class="inlineCode">wwwroot/appsettings.json</code>:</p>
<pre class="programlisting code"><code class="hljs-code">{
"Local": {
"Authority": "{AUTHORITY}",
"ClientId": "{CLIENT ID}"
}
}
</code></pre>
<p class="normal">If you use <a id="_idIndexMarker1401"/>Google as the authentication provider, <code class="inlineCode">AUTHORITY</code> is <code class="inlineCode">https://accounts.google.com/</code>, while <code class="inlineCode">CLIENT ID</code> is the client ID you receive when <a id="_idIndexMarker1402"/>you register your Blazor application with the Google Developers program.</p>
<p class="normal">Google needs some more parameters, namely the return URL to return once the authentication process is completed and the page to return to after a logout:</p>
<pre class="programlisting code"><code class="hljs-code">{
"Local": {
"Authority": "https://accounts.google.com/",
"ClientId": "2...7-e...q.apps.googleusercontent.com",
"PostLogoutRedirectUri": "https://localhost:5001/authentication/logout-callback",
"RedirectUri": "https://localhost:5001/authentication/login-callback",
"ResponseType": "id_token"
}
}
</code></pre>
<p class="normal">Where <code class="inlineCode">https://localhost:5001</code> must be replaced with the actual domain of the Blazor application.</p>
<p class="normal">Before any authentication or if the authentication fails, an unauthenticated <code class="inlineCode">ClaimsPrincipal</code> is created. This way, when the user tries to access a page that is protected by an <code class="inlineCode">[Authorize]</code> attribute, the <code class="inlineCode">AuthorizeRouteView</code> component invokes the <code class="inlineCode">RedirectToLogin</code> component, which, in turn, navigates to the <code class="inlineCode">Authentication.razor</code> page, passing it a login request in its <code class="inlineCode">action</code> route parameter:</p>
<pre class="programlisting code"><code class="hljs-code">@page "/authentication/{action}"
@using Microsoft.AspNetCore.Components.WebAssembly.Authentication
&lt;RemoteAuthenticatorView Action="@Action"  /&gt;
@code{
    [Parameter] public string Action { get; set; }
}
</code></pre>
<p class="normal">The <code class="inlineCode">RemoteAuthenticatorView</code> acts as an interface with the usual ASP.NET Core user login/registration system, and whenever it receives an “action” to perform, it redirects the user from the Blazor application to the proper ASP.NET Core server page (login, registration, logout, and user profile).</p>
<p class="normal">Once the <a id="_idIndexMarker1403"/>user logs in, they are redirected to <a id="_idIndexMarker1404"/>the Blazor application page that caused the login request. The redirect URL is computed by the <code class="inlineCode">BlazorReview.Layout-&gt;RedirectToLogin.razor</code> component, which extracts it from the <code class="inlineCode">NavigationManager</code> and passes it to the <code class="inlineCode">RemoteAuthenticatorView</code> component. This time, the <code class="inlineCode">AuthenticationStateProvider</code> is able to get the user information from the authentication cookie that has been created by the login operation.</p>
<p class="normal">It is possible both to design a custom OAuth provider for your Blazor application or to design a completely custom way to get a bearer token with an internal login Blazor page without leaving the Blazor application. In this last case, you must provide a custom implementation of the <code class="inlineCode">AuthenticationStateProvider</code>. More details on these advanced custom scenarios are available in the official documentation reference in the <em class="italic">Further reading</em> section.</p>
<p class="normal">Having learned how to authenticate with an external OAuth provider and how to handle authorization within the Blazor application, we are ready to learn how to exchange data and how to authenticate with a REST API.</p>
<p class="normal">The next subsection describes a Blazor WebAssembly-specific implementation of the <code class="inlineCode">HttpClient</code> class and related types.</p>
<h2 class="heading-2" id="_idParaDest-402">Communication with the server</h2>
<p class="normal">Blazor WebAssembly <a id="_idIndexMarker1405"/>supports the same .NET <code class="inlineCode">HttpClient</code> and <code class="inlineCode">HttpClientFactory</code> classes described in the <em class="italic">.NET HTTP clients</em> section of <em class="italic">Chapter 15</em>, <em class="italic">Applying Service-Oriented Architectures with .NET</em>. However, due to the communication limitations of browsers, their implementations are different and rely on the<a id="_idIndexMarker1406"/> browser’s <strong class="keyWord">fetch API</strong>.</p>
<p class="normal">In fact, for security reasons, all browsers, do not allow direct opening of generic <strong class="keyWord">TCP/IP</strong> connections but force <a id="_idIndexMarker1407"/>all server communications to pass either through<a id="_idIndexMarker1408"/> <strong class="keyWord">Ajax</strong> or through the <strong class="keyWord">fetch API</strong>. </p>
<p class="normal">This way, when you attempt a communication toward a URL that differs from the domain where the browser downloaded the SPA, the browser automatically switches to the CORS protocol, thus informing the server that the communication was started by a browser application that was downloaded by a different domain and that might potentially be a phishing website.</p>
<p class="normal">In turn, the <a id="_idIndexMarker1409"/>server accepts CORS communications just from well-known domains that are pre-listed in its code. This way, the server is sure that the request can’t come from a phishing website.</p>
<p class="normal">In <em class="italic">Chapter 15</em>, <em class="italic">Applying Service-Oriented Architectures with .NET</em>, we analyzed how to take advantage of <code class="inlineCode">HttpClientFactory</code> to define typed clients. You can also define typed clients in Blazor with exactly the same syntax.</p>
<p class="normal">However, since an authenticated Blazor application needs to send the bearer token created during the authentication process in each request to the application server, it is common to define a named client as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">builder.Services.AddHttpClient("BlazorReview.ServerAPI", client =&gt;
         client.BaseAddress = new Uri("https://&lt;web api URL&gt;"))
.AddHttpMessageHandler&lt;BaseAddressAuthorizationMessageHandler&gt;();
</code></pre>
<p class="normal"><code class="inlineCode">AddHttpMessageHandler</code> adds a <code class="inlineCode">DelegatingHandler</code>, that is, a subclass of the <code class="inlineCode">DelegatingHandler</code> abstract class. Implementations of <code class="inlineCode">DelegatingHandler</code> override its <code class="inlineCode">SendAsync</code> method in order to process each request and each relative response:</p>
<pre class="programlisting code"><code class="hljs-code">protected override async Task&lt;HttpResponseMessage&gt; SendAsync(
        HttpRequestMessage request,
        CancellationToken cancellationToken)
{
//modify request
   ...
HttpResponseMessage= response = await base.SendAsync(
   request, cancellationToken);
//modify response
   ...
return response;
}
</code></pre>
<p class="normal">If this bearer token is expired or is not found at all, it tries to get a new bearer token by using the authentication cookie received when the user manually logged in with the OAuth provider. This way, it can obtain a fresh bearer token without requesting a new manual login. If this attempt also fails, an <code class="inlineCode">AccessTokenNotAvailableException</code> is thrown. Typically, this exception is captured and used to trigger a redirection to the login page by calling its <code class="inlineCode">Redirect</code> method, as shown below:</p>
<pre class="programlisting code"><code class="hljs-code">try
{
        //server call here
}
catch (AccessTokenNotAvailableException exception)
{
        exception.Redirect();
}
</code></pre>
<p class="normal">If both<a id="_idIndexMarker1410"/> the Blazor application and the Web API are deployed in different subfolders of the same domain, Blazor requests are issued without the CORS protocol, so they are automatically accepted by the server. Otherwise, the ASP.NET Core server must enable CORS requests, and must list the Blazor application URL among the allowed CORS domains with something like:</p>
<pre class="programlisting code"><code class="hljs-code">builder.Services.AddCors(o =&gt; {
    o.AddDefaultPolicy(pbuilder =&gt;
    {
        pbuilder.AllowAnyMethod();
        pbuilder.WithHeaders(HeaderNames.ContentType, HeaderNames.Authorization);
        pbuilder.WithOrigins(https://&lt;Blazor client url&gt;, …, https://&lt;Another client url&gt;);
    });
 });
</code></pre>
<p class="normal">Then, you must also place the <code class="inlineCode">app.UseCors()</code> middleware in the ASP.NET Core pipeline. </p>
<p class="normal">The example data shown on the <code class="inlineCode">Weather</code> page of the <code class="inlineCode">ReviewBlazor</code> application are downloaded from a static file located in the <code class="inlineCode">wwwroot/sample-data</code> folder of the same Blazor application, so a normal, not-CORS request is issued and no bearer token is needed to request. Accordingly, the <code class="inlineCode">Weather</code>page uses a default <code class="inlineCode">HttpClient</code> defined in <code class="inlineCode">Program.cs</code> as:</p>
<pre class="programlisting code"><code class="hljs-code">builder.Services.AddScoped(sp =&gt; new HttpClient { BaseAddress = new Uri(builder.HostEnvironment.BaseAddress) });
</code></pre>
<p class="normal">The next subsection explains how to improve the performance of computation-intensive applications with Blazor AOT compilation.</p>
<h2 class="heading-2" id="_idParaDest-403">AOT compilation</h2>
<p class="normal">Once<a id="_idIndexMarker1411"/> uploaded in the browser, .NET assemblies are not <a id="_idIndexMarker1412"/>compiled <strong class="keyWord">Just in Time</strong> (<strong class="keyWord">JIT</strong>) at their first execution as is the case for other platforms. Instead, they are interpreted by a very fast interpreter. Just the .NET runtime is pre-compiled and uploaded in the browser directly in WebAssembly.</p>
<p class="normal">JIT compilation is avoided since it would considerably increase the application start time, which is already quite high because of the high application download size (about 10 MB). In turn, the download size is high due to the .NET libraries that any Blazor application needs to work properly.</p>
<p class="normal">In order to reduce download size, during the compilation in release mode, Blazor .NET assemblies are tree-shaken to remove all unused types and methods. However, notwithstanding this tree-shaking, the typical download size remains quite high. A good download improvement is achieved with the default caching of the .NET runtime, which reduces the download size to 2-4 MB. However, the download size still remains high the first time a Blazor application is visited.</p>
<p class="normal">Starting from .NET 6, Blazor offers an alternative to JIT compilation: <strong class="keyWord">Ahead-of-Time</strong> (<strong class="keyWord">AOT</strong>) compilation. With <a id="_idIndexMarker1413"/>AOT, all application assemblies are compiled into a unique WebAssembly file during the application publication.</p>
<p class="normal">AOT compilation is very slow and may last something like 10-30 minutes, even in the case of small applications. On the other hand, it must be executed only once when the application is published, so the compilation time doesn’t impact the application start time.</p>
<p class="normal">Unfortunately, AOT compilation more than doubles the download size, since the compiled code is more verbose than the source .NET code. Therefore, AOT should be adopted only in performance-critical applications that can trade a higher start time for better performance.</p>
<p class="normal">.NET WebAssembly AOT compilation requires an additional build tool that must be installed as an optional .NET SDK workload in order to use it. The first time, you can install it with the following shell command:</p>
<pre class="programlisting con"><code class="hljs-con">dotnet workload install wasm-tools
</code></pre>
<p class="normal">Instead, when a new .NET version is installed, we just need to launch the following command to update all previously installed workloads:</p>
<pre class="programlisting con"><code class="hljs-con">dotnet workload update
</code></pre>
<p class="normal">Once the AOT workload has been installed, AOT compilation can be enabled on a per-project basis by adding the <code class="inlineCode">&lt;RunAOTCompilation&gt;true&lt;/RunAOTCompilation&gt;</code> declaration to the Blazor project file, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Project Sdk="Microsoft.NET.Sdk.BlazorWebAssembly"&gt;
&lt;PropertyGroup&gt;
&lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;
&lt;RunAOTCompilation&gt;true&lt;/RunAOTCompilation&gt;
&lt;/PropertyGroup&gt;
  ...
</code></pre>
<p class="normal">The next <a id="_idIndexMarker1414"/>section briefly discusses some of the most relevant third-party tools and libraries that complete Blazor’s official features and help increase productivity in Blazor projects.</p>
<h1 class="heading-1" id="_idParaDest-404">Third-party tools for Blazor WebAssembly</h1>
<p class="normal">Notwithstanding<a id="_idIndexMarker1415"/> Blazor being a young product, its third-party tool and product ecosystem is already quite rich. Among the open source, free products, it is <a id="_idIndexMarker1416"/>worth mentioning the <strong class="keyWord">Blazorise</strong> project (<a href="https://github.com/stsrki/Blazorise">https://github.com/stsrki/Blazorise</a>), which contains various free basic Blazor components (inputs, tabs, modals, and so on) that can be styled with various CSS frameworks, such as<a id="_idIndexMarker1417"/> Bootstrap and Material. It also contains a simple editable grid and a simple tree view.</p>
<p class="normal">Also worth<a id="_idIndexMarker1418"/> mentioning is <strong class="keyWord">BlazorStrap</strong> (<a href="https://github.com/chanan/BlazorStrap">https://github.com/chanan/BlazorStrap</a>), which contains pure Blazor implementations of all Bootstrap 4 components and widgets.</p>
<p class="normal">Among all the <a id="_idIndexMarker1419"/>commercial products, it is worth mentioning <strong class="keyWord">Blazor Controls Toolkit</strong> (<a href="https://blazorct.azurewebsites.net/">https://blazorct.azurewebsites.net/</a>), which is a complete toolset for implementing commercial applications. It contains all input types with their fallbacks in case they are not supported by the browser; all Bootstrap components; other basic components; a complete, advanced drag-and-drop framework; and advanced customizable and editable components, like detail views, detail lists, grids, and a tree-repeater (a generalization of the tree view). All components are based on a sophisticated metadata representation system that enables the user to design the markup in a declarative way using data annotations and inline Razor declarations.</p>
<p class="normal">Moreover, it <a id="_idIndexMarker1420"/>contains additional sophisticated <a id="_idIndexMarker1421"/>validation attributes, tools for undoing user input, tools for computing changes to send to the server, sophisticated client-side and server-side query tools based on the OData protocol, and tools to maintain and save the whole application state.</p>
<p class="normal">It is also worth mentioning <a id="_idIndexMarker1422"/>the <strong class="keyWord">bUnit</strong> open-source project (<a href="https://github.com/egil/bUnit">https://github.com/egil/bUnit</a>), which provides all the tools for testing Blazor components.</p>
<p class="normal">The <strong class="keyWord">Awesome Blazor</strong> project (<a href="https://github.com/AdrienTorris/awesome-blazor">https://github.com/AdrienTorris/awesome-blazor</a>) lists thousands<a id="_idIndexMarker1423"/> of open-source and commercial Blazor resources, such as tutorials, posts, libraries, and example projects.</p>
<p class="normal">A complete example of a Blazor WebAssembly application based on the WWTravelClub book use case can be found in the <em class="italic">Using client technologies </em>section of <em class="italic">Chapter 21, Case Study.</em> The next section explains how to use Blazor to implement cross-platform applications. The actual code is contained in the folder associated with this chapter in the GitHub repository of the book.</p>
<h1 class="heading-1" id="_idParaDest-405">.NET MAUI Blazor</h1>
<p class="normal">.NET MAUI is Microsoft’s <a id="_idIndexMarker1424"/>advised choice to implement cross-platform applications. In fact, .NET MAUI applications can be just-in-time compiled for all Windows, Android, iOS, and other Linux-based devices. .NET MAUI contains a common abstraction of all target devices, and at the same time takes advantage of each device’s peculiarities by offering platform-specific libraries each containing platform-specific features of a target platform.</p>
<p class="normal">We will not describe .NET MAUI in detail, but after a short introduction to .NET MAUI, we will focus just on .NET MAUI Blazor. This way, by learning just Blazor, you will be able to develop single-page applications, progressive applications, and cross-platform applications.</p>
<h2 class="heading-2" id="_idParaDest-406">What is .NET MAUI?</h2>
<p class="normal">.NET MAUI <a id="_idIndexMarker1425"/>extends Xamarin.Forms’ cross-platform capabilities from Android and iOS to also include Windows and macOS. Thus, .NET MAUI is a cross-platform framework for creating both native mobile and desktop apps with C#.</p>
<p class="normal">The basis of .NET MAUI is<a id="_idIndexMarker1426"/> Xamarin.Forms. In fact, Microsoft has provided a guide for migrating original Xamarin.Forms apps to .NET MAUI, as can be seen at the following link: <a href="https://docs.microsoft.com/en-us/dotnet/maui/get-started/migrate">https://docs.microsoft.com/en-us/dotnet/maui/get-started/migrate</a>. However, .NET MAUI has been conceived to be the new-generation framework for any native/desktop app development in C#:</p>
<figure class="mediaobject"><img alt="Interface gráfica do usuário, Site  Descrição gerada automaticamente" src="img/B19820_19_02.png"/></figure>
<p class="packt_figref">Figure 19.2: .NET MAUI high-level architecture</p>
<p class="normal">There is a specific difference between Xamarin.Forms and .NET MAUI. In Xamarin.Forms, there is a specific native project for any kind of device we would like to publish to on the app, while<a id="_idIndexMarker1427"/> in .NET MAUI, this approach is based on as single project targeting multiple platforms.</p>
<p class="normal">The next section explains how to use .NET MAUI to run a Blazor application as a native application.</p>
<h2 class="heading-2" id="_idParaDest-407">Developing native applications with Blazor</h2>
<p class="normal">.NET MAUI is<a id="_idIndexMarker1428"/> not installed by default when you install Visual Studio 2022, but you need to select the .NET MAUI workload in the Visual Studio installer. Therefore, if you don’t see MAUI projects when you start a new <a id="_idIndexMarker1429"/>project in your Visual Studio installation, you need to run the Visual Studio installer and modify your existing installation with the addition of the .NET MAUI workload.</p>
<p class="normal">Once you have the MAUI workload installed, in the project creation wizard, you should be able to select <strong class="screenText">C#/All platforms/MAUI</strong>, and then select <strong class="screenText">.NET MAUI Blazor Hybrid App</strong>, as shown here:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_19_03.png"/></figure>
<p class="packt_figref">Figure 19.3: Creating a .NET MAUI Blazor application</p>
<p class="normal">Create a<a id="_idIndexMarker1430"/> MAUI Blazor project and call it <code class="inlineCode">MAUIBlazorReview</code>. The MAUI Blazor application contains the usual <code class="inlineCode">Layout</code> and <code class="inlineCode">Pages</code> folders where you can place your Blazor components and pages, but they are <a id="_idIndexMarker1431"/>placed inside a <code class="inlineCode">Components</code> folder. It also contains a <code class="inlineCode">wwwroot</code> folder containing the usual <code class="inlineCode">index.html</code> page and all the CSS and JavaScript you might need. Finally, it also contains the usual <code class="inlineCode">_Imports.razor</code> page where you can place all your default <code class="inlineCode">using</code> statements.</p>
<p class="normal">A MAUI Blazor application also uses layout pages that you can place in the <code class="inlineCode">Shared</code> folder and may reference Razor libraries containing CSS components and JavaScript files.</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_19_04.png"/></figure>
<p class="packt_figref">Figure 19.4: .NET MAUI Blazor project</p>
<p class="normal">The only<a id="_idIndexMarker1432"/> difference is that services, instead of being declared in <code class="inlineCode">Program.cs</code> files, are declared in <code class="inlineCode">MauiProgram.cs</code> together <a id="_idIndexMarker1433"/>with MAUI-specific code:</p>
<pre class="programlisting code"><code class="hljs-code"> public static class MauiProgram
    {
        public static MauiApp CreateMauiApp()
        {
            var builder = MauiApp.CreateBuilder();
            builder
                .UseMauiApp&lt;App&gt;()
                .ConfigureFonts(fonts =&gt;
                {
                    fonts.AddFont("OpenSans-Regular.ttf", "OpenSansRegular");
                });
            builder.Services.AddMauiBlazorWebView();
            #if DEBUG
            builder.Services.AddBlazorWebViewDeveloperTools();
 builder.Logging.AddDebug();
            #endif
//this is a service
builder.Services.AddSingleton&lt;WeatherForecastService&gt;();
            return builder.Build();
        }
    }
</code></pre>
<p class="normal">Attention <a id="_idIndexMarker1434"/>must be paid when using an <code class="inlineCode">HttpClient</code> class to communicate with a server. Blazor web applications may use URLs relative to the domain where they were downloaded, while MAUI Blazor applications <a id="_idIndexMarker1435"/>must use absolute URLs since they are not associated with any default URL. Therefore, an <code class="inlineCode">HttpClient</code> definition is added to the services with something like this:</p>
<pre class="programlisting code"><code class="hljs-code">builder.Services.AddScoped(sp =&gt; new HttpClient
{ BaseAddress = new Uri("https://localhost:7215") });
</code></pre>
<p class="normal">The <code class="inlineCode">Platforms</code> folder contains a subfolder for each platform supported by the application, where each subfolder contains platform-specific code.</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_19_05.png"/></figure>
<p class="packt_figref">Figure 19.5: Platforms folder</p>
<p class="normal">Supported folders can be changed by editing the <code class="inlineCode">TargetFrameworks</code> element of the <code class="inlineCode">MAUIBlazorReview.csproj</code> file:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;TargetFrameworks&gt;net8.0-android;net8.0-ios;net8.0-maccatalyst&lt;/TargetFrameworks&gt;
</code></pre>
<p class="normal">You can <a id="_idIndexMarker1436"/>select the platform to run the application from using the dropdown next to the green Visual Studio run button. On <a id="_idIndexMarker1437"/>a Windows machine, you can select just Windows and Android. If you select Android, an Android device simulator is launched.</p>
<p class="normal">In order to debug for iOS/Mac platforms on a Windows machine, you need to connect an iOS/Mac device to your computer.</p>
<p class="normal">When you build the project, the build may ask you to install an Android SDK version. If this is the case, please follow the simple instructions in the error message.</p>
<h1 class="heading-1" id="_idParaDest-408">Summary</h1>
<p class="normal">In this chapter, you learned about client-side technologies. In particular, you learned what an SPA is and how to build one based on the Blazor WebAssembly framework. The chapter first described the Blazor WebAssembly architecture, and then explained how to exchange input/output with Blazor components and the concept of binding.</p>
<p class="normal">After having explained Blazor’s general principles, the chapter focused on how to get user input while providing the user with adequate feedback and visual clues in the event of errors. Then, the chapter provided a short description of advanced features, such as JavaScript interoperability, globalization, authentication with authorization, and client-server communication.</p>
<p class="normal">Finally, the last section explained how to use Blazor to implement cross-platform applications based on Microsoft MAUI and how to transform a Blazor WebAssembly project into a .NET MAUI Blazor project.</p>
<p class="normal">Complete examples of Blazor applications based on the WWTravelClub book use case can be found in the <em class="italic">Using client technologies </em>section of <em class="italic">Chapter 21</em>, <em class="italic">Case Study</em>.</p>
<h1 class="heading-1" id="_idParaDest-409">Questions</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">What is WebAssembly?</li>
<li class="numberedList">What is an SPA?</li>
<li class="numberedList">What is the purpose of the Blazor <code class="inlineCode">router</code> component?</li>
<li class="numberedList">What is a Blazor page?</li>
<li class="numberedList">What is the purpose of the <code class="inlineCode">@namespace</code> directive?</li>
<li class="numberedList">What is an <code class="inlineCode">EditContext</code>?</li>
<li class="numberedList">What is the right place to initialize a component?</li>
<li class="numberedList">What is the right place to process the user input?</li>
<li class="numberedList">What is the <code class="inlineCode">IJSRuntime</code> interface?</li>
<li class="numberedList">What is the purpose of <code class="inlineCode">@ref</code>?</li>
</ol>
<h1 class="heading-1" id="_idParaDest-410">Further reading</h1>
<ul>
<li class="bulletList">The Blazor official documentation is available at <a href="https://docs.microsoft.com/en-us/aspnet/core/blazor">https://docs.microsoft.com/en-us/aspnet/core/blazor</a>.</li>
<li class="bulletList">Lazy loading assemblies is described at <a href="https://docs.microsoft.com/en-US/aspnet/core/blazor/webassembly-lazy-load-assemblies">https://docs.microsoft.com/en-US/aspnet/core/blazor/webassembly-lazy-load-assemblies</a>.</li>
<li class="bulletList">All HTML events supported by Blazor together with their event arguments are listed at <a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/components/event-handling#event-arguments-1">https://docs.microsoft.com/en-us/aspnet/core/blazor/components/event-handling#event-arguments-1</a>.</li>
<li class="bulletList">Blazor supports the same validation attributes as ASP.NET MVC, with the exception of <code class="inlineCode">RemoteAttribute</code>: <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation#built-in-attributes">https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation#built-in-attributes</a>.</li>
<li class="bulletList">A description of the <code class="inlineCode">InputFile</code> component, and how to use it, can be found here: <a href="https://docs.microsoft.com/en-US/aspnet/core/blazor/file-uploads">https://docs.microsoft.com/en-US/aspnet/core/blazor/file-uploads</a>.</li>
<li class="bulletList">More details on Blazor localization and globalization are available here: <a href="https://docs.microsoft.com/en-US/aspnet/core/blazor/globalization-localization">https://docs.microsoft.com/en-US/aspnet/core/blazor/globalization-localization</a>.</li>
<li class="bulletList">More details on Blazor authentication and all its related URLs are available here: <a href="https://docs.microsoft.com/en-US/aspnet/core/blazor/security/webassembly/">https://docs.microsoft.com/en-US/aspnet/core/blazor/security/webassembly/</a>.</li>
<li class="bulletList">The Blazorise project: <a href="https://github.com/stsrki/Blazorise">https://github.com/stsrki/Blazorise</a>.</li>
<li class="bulletList">BlazorStrap: <a href="https://github.com/chanan/BlazorStrap">https://github.com/chanan/BlazorStrap</a>.</li>
<li class="bulletList">Blazor Controls Toolkit: <a href="https://blazorct.azurewebsites.net/">https://blazorct.azurewebsites.net/</a>.</li>
<li class="bulletList">bUnit: <a href="https://github.com/egil/bUnit">https://github.com/egil/bUnit</a>.</li>
<li class="bulletList">The Awesome Blazor project: <a href="https://github.com/AdrienTorris/awesome-blazor">https://github.com/AdrienTorris/awesome-blazor</a>.</li>
</ul>
<h1 class="heading-1">Learn more on Discord</h1>
<p class="normal">To join the Discord community for this book – where you can share feedback, ask questions to the authors, and learn about new releases – follow the QR code below:</p>
<p class="normal"><a href="https://packt.link/SoftwareArchitectureCSharp12Dotnet8">https://packt.link/SoftwareArchitectureCSharp12Dotnet8</a></p>
<p class="normal"><img alt="" role="presentation" src="img/QR_Code175081751210902046.png"/></p>
</div>
</body></html>