<html><head></head><body>
        

                            
                    <h1 class="header-title">Automation for Software Testing</h1>
                
            
            
                
<p>In previous chapters, we discussed the importance of unit tests and integration tests in software development, and how they ensure the reliability of your code base. We also discussed how unit and integration tests are integral parts of all software production stages and are run each time the code base is modified.</p>
<p>There are also other important tests, called <strong>functional</strong>/<strong>acceptation</strong> tests. They are run only at the end of each sprint to verify that the output of the sprint actually satisfies the specifications that were agreed upon with the stakeholders.</p>
<p>This chapter is specifically dedicated to functional/acceptance tests and to the techniques for defining and executing them. More specifically, this chapter covers the following topics:</p>
<ul>
<li>Understanding the purpose of functional tests</li>
<li>Using unit testing tools for automating functional tests in C#</li>
<li>Use case – automating functional tests</li>
</ul>
<p>By the end of this chapter, you will be able to design both manual and automatic tests to verify that the code produced by a sprint complies with its specifications.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>The reader is encouraged to read <a href="c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml">Chapter 15</a>, <em>Testing Your Code with Unit Test Cases and TDD</em>, before proceeding with this chapter.</p>
<p>This chapter requires Visual Studio 2017 or the 2019 free Community Edition or better with all the database tools installed. Here, we will modify the code of <a href="c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml"/><a href="c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml">Chapter 15</a>, <em>Testing Your Code with Unit Test Cases and TDD</em>, which is available at <a href="https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch20">https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch20</a><a href="https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch20">.</a></p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the purpose of functional tests</h1>
                
            
            
                
<p>Functional/acceptance tests use techniques similar to unit and integration tests but differ from them in that they are run only at the end of each sprint. They have the fundamental role of verifying that the current version of the whole software complies with its specifications. This verification is turned into a formal process for the following purposes:</p>
<ul>
<li>Functional tests represent the most important part of the contract between stakeholders and the development team, the other part being the verification of non-functional specifications. The way this contract is formalized depends on the very nature of the relationship between the development team and stakeholders. In the case of a supplier-customer relationship, they become part of the supplier-customer business contract for each sprint, and they are written by a team that works for the customer. If the tests fail, then the sprint is rejected and the supplier must run a supplementary sprint to fix all problems. In case there is no formal business contract, the result of the tests is usually used to drive the specifications for the next sprints. However, also in this case, if the failure percentage is high, the sprint may be rejected and should be repeated.</li>
<li>Formalized functional tests that run at the end of each sprint avoid that results achieved in previous sprints might be destroyed by new code.</li>
<li>When using an agile development methodology, maintaining an updated battery of functional tests is the best way to get a formal representation of the final system specifications since, during agile development, the specifications of the final system are not decided before development starts but are the result of the system evolution.</li>
</ul>
<p>Since the output of the first sprints may differ a lot from the final system in these early stages, it is not worth spending too much time writing detailed manual tests and/or automatized tests. Therefore, you may limit to add a few examples to the user stories that will be used both as inputs for software development and as manual tests.</p>
<p>As system functionalities become always more stable, it is worth investing time in writing detailed and formal functional tests for them. For each functional specification, we must write tests that verify their correct operation also in extreme cases. For instance, in a payment use case, we must write tests that verify all possibilities:</p>
<ul>
<li>Not enough funds</li>
<li>Various digitization errors</li>
<li>Card expired</li>
<li>Wrong credentials and repeated wrong credentials</li>
</ul>
<p>In the case of manual tests, for each of the preceding scenarios, we must give all details of all steps involved in each operation, and for each step, the expected result.</p>
<p>An important decision is if you want to automate all or a part of the acceptance/functional tests since it is very expansive to write automatic tests that simulate a human operator that interacts with a system's user interface. The final decision depends on the cost of the test implementation divided by the expected number of times it will be used.</p>
<p>In the case of CI/CD, the same functional test can be executed several times but, unluckily, functional/acceptance tests are strictly tied to the way the user interface is implemented, and, in modern systems, the user interface is frequently changed. Therefore, in this case, the same test is executed with exactly the same user interface not more than a couple of times.</p>
<p>In order to overcome all the problems related to the user interface, functional tests can be implemented as <strong>subcutaneous tests</strong>, that is, as tests that bypass the user interface. However, subcutaneous tests are incomplete by their very nature since they can't detect errors in the user interface itself. Moreover, in the case of a web application, subcutaneous tests usually suffer from other limitations because they bypass the whole HTTP protocol. In the case of ASP.NET Core applications, this means that the whole ASP.NET Core pipeline must be bypassed and that requests are passed directly to ASP.NET controllers. Therefore, authentication, authorization, CORS, and the behavior of other modules in the ASP.NET Core pipeline will not be analyzed by the tests.</p>
<p>A complete automatic functional test of a web application should do the following things:</p>
<ol>
<li>Start an actual browser on the URL to be tested.</li>
<li>Wait so that any JavaScript on the page completes its execution.</li>
<li>Then, send commands to the browser that simulate the behavior of a human operator.</li>
<li>Finally, after each interaction with the browser, automatic tests should wait so that any JavaScript that was triggered by the interaction completes.</li>
</ol>
<p>While browser automatization tools exist, tests implemented with browser automatization, as mentioned earlier, are very expensive and difficult to implement. Therefore, the suggested approach of ASP.NET Core MVC is to send actual HTTP requests to an actual copy of the web application, with a .NET HTTP client instead of using a browser. Once the HTTP client receives an HTTP response, it parses it in a DOM tree and verifies that it received the right response.</p>
<p class="mce-root"/>
<p>The only difference with the browser automatization tools is that the HTTP client is not able to run any JavaScript. However, other tests may be added to test the JavaScript code. These tests are based on test tools that are specific to JavaScript, such as <strong>Jasmine</strong> and <strong>Karma</strong>.</p>
<p>The next section explains how to automatize functional tests for web applications with a .NET HTTP client, while a practical example of functional test automation is shown in the last section. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using unit testing tools to automate functional tests in C#</h1>
                
            
            
                
<p>Automated functional/acceptance tests use the same test tools as unit and integration tests. That is, these tests can be embedded in the same xUnit, NUnit, or MSTests projects that we described in <a href="c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml">Chapter 15</a>, <em>Testing Your Code with Unit Test Cases and TDD</em>. However, in this case, we must add further tools that are able to interact with and inspect the user interface. </p>
<p>In the remainder of this chapter, we will focus on web applications since they are the main focus of this book. Accordingly, if we are testing web APIs, we just need <kbd>HTTPClient</kbd> instances since they can easily interact with web API endpoints both in XML and JSON. </p>
<p>In the case of ASP.NET Core MVC applications that return HTML pages, the interaction is more complex, since we also need tools for parsing and interacting with the HTML page DOM tree. The <kbd>AngleSharp</kbd> NuGet package is a great solution since it supports state-of-the-art HTML and minimal CSS and has extension points for externally provided JavaScript engines, such as Node.js. However, we don't advise you to include JavaScript and CSS in your tests, since they are strictly tied to target browsers, so the best option for them is to use JavaScript-specific test tools that you can run directly in the target browsers themselves. </p>
<p>There are two basic options for testing a web application with the <kbd>HTTPClient</kbd> class:</p>
<ul>
<li>An <kbd>HTTPClient</kbd> instance connects with the actual <em>staging</em> web application through the internet/intranet, together with all other humans that are beta-testing the software. The advantage of this approach is that you are testing the <em>real stuff</em>, but tests are more difficult to conceive since you can't control the initial state of the application before each test.</li>
<li>An <kbd>HTTPClient</kbd> instance connects with a local application that is configured, initialized, and launched before every single test. This scenario is completely analogous to the unit test scenario. Test results are reproducible the initial state before each test is fixed, tests are easier to design, and the actual database can be replaced by a faster and easier-to-initialize in-memory database. However, in this case, you are far from the actual system's operation.</li>
</ul>
<p>A good strategy is to use the second approach, where you have full control of the initial state, for testing all extreme cases, and then the first approach for testing random average cases on the <em>real stuff</em>.</p>
<p>The two sections that follow describe both approaches. The two approaches differ just in the way you define the fixtures of your tests. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing the staging application</h1>
                
            
            
                
<p>In this case, your tests need just an instance of <kbd>HTTPClient</kbd>, so you must define an efficient fixture that supplies <kbd>HTTPClient</kbd> instances, avoiding the risk of running out of windows connections. We faced this problem in the <em>.NET Core HTTP clients</em> section of <a href="3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml">Chapter 12</a>, <em>Applying Service-Oriented Architectures with .NET Core</em>. It can be solved by managing <kbd>HTTPClient</kbd> instances with <kbd>IHTTPClientFactory</kbd> and injecting them with dependency injection.</p>
<p>Once we have a dependency injection container, we can enrich it with the capability of efficiently handling <kbd>HTTPClient</kbd> instances with the following code snippet:</p>
<pre>services.AddHTTPClient();</pre>
<p>Here, the <kbd>AddHTTPClient</kbd> extension belongs to the <kbd>Microsoft.Extensions.DependencyInjection</kbd> namespace and is defined in the <kbd>Microsoft.Extensions.HTTP</kbd> NuGet package. Therefore, our test fixture must create a dependency injection container, must call <kbd>AddHTTPClient</kbd>, and finally, must build the container. The following fixture class does this job (please refer to the <em>Advanced test preparation/test tear down scenarios</em> section of <a href="c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml">Chapter 15</a>, <em>Testing Your Code with Unit Test Cases and TDD</em>, if you don't remember fixture classes):</p>
<pre>public class HTTPClientFixture<br/>{<br/>    public HTTPClientFixture()<br/>    {<br/>        var serviceCollection = new ServiceCollection();<br/>        serviceCollection<br/>            .AddHTTPClient();<br/>         ServiceProvider = serviceCollection.BuildServiceProvider();<br/>    }<br/><br/>    public ServiceProvider ServiceProvider { get; private set; }<br/>}</pre>
<p>After the preceding definition, your tests should look as follows:</p>
<pre>public class UnitTest1:IClassFixture&lt;HTTPClientFixture&gt;<br/>{<br/>    private ServiceProvider _serviceProvider;<br/><br/>    public UnitTest1(HTTPClientFixture fixture)<br/>    {<br/>        _serviceProvider = fixture.ServiceProvider;<br/>    }<br/><br/>    [Fact]<br/>    public void Test1()<br/>    {<br/>        using (var factory = <br/>            _serviceProvider.GetService&lt;IHTTPClientFactory&gt;())<br/>        {<br/>            HTTPClient client = factory.CreateClient();<br/>            //use client to interact with application here<br/>        }<br/>    }<br/>}</pre>
<p>In <kbd>Test1</kbd>, once you get an HTTP client, you can test the application by issuing an HTTP request and then by analyzing the response returned by the application. More details on how to process the response returned by the server will be given in the <em>Use case</em> section.</p>
<p>The next section explains how to test an application that runs in a controlled environment.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing a controlled application</h1>
                
            
            
                
<p>In this case, we create an ASP.NET Core server within the test application and test it with an <kbd>HTTPClient</kbd> instance. The <kbd>Microsoft.AspNetCore.Mvc.Testing</kbd> NuGet package contains all that we need to create both an HTTP client and the server running the application. We also need to reference the whole web framework by referencing the <kbd>Microsoft.AspNetCore.App</kbd> NuGet package. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Finally, we must also transform the test project into a web project with the following steps:</p>
<ol>
<li>Click on the test project icon in Visual Studio solution explorer, and select the edit project item from the context menu.</li>
<li>Replace the root XML node, which should be <kbd>&lt;Project Sdk="Microsoft.NET.Sdk"&gt;</kbd>, with <kbd>&lt;Project Sdk="Microsoft.NET.Sdk.web"&gt;</kbd>.</li>
</ol>
<p><kbd>Microsoft.AspNetCore.Mvc.Testing</kbd> contains a fixture class that does the job of launching a local web server and furnishing a client for interacting with it. The predefined fixture class is <kbd>WebApplicationFactory&lt;T&gt;</kbd>. The generic <kbd>T</kbd> argument must be instantiated with the <kbd>Startup</kbd> class of your web project.</p>
<p>Tests look like the following class:</p>
<pre>public class UnitTest1 <br/>    : IClassFixture&lt;WebApplicationFactory&lt;MyProject.Startup&gt;&gt;<br/>{<br/>    private readonly <br/>        WebApplicationFactory&lt;RazorPagesProject.Startup&gt; _factory;<br/><br/>    public UnitTest1 (WebApplicationFactory&lt;MyProject.Startup&gt; factory)<br/>    {<br/>        _factory = factory;<br/>    }<br/><br/>    [Theory]<br/>    [InlineData("/")]<br/>    [InlineData("/Index")]<br/>    [InlineData("/About")]<br/>    ....<br/>    <br/>    public async Task MustReturnOK(string url)<br/>    {<br/>        var client = _factory.CreateClient();<br/>        // here both client and server are ready<br/>        <br/>        var response = await client.GetAsync(url);<br/>        //get the response<br/>  <br/>        response.EnsureSuccessStatusCode(); <br/>        // verify we got a success return code.<br/>        <br/>    }<br/>    ...<br/>    ---<br/>}</pre>
<p>If you want to analyze the HTML of the returned pages, you must also reference the <kbd>AngleSharp</kbd> NuGet package. We will see how to use it in the example of the next section. The simplest way to cope with databases in this type of tests is to replace them with in-memory databases that are faster and automatically cleared whenever the local server is shut down and restarted.</p>
<p>This can be done by creating a new deployment environment, say <kbd>AutomaticStaging</kbd>, and an associate configuration file that is specific for the tests. After having created this new deployment environment, go to the <kbd>ConfigureServices</kbd> method of your application's <kbd>Startup</kbd> class and locate the place where you add your <kbd>DBContext</kbd> configuration. Once located that place, add an <kbd>if</kbd> there, that, in case the application is running in the <kbd>AutomaticStaging</kbd> environment, replaces your <kbd>DBContext</kbd> configuration with something like this:</p>
<pre>services.AddDbContext&lt;MyDBContext&gt;(options =&gt;  options.UseInMemoryDatabase(databaseName: "MyDatabase"));</pre>
<p>As an alternative, you can also add all needed instructions to clear a standard database in the constructor of a custom fixture that inherits from <kbd>WebApplicationFactory&lt;T&gt;</kbd>. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Use case – automating functional tests</h1>
                
            
            
                
<p>In this section, we will add a simple acceptance test to the ASP.NET Core test project of <a href="c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml">Chapter 15</a>, <em>Testing Your Code with Unit Test Cases and TDD</em>. Our test approach is based on the <kbd>Microsoft.AspNetCore.Mvc.Testing</kbd> and <kbd>AngleSharp</kbd> NuGet packages. Please make a new copy of the whole solution.</p>
<p>As a first step, we must turn the test project into a web project by replacing the <kbd>sdk</kbd> attribute of the root node of its project file in <kbd>Sdk="Microsoft.NET.Sdk.web"</kbd>. </p>
<p>The test project already references the ASP.NET Core project under <kbd>test</kbd> and all the required xUnit NuGet packages, so we need to add just the <kbd>Microsoft.AspNetCore.Mvc.Testing</kbd> and <kbd>AngleSharp</kbd> NuGet packages.</p>
<p>Now, let's add a new class file called <kbd>UIExampleTestcs.cs</kbd>. We need <kbd>using</kbd> statements to reference all the necessary namespaces. More specifically, we need the following: </p>
<ul>
<li><kbd>using PackagesManagement;</kbd>: This is needed for referencing your application classes. </li>
<li><kbd>using Microsoft.AspNetCore.Mvc.Testing;</kbd>: This is needed for referencing the client and server classes. </li>
<li><kbd>using AngleSharp;</kbd> and <kbd>using AngleSharp.Html.Parser;</kbd>: These are needed for referencing <kbd>AngleSharp</kbd> classes.</li>
<li><kbd>System.IO</kbd>: This is needed in order to extract HTML from HTTP responses.</li>
<li><kbd>using Xunit</kbd>: This is needed for referencing all <kbd>xUnit</kbd> classes. </li>
</ul>
<p>Summing up, the whole <kbd>using</kbd> block is as follows:</p>
<pre>using PackagesManagement;<br/>using System;<br/>using System.Collections.Generic;<br/>using System.Linq;<br/>using System.Threading.Tasks;<br/>using Xunit;<br/>using Microsoft.AspNetCore.Mvc.Testing;<br/>using AngleSharp;<br/>using AngleSharp.Html.Parser;<br/>using System.IO;</pre>
<p>We will use the standard fixture class we introduced in the previous <em>Testing a controlled application</em> section, that is, the following:</p>
<pre>public class UIExampleTestcs:<br/>         IClassFixture&lt;WebApplicationFactory&lt;Startup&gt;&gt;<br/>{<br/>    private readonly<br/>       WebApplicationFactory&lt;Startup&gt; _factory;<br/>    public UIExampleTestcs(WebApplicationFactory&lt;Startup&gt; factory)<br/>    {<br/>       _factory = factory;<br/>    }<br/>}</pre>
<p>Now, we are ready to write a test for the home page! This test verifies that the home URL returns a successful HTTP result and that the home page contains a link to the package management page, which is the <kbd>/ManagePackages</kbd> relative link. </p>
<p>It is fundamental to understand that automatic tests must not depend on the details of the HTML, but that they must verify just logical facts, in order to avoid frequent changes after each small modification of the application HTML. That's why we just verify that the needed links exist without putting constraints on where they are.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Let's call <kbd>TestMenu</kbd> our home page test:</p>
<pre>[Fact]<br/>public async Task TestMenu()<br/>{<br/>    var client = _factory.CreateClient();<br/>    ...<br/>    ...         <br/>}<br/><br/></pre>
<p>The first step of each test is the creation of a client. Then, if the test needs the analysis of some HTML, we must prepare the so-called <kbd>AngleSharp</kbd> browsing context:</p>
<pre>//Create an angleSharp default configuration<br/>var config = Configuration.Default;<br/><br/>//Create a new context for evaluating webpages <br/>//with the given config<br/>var context = BrowsingContext.New(config);</pre>
<p>The configuration object specifies options such as cookie handling and other browser-related properties. At this point, we are ready to require the home page:</p>
<pre>var response = await client.GetAsync("/");</pre>
<p>As a first step, we verify that the response we received contains a success status code, as follows:</p>
<pre>response.EnsureSuccessStatusCode(); </pre>
<p>The preceding method call throws an exception in case of unsuccessful status code, hence causing the test to fail. HTML analysis needs to be extracted from the response. The following code shows a simple way to do it:</p>
<pre>var stream = await response.Content.ReadAsStreamAsync();<br/>string source;<br/>using (StreamReader responseReader = new StreamReader(stream))<br/>{<br/>    source = await responseReader.ReadToEndAsync();<br/>} </pre>
<p><kbd>ReadAsStreamAsync</kbd> returns <kbd>Stream</kbd>, which we can use to build <kbd>StreamReader</kbd> (a stream specialized for reading text), which can read the whole response body.</p>
<p>Now, we must pass the extracted HTML to our previous <kbd>AngleSharp</kbd> browsing context object, so it can build a DOM tree. The following code shows how to do it:</p>
<pre>var document = await context.OpenAsync(req =&gt; req.Content(source));</pre>
<p>The <kbd>OpenAsync</kbd> method executes a DOM-building activity with the settings contained in <kbd>context</kbd>. The input for building the DOM document is specified by the lambda function passed as an argument to <kbd>OpenAsync</kbd>. In our case, <kbd>req.Content(...)</kbd> builds a DOM tree from the HTML string passed to the <kbd>Content</kbd> method, which is the HTML contained in the response received by the client.</p>
<p>Once a <kbd>document</kbd> object is obtained, we can use it as we would use it in JavaScript. In particular, we can use <kbd>QuerySelector</kbd> to find an anchor with the required link:</p>
<pre>var node = document.QuerySelector("a[href=\"/ManagePackages\"]");</pre>
<p>It remains to verify just that <kbd>node</kbd> is not null:</p>
<pre>Assert.NotNull(node);</pre>
<p>We have done it! If you want to analyze pages that require a user to be logged in or other more complex scenarios, you need to enable cookies and automatic URL redirects in the HTTP client. This way, the client will behave like a usual browser that stores and sends cookies and that moves to another URL whenever it receives a <kbd>Redirect</kbd> HTTP response. This can be done by passing an options object to the <kbd>CreateClient</kbd> method, as follows:</p>
<pre>var client = _factory.CreateClient(<br/>    new WebApplicationFactoryClientOptions<br/>    {<br/>        AllowAutoRedirect=true,<br/>        HandleCookies=true<br/>    });</pre>
<p>With the preceding setup, your tests can do everything a usual browser can do. For instance, you can design tests where the HTTP client logs in and accesses pages that require authentication since <kbd>HandleCookies=true</kbd> lets the authentication cookie be stored by the client and be sent in all subsequent requests.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter explains the importance of acceptance/functional tests, and how to define detailed manual tests to be run on the output of each sprint. At this point, you should be able to define automatic and/or manual tests to verify that, at the end of each sprint, your application complies with its specifications.</p>
<p>Then, this chapter analyzed when it is worth automating some or all acceptance/functional tests and describes how to automate them in ASP.NET Core applications. </p>
<p>A final example showed how to write, in practice, ASP.NET Core acceptance/functional tests with the help of <kbd>AngleSharp</kbd> to inspect the responses returned by the application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>Is it always worth automating user interface acceptance tests in the case of quick CI/CD cycles?</li>
<li>What is the disadvantage of the subcutaneous test for ASP.NET Core applications?</li>
<li>What is the suggested technique for writing ASP.NET Core acceptance tests?</li>
<li>What is the suggested way of inspecting the HTML returned by the server?</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p>More details on the <kbd>Microsoft.AspNetCore.Mvc.Testing</kbd> NuGet package and <kbd>AngleSharp</kbd> can be found in their respective official documentation at <a href="https://docs.microsoft.com/en-US/aspnet/core/test/integration-tests?view=aspnetcore-3.0">https://docs.microsoft.com/en-US/aspnet/core/test/integration-tests?view=aspnetcore-3.0</a> and <a href="https://anglesharp.github.io/">https://anglesharp.github.io/</a>.</p>
<p>Readers interested in JavaScript tests can refer to the Jasmine documentation: <a href="https://jasmine.github.io/">https://jasmine.github.io/</a>.</p>


            

            
        
    </body></html>