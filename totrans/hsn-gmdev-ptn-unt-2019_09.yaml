- en: Singleton
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Singleton
- en: The Singleton is the most infamous pattern in the industry, but ironically,
    it's very popular with Unity developers. In consequence, it has become somewhat
    the duct tape of programmers, overused as a quick fix instead of a cornerstone
    of a robust architecture. There are many ways to implement a Singleton, from the
    simple but unsafe to the complicated but robust; we will go with the latter, because
    if we need to implement an unpopular pattern, let's do it in a way that won't
    backfire on us.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Singleton 是行业中最臭名昭著的模式，但讽刺的是，它在 Unity 开发者中非常受欢迎。因此，它已经变成了程序员的胶带，被过度用作快速修复而不是稳健架构的基石。实现
    Singleton 有许多方法，从简单但不安全到复杂但稳健；我们将选择后者，因为如果我们需要实现不受欢迎的模式，让我们以一种不会对我们产生反作用的方式去做。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The basics of the Singleton's pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Singleton 模式的基础
- en: Implementing the perfect Singleton in Unity
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Unity 中实现完美的 Singleton
- en: Programmers love to argue, sometimes to the point of paralysis, so it's important
    never to become religious about design patterns. Always remember that there's
    no perfect solution; every design decision you make will have trade-offs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员喜欢争论，有时甚至到了瘫痪的地步，因此永远不要对设计模式过于虔诚。始终记住，没有完美的解决方案；你做出的每一个设计决策都会有权衡。
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This is a hands-on chapter; you will need to have a basic understanding of Unity
    and C#.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个实践性章节；你需要对 Unity 和 C# 有基本的了解。
- en: 'We will be using the following specific Unity engine and C# language concept:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下特定的 Unity 引擎和 C# 语言概念：
- en: Generics
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型
- en: If unfamiliar with this concept, please review them before starting this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不熟悉这个概念，请在开始本章之前查看它们。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际应用：
- en: '[http://bit.ly/2YwBVEv](http://bit.ly/2YwBVEv)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2YwBVEv](http://bit.ly/2YwBVEv)'
- en: An overview of the Singleton pattern
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Singleton 模式的概述
- en: As its name implies, the Singleton pattern's main goal is to guarantee a singularity.
    This approach means if a class implements this pattern correctly, once initialized,
    it will have only one instance of itself in memory during runtime. This mechanism
    can be useful when you have a class that manages a system that needs to be globally
    accessible from a singular entry point.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，Singleton 模式的主要目标是保证唯一性。这种方法意味着如果一个类正确实现了这个模式，一旦初始化，它将在运行时内存中只有一个自身的实例。这种机制在需要从单一入口点全局访问系统时非常有用。
- en: 'As we can see from the following diagram, the Singleton''s design is quite
    simple; unlike the Prototype pattern, a class implemented as a Singleton doesn''t
    make a copy of itself but only returns its current instance to a client that''s
    requesting it:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图中所示，Singleton 的设计相当简单；与原型模式不同，作为 Singleton 实现的类不会复制自身，而是仅将其当前实例返回给请求它的客户端：
- en: '![](img/a1c31bad-1e47-410b-9f00-f2c1c141a7d1.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a1c31bad-1e47-410b-9f00-f2c1c141a7d1.png)'
- en: And if correctly implemented, a Singleton instance will even destroy any other
    instances of itself, just in case someone is trying to duplicate it. In other
    words, there can only be one. But we will see further in this chapter, implementing
    a solid Singleton in Unity is not as easy as it looks.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正确实现，Singleton 实例甚至可以销毁任何其他自身的实例，以防有人试图复制它。换句话说，只能有一个。但我们将在本章中进一步看到，在 Unity
    中实现一个稳固的 Singleton 并不像看起来那么简单。
- en: Benefits and drawbacks
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点和缺点
- en: The Singleton is a very controversial pattern; it's disliked by many because
    Unity developers frequently misuse it. If this contempt for this pattern is justified,
    I would say yes, but only to a certain degree. Instead of listing all the potential
    benefits and drawbacks of this pattern, I will present only one advantage and
    disadvantage; both are what I find to be the best arguments for or against the
    use of this pattern.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Singleton 是一个非常具有争议的模式；许多人不喜欢它，因为 Unity 开发者经常误用它。如果对这种模式的蔑视是合理的，我会说是的，但只到一定程度。而不是列出这个模式的所有潜在优点和缺点，我将只提出一个优点和缺点；两者都是我认为支持或反对使用这个模式的最有力的论据。
- en: 'This is the benefit:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是优点：
- en: '**A singular point of entry**: The Singleton offers a singular but global access
    point to an instance of itself. This mechanism makes it easier to access dependencies
    that are exposed by a Singleton instance.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**唯一的入口点**：Singleton提供了一个唯一的但全局的访问点，用于访问其自身的实例。这种机制使得访问由Singleton实例暴露的依赖项变得更加容易。'
- en: 'This is the drawback:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是缺点：
- en: '**Obfuscation of dependencies**: Singletons are often used as *duct tape* to
    simplify access to complex interlocked dependencies. It''s an easy solution that
    prevents the weeding out of wrong architecture choices.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖项的混淆**：Singleton通常被用作“胶带”来简化对复杂互锁依赖项的访问。这是一个简单的解决方案，可以防止错误的架构选择被清除。'
- en: So, taking into account these two arguments, there's a simple question we must
    ask when deciding to use a Singleton; is it because it's needed and fits with
    our overall architecture, or are we using it because it's a quick solution to
    a complex problem? From our answer, we can determine whether we are smart or just
    lazy with our design choices.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，考虑到这两个论点，当我们决定使用Singleton时，我们必须问一个简单的问题；这是因为它需要并且与我们的整体架构相匹配，还是我们使用它是因为它是一个解决复杂问题的快速解决方案？从我们的答案中，我们可以确定我们在设计选择上是聪明还是懒惰。
- en: When you are making design choices, it's important to always keep in mind whether
    your architecture is maintainable, scalable, and testable. If you can't individually
    test your modules, it's a good indication that your design has made your code
    base coupled and dependent on global dependencies.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在做设计选择时，始终牢记你的架构是否可维护、可扩展和可测试非常重要。如果你不能单独测试你的模块，那么这可能是一个很好的迹象，表明你的设计已经使你的代码库耦合并依赖于全局依赖项。
- en: Use case example
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例示例
- en: 'We must take into consideration that most games are made up of a collection
    of levels but each level includes a sequence of events during its lifespan, such
    as the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须考虑，大多数游戏都是由一系列关卡组成的，但每个关卡在其生命周期内都包含一系列事件，如下所示：
- en: Loading of previous save
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载上一个保存
- en: Triggering of introductory sequence
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发引导序列
- en: Spawning of environment and characters
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境和角色的生成
- en: Managing runtime game states
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理运行时游戏状态
- en: Triggering the end scene sequence
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发结束场景序列
- en: Save current player stats
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存当前玩家状态
- en: Trigger next level
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发下一级
- en: To be able to manage this, we will need a Game Manager that will be active throughout
    the entire life span of a scene. As an analogy, if we look at the classic pen-and-paper
    version of Dungeons and Dragons, there's usually a Game Master that moderates
    and overlooks the flow of the game so the players can have a consistent but structured
    experience.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够管理这一点，我们需要一个在整个场景生命周期中保持活跃的游戏管理器。作为一个类比，如果我们看看经典的纸笔版《龙与地下城》，通常有一个游戏大师来调节和监督游戏的流程，以便玩家能够有一个一致但结构化的体验。
- en: So, for our use case, we will need something similar but, of course, not as
    sophisticated as a human Game Master. The Singleton is a perfect pattern to implement
    a GM because it offers us a way to write a class as a singular but global entity
    that will accessible throughout the runtime of our game.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于我们的用例，我们需要类似的东西，但当然，不如人类游戏大师那样复杂。Singleton是一个完美的模式来实现GM，因为它为我们提供了一种将类编写为单一但全局实体的方式，该实体将在我们游戏的整个运行时中可访问。
- en: Code example
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: In this section, we will explore two versions of an implementation of the Singleton
    pattern in Unity. The first example is unsafe but straightforward. The second
    is advanced but more robust, as indicated at the beginning of this chapter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Unity中Singleton模式实现的两种版本。第一个例子是不安全的但直接的。第二个例子是高级的但更健壮的，如本章开头所述。
- en: Simple approach
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单方法
- en: 'Let''s start by reviewing a simple way of implementing the Singleton in Unity.
    We have to keep in mind that we don''t have access to a constructor when we use
    `MonoBehaviours`, so we will need to control the initialization of any member
    variables in the `Awake()` magic function, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先回顾一下在Unity中实现Singleton的简单方法。我们必须记住，当我们使用`MonoBehaviours`时，我们没有访问构造函数，因此我们需要在`Awake()`魔法函数中控制任何成员变量的初始化，如下所示：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As we can see, we have only one member, and it''s static and public, which
    will make it easier for our clients to refer to it. In our `Awake()`, we pass
    our current `this` instance to the public static instance variable. This approach
    means our clients will have one constant and persistent access point to our `GameManager`,
    as seen in the following code snippet:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们只有一个成员，它是静态且公开的，这将使我们的客户端更容易引用它。在我们的`Awake()`方法中，我们将当前的`this`实例传递给公开的静态实例变量。这种方法意味着我们的客户端将有一个恒定且持久的访问点来访问我们的`GameManager`，如下面的代码片段所示：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It looks pretty simple. We need to refer to the static instance member of the
    `GameManager` class, and we can call at any point its public functions. But there''s
    one huge problem: this is not a Singleton for the reason that there''s no mechanism
    in place that avoids having two instances of this object in memory.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来很简单。我们需要引用`GameManager`类的静态实例成员，并且我们可以在任何点调用其公共函数。但有一个巨大的问题：这不是一个单例，因为没有机制可以防止在内存中有两个该对象的实例。
- en: 'We just implemented an interface to an instance of a global manager, but we
    are not protecting it from duplication in memory or preserving its integrity.
    Let''s see whether we can do better with the next example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是实现了一个全局管理器实例的接口，但我们没有保护它免受内存中重复或保持其完整性的影响。让我们看看在下一个示例中我们是否能做得更好：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, this is getting better. We are at least checking for `null` references
    before assigning the `_instance` static member, and avoiding potential duplicated
    instances of our `GameManager` by destroying them at the moment they *awake*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这已经变得更好了。我们至少在分配`_instance`静态成员之前检查`null`引用，并通过在它们`awake`时销毁它们来避免`GameManager`的潜在重复实例。
- en: This approach seems valid, but there's nothing that will guarantee consistency
    if you decide to have multiple classes implemented as Singletons. You might have
    one programmer writing a Singleton one way and another writing entirely differently.
    In the long run, this nullifies one of the fundamental benefits of design patterns;
    consistency in the architecture.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法看起来是有效的，但如果决定有多个类实现为单例，则没有任何机制可以保证一致性。你可能会有一位程序员以一种方式编写单例，而另一位则以完全不同的方式编写。从长远来看，这抵消了设计模式的基本好处之一；架构的一致性。
- en: In the next section, we will look at a potential candidate for an advanced Singleton
    implementation that can become a pillar for our code base and offer us complete
    re-usability.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一个高级单例实现的潜在候选者，它可以成为我们代码库的支柱，并为我们提供完全的可重用性。
- en: Advanced approach
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级方法
- en: 'The following class is an example of a complete Singleton implementation, but
    there''s a lot to unpack here, so we are going to try to focus on the following
    essential elements:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类是一个完整的单例实现的示例，但这里有很多东西需要解释，因此我们将尝试关注以下基本元素：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we are introducing **Generics**, a compelling C# feature that
    permits us to defer the type of a class at runtime. When we say a class is generic,
    it means that it doesn't have a defined object type. This approach is advantageous
    because we can assign it a specific type when we initialize it. In other words,
    it can become anything we want, and this could solve a core issue we are having
    with Singletons, which is the consistency of implementation between our classes
    that are Singletons.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们介绍了**泛型**，这是一个令人信服的C#特性，允许我们在运行时延迟类的类型。当我们说一个类是泛型时，这意味着它没有定义的对象类型。这种方法的优势在于，当我们初始化它时，我们可以将其分配为特定的类型。换句话说，它可以成为我们想要的任何东西，这可以解决我们与单例相关的核心问题，即我们的单例类之间实现的一致性。
- en: 'Let''s apply our generic Singleton class to a couple of Managers and see how
    we maintain uniformity in the way we write Singleton classes, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的通用单例类应用到几个管理器上，看看我们如何保持编写单例类的方式的一致性，如下所示：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we can see, by inheriting the Singleton parent class, we have made our `GameManager`
    into a Singleton with one line of code (`Singleton<GameManager>`). This mechanism
    is possible because our parent class has all the core components of a Singleton.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，通过继承单例父类，我们只需一行代码（`Singleton<GameManager>`）就将`GameManager`变成了单例。这种机制之所以可行，是因为我们的父类拥有单例的核心组件。
- en: 'Next up is another example of a `Manager` class converted into a Singleton
    with one simple line of code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个将`Manager`类转换为单例模式的示例，只需一行代码即可实现：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can test our new Singletons with the following `Client` class:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下`Client`类来测试我们新的单例：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that we have found a structured and reusable approach to the implementation
    of the Singleton pattern, we can safely integrate it into our code base while
    keeping in mind not to overuse it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经找到了实现单例模式的结构化和可重用方法，我们可以在不过度使用的情况下安全地将它集成到我们的代码库中。
- en: Summary
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we tackled one of the most controversial design patterns out
    there. But we found a way to implement with a consistent and reusable approach.
    Even if the debate around the Singleton's usefulness persists, we can see how
    it can be beneficial for Unity developers.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们解决了最具有争议性的设计模式之一。但我们找到了一种以一致和可重用的方法来实现它的方法。即使关于单例有用性的争论持续存在，我们也可以看到它对Unity开发者是有益的。
- en: 'We have completed the creational pattern section of the book, and now we have
    three core patterns in our toolkit, each with a specific function:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了创建型模式章节，现在我们的工具箱中有三个核心模式，每个模式都有其特定的功能：
- en: The Prototype pattern offers us a way to create objects by copying them from
    a reference
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型模式为我们提供了一种通过复制引用来创建对象的方法
- en: The Abstract pattern enforces the localization of the creation process of objects
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象模式强制执行对象的创建过程的本地化
- en: The Singleton offers a way to implement a mechanism that guarantees one singular
    instance of an object in memory
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例提供了一种实现机制，确保在内存中只有一个对象的唯一实例
- en: In the next chapter, we will transition out from Creational to Behavioral patterns.
    The first on our list is the Strategy pattern, a classic pattern that focuses
    on the dynamic selection of algorithms at runtime.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从创建型模式过渡到行为型模式。我们列表中的第一个是策略模式，这是一个经典的模式，它关注于在运行时动态选择算法。
- en: Exercise
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: The main issue with the Singleton pattern is that its instance is globally accessible
    and persistent, so if any component that has dependencies related to a Singleton
    object, it cannot be tested as an isolated unit. But in the real world, code bases
    are never perfect, and programmers often use Singletons.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式的主要问题在于其实例是全局可访问且持久的，因此如果任何与单例对象相关的依赖组件，它就不能作为一个独立的单元进行测试。但在现实世界中，代码库从不完美，程序员经常使用单例。
- en: So, you need to find a way to maintain proper unit testing best practices even
    when dealing with an architecture that is heavily dependent on global Singleton
    instances. So, as an exercise, I would recommend reading up on **test-driven development**
    (**TDD**) practices, especially core concepts such as **Stubs** and **Mocks**.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使在与高度依赖全局单例实例的架构打交道时，你也必须找到一种方法来维护适当的单元测试最佳实践。所以，作为一个练习，我建议你阅读有关**测试驱动开发**（**TDD**）实践的内容，特别是像**存根**和**模拟**这样的核心概念。
- en: TDD is beyond the scope of this book, so please refer to the *Further reading*
    section for more information on the subject.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: TDD超出了本书的范围，所以请参考*进一步阅读*部分以获取更多关于该主题的信息。
- en: Further reading
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Test Driven Development: By Example* by Kent Beck[https://www.pearson.com/us/higher-education/program/Beck-Test-Driven-Development-By-Example/PGM206172.html](https://www.pearson.com/us/higher-education/program/Beck-Test-Driven-Development-By-Example/PGM206172.html)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《通过示例的测试驱动开发》* by Kent Beck[https://www.pearson.com/us/higher-education/program/Beck-Test-Driven-Development-By-Example/PGM206172.html](https://www.pearson.com/us/higher-education/program/Beck-Test-Driven-Development-By-Example/PGM206172.html)'
- en: '*Real World: Test-Driven Development* by Mauricio Aniche[https://www.goodreads.com/book/show/24400837-real-world-test-driven-development](https://www.goodreads.com/book/show/24400837-real-world-test-driven-development)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《现实世界的测试驱动开发》* by Mauricio Aniche[https://www.goodreads.com/book/show/24400837-real-world-test-driven-development](https://www.goodreads.com/book/show/24400837-real-world-test-driven-development)'
