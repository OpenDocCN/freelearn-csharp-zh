- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error Handling, Monitoring, and Observability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 4*](B18971_04.xhtml#_idTextAnchor170), we introduced how to use
    logging in ASP.NET Core web API applications. Logging is a critical part of application
    development that helps developers understand what’s happening in their applications.
    However, logging is not enough – we need more tools to monitor and observe how
    our application is running. In this chapter, we will explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Health checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring and observability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After reading this chapter, you will be able to understand how to monitor ASP.NET
    Core web API applications. You will have gained knowledge of observability and
    **OpenTelemetry**, as well as how to use some tools, such as Prometheus and Grafana,
    to monitor applications.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code samples for this chapter can be found at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter16](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter16).
    You can use VS 2022 or VS Code to open the solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an exception occurs in an ASP.NET Core web API application, the application
    will throw an exception. If this exception is not handled, the application will
    crash and cause a 500 error. The response body will contain the stack trace of
    the exception. Displaying the stack trace to the client is acceptable during development.
    However, we should never expose the stack trace to the client in production. The
    stack trace contains sensitive information about the application that can be used
    by attackers to attack the application.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at an example. The `MyWebApiDemo` sample application has a controller
    named `UsersController`, which has an action to get a user by their user ID. This
    action looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It is not advisable to use `First` in this instance as it will result in an
    exception being thrown if the user is not found in the collection. To illustrate
    how to handle exceptions in the application, we will use this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application and send a `GET` request to the `https://localhost:5001/users/100`
    endpoint. You can test it in the Swagger UI directly. The application will return
    a 500 error because no user with an ID of 100 will be found. The response body
    will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.1 – The response body contains the stack trace](img/B18971_16_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.1 – The response body contains the stack trace
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of whether the application is running in the development environment,
    the response body contains the stack trace. We should never show the stack trace
    for the production environment. Additionally, the response body is not a valid
    JSON payload, making it difficult for the client to parse it.
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET Core provides a built-in exception handling middleware to handle exceptions
    and return an error payload. The exception handling middleware can return a valid
    JSON payload to the client. This kind of JSON payload for error and exceptions
    is called **Problem Details** and is defined in RFC7807: [https://datatracker.ietf.org/doc/html/rfc7807](https://datatracker.ietf.org/doc/html/rfc7807).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A problem details object can have the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type`: A URI reference that’s used to identify the problem type. This reference
    provides helpful documentation in a human-readable format, which can assist clients
    in understanding the error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: A summary that describes the problem’s type in a human-readable format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status`: An HTTP status code generated by the original server to indicate
    the status of the problem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`detail`: A human-readable description of the problem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`instance`: A URI reference that provides a specific occurrence of the problem,
    allowing for a more precise understanding of the issue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client can parse the problem details object and display a user-friendly
    error message. This object can be extended to include additional information about
    the error, though the existing properties should be sufficient for most cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the exception handling middleware, we need to create a controller to
    show the problem details. Create a new controller named `ErrorController` and
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code comes from Microsoft’s official documentation: [https://learn.microsoft.com/en-us/aspnet/core/web-api/handle-errors](https://learn.microsoft.com/en-us/aspnet/core/web-api/handle-errors).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several things to note in the `ErrorController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: The controller is marked with the `[ApiExplorerSettings(IgnoreApi = true)]`
    attribute. This attribute is used to hide this endpoint from the OpenAPI specification
    and Swagger UI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The controller has two actions. The first action is used to show a detailed
    error message in the development environment, so it provides the route `/error-development`
    that shows the stack trace of the exception. The second action is used to show
    a generic error message in the production environment, so it provides the `/error`
    route that has no additional information about the exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the actions, we use the `IExceptionHandlerFeature` interface to get the exception
    information. The `IExceptionHandlerFeature` interface is a feature containing
    the exception of the original request to be examined by an exception handler.
    We can log the exception information or return it to the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we need to register the exception handling middleware in the application.
    Open the `Program.cs` file and call the `UseExceptionHandler` method to add the
    exception handling middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For the development environment, we can use the /`error-development` endpoint
    to show the detailed error message. For the production environment, we can use
    the /`error` endpoint to show the generic error message. It is a good practice
    to hide the stack trace in the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application and send a `GET` request to the `https://localhost:5001/users/100`
    endpoint. The application will return a 500 error. The response body will look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.2 – The response body contains the problem details alongside the
    stack trace in the development environment](img/B18971_16_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.2 – The response body contains the problem details alongside the stack
    trace in the development environment
  prefs: []
  type: TYPE_NORMAL
- en: The response body now contains a problem details JSON payload. It also contains
    the stack trace of the exception for troubleshooting in the development environment.
    The client can parse the response body and display a user-friendly error message.
    Meanwhile, the response headers contain the `Content-Type` header with a value
    of `application`/`problem+json`. This indicates that the response body is a problem
    details JSON payload.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the application in the production environment, the response body
    will not contain the stack trace of the exception. The response body will look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.3 – The response body contains a general error message in the production
    environment](img/B18971_16_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.3 – The response body contains a general error message in the production
    environment
  prefs: []
  type: TYPE_NORMAL
- en: The default problem details object can be extended to include additional information
    about the error. We will discuss how to customize the problem details in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Model validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a client sends a request to the application, the application needs to validate
    the request. For example, when a user updates their profile, the `Email` property
    must be a valid email address. If the value of the `Email` property is invalid,
    the application should return an HTTP 400 response with a problem details object
    that contains the validation error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET Core offers a built-in model validation feature to validate the request
    model. This feature is enabled using validation attributes, which are defined
    in the `System.ComponentModel.DataAnnotations` namespace. The following table
    outlines some available validation attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Required` | Specifies that a data field is required |'
  prefs: []
  type: TYPE_TB
- en: '| `Range` | Specifies that a numeric field must be in a specified range |'
  prefs: []
  type: TYPE_TB
- en: '| `StringLength` | Specifies the minimum and maximum length of a `string` field
    |'
  prefs: []
  type: TYPE_TB
- en: '| `EmailAddress` | Specifies that a data field must be a valid email address
    |'
  prefs: []
  type: TYPE_TB
- en: '| `RegularExpression` | Specifies that a data field must match the specified
    regular expression |'
  prefs: []
  type: TYPE_TB
- en: '| `Url` | Specifies that a data field must be a valid URL |'
  prefs: []
  type: TYPE_TB
- en: Table 16.1 – Common model validation attributes
  prefs: []
  type: TYPE_NORMAL
- en: 'We can apply these validation attributes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application and send a `POST` request to the `/users` endpoint with
    an invalid request body, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The application will return an HTTP 400 response with a problem details object,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this way, the client can parse the response body and display a user-friendly
    error message so that the user can correct the input.
  prefs: []
  type: TYPE_NORMAL
- en: Using FluentValidation to validate models
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The previous section discussed the use of built-in validation attributes. However,
    these have certain limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: The validation attributes are tightly coupled with the model. The models are
    polluted with validation attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The validation attributes cannot validate complex validation rules. If one property
    has dependencies on other properties, or the validation needs external services,
    the validation attributes cannot handle this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To solve these problems, we can use `FluentValidation` to validate the models.
    `FluentValidation` is a popular open-source library for building strongly typed
    validation rules, allowing us to separate the validation logic from the models.
    It also supports complex validation rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `FluentValidation`, we need to install the `FluentValidation.AspNetCore`
    NuGet package. Run the following command in the terminal to install the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Previously, `FluentValidation` provided a separate package for ASP.NET Core
    named `FluentValidation.AspNetCore`. However, this package is deprecated. It is
    recommended to use the `FluentValidation` package directly and use manual validation
    instead of using the ASP.NET Core validation pipeline. This is because the ASP.NET
    Core validation pipeline does not support asynchronous validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to create a validator for the `User` model. Create a new class
    named `UserValidator` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use fluent syntax to specify validation rules for
    each property. We can also create a custom rule for dependent properties. In this
    example, we’re creating a custom rule to validate the `Country` and `PhoneNumber`
    properties. If the country is New Zealand, we can create a custom rule that requires
    the phone number to start with 64\. This is just one example of how to validate
    properties that depend on other properties; built-in validation attributes cannot
    handle this type of validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to register the validator in the application. Add the following
    code to the `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code looks straightforward. But what if we have many validators?
    We can register all validators in a specific assembly. To do this, we need to
    install the `FluentValidation.DependencyInjectionExtensions` NuGet package. Run
    the following command in the terminal to install the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can register all validators, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can validate the model in the controller. Update the `Post` action,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we utilize the `ValidateAsync()` method to validate the
    model. If the model is invalid, we return an HTTP `400` response containing a
    problem details object that contains the associated validation error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Send a `POST` request to the `/users` endpoint with the following payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The application will return a 400 error with the following problem details
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the custom validation rule is executed and the error message
    is returned to the client.
  prefs: []
  type: TYPE_NORMAL
- en: "`FluentValidation` has more features than just built-in validation attributes.\
    \ If you have complex validation rules, you can consider using `FluentValidation`.\
    \ For more details, please refer to the official documentation: [https://docs.fluentvalidation.net/en/latest/index.html](https://docs.fluentvalidation.net/en/latest/index\uFEFF\
    .html)."
  prefs: []
  type: TYPE_NORMAL
- en: Health checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To monitor the application, we need to know whether the application is running
    correctly or not. We can perform health checks to monitor the application. Normally,
    a health check is an endpoint that returns the health status of the application.
    This status can be *Healthy*, *Degraded*, or *Unhealthy*.
  prefs: []
  type: TYPE_NORMAL
- en: A health check is a critical part of the microservice architecture. In the microservice
    architecture, one API service may have multiple instances and also have dependencies
    on other services. A load balancer or orchestrator can be used to distribute the
    traffic to different instances. If one instance is unhealthy, the load balancer
    or orchestrator can stop sending traffic to the unhealthy instance. For example,
    Kubernetes – a popular container orchestrator – can use health checks to determine
    whether a container is healthy or not. If a container is not live, Kubernetes
    will restart the container.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t discuss the details of Kubernetes in this book. Instead, we will focus
    on how to implement health checks for Kubernetes in ASP.NET Core web API applications.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a basic health check
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ASP.NET Core provides a straightforward way to configure health checks. We
    can use the `AddHealthChecks` method to add health checks to the application.
    Open the `Program.cs` file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code adds a basic health check to the application. The health
    check’s endpoint is `/healthcheck`. Run the application and send a `GET` request
    to the `/healthcheck` endpoint. If successful, the application will return a `200`
    response with `Healthy` in plain text in the response body.
  prefs: []
  type: TYPE_NORMAL
- en: However, this health check is too simple. In the real world, a web API application
    may be more complex. It may have multiple dependencies, such as databases, message
    queues, and other services. We need to check the health status of these dependencies.
    If some core dependencies are unhealthy, the application should be unhealthy.
    Let’s see how to implement a more complex health check.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a complex health check
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A health check implementation class implements the `IHealthCheck` interface.
    The `IHealthCheck` interface is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create a custom health check implementation to ensure the proper functioning
    of our API. For instance, if the API depends on another service, we can create
    a health check implementation to verify the health status of the dependent service.
    If the dependent service is unhealthy, the API won’t be able to function correctly.
    Here is an example of a health check implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we create a health check implementation to check the
    health status of the [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts)
    endpoint. If the endpoint returns a 200 response, the health check returns healthy.
    Otherwise, the health check returns unhealthy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to register the health check implementation in the application.
    Open the `Program.cs` file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This code is similar to the previous health check. First, we use the `AddHealthChecks`
    method to register the strongly typed health check implementation. Then, we use
    the `MapHealthCheck` method to map the `/other-service-health-check` endpoint
    to the health check implementation. We also use the `HealthCheckOptions` object
    to specify the name of the health check, which is used to filter the health checks.
    If we do not specify the name of the health check, all health check implementations
    will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Run the application and send a `GET` request to the `/other-service-health-check`
    endpoint. If the dependent service, `https://jsonplaceholder.typicode.com/posts`,
    is healthy, the application will return a 200 response with `Healthy` in plain
    text in the response body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we need to check multiple dependent services. We can register multiple
    health check implementations with a specific tag, at which point we can use this
    tag to filter the health checks. The following code shows how to register multiple
    health check implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we register three health check implementations with
    the same tag – that is, `other-service`. Now, we can use the tag to filter the
    health checks. The following code shows how to filter the health checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Like the `Name` property, we can use the `Tags` property to filter the health
    checks. When we send a `GET` request to the `/other-services-health-check` endpoint,
    the application will return a `200 OK` response with `Healthy` in plain text in
    the response body if all dependent services are healthy. But if one of the dependent
    services is unhealthy, the health check will return a `503 Service Unavailable`
    response with `Unhealthy` in plain text in the response body.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If the `MapHealthChecks()` method does not use the `HealthCheckOptions` parameter,
    the health check endpoint will run all registered health checks by default.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a database health check
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we discussed how to implement a health check for a
    dependent service. As databases are a common component of web API applications,
    this section will focus on how to implement a database health check.
  prefs: []
  type: TYPE_NORMAL
- en: 'The approach to implementing a database health check is similar to what we
    covered in the previous section: we need to connect to the database and execute
    a simple query to check if the database is healthy. If you use EF Core to access
    the database, you can use the `Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore`
    package to implement a database health check. This package provides a health check
    implementation for EF Core, so we do not need to write the health check implementation
    ourselves. Run the following command in the terminal to install the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the sample project, we have an `InvoiceDbContext` class to access the database.
    The following code shows how to register the `InvoiceDbContext` class in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’ve done this, register the EF Core `DbContext` health check implementation,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, assign a tag to the health check implementation so that we can filter
    the health checks. Then, we can map the health check endpoint to the health check’s
    implementation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Run the application and send a `GET` request to the `/database-health-checks`
    endpoint. If the database is healthy, the application will return a `200 OK` response
    with `Healthy` in plain text in the response body. Additionally, you can register
    multiple health checks for different databases if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you are using other ORMs to access the database, you can create a custom
    health check implementation following the previous section. This can be done by
    executing a simple query, such as `SELECT 1`, to determine whether the database
    is functioning properly.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding readiness and liveness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous sections, we discussed how to implement health checks for ASP.NET
    Core web API applications. In the real world, we may need to deploy the applications
    to a container orchestrator, such as Kubernetes. Kubernetes is a popular container
    orchestrator that can manage containerized applications, monitor health statuses,
    and scale up or down based on workload. Kubernetes uses the term **probe**, which
    is similar to health checks, to monitor the health status of the applications.
    While this book does not cover the details of Kubernetes, it will discuss how
    to implement Kubernetes probes in ASP.NET Core web API applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes has three types of probes: *readiness*, *liveness*, and *startup*.
    Let’s take a closer look:'
  prefs: []
  type: TYPE_NORMAL
- en: '`liveness`: This probe indicates whether the application is running correctly.
    Kubernetes performs a `liveness` probe every few seconds. If the application does
    not respond to the `liveness` probe for a specified period, the container will
    be killed and Kubernetes will create a new one to replace it. The `liveness` probe
    can execute either an HTTP request, a command, or a TCP socket check. It also
    supports gRPC health checks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readiness`: This probe is used to determine whether the application is ready
    to receive traffic. Some applications need to perform some initialization tasks
    before they can receive traffic, such as connecting to the database, loading configuration,
    checking the dependent services, and so on. During this period, the application
    cannot receive traffic, but this does not mean that the application is unhealthy.
    Kubernetes should not kill the application and restart it. After the initialization
    is complete and all dependent services are healthy, the `readiness` probe will
    inform Kubernetes that the application is ready to receive traffic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startup`: This probe is similar to the `readiness` probe. However, the difference
    is that the `startup` probe is only executed once the application starts. It is
    used to determine whether the application has completed the initialization process.
    If this probe is configured, the `liveness` and `readiness` probes will not be
    executed until the `startup` probe is successful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the probes incorrectly may cause cascading failures. For example,
    service A depends on service B and service B depends on service C. If the `liveness`
    probes are misconfigured incorrectly to check the dependent services when service
    C is unhealthy, service A and service B will be restarted, which does not solve
    the problem. This is a cascading failure. In this case, service A and service
    B should not be restarted. Instead, only service C should be restarted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a `liveness` HTTP probe configuration for Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the configuration, we define the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`path`, `port`, and `httpHeaders`: These properties are used to configure the
    HTTP request. In the preceding example, we specify a custom HTTP header called
    `Custom-Header` with a value of `X-Health-Check`. The application can use this
    HTTP header to identify whether the request is a health check request. If the
    request does not have this HTTP header, the application can deny the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initialDelaySeconds`: This property is used to specify the number of seconds
    after the container has started before the first probe is executed. The default
    value is 0\. Do not use a high value for this property. You can use the `startup`
    probe to check the initialization of the application instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`periodSeconds`: This property is used to specify the number of seconds between
    each probe. The default value is 10\. The minimum value is 1\. You can adjust
    this value based on your scenarios. Make sure Kubernetes can discover the unhealthy
    container as soon as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeoutSeconds`: This property is used to specify the number of seconds after
    which the probe times out. The default value is 1 and the minimum value is also
    1\. Make sure the probe is fast.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`successThreshold`: This property is used to determine the number of consecutive
    successful responses required for a probe to be considered successful after having
    previously failed. The value must be 1 for liveness probes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`failureThreshold`: This property is used to specify the number of consecutive
    failures for the probe to be considered failed after having succeeded. Do not
    use a high value for this property; otherwise, Kubernetes needs to wait a long
    time to restart the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that the `liveness` probe should not depend on other services.
    In other words, do not check the health status of other services in the `liveness`
    probe. Instead, this probe should only check whether the application can respond
    to the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a `readiness` HTTP probe’s configuration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few different considerations for the `readiness` probe:'
  prefs: []
  type: TYPE_NORMAL
- en: '`successThreshold`: The default value is 1\. However, we can increase this
    value to make sure the application is ready to receive traffic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`failureThreshold`: After at least `failureThreshold` probes have failed, Kubernetes
    will stop sending traffic to the container. As the application may have temporary
    problems, we can allow a few failures before the application is considered unhealthy.
    However, do not use a high value for this property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the application takes a long time to initialize, we can use the `startup`
    probe to check the initialization of the application. An example of a `startup`
    HTTP probe configuration is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this configuration, the `startup` probe will be executed every 5 seconds,
    and the application will have a maximum of 150 seconds (5 * 30 = 150 seconds)
    to complete the initialization. `successThreshold` must be 1 so that once the
    `startup` probe is successful, the `liveness` and `readiness` probes will be executed.
    If the `startup` probe fails after 150 seconds (about 2 and a half minutes), Kubernetes
    will kill the container and start a new one. So, ensure that the `startup` probe
    has enough time to complete the initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Kubernetes probes is not a simple task. We need to consider many
    factors. For example, should we check the dependent services in the `readiness`
    probe? If the application can partially operate without a specific dependent service,
    it can be considered as degraded instead of unhealthy. In this case, if the application
    has mechanisms to handle transient failures gracefully, it might be acceptable
    to omit specific dependent services in the `readiness` probe. So, please consider
    your scenarios carefully; you may need a compromise when configuring the probes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section is not intended to cover all the details of Kubernetes probes.
    For more details, please refer to the following official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes documentation: [https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: "Health checks in ASP.NET Core: [https://learn.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks](https://learn.microsoft.com/en-us/aspnet/core/host-\uFEFF\
    and-deploy/health-checks)."
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring and observability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the real world, building an application is just the first step. We also need
    to monitor and observe how the application is performing. This is where the concept
    of *observability* comes in. In this section, we will discuss observability and
    how to use OpenTelemetry to monitor and observe applications.
  prefs: []
  type: TYPE_NORMAL
- en: What is observability?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B18971_04.xhtml#_idTextAnchor170), we introduced logging in
    ASP.NET Core web API applications. We learned how to use the built-in logging
    framework to log messages to different logging providers. **Observability** is
    a more comprehensive concept than logging. Besides logging, observability allows
    us to gain a deeper understanding of how the application is performing. For instance,
    we can determine how many requests are processed in a given hour, what the request
    latency is, and how requests are handled by multiple services in a microservice
    architecture. All of these are part of observability.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, observability has three pillars:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Logs**: Logs are used to record what is happening within the application,
    such as incoming requests, outgoing responses, important business logic executions,
    exceptions, errors, warnings, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metrics**: Metrics are used to measure the performance of the application,
    such as the number of requests, the request latency, error rates, resource usage,
    and so on. These metrics can be used to trigger alerts when the application is
    not performing well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Traces**: Traces are used to track the flow of requests across multiple services
    to identify where the time is spent or where the errors occur. This is especially
    useful in the microservice architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize, observability is the practice of understanding the application’s
    internal state and operational characteristics by analyzing its logs, metrics,
    and traces. There are a few different ways to implement observability in ASP.NET
    Core web API applications – we can update the source code to add logging, metrics,
    and traces or use tools to monitor and observe the application without changing
    the code. In this section, we will discuss the first approach by using OpenTelemetry
    to implement observability in ASP.NET Core web API applications. This gives us
    more flexibility to customize the observability aspect.
  prefs: []
  type: TYPE_NORMAL
- en: Using OpenTelemetry to collect observability data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenTelemetry is a popular cross-platform, open-source standard for collecting
    observability data. It provides a set of APIs, SDKs, and tools to instrument,
    generate, collect, and export telemetry data so that we can analyze the application’s
    performance and behavior. It supports many platforms and languages, as well as
    popular cloud providers. You can find more details about OpenTelemetry at [https://opentelemetry.io/](https://opentelemetry.io/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The .NET OpenTelemetry implementation consists of the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Core API**: The core API is a set of interfaces and classes that define the
    OpenTelemetry API. It is a platform-independent API that can be used to instrument
    the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instrumentation**: This is a set of libraries that can be used to collect
    instrumentation from the application. This component includes multiple packages
    for different frameworks and platforms, such as ASP.NET Core, gRPC, HTTP calls,
    SQL database operations, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exporters**: Exporters are used to export the collected telemetry data to
    different targets, such as console and **Application Performance Monitoring**
    (**APM**) systems, including Prometheus, Zipkin, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B18971_04.xhtml#_idTextAnchor170), we introduced using *Serilog*
    and *Seq* to collect logs. In the next few sections, we will focus on how to use
    OpenTelemetry to collect metrics and traces. We will use *Prometheus* to collect
    metrics and *Grafana* to visualize the metrics. We will also use *Jaeger* to collect
    traces. All these tools are open-source. In addition, we will explore Azure Application
    Insights, a powerful APM system provided by Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating OpenTelemetry with ASP.NET Core web API applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will explore how to use metrics in ASP.NET Core web API
    applications. In the sample project, we have an `InvoiceController` class to manage
    invoices. We want to know how many requests are executed and the duration of each
    request. We have several steps to perform:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the metrics for these activities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate and collect instrumentation data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visualize the data in a dashboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To start, we need to install some NuGet packages using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: These packages include the required .NET OpenTelemetry implementations. Note
    that at the time of writing, some packages did not have stable versions available,
    so we needed to use the `--prerelease` option to install the latest preview versions.
    If you are reading this book when the stable versions are available, you can omit
    the `--``prerelease` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must define the metrics. In this example, we want to know how many
    requests are executed for each action for the `/api/Invoices` endpoint. Create
    a new class named `InvoiceMetrics` in the `\OpenTelemetry\Metrics` folder. The
    following code shows how to define the metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `IMeterFactory` interface is registered in ASP.NET Core’s DI container by
    default and is used to create a meter. This meter, which is called `MyWebApiDemo.Invoice`,
    is used to record the metrics. Additionally, four counters are created to record
    the number of requests for each action. To facilitate this, four public methods
    are exposed to increment the counters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The name of each metric must be unique. When we create a metric or a counter,
    it is recommended to follow the OpenTelemetry naming guidelines: [https://github.com/open-telemetry/semantic-conventions/blob/main/docs/general/metrics.md#general-guidelines](https://github.com/open-telemetry/semantic-conventions/blob/main/docs/general/metrics.md#general-guidelines).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to register the metrics in the application. Add the following
    code to the `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we used the `AddOpenTelemetry()` method to register the
    OpenTelemetry services. The `ConfigureResource()` method registers the service
    name. Inside the `WithMetrics()` method, we use the `AddConsoleExporter()` method
    to add a console exporter. This console exporter is useful for local development
    and debugging. We also added three meters, including the ASP.NET Core hosting
    and Kestrel server, so that we can collect the metrics from the ASP.NET Core web
    API framework. Finally, we registered the `InvoiceMetrics` class in the dependency
    injection container as a singleton.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can use the `InvoiceMetrics` class to record the metrics. Open the
    `InvoiceController` class and call the `IncrementCreate()` method in the `Post`
    action, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The other actions are similar. Before we check the metrics in the console,
    we need to install the **dotnet-counters** tool, a command-line tool for viewing
    live metrics. Run the following command in the terminal to install the tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can use the `dotnet counters` command to view the metrics. We can
    check the metrics from `Microsoft.AspNetCore.Hosting` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application and send some requests to the `/api/Invoices` endpoint.
    You will see the following metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see the metrics for the HTTP actions, including the active requests
    and the request duration. You can use this tool to observe more performance metrics,
    such as CPU usage or the rate of exceptions being thrown in the application. For
    more information about this tool, please refer to the official documentation:
    [https://learn.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-counters](https://learn.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-counters).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the custom metrics via `InvoiceMetrics`, you need to specify the `--counters`
    option in the command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The output may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see the metrics we defined in the `invoiceMetrics` class. Note
    that you can include multiple counters in the `--counters` option, separated by
    commas. For example, you can use the following command to check the metrics for
    both `Microsoft.AspNetCore.Hosting` and `MyWebApiDemo.Invoice`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `InvoiceMetrics` class, we defined four counters. There are more types
    of instruments in OpenTelemetry, such as `Gauge`, `Histogram`, and others. Here
    are some of the different types of instruments that are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Counter`: A counter is used to track a value that can only increase over time
    – for example, the number of requests after the application starts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UpDownCounter`: An up-down counter is similar to a counter, but it can increase
    or decrease over time. An example of this is the number of active requests. When
    a request starts, the counter increases by 1\. When the request ends, the counter
    decreases by 1\. It can also be used to monitor the size of a queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Gauge`: A gauge measures a current value at a specific point in time, such
    as CPU usage or memory usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Histogram`: A histogram measures the statistical distribution of values using
    aggregations. For example, a histogram can measure how many requests are processed
    longer than a specific duration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can define more metrics to monitor the application. Define an `UpDownCounter`
    instrument to track how many active requests there are for the `/api/Invoices`
    endpoint. Update the `InvoiceMetrics` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, update the `InvoiceController` class so that it increments and decrements
    the counter. For simplicity, we’ll just call the `IncrementRequest()` and `DecrementRequest()`
    methods in the controller. In the real world, it is recommended to use an ASP.NET
    Core middleware to handle this. The following code shows how to update the `InvoiceController`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of `Histogram` is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, update the `InvoiceController` class so that it records the request’s
    duration. Similarly, we can just use the `RecordRequestDuration()` method in the
    controller. The following code shows how to update the `InvoiceController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use a `Task.Delay()` method to simulate latency. Run the application
    and send some requests to the `/api/Invoices` endpoint. Then, check the metrics
    using the `dotnet-counters` tool. You will see the metrics, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, the histogram instruments are shown as `Percentile=50`,
    `Percentile=95`, and `Percentile=99`. This is the default configuration for the
    `dotnet-counters` tool. We can use other tools, such as Prometheus and Grafana,
    to provide more visualization options. We will discuss this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using Prometheus to collect and query metrics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Prometheus** is a widely used open-source monitoring system. Prometheus was
    originally developed by SoundCloud ([https://soundcloud.com/](https://soundcloud.com/)),
    then joined the Cloud Native Computing Foundation ([https://cncf.io/](https://cncf.io/))
    in 2016\. Prometheus is capable of collecting metrics from a variety of sources,
    including applications, databases, operating systems, and more. It also offers
    a powerful query language for querying the collected metrics, as well as a dashboard
    to visualize them.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will use Prometheus to collect metrics from the ASP.NET
    Core web API application and visualize the metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Prometheus, navigate to the official website: [https://prometheus.io/download/](https://prometheus.io/download/).
    Download the latest version of Prometheus for your operating system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to configure the ASP.NET web API application to export metrics
    for Prometheus. Install the `OpenTelemetry.Exporter.Prometheus.AspNetCore` package
    in the ASP.NET Core web API project using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, register the Prometheus exporter in the `Program.cs` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have two exporters: the console exporter and the Prometheus exporter.
    If you don’t need the console exporter, you can remove it. We’re also using the
    `MapPrometheusScrapingEndpoint()` method to map the `/metrics` endpoint for the
    Prometheus exporter. This endpoint is used by Prometheus to scrape metrics from
    the application.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to configure Prometheus to collect metrics from the ASP.NET Core
    web API application. Find the port number of the ASP.NET Core web API application.
    In the sample project, we use port number 5125 for HTTP. You can find the relevant
    port numbers in the `launchSettings.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `prometheus.yml` file in the Prometheus folder. Add a job at the end
    of the file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `scrape_interval` property is set to specify the interval at which metrics
    should be scrapped. For testing purposes, this can be set to 5 seconds so that
    you can view metrics immediately. However, in production scenarios, it is recommended
    to set this to a higher value, such as 15 seconds. Additionally, ensure that the
    `targets` property is set to the correct port number before saving the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use HTTPS for the ASP.NET Core web API application, you need to specify
    the `schema` property, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application and send some requests to the `/api/Invoices` endpoint.
    Navigate to the `/metrics` endpoint; you will see the relevant metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.4 – Metrics for Prometheus](img/B18971_16_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.4 – Metrics for Prometheus
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can run Prometheus by executing the `prometheus.exe` file. In the output,
    you will find the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that Prometheus is running on port `9090`. Navigate to `http://localhost:9090`.
    You will see the Prometheus dashboard, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.5 – Prometheus dashboard](img/B18971_16_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.5 – Prometheus dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'Prometheus will start to scrape metrics from the ASP.NET Core web API application
    we configured in the `prometheus.yml` file. Click **Status** | **Targets** at
    the top. You will see the following page, which shows the status of the ASP.NET
    Core web API application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.6 – Prometheus targets](img/B18971_16_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.6 – Prometheus targets
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **Graph** in the top menu. You will see the following page, which shows
    the available metrics. Click the **Open Metrics Explorer** button (highlighted
    in *Figure 16**.7*) to open **Metrics Explorer**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.7 – Prometheus Metrics Explorer](img/B18971_16_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.7 – Prometheus Metrics Explorer
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose one metric, such as `mywebapidemo_invoices_read_total`, and click the
    **Execute** button. Then, click the **Graph** tab; you will see the following
    page, which shows the metric graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.8 – Prometheus graph](img/B18971_16_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.8 – Prometheus graph
  prefs: []
  type: TYPE_NORMAL
- en: 'Prometheus provides a powerful query language to query the metrics. For example,
    we can use the following query to get the `mywebapidemo.invoices.read` counter
    per minute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.9 – Requests per minute](img/B18971_16_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.9 – Requests per minute
  prefs: []
  type: TYPE_NORMAL
- en: 'The following query can get the requests that take longer than 100 milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 16**.10* shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.10 – Requests that take longer than 100 milliseconds](img/B18971_16_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.10 – Requests that take longer than 100 milliseconds
  prefs: []
  type: TYPE_NORMAL
- en: 'This section provided a brief introduction to Prometheus. For more information
    about the querying language syntax, please refer to the official documentation:
    [https://prometheus.io/docs/prometheus/latest/querying/basics/](https://prometheus.io/docs/prometheus/latest/querying/basics/).'
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus is a powerful tool for collecting and querying metrics. To gain better
    visualization of these metrics, Grafana can be used to create dashboards. In the
    following section, we will explore how to use Grafana to read metrics from Prometheus
    and create informative dashboards.
  prefs: []
  type: TYPE_NORMAL
- en: Using Grafana to create dashboards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Grafana** is a popular opensource analytics and dashboarding tool. It can
    visualize metrics from multiple data sources, such as Prometheus, Elasticsearch,
    Azure Monitor, and others. Grafana can create beautiful dashboards to help us
    understand the application’s performance and behavior. In this section, we will
    use Grafana to create dashboards for the ASP.NET Core web API application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Grafana also provides a managed service called **Grafana Cloud**. The free
    tier of Grafana Cloud has a limit of 10,000 metrics, 3 users, and 50 GB of logs.
    You can check the pricing here: [https://grafana.com/pricing/](https://grafana.com/pricing/).
    In this book, we will install Grafana locally. Download the latest version of
    Grafana from the official website: [https://grafana.com/oss/grafana/](https://grafana.com/oss/grafana/).
    Then, choose the version for your operating system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run Grafana by executing the `grafana-server.exe` file if you’re using Windows.
    You may see a Windows Security Alert dialog box. Click the **Allow** button to
    allow Grafana to communicate on these networks. You will find the following line
    in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This means that Grafana is running on port `3000`. Navigate to `http://localhost:3000`.
    The default username and password are both `admin`. Once you’ve logged in, you
    will be prompted to change the password.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The default theme of Grafana is dark. If you prefer a light theme, you can change
    it by going to the **Preferences** page. We’re using the light theme in this book
    for better readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the hamburger menu in the top-left corner, and then click **Connections**.
    This page shows the data sources that Grafana supports:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.11 – Grafana data sources](img/B18971_16_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.11 – Grafana data sources
  prefs: []
  type: TYPE_NORMAL
- en: 'Search for *Prometheus* and click on it. Then, click the **Create a Prometheus
    data source** button in the top-right corner. On the **Settings** page, we can
    configure the data source, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.12 – Configuring the Prometheus data source](img/B18971_16_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.12 – Configuring the Prometheus data source
  prefs: []
  type: TYPE_NORMAL
- en: Use `http://localhost:9090` as the URL. Then, click the `Successfully queried
    the Prometheus API`. At this point, we can create dashboards to visualize the
    metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the **Dashboards** page and click the **New** button. From the
    drop-down list, click **New Dashboard**. You will be navigated to the new dashboard
    page. Click the **Add visualization** button, then choose Prometheus as the data
    source, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.13 – Adding a visualization](img/B18971_16_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.13 – Adding a visualization
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can use the query language to query the metrics. In the `mywebapidemo.invoices.read`
    requests for the `/``api/Invoices` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.14 – Querying the metrics](img/B18971_16_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.14 – Querying the metrics
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **Run queries** button; you will see the following output in the
    panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.15 – Query result](img/B18971_16_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.15 – Query result
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, click the **Apply** button; you will see the graph in the dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.16 – Grafana dashboard](img/B18971_16_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.16 – Grafana dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'You can adjust the size of the dashboard as necessary. Feel free to add more
    dashboard panels to visualize the metrics. Before you leave the dashboard, click
    the **Save** button in the top-right corner to save it. You can also export the
    dashboard as a JSON file and import it later:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.17 – Adding more panels](img/B18971_16_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.17 – Adding more panels
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify the process of creating Grafana dashboards, James Newton-King,
    the esteemed author of JSON.NET, has provided a Grafana dashboard template for
    ASP.NET Core web API applications. You can find the template here: [https://github.com/JamesNK/aspnetcore-grafana/blob/main/README.md](https://github.com/JamesNK/aspnetcore-grafana/blob/main/README.md).
    There are two dashboards in this repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ASP.NET Core.json`: This dashboard shows an overview of the ASP.NET Core web
    API application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ASP.NET Core Endpoint.json`: This dashboard shows the details for specific
    endpoints'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a new dashboard and click the `ASP.NET Core.json` file or paste the
    content of the file into the textbox, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.18 – Importing the dashboard](img/B18971_16_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.18 – Importing the dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **Load** button. On the next page, choose the Prometheus data source
    and click the **Import** button. You will see the following dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.19 – ASP.NET Core dashboard provided by James Newton-King](img/B18971_16_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.19 – Overview of the ASP.NET Core dashboard provided by James Newton-King
  prefs: []
  type: TYPE_NORMAL
- en: This dashboard provides an overview of the ASP.NET Core web API application.
    Here, you can see the number of requests, the request’s duration, the number of
    active requests, and so on. You can also see the error rate, which is important
    for monitoring the application.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16**.20* shows the **ASP.NET Core** **Endpoint** dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.20 – The ASP.NET Core Endpoint dashboard provided by James Newton-King](img/B18971_16_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.20 – Overview of the ASP.NET Core Endpoint dashboard provided by James
    Newton-King
  prefs: []
  type: TYPE_NORMAL
- en: You can choose the endpoint from the drop-down list. Once you’ve done this,
    you will see the metrics for the endpoint. For example, *Figure 16**.20* shows
    the metrics for the `/``api/Invoices` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Grafana offers many options to customize dashboards. On any dashboard panel,
    you can click the three dots in the top-right corner and then click **Edit** to
    edit the panel. You can change the title, the visualization type, the query, and
    so on. You can also use the **Builder** or **Code** editor to edit the query,
    as shown in *Figure 16**.21* and *Figure 16**.22*, respectively. Here’s what the
    **Builder** editor looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.21 – Editing the query using the Builder editor](img/B18971_16_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.21 – Editing the query using the Builder editor
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the **Code** editor looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.22 – Editing the query using the Code editor](img/B18971_16_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.22 – Editing the query using the Code editor
  prefs: []
  type: TYPE_NORMAL
- en: 'Grafana provides a better visualization of the metrics. You can learn more
    about Grafana by reading the official documentation: [https://grafana.com/docs/grafana/latest/.](https://grafana.com/docs/grafana/latest/.
    )'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore how to use OpenTelemetry and Jaeger to
    collect traces.
  prefs: []
  type: TYPE_NORMAL
- en: Using Jaeger to collect traces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Traces are important for understanding how requests are handled by the application.
    In a microservice architecture, a request will be handled by multiple services.
    Distributed tracing can be used to track the flow of requests across multiple
    services. In this section, we will learn about the basic concepts of distributed
    tracing and how to use OpenTelemetry and Jaeger to collect traces.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in a microservice architecture, service A calls service B, and
    service B calls service C and service D. When a client sends a request to service
    A, the request will be passed through service B, service C, and service D. In
    this case, if any of these services fails to process the request, or the request
    takes too long to process, we need to know which service is responsible for the
    failure and which part of the request contributes to the latency or errors. Distributed
    tracing can give us the big picture of how the request is processed by these services.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have not discussed microservice architecture in detail in this book. To
    demonstrate distributed tracing, we added two web API projects to the sample project.
    You can find a controller named `OrdersController` in the `MyWebApiDemo` project.
    In this controller, we can call the `Post` action to create an order. The `Post`
    action will call two external services:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CustomerService`: A service to check whether the customer exists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProductService`: A service to check whether the product exists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create an order, we must ensure the customer ID is valid by calling the `/api/customers/{id}`
    endpoint of `CustomerService`. Additionally, we must verify that the products
    are valid by calling the `/api/products/{id}` endpoint of `ProductService`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that these services are for demonstration purposes only and should not
    be used for production purposes. As such, there is no real database access layer;
    instead, a static list is used to store the temporary data. Additionally, there
    is no consideration for transaction and concurrency management.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s enable tracing in the `MyWebApiDemo` project. Open the `Program.cs`
    file and add the following code to the `MyWebApiDemo` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we enabled tracing in our code using the `WithTracing`
    method. To further instrument our application, we added ASP.NET Core and HTTP
    client instrumentation. The HTTP client instrumentation is used to trace the HTTP
    calls to the external services. Finally, we added a console exporter to export
    the traces to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application and send some requests to the `api/orders` endpoint. You
    will see some tracing information in the terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the console trace, you will find two important properties: `Activity.TraceId`
    and `Activity.SpanId`. The `Activity.TraceId` property is used to identify a trace,
    which is a collection of spans. A span is a unit of work in a trace. For example,
    if we send a `POST` request to the `api/Orders` endpoint to create an order, the
    application will call `ProductService` and `CustomerService`. Each call is a span.
    However, it is not convenient to search for a specific span in the console output.
    Next, we will use Jaeger to collect and visualize the traces.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jaeger** is an open-source distributed tracing platform that is used to monitor
    and troubleshoot distributed workflows and identify performance bottlenecks. Jaeger
    was originally developed by Uber Technologies ([http://uber.github.io/](http://uber.github.io/))
    and joined the Cloud Native Computing Foundation in 2017.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Jaeger from the official website: [https://www.jaegertracing.io/download/](https://www.jaegertracing.io/download/).
    You can choose the version for your operating system or use the Docker image.
    In this book, we will use the executable binaries on Windows. Navigate to the
    Jaeger folder in the terminal and run the following command to start Jaeger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `jaeger-all-in-one` command is for quick local testing. It starts all the
    components of Jaeger, including the Jaeger UI, `jaeger-collector`, `jaeger-agent`,
    `jaeger-query`, and in-memory storage. The `--collector.otlp.enabled` option is
    used to specify that `jaeger-collector` should accept traces in OTLP format. In
    the output, you can find the following line, which indicates that Jaeger is receiving
    data from OTLP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '`jaeger-collector` utilizes port `4317` to receive data via the gRPC protocol
    and port `4318` via the HTTP protocol. This allows for efficient communication
    between `jaeger-collector` and other services.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to configure the ASP.NET Core web API project so that it exports
    the OTLP traces to Jaeger. Open the `Program.cs` file and update the `WithTracing()`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We use the `AddOtlpExporter` method to add the exporter for Jaeger. As a best
    practice, it is recommended to use the configuration system to set the URL, rather
    than hard-coding it. As an example, you can define it in the `appsettings.json`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Restart the three applications and send some `POST` requests to the `/api/Orders`
    endpoint. Here is a payload example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to `http://localhost:16686/`; you will see the Jaeger UI. In the **Search**
    tab, choose **Service**, then **Operation**, and then click the **Find Traces**
    button. You will see the traces, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.23 – Jaeger traces](img/B18971_16_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.23 – Jaeger traces
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on a trace to view its details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.24 – A trace’s details](img/B18971_16_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.24 – A trace’s details
  prefs: []
  type: TYPE_NORMAL
- en: You will see that this request includes three spans. The parent is the inbound
    request, and it has two outbound requests to other services.
  prefs: []
  type: TYPE_NORMAL
- en: We can enable traces in the dependent services to better understand how these
    requests are processed. Configure `ProductService` and `CustomerService` following
    the same methods. These traces should be sent to one Jaeger instance so that Jaeger
    can correlate the requests across different services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the Jaeger UI now. You will find that one `/api/Orders` call has five
    spans now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.25 – The traces across multiple services](img/B18971_16_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.25 – The traces across multiple services
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also check the latency for each span, as shown in *Figure 16**.26*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.26 – The latency for each span](img/B18971_16_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.26 – The latency for each span
  prefs: []
  type: TYPE_NORMAL
- en: 'Using traces can help us understand how requests are handled by the application.
    We can also use traces to find performance bottlenecks. It is especially useful
    for microservice architectures. For more information about Jaeger, please refer
    to the official documentation: [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter16/MyWebApiDemo](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter16/MyWebApiDemo).'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will recap logging and discuss how to propagate the trace context in
    the logs.
  prefs: []
  type: TYPE_NORMAL
- en: Using HTTP logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B18971_04.xhtml#_idTextAnchor170), we discussed how to use
    the `ILogger` interface to log messages. Sometimes, we want to log the HTTP requests
    and responses for troubleshooting purposes. In this section, we will discuss HTTP
    logging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow [*Chapter 4*](B18971_04.xhtml#_idTextAnchor170) to configure the logging
    system. You can use Serilog to send logs to Seq. To enable HTTP logging, we need
    to use the HTTP logging middleware. The middleware will log the inbound requests
    and outbound responses. The updated code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we specify `HttpLoggingFields` to log all fields. Be
    careful when you use this option in production because it may potentially impact
    the performance and log sensitive information. We should not log **personally
    identifiable information** (**PII**) and any sensitive information. We’re using
    it for demonstration purposes only here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also update the `appsettings.json` file to specify the log levels. Add
    the following code to the `LogLevel` section of the `appsettings.json` file so
    that we can see information logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Configure the logging in the `CustomerService` and `ProductService` projects
    using the same methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the three applications and send some requests to the `/api/Orders` endpoint.
    You will see the following logs in the Seq dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.27 – HTTP logging](img/B18971_16_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.27 – HTTP logging
  prefs: []
  type: TYPE_NORMAL
- en: In the logs, you will find details about the HTTP requests and responses. If
    you want to change the logging fields, you can change the `LoggingFields` property
    of `HttpLoggingOptions` in the `AddHttpLogging()` method. The `LoggingFields`
    property is an enum. You can choose `RequestPath`, `RequestQuery`, `RequestMethod`,
    `RequestStatusCode`, `RequestBody`, `RequestHeaders`, `ResponseHeaders`, `ResponseBody`,
    `Duration`, and so on. The `HttpLoggingOptions` class has other properties, such
    as `RequestHeaders`, `ResponseHeaders`, `RequestBodyLogLimit`, `ResponseBodyLogLimit`,
    and others. You can use these properties to configure the logging system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we enabled HTTP logging for all requests, we can filter the logs by trace
    ID. Check the Jaeger UI and click on a trace. You will find the trace ID in the
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.28 – The trace ID in Jaeger](img/B18971_16_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.28 – The trace ID in Jaeger
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, the trace ID is `8c7ab3bccf13135f27baf11c161e17ca`.
    Copy this trace ID and use the following query in the Seq dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Click the green **Go** button to filter the logs. You will see the logs for
    this trace:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.29 – Filtering the logs by trace ID](img/B18971_16_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.29 – Filtering the logs by trace ID
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16**.29* provides a comprehensive view of all the logs for the trace,
    including HTTP requests and responses for three services. This is an invaluable
    resource for troubleshooting.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Azure Application Insights
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding sections, we explored how to use OpenTelemetry to collect metrics
    and traces. We also discussed how to leverage open-source tools such as Prometheus,
    Grafana, Jaeger, and Seq to visualize the metrics, traces, and logs. Now, we’ll
    look at how to use Azure Application Insights to create a unified dashboard for
    monitoring an ASP.NET Core web API application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure Application Insights is an extensible APM service for monitoring applications.
    It can collect and analyze logs, metrics, and traces from multiple sources. To
    follow this section, you need to have an Azure subscription. If you do not have
    one, you can create a free account here: [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the Azure portal and create a new Application Insights resource. You
    can find the Application Insights service in the **Monitoring** category. Choose
    the **Application Insights** service and click the **Create** button. On the next
    page, you need to specify the resource group, name, region, and pricing tier,
    as shown in *Figure 16**.30*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.30 – Creating an Application Insights resource](img/B18971_16_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.30 – Creating an Application Insights resource
  prefs: []
  type: TYPE_NORMAL
- en: Once the Application Insights resource has been created, navigate to the **Overview**
    page. You will find the **Instrumentation Key** and **Connection String** values.
    **Instrumentation Key** is used to identify the Application Insights resource,
    while **Connection String** is used to connect to the Application Insights resource.
    We will use **Connection String** to configure the ASP.NET Core web API applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `appsettings.json` file in the `MyWebApiDemo` project. Add the following
    setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Please replace the connection string with your own value. This is for demonstration
    purposes only. It is recommended to use different Application Insights resources
    for different environments. This will ensure that metrics and traces are not mixed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to install the `Azure.Monitor.OpenTelemetry.AspNetCore` package
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This package is used to export metrics and traces to Azure Application Insights.
    At the time of writing, the package was still in preview. If you are reading this
    book after the package has been released, you can omit the `--``prerelease` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, update the `Program.cs` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This method will read the `APPLICATIONINSIGHTS_CONNECTION_STRING` setting from
    the configuration system and export the metrics and traces to Azure Application
    Insights.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the `CustomerService` and `ProductService` projects using the same
    methods. Run the three applications and send some `POST` requests to the `/api/Orders`
    endpoint. Then, navigate to the Application Insights resource in the Azure portal.
    You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.31 – Azure Application Insights](img/B18971_16_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.31 – Overview of Azure Application Insights
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find even more information about logs, metrics, and traces. Click the
    **Logs** tab; you will see the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.32 – Azure Application Insights logs](img/B18971_16_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.32 – Azure Application Insights logs
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 16**.32*, we use `requests | where url !contains "metrics"` to query
    the logs. This query will filter the logs that do not contain the `metrics` keyword.
    You can also use `traces` to query the traces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Metrics** tab shows the available metrics, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.33 – Azure Application Insights metrics](img/B18971_16_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.33 – Azure Application Insights metrics
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can find the metrics we defined for the `api/Invoices` endpoint. If
    you cannot see the metrics, send some requests to the `api/Invoices` endpoint
    and wait a few minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **Application map** tab; you will see the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.34 – Azure Application Insights application map](img/B18971_16_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.34 – Overview of the Azure Application Insights application map
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16**.34* shows the requests flow across multiple services. You can
    also find the latency for each service.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon clicking any request in the diagram, you will see details such as the
    response time, dependency count, performance histogram, and dependencies, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.35 – Azure Application Insights request details](img/B18971_16_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.35 – Overview of Azure Application Insights request details
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **Performance** tab; you will see the overall performance of the
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.36 – Azure Application Insights performance](img/B18971_16_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.36 – Overview of Azure Application Insights performance
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on one operation, such as `POST api/Orders`, will allow you to view
    the performance of that operation. For further details, click the **xx Samples**
    button located under the **Drill into...** label in the bottom-right corner. You
    will see a list of all the requests for that operation on the right-hand side
    of the screen. Clicking on one of these requests will allow you to view the details
    of that request, including the request and response body, as shown in *Figure
    16**.37*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.37 – Azure Application Insights end-to-end transaction details](img/B18971_16_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.37 – Azure Application Insights end-to-end transaction details
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 16**.37*, you can see how the request is processed by multiple services,
    similar to what the Jaeger UI does.
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure Application Insights is a super powerful tool for monitoring applications.
    The benefits of using Azure Application Insights are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It is a managed service. You do not need to maintain the infrastructure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides a unified dashboard for monitoring applications. You do not need
    to use multiple tools. Application Insights can provide a centralized view of
    the metrics, traces, and logs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easy to integrate with your applications. Configuring one connection string
    is much easier than configuring multiple tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides a powerful query language to query metrics, traces, and logs. You
    can use the query language to create custom dashboards.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It offers more features, such as alerting, failure analysis, funnel analysis,
    user flows, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that Azure Application Insights is not free. It is part of Azure Monitor,
    a comprehensive monitoring solution for enterprise applications. You can find
    its pricing here: [https://azure.microsoft.com/en-us/pricing/details/monitor/](https://azure.microsoft.com/en-us/pricing/details/monitor/).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed monitoring and observability in ASP.NET Core web
    API applications. We explored how to handle errors and exceptions and return proper
    error responses. We also discussed how to implement health checks to determine
    the status of the application. Then, we learned about the basic concepts of observability,
    including logs, metrics, and traces, and how to integrate with OpenTelemetry and
    define custom metrics. We also explored some open-source tools, such as Prometheus,
    Grafana, Jaeger, and Seq, to collect and visualize metrics, traces, and logs.
    Finally, we introduced Azure Application Insights, a managed service for monitoring
    applications in one place.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring and observability are complex topics that require a deeper understanding
    of distributed systems and microservice architecture. In this chapter, we only
    introduced the basic concepts. To gain a more comprehensive understanding of these
    topics, further study is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore advanced topics related to architecture
    and design patterns. These include **domain-driven design** (**DDD**), clean architecture,
    and cloud-native patterns such as CQRS, resilience patterns, and more. This will
    provide you with a comprehensive overview of the various approaches to architecture
    and design.
  prefs: []
  type: TYPE_NORMAL
