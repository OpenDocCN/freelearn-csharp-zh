- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Build and Test
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 & 测试
- en: At this point in the development journey, we’ve gone through a great amount
    of work together. We should now have a vertical slice of a game that, so far,
    we’ve been able to play in the Unity Editor and it’s working. This is wonderful,
    but are you going to expect your players to download Unity and open the package
    up, then play it in the editor? I think not! This is where we want to build the
    game project out into an executable. In this chapter, we will go over how to build
    your game out so it can be published and tested and ultimately get into the hands
    of players.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发旅程的这个阶段，我们已经一起完成了很多工作。现在，我们应该有一个游戏垂直切片，到目前为止，我们已经在 Unity 编辑器中能够玩到，并且它正在运行。这是很棒的，但你是否期望你的玩家下载
    Unity 并打开包，然后在编辑器中玩游戏？我想不是！这就是我们想要将游戏项目构建成可执行文件的地方。在本章中，我们将介绍如何构建你的游戏，使其可以发布、测试，并最终让玩家能够玩到。
- en: 'You will learn about:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习到：
- en: Building from Unity
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Unity 构建
- en: Testing—functional, performance, playtesting, soak, and localization testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试——功能测试、性能测试、游戏测试、浸泡测试和本地化测试
- en: User Experience (UX)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户体验 (UX)
- en: Building with Unity
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Unity 构建
- en: We’ve worked very hard to put together an experience. We now need to be able
    to get it out to people. To do this, we need to tell Unity a couple of things.
    It needs to know what you are building for, such as which scenes should be built
    within the application, which platform, and additional options that affect the
    build output executable.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为了构建一个体验付出了很多努力。现在，我们需要能够将它带给人们。为了做到这一点，我们需要告诉 Unity 几件事情。它需要知道你正在为哪个平台构建，例如，哪些场景应该在应用程序中构建，哪个平台，以及影响构建输出可执行文件的其他选项。
- en: 'Where we are now in the vertical slice is a good place to build at. This may
    not always be the case in every project. In most cases, the best way to work with
    the build is this: build early, build often. In our case, we needed to wait until
    we had some mechanics and a standard playthrough from our two major puzzles before
    we decided to build.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在垂直切片的这个阶段，构建是一个很好的选择。在大多数项目中，这并不总是情况。在大多数情况下，与构建一起工作的最佳方式是：尽早构建，经常构建。在我们的情况下，我们需要等待我们有一些机制和两个主要谜题的标准游玩流程，然后我们才决定构建。
- en: In *Figure 11.1* you can see the **Build Settings** menu, which is found under
    **File** > **Build Settings**. Below the image, we will break down each of these
    settings.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 11.1*中，你可以看到**构建设置**菜单，它位于**文件** > **构建设置**下。在图片下方，我们将逐一解释这些设置。
- en: '![Graphical user interface  Description automatically generated](img/B17304_11_01.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面 自动生成描述](img/B17304_11_01.png)'
- en: 'Figure 11.1: Build settings'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：构建设置
- en: The first block we see is **Scenes In Build**. As it is at the top, we should
    have a feeling that it’s important. This automatically places the default scene
    into the box, but there may be other scenes that you want. You may have another
    scene for menu systems or another map that might be a tutorial level. The key
    factor here is to have the scenes that you want in the game in this box; you can
    just drag the scenes from the project window into the **Scenes In Build** box.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看到的是**构建场景**。由于它位于顶部，我们应该感觉到它很重要。这会自动将默认场景放入框中，但可能还有其他你想要的场景。你可能还有一个用于菜单系统的场景或另一个可能是教程级别的地图。这里的关键因素是要将你想要的场景放入这个框中；你可以直接将场景从项目窗口拖到**构建场景**框中。
- en: The top scene in this list will always be the first scene that is loaded.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 列表顶部的场景将始终是第一个加载的场景。
- en: Below the **Scenes In Build** block, the GUI is split into two sections, **Platform**
    and then settings for that platform. On the left, we choose which platform we
    want to build for. After that, the settings for that platform will be on the right
    side. We will go over just the **PC, Mac & Linux Standalone** options.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在“**构建场景**”块下方，GUI 被分为两个部分，**平台**以及该平台的设置。在左侧，我们选择我们想要构建的平台。之后，该平台的设置将显示在右侧。我们将简要介绍**PC、Mac
    和 Linux 独立版**选项。
- en: If you are building for any other platform, the Unity documentation will help
    guide you through the building process. We will be describing most of the parameters
    that are available below. Console and mobile choices will have a few different
    available parameters specific to their target platform’s needs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在为任何其他平台构建，Unity 文档将帮助你了解构建过程。我们将描述大部分在下面可用的参数。控制台和移动设备的选择将有一些针对其目标平台需求的特定参数。
- en: Target platform
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标平台
- en: 'This option is simple enough: which platform would you like to target with
    this build? The choices here are Windows, macOS, and Linux. We are building for
    Windows with this vertical slice.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项很简单：你希望用这个构建针对哪个平台？这里的选项是 Windows、macOS 和 Linux。我们在这个垂直切片中为 Windows 构建应用程序。
- en: Architecture
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构
- en: We need to know what CPU architecture we should be planning on. A 32-bit OS
    will require your game to use less than 4 GB of RAM. You can do this, but you
    can use 64-bit for smaller games as well; it will not hurt your game. In general,
    64-bit should be the way to go.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要知道我们应该计划哪种 CPU 架构。32 位操作系统将要求你的游戏使用少于 4 GB 的 RAM。你可以这样做，但即使是小型游戏也可以使用 64
    位；这对你的游戏没有坏处。一般来说，64 位应该是首选。
- en: Server Build
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器构建
- en: Unity can create a server for your game if you are working on a multiplayer
    game. This will build the player settings with no visual elements. It will also
    build managed scripts that are defined for multiplayer. We will not be working
    with this, but know the option is there. We also will not be going over multiplayer
    development with Unity as that would be a much different project from the beginning.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在开发多人游戏，Unity 可以为你创建一个游戏服务器。这将构建没有视觉元素的玩家设置。它还将构建为多人游戏定义的托管脚本。我们不会使用这个选项，但要知道这个选项是存在的。我们也不会用
    Unity 讲解多人游戏开发，因为这将是一个从开始就完全不同的项目。
- en: Copy PDB files
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制 PDB 文件
- en: This is a Windows-platform-only setting. It will allow you to build in the Microsoft
    program database for debugging. We will not be using this either in our build.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个仅适用于 Windows 平台的设置。它将允许你在 Microsoft 程序数据库中进行构建以进行调试。我们也不会在我们的构建中使用这个选项。
- en: Create Visual Studio Solution
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Visual Studio 解决方案
- en: This is also a Windows-platform-only setting. Enabling this will allow you to
    build from Visual Studio instead of only from **Build Settings** menu. If you
    are targeting macOS, there would instead be a **Create Xcode Project** checkbox.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个仅适用于 Windows 平台的设置。启用此选项将允许你从 Visual Studio 而不是仅从**构建设置**菜单构建。如果你针对 macOS，则会有一个**创建
    Xcode 项目**复选框。
- en: Development Build
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发构建
- en: Enabling this will allow debugging, including the Profiler. The Profiler is
    an analyzer to know what is being performed during runtime.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此选项将允许调试，包括分析器。分析器是一个分析器，用于了解在运行时正在执行什么操作。
- en: We will be going over this thoroughly in the *Testing* section of this chapter.
    There are also defined settings that will be included. This is very good for when
    you need to test your application and are worried about performance. You especially
    need to keep it in mind if you have a tight visual budget. There is a term that
    is used called “benchmarking.” This term refers to testing your build on a target
    machine. If you choose a lower-end computer to test on, note its specs and build
    the game in development mode so that you can run the Profiler while it’s running.
    Once you have the benchmark, you can make some educated guesses on how it will
    run on higher-end and lower-end machines.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的**测试**部分详细讲解这一点。这里还定义了一些将包含的设置。这对于当你需要测试你的应用程序并且担心性能时非常好。如果你有紧张的视觉预算，你尤其需要注意这一点。有一个术语叫做“基准测试”。这个术语指的是在目标机器上测试你的构建。如果你选择低端计算机进行测试，请注意其规格，并在开发模式下构建游戏，这样你可以在运行时运行分析器。一旦你有了基准测试，你就可以对它在高端和低端机器上的运行做出一些有根据的猜测。
- en: Autoconnect Profiler
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动连接分析器
- en: If you have **Development Build** turned on, then you can enable this setting.
    It will automatically connect the Profiler that we talked about above in the *Development
    Build* section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经开启了**开发构建**，那么你可以启用此设置。它将自动连接我们在**开发构建**部分提到的分析器。
- en: Deep Profiling Support
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深度分析支持
- en: This also requires the development build to be enabled. This enables the Unity
    Profiler to record more detailed data. This will not be the best option for checking
    performance as there could be some slowing down of executing scripts. The primary
    purpose of a deep profiling build is to get a specific cause of managed applications
    by recording all function calls.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这也要求启用开发构建。这将使 Unity 分析器能够记录更详细的数据。这不会是检查性能的最佳选项，因为执行脚本可能会有些减慢。深度分析构建的主要目的是通过记录所有函数调用来获取托管应用程序的具体原因。
- en: Since every method will be recorded individually, deep profiling provides a
    very clear view of what is being called and when. Some bugs during gameplay can
    be lured out and caught more easily with a deep profile.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个方法都会单独记录，深度分析提供了对正在调用什么以及何时调用的非常清晰的视图。在游戏过程中，一些错误可以通过深度分析更容易地诱出和捕获。
- en: Script Debugging
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本调试
- en: 'Enabling this also needs **Development Build** enabled and it adds debugging
    symbols to the script code. This will allow the **IDE** (**Integrated Development
    Editor**, such as Visual Studio) to be attached to the game when it runs to debug
    it through your breakpoints and debugging systems. When you select this, another
    option will pop up as shown below in *Figure 11.2*:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此选项还需要启用**开发构建**，并且它会在脚本代码中添加调试符号。这将允许**IDE**（**集成开发编辑器**，例如Visual Studio）在游戏运行时附加到游戏上，通过你的断点和调试系统进行调试。当你选择此选项时，将弹出另一个选项，如下图中所示：
- en: '![](img/B17304_11_02.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17304_11_02.png)'
- en: 'Figure 11.2: Wait For Managed Debugger build setting option'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：等待托管调试器构建设置选项
- en: The **Wait For Managed Debugger** option, if enabled, will wait until the IDE
    is looking for the build to ask for the connection. No scripts will be executed
    until there is a connection with the debugger.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用**等待托管调试器**选项，它将等待IDE寻找构建并请求连接。在没有与调试器建立连接之前，不会执行任何脚本。
- en: Scripts Only Build
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅构建脚本
- en: There may come a time when you find some bugs and need to be able to make some
    changes, but you don’t want to build everything. Data files can get to be very
    large. We have talked previously in this book about how iteration matters more
    than almost anything. This can significantly reduce the time between iterations
    of debugging.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能会发现一些错误并需要做出一些更改，但你不想构建一切。数据文件可能会变得非常大。我们在这本书中之前已经讨论过迭代的重要性几乎超过任何事情。这可以显著减少调试迭代之间的时间。
- en: This option will only build the scripts and keep all the data files intact.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项将只构建脚本并保持所有数据文件完整。
- en: Compression Method
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 压缩方法
- en: 'There are three options here: **Default**, **LZ4**, and **LZ4HC**. **Default**
    means no compression. No compression will have a runnable file on Windows, Mac,
    and Linux right away. On Android builds, it will build as a ZIP file.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三个选项：**默认**、**LZ4**和**LZ4HC**。**默认**表示不进行压缩。不进行压缩的文件在Windows、Mac和Linux上可以直接运行。在Android构建中，它将构建为ZIP文件。
- en: '**LZ4** is useful for development builds as the data stored will be compressed
    and unpacked or decompressed during runtime. Scene and asset loading depend on
    disk read speeds. This is another option that can be used to help iteration speeds
    as the build time is faster than the default. An interesting note is that LZ4
    decompression on Android is faster than the default ZIP.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**LZ4**对于开发构建很有用，因为存储的数据将在运行时进行压缩和解压缩。场景和资产加载依赖于磁盘读取速度。这是一个可以用来帮助提高迭代速度的选项，因为构建时间比默认设置快。一个有趣的注意点是，Android上的LZ4解压缩比默认的ZIP快。'
- en: '**LZ4HC** is a high-compression version of LZ4, which will take longer to build
    as it compresses the build further. This is a great option for release builds
    after spending time debugging.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**LZ4HC**是LZ4的高压缩版本，由于进一步压缩构建，构建时间会更长。这是一个在花费时间调试后用于发布构建的绝佳选项。'
- en: Starting with **Default** for quick tests in gameplay testing is a good idea.
    After you get to the point where you need to development build and debug, use
    LZ4\. Then after you’re ready to make releases, build on LZ4HC.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏测试中从**默认**开始进行快速测试是个好主意。当你需要开发构建和调试时，使用LZ4。然后当你准备好发布时，使用LZ4HC进行构建。
- en: Testing
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'Testing a game is a broad concept. There are large testing portions that are
    more common and some smaller, more specific ones. The more common testing patterns
    we see are:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏测试是一个广泛的概念。有一些更常见的测试部分和一些更小、更具体的部分。我们常见的测试模式包括：
- en: Functional
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试
- en: Performance
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能测试
- en: Playtesting
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏测试
- en: Soak
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浸泡测试
- en: Localization
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地化
- en: If you research game QA or game testing, you will find several other names for
    testing, and a studio may have their own specific testing that is their form of
    best practice.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你研究游戏质量保证或游戏测试，你会找到几个其他测试的名称，一个工作室可能有他们自己的特定测试，这是他们的最佳实践形式。
- en: None of this is wrong. The testing we will explain from the list above is seen
    in almost every studio. Let’s break down the first in the list, functional testing.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以上内容均无错误。我们将从上面的列表中解释的测试在几乎每个工作室都能看到。让我们先分解列表中的第一个，功能测试。
- en: Functional testing
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能测试
- en: Your testing started well before you got to this chapter. Every time you pressed
    play to check if a script did what it was supposed to do, you tested that script
    alongside the rest of the game. This is part of the iterative nature of game development
    and is also called functional testing.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你的测试在你到达这一章之前就已经开始了。每次你按下播放来检查脚本是否按预期工作，你都在与游戏的其他部分一起测试那个脚本。这是游戏开发迭代性质的一部分，也被称为功能测试。
- en: 'Functional testing has a very direct name! It’s testing for the game’s functions.
    A few examples of the scope of the functions being tested are:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试有一个非常直接的名字！它是测试游戏的功能。正在测试的功能范围的一些例子包括：
- en: Animation – Looking for animations that don’t work together or character rigs
    that are broken. This is carried out by testing mechanics and movements where
    the character animation is being transitioned to other animations.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画 – 寻找不兼容的动画或损坏的角色绑定。这是通过测试角色动画过渡到其他动画的机械和动作来完成的。
- en: Audio elements and quality – Listening intently for the purpose of hearing imperfections
    at specific times. Examples of this might be listening for footstep sounds that
    sound wrong, ambient noises for objects that aren’t there, and anywhere sound
    is incorrectly placed.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音频元素和质量 – 仔细聆听以在特定时间听到不完美之处。这类例子可能包括聆听听起来不正确的脚步声、不存在物体的环境噪音，以及声音放置不正确的地方。
- en: Cinematics – Playing through the cinematics to find any out-of-place sounds,
    visuals, animations, or timing of the entire cinematic.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电影场景 – 播放电影场景以查找任何不合适的声音、视觉效果、动画或整个电影场景的时序。
- en: Instructions or tutorials – There could be instructions on how to play the game.
    These instructions should be written properly and make sense to the controller
    scheme the player is using.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令或教程 – 可能会有关于如何玩游戏的说明。这些说明应该写得恰当，并且对玩家使用的控制器方案有意义。
- en: Mechanics interaction – Playing through all the mechanics to feel them out,
    checking to see if they are working as intended and can be completed if there
    is completion.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机械交互 – 通过体验所有机械操作来感受它们，检查它们是否按预期工作并且可以完成，如果存在完成条件的话。
- en: Sorting – This is a visual check dealing with transparency issues. Layers on
    the screen need to know their layer on the screen. Some effects and UI will have
    a hard time knowing what is on top to be sorted properly. This takes testing with
    multiple scenarios to ensure that the GameObjects with transparency are sorting
    properly.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分类 – 这是一个视觉检查，涉及透明度问题。屏幕上的图层需要知道它们在屏幕上的层级。一些效果和用户界面可能很难知道哪些在上面以便正确排序。这需要通过多种场景的测试来确保具有透明度的游戏对象能够正确排序。
- en: Usability – Usability has its own thread of work that can be tested, but in
    this case, we are looking for controller schemes that make sense and work. An
    example is the **A** button being used for a jump; this is so common that if something
    else is used, it would need to be explained thoroughly as to why.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户体验 – 用户体验有其独立的工作线程，可以进行测试，但在这个案例中，我们寻找的是合理且有效的控制器方案。例如，**A** 按钮用于跳跃；这是如此常见，以至于如果使用其他按钮，就需要彻底解释为什么这样做。
- en: UI (menu structure, resolution, aspect ratio, font sizing) – The user interface
    needs to be checked thoroughly for many parts. How does it look when it’s scaled?
    Do the colors look correct? Can you understand how the menu flows? Every small
    problem that pops up will be seen by the majority of users. They need to be documented
    to be fixed.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面（菜单结构、分辨率、纵横比、字体大小） – 用户界面需要彻底检查许多部分。缩放后看起来如何？颜色是否正确？能否理解菜单的流程？任何出现的小问题都会被大多数用户看到。这些问题需要被记录下来以便修复。
- en: As you can see, functional testing is thorough and needs to be iterated on to
    make sure that the game’s functions all make sense to the player and work properly.
    When you’re playing the game to test a single mechanic, this is a great practice,
    but it is only checking out that mechanic in a bubble. The rest of the game could
    potentially be affected by the changes you are making. Strong functional testing
    done early and often will make your project that much cleaner and more positive
    in the end.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，功能测试是彻底的，并且需要迭代以确保游戏的所有功能对玩家都有意义并且工作正常。当你玩游戏来测试单个机制时，这是一个很好的实践，但它只是在孤岛中检查那个机制。游戏的其他部分可能会受到你所做更改的影响。早期和经常进行强有力的功能测试将使你的项目最终更加干净和积极。
- en: While working through functional testing, you may encounter hitches in rendering,
    making the framerate low. If this happens, take note and add it to the list of
    performance testing that will be done as well. Since we’re on the topic, let’s
    go into how to performance test in Unity.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行功能测试时，您可能会遇到渲染中断，导致帧率降低。如果发生这种情况，请注意并将其添加到将要进行的性能测试列表中。既然我们提到了这个话题，让我们来看看如何在Unity中进行性能测试。
- en: Performance testing
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能测试
- en: 'Inside Unity, we have four sources of analysis:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity内部，我们有四个分析来源：
- en: Unity Profiler
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity性能分析器
- en: Memory Profiler
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存性能分析器
- en: Frame debugger
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帧调试器
- en: Physics debugger and Profiler
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理调试器和性能分析器
- en: All four of these analysis tools have their own specific uses to help define
    what might be causing an issue. We will go through them to a basic degree to get
    familiar with each one. Starting off, we need to go over the most commonly used
    one, Unity Profiler.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个分析工具都有它们自己的特定用途，以帮助确定可能引起问题的原因。我们将简要介绍它们，以便熟悉每个工具。首先，我们需要了解最常用的一个，即Unity性能分析器。
- en: Unity profiler
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Unity性能分析器
- en: 'To perform profiling, you will need to use Unity’s analyzing tool, the Profiler,
    which looks as in *Figure 11.3* below:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行性能分析，您需要使用Unity的分析工具，即Profiler，其外观如下所示**图11.3**：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B17304_11_03.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成描述](img/B17304_11_03.png)'
- en: 'Figure 11.3: Unity’s Profiler window example'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**图11.3**：Unity性能分析器窗口示例'
- en: 'The profiling tool helps with identifying CPU use, memory usage, and rendering
    time. When you open the Profiler by going to **Window** > **Analysis** > **Profiler,**
    you will see four sections, as displayed in *Figure 11.3* above. The four sections
    are:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析工具有助于识别CPU使用情况、内存使用情况和渲染时间。当您通过**窗口**>**分析**>**性能分析器**打开性能分析器时，您将看到四个部分，如上图中**图11.3**所示。这四个部分是：
- en: (Red) Profiler modules – This section contains what profile modules are in use
    and has colors to show what is taking place when the recording of the Profiler
    starts.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （红色）性能分析模块 – 此部分包含正在使用的性能分析模块，并使用颜色显示性能分析开始记录时的活动情况。
- en: (Orange) Profiler controls – These controls are for setting up what the Profiler
    is doing. Here you can start recording and change modes or the Profiler tool.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （橙色）性能分析控制 – 这些控制用于设置性能分析器正在执行的操作。在这里，您可以开始记录并更改模式或性能分析工具。
- en: (Yellow) Frame charts – This shows the individual frames as a stacked chart
    over time and curves for rendering passes.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （黄色）帧图表 – 这显示了随时间堆叠的图表和渲染过程曲线的各个帧。
- en: (Green) Module details panels – The module details panels explain every section
    of the selected frame broken down over a percentage of use on the thread requested.
    **Default** is the main thread.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （绿色）模块详细信息面板 – 模块详细信息面板解释了所选帧的每个部分，并按请求的线程的使用百分比分解。**默认**是主线程。
- en: As an example, in the profile below in *Figure 11.4*, we have a frame selected
    while playing our game; I recorded 7800 frames while moving Myvari around. You
    can see that we’re currently running close to 60 frames per second. I wanted to
    know what was taking the most CPU time from the **PlayerLoop** — in this case,
    it was the game being played in the editor at ~80%. Scrolling down the **PlayerLoop,**
    we see that the forward renderer is the heaviest task on the main thread. There
    is not a lot going on currently in the scene, which is why we’re running an average
    of 60 FPS.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下面的**图11.4**中，我们在玩游戏时选择了帧；我在移动Myvari时记录了7800帧。您可以看到我们当前每秒运行接近60帧。我想知道**PlayerLoop**中占用最多CPU时间的是什么——在这种情况下，是编辑器中运行的游戏，大约占80%。向下滚动**PlayerLoop**，我们看到前向渲染器是主线程上最重的任务。场景中目前没有太多活动，这就是为什么我们平均每秒运行60帧。
- en: '![Graphical user interface  Description automatically generated](img/B17304_11_04.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面  自动生成描述](img/B17304_11_04.png)'
- en: 'Figure 11.4: Profiler with frame selected'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**图11.4**：已选择帧的性能分析器'
- en: You can see how much information comes along with the Profiler. This is fantastic
    information when you want to see what might be causing your game to have a lower
    framerate.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到性能分析器附带了多少信息。当您想查看可能造成游戏帧率较低的原因时，这些信息非常宝贵。
- en: Memory Profiler
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存性能分析器
- en: This tool, as expected, profiles the memory of the editor. You can also run
    the memory profiler on a standalone build if **Development Build** is selected
    in the **Build Settings** menu. The limitation here is that you cannot run the
    memory Profiler on a release build, just as with the Unity Profiler we saw previously.
    The Memory Profiler also isn’t automatically added to the Unity project. It is
    a package that can be added. To add it, follow along below.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，这个工具分析了编辑器的内存。您还可以在**构建设置**菜单中选择**开发构建**时在独立构建上运行内存分析器。这里的限制是您不能在发布构建上运行内存分析器，就像我们之前看到的Unity分析器一样。内存分析器也不是自动添加到Unity项目中的。它是一个可以添加的包。要添加它，请按照以下步骤操作。
- en: 'To add the Memory Profiler, go to your **Package Manager** and add a package
    by name. This can be done by selecting the options as shown in *Figure 11.5* and
    then adding `com.unity.memoryProfiler` to the **Add package by name** field:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加内存分析器，请转到您的**包管理器**并按名称添加一个包。这可以通过选择如图11.5所示的选项，然后将`com.unity.memoryProfiler`添加到**按名称添加包**字段中完成：
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B17304_11_05.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序、聊天或文本消息  自动生成描述](img/B17304_11_05.png)'
- en: 'Figure 11.5: (Left) Add package by name, (right) Adding the Memory Profiler'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5：（左）按名称添加包，（右）添加内存分析器
- en: When it’s installed, you can access the Memory Profiler by going to **Windows**
    > **Analysis** > **Memory Profiler**. When it first loads, you will see a blank
    middle section with an option to create a snapshot. If you press play and then
    take a snapshot, you will get a similar screen to what we have here. There is
    a large amount of info to go over within this Profiler. The primary use of this
    is if you have a low framerate and you want to check memory usage or if during
    a soak test you are seeing crashes. You can see, through multiple snapshots in
    time, what memory is being used.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，您可以通过转到**Windows** > **分析** > **内存分析器**来访问内存分析器。当它首次加载时，您将看到一个空白的中部区域，并有一个创建快照的选项。如果您按下播放并然后拍摄快照，您将得到与我们这里相似的屏幕。在这个分析器中有很多信息需要查看。这个的主要用途是如果您有低帧率并且想要检查内存使用，或者在长时间测试期间看到崩溃。您可以通过多个时间点的快照看到正在使用的内存。
- en: '![Graphical user interface  Description automatically generated with low confidence](img/B17304_11_06.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面  自动生成描述，置信度低](img/B17304_11_06.png)'
- en: 'Figure 11.6: Memory Profiler'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6：内存分析器
- en: While looking at a snapshot, the center area breaks down all the memory in that
    snapshot. In the bottom area, there are blocks of everything used in groups. You
    can select the groups to break them down even further. We did this to the bottom
    mauve-colored block, which is used to display `Texture2D`. We already knew that
    this would have? a large memory footprint as it’s the texturing for all the architecture.
    It needed to be fairly large.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看快照时，中心区域会分解该快照中的所有内存。在底部区域，有用于组内的一切的块。你可以选择组来进一步分解它们。我们这样做是为了底部的紫色块，它用于显示`Texture2D`。我们已经知道这会有一个很大的内存占用，因为它是所有架构的纹理。它需要相当大。
- en: If the memory looks as you expected, then it may be a good idea to look at the
    frame debugger to check what could be loading in specific frames that could cause
    issues. Let’s look into that tool next.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内存看起来符合您的预期，那么查看帧调试器以检查可能引起问题的特定帧中加载了什么可能是个好主意。让我们接下来看看这个工具。
- en: Frame debugger
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 帧调试器
- en: Being able to see an individual frame and how the draw calls were constructed
    to give you the rendering of that frame can be very helpful for debugging visual
    artifacts. You may have used this when you were doing functional testing and found
    sorting issues. You can now load the frame debugger up and see when each item
    was rendered. From this point, you will have the knowledge to be able to work
    through why it was rendered in the wrong order.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 能够看到单个帧以及如何构建绘制调用以提供该帧的渲染，这对于调试视觉伪影非常有帮助。您可能在使用功能测试时使用过它，并发现了排序问题。现在您可以加载帧调试器并查看每个项目何时被渲染。从这个点开始，您将拥有知识来了解为什么它以错误的顺序被渲染。
- en: '![Text  Description automatically generated](img/B17304_11_07.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![文本  自动生成描述](img/B17304_11_07.png)'
- en: 'Figure 11.7: Frame debugger'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7：帧调试器
- en: Another strong feature of the frame debugger is that you are able to see what
    Shader properties were set on the item that was being rendered, as shown in *Figure
    11.7* above. This is useful as when you are setting Shader properties procedurally,
    you may have an expectation of the Shader properties using certain textures of
    variables. If they aren’t as expected, then it would be a great idea to check
    out the frame and see what it is set to. This could lead to finding out that for
    one frame it was set to what you expected but then overridden. This could help
    lead you to the right script that is changing your Shader properties a frame or
    two after your expected values are being set.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 帧调试器的另一个强大功能是您可以看到渲染项上设置了哪些Shader属性，如上图中*图11.7*所示。这很有用，因为当您以程序方式设置Shader属性时，您可能期望Shader属性使用某些纹理或变量。如果它们不符合预期，那么检查帧并查看其设置将是一个很好的主意。这可能导致发现对于一帧，它被设置为预期的值，但随后被覆盖。这可能会帮助您找到在预期值设置后一帧或两帧更改您的Shader属性的脚本。
- en: Physics debugger and Profiler module
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 物理调试器和分析模块
- en: For physics, we have both a debugger and a Profiler module. The physics debugger
    is a visualization tool to know what physics collisions are in the scene and what
    they should or should not be able to collide with. As you saw in *Chapter 7*,
    *Rigid Bodies and Physics Interaction*, the Rigidbody is complicated in its optimization
    settings for physics properties. Being able to visualize what type of collider
    is on what and where is a great help to knowing what objects are doing when and
    why. In *Figure 11.8* below, you can see in the scene which objects are physics
    objects.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于物理，我们既有调试器也有分析模块。物理调试器是一个可视化工具，用于了解场景中有什么物理碰撞以及它们应该或不应该能够与之碰撞。如您在*第7章*，*刚体和物理交互*中看到的，刚体在物理属性的优化设置中很复杂。能够可视化哪种类型的碰撞器在哪里，以及它们在哪里，对于了解物体何时以及为什么这样做非常有帮助。在下图中，您可以看到场景中哪些对象是物理对象。
- en: 'Opening the **Colors** section of the physics debugger will allow you to colorize
    them according to what you might need to debug:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 打开物理调试器的**颜色**部分，您可以根据需要调试的内容对它们进行着色：
- en: '![Graphical user interface  Description automatically generated](img/B17304_11_08.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面  自动生成的描述](img/B17304_11_08.png)'
- en: 'Figure 11.8: Physics Debugger'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8：物理调试器
- en: After you have identified any physics issues from the GameObjects visualized
    by the physics debugger we have another tool to gather more information. Fortunately
    for us, we also have the physics Profiler module to be able to help us with any
    physics issues that are being visualized so we can look up the issue. The physics
    Profiler module is in the Unity Profiler and will help find answers to the physics
    discrepancies you may see when the debugger is on.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在您通过物理调试器识别出由GameObject可视化的任何物理问题时，我们还有另一个工具来收集更多信息。幸运的是，我们还有物理分析模块，可以帮助我们处理任何正在可视化的物理问题，以便我们可以查找问题。物理分析模块位于Unity分析器中，将帮助您找到当调试器开启时可能看到的物理差异的答案。
- en: 'To see what the physics Profiler module looks like, see *Figure 11.9* below:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看物理分析模块的外观，请参见下图的*图11.9*：
- en: '![Graphical user interface, chart  Description automatically generated](img/B17304_11_09.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，图表  自动生成的描述](img/B17304_11_09.png)'
- en: 'Figure 11.9: Physics Profiler module'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9：物理分析模块
- en: The use of this may not be understood at this point as we don’t have a case
    with our physics mechanics to show a direct problem. We don’t have fast-moving
    items that can cause a lot of physics issues. If your game does have fast-moving
    objects, when you are recording your Profiler and noticing GameObjects clipping
    through other GameObjects when they shouldn’t, this module would be good to see
    the total memory used. It’s possible that the memory being used is not allowing
    for the physics to update fast enough to get the active body information.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您可能不会理解这一点，因为我们没有与我们的物理力学相关的案例来展示直接的问题。我们没有快速移动的项目，这可能导致许多物理问题。如果您的游戏确实有快速移动的对象，当您记录分析器并注意到GameObject在它们不应该时穿过其他GameObject时，这个模块会很好，可以看到使用的总内存。可能使用的内存不允许物理更新得足够快，以获取活动体信息。
- en: Physics debugging can take time to get to an answer as this needs to happen
    while the physics work is taking place. Be patient with this debugging and use
    as many tools as possible to get the answer you need.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 物理调试可能需要时间才能得到答案，因为这需要在物理工作正在进行时发生。对此调试要有耐心，并尽可能使用更多工具来获取您需要的答案。
- en: Now that we’ve gone over all of the debugging tools, we need to test the game
    with others outside of our team. This is called playtesting. Let’s get the game
    into others’ hands.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了所有的调试工具，我们需要用我们团队之外的人来测试游戏。这被称为游戏测试。让我们把游戏交给其他人来玩。
- en: Playtesting
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏测试
- en: This is a difficult problem to assess. At first, it may be a good idea to test
    internally with you and your team, friends, and allies. You ask them to play the
    game and see how they feel about it. This is not meant to build your ego. You
    need to be there when they are playing and ask them to speak out loud about how
    they feel about the experience. Do not prompt them on anything. You want them
    to give you genuine feelings and if they speak to the intended experience, you’re
    on the right track.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个难以评估的问题。起初，对你和你的团队、朋友和盟友进行内部测试可能是个好主意。你让他们玩游戏，看看他们对它的感受如何。这并不是为了建立你的自尊。当他们玩游戏时，你需要在场，并要求他们大声说出他们对这次体验的感受。不要对他们进行任何提示。你希望他们给你真实的感受，如果他们针对预期的体验进行交流，你就走上了正确的道路。
- en: Even if the game’s art isn’t in place and the menu systems are blocky objects
    with Arial font placeholding for later, none of that detracts from the core game
    experience. One example is the visceral response when someone enters the first
    emotional touchpoint you want to evoke. For our project, we want to give a sense
    of wonder. This is close to confusion, so we need to be deliberate in placement
    and light usage to encourage adventuring on the player’s terms. If they say things
    such as, “I wonder what’s over there,” we are leaning into that sense of wonder.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 即使游戏的艺术设计尚未到位，菜单系统是带有Arial字体占位符的方块物体，这些都丝毫没有减损核心游戏体验。一个例子是，当有人进入你想要激发的第一个情感触点时，产生的直观反应。对于我们项目来说，我们想要给人一种惊奇感。这接近于困惑，因此我们需要在放置和光线使用上谨慎，以鼓励玩家按照自己的意愿冒险。如果他们说诸如“我想知道那里有什么”之类的话，我们就是在追求那种惊奇感。
- en: At the same time, they may say that same sentence, but you didn’t have anything
    planned. Let them explore wherever they thought there might be something and take
    note. It would be a good idea to put something there. Allow that inherent wonderment
    to take your design further than you have already gone. It almost doesn’t matter
    what would be there if there is a kind of interaction. An example of this is an
    area that has nothing to do with the narrative that’s off to the side just slightly,
    being available to move into. When testers move into spots on the map that you
    don’t expect them to, take that as an opportunity for engagement. You could build
    it up as a scenic view. When you walk over there, the camera pans out a bit to
    take in the view. This isn’t an addition to the story, but the sense of wonder
    was fulfilled. Something happened when you explored.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，他们可能会说出同样的句子，但你并没有计划任何内容。让他们探索他们认为可能存在的地方，并做好笔记。在那里放置一些东西是个好主意。让那种固有的好奇心将你的设计推进到你已经达到的范围之外。如果存在某种互动，那么那里有什么几乎无关紧要。一个例子是，一个与叙事无关的区域稍微偏离一侧，可供进入。当测试者进入你预料之外的地图上的位置时，把这视为一个互动的机会。你可以把它建成一个风景点。当你走过去时，摄像头会稍微向外移动，以摄入景色。这不是故事的补充，而是实现了对好奇心的满足。当你探索时，发生了某些事情。
- en: Exploration may not be a large portion of your game; maybe your title is a socially
    focused experience. The need for interaction is high for any player that is inside
    a multiplayer game. In what ways can you interact with your friends when playing
    together? An extremely good example of this is FromSoftware’s multiplayer interaction
    system. The social interaction in FromSoftware’s game — for example *Elden Ring*
    — allows you to leave short messages with specific words, but you can also use
    emotes and the message will play your character as a ghost with your small message
    and the emote. This allows interaction with the emotes that you may have found.
    This is a very interesting way to allow interaction within a game that is defined
    by its ability to make you feel alone and weak.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 探索可能不是你游戏的大部分内容；也许你的标题是一个以社交为中心的体验。在多人游戏中，任何玩家都需要高度互动。当你们一起玩游戏时，你们如何与朋友互动？一个极好的例子是FromSoftware的多人互动系统。FromSoftware的游戏中的社交互动——例如*艾尔登法环*——允许你留下带有特定词语的简短信息，但你也可以使用表情符号，信息会播放你的角色作为幽灵，带着你的简短信息和表情符号。这允许你与可能找到的表情符号进行互动。这是在定义其让你感到孤独和脆弱的能力的游戏中允许互动的一种非常有趣的方式。
- en: After they are done playing, take all your notes and thank them for their time.
    You do not need to implement everything you wrote down from their test, but after
    you have five people test it, there will be trends. Take care of those trends
    first.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在他们玩完游戏后，记下所有笔记，并感谢他们花时间。你不需要实现他们测试中写下的一切，但当你有五个人测试它时，会出现趋势。首先关注这些趋势。
- en: Soak testing
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浸泡测试
- en: Soak testing isn’t an intuitive name. We aren’t going to dunk our computers
    into a bath; we will just let the game run for 24 hours idly. Your character is
    in the game, live, just sitting by itself while the game plays out. The reason
    for this is to attempt to bring out any possible memory leaks in the game.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 浸泡测试不是一个直观的名字。我们不会把我们的电脑浸入浴缸；我们只是让游戏闲置运行24小时。你的角色在游戏中，是活着的，只是独自坐着，游戏在进行。这样做的原因是为了尝试找出游戏中可能存在的任何内存泄漏。
- en: A memory leak is when there is some memory that isn’t being taken care of somewhere.
    Let’s say we have a particle that is falling from a tree for some nice ambiance.
    The particle is set to die, but an accidental couple of extra 0s were added so
    now instead of lasting for 10 seconds, it’s lasting for 1000 seconds. This might
    not be a problem when you are running around in the game as when you leave, the
    particles will get culled. But if you let the game idle, all the particle systems
    making leaves will pile up and several thousand leaves on the ground might cause
    performance to tank hard. This would need fixing, and wouldn’t have been possible
    without soak testing.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏是指某些没有被妥善处理的内存。比如说，我们有一个粒子从树上落下，营造一些美好的氛围。粒子被设置为死亡，但是不小心多加了几个额外的0，所以现在它不是持续10秒，而是持续1000秒。当你游戏中四处跑动时，这可能不是问题，因为当你离开时，粒子会被清除。但是如果你让游戏闲置，所有制造树叶的粒子系统都会堆积起来，地面上可能堆积数千片树叶，这可能会导致性能大幅下降。这需要修复，而且没有压力测试是无法实现的。
- en: Localization testing
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地化测试
- en: Localization is the act of translating the game to be experienced in another
    language. This test can take longer than expected and you need to be patient.
    Every menu item, dialogue line, and description needs to be considered for this
    testing portion. Translation also isn’t just a word-for-word explanation. Some
    languages require more context for their descriptions, which can lead to very
    confusing translations if not paid close attention to.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化是将游戏翻译成另一种语言以供体验的行为。这个测试可能比预期的要长，你需要有耐心。每个菜单项、对话行和描述都需要考虑这个测试部分。翻译也不只是逐字逐句的解释。一些语言需要更多的上下文来描述，如果不仔细注意，可能会导致非常混乱的翻译。
- en: When localizing a game, take care not to rush this process. It can completely
    throw off another culture’s experience, which would be a shame!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地化游戏时，要注意不要仓促行事。这可能会完全破坏另一种文化的体验，这将是件遗憾的事！
- en: User experience, or UX
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户体验，或UX
- en: UX can be defined as the sum of the parts within branding, design, and usability.
    For our part, we will briefly cover how branding plays its part in the UX role.
    We will then speak about design only a little bit as we’ve covered design for
    the fundamental parts of this project already. After we cover those quickly, we
    can then move into usability. Let’s go for it!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: UX可以被定义为品牌、设计和可用性中各个部分的和。就我们而言，我们将简要介绍品牌在UX角色中的作用。然后我们将只简单谈谈设计，因为我们已经覆盖了该项目基本部分的设计。在快速覆盖这些内容之后，我们就可以进入可用性部分。让我们开始吧！
- en: Branding
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 品牌
- en: To cover this broadly, branding through a UX lens is about how the overall experience
    the user will take through the journey of the game will need to also be reflected
    in the branding. For an overly contrasted example, think about if a horror game
    ‘s branding used soft tones and pastels with flowers and happy music as their
    marketing material. This obviously doesn’t fit the branding of the game and will
    cause dissonance in the user’s experience.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了广泛地涵盖这一点，通过UX视角的品牌化是关于用户在整个游戏旅程中体验的整体体验也需要在品牌中反映出来。用一个过于对比的例子来说，想想如果一个恐怖游戏的品牌使用了柔和的色调和粉彩，以及花朵和欢快的音乐作为他们的营销材料。这显然不符合游戏的品牌，会在用户的体验中造成不和谐。
- en: The purpose and point of UX as a defined part of development is that deliberate
    cohesive actions are paid attention to. The time spent on UX should ensure that
    all the designed parts, including the logo, marketing material, and the game parts,
    are part of a whole, unified experience.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: UX作为开发中定义的一部分的目的和要点是，要关注那些有意识的、连贯的行动。在UX上花费的时间应该确保所有设计部分，包括标志、营销材料和游戏部分，都是整体统一体验的一部分。
- en: Design
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计
- en: We’ve covered a lot of design in this book so far. Interestingly, we’ve covered
    all of our design in a bit of a siloed manner. Sometimes this can cause an issue,
    but luckily for our project we really focused this game on the character design.
    The rest of the design was built around the past of her race, which provided answers
    to questions for visual cues.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这本书已经涵盖了大量的设计。有趣的是，我们以一种相对封闭的方式涵盖了所有的设计。有时这可能会引起问题，但幸运的是，对于我们的项目，我们真正专注于角色设计。其余的设计都是围绕她种族的过去构建的，这为视觉提示提供了答案。
- en: The pacing of the game is dealt with through the style of gameplay and mechanics
    being focused on environmental narratives. With those three parts combined, it
    turned out to be a cohesive project already. This does a good job of validating
    the time we spent on design within every part. Good job sticking with it!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的节奏是通过游戏风格和机制专注于环境叙事来处理的。结合这三个部分，它已经是一个统一的项目了。这很好地验证了我们在每个部分上所花费的时间。做得好，坚持下来！
- en: Usability
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可用性
- en: After you’ve hooked a user through your exquisite branding and intelligent and
    cohesive design, they should be able to use the product. For games, usability
    is all focused on interactions. This shouldn’t be much surprise as we’ve defined
    this as a pillar for experience in *Chapter 6*, *Interactions and Mechanics*.
    We’ve worked through overall interaction with the player; however, there is no
    defined affordance. We need to work through how the player knows they can perform
    the interactions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过您精美的品牌和智能而统一的设计吸引用户之后，他们应该能够使用该产品。对于游戏来说，可用性全部集中在交互上。这不应该让人感到惊讶，因为我们已经在*第6章*，*交互和机制*中将其定义为体验的支柱。我们已经与玩家进行了整体交互；然而，没有定义便利设施。我们需要弄清楚玩家如何知道他们可以执行这些交互。
- en: We will go over the major portions of the vertical slice here, starting with
    the initial problem of getting to the first puzzle, then moving on to the first
    puzzle itself. After that, we need to bring about how the next mechanic, telekinesis,
    will be introduced, and then lastly the final puzzle.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里概述垂直切片的主要部分，从到达第一个谜题的初始问题开始，然后转到第一个谜题本身。之后，我们需要介绍下一个机制——心灵感应，最后是最后一个谜题。
- en: Initial problem
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始问题
- en: 'Within the starting cave section, we have a blocked stairway where the player
    needs to interact with two objects to unlock. There are several things we will
    use to give affordance to the player, so they know how to perform the needed task:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在起始洞穴部分，我们有一个被封锁的楼梯，玩家需要与两个物体交互来解锁。我们将使用一些东西来给玩家提供便利，让他们知道如何执行所需的任务：
- en: Light pooling
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光池
- en: Worldspace UI
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 世界空间UI
- en: Satisfy the action
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 满足动作
- en: Light pooling is a small part of environment or level design that allows the
    player to feel as though they should be heading in that direction. If a tunnel
    is dark and there is a light at the end, the player will tend to head toward that
    light. We can use this method to have glowing objects or lights near a button
    that needs to be pressed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 光池是环境或关卡设计的一个小部分，它让玩家感觉他们应该朝那个方向前进。如果一个隧道很暗，而隧道尽头有光，玩家往往会朝那个光走去。我们可以使用这种方法，在需要按下的按钮附近放置发光的物体或灯光。
- en: Now that they are near it, when they mouse near enough, we will pop up a worldspace
    UI for interaction. This button should be the same as every other interaction
    of this type. For this game, our interaction is the *E* key on the keyboard.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在他们已经接近了，当鼠标靠近足够近时，我们将弹出世界空间UI以进行交互。这个按钮应该与其他此类交互相同。对于这款游戏，我们的交互是键盘上的*E*键。
- en: After you use the interactive button, there needs to be something that satisfies
    the use of that action. In this case, it’s a button in a rock. It will animate
    to set itself in place, glow from being used, and trigger a sound to fully indicate
    that the user used their affordance.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用交互按钮之后，需要有一些东西来满足该动作的使用。在这种情况下，它是一个岩石中的按钮。它将动画化以放置到位，发光以表示使用，并触发一个声音来完全指示用户已经使用了他们的便利设施。
- en: First puzzle
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一个谜题
- en: 'When you first come up to the first puzzle, it may not be immediately understood
    that the player’s purpose is to move the stones into a position. We used one primary
    key usability feature, among others which will seem similar. Let’s list them out
    again:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次来到第一个谜题时，可能不会立即理解玩家的目的是将石头移动到某个位置。我们使用了一个主要的关键可用性功能，以及其他一些看起来相似的功能。让我们再次列出它们：
- en: Light pooling
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光池
- en: Hero art piece
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英雄艺术品
- en: Worldspace UI
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 世界空间UI
- en: Camera positioning (the key factor previously mentioned)
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摄像机定位（之前提到的关键因素）
- en: Satisfy the action
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 满足动作
- en: We previously went over light pooling as a concept for positioning. In this
    case, we will be using light pooling to draw visual attention to a place to move
    to. The thing to look at is the door as it has the answer to the puzzle laid out
    in front of you.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经讨论了光池化作为定位的概念。在这种情况下，我们将使用光池化来吸引视觉注意力到一个移动的地方。要注意的是门，因为它在你面前展示了谜题的答案。
- en: The art piece we are light pooling to is the answer to the puzzle. It’s directly
    placed at the next position you are headed and right in front of you when you
    exit the stairs, and it’s lit up. There is no barrier to entry on what you should
    be looking at when you get to the top of the stairs. That is what we like to do
    for our players. Let them get a feel for exploration but know they are looking
    at the right place when they do.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们光池化的艺术品是谜题的答案。它直接放置在你即将前往的下一个位置，当你从楼梯出来时，它就在你面前，并且是亮的。当你到达楼梯顶部时，没有障碍阻止你看到你应该看的地方。这就是我们为玩家所做的事情。让他们感受到探索的乐趣，但当他们这样做时，知道他们正在看对的地方。
- en: Our worldspace UI is the same as before, but we are using it to let the player
    know they can interact with the puzzle piece when they get close to the moveable
    pieces.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的世界空间用户界面与之前相同，但我们使用它来让玩家知道当他们靠近可移动部件时可以与之交互。
- en: The key factor to moving in the next section is the camera movement. When you
    enter the space of the puzzle, the camera will gently move up to a position that
    will represent the successful movement of the pillars in coordination with the
    art piece on the door when you first entered.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节移动的关键因素是摄像机移动。当你进入谜题的空间时，摄像机将缓缓上升到一个位置，这将代表当你第一次进入时，与门上的艺术品协调的柱子成功移动的位置。
- en: After the player moves the pillars into position, there are loud sounds of rocks
    being put into place and connections of what might sound like a large lock tumbler
    falling into place. When the final pillar is in place, the entire piece moves
    into the finalized complete position and the camera moves back to their shoulder
    while a pillar rises in the middle to allow the player to press the “door open”
    button.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家将柱子移动到正确位置后，会听到岩石被放置到位的巨大声响，以及可能听起来像大锁芯落下的连接声。当最后一个柱子到位时，整个部件会移动到最终完成的位置，摄像机也会移回玩家的肩膀位置，同时中间的柱子升起，以便玩家按下“开门”按钮。
- en: Introduction to a secondary mechanic
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二级机制介绍
- en: We’ve been explaining players’ affordances and how to get them to do the actions.
    You can add new mechanics without breaking the experience as long as you take
    care to introduce them in a deliberate manner. So far, Myvari has only been an
    explorer. We want her to have slight telekinesis powers from her ancient blood.
    We could just have them active and put something in her way, but that isn’t very
    fun, and the experience isn’t as strong.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在解释玩家的可用性和如何引导他们执行动作。只要你小心地以故意的方式介绍它们，你就可以在不破坏体验的情况下添加新的机制。到目前为止，Myvari只是一名探险者。我们希望她能从她古老的血液中获得轻微的心灵感应能力。我们只需让它们活跃并给她设置障碍，但这不是很有趣，体验也不够强烈。
- en: To get ourselves a new mechanic and hopefully draw the player into caring about
    our main character, what we will do is give two actions that at first don’t directly
    involve the player, but they do involve Myvari. The first thing that we will do
    is, while walking out in a thin area on the side of the mountain, we will have
    a large rock come tumbling down the mountain. There will be a cinematic that will
    happen where she will be alarmed, and she will defend herself by putting up her
    arm, which triggers her telekinesis just slightly, and she will maneuver the rock
    to the side slightly so that is crashes down the mountain instead of on top of
    Myvari herself.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给我们自己一个新的机制，并希望吸引玩家关注我们的主要角色，我们将采取两个最初不直接涉及玩家的动作，但它们确实涉及到Myvari。我们首先会做的是，当Myvari在山的一侧狭窄地带行走时，一块大石头将从山上滚落。将发生一个电影般的场景，她会感到惊慌，并抬起手臂自卫，这会稍微触发她的心灵感应能力，她将稍微调整石头，使其从山上滚落，而不是落在Myvari自己身上。
- en: Next, after some small exploration, the player will come across an area where
    they cannot enter the next area, but can see it. There is a pillar that looks
    like the one that opened the first door from the first puzzle, but it’s separated.
    We will use a new form of worldspace UI and when you hover over the broken piece,
    it will be outlined and the interact button will pop up. This outline will have
    a similar color to what was used when the telekinesis happened with the rock and
    when you interact with it, you will put your hand out and pick it up. It will,
    when close enough to the pillar, automatically fix itself, which triggers many
    visual changes to the area you are in.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在经过一些小范围的探索后，玩家会遇到一个他们无法进入的区域，但可以看到它。这里有一个柱子，看起来像第一个谜题中打开第一扇门的那个柱子，但它被分开了。我们将使用一种新的世界空间用户界面，当你悬停在破碎的部分上时，它会被勾勒出来，交互按钮会弹出。这个轮廓将与在心灵感应发生时用于岩石的颜色相似，当你与之交互时，你会伸出你的手并拿起它。当它靠近柱子足够近时，它会自动修复，这会触发你所在区域许多视觉上的变化。
- en: In conclusion, we are using small examples of telekinesis to introduce this
    slowly and in a way that befits the character. This is a good use of usability
    as the player gets to grow with the character. We can now take what we learned
    here and push it into the final puzzle, which uses this telekinesis as a primary
    mechanic.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们通过使用心灵感应的小例子来慢慢介绍，这种方式符合角色的特点。这是一个很好的可用性应用，因为玩家可以随着角色一起成长。现在我们可以将在这里学到的知识应用到最终的谜题中，该谜题将心灵感应作为主要的机制。
- en: Final puzzle
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终谜题
- en: It’s interesting how much effort it takes to make an experience strong! Those
    lead-up efforts for describing a mechanic are the glue that makes the experience
    a matter of immersion instead of just another button to press to make the character
    do something.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 制作一个强大的体验需要付出多少努力真是令人惊讶！那些描述机制的前期努力是使体验成为沉浸式体验而不是仅仅按下一个按钮让角色做某事的粘合剂。
- en: 'We now enter the final puzzle and there are similar means for player affordances
    that you’ve seen previously. We will use slightly different means as the items
    used in the mechanic are different, but the overall concept is driven by the environment.
    You will see these UX usability functions in the final puzzle area:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们进入了最后的谜题，这里有一些与之前看到的玩家操作手段相似的方法。我们将使用稍微不同的方法，因为用于机制中的物品不同，但整体概念是由环境驱动的。你将在最终的谜题区域看到这些用户体验功能：
- en: Light pooling
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光池
- en: Connection to the hero art piece
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与英雄艺术品的连接
- en: Worldspace UI
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 世界空间用户界面
- en: Satisfy the action
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 满足动作
- en: As always, we use lighting to help our players understand the next move subtly.
    There is a large light coming from behind our hero piece (main focus) tree, meaning
    it has narrative implications and needed more authored treatment, which shows
    a glow coming from each of the cables attached to the architecture. If you follow
    the cables, they flow through large pillars.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们使用光照来帮助玩家微妙地理解下一步行动。有一个大光从我们的英雄艺术品（主要焦点）树后面发出，这意味着它有叙事含义，需要更多的作者处理，这显示了从连接到建筑的每根电缆中发出的光芒。如果你跟随电缆，它们会流经大柱子。
- en: Those pillars are connected to the hero art piece, which is the central tree.
    The thing is that the pillars themselves are missing something. That something
    is on the ground in multiple locations around the tree’s area. Moving your mouse
    to look at these larger spherical objects shows you can interact with them.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 那些柱子与英雄艺术品（中心树）相连。问题是柱子本身缺少一些东西。那些东西就在树周围的多个位置的地面上。将鼠标移到这些较大的球形物体上，你会看到你可以与之交互。
- en: The interaction, in this case, is the worldspace UI. This is the outline that
    we already saw previously coming across the water bridge when we picked up the
    piece to complete the pillar. Picking up the object and moving it near the empty
    location with the same shape lights up the cables, which needs to be done in a
    certain order to get power to the tree. This is only slowed down by the character’s
    ability to notice some cabling is broken or not connected properly.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，交互是世界空间用户界面。这是我们之前在拿起部件完成柱子时跨越水桥时看到的轮廓。拿起物体并将其移到相同形状的空位附近，会点亮电缆，需要按照一定的顺序完成，以便给树供电。这只会因为角色能够注意到一些电缆损坏或连接不正确而减慢速度。
- en: Satisfying the action comes from the nice energy flowing from the cables toward
    the tree with each placement of the object. By the end, the tree will light up
    in a cinematic and open a section that reveals a tiara. Myvari grabs the tiara
    and places it on her head to unlock her place as the final princess of her ancient
    race.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 满足动作来自于每次放置物体时从电缆流向树木的流畅能量。最终，树木将亮起，以电影般的方式打开一个区域，揭示一顶王冠。Myvari 抓住王冠，戴在她的头上，解锁了她作为她古老种族最后一位公主的位置。
- en: This ends the vertical slice when the portal turns on from the completion of
    the puzzle and she walks through it, excited for the next step of the adventure.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当门户在完成拼图后开启，她兴奋地穿过它，这标志着垂直切片的结束。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You might be thinking, “what’s next?” This is a great question. You have a game
    that is built and has gone through some testing with some bug fixes. It’s a playable
    item in this case and could provide plenty of context to investors to continue
    the journey of getting a game funded or published.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，“接下来是什么？”这是一个很好的问题。你有一个已经制作完成并经过一些测试的游戏，其中包含了一些错误修复。在这种情况下，它是一个可玩的项目，并且可以为投资者提供足够的背景信息，以继续获得游戏资助或发布的旅程。
- en: What we will go over next are polishing techniques to try for beauty and UX
    to take the front seat. We’re calling these finishing touches as we know that
    the vertical slice is in a good state to add final touches to it only. Take some
    time in the next chapter to see all the tasks we can do to push our brand and
    quality into the game.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要讨论的是一些抛光技巧，旨在追求美观和用户体验。我们把这些最后的修饰称为“完成 touches”，因为我们知道垂直切片已经处于一个很好的状态，可以添加最后的修饰。在下一章中，我们将花时间查看所有可以推动我们的品牌和质量进入游戏的任务。
