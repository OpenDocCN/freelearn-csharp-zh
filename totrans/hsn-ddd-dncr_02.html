<html><head></head><body>
        

                            
                    <h1 class="header-title">Language and Context</h1>
                
            
            
                
<p>In the previous chapter, we discussed the importance of language briefly. In the software industry, we developed this naïve perception that the only languages that matter are programming languages. That's why we often speak complete gibberish and our colleagues from other departments, or our customers, have a hard time understanding what we're trying to say. This issue is mutual because many lines of business have developed their jargon, which other people might not completely understand.</p>
<p>In this chapter, we're going to go deeper into the importance of language and go through several examples of mockups and code. We'll also get into the concept of language in a context and introduce the Ubiquitous Language, one of the most critical aspects of <strong>Domain-Driven Design</strong> (<strong>DDD</strong>).</p>
<p>In this chapter, we'll go deeper into the following topics:</p>
<ul>
<li>Ubiquitous Language</li>
<li>Why language is important</li>
<li>Making implicit explicit</li>
<li>Language in context</li>
<li>Expressing behavior</li>
</ul>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Ubiquitous Language</h1>
                
            
            
                
<p>It isn't a coincidence that the website of Eric Evans, the author of the original DDD book, is located at <a href="http://domainlanguage.com">http://domainlanguage.com</a>. Fundamental concepts of DDD, such as Ubiquitous Language and Bounded Context, are both based on the idea of language. It might sound strange to those who haven't spent many years developing software because, for less experienced developers, the only language that's important is a programming language. We learn to program usually by studying some concepts and applying them to practice using one of the programming languages. We think that we can translate a human language into a programming language, and this is the essence of our work. There's some degree of truth there indeed. However, this is by far not the essential part of the developer's daily routine.</p>
<p>Two people can understand each other only if they can speak the same language. It doesn't necessarily need to be verbal; it might very well be sign language or the language of music. But both interlocutors need to share the same understanding of this universal language. Otherwise, there will be trouble. Not only do they need to speak the same language, but this language must be in one context. There's a whole book called <em>American and British English: Divided by a Common Language?</em> by Paul Baker, which describes how different the same language became after being split by the ocean for a long enough time.</p>
<p>In this section, we'll look deeper into the importance of language and the context in which these concepts are crucial for successful software projects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Domain language</h1>
                
            
            
                
<p>Nearly every industry has developed a particular language that only people from that industry fully understand. Some of those words spread out to the world, like the automotive world, which enriched our language with terms such as gearbox, ignition, combustion engine, and even body shop. The last term is ambiguous when being looked at outside of the domain. But as soon as the domain is specified, it becomes clear that we don't mean a beauty product boutique, nor a software outsourcing company, but a place where car bodies are being repaired after accidents.</p>
<p>Of course, the automotive industry isn't unique in this sense. Other industries have developed their terms, and their language might be much less known and more cryptic for outsiders.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>One of the examples of such an industry is, of course, the software industry. When two programmers discuss implementation details of some reasonably complex systems, non-programmers around them don't understand much of this conversation and usually get bored. Lack of understanding always results in a lack of interest:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/5486bbce-882b-4615-b491-8138cd1743d5.png" style="width:47.08em;height:29.67em;"/></p>
<p>The world, as seen by a programmer (based on the original work by Manu Cornet)</p>
<p>The software industry is, in a sense, unique because it tends to serve a variety of business problems within any other industry. Almost everything today requires or wishes for some degree of automation, and this means software. This also means that people from the business will come to their developers or external software companies and try to express their problems using their language. When this language isn't understood correctly, issues arise.</p>
<p>Functional requirements, written by dedicated professionals who are neither business people nor software developers, have been seen as the holy grail of successful software. Each time we reach an undesired outcome after the software is delivered to an unhappy customer, we blame requirements. We say—next time, we'll write better requirements and more detailed specifications and explain what developers need to do down to every single small detail. It can quickly become a blame game when everyone is pointing fingers to each other and no one is willing to be responsible for anything.</p>
<p>In addition to the points we were discussing in <a href="948b7834-c47c-4321-a91c-2ba58068c52e.xhtml" target="_blank">Chapter 1</a>, <em>Why Domain-Driven Design? </em>(in the <em>What went wrong with requirements?</em> section), one additional aspect is worth mentioning here. It's the language. Requirements not only focus on the solution and hide problems, but requirements also tend to <strong>translate</strong> business language to more technical language, which is seen as <strong>developer-friendly</strong>. In reality, this works more like a broken telephone. The more levels of translation that are being added to the transmission line, the less relevant information reaches the receiver without being disturbed beyond recognition.</p>
<p>One more aspect of such a <em>translation</em> is that it slows down communication. If developers require more information from the business but are unable to understand what the business means when they speak, the involvement of translators becomes unavoidable. Usually, these are the same people that write requirements, but not always. I've heard enough examples when only people such as enterprise architects are allowed to talk to customers; then, they translate their understanding to business analysis, who then throw requirements over the wall to poor developers, which are then literally lost in translation.</p>
<p>That's why understanding the business is significant for people who are working to create a good solution for real business problems. Being able to understand the business and communicate without a need for translations and translators not only shortens the communication time but also substantially improves the quality of such communication.</p>
<p>At the same time, we all know that business people, who usually play the customer role for the systems we create, are overall much less available as we would like them to be. You might end up having just a few session with people who actually possess the crucial information that you must obtain in order to make the system do what it should do. Sometimes they are even unwilling to take discussions with developers. It might be related to some personal issues, negative experience from the past or unconscious fear of looking silly in front of the bund of nerds.</p>
<p>In such cases, having a dedicated person, which is trusted by the business and speaks their language really helps. Our aim would be to ensure that this person is also trusted by the development team. You can call this role as a business analyst or a product owner, it doesn't really matter. The best people I know in this role are able to speak to everyone in their language, like the high-degree translators that work with world leaders behind their backs, being able to translate from one language to another without losing the meaning of things. At the same time, the best approach is still to avoid such a translation altogether.</p>
<p>For example, London City bankers are notorious for hiring developers who have already been exposed to banking and have ideally worked in the City before. They value their time and want to shorten the time spent on communication and discussions. Therefore, someone who has exposure to their language and shows a decent level of understanding of their business and their language is valued higher than someone else who might be a better developer but needs to be trained and get to know the language before really starting to work on real-life tasks.</p>
<p>Jargon terms are usually hard to grasp for outsiders since words that are being used are often everyday use words, but have an entirely different meaning. Some examples from the aforementioned financial domain are as follows:</p>
<ul>
<li><strong>Call</strong>: Short for a <strong>call</strong> option<em>,</em> this is a demand for payment of lent or unpaid capital</li>
<li><strong>Security</strong>: To attest the credit, the right to property, or the ownership of stocks or bonds that are related to tradable derivatives, this certificate is used<br/></li>
<li><strong>Swap</strong>: Among two borrowers, if each of them gain access to the required funds or a fixed interest is changed to floating, it's considered as swap</li>
</ul>
<p>Learning the domain language is crucial to establish effective communication between domain experts and developers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Sample application domain</h1>
                
            
            
                
<p class="mce-root">Throughout this book, we'll be developing a sample application to practice our gained knowledge and skills. In this section, you'll get an introduction to the business domain, and more details will be added later throughout this book.</p>
<p class="mce-root">The domain that we're going to be working on is selling stuff online for private individuals. We'll be building an application to publish classified ads and something that might be necessary to support this type of activity.</p>
<p class="mce-root">If you aren't familiar with the terminology, think about a bunch of stuff you have in your storage room or in the basement, which you would be delighted to remove. You can publish a small ad online, and other people might buy things that you no longer need. You can also give stuff away for free. Examples of such services are websites such as eBay, Craigslist, Gumtree, Marktplaats (the Netherlands), and FINN.no (Norway).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Making implicit explicit</h1>
                
            
            
                
<p>When we start working on a new system, we need to learn a lot. We discussed the paradox of ignorance in <a href="948b7834-c47c-4321-a91c-2ba58068c52e.xhtml" target="_blank">Chapter 1</a>, <em>Why Domain-Driven Design?</em>, and you might remember that the highest level of ignorance and thereby the lowest level of knowledge is when we make a lot of decisions about the future system.</p>
<p>We not only suffer a lack of knowledge about the business domain we're trying to solve problems for—we're also forced to work in an environment with a high level of ambiguity. Before we learn about the domain language, we use our understanding, which is often based on assumptions.</p>
<p>Imagine a situation where you come to a meeting with domain experts at the beginning of the project. They try to explain their problem, and you slowly begin to study their language and, at some point, you think you got the idea and more or less know what to do. Here, it's important to remember what we were going through in the previous chapter when we discussed cognitive biases and their influence on decision making. The first and the most obvious risk is that <strong>what you see is all there is</strong> (<strong>WYSIATI</strong>), or availability heuristics. You apply your limited knowledge to past experiences and then get the feeling of understanding. At this point, we're usually asked to make estimates and logically we fail, since biases play a trick on our minds and give the illusion of understanding.</p>
<p>At such meetings, we often agree on something. Then, everyone leaves the room to meet again and maybe discuss some specifications or even prototypes after a couple of weeks. Time passes by, we're still in the same room, and no one is pleased since, to our mutual dissatisfaction, we find out that we agreed on completely different things. Everyone had a picture in mind, and all those pictures were different.</p>
<div><img src="img/da7b2f76-711c-4ca2-a43d-6e035e46b02e.jpg" style="width:61.92em;height:20.83em;"/></div>
<p class="mce-root"/>
<p>We agree on different things if we don't visualize</p>
<p>People spend hours arguing about things they thought are different but are the same. People also agree on something that they don't share a common understanding about, and this never goes well.</p>
<p>To fix this, we need to remove assumptions. We need to make <em>implicit</em> things <em>explicit</em>.</p>
<p>Look at this sample form from a real-life HR management system. Here, an employee can request sick leave:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6ab13797-43ea-4757-af5b-b75123d1362b.png" style="width:19.17em;height:14.83em;"/></p>
<p>Sick leave registration form</p>
<p>Here, we can see a typical structure, which is created by a programmer. We could even imagine a SQL table where the data that's entered into this form gets stored. It most probably has the <kbd>StartDate</kbd>, <kbd>EndDate</kbd>, and <kbd>HalfDay</kbd> columns and the employee <kbd>id</kbd>. Notice that there's a Save button here too, which is very common to find in forms like this.</p>
<p>But despite the fact that this form might look okay, let's think a little bit more about what we see here. After spending a bit of time analyzing this form, we could see the following issues:</p>
<ul>
<li>The Start date is ambiguous. It might be the date when sick leave is registered, or it might also be the date when the employee didn't come to work because they got sick.</li>
<li>The End date is even more ambiguous because it might represent the last day of the sick leave, or the day when the employee came back to work.</li>
<li>The Half day might apply to both of those fields, but there's no clear indication of what it means.</li>
<li>Finally, the Save button gives us no clue about what will happen next. There might be just a record in a table, and we need to tell someone to look at it, or there might be an approval process that gets started automatically. Does the employee need to call or send an email to the line manager after filling out this form?</li>
</ul>
<p>As you can see, even in such a small form with two fields, one checkbox, and two buttons, many things are implicit. If we imagine the code behind this form, all those implicit and ambiguous concepts could be found there as well. I already mentioned a table that has columns that represent those fields in the form. All properties in the domain model classes, data model objects, and other code artifacts are equally implicit. Everything there demands an explanation, such as <em>this date means the day when an employee came back to work</em>, and without such an explanation. Things like reports could be just plain wrong.</p>
<p>Compare it with another example, also taken from a real-life HR management system, which was made by a competitor:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/8dfa5910-680a-4721-a05f-101c827b3ffa.png" style="width:22.83em;height:15.33em;"/></p>
<p>The sick leave registration form that makes sense</p>
<p>In this form, the fields make much more sense for regular people who don't need to solve puzzles or read the help to understand what to enter in these fields. Things that were made <em>implicit</em> in the first sample are <em>explicit</em> here. Everything, from naming individual fields to calls for actions, has a better meaning. We could also imagine that, behind this form, we can find code like this:</p>
<pre>SickLeaveApplication.Handle(new SendSickLeaveForApproval<br/>{<br/>    EmployeeId = context.User.EmployeeId,<br/>    DateRegistered = request.DateRegistered,<br/>    FirstDayNotAtWork = request.FirstDayNotAtWork,<br/>    LeftDuringWorkday = request.LeftDuringWorkday,<br/>    CameBackToWork = request.CameBackToWork,<br/>    CameBackAfterLunch = request.CameBackAfterLunch<br/>});</pre>
<p>This code expresses the same meaning and terminology as the user interface. So, not only will the end user have an easy time filling out this form, but also a fellow developer would be happy reading this code, where the intent is clearly expressed and all the concepts are explicit.</p>
<p>Another aspect of making implicit explicit is to create domain concepts that are visible in the code. In the preceding code, the <kbd>SendSickLeaveForApproval</kbd> command exhibits a precise domain concept in the code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Domain language for classified ads</h1>
                
            
            
                
<p>Our developers were discussing the flow of publishing classified ads. They went through the creation process and got to the point where the user clicks the Publish button. Together, with the domain expert, they discovered that ads couldn't be published immediately since an ad could contain malicious content. They decided to put in some approval process, which should take place after the user clicks Publish and the ad becomes visible on the website.</p>
<p>Developers quickly decided to create a property for their <kbd>ClassifiedAd</kbd> domain class, called <kbd>Status</kbd>. It should be an enum, which indicates different stages of the review and publication process. It could also be reused later for statuses that aren't yet known. Since they want to have behavior in their domain model, they added the <kbd>UpdateStatus</kbd> method to the class, which looks like this:</p>
<pre>public class ClassifiedAd<br/>{<br/>    private ClassifiedAdStatus _status;<br/><br/>    public void UpdateStatus(ClassifiedAdStatus newStatus)<br/>    {<br/>        _status = newStatus;<br/>        DomainEvents.Publish(<br/>            new ClassifiedAdStatusUpdated(_id, newStatus));<br/>    }<br/>}</pre>
<p>Now that the method also publishes a domain event, other parts of the system can subscribe to this event and do some other vital actions.</p>
<p>We will spend more time with domain events and commands later in this book. For now, the sample code uses domain events in the code to closely resemble events and commands we were using in the EventStorming chapter.</p>
<p>So, after the user clicks Publish, the following would happen:</p>
<pre>ad.UpdateStatus(ClassifiedAdStatus.Published);</pre>
<p>After the review is complete, the ad would be activated, like so:</p>
<pre>ad.UpdateStatus(ClassifiedAdStatus.Activated);</pre>
<p>It might seem acceptable. Our <kbd>ClassifiedAd</kbd> class is a state machine, where instances of this class move from one status to another through the life cycle of the ad. However, we already miss the intent. Our language becomes weird—instead of saying that we want to <em>publish</em> the announcement, we <em>update the status</em>. Instead of <em>activating</em> the ad, we <em>update the status</em> again!</p>
<p>Even if it all seems to work after some more behavior is added to the system, code like this will start to appear:</p>
<pre>public void UpdateStatus(ClassifiedAdStatus newStatus)<br/>{<br/>    if (newStatus == ClassifiedAdStatus.Published<br/>        &amp;&amp; (string.IsNullOrEmpty(_title)<br/>            || _price == 0 || string.IsNullOrEmpty(_text))<br/>        throw new DomainException(<br/>            "Ad can't be activated because some mandatory fields are empty");<br/><br/>    if (newStatus == ClassifiedAdStatus.Activated <br/>        &amp;&amp; _status == ClassifiedAdStatus.ViolationReported)<br/>        throw new DomainException("Reported ads can't be activated");<br/><br/>    if (newStatus == ClassifiedAdStatus.Deactivated<br/>        &amp;&amp; _status != ClassifiedAdStatus.ViolationReported)<br/>        throw new DomainException("Only a reported ad can be deactivated");<br/><br/>    _status = newStatus;<br/>    DomainEvents.Publish(new AdStatusUpdated(newStatus));<br/>}</pre>
<p>That isn't the code we expect to see in such a simple method. It takes too much responsibility, and the logical blocks in this method barely relate to each other. But things get worse when it gets to the domain event handling:</p>
<pre>public void Handle(ClassifiedAdStatusUpdated @event)<br/>{<br/>    // controlling the ad visibility based on it's reported status<br/>    if (_status == ClassifiedAdStatus.ViolationReported<br/>        &amp;&amp; @event.Status == ClassifiedAdStatus.MaliciousContentDetected)<br/>        CommandDispatcher.Send(<br/>            new UpdateAdVisibility(@event.Id, false));<br/>}</pre>
<p>The number of flow control operators is growing, and most of the behavior is now being driven by status updates, something that, in the beginning, was considered to be a small and concise operation on a single property of the domain object. The intent of this update operation is dissolved, and each call needs to be carefully controlled for side effects. The risk of damaging an existing behavior when adding new features is now genuine.</p>
<p>Discussions with domain experts also lost some meaning. Instead of using phrases such as <em>if the malicious content is detected, we hide the ad and inform our moderation group</em>, it becomes <em>and then we query all ads with the status equals</em> <kbd>MaliciousContentDetected</kbd> <em>and use the notification service to deliver a message to all users that have moderation rights</em>. The meaning of the language gets lost behind technical gibberish, mixed with generalized words such as <strong>status</strong> and <strong>message</strong>.</p>
<p>The team decides to refactor the code and use proper domain language instead. So, this is what they came up with:</p>
<pre>public class ClassifiedAd<br/>{<br/>    private ClassifiedAdStatus _status;<br/><br/>    public void Publish()<br/>    {<br/>        _status = ClassifiedAdStatus.Published;<br/>        DomainEvents.Publish(new ClassifiedAdPublished(_id));<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p>Now, we can also refactor the domain event handling to something like this:</p>
<pre>public void Handle(ClassifiedAdPublished @event) =&gt;<br/>    CommandDispatcher.Send(new ShowClassifiedAd(@event.Id));</pre>
<p>Then, to handle cases with malicious content, we can write the new event handler:</p>
<pre>public void ReportViolation(User reportedBy, string reason)<br/>{<br/>    _violationReports.Add(reportedBy, reason);<br/>    DomainEvents.Publish(new ViolationReported(reportedBy, reason));<br/>}<br/><br/>public void Handle(ViolationReported @even) =&gt;<br/>    CommandDispatcher.Send(new InformModerators(@event.Id, @event.Reason));<br/><br/>public void Handle(MalicionsAdDetected @event) =&gt;<br/>    CommandDispatcher.Send(new InformModerators(@event.Id, @event.Reason));</pre>
<p>Our small example also shows that the domain language can't be built by making a glossary with nouns. A misconception about collecting a lot of nouns in an extensive list and calling it a domain language definitely exists. But this isn't a happy path, and usually, it leads to something called an anemic model, which is considered an anti-pattern. Classes in anemic models only have properties, and properties are always named by nouns. But a no less important part of every domain is the behavior. Nouns express what the domain operates with, but verbs describe what's being done. Without verbs, our domain tends to be a set of magic actions when properties change values without any particular reason. But our preceding code clearly expresses the domain behavior by introducing verbs as part of the domain language. These verbs are precise, show the intent, and describe actions. They're used both in imperative style for activities and in the past tense when describing the history when we publish domain events from our code.</p>
<p>In the preceding example, we not only improve our code and brought a better understanding of what it does and what concepts are being present there, but we also discovered some new terms and concepts that our domain model would benefit from. We can start using this terminology when talking to domain experts and see whether they understand it. Sometimes, they might give developers strange looks, trying to understand their excitement because they knew this <em>new</em> concept already—its part of <em>their language</em>, and it was just never expressed in conversations between business and development people. Such breakthroughs not only make the code better and closer to the actual business model but also improve communication between developers and domain experts.</p>
<p>By making implicit things explicit, not only do we discover missing concepts in our code, but we also put them into our domain model. This part is essential because the language is used across the whole range of models—business and mental models, conceptual and visual models, and domain models in diagrams and code. This pattern of using the same concept and, in general, the same language across multiple levels of models in the system is called <strong>Ubiquitous Language</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Language and context</h1>
                
            
            
                
<p>In the introduction of this chapter, we already touched on the topic of linguistic differences in the same language. If one language is divided by some boundary, be it a geographical, national, or professional area, it starts to split. We used British and American English as an example before, but of course, there are more examples like this. Dutch language spoken in Belgium is often even referred to as a separate language, Flemish because it sounds different, but mainly because, for everyday objects and actions, different words are being used. The same can be observed for languages that evolve within professional groups where people develop jargon, and we've looked at some examples of this too.</p>
<p>These examples were presented here to demonstrate how important it is to define the precise meaning of words. Avoiding confusion is indeed one of the goals in order to find and identify Ubiquitous Language.</p>
<p>It's important to realize that Ubiquitous Language is only valid within a context. A different context is defined by a different language. There's a misconception that Ubiquitous Language is called <em>ubiquitous</em> because it's the single language for the whole business, organization, or domain. That isn't the case. It's ubiquitous not horizontally, but vertically. Each context might have its own language, but all layers in this context share one Ubiquitous Language—meetings with the business, models, code, tests, UI concepts, data structures, and so on.</p>
<p>Let's have a look at the classic example of the term <strong>Product</strong> being used in different contexts of the e-commerce domain:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e5a1c911-2b91-4b71-803c-17884a3d0a61.png" style="width:21.08em;height:18.33em;"/></p>
<p>Product in different contexts</p>
<p>Although we're operating in the same domain, clearly the term <strong>Product</strong> has a somewhat different meaning in each of the identified contexts:</p>
<ul>
<li><strong>Sales</strong>: For the salespeople, product means the sales price and maybe the margin. It's where the company earns money, and other properties of the product aren't that important.</li>
<li><strong>Purchasing</strong>: If we buy a product to resell, we're mostly interested in the purchase price, how many items of a given product the supplier has in stock, and how fast they can be delivered.</li>
<li><strong>Inventory</strong>: We're mainly interested in how many items we have in stock. If a specific item is out of stock, this context can keep the estimated date when it will be back in stock. Here, we probably also define some internal properties of the product, such as the item number.</li>
<li><strong>Warehouse</strong>: It needs to manage the space that's required to store products, so people in this context need to know when product batches arrive when shipments to customers take place, how products are packaged, and where they are stored.</li>
</ul>
<p>As you can see, although we have a popular term, such as <strong>Product</strong>, different departments in the same domain or organization really have very little shared interest and have more in-depth knowledge in their subset of properties of something that otherwise could be considered the same object.</p>
<p>Another good example would be the term <strong>policy</strong> in the insurance domain. It's a bit less well-known for people that don't work in insurance but, in general, we understand that people that sell insurance to us are mostly interested in money and in getting new customers. So, for them, the policy means new sales and money. When it comes to approvals, if we take vehicle insurance as an example, policy implies risk. Even after a policy is sold, there's a chance that the risk assessment department could request additional documentation and, after some internal checks, reject the policy. And finally, when it comes to the point of handling a claim on the existing policy, for the claim handling department, it's a cost since the insurance company loses money.</p>
<p>Both examples demonstrate that, even for the same domain, there's a different context where language changes and sometimes changes significantly. What happens if we keep using the same meaning of words across contexts? Well, things become much less explicit. The degree of ambiguity increases with each new context that we fail to identify and separate. It leads to unclear models and, as a result, to obscure code, where we need to clarify what we mean exactly when we use this and that word.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Mixing different contexts in one working environment also leads to something called <strong>context switching</strong>. In <em>Quality Software Management: Systems Thinking</em>, Gerald Weinberg suggested that an increasing number of projects that one individual works on leads to significant productivity loss due to context switching:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/fd0a33da-1a7f-4740-8a6f-308456ec8392.png" style="width:48.33em;height:34.00em;"/></p>
<p>Productivity loss due to context switching</p>
<p>Adding one more project to current tasks means 20% productivity loss. Hence, when the number of contexts reaches five, the amount of time spent on the actual work becomes tremendously low. Most of the time is then spent figuring out in which context the current task belongs.</p>
<p>It's not only valid for the project. You might know from experience that, for larger projects where generalization prevails over precision and unambiguity, the phenomena of context switching effects the performance just as much. In our <strong>product</strong> example, if we were to put all of the properties of different logical views of the product in one place, working with such an object would involve some additional effort of trying to understand which part of the product we're working on at the moment. So, despite this still being one thing, the hidden context switching and productivity will suffer.</p>
<p>Assuming that centralization and generalization are good things, many software systems create so-called God classes, such as <kbd>Customer</kbd> or <kbd>Product</kbd>, which contain all possible properties for all possible views of a physical object. In addition to context switching, there are more downsides to such an approach.</p>
<p>One is obviously that not all properties need to have value during a specific life cycle of such an object in the system. For example, the phased-out product has no features that are related to sales whatsoever. But since we have one class for everything, we must assign empty values to all of these properties. Such an approach leads to a high degree of confusion since we hardly understand why these properties are vacant—either there's a mistake in the system, or this is just a typical situation due to the object's state.</p>
<p>Another issue is that, inevitably, such classes attract a lot of dependencies. You've probably seen data models, which sometimes mimic <strong>domain models</strong>, where the whole complex system has one large SQL database where tables have many cross-references. We could imagine that things such as <kbd>Product</kbd> can be referenced by <kbd>Order</kbd><em>,</em> <kbd>ShoppingCart</kbd><em>,</em> <kbd>Catalogue</kbd><em>,</em> <kbd>Invoice</kbd><em>,</em> <kbd>PurchaseInvoice</kbd><em>,</em> <kbd>Return</kbd>, <kbd>CreditNote</kbd>, and so on. The model becomes tangled and very hard to maintain. Sometimes, it gets worse because referential dependencies are sometimes plain wrong. For example, it isn't correct to show an updated product description on some order from the past. The order should contain a snapshot of the purchased product as it was at the moment of purchase.</p>
<p>We've identified enough reasons for us to be cautious when it comes to forgetting about context when seeking language. Ubiquitous Language is always unambiguous, explicit, and context-specific. As soon as you sense or observe that the meanings of words start to change between different parts of the system, this should trigger an alarm in your head that you are probably crossing context boundaries.</p>
<p class="mce-root"><strong>Context emerges when discussing users</strong>. Developers love to think of people as users. This term is so ambiguous that it's almost guaranteed that we switch between different contexts when talking about users.</p>
<p>Getting back to our sample domain, the team developers discussed how their users would rate their deals. They thought that it could be useful if people could give a rating to each other, helping to build trust in the community. During the conversation, some of them noticed that they use the words <em>user</em>, <em>those who sell</em>, <em>seller</em>, <em>those who buy</em>, and <em>buyer</em> interchangeably. When the generic term <em>user</em> was used, it almost always required clarification: what role this user plays at that particular moment. At the same time, when they named their users as <em>buyers</em> and <em>sellers</em>, there was no ambiguity, and no further clarification was required.</p>
<p>After noticing this, the group decided that they discovered new elements of Ubiquitous Language and started to use these terms. It was a good insight that saved them a lot of time when they discussed models and removed ambiguity in code.</p>
<p>At the same time, splitting people into <em>sellers</em> and <em>buyers</em> in the authorization part of the system made no sense at all. These were just <em>users</em>, and they can log in to the system and do some operations, such as update their profile, without any clear distinction of whether they're going to sell or buy on the site. It was another context when the word <em>user</em> wasn't ambiguous and was explicit.</p>
<p>Later, they discovered another distinction for users when they modeled the back office system. There, users started to take roles, and again ambiguity was there until they identified these roles and began to use terms such as <em>administrator</em>, <em>support assistant</em>, and <em>reviewer</em>. A new context was discovered, and a new model emerged for that context, which was separated from other contexts by the meanings of words.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we discussed the importance of language in system design and how precise and unambiguous terminology brings clarity. We also have a shared understanding of the domain for business people and developers. We also looked at how different industries use the same words to express different concepts and what consequences this has on domain modeling.</p>
<p>The code sample in this chapter showed how unclear language could make the implementation more complicated and less understandable. By introducing better language to the code, we made it much clearer and shorter and more concise. We made some implicit concepts more explicit, and it helped to get a better understanding of the business and improved the code quality. We also discovered many verbs that became part of the language, which is an essential addition to a glossary of nouns that are often seen as the only important part of the domain model.</p>
<p>This chapter introduced the term <em>Ubiquitous Language</em>, which was coined by Eric Evans. We emphasize the fact that the ubiquity of the language isn't in its wideness but in its precision, and the fact that it's being used for all artifacts of the software development process—from initial discussions, through modeling and design, to code and tests.</p>
<p>We looked at how words change their meaning between different contexts and how context switching can negatively impact productivity. Using our sample domain, we went through a couple of examples of how contexts are being discovered during the modeling process and in conversations between developers and domain experts. </p>
<p>In the next chapter, we'll explore one of the most popular techniques for domain modeling and go through some practical tips on how to organize useful workshops between domain experts and developers.</p>


            

            
        
    </body></html>