- en: '*Chapter 2*: Evolution of Multithreaded Programming in .NET'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As .NET and C# have evolved over the last 20 years, new and innovative approaches
    to multithreaded programming have been introduced. C# has added new language features
    to support asynchronous programming, and .NET Framework and .NET Core have added
    new types to support the languages. The most impactful improvements were introduced
    with C# 5 and .NET Framework 4.0 when Microsoft added the `async` and `await`
    keywords.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will introduce concepts and features that will be explored in greater
    depth in subsequent chapters. These concepts include the .NET `async` and `await`,
    concurrent collections, and parallelism. We will start by discovering when and
    why threading features were added to .NET and C#. Then, we will create some practical
    examples of how to use the new concepts. Finally, we will wrap up the chapter
    by discussing when it makes sense to use these new features in your own projects.
    It is important to select the best tool for every real-world scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: .NET threading through the years
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beyond threading basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to parallelism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basics of `async` and `await`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the right path forward
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how your options have expanded
    when selecting how to approach concurrency in your .NET applications.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the examples in this chapter, the following software is
    recommended for Windows users:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022 version 17.0 or later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET 6.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use the WorkingWithTimers project, you will need to install the Visual Studio
    workload for **.NET desktop development**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While these are recommended, if you have .NET 6 installed, you can use your
    preferred editor. For example, Visual Studio 2022 for Mac on macOS 10.13 or later,
    JetBrains Rider, or Visual Studio Code will work just as well.
  prefs: []
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter02.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start the chapter with a .NET and C# history lesson.
  prefs: []
  type: TYPE_NORMAL
- en: .NET threading through the years
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with threads in .NET and C# has undergone much evolution since .NET
    Framework 1.0 and C# 1.0 were introduced in 2002\. Most of the concepts discussed
    in [*Chapter 1*](B18552_01_ePub.xhtml#_idTextAnchor014), regarding the `System.Threading.Thread`
    objects have been available since those early days of .NET. While the `Thread`
    object is still available in .NET 6 and can be useful for simple scenarios, there
    are more elegant and modern solutions that are available today.
  prefs: []
  type: TYPE_NORMAL
- en: This section will highlight when the most impactful parallelism and concurrency
    features were added. We will begin by skipping ahead 8 years to 2010.
  prefs: []
  type: TYPE_NORMAL
- en: C# 4 and .NET Framework 4.0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In 2010, Microsoft released Visual Studio 2010 alongside C# 4 and .NET Framework
    4.0\. While some earlier language and framework features such as **generics**,
    **lambda expressions**, and **anonymous methods** would help facilitate later
    threading features, these 2010 releases were the most significant for threading
    since 2002\. .NET Framework included the following features that will be explored
    in more detail in the subsequent sections and chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.Collections.Concurrent` namespace to provide safe access to collections
    of data in multithreaded code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Parallel.For` and `Parallel.ForEach` and for invoking parallel operations
    with `Parallel.Invoke`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AsParallel`, `WithCancellation`, and `WithDegreeOfParallelism`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will cover these features in the *Introduction to concurrency* and *Introduction
    to parallelism* sections. Next, we will learn about the important threading features
    that were included in .NET and C# two years later.
  prefs: []
  type: TYPE_NORMAL
- en: C# 5 and 6 and .NET Framework 4.5.x
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In 2012, Microsoft released what could be considered the most important feature
    for modern multithreaded programming with .NET: asynchronous programming with
    `async` and `await`. The `async` and `await` keywords were added to C# 5 in the
    same release when .NET Framework 4.5 added the TPL. The centerpiece of the TPL
    was the `Task` class in the new `System.Threading.Tasks` namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Task` object returns from an `async` operation, providing a way for developers
    to check the status of the operation or wait for its completion. The work of an
    `async` task is performed on a background thread on the thread pool, rather than
    in the main thread. We will learn more about thread pools in the *Beyond threading
    basics* section. The basics of the TPL will be discussed in the *Basics of async
    and await* section of this chapter and in more depth in [*Chapter 5*](B18552_05_ePub.xhtml#_idTextAnchor082).
  prefs: []
  type: TYPE_NORMAL
- en: Some tooling and language features related to async programming were added in
    the following years. In 2013, .NET Framework 4.5.1 was released. This release
    corresponded to the release of Visual Studio 2013, which added async debugging
    features to the `catch` and `finally` blocks of exception handlers.
  prefs: []
  type: TYPE_NORMAL
- en: The next features came in 2017 with Microsoft’s continued shift from .NET Framework
    to .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: C# 7.x and .NET Core 2.0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second major version of .NET Core released by the .NET team included the
    new `ValueTask` and `ValueTask<TResult>` types. A `ValueTask` type is a structure
    that wraps a `Task` or an `IValueTaskSource` instance and includes some additional
    fields. It is only available when using C# 7.0 or later. The `ValueTask` type
    was added because many async operations, in practice, complete synchronously but
    still incur the overhead of allocating a `Task` instance to return to the caller.
    In these cases, performance can be improved by replacing `Task` with `ValueTask`,
    which does not incur any allocation when completing its work synchronously. To
    read more about the motivation behind the introduction of `ValueTask` and when
    to use it, you can read the following blog post by Stephen Toub of the .NET team:
    https://devblogs.microsoft.com/dotnet/understanding-the-whys-whats-and-whens-of-valuetask/.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are not familiar with Stephen Toub, he is a Partner Software Engineer
    for Microsoft and works as a developer on the .NET Team. His work on the .NET
    team was key in bringing `async`, `await`, and the TPL to the .NET developer community.
    You can read some of his other articles on the .NET Parallel Programming blog
    at https://devblogs.microsoft.com/pfxteam/author/toub/.
  prefs: []
  type: TYPE_NORMAL
- en: C# 7.0 also introduced `_`) to replace an intentionally unused variable. A `Task`
    instance returned by an async call. By using a discard in this scenario, it signals
    to the compiler explicitly that you want to ignore the returned `Task` instance.
    Discards can be used as placeholders for variables in other scenarios, too. Using
    discards can make the intent of your code clearer and, in some cases, reduce memory
    allocation. You can read more about their use on the Microsoft Docs website at
    https://docs.microsoft.com/dotnet/csharp/fundamentals/functional/discards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later in 2017, C# 7.1 was released, adding a feature of note for async programming:
    the ability to declare the `Main` method of a class as async. This made it possible
    to await other async methods directly from the `Main` method.'
  prefs: []
  type: TYPE_NORMAL
- en: The next async features of note came along in 2019 with C# 8.
  prefs: []
  type: TYPE_NORMAL
- en: C# 8 and .NET Core 3.0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When C# 8 and .NET Core 3.0 were released in 2019, several languages and .NET
    features were added to support the new `IAsyncEnumerable` type to provide a streaming
    source of asynchronous data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine a code snippet that uses `IAsyncEnumerable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the new `await foreach` language feature is used to call an
    async method to get all the orders for a customer. It then uses a `yield return`
    operation to return each `order` object with more than 10 items via the `IAsyncEnumerable`
    type as it is processed. We will cover some more real-world scenarios of using
    `IAsyncEnumerable` in [*Chapter 5*](B18552_05_ePub.xhtml#_idTextAnchor082).
  prefs: []
  type: TYPE_NORMAL
- en: The other async feature added in C# 8 was the `System.IAsyncDisposable` interface.
    When implementing `IAsyncDisposable`, your class must implement a parameterless
    `DisposeAsync` method. If your class consumes managed resources that implement
    `IAsyncDisposable`, and they cannot be disposed of in line with an `async using`
    block, you should implement `IAsyncDisposable` and clean up these resources in
    a protected `DisposeAsyncCore` method. For a comprehensive example that uses both
    `IDisposable` and `IAsyncDisposable`, you can review the Microsoft Docs example
    at https://docs.microsoft.com/dotnet/standard/garbage-collection/implementing-disposeasync#implement-both-dispose-and-async-dispose-patterns.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the most recent releases of C# and .NET. Let’s review what’s
    new for async developers in these 2021 releases.
  prefs: []
  type: TYPE_NORMAL
- en: C# 10 and .NET 6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET 6 was released in November 2021 along with C# 10\. One of the new features
    in .NET 6 was the ability of `System.Text.Json` to serialize and deserialize an
    `IAsyncEnumerable` type. Prior to .NET 6, a serialized `IAsyncEnumerable` type
    would contain an empty JSON object. This is considered a breaking change in .NET
    6, but it is a change for the better. The primary motivation behind the change
    was to support `IAsyncEnumerable<T>` responses in the ASP.NET Core MVC controller
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other .NET 6 feature of note for async developers is that the C# project
    templates in Visual Studio 2021 were modernized to leverage several recent language
    features, including the `async Main` method available in C# 7.1 and later. The
    .NET team blogged about these updated templates when .NET 6 release candidate
    2 was released in October 2021: https://devblogs.microsoft.com/dotnet/announcing-net-6-release-candidate-2/#net-sdk-c-project-templates-modernized.'
  prefs: []
  type: TYPE_NORMAL
- en: This should give you an idea of when each of the significant threading features
    was added to C# and .NET, and it sets the stage for the upcoming sections of this
    chapter, where we will cover some of the basics of parallel programming and concurrency.
    Let’s begin by looking at some more features of threading, starting with the .NET
    thread pool.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond threading basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we introduce parallel programming, concurrency, and async programming
    with .NET and C#, we have a few more threading concepts to cover. The most important
    of these is the .NET managed thread pool, which is used by awaited method calls
    that execute asynchronously in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Managed thread pool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ThreadPool` class in the `System.Threading` namespace has been part of
    .NET since the beginning. It provides developers with a pool of worker threads
    that they can leverage to perform tasks in the background. In fact, that is one
    of the key characteristics of thread pool threads. They are background threads
    that run at the default priority. When one of these threads completes its task,
    it is returned to the pool of available threads to await its next task. You can
    queue as many tasks to the thread pool as the available memory will support, but
    the number of active threads is limited by the number that the operating system
    can allocate to your application, based on the processor capacity and other running
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to use the `ThreadPool` class in a .NET 6 application, you would
    typically do so through the TPL, but let’s explore how it can be used directly
    with `ThreadPool.QueueUserWorkItem`. The following code takes the example scenario
    of [*Chapter 1*](B18552_01_ePub.xhtml#_idTextAnchor014), but uses a `ThreadPool`
    thread to perform the background process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, the key differences are that there is no need to set `IsBackground` to
    `true`, and you do not call `Start()`. The process will start either as soon as
    the item is queued on `ThreadPool` or when the next `ThreadPool` becomes available.
    While you might not explicitly use `ThreadPool` frequently in your code, it is
    leveraged by many of the common threading features in .NET. So, it’s important
    to have some understanding of how it works.
  prefs: []
  type: TYPE_NORMAL
- en: One of the common .NET features that use `ThreadPool` is timers.
  prefs: []
  type: TYPE_NORMAL
- en: Threading and timers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will examine two timer classes that use `ThreadPool`, `System.Timers.Timer`
    and `System.Threading.Timer`. Both of these types are safe to use with managed
    threading and are available on every platform supported by .NET 6.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Some additional timers are only applicable to either web or Windows platform
    development. This section will focus on the timers that are platform agnostic.
    To read more about the other timers, you can refer to the documentation on the
    Microsoft Docs website at https://docs.microsoft.com/dotnet/standard/threading/timers.
  prefs: []
  type: TYPE_NORMAL
- en: System.Timers.Timer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You are probably most familiar with the `Timer` object in the `System.Timers`
    namespace. This timer will raise an `Elapsed` event on a thread pool thread at
    the interval specified in the `Interval` property. The mechanism can be stopped
    or started by using the Boolean `Enabled` property. If you need the `Elapsed`
    event to only fire once, the `AutoReset` property can be set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'To follow along with the code in this example, download the code from the **WorkingWithTimers**
    project of this chapter’s GitHub repository: https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter02.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This example uses a `Timer` object to check for new messages and alert a user
    if any are found:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by declaring a `Timer` object and setting it up in an `InitializeTimer`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create the `_timer_Elapsed` event handler to check for messages and update
    the users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the `_timer` object has its `Enabled` property set to `true`, the `Elapsed`
    event will fire every second. In the `StartTimer()` and `StopTimer()` methods
    in the `TimerSample` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the **WorkingWithTimers** project and try using the **Start Timer** and
    **Stop Timer** buttons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see messages in Visual Studio’s debug **Output** window appearing
    every second while the timer is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Remember that timer events are firing on a thread pool thread. The code executing
    in these methods might not have access to update the UI. These timer examples
    are part of a `InvokeRequired` on the form or user control and then updating the
    UI with the `Invoke` method, if necessary. More information about how to update
    a WinForms UI can be found on the Microsoft Docs website at https://docs.microsoft.com/dotnet/desktop/winforms/controls/how-to-make-thread-safe-calls.
  prefs: []
  type: TYPE_NORMAL
- en: In your own applications, you would use the `AlertUser` method to present an
    alert message to the user or update a notification icon in the UI. Next, let’s
    try the `System.Threading.Timer` class.
  prefs: []
  type: TYPE_NORMAL
- en: System.Threading.Timer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we will create the same example with the `System.Threading.Timer` class.
    This `Timer` class must be initialized a little differently:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'To follow along with the code in this example, download the code from the **WorkingWithTimers**
    project of this chapter’s GitHub repository: https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter02.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new `InitializeTimer` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The constructor for the `Timer` class takes four parameters. The `callback`
    parameter is a delegate to invoke on the thread pool when the timer period elapses.
    The `state` parameter is an object to pass to the callback delegate. The `dueTime`
    parameter tells the timer how long (in milliseconds) to wait before triggering
    the timer for the first time. Finally, the `period` parameter specifies the interval
    (in milliseconds) between each delegate invocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'After instantiating the timer, it will immediately start. There is no `Enabled`
    property to start or stop this timer. When you are done with it, you should dispose
    of it with either the `Dispose` method or the `DisposeAsync` method. This is happening
    in our `DisposeTimerAsync` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`MessageUpdater` is a class that is used as the `state` object provided to
    the `TimerCallback` method. It has a single method that handles updates to the
    message count. The logic to update the user about new messages can be encapsulated
    by this class. In our case, it will simply update the debug output with the number
    of new messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final piece to examine is the `TimerFired` callback method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Similar to the `_timer_Elapsed` method from the previous example, this method
    simply checks for new messages and triggers an update. However, this time, the
    update is performed by the `MessageUpdater` class, which, in your application,
    could be abstracted through an `IMessageUpdater` interface and injected into this
    class for improved separation of concerns and testability.
  prefs: []
  type: TYPE_NORMAL
- en: Try this example by using the **Start Threading Timer** and **Stop Threading
    Timer** buttons in the application. You should see a debug message appearing with
    new message counts in the **Output** window, as you did in the previous example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The two timers serve similar purposes; however, most of the time, you will want
    to use `System.Threading.Timer` to leverage its async nature. However, if you
    need to frequently stop and start your timer processes, the `System.Timers.Timer`
    class is a better choice.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered some additional managed threading concepts to level-set
    your knowledge, it’s time to shift gears and introduce the concept of parallel
    programming with C#.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to parallelism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While exploring the history of threading in C# and .NET, we learned that parallelism
    was introduced to developers in .NET Framework 4.0\. In this section, the aspects
    that will be explored are exposed in the TPL through the `System.Threading.Tasks.Parallel`
    class. In addition, we will cover some of the basics of PLINQ through examples.
    These data parallelism concepts will be covered in greater detail with real-world
    examples in [*Chapter 6*](B18552_06_ePub.xhtml#_idTextAnchor098), [*Chapter 7*](B18552_07_ePub.xhtml#_idTextAnchor120),
    and [*Chapter 8*](B18552_08_ePub.xhtml#_idTextAnchor130).
  prefs: []
  type: TYPE_NORMAL
- en: At a high level, parallelism is the concept of executing multiple tasks in parallel.
    These tasks could be related to one another, but this is not a requirement. In
    fact, related tasks running in parallel run a greater risk of encountering synchronization
    issues or blocking one another. For example, if your application loads order data
    from an orders service and user preferences and application state from an **Azure
    blob store**, these two processes can be run in parallel without having to worry
    about conflicts or data synchronization. On the other hand, if the application
    is loading order data from two different order services and combining the results
    in a single collection, you will need a synchronization strategy.
  prefs: []
  type: TYPE_NORMAL
- en: That type of scenario will be discussed, in greater depth, in [*Chapter 9*](B18552_09_ePub.xhtml#_idTextAnchor146).
    In this section, we will prepare for those advanced scenarios by learning some
    uses of the `Parallel` class. Let’s start with `Parallel.Invoke`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Parallel.Invoke
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Parallel.Invoke` is a method that can execute multiple actions, and they could
    be executed in parallel. There is no guarantee of the order in which they will
    execute. Each action will be queued in the thread pool. The `Invoke` call will
    return when all the actions have been completed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the `Parallel.Invoke` call will execute four actions: another
    method in the `ParallelInvokeExample` class named `DoComplexWork`, a lambda expression,
    an `Action` declared inline, and a `delegate`. Here is the complete `ParallelInvokeExample`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a new instance of `ParallelInvokeExample` and executing `DoWorkInParallel`
    from a console application will produce an output similar to the following, although
    the order of operations may vary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Output produced by the DoWorkInParallel method ](img/Figure_2.1_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Output produced by the DoWorkInParallel method
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to implement a `Parallel.ForEach` loop
    and discuss when you might want to leverage it.
  prefs: []
  type: TYPE_NORMAL
- en: Using Parallel.ForEach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Parallel.ForEach` is probably the most used member of the `Parallel` class
    in .NET. This is because, in many cases, you can simply take the body of a standard
    `foreach` loop and use it inside a `Parallel.ForEach` loop. However, when introducing
    any parallelism into a code base, you must be sure that the code being invoked
    is thread-safe. If the body of a `Parallel.ForEach` loop modifies any of the collections,
    you will either need to employ one of the synchronization methods discussed in
    [*Chapter 1*](B18552_01_ePub.xhtml#_idTextAnchor014), or use one of .NET’s concurrent
    collections. We will introduce concurrent collections in the *Introduction to
    concurrency* section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of using `Parallel.ForEach`, we will create a method that accepts
    a list of numbers and checks whether each number is contained in a string representation
    of the current time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the call to `ExecuteParallelForEach` from the console application’s
    `Main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the program, and examine the console output. You should see that more
    than one thread was used to process the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Console output from a Parallel.ForEach loop ](img/Figure_2.2_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Console output from a Parallel.ForEach loop
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will wrap up this section on parallelism in .NET with an introduction
    to PLINQ.
  prefs: []
  type: TYPE_NORMAL
- en: Basics of Parallel LINQ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section will look at one of the simplest ways to add some parallelism
    to your code. By adding the `AsParallel` method to your LINQ query, you can transform
    it into a PLINQ query, with the operations after `AsParallel` being executed on
    the thread pool when necessary. There are many factors to consider when deciding
    when to use PLINQ. We will discuss those in some depth in [*Chapter 8*](B18552_08_ePub.xhtml#_idTextAnchor130).
    For this example, we will introduce `Where` clause that checks whether each given
    integer is an even number. To help illustrate how PLINQ can impact sequences,
    `Task.Delay` is also introduced. Here is the complete `ParallelLinqExample` class
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Main` method of your console application, add some code to pass a list
    of integers to both the `ExecuteLinqQuery` and `ExecuteParallelLinqQuery` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Examine the output, and you should see that the order of the numbers in the
    PLINQ sequence has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Console output of the LINQ and PLINQ queries ](img/Figure_2.3_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Console output of the LINQ and PLINQ queries
  prefs: []
  type: TYPE_NORMAL
- en: We will explore more aspects of parallelism over several chapters in *Part 2*,
    *Parallel Programming and Concurrency with C#,* of this book. Let’s shift gears
    and learn about some concurrency patterns in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what is concurrency and how does it relate to parallelism in the context
    of C# and .NET? The terms are frequently used interchangeably, and if you think
    about it, they do have similar meanings. When multiple threads are executing in
    parallel, they are running concurrently. In this book, we will use the term concurrency
    when discussing patterns to follow when designing for managed threading. Additionally,
    we will discuss concurrency in the context of the concurrent collections that
    were introduced to .NET developers in .NET Framework 4.0\. Let’s start by learning
    about the concurrent collections in the `System.Collections.Concurrent` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: .NET has several collections that have been created with thread safety built-in.
    These collections can all be found in the `System.Collections.Concurrent` namespace.
    In this section, we will introduce five of the collections. The remaining three
    are variations of `Partitioner`. These will be explored in [*Chapter 9*](B18552_09_ePub.xhtml#_idTextAnchor146),
    where we will work with each of the collection types through practical examples.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'While your code does not require the use of locks when using concurrent collections,
    different techniques for synchronization are being employed inside these collections.
    Some of them do use locking, while others have retry mechanisms to deal with contention.
    To read more about how concurrent collections handle contention, check out this
    Microsoft blog post on the .NET Parallel Programming blog: https://devblogs.microsoft.com/pfxteam/faq-are-all-of-the-new-concurrent-collections-lock-free/.'
  prefs: []
  type: TYPE_NORMAL
- en: The first collection we will introduce is `ConcurrentBag<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: ConcurrentBag<T>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ConcurrentBag<T>` collection is a concurrent collection intended to hold
    a collection of unordered objects. Duplicate values are allowed, as are null values
    when `T` is a nullable type. It makes an excellent thread-safe replacement for
    an array, `List<T>`, or other `IEnumerable<T>` instances where the ordering of
    items is not a requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, `ConcurrentBag<T>` stores a linked list of items for each thread
    adding items. As items are taken or peeked at from the collection, priority will
    be given to the internal list, which had items added by the current thread. Let’s
    suppose thread 1 adds items A, B, and C and thread 2 adds items D, E, F, and G.
    If thread 1 calls `TryPeek` or `TryTake` four times, `ConcurrentBag<T>` will get
    items from the A, B, and C list first before taking items from the linked list
    containing items from thread 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list details the properties and methods of `ConcurrentBag<T>`
    that you are likely to use in most implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Add(T)`: This adds an object to the bag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TryPeek(out T)`: This tries to fetch a value from the bag with an `out` parameter
    but does not remove that item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TryTake(out T)`: This attempts to fetch a value from the bag with an `out`
    parameter and removes it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Clear()`: This clears all of the objects from the bag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Count`: This returns the number of objects in the bag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IsEmpty`: This returns a `bool` value indicating whether the bag is empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ToArray()`: This returns an array of objects of type `T`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ConcurrentBag<T>` collection has two constructors. One constructor takes
    no parameters and simply creates a new empty bag. The other accepts an `IEnumerable<T>`
    type of object to be copied to the new bag.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s take a quick look at the `ConcurrentQueue<T>` collection.
  prefs: []
  type: TYPE_NORMAL
- en: ConcurrentQueue<T>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The .NET `ConcurrentQueue<T>` collection is similar in implementation to its
    thread-unsafe counterpart, `Queue<T>`. As such, it makes a great replacement for
    `Queue<T>` when managed threading is introduced to an existing code base. `ConcurrentQueue<T>`
    is a strongly typed list of objects that enforces **first in, first out** (**FIFO**)
    logic, which is the definition of a **queue**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '**FIFO** logic is commonly seen in the manufacturing industry and in warehouse
    management software. When working with perishable goods, it is important to use
    your oldest raw materials first. Therefore, those pallets of goods that were the
    first to be put into the warehouse should be the first to be pulled when a pallet
    of that type is requested by the system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the commonly used members of the `ConcurrentQueue<T>` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Enqueue(T)`: This adds a new object to the queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TryPeek(out T)`: This attempts to get the object at the front of the queue
    without removing it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TryDequeue(out T)`: This tries to get the object at the front of the queue
    and removes it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Clear()`: This clears the queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Count`: This returns the number of objects in the queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IsEmpty`: This returns a `bool` value indicating whether the queue is empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ToArray()`: This returns the objects in the queue as an array of type `T`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similar to the `ConcurrentBag<T>` collection, the `ConcurrentQueue<T>` collection
    has two constructors: one parameterless and one that takes an `Ienumerable<T>`
    type to populate the new queue. Next, let’s introduce a similar collection: `ConcurrentStack<T>`.'
  prefs: []
  type: TYPE_NORMAL
- en: ConcurrentStack<T>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ConcurrentStack<T>` can be thought of as `ConcurrentQueue<T>`, but it uses
    `Push` method instead of `Enqueue`, and removing items uses a `TryPop` method
    instead of `TryDequeue`. Another advantage of the `ConcurrentStack<T>` collection
    is that it can add or remove multiple objects in one operation. These range operations
    are supported by using the `PushRange` and `TryPopRange` methods. The range operations
    take arrays of `T` as parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: C`oncurrentStack<T>` and `ConcurrentQueue<T>` in .NET 6 both implement the `IReadOnlyCollection<T>`
    interface. This means that once the collection has been created, it is read-only
    and cannot be reassigned or set to `null`. You can only add or remove items or
    use `Clear()` to empty the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to one of the most powerful concurrent collections, `BlockingCollection<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: BlockingCollection<T>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`BlockingCollection<T>` is a thread-safe collection of objects that implements
    several interfaces, including `IProducerConsumerCollection<T>`. The `IProducerConsumerCollection<T>`
    interface provides a set of members intended to support applications that need
    to implement the **producer/consumer pattern**.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The producer/consumer pattern is a concurrency design pattern where a set of
    data is concurrently fed by one or more producer threads. At the same time, there
    are one or more consumer threads monitoring and fetching the data being produced
    to consume and process it concurrently. The `BlockingCollection<T>` collection
    is the data store in this producer/consumer pattern. You can read more about producer/consumer
    on Wikipedia at https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem.
  prefs: []
  type: TYPE_NORMAL
- en: '`BlockingCollection<T>` has several methods and properties that assist in a
    producer/consumer workflow. You can indicate that the producer process is done
    adding items to the collection by calling the `CompleteAdding` method. Once this
    method is called, no more items can be added to the collection with the `Add`
    or `TryAdd` methods. If you plan to use `CompleteAdding` in your workflow, it
    is best to always use `TryAdd` and check the Boolean result when adding objects
    to the collection. If the collection has been marked as complete for adding, calling
    `Add` will throw `InvalidOperationException`. Additionally, you can check the
    `IsAddingCompleted` property to find out whether `CompleteAdding` has already
    been called.'
  prefs: []
  type: TYPE_NORMAL
- en: Items are removed from `BlockingCollection<T>` by a consumer process with the
    `Take` or `TryTake` methods. Again, it is safer to use `TryTake` to avoid any
    exceptions when the collection is empty. If `CompleteAdding` has been called and
    all objects have been removed from the collection, the `IsCompleted` property
    will return true.
  prefs: []
  type: TYPE_NORMAL
- en: We will walk through a real-world producer/consumer implementation in [*Chapter
    9*](B18552_09_ePub.xhtml#_idTextAnchor146) *.NET*. Now, let’s move on to our final
    concurrent collection in this section, `ConcurrentDictionary<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: ConcurrentDictionary<TKey, TValue>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you have probably guessed, `ConcurrentDictionary<TKey,` `TValue>` is a great
    replacement for `Dictionary<TKey, TValue>` when working with managed threading.
    Both collections implement the `IDictionary<TKey, TValue>` interface. The concurrent
    version of this collection adds the following methods for working with data concurrently:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TryAdd`: This tries to add a new key/value pair to the dictionary and returns
    a Boolean value indicating whether the object was successfully added to the dictionary.
    If the key already exists, the method will return `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TryUpdate`: This operation passes a key along with the existing and new values
    for the item. It will update the existing item to the new value if it exists in
    the dictionary with the existing value provided. The Boolean value that is returned
    indicates whether the object was successfully updated in the dictionary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddOrUpdate`: This method will add or update an item in the dictionary based
    on whether the key exists and uses an update delegate to perform any logic based
    on the current and new values for the item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetOrAdd`: This method will add an item if the key does not already exist.
    If it does exist, the existing value is returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the most important and common concurrent collections in .NET to understand.
    We will cover some examples of each and learn about more of the collections in
    `System.Collections.Concurrent` later, but this section should provide a solid
    base for understanding what is to come.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will introduce the C# `async` and `await` keywords that
    were added to C# 5.0.
  prefs: []
  type: TYPE_NORMAL
- en: Basics of async and await
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the TPL was introduced in .NET Framework 4.5, C# 5.0 also added language
    support for task-based asynchronous programming with the `async` and `await` keywords.
    This immediately became the default method of implementing asynchronous workflows
    in C# and .NET. Now, 10 years later, `async`/`await` and the TPL have become an
    integral part of building robust, scalable .NET applications. You might be wondering
    why it is so important to adopt async programming in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the async keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many reasons for writing async code. If you’re writing server-side
    code on a web server, using async allows the server to handle additional requests
    while your code is awaiting a long-running operation. On a client application,
    freeing the UI thread to perform other operations with async code allows your
    UI to remain responsive to users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important reason to adopt async programming in .NET is that many third-party
    and open source libraries are using `async`/`await`. Even .NET itself is exposing
    more APIs as async in every release, especially those involving IO operations:
    networking, file, and database access.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try writing your first async method with C#.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an async method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating and consuming an async method is easy. Let’s try a simple example
    with a new console application:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new console application in Visual Studio and name it **AsyncConsoleExample**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a class to the project, named `NetworkHelper`, and add the following methods
    to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are a few things to point out in the preceding code. Both methods have
    an `async` modifier, indicating that they will be awaiting some work and will
    run asynchronously. Inside the methods, we are using the `await` keyword with
    the calls to `Task.Delay`. This will ensure that no code after this point will
    execute until the awaited method has been completed. However, during this time,
    the active thread can be released to perform other work elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, look at the call to `NetworkCheckInternalAsync`. Instead of awaiting
    this call, we are capturing the returned `Task` instance in a variable named `t`,
    and we don’t `await` it until after the `for` loop. This means that the `for`
    loops in both methods will run concurrently. If we had, instead, awaited `NetworkCheckInternalAsync`,
    its `for` loop would have been completed before the `for` loop in `CheckNetworkStatusAsync`
    could begin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, replace the code in `Program.cs` with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are awaiting the call to `CheckNetworkStatusAsync`. This is possible because
    the default `Main` method in a .NET 6 console application is `async` by default.
    If you try to `await` something in a method that is not marked as `async`, you
    will get a compiler error. We will explore some of the options you can use when
    you must call async methods from existing non-async code in [*Chapter 5*](B18552_05_ePub.xhtml#_idTextAnchor082).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, run the application and examine the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Console output for the async sample application ](img/Figure_2.4_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Console output for the async sample application
  prefs: []
  type: TYPE_NORMAL
- en: As expected, capturing the async method’s result allowed the two loops to run
    concurrently. Try awaiting the call to `NetworkCheckInternalAsync` and see how
    the output changes. You should see that all the output from the private method
    will appear before the output from the `for` loop in `CheckNetworkStatusAsync`
    begins.
  prefs: []
  type: TYPE_NORMAL
- en: This was a brief introduction to the world of async programming with C#. We’ll
    be working with it quite a lot throughout the rest of this book. Let’s wrap things
    up by discussing how to choose which of these options to leverage when building
    a new project or enhancing an existing application.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right path forward
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have been introduced to some advanced managed threading concepts,
    parallel programming, concurrent collections, and the async/await paradigm, let’s
    discuss how they all fit together in the real world. Choosing the right path forward
    with multithreaded development in .NET will usually involve more than one of these
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: When working with .NET 6, you should usually choose to create `async` methods
    in your projects. The reasons discussed in this chapter are compelling. Asynchronous
    programming keeps both client and server applications responsive, and `async`
    is used extensively throughout .NET itself.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the `Parallel` class operations can be leveraged when your code needs
    to process a set of items quickly and the underlying code doing the processing
    is thread-safe. This is one place where concurrent collections can be introduced.
    If any parallel or async operations are manipulating shared data, the data should
    be stored in one of the .NET concurrent collections.
  prefs: []
  type: TYPE_NORMAL
- en: If you are working with existing code, often, the most prudent path is to limit
    how much multithreaded code is added. Legacy projects such as these are a great
    place to incrementally add some `ThreadPool` or `Parallel` operations and test
    the results. It is important to test the application functionally and for performance.
    Performance testing tools for managed threading will be covered in [*Chapter 10*](B18552_10_ePub.xhtml#_idTextAnchor158).
  prefs: []
  type: TYPE_NORMAL
- en: This preliminary guidance will help you get an idea of where you can boost your
    applications’ performance with managed threading. We will build on your learning
    and this guidance throughout the rest of the book. Let’s wrap up and discuss what
    you have learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started by looking at a brief history of C#, .NET, and managed
    threading. We discussed how Microsoft has added features for asynchronous and
    parallel programming over the last 20 years. Next, we took a tour of parallel
    programming with .NET, concurrent collections, and asynchronous development with
    C#. Finally, we examined when you might choose each of these concepts for your
    own applications and why you will often choose more than one of them. You will
    be able to take what you learned in this chapter and start thinking about practical
    applications of managed threading in your day-to-day work.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take what you have learned so far and discuss some
    of the best practices for the practical application of the concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which class in .NET manages the thread pool threads available to your application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In which version of C# were the `async` and `await` keywords introduced?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In which version of .NET was the TPL introduced?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In which version of .NET Core was `IAsyncEnumerable` introduced?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type should every `async` method return?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which concurrent collection would you choose to replace `Dictionary<TKey, TValue>`
    in a multithreaded scenario?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which concurrent collection is frequently used with the producer/consumer design
    pattern in .NET?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which parallel feature in .NET features the `AsParallel` method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
