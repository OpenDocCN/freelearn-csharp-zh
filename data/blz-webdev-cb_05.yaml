- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Managing Application State
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理应用程序状态
- en: In this chapter, we will explore the crucial aspect of maintaining and manipulating
    the state of a Blazor application. An **application state** is the runtime data
    that dictates the behavior and appearance of an application, reflecting user interactions
    and decisions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨维护和操作 Blazor 应用程序状态的关键方面。**应用程序状态**是运行时数据，它决定了应用程序的行为和外观，反映了用户的交互和决策。
- en: We will walk through various strategies for state management, from encoding
    state in the URL for bookmarkable states and easy sharing to implementing in-memory
    state containers for rapid access. You’ll learn how to inject application state
    as a service, allowing centralized state management across different components,
    and how to persist state to ensure data continuity across sessions. Furthermore,
    we will explore techniques to resolve persisted state upon application load, invoking
    state changes from anywhere within an application, and monitoring these changes
    with dedicated listening components. We will pay special attention to sharing
    state across different render mode boundaries.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍各种状态管理策略，从将状态编码到 URL 以实现可书签状态和易于共享，到实现内存中的状态容器以实现快速访问。你将学习如何将应用程序状态作为服务注入，以实现不同组件之间的集中式状态管理，以及如何持久化状态以确保会话间的数据连续性。此外，我们将探讨在应用程序加载时解决持久化状态、从应用程序的任何地方调用状态变化以及使用专用监听组件监控这些变化的技巧。我们将特别关注在不同渲染模式边界之间共享状态。
- en: By the end of this chapter, you’ll have a solid foundation in state management
    practices that will help you build dynamic, responsive, and stateful Blazor applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将具备在状态管理实践方面的坚实基础，这将帮助你构建动态、响应和有状态的 Blazor 应用程序。
- en: 'Here are the recipes that will take us there:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些将带我们到达那里的配方：
- en: Having a bookmarkable state
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有可书签状态
- en: Implementing an in-memory state container
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现内存中的状态容器
- en: Injecting application state as a service
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序状态作为服务注入
- en: Invoking state changes from anywhere
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从任何地方调用状态变化
- en: Persisting state
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久化状态
- en: Resolving persisted state
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决持久化状态
- en: Sharing state across interactive render mode boundaries
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在交互渲染模式边界之间共享状态
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The barrier of entry to that chapter is not high. You’ll need the following
    tools:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 那一章节的入门门槛不高。你需要以下工具：
- en: A modern IDE (that supports Blazor development)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个支持 Blazor 开发的现代 IDE
- en: .NET 9 installed on your development machine
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的开发机器上安装了 .NET 9
- en: A modern web browser (one that supports Web Assembly and has DevTools)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个支持 Web Assembly 和具有 DevTools 的现代网络浏览器
- en: A bare-bone Blazor project (where you’ll write your code)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个基本的 Blazor 项目（你将在其中编写代码）
- en: 'You can find all the examples and data samples referenced in the following
    recipes in a dedicated GitHub repository at: [https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter05](https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter05)
    . In each recipe that needs any samples, I will also point you to the directory
    where you can find them.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下 GitHub 仓库中找到以下配方中引用的所有示例和数据样本：[https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter05](https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter05)。在需要任何样本的每个配方中，我还会指向你可以找到它们的目录。
- en: Having bookmarkable state
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有可书签状态
- en: In this recipe, we will introduce the simplest yet powerful pattern of leveraging
    a URL to maintain and share application state. Unlike more complex state management
    strategies, embedding state flags directly in the URL doesn’t require in-memory
    persistence. A static URL allows users to bookmark a specific application state
    and facilitates the easy sharing of that state with others. We will follow the
    well-known **restful routing** pattern and elegantly map application states to
    readable and shareable URLs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将介绍利用 URL 维护和共享应用程序状态的最简单但功能强大的模式。与更复杂的状态管理策略不同，直接在 URL 中嵌入状态标志不需要内存持久化。静态
    URL 允许用户书签特定的应用程序状态，并便于与他人轻松共享该状态。我们将遵循众所周知的**RESTful 路由**模式，并将应用程序状态优雅地映射到可读和可共享的
    URL。
- en: Let’s create a component that allows us to bookmark and view an entire event
    list or specific event information.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个组件，允许我们书签并查看整个事件列表或特定事件信息。
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we start implementing a component with bookmarkable state, we need to
    do the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实现具有可书签状态的组件之前，我们需要做以下事情：
- en: Create a **Chapter05** / **Recipe01** directory – this will be our working directory
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**Chapter05** / **Recipe01**目录——这将是我们的工作目录
- en: Copy the **Api** and **Event** files from the **Chapter05** / **Data** directory
    in the GitHub repository
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从GitHub仓库中的**Chapter05** / **Data**目录复制**Api**和**Event**文件
- en: How to do it…
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Follow these steps to implement stateful URLs in your application:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在应用程序中实现状态化URL：
- en: 'Navigate to the **Program** file of your application and register the **Api**
    service, as scoped in the application’s dependency injection container:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到应用程序的**Program**文件并注册**Api**服务，如应用程序的依赖注入容器中定义的：
- en: '[PRE0]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a **Store** component with two navigable routes to facilitate user access
    to different application states through the URL:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有两个可导航路由的**Store**组件，以方便用户通过URL访问不同的应用程序状态：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside the **@code** block of the **Store** component, inject the **Api** service
    and declare an **EventId** parameter that we will use to fetch specific event
    details:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Store**组件的**@code**块内部，注入**Api**服务并声明一个我们将用于获取特定事件详细信息的**EventId**参数：
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Still within the **@code** block, initialize the **Collection** and **Event**
    variables that will hold the fetched data, based on the application’s current
    state:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在**@code**块中，根据应用程序的当前状态初始化将保存获取数据的**Collection**和**Event**变量：
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Override the **OnParametersSetAsync()** life cycle method and implement the
    logic to update the component’s state, based on the parameters passed in the URL:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖**OnParametersSetAsync()**生命周期方法并实现基于传递到URL中的参数更新组件状态的逻辑：
- en: '[PRE4]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the markup of the **Store** component, add a section to render **Event**
    details conditionally:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Store**组件的标记中，添加一个部分以条件性地渲染**Event**详细信息：
- en: '[PRE5]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add another section to the **Store** markup to render the **Collection** elements:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Store**标记中添加另一个部分以渲染**Collection**元素：
- en: '[PRE6]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works…
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we navigate to the **Program** of the application and register
    the API service in the application’s dependency injection container, so we can
    inject it later when required.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 1**中，我们导航到应用程序的**Program**并注册API服务到应用程序的依赖注入容器中，以便在需要时可以注入它。
- en: In *step 2* , we create a routable **Store** component a slightly enhanced routing.
    We declare two routable paths – **/ch05r01/events** for rendering all available
    events and **/ch05r01/events/{eventId:guid}** for specific event details. By leveraging
    path parametrization and path constraints, we specify the **EventId** parameter
    within the curly braces, setting **Guid** as its expected value type.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 2**中，我们创建了一个具有略微增强路由的**Store**组件。我们声明了两个可路由路径——**/ch05r01/events**用于渲染所有可用的活动，以及**/ch05r01/events/{eventId:guid}**用于特定事件的详细信息。通过利用路径参数化和路径约束，我们在大括号内指定了**EventId**参数，将其期望值类型设置为**Guid**。
- en: In *step 3* , we initialize the **@code** block, where we declare the **EventId**
    parameter expected by the route. Blazor automatically intercepts and assigns path
    parameter values based on the name matching. We also inject the **Api** service
    from the provided sample data, allowing us to fetch event information seamlessly.
    In *step 4* , we initialize the **Collection** and **Event** variables. These
    are essential in supporting the dual states of the **Store** component – one for
    showcasing a list of available events and another for presenting details of a
    specific, selected event. In *step 5* , we fine-tune the rendering logic by overriding
    the **OnParametersSetAsync()** life cycle method. We determine whether the **EventId**
    was correctly resolved and fetch the details of that specific event, using the
    injected **Api** service. Otherwise, we retrieve the entire collection of available
    events.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 3**中，我们初始化**@code**块，其中我们声明了路由所期望的**EventId**参数。Blazor会自动拦截并根据名称匹配分配路径参数值。我们还从提供的示例数据中注入了**Api**服务，使我们能够无缝地获取事件信息。在**步骤
    4**中，我们初始化**Collection**和**Event**变量。这些变量对于支持**Store**组件的双重状态至关重要——一个用于展示可用的活动列表，另一个用于展示特定选中活动的详细信息。在**步骤
    5**中，我们通过覆盖**OnParametersSetAsync()**生命周期方法来微调渲染逻辑。我们确定**EventId**是否正确解析，并使用注入的**Api**服务获取该特定事件的详细信息。否则，我们检索整个可用的活动集合。
- en: From *step 6* , we implement the **Store** markup that supports two distinct
    states. To accommodate this, we include two conditional markup sections. If **Event**
    was fetched, indicating that a specific event’s details are ready for display,
    we render its **Id** and quickly return to skip any further logic. We cover the
    component’s alternative state in *step 7* by iterating over **Collection** . We
    render links to each event’s details, utilizing the **Store** component’s parametrized
    path and providing **item.Id** where the **eventId** parameter goes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从*步骤6*开始，我们实现支持两种不同状态的**Store**标记。为了适应这一点，我们包括两个条件标记部分。如果已获取**Event**，表示特定事件的详细信息已准备好显示，我们将渲染其**Id**并快速返回以跳过任何进一步的逻辑。我们通过遍历**Collection**在*步骤7*中覆盖组件的替代状态。我们渲染指向每个事件详细信息的链接，利用**Store**组件的参数化路径，并在**eventId**参数的位置提供**item.Id**。
- en: There’s more…
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You will find parameterized paths most useful in **CRUD** ( **Create, Read,
    Update, Delete** ) scenarios. Assuming we would implement a form within the **Store**
    component designed to attach to an **Event** object, we could ingeniously treat
    a **Guid.Empty** value as a trigger to initiate the creation process and initialize
    a new, empty **Event** model. Conversely, if a valid **Guid** is provided, we
    would fetch the existing **Event** from the API. We’ve effectively covered two
    scenarios with the same form and avoided code duplication.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现参数化路径在**CRUD**（**创建、读取、更新、删除**）场景中非常有用。假设我们将在**Store**组件内实现一个表单，该表单旨在附加到**Event**对象上，我们可以巧妙地将**Guid.Empty**值用作触发创建过程的信号，并初始化一个新的、空的**Event**模型。相反，如果提供了一个有效的**Guid**，我们将从API获取现有的**Event**。我们有效地使用相同的表单覆盖了两种场景，避免了代码重复。
- en: Specifying the type for a value in a path isn’t a strict requirement. By default,
    Blazor will map parameters as strings, giving you the flexibility to parse them
    into the required type at a later stage. However, the real power lies in utilizing
    route constraints effectively. While parsing parameters later provides flexibility,
    I strongly recommend leveraging route constraints wherever possible. In the **Store**
    component example, by specifying a parameter type as **Guid** , if the route does
    not match due to the route constraint, Blazor shows a **NotFound** content – filtering
    out invalid inputs preemptively and enhancing the robustness and security of your
    application. We will explore routing and the **NotFound** content in [*Chapter
    9*](B22020_09.xhtml#_idTextAnchor308) .
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在路径中指定值的类型并不是一个严格的要求。默认情况下，Blazor会将参数映射为字符串，这为您在稍后阶段将它们解析为所需类型提供了灵活性。然而，真正的力量在于有效地利用路由约束。虽然稍后解析参数提供了灵活性，但我强烈建议尽可能利用路由约束。在**Store**组件示例中，通过指定参数类型为**Guid**，如果由于路由约束导致路由不匹配，Blazor将显示**NotFound**内容——预先过滤掉无效输入，从而增强应用程序的健壮性和安全性。我们将在[*第9章*](B22020_09.xhtml#_idTextAnchor308)中探讨路由和**NotFound**内容。
- en: Implementing an in-memory state container
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现内存状态容器
- en: Efficiently managing interactions with external APIs is absolutely crucial in
    modern web development. An **in-memory state container** allows you to persist
    specific objects for an application lifetime unless configured otherwise. When
    you receive a comprehensive data object from the API upon the initial call, rather
    than fetching this data anew for every page transition, an in-memory state container
    facilitates the smooth transfer of the entire object throughout the various stages
    and pages of the application. Furthermore, an in-memory state container proves
    invaluable during multi-stage setup processes, allowing the current state of a
    complex setup object to be persistently carried forward without loss or repeated
    external calls.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代Web开发中，有效地管理与外部API的交互至关重要。一个**内存状态容器**允许您在应用程序生命周期内持久化特定对象，除非另有配置。当您在初始调用中从API接收到一个完整的数据对象时，而不是在每次页面转换时重新获取这些数据，内存状态容器可以促进整个对象在应用程序的各个阶段和页面之间的平滑传输。此外，在多阶段设置过程中，内存状态容器非常有价值，它允许复杂设置对象的当前状态持久地向前推进，而不会丢失或重复外部调用。
- en: Let’s implement a container where we will persist event information and display
    it after redirecting a user to an event details page.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个容器，我们将在此容器中持久化事件信息，并在将用户重定向到事件详情页面后显示这些信息。
- en: Getting ready
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before diving into the implementation of an in-memory container, we need to
    do the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入实现内存容器之前，我们需要做以下几步：
- en: Create a **Chapter05** / **Recipe02** directory – this will be your working
    directory
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**Chapter05**/**Recipe02**目录——这将成为您的工作目录
- en: Copy **Api** and **Event** files from the **Chapter05** / **Data** directory
    in the GitHub repository
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从GitHub仓库中**Chapter05**/**Data**目录复制**Api**和**Event**文件
- en: Register the **Api** service as scoped in the application’s dependency injection
    container (you can check the *Having a bookmarkable state* recipe to see how)
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**Api**服务注册为在应用程序的依赖注入容器中作用域内（您可以通过查看*Having a bookmarkable state*菜谱来了解如何操作）
- en: How to do it…
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Implement the in-memory state container with the following steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤实现内存状态容器：
- en: 'Create a generic **StateContainer<T>** class to hold any type of object in
    memory:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个泛型**StateContainer<T>**类来在内存中持有任何类型的对象：
- en: '[PRE7]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Within **StateContainer<T>** , initialize a backing **_container** as a generic
    **Dictionary** where you will persist state objects:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**StateContainer<T>**中，初始化一个后端**_container**作为泛型**Dictionary**，您将在其中持久化状态对象：
- en: '[PRE8]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the **Persist()** and **Resolve()** methods to **StateContainer<T>** that
    either store or retrieve objects from **_container** , using a **Guid** key:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向**StateContainer<T>**添加**Persist()**和**Resolve()**方法，使用**Guid**键从**_container**存储或检索对象：
- en: '[PRE9]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Navigate to the **Program** application root and register the **StateContainer<Event>**
    in the dependency injection container:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**Program**应用程序根目录并在依赖注入容器中注册**StateContainer<Event>**：
- en: '[PRE10]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add a static **Config** class and define a customized **PrerenderDisabled**
    render mode, based on **InteractiveWebAssembly** but with disabled pre-rendering:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个静态**Config**类并定义一个基于**InteractiveWebAssembly**但禁用了预渲染的定制**PrerenderDisabled**渲染模式：
- en: '[PRE11]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a routable **Store** component that renders in **PrerenderDisabled**
    mode:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个在**PrerenderDisabled**模式下渲染的可路由**Store**组件：
- en: '[PRE12]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the **@code** section of **Store** , inject **StateContainer<Event>** to
    persist **Event** objects, **NavigationManager** to facilitate navigation, and
    **Api** to seed data from an external source:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Store**的**@code**部分，注入**StateContainer<Event>**以持久化**Event**对象，**NavigationManager**以促进导航，以及**Api**从外部源播种数据：
- en: '[PRE13]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Still inside the **@code** block, initialize a backing **Data** collection
    and override the **OnInitializedAsync()** life cycle method to fetch **Data**
    objects from **Api** :'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在**@code**块内部，初始化一个后端**Data**集合并覆盖**OnInitializedAsync()**生命周期方法以从**Api**获取**Data**对象：
- en: '[PRE14]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Lastly, in the **@code** block, implement a **ShowDetails()** method that stores
    a requested **Event** in the in-memory **StateContainer<Event>** and redirects
    to a page displaying the event details:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在**@code**块中，实现一个**ShowDetails()**方法，将请求的**Event**存储在内存中的**StateContainer<Event>**中，并重定向到显示事件详情的页面：
- en: '[PRE15]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the **Store** markup, construct a loop where you render navigation buttons
    to all elements from the **Data** collection:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Store**标记中，构建一个循环以渲染来自**Data**集合的所有元素的导航按钮：
- en: '[PRE16]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create an **EventDetails** component with a route matching the one specified
    in the previous step and rendering in **PrerenderDisabled** mode:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个与上一步中指定的路由匹配的**EventDetails**组件，并以**PrerenderDisabled**模式渲染：
- en: '[PRE17]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the **@code** section of **EventDetails** , inject **StateContainer<Event>**
    and declare an **EventId** parameter to capture an event identifier from the URL:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**EventDetails**的**@code**部分，注入**StateContainer<Event>**并声明一个**EventId**参数以从URL捕获事件标识符：
- en: '[PRE18]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Still within the **@code** block, declare a **Model** variable to maintain
    the current component state and override the **OnParametersSet()** life cycle
    method to resolve **Model** from the injected **Container** :'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在**@code**块内部，声明一个**Model**变量以维护当前组件状态，并覆盖**OnParametersSet()**生命周期方法以从注入的**Container**解析**Model**：
- en: '[PRE19]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the **EventDetails** markup, introduce a nullability check for **Model**
    , and render the current capacity of the underlying event if **Model** is successfully
    resolved:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**EventDetails**标记中，对**Model**进行空值检查，并在**Model**成功解析时渲染底层事件的当前容量：
- en: '[PRE20]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works…
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We start the implementation by laying the foundation of in-memory state persistence.
    In *step 1* , we add a generic class, **StateContainer<T>** . In *step 2* , we
    initialize a backing collection within **StateContainer<T>** to persist state
    objects. We opt for **Dictionary<Guid, T>** , as we will exploit its straightforward
    key-value API, but any alternative collection type would also work. In *step 3*
    , we implement the **Persist()** and **Resolve()** methods. The **Persist()**
    method, accepting **key** and **value** , allows us to add objects to our in-memory
    container. Concurrently, the **Resolve()** method allows to retrieve these objects
    using their keys. In *step 4* , we add our in-memory state container to the application’s
    dependency injection container. As we will be working with **Event** objects,
    we register **StateContainer<Event>** . We give it a **Scoped** lifetime to ensure
    that **Event** objects are available throughout the user session.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过建立内存状态持久化的基础来开始实施。在*步骤 1*中，我们添加了一个通用类，**StateContainer<T>**。在*步骤 2*中，我们在**StateContainer<T>**内部初始化一个后端集合以持久化状态对象。我们选择**Dictionary<Guid,
    T>**，因为我们将会利用其直接的键值API，但任何其他集合类型也同样适用。在*步骤 3*中，我们实现了**Persist()**和**Resolve()**方法。**Persist()**方法接受**key**和**value**，允许我们将对象添加到我们的内存容器中。同时，**Resolve()**方法允许我们使用它们的键检索这些对象。在*步骤
    4*中，我们将我们的内存状态容器添加到应用程序的依赖注入容器中。由于我们将与**Event**对象一起工作，我们注册了**StateContainer<Event>**。我们给它一个**Scoped**生命周期，以确保**Event**对象在整个用户会话中可用。
- en: In *step 5* , we introduce a custom render mode – **PrerenderDisabled** . We
    place **PrerenderDisabled** in a new, static **Config** class so that it’s easily
    reusable. Why do we need a custom render mode? When you declare interactivity
    mode per component, Blazor serves pre-rendered content by default and hydrates
    the component state subsequently. In our case, this would raise exceptions, as
    the in-memory state container remains inaccessible during the initial component
    render. Our **PrerenderDisabled** mode, based on **InteractiveWebAssembly** ,
    solves that challenge.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 5*中，我们引入了一个自定义渲染模式——**PrerenderDisabled**。我们将**PrerenderDisabled**放置在一个新的静态**Config**类中，以便它易于重用。为什么我们需要一个自定义渲染模式？当你为每个组件声明交互模式时，Blazor默认通过预渲染内容提供服务，随后再水化组件状态。在我们的情况下，这会引发异常，因为内存状态容器在组件初始渲染期间不可访问。我们的基于**InteractiveWebAssembly**的**PrerenderDisabled**模式解决了这个挑战。
- en: In *step 6* , we create a routable **Store** component, referencing the sample
    data assembly, and we leverage **PrerenderDisabled** mode, defined in **Config**
    . In *step 7* , we inject the required services – **StateContainer<Event>** for
    object state persistence, **Navigation** for user-directed navigation, and **Api**
    for fetching events from an external data source. In *step 8* , we initialize
    the **Data** collection within the **Store** component and populate it by invoking
    **Api** in the **OnInitializedAsync()** life cycle method. In *step 9* , we define
    a **ShowDetails()** method that adds the selected **Event** object to the in-memory
    state container and redirects the user to an event details page. In *step 10*
    , we jump to the **Store** markup and render buttons, allowing us to navigate
    to the details of any element from the **Data** collection.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 6*中，我们创建了一个可路由的**Store**组件，引用示例数据程序集，并利用**Config**中定义的**PrerenderDisabled**模式。在*步骤
    7*中，我们注入了所需的服务——用于对象状态持久化的**StateContainer<Event>**、用于用户导向导航的**Navigation**以及用于从外部数据源获取事件的**Api**。在*步骤
    8*中，我们在**Store**组件内初始化**Data**集合，并通过在**OnInitializedAsync()**生命周期方法中调用**Api**来填充它。在*步骤
    9*中，我们定义了一个**ShowDetails()**方法，它将选定的**Event**对象添加到内存状态容器中，并将用户重定向到事件详情页面。在*步骤
    10*中，我们跳转到**Store**标记并渲染按钮，允许我们从**Data**集合中的任何元素导航到其详情。
- en: Now, we also need to add the event details page. In *step 11* , we create an
    **EventDetails** component with a route matching the one chosen in *step 9* .
    We also declare its render mode to **PrerenderDisabled** - in line with the **Store**
    component. In *step 12* , we inject the **StateContainer<Event>** and declare
    **EventId** , allowing Blazor to intercept the event identifier directly from
    the page URL. In *step 13* , we declare **Model** for the **EventDetails** component
    and override the **OnParametersSet()** life cycle method, where we resolve the
    **Model** value using the intercepted **EventId** . Note that we leverage our
    **StateContainer<Event>** to fetch the **Model** details and avoid additional
    fetching from external sources. As we wrap up the implementation, in *step 14*
    , we complete the **EventDetails** component with a markup that checks for the
    **Model** state and displays information about the event’s current capacity.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还需要添加事件详情页面。在*步骤11*中，我们创建了一个**EventDetails**组件，其路由与*步骤9*中选择的路由相匹配。我们还将其渲染模式声明为**PrerenderDisabled**——与**Store**组件保持一致。在*步骤12*中，我们注入了**StateContainer<Event>**并声明了**EventId**，允许Blazor直接从页面URL拦截事件标识符。在*步骤13*中，我们为**EventDetails**组件声明了**Model**并重写了**OnParametersSet()**生命周期方法，在那里我们使用拦截的**EventId**解析**Model**值。请注意，我们利用我们的**StateContainer<Event>**来获取**Model**详情，并避免从外部来源进行额外的获取。在我们完成实现时，在*步骤14*中，我们使用检查**Model**状态的标记来完善**EventDetails**组件，并显示关于事件当前容量的信息。
- en: There’s more…
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Interestingly, the in-memory state container isn’t just for holding onto data.
    It’s also handy when managing multi-step forms or complex configuration processes,
    as you can save and retrieve the progress efficiently.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，内存状态容器不仅用于保存数据。在管理多步骤表单或复杂配置过程时，它也非常方便，因为您可以有效地保存和检索进度。
- en: A critical aspect we’ve deliberately omitted is the mechanism for cleaning up
    the state container. Depending on your application’s requirements, you may need
    to persist state for different durations. By following our implementation above,
    simply registering **StateContainer<T>** as **Scoped** ensures that the state
    lives as long as the user session. However, you might face scenarios where you
    need more control over the life cycle of state objects. Should you need to clear
    the state when the user navigates away from a specific component or completes
    a set of steps, implementing **IDisposable** or utilizing **OwningComponentBase**
    for scoped disposal are more effective strategies.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意省略的一个关键方面是清理状态容器的机制。根据您应用程序的要求，您可能需要以不同的时长持久化状态。通过遵循我们上面的实现，简单地注册**StateContainer<T>**为**Scoped**确保状态与用户会话保持一致。然而，您可能会遇到需要更多控制状态对象生命周期的情况。如果您需要在用户离开特定组件或完成一系列步骤时清除状态，实现**IDisposable**或利用**OwningComponentBase**进行作用域内销毁是更有效的策略。
- en: A word of caution before we end this recipe – you must strategically assess
    the feasibility of in-memory state containers in your scenarios. The complexity
    of the persisted objects and the duration of their persistence might put an unnecessary
    strain on application memory and lead to performance issues.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束这个食谱之前，我要提醒大家——你们必须战略性地评估在您的场景中内存状态容器的可行性。持久化对象复杂性和持久化时长可能会对应用程序内存造成不必要的压力，并导致性能问题。
- en: Injecting application state as a service
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将应用程序状态作为服务注入
- en: In this recipe, we will showcase a design pattern to streamline state management
    across your application by introducing an application state service and leveraging
    dependency injection. This method simplifies how components interact with each
    other, enabling them to seamlessly listen to or communicate changes in the application’s
    state. Leveraging dependency injection, you enhance the responsiveness of your
    application and maintain a clean architecture by avoiding tight coupling between
    components. With an application state service, your application remains agile,
    maintainable, and scalable, adapting to the evolving needs of web development.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将通过引入应用程序状态服务和利用依赖注入来展示一个设计模式，以简化跨应用程序的状态管理。这种方法简化了组件之间的交互，使它们能够无缝地监听或通信应用程序状态的变化。通过依赖注入，您提高了应用程序的响应性，并通过避免组件之间的紧密耦合来保持清晰的架构。有了应用程序状态服务，您的应用程序保持敏捷、可维护和可扩展，适应着网络开发的不断变化需求。
- en: Let’s implement an injectable state service that allows us to post and receive
    success and failure messages.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个可注入的状态服务，以便我们可以发布和接收成功和失败的消息。
- en: Getting ready
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before you dive into an injectable state service, do the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究可注入的状态服务之前，请执行以下操作：
- en: Create a **Chapter05** / **Recipe03** directory – this will be your working
    directory
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 **Chapter05** / **Recipe03** 目录——这将是你的工作目录：
- en: Copy the **Config** class with customized **PrerenderDisabled** render mode
    from the *Implementing an in-memory state container* recipe or the **Chapter05**
    / **Recipe03** directory in the GitHub repository
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 *Implementing an in-memory state container* 菜单或 GitHub 仓库中的 **Chapter05**
    / **Recipe03** 目录复制 **Config** 类，并使用定制的 **PrerenderDisabled** 渲染模式：
- en: How to do it…
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow this guide to implement an injectable state service in your application:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 按照此指南在您的应用程序中实现可注入的状态服务：
- en: 'Add a **StateArgs** base record and define the **SuccessArgs** and **FailureArgs**
    state arguments deriving from that base:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 **StateArgs** 基础记录，并定义从该基础记录派生的 **SuccessArgs** 和 **FailureArgs** 状态参数：
- en: '[PRE21]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Introduce a **StoreState** class with an **event** delegate that can be subscribed
    to and a **Notify()** method that accepts **StateArgs** and triggers the **OnChanged**
    event:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引入一个具有 **event** 代理可以订阅的 **StoreState** 类和一个接受 **StateArgs** 并触发 **OnChanged**
    事件的 **Notify()** 方法的 **StoreState** 类：
- en: '[PRE22]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Navigate to the **Program** class and register **StoreState** in the dependency
    injection container:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **Program** 类并在依赖注入容器中注册 **StoreState**：
- en: '[PRE23]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a routable **Store** component that leverages **PrerenderDisabled**
    render mode and implements the **IDisposable** interface:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个可路由的 **Store** 组件，利用 **PrerenderDisabled** 渲染模式并实现 **IDisposable** 接口：
- en: '[PRE24]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the **Store** component **@code** block, inject **StoreState** and initialize
    a **Message** variable:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Store** 组件的 **@code** 块中，注入 **StoreState** 并初始化一个 **Message** 变量：
- en: '[PRE25]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Still in the **@code** block, implement a **ReactAsync()** method to convert
    **StateArgs** into user-friendly messages and apply UI changes:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 **@code** 块中，实现一个将 **StateArgs** 转换为用户友好的消息并应用 UI 变化的 **ReactAsync()** 方法：
- en: '[PRE26]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the **@code** block, override the **OnInitialized()** life cycle method
    to subscribe the **ReactAsync()** method to the **StoreState** event:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **@code** 块中，覆盖 **OnInitialized()** 生命周期方法，将 **ReactAsync()** 方法订阅到 **StoreState**
    事件：
- en: '[PRE27]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Lastly, within the **@code** block, implement the **Dispose()** method as required
    by **IDisposable** and unsubscribe **ReactAsync()** from the **StoreState** event:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 **@code** 块中，实现 **Dispose()** 方法，以满足 **IDisposable** 的要求，并从 **StoreState**
    事件中取消订阅 **ReactAsync()**：
- en: '[PRE28]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the **Store** component’s markup, add two buttons that, upon being clicked,
    call the **Notify()** method with either **SuccessArgs** or **FailureArgs** .
    Include a paragraph to display the current value of the **Message** variable as
    well:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Store** 组件的标记中，添加两个按钮，点击后调用带有 **SuccessArgs** 或 **FailureArgs** 的 **Notify()**
    方法。同时包含一个段落来显示 **Message** 变量的当前值：
- en: '[PRE29]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works…
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we define three object types – **StateArgs** , **SuccessArgs**
    , and **FailureArgs** – to represent states within our application. Leveraging
    inheritance and having **SuccessArgs** and **FailureArgs** inherit from **StateArgs**
    allows us to maintain simplicity in our state-handling logic. In *step 2* , we
    implement the **StoreState** class, which acts as an application state service.
    We expose an event – encapsulating an invocation of an asynchronous method with
    a **StateArgs** parameter and a **Notify()** method – allowing any component to
    communicate state changes. We’ve effectively encapsulated the complexities of
    state transitions behind a simple, intuitive interface. With **StoreState** ready
    to go, in *step 3* , we integrate it into our application’s dependency injection
    container within the **Program** class.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中，我们定义了三种对象类型——**StateArgs**、**SuccessArgs** 和 **FailureArgs**——来表示我们应用程序中的状态。利用继承，并让
    **SuccessArgs** 和 **FailureArgs** 从 **StateArgs** 继承，我们可以在状态处理逻辑中保持简单。在 *步骤 2*
    中，我们实现了 **StoreState** 类，它充当应用程序状态服务。我们公开了一个事件——封装了一个带有 **StateArgs** 参数的异步方法调用和一个
    **Notify()** 方法——允许任何组件通信状态变化。我们有效地将状态转换的复杂性封装在一个简单直观的接口后面。**StoreState** 准备就绪后，在
    *步骤 3* 中，我们将它集成到 **Program** 类中应用程序的依赖注入容器中。
- en: In *step 4* , we create a routable **Store** component to demonstrate the practical
    use of our application state service. We opt for custom **PrerenderDisabled**
    render mode to avoid potential rendering pitfalls; you learned about that in the
    *Implementing an in-memory state container* recipe. We also declare **Store**
    to implement the **IDisposable** interface, indicating that there will be a custom
    cleanup logic to execute. In *step 5* , we inject **StoreState** as **State**
    and initialize the **Message** variable, where we will capture user-friendly snapshots
    of the application’s state for display. In *step 6* , we implement a **ReactAsync()**
    method that acts as a dynamic resolver of **StateArgs** . We update the **Message**
    variable based on the **args** type, pivoting between success and failure states.
    Afterward, we invoke **StateHasChanged()** to notify that the UI state has changed,
    but we wrap it inside the **InvokeAsync()** method to ensure that our UI remains
    responsive and thread-safe.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 4**中，我们创建了一个可路由的**Store**组件来展示我们的应用程序状态服务的实际用途。我们选择自定义**PrerenderDisabled**渲染模式以避免潜在的渲染陷阱；您在*实现内存状态容器*菜谱中了解到这一点。我们还声明**Store**实现**IDisposable**接口，表示将执行自定义清理逻辑。在**步骤
    5**中，我们将**StoreState**作为**State**注入，并初始化**Message**变量，我们将捕获应用程序状态的友好快照以供显示。在**步骤
    6**中，我们实现了一个**ReactAsync()**方法，它充当**StateArgs**的动态解析器。我们根据**args**类型更新**Message**变量，在成功和失败状态之间转换。之后，我们调用**StateHasChanged()**来通知UI状态已更改，但我们将其包装在**InvokeAsync()**方法中，以确保我们的UI保持响应和线程安全。
- en: In *step 7* , we enable the **Store** component to listen to state changes broadcasted
    by **StoreState** . We override the **OnInitialized()** method and subscribe our
    **ReactAsync()** to **State.OnChanged** . In *step 8* , we implement the **Dispose()**
    method, enforced by the **IDisposable** interface. Here, we unsubscribe **ReactAsync()**
    from **State.OnChanged** to prevent memory leaks and guarantee graceful component
    disposal.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 7**中，我们使**Store**组件能够监听由**StoreState**广播的状态变化。我们重写了**OnInitialized()**方法，并将我们的**ReactAsync()**订阅到**State.OnChanged**。在**步骤
    8**中，我们实现了由**IDisposable**接口强制执行的**Dispose()**方法。在这里，我们取消订阅**ReactAsync()**从**State.OnChanged**，以防止内存泄漏并确保组件的优雅销毁。
- en: In *step 9* , we put the **Store** markup in place. We add two buttons – one
    signals success while the other signals failure. Both utilize the **State.Notify()**
    method to orchestrate state changes. Below these buttons, we add paragraph tags
    and render **Message** to visualize the impact of our button’s interactions. To
    keep the example simple, we’re triggering state changes with buttons within the
    same component that listens to those state changes. However, you could place these
    buttons in any component across the application, and our **Store** will still
    accurately receive and react to the state notifications. That’s the true strength
    and agility of having an injectable application state service.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 9**中，我们将**Store**标记放入适当的位置。我们添加了两个按钮——一个表示成功，另一个表示失败。两者都使用**State.Notify()**方法来协调状态变化。在这些按钮下方，我们添加了段落标签，并渲染**Message**以可视化按钮交互的影响。为了保持示例简单，我们使用同一组件内的按钮来触发状态变化，该组件监听这些状态变化。然而，您可以将这些按钮放置在应用程序的任何组件中，我们的**Store**仍然能够准确接收并响应状态通知。这正是具有可注入应用程序状态服务的真正强大和敏捷之处。
- en: See also
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this recipe, we’ve touched on the topic of events in .NET. We won’t dive
    deep into the .NET fundamentals in that book, but if you’re curious to learn more,
    check out the official Microsoft Learn resources: [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/events/](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/events/)
    .'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们触及了.NET中事件的主题。我们不会深入探讨那本书中的.NET基础知识，但如果您想了解更多，请查看官方的Microsoft Learn资源：[https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/events/](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/events/)。
- en: Invoking state changes from anywhere
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从任何地方调用状态变化
- en: In this recipe, we’re exploring injecting state service globally in your Blazor
    application. State service can cover anything from a user’s app personalization
    to user session details or processing indicators. In our example, we’re implementing
    an overlay covering our interface during a long-running task. **Overlay** serves
    as a visual cue to users, signaling that their request is being executed and preventing
    any user interactions that could disrupt the ongoing process.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们正在探索在您的 Blazor 应用程序中全局注入状态服务。状态服务可以涵盖从用户的应用个性化到用户会话详情或处理指示器等任何内容。在我们的示例中，我们实现了一个在长时间运行的任务期间覆盖我们界面的覆盖层。**Overlay**
    作为视觉提示，向用户发出信号，表明他们的请求正在执行，并防止任何可能干扰正在进行的过程的用户交互。
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we explore the strategy to globally inject state service and trigger
    an overlay, do the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索全局注入状态服务和触发覆盖层的策略之前，请执行以下操作：
- en: Create a **Chapter05** / **Recipe04** directory – this will be your working
    directory
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 **Chapter05** / **Recipe04** 目录——这将成为您的工作目录
- en: Copy **Api** and **Event** files from the **Chapter05** / **Data** directory
    in the GitHub repository
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 GitHub 仓库中的 **Chapter05** / **Data** 目录复制 **Api** 和 **Event** 文件
- en: Copy the **Overlay.css** file from the **Chapter05** / **Data** directory in
    the GitHub repository and rename it **Overlay.razor.css** ; after renaming, your
    IDE might display a compilation error – we will explain that behavior and fix
    the error by the end of this recipe
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 GitHub 仓库中的 **Chapter05** / **Data** 目录复制 **Overlay.css** 文件并将其重命名为 **Overlay.razor.css**；重命名后，您的
    IDE 可能会显示编译错误——我们将在本食谱的末尾解释这种行为并修复错误
- en: Register the **Api** service as scoped in the application’s dependency injection
    container (check out the *Having a bookmarkable state* recipe to see how)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序的依赖注入容器中将 **Api** 服务注册为作用域内（查看 *Having a bookmarkable state* 食谱了解如何操作）
- en: How to do it…
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these instructions to add a globally injected overlay state handler:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明添加全局注入的覆盖状态处理器：
- en: 'Create an **OverlayState** class with an **OnChanged** event for subscribers
    to listen to and an **ExecuteAsync()** method that triggers **OnChanged** , both
    before and after executing any job passed to it:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有订阅者可以监听的 **OnChanged** 事件和触发 **OnChanged** 的 **ExecuteAsync()** 方法的 **OverlayState**
    类，该方法在执行传递给它的任何作业之前和之后都会触发：
- en: '[PRE30]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Navigate to the **Program** class and register **OverlayState** in the dependency
    injection container.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **Program** 类并在依赖注入容器中注册 **OverlayState**。
- en: '[PRE31]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Navigate to the main **_Imports.razor** file at the project level and inject
    the **OverlayState** , making it available across all components. You might need
    to reference the missing assembly as well:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到项目级别的 **_Imports.razor** 主文件并注入 **OverlayState**，使其在所有组件中可用。您可能还需要引用缺失的程序集：
- en: '[PRE32]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create an **Overlay** component that implements the **IDisposable** interface:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个实现 **IDisposable** 接口的 **Overlay** 组件：
- en: '[PRE33]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the **@code** block of **Overlay** , initialize an **IsVisible** variable
    and define a **ReactAsync()** method to update **IsVisible** , based on state
    changes:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Overlay** 的 **@code** 块中初始化一个 **IsVisible** 变量并定义一个 **ReactAsync()** 方法来根据状态更改更新
    **IsVisible**：
- en: '[PRE34]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Override the **OnInitialized()** life cycle method in the **@code** block of
    the **Overlay** , and subscribe the **ReactAsync()** method to the **OverlayState.OnChanged**
    event for state change notifications:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Overlay** 的 **@code** 块中重写 **OnInitialized()** 生命周期方法，并将 **ReactAsync()**
    方法订阅到 **OverlayState.OnChanged** 事件以接收状态变更通知：
- en: '[PRE35]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Still within the **@code** block, implement a **Dispose()** **method to unsubscribe**
    **ReactAsync()** from the **OverlayState.OnChanged** event:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 **@code** 块中，实现一个 **Dispose()** 方法来取消订阅 **ReactAsync()** 从 **OverlayState.OnChanged**
    事件：
- en: '[PRE36]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the **Overlay** markup, include an **<overlay>** section that visually represents
    the overlay, and use the **IsVisible** variable to toggle the visibility of this
    section with:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Overlay** 标记中，包含一个表示覆盖层的 **<overlay>** 部分，并使用 **IsVisible** 变量通过以下方式切换此部分的可见性：
- en: '[PRE37]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create a routable **Store** component that renders in **InteractiveWebAssembly**
    mode:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个在 **InteractiveWebAssembly** 模式下渲染的 **Store** 组件：
- en: '[PRE38]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the **Store** component’s **@code** block, inject the **Api** service, and
    implement a **SyncAsync()** method to engage the **OverlayState** for managing
    overlay visibility while executing the **Api** service request:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Store** 组件的 **@code** 块中注入 **Api** 服务，并实现一个 **SyncAsync()** 方法来在执行 **Api**
    服务请求时管理 **OverlayState** 的可见性：
- en: '[PRE39]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the **Store** markup, embed the **Overlay** component, and include a button
    to trigger the **SyncAsync()** method:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Store**标记中，嵌入**Overlay**组件，并包含一个按钮来触发**SyncAsync()**方法：
- en: '[PRE40]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: In *step 1* , we create an **OverlayState** service. As we expect our overlay
    to have a binary nature – visible or hidden – we build a **bool** -based logic.
    We add a subscribable event of type **Func<bool, Task>** and implement an **ExecuteAsync()**
    method, which accepts an asynchronous **job** as a parameter. Within **ExecuteAsync()**
    , we toggle the overlay’s visibility by invoking the **OnChanged** event before
    and after the **job** execution, effectively showing the overlay during processing
    and hiding it upon completion. In *step 2* , we integrate **OverlayState** into
    the dependency injection container, and in *step 3* , we achieve **OverlayState**
    global accessibility by injecting it into the **_Imports.razor** file. **_Imports.razor**
    files in a Blazor application act as encapsulators of adding namespaces and directives,
    enabling them to be accessible across sibling or nested Razor components without
    declaring them explicitly in each.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1步*，我们创建一个**OverlayState**服务。由于我们预计我们的覆盖层将具有二进制性质——可见或隐藏，我们构建了一个基于**bool**的逻辑。我们添加一个可订阅的事件类型**Func<bool,
    Task>**并实现了一个**ExecuteAsync()**方法，该方法接受一个异步**作业**作为参数。在**ExecuteAsync()**中，我们通过在**作业**执行前后调用**OnChanged**事件来切换覆盖层的可见性，有效地在处理期间显示覆盖层，并在完成后隐藏它。在*第2步*，我们将**OverlayState**集成到依赖注入容器中，在*第3步*，我们通过将其注入到**_Imports.razor**文件中来实现**OverlayState**的全局可访问性。Blazor应用程序中的**_Imports.razor**文件充当添加命名空间和指令的封装器，使它们能够在不显式声明的情况下跨兄弟或嵌套Razor组件访问。
- en: In *step 4* , we create an **Overlay** component, interacting with **OverlayState**
    . As we will implement event-driven logic in **Overlay** , we declare it to implement
    the **IDisposable** interface. In *step 5* , we initiate an **IsVisible** variable
    to track the overlay’s visibility state and a **ReactAsync()** method to respond
    to those state changes. Now, we can leverage the **ReactAsync()** method to listen
    to the **OverlayState** event. In *step 6* , we override the **OnInitialized()**
    life cycle method to subscribe to the **OverlayState.OnChanged** event with **ReactAsync()**
    . Now, Blazor will communicate any changes in the overlay state to the **Overlay**
    UI. In *step 7* , we address potential memory leaks and unsubscribe from the **OnChanged**
    event within the **Dispose()** method. In *step 8* , we implement the **Overlay**
    markup. We introduce a custom **<overlay>** tag to avoid conflicts with other,
    standard DOM elements. We use the **IsVisible** flag to toggle the **visible**
    class, deciding whether an overlay is currently visible. Blazor will automatically
    associate the **Overlay.razor.css** collocated styles (which you’ve copied from
    the sample directory) and scope that styling to the **Overlay** component we just
    implemented.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第4步*，我们创建一个**Overlay**组件，与**OverlayState**进行交互。由于我们将在**Overlay**中实现事件驱动逻辑，我们将其声明为实现**IDisposable**接口。在*第5步*，我们初始化一个**IsVisible**变量来跟踪覆盖层的可见状态，以及一个**ReactAsync()**方法来响应这些状态变化。现在，我们可以利用**ReactAsync()**方法来监听**OverlayState**事件。在*第6步*，我们重写**OnInitialized()**生命周期方法，使用**ReactAsync()**订阅**OverlayState.OnChanged**事件。现在，Blazor将把覆盖层状态的变化通知给**Overlay**
    UI。在*第7步*，我们处理潜在的内存泄漏，并在**Dispose()**方法中取消订阅**OnChanged**事件。在*第8步*，我们实现**Overlay**标记。我们引入一个自定义的**<overlay>**标签以避免与其他标准DOM元素冲突。我们使用**IsVisible**标志来切换**visible**类，决定覆盖层当前是否可见。Blazor将自动关联**Overlay.razor.css**同目录样式（您已从示例目录中复制），并将该样式范围限定于我们刚刚实现的**Overlay**组件。
- en: In *step 9* , we shift to showcasing the practical application of **OverlayState**
    and **Overlay** . We create a **Store** component and set it to render in **InteractiveWebAssembly**
    mode. In *step 10* , we inject the **Api** service and implement a **SyncAsync()**
    method. In the **SyncAsync()** method, we leverage **OverlayState.ExecuteAsync()**
    to encapsulate the execution of potentially time-consuming operations and display
    a visual cue in the form of an overlay, ensuring that the user is aware that their
    request is processing. In *step 11* , we introduce the **Store** markup by adding
    the **Overlay** component and a trigger button for the **SyncAsync()** method.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 9* 中，我们转向展示 **OverlayState** 和 **Overlay** 的实际应用。我们创建一个 **Store** 组件，并将其设置为以
    **InteractiveWebAssembly** 模式渲染。在 *步骤 10* 中，我们注入 **Api** 服务并实现一个 **SyncAsync()**
    方法。在 **SyncAsync()** 方法中，我们利用 **OverlayState.ExecuteAsync()** 封装可能耗时的操作执行，并以覆盖的形式显示视觉提示，确保用户知道他们的请求正在处理。在
    *步骤 11* 中，我们通过添加 **Overlay** 组件和 **SyncAsync()** 方法的触发按钮来引入 **Store** 标记。
- en: There’s more…
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: As we’ve injected the **OverlayState** globally across all components, we can
    decouple the **Overlay** presence from any component state. We can achieve that
    by incorporating the **Overlay** tag within the application’s layout file. With
    that, the overlay functionality is omnipresent – you can leverage the overlay
    from any application area with minimal fuss.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经将 **OverlayState** 注入到所有组件中，我们可以将 **Overlay** 的存在与任何组件状态解耦。我们可以通过在应用程序的布局文件中包含
    **Overlay** 标签来实现这一点。有了这个，覆盖功能无处不在——您可以从任何应用程序区域轻松利用覆盖功能。
- en: 'Here’s what the layout could look like:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是布局可能的样子：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Persisting state
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化状态
- en: In modern web development, the ability to persist application and session states
    is no longer a luxury but a necessity. Whether it’s to enhance user experience,
    safeguard user progress, or maintain preferences across sessions, state persistence
    plays a pivotal role in creating seamless and engaging digital experiences. Consider
    the convenience of saving local application configurations on the client side,
    such as a user’s preference for dark mode or their choice to receive push notifications.
    Similarly, persisting parts of the session state can be crucial for ensuring that
    users don’t lose valuable progress due to unexpected disruptions – imagine the
    frustration it would cause. These small touches can significantly boost the usability
    and personalization of any application. Let’s see how to persist state in your
    Blazor app.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代网络开发中，持久化应用程序和会话状态不再是奢侈品，而是必需品。无论是为了增强用户体验、保护用户进度，还是跨会话维护偏好设置，状态持久化在创建无缝和引人入胜的数字体验中发挥着关键作用。考虑在客户端保存本地应用程序配置的便利性，例如用户对深色模式的偏好或他们选择接收推送通知的选择。同样，持久化会话状态的一部分对于确保用户不会因为意外中断而丢失宝贵的进度至关重要——想象一下这会带来多大的挫败感。这些小细节可以显著提高任何应用程序的可用性和个性化。让我们看看如何在您的
    Blazor 应用程序中持久化状态。
- en: Let’s implement an option to switch between light and dark modes and persist
    a proper setting flag in a user’s browser.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个选项来在浅色和深色模式之间切换，并在用户的浏览器中持久化一个合适的设置标志。
- en: Getting ready
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before implementing state persistence, do the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现状态持久化之前，请执行以下操作：
- en: Create a **Chapter05** / **Recipe05** directory – this will be your working
    directory
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 **Chapter05** / **Recipe05** 目录——这将成为您的工作目录
- en: How to do it…
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Follow these steps to implement state persistence:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现状态持久化：
- en: 'Add an **{ASSEMBLY_NAME}.lib.module.js** file within the wwwroot directory
    of your client application, and define a **browserStorage** object with a **set**
    function that is capable of storing a **key** - **value** pair in either session
    storage or local storage, based on a **type** parameter:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的客户端应用的 wwwroot 目录中添加一个 **{ASSEMBLY_NAME}.lib.module.js** 文件，并定义一个具有 **set**
    函数的 **browserStorage** 对象，该函数能够根据 **type** 参数在会话存储或本地存储中存储一个 **key** - **value**
    对：
- en: '[PRE42]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a generic, abstract **StorageValue** class with the **Key** and **Value**
    properties, aligning with the parameters expected by the **browserStorage.set**
    function:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有 **Key** 和 **Value** 属性的通用、抽象 **StorageValue** 类，与 **browserStorage.set**
    函数期望的参数相匹配：
- en: '[PRE43]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create **LocalStorageValue** and **SessionStorageValue** records – specific
    implementations of **StorageValue** for different browser storage types:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 **LocalStorageValue** 和 **SessionStorageValue** 记录——针对不同浏览器存储类型的 **StorageValue**
    的特定实现：
- en: '[PRE44]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create a **BrowserStorage** class within your application, and inject the **IJSRuntime**
    service available in Blazor by default:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的应用程序中创建一个**BrowserStorage**类，并通过Blazor默认提供的**IJSRuntime**服务进行注入：
- en: '[PRE45]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Inside the **BrowserStorage** , define **const** values to ensure the consistency
    of the logic:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**BrowserStorage**内部，定义**const**值以确保逻辑的一致性：
- en: '**_setFunc** to store the JavaScript function name'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**_setFunc**用于存储JavaScript函数名'
- en: '**_local** and **_session** to reference the storage types:'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**_local**和**_session**用于引用存储类型：'
- en: '[PRE46]'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Still inside **BrowserStorage** , implement a **PersistAsync()** method, accepting
    a **StorageValue<T>** parameter. Utilize **JsonSerializer** to convert the value
    to JSON and determine the appropriate storage location, before invoking the **browserStorage.set**
    function:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在**BrowserStorage**中，实现一个**PersistAsync()**方法，接受一个**StorageValue<T>**参数。利用**JsonSerializer**将值转换为JSON并确定适当的存储位置，然后调用**browserStorage.set**函数：
- en: '[PRE47]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Navigate to the application’s **Program** class and register the **BrowserStorage**
    service in the dependency injection container:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到应用程序的**Program**类并在依赖注入容器中注册**BrowserStorage**服务：
- en: '[PRE48]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create a routable **Settings** component that renders in **InteractiveWebAssembly**
    mode:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个可路由的**Settings**组件，以**InteractiveWebAssembly**模式渲染：
- en: '[PRE49]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Within the **@code** block of **Settings** , inject **BrowserStorage** and
    declare constant keys dedicated to managing view mode persistence:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Settings**的**@code**块中注入**BrowserStorage**并声明用于管理视图模式持久化的专用常量键：
- en: '[PRE50]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Still in the **@code** block, implement a **SetViewModeAsync()** method that
    takes a **mode** parameter, encapsulates it within a **LocalStorageValue<string>**
    object, and persists it using the **BrowserStorage.PersistAsync()** method:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在**@code**块中，实现一个**SetViewModeAsync()**方法，该方法接受一个**mode**参数，将其封装在一个**LocalStorageValue<string>**对象中，并使用**BrowserStorage.PersistAsync()**方法进行持久化：
- en: '[PRE51]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the **Settings** component’s markup, introduce two buttons that utilize
    the **SetViewModeAsync()** method to adjust the application’s view mode – one
    to set light mode and the other for dark mode:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**设置**组件的标记中，引入两个按钮，它们使用**SetViewModeAsync()**方法来调整应用程序的视图模式——一个用于设置浅色模式，另一个用于深色模式：
- en: '[PRE52]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works…
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we will require a piece of custom **JavaScript** to lay the
    foundation of our process. We utilize the **{ASSEMBLY_NAME}.lib.module.js** file,
    which resides in the **wwwroot** folder of our client-side project; if you don’t
    have it yet, create one. Blazor will automatically embed it, so explicit registration
    is not required. In *step 1* , we navigate to that **.js** file and define a **browserStorage**
    API. For now, we implement just a **set** function that accepts the **type** ,
    **key** , and **value** parameters, and depending on the specified **type** ,
    it invokes the **setItem** function of either the **sessionStorage** or **localStorage**
    instance.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们需要一段自定义的**JavaScript**来为我们处理过程打下基础。我们使用位于客户端项目**wwwroot**文件夹中的**{ASSEMBLY_NAME}.lib.module.js**文件；如果您还没有，请创建一个。Blazor将自动嵌入它，因此不需要显式注册。在*步骤
    1*中，我们导航到该**.js**文件并定义一个**browserStorage** API。目前，我们只实现了一个**set**函数，它接受**type**、**key**和**value**参数，并根据指定的**type**，调用**sessionStorage**或**localStorage**实例的**setItem**函数。
- en: In *step 2* , we create a **StorageValue** generic record with the **Key** and
    **Value** properties. By marking this record as **abstract** , we signal our intention
    to use it as a foundation for more specific storage values. And we implement just
    that in *step 3* , where we add **LocalStorageValue** and **SessionStorageValue**
    , both inheriting from **StorageValue** .
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 2*中，我们创建了一个具有**Key**和**Value**属性的**StorageValue**泛型记录。通过将此记录标记为**abstract**，我们表明我们的意图是将其用作更具体存储值的基石。在*步骤
    3*中，我们实现了这一点，添加了**LocalStorageValue**和**SessionStorageValue**，它们都继承自**StorageValue**。
- en: In *step 4* , we initiate the **BrowserStorage** service. As we need to call
    a JavaScript function from our C# code, we inject Blazor’s baked-in **IJSRuntime**
    into our service. In *step 5* , we introduce a few **const** values to anchor
    our persistence logic. With **_setFunc** , we encapsulate the naming of the JavaScript
    function we want to call, while **_local** and **_session** identify the two available
    browser storage types. In *step 6* , we finalize the **BrowserStorage** implementation
    with the **PersistAsync()** generic method. However, browser storage allows us
    to store **string** types only. We address that constraint by leveraging the **JsonSerializer**
    to transform our **value** object into a **JSON** format. Then, using the **is**
    operator and our constant values, we resolve the appropriate browser storage type.
    Having all the required payload, we end the **PersistAsync()** logic by delegating
    work to the **browserStorage.set** function, with the help of the **IJSRuntime**
    reference and its **InvokeVoidAsync()** method. Now, we need to make our **BrowserStorage**
    available for components. In *step 7* , we navigate to the **Program** class and
    register **BrowserStorage** within the dependency injection container. Given the
    stateless nature of **BrowserStorage** , we opt for a **Transient** lifetime to
    avoid unnecessary memory use.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第4步*中，我们初始化**BrowserStorage**服务。由于我们需要从我们的C#代码中调用JavaScript函数，我们将Blazor内置的**IJSRuntime**注入到我们的服务中。在*第5步*中，我们引入了一些**const**值来锚定我们的持久化逻辑。通过**_setFunc**，我们封装了我们想要调用的JavaScript函数的命名，而**_local**和**_session**则标识了两种可用的浏览器存储类型。在*第6步*中，我们使用**PersistAsync()**泛型方法最终确定**BrowserStorage**的实现。然而，浏览器存储只允许我们存储**string**类型。我们通过利用**JsonSerializer**将我们的**value**对象转换为**JSON**格式来解决这个问题。然后，使用**is**运算符和我们的常量值，我们解决适当的浏览器存储类型。拥有所有所需的负载后，我们通过委托工作到**browserStorage.set**函数来结束**PersistAsync()**逻辑，借助**IJSRuntime**引用及其**InvokeVoidAsync()**方法。现在，我们需要使我们的**BrowserStorage**对组件可用。在*第7步*中，我们导航到**Program**类，并在依赖注入容器中注册**BrowserStorage**。鉴于**BrowserStorage**的无状态特性，我们选择**Transient**生命周期以避免不必要的内存使用。
- en: In *step 8* , we create a **Settings** component and set it to render in **InteractiveWebAssembly**
    mode, ensuring the component’s interactivity. Then, in *step 9* , we inject **BrowserStorage**
    into the **Settings** and declare a few constant variables – **_key** , which
    holds the storage value key, and **_light** and **_dark** , which outline the
    available view modes. In *step 10* , we implement the **SetViewModeAsync()** method,
    where we initialize the **LocalStorageValue** variable with our **_key** and the
    **mode** parameter and invoke the **PersistAsync()** method of the injected **BrowserStore**
    service. To wrap it up, in *step 11* , we add two buttons to the **Settings**
    component markup. With these buttons, users can invoke the **SetViewModeAsync()**
    method and set the selected view mode in the browser’s local storage.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第8步*中，我们创建了一个**设置**组件，并将其设置为以**InteractiveWebAssembly**模式渲染，确保组件的交互性。然后，在*第9步*中，我们将**BrowserStorage**注入到**设置**组件中，并声明了一些常量变量——**_key**，它存储存储值的键，以及**_light**和**_dark**，它们概述了可用的视图模式。在*第10步*中，我们实现了**SetViewModeAsync()**方法，其中我们使用我们的**_key**和**mode**参数初始化**LocalStorageValue**变量，并调用注入的**BrowserStore**服务的**PersistAsync()**方法。为了总结，在*第11步*中，我们在**设置**组件的标记中添加了两个按钮。通过这些按钮，用户可以调用**SetViewModeAsync()**方法，并在浏览器的本地存储中设置所选的视图模式。
- en: 'Steps may vary a little between browsers, but here’s how you can peak the **viewMode**
    key value with Chrome DevTools:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤在不同浏览器之间可能略有不同，但以下是您如何使用Chrome DevTools查看**viewMode**键值的方法：
- en: '![Figure 5.1: Peaking the value persisted in a browser’s local storage with
    Chrome DevTools](img/Figure_5.1_B22020.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1：使用Chrome DevTools查看浏览器本地存储中持久化的值](img/Figure_5.1_B22020.jpg)'
- en: 'Figure 5.1: Peaking the value persisted in a browser’s local storage with Chrome
    DevTools'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：使用Chrome DevTools查看浏览器本地存储中持久化的值
- en: There’s more…
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We’ve developed a custom JavaScript function to enable access to a browser’s
    storage, as this implementation remains functional across both server and client-side
    scenarios, offering broad compatibility and flexibility. When integrating JavaScript
    into Blazor applications, you must remember that services depending on **IJSRuntime**
    cannot be registered as singletons. **IJSRuntime** requires access to each user’s
    browser session, which makes it architecturally incompatible with the singleton
    initialization pattern and lifetime model.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发了一个自定义JavaScript函数，以启用对浏览器存储的访问，因为这个实现可以在服务器端和客户端场景中保持功能，提供广泛的兼容性和灵活性。当将JavaScript集成到Blazor应用程序中时，你必须记住，依赖于**IJSRuntime**的服务不能注册为单例。**IJSRuntime**需要访问每个用户的浏览器会话，这使得它与单例初始化模式和生命周期模型在架构上不兼容。
- en: However, for projects strictly confined to server-side Blazor, you should consider
    leveraging the built-in **ProtectedBrowserStorage** API. **ProtectedBrowserStorage**
    is a Blazor-native mechanism that enables browser storage access with a data encryption
    layer that doesn’t require custom JavaScript at all.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于严格限制在服务器端Blazor的项目，你应该考虑利用内置的**ProtectedBrowserStorage** API。**ProtectedBrowserStorage**是Blazor原生机制，它通过一个不需要任何自定义JavaScript的数据加密层启用浏览器存储访问。
- en: Resolving persisted state
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决持久化状态
- en: In the previous recipe, you explored persisting application state within a browser’s
    storage. Building upon this foundation, in this recipe, we’ll focus on an equally
    crucial aspect – restoring that persisted state. That functionality is invaluable
    when dealing with user-specific local application personalization, such as the
    preference between dark or light mode or the consent to receive push notifications.
    With state persistence and resolution, you offer users the convenience of rejoining
    their sessions exactly where they left them. This continuity is fundamental in
    crafting a user-centric application and offering a personalized experience.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中，你探索了在浏览器存储中持久化应用程序状态。在这个基础上，在这个菜谱中，我们将关注同样重要的一个方面——恢复那个持久化的状态。这个功能在处理用户特定的本地应用程序个性化时非常有价值，例如在暗色或亮色模式之间的偏好或接收推送通知的同意。通过状态持久化和解决，你为用户提供了一种方便的方式，让他们能够从他们离开的地方重新加入会话。这种连续性在构建以用户为中心的应用程序和提供个性化体验方面是基本的。
- en: With the light or dark mode persisted in the last recipe, let’s implement an
    option to resolve a persisted view mode value when a component renders.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中保持亮色或暗色模式的情况下，让我们实现一个选项，当组件渲染时解决持久化的视图模式值。
- en: Getting ready
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before you start resolving persisted state, do the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始解决持久化状态之前，请执行以下操作：
- en: Create a **Chapter05** / **Recipe06** directory – this will be your working
    directory
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**Chapter05** / **Recipe06**目录——这将是你的工作目录
- en: Copy the **BrowserStorage** , **Settings** , and all **StorageValue** records
    from the *Persisting state* recipe or the **Chapter05** / **Recipe05** directory
    of the GitHub repository
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从*持久化状态*菜谱或GitHub仓库的**Chapter05** / **Recipe05**目录中复制**BrowserStorage**、**Settings**和所有**StorageValue**记录
- en: If you’re not following along the entire chapter but starting with this recipe,
    copy the **BlazorCookbook.App.Client.lib.module.js** file from the **wwwroot**
    directory of the **BlazorCookbook.App.Client** in the GitHub repository to the
    **wwwroot** of your project, and rename it to match your project assembly
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你不是从整个章节开始，而是从这个菜谱开始，请将GitHub仓库中**BlazorCookbook.App.Client**的**wwwroot**目录下的**BlazorCookbook.App.Client.lib.module.js**文件复制到你的项目的**wwwroot**中，并将其重命名为与你的项目程序集匹配
- en: Register the **BrowserStorage** as transient in your application’s **Program**
    class (check out the *Persisting state* recipe to see how)
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的应用程序的**Program**类中将**BrowserStorage**注册为瞬态（查看*持久化状态*菜谱了解如何操作）
- en: How to do it…
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these instructions to implement the resolution of persisted state:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明实现持久化状态的解决：
- en: 'Open the **{ASSEMBLY_NAME}.lib.module.js** script file, and enhance **browserStorage**
    by adding a **get** function that retrieves the persisted value from storage,
    specified by the **type** parameter:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**{ASSEMBLY_NAME}.lib.module.js**脚本文件，通过添加一个**get**函数来增强**browserStorage**，该函数从存储中检索由**type**参数指定的持久化值：
- en: '[PRE53]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the **BrowserStorage** class, introduce a new **_getFunc** variable to hold
    the name of the newly created **browserStorage.get** JavaScript function:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**BrowserStorage**类中，引入一个新的**_getFunc**变量来保存新创建的**browserStorage.get**JavaScript函数的名称：
- en: '[PRE54]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Within the **BrowserStorage** , implement a **ResolveAsync()** generic method,
    accepting a **StorageValue** parameter that fetches the persisted value from the
    appropriate browser storage. Utilize **JsonSerializer** to transform the retrieved
    string into the expected object type:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**BrowserStorage**中实现一个**ResolveAsync()**通用方法，接受一个**StorageValue**参数，从适当的浏览器存储中获取持久化的值。利用**JsonSerializer**将检索到的字符串转换为预期的对象类型：
- en: '[PRE55]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Move to the **Settings** component. Extend the **@code** section with a new
    **ViewMode** variable, and override the **OnAfterRenderAsync()** life cycle method
    with logic to resolve the persisted **viewMode** value in **ViewMode** :'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转向**Settings**组件。在**@code**部分扩展一个新的**ViewMode**变量，并重写**OnAfterRenderAsync()**生命周期方法，其中包含解析持久化的**viewMode**值到**ViewMode**中的逻辑：
- en: '[PRE56]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Enhance the **Settings** component’s markup by adding a paragraph below the
    buttons to display the current **ViewMode** value:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在按钮下方添加一个段落来增强**Settings**组件的标记，以显示当前的**ViewMode**值：
- en: '[PRE57]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works…
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We start by enhancing our **browserStorage** API. In *step 1* , we navigate
    to the **{ASSEMBLY_NAME}.lib.module.js** script file and expand the **browserStorage**
    functionality with a **get** function. We mirror the **set** function’s implementation,
    utilizing the **type** parameter to select the appropriate storage type and fetching
    the value associated with the specified **key** .
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先增强我们的**browserStorage** API。在**步骤 1**中，我们导航到**{ASSEMBLY_NAME}.lib.module.js**脚本文件，并使用**get**函数扩展**browserStorage**功能。我们模仿了**set**函数的实现，利用**type**参数选择适当的存储类型，并获取与指定**key**关联的值。
- en: In *step 2* , we refine our **BrowserStorage** service implementation by introducing
    a **_getFunc** variable to store the name of our newly created **browserStorage.get**
    function, safeguarding against potential typo errors in future references. Following
    this, in *step 3* , we implement a **ResolveAsync()** generic method that mirrors
    the logic of the existing **PersistAsync()** method. **ResolveAsync()** takes
    a **StorageValue** parameter, identifies the correct storage using the **is**
    operator, and calls the **InvokeAsync()** generic method provided by **IJSRuntime**
    to pull the **value** from browser storage. Since this value returns as a JSON
    string, we utilize the **JsonSerializer** API to convert this string back into
    the desired data type.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 2**中，我们通过引入一个**_getFunc**变量来存储我们新创建的**browserStorage.get**函数的名称，从而完善我们的**BrowserStorage**服务实现，以防止未来引用中可能出现的拼写错误。随后，在**步骤
    3**中，我们实现了一个通用的**ResolveAsync()**方法，该方法与现有的**PersistAsync()**方法的逻辑相匹配。**ResolveAsync()**接受一个**StorageValue**参数，使用**is**运算符识别正确的存储，并调用由**IJSRuntime**提供的**InvokeAsync()**通用方法从浏览器存储中提取**value**。由于此值返回为JSON字符串，我们利用**JsonSerializer**
    API将此字符串转换回所需的数据类型。
- en: In *step 4* , we shift to the **Settings** component, where we initialize a
    **ViewMode** variable to hold the resolved value of the user’s persisted view
    mode choice. We then override the **OnAfterRenderAsync()** life cycle method,
    where we use the injected **Storage** service and the newly introduced **ResolveAsync()**
    method to resolve the **ViewMode** value when the **Settings** component initially
    renders. Leveraging the **fast-return pattern** , we ensure that the method exits
    immediately during subsequent component state changes. Since Blazor executes our
    resolving logic post-render, we must invoke the **StateHasChanged()** method to
    refresh the UI with the updated values. Finally, in *step 5* , for the sake of
    simplicity, we add a paragraph below the action buttons within the **Settings**
    markup to display the current **ViewMode** value. Alternatively, you can apply
    CSS classes for light and dark modes to the DOM elements, should you have the
    supporting CSS in place.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 4**中，我们转向**Settings**组件，在其中初始化一个**ViewMode**变量来保存用户持久化视图模式选择的解析值。然后我们重写**OnAfterRenderAsync()**生命周期方法，在其中我们使用注入的**Storage**服务和新引入的**ResolveAsync()**方法在**Settings**组件首次渲染时解析**ViewMode**值。利用**快速返回模式**，我们确保在后续组件状态变化时方法立即退出。由于Blazor在渲染后执行我们的解析逻辑，我们必须调用**StateHasChanged()**方法以刷新带有更新值的UI。最后，在**步骤
    5**中，为了简化，我们在**Settings**标记中的操作按钮下方添加一个段落来显示当前的**ViewMode**值。如果您有相应的CSS，还可以将CSS类应用于DOM元素，以实现浅色和深色模式。
- en: There’s more…
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: We used the **OnAfterRenderAsync()** method to resolve the **ViewMode** value
    for an architectural reason. Blazor blocks all **IJSRuntime** interactions in
    the initial phases of component initialization. Before the DOM is created, the
    component is essentially in a setup phase, initializing and fetching required
    data. Once rendering completes and the DOM structure is in place, Blazor allows
    us to invoke the **IJSRuntime** API and interact with loaded JavaScript functions.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用**OnAfterRenderAsync()**方法根据架构原因解决**ViewMode**值。Blazor在组件初始化的初始阶段阻止所有**IJSRuntime**交互。在DOM创建之前，组件基本上处于设置阶段，初始化和获取所需数据。一旦渲染完成并且DOM结构就绪，Blazor允许我们调用**IJSRuntime**
    API并交互加载的JavaScript函数。
- en: Sharing state across interactive render mode boundaries
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在交互式渲染模式边界之间共享状态
- en: Navigating state management in Blazor apps becomes complicated when you switch
    from running solely in one render mode to mixing render modes, or using **InteractiveAuto**
    mode. The challenge arises from the recreation of a scoped state with every render
    mode change, due to the lack of automatic state sharing between server and client
    environments. You can tackle this fragmentation by designating a single, consistent
    source for state persistence. In this recipe, we will dive into a strategy where
    the client is the source of truth, and we will restore state from the browser
    storage.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从仅在一个渲染模式下运行切换到混合渲染模式或使用**InteractiveAuto**模式时，Blazor应用中的状态管理变得复杂。由于服务器和客户端环境之间缺乏自动状态共享，每次渲染模式更改都会重新创建作用域状态，这导致了这种碎片化。你可以通过指定一个单一、一致的状态持久化源来解决这个问题。在这个配方中，我们将深入研究一个策略，其中客户端是真相的来源，我们将从浏览器存储中恢复状态。
- en: Let’s implement a generic component base that allows us to share state across
    interactive render mode boundaries.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个通用的组件基类，以便我们可以在交互式渲染模式边界之间共享状态。
- en: Getting ready
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before you dive into state sharing, do the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在你深入研究状态共享之前，请执行以下操作：
- en: Create a **Chapter05** / **Recipe07** directory – this will be your working
    directory
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**Chapter05** / **Recipe07**目录——这将是你的工作目录
- en: Copy the **BrowserStorage** and **StorageValue** objects from the *Resolving
    persisted state* recipe or from the **Chapters05** / **Recipe06** directory of
    the GitHub repository
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从“解析持久化状态”配方或从GitHub仓库的**Chapters05** / **Recipe06**目录中复制**BrowserStorage**和**StorageValue**对象
- en: If you’re not following along the entire chapter but starting with this recipe,
    copy the **BlazorCookbook.App.Client.lib.module.js** file from the **wwwroot**
    directory of the **BlazorCookbook.App.Client** in the GitHub repository to the
    **wwwroot** of your project, and rename it to match your project assembly
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你不是从本章的整个内容开始，而是从这个配方开始，请从GitHub仓库中的**BlazorCookbook.App.Client**的**wwwroot**目录中复制**BlazorCookbook.App.Client.lib.module.js**文件到你的项目的**wwwroot**，并将其重命名为与你的项目程序集匹配
- en: Register the **BrowserStorage** as transient in your application’s **Program**
    class (check out the *Persisting state* recipe to see how)
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的应用程序的**Program**类中将**BrowserStorage**注册为瞬态（查看*持久化状态*配方了解如何操作）
- en: How to do it…
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to implement sharing state across interactive render mode
    boundaries:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在交互式渲染模式边界之间实现状态共享：
- en: 'Create a **CartState** class, with an **UpdateTime** property and an **Add()**
    method that mimics adding to the cart and refreshes **UpdateTime** :'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有**UpdateTime**属性和**Add()**方法的**CartState**类，该方法模拟添加到购物车并刷新**UpdateTime**：
- en: '[PRE58]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Navigate to the **Program** class and register a global **CascadingValue**
    for **CartState** :'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**Program**类并注册一个全局的**CascadingValue**用于**CartState**：
- en: '[PRE59]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create a generic **CrossingInteractiveBoundary** component that implements
    the **IAsyncDisposable** interface:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个实现**IAsyncDisposable**接口的通用**CrossingInteractiveBoundary**组件：
- en: '[PRE60]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Within the component’s **@code** section of **CrossingInteractiveBoundary**
    , define a unique state identifier, **_key** , inject **BrowserStorage** , and
    use **CascadingParameter** to intercept the generic **State** :'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**CrossingInteractiveBoundary**组件的**@code**部分中，定义一个唯一的状态标识符**_key**，注入**BrowserStorage**，并使用**CascadingParameter**来拦截通用的**State**：
- en: '[PRE61]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Still within the **@code** block, override the **OnAfterRenderAsync()** life
    cycle method to hydrate **State** by fetching the persisted value with **SessionStorageValue**
    , via the **ResolveAsync()** method of **Storage** :'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在**@code**块中，通过覆盖**OnAfterRenderAsync()**生命周期方法，使用**SessionStorageValue**通过**Storage**的**ResolveAsync()**方法获取持久化值来恢复**State**：
- en: '[PRE62]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Lastly, in the **@code** block, to preserve state upon disposal, implement
    a **DisposeAsync()** method, as mandated by the **IAsyncDisposable** contract,
    and send the updated **State** back to the browser storage through the **PersistAsync()**
    method:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在**@code**块中，为了在销毁时保留状态，实现一个**DisposeAsync()**方法，这是由**IAsyncDisposable**契约要求的，并通过**PersistAsync()**方法将更新后的**State**发送回浏览器存储：
- en: '[PRE63]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Create a routable **Cart** component that operates in **InteractiveAuto** render
    mode and inherits from the **CrossingInteractiveBoundary<CartState>** type:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个在**InteractiveAuto**渲染模式下操作的**Cart**组件，并从**CrossingInteractiveBoundary<CartState>**类型继承：
- en: '[PRE64]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In the layout of the **Cart** component, add a button that triggers the **Add()**
    method of **State** and a paragraph to display the current value of the **UpdateTime**
    property:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Cart**组件的布局中，添加一个触发**State**的**Add()**方法的按钮和一个用于显示**UpdateTime**属性当前值的段落：
- en: '[PRE65]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: How it works…
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: In *step 1* , we create a **CartState** state class with an **UpdateTime** property
    and an **Add()** method that refreshes **UpdateTime** with the current UTC, demonstrating
    the dynamic state interactions. In *step 2* , we navigate to the **Program** class,
    and by leveraging Blazor’s **AddCascadingValue()** extension method, we declare
    **CartState** as a globally accessible **CascadingValue** , ensuring that the
    state object is available throughout the application. We declare that the initial
    state of the cart is represented by a new instance of the **CartState** object.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 1**中，我们创建了一个具有**UpdateTime**属性和刷新**UpdateTime**为当前UTC的**Add()**方法的**CartState**状态类，展示了动态状态交互。在**步骤
    2**中，我们导航到**Program**类，并利用Blazor的**AddCascadingValue()**扩展方法，将**CartState**声明为全局可访问的**CascadingValue**，确保状态对象在整个应用程序中可用。我们声明购物车的初始状态由**CartState**对象的新实例表示。
- en: In *step 3* , we introduce the cornerstone of our state-sharing mechanism –
    the **CrossingInteractiveBoundary** component. By implementing the **IAsyncDisposable**
    interface, we prepare **CrossingInteractiveBoundary** to have an asynchronous
    disposal logic. In *step 4* , we define a unique **_key** storage identifier and
    inject **BrowserStorage** to persist state beyond traditional life cycle boundaries.
    With the **CascadingParameter** attribute, we dynamically capture the **State**
    value, regardless of the currently expected type. In *step 5* , we override the
    **OnAfterRenderAsync()** life cycle method of the **CrossingInteractiveBoundary**
    to rehydrate **State** with previously persisted values from the browser’s session
    storage. We utilize the **try** - **catch** structure to gracefully handle scenarios
    where the user initializes state for the first time, so there’s no value to restore.
    In *step 6* , we complete the implementation with the **DisposeAsync()** method,
    but instead of releasing resources, we add logic to persist the **State** value
    with the **PersistAsync()** method of **Storage** . This way, we ensure that the
    state remains updated and recoverable, regardless of navigation actions or rendering
    mode transitions.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 3**中，我们引入了我们状态共享机制的核心——**CrossingInteractiveBoundary**组件。通过实现**IAsyncDisposable**接口，我们为**CrossingInteractiveBoundary**准备了一个异步销毁逻辑。在**步骤
    4**中，我们定义了一个唯一的**_key**存储标识符，并将**BrowserStorage**注入以在传统的生命周期边界之外持久化状态。通过**CascadingParameter**属性，我们动态捕获**State**值，无论当前期望的类型如何。在**步骤
    5**中，我们重写了**CrossingInteractiveBoundary**的**OnAfterRenderAsync()**生命周期方法，使用从浏览器会话存储中持久化的先前值重新激活**State**。我们利用**try**-**catch**结构优雅地处理用户首次初始化状态时没有值可以恢复的情况。在**步骤
    6**中，我们通过**DisposeAsync()**方法完成实现，但不是释放资源，而是添加逻辑使用**Storage**的**PersistAsync()**方法持久化**State**值。这样，我们确保状态保持更新并可恢复，无论导航操作或渲染模式转换。
- en: In *step 7* , we introduce the **Cart** component that renders in dynamic **InteractiveAuto**
    mode and inherits from **CrossingInteractiveBoundary** , with state represented
    by the **CartState** object. Blazor will seamlessly alternate between server-side
    and client-side rendering, which makes it a perfect environment to showcase the
    adaptive state-sharing logic of **CrossingInteractiveBoundary** . In *step 8*
    , we add the **Cart** markup – a button that invokes the **Add()** method of **CartState**
    and a paragraph displaying the current **UpdateTime** value.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 7**中，我们引入了在动态**InteractiveAuto**模式下渲染的**Cart**组件，并从**CrossingInteractiveBoundary**继承，状态由**CartState**对象表示。Blazor将在服务器端和客户端渲染之间无缝切换，这使得它成为展示**CrossingInteractiveBoundary**自适应状态共享逻辑的完美环境。在**步骤
    8**中，我们添加了**Cart**标记——一个调用**CartState**的**Add()**方法的按钮和一个显示当前**UpdateTime**值的段落。
- en: There’s more…
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The strategy we’ve explored in this recipe is not limited to cascading parameters.
    You can also leverage **BrowserStorage** to hydrate and persist the state of the
    state injected as a service (you learned how to implement injectable state in
    the *Injecting application state as a service* recipe). Depending on your architectural
    requirements, you can leverage a **REST API** or **gRPC** service and persist
    state on the server as well. Moreover, as the complexity and size of the state
    object grows, you’ll see that state hydration can cause a visible delay before
    the UI refreshes with the correct data. That’s where the **Overlay** component,
    which we implemented in the *Invoking state changes from anywhere* recipe, comes
    in handy. By temporarily obscuring the UI until state resolution completes, we
    ensure that users experience a seamless and cohesive interface.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中我们探索的策略不仅限于级联参数。你还可以利用 **BrowserStorage** 来激活并持久化作为服务注入的状态（你已经在 *将应用状态注入为服务*
    配方中学习了如何实现可注入状态）。根据你的架构需求，你可以利用 **REST API** 或 **gRPC** 服务，并在服务器上持久化状态。此外，随着状态对象复杂性和大小的增长，你会发现状态激活可能会在UI刷新正确数据之前造成明显的延迟。这就是我们在
    *从任何地方调用状态变化* 配方中实现的 **Overlay** 组件派上用场的地方。通过暂时遮挡UI直到状态解析完成，我们确保用户体验到无缝且一致的用户界面。
