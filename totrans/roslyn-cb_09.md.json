["```cs\nclass C\n{\n void Method(int x)\n {\n x = x + 1;\n }\n}\n\n```", "```cs\nclass (Keyword) C (IdToken)\n{ (OpenBraceToken)\n void (Keyword) Method (IdToken) ( (OpenParenToken) int (Keyword) x (IdToken) ) (CloseParenToken)\n { (OpenBraceToken)\n  x (IdToken) = (EqualsToken) x (IdToken) + (PlusToken) 1 (NumericalLiteralToken) ; (SemiColonToken)\n } (CloseBraceToken)\n} (CloseBraceToken)\n\n```", "```cs\nBoundBlockStatement (1 statements) (Syntax: '{ ... }')\n  BoundExpressionStatement (Syntax: 'x = x + 1;')\n    BoundSimpleAssignmentExpression (Type: System.Int32) (Syntax: 'x = x + 1')\n      Left: BoundParameterReferenceExpression (Type: System.Int32) (Syntax: 'x')\n      Right: BoundBinaryOperatorExpression (IntegerAdd) (Type: System.Int32) (Syntax: 'x + 1')\n          Left: BoundParameterReferenceExpression (Type: System.Int32) (Syntax: 'x')\n          Right: BoundLiteralExpression (Type: System.Int32, Constant: 1) (Syntax: '1')\n\n```", "```cs\n.method private hidebysig instance void Method(int32 x) cil managed\n{\n  // Code size 7 (0x7)\n  .maxstack 8\n  IL_0000: nop\n  IL_0001: ldarg.1\n  IL_0002: ldc.i4.1\n  IL_0003: add\n  IL_0004: starg.s x\n  IL_0006: ret\n} // end of method C::Method\n\n```", "```cs\npublic string GetString(int expression)\n{\n string expressionStr;\n switch (expression)\n {\n  case 1:\n   expressionStr = \"One\";\n   break;\n\n  case 2:\n   expressionStr = \"Two\";\n   break;\n\n  case 3:\n   expressionStr = \"Three\";\n   break;\n\n  default:\n   expressionStr = \"More than three\";\n   break;\n }\n\n return expressionStr;\n}\n\n```", "```cs\nstring expressionStr = expression ?: [1, 2, 3] : [\"One\", \"Two\", \"Three\", \"More than three\"];\n\n```", "```cs\nswitch-expression:\n null-coalescing-expression\n null-coalescing-expression ?: bracketed-argument-list : bracketed-argument-list\n\n bracketed-argument-list:\n [ argument-list ]\n\n```", "```cs\nQuestionColonToken = 8284,\n...\nSwitchExpression = 8658,\n\n```", "```cs\n  <Node Name=\"SwitchExpressionSyntax\" Base=\"ExpressionSyntax\">\n    <Kind Name=\"SwitchExpression\"/>\n    <Field Name=\"Expression\" Type=\"ExpressionSyntax\">\n      <PropertyComment>\n        <summary>ExpressionSyntax node representing the expression of the switch expression.</summary>\n      </PropertyComment>\n    </Field>\n    <Field Name=\"QuestionColonToken\" Type=\"SyntaxToken\">\n      <Kind Name=\"QuestionColonToken\"/>\n      <PropertyComment>\n        <summary>SyntaxToken representing the question mark.</summary>\n      </PropertyComment>\n    </Field>\n    <Field Name=\"Labels\" Type=\"BracketedArgumentListSyntax\">\n      <PropertyComment>\n        <summary>BracketedArgumentListSyntax node representing comma separated labels to switch on.</summary>\n      </PropertyComment>\n    </Field>\n    <Field Name=\"ColonToken\" Type=\"SyntaxToken\">\n      <Kind Name=\"ColonToken\"/>\n      <PropertyComment>\n        <summary>SyntaxToken representing the colon.</summary>\n      </PropertyComment>\n    </Field>\n    <Field Name=\"Values\" Type=\"BracketedArgumentListSyntax\">\n      <PropertyComment>\n        <summary>BracketedArgumentListSyntax node representing the comma separated expression results.</summary>\n      </PropertyComment>\n    </Field>\n    <TypeComment>\n      <summary>Class which represents the syntax node for switch expression.</summary>\n    </TypeComment>\n    <FactoryComment>\n      <summary>Creates a SwitchExpressionSyntax node.</summary>\n    </FactoryComment>\n  </Node>\n\n```", "```cs\nswitch-expression:\n null-coalescing-expression\n null-coalescing-expression ?: bracketed-argument-list : bracketed-argument-list\n\n```", "```cs\n// Valid syntax cases\nexpression ?: [1, 2, 3] : [\"One\", \"Two\", \"Three\", \"More than three\"];\nexpression ?: [MethodCall1()] : [\"One\", \"Two\", \"Three\", \"More than three\"]; // invalid semantics\n\n// Invalid syntax cases\nexpression ?: [MethodCall1(), 2] : \"One\"; // argument lists must be bracketed\nexpression ?: [MethodCall1(), MethodCall2()]; // missing colon and argument list\n\n```", "```cs\nstring expression = ...\n\n// Valid syntax and semantics\nexpression ?: [1, 2, 3] : [\"One\", \"Two\", \"Three\", \"More than three\"];\n\n// Invalid semantics, valid syntax\nexpression ?: [MethodCall1(), 2] : [\"One\", \"Two\", \"Three\"]; // non constant label\nexpression ?: [1.0] : [\"One\", \"Two\"]; // No implicit conversion from label to switch governing type\nexpression ?: [1] : [\"One\", 1.0]; // No implicit conversions to a common type between \"One\" and 1.0\n\n```", "```cs\nConsole.WriteLine(expression ?: [1, 2, 3] : [\"One\", \"Two\", \"Three\", \"More than three\"]);\n\n// expression == 1, prints \"One\"\n// expression == 2, prints \"Two\"\n// expression == 3, prints \"Three\"\n// otherwise, prints \"More than three\"\n\n```", "```cs\ncase '?': \n if (TextWindow.PeekChar() == '?')\n { ...\n }\n else if (TextWindow.PeekChar() == ':')\n {\n TextWindow.AdvanceChar();\n info.Kind = SyntaxKind.QuestionColonToken;\n }\n else\n { ...\n }\n\n```", "```cs\nif (tk == SyntaxKind.QuestionToken && precedence <= Precedence.Ternary)\n{ ...\n}\nelse if (tk == SyntaxKind.QuestionColonToken && precedence <= Precedence.Ternary)\n{\n var questionColonToken = this.EatToken();\n var labels = this.ParseBracketedArgumentList();\n var colon = this.EatToken(SyntaxKind.ColonToken);\n var values = this.ParseBracketedArgumentList();\n leftOperand = _syntaxFactory.SwitchExpression(leftOperand, questionColonToken, labels, colon, values);\n}\n\nreturn leftOperand;\n\n```", "```cs\n case SyntaxKind.EndOfFileToken:\n case SyntaxKind.QuestionColonToken:\n  return false;\n\n```", "```cs\n case SyntaxKind.XmlProcessingInstructionEndToken:\n  return \"?>\";\n case SyntaxKind.QuestionColonToken:\n return \"?:\";\n ...\n\n```", "```cs\nclass Class\n{\n void M(int expr)\n {\n  var exprStr = expr ?: [1, 2, 3] : [\"One\", \"Two\", \"Three\", \"More than three\"];\n  System.Console.WriteLine(exprStr);\n }\n}\n\n```", "```cs\nError CS1003 Syntax error, ':' expected ClassLibrary <%PROJECT_DIR%>\\ClassLibrary\\Class1.cs 5\nError CS1003 Syntax error, '[' expected ClassLibrary <%PROJECT_DIR%>\\ClassLibrary\\Class1.cs 5\nError CS1003 Syntax error, ']' expected ClassLibrary <%PROJECT_DIR%>\\ClassLibrary\\Class1.cs 5\n\n```", "```cs\ncase '?': \n if (TextWindow.PeekChar() == '?')\n { ...\n }\n else if (TextWindow.PeekChar() == ':')\n {\n TextWindow.AdvanceChar();\n info.Kind = SyntaxKind.QuestionColonToken;\n }\n else\n { ...\n }\n\n```", "```cs\nif (tk == SyntaxKind.QuestionToken && precedence <= Precedence.Ternary)\n{ ...\n}\nelse if (tk == SyntaxKind.QuestionColonToken && precedence <= Precedence.Ternary)\n{\n var questionColonToken = this.EatToken();\n var labels = this.ParseBracketedArgumentList();\n var colon = this.EatToken(SyntaxKind.ColonToken);\n var values = this.ParseBracketedArgumentList();\n leftOperand = _syntaxFactory.SwitchExpression(leftOperand, questionColonToken, labels, colon, values);\n}\n\n```", "```cs\nprotected SyntaxToken EatToken(SyntaxKind kind)\n{\n Debug.Assert(SyntaxFacts.IsAnyToken(kind));\n\n var ct = this.CurrentToken;\n if (ct.Kind == kind)\n {\n  MoveToNextToken();\n  return ct;\n }\n\n //slow part of EatToken(SyntaxKind kind)\n return CreateMissingToken(kind, this.CurrentToken.Kind, reportError: true);\n}\n\n```", "```cs\n*Error CS1003 Syntax error, **':' expected** ClassLibrary <%PROJECT_DIR%>\\ClassLibrary\\Class1.cs 5*\n\n```", "```cs\n<Node Name=\"BoundSwitchOperator\" Base=\"BoundExpression\">\n <!-- Non-null type is required for this node kind -->\n <Field Name=\"Type\" Type=\"TypeSymbol\" Override=\"true\" Null=\"disallow\"/>\n\n <Field Name=\"Expression\" Type=\"BoundExpression\"/>\n <Field Name=\"Labels\" Type=\"ImmutableArray&lt;BoundExpression&gt;\"/>\n <Field Name=\"Values\" Type=\"ImmutableArray&lt;BoundExpression&gt;\"/>\n</Node>\n\n```", "```cs\ncase SyntaxKind.SwitchExpression:\n return BindSwitchOperator((SwitchExpressionSyntax)node, diagnostics);\n\n```", "```cs\npublic override BoundNode VisitSwitchOperator(BoundSwitchOperator node)\n{\n // TODO: Implement lowering for switch operator.\n return MakeLiteral(node.Syntax,\n  ConstantValue.Create($\"CodeGen not yet implemented for: '{node.Syntax.ToString()}'\"),\n  _compilation.GetSpecialType(SpecialType.System_String));\n}\n\n```", "```cs\npublic override BoundNode VisitSwitchOperator(BoundSwitchOperator node)\n{\n // TODO: Implement flow analysis for switch operator.\n return null;}\n\n```", "```cs\nclass Class\n{\n public static void Main(string[] args)\n {\n  System.Console.WriteLine(args.Length ?: [0, 1, 2] : [\"Zero\", \"One\", \"Two\", \"More than two\"]);\n }}\n\n```", "```cs\n<Node Name=\"BoundSwitchOperator\" Base=\"BoundExpression\">\n <!-- Non-null type is required for this node kind -->\n <Field Name=\"Type\" Type=\"TypeSymbol\" Override=\"true\" Null=\"disallow\"/>\n\n <Field Name=\"Expression\" Type=\"BoundExpression\"/>\n <Field Name=\"Labels\" Type=\"ImmutableArray&lt;BoundExpression&gt;\"/>\n <Field Name=\"Values\" Type=\"ImmutableArray&lt;BoundExpression&gt;\"/>\n</Node>\n\n```", "```cs\nprivate BoundSwitchOperator ***BindSwitchOperator***(SwitchExpressionSyntax node, DiagnosticBag diagnostics)\n{\n BoundExpression switchExpr = BindValue(node.Expression, diagnostics, BindValueKind.RValue);\n ImmutableArray<BoundExpression> labelsExpr = BindSwitchOperatorArguments(node.Labels, diagnostics);\n ImmutableArray<BoundExpression> valuesExpr = BindSwitchOperatorArguments(node.Values, diagnostics);\n\n // TODO: Add semantic validation for arguments and diagnostics.\n TypeSymbol type = valuesExpr.Length > 1 ? valuesExpr[0].Type : CreateErrorType();\n bool hasErrors = type.IsErrorType();\n\n return new BoundSwitchOperator(node, switchExpr, labelsExpr, valuesExpr, type, hasErrors);\n}\n\n```", "```cs\nprivate ImmutableArray<BoundExpression> BindSwitchOperatorArguments(BracketedArgumentListSyntax node, DiagnosticBag diagnostics)\n{\n AnalyzedArguments analyzedArguments = AnalyzedArguments.GetInstance();\n ImmutableArray<BoundExpression> arguments;\n try\n {\n  BindArgumentsAndNames(node, diagnostics, analyzedArguments);\n  arguments = BuildArgumentsForErrorRecovery(analyzedArguments);\n }\n finally\n {\n  analyzedArguments.Free();\n }\n\n return arguments;\n}\n\n```", "```cs\n// TODO: Implement IOperation support for switch operator.\ninternal partial class BoundSwitchOperator\n{\n protected override OperationKind ExpressionKind => OperationKind.None;\n\n public override void Accept(OperationVisitor visitor)\n {\n  visitor.VisitNoneOperation(this);\n }\n\n public override TResult Accept<TArgument, TResult>(OperationVisitor<TArgument, TResult> visitor, TArgument argument)\n {\n  return visitor.VisitNoneOperation(this, argument);\n }\n}\n\n```", "```cs\n return MakeLiteral(node.Syntax,\n  ConstantValue.Create($\"CodeGen not yet implemented for: '{node.Syntax.ToString()}'\"),\n  _compilation.GetSpecialType(SpecialType.System_String));\n\n```", "```cs\n /// <summary>\n /// Represents a C# switch operator.\n /// </summary>\n /// <remarks>\n /// This interface is reserved for implementation by its associated APIs. We reserve the right to\n /// change it in the future.\n /// </remarks>\n public interface ISwitchChoiceExpression : IOperation\n {\n  /// <summary>\n  /// Switch expression to be tested.\n  /// </summary>\n  IOperation SwitchExpression { get; }\n\n  /// <summary>\n  /// List of labels to compare the switch expression against.\n  /// </summary>\n  ImmutableArray<IOperation> SwitchLabels { get; }\n\n  /// <summary>\n  /// List of values corresponding to the labels.\n  /// </summary>\n  ImmutableArray<IOperation> SwitchValues { get; }\n }\n\n```", "```cs\nclass Class\n{\n public static void Main(string[] args)\n {\n  System.Console.WriteLine(args.Length ?: [0, 1, 2] : [\"Zero\", \"One\", \"Two\", \"More than two\"]);\n }\n}\n\n```", "```cs\n.method public hidebysig static void Main(string[] args) cil managed\n{\n .entrypoint\n // Code size 51 (0x33)\n .maxstack 8\n IL_0000: nop\n IL_0001: ldarg.0\n IL_0002: ldlen\n IL_0003: conv.i4\n IL_0004: brfalse.s IL_0027\n IL_0006: ldarg.0\n IL_0007: ldlen\n IL_0008: conv.i4\n IL_0009: ldc.i4.1\n IL_000a: beq.s IL_0020\n IL_000c: ldarg.0\n IL_000d: ldlen\n IL_000e: conv.i4\n IL_000f: ldc.i4.2\n IL_0010: beq.s IL_0019\n IL_0012: ldstr \"More than two\"\n IL_0017: br.s IL_001e\n IL_0019: ldstr \"Two\"\n IL_001e: br.s IL_0025\n IL_0020: ldstr \"One\"\n IL_0025: br.s IL_002c\n IL_0027: ldstr \"Zero\"\n IL_002c: call void [mscorlib]System.Console::WriteLine(string)\n IL_0031: nop\n IL_0032: ret\n} // end of method Class::Main\n\n```", "```cs\nargs.Length ?: [0, 1, 2] : [\"Zero\", \"One\", \"Two\", \"More than two\"]\n\n```", "```cs\nargs.Length == 0\n  jump to label Val0\nargs.Length == 1\n  jump to label Val1\nargs.Length == 2\n  jump to label Val2\nresult = \"More than two\"\n  jump to label Exit\nVal2:\n result = \"Two\"\n   jump to label Exit\nVal1:\n result = \"One\"\n   jump to label Exit\nVal0:\n result = \"Zero\"\n   jump to label Exit\nExit:\n\n```", "```cs\n/// <summary>\n/// Rewrite switch operator into nested conditional operators.\n/// </summary>\npublic override BoundNode VisitSwitchOperator(BoundSwitchOperator node)\n{\n // just a fact, not a requirement (VisitExpression would have rewritten otherwise)\n Debug.Assert(node.ConstantValue == null);\n\n var rewrittenExpression = VisitExpression(node.Expression);\n var rewrittenLabels = node.Labels.SelectAsArray(l => VisitExpression(l));\n var rewrittenValues = node.Values.SelectAsArray(l => VisitExpression(l));\n var rewrittenType = VisitType(node.Type);\n var booleanType = _compilation.GetSpecialType(SpecialType.System_Boolean);\n\n return RewriteSwitchOperator(\n  node.Syntax,\n  rewrittenExpression,\n  rewrittenLabels,\n  rewrittenValues,\n  rewrittenType,\n  booleanType);\n}\n\n```", "```cs\nprivate static BoundExpression RewriteSwitchOperator(\n SyntaxNode syntax,\n BoundExpression rewrittenExpression,\n ImmutableArray<BoundExpression> rewrittenLabels,\n ImmutableArray<BoundExpression> rewrittenValues,\n TypeSymbol rewrittenType,\n TypeSymbol booleanType)\n{\n Debug.Assert(rewrittenLabels.Length >= 1);\n Debug.Assert(rewrittenLabels.Length + 1 == rewrittenValues.Length);\n\n var label = rewrittenLabels[0];\n var consequence = rewrittenValues[0];\n var condition = new BoundBinaryOperator(label.Syntax, BinaryOperatorKind.Equal, rewrittenExpression, label, null, null, LookupResultKind.Viable, booleanType);\n BoundExpression alternative = rewrittenLabels.Length > 1 ?\n  RewriteSwitchOperator(syntax, rewrittenExpression, rewrittenLabels.RemoveAt(0), rewrittenValues.RemoveAt(0), rewrittenType, booleanType) :\n  rewrittenValues[1];\n return new BoundConditionalOperator(label.Syntax, condition, consequence, alternative, null, rewrittenType);\n}\n\n```", "```cs\n[Fact]\npublic void TestSwitchExpression()\n{\n var text = @\"expr ?: [0, 1, 2] : [\"\"Zero\"\", \"\"One\"\", \"\"Two\"\", \"\"More than two\"\"]\";\n var expr = SyntaxFactory.ParseExpression(text);\n\n Assert.NotNull(expr);\n Assert.Equal(SyntaxKind.SwitchExpression, expr.Kind());\n Assert.Equal(text, expr. ToString());\n Assert.Equal(0, expr.Errors().Length);\n\n var switchExpr = (SwitchExpressionSyntax)expr;\n Assert.NotNull(switchExpr.Expression);\n Assert.Equal(\"expr\", switchExpr.Expression.ToString());\n\n Assert.NotNull(switchExpr.QuestionColonToken);\n Assert.False(switchExpr.QuestionColonToken.IsMissing);\n\n Assert.NotNull(switchExpr.Labels.OpenBracketToken);\n Assert.False(switchExpr.Labels.OpenBracketToken.IsMissing);\n Assert.Equal(3, switchExpr.Labels.Arguments.Count);\n Assert.Equal(\"0\", switchExpr.Labels.Arguments[0].ToString());\n Assert.Equal(\"1\", switchExpr.Labels.Arguments[1].ToString());\n Assert.Equal(\"2\", switchExpr.Labels.Arguments[2].ToString());\n Assert.NotNull(switchExpr.Labels.CloseBracketToken);\n Assert.False(switchExpr.Labels.CloseBracketToken.IsMissing);\n\n Assert.NotNull(switchExpr.ColonToken);\n Assert.False(switchExpr.ColonToken.IsMissing);\n\n Assert.NotNull(switchExpr.Values.OpenBracketToken);\n Assert.False(switchExpr.Values.OpenBracketToken.IsMissing);\n Assert.Equal(4, switchExpr.Values.Arguments.Count);\n Assert.Equal(@\"\"\"Zero\"\"\", switchExpr.Values.Arguments[0].ToString());\n Assert.Equal(@\"\"\"One\"\"\", switchExpr.Values.Arguments[1].ToString());\n Assert.Equal(@\"\"\"Two\"\"\", switchExpr.Values.Arguments[2].ToString());\n Assert.Equal(@\"\"\"More than two\"\"\", switchExpr.Values.Arguments[3].ToString());\n Assert.NotNull(switchExpr.Values.CloseBracketToken);\n Assert.False(switchExpr.Values.CloseBracketToken.IsMissing);\n}\n\n CreateCompilationWithMscorlib(source).VerifyDiagnostics();\n}\n\n```", "```cs\n<%USERS_FOLDER%>\\.nuget\\packages\\xunit.runner.console\\2.2.0-beta4-build3444\\tools\\xunit.console.x86.exe \"<%REPO_ROOT%>\\Binaries\\Debug\\UnitTests\\CSharpCompilerSyntaxTest\\Roslyn.Compilers.CSharp.Syntax.UnitTests.dll\" -html \"<%REPO_ROOT%>\\Binaries\\Debug\\UnitTests\\CSharpCompilerSyntaxTest\\xUnitResults\\Roslyn.Compilers.CSharp.Syntax.UnitTests.html\" -noshadow -method Microsoft.CodeAnalysis.CSharp.UnitTests.ExpressionParsingTexts.TestSwitchExpression\n\n```", "```cs\n[Fact]\npublic void TestSwitchExpressionBinding()\n{\n var source =\n@\"\nclass Class\n{\n public static void Main(string[] args)\n {\n System.Console.WriteLine(args.Length ?: [0, 1, 2] : [\"\"Zero\"\", \"\"One\"\", \"\"Two\"\", \"\"More than two\"\"]);\n }\n}\n\";\n var compilation = CreateCompilationWithMscorlib(source);\n compilation.VerifyDiagnostics();\n\n var tree = compilation.SyntaxTrees[0];\n var model = compilation.GetSemanticModel(tree);\n\n var switchExp = (SwitchExpressionSyntax)tree.GetRoot().DescendantNodes().Where(n => n.IsKind(SyntaxKind.SwitchExpression)).Single();\n Assert.Equal(@\"args.Length ?: [0, 1, 2] : [\"\"Zero\"\", \"\"One\"\", \"\"Two\"\", \"\"More than two\"\"]\", switchExp.ToString());\n var symbolInfo = model.GetSymbolInfo(switchExp);\n Assert.Null(symbolInfo.Symbol);\n var typeInfo = model.GetTypeInfo(switchExp);\n Assert.NotNull(typeInfo.Type);\n Assert.Equal(\"string\", typeInfo.Type.ToString());\n\n symbolInfo = model.GetSymbolInfo(switchExp.Expression);\n Assert.NotNull(symbolInfo.Symbol);\n Assert.Equal(\"System.Array.Length\", symbolInfo.Symbol.ToString());\n\n typeInfo = model.GetTypeInfo(switchExp.Expression);\n Assert.NotNull(typeInfo.Type);\n Assert.Equal(\"int\", typeInfo.Type.ToString());\n\n Assert.Equal(3, switchExp.Labels.Arguments.Count);\n var constantValue = model.GetConstantValue(switchExp.Labels.Arguments[0].Expression);\n Assert.True(constantValue.HasValue);\n Assert.Equal(0, constantValue.Value);\n typeInfo = model.GetTypeInfo(switchExp.Labels.Arguments[0].Expression);\n Assert.NotNull(typeInfo.Type);\n Assert.Equal(\"int\", typeInfo.Type.ToString());\n\n Assert.Equal(4, switchExp.Values.Arguments.Count);\n constantValue = model.GetConstantValue(switchExp.Values.Arguments[0].Expression);\n Assert.True(constantValue.HasValue);\n Assert.Equal(\"Zero\", constantValue.Value);\n typeInfo = model.GetTypeInfo(switchExp.Values.Arguments[0].Expression);\n Assert.NotNull(typeInfo.Type);\n Assert.Equal(\"string\", typeInfo.Type.ToString());\n}\n\n```", "```cs\n<%USERS_FOLDER%>\\.nuget\\packages\\xunit.runner.console\\2.2.0-beta4-build3444\\tools\\xunit.console.x86.exe \"<%REPO_ROOT%>\\Binaries\\Debug\\UnitTests\\CSharpCompilerSemanticTest\\Roslyn.Compilers.CSharp.Semantic.UnitTests.dll\" -html \"<%REPO_ROOT%>\\Binaries\\Debug\\UnitTests\\CSharpCompilerSemanticTest\\xUnitResults\\Roslyn.Compilers.CSharp.Semantic.UnitTests.html\" -noshadow -method Microsoft.CodeAnalysis.CSharp.UnitTests.Semantics.BindingTests.TestSwitchExpressionBinding\n\n```", "```cs\n[Fact]\npublic void TestSwitchExpressionCodeGen()\n{\n string source = @\"\nclass Class\n{\n public static void Main(string[] args)\n {\n System.Console.WriteLine(args.Length ?: [0, 1, 2] : [\"\"Zero\"\", \"\"One\"\", \"\"Two\"\", \"\"More than two\"\"]);\n }\n}\";\n\n var compilation = CompileAndVerify(source, options: TestOptions.DebugExe);\n compilation.VerifyIL(\"Class.Main\", @\"\n{\n // Code size 51 (0x33)\n .maxstack 2\n IL_0000: nop\n IL_0001: ldarg.0\n IL_0002: ldlen\n IL_0003: conv.i4\n IL_0004: brfalse.s IL_0027\n IL_0006: ldarg.0\n IL_0007: ldlen\n IL_0008: conv.i4\n IL_0009: ldc.i4.1\n IL_000a: beq.s IL_0020\n IL_000c: ldarg.0\n IL_000d: ldlen\n IL_000e: conv.i4\n IL_000f: ldc.i4.2\n IL_0010: beq.s IL_0019\n IL_0012: ldstr \"\"More than two\"\"\n IL_0017: br.s IL_001e\n IL_0019: ldstr \"\"Two\"\"\n IL_001e: br.s IL_0025\n IL_0020: ldstr \"\"One\"\"\n IL_0025: br.s IL_002c\n IL_0027: ldstr \"\"Zero\"\"\n IL_002c: call \"\"void System.Console.WriteLine(string)\"\"\n IL_0031: nop\n IL_0032: ret\n}\n\");\n}\n\n```", "```cs\n<%USERS_FOLDER%>\\.nuget\\packages\\xunit.runner.console\\2.2.0-beta4-build3444\\tools\\xunit.console.x86.exe \"<%REPO_ROOT%>\\Binaries\\Debug\\UnitTests\\CSharpCompilerEmitTest\\xUnitResults\\Roslyn.Compilers.CSharp.Emit.UnitTests.html\" -noshadow -method Microsoft.CodeAnalysis.CSharp.UnitTests.CodeGen.CodeGenTests.TestSwitchExpressionCodeGen\n\n```"]