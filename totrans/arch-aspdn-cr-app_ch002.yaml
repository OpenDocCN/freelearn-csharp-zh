- en: 1 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you begin: Join our book community on Discord'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Qr code Description automatically generated](img/file0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The goal of this book is not to create yet another design pattern book; instead,
    the chapters are organized according to scale and topic, allowing you to start
    small with a solid foundation and build slowly upon it, just like you would build
    a program.Instead of a guide covering a few ways of applying a design pattern,
    we will explore the thought processes behind the systems we are designing from
    a software engineer’s point of view.This is not a magic recipe book; from experience,
    there is no magical recipe when designing software; there are only your logic,
    knowledge, experience, and analytical skills. Let’s define “experience” as *your
    past successes and failures*. And don’t worry, you will fail during your career,
    but don’t get discouraged by it. The faster you fail, the faster you can recover
    and learn, leading to successful products. Many techniques covered in this book
    should help you achieve success. Everyone has failed and made mistakes; you aren’t
    the first and certainly won’t be the last. To paraphrase a well-known saying by
    Roosevelt: *the people that never fail are the ones who never do anything*.At
    a high level:'
  prefs: []
  type: TYPE_NORMAL
- en: This book explores basic patterns, unit testing, architectural principles, and
    some ASP.NET Core mechanisms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we move up to the component scale, exploring patterns oriented toward
    small chunks of software and individual units.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, we move to application-scale patterns and techniques, exploring
    ways to structure an application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some subjects covered throughout the book could have a book of their own, so
    after this book, you should have plenty of ideas about where to continue your
    journey into software architecture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are a few pointers about this book that are worth mentioning:'
  prefs: []
  type: TYPE_NORMAL
- en: The chapters are organized to start with small-scale patterns and then progress
    to higher-level ones, making the learning curve easier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of giving you a recipe, the book focuses on the thinking behind things
    and shows the evolution of some techniques to help you understand why the shift
    happened.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many use cases combine more than one design pattern to illustrate alternate
    usage so you can understand and use the patterns efficiently. This also shows
    that design patterns are not beasts to tame but tools to use, manipulate, and
    bend to your will.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As in real life, no textbook solution can solve all our problems; real problems
    are always more complicated than what’s explained in textbooks. In this book,
    I aim to show you how to mix and match patterns to think “architecture” instead
    of giving you step-by-step instructions to reproduce.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The rest of the introduction chapter introduces the concepts we explore throughout
    the book, including refreshers on a few notions. We also touch on .NET, its tooling,
    and some technical requirements.In this chapter, we cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a design pattern?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anti-patterns and code smell.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the web – request/response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with .NET.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a design pattern?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since you just purchased a book about design patterns, I guess you have some
    idea of what design patterns are, but let’s make sure that we are on the same
    page.**Abstract definition**: A design pattern is a proven technique that we can
    use to solve a specific problem.In this book, we apply different patterns to solve
    various problems and leverage some open-source tools to go further, faster! Abstract
    definitions make people sound smart, but understanding concepts requires more
    practice, and there is no better way to learn than by experimenting with something,
    and design patterns are no different.If that definition does not make sense to
    you yet, don’t worry. You should have enough information by the end of the book
    to correlate the multiple practical examples and explanations with that definition,
    making it crystal clear.I like to compare programming to playing with LEGO® because
    what you have to do is very similar: put small pieces together to create something
    bigger. Therefore, if you lack imagination or skills, possibly because you are
    too young, your castle might not look as good as someone with more experience.
    With that analogy in mind, a design pattern is a plan to assemble a solution that
    fits one or more scenarios, like the tower of a castle. Once you designed a single
    tower, you can build multiple by following the same steps. Design patterns act
    as that tower plan and give you the tools to assemble reliable pieces to improve
    your masterpiece (program).However, instead of snapping LEGO® blocks together,
    you nest code blocks and interweave objects in a virtual environment!Before going
    into more detail, well-thought-out applications of design patterns should improve
    your application designs. That is true whether designing a small component or
    a whole system. However, be careful: throwing patterns into the mix just to use
    them can lead to the opposite result: over-engineering. Instead, aim to write
    the least amount of readable code that solves your issue or automates your process.As
    we have briefly mentioned, design patterns apply to different software engineering
    levels, and in this book, we start small and grow to a cloud-scale! We follow
    a smooth learning curve, starting with simpler patterns and code samples that
    bend good practices to focus on the patterns—finally ending with more advanced
    topics and good practices.Of course, some subjects are overviews more than deep
    dives, like automated testing, because no one can fit it all in a single book.
    Nonetheless, I’ve done my best to give you as much information about architecture-related
    subjects as possible to ensure the proper foundations are in place for you to
    get as much as possible out of the more advanced topics, and I sincerely hope
    you’ll find this book a helpful and enjoyable read.Let’s start with the opposite
    of design patterns because it is essential to identify wrong ways of doing things
    to avoid making those mistakes or to correct them when you see them. Of course,
    knowing the right way to overcome specific problems using design patterns is also
    crucial.'
  prefs: []
  type: TYPE_NORMAL
- en: Anti-patterns and code smells
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Anti-patterns and code smells are bad architectural practices or tips about
    possible bad design. Learning about best practices is as important as learning
    about bad ones, which is where we start. The book highlights multiple anti-patterns
    and code smells to help you get started. Next, we briefly explore the first few.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An **anti-pattern** is the opposite of a design pattern: it is a proven flawed
    technique that will most likely cause you trouble and cost you time and money
    (and probably give you headaches).An anti-pattern is a pattern that seems a good
    idea and seems to be the solution you were looking for, but it causes more harm
    than good. Some anti-patterns started as legitimate design patterns and were labelled
    anti-patterns later. Sometimes, it is a matter of opinion, and sometimes the classification
    can be influenced by the programming language or technologies.Let’s look at an
    example next. We will explore some other anti-patterns throughout the book.'
  prefs: []
  type: TYPE_NORMAL
- en: Anti-pattern – God Class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A **God class** is a class that handles too many things. Typically, this class
    serves as a central entity which many other classes inherit or use within the
    application it is the class that knows and manages everything in the system; it
    is *the* class. On the other hand, it is also the class that nobody wants to update,
    which breaks the application every time somebody touches it: **it is an evil class**!The
    best way to fix this is to segregate responsibilities and allocate them to multiple
    classes rather than concentrating them in a single class. We look at how to split
    responsibilities throughout the book, which helps create more robust software.If
    you have a personal project with a *God class* at its core, start by reading the
    book and then try to apply the principles and patterns you learn to divide that
    class into multiple smaller classes that interact together. Try to organize those
    new classes into cohesive units, modules, or assemblies.To help fix God classes,
    we dive into architectural principles in *Chapter 3*, *Architectural Principles*,
    opening the way to concepts such as responsibility segregation.'
  prefs: []
  type: TYPE_NORMAL
- en: Code smells
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **code smell** is an indicator of a possible problem. It points to areas of
    your design that could benefit from a redesign. By “code smell,” we mean “code
    that stinks” or “code that does not smell right.”It is important to note that
    a code smell only indicates the possibility of a problem; it does not mean a problem
    exists. Code smells are usually good indicators, so it is worth analyzing your
    software’s “smelly” parts.An excellent example is when a method requires many
    comments to explain its logic. That often means that the code could be split into
    smaller methods with proper names, leading to more readable code and allowing
    you to get rid of those pesky comments.Another note about comments is that they
    don’t evolve, so what often happens is that the code described by a comment changes,
    but the comment remains the same. That leaves a false or obsolete description
    of a block of code that can lead a developer astray.The same is also true with
    method names. Sometimes, the method’s name and body tell a different story, leading
    to the same issues. Nevertheless, this happens less often than orphan or obsolete
    comments since programmers tend to read and write code better than spoken language
    comments. Nonetheless, keep that in mind when reading, writing, or reviewing code.
  prefs: []
  type: TYPE_NORMAL
- en: Code smell – Control Freak
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An excellent example of a code smell is using the `new` keyword. This indicates
    a hardcoded dependency where the creator controls the new object and its lifetime.
    This is also known as the **Control Freak anti-pattern**, but I prefer to box
    it as a code smell instead of an anti-pattern since the `new` keyword is not intrinsically
    wrong.At this point, you may be wondering how it is possible not to use the `new`
    keyword in object-oriented programming, but rest assured, we will cover that and
    expand on the control freak code smell in *Chapter 7*, *Deep Dive into Dependency
    Injection*.
  prefs: []
  type: TYPE_NORMAL
- en: Code smell – Long Methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The **long methods** code smell is when a method extends to more than 10 to
    15 lines of code. That is a good indicator that you should think about that method
    differently. Having comments that separate multiple code blocks is a good indicator
    of a method that may be too long.Here are a few examples of what the case might
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: The method contains complex logic intertwined in multiple conditional statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method contains a big `switch` block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method does too many things.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method contains duplications of code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To fix this, you could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Extract one or more private methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract some code to new classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reuse the code from external classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have a lot of conditional statements or a huge `switch` block, you could
    leverage a design pattern such as the Chain of Responsibility, or CQRS, which
    you will learn about in *Chapter 10*, *Behavioral Patterns*, and *Chapter 14*,
    *Mediator and CQRS Design Patterns*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Usually, each problem has one or more solutions; you need to spot the problem
    and then find, choose, and implement one of the solutions. Let’s be clear: a method
    containing 16 lines does not necessarily need refactoring; it could be OK. Remember
    that a code smell indicates that there *might* be a problem, not that there necessarily
    *is* one—apply common sense.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the web – request/response
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before going any further, it is imperative to understand the basic concept
    of the web. The idea behind HTTP 1.X is that a client sends an HTTP request to
    a server, and then the server responds to that client. That can sound trivial
    if you have web development experience. However, it is one of the most important
    web programming concepts, irrespective of whether you are building web APIs, websites,
    or complex cloud applications.Let’s reduce an HTTP request lifetime to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The communication starts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client sends a request to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server receives the request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server does something with the request, like executing code/logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server responds to the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The communication ends.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that cycle, the server is no longer aware of the client. Moreover, if
    the client sends another request, the server is unaware that it responded to a
    request earlier for that same client because **HTTP is stateless**.There are mechanisms
    for creating a sense of persistence between requests for the server to be “aware”
    of its clients. The most well-known of these is cookies.If we dig deeper, an HTTP
    request comprises a header and an optional body. Then, requests are sent using
    a specific method. The most common HTTP methods are `GET` and `POST`. On top of
    those, extensively used by web APIs, we can add `PUT`, `DELETE`, and `PATCH` to
    that list.Although not every HTTP method accepts a body, can respond with a body,
    or should be idempotent, here is a quick reference table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Request has body** | **Response has body** | **Idempotent**
    |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | No* | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Yes | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | Yes | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Yes | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | May | May | Yes |'
  prefs: []
  type: TYPE_TB
- en: '* Sending a body with a `GET` request is not forbidden by the HTTP specifications,
    but the semantics of such a request are not defined either. It is best to avoid
    sending `GET` requests with a body.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'An **idempotent** request is a request that always yields the same result,
    whether it is sent once or multiple times. For example, sending the same `POST`
    request multiple times should create multiple similar entities, while sending
    the same `DELETE` request multiple times should delete a single entity. The status
    code of an idempotent request may vary, but the server state should remain the
    same. We explore those concepts in more depth in *Chapter 4*, *Model-View-Controller*.Here
    is an example of a `GET` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The HTTP header comprises a list of key/value pairs representing metadata that
    a client wants to send to the server. In this case, I queried my blog using the
    `GET` method and Google Chrome attached some additional information to the request.
    I replaced the `Cookie` header’s value with `...` because it can be pretty large
    and that information is irrelevant to this sample. Nonetheless, cookies are passed
    back and forth like any other HTTP header.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note about cookies**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The client sends cookies, and the server returns them for every request-response
    cycle. This could kill your bandwidth or slow down your application if you pass
    too much information back and forth (cookies or otherwise). One good example would
    be a serialized identity cookie that is very large.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Another example, unrelated to cookies but that created such a back-and-forth,
    was the good old Web Forms `ViewState`. This was a hidden field sent with every
    request. That field could become very large when left unchecked.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Nowadays, with high-speed internet, it is easy to forget about those issues,
    but they can significantly impact the user experience of someone on a slow network.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'When the server decides to respond to the request, it returns a header and
    an optional body, following the same principles as the request. The first line
    indicates the request’s status: whether it was successful. In our case, the status
    code was `200`, which indicates success. Each server can add more or less information
    to its response. You can also customize the response with code.Here is the response
    to the previous request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that the browser has received the server’s response, it renders the HTML
    webpage. Then, for each resource, it sends another HTTP call to its URI and loads
    it. A resource is an external asset, such as an image, a JavaScript file, a CSS
    file, or a font.After the response, the server is no longer aware of the client;
    the communication has ended. It is essential to understand that to create a pseudo-state
    between each request, we need to use an external mechanism. That mechanism could
    be the *session-state* leveraging cookies, simply using cookies, or some other
    ASP.NET Core mechanisms, or we could create a stateless application. I recommend
    going stateless whenever possible. We write primarily stateless applications in
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you want to learn more about session and state management, I left a link
    in the *Further reading* section at the end of the chapter.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: As you can imagine, the backbone of the internet is its networking stack. The
    **Hypertext Transfer Protocol** (**HTTP**) is the highest layer of that stack
    (layer 7). HTTP is an application layer built on the **Transmission Control Protocol**
    (**TCP**). TCP (layer 4) is the transport layer, which defines how data is moved
    over the network (for instance, the transmission of data, the amount of transmitted
    data, and error checking). TCP uses the **Internet Protocol** (**IP**) layer to
    reach the computer it tries to talk to. IP (layer 3) represents the network layer,
    which handles packet IP addressing.A packet is a chunk of data that is transmitted
    over the wire. We could send a large file directly from a source to a destination
    machine, but that is not practical, so the network stack breaks down large items
    into smaller packets. For example, the source machine breaks a file into multiple
    packets, sends them to the target machine, and then the target reassembles them
    back into the source file. This process allows numerous senders to use the same
    wire instead of waiting for the first transmission to be done. If a packet gets
    lost in transit, the source machine can also send only that packet back to the
    target machine.Rest assured, you don’t need to understand every detail behind
    networking to program web applications, but it is always good to know that HTTP
    uses TCP/IP and chunks big payloads into smaller packets. Moreover, HTTP/1 limits
    the number of parallel requests a browser can open simultaneously. This knowledge
    can help you optimize your apps. For example, a high number of assets to load,
    their size, and the order in which they are sent to the browser can increase the
    page load time, the perceived page load time, or the paint time.To conclude this
    subject and not dig too deep into networking, HTTP/1 is older but foundational.
    HTTP/2 is more efficient and supports streaming multiple assets using the same
    TCP connection. It also allows the server to send assets to the client before
    it requests the resources, called a server push.If you find HTTP interesting,
    HTTP/2 is an excellent place to start digging deeper, as well as the HTTP/3 proposed
    standard that uses the QUIC transport protocol instead of HTTP (RFC 9114). ASP.NET
    Core 7.0+ supports HTTP/3, which is enabled by default in ASP.NET Core 8.0.Next,
    let’s quickly explore .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with .NET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A bit of history: .NET Framework 1.0 was first released in 2002\. .NET is a
    managed framework that compiles your code into an **Intermediate Language** (**IL**)
    named **Microsoft Intermediate Language** (**MSIL**). That IL code is then compiled
    into native code and executed by the **Common Language Runtime** (**CLR**). The
    CLR is now known simply as the **.NET runtime**. After releasing several versions
    of .NET Framework, Microsoft never delivered on the promise of an interoperable
    stack. Moreover, many flaws were built into the core of .NET Framework, tying
    it to Windows.Mono, an open-source project, was developed by the community to
    enable .NET code to run on non-Windows OSes. Mono was used and supported by Xamarin,
    acquired by Microsoft in 2016\. Mono enabled .NET code to run on other OSes like
    Android and iOS. Later, Microsoft started to develop an official cross-platform
    .NET SDK and runtime they named .NET Core.The .NET team did a magnificent job
    building ASP.NET Core from the ground up, cutting out compatibility with the older
    .NET Framework versions. That brought its share of problems at first, but .NET
    Standard alleviated the interoperability issues between the old .NET and the new
    .NET.After years of improvements and two major versions in parallel (Core and
    Framework), Microsoft reunified most .NET technologies into .NET 5+ and the promise
    of a shared **Base Class Library** (**BCL**). With .NET 5, .NET Core simply became
    .NET while ASP.NET Core remained ASP.NET Core. There is no .NET “Core” 4, to avoid
    any potential confusion with .NET Framework 4.X.New major versions of .NET release
    every year now. Even-number releases are **Long-Term Support** (**LTS**) releases
    with free support for 3 years, and odd-number releases (Current) have free support
    for only 18 months.The good thing behind this book is that the architectural principles
    and design patterns covered should remain relevant in the future and are not tightly
    coupled with the versions of .NET you are using. Minor changes to the code samples
    should be enough to migrate your knowledge and code to new versions.Next, let’s
    cover some key information about the .NET ecosystem.'
  prefs: []
  type: TYPE_NORMAL
- en: .NET SDK versus runtime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can install different binaries grouped under SDKs and runtimes. The SDK
    allows you to build and run .NET programs, while the runtime only allows you to
    run .NET programs.As a developer, you want to install the SDK on your deployment
    environment. On the server, you want to install the runtime. The runtime is lighter,
    while the SDK contains more tools, including the runtime.
  prefs: []
  type: TYPE_NORMAL
- en: .NET 5+ versus .NET Standard
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When building .NET projects, there are multiple types of projects, but basically,
    we can separate them into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications target a version of .NET, such as `net5.0` and `net6.0`. Examples
    of that would be an ASP.NET application or a console application.Libraries are
    bundles of code compiled together, often distributed as a NuGet package. .NET
    Standard class library projects allow sharing code between .NET 5+, and .NET Framework
    projects. .NET Standard came into play to bridge the compatibility gap between
    .NET Core and .NET Framework, which eased the transition. Things were not easy
    when .NET Core 1.0 first came out.With .NET 5 unifying all the platforms and becoming
    the future of the unified .NET ecosystem, .NET Standard is no longer needed. Moreover,
    app and library authors should target the base **Target Framework Moniker** (**TFM**),
    for example, `net8.0`. You can also target `netstandard2.0` or `netstandard2.1`
    when needed, for example, to share code with .NET Framework. Microsoft also introduced
    OS-specific TFMs with .NET 5+, allowing code to use OS-specific APIs like `net8.0-android`
    and `net8.0-tvos`. You can also target multiple TFMs when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I’m sure we will see .NET Standard libraries stick around for a while. All projects
    will not just migrate from .NET Framework to .NET 5+ magically, and people will
    want to continue sharing code between the two.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: The next versions of .NET are built over .NET 5+, while .NET Framework 4.X will
    stay where it is today, receiving only security patches and minor updates. For
    example, .NET 8 is built over .NET 7, iterating over .NET 6 and 5.Next, let’s
    look at some tools and code editors.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code versus Visual Studio versus the command-line interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'How can one of these projects be created? .NET Core comes with the `dotnet`
    **command-line interface** (**CLI**), which exposes multiple commands, including
    `new`. Running the `dotnet new` command in a terminal generates a new project.To
    create an empty class library, we can run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That would generate an empty class library in the newly created `MyProject`
    directory.The `-h` option helps discover available commands and their options.
    For example, you can use `dotnet -h` to find the available SDK commands or `dotnet
    new -h` to find out about options and available templates.It is fantastic that
    .NET now has the `dotnet` CLI. The CLI enables us to automate our workflows in
    **continuous integration** (**CI**) pipelines while developing locally or through
    any other process.The CLI also makes it easier to write documentation that anyone
    can follow; writing a few commands in a terminal is way easier and faster than
    installing programs like Visual Studio and emulators.**Visual Studio Code** is
    my favourite text editor. I don’t use it much for .NET coding, but I still do
    to reorganize projects, when it’s CLI time, or for any other task that is easier
    to complete using a text editor, such as writing documentation using Markdown,
    writing JavaScript or TypeScript, or managing JSON, YAML, or XML files. To create
    a C# project, a Visual Studio solution, or to add a NuGet package using Visual
    Studio Code, open a terminal and use the CLI.As for **Visual Studio**, my favourite
    C# IDE, it uses the CLI under the hood to create the same projects, making it
    consistent between tools and just adding a user interface on top of the `dotnet
    new` CLI command.You can create and install additional `dotnet` `new` project
    templates in the CLI or even create global tools. You can also use another code
    editor or IDE if you prefer. Those topics are beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of project templates
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here is an example of the templates that are installed (`dotnet` `new --list`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1: Project templates](img/file1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: Project templates'
  prefs: []
  type: TYPE_NORMAL
- en: 'A study of all the templates is beyond the scope of this book, but I’d like
    to visit the few that are worth mentioning, some of which we will use later:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dotnet new console` creates a console application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet new classlib` creates a class library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet new xunit` creates an xUnit test project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet new web` creates an empty web project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet new mvc` scaffolds an MVC application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet new webapi` scaffolds a web API application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running and building your program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you are using Visual Studio, you can always hit the play button, or *F5*,
    and run your app. If you are using the CLI, you can use one of the following commands
    (and more). Each of them also offers different options to control their behaviour.
    Add the `-h` flag with any command to get help on that command, such as `dotnet
    build -h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `dotnet restore` | Restore the dependencies (a.k.a. NuGet packages) based
    on the `.csproj` or `.sln` file present in the current dictionary. |'
  prefs: []
  type: TYPE_TB
- en: '| `dotnet build` | Build the application based on the `.csproj` or `.sln` file
    present in the current dictionary. It implicitly runs the `restore` command first.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `dotnet run` | Run the current application based on the `.csproj` file present
    in the current dictionary. It implicitly runs the `build` and `restore` commands
    first. |'
  prefs: []
  type: TYPE_TB
- en: '| `dotnet watch run` | Watch for file changes. When a file has changed, the
    CLI updates the code from that file using the hot-reload feature. When that is
    impossible, it rebuilds the application and then reruns it (equivalent to executing
    the `run` command again). If it is a web application, the page should refresh
    automatically. |'
  prefs: []
  type: TYPE_TB
- en: '| `dotnet test` | Run the tests based on the `.csproj` or `.sln` file present
    in the current directory. It implicitly runs the `build` and `restore` commands
    first. We cover testing in the next chapter. |'
  prefs: []
  type: TYPE_TB
- en: '| `dotnet watch test` | Watch for file changes. When a file has changed, the
    CLI reruns the tests (equivalent to executing the `test` command again). |'
  prefs: []
  type: TYPE_TB
- en: '| `dotnet publish` | Publish the current application, based on the `.csproj`
    or `.sln` file present in the current directory, to a directory or remote location,
    such as a hosting provider. It implicitly runs the `build` and `restore` commands
    first. |'
  prefs: []
  type: TYPE_TB
- en: '| `dotnet pack` | Create a NuGet package based on the `.csproj` or `.sln` file
    present in the current directory. It implicitly runs the `build` and `restore`
    commands first. You don’t need a `.nuspec` file. |'
  prefs: []
  type: TYPE_TB
- en: '| `dotnet clean` | Clean the build(s) output of a project or solution based
    on the `.csproj` or `.sln` file present in the current directory. |'
  prefs: []
  type: TYPE_TB
- en: Technical requirements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Throughout the book, we will explore and write code. I recommend installing
    Visual Studio, Visual Studio Code, or both to help with that. I use Visual Studio
    and Visual Studio Code. Other alternatives are Visual Studio for Mac, Riders,
    or any other text editor you choose.Unless you install Visual Studio, which comes
    with the .NET SDK, you may need to install it. The SDK comes with the CLI we explored
    earlier and the build tools for running and testing your programs. Look at the
    `README.md` file in the GitHub repository for more information and links to those
    resources.The source code of all chapters is available for download on GitHub
    at the following address: [https://adpg.link/net6](https://adpg.link/net6).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter looked at design patterns, anti-patterns, and code smells. We also
    explored a few of them. We then moved on to a recap of a typical web application’s
    request/response cycle.We continued by exploring .NET essentials, such as SDK
    versus runtime and app targets versus .NET Standard. We then dug a little more
    into the .NET CLI, where I laid down a list of essential commands, including `dotnet
    build` and `dotnet watch run`. We also covered how to create new projects. This
    has set us up to explore the different possibilities we have when building our
    .NET applications.In the next two chapters, we explore automated testing and architectural
    principles. These are foundational chapters for building robust, flexible, and
    maintainable applications.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at a few practice questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Can we add a body to a `GET` request?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are long methods a code smell?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it true that .NET Standard should be your default target when creating libraries?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a code smell?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some links to consolidate what has been learned in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Overview of how .NET is versioned: [https://adpg.link/n52L](https://adpg.link/n52L)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET CLI overview: [https://adpg.link/Lzx3](https://adpg.link/Lzx3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Custom templates for `dotnet` `new`: [https://adpg.link/74i2](https://adpg.link/74i2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Session and state management in ASP.NET Core: [https://adpg.link/Xzgf](https://adpg.link/Xzgf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
