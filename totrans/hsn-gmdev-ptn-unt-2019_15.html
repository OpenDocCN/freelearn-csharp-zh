<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Visitor</h1>
                </header>
            
            <article>
                
<p>I have to admit that I find the Visitor pattern confusing and strange. I wrestled with the concepts behind this pattern for a while before grasping its design, mostly because I seldom use it, and I mostly read about it from academic sources. But I began to appreciate this pattern when I started to visualize objects not just as chunks of data stored in the heap, but as a structure that can be visited and acted upon by another object. So, this means that it's possible to perform specific operations on elements of an object's structure without modifying it. This approach can be useful when you need to implement a system that needs to traverse a hierarchical structure and execute specific operations on individual nodes.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>The basic principles behind the Visitor pattern</li>
<li>Implementing a simulation of a one-armed factory robot</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="mce-root">This chapter is hands-on. You will need to have a basic understanding of Unity and C#.<br/></p>
<p>We will be using the following Unity engine and C# language concept:</p>
<ul>
<li>Interfaces</li>
</ul>
<p>If you are unfamiliar with this concept, please review it before starting this chapter.</p>
<p>The code files of this chapter can be found on GitHub:</p>
<p class="mce-root"><a href="https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018">https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018</a></p>
<p class="mce-root">Check out the following video to see the code in action:</p>
<p><a href="http://bit.ly/2OsR6d6">http://bit.ly/2OsR6d6</a></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An overview of the Visitor pattern</h1>
                </header>
            
            <article>
                
<p>The primary purpose of the Visitor pattern is simple once you grasp it; a <em>Visitable</em> object permits a Visitor object to operate on a specific element of its structure. This allows the visited object to receive new functionality from visitors.</p>
<p>This description might seem very abstract at first, but it's easier to visualize if you imagine an object as a data structure, instead of a closed-off container of data and logic. With this in mind, you can see that there's a broader array of possibilities in the way of manipulation objects.</p>
<p>In the following diagram, we can visualize those principals:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5b278a21-5e74-4ca7-8fe9-66f68e73b167.png" style="width:39.67em;height:37.42em;"/></p>
<p>There are two key participants in this pattern:</p>
<ul>
<li>The <strong>Visitor</strong> is the interface for concrete visitors</li>
<li>The <strong>Visitable</strong> is the interface for objects that are accepting visitors</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Benefits and drawbacks</h1>
                </header>
            
            <article>
                
<p>The Visitor pattern is not as popular as the singleton pattern or the dependency injection pattern, so there's less controversy surrounding its benefits and drawbacks, which are listed as follows:</p>
<p>The following are the benefits:</p>
<ul>
<li><strong>Separation of data and logic</strong>: The Visitor pattern offers a way to decouple an object's data structures from its behaviors. This approach makes it easier to extend object capabilities by just adding more visitors.</li>
<li><strong>Double dispatch</strong>: The Visitor pattern offers the ability to choose which method to use at runtime, depending on a given argument's type, thereby making the code more dynamic.</li>
</ul>
<p><span>The following are the </span>drawbacks:</p>
<ul>
<li><strong>Code complexity</strong>: The most obvious drawback of the Visitor pattern is that it makes code more obscure. A programmer that's not versed in the intricacies of the <span>Visitor pattern </span>might easily get lost.</li>
<li><strong>Inflexibility</strong>: The Visitor <span>pattern </span>is not an easy pattern to use, and demands consistency in its implementation. It can also be hard to remove once integrated into a code base, so it can be a long-term commitment.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Use case example</h1>
                </header>
            
            <article>
                
<p>We will make our use case simple, so we don't get lost in layers of abstraction while we try to grasp the intricacies of the Visitor pattern. Imagine that we are working on a project in which we need to design an interactive simulation of a robot with a mechanical arm.</p>
<p>The robot is very modular, and primarily built out of various components. So, we want our code to reflect this by making it possible for us to attach individual components to our skeleton robot object dynamically. To achieve this, we are going to use the Visitor pattern, because it offers us a way to dynamically add elements to an object's structure without modifying it <span>directly</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Code example</h1>
                </header>
            
            <article>
                
<p>Now, it's time to implement our one-armed robot, by attaching to it all the components it needs to operate while not modifying its basic structure:</p>
<ol>
<li>Let's start by implementing the Visitor interface, in which we declare those robot parts we are going to operate on with our Visitors:</li>
</ol>
<pre style="padding-left: 60px">public interface IRobotPartVisitor<br/>{<br/>    void Visit(Robot robot);<br/>    void Visit(Battery battery);<br/>    void Visit(MechanicalArm mechanicalArm);<br/>    void Visit(ThermalImager thermalImager);<br/>}</pre>
<ol start="2">
<li>To help us out with our understanding of this pattern, let's implement two concrete Visitor patterns as follows; the first visits all our robot parts and turns them on, while the other one shuts them off:</li>
</ol>
<ul>
<li style="padding-left: 30px"><kbd>RobotPartActivateVisitor</kbd>:</li>
</ul>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class RobotPartActivateVisitor : IRobotPartVisitor<br/>{<br/>    public void Visit(Robot robot)<br/>    {<br/>        Debug.Log("Robot waking up.");<br/>    }<br/><br/>    public void Visit(Battery battery)<br/>    {<br/>        Debug.Log("Battery is charged up.");<br/>    }<br/><br/>    public void Visit(MechanicalArm mechanicalArm)<br/>    {<br/>        Debug.Log("The mechanical arm is actiaved.");<br/>    }<br/><br/>    public void Visit(ThermalImager thermalImager)<br/>    {<br/>        Debug.Log("The thermal imager is turned on.");<br/>    }<br/>}</pre>
<ul>
<li style="padding-left: 30px"><kbd>RobotPartShutdownVisitor</kbd>:</li>
</ul>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class RobotPartShutdownVisitor : IRobotPartVisitor<br/>{<br/>    public void Visit(Robot robot)<br/>    {<br/>        Debug.Log("Robot is going back to sleep.");<br/>    }<br/><br/>    public void Visit(Battery battery)<br/>    {<br/>        Debug.Log("Battery is charging down.");<br/>    }<br/><br/>    public void Visit(MechanicalArm mechanicalArm)<br/>    {<br/>        Debug.Log("The mechanical arm is folding back to it's default position.");<br/>    }<br/><br/>    public void Visit(ThermalImager thermalImager)<br/>    {<br/>        Debug.Log("The thermal imager is turned off.");<br/>    }<br/>}</pre>
<p style="padding-left: 60px">As you can see, it's quite straightforward at this point; we have a <kbd>Visit()</kbd> function for each robot part. This approach permits us to operate on them individually.</p>
<ol start="3">
<li>Now that we have our Visitors ready, it's time for us to implement our Visitables. Let's start by writing our <kbd>Visitable</kbd> interface:</li>
</ol>
<pre style="padding-left: 60px">public interface IRobotPart<br/>{<br/>    void Accept(IRobotPartVisitor robotPartVisitor);<br/>}</pre>
<ol start="4">
<li>Let's now implement our concrete Visitables:</li>
</ol>
<ul>
<li style="padding-left: 30px"><kbd>Battery</kbd>:</li>
</ul>
<pre style="padding-left: 60px">public class Battery : IRobotPart<br/>{<br/>    public void Accept(IRobotPartVisitor robotPartVisitor)<br/>    {<br/>        robotPartVisitor.Visit(this);<br/>    }<br/>}</pre>
<ul>
<li style="padding-left: 30px"><kbd>ThermalImager</kbd>:</li>
</ul>
<pre style="padding-left: 60px">public class ThermalImager : IRobotPart<br/>{<br/>    public void Accept(IRobotPartVisitor robotPartVisitor)<br/>    {<br/>        robotPartVisitor.Visit(this);<br/>    }<br/>}</pre>
<ul>
<li style="padding-left: 30px"><kbd>MechanicalArm</kbd>:</li>
</ul>
<pre style="padding-left: 60px">public class MechanicalArm : IRobotPart<br/>{<br/>    public void Accept(IRobotPartVisitor robotPartVisitor)<br/>    {<br/>        robotPartVisitor.Visit(this);<br/>    }<br/>}</pre>
<p style="padding-left: 60px">Notice how we are referencing the Visitor interface inside the <kbd>Accept()</kbd> function. This piece of code is what makes it possible for our Visitors to operate on our Visitables.</p>
<ol start="5">
<li>It's time for us to build our <kbd>Robot</kbd>, attaching all its core parts by referencing them in its constructor:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class Robot : IRobotPart<br/>{<br/>    private IRobotPart[] robotParts;<br/><br/>    public Robot()<br/>    {<br/>        robotParts = new IRobotPart[] { new MechanicalArm(), new ThermalImager(), new Battery() };<br/>    }<br/><br/>    public void Accept(IRobotPartVisitor robotPartVisitor)<br/>    {<br/>        for (int i = 0; i &lt; robotParts.Length; i++)<br/>        {<br/>            robotParts[i].Accept(robotPartVisitor);<br/>        }<br/>        robotPartVisitor.Visit(this);<br/>    }<br/>}</pre>
<ol start="6">
<li>Finally, we have our <kbd>Client</kbd> class, which acts as a proof of concept by actually triggering our Visitors to operate on our robot's parts:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class Client : MonoBehaviour<br/>{<br/>    void Update()<br/>    {<br/>        // Active robot<br/>        if (Input.GetKeyDown(KeyCode.O))<br/>        {<br/>            IRobotPart robot = new Robot();<br/>            robot.Accept(new RobotPartActivateVisitor());<br/>        }<br/>        <br/>        // Shutdown robot<br/>        if (Input.GetKeyDown(KeyCode.S))<br/>        {<br/>            IRobotPart robot = new Robot();<br/>            robot.Accept(new RobotPartShutdownVisitor());<br/>        }<br/>    }<br/>}</pre>
<p>So, we have implemented a simple, but flexible, use case of the Visitor pattern. The point to bear in mind is that any Visitor can operate on a Visitable object if it has implemented the <kbd>Accept()</kbd> function. This mechanism allows various operations to be performed on a Visitable object without directly modifying it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we reviewed the Visitor, probably one of the most advanced patterns in this book, because it demands that we approach object-oriented programming from a different perspective and start viewing objects as structures instead of abstract entities that exist on the heap. We can now use what we have learned and extend the Visitor pattern to implement systems that need to operate on complex hierarchical data structures, such as XML files or directory trees.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In the next chapter, we are going to review a handy, but straightforward, pattern that's often over-used in Unity, the Façade pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Practical exercise</h1>
                </header>
            
            <article>
                
<p>As a practical exercise, I would recommend studying an advanced use of the Visitor pattern. A perfect example of this is the application of the Visitor pattern to navigate and process an <strong>Abstract Syntax Tree</strong> (<strong><span>AST</span></strong>). These types of implementations can showcase the architectural possibilities that the Visitor pattern offers.</p>
<p>For information on ASTs, please review the <em>Further reading</em> section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li><span><em>Dive Into Design Patterns,</em> by Alexander Shvets<br/>
<a href="https://refactoring.guru/design-patterns/book">https://refactoring.guru/design-patterns/book</a></span></li>
<li><em>Abstract syntax tree</em><br/>
<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">https://en.wikipedia.org/wiki/Abstract_syntax_tree</a><strong><br/></strong></li>
</ul>


            </article>

            
        </section>
    </body></html>