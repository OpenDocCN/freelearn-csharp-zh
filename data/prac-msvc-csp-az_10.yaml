- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: All About Testing the Solution
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于测试解决方案的所有内容
- en: When creating microservices and using **continuous integration and continuous
    delivery** (**CI/CD**), finding errors early is an important part. Having errors
    in production is costly, and it’s best to find them as early as possible. Testing
    helps reduce costs by finding errors early.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建微服务并使用**持续集成和持续部署**（**CI/CD**）时，尽早发现错误是一个重要的部分。在生产环境中出现错误是昂贵的，最好尽早发现它们。测试通过尽早发现错误来帮助降低成本。
- en: This chapter covers different kinds of tests needed with microservices solutions.
    We start creating unit tests, which should be the major tests used because issues
    are found fast, followed by integration tests, where multiple components of the
    solution are tested in collaboration. Integration tests can be done in-process
    where HTTP requests are simulated and in an environment where services are running
    on the systems, which allows you to test the environment under load.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了与微服务解决方案一起需要的不同类型的测试。我们开始创建单元测试，这些测试应该是主要使用的测试，因为问题可以快速发现，接着是集成测试，其中解决方案的多个组件在协作中测试。集成测试可以在进程内进行，其中模拟HTTP请求，也可以在服务在系统上运行的环境中执行，这允许您在负载下测试环境。
- en: 'In this chapter, you’ll learn how to do the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下内容：
- en: Create unit tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建单元测试
- en: Create .NET Aspire integration tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建.NET Aspire集成测试
- en: Create end-to-end .NET Playwright tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建端到端.NET Playwright测试
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: With this chapter, as with the previous chapters, you need an Azure subscription
    and a Docker Desktop.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，您需要一个Azure订阅和Docker Desktop。
- en: 'The code for this chapter can be found in this GitHub repository: [https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下GitHub仓库中找到：[https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/)。
- en: In the `ch10/final` folder, you’ll see these projects with the final result
    of this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ch10/final`文件夹中，您将看到本章的最终结果。
- en: 'These projects are unchanged from previous chapters:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些项目与之前章节相同，但特别关注测试：
- en: '`Codebreaker.AppHost` – The .NET Aspire host project'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.AppHost` – .NET Aspire宿主项目'
- en: '`Codebreaker.ServiceDefaults` – Common service configuration'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.ServiceDefaults` – 通用服务配置'
- en: '`Codebreaker.Bot` – The bot service to run games'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.Bot` – 运行游戏的机器人服务'
- en: 'These projects are unchanged from previous chapters, but of special interest
    for the tests:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些项目与之前章节相同，但特别关注测试：
- en: '`Codebreaker.Analyzers` – This is the project that contains analyzers to verify
    game moves and return results'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.Analyzers` – 这是包含验证游戏移动并返回结果的分析器的项目'
- en: '`Codebreaker.GameApis` – The games API service project'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.GameApis` – 游戏API服务项目'
- en: 'These projects are new:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些项目是新的：
- en: '`Codebreaker.Analyzers.Tests` – Unit tests for the analyzer library'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.Analyzers.Tests` – 分析器库的单元测试'
- en: '`Codebreaker.Bot.Tests` – Unit tests for the bot service library'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.Bot.Tests` – 机器人服务库的单元测试'
- en: '`Codebreaker.GameAPIs.Tests` – Unit tests for the games services project'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.GameAPIs.Tests` – 游戏服务项目的单元测试'
- en: '`Codebreaker.GameAPIs.IntegrationTests` – In-memory integration tests'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.GameAPIs.IntegrationTests` – 内存集成测试'
- en: '`Codebreaker.GameAPIs.Playwright` – Tests with Microsoft Playwright'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.GameAPIs.Playwright` – 使用Microsoft Playwright的测试'
- en: Working through the code with this chapter, you can start using the `start`
    folder, which contains the same projects without the test projects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章学习代码，您可以开始使用`start`文件夹，其中包含与测试项目相同的项目。
- en: To easily deploy the solution to Microsoft Azure, check out the README file
    in the source code repo of this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要轻松地将解决方案部署到Microsoft Azure，请查看本章源代码仓库中的README文件。
- en: Creating unit tests
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建单元测试
- en: Unit tests are tests that test a small piece of testable software. Does this
    functionality behave as expected? These tests should be fast, used directly on
    the developer system (and run with CI as well). With the **Visual Studio Live
    Unit Testing** feature (part of Visual Studio Enterprise), unit tests run while
    the code is updated, even before saving the source code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是测试可测试软件的小部分。这个功能是否按预期工作？这些测试应该快速，直接在开发系统上使用（并且与CI一起运行）。使用**Visual Studio
    Live Unit Testing**功能（Visual Studio Enterprise的一部分），单元测试在代码更新时运行，甚至在保存源代码之前。
- en: The cost of bugs grows during the **software development life cycle** (**SDLC**).
    When bugs are found late (for example, in production), the cost grows exponentially.
    For fixing bugs early (for example, while typing the code), Visual Studio can
    give hints and show errors; as we are already working on the code, it’s not necessary
    to take the time to dive into the functionality as we are already working on it.
    For finding bugs with other test types (for example, integration or load tests),
    the fixes are more expensive – but of course, a lot less expensive than finding
    a bug in production.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发生命周期（**SDLC**）中，错误成本会增长。当错误发现得晚（例如，在生产环境中）时，成本会呈指数增长。对于早期修复错误（例如，在编写代码时），Visual
    Studio可以提供提示并显示错误；因为我们已经在编写代码，所以没有必要花时间去深入研究功能，因为我们已经在处理它了。对于使用其他测试类型（例如，集成或负载测试）查找错误，修复成本更高——但当然，比在生产环境中发现错误要便宜得多。
- en: A goal should be to reduce cost, and thus if some functionality can be verified
    with unit tests and other test types, prefer unit tests.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个目标应该是降低成本，因此如果某些功能可以通过单元测试和其他测试类型进行验证，则优先选择单元测试。
- en: Before we start creating a unit test, what is the heart of the games service
    in need of unit tests? It’s the analyzer library. There’s some complexity with
    the game rules, and it’s easy to make some logical errors writing the code. It’s
    also a place where some refactoring could be done to increase performance and
    reduce memory needs. After refactoring, the application should function in the
    same way.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建单元测试之前，需要单元测试的游戏服务的心脏是什么？它是分析库。游戏规则有一些复杂性，编写代码时容易出错。这也是可以进行一些重构以提高性能和减少内存需求的地方。重构后，应用程序应该以相同的方式运行。
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When I was initially developing the games analyzer library, I created unit tests
    beforehand and enhanced the unit tests while developing the algorithms. With **test-driven
    development** (**TDD**), unit tests are created before the functionality.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我最初开发游戏分析库时，我事先创建了单元测试，并在开发算法的过程中增强了单元测试。使用**测试驱动开发**（**TDD**），单元测试是在功能之前创建的。
- en: Before fixing bugs, I also created new unit tests. Why did the bug occur? Why
    was it not covered by a test? With many different projects, I see bugs that have
    been fixed come back with a later version. If there’s a unit test to verify the
    functionality, the same issue cannot resurface with a new version.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在修复错误之前，我也创建了新的单元测试。错误为什么会发生？为什么它没有被测试覆盖？在许多不同的项目中，我看到一些错误被修复，但在稍后的版本中又出现了。如果有单元测试来验证功能，同样的问题就不会在新版本中再次出现。
- en: Next, let’s dive into the `Codebreaker` code, which needs many unit tests.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们深入到`Codebreaker`代码中，它需要许多单元测试。
- en: Exploring the games analyzer library
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索游戏分析库
- en: 'Let’s explore the `GameGuessAnalyzer` class in the `Codebreaker` analyzer library:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索`Codebreaker`分析库中的`GameGuessAnalyzer`类：
- en: Codebreaker.GameAPIs.Analyzers.Tests/Analyzers/GameGuessAnalyzer.cs
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Analyzers.Tests/Analyzers/GameGuessAnalyzer.cs
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `GetResult` method is the heart of this class. With the constructor of the
    `GameGuessAnalyzer` abstract base class, the game and the guesses are passed with
    parameters. The `GetResult` method uses the codes of the game and uses the guesses
    to return the result – the number of colors that are in the correct position and
    the number of colors that are correct but in the wrong position. The implementation
    of the `GetResult` method is just an invocation of four methods. The `ValidateGuess`
    method analyses the correctness of guesses and throws an exception if the guesses
    are not correct. The `GetCoreResult` method is abstract and needs to be implemented
    by a derived class.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetResult`方法是这个类的核心。使用`GameGuessAnalyzer`抽象基类的构造函数，游戏和猜测通过参数传递。`GetResult`方法使用游戏的代码并使用猜测来返回结果——正确位置的颜色数量和正确但位置错误的颜色数量。`GetResult`方法的实现只是调用四个方法。`ValidateGuess`方法分析猜测的正确性，如果猜测不正确则抛出异常。`GetCoreResult`方法是抽象的，需要由派生类实现。'
- en: 'One of the classes deriving from the `GameGuessAnalyzer` class is the `ColorGameGuessAnalyzer`
    class. This is used by the `Game6x4` and `Game8x5` game types (six colors with
    four codes and eight colors with five codes):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从`GameGuessAnalyzer`类派生的一个类是`ColorGameGuessAnalyzer`类。这个类被`Game6x4`和`Game8x5`游戏类型（六种颜色和四种代码，八种颜色和五种代码）使用：
- en: Codebreaker.Analyzers.Tests/Analyzers/ColorGameGuessAnalyzer.cs
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Analyzers.Tests/Analyzers/ColorGameGuessAnalyzer.cs
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This class overrides the `ValidateGuessValues` and the `GetCoreResult` methods.
    `ValidateGuessValues` validates the input data and throws exceptions if the data
    is not valid. The `GetCoreResult` method implements the algorithm for the `Codebreaker`
    game, finds if the guesses are correctly placed and if the guesses are correct
    but incorrectly placed, and returns the result accordingly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类重写了`ValidateGuessValues`和`GetCoreResult`方法。`ValidateGuessValues`方法验证输入数据，如果数据无效则抛出异常。`GetCoreResult`方法实现了`Codebreaker`游戏的算法，检查猜测是否正确放置，以及猜测正确但放置错误的情况，并相应地返回结果。
- en: Let’s create a unit test project for this library.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个库创建一个单元测试项目。
- en: Creating a unit test project
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建单元测试项目
- en: 'Using the .NET CLI, we can create a new xUnit test project:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用.NET CLI，我们可以创建一个新的xUnit测试项目：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command creates a `Codebreaker.Analyzers.Tests` project with references
    to xUnit NuGet packages and a project reference to the analyzer project.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令创建了一个包含对xUnit NuGet包的引用以及分析器项目引用的`Codebreaker.Analyzers.Tests`项目。
- en: Note
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I’m mainly using xUnit for unit tests. It’s a matter of choice whether to use
    **MSTest**, **NUnit**, or **xUnit**; you can use any of these frameworks for unit
    tests, and all of these are greatly integrated within the .NET tools. I myself
    switched from MSTest to xUnit with early betas of .NET Core 1.0 when xUnit was
    available, but MSTest was not ready for the new .NET – and most unit tests from
    the .NET team themselves are done using xUnit.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我主要使用xUnit进行单元测试。使用**MSTest**、**NUnit**还是**xUnit**是一个选择问题；你可以使用这些框架中的任何一个进行单元测试，并且所有这些框架都很好地集成在.NET工具中。我自己在xUnit可用时，从MSTest切换到xUnit，当时.NET
    Core 1.0的早期测试版，而MSTest还没有准备好迎接新的.NET。而且，.NET团队自己完成的多数单元测试都是使用xUnit。
- en: Before creating the first tests, some preparations need to be done.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建第一个测试之前，需要进行一些准备工作。
- en: Mocking the IGame interface
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟`IGame`接口
- en: 'With the constructor of the `ColorGameGuessAnalyzer` class, an object implementing
    the `IGame` interface is required with the constructor. A unit test should only
    test a small functionality without testing dependencies that are covered by their
    own unit tests. When testing the `ColorGameGuessAnalyzer` class, we don’t want
    to add a dependency to the `Game` class while testing the analyzer. What’s needed
    by the `ColorGameGuessAnalyzer` class is the `IGame` interface. To allow the test
    to run, the `IGame` interface is implemented by a mocking class:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ColorGameGuessAnalyzer`类的构造函数中，需要一个实现`IGame`接口的对象。单元测试应该只测试一小部分功能，而不测试由它们自己的单元测试覆盖的依赖项。在测试`ColorGameGuessAnalyzer`类时，我们不想在测试分析器时添加对`Game`类的依赖。`ColorGameGuessAnalyzer`类需要的是`IGame`接口。为了允许测试运行，由一个模拟类实现了`IGame`接口：
- en: Codebreaker.GameAPIs.Analyzers.Tests/MockColorGame.cs
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Analyzers.Tests/MockColorGame.cs
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `MockColorGame` class is just a simple data holder to implement the `IGame`
    interface, thus we don’t need to use any mocking library. With another unit test
    implementation done later, we’ll use a mocking library to mock functionality that
    should not be tested by the unit test.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`MockColorGame`类只是一个简单的数据持有者，用于实现`IGame`接口，因此我们不需要使用任何模拟库。在稍后完成的另一个单元测试实现中，我们将使用模拟库来模拟不应由单元测试测试的功能。'
- en: Creating test helpers
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建测试辅助方法
- en: 'To define common functionality needed by multiple unit tests, helper methods
    are created within the `ColorGame6x4AnalyzerTests` test class:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义多个单元测试所需的通用功能，在`ColorGame6x4AnalyzerTests`测试类中创建了辅助方法：
- en: Codebreaker.GameAPIs.Analyzers.Tests/Analyzers/ColorGame6x4AnalyzerTests.cs
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Analyzers.Tests/Analyzers/ColorGame6x4AnalyzerTests.cs
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `AnalyzeGame` method receives a string array representing the valid code,
    a string array representing the guesses, and the move number. This information
    is used to create a mocked game instance and to invoke the `GetResult` method
    of the analyzer class. The result of the analysis is returned with a `ColorResult`
    type. This helper method can now be used to easily create unit tests.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnalyzeGame`方法接收一个表示有效代码的字符串数组，一个表示猜测的字符串数组以及移动次数。这些信息用于创建模拟的游戏实例并调用分析器类的`GetResult`方法。分析结果以`ColorResult`类型返回。现在可以使用这个辅助方法轻松创建单元测试。'
- en: Creating a simple unit test
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个简单的单元测试
- en: 'The first unit test is implemented with the `GetResult_Should_ReturnThreeWhite`
    method:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个单元测试是通过`GetResult_Should_ReturnThreeWhite`方法实现的：
- en: Codebreaker.GameAPIs.Analyzers.Tests/ColorGame6x4AnalyzerTests.cs
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Analyzers.Tests/ColorGame6x4AnalyzerTests.cs
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using xUnit, the `Fact` attribute declares a method to be a unit test. A unit
    test consists of three parts: `expectedKeyPegs` variable. Invoking the `AnalyzeGame`
    method is the act. The `Green` – `Yellow` – `Green` – `Black` code is passed as
    valid code, and `Yellow` – `Green` – `Black` – `Blue` as a guess. With this guess,
    no color is in the correct position, but three colors are correct in the wrong
    positions, thus three whites should be returned. If this result is correct, this
    is verified using the `Assert.Equal` method.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用xUnit，`Fact`属性声明一个方法为单元测试。一个单元测试由三个部分组成：`expectedKeyPegs`变量。调用`AnalyzeGame`方法是行为。将`Green`
    – `Yellow` – `Green` – `Black`代码作为有效代码传递，将`Yellow` – `Green` – `Black` – `Blue`作为猜测。这个猜测中，没有颜色在正确的位置，但三种颜色在错误的位置，因此应该返回三个白色。如果这个结果是正确的，使用`Assert.Equal`方法进行验证。
- en: Passing test data to unit tests
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将测试数据传递给单元测试
- en: 'With this scenario, it’s useful to just define one method that’s used with
    different test data to verify the different outcomes:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，定义一个用于不同测试数据以验证不同结果的方法是有用的：
- en: Codebreaker.GameAPIs.Analyzers.Tests/ColorGame6x4AnalyzerTests.cs
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Analyzers.Tests/ColorGame6x4AnalyzerTests.cs
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With xUnit, using the `Theory` attribute instead of the `Fact` attribute allows
    the test method to be invoked multiple times, passing different test data. The
    `GetResult_ShouldReturn_InlineResults` method uses arguments that are specified
    with the `InlineData` attribute. With every `InlineData` attribute, the parameter
    values for the arguments defined with the method are passed. Here, two tests are
    covered with one implementation. This feature allows for quickly extending test
    cases by just adding new `InlineData` attributes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用xUnit，使用`Theory`属性而不是`Fact`属性允许测试方法被多次调用，传递不同的测试数据。`GetResult_ShouldReturn_InlineResults`方法使用由`InlineData`属性指定的参数。每个`InlineData`属性都传递了定义方法的参数的参数值。在这里，一个实现覆盖了两个测试。这个特性允许通过仅添加新的`InlineData`属性来快速扩展测试用例。
- en: 'Instead of using the `InlineDataAttribute` class, a class can be created implementing
    `IEnumerable<object[]>` to supply test data:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用`InlineDataAttribute`类不同，可以创建一个实现`IEnumerable<object[]>`的类来提供测试数据：
- en: Codebreaker.GameAPIs.Analyzers.Tests/ColorGame6x4AnalyzerTests.cs
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Analyzers.Tests/ColorGame6x4AnalyzerTests.cs
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`object[]` defines all the values for one method invocation. The first argument
    passed defines the valid code for the game, the second argument the guess data,
    and the third argument the expected result. With every iteration of `IEnumerable`,
    a new test run is done. The next code snippet shows the test method implementation
    using the data class:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`object[]`定义了一个方法调用所需的所有值。第一个参数定义了游戏的有效代码，第二个参数是猜测数据，第三个参数是预期结果。随着`IEnumerable`的每次迭代，都会进行一次新的测试运行。下一个代码片段展示了使用数据类实现的测试方法：'
- en: Codebreaker.GameAPIs.Analyzers.Tests/ColorGame6x4AnalyzerTests.cs
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Analyzers.Tests/ColorGame6x4AnalyzerTests.cs
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Instead of using the `InlineData` attribute, here `ClassData` is used. Using
    an object returning the test data is more flexible. The `InlineData` attribute
    requires constant values that are stored by the compiler. With the `ClassData`
    attribute, data can also be created dynamically.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用`InlineData`属性不同，这里使用`ClassData`。使用返回测试数据的对象更灵活。`InlineData`属性需要由编译器存储的常量值。使用`ClassData`属性，数据也可以动态创建。
- en: Expecting exceptions with a unit test
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用单元测试期望抛出异常
- en: 'Another test case where we expect an exception to be thrown is shown in the
    next code snippet:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码片段中，展示了另一个我们期望抛出异常的测试用例：
- en: Codebreaker.GameAPIs.Analyzers.Tests/ColorGame6x4AnalyzerTests.cs
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Analyzers.Tests/ColorGame6x4AnalyzerTests.cs
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`Assert.Throws` defines the exception type that should be thrown by the implementation
    when the test data is passed. If an exception is not thrown, the test fails.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Assert.Throws`定义了在传递测试数据时实现应该抛出的异常类型。如果没有抛出异常，测试失败。'
- en: Using a mocking library
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模拟库
- en: 'With some classes that should be tested, it’s great to have a mocking library.
    The `GamesService` class injecting the `IGamesRepository` interface is shown in
    the following code snippet:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些需要测试的类，拥有一个模拟库是非常棒的。以下代码片段展示了注入`IGamesRepository`接口的`GamesService`类：
- en: Codebreaker.GameAPIs/Services/GamesService.cs
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Services/GamesService.cs
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With the `GamesService` class, the `IGamesRepository` interface is injected
    using constructor injection. When testing the `SetMoveAsync` method, the implementation
    of the `IGamesRepository` interface should not be part of this test. There’s another
    test for the games repository. Instead, a mocking implementation of this class
    is used for the unit test. The `SetMoveAsync` method invokes the `GetGameAsync`
    method of the `IGamesRepository` interface. The real implementation of this method
    should not be part of the test, but we need some different results that can be
    used with the methods used afterward. When this method returns `null` because
    it didn’t find the game, `CodebreakerException.ThrowIfNull` should throw an exception.
    If the method returns a game that already ended, the next method should throw
    an exception because a new move cannot be set to a game that already ended. The
    `ThrowIfUnexpectedGameType` method should throw an exception if the game type
    passed is different from the game type of the game retrieved. This can easily
    be solved by using a mocking library.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`GamesService`类，通过构造函数注入将`IGamesRepository`接口注入。在测试`SetMoveAsync`方法时，`IGamesRepository`接口的实现不应包含在这个测试中。还有一个针对游戏存储库的测试。相反，使用这个类的模拟实现进行单元测试。`SetMoveAsync`方法调用`IGamesRepository`接口的`GetGameAsync`方法。这个方法的实际实现不应包含在测试中，但我们需要一些不同的结果，这些结果可以用后续使用的方法来使用。当这个方法返回`null`因为它没有找到游戏时，`CodebreakerException.ThrowIfNull`应该抛出异常。如果方法返回一个已经结束的游戏，下一个方法应该抛出异常，因为不能将新移动设置到已经结束的游戏中。如果传递的游戏类型与检索到的游戏类型不同，`ThrowIfUnexpectedGameType`方法应该抛出异常。这可以通过使用模拟库轻松解决。
- en: Let’s create another xUnit test project named `Codebreaker.GameAPIs.Tests` to
    test the `GamesService` class. To mock the `IGamesRepository` interface, add the
    `moq` NuGet package.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个名为`Codebreaker.GameAPIs.Tests`的xUnit测试项目来测试`GamesService`类。为了模拟`IGamesRepository`接口，添加`moq`
    NuGet包。
- en: 'The following code snippet shows fields for games and game IDs that are used
    by the unit test:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段显示了单元测试中使用的游戏和游戏ID字段：
- en: Codebreaker.GameAPIs.Tests/GamesServiceTests.cs
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Tests/GamesServiceTests.cs
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `IGamesRepository` interface is mocked creating a new instance by using
    the generic `Mock` type. After this, games are predefined for a game not found
    in the repository (`_notFoundGameId`), a game that already ended (`_endedGame`),
    and a running game that is active (`_running6x4Game`).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用泛型`Mock`类型创建一个新的实例来模拟`IGamesRepository`接口。之后，为在存储库中找不到的游戏（`_notFoundGameId`）、已经结束的游戏（`_endedGame`）和活跃的正在运行的游戏（`_running6x4Game`）预定义了游戏。
- en: 'The constructor of the `GamesServiceTests` class initializes the game objects:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`GamesServiceTests`类的构造函数初始化游戏对象：'
- en: Codebreaker.GameAPIs.Tests/GamesServiceTests.cs
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Tests/GamesServiceTests.cs
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With the constructor, instances of the different game types are created. The
    game already ended has the `EndTime` property set. To specify the behavior of
    the mocking implementation, the `Setup` method is invoked. With this, if the `GetGameAsync`
    method receives the ended game ID with the parameter, it returns the configured
    game instance that already ended. Passing the game ID of the running game, the
    corresponding instance is returned. With the third invocation of the `Setup` method,
    it’s defined that the `AddMoveAsync` method contains an implementation when passing
    the running game. `It.IsAny<Move>` allows us to invoke this method with any `Move`
    instance.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构造函数，创建了不同游戏类型的实例。已经结束的游戏设置了`EndTime`属性。为了指定模拟实现的行怍，调用了`Setup`方法。通过这种方式，如果`GetGameAsync`方法接收到带有参数的已结束游戏ID，它将返回已配置的已结束游戏实例。传递正在运行的游戏ID，将返回相应的实例。在第三次调用`Setup`方法时，定义了当传递正在运行的游戏时，`AddMoveAsync`方法包含一个实现。`It.IsAny<Move>`允许我们使用任何`Move`实例调用此方法。
- en: 'Now, we can implement unit tests. The first unit test is to verify that the
    `SetMoveAsync` method throws an exception if the game already ended:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现单元测试。第一个单元测试是验证如果游戏已经结束，`SetMoveAsync`方法会抛出异常：
- en: Codebreaker.GameAPIs.Tests/GamesServiceTests.cs
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Tests/GamesServiceTests.cs
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the *arrange* step, the `GamesService` class is instantiated with the mocking
    object of the `IGamesRepository` implementation. With the unit test act – as already
    used before – `Assert.ThrowAsync` is used to check if an exception was thrown
    when invoking the `SetMoveAsync` method with the specified game that already ended.
    Another check that is done here is using the `Verify` method on the `Mock` class
    to check if the method is exactly called once.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在*安排*步骤中，使用`IGamesRepository`实现的模拟对象实例化了`GamesService`类。在单元测试操作中——如之前已使用——使用`Assert.ThrowAsync`来检查在调用带有已结束游戏的指定参数的`SetMoveAsync`方法时是否抛出了异常。这里进行的另一个检查是使用`Mock`类上的`Verify`方法来检查该方法是否恰好被调用了一次。
- en: The `SetMoveAsync_Should_ThrowWithUnexpcectedGameType` and `SetMoveAsync_Should_ThorwWithNotFoundGameType`
    unit test methods are very similar, thus are not listed here. Check the source
    code repo for details.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetMoveAsync_Should_ThrowWithUnexpcectedGameType`和`SetMoveAsync_Should_ThorwWithNotFoundGameType`单元测试方法非常相似，因此在此未列出。请检查源代码仓库以获取详细信息。'
- en: 'The test method to test the normal flow is shown here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了测试正常流程的测试方法：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `SetMoveAsync_Should_UpdateGameAndAddMove` method verifies that the `GetGameAsync`
    and `AddMoveAsync` methods are called once, and with the first move in the game,
    the `Moves` property contains exactly one value.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetMoveAsync_Should_UpdateGameAndAddMove`方法验证了`GetGameAsync`和`AddMoveAsync`方法各被调用了一次，并且游戏中的第一个移动使得`Moves`属性恰好包含一个值。'
- en: Running unit tests
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行单元测试
- en: 'To start unit tests, you can use the `dotnet test` .NET CLI command to run
    all the tests. Using Visual Studio, the **Test** menu is available to run all
    the tests. Using **Test Explorer**, as shown in *Figure 10**.1*, you can start
    testing by test, a group of tests, or all tests, see the outcome of every test,
    debug tests, run tests until they fail, define a playlist of tests, and more:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动单元测试，你可以使用`dotnet test` .NET CLI命令运行所有测试。使用Visual Studio，**测试**菜单可用于运行所有测试。使用**测试资源管理器**，如图*图10.1*所示，你可以按测试、测试组或所有测试启动测试，查看每个测试的结果，调试测试，运行测试直到它们失败，定义测试播放列表等：
- en: '![Figure 10.1 – Visual Studio Test Explorer](img/B21217_10_01.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – Visual Studio测试资源管理器](img/B21217_10_01.jpg)'
- en: Figure 10.1 – Visual Studio Test Explorer
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – Visual Studio测试资源管理器
- en: 'When using Visual Studio 2022 Enterprise Edition, you can start Live Unit Testing.
    With Live Unit Testing, a unit test runs while you change the source code. Here,
    you can also monitor which code lines are covered by a unit test and which lines
    are missed. *Figure 10**.2* shows the Visual Studio Code editor with Live Unit
    Testing turned on, and code line *53* missed from all unit tests:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Visual Studio 2022企业版时，你可以启动实时单元测试。使用实时单元测试，单元测试会在你更改源代码时运行。在这里，你还可以监控哪些代码行被单元测试覆盖，哪些行被遗漏。*图10.2*显示了实时单元测试已开启的Visual
    Studio代码编辑器，以及所有单元测试中遗漏的代码行*53*：
- en: '![Figure 10.2 – Visual Studio Live Unit Testing](img/B21217_10_02.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – Visual Studio实时单元测试](img/B21217_10_02.jpg)'
- en: Figure 10.2 – Visual Studio Live Unit Testing
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – Visual Studio实时单元测试
- en: After working through some unit tests, let’s move over to other test types.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成一些单元测试后，让我们转向其他测试类型。
- en: Creating .NET Aspire integration tests
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建.NET Aspire集成测试
- en: While unit tests should be the primary tests, integration tests not only test
    a small functionality but include testing of multiple components within one test,
    such as including infrastructure – for example, a database.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单元测试应该是主要的测试，但集成测试不仅测试小的功能，还包括在一个测试中测试多个组件，例如包括基础设施——例如，数据库。
- en: .NET Aspire contains a library and test templates using xUnit, which easily
    allows creating integration tests to directly access the app model.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Aspire包含一个库和测试模板，使用xUnit，这可以轻松地创建集成测试以直接访问应用程序模型。
- en: 'Let’s create a .NET Aspire test project using .NET Aspire and xUnit, named
    `Codebreaker.IntegrationTests`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用.NET Aspire和xUnit创建一个名为`Codebreaker.IntegrationTests`的.NET Aspire测试项目：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This project includes references to the `Aspire.Hosting.Testing` NuGet package,
    as well as `Microsoft.NET.Test.Sdk`, xUnit, and `xunit.runner.visualstudio`. To
    allow accessing the app model, add a project reference to `Codebreaker.AppHost`.
    With the integration test we implement, we need types from the game APIs project,
    thus we also add a reference to `Codebreaker.GameAPIs`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目包含对`Aspire.Hosting.Testing` NuGet包的引用，以及`Microsoft.NET.Test.Sdk`、xUnit和`xunit.runner.visualstudio`。为了允许访问应用程序模型，添加对`Codebreaker.AppHost`的项目引用。由于我们实现的集成测试需要来自游戏API项目中的类型，因此我们还添加了对`Codebreaker.GameAPIs`的引用。
- en: Creating asynchronous initialization
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建异步初始化
- en: 'With all the integration tests of the game APIs, we need an `HttpClient` instance.
    xUnit allows for asynchronous initialization by implementing the `IAsyncLifetime`
    interface:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行游戏API的所有集成测试时，我们需要一个`HttpClient`实例。xUnit允许通过实现`IAsyncLifetime`接口进行异步初始化：
- en: Codebreaker.IntegrationTests/GameAPIsTests.cs
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.IntegrationTests/GameAPIsTests.cs
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Renaming the class created from the `IAsyncLifetime` interface defines the `InitializeAsync`
    and `DisposeAsync` methods. Field members that will be initialized within the
    InitalizeAsync method are the `DistributedApplication` and `HttpClient` classes.
    You already know the `DistributedApplication` class from the app model in the
    `AppHost` project. You’ll see how this will be used in the `InitalizeAsync` method.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将从`IAsyncLifetime`接口创建的类重命名定义了`InitializeAsync`和`DisposeAsync`方法。将在`InitializeAsync`方法中初始化的字段成员是`DistributedApplication`和`HttpClient`类。您已经从`AppHost`项目中的应用程序模型中了解了`DistributedApplication`类。您将看到如何在`InitializeAsync`方法中使用它。
- en: While we didn’t dispose of the `DistributedApplication` instance in the `AppHost`
    project (because there’s only one instance running for the lifetime of the application,
    and the resources are freed on the application end), it’s important to dispose
    of it with unit tests, as it initialized providers and file watchers. With many
    tests, the user limit of `INotify` instances and the process limit of open file
    descriptors can be reached – thus, don’t forget to dispose of this resource in
    test projects.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们没有在`AppHost`项目中释放`DistributedApplication`实例（因为应用程序的生命周期内只有一个实例在运行，资源在应用程序结束时释放），但在单元测试中释放它很重要，因为它初始化了提供者和文件监视器。随着测试数量的增加，`INotify`实例的用户限制和打开文件描述符的进程限制可能会达到极限——因此，不要忘记在测试项目中释放这个资源。
- en: 'Let’s see how to create `DistributedApplication` and `HttpClient` classes:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建`DistributedApplication`和`HttpClient`类：
- en: Codebreaker.IntegrationTests/GameAPIsTests.cs
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.IntegrationTests/GameAPIsTests.cs
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using `DistributedApplicationTestingBuilder` (defined in the `Aspire.Hosting.Testing`
    namespace), invoking the `CreateAsync` method, a new instance of `DistributedApplicationTestingBuilder`
    is returned. The generic parameter references the `Codebreaker` `AppHost` project.
    Similar to what you’ve seen when using the generic parameter with the projects
    referenced in the `AppHost` project, the same mechanism is used here, referencing
    the `AppHost` project itself. Invoking the `BuildAsync` method returns a `DistributedApplication`
    instance that we may forget to dispose of. Using this instance, we can access
    the app model definition. In the app model specified by the `Codebreaker.AppHost`
    project, we have `gameapis` defined, which is the name of the `Codebreaker.GameAPIs`
    project. `CreateHttpClient` returns an `HttpClient` object to reference this service.
    Both the `HttpClient` and the `DistributedApplication` objects returned are assigned
    to field members. Now, we are ready to create tests.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`DistributedApplicationTestingBuilder`（在`Aspire.Hosting.Testing`命名空间中定义），调用`CreateAsync`方法，返回一个新的`DistributedApplicationTestingBuilder`实例。泛型参数引用了`Codebreaker`的`AppHost`项目。类似于在使用`AppHost`项目中引用的项目时使用泛型参数，这里使用了相同的机制，引用了`AppHost`项目本身。调用`BuildAsync`方法返回一个`DistributedApplication`实例，我们可能会忘记释放它。使用这个实例，我们可以访问应用程序模型定义。在由`Codebreaker.AppHost`项目指定的应用程序模型中，我们定义了`gameapis`，这是`Codebreaker.GameAPIs`项目的名称。`CreateHttpClient`返回一个`HttpClient`对象来引用这个服务。返回的`HttpClient`和`DistributedApplication`对象都分配给了字段成员。现在，我们已准备好创建测试。
- en: Creating a test to verify an HTTP bad request status
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个测试来验证HTTP错误请求状态
- en: 'With the first test, let’s verify if the correct status code is returned when
    an invalid move number is sent. First, we need to start a new game:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个测试中，让我们验证当发送无效的移动编号时是否返回正确的状态码。首先，我们需要开始一个新的游戏：
- en: Codebreaker.IntegrationTests/GameAPIsTests.cs
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.IntegrationTests/GameAPIsTests.cs
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Starting the game, we already use the `HttpClient` instance and invoke an HTTP
    `POST` request, passing the `CreateGameRequest` object. `CreateGameRequest` is
    available in the test project because we added a project reference to the `Codebreaker.GameAPIs`
    project on creation of the test project.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 开始游戏时，我们已经使用了`HttpClient`实例并调用了HTTP `POST`请求，传递了`CreateGameRequest`对象。`CreateGameRequest`在测试项目中可用，因为我们创建测试项目时添加了对`Codebreaker.GameAPIs`项目的项目引用。
- en: 'Continue the implementation of this method by setting a game move:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置游戏移动来继续实现此方法：
- en: Codebreaker.IntegrationTests/GameAPIsTests.cs
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.IntegrationTests/GameAPIsTests.cs
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We use `HttpClient` once more – this time to send a `PATCH` request. Passing
    `moveNumber` with a `0` value specifies an incorrect move. The first correct move
    starts with `1`. This way, we expect to receive a `BadRequest` result, which is
    verified using `Assert.Equal`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用`HttpClient` - 这次是发送`PATCH`请求。传递`moveNumber`时带有`0`值指定了一个错误的移动。第一个正确的移动从`1`开始。这样，我们期望收到一个`BadRequest`结果，这通过`Assert.Equal`进行验证。
- en: Let’s create another test to play a complete game.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再创建一个测试来玩完整游戏。
- en: Creating a test to play a complete game
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个测试来玩完整游戏
- en: 'The following code snippet shows an integration test setting multiple moves:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了设置多个移动的集成测试设置：
- en: Codebreaker.IntegrationTests/GameAPIsTests.cs
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.IntegrationTests/GameAPIsTests.cs
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Starting the game is the same as before, thus the code is not shown here. Sending
    the first move is just a little bit different in that we send the correct move
    number. From there, we continue sending a `GET` request:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 开始游戏与之前相同，因此这里不显示代码。发送第一步稍有不同，我们发送正确的移动编号。从那里，我们继续发送`GET`请求：
- en: Codebreaker.IntegrationTests/GameAPIsTests.cs
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.IntegrationTests/GameAPIsTests.cs
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Before sending a `GET` request, we check if the game was won with the first
    move. This should happen about once in 1,296 invocations; thus, it will happen
    when running the test often. We don’t want to fail the test if the game was won
    with the first move. If the game has not been won yet, a `GET` request is done
    to find out the correct values, then the correct values are used to make the second
    move.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送`GET`请求之前，我们检查游戏是否在第一步中获胜。这应该在大约1,296次调用中发生一次；因此，在运行测试时经常会发生。我们不希望游戏在第一步中获胜时测试失败。如果游戏尚未获胜，则发送`GET`请求以找出正确的值，然后使用这些正确的值来做出第二步。
- en: 'Sending the correct move, we should get a successful result:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 发送正确的移动，我们应该得到一个成功的结果：
- en: Codebreaker.IntegrationTests/GameAPIsTests.cs
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.IntegrationTests/GameAPIsTests.cs
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After sending the second move, the result is verified. Finally, the game is
    deleted. In between all these invocations, results are verified.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 发送第二步后，结果得到验证。最后，游戏被删除。在这些调用之间，结果得到验证。
- en: Run all the integration tests either using the `dotnet test` .NET CLI command
    or with Visual Studio Test Explorer, just as before with the unit tests. Just
    remember not to use integration tests with Live Unit Testing.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`dotnet test` .NET CLI命令或与Visual Studio Test Explorer一起运行所有集成测试，就像之前单元测试一样。只需记住不要使用集成测试与Live
    Unit Testing一起使用。
- en: With CI, as covered in [*Chapter 8*](B21217_08.xhtml#_idTextAnchor183), all
    these tests should run as well. This can simply be done using `dotnet test`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如第8章所述，使用CI，所有这些测试都应该运行。这可以通过使用`dotnet test`简单地完成。
- en: Using .NET Aspire testing for integration tests has the advantage that the server
    doesn’t need to be started. However, creating load tests, testing the solution
    before a switch to the production environment, and directly sending HTTP requests
    should be done from a test environment as well. We’ll do this in the next section.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用.NET Aspire测试进行集成测试的优点是服务器不需要启动。然而，创建负载测试、在切换到生产环境之前测试解决方案以及直接发送HTTP请求也应从测试环境中进行。我们将在下一节中这样做。
- en: Creating end-to-end .NET Playwright tests
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建端到端.NET Playwright测试
- en: '**Microsoft Playwright** ([https://playwright.dev](https://playwright.dev))
    offers tools and libraries from Microsoft for web tests, which include tests on
    web APIs.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**Microsoft Playwright** ([https://playwright.dev](https://playwright.dev))
    提供了Microsoft的用于Web测试的工具和库，包括对Web API的测试。'
- en: Playwright offers several tools (including generating tests by recording actions
    with web pages, inspecting web pages, generating selectors, and viewing traces),
    tests across different platforms, and test libraries for TypeScript, JavaScript,
    Python, .NET, and Java. With UI automation, Playwright can replace manual testers!
    Here, we’ll use Playwright to test APIs – using .NET!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Playwright提供了一些工具（包括通过网页记录动作生成测试、检查网页、生成选择器和查看跟踪），支持跨不同平台进行测试，以及为TypeScript、JavaScript、Python、.NET和Java提供测试库。通过UI自动化，Playwright可以替代手动测试人员！在这里，我们将使用Playwright来测试API
    - 使用.NET！
- en: Creating a test project with Playwright
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Playwright创建测试项目
- en: 'Let’s start creating a test project with Playwright. Because xUnit has a focus
    on unit tests and there’s an issue with limiting concurrent test runs, Playwright
    supports NUnit and MSTest. Here, we use NUnit:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Playwright开始创建一个测试项目。因为xUnit专注于单元测试，并且存在限制并发测试运行的问题，所以Playwright支持NUnit和MSTest。在这里，我们使用NUnit：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Using `dotnet new`, we create a new .NET project, this time using NUnit for
    the testing framework. `Microsoft.Playwright.NUnit` is the Playwright package
    for NUnit. After `dotnet build`, a `playwright.ps1` PowerShell script file is
    created in the `bin/debug/net8.0` folder that installs required browsers:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dotnet new`创建一个新的.NET项目，这次使用NUnit作为测试框架。`Microsoft.Playwright.NUnit`是NUnit的Playwright包。在`dotnet
    build`之后，在`bin/debug/net8.0`文件夹中创建了一个`playwright.ps1` PowerShell脚本文件，用于安装所需的浏览器：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Creating a context
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建上下文
- en: 'Playwright has its own API for creating HTTP requests. This needs to be initialized,
    together with some housekeeping:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Playwright有自己的API用于创建HTTP请求。这需要初始化，以及一些维护工作：
- en: Codebreaker.GameAPIs.Playwright/GamesAPITests.cs
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Playwright/GamesAPITests.cs
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Because this test class shouldn’t participate in live unit testing, the `Category`
    assembly attribute is used to mark the complete assembly with `SkipWhenLiveUnitTesting`.
    Contrary to xUnit where the `AssemblyTrait` attribute was used, NUnit uses the
    `Category` attribute.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个测试类不应参与实时单元测试，所以使用`Category`程序集属性来标记整个程序集，并使用`SkipWhenLiveUnitTesting`。与使用`AssemblyTrait`属性的不同，NUnit使用`Category`属性。
- en: 'With Playwright, the test class needs to derive from the `PlaywrightTest` base
    class. The field of type `IAPIRequestContext` is Playwright’s API to create HTTP
    requests. This field is initialized with the next source code snippet:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Playwright时，测试类需要从`PlaywrightTest`基类派生。类型为`IAPIRequestContext`的字段是Playwright创建HTTP请求的API。这个字段使用下一个源代码片段进行初始化：
- en: Codebreaker.GameAPIs.Playwright/GamesAPITests.cs
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Playwright/GamesAPITests.cs
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `SetupAPITesting` method is invoked before every test. With NUnit, such
    an initialization method needs to be annotated with the `Setup` attribute. To
    initialize `IAPIRequestContext`, the `Playwright.APIRequest.NewContextAsync` method
    is invoked. Here, the HTTP headers and the base address for the service are specified.
    To allow this to be configured with the `appsettings.json` file, the `ConfigurationBuilder`
    class is used. To simulate a think time, `_thinkTimeMS` is retrieved from the
    configuration, which is then used before setting every game move.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个测试之前都会调用`SetupAPITesting`方法。在NUnit中，这样的初始化方法需要使用`Setup`属性进行注释。为了初始化`IAPIRequestContext`，调用`Playwright.APIRequest.NewContextAsync`方法。在这里，指定了服务的基础地址和HTTP头。为了允许使用`appsettings.json`文件进行配置，使用`ConfigurationBuilder`类。为了模拟思考时间，从配置中检索`_thinkTimeMS`，然后在设置每个游戏移动之前使用它。
- en: 'As the API context is created, it also needs to be disposed of:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 随着API上下文的创建，它也需要被销毁：
- en: Codebreaker.GameAPIs.Playwright/GamesAPITests.cs
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Playwright/GamesAPITests.cs
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A method that’s invoked after the test has run is annotated with the `TearDown`
    attribute. The context needs to be disposed of after use.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试运行之后调用的方法被注释为`TearDown`属性。使用完毕后，需要销毁上下文。
- en: After the preparation, let’s create our test.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 准备完成后，让我们创建我们的测试。
- en: Playing a game with Playwright
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Playwright玩游戏
- en: 'Tests created with NUnit are annotated with the `Test` attribute:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NUnit创建的测试用例被`Test`属性注释：
- en: Codebreaker.GameAPIs.Playwright/GamesAPITests.cs
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Playwright/GamesAPITests.cs
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: NUnit uses the `Test` attribute to specify a test. The `Repeat` attribute can
    be used to specify the number of runs the test should be repeated running one
    test. This attribute is useful in generating a longer load on the server. The
    `PlayTheGameToWin` method defines the flow with the API. First, a new game is
    created invoking the `CreateGameAsync` method. After this, for up to 10 moves,
    moves are placed with the `SetMoveAsync` method. If – with the randomly chosen
    guesses – the game is already finished, we are done. Otherwise, information about
    the game is retrieved using `GetGameAsync`, and one more time, `SetMoveAsync`
    is invoked – this time with the correct move.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: NUnit使用`Test`属性来指定一个测试。可以使用`Repeat`属性来指定测试应该重复运行的次数。这个属性在生成更长的服务器负载时很有用。`PlayTheGameToWin`方法使用API定义流程。首先，通过调用`CreateGameAsync`方法创建一个新的游戏。之后，最多进行10次移动，使用`SetMoveAsync`方法放置移动。如果——使用随机选择的猜测——游戏已经结束，我们就完成了。否则，使用`GetGameAsync`检索游戏信息，然后再次调用`SetMoveAsync`——这次使用正确的移动。
- en: 'One of these invocations is shown in the next code snippet. For the other ones,
    check the source code repository:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码片段显示了其中的一种调用方式。对于其他调用方式，请检查源代码仓库：
- en: Codebreaker.GameAPIs.Playwright/GamesAPITests.cs
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Playwright/GamesAPITests.cs
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `SetMoveAsync` method sets a move by using the `IAPIRequestContext` interface’s
    `PatchAsync` method. Depending on the HTTP verb used, `GetAsync`, `PostAsync`…
    methods are available. The HTTP body that is sent to the service is specified
    with the `DataObject` property. The `PatchAsync` method returns an `IAPIResponse`
    response. Using this response, the JSON data can be retrieved using the `JsonAsync`
    method. The `Ok` property that is used with an `Assert` verification returns `true`
    with a status code in the range of 200 to 299.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetMoveAsync` 方法通过使用 `IAPIRequestContext` 接口的 `PatchAsync` 方法来设置移动。根据使用的 HTTP
    动词，`GetAsync`、`PostAsync`… 方法都是可用的。发送到服务的 HTTP 主体由 `DataObject` 属性指定。`PatchAsync`
    方法返回一个 `IAPIResponse` 响应。使用此响应，可以使用 `JsonAsync` 方法检索 JSON 数据。与 `Assert` 验证一起使用的
    `Ok` 属性在 200 到 299 的状态码范围内返回 `true`。'
- en: With this test in place, we can run the test using `dotnet test` or with Test
    Explorer within Visual Studio. Just this time, the service needs to be running!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在此测试到位的情况下，我们可以使用 `dotnet test` 或在 Visual Studio 中的 Test Explorer 中运行测试。但这次，服务需要正在运行！
- en: Creating test loads
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建测试负载
- en: The Playwright tests can now be used to simulate a user load, to run multiple
    users concurrently. For this, just compute resources are needed to run the needed
    load. By reducing the delay time, a few “virtual users” can be used to simulate
    the load of a bigger number of real users. How long real users are thinking between
    moves needs to be analyzed monitoring the solution in production.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Playwright 测试现在可以用来模拟用户负载，以并发运行多个用户。为此，只需要计算资源来运行所需的负载。通过减少延迟时间，可以使用少量“虚拟用户”来模拟更多真实用户的负载。需要分析真实用户在移动之间的思考时间，这需要监控生产环境中的解决方案。
- en: Note
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Reducing the delay between moves, you can use fewer compute resources to simulate
    a large number of real users with just a few virtual users. There’s also a good
    reason to increase the delay time for the time used by real users. In [*Chapter
    12*](B21217_12.xhtml#_idTextAnchor294), we’ll enhance the solution with caching.
    What if the cached game is not available after a user has a long delay between
    moves? Does the application still behave correctly? You should also run such integration
    tests.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 减少移动之间的延迟，你可以使用更少的计算资源来仅用少量虚拟用户模拟大量真实用户的负载。也有很好的理由增加真实用户所用的时间的延迟时间。在 [*第 12
    章*](B21217_12.xhtml#_idTextAnchor294) 中，我们将通过缓存来增强解决方案。如果用户在移动之间有长时间的延迟，缓存的游戏不可用，应用程序是否仍然表现正确？你还应该运行此类集成测试。
- en: Using the **Microsoft Playwright Testing** cloud service, compute resources
    are available to test web applications. This service is – at the time of this
    writing – not available to test REST APIs. Another service to run load tests is
    **Azure Load Testing**. With this tool, you can write **JMeter** scripts to run
    the tests or specify web requests from the web portal. In [*Chapter 12*](B21217_12.xhtml#_idTextAnchor294),
    we’ll use this service to create load tests to increase the replica count of the
    games API. This tool not only runs the load but also gives a great report to show
    information about all resources interacting with the requests.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **Microsoft Playwright 测试** 云服务，计算资源可用于测试 Web 应用程序。在撰写本文时，此服务不可用于测试 REST
    API。另一个运行负载测试的服务是 **Azure Load Testing**。使用此工具，你可以编写 **JMeter** 脚本来运行测试或从 Web
    门户指定 Web 请求。在 [*第 12 章*](B21217_12.xhtml#_idTextAnchor294) 中，我们将使用此服务创建负载测试来增加游戏
    API 的副本数量。此工具不仅运行负载，还提供了一个出色的报告，显示了与请求交互的所有资源的信息。
- en: Note
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All the tests covered here can also be used with GitHub actions. After building
    the .NET libraries and applications, `dotnet test` should be triggered to start
    all the unit tests. After deploying the services to the test environment, integration
    tests should run before the solution is deployed to the next environment – for
    example, the staging environment. Automated load tests should make sure the solution
    is working under load.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这里涵盖的所有测试也可以与 GitHub Actions 一起使用。在构建 .NET 库和应用程序之后，应触发 `dotnet test` 以启动所有单元测试。在将服务部署到测试环境之后，在解决方案部署到下一个环境之前——例如，预发布环境——应运行集成测试。自动负载测试应确保解决方案在负载下运行。
- en: Continuously – for workflows triggered on a timely basis – you should check
    if new security issues are found in dependencies, and these dependencies should
    be updated. For this, with GitHub, just *Dependabot* needs to be configured.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 持续地——对于基于时间触发的流程——你应该检查依赖项中是否发现新的安全漏洞，并且这些依赖项应该得到更新。为此，使用 GitHub，只需配置 *Dependabot*
    即可。
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned to create *unit tests* to test simple functionality.
    These tests can be used with Live Unit Testing where test errors immediately show
    up during development. With unit tests, you learned to use a *mocking library*
    to replace functionality that is not in the scope of the unit test and is covered
    by a different unit test.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何创建*单元测试*来测试简单的功能。这些测试可以与实时单元测试一起使用，在开发期间立即显示测试错误。通过单元测试，您学习了如何使用*模拟库*来替换单元测试范围之外的函数，并由不同的单元测试覆盖。
- en: You learned how .NET Aspire makes *integration tests* simple using `Aspire.Hosting.Testing`.
    There’s no need to start the service, as the handler of `HttpClient` is replaced
    to send requests to the service in-process.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您学习了如何使用`Aspire.Hosting.Testing`使*集成测试*变得简单。无需启动服务，因为`HttpClient`的处理程序被替换为向服务进程发送请求。
- en: Using Microsoft Playwright, you created an integration test that makes HTTP
    requests to the API and can be used to test the solution under load.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Microsoft Playwright，您创建了一个集成测试，该测试向API发送HTTP请求，并可用于在负载下测试解决方案。
- en: While you monitored metrics data in this chapter, the next chapter expands on
    this so that you can create your own metric counts and add logging and distributed
    tracing to the microservices solution.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您监控了指标数据，下一章将在此基础上扩展，以便您可以创建自己的指标计数，并将日志记录和分布式跟踪添加到微服务解决方案中。
- en: Further reading
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics discussed in this chapter, you can refer to
    the following links:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章讨论的主题，您可以参考以下链接：
- en: 'Martin Fowler on testing microservices: [https://martinfowler.com/articles/microservice-testing](https://martinfowler.com/articles/microservice-testing)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Martin Fowler关于微服务测试的观点: [https://martinfowler.com/articles/microservice-testing](https://martinfowler.com/articles/microservice-testing)'
- en: 'Live Unit Testing: [https://learn.microsoft.com/en-us/visualstudio/test/live-unit-testing](https://learn.microsoft.com/en-us/visualstudio/test/live-unit-testing)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '实时单元测试: [https://learn.microsoft.com/en-us/visualstudio/test/live-unit-testing](https://learn.microsoft.com/en-us/visualstudio/test/live-unit-testing)'
- en: 'Integration tests: [https://learn.microsoft.com/en-us/aspnet/core/test/integration-tests](https://learn.microsoft.com/en-us/aspnet/core/test/integration-tests)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '集成测试: [https://learn.microsoft.com/en-us/aspnet/core/test/integration-tests](https://learn.microsoft.com/en-us/aspnet/core/test/integration-tests)'
- en: '*Testing .NET Aspire* *apps*: [https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/testing](https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/testing)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试.NET Aspire应用*: [https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/testing](https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/testing)'
- en: 'Microsoft Playwright: [https://playwright.dev/](https://playwright.dev/)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Microsoft Playwright: [https://playwright.dev/](https://playwright.dev/)'
- en: '*Guide to Secure .NET Development with OWASP Top* *10*: [https://learn.microsoft.com/en-us/training/modules/owasp-top-10-for-dotnet-developers/](https://learn.microsoft.com/en-us/training/modules/owasp-top-10-for-dotnet-developers/)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用OWASP Top 10安全指南进行.NET开发*: [https://learn.microsoft.com/en-us/training/modules/owasp-top-10-for-dotnet-developers/](https://learn.microsoft.com/en-us/training/modules/owasp-top-10-for-dotnet-developers/)'
- en: '*Working with* *Dependabot*: [https://docs.github.com/en/code-security/dependabot/working-with-dependabot](https://docs.github.com/en/code-security/dependabot/working-with-dependabot)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与Dependabot协作*: [https://docs.github.com/en/code-security/dependabot/working-with-dependabot](https://docs.github.com/en/code-security/dependabot/working-with-dependabot)'
