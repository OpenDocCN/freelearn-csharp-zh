- en: '*Chapter 3*: Best Practices for Managed Threading'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*: 管理线程的最佳实践'
- en: When building applications that leverage parallelism and concurrency, developers
    need to be aware of some best practices regarding integrating managed threading
    concepts. This chapter will assist in this capacity. We will cover important concepts
    such as working with static data, avoiding deadlocks, and exhausting managed resources.
    These are all areas that can lead to unstable applications and unexpected behavior.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建利用并行性和并发性的应用程序时，开发者需要了解一些关于集成管理线程概念的最佳实践。本章将在这方面提供帮助。我们将涵盖重要概念，如处理静态数据、避免死锁以及耗尽管理资源。这些都是可能导致应用程序不稳定和意外行为的问题领域。
- en: 'In this chapter, you will learn the following concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下概念：
- en: Handling static objects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理静态对象
- en: Managing deadlocks and race conditions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理死锁和竞态条件
- en: Threading limits and other recommendations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程限制和其他建议
- en: By the end of this chapter, you will have the knowledge to avoid the most common
    managed threading pitfalls.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将具备避免最常见的管理线程陷阱的知识。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples in this chapter, the following software is
    recommended for Windows developers:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中的示例，以下软件是推荐给Windows开发者的：
- en: Visual Studio 2022 version 17.0 or later
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022版本17.0或更高
- en: .NET 6
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 6
- en: While these are recommended, if you have .NET 6 installed, you can use your
    preferred editor. For example, Visual Studio 2022 for Mac on macOS 10.13 or later,
    JetBrains Rider, or Visual Studio Code will work just as well.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些是推荐的，但如果您已安装.NET 6，您可以使用您喜欢的编辑器。例如，macOS 10.13或更高版本的Visual Studio 2022 for
    Mac、JetBrains Rider或Visual Studio Code都将同样有效。
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter03](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter03).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在GitHub上找到，链接为[https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter03](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter03)。
- en: We will get started by discussing some best practices for handling static data
    in .NET.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始讨论处理.NET中静态数据的一些最佳实践。
- en: Handling static objects
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理静态对象
- en: When working with static data in .NET, there are some important things to understand
    when it comes to managed threading.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当在.NET中处理静态数据时，关于管理线程有一些重要的事情需要理解。
- en: Static data and constructors
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态数据和构造函数
- en: One important item to understand about accessing static data from managed threads
    relates to constructors. Before a static member of any class can be accessed,
    its **static constructor** must first finish running. The runtime will block thread
    execution until the static constructor has run to ensure that all required initialization
    has finished.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 关于从管理线程访问静态数据的一个重要事项与构造函数有关。在任何类的静态成员可以访问之前，其**静态构造函数**必须首先完成运行。运行时会阻塞线程执行，直到静态构造函数运行，以确保所有必需的初始化都已完成。
- en: If you are using static objects within your own code base, you will know which
    classes have static constructors and can control the complexity of the logic inside
    them. When the static data is outside of your control, inside a third-party library
    or .NET itself, things may not be so clear.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在自己的代码库中使用静态对象，您将知道哪些类有静态构造函数，并可以控制其内部的逻辑复杂性。当静态数据不在您的控制范围内，在第三方库或.NET本身内部时，事情可能并不那么清晰。
- en: Let’s try a quick example to illustrate the potential delays that can be encountered
    in this scenario.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个快速示例来展示在这种场景中可能遇到的潜在延迟。
- en: Start by creating a new .NET console application in Visual Studio named `ThreadingStaticDataExample`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在Visual Studio中创建一个新的.NET控制台应用程序，命名为`ThreadingStaticDataExample`。
- en: 'Add a new class to the project named `WorkstationState` with the following
    static members:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个名为 `WorkstationState` 的新类，并包含以下静态成员：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This class will hold some information about the current workstation, including
    the host name, local IP address, and whether the network is currently available.
    The private `GetLocalIpAddress` method fetches the local IP based on a provided
    host name.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将包含有关当前工作站的一些信息，包括主机名、本地IP地址以及网络是否当前可用。私有`GetLocalIpAddress`方法根据提供的主机名获取本地IP。
- en: There is a static constructor for `WorkstationState` that sets the initial property
    data and injects a delay of two seconds with a `Thread.Sleep` call. This will
    help us simulate the application fetching some other network information that
    takes some time to retrieve on a slow network connection.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkstationState`有一个静态构造函数，用于设置初始属性数据和通过`Thread.Sleep`调用注入两秒的延迟。这将帮助我们模拟应用程序获取一些其他需要时间从慢速网络连接检索的网络信息。'
- en: 'Next, add a class named `WorkstationHelper`. This class will contain an async
    method to update the static `IsNetworkAvailable` and `NetworkConnectivityLastUpdated`
    properties in `WorkstationState` and return the value of `IsNetworkAvailable`
    to the caller:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个名为`WorkstationHelper`的类。这个类将包含一个异步方法，用于更新`WorkstationState`中的静态`IsNetworkAvailable`和`NetworkConnectivityLastUpdated`属性，并将`IsNetworkAvailable`的值返回给调用者：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There is also a `Task.Delay` call being awaited if you would like to call this
    in a loop and experiment by varying the injected delay.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在循环中调用此方法并通过改变注入的延迟进行实验，也可以等待`Task.Delay`调用。
- en: 'Finally, update `Program.cs` to call `GetNetworkAvailability` and update the
    console output with the connectivity, host name, and IP address:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新`Program.cs`以调用`GetNetworkAvailability`并更新控制台输出，包括连接性、主机名和IP地址：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the program and examine the output. You can see that there is a two second
    delay between the times in the two `Console.WriteLine` calls injected by the static
    constructor:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序并检查输出。你可以看到，在静态构造函数注入的两个`Console.WriteLine`调用之间有2秒的延迟：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Static constructors are one aspect of static data to keep in mind when working
    with managed threading. A more common issue is controlling concurrent read/write
    access to static objects across threads.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理托管线程时，静态构造函数是需要注意的静态数据的一个方面。一个更常见的问题是控制线程之间的静态对象的并发读写访问。
- en: Controlling shared access to static objects
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制对静态对象的共享访问
- en: When it comes to static data, the best practice is to avoid using it whenever
    possible. In general, it makes your code less testable, less scalable, and more
    prone to unexpected behavior when working with concurrency. However, there are
    times when static data cannot be avoided. You may be working with a legacy code
    base, where refactoring the code to remove statics can be risky or too large an
    effort to undertake. Static classes can also be useful when data rarely changes,
    or when the classes are stateless.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到静态数据时，最佳实践是尽可能避免使用它。一般来说，这会使你的代码更难以测试、更难以扩展，并且在并发工作时更容易出现意外行为。然而，有时静态数据是不可避免的。你可能正在处理一个遗留代码库，其中重构代码以删除静态变量可能是有风险的，或者是一个过于庞大的任务。当数据很少变化，或者类是无状态的时，静态类也可能很有用。
- en: For cases where static objects are unavoidable, some precautions can be taken.
    Let’s review some of them and discuss the merits of each, starting with locking
    mechanisms.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不可避免使用静态对象的情况，可以采取一些预防措施。让我们回顾一些这些措施，并讨论每个措施的优点，从锁定机制开始。
- en: Locks
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 锁
- en: In [*Chapter 1*](B18552_01_ePub.xhtml#_idTextAnchor014)*,* we discussed some
    strategies for locking objects for shared use. **Locks** are even more important
    when working with static variables because of the chance of concurrent access
    increases with the increased scope of the object.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B18552_01_ePub.xhtml#_idTextAnchor014)*中，我们讨论了一些用于锁定对象以供共享使用的策略。**锁**在处理静态变量时尤为重要，因为随着对象作用域的增加，并发访问的可能性也会增加。
- en: 'The simplest way of preventing concurrent access to an object from multiple
    threads is to enclose any code that accesses it with a lock. Let’s modify the
    code in `WorkstationHelper` to prevent multiple calls to `GetNetworkActivity`
    from writing to `WorkstationState` properties concurrently:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 防止多个线程同时访问一个对象的最简单方法是将访问它的任何代码用锁包围起来。让我们修改`WorkstationHelper`中的代码，以防止多个调用`GetNetworkActivity`同时写入`WorkstationState`属性：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have added a private static `_workstationLock` object, and we are using it
    as part of the lock block enclosing the writes to `WorkstationState` properties.
    If `GetNetworkAvailability` were now used in a `Parallel.ForEach` or some other
    concurrent operation, only one thread could enter that lock block at a time.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个私有的静态`_workstationLock`对象，并且我们正在将其用作包围`WorkstationState`属性写入的锁块的一部分。如果现在在`Parallel.ForEach`或其他并发操作中使用`GetNetworkAvailability`，则一次只能有一个线程进入该锁块。
- en: You can use any of the locking mechanisms that were discussed in [*Chapter 1*](B18552_01_ePub.xhtml#_idTextAnchor014).
    Choose the feature that works best for your scenario. Another .NET feature you
    can leverage with static members is the `ThreadStatic` attribute.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用在[*第1章*](B18552_01_ePub.xhtml#_idTextAnchor014)中讨论过的任何锁定机制。选择最适合你场景的功能。你还可以利用.NET的另一个功能，即`ThreadStatic`属性。
- en: ThreadStatic attribute
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ThreadStatic属性
- en: The `ThreadStatic` attribute can be added to a static field to indicate that
    a separate static instance of the object should be created for each thread. The
    `ThreadStatic` attribute should only be used when this is the desired behavior,
    and it is well documented in your code. It can produce unexpected results when
    used improperly.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将`ThreadStatic`属性添加到静态字段中，以指示为每个线程创建对象的一个单独的静态实例。只有在需要此行为时才应使用`ThreadStatic`属性，并且应在代码中良好地记录。如果使用不当，它可能会产生意外的结果。
- en: Fields marked as `ThreadStatic` should not have their data initialized in a
    constructor, as the initialization will only apply to the current thread. The
    value on all other threads will be `null` or the default value for that type.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为`ThreadStatic`的字段不应在构造函数中初始化其数据，因为初始化只会应用于当前线程。其他线程上的值将是`null`或该类型的默认值。
- en: If you applied the `ThreadStatic` attribute to the `NetworkConnectivityLastUpdated`
    property of `WorkstationState` and call `WorkstationHelper.GetNetworkAvailability`
    thirty times in a `Parallel.For` loop, the value read in `Program.cs` at the end
    may or may not be the last value written to one of the static instances. The variable
    in `Program.cs` will contain the last value written from the main thread inside
    the `Parallel.For` loop.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`ThreadStatic`属性应用于`WorkstationState`的`NetworkConnectivityLastUpdated`属性，并在`Parallel.For`循环中调用`WorkstationHelper.GetNetworkAvailability`三十次，那么在`Program.cs`中读取的值可能是也可能不是写入静态实例中的最后一个值。`Program.cs`中的变量将包含在`Parallel.For`循环内部主线程中写入的最后一个值。
- en: 'To try it for yourself, add the `ThreadStatic` attribute to `NetworkConnectivityLastUpdated`
    and make it an internal field instead of a property. The attribute cannot be applied
    to properties:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要亲自尝试，请将`ThreadStatic`属性添加到`NetworkConnectivityLastUpdated`，并将其作为内部字段而不是属性。该属性不能应用于属性：
- en: '[PRE20]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then update `Program.cs` to use a `Parallel.For` loop:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后更新`Program.cs`以使用`Parallel.For`循环：
- en: '[PRE21]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The time between the date/time values in the output will now vary each time
    you run the program because the final value written to the console may not be
    the final value across all threads.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的日期/时间值之间的时间间隔现在每次运行程序时都会变化，因为写入控制台的最后值可能不是所有线程中的最终值。
- en: While `ThreadStatic` should be applied only in scenarios where instances per
    thread are necessary, another pattern similar in application to statics is the
    **singleton**. Let’s discuss the use of singletons in a multithreaded application.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`ThreadStatic`应仅应用于需要每个线程的实例的场景，但另一种与静态类似的应用模式是**单例**。让我们讨论在多线程应用程序中使用单例。
- en: Working with singletons
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与单例一起工作
- en: The singleton pattern is an object **design pattern** that only allows a single
    instance of itself to be created. This design pattern is one of the most common
    and is known by most .NET developers. Every mainstream **dependency injection
    (DI)** framework allows registered types to be registered as singletons. The container
    will only create one instance for each of these types, providing the same instances
    every time the type is requested.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式是一种对象**设计模式**，它只允许创建该对象的一个实例。这种设计模式是最常见的之一，并且大多数.NET开发者都了解它。每个主流**依赖注入（DI）**框架都允许将注册的类型注册为单例。容器将为这些类型中的每一个创建一个实例，每次请求该类型时都提供相同的实例。
- en: 'We can manually create a singleton for our `WorkstationState` with a `lock`
    and a little extra code. This is the `WorkstationStateSingleton`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`lock`和一点额外的代码手动创建一个`WorkstationState`的单例。这是`WorkstationStateSingleton`：
- en: '[PRE22]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The complete implementation of the class can be found in the GitHub repository
    referenced in the *Technical requirements* section of this chapter. Look at the
    `ThreadingStaticDataExample` in the `chapter3` folder.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 类的完整实现可以在本章*技术要求*部分引用的GitHub存储库中找到。查看`chapter3`文件夹中的`ThreadingStaticDataExample`。
- en: There are two steps taken to make this a singleton. First, the constructor is
    private so only the `WorkstationStateSingleton` can create an instance of itself.
    Second, a static `Instance` method is created. It returns the `_singleton` instance
    of itself if it is not `null`. Otherwise, it creates the instance to return. Surrounding
    this code with the `_lock` ensures that the instances are not created twice on
    different concurrent threads.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使其成为单例需要采取两个步骤。首先，构造函数是私有的，这样只有`WorkstationStateSingleton`可以创建自己的实例。其次，创建一个静态的`Instance`方法。如果它不是`null`，它将返回自己的`_singleton`实例。否则，它将创建实例以返回。使用`_lock`包围这段代码确保在并发线程上不会创建两次实例。
- en: A singleton presents the same challenges as a static class. All shared data
    should be protected by locks if they can be accessed concurrently by managed threads.
    The added challenge with singletons that are registered in a DI container is that
    a `lock` object, `Mutex`, or another mechanism must be declared at the same scope
    as the container. This will ensure that all data that can potentially use the
    singleton can also enforce the same lock.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 单例与静态类面临相同的挑战。如果共享数据可以被管理线程并发访问，则应该由锁来保护。对于注册在DI容器中的单例，增加的挑战是必须在容器相同的范围内声明一个`lock`对象、`Mutex`或另一种机制。这将确保所有可能使用单例的数据也能强制执行相同的锁。
- en: Note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that the use of singletons is generally not considered a good practice
    today. For this reason, many developers consider them an anti-pattern. However,
    it is important to understand them and how existing singletons in your code may
    be impacted by multithreaded code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，单例的使用通常不被认为是良好的实践。因此，许多开发者认为它们是一种反模式。然而，了解它们以及你的代码中现有的单例可能如何受到多线程代码的影响是很重要的。
- en: '**Deadlocks** are one of the pitfalls of aggressive locking. Aggressive locking
    is when you are locking uses of an object in many parts of the code that could
    be executing in parallel. In the next section, we will discuss deadlocks and **race
    conditions** in managed threading.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**死锁**是积极锁定的一种陷阱。积极锁定是指你在代码的许多部分使用对象锁定，而这些部分可能并行执行。在下一节中，我们将讨论管理线程中的死锁和**竞态条件**。'
- en: Managing deadlocks and race conditions
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理死锁和竞态条件
- en: 'As with many tools at a developer’s disposal, misusing features of managed
    threading can have adverse impacts on your applications at runtime. Deadlocks
    and race conditions are two scenarios that can be created because of multithreaded
    programming:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 就像开发者可用的许多工具一样，滥用管理线程的功能可能会在运行时对你的应用程序产生不利影响。死锁和竞态条件是多线程编程可能产生的两种情况：
- en: A **deadlock** happens when multiple threads are trying to lock the same resource
    and as a result, cannot continue executing.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**死锁**发生在多个线程试图锁定相同的资源，结果无法继续执行。'
- en: '**Race conditions** happen when multiple threads are proceeding toward updating
    a particular routine, and a correct outcome is dependent on the order in which
    they execute it.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**竞态条件**发生在多个线程正在尝试更新特定例程时，并且正确的结果取决于它们执行的顺序。'
- en: '![Figure 3.2 – Two threads in contention for the same resources, causing a
    deadlock ](img/Figure_3.1_B18552.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 两个线程争夺相同资源，导致死锁](img/Figure_3.1_B18552.jpg)'
- en: Figure 3.2 – Two threads in contention for the same resources, causing a deadlock
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 两个线程争夺相同资源，导致死锁
- en: First, let’s discuss deadlocks and some techniques for avoiding them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论死锁以及避免它们的一些技术。
- en: Mitigating deadlocks
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓解死锁
- en: It is critical to avoid deadlocks in your applications. If one of the threads
    involved in a deadlock is the application’s UI thread, it will cause the application
    to freeze. When only non-UI threads are deadlocked, it can be harder to diagnose
    the problem. Deadlocked thread pool threads will prevent an application from closing,
    but deadlocked background threads will not.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中避免死锁至关重要。如果一个死锁涉及的线程是应用程序的UI线程，它将导致应用程序冻结。当只有非UI线程发生死锁时，诊断问题可能更困难。死锁的线程池线程将阻止应用程序关闭，但死锁的后台线程则不会。
- en: Well-instrumented code is essential in debugging problems when they occur in
    a production environment. If the issue can be reproduced in your own development
    environment, stepping through the code with the Visual Studio debugger is the
    fastest way to find the source of a deadlock. We will discuss debugging techniques
    in detail in [*Chapter 10*](B18552_10_ePub.xhtml#_idTextAnchor158).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中出现问题时，良好的代码调试工具对于调试问题至关重要。如果问题可以在您的开发环境中重现，使用 Visual Studio 调试器逐步执行代码是找到死锁来源的最快方式。我们将在
    [*第10章*](B18552_10_ePub.xhtml#_idTextAnchor158) 中详细讨论调试技术。
- en: 'One of the easiest ways to create a deadlock is through recursion or nested
    methods that try to acquire a lock on the same resource. Look at the following
    code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过递归或尝试在相同资源上获取锁的嵌套方法，是创建死锁的最简单方法之一。看看以下代码：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `ProcessData` method is locking the `_lock` object and processing with `_data`.
    However, it is calling `AddData,` which also tries to acquire the same lock. This
    lock will never become available, and the process will be deadlocked. In this
    case, the problem is apparent. What if `AddData` is called from multiple places
    or some `Parallel.ForEach` any loops are involved in the parent code? Some of
    the parent code uses `_data` and acquire a lock, but some do not. This is a case
    where non-blocking read locks in the `ReaderWriterLockSlim` can help prevent deadlocks.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProcessData` 方法正在锁定 `_lock` 对象并使用 `_data` 进行处理。然而，它调用了 `AddData`，这也试图获取相同的锁。这个锁永远不会变得可用，进程将会死锁。在这种情况下，问题很明显。如果
    `AddData` 从多个地方调用或者父代码中涉及任何 `Parallel.ForEach` 循环，会怎样？一些父代码使用 `_data` 并获取锁，但有些则没有。这就是
    `ReaderWriterLockSlim` 中的非阻塞读锁可以帮助防止死锁的情况。'
- en: 'Another way to prevent deadlocks is by adding a timeout to the lock attempt
    with `Monitor.TryEnter`. In this example, the code will time out if a lock cannot
    be acquired within one second:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 防止死锁的另一种方法是使用 `Monitor.TryEnter` 给锁尝试添加超时。在这个例子中，如果在一秒内无法获取锁，代码将超时：
- en: '[PRE49]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Logging any failures to acquire locks can help to pinpoint possible sources
    of deadlocks in your code so you can rework the code to avoid them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 记录获取锁失败的情况可以帮助您确定代码中可能的死锁来源，以便您可以重新编写代码以避免它们。
- en: Next, let’s examine how race conditions can occur in multithreaded applications.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看在多线程应用程序中竞态条件是如何发生的。
- en: Avoiding race conditions
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免竞态条件
- en: 'A race condition occurs when multiple threads are reading and writing the same
    variables simultaneously. Without any locks in place, the outcome can be wildly
    unpredictable. Some operations can be overwritten by other parallel threads’ results.
    Even with locks in place, the order of two thread operations can change the result.
    Here is a simple example without locks that performs some addition and multiplication
    in parallel:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个线程同时读取和写入相同的变量时，就会发生竞态条件。如果没有任何锁，结果可能是完全不可预测的。某些操作可以被其他并行线程的结果覆盖。即使有锁，两个线程操作顺序的改变也可能改变结果。以下是一个没有锁的简单示例，它并行执行了一些加法和乘法：
- en: '[PRE68]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: We all know that when combining addition and multiplication, the order of operations
    is important. If the two operations are processed sequentially, the two results
    could be either `180` or `45`, but if both `AddValue` and `MultiplyValue` read
    the initial value of `3` before performing their respective operations, the last
    method to complete will write either `18` or `30` as the final value of `_runningTotal`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道，当结合加法和乘法时，操作顺序很重要。如果这两个操作按顺序处理，两个结果可以是 `180` 或 `45`，但如果 `AddValue` 和 `MultiplyValue`
    在执行各自的操作之前都读取了初始值 `3`，则最后一个完成的方法将写入 `18` 或 `30` 作为 `_runningTotal` 的最终值。
- en: 'If you want to ensure that multiplication happens before addition, the `PerformCalculations`
    method can be rewritten to use the `ContinueWith` method on the `Task` returned
    from `MultiplyValue`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想确保乘法发生在加法之前，可以将 `PerformCalculations` 方法重写为使用 `MultiplyValue` 返回的 `Task`
    上的 `ContinueWith` 方法：
- en: '[PRE89]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: This code will always multiply before adding and will always finish with `_runningTotal`
    equaling `45`. Using `async` and `await` throughout the code ensures that the
    UI or service process remains responsive while using threads from the thread pool
    as needed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在加法之前总是先进行乘法，并且总是以 `_runningTotal` 等于 `45` 结束。在整个代码中使用 `async` 和 `await`
    确保在需要时使用线程池中的线程时，UI 或服务进程保持响应。
- en: 'The `Interlocked` class discussed in the previous chapter can also be used
    to perform mathematic operations on shared resources. `Interlocked.Add` and `Interlocked.Exchange`
    can perform thread-safe operations on the `_runningTotal` variable in parallel.
    Here is the original `Parallel.Invoke` example modified to use `Interlocked` methods
    with `_runningTotal`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中讨论的**Interlocked**类也可以用于对共享资源执行数学操作。`Interlocked.Add`和`Interlocked.Exchange`可以在并行中对`_runningTotal`变量执行线程安全操作。以下是修改后的原始`Parallel.Invoke`示例，使用`Interlocked`方法与`_runningTotal`：
- en: '[PRE97]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: The two operations could still perform in different orders, but the uses of
    `_runningTotal` are now locked and thread-safe. The **Interlocked** class is more
    efficient than using a lock statement and will yield greater performance for simple
    changes like these.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个操作仍然可能以不同的顺序执行，但现在`_runningTotal`的使用已被锁定且线程安全。**Interlocked**类比使用锁定语句更高效，对于这种简单的更改，它将提供更好的性能。
- en: It is important to guard all shared resources when performing concurrent operations
    in your code. By creating a well-designed locking strategy, you will achieve the
    best possible performance while maintaining thread safety in your application.
    Let’s finish up this chapter with some guidance around threading limits.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中执行并发操作时，保护所有共享资源非常重要。通过创建一个精心设计的锁定策略，你将在保持应用程序线程安全的同时实现最佳性能。让我们以关于线程限制的指导来结束这一章。
- en: Threading limits and other recommendations
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程限制和其他建议
- en: So, it sounds like using multiple threads can really speed up your application’s
    performance. You should probably start replacing all your `foreach` loops with
    `Parallel.ForEach` loop and start calling all your services and helper methods
    on thread pool threads, right? Are there any limits and what are they? Well, when
    it comes to threading, there absolutely are limits.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用多个线程确实可以加快应用程序的性能。你可能应该开始用`Parallel.ForEach`循环替换所有的`foreach`循环，并在线程池线程上调用所有你的服务和辅助方法，对吧？有没有限制，它们是什么？好吧，当涉及到线程时，绝对存在限制。
- en: The number of threads that can execute simultaneously is limited by the number
    of processors and processor cores on the system. There is no way around hardware
    limitations, as the CPU (or virtual CPU when running on a virtual machine) can
    only run so many threads. In addition, your application must share these CPUs
    with other processes running on the system. If your CPU has four cores, it is
    actively running five other applications, and your program is trying to execute
    a process with multiple threads, the system is not likely to accept more than
    one of your threads at a time.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 可以同时执行的线程数受系统上的处理器和处理器核心数限制。硬件限制无法规避，因为CPU（或在虚拟机上运行时为虚拟CPU）只能运行这么多线程。此外，你的应用程序必须与其他系统上运行的其他进程共享这些CPU。如果你的CPU有四个核心，它正在积极运行五个其他应用程序，而你的程序正在尝试执行一个具有多个线程的过程，系统不太可能一次接受你的多个线程。
- en: The .NET thread pool is optimized to handle different scenarios based on the
    number of threads available, but you can do some things to guard against taxing
    the system. Some parallel operations such as `Parallel.ForEach` can limit how
    many threads the loop will try to use. You can provide a `ParallelOptions` object
    to the operation and set the `MaxDegreeOfParallelism` option. By default, the
    loop will use as many threads as the scheduler will provide.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: .NET线程池已针对基于可用线程数的不同场景进行了优化，但你也可以做一些事情来防止过度使用系统。一些并行操作，如`Parallel.ForEach`，可以限制循环尝试使用的线程数。你可以向操作提供一个`ParallelOptions`对象并设置`MaxDegreeOfParallelism`选项。默认情况下，循环将使用调度器提供的所有线程。
- en: 'You can ensure that the maximum does not exceed half the number of available
    cores on the system with the following implementation:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下实现确保最大值不超过系统可用核心数的一半：
- en: '[PRE125]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'PLINQ operations can also limit the max degree of parallelism with the `WithDegreeOfParallelism`
    extension method:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: PLINQ操作也可以使用`WithDegreeOfParallelism`扩展方法来限制最大并行度：
- en: '[PRE138]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'An application can also adjust the thread pool maximum values, if necessary.
    By calling `ThreadPool.SetMaxThreads`, you can change the maximum values for `workerThreads`
    and `completionPortThreads`. `completionPortThreads` is the number of async I/O
    threads on the thread pool. It is usually not required to change these values,
    and there are some limits to the values you can set. The maximum cannot be set
    to less than the number of cores on the system or less than the current minimum
    values on the thread pool. You can query the current minimums with `ThreadPool.GetMinThreads`.
    Here is an example of how to safely set the maximum thread values to values greater
    than the current minimums:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，应用程序也可以调整线程池的最大值。通过调用`ThreadPool.SetMaxThreads`，你可以更改`workerThreads`和`completionPortThreads`的最大值。`completionPortThreads`是线程池上的异步I/O线程的数量。通常不需要更改这些值，并且你可以设置一些限制。最大值不能设置为小于系统核心数或小于线程池当前的最小值。你可以使用`ThreadPool.GetMinThreads`查询当前的最小值。以下是如何安全地将最大线程值设置为大于当前最小值的示例：
- en: '[PRE150]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: There are some other general guidelines to follow regarding the number of threads
    to assign to an operation in your application. Try to avoid assigning multiple
    threads to operations that share a resource. For example, if you have a service
    that logs activity to a file, you should not assign more than one background worker
    to do the logging. The blocking file I/O operations will prevent the second thread
    from writing until the first one is complete. You are not gaining any efficiency
    in this case.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中为操作分配线程的数量有一些其他的一般性指南需要遵循。尽量避免为共享资源的操作分配多个线程。例如，如果你有一个将活动记录到文件的服务，你不应该分配超过一个后台工作线程来进行记录。阻塞的文件I/O操作将阻止第二个线程写入，直到第一个线程完成。在这种情况下，你并没有获得任何效率的提升。
- en: If you find yourself adding extensive locking to objects in your application,
    you are either using too many threads or the task distribution needs to be changed
    to reduce contention for resources. Try to divide threaded task responsibility
    by the types of data being consumed. You might have many parallel tasks calling
    services to fetch data, but only one or two threads are needed to process the
    data once it is returned.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己正在应用程序中的对象上添加大量的锁定，那么你可能是在使用过多的线程，或者任务分配需要改变以减少对资源的竞争。尝试通过消耗的数据类型来划分线程任务的责任。你可能有很多并行任务调用服务来获取数据，但一旦数据返回，只需要一个或两个线程来处理数据。
- en: 'You may have heard the term **thread starvation**. This usually happens when
    too many threads are blocking or waiting for resources to become available. There
    are some common scenarios where this happens:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过**线程饥饿**这个术语。这通常发生在有太多的线程正在阻塞或等待资源变得可用时。有一些常见的场景会发生这种情况：
- en: '**Locks**: There are too many threads competing for the same locked resources.
    Analyze your code to determine how to reduce contention.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**锁**：有太多的线程在竞争相同的锁定资源。分析你的代码以确定如何减少竞争。'
- en: '`async`. This allows the webserver to serve other requests while yours are
    waiting for operations to complete.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async`。这允许web服务器在你等待操作完成的同时服务其他请求。'
- en: '**Too much threading**: Creating too many thread pool threads will result in
    more idle threads waiting to be processed. It also increases the likelihood of
    thread contention and starvation.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过多的线程**：创建过多的线程池线程会导致更多的空闲线程等待处理。这也增加了线程竞争和饥饿的可能性。'
- en: Avoid these practices, and .NET will do its best to manage the thread pool to
    serve your application and others on the system.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这些做法，.NET 将尽力管理线程池以服务于你的应用程序和其他系统上的应用程序。
- en: Finally, do not use `Thread.Suspend` and `Thread.Resume` trying to control the
    sequence of operations across multiple threads. Instead, leverage other techniques
    discussed in this chapter, including locking mechanisms and `Task.ContinueWith`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，不要使用`Thread.Suspend`和`Thread.Resume`来尝试控制多个线程间操作的顺序。相反，利用本章讨论的其他技术，包括锁定机制和`Task.ContinueWith`。
- en: We have covered plenty of best practices for managed threading in this chapter.
    Let’s wrap up by reviewing what we have learned.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经介绍了许多关于托管线程的最佳实践。让我们通过回顾我们所学的内容来结束本章。
- en: Summary
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed some best practices to follow when working with
    managed threads in C# and .NET. We started by creating some examples of how to
    manage and process static data in a multithreaded application. The examples illustrated
    how to leverage locks, work with singletons, and how static constructors can impact
    performance when working with static data. Next, we explored some techniques for
    avoiding deadlocks and race conditions. Both pitfalls can be avoided if you design
    your algorithms to minimize the need for locking. Finally, we looked at some features
    of .NET that can adjust the limits of several parallel and thread pool operations.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了在 C# 和 .NET 中处理托管线程时应遵循的一些最佳实践。我们首先创建了一些示例，说明了如何在多线程应用程序中管理和处理静态数据。这些示例说明了如何利用锁、与单例一起工作，以及静态构造函数在处理静态数据时如何影响性能。接下来，我们探索了一些避免死锁和竞态条件的技巧。如果你设计算法以最小化锁定需求，这两个陷阱都可以避免。最后，我们查看了一些可以调整多个并行和线程池操作限制的
    .NET 功能。
- en: 'At this point, you are well prepared to start using managed threads responsibly
    in your .NET projects. For some further reading on best practices with managed
    threading, you can check out some recommendations on Microsoft Docs: https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经准备好在 .NET 项目中负责任地使用托管线程了。有关托管线程的最佳实践，你可以查看 Microsoft Docs 上的建议：https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices。
- en: In the next chapter, [*Chapter 4*](B18552_04_ePub.xhtml#_idTextAnchor072), you
    will learn how to leverage parallelism and concurrency to keep your application
    responsive and pick up some best practices for updating the UI from a non-UI thread.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章（[*第 4 章*](B18552_04_ePub.xhtml#_idTextAnchor072)）中，你将学习如何利用并行性和并发性来保持应用程序的响应性，并了解一些从非
    UI 线程更新 UI 的最佳实践。
- en: Questions
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which design pattern models how to create an object that only has one instance?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个设计模式模型描述了如何创建只有一个实例的对象？
- en: What .NET attribute will cause a static field to have one instance per thread?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个 .NET 属性会导致静态字段在每个线程中只有一个实例？
- en: What is a threading deadlock?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程死锁是什么？
- en: Which method on the `Monitor` class can be used to specify a timeout when trying
    to access a locked resource?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在尝试访问已锁定资源时，`Monitor` 类上的哪个方法可以指定超时？
- en: Which lightweight class can be used to lock value types for atomic operations?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个轻量级类可以用于锁定值类型以进行原子操作？
- en: Which thread-safe operation can be used to add two integers?
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个线程安全操作可以用来添加两个整数？
- en: What option can be set on a `Parallel.For` or `Parallel.ForEach` loop to limit
    the number of threads used?
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Parallel.For` 或 `Parallel.ForEach` 循环中可以设置哪个选项来限制使用的线程数？
- en: How can you limit the number of threads used in a PLINQ query?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何限制 PLINQ 查询中使用的线程数？
- en: What is the name of the method to find the current minimum thread values on
    the thread pool?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在线程池中找到当前最小线程值的方法的名称是什么？
