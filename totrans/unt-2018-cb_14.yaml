- en: Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: State-driven behavior DIY states
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State-driven behavior State Design Pattern classes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State-driven behavior with Unity Scriptable Objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publisher-Subscriber pattern C# delegates and events
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model-View-Controller (MVC) pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In computer programming in general, some types of features and requirements
    occur commonly. For computer game programming, there are often features for new
    games that have things in common with existing games. Software **Design Patterns**
    are reusable, computer-language-independent templates for how to solve common
    problems.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Not all design patterns are needed for all languages (for example, some computer
    languages may have features that already provide an easy way to solve a common
    problem). In this chapter, we'll explore several common design patterns in the
    context of Unity game programming in the C# programming language.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The big picture
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no need to reinvent the wheel, and there are many advantages for game
    programmers to adopt tried-and-tested approaches to solving common features for
    game projects. Design patterns have been designed by experience, and refined to
    encourage good programming practice and well-designed architectural software solutions.
    A common theme in design patterns is the independence of code components, and
    clearly-defined interfaces for when components do need to know about each other
    and the protocols for their interactions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the recipes focus on three main design patterns, all of which
    are well known and found not only in game software designs but in the design of
    many interactive software systems, such as web applications and mobile phone programming.
    The design patterns explored in this chapter are:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '**The State pattern**: States and their transitions'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Publisher-Subscriber pattern**: Observers subscribing to event-publishing
    objects'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Model-View-Controller (MCV) pattern**: Separating internal workings from
    UI components and display representations'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, examples are presented in generic object-oriented designs,
    also there are C#-specific features (such as **delegates** and **events**), and
    some Unity-specific features (such as **scriptable objects**). While generic approaches
    have the advantage that programmers from other languages or domains will be instantly
    familiar with their Unity game implementations, the most significant game memory-speed
    improvements are found through exploiting language- and engine-specific features.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'C# **Delegate** variables are like a container for a function (or collection
    of functions) that can be passed around and invoked. They have values assigned
    to them and can be changed at runtime. **Delegates** can multicast through the
    use of the `+=` operator, multiple methods can be assigned a single delegate,
    and all will be invoked when the delegate is invoked. C# **events** are a special,
    more secure kind of delegate. By defining public static event variables, we restrict
    other script classes to only be allowed to:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Subscribe one of their methods
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsubscribe one of their methods
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events ensure a good separation of our code logic, and mean that the script
    class publishing events does not need to know anything about, or how many, other
    script classes are subscribing to published events.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some sources where you can learn more about **Design Patterns** and
    Unity:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'The Unity tutorial about **Scriptable Objects** for enemy state-driven AI:
    [https://unity3d.com/learn/tutorials/topics/navigation/finite-state-ai-delegate-pattern](https://unity3d.com/learn/tutorials/topics/navigation/finite-state-ai-delegate-pattern)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Unity tutorial about **delegates** and **events**:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://unity3d.com/learn/tutorials/topics/scripting/delegates?playlist=17117](https://unity3d.com/learn/tutorials/topics/scripting/delegates?playlist=17117)'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://unity3d.com/learn/tutorials/topics/scripting/events](https://unity3d.com/learn/tutorials/topics/scripting/events)'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prime[31]''s video about Unity delegates and events (from 2011, but still a
    nice introduction): [http://www.youtube.com/watch?v=N2zdwKIsXJs](http://www.youtube.com/watch?v=N2zdwKIsXJs)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Eric Nordeus'' tutorial on Unity and **Design Patterns**: [http://www.habrador.com/tutorials/programming-patterns/](http://www.habrador.com/tutorials/programming-patterns/)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unity **Model-View-Controller** tutorials:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Gameasutra: [https://www.gamasutra.com/blogs/TabeaIseli/20160926/282062/MVC_in_Unity.php](https://www.gamasutra.com/blogs/TabeaIseli/20160926/282062/MVC_in_Unity.php)'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Eduardo Dias Da Costa: [https://www.toptal.com/unity-unity3d/unity-with-mvc-how-to-level-up-your-game-development](https://www.toptal.com/unity-unity3d/unity-with-mvc-how-to-level-up-your-game-development)'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Jackson Dunstan: [https://jacksondunstan.com/articles/3092](https://jacksondunstan.com/articles/3092)'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: State-driven behavior DIY states
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Games as a whole, and individual objects or characters, can often be thought
    of (or modeled as) passing through different states or modes. Modeling states
    and changes of state (due to events or game conditions) is a very common way to
    manage the complexity of games and game components. In this recipe, we create
    a simple three-state game (game playing/game won/game lost) using a `GameManager`
    class. Buttons and a timer are provided to simulate the events that would allow
    a player to win or lose the game:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db3d658f-f2bb-45a7-b80a-21f607df37ec.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use states to manage object behavior, follow these steps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Create two UI Buttons at the top-middle of the screen. Name one `Button-win`
    and edit its text to read `Win Game`. Name the second `Button-lose` and edit its
    text to read `Lose Game`.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a UI Text object at the top left of the screen. Name this `Text-state-messages`,
    and set its Rect Transform height property to `300` and its Text (Script) Paragraph
    Vertical Overflow property to `Overflow`.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new C# script class,&nbsp;`GameStates.cs`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create the&nbsp;`MyGameManager.cs`&nbsp;C# script class, and add an instance
    object as a component to the Main Camera:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create the&nbsp;`ButtonActions.cs`&nbsp;C# script class, and add an instance
    object as a component to the Main Camera:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the Hierarchy, select the Button-win button, and for its Button (Script)
    component, add an OnClick action to call the `BUTTON_CLICK_ACTION_WIN_GAME()`
    method from the ButtonsActions component in the Main Camera GameObject.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Hierarchy, select the Button-lose button, and for its Button (Script)
    component, add an OnClick action to call the `BUTTON_CLICK_ACTION_LOSE_GAME()`
    method from the ButtonActions component in the Main Camera GameObject.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Hierarchy, select the Main Camera GameObject. Drag this GameObject into
    the Inspector to ensure that all three GameManager (Script) public variables (Text
    State Messages, Button Win Game, and Button Lose Game)&nbsp;have the corresponding
    Canvas GameObjects dragged into them (the two buttons and the UI Text GameObject).
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As can be seen in the following state chart figure, this recipe models a simple
    game, which starts in the `GamePlaying` state; then, depending on the button clicked
    by the user, the game moves either into the `GameWon` state or the `GameLost`
    state. Also, if the user waits too long (five seconds) to click on a button, the
    game moves into the `GameLost` state.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'The possible states of the system are defined using the enumerated&nbsp;`GameStateType`&nbsp;type
    in the&nbsp;`GameStates` class, and the current state of the system at any point
    in time is stored in the&nbsp;`currentState` variable of GameManager:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/618d0afd-9a1a-42b7-878d-22f91b072349.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: The initial state,&nbsp;`GamePlaying`, is set in the `Start()` method of `MyGameManager`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '`GameManager` seems to now be a special asset name in Unity, for that reason,
    we have named our game manager script classes `MyGameManager` to avoid any issues.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: When the `MyGameManager` object receives messages (for example, every frame
    for `Update()`), its behavior must be appropriate for the current state. So, we
    see a `Switch` statement in the&nbsp;`Update()` method&nbsp;that calls state-specific
    methods. For example, if the current state is `GamePlaying`, when an `Update()`
    message is received, the `UpdateStateGamePlaying()` method will be called.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NewGameState(...)` method first calls the `OnMyStateExit(...)` method
    with the current state, since there may be actions to be performed when a particular
    state is exited; for example, when the `GamePlaying` state is exited, it destroys
    the two buttons. Next, the `NewGameState(...)` method sets the `currentState`
    variable to be assigned the new state. Next, the `OnMyStateEnter(...)` method
    is called, since there may be actions to be performed immediately when a new state
    is entered. Finally, a message divider is posted     to the UI Text box, with a call to the `PostMessageDivider()` method.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: The `BUTTON_CLICK_ACTION_WIN_GAME()` and `BUTTON_CLICK_ACTION_LOSE_GAME()` methods
    are executed if their corresponding buttons have been clicked. They move the game
    into the corresponding `GameWon` or `GameLost` state.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Logic has been written in the `UpdateStateGamePlaying()` method, so once&nbsp;`MyGameManager`
    has been in the `GamePlaying` state for more than a certain time (defined in the&nbsp;`timeToPressAButton`
    variable), the game will automatically change into the `GameLost` state.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: So, for each state, we may need to write methods for state exit, state entry,
    and update events, and also a main method for each event with a Switch statement
    to determine which state method should be called (or not). As can be imagined,
    the size of our methods and the number of methods in our `MyGameManager` class
    will grow significantly as more states and a more complex game logic are needed
    for non-trivial games.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next recipe takes a more sophisticated approach to state-driven games, where
    each state has its own class. The next recipe in this chapter illustrates how
    to manage the complexity of states with class inheritance and the State Design
    Pattern.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State-driven behavior using the State Design Pattern
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous pattern illustrated not only the usefulness of modeling game states,
    but also how a game manager class can grow in size and become unmanageable. To
    manage the complexity of many states and complex behaviors of states, the State
    pattern has been proposed in the software-development community. Design patterns
    are general-purpose software component architectures that have been tried and
    tested and found to be good solutions to commonly-occurring software-system features.
    The key features of the State pattern are that each state is modeled by its own
    class and that all states inherit (are subclassed) from a single parent state
    class. The states need to know about each other in order to tell the game manager
    to change the current state. This is a small price to pay for the division of
    the complexity of the overall game behavior into separate state classes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: Many thanks to the contribution from Bryan Griffiths, which has helped
    improve this recipe.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe builds upon the previous recipe. So, make a copy of that project,
    open it, and then follow the steps for this recipe.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To manage an object''s behavior using the State pattern architecture, perform
    the following steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C# script class called `GameState`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a new C# script class called `StateGamePlaying`:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a new C# script class called `StateGameWon`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a new C# script class called `StateGameLost`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Replace the contents of the&nbsp;`MyGameManager`&nbsp;C# script class with
    the following:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the Hierarchy, select the Button-win button, and for its Button (Script)
    component, add an OnClick action to call the `BUTTON_CLICK_ACTION_WIN_GAME()`
    method from the GameManager component in the Main Camera GameObject.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Hierarchy, select the Button-lose button, and for its Button (Script)
    component, add an OnClick action to call the `BUTTON_CLICK_ACTION_LOSE_GAME()`
    method from the GameManager component in the Main Camera GameObject.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Hierarchy, select the Main Camera GameObject. Drag&nbsp;it into the Inspector
    to ensure that all three GameManager (Script) public variables (Text State Messages,
    Button Win Game, and Button Lose Game)&nbsp;have the corresponding Canvas GameObjects
    dragged into them (the two buttons and the **UI Text** GameObject).
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The scene is very straightforward for this recipe. There is the single Main
    Camera GameObject that has the `MyGameManager` script object component attached
    to it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: "A C# scripted class is defined for each state that the game needs to manage—for\
    \ this example,&nbsp;`StateGamePlaying`, `StateGameWon`, and `StateGameLost`.\
    \ Each of these state classes is a subclass of `GameState`. `GameState` defines\
    \ properties \Land methods that all subclass states will possess:"
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'An enumerated type `EventType`, which defines the two possible button click
    events that the game might generate: `ButtonWinGame` and `ButtonLoseGame`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `gameManager` variable so that each state object has a link to the game
    manager.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructor method that accepts a reference to `MyGameManager`, which&nbsp;automatically
    makes the `gameManager` variable refer to the passed-in `MyGameManager` object.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The four methods with empty bodies: `OnMyStateEntered()`, `OnMyStateExit()`,
    `OnEventRecieved(...)`, and `StateUpdate()`. Note that these methods are declared
    virtual so that they can be overridden by subclasses if necessary, but if not
    overridden then will do nothing.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the `MyGameManager` class''s&nbsp;`Awake()` method is executed, three
    state objects are created, one for each of the playing/win/lose classes. These
    state objects are stored in their corresponding variables: `stateGamePlaying`,
    `stateGameWon`, and `stateGameLost`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The `MyGameManager` class has a variable called `currentState`, which is a reference
    to the current state object at any time while the game runs (initially, it will
    be null). Since it is of the `GameState` class (the parent of all state classes),
    it can refer to any of the different state objects.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: After `Awake()`, `GameManager` will receive a `Start()` message. This method
    initializes&nbsp;`currentState` to be the `stateGamePlaying` object.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'For each frame,&nbsp;`GameManager` will receive `Update()` messages. Upon receiving
    these messages, `GameManager` sends a `StateUpdate()` messages to&nbsp;`currentState     &nbsp;`&nbsp;object. So, for each frame, the object for the current state of the
    game will execute those methods. For example, when&nbsp;`currentState` is set
    to game playing, for each frame, the `gamePlayingObject` will calls its (in this
    case, empty) `StateUpdate()` method.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The `StateGamePlaying` class implements statements in its `OnEventReceived()`
    method so that when the user clicks on a button, the `gamePlayingObject` will
    call the `GameManager` instance's `NewState(...)` method, passing it the object
    corresponding to the new state. So for example, if the user clicks on Button-win,
    the `NewState(...)` method is passed to `gameManager.stateGameWon`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Timer event to lose the game after five seconds
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The state pattern solution makes it much simpler, and cleaner to add new features.
    For example, to add the five-second-timer feature to this recipe, do the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C# script class called `SimpleTimer`, and add an instance object
    as a component to the Main Camera GameObject:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add a new event type of `TimerFinished` to the `GameState` script class:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add a new case to the switch statement in `StateGamePlaying`, so that this
    `TimerFinished` event also causes the game to go into the `GameLost` state:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: See also
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, some of the complexity of different types of events causing
    the `MyGameManager` to change its current state was implemented by other scripted
    objects (`ButtonActions` and `SimpleTimer` as scripted object components inside
    Main Camera) invoking the&nbsp;`PublishEventToCurrentState(...)` public method.
    A better was to implement events in games is provided later in this chapter in
    the&nbsp;*Publisher-Subscriber pattern C# delegates and events* recipe.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State-driven behavior with Unity Scriptable Objects
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity has a feature called Scriptable Objects. Scriptable Objects are asset
    files stored in the `Assets` folder, like any other asset (such as Materials or
    Textures). In some ways,&nbsp;Scriptable Objects are like Monobehaviours, but
    they are not attached to GameObjects. Both logic (code) and data can be stored
    as asset files in the form of&nbsp;Scriptable Objects.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we implement a state-based game where the game starts in a game-playing
    state, and goes to a game-lost state when a timer runs out. If two stars are collected
    before the timer runs out, the game goes into the game-won state. A **UI Button**
    is offered to the user, which collects a star each time it is clicked.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: As you'll see, Scriptable Object asset files are used to represent which decisions
    cause which state changes to take place.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To manage a game''s state-driven behavior with Unity Scriptable Objects, perform
    the following steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Create a **UI Button** in the middle of the screen. Name it `Button-collect-star`
    and edit its text to read `Collect a star`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **UI Text** object at the top-right of the screen. Name this `Text-current-state`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **UI Text** object at the top-left of the screen. Name this `Text-stars-collected`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a second UI Text object at the top-left of the screen, positioned below
    `Text-stars-collected`. Name this `Text-seconds-left`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new C# script class called `Decision`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a new C# script class called `Transition`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a new C# script class called `State`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a new C# script class called `StateController`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a new C# script class called `GameWonDecision`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a new C# script class called `GameLostDecision`:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a new C# script class called `MyGameManager`, and add an instance object
    as a component of the Main Camera:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the Hierarchy, select the Button-collect-star button, and for its Button
    (Script) component, add an OnClick action to call the `BUTTON_ACTION_PickupOneStar()`
    method from the `MyGameManager` component in the Main Camera GameObject.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project panel, create two new folders, named `_Decisions` and `_States`.
    These folders will contain the Scriptable Object asset files for this project.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the&nbsp;`_Decisions` folder, create two new Decision Scriptable Objects
    named `GameWonDecision` and `GameLostDecision`. Do this by choosing menu: Assets
    | Create | MyGame | Decisions.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the&nbsp;`_States` folder, create three new State Scriptable Objects named
    `StateGamePlaying`, `StateGameWon`, and `StateGameLost`. Do this by choosing menu:
    Assets | Create | MyGame | State.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the&nbsp;Project panel folder `_States`, select the&nbsp;`StateGamePlaying`
    Scriptable Object, and in the Inspector, set the size of its Transitions property
    to `2`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For Element 0, set the Decision to GameWonDecision and the True&nbsp;state to
    StateGameWon
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Element 1, set the Decision to GameLostDecision and the True&nbsp;state
    to StateGameLost:'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/36fe5ff2-2a96-4d8a-babb-f9622131b3bf.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: In the Hierarchy, select the Main Camera GameObject. Drag it into the Inspector
    to ensure that all three GameManager (Script) public variables (Text Current State,
    Text Stars Collected, and Text Seconds Left)&nbsp;have the corresponding Canvas
    **UI Text** GameObjects dragged into them.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. The game should start in `StateGamePlaying`. If the user does
    nothing, when the timer gets to zero, the game should go into `StateGameLost`.
    If the user clicks the button twice (simulating collecting two stars) before the
    timer hits zero, the game should go into `StateGameWon`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GameManager knows nothing about the state-based decisions going on in this
    game. It has a public method giving the number of seconds left in the timer: `GetTimeRemaining()`.
    It also has a public method that returns a Boolean (true/false) about whether
    or not all stars have been collected: `HasCollectedAllStars()`. It also has references
    to the three&nbsp;**UI Text** GameObjects, so it can keep the display updated
    with the time left and stars collected. A public&nbsp;`DispayCurrentState(...)`&nbsp;method
    also updates the name of current game state (that is, whatever was passed to this
    method).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The core game behavior is driven by the `StateController` script class. This
    maintains the current state, and has a reference to the instance object of the
    `MyGameManager` class that is its sibling component in the Main Camera. Its `Awake()`
    method gets the reference to the `MyGameManager` object. Its `Update()`&nbsp;method
    invokes the current state's `UpdateState(...)` method. It passes a reference to
    itself to the current state. It also has a third public method, `TransitionToState(...)`,
    which allows a state to instruct the controller to change the current state.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Transition` class has no methods, it simply stores references to two objects:
    a decision and the state that the system will to change to if the decision is
    true.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: The `Decision` class is abstract, which means there will never be any objects
    created from this class, but subclasses may be defined. It declares that any subclasses
    must implement a method named `Decide(...)`, which&nbsp;returns a Boolean (true/false)
    value.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: The `State` class has an array of `Transition` objects, and its `UpdateState()`
    method simple invokes its `CheckTransitions(...)` method.&nbsp;`CheckTransitions(...)`
    loops through each transition, testing its `Decision`. If the decision is true,
    it tells&nbsp;`StateController` to make the current state the true state of the
    transition.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project, we have declared two subclasses of the `Decision` class:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '`GameWonDecision`: This class'' `Decide(...)` method returns the value of its&nbsp;`GameWonActionDetected(...)`
    method.&nbsp;`GameWonActionDetected(...)` returns the value of the game manager''s
    `HasCollectedAllStars()` method, that is, the game-won decision is true when the
    game manager says that all stars have been collected.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GameWonDecision`: This class''s&nbsp;`Decide(...)` method returns the value
    of its&nbsp;`GameLostActionDetected(...)` method.&nbsp;`GameLostActionDetected(...)`
    returns true if the game manager''s timer is zero or less (time has run out).'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have created five scriptable object assets:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '**Three states**: `StateGamePlaying`, `StateGameWon`, `StateGameLost`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Two decisions**: `GameWonDecision` and `GameLostDecision`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We were able to create these Scriptable Object assets via the Create menu through
    the statements immediately before the script-class declarations for `Decision`
    and `State` that declared that there should be a new sub-menu in the Create Asset
    menu named MyGame:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The only one of these Scriptable Objects that needed any customizing was `StateGamePlaying`.
    Two transitions were defined in this object:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: If `GameWonDecision` becomes true, the State Controller should set the current
    state to `StateGameWon`
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `GameLostDecision` becomes true, the State Controller should set the current
    state to `StateGameLost`
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While it may seem like there was a lot of work for this simple game, what this
    recipe illustrates is how some generic state-machine classes can be created (`State`,
    `Decision`, `Transition`, `StateController`), and that the actual game behavior
    is modelled through a set of Scriptable Object assets, and two classes to implement
    the decision-making for special game events (`GameWonDecision` and `GameLostDecision`).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Since Scriptable Object are asset files, there are only one of them. At times,
    we may want the same Scriptable Object to be used by different GameObjects when
    the game is running—for example, the state transitions for the AI of lots of different
    enemy characters may share the use of the same Scriptable Object. For this reason,
    a reference to a `StateController` object instance is passed when methods are
    invoked on `State` and `Decision` Scriptable Objects,&nbsp;so the logic in the
    methods of the Scriptable Object can work on whatever run-time controller object
    is provided with. This is an example of another design pattern known as the **Delegate**
    design pattern (not to be confused with a C# delegate!).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Extending the game to model Player health
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To further understand the power of this data-centric approach to state-based
    games, let''s add the following behavior to the game:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The player has a health value, starting at 100% (a float value of 1.0)
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In each frame, a random amount of health is added or subtracted
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The game is lost if the health of the player goes down to zero
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To implement this feature, all we need to do is:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a test to the&nbsp;`GameLostDecision`&nbsp;script class to return true
    if time or health are zero:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the `health` feature to the&nbsp;`GameManager` script class:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We could also add another **UI Text** on screen to see the current value of
    health. If the public `healthPlusMaximum` variable is set smaller than the minus
    maximum (for example,&nbsp;`0.02`), the health will go downwards since the random
    average will be less than zero.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'To add another state, such as&nbsp;`StatePauseGame`, all that is needed are
    the following steps:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Create new&nbsp;`GamePausedDecision` script class, with the logic to detect
    whether the game is paused (for example, the game manager could have an&nbsp;`isPaused`&nbsp;boolean
    variable that gets set to true when the user presses the *P* key)
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new&nbsp;`StateGamePaused` Scriptable Object State
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new&nbsp;`GamePausedDecision` Scriptable Object State
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a third transition to the&nbsp;`StateGamePlaying`&nbsp;Scriptable Object
    State (element 2), with `GamePausedDecision` and the true state of `StateGamePaused`
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To see this approach to state-driven games using Scriptable Objects taken much
    further, including adding the feature for actions to be performed during each
    state, follow the online video Unity tutorial about Scriptable Objects for enemy
    state-driven AI:&nbsp;[https://unity3d.com/learn/tutorials/topics/navigation/finite-state-ai-delegate-pattern](https://unity3d.com/learn/tutorials/topics/navigation/finite-state-ai-delegate-pattern).
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publisher-Subscriber pattern C# delegates and events
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When events can be based on visibility, distance, or collisions, we can use
    such events as `OnTriggerExit` and `OnBecomeInvisible`. When events can be based
    on time periods, we can use coroutines. However, some events are unique to each
    game situation, and C# offers several methods of broadcasting user-defined event
    messages to scripted objects. One approach is the `SendMessage(...)` method, which,
    when sent to a GameObject, will check every Monobehaviour scripted component and
    execute the named method if its parameters match. However, this involves an inefficient
    technique known as reflection. C# offers another event message approach known
    as delegates and events, which we describe and implement in this recipe.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Delegates and events work in a similar way to `SendMessage(...)`, but are much
    more efficient since Unity maintains a defined list of which objects are listening
    to the broadcast events. `SendMessage(...)` should be avoided if performance is
    important, since it means that Unity has to analyze each scripted object (reflect
    over the object) to see whether there is a public method corresponding to the
    message that has been sent; this is much slower than using delegates and events.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Delegates separate the code declaring the delegate from any of the codes (classes)
    that use the delegate. The script-class that declares the public delegate does
    not need to know anything about the object or objects that make use of its delegated
    functionality.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Delegates and events implement the **Publisher-Subscriber design pattern** (**pubsub**).
    This is also known as the **Observer** design pattern. Objects can subscribe one
    of their methods to receive a particular type of event message from a particular
    publisher. In this recipe, we'll have a manager class that will publish new events
    when **UI Buttons** are clicked. We'll create some **UI objects**, some of which
    subscribe to the color-change events. Each time a color-change event is published,
    subscribed **UI objects** receive the event message and change their color accordingly.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: We will also add a console event logger, to listen for and log messages about
    color-change events.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'C# publisher objects don''t have to worry about how many objects subscribe
    to them at any point in time (it could be none or 1,000!). This is known as **loose
    coupling**, since it allows different code components to be written (and maintained)
    independently and is a desirable feature of object-oriented code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2154430f-5063-4aa5-a1ab-610c558782c8.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, a Unity Package has been provided (`colorChangeScene.unitypackage`)
    in the `17_04` folder. This package contains a scene with **UI Buttons** and other
    objects for the recipe.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement the Publisher-Subscriber pattern using C# delegates and events,
    follow these steps:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity project, and delete the default&nbsp;`Scenes` folder.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the provided Unity package (`colorChangeScene.unitypackage`).
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `ColorManager` C# script class to the Main Camera:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create the&nbsp;`ColorChangeListenerImage`&nbsp;C# script class, and add an
    instance object as a component to the&nbsp;`Image-listening` and `Slider-listening`
    GameObjects (both children of&nbsp;Canvas | listening-game-objects):'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create the&nbsp;`ColorChangeListenerText`&nbsp;C# script class, and add an
    instance object as a component to the&nbsp;`Text-listening` GameObject&nbsp;(a
    child of&nbsp;Canvas | listening-game-objects):'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create the `ColorChangeListenerConsole` C# script class:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create the `ColorModel` C# script class:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With button-GREEN selected in the Hierarchy, add a new OnClick() event for this
    button, dragging the Main Camera as the target GameObject and selecting the&nbsp;BUTTON_ACTION_make_green()
    public function. Do the same for the button-BLUE and button-RED buttons with the&nbsp;BUTTON_ACTION_make_blue()
    and BUTTON_ACTION_make_red() functions, respectively.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. When you click a change-color button, the three **UI objects**
    on the right of the screen show all changes to the corresponding color, while
    the two **UI objects** at the bottom-left of the screen remain in the default
    white color. You should also see `Debug.Log` messages in the Console panel, showing
    the RBG color corresponding to the button that was clicked.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have added an instance object of `ColorManager` to the Main Camera. This
    class does three main things:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Creates an instance object of the&nbsp;`ColorChangeListenerConsole` script class
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates an instance object of the&nbsp;`ColorModel` script class
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offers three public methods that can be invoked by clicking the red/green/blue
    UI Buttons
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each time a button is clicked, the `colorModel` object is told to `SetColor(...)`
    to the corresponding color.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: The `ColorModel`&nbsp;script class has a private variable of the current color.
    This value can be changed by invoking its `SetColor(...)` method (from the `ColorManager`
    when a button is clicked). As well as changing the value of color, the&nbsp;`SetColor(...)`&nbsp;method
    also invokes the&nbsp;`PublishColorEvent()` method. The&nbsp;`PublishColorEvent()`&nbsp;method
    publishes the&nbsp;`OnChangeColor(this.color)` event,&nbsp;so that all registered
    listeners to this event will be invoked with the new color value.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'On the right-hand side of the screen, we have three GameObjects: Image-listening,
    Slider-listening, and Text-listening. Each of these objects has a scripted component
    of either `ColorChangeListenerImage` or `ColorChangeListenerText`. These components
    register their respective `OnChangeColor(...)` methods to listen for `OnChangeColor(this.color)`
    events. The `ColorChangeListenerImage` and `ColorChangeListenerText` script classes
    both register their `ChangeColor(...)` methods to the `OnChangeColor(...)` event
    of the `ColorModel` script class.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: The&nbsp;`ColorChangeListenerConsole`&nbsp;script class also registers its `ChangeColor(...)`
    methods to the `OnChangeColor(...)` event of the&nbsp;`ColorModel` script class.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Since our scripted objects may be disabled and enabled at different times, each
    time a scripted `ColorChangeListener` object is enabled (such as when its GameObject
    parent is instantiated), its `OnChangeColor()` method is added (`+=`) to the list
    of those subscribed to listen for color-change events, likewise, each time `ColorChangeListenerImage`
    or `Text` objects are disabled, those methods are removed (`-=`) from the list
    of event subscribers.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: It is very important that methods are removed from the list of subscribers to
    an event when they are no longer required. Failure to do this can lead to significant
    problems, such as memory leaks.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: When `ColorChangeListenerImage` or a `Text` object receives a color-change message,
    its subscribed `OnChangeColor()` method is executed and the color of the appropriate
    component is changed to the received color value (green/red/blue).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: The `ColorManager` class declares a **Delegate** named `ColorChangeHandler`.
    Delegates define the return type (in this case, `void`) and argument signature
    of methods that can be delegated (subscribed) to an event. In this case, methods
    must have the argument signature of a single parameter of the&nbsp;`Color` type.
    Our `OnChangeColor()` method in the&nbsp;`ColorChangeListenerImage`, `Text`, and
    `Console`&nbsp;classes matches this argument signature and so is permitted to
    subscribe to&nbsp;`changeColorEvent` in the `ColorManager` class.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that&nbsp;`ColorChangeListenerConsole` does not have `OnEnable`
    or `OnDisable` methods. This is because it is not a MonoBehaviour, and so does
    not receive Unity runtime events such as `Awake()`, `Update()`, or `OnEnable()`.
    However, being a simple class, it can have a constructor method invoked when a
    new object instance is created with the new keyword, and a destructor method invoked
    when the object is no longer referenced. So it is in those methods that these
    objects register and deregister to listen to `ColorModel.OnChangeColor` events.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Model-View-Controller (MVC) pattern
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Model-View-Controller** (**MVC**) pattern is a software architecture that
    tries to separate the data (Model) from the displays (Views) and actions that
    change that data (Controller).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we use the MVC pattern to implement a feature of many games—a
    visual health bar representing the Player''s numeric health value (in this case,
    a float number from 0.0 - 1.0). As the user presses the Up/Down arrow keys (simulating
    healing and damage), the value of the player''s heath changes. With the health-change
    events, the visual display and a **Console** log are updated to present the new
    health values to the user:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f1a83c1-3d1a-4ecd-8b51-b8ba25b99953.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, two images been provided in the `17_05` folder:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '`health_bar_outline.png`: A red heart image and outline for the health filler'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`health_bar_fill_blue_to_green.png`: A graduated (blue left to green right)
    filler image, indicating how much health is left'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thanks to Pixel Art Maker for the health bar image:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[http://pixelartmaker.com/art/49e2498a414f221](http://pixelartmaker.com/art/49e2498a414f221)'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement the MVC pattern in Unity, follow these steps:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Import the two provided images.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **UI Image** named `Image-health-bar-outline`, and populate it with
    the `health_bar_outline` image asset.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **UI Image** named `Image-health-bar-filler`, and populate it with
    the `health_bar_fill_blue_to_green` image asset. In the Inspector for the Image
    (Script) component, set the Image Type to Filled, and the Fill Type to Horizontal.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Arrange your **Canvas** so that Image-health-bar-filler is before Image-health-bar
    in the Hierarchy (the filler appears behind the outline).
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new C# script class,&nbsp;`Player`:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create a new C# script class,&nbsp;`PlayerController`:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a new C# script class,&nbsp;`HealthBarDisplay`, and add an instance
    object as a component to `Image-health-bar-filler`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a new C# script class,&nbsp;`HealthChangeLogger`:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the following `PlayerManager` C# script class&nbsp;to the Main Camera:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Run the game. Pressing the Up/Down arrow keys should raise/lower the player's
    health, which should be confimed by the meter fill image, and in the `Debug.Log()`
    messages in the **Console**.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You were provided with two&nbsp;**UI Images**:&nbsp;one is a health bar outline
    (red heart and a black outline), the second is the filler image—to show dark blue
    to light blue to green, for weak to strong health values.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: You set the Image Type of Image-health-bar-filler to be Filled, and that it
    is to be filled Horizontally (left to right). Therefore, the fillAmount property
    of a UI Image determines how much of this filler image is displayed to the user
    (from `0.0` to `1.0`).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: The `PlayerManager`&nbsp;script class is a manager script that initializes the&nbsp;`PlayerController`
    and `HealthChangeLogger` objects, and also allows the user to change the health
    of the Player by pressing the Up and Down arrow keys (simulating healing/damage
    during a game). Via the `Update()` method, each Up/Down arrow key press invokes
    the `PlayerController` methods:&nbsp;`AddToHealth()` and `ReducedHealth()`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The `PlayerController`&nbsp;script class creates a `PlayerModel` object in its
    constructor. It has two other methods, `AddToHealth()` and `ReducedHealth()`,
    that add to/reduce the health of the `PlayerModel` object by `+0.5` and `-0.1`,
    respectively.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: The `PlayerModel`&nbsp;script class manages values for `Player` health, and
    uses delegates and events to publish health changes to any listening **View**
    classes. When a new object is created, the health property is initialized, and
    a health-change event is published to all listening objects. Likewise, when the
    `AddHealth(...)` and `ReduceHealth(...)` methods are invoked with a value, the
    value of the health is changed, and the health-change event is published to all
    listening objects. The&nbsp;`OnHealthChange`&nbsp;event is visible to other objects
    as a static public event. The&nbsp;`PublishHealthChangeEvent()`&nbsp;method publishes
    the new value of health by invoking all listening `OnHealthChange(...)` methods.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two View classes that register to listen for `Player.OnHealthChange(...)`
    events:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '`HealthBarDisplay`: Updates&nbsp;`fillAmount` for a UI Image for each new health
    value received'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HealthChangeLogger`: Prints messages about the new `Player health` value received
    to the Debug.Log file'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As can be seen, each of the Model/View/Controller classes is quite small and
    simple, and each has their own, well-defined responsibilities. It would be easy
    to add another kind of health-change event listener, perhaps to play a sound,
    without having to change any code in any of these existing classes. Likewise,
    it would be straightforward to add a new property to our `PlayerModel` (perhaps
    a score or inventory value of stars collected, and then add another public static
    event for score/inventory changes to be published to subscribed listening views).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如所见，每个Model/View/Controller类都相当小且简单，并且每个都有自己的、定义良好的职责。很容易添加另一种健康变化事件监听器，比如播放一个声音，而不需要更改这些现有类中的任何代码。同样，添加一个新的属性到我们的`PlayerModel`（可能是一个得分或收集到的星星的库存值）也很简单，然后添加另一个公共静态事件，以便将得分/库存更改发布给订阅的监听视图。
- en: See also
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Only&nbsp;`PlayerManager` is a MonoBehaviour. One of the advantages of this
    MVC&nbsp;architecture is that each of these components becomes much easier to
    unit-test in isolation. A version of this recipe is used as an example in the&nbsp;*State
    Design Pattern* *PlayMode and Unit Testing a health bar with events, logging,
    and exceptions*&nbsp;recipe in Chapter 19, *Automated Testing*&nbsp;.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有`PlayerManager`是一个MonoBehaviour。这种MVC架构的一个优点是，这些组件中的每一个都变得更容易在隔离状态下进行单元测试。这个食谱的版本在第19章“自动化测试”中的*状态设计模式*
    *PlayMode和单元测试带有事件、日志和异常的健康条*食谱中被用作示例。
