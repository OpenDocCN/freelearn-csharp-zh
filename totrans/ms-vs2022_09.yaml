- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling Advanced Git Workflows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will dive deep into the world of Git integration within
    Visual Studio, focusing on practical skills that will enhance our software development
    workflows. We will focus on advanced features provided by Visual Studio 2022.
    This chapter is designed to equip you with the tools and techniques needed to
    manage repositories efficiently, resolve conflicts effectively, and leverage the
    power of interactive staging.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing a repository through Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolving conflicts through Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring interactive staging in Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to streamline our process for collaborative development experiences,
    we will explore mastering the management of branches, resolving conflicts, and
    implementing interactive staging.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While writing this chapter, I used the following versions of Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Enterprise 2022 version 17.12.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preview 1.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing a repository through Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re familiar with development, you’ll have likely already used tools such
    as **GitKraken** or **Sourcetree** , among others. For now, all our daily usage
    of Git and repository management can be handled entirely within Visual Studio.
    In this section, we’ll explore how we can leverage Visual Studio to manage our
    repositories without having to exit our favorite IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Manage Branches window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Visual Studio 2022 introduced a window named **Manage Branches** . To open
    it, we have several options. The first option is using the top **Git** | **Manage
    Branches** menu option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Manage Branches top-bar menu option](img/B22218_09_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Manage Branches top-bar menu option
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is going to **Git Changes** windows, then using the three
    dots in the top-right corner of the window and selecting **Manage Branches** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Manage Branches Git Changes menu](img/B22218_09_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Manage Branches Git Changes menu
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, in the **Git Changes** window, if we have pending outgoing or incoming
    commits, we can directly click on the **View Commits** link below the **Branches**
    **Combo** box.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we can search for this feature by using the **Feature Search** box
    with the *Ctrl* + *Q* shortcut.
  prefs: []
  type: TYPE_NORMAL
- en: 'This action will open the **Git** **Repository** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Git Repository window](img/B22218_09_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Git Repository window
  prefs: []
  type: TYPE_NORMAL
- en: 'In this window, we can find all the branches of our repository. When we click
    on a branch, we can see details about its state, in the right part of the window,
    which is organized into three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Incoming** : This section shows changes from other branches that have not
    yet been merged into the currently selected branch. These changes could come from
    any remote branch that has updates compared to our local branch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Outgoing** : This section displays changes that have been made locally but
    have not yet been pushed to the remote repository. This includes commits that
    we’ve made since our last synchronization with the remote branch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Local History** : This section offers a detailed view of the commit history
    for the currently selected branch. Unlike the **Incoming** and **Outgoing** sections,
    which focus on changes relative to other branches, the **Local History** section
    focuses on the chronological progression of commits within the selected branch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Through this window, we can organize our view using the features offered by
    the toolbox menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Manage Branches toolbox](img/B22218_09_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Manage Branches toolbox
  prefs: []
  type: TYPE_NORMAL
- en: 'This toolbox offers us the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Refresh** : Updates the list of branches, tags, and other repository objects
    displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Go to Child** : Navigates directly to a child branch of the currently selected
    branch. A child branch is typically created from another branch (the parent) as
    a result of operations such as branching or merging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Go to Parent** : Enables navigation to the parent branch of the currently
    selected branch. The parent branch is the branch from which the current branch
    was originally created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Show first Parent Only** : Filters the view to display only the immediate
    parent branch of the current selection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Show Local Branches** : Hides any remote branches from the view, allowing
    you to concentrate on branches that exist only on our local machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Show Remote Branches** : Filters the view to display only the branches that
    exist on the remote repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Show Tags** : Makes Git tags visible in the **Git Repository** window alongside
    branches. Git tags are references to specific points in our repository’s history,
    often used to mark release versions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clear Toggled Branches in History** : Provides a way to clean up branches’
    histories by removing the toggles next to branches in the history panel. This
    can make it easier to see the commit history of the currently selected branch
    without being distracted by toggles indicating the presence of other branches
    in the history.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this toolbox, we can interact with different branches and perform various
    Git operations. To access these options, we open the context menu by right-clicking
    on the desired branch or commit.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Git command menu](img/B22218_09_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Git command menu
  prefs: []
  type: TYPE_NORMAL
- en: From this menu, we can process classic Git commands, such as creating new branches
    and tags, viewing commit details, reverting commits, and even deleting changes.
    Some of the options may be disabled depending on the state of the commit.
  prefs: []
  type: TYPE_NORMAL
- en: One of the handy options provided is **Checkout(--detach)** .
  prefs: []
  type: TYPE_NORMAL
- en: Looking at Checkout(-- detach)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the Git command menu ( *Figure 9* *.5* ), we can find the **Checkout (--detach)**
    option, which allows us to revert to an earlier state of our repository, which
    is particularly useful for testing or running code as it existed at a particular
    moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, we might want to check out the latest commit of a remote branch
    to quickly review a pull request and evaluate the most recent updates. To do this,
    we first need to ensure that we have fetched and updated our local copy of the
    branch. Then, we can right-click on the remote branch of interest and select **Checkout
    Tip** **Commit (--detach)** :'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 9.6 – \uFEFFCheckout Tip Commit (--detach)](img/B22218_09_6.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Checkout Tip Commit (--detach)
  prefs: []
  type: TYPE_NORMAL
- en: It’s crucial to note that any commits made while in a **detached HEAD** state
    aren’t linked to a specific branch. As a result, Git might remove these commits
    once you switch to another branch, as they become vulnerable to being deleted.
    Therefore, to safeguard our work, it’s advisable to start a new branch before
    moving away from a detached HEAD state if we want to keep potential changes.
  prefs: []
  type: TYPE_NORMAL
- en: Handling multiple repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For greater convenience, or depending on our team’s organization, we might come
    across solutions built across several repositories. This could be a nightmare
    to deal with. Visual Studio introduces multi-repo branching, which streamlines
    this use case.
  prefs: []
  type: TYPE_NORMAL
- en: Both the status bar and the **Git Changes** tool window in Visual Studio now
    include enhanced branch selection features that support working with multiple
    repositories. These tools allow for easy switching between branches and facilitate
    branch management across all our currently active repos. To swiftly change branches
    within any active repository, simply expand the repository tree in the branch
    picker and select the branch you wish to switch to.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Select repository](img/B22218_09_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Select repository
  prefs: []
  type: TYPE_NORMAL
- en: For better efficiency, Visual Studio offers us the capability to work with multiple
    repositories as if they were one. Indeed, we can create a new branch across our
    multiple repositories by using the top **Git** | **New branch…** menu option.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 9.8 –Creating \uFEFFa new branch in multi-repositories](img/B22218_09_8.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 –Creating a new branch in multi-repositories
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can choose which repository(s) to include when creating the new branch
    using the checkboxes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can access and manage all repositories and branches through the
    **Manage Branches** feature, allowing us to interact with them seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have learned how to leverage Visual Studio 2022 to manage branches,
    using the **Manage Branches** and multi-repository features, in the next section,
    we will explore an important part of a shared code base: resolving conflicts.'
  prefs: []
  type: TYPE_NORMAL
- en: Resolving conflicts through Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Resolving conflicts involves identifying and merging changes made by multiple
    contributors to the same lines of code. This process ensures that everyone’s contributions
    are integrated smoothly, maintaining the integrity and consistency of the shared
    code base. By understanding and effectively managing these conflicts, teams can
    ensure that their software development process remains efficient and productive,
    fostering a collaborative environment where contributions from all team members
    are valued and integrated seamlessly. In this section, we will see how Visual
    Studio 2022 allows us to handle this process.
  prefs: []
  type: TYPE_NORMAL
- en: Git excels at seamlessly integrating file modifications under normal conditions,
    provided that the content of the files doesn’t undergo significant alterations
    between updates. When our branch lags significantly behind the primary branch,
    it’s advisable to rebase our branches prior to initiating a pull request. This
    process ensures that our branch can be smoothly incorporated into the main branch
    without encountering conflict issues.
  prefs: []
  type: TYPE_NORMAL
- en: Despite its proficiency in resolving changes using the history in our repository,
    merge changes are sometimes not clear, and Git stops the merge and informs us
    about file conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: So, in that case, when we pull the remote branch to our local repository, Visual
    Studio will warn us in the **Git Changes** window with a message and list the
    files that expriencing conflicts with the merge.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Merge conflicts arising](img/B22218_09_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Merge conflicts arising
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the **Car.cs** file was modified on both the remote and local
    branches. In such a case, we must complete the merging process by ourselves. To
    do that, we will double-click on the concerned file, which will open the file
    in resolve conflict mode.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Resolve conflict mode](img/B22218_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Resolve conflict mode
  prefs: []
  type: TYPE_NORMAL
- en: 'In this mode, we can see three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Incoming** : These are the modifications made in the branch we are trying
    to merge with our current branch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Current** : These changes refer to the modifications we have made in our
    current branch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Result** : This section consolidates the result of the merging. Notice that
    we can manually edit this part at our convenience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We may have unique preferences for how conflict windows are displayed. To adjust
    these settings according to personal convenience, simply click on the gear icon
    located in the upper-right corner of the interface.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Change the resolve conflict view](img/B22218_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Change the resolve conflict view
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, we can switch between three modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertical View** : The **Result** section is placed between the **Incoming**
    and **Outgoing** sections'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Horizontal View** : The **Result** section is placed below the **Incoming**
    and **Outgoing** sections'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mixed View** : Here, the **Incoming** and **Outgoing** sections are side
    by side and the **Result** section is below them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resolve conflict mode also provides a toolbox to enable us to easily resolve
    conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Resolve conflict toolbox](img/B22218_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Resolve conflict toolbox
  prefs: []
  type: TYPE_NORMAL
- en: This toolbox allows us to use the **Take Incoming** button (or press *F10* )
    to automatically accept all changes coming from the other branch. Alternatively,
    we can click the **Take Current** button (or press *F11* ) to retain our current
    version of all conflicting changes.
  prefs: []
  type: TYPE_NORMAL
- en: In the left corner, the arrows enable us to navigate through the differences
    and conflicts across the file. This way, we can resolve conflicts line by line.
    To combine both modifications, we can use the checkboxes on the left side of each
    section. We can see them in *Figure 9* *.10* .
  prefs: []
  type: TYPE_NORMAL
- en: After successfully resolving all conflicts, a notification indicating **0 Remaining**
    will appear near the arrows in the top-left corner of the screen. This signifies
    that there are no unresolved conflicts. To finalize the merge operation, click
    on the **Accept** **Merge** button.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after we accept the merge and repeat the process in all conflict files,
    we use the **Git Changes** window to create a merge commit and resolve the conflict.
    In our daily use cases, we sometimes write code that we don’t want to commit immediately
    or at all. Git offers us fine-grained control over which changes are committed,
    a feature known as staging. In the next section, let’s explore how Visual Studio
    streamlines this process.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring interactive staging in Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The staging area is where Git stores information about what will go in our next
    commit.
  prefs: []
  type: TYPE_NORMAL
- en: Staging allows us to select which changes we want to include in the next commit.
    It is a crucial Git feature. The main reason is that it provides a level of granularity
    and control over what gets committed. By staging only the necessary changes, we
    make the project history cleaner and easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, imagine we work on a feature that involves several changes in
    two functions. We might have finished making changes for one function but are
    still working on the other. With staging, we can commit the first function without
    including the second. This way, our commit reflects the state of the feature at
    that point in time, and our teammates can integrate the stable part without getting
    distracted by incomplete tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Since version 17.6, Visual Studio 2022 has integrated interactive staging features.
    In this section, we will explore how.
  prefs: []
  type: TYPE_NORMAL
- en: When we make modifications to the files, these modifications will appear above
    the **Changes** section in the **Git** **Changes** window.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Changes section](img/B22218_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – Changes section
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we made changes to three files. By default, Visual Studio
    displays the **Commit All** button, which **stage all** changes in the files and
    then commits them using the message entered in the text box. As if we executed
    directly those command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to stage only the **Car.cs** file, we can right-click on it and
    select **Stage** ; alternatively, we can use the **+** button that appears on
    the right when the file is selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – Staging a file](img/B22218_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – Staging a file
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, the **Staged Changes** section will appear, and we can find the
    **Car.cs** file listed under it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15 – Staged Changes section](img/B22218_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – Staged Changes section
  prefs: []
  type: TYPE_NORMAL
- en: 'You might notice that now the **Git Changes** window will display a **Commit
    Staged** button instead of the **Commit All** one. Under the hood, Visual Studio
    will execute the following **git** command to stage our specified file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we go back to our initial example, both features can be in the same file.
    For instance, we finish implementing the **UpdateModel()** function and leave
    **DeleteCar()** in a standby state. Here, we will take advantage of the interactive
    staging feature, by selecting the change we want to stage line by line, following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Git Changes** window, we double-click on the **Car.cs** file to open
    the **Diff** window. This will show us the difference between the remote repository
    and our local repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.16 – Diff window](img/B22218_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – Diff window
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have identified the lines you want to stage, select them and click
    on the **+ Stage Lines** pop-up button to add them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.17 – Stage Lines](img/B22218_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.17 – Stage Lines
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the **Git Changes** window, we can find two versions of our **Car.cs**
    file: one with the lines we picked to stage in the **Staged Changes** section
    and another with our complete pending changes in the **Changes** section.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.18 – Staged by line file](img/B22218_09_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.18 – Staged by line file
  prefs: []
  type: TYPE_NORMAL
- en: After staging our changes, we can commit them using the standard commit workflow
    with the **Commit Staged** button. This ensures that our commits are clean and
    logically organized, reflecting the changes we intended to share.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored how we can properly stage commits by selectively
    choosing specific lines of changes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter delved into essential aspects of managing software development
    projects using Visual Studio, focusing on repository management, resolving conflicts,
    and leveraging the interactive staging feature. These lessons are crucial as they
    equip us with the tools and techniques necessary to maintain clean, efficient
    code bases and ensure smooth collaboration among team members.
  prefs: []
  type: TYPE_NORMAL
- en: We started by diving deep into the capabilities of Visual Studio for managing
    repositories, underscoring its critical role in simplifying version control processes.
    Following this, we delved into the art of resolving conflicts within Visual Studio,
    offering valuable insights into navigating the challenges of the merge conflicts
    that commonly surface during teamwork. Our journey concluded with an examination
    of the interactive staging feature, which provides a more user-friendly method
    for preparing commits.
  prefs: []
  type: TYPE_NORMAL
- en: As we move forward to the next chapter, we will build upon the foundational
    knowledge acquired in this chapter. The upcoming discussion will focus on automating
    the integration process, further enhancing project efficiency and reliability.
    This transition marks the next logical step in our journey toward mastering modern
    software development practices through Visual Studio 2022, where continuous integration
    plays a pivotal role in delivering high-quality software consistently.
  prefs: []
  type: TYPE_NORMAL
