- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Writing, Debugging, and Testing Functions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写、调试和测试函数
- en: This chapter is about writing functions to reuse code, debugging logic errors
    during development, unit testing your code to remove bugs, and improving stability
    and reliability.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于编写函数以重用代码，在开发过程中调试逻辑错误，对代码进行单元测试以移除错误，并提高稳定性和可靠性。
- en: In an optional online-only section, you will learn about logging exceptions
    during runtime. You can find information on this at the end of the chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个可选的在线部分，你将学习如何在运行时记录异常。你可以在本章末尾找到相关信息。
- en: 'This chapter covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Writing functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写函数
- en: Debugging during development
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发过程中的调试
- en: Hot reloading during development
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发过程中的热重载
- en: Unit testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Throwing and catching exceptions in functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数中抛出和捕获异常
- en: Writing functions
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写函数
- en: A fundamental principle of programming is **don’t repeat yourself** (**DRY**).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 编程的一个基本原则是**不要重复自己**（**DRY**）。
- en: While programming, if you find yourself writing the same statements over and
    over again, then turn those statements into a **function**. Functions are like
    tiny programs that complete one small task. For example, you might write a function
    to calculate sales tax and then reuse that function in many places in a financial
    application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程过程中，如果你发现自己反复编写相同的语句，那么将这些语句转换成一个**函数**。函数就像微小的程序，完成一项小任务。例如，你可能编写一个函数来计算销售税，然后在财务应用的许多地方重用该函数。
- en: Like programs, functions usually have inputs and outputs. They are sometimes
    described as black boxes, where you feed in some raw materials at one end and
    a manufactured item emerges at the other. Once created and thoroughly debugged
    and tested, you don’t need to think about how they work.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与程序一样，函数通常有输入和输出。它们有时被描述为黑盒，你在一边输入一些原材料，在另一边就出现了一个制造品。一旦创建并彻底调试和测试，你就不需要考虑它们是如何工作的。
- en: Exploring top-level programs, functions, and namespaces
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索顶级程序、函数和命名空间
- en: In *Chapter 1*, *Hello, C#! Welcome, .NET!*, we learned that since C# 10 and
    .NET 6, the default project template for console apps uses the top-level program
    feature introduced with C# 9.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第一章*，*Hello, C#! 欢迎使用 .NET!*，我们了解到自 C# 10 和 .NET 6 以来，控制台应用的默认项目模板使用了 C# 9
    中引入的顶级程序功能。
- en: Once you start writing functions, it is important to understand how they work
    with the automatically generated `Program` class and its `<Main>$` method.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开始编写函数，了解它们如何与自动生成的 `Program` 类及其 `<Main>$` 方法协同工作就很重要。
- en: 'Let’s explore how the top-level program feature works when you define functions:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索当你定义函数时，顶级程序功能是如何工作的：
- en: 'Use your preferred code editor to create a new solution and project, as defined
    in the following list:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的代码编辑器创建一个新的解决方案和项目，如下列表所示：
- en: '**Project template**: **Console App** / `console`'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目模板**：**控制台应用** / `console`'
- en: '**Project file and folder**: `TopLevelFunctions`'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目文件和文件夹**：`TopLevelFunctions`'
- en: '**Solution file and folder**: `Chapter04`'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案文件和文件夹**：`Chapter04`'
- en: '**Do not use top-level statements**: Cleared'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要使用顶级语句**：已清除'
- en: '**Enable native AOT** (**ahead-of-time**) **publish**: Cleared'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用原生 AOT（提前编译）发布**：已清除'
- en: 'In `Program.cs`, delete the existing statements, define a local function at
    the bottom of the file, and call it, as shown in the following code:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，删除现有的语句，在文件底部定义一个局部函数，并调用它，如下代码所示：
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Good Practice**: Functions do not need to be at the bottom of the file, but
    it is good practice rather than mixing them up with other top-level statements.
    Types, like classes, *must* be declared at the bottom of the `Program.cs` file
    rather than in the middle of the file or you will see the compiler error `CS8803`,
    as shown at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-messages/cs8803](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-messages/cs8803).
    It would be better to define types like classes in a separate file.'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**良好实践**：函数不需要放在文件的底部，但将它们与其他顶级语句混合并不是一个好的实践。类型，如类，*必须*在 `Program.cs` 文件的底部声明，而不是在文件中间，否则你将看到编译器错误
    `CS8803`，如下链接所示：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-messages/cs8803](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-messages/cs8803)。最好在单独的文件中定义类型，如类。'
- en: 'Run the console app and note that the namespace for the `Program` class is
    `null`, as shown in the following output:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用并注意，`Program` 类的命名空间为 `null`，如下所示输出：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What is automatically generated for a local function?
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动为局部函数生成什么？
- en: 'The compiler automatically generates a `Program` class with a `<Main>$` function,
    then moves your statements and function inside the `<Main>$` method, which makes
    the function local, and renames the function, as shown highlighted in the following
    code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器自动生成一个带有`<Main>$`函数的`Program`类，然后将您的语句和函数移动到`<Main>$`方法中，使函数局部化，并重命名函数，如下面高亮显示的代码所示：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For the compiler to know what statements need to go where, you must follow
    some rules:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让编译器知道哪些语句需要放在哪里，您必须遵循一些规则：
- en: Import statements (`using`) must go at the top of the `Program.cs` file.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入语句（`using`）必须放在`Program.cs`文件的顶部。
- en: Statements that will go in the `<Main>$` function can be mixed with functions
    in the middle of the `Program.cs` file. Any functions will become **local functions**
    in the `<Main>$` method.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将要放入`<Main>$`函数中的语句可以与`Program.cs`文件中间的函数混合。任何函数都将成为`<Main>$`方法中的**局部函数**。
- en: The last point is important because local functions have limitations, such as
    they cannot have XML comments to document them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点很重要，因为局部函数有一些限制，例如它们不能有XML注释来文档化它们。
- en: If the contents of the file which is code were the .NET SDK or some other tool
    that generated this code, then the code would need to be in a source code file
    that the compiler would then find in the filesystem and compile it. Because this
    code is generated by the compiler itself, there is no need for a source code file.
    The only way to discover what the compiler does is to use a decompiler on the
    assembly and reverse engineer the original code. You can also throw exceptions
    in the functions and methods to see some of the information, as I showed in *Chapter
    1*, *Hello, C#! Welcome, .NET!*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包含代码的文件是.NET SDK或其他生成此代码的工具，则该代码需要在一个编译器会在文件系统中找到并编译的源代码文件中。因为此代码是由编译器本身生成的，所以不需要源代码文件。发现编译器做了什么唯一的方法是使用反编译器对程序集进行逆向工程以获取原始代码。您也可以在函数和方法中抛出异常以查看一些信息，正如我在*第一章*，*你好，C#!
    欢迎使用，.NET!*中展示的那样。
- en: You are about to see some C# keywords like `static` and `partial`, which will
    be formally introduced in *Chapter 5*, *Building Your Own Types with Object-Oriented
    Programming*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一些C#关键字，如`static`和`partial`，这些将在*第五章*，*使用面向对象编程构建自己的类型*中正式介绍。
- en: Defining a partial Program class with a static function
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义具有静态函数的`partial Program`类
- en: 'A better approach is to write any functions in a separate file and define them
    as `static` members of the `Program` class:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是，将任何函数写在单独的文件中，并将它们定义为`Program`类的`static`成员：
- en: Add a new class file named `Program.Functions.cs`. The name of this file does
    not actually matter but using this naming convention is sensible. You could name
    the file `Gibberish.cs` and it would have the same behavior.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Program.Functions.cs`的新类文件。这个文件名实际上并不重要，但使用这种命名约定是合理的。您可以将文件命名为`Gibberish.cs`，它会有相同的行为。
- en: 'In `Program.Functions.cs`, delete any existing statements and then add statements
    to define a `partial Program` class. Cut and paste the `WhatsMyNamespace` function
    to move it from `Program.cs` into `Program.Functions.cs`, and then add the `static`
    keyword to the function, as shown highlighted in the following code:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.Functions.cs`中，删除任何现有语句，然后添加语句来定义一个`partial Program`类。将`WhatsMyNamespace`函数剪切并粘贴到`Program.cs`中，然后将其移动到`Program.Functions.cs`中，并给函数添加`static`关键字，如下面高亮显示的代码所示：
- en: '[PRE3]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In `Program.cs`, confirm that its entire content is now just three statements,
    as shown in the following code:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，确认其全部内容现在只是三条语句，如下面代码所示：
- en: '[PRE4]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Run the console app and note that it has the same behavior as before.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序，并注意它的行为与之前相同。
- en: What is automatically generated for a static function?
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动为静态函数生成什么？
- en: 'When you use a separate file to define a `partial Program` class with `static`
    functions, the compiler defines a `Program` class with a `<Main>$` function and
    merges your function as a member of the `Program` class, as shown in the following
    highlighted code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用单独的文件来定义具有`static`函数的`partial Program`类时，编译器会定义一个带有`<Main>$`函数的`Program`类，并将您的函数作为`Program`类的一个成员合并，如下面高亮显示的代码所示：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Solution Explorer** shows that your `Program.Functions.cs` class file merges
    its `partial Program` with the auto-generated `partial Program` class, as shown
    in *Figure 4.1*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案资源管理器**显示，您的`Program.Functions.cs`类文件将其`partial Program`与自动生成的`partial
    Program`类合并，如图*4.1*所示：'
- en: '![](img/B22322_04_01.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_04_01.png)'
- en: 'Figure 4.1: Solution Explorer showing the merged partial Program class'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：解决方案资源管理器显示合并的 `partial Program` 类
- en: '**Good Practice**: Create any functions that you will call in `Program.cs`
    in a separate file and manually define them inside a `partial Program` class.
    This will merge them into the automatically generated `Program` class *at the
    same level* as the `<Main>$` method, instead of as local functions *inside* the
    `<Main>$` method.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：在 `Program.cs` 中将要调用的任何函数创建在单独的文件中，并在 `partial Program` 类中手动定义它们。这将使它们与自动生成的
    `Program` 类在 `<Main>$` 方法的同一级别合并，而不是作为 `<Main>$` 方法内部的本地函数。'
- en: It is important to note the lack of namespace declarations. Both the automatically
    generated `Program` class and the explicitly defined `Program` class are in the
    default `null` namespace.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意缺少命名空间声明。自动生成的 `Program` 类和显式定义的 `Program` 类都在默认的 `null` 命名空间中。
- en: '**Warning!** Do not define a namespace for your `partial Program` class. If
    you do, it will be in a different namespace and therefore will not merge with
    the auto-generated `partial Program` class.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**！不要为你的 `partial Program` 类定义命名空间。如果你这样做，它将位于不同的命名空间中，因此不会与自动生成的 `partial
    Program` 类合并。'
- en: Optionally, all the `static` methods in the `Program` class could be explicitly
    declared as `private` but this is the default anyway. Since all the functions
    will be called within the `Program` class itself, the access modifier is not important.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，可以将 `Program` 类中的所有 `static` 方法显式声明为 `private`，但这已经是默认设置。由于所有函数都将在本 `Program`
    类内部调用，因此访问修饰符并不重要。
- en: Times table example
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 乘法表示例
- en: 'Let’s say that you want to help your child learn their times tables, so you
    want to make it easy to generate a times table for a number, such as the 7 times
    table:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想帮助你的孩子学习乘法表，因此你想使其容易生成一个数字的乘法表，例如7的乘法表：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Most times tables have 10, 12, or 20 rows, depending on how advanced the child
    is.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数乘法表都有10、12或20行，这取决于孩子的学习程度。
- en: 'You learned about the `for` statement earlier in this book, so you know that
    it can be used to generate repeated lines of output when there is a regular pattern,
    such as a 7 times table with 12 rows, as shown in the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章中已经学习了 `for` 语句，所以你知道它可以在存在常规模式时用于生成重复的输出行，例如12行的7乘法表，如下所示：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: However, instead of always outputting the 7 times table with 12 rows, we want
    to make this more flexible so it can output times tables of any size for any number.
    We can do this by creating a function.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不想总是输出12行的7乘法表，我们希望使其更加灵活，以便可以输出任何大小和任何数字的乘法表。我们可以通过创建一个函数来实现这一点。
- en: 'Let’s explore functions by creating one to output any times table for numbers
    0 to 255 of any size up to 255 rows (but it defaults to 12 rows):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个函数来探索函数，该函数可以输出任何大小（最多255行，但默认为12行）的0到255的任意数字的乘法表：
- en: 'Use your preferred code editor to create a new project, as defined in the following
    list:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的代码编辑器创建一个新项目，如下所示：
- en: 'Project template: **Console App** / `console`'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console`
- en: 'Project file and folder: `WritingFunctions`'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`WritingFunctions`
- en: 'Solution file and folder: `Chapter04`'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter04`
- en: In Visual Studio, set the startup project for the solution to the current selection.
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，将解决方案的启动项目设置为当前选择。
- en: 'In `WritingFunctions.csproj`, after the `<PropertyGroup>` section, add a new
    `<ItemGroup>` section to statically import `System.Console` for all C# files using
    the implicit usings .NET SDK feature, as shown in the following markup:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `WritingFunctions.csproj` 中，在 `<PropertyGroup>` 部分之后，添加一个新的 `<ItemGroup>`
    部分以静态导入 `System.Console`，为所有使用隐式使用 .NET SDK 功能的 C# 文件，如下所示：
- en: '[PRE8]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Add a new class file to the project named `Program.Functions.cs`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个名为 `Program.Functions.cs` 的新类文件。
- en: 'In `Program.Functions.cs`, replace any existing code with new statements to
    define a function named `TimesTable` in the `partial` `Program` class, as shown
    in the following code:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Functions.cs` 中，用以下代码替换任何现有的代码，以在 `partial Program` 类中定义一个名为 `TimesTable`
    的函数，如下所示：
- en: '[PRE9]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code, note the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，请注意以下内容：
- en: '`TimesTable` must have a `byte` value passed to it as a parameter named `number`.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimesTable` 必须有一个名为 `number` 的 `byte` 值作为参数传递。'
- en: '`TimesTable` can optionally have a `byte` value passed to it as a parameter
    named `size`. If a value is not passed, it defaults to `12`.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimesTable` 可选地可以有一个名为 `size` 的 `byte` 值作为参数传递。如果没有传递值，则默认为 `12`。'
- en: '`TimesTable` is a `static` method because it will be called by the `static`
    method `<Main>$`.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimesTable`是一个`static`方法，因为它将由`static`方法`<Main>$`调用。'
- en: '`TimesTable` does not return a value to the caller, so it is declared with
    the `void` keyword before its name.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimesTable`不向调用者返回值，因此它使用`void`关键字在名称之前声明。'
- en: '`TimesTable` uses a `for` statement to output the times table for the `number`
    passed to it with its number of rows equal to `size`.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimesTable`使用`for`语句输出传递给它的`number`的乘法表，其行数等于`size`。'
- en: 'In `Program.cs`, delete the existing statements, and then call the function.
    Pass in a `byte` value for the `number` parameter, for example, `7`, as shown
    in the following code:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有的语句，然后调用该函数。为`number`参数传递一个`byte`值，例如`7`，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the code and then view the result, as shown in the following output:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE11]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Set the `size` parameter to `20`, as shown in the following code:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`size`参数设置为`20`，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Run the console app and confirm that the times table now has 20 rows.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序并确认现在的时间表有20行。
- en: '**Good Practice**: If a function has one or more parameters where just passing
    the values may not provide enough meaning, then you can optionally specify the
    name of the parameter as well as its value, as shown in the following code: `TimesTable(number:
    7, size: 10)`.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：如果一个函数有一个或多个参数，仅传递值可能不足以提供足够的意义，那么你可以选择性地指定参数的名称以及其值，如下面的代码所示：`TimesTable(number:
    7, size: 10)`。'
- en: Change the number passed into the `TimesTable` function to other `byte` values
    between `0` and `255` and confirm that the output times tables are correct.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将传递给`TimesTable`函数的数字更改为`0`到`255`之间的其他`byte`值，并确认输出的乘法表是正确的。
- en: 'Note that if you try to pass a non-`byte` number, for example, an `int`, `double`,
    or `string`, an error is returned, as shown in the following output:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，如果你尝试传递一个非`byte`的数字，例如`int`、`double`或`string`，将会返回一个错误，如下面的输出所示：
- en: '[PRE13]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A brief aside about arguments and parameters
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于参数和参数的简要说明
- en: In daily usage, most developers will use the terms **argument** and **parameter**
    interchangeably. Strictly speaking, the two terms have specific and subtly different
    meanings. But just like a person can be both a parent and a doctor, the two terms
    often apply to the same thing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常使用中，大多数开发者会将术语**参数**和**参数**互换使用。严格来说，这两个术语有具体和细微的区别。但就像一个人可以是父母和医生一样，这两个术语通常适用于同一事物。
- en: 'A *parameter* is a variable in a function definition. For example, `startDate`
    is a parameter of the `Hire` function, as shown in the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*参数*是函数定义中的一个变量。例如，`startDate`是`Hire`函数的参数，如下面的代码所示：'
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When a method is called, an *argument* is the data you pass into the method’s
    parameters. For example, `when` is a variable passed as an argument to the `Hire`
    function, as shown in the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用一个方法时，*参数*是你传递给方法参数的数据。例如，`when`是一个作为参数传递给`Hire`函数的变量，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You might prefer to specify the parameter name when passing the argument, as
    shown in the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能更喜欢在传递参数时指定参数名称，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When talking about the call to the `Hire` function, `startDate` is the parameter,
    and `when` is the argument.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈论对`Hire`函数的调用时，`startDate`是参数，而`when`是参数。
- en: 'If you read the official Microsoft documentation, they use the phrases **named
    and optional arguments** and **named and optional parameters** interchangeably,
    as shown at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读官方的Microsoft文档，他们会交替使用**命名和可选参数**和**命名和可选参数**这两个短语，如下面的链接所示：[https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments)。
- en: 'It gets complicated because a single object can act as both a parameter and
    an argument, depending on the context. For example, within the `Hire` function
    implementation, the `startDate` parameter could be passed as an argument to another
    function like `SaveToDatabase`, as shown in the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这变得复杂，因为单个对象可以根据上下文同时作为参数和参数。例如，在`Hire`函数的实现中，`startDate`参数可以作为参数传递给另一个函数，如`SaveToDatabase`，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Naming things is one of the hardest parts of computing. A classic example is
    the parameter to the most important function in C#, `Main`. It defines a parameter
    named `args`, short for arguments, as shown in the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 命名事物是计算中最困难的部分之一。一个经典的例子是 C# 中最重要的函数 `Main` 的参数。它定义了一个名为 `args` 的参数，代表参数，如下所示：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To summarize, parameters define inputs to a function; arguments are passed to
    a function when calling the function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，参数定义了函数的输入；当调用函数时，将参数传递给函数。
- en: '**Good Practice**: Try to use the correct term depending on the context, but
    do not get pedantic with other developers if they “misuse” a term. I must have
    used the terms **parameter** and **argument** thousands of times in this book.
    I’m sure some of those times I’ve been imprecise. Please do not @ me about it.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：根据上下文尽量使用正确的术语，但如果其他开发者“误用”术语，不要过于拘泥。我在这本书中可能已经使用了成千上万次的“参数”和“参数”这两个术语。我确信有些时候我可能不够精确。请不要因此@我。'
- en: Writing a function that returns a value
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写返回值的函数
- en: The previous function performed actions (looping and writing to the console),
    but it did not return a value. Let’s say that you need to calculate sales or **value-added
    tax** (**VAT**). In Europe, VAT rates can range from 8% in Switzerland to 27%
    in Hungary. In the **United States** (**US**), state sales taxes can range from
    0% in Oregon to 8.25% in California.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个函数执行了操作（循环和写入控制台），但没有返回值。假设你需要计算销售额或**增值税**（**VAT**）。在欧洲，增值税率可以从瑞士的 8% 到匈牙利的
    27% 不等。在美国（**US**），州销售税率可以从俄勒冈州的 0% 到加利福尼亚州的 8.25% 不等。
- en: Tax rates change all the time, and they vary based on many factors. The values
    used in this example do not need to be accurate.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 税率随时变化，并且根据许多因素而有所不同。本例中使用的值不需要非常准确。
- en: 'Let’s implement a function to calculate taxes in various regions around the
    world:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个用于计算世界各地税收的函数：
- en: 'In `Program.Functions.cs`, in the `Program` class, write a function named `CalculateTax`,
    as shown in the following code:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Functions.cs` 文件中，在 `Program` 类中，编写一个名为 `CalculateTax` 的函数，如下所示：
- en: '[PRE19]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, note the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，请注意以下内容：
- en: '`CalculateTax` has two inputs: a parameter named `amount`, which will be the
    amount of money spent, and a parameter named `twoLetterRegionCode`, which will
    be the region where the amount is spent.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CalculateTax` 有两个输入：一个名为 `amount` 的参数，它将是花费的金额，以及一个名为 `twoLetterRegionCode`
    的参数，它将是花费的区域。'
- en: '`CalculateTax` will perform a calculation using a `switch` expression and then
    return the sales tax or VAT owed on the amount as a `decimal` value; so, before
    the name of the function, we have declared the data type of the return value to
    be `decimal`.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CalculateTax` 将使用 `switch` 表达式执行计算，然后以 `decimal` 类型的值返回应缴纳的销售额税或增值税；因此，在函数名称之前，我们已声明返回值的类型为
    `decimal`。'
- en: 'At the top of `Program.Functions.cs`, import the namespace to work with cultures,
    as shown in the following code:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Functions.cs` 文件的顶部，导入用于处理文化的命名空间，如下所示：
- en: '[PRE20]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In `Program.Functions.cs`, in the `Program` class, write a function named `ConfigureConsole`,
    as shown in the following code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Functions.cs` 文件中，在 `Program` 类中，编写一个名为 `ConfigureConsole` 的函数，如下所示：
- en: '[PRE21]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This function enables UTF-8 encoding for the console output. This is necessary
    to output some special symbols like the Euro currency symbol. This function also
    controls the current culture used to format dates, times, and currency values.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数为控制台输出启用 UTF-8 编码。这是输出一些特殊符号（如欧元货币符号）所必需的。此函数还控制用于格式化日期、时间和货币值的当前文化。
- en: 'In `Program.cs`, comment out any `TimesTable` method calls, and then call the
    `ConfigureConsole` method and the `CalculateTax` method, passing values for the
    amount, such as `149`, and a valid region code, such as `FR`, as shown in the
    following code:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，注释掉任何 `TimesTable` 方法调用，然后调用 `ConfigureConsole` 方法以及 `CalculateTax`
    方法，传递金额值，例如 `149`，以及有效的区域代码，例如 `FR`，如下所示：
- en: '[PRE22]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the code, view the result, and note that it uses the US English culture,
    meaning US dollars for the currency, as shown in the following output:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意它使用的是美国英语文化，这意味着货币为美元，如下所示：
- en: '[PRE23]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In `Program.cs`, change the `ConfigureConsole` method to use your local computer
    culture, as shown in the following code:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，将 `ConfigureConsole` 方法更改为使用您本地的计算机文化，如下所示：
- en: '[PRE24]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the code, view the result, and note that the currency should now show your
    local currency. For example, for me in the UK, I would see `£29.80`, as shown
    in the following output:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意货币现在应显示为您的本地货币。例如，对我来说在英国，我会看到 `£29.80`，如下所示输出：
- en: '[PRE25]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In `Program.cs`, change the `ConfigureConsole` method to use the French culture,
    as shown in the following code:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，将 `ConfigureConsole` 方法更改为使用法语文化，如下所示代码：
- en: '[PRE26]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the code, view the result, and note that the currency should now show Euros,
    as used in France, as shown in the following output:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意货币现在应显示为欧元，这是在法国使用的，如下所示输出：
- en: '[PRE27]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Can you think of any problems with the `CalculateTax` function as written? What
    would happen if the user entered a code such as `fr` or `UK`? How could you rewrite
    the function to improve it? Would using a `switch` *statement* instead of a `switch`
    *expression* be clearer?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到 `CalculateTax` 函数编写中的任何问题吗？如果用户输入了如 `fr` 或 `UK` 这样的代码会发生什么？你如何重写该函数以改进它？使用
    `switch` *语句* 而不是 `switch` *表达式* 会更清晰吗？
- en: Converting numbers from cardinal to ordinal
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数字从基数转换为序数
- en: 'Numbers that are used to count are called **cardinal** numbers, for example,
    1, 2, and 3, whereas numbers used to order are **ordinal** numbers, for example,
    1st, 2nd, and 3rd. Let’s create a function to convert cardinals to ordinals:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 用于计数的数字称为 **基数**，例如，1、2 和 3，而用于排序的数字称为 **序数**，例如，1st、2nd 和 3rd。让我们创建一个函数将基数转换为序数：
- en: 'In `Program.Functions.cs`, write a function named `CardinalToOrdinal` that
    converts a cardinal `uint` value into an ordinal `string` value; for example,
    it converts the `uint` value of `1` into the `string` value `"1st"`, the `uint`
    value of `2` into the `string` value of `"2nd"`, and so on, as shown in the following
    code:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Functions.cs` 中，编写一个名为 `CardinalToOrdinal` 的函数，该函数将基数 `uint` 值转换为序数
    `string` 值；例如，它将 `uint` 值 `1` 转换为字符串值 `"1st"`，`uint` 值 `2` 转换为字符串值 `"2nd"`，依此类推，如下所示代码：
- en: '[PRE28]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'From the preceding code, note the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，注意以下内容：
- en: '`CardinalToOrdinal` has one input, a parameter of the `uint` type named `number`,
    because we do not want to allow negative numbers, and one output: a return value
    of the `string` type.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CardinalToOrdinal` 有一个输入，一个名为 `number` 的 `uint` 类型参数，因为我们不希望允许负数，并且有一个输出：返回
    `string` 类型的值。'
- en: A `switch` *statement* is used to handle the special cases of `11`, `12`, and
    `13`.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `switch` *语句* 处理 `11`、`12` 和 `13` 的特殊情况。
- en: 'A `switch` *expression* then handles all other cases: if the last digit is
    `1`, then use `st` as the suffix; if the last digit is `2`, then use `nd` as the
    suffix; if the last digit is `3`, then use `rd` as the suffix; and if the last
    digit is anything else, then use `th` as the suffix.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，使用 `switch` *表达式* 处理所有其他情况：如果最后一位数字是 `1`，则使用 `st` 作为后缀；如果最后一位数字是 `2`，则使用
    `nd` 作为后缀；如果最后一位数字是 `3`，则使用 `rd` 作为后缀；如果最后一位数字是其他任何数字，则使用 `th` 作为后缀。
- en: 'In `Program.Functions.cs`, write a function named `RunCardinalToOrdinal` that
    uses a `for` statement to loop from 1 to 150, calling the `CardinalToOrdinal`
    function for each number and writing the returned `string` to the console, separated
    by a space character, as shown in the following code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Functions.cs` 中，编写一个名为 `RunCardinalToOrdinal` 的函数，该函数使用 `for` 循环从
    1 到 150，对每个数字调用 `CardinalToOrdinal` 函数，并将返回的 `string` 写入控制台，用空格字符分隔，如下所示代码：
- en: '[PRE29]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In `Program.cs`, comment out the `CalculateTax` statements and call the `RunCardinalToOrdinal`
    method, as shown in the following code:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，注释掉 `CalculateTax` 语句并调用 `RunCardinalToOrdinal` 方法，如下所示代码：
- en: '[PRE30]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Run the console app and view the results, as shown in the following output:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序并查看结果，如下所示输出：
- en: '[PRE31]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the `RunCardinalToOrdinal` function, change the maximum number to `1500`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RunCardinalToOrdinal` 函数中，将最大数更改为 `1500`。
- en: 'Run the console app and view the results, as shown in the following output:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序并查看结果，如下所示输出：
- en: '[PRE32]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Calculating factorials with recursion
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用递归计算阶乘
- en: 'The factorial of 5 is 120 because factorials are calculated by multiplying
    the starting number by one less than itself, and then by one less again, and so
    on until the number is reduced to 1\. An example can be seen here: 5 x 4 x 3 x
    2 x 1 = 120.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 5 的阶乘是 120，因为阶乘是通过将起始数字乘以比它小一的数字，然后再乘以再小一的数字，依此类推，直到数字减少到 1 来计算的。一个例子如下：5 x
    4 x 3 x 2 x 1 = 120。
- en: 'The factorial function is defined for non-negative integers only, i.e., for
    0, 1, 2, 3, and so on, and it is defined as:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 阶乘函数仅对非负整数定义，即对 0、1、2、3 等等，其定义为：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We could leave it to the compiler to reject negative numbers by declaring the
    input parameter as `uint` as we did for the `CardinalToOrdinal` function, but
    this time, let’s see an alternative way to handle that: throwing an argument exception.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将拒绝负数的任务留给编译器，就像我们在 `CardinalToOrdinal` 函数中所做的那样，将输入参数声明为 `uint`，但这次，让我们看看另一种处理方式：抛出参数异常。
- en: 'Factorials are written like this: `5!`, where the exclamation mark is read
    as “bang,” so `5!` = 120, or *five bang equals one hundred and twenty*. Bang is
    a good term to use in the context of factorials because they increase in size
    very rapidly, just like an explosion.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 阶乘的表示方式为 `5!`，其中感叹号读作“bang”，所以 `5!` = 120，或者说 *五bang等于一百二十*。在阶乘的上下文中，“bang”是一个很好的术语，因为它们增长得非常快，就像爆炸一样。
- en: 'We will write a function named `Factorial`; this will calculate the factorial
    for an `int` passed to it as a parameter. We will use a clever technique called
    **recursion**, which refers to a function that calls itself within its implementation,
    either directly or indirectly:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个名为 `Factorial` 的函数；这将计算传递给它的 `int` 参数的阶乘。我们将使用一种称为 **递归** 的巧妙技术，它指的是在其实现中直接或间接调用自身的函数：
- en: 'In `Program.Functions.cs`, write a function named `Factorial`, as shown in
    the following code:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Functions.cs` 文件中，编写一个名为 `Factorial` 的函数，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As before, there are several noteworthy elements in the preceding code, including
    the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，前面的代码中有几个值得注意的元素，包括以下内容：
- en: If the input parameter `number` is negative, `Factorial` throws an exception.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入参数 `number` 是负数，`Factorial` 会抛出异常。
- en: If the input parameter `number` is `0`, `Factorial` returns `1`.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入参数 `number` 是 `0`，`Factorial` 返回 `1`。
- en: If the input parameter `number` is more than `0` (which it will be in all other
    cases), `Factorial` multiplies the number by the result of calling itself and
    passing one less than `number`. This makes the function recursive.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入参数 `number` 大于 `0`（在其他所有情况下都会是这样），`Factorial` 会将数字乘以调用自身并传递 `number` 减一的返回结果。这使得函数是递归的。
- en: '**More Information**: Recursion is clever but it can lead to problems, such
    as a stack overflow due to too many function calls because memory is used to store
    data on every function call, and it eventually uses too much. Iteration is a more
    practical, if less succinct, solution in languages such as C#. You can read more
    about this at the following link: [https://en.wikipedia.org/wiki/Recursion_(computer_science)#Recursion_versus_iteration](https://en.wikipedia.org/wiki/Recursion_(computer_science)#Recursion_versus_iteration).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：递归很巧妙，但它可能会导致问题，例如由于函数调用过多而导致的栈溢出，因为每次函数调用都会使用内存来存储数据，最终会使用太多。在 C#
    等语言中，迭代是一个更实际、但不太简洁的解决方案。您可以在以下链接中了解更多信息：[https://en.wikipedia.org/wiki/Recursion_(computer_science)#Recursion_versus_iteration](https://en.wikipedia.org/wiki/Recursion_(computer_science)#Recursion_versus_iteration)。'
- en: 'In `Program.Functions.cs`, write a function named `RunFactorial` that uses
    a `for` statement to output the factorials of numbers from 1 to 15, calls the
    `Factorial` function inside its loop, and then outputs the result, formatted using
    the code `N0`, which refers to a number format using thousand separators with
    zero decimal places, as shown in the following code:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Functions.cs` 文件中，编写一个名为 `RunFactorial` 的函数，该函数使用 `for` 循环输出从 1 到
    15 的数字的阶乘，在其循环内部调用 `Factorial` 函数，然后输出结果，使用代码 `N0` 格式化，该代码指的是使用千位分隔符且没有小数位的数字格式，如下面的代码所示：
- en: '[PRE35]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Comment out the `RunCardinalToOrdinal` method call and call the `RunFactorial`
    method.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `RunCardinalToOrdinal` 方法的调用注释掉，并调用 `RunFactorial` 方法。
- en: 'Run the project and view the results, as shown in the following partial output:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行项目并查看结果，如下面的部分输出所示：
- en: '[PRE36]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It is not immediately obvious in the previous output, but factorials of 13 and
    higher overflow the `int` type because they are so big. `12!` is 479,001,600,
    which is about half a billion. The maximum positive value that can be stored in
    an `int` variable is about two billion. `13!` is 6,227,020,800, which is about
    six billion, and when stored in a 32-bit integer, it overflows silently without
    showing any problems.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中并不立即明显，但 13 及以上的阶乘会超出 `int` 类型的范围，因为它们非常大。`12!` 是 479,001,600，大约是五亿。可以存储在
    `int` 变量中的最大正数值大约是二十亿。`13!` 是 6,227,020,800，大约是六十亿，当存储在 32 位整数中时，它会静默溢出而不会显示任何问题。
- en: What should you do to get notified when an overflow happens? Of course, we could
    solve the problem for `13!` and `14!` by using a `long` (64-bit integer) instead
    of an `int` (32-bit integer), but we will quickly hit the overflow limit again.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该做什么才能在溢出发生时收到通知？当然，我们可以通过使用 `long`（64位整数）而不是 `int`（32位整数）来解决 `13!` 和 `14!`
    的问题，但我们很快就会再次达到溢出限制。
- en: 'The point of this section is to understand and show you that numbers can overflow,
    and not specifically how to calculate factorials higher than `12!`. Let’s take
    a look:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目的在于理解和展示数字可能会溢出，而不是具体讲解如何计算大于 `12!` 的阶乘。让我们来看一看：
- en: 'Modify the `Factorial` function to check for overflows in the statement that
    calls itself, as shown highlighted in the following code:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `Factorial` 函数，以便在自我调用的语句中检查溢出，如下所示，代码中已突出显示：
- en: '[PRE37]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Modify the `RunFactorial` function to change the starting number to `-2` and
    to handle overflow and other exceptions when calling the `Factorial` function,
    as shown highlighted in the following code:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `RunFactorial` 函数，将起始数字改为 `-2`，并在调用 `Factorial` 函数时处理溢出和其他异常，如下所示，代码中已突出显示：
- en: '[PRE38]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Run the code and view the results, as shown in the following partial output:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示的部分输出：
- en: '[PRE39]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Documenting functions with XML comments
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 XML 注释记录函数
- en: By default, when calling a function such as `CardinalToOrdinal`, code editors
    will show a tooltip with basic information.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当调用 `CardinalToOrdinal` 等函数时，代码编辑器会显示包含基本信息的工具提示。
- en: 'Let’s improve the tooltip by adding extra information:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加额外信息来改进工具提示：
- en: 'If you are using VS Code with the **C#** extension, you should navigate to
    **View** | **Command Palette** | **Preferences: Open Settings (UI)**, and then
    search for `formatOnType` and make sure that it is enabled. C# XML documentation
    comments are a built-in feature of Visual Studio and Rider, so you do not need
    to do anything to use them.'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用带有 **C#** 扩展的 VS Code，你应该导航到 **视图** | **命令面板** | **首选项：打开设置（UI**），然后搜索
    `formatOnType` 并确保它已启用。C# XML 文档注释是 Visual Studio 和 Rider 的内置功能，因此您不需要做任何事情就可以使用它们。
- en: 'On the line above the `CardinalToOrdinal` function, type three forward slashes,
    `///`, and note that they are expanded into an XML comment that recognizes that
    the function has a single parameter named `number`, as shown in the following
    code:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CardinalToOrdinal` 函数上方的一行中，输入三个反斜杠 `///`，并注意它们被扩展为识别函数有一个名为 `number` 的单个参数的
    XML 注释，如下所示，代码中已突出显示：
- en: '[PRE40]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Enter suitable information for the XML documentation comment for the `CardinalToOrdinal`
    function. Add a summary and describe the input parameter and the return value,
    as shown highlighted in the following code:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `CardinalToOrdinal` 函数输入合适的 XML 文档注释信息。添加摘要并描述输入参数和返回值，如下所示，代码中已突出显示：
- en: '[PRE41]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, when calling the function, you will see more details, as shown in *Figure
    4.2*:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当调用函数时，你会看到更多详细信息，如下所示 *图 4.2*：
- en: '![](img/B22322_04_02.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_04_02.png)'
- en: 'Figure 4.2: A tooltip showing the more detailed method signature'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：显示更详细的方法签名的工具提示
- en: 'It is worth emphasizing that this feature is primarily designed to be used
    with a tool that converts the comments into documentation, like Sandcastle, which
    you can read more about at the following link: [https://github.com/EWSoftware/SHFB](https://github.com/EWSoftware/SHFB).
    The tooltips that appear while entering code or hovering over the function name
    are a secondary feature.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 值得强调的是，此功能主要是为了与将注释转换为文档的工具一起使用而设计的，例如 Sandcastle，你可以在以下链接中了解更多信息：[https://github.com/EWSoftware/SHFB](https://github.com/EWSoftware/SHFB)。在输入代码或悬停在函数名称上时出现的工具提示是次要功能。
- en: Local functions do not support XML comments because local functions cannot be
    used outside the member in which they are declared, so it makes no sense to generate
    documentation from them. Sadly, this also means no tooltip, which would still
    be useful, but neither Visual Studio nor VS Code recognizes that.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 局部函数不支持 XML 注释，因为局部函数不能在它们声明的成员之外使用，因此从它们生成文档没有意义。遗憾的是，这也意味着没有工具提示，虽然这仍然很有用，但
    Visual Studio 和 VS Code 都没有识别出来。
- en: '**Good Practice**: Add XML documentation comments to all your functions except
    your local functions.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：除了局部函数外，为所有函数添加 XML 文档注释。'
- en: Using lambdas in function implementations
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在函数实现中使用 lambda 表达式
- en: '**F#** is Microsoft’s strongly typed functional-first programming language
    that, like C#, compiles to **Intermediate Language** (**IL**) to be executed by
    .NET. Functional languages evolved from lambda calculus, a computational system
    based only on functions. The code looks more like mathematical functions than
    steps in a recipe.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**F#** 是微软的强类型函数式编程语言，与 C# 类似，它编译成 **中间语言**（**IL**）以由 .NET 执行。函数式语言起源于 lambda
    演算，这是一种仅基于函数的计算系统。代码看起来更像数学函数，而不是食谱中的步骤。'
- en: 'Some of the important attributes of functional languages are defined in the
    following list:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表中定义了函数式语言的一些重要属性：
- en: '**Modularity**: The same benefit of defining functions in C# applies to functional
    languages. This breaks up a large, complex code base into smaller pieces.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化**：在 C# 中定义函数的相同好处也适用于函数式语言。这将一个大而复杂的代码库分解成更小的部分。'
- en: '**Immutability**: Variables in the C# sense do not exist. Any data value inside
    a function cannot change. Instead, a new data value can be created from an existing
    one. This reduces bugs.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变性**：在 C# 的意义上，变量不存在。函数内部的数据值不能改变。相反，可以从现有数据值创建一个新的数据值。这减少了错误。'
- en: '**Maintainability**: Functional code is cleaner and clearer (for mathematically
    inclined programmers).'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：函数式代码更干净、更清晰（对于数学倾向的程序员来说）。'
- en: Since C# 6, Microsoft has worked to add features to the language to support
    a more functional approach, for example, adding **tuples** and **pattern matching**
    in C# 7, **non-null reference types** in C# 8, and improving pattern matching
    and adding records, that is, potentially **immutable objects**, in C# 9.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 自 C# 6 以来，微软一直在努力添加语言特性以支持更函数式的方法，例如，在 C# 7 中添加 **元组** 和 **模式匹配**，在 C# 8 中添加
    **非空引用类型**，并在 C# 9 中改进模式匹配和添加记录，即潜在的 **不可变对象**。
- en: In C# 6, Microsoft added support for **expression-bodied function members**.
    We will look at an example of this now. In C#, lambdas are the use of the `=>`
    character to indicate a return value from a function.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 6 中，微软添加了对 **表达式主体函数成员** 的支持。我们现在将看看这个例子。在 C# 中，lambda 是使用 `=>` 字符来表示函数的返回值。
- en: 'The **Fibonacci sequence** of numbers always starts with 0 and 1\. Then, the
    rest of the sequence is generated using the rule of adding together the previous
    two numbers, as shown in the following sequence of numbers:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 数字的 **斐波那契数列** 总是以 0 和 1 开始。然后，其余的序列使用将前两个数字相加的规则生成，如下所示数列：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The next term in the sequence would be 34 + 55, which is 89.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 序列的下一个项将是 34 + 55，即 89。
- en: 'We will use the Fibonacci sequence to illustrate the difference between an
    imperative and declarative function implementation:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用斐波那契数列来说明命令式和声明式函数实现之间的区别：
- en: 'In `Program.Functions.cs`, write a function named `FibImperative`, which will
    be written in an imperative style, as shown in the following code:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Functions.cs` 中，编写一个名为 `FibImperative` 的函数，它将以命令式风格编写，如下所示代码：
- en: '[PRE43]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In `Program.Functions.cs`, write a function named `RunFibImperative` that calls
    `FibImperative` inside a `for` statement that loops from 1 to 30, as shown in
    the following code:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Functions.cs` 中，编写一个名为 `RunFibImperative` 的函数，该函数在从 1 到 30 的循环语句中调用
    `FibImperative`，如下所示代码：
- en: '[PRE44]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In `Program.cs`, comment out the other method calls and call the `RunFibImperative`
    method.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，注释掉其他方法调用并调用 `RunFibImperative` 方法。
- en: 'Run the console app and view the results, as shown in the following partial
    output:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序并查看结果，如下所示的部分输出：
- en: '[PRE45]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In `Program.Functions.cs`, write a function named `FibFunctional` written in
    a declarative style, as shown in the following code:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Functions.cs` 中，编写一个名为 `FibFunctional` 的函数，采用声明式风格，如下所示代码：
- en: '[PRE46]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In `Program.Functions.cs`, write a function to call it inside a `for` statement
    that loops from 1 to 30, as shown in the following code:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Functions.cs` 中，编写一个函数，在从 1 到 30 的循环语句中调用它，如下所示代码：
- en: '[PRE47]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In `Program.cs`, comment out the `RunFibImperative` method call and call the
    `RunFibFunctional` method.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，注释掉 `RunFibImperative` 方法调用并调用 `RunFibFunctional` 方法。
- en: Run the code and view the results (which will be the same as before).
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果（将与之前相同）。
- en: Now that you have seen some examples of functions, let’s see how you can fix
    them when they have bugs.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了一些函数的示例，让我们看看当它们有错误时如何修复它们。
- en: Debugging during development
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发期间的调试
- en: In this section, you will learn how to debug problems at development time. You
    must use a code editor that has debugging tools, such as Visual Studio or VS Code.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何在开发时间调试问题。您必须使用具有调试工具的代码编辑器，例如 Visual Studio 或 VS Code。
- en: Creating code with a deliberate bug
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建包含故意错误的代码
- en: 'Let’s explore debugging by creating a console app with a deliberate bug, which
    we will then use the debugger tools in your code editor to track down and fix:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个包含故意错误的控制台应用程序来探索调试，然后我们将使用代码编辑器中的调试工具来追踪并修复：
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `Debugging` to the `Chapter04` solution.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器将一个新的 **Console App** / `console` 项目命名为 `Debugging` 并添加到 `Chapter04`
    解决方案中。
- en: Modify `Debugging.csproj` to statically import `System.Console` for all code
    files.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Debugging.csproj` 修改为静态导入所有代码文件的 `System.Console`。
- en: 'In `Program.cs`, delete any existing statements, and then, at the bottom of
    the file, add a function with a deliberate bug, as shown in the following code:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，删除任何现有的语句，然后在文件底部添加一个包含故意错误的函数，如下所示代码：
- en: '[PRE48]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Above the `Add` function, write statements to declare and set some variables
    and then add them together using the buggy function, as shown in the following
    code:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Add` 函数上方编写语句以声明和设置一些变量，然后使用有错误的函数将它们相加，如下所示代码：
- en: '[PRE49]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Run the console application and view the result, as shown in the following
    output:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序并查看结果，如下所示输出：
- en: '[PRE50]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: But wait, there’s a bug! 4.5 added to 2.5 should be 7, not 11.25!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等，这里有错误！4.5 加上 2.5 应该是 7，而不是 11.25！
- en: We will use the debugging tools to hunt for and squish the bug.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用调试工具来寻找并修复错误。
- en: Setting a breakpoint and starting debugging
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置断点和开始调试
- en: Breakpoints allow us to mark a line of code that we want to pause at to inspect
    the program state and find bugs.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 断点允许我们标记我们想要暂停以检查程序状态和查找错误的代码行。
- en: Using Visual Studio
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Visual Studio
- en: 'Let’s set a breakpoint and then start debugging using Visual Studio:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一个断点，然后使用 Visual Studio 开始调试：
- en: Click in line 1, which is the statement that declares the variable named `a`.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第 1 行点击，这是声明名为 `a` 的变量的语句。
- en: 'Navigate to **Debug** | **Toggle Breakpoint** or press *F9*. A red circle will
    appear in the margin bar on the left-hand side and the statement will be highlighted
    in red to indicate that a breakpoint has been set, as shown in *Figure 4.3*:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **调试** | **切换断点** 或按 *F9*。在左侧边缘栏上会出现一个红色圆圈，并且语句将以红色突出显示以指示已设置断点，如图 *图 4.3*
    所示：
- en: '![](img/B22322_04_03.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_04_03.png)'
- en: 'Figure 4.3: Toggling breakpoints using Visual Studio'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：使用 Visual Studio 切换断点
- en: Breakpoints can be toggled off with the same action. You can also left-click
    in the margin to toggle a breakpoint on and off or right-click a breakpoint to
    see more options, such as delete, disable, or edit conditions, or actions for
    an existing breakpoint.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 断点可以通过相同的操作关闭。您还可以在边缘处左键单击以切换断点的开/关，或右键单击断点以查看更多选项，例如删除、禁用或编辑条件或现有断点的操作。
- en: 'Navigate to **Debug** | **Start Debugging** or press *F5*. Visual Studio starts
    the console application and then pauses when it hits the breakpoint. This is known
    as *break mode*. Extra windows titled **Locals** (showing the current values of
    local variables), **Watch 1** (showing any watch expressions you have defined),
    **Call Stack**, **Exception Settings**, and **Immediate Window** may appear. The
    **Debugging** toolbar appears. The line that will be executed next is highlighted
    in yellow, and a yellow arrow points at the line from the margin bar, as shown
    in *Figure 4.4*:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **调试** | **开始调试** 或按 *F5*。Visual Studio 启动控制台应用程序，然后在遇到断点时暂停。这被称为 *断点模式*。可能会出现标题为
    **局部变量**（显示局部变量的当前值）、**监视 1**（显示您定义的任何监视表达式）、**调用堆栈**、**异常设置** 和 **立即窗口** 的额外窗口。将出现
    **调试** 工具栏。将要执行的下一行以黄色突出显示，并且从边缘栏指向该行的黄色箭头，如图 *图 4.4* 所示：
- en: '![](img/B22322_04_04.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_04_04.png)'
- en: 'Figure 4.4: Break mode in Visual Studio'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：Visual Studio 中的断点模式
- en: If you do not want to see how to use VS Code to start debugging, then you can
    skip the *Using VS Code* section and continue to the section titled *Navigating
    with the debugging toolbar*.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想了解如何使用 VS Code 开始调试，则可以跳过 *使用 VS Code* 部分，并继续到标题为 *使用调试工具栏导航* 的部分。
- en: Using VS Code
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 VS Code
- en: 'Let’s set a breakpoint and then start debugging using VS Code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一个断点，然后使用 VS Code 开始调试：
- en: Click in line 1, which is the statement that declares the variable named `a`.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第 1 行点击，这是声明名为 `a` 的变量的语句。
- en: Navigate to **Run** | **Toggle Breakpoint** or press *F9*. A red circle will
    appear in the margin bar on the left-hand side to indicate that a breakpoint has
    been set.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**运行** | **切换断点**或按*F9*。在左侧边栏上会出现一个红色圆圈，以指示已设置断点。
- en: Breakpoints can be toggled off with the same action. You can also left-click
    in the margin to toggle a breakpoint on and off; right-click to see more options,
    such as remove, edit, or disable an existing breakpoint; or add a breakpoint,
    conditional breakpoint, or Logpoint when a breakpoint does not yet exist. **Logpoints**,
    also known as **Tracepoints**, indicate that you want to record some information
    without having to stop executing the code at that point.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 断点可以通过相同的操作切换关闭。您还可以在边栏中左键单击以切换断点的开启和关闭；右键单击以查看更多选项，例如删除、编辑或禁用现有断点；或者在没有断点时添加断点、条件断点或Logpoint。**Logpoints**，也称为**Tracepoints**，表示您希望在代码执行到该点时记录一些信息，而无需在该点停止执行代码。
- en: Navigate to **View** | **Run**, or in the left navigation bar, you can click
    the **Run and Debug** icon (the triangle “play” button and “bug”) or press *Ctrl*
    + *Shift* + *D* (on Windows).
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**视图** | **运行**，或在左侧导航栏中，您可以单击**运行和调试**图标（三角形“播放”按钮和“虫子”）或按*Ctrl* + *Shift*
    + *D*（在Windows上）。
- en: 'At the top of the **RUN AND DEBUG** window, click the **Run and Debug** button,
    and then select the **Debugging** project, as shown in *Figure 4.5*:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**RUN AND DEBUG**窗口的顶部，单击**运行和调试**按钮，然后选择**调试**项目，如图*图4.5*所示：
- en: '![](img/B22322_04_05.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_04_05.png)'
- en: 'Figure 4.5: Selecting the project to debug using VS Code'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：使用VS Code选择要调试的项目
- en: If you are first prompted to choose a debugger, select **C#**, not .NET 5+ or
    .NET Core.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您首先被提示选择调试器，请选择**C#**，而不是.NET 5+或.NET Core。
- en: 'VS Code starts the console app and then pauses when it hits the breakpoint.
    This is known as **break mode**. The line that will be executed next is highlighted
    in yellow, and a yellow block points at the line from the margin bar, as shown
    in *Figure 4.6*:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: VS Code启动控制台应用程序，并在遇到断点时暂停。这被称为**断点模式**。即将执行的行将以黄色突出显示，并且从边栏栏中指向该行的黄色方块，如图*图4.6*所示：
- en: '![](img/B22322_04_06.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_04_06.png)'
- en: 'Figure 4.6: Break mode in VS Code'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：VS Code中的断点模式
- en: Navigating with the debugging toolbar
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用调试工具栏进行导航
- en: Visual Studio has two debug-related buttons in its **Standard** toolbar to start
    or continue debugging and to hot reload changes to the running code, and a separate
    **Debug** toolbar for the rest of the tools.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio在其**标准**工具栏中有两个与调试相关的按钮，用于启动或继续调试以及快速重新加载运行代码的更改，还有一个单独的**调试**工具栏用于其他工具。
- en: VS Code shows a floating toolbar with buttons to make it easy to access debugging
    features.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code显示一个浮动工具栏，其中包含按钮，便于访问调试功能。
- en: 'Both are shown in *Figure 4.7*:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 两者均在*图4.7*中展示：
- en: '![](img/B22322_04_07.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_04_07.png)'
- en: 'Figure 4.7: Debugging toolbars in Visual Studio and VS Code'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：Visual Studio和VS Code中的调试工具栏
- en: 'The following list describes the most common buttons in the toolbars:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表描述了工具栏中最常见的按钮：
- en: '**Start**/**Continue**/*F5*: This button is context-sensitive. It will either
    start running a project or continue running the project from the current position
    until it ends or hits a breakpoint.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始**/**继续**/*F5*：此按钮是上下文相关的。它将启动运行项目或从当前位置继续运行项目，直到结束或遇到断点。'
- en: '**Hot Reload**: This button will reload compiled code changes without needing
    to restart the app.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**热重载**：此按钮将在无需重新启动应用程序的情况下重新加载编译的代码更改。'
- en: '**Break All**: This button will break into the next available line of code
    in a running app.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断点全部**：此按钮将在运行的应用程序中进入下一个可用的代码行。'
- en: '**Stop Debugging**/**Stop**/*Shift* + *F5* (red square): This button will stop
    the debugging session.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止调试**/**停止**/*Shift* + *F5*（红色方块）：此按钮将停止调试会话。'
- en: '**Restart**/*Ctrl* or *Cmd* + *Shift* + *F5* (circular arrow): This button
    will stop and then immediately restart the program with the debugger attached
    again.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重启**/*Ctrl* 或 *Cmd* + *Shift* + *F5*（圆形箭头）：此按钮将停止程序，然后立即重新启动程序，并再次附加调试器。'
- en: '**Show Next Statement**: This button will move the current cursor to the next
    statement that will execute.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示下一语句**：此按钮将当前光标移动到即将执行的下一语句。'
- en: '**Step Into**/*F11*, **Step Over**/*F10*, and **Step Out**/*Shift* + *F11*
    (blue arrows over dots): These buttons step through the code statements in various
    ways, as you will see in a moment.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进入**/*F11*，**跳过**/*F10*，和**跳出**/*Shift* + *F11*（蓝色箭头覆盖点）：这些按钮以各种方式逐步执行代码语句，您将在稍后看到。'
- en: '**Show Threads in Source**: This button allows you to examine and work with
    threads in the application that you’re debugging.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示源中的线程**：此按钮允许你检查和操作你正在调试的应用程序中的线程。'
- en: Debugging windows
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试窗口
- en: While debugging, both Visual Studio and VS Code show extra windows that allow
    you to monitor useful information, such as variables, while you step through your
    code.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试过程中，Visual Studio和VS Code都会显示额外的窗口，允许你在执行代码时监控有用的信息，例如变量。
- en: 'The most useful windows are described in the following list:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表中描述了最有用的窗口：
- en: '**VARIABLES**, including **Locals**, which shows the name, value, and type
    of any local variables automatically. Keep an eye on this window while you step
    through your code.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量**，包括**局部变量**，显示任何局部变量的名称、值和类型。在执行代码时，请注意此窗口。'
- en: '**WATCH**, or **Watch 1**, which shows the value of variables and expressions
    that you manually enter.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WATCH**，或**Watch 1**，显示你手动输入的变量和表达式的值。'
- en: '**CALL STACK**, which shows the stack of function calls.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用堆栈**，显示函数调用的堆栈。'
- en: '**BREAKPOINTS**, which shows all your breakpoints and allows finer control
    over them.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断点**，显示所有断点并允许更精细地控制它们。'
- en: 'When in break mode, there is also a useful window at the bottom of the edit
    area:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在断点模式下，编辑区域底部还有一个有用的窗口：
- en: '**DEBUG CONSOLE**, or **Immediate Window**, enables live interaction with your
    code. You can interrogate the program state, for example, by entering the name
    of a variable. For example, you can ask a question such as “What is 1+2?” by typing
    `1+2` and pressing *Enter*.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试控制台**，或**即时窗口**，允许你与代码进行实时交互。例如，你可以通过输入变量的名称来查询程序状态。例如，你可以通过输入`1+2`并按*Enter*来询问“1+2等于多少？”。'
- en: Stepping through code
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逐行执行代码
- en: 'Let’s explore some ways to step through the code using either Visual Studio
    or VS Code:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一些使用Visual Studio或VS Code逐行执行代码的方法：
- en: The menu commands for debugging are on the **Debug** menu in Visual Studio or
    the **Run** menu in VS Code and Rider.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 调试的菜单命令位于Visual Studio的**调试**菜单或VS Code和Rider的**运行**菜单中。
- en: Navigate to **Run** or **Debug** | **Step Into**, click on the **Step Into**
    button in the toolbar, or press *F11*. The yellow highlight steps forward one
    line.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**运行**或**调试** | **进入**，点击工具栏中的**进入**按钮，或按*F11*。黄色高亮显示向前移动一行。
- en: Navigate to **Run** or **Debug** | **Step Over**, click on the **Step Over**
    button in the toolbar, or press *F10*. The yellow highlight steps forward one
    line. At the moment, you can see that there is no difference between using **Step
    Into** or **Step Over** because we are executing single statements.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**运行**或**调试** | **进入**，点击工具栏中的**进入**按钮，或按*F11*。黄色高亮显示向前移动一行。目前，你可以看到使用**进入**或**跳过**没有区别，因为我们正在执行单行语句。
- en: You should now be on the line that calls the `Add` method.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在应该位于调用`Add`方法的行上。
- en: The difference between **Step Into** and **Step Over** can be seen when you
    are about to execute a method call.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当你即将执行方法调用时，可以看到**进入**和**跳过**之间的区别。
- en: If you click on **Step Into**, the debugger steps *into* the method so that
    you can step through every line in that method.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击**进入**，调试器将进入方法，以便你可以逐行执行该方法中的每一行。
- en: If you click on **Step Over**, the whole method is executed in one go; it does
    not skip over the method without executing it.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击**跳过**，整个方法将一次性执行；它不会跳过方法而不执行。
- en: Click on **Step Into** to step inside the `Add` method.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**进入**以进入`Add`方法。
- en: Hover your mouse pointer over the `a` or `b` parameters in the code editing
    window and note that a tooltip appears showing their current value.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标指针悬停在代码编辑窗口中的`a`或`b`参数上，并注意会弹出一个显示它们当前值的工具提示。
- en: Select the expression `a * b`, right-click the expression, and select **Add
    to Watch** or **Add Watch**. The expression is added to the **WATCH** or **Watch
    1** window, showing that this operator is multiplying `a` by `b` to give the result
    `11.25`.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择表达式`a * b`，右键单击表达式，并选择**添加到监视**或**添加监视**。表达式被添加到**WATCH**或**Watch 1**窗口中，显示该运算符正在将`a`乘以`b`得到结果`11.25`。
- en: In the **WATCH** or **Watch 1** window, right-click the expression and choose
    **Remove Expression** or **Delete Watch**.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**WATCH**或**Watch 1**窗口中，右键单击表达式并选择**移除表达式**或**删除监视**。
- en: Fix the bug by changing `*` to `+` in the `Add` function.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将`Add`函数中的`*`改为`+`来修复错误。
- en: Restart debugging by clicking the circular arrow **Restart** button or pressing
    *Ctrl* or *Cmd* + *Shift* + *F5*.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击圆形箭头的**重启**按钮或按*Ctrl*或*Cmd* + *Shift* + *F5*来重启调试。
- en: Step over the function, take a minute to note how it now calculates correctly,
    and click the **Continue** button or press *F5*.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳过函数，花一分钟注意它现在是如何正确计算的，然后点击**继续**按钮或按*F5*。
- en: 'With VS Code, note that when writing to the console during debugging, the output
    appears in the **DEBUG CONSOLE** window instead of the **TERMINAL** window, as
    shown in *Figure 4.8*:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用VS Code时，注意在调试期间写入控制台时，输出出现在**DEBUG CONSOLE**窗口而不是**TERMINAL**窗口，如图*4.8*所示：
- en: '![](img/B22322_04_08.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22322_04_08.png)'
- en: 'Figure 4.8: Writing to the DEBUG CONSOLE during debugging'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：调试期间写入DEBUG CONSOLE
- en: Using the VS Code integrated terminal during debugging
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用VS Code集成终端进行调试
- en: By default, the console is set to use the internal **DEBUG CONSOLE** during
    debugging, which does not allow interactions like entering text from the `ReadLine`
    method.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，控制台在调试期间设置为使用内部**DEBUG CONSOLE**，这不允许像从`ReadLine`方法中输入文本这样的交互。
- en: 'To improve the experience, we can change the setting to use the integrated
    terminal instead. First, let’s modify the code to require interaction with the
    user:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高体验，我们可以将设置更改为使用集成终端。首先，让我们修改代码以要求与用户交互：
- en: 'At the top of `Program.cs`, add statements to prompt the user to enter a number
    and parse that as a `double` into the variable `a`, as shown highlighted in the
    following code:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`的顶部，添加提示用户输入数字并将该数字解析为变量`a`中的`double`类型的语句，如下面的代码所示，高亮显示：
- en: '[PRE51]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Set a breakpoint on line 1 that writes the prompt `Enter a number`.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第1行设置断点，写入提示`Enter a number`。
- en: At the top of the **RUN AND DEBUG** window, click the **Run and Debug** button,
    and then select the **Debugging** project.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**运行和调试**窗口的顶部，点击**运行和调试**按钮，然后选择**Debugging**项目。
- en: Note that the `Enter a number` prompt is not written to either **TERMINAL**
    or **DEBUG CONSOLE** and neither window is waiting for the user to enter a number
    and press *Enter*.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，`Enter a number`提示既没有写入**TERMINAL**也没有写入**DEBUG CONSOLE**，并且两个窗口都没有等待用户输入数字并按*Enter*。
- en: Stop debugging.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止调试。
- en: 'At the top of the **RUN AND DEBUG** window, click the **create a launch.json
    file** link, and then, when prompted for the debugger, select **C#**, as shown
    in *Figure 4.9*:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**运行和调试**窗口的顶部，点击**创建launch.json文件**链接，然后，当提示选择调试器时，选择**C#**，如图*4.9*所示：
- en: '![](img/B22322_04_09.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22322_04_09.png)'
- en: 'Figure 4.9: Selecting a debugger for the launch.json file'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：为launch.json文件选择调试器
- en: 'In the `launch.json` file editor, click the **Add Configuration...** button,
    and then select **.NET: Launch .NET Core Console App**, as shown in *Figure 4.10*:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在`launch.json`文件编辑器中，点击**添加配置...**按钮，然后选择**.NET: Launch .NET Core Console App**，如图*4.10*所示：'
- en: '![](img/B22322_04_10.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22322_04_10.png)'
- en: 'Figure 4.10: Adding a launch configuration for a .NET console app'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10：为.NET控制台应用程序添加启动配置
- en: 'In `launch.json`, make the following additions and changes, as shown highlighted
    in the following configuration:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`launch.json`中，进行以下添加和更改，如下面的配置所示，高亮显示：
- en: Comment out the `preLaunchTask` setting.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释掉`preLaunchTask`设置。
- en: In the `program` path, add the `Debugging` project folder after the `workspaceFolder`
    variable.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`program`路径中，在`workspaceFolder`变量之后添加`Debugging`项目文件夹。
- en: In the `program` path, change `<target-framework>` to `net9.0`.
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`program`路径中，将`<target-framework>`更改为`net9.0`。
- en: In the `program` path, change `<project-name.dll>` to `Debugging.dll`.
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`program`路径中，将`<project-name.dll>`更改为`Debugging.dll`。
- en: 'Change the `console` setting from `internalConsole` to `integratedTerminal`:'
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`console`设置从`internalConsole`更改为`integratedTerminal`：
- en: '[PRE52]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Remember that with VS Code, we open the `Chapter04` folder to process the solution
    file, so the workspace folder is `Chapter04`, not the `Debugging` project.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，使用VS Code时，我们打开`Chapter04`文件夹来处理解决方案文件，因此工作区文件夹是`Chapter04`，而不是`Debugging`项目。
- en: At the top of the **RUN AND DEBUG** window, note the drop-down list of launch
    configurations, and click the **Start Debugging** button (green triangle), as
    shown in *Figure 4.11*.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**运行和调试**窗口的顶部，注意启动配置的下拉列表，并点击**开始调试**按钮（绿色三角形），如图*4.11*所示。
- en: Navigate to **View** | **Terminal** and note the **TERMINAL** window is attached
    to `Debugging.dll`, as shown in *Figure 4.11*.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**视图** | **终端**，并注意**终端**窗口附加到`Debugging.dll`，如图*4.11*所示。
- en: Step over the statement that writes `Enter a number:` to the console.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳过将`Enter a number:`写入控制台的语句。
- en: Step over the statement that calls `ReadLine`.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳过调用`ReadLine`的语句。
- en: Type `5.5` and press *Enter*.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`5.5`并按*Enter*。
- en: 'Continue stepping through the statements or press *F5* or click **Continue**,
    and note the output written to the integrated terminal, as shown in *Figure 4.11*:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续逐句执行或按*F5*或点击**继续**，并注意写入集成终端的输出，如图*图4.11*所示：
- en: '![](img/B22322_04_11.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_04_11.png)'
- en: 'Figure 4.11: A launch configuration set to use the integrated terminal for
    user interaction'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11：设置为使用集成终端进行用户交互的启动配置
- en: Customizing breakpoints
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义断点
- en: 'It is easy to make more complex breakpoints:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 创建更复杂的断点很容易：
- en: If you are still debugging, click the **Stop** button in the debugging toolbar,
    navigate to **Run** or **Debug** | **Stop Debugging**, or press *Shift* + *F5*.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您仍在调试中，请点击调试工具栏中的**停止**按钮，导航到**运行**或**调试** | **停止调试**，或按*Shift* + *F5*。
- en: Navigate to **Run** | **Remove All Breakpoints** or **Debug** | **Delete All
    Breakpoints**.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**运行** | **移除所有断点**或**调试** | **删除所有断点**。
- en: Click on the `WriteLine` statement that outputs the answer.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击输出答案的`WriteLine`语句。
- en: Set a breakpoint by pressing *F9* or navigating to **Run** or **Debug** | **Toggle
    Breakpoint**.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*F9*或导航到**运行**或**调试** | **切换断点**来设置断点。
- en: 'Right-click the breakpoint and choose the appropriate menu for your code editor:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击断点并选择适合您的代码编辑器的适当菜单：
- en: In VS Code, choose **Edit Breakpoint...**.
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在VS Code中，选择**编辑断点...**。
- en: In Visual Studio, choose **Conditions...**.
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，选择**条件...**。
- en: 'Type an expression, such as the `answer` variable must be greater than `9`,
    and then press *Enter* to accept it, and note the expression must evaluate to
    `true` for the breakpoint to activate, as shown in *Figure 4.12*:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个表达式，例如`answer`变量必须大于`9`，然后按*Enter*键接受它，并注意表达式必须评估为`true`，断点才能激活，如图*图4.12*所示：
- en: '![](img/B22322_04_12.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_04_12.png)'
- en: 'Figure 4.12: Customizing a breakpoint with an expression using VS Code'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12：使用VS Code自定义带有表达式的断点
- en: Start debugging and note the breakpoint is not hit.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始调试并注意断点未被触发。
- en: Stop debugging.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止调试。
- en: Edit the breakpoint or its conditions and change its expression to less than
    `9`.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑断点或其条件，并将其表达式更改为小于`9`。
- en: Start debugging and note the breakpoint is hit.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始调试并注意断点被触发。
- en: Stop debugging.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止调试。
- en: 'Edit the breakpoint or its conditions (in Visual Studio, click **Add condition**),
    select **Hit Count**, then enter a number such as `3`, meaning that you would
    have to hit the breakpoint three times before it activates, as shown in *Figure
    4.13*:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑断点或其条件（在Visual Studio中，点击**添加条件**），选择**触发次数**，然后输入一个数字，例如`3`，这意味着您必须触发断点三次才能激活它，如图*图4.13*所示：
- en: '![](img/B22322_04_13.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_04_13.png)'
- en: 'Figure 4.13: Customizing a breakpoint with an expression and hit count using
    Visual Studio'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13：使用Visual Studio自定义带有表达式和触发次数的断点
- en: 'Hover your mouse over the breakpoint’s red circle to see a summary, as shown
    in *Figure 4.14*:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在断点的红色圆圈上，可以看到摘要，如图*图4.14*所示：
- en: '![](img/B22322_04_14.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_04_14.png)'
- en: 'Figure 4.14: A summary of a customized breakpoint in VS Code'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14：VS Code中自定义断点的摘要
- en: You have now fixed a bug using some debugging tools and seen some advanced possibilities
    for setting breakpoints.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已使用一些调试工具修复了一个错误，并看到了设置断点的先进可能性。
- en: Hot reloading during development
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发中的热重载
- en: '**Hot Reload** is a feature that allows a developer to apply changes to code
    while the app is running and immediately see the effect. This is great for fixing
    bugs quickly. Hot Reload is also known as **Edit and Continue**. A list of the
    types of changes you can make that support Hot Reload is found at the following
    link: [https://aka.ms/dotnet/hot-reload](https://aka.ms/dotnet/hot-reload).'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '**热重载**是一个允许开发者在应用程序运行时应用代码更改并立即看到效果的特性。这对于快速修复错误非常有用。热重载也称为**编辑并继续**。您可以在以下链接中找到支持热重载的更改类型列表：[https://aka.ms/dotnet/hot-reload](https://aka.ms/dotnet/hot-reload)。'
- en: Just before the release of .NET 6, a high-level Microsoft employee caused controversy
    by attempting to make the feature exclusive to Visual Studio. Luckily the open-source
    contingent within Microsoft successfully had the decision overturned. Hot Reload
    remains available using the command-line tool as well.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET 6发布之前，一位高级微软员工试图使该功能仅限于Visual Studio，引发了争议。幸运的是，微软内部的开放源代码阵营成功地推翻了这一决定。使用命令行工具仍然可以使用Hot
    Reload。
- en: 'Let’s see it in action:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际操作：
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `HotReloading` to the `Chapter04` solution.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器，将名为 `HotReloading` 的新 **控制台应用程序** / `console` 项目添加到 `Chapter04`
    解决方案中。
- en: Modify `HotReloading.csproj` to statically import `System.Console` for all code
    files.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `HotReloading.csproj` 以静态导入所有代码文件的 `System.Console`。
- en: 'In `Program.cs`, delete the existing statements, and then write a message to
    the console every two seconds, as shown in the following code:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，删除现有的语句，然后每两秒向控制台写入一条消息，如下所示代码：
- en: '[PRE53]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Hot reloading using Visual Studio
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Visual Studio 进行热重载
- en: 'If you are using Visual Studio, Hot Reload is built into the user interface:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 Visual Studio，热重载功能已集成到用户界面中：
- en: In Visual Studio, start the project and note that the message is output every
    two seconds.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中启动项目，并注意每两秒输出一条消息。
- en: Leave the project running.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持项目运行。
- en: In `Program.cs`, change `Hello` to `Goodbye`.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，将 `Hello` 改为 `Goodbye`。
- en: Navigate to **Debug** | **Apply Code Changes** or click the **Hot Reload** button
    in the toolbar, as shown in *Figure 4.15*, and note the change is applied without
    needing to restart the console app.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **调试** | **应用代码更改** 或在工具栏中点击 **热重载** 按钮，如图 4.15 所示，并注意更改已应用而无需重新启动控制台应用程序。
- en: 'Drop down the **Hot Reload** button menu and select **Hot Reload on File Save**,
    as shown in *Figure 4.15*:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开热重载按钮菜单，并选择 **文件保存时热重载**，如图 4.15 所示：
- en: '![](img/B22322_04_15.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_04_15.png)'
- en: 'Figure 4.15: Changing Hot Reload options'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15：更改热重载选项
- en: Change the message again, save the file, and note the console app updates automatically.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次更改消息，保存文件，并注意控制台应用程序自动更新。
- en: Hot reloading using VS Code and dotnet watch
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 VS Code 和 dotnet watch 进行热重载
- en: 'If you are using VS Code, you must issue a special command when starting the
    console app to activate Hot Reload:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 VS Code，在启动控制台应用程序时必须发出一个特殊命令以激活热重载：
- en: 'In VS Code, in **TERMINAL**, start the console app using `dotnet watch`, and
    note the output that shows that Hot Reload is active, as shown in the following
    output:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中，在 **终端** 中使用 `dotnet watch` 启动控制台应用程序，并注意显示热重载已激活的输出，如下所示输出：
- en: '[PRE54]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In VS Code, change `Hello` to `Goodbye`, and note that, after a couple of seconds,
    the change is applied without needing to restart the console app, as shown in
    the following output:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中，将 `Hello` 改为 `Goodbye`，并注意几秒钟后更改已应用而无需重新启动控制台应用程序，如下所示输出：
- en: '[PRE55]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Press *Ctrl* + *C* to stop it running, as shown in the following output:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Ctrl* + *C* 停止其运行，如下所示输出：
- en: '[PRE56]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now that you’ve seen tools for finding and removing bugs during development,
    let’s see how you can track down less obvious problems that might happen during
    development and production by writing tests.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了在开发过程中查找和删除错误的方法，让我们看看如何通过编写测试来追踪开发和生产过程中可能出现的更不明显的问题。
- en: Unit testing
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Fixing bugs in code is expensive. The earlier that a bug is discovered in the
    development process, the less expensive it will be to fix.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 修复代码中的错误代价高昂。在开发过程中越早发现错误，修复成本就越低。
- en: Unit testing is a good way to find bugs early in the development process because
    they test a small unit before they are integrated together or seen by user acceptance
    testers. Some developers even follow the principle that programmers should create
    unit tests before they write code, and this is called **test-driven development**
    (**TDD**).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是开发过程中早期发现错误的好方法，因为它们在集成到一起或被用户验收测试人员看到之前测试了一个小的单元。一些开发者甚至遵循程序员应该在编写代码之前创建单元测试的原则，这被称为
    **测试驱动开发** (**TDD**)。
- en: Microsoft has a proprietary unit testing framework known as **MSTest**. There
    is also a framework named **NUnit**. However, we will use the free and open-source
    third-party framework **xUnit.net**. All three do basically the same thing. xUnit
    was created by the same team that built NUnit, but they fixed the mistakes they
    felt they made previously. xUnit is more extensible and has better community support.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 微软有一个名为 **MSTest** 的专有单元测试框架。还有一个名为 **NUnit** 的框架。然而，我们将使用免费且开源的第三方框架 **xUnit.net**。这三个框架基本上做的是同一件事。xUnit
    是由构建 NUnit 的同一团队创建的，但他们修正了他们认为之前犯下的错误。xUnit 更易于扩展，并且拥有更好的社区支持。
- en: 'If you are curious about the pros and cons of the various testing systems,
    then there are hundreds of articles written by proponents of each. Just google
    them: [https://www.google.com/search?q=xunit+vs+nunit](https://www.google.com/search?q=xunit+vs+nunit).'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇各种测试系统的优缺点，那么有数百篇文章是由每个系统的支持者撰写的。只需在谷歌上搜索：[https://www.google.com/search?q=xunit+vs+nunit](https://www.google.com/search?q=xunit+vs+nunit)。
- en: Understanding types of testing
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解测试类型
- en: 'Unit testing is just one of many types of testing, as described in *Table 4.1*:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试只是许多测试类型中的一种，如 *表 4.1* 所述：
- en: '| **Type** | **Description** |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **描述** |'
- en: '| Unit | Tests the smallest unit of code, typically a method or function. Unit
    testing is performed on a unit of code isolated from its dependencies by mocking
    them if needed. Each unit should have multiple tests: some with typical inputs
    and expected outputs, some with extreme input values to test boundaries, and some
    with deliberately wrong inputs to test exception handling. |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| 单元 | 测试代码的最小单元，通常是方法或函数。单元测试是在通过模拟（如果需要）将其依赖项隔离的代码单元上进行的。每个单元应具有多个测试：一些具有典型输入和预期输出，一些具有极端输入值以测试边界，还有一些具有故意错误的输入以测试异常处理。|'
- en: '| Integration | Tests if the smaller units and larger components work together
    as a single piece of software. Sometimes involves integrating with external components
    for which you do not have source code. |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| 集成 | 测试较小的单元和较大的组件是否作为一个单一的软件组件一起工作。有时涉及与外部组件的集成，而这些组件你没有源代码。|'
- en: '| System | Tests the whole system environment in which your software will run.
    |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| 系统 | 测试软件将运行的整个系统环境。|'
- en: '| Performance | Tests the performance of your software; for example, your code
    must return a web page full of data to a visitor in under 20 milliseconds. |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| 性能 | 测试软件的性能；例如，你的代码必须在 20 毫秒内向访客返回一个充满数据的网页。|'
- en: '| Load | Tests how many requests your software can handle simultaneously while
    maintaining required performance, for example, 10,000 concurrent visitors to a
    website. |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| 负载 | 测试软件可以同时处理多少请求，同时保持所需性能，例如，一个网站有 10,000 个并发访客。|'
- en: '| User Acceptance | Tests if users can happily complete their work using your
    software. |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| 用户验收 | 测试用户是否可以使用你的软件愉快地完成他们的工作。|'
- en: 'Table 4.1: Types of testing'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1：测试类型
- en: Creating a class library that needs testing
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建需要测试的类库
- en: 'First, we will create a function that needs testing. We will create it in a
    class library project separate from a console app project. A class library is
    a package of code that can be distributed and referenced by other .NET applications:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个需要测试的函数。我们将在一个与控制台应用程序项目分开的类库项目中创建它。类库是一组代码，可以分发并由其他 .NET 应用程序引用：
- en: Use your preferred code editor to add a new **Class Library** / `classlib` project
    named `CalculatorLib` to the `Chapter04` solution.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的代码编辑器将一个名为 `CalculatorLib` 的新 **类库** / `classlib` 项目添加到 `Chapter04` 解决方案中。
- en: At this point, you will have created about a dozen new console app projects
    and added them to a solution. The only difference when adding a **Class Library**
    / `classlib` project is selecting a different project template. The rest of the
    steps are the same as adding a **Console App** / `console` project.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你将创建大约十几个新的控制台应用程序项目并将它们添加到解决方案中。添加 **类库** / `classlib` 项目时唯一的区别是选择不同的项目模板。其余步骤与添加
    **控制台应用程序** / `console` 项目相同。
- en: 'If you are using Visual Studio:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Visual Studio：
- en: Navigate to **File** | **Add** | **New Project**.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **文件** | **添加** | **新项目**。
- en: In the **Add a new project** dialog, search for and select **Class Library [C#]**
    and then click **Next**.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **添加新项目** 对话框中，搜索并选择 **类库 [C#]**，然后点击 **下一步**。
- en: In the **Configure your new project** dialog, for the **Project name**, enter
    `CalculatorLib`, leave the location as `C:\cs13net9\Chapter04`, and then click
    **Next**.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **配置新项目** 对话框中，对于 **项目名称**，输入 `CalculatorLib`，保留位置为 `C:\cs13net9\Chapter04`，然后点击
    **下一步**。
- en: In the **Additional information** dialog, select **.NET 9.0 (Standard Term Support)**,
    and then click **Create**.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **附加信息** 对话框中，选择 **.NET 9.0 (标准术语支持**)，然后点击 **创建**。
- en: 'If you are using VS Code:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 VS Code：
- en: In **TERMINAL**, switch to a terminal in the `Chapter04` folder.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **终端** 中，切换到 `Chapter04` 文件夹下的终端。
- en: 'Use the `dotnet` CLI to create a new class library project named `CalculatorLib`,
    as shown in the following command: `dotnet new classlib -o CalculatorLib`.'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `dotnet` CLI 创建一个名为 `CalculatorLib` 的新类库项目，如下命令所示：`dotnet new classlib -o
    CalculatorLib`。
- en: 'Use the `dotnet` CLI to add the new project folder to the solution, as shown
    in the following command: `dotnet sln add CalculatorLib`.'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `dotnet` CLI 将新的项目文件夹添加到解决方案中，如下所示命令：`dotnet sln add CalculatorLib`。
- en: 'Note the results, as shown in the following output: ``Project `CalculatorLib\CalculatorLib.csproj`
    added to the solution``.'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意结果，如下所示输出：``项目 `CalculatorLib\CalculatorLib.csproj` 已添加到解决方案``。
- en: For all code editors, in the `CalculatorLib` project, rename the file named
    `Class1.cs` to `Calculator.cs`.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于所有代码编辑器，在 `CalculatorLib` 项目中，将名为 `Class1.cs` 的文件重命名为 `Calculator.cs`。
- en: 'In `Calculator.cs`, modify the file to define a `Calculator` class (with a
    deliberate bug), as shown in the following code:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Calculator.cs` 中，修改文件以定义一个 `Calculator` 类（故意包含一个错误），如下所示代码：
- en: '[PRE57]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Compile your class library project:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译您的类库项目：
- en: In Visual Studio, navigate to **Build** | **Build CalculatorLib**.
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，导航到 **构建** | **构建 CalculatorLib**。
- en: In VS Code, in a **TERMINAL** window for the `CalculatorLib` folder, enter the
    command `dotnet build`. (You could also run this command in the `Chapter04` folder
    but that would build the whole solution, which is unnecessary in this scenario.)
  id: totrans-418
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 VS Code 中，在 `CalculatorLib` 文件夹的 **终端** 窗口中，输入命令 `dotnet build`。（您也可以在 `Chapter04`
    文件夹中运行此命令，但那样会构建整个解决方案，在这种情况下是不必要的。）
- en: 'Use your preferred code editor to add a new **xUnit Test Project [C#]** / `xunit`
    project named `CalculatorLibUnitTests` to the `Chapter04` solution. For example,
    at the command prompt or terminal in the `Chapter04` folder, enter the following
    commands:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器将新的 **xUnit 测试项目 [C#]** / `xunit` 项目 `CalculatorLibUnitTests` 添加到
    `Chapter04` 解决方案中。例如，在命令提示符或 `Chapter04` 文件夹中的终端中，输入以下命令：
- en: '[PRE58]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In the `CalculatorLibUnitTests` project, add a project reference to the `CalculatorLib`
    project:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CalculatorLibUnitTests` 项目中，将 `CalculatorLib` 项目添加为项目引用：
- en: If you are using Visual Studio, in **Solution Explorer**, select the `CalculatorLibUnitTests`
    project, navigate to **Project** | **Add Project Reference…**, check the box to
    select the `CalculatorLib` project, and then click **OK**.
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您正在使用 Visual Studio，在 **解决方案资源管理器** 中选择 `CalculatorLibUnitTests` 项目，导航到 **项目**
    | **添加项目引用…**，勾选复选框以选择 `CalculatorLib` 项目，然后点击 **确定**。
- en: 'If you are using VS Code, use the `dotnet add reference` command, or in the
    file named `CalculatorLibUnitTests.csproj`, modify the configuration to add an
    item group with a project reference to the `CalculatorLib` project, as shown highlighted
    in the following markup:'
  id: totrans-423
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您正在使用 VS Code，使用 `dotnet add reference` 命令，或在名为 `CalculatorLibUnitTests.csproj`
    的文件中修改配置以添加一个项目组，其中包含对 `CalculatorLib` 项目的项目引用，如下所示突出显示的标记：
- en: '[PRE59]'
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The path for a project reference can use either forward `(/)` or back slashes
    `(\)` because the paths are processed by the .NET SDK and changed if necessary
    for the current operating system.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 项目引用的路径可以使用前导斜杠 `(/)` 或反斜杠 `(\)`，因为路径由 .NET SDK 处理，并在必要时根据当前操作系统进行更改。
- en: Build the `CalculatorLibUnitTests` project.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目 `CalculatorLibUnitTests`。
- en: Writing unit tests
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: 'A well-written unit test will have three parts:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 一个编写良好的单元测试将包含三个部分：
- en: '**Arrange**: This part will declare and instantiate variables for input and
    output.'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备**：这一部分将声明和实例化输入和输出的变量。'
- en: '**Act**: This part will execute the unit that you are testing. In our case,
    that means calling the method that we want to test.'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行**：这一部分将执行您正在测试的单元。在我们的例子中，这意味着调用我们想要测试的方法。'
- en: '**Assert**: This part will make one or more assertions about the output. An
    assertion is a belief that, if not true, indicates a failed test. For example,
    when adding 2 and 2, we would expect the result to be 4.'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言**：这一部分将对输出进行一个或多个断言。断言是一种信念，如果为假，则表明测试失败。例如，当将 2 和 2 相加时，我们期望结果是 4。'
- en: 'Now, we will write some unit tests for the `Calculator` class:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为 `Calculator` 类编写一些单元测试：
- en: Rename the file `UnitTest1.cs` to `CalculatorUnitTests.cs` and then open it.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件 `UnitTest1.cs` 重命名为 `CalculatorUnitTests.cs` 然后打开它。
- en: In VS Code, rename the class to `CalculatorUnitTests`. (Visual Studio prompts
    you to rename the class when you rename the file.)
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中，将类重命名为 `CalculatorUnitTests`。（Visual Studio 在您重命名文件时将提示您重命名类。）
- en: 'In `CalculatorUnitTests`, import the `CalculatorLib` namespace, and then modify
    the `CalculatorUnitTests` class to have two test methods, one for adding 2 and
    2, and another for adding 2 and 3, as shown in the following code:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CalculatorUnitTests` 中导入 `CalculatorLib` 命名空间，然后修改 `CalculatorUnitTests`
    类以包含两个测试方法，一个用于将 2 和 2 相加，另一个用于将 2 和 3 相加，如下所示代码：
- en: '[PRE60]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Visual Studio still uses an older project item template that uses a nested namespace.
    The preceding code shows the modern project item template used by `dotnet new`
    and Rider that uses a file-scoped namespace.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio仍然使用一个较旧的项模板，该模板使用嵌套命名空间。前面的代码显示了`dotnet new`和Rider使用的现代项目项模板，它使用文件作用域命名空间。
- en: Build the `CalculatorLibUnitTests` project.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建CalculatorLibUnitTests项目。
- en: Running unit tests using Visual Studio
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Visual Studio 运行单元测试
- en: 'Now we are ready to run the unit tests and see the results:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好运行单元测试并查看结果：
- en: In Visual Studio, navigate to **Test** | **Run All Tests**.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，导航到**测试** | **运行所有测试**。
- en: 'In **Test Explorer**, note that the results indicate that two tests ran, one
    test passed, and one test failed, as shown in *Figure 4.16*:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**测试资源管理器**中，注意结果指示运行了两个测试，一个测试通过，一个测试失败，如图*图4.16*所示：
- en: '![](img/B22322_04_16.png)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_04_16.png)'
- en: 'Figure 4.16: The unit test results in Visual Studio’s Test Explorer'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16：Visual Studio测试资源管理器中的单元测试结果
- en: Running unit tests using VS Code
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 VS Code 运行单元测试
- en: 'Now we are ready to run the unit tests and see the results:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好运行单元测试并查看结果：
- en: If you have not recently built the test project, then build the `CalculatorLibUnitTests`
    project to make sure that the new testing feature in the C# Dev Kit extension
    recognizes the unit tests that you have written.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你最近没有构建测试项目，那么构建CalculatorLibUnitTests项目以确保C#开发工具包扩展中的新测试功能能够识别你编写的单元测试。
- en: In VS Code, navigate to **View** | **Testing**, and note the **TESTING** window
    has a mini toolbar with buttons to **Refresh Tests**, **Run Tests**, **Debug Tests**,
    and so on.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中，导航到**查看** | **测试**，注意**测试**窗口有一个迷你工具栏，带有**刷新测试**、**运行测试**、**调试测试**等按钮。
- en: In the **TESTING** window, expand the **CalculatorLibUnitTests** project to
    show the two tests.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**测试**窗口中，展开**CalculatorLibUnitTests**项目以显示两个测试。
- en: Hover your mouse pointer over **CalculatorUnitTests** and then click the **Run
    Tests** button (black triangle icon) defined in that class.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标指针悬停在**CalculatorUnitTests**上，然后点击该类中定义的**运行测试**按钮（黑色三角形图标）。
- en: 'Click the **TEST RESULTS** tab and note that the results indicate that two
    tests ran, one test passed, and one test failed, as shown in *Figure 4.17*:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**测试结果**选项卡，注意结果指示运行了两个测试，一个测试通过，一个测试失败，如图*图4.17*所示：
- en: '![](img/B22322_04_17.png)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_04_17.png)'
- en: 'Figure 4.17: The unit test results in VS Code’s TEST RESULTS'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17：VS Code的测试结果中的单元测试结果
- en: Fixing the bug
  id: totrans-454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复错误
- en: 'Now you can fix the bug:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以修复错误：
- en: Fix the bug in the `Add` method.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复`Add`方法中的错误。
- en: Run the unit tests again to see that the bug has now been fixed and both tests
    have passed.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行单元测试以查看错误是否已修复并且两个测试都通过。
- en: Now that we’ve written, debugged, logged, and unit-tested functions, let’s finish
    this chapter by looking at how to throw and catch exceptions in functions.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写、调试、记录和单元测试了函数，让我们通过查看如何在函数中抛出和捕获异常来结束本章。
- en: Specifying multiple parameter values
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定多个参数值
- en: 'We created two unit test methods: the first to test adding 2 and 2, and the
    second to test adding 2 and 3\. Instead of writing two separate methods decorated
    with `[Fact]`, we could have written one method decorated with `[Theory]` and
    passed different parameter values using `[InlineData]`, as shown in the following
    code:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个单元测试方法：第一个用于测试2加2，第二个用于测试2加3。我们不必编写两个分别用`[Fact]`装饰的方法，我们可以编写一个用`[Theory]`装饰的方法，并通过`[InlineData]`传递不同的参数值，如下面的代码所示：
- en: '[PRE61]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The order of parameters passed in the `[InlineData]` attribute must match the
    order of parameters in the test method.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '`[InlineData]`属性中传递的参数顺序必须与测试方法中参数的顺序匹配。'
- en: Now let’s see how to throw and catch exceptions when something goes wrong.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看当出现错误时如何抛出和捕获异常。
- en: Throwing and catching exceptions in functions
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数中的抛出和捕获异常
- en: In *Chapter 3*,*Controlling Flow, Converting Types, and Handling Exceptions*,
    you were introduced to exceptions and how to use a `try-catch` statement to handle
    them. But you should only catch and handle an exception if you have enough information
    to mitigate the issue. If you do not, then you should allow the exception to pass
    up through the call stack to a higher level.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在**第3章**，“控制流程，转换类型和处理异常”中，你被介绍了异常以及如何使用`try-catch`语句来处理它们。但你应该只在有足够信息来缓解问题的情况下捕获和处理异常。如果没有，你应该允许异常通过调用堆栈向上传递到更高层次。
- en: Understanding usage errors and execution errors
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解使用错误和执行错误
- en: '**Usage errors** are when a programmer misuses a function, typically by passing
    invalid values as parameters. They could be avoided by that programmer changing
    their code to pass valid values. When some programmers first learn C# and .NET,
    they sometimes think exceptions can always be avoided because they assume all
    errors are usage errors. Usage errors should all be fixed before production runtime.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用错误**发生在程序员误用函数时，通常是通过传递无效的参数值。他们可以通过更改代码以传递有效值来避免这些错误。当一些程序员刚开始学习C#和.NET时，他们有时认为异常总是可以避免的，因为他们假设所有错误都是使用错误。在使用生产运行之前，应该修复所有使用错误。'
- en: '**Execution errors** are when something happens at runtime that cannot be fixed
    by writing “better” code. Execution errors can be split into **program errors**
    and **system errors**. If you attempt to access a network resource but the network
    is down, you need to be able to handle that system error by logging an exception,
    and possibly backing off for a time and trying again. However, some system errors,
    such as running out of memory, simply cannot be handled. If you attempt to open
    a file that does not exist, you might be able to catch that error and handle it
    programmatically by creating a new file. Program errors can be programmatically
    fixed by writing smart code. System errors often cannot be fixed programmatically.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '**执行错误**发生在运行时发生的事情，无法通过编写“更好的”代码来修复。执行错误可以分为**程序错误**和**系统错误**。如果你尝试访问网络资源但网络断开，你需要能够通过记录异常来处理该系统错误，并且可能需要暂时退后并再次尝试。然而，某些系统错误，如内存不足，根本无法处理。如果你尝试打开一个不存在的文件，你可能能够捕获该错误并通过创建新文件来程序化地处理它。程序错误可以通过编写智能代码来程序化修复。系统错误通常无法通过程序化修复。'
- en: Commonly thrown exceptions in functions
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数中常见的抛出异常
- en: Very rarely should you define new types of exceptions to indicate usage errors.
    .NET already defines many that you should use.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 很少应该定义新的异常类型来指示使用错误。.NET已经定义了许多你应该使用的异常。
- en: When defining your own functions with parameters, your code should check the
    parameter values and throw exceptions if they have values that will prevent your
    function from properly functioning.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义带有参数的自定义函数时，你的代码应该检查参数值，并在它们具有将阻止函数正常工作的值时抛出异常。
- en: For example, if a parameter to a function should not be `null`, throw `ArgumentNullException`.
    For other problems, throw `ArgumentException`, `NotSupportedException`, or `InvalidOperationException`.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个函数的参数不应该为`null`，则抛出`ArgumentNullException`。对于其他问题，抛出`ArgumentException`、`NotSupportedException`或`InvalidOperationException`。
- en: 'For any exception, include a message that describes the problem for whoever
    will have to read it (typically a developer audience for class libraries and functions,
    or end users if it is at the highest level of a GUI app), as shown in the following
    code:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何异常，包括一个描述问题的消息，以便任何需要阅读它的人（通常是面向类库和函数的开发者受众，或者如果是在GUI应用程序的最高级别，则是最终用户），如下面的代码所示：
- en: '[PRE62]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '**Good Practice**: If a function cannot successfully perform its operation,
    you should consider it a function failure and report it by throwing an exception.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：如果一个函数无法成功执行其操作，你应该将其视为函数失败，并通过抛出异常来报告。'
- en: Throwing exceptions using guard clauses
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用保护子句抛出异常
- en: Instead of instantiating an exception using `new`, you can use static methods
    on the exception itself. When used in a function implementation to check argument
    values, they are known as **guard clauses**. Some were introduced with .NET 6,
    and more were added in .NET 8.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用异常本身的静态方法而不是使用`new`来实例化异常。当在函数实现中用于检查参数值时，它们被称为**保护子句**。其中一些是在.NET 6中引入的，并在.NET
    8中添加了更多。
- en: 'Common guard clauses are shown in *Table 4.2*:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的保护子句在*表4.2*中展示：
- en: '| **Exception** | **Guard clause methods** |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
  zh: '| **异常** | **保护子句方法** |'
- en: '| `ArgumentException` | `ThrowIfNullOrEmpty`, `ThrowIfNullOrWhiteSpace` |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '| `ArgumentException` | `ThrowIfNullOrEmpty`、`ThrowIfNullOrWhiteSpace` |'
- en: '| `ArgumentNullException` | `ThrowIfNull` |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
  zh: '| `ArgumentNullException` | `ThrowIfNull` |'
- en: '| `ArgumentOutOfRangeException` | `ThrowIfEqual`, `ThrowIfGreaterThan`, `ThrowIfGreaterThanOrEqual`,
    `ThrowIfLessThan`, `ThrowIfLessThanOrEqual`, `ThrowIfNegative`, `ThrowIfNegativeOrZero`,
    `ThrowIfNotEqual`, `ThrowIfZero` |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
  zh: '| `ArgumentOutOfRangeException` | `ThrowIfEqual`、`ThrowIfGreaterThan`、`ThrowIfGreaterThanOrEqual`、`ThrowIfLessThan`、`ThrowIfLessThanOrEqual`、`ThrowIfNegative`、`ThrowIfNegativeOrZero`、`ThrowIfNotEqual`、`ThrowIfZero`
    |'
- en: 'Table 4.2: Common guard clauses'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.2：常见保护子句
- en: 'Instead of writing an `if` statement and then throwing a `new` exception, we
    can simplify the previous example, as shown in the following code:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简化前面的示例，而不是编写 `if` 语句然后抛出 `new` 异常，如下所示：
- en: '[PRE63]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '**More Information**: To get a sense of how often Microsoft source code uses
    its own guard clauses, you can read the following section of an online blog article:
    [https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/#exceptions](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/#exceptions).
    For example, `ThrowIfNull` is called 4,795 times from within the `src` for the
    core libraries in `dotnet/runtime`.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：为了了解 Microsoft 源代码使用其自己的守卫子句的频率，您可以阅读以下在线博客文章的以下部分：[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/#exceptions](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/#exceptions)。例如，`ThrowIfNull`
    在 `dotnet/runtime` 的核心库中的 `src` 内部被调用了 4,795 次。'
- en: Understanding the call stack
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解调用栈
- en: The entry point for a .NET console application is the `Main` method (if you
    have explicitly defined this class) or `<Main>$` (if it was created for you by
    the top-level program feature) in the `Program` class.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 控制台应用程序的入口点是 `Main` 方法（如果你明确定义了此类）或 `Program` 类中的 `<Main>$`（如果它是通过顶级程序功能为你创建的）。
- en: 'The `Main` method will call other methods, which call other methods, and so
    on; these methods could be in the current project or referenced projects and NuGet
    packages, as shown in *Figure 4.18*:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法将调用其他方法，这些方法又调用其他方法，依此类推；这些方法可能位于当前项目或引用的项目和 NuGet 包中，如图 *4.18* 所示：'
- en: '![](img/B22322_04_18.png)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_04_18.png)'
- en: 'Figure 4.18: A chain of method calls that create a call stack'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18：创建调用栈的方法链
- en: 'Let’s create a similar chain of methods to explore where we could catch and
    handle exceptions:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个类似的方法链，以探索我们可以捕获和处理异常的地方：
- en: Use your preferred code editor to add a new **Class Library** / `classlib` project
    named `CallStackExceptionHandlingLib` to the `Chapter04` solution.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器，将名为 `CallStackExceptionHandlingLib` 的新 **类库** / `classlib` 项目添加到
    `Chapter04` 解决方案中。
- en: Rename the `Class1.cs` file to `Processor.cs`.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Class1.cs` 文件重命名为 `Processor.cs`。
- en: 'In `Processor.cs`, modify its contents, as shown in the following code:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Processor.cs` 中，修改其内容，如下所示：
- en: '[PRE64]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `CallStackExceptionHandling` to the `Chapter04` solution.
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器，将名为 `CallStackExceptionHandling` 的新 **控制台应用程序** / `console` 项目添加到
    `Chapter04` 解决方案中。
- en: 'In the `CallStackExceptionHandling` console app project, add a reference to
    the `CallStackExceptionHandlingLib` class library project, as shown in the following
    markup:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CallStackExceptionHandling` 控制台应用程序项目中，添加对 `CallStackExceptionHandlingLib`
    类库项目的引用，如下所示：
- en: '[PRE65]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Build the `CallStackExceptionHandling` console app project to make sure dependent
    projects are compiled and copied to the local `bin` folder.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建名为 `CallStackExceptionHandling` 的控制台应用程序项目，以确保依赖项目被编译并复制到本地的 `bin` 文件夹。
- en: 'In `Program.cs`, delete the existing statements, add statements to define two
    methods, and chain calls to them and the methods in the class library, as shown
    in the following code:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，删除现有语句，添加定义两个方法的语句，并将它们以及类库中的方法进行链式调用，如下所示：
- en: '[PRE66]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Run the console app *without* the debugger attached, and note the results,
    as shown in the following partial output:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在没有附加调试器的情况下运行控制台应用程序，并注意结果，如下所示的部分输出：
- en: '[PRE67]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Note that the call stack is upside down. Starting from the bottom, you see:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 注意调用栈是倒置的。从底部开始，你看到：
- en: The first call is to the `<Main>$` entry point function in the auto-generated
    `Program` class. This is where arguments are passed in as a `String` array.
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一次调用是自动生成的 `Program` 类中的 `<Main>$` 入口点函数。这是将参数作为 `String` 数组传递的地方。
- en: The second call is to the `<<Main>$>g__Alpha|0_0` function. (The C# compiler
    renames it from `Alpha` when it adds it as a local function.)
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二次调用是 `<<Main>$>g__Alpha|0_0` 函数。（当 C# 编译器将其添加为局部函数时，会将其重命名为 `Alpha`。）
- en: The third call is to the `Beta` function.
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三次调用是 `Beta` 函数。
- en: The fourth call is to the `Gamma` function.
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四次调用是 `Gamma` 函数。
- en: The fifth call is to the `Delta` function. This function attempts to open a
    file by passing a bad file path. This causes an exception to be thrown. Any function
    with a `try-catch` statement could catch this exception. If it does not, the exception
    is automatically passed up the call stack until it reaches the top, where .NET
    outputs the exception (and the details of this call stack).
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五次调用是到 `Delta` 函数。此函数尝试通过传递一个错误的文件路径来打开文件。这导致抛出异常。任何带有 `try-catch` 语句的函数都可以捕获此异常。如果它没有捕获，异常将自动向上传递到调用堆栈，直到达到顶部，此时.NET将输出异常（以及此调用堆栈的详细信息）。
- en: '**Good Practice**: Unless you need to step through your code to debug it, you
    should always run your code without the debugger attached. In this case, it is
    especially important not to attach the debugger because, if you do, it will catch
    the exception and show it in a GUI dialog box instead of outputting it as shown
    in the book.'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：除非你需要逐步通过代码来调试它，否则你应该始终在没有附加调试器的情况下运行你的代码。在这种情况下，特别重要的是不要附加调试器，因为如果你这样做，它将捕获异常并在GUI对话框中显示它，而不是像书中所示那样输出它。'
- en: Where to catch exceptions
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在哪里捕获异常
- en: Programmers can decide if they want to catch an exception near the failure point
    or centralized higher up the call stack. This allows your code to be simplified
    and standardized. You might know that calling a function could throw one or more
    types of exception but you do not need to handle any of them at the current point
    in the call stack.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员可以决定他们是否希望在失败点附近或调用堆栈更高处捕获异常。这允许你的代码简化并标准化。你可能知道调用一个函数可能会抛出一个或多个类型的异常，但你不需要在当前调用堆栈点处理它们。
- en: Rethrowing exceptions
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新抛出异常
- en: Sometimes, you want to catch an exception, log it, and then rethrow it. For
    example, if you are writing a low-level class library that will be called from
    an application, your code may not have enough information to programmatically
    fix the error in a smart way, but the calling application might have more information
    and be able to. Your code should log the error in case the calling application
    does not, and then rethrow it up the call stack in case the calling application
    chooses to handle it better.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能想要捕获一个异常，记录它，然后重新抛出它。例如，如果你正在编写一个将被应用程序调用的低级类库，你的代码可能没有足够的信息以编程方式以智能的方式修复错误，但调用应用程序可能拥有更多信息并能做到这一点。你的代码应该记录错误，以防调用应用程序没有记录，然后将其重新抛出到调用堆栈，以防调用应用程序选择更好地处理它。
- en: 'There are three ways to rethrow an exception inside a `catch` block, as shown
    in the following list:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `catch` 块内部重新抛出异常有三种方法，如下所示列表所示：
- en: To throw the caught exception with its original call stack, call `throw`.
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要以原始调用堆栈抛出捕获的异常，请调用 `throw`。
- en: To throw the caught exception as if it was thrown at the current level in the
    call stack, call `throw` with the caught exception, for example, `throw ex`. This
    is usually poor practice because you have lost some potentially useful information
    for debugging but it can be useful when you want to deliberately remove that information
    when it contains sensitive data.
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将捕获的异常作为如果它在调用堆栈的当前级别抛出一样抛出，请使用捕获的异常调用 `throw`，例如，`throw ex`。这通常是一种不好的做法，因为你已经失去了可能对调试有用的信息，但在你想要故意删除包含敏感数据的信息时，这可能是有用的。
- en: To wrap the caught exception in another exception that can include more information
    in a message that might help the caller understand the problem, throw a new exception,
    and pass the caught exception as the `innerException` parameter.
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将捕获的异常包装在另一个异常中，该异常可以包含更多可能帮助调用者理解问题的信息，请抛出一个新的异常，并将捕获的异常作为 `innerException`
    参数传递。
- en: 'If an error occurs when we call the `Gamma` function, then we could catch the
    exception and perform one of the three techniques of rethrowing an exception,
    as shown in the following code:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在调用 `Gamma` 函数时发生错误，那么我们可以捕获异常并执行以下代码中所示的三种重新抛出异常的技术之一：
- en: This code is just illustrative. You would never use all three techniques in
    the same `catch` block!
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码只是为了说明。你永远不会在同一个 `catch` 块中使用所有三种技术！
- en: '[PRE68]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Let’s see this in action with our call stack example:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过我们的调用堆栈示例来看看这个动作：
- en: 'In the `CallStackExceptionHandling` project in `Program.cs`, in the `Beta`
    function, add a `try-catch` statement around the call to the `Gamma` function,
    as shown highlighted in the following code:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CallStackExceptionHandling` 项目的 `Program.cs` 文件中，在 `Beta` 函数中，在调用 `Gamma`
    函数周围添加一个 `try-catch` 语句，如下所示，代码中已突出显示：
- en: '[PRE69]'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Note your code editor will show a squiggle under the `throw ex` to warn you
    that you will lose call stack information, as described in the code analyzer message
    `Re-throwing caught exception changes stack information`; more details can be
    found at the following link: [https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca2200](https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca2200).'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你的代码编辑器将在`throw ex`下显示一个波浪线来警告你，你将丢失调用堆栈信息，如代码分析器消息“重新抛出捕获的异常会更改堆栈信息”中所述；更多详细信息可以在以下链接中找到：[https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca2200](https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca2200)。
- en: 'Run the console app and note that the output excludes some details of the call
    stack, as shown in the following output:'
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序并注意输出排除了一些调用堆栈的详细信息，如下面的输出所示：
- en: '[PRE70]'
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Remove the `ex` by replacing the statement `throw ex;` with `throw;`.
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将`throw ex;`语句替换为`throw;`来移除`ex`。
- en: Run the console app and note that the output includes all the details of the
    call stack.
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序并注意输出包括调用堆栈的所有详细信息。
- en: Implementing the tester-doer and try patterns
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现测试执行者和尝试模式
- en: 'The **tester-doer pattern** can avoid some thrown exceptions (but not eliminate
    them completely). This pattern uses pairs of functions: one to perform a test
    and the other to perform an action that would fail if the test was not passed.'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试执行者模式**可以避免一些抛出的异常（但并不能完全消除）。这种模式使用一对函数：一个用于执行测试，另一个用于执行如果测试未通过就会失败的操作。'
- en: .NET implements this pattern itself. For example, before adding an item to a
    collection by calling the `Add` method, you can test to see if it is read-only,
    which would cause `Add` to fail and, therefore, throw an exception.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 本身实现了这个模式。例如，在通过调用`Add`方法向集合中添加项之前，你可以测试它是否只读，这会导致`Add`失败并因此抛出异常。
- en: 'For example, before withdrawing money from a bank account, you might test that
    the account is not overdrawn, as shown in the following code:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在从银行账户取款之前，你可能需要测试账户是否没有透支，如下面的代码所示：
- en: '[PRE71]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The tester-doer pattern can add performance overhead, so you can also implement
    the **try pattern**, which, in effect, combines the test and do parts into a single
    function, as we saw with `TryParse`.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 测试执行者模式可能会增加性能开销，因此你也可以实现**尝试模式**，实际上，这种模式将测试和执行部分合并为一个单独的函数，就像我们在`TryParse`中看到的那样。
- en: Another problem with the tester-doer pattern occurs when you are using multiple
    threads. In this scenario, one thread calls the test function, and it returns
    a value that indicates that it is okay to proceed. But then another thread executes,
    which changes the state. Then the original thread continues executing, assuming
    that everything is fine, but it is not fine. This is called a *race condition*.
    This topic is too advanced to cover how to handle it in this book.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 测试执行者模式的一个问题是当你使用多个线程时。在这种情况下，一个线程调用测试函数，并返回一个表示可以继续执行的状态值。但然后另一个线程执行，改变了状态。然后原始线程继续执行，假设一切正常，但实际上并不正常。这被称为*竞争条件*。这个话题过于复杂，本书中不会涵盖如何处理它。
- en: '**Good Practice**: Use the try pattern in preference to the tester-doer pattern.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：优先使用尝试模式而不是测试执行者模式。'
- en: 'If you implement your own try pattern function and it fails, remember to set
    the `out` parameter to the default value of its type and then return `false`,
    as shown in the following code:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你实现了自己的尝试模式函数并且它失败了，请记住将`out`参数设置为该类型的默认值，然后返回`false`，如下面的代码所示：
- en: '[PRE72]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '**More Information**: Now that you’ve been introduced to the basics of exceptions,
    you can learn more about the details by reading the official documentation at
    the following link: [https://learn.microsoft.com/en-us/dotnet/standard/exceptions/](https://learn.microsoft.com/en-us/dotnet/standard/exceptions/).'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：现在你已经了解了异常的基本知识，你可以通过阅读以下链接中的官方文档来了解更多细节：[https://learn.microsoft.com/en-us/dotnet/standard/exceptions/](https://learn.microsoft.com/en-us/dotnet/standard/exceptions/)。'
- en: Practicing and exploring
  id: totrans-542
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习和探索
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring, with deeper research, the topics covered in
    this chapter.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题、进行一些实际操作练习，并深入探索本章涵盖的主题来测试你的知识和理解。
- en: Exercise 4.1 – online material
  id: totrans-544
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.1 – 在线材料
- en: Online material can be extra content written by me for this book, or it can
    be references to content created by Microsoft or third parties.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 在线材料可以是为我这本书写的额外内容，也可以是引用由微软或第三方创建的内容。
- en: Logging during development and runtime
  id: totrans-546
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发和运行时记录
- en: 'You should add code throughout your application to log what is happening, especially
    when exceptions occur, so that you can review the logs and use them to trace the
    issue and fix the problem. In an online-only section, you will learn how to implement
    basic logging; this is found at the following link:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在应用程序中添加代码来记录正在发生的事情，尤其是在异常发生时，这样你就可以查看日志并使用它们来追踪问题并解决问题。在一个在线部分，你将学习如何实现基本的记录；这可以在以下链接中找到：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch04-logging.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch04-logging.md)'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch04-logging.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch04-logging.md)'
- en: Exercise 4.2 – practice exercises
  id: totrans-549
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.2 – 练习题
- en: Practice exercises go deeper into the topics for this chapter.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 练习题深入探讨了本章的主题。
- en: Writing functions with debugging and unit testing
  id: totrans-551
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写带有调试和单元测试的函数
- en: 'Prime factors are a combination of the smallest prime numbers that, when multiplied
    together, will produce the original number. Consider the following examples:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 质因数是几个最小的质数的组合，当它们相乘时会产生原始数字。考虑以下示例：
- en: Prime factors of 4 are 2 x 2
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 的质因数是 2 x 2
- en: Prime factor of 7 is 7
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7 的质因数是 7
- en: Prime factors of 30 are 5 x 3 x 2
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 30 的质因数是 5 x 3 x 2
- en: Prime factors of 40 are 5 x 2 x 2 x 2
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 40 的质因数是 5 x 2 x 2 x 2
- en: Prime factors of 50 are 5 x 5 x 2
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 50 的质因数是 5 x 5 x 2
- en: 'Create three projects:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 创建三个项目：
- en: A class library named `Exercise_PrimeFactorsLib` with a static class and static
    method named `PrimeFactors`, which, when passed an `int` variable as a parameter,
    returns a `string` showing its prime factors
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `Exercise_PrimeFactorsLib` 的类库，其中包含一个静态类和一个名为 `PrimeFactors` 的静态方法，该方法接受一个
    `int` 类型的参数，并返回一个显示其质因数的 `string`。
- en: A unit test project named `Exercise_PrimeFactorsTests` with a few suitable unit
    tests
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `Exercise_PrimeFactorsTests` 的单元测试项目，包含一些合适的单元测试
- en: A console application to use it, named `Exercise_PrimeFactorsApp`
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `Exercise_PrimeFactorsApp` 的控制台应用程序来使用它
- en: To keep it simple, you can assume that the largest number entered will be 1,000.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，你可以假设输入的最大数字将是 1,000。
- en: Use the debugging tools and write unit tests to ensure that your function works
    correctly with multiple inputs and returns the correct output.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 使用调试工具和编写单元测试来确保你的函数能够正确处理多个输入并返回正确的输出。
- en: Exercise 4.3 – test your knowledge
  id: totrans-564
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.3 – 测试你的知识
- en: 'Answer the following questions. If you get stuck, try googling the answers,
    if necessary, while remembering that if you get totally stuck, the answers are
    in the *Appendix*:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题。如果你卡住了，可以尝试在谷歌上搜索答案，如果需要的话，同时记住，如果你完全卡住了，答案可以在 *附录* 中找到：
- en: What does the C# keyword `void` mean?
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C# 关键字 `void` 的含义是什么？
- en: What are some differences between imperative and functional programming styles?
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指令式编程和函数式编程风格之间有哪些不同之处？
- en: In VS Code or Visual Studio, what is the difference between pressing *F5*, *Ctrl*
    or *Cmd* + *F5*, *Shift* + *F5*, and *Ctrl* or *Cmd* + *Shift* + *F5*?
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 或 Visual Studio 中，按下 *F5*、*Ctrl* 或 *Cmd* + *F5*、*Shift* + *F5* 和 *Ctrl*
    或 *Cmd* + *Shift* + *F5* 有什么区别？
- en: Where does the `Trace.WriteLine` method write its output to?
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Trace.WriteLine` 方法将输出写入到何处？'
- en: What are the five trace levels?
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪五个跟踪级别？
- en: What is the difference between the `Debug` and `Trace` classes?
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Debug` 类和 `Trace` 类之间的区别是什么？'
- en: When writing a unit test, what are the three “A”s?
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当编写单元测试时，三个“A”指的是什么？
- en: When writing a unit test using xUnit, which attribute must you decorate the
    test methods with?
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用 xUnit 编写单元测试时，你必须用哪个属性来装饰测试方法？
- en: What `dotnet` command executes xUnit tests?
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 xUnit 测试的 `dotnet` 命令是什么？
- en: What statement should you use to rethrow a caught exception named `ex` without
    losing the stack trace?
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要重新抛出名为 `ex` 的捕获异常而不丢失堆栈跟踪，你应该使用哪个语句？
- en: Exercise 4.4 – explore topics
  id: totrans-576
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.4 – 探索主题
- en: 'Use the links on the following page to learn more about the topics covered
    in this chapter:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下页面上的链接了解本章涵盖的主题的更多信息：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-4---writing-debugging-and-testing-functions](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-4---writing-debugging-and-testing-functions)'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-4---writing-debugging-and-testing-functions](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-4---writing-debugging-and-testing-functions)'
- en: Summary
  id: totrans-579
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter, you learned:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了：
- en: How to write reusable functions with input parameters and return values, in
    both an imperative and functional style
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用输入参数和返回值编写可重用函数，无论是命令式还是函数式风格
- en: How to use the Visual Studio and VS Code debugging and diagnostic features like
    logging and unit tests to identify and fix any bugs in them
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Visual Studio 和 VS Code 的调试和诊断功能，如日志和单元测试，来识别和修复其中的任何错误
- en: How to throw and catch exceptions in functions and understand the call stack
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在函数中抛出和捕获异常，并理解调用栈
- en: In the next chapter, you will learn how to build your own types using object-oriented
    programming techniques.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何使用面向对象编程技术构建自己的类型。
- en: Learn more on Discord
  id: totrans-585
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多信息
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的 Discord 社区——在那里您可以分享反馈，向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/csharp13dotnet9](https://packt.link/csharp13dotnet9)'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/csharp13dotnet9](https://packt.link/csharp13dotnet9)'
- en: '![](img/QR_Code281224304227278796.png)'
  id: totrans-588
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code281224304227278796.png)'
- en: Leave a Review!
  id: totrans-589
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下您的评价！
- en: Thank you for purchasing this book from Packt Publishing—we hope you enjoy it!
    Your feedback is invaluable and helps us improve and grow. Once you’ve completed
    reading it, please take a moment to leave an Amazon review; it will only take
    a minute, but it makes a big difference for readers like you.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您从 Packt Publishing 购买这本书——我们希望您喜欢它！您的反馈对我们来说是无价的，它帮助我们改进和成长。一旦您阅读完毕，请花一点时间在亚马逊上留下评价；这只需一分钟，但对像您这样的读者来说意义重大。
- en: Scan the QR or visit the link to receive a free ebook of your choice.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描二维码或访问链接，免费获取您选择的电子书。
- en: '[https://packt.link/NzOWQ](https://packt.link/NzOWQ)'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/NzOWQ](https://packt.link/NzOWQ)'
- en: '![A qr code with black squares  Description automatically generated](img/review1.png)'
  id: totrans-593
  prefs: []
  type: TYPE_IMG
  zh: '![带有黑色方块的二维码  自动生成的描述](img/review1.png)'
