- en: '*Chapter 3*: Step-By-Step Application Development'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces the fundamentals of ABP Framework by building an example
    application. The example application is used to manage products on a typical **CRUD**
    page (note that a CRUD page is used to **Create**, **Read** (view), **Update**,
    and **Delete** entities).
  prefs: []
  type: TYPE_NORMAL
- en: The example presented in this chapter is more advanced than a simple CRUD page.
    It implements many aspects of application development with production quality.
    By the end of this chapter, you will understand the basics, and you will be ready
    to start development with ABP Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will proceed, step by step, in the order of building a real-world project.
    This chapter consists of the following topics; each represents a step in this
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the domain objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entity Framework** (**EF**) Core and database mappings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing the product data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User Interface (UI) and Database Preference
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: I prefer **Razor Pages (MVC)** as the UI framework and **EF Core** as the database
    provider. We will cover other UI frameworks and database providers in separate
    chapters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be building an application, so you need to have .NET runtime, ABP CLI,
    and an IDE/editor installed to build ASP.NET Core projects.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to [*Chapter 2*](B17287_02_Epub_AM.xhtml#_idTextAnchor026), *Getting
    Started with ABP Framework*, to learn how to prepare your development environment,
    as well as create and run the solution.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the source code of the final application from the GitHub repository
    at [https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step is to create a solution for the product management application.
    If you''ve created the *ProductManagement* solution in [*Chapter 2*](B17287_02_Epub_AM.xhtml#_idTextAnchor026),
    *Getting Started with ABP Framework*, you can use it. Otherwise, create an empty
    folder in your computer, open a command-line terminal in this folder, and run
    the following **ABP CLI** command to create a new web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Open the solution in your favorite IDE, create the database, and run the web
    project. If you have problems with running the solution, please refer to the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a running solution. We can start the development by defining the
    domain objects of the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the domain objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you will learn how to define entities with ABP Framework.
    The domain is simple for this application. We have **Product** and **Category**
    entities and a **ProductStockState** enum, as shown in *Figure 3.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – An example product management domain'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.1_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – An example product management domain
  prefs: []
  type: TYPE_NORMAL
- en: 'Entities are defined in the *Domain Layer* of the solution, and the domain
    layer is split into two projects within the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ProductManagement.Domain** is used to define your entities, value objects,
    domain services, repository interfaces, and other core domain-related classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ProductManagement.Domain.Shared** is used to define some primitive shared
    types. The types defined in this project are available to all other layers. Typically,
    we define enums and some constants here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we can start by creating the `Category` and `Product` entities and the `ProductStockState`
    enum.
  prefs: []
  type: TYPE_NORMAL
- en: Category
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Category` entity is used to categorize the products. Create a *Categories*
    folder inside the *ProductManagement.Domain* project and a `Category` class inside
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`Category` is a class is derived from `AuditedAggregateRoot<Guid>`. Here, `Guid`
    is the primary key (`Id`) type of the entity. You can use any type of primary
    key (such as `int`, `long`, or `string`) as long as your database management system
    supports it.'
  prefs: []
  type: TYPE_NORMAL
- en: '`AggregateRoot` is a special type of entity that is used to create the root
    entity type of an aggregate. An aggregate is a **Domain-Driven Design** (**DDD**)
    concept that we will discuss in greater detail in the upcoming chapters. For now,
    consider that we inherit the main entities from this class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AuditedAggregateRoot` class adds some more properties to the `AggregateRoot`
    class: `CreationTime` as `DateTime`, `CreatorId` as `Guid`, `LastModificationTime`
    as `DateTime`, and `LastModifierId` as `Guid`.'
  prefs: []
  type: TYPE_NORMAL
- en: ABP automatically sets these properties. For example, when you insert an entity
    into the database, `CreationTime` is set to the current time, and `CreatorId`
    is automatically set to the `Id` property of the current user.
  prefs: []
  type: TYPE_NORMAL
- en: The audit logging system and the base `Audited` classes will be covered in [*Chapter
    8*](B17287_08_Epub_AM.xhtml#_idTextAnchor249), *Using the Features and Services
    of ABP*.
  prefs: []
  type: TYPE_NORMAL
- en: About Rich Domain Models
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I keep the entities simple, with public getters and setters.
    If you want to create rich domain models and apply DDD principles and other best
    practices, we will discuss them in upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: ProductStockState
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ProductStockState` is a simple enum to set and track the availability of the
    product in stock.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a *Products* folder inside the *ProductManagement.Domain.Shared* project
    and a `ProductStockState` enum inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We define this `enum` in the `ProductManagement.Domain.Shared` project since
    we will reuse it in the **Data Transfer Objects** (**DTOs**) and the UI layer.
  prefs: []
  type: TYPE_NORMAL
- en: Product
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Product` class represents a real product. I intentionally added different
    types of properties to show their usages. Create a *Products* folder inside the
    *ProductManagement.Domain* project and a `Product` class inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This time, I inherited from `FullAuditedAggregateRoot`, which adds `IsDeleted`
    as `bool`, `DeletionTime` as `DateTime`, and `DeleterId` as `Guid` properties
    in addition to the `AuditedAggregateRoot` class used for the `Category` class.
  prefs: []
  type: TYPE_NORMAL
- en: '`FullAuditedAggregateRoot` implements the `ISoftDelete` interface, which makes
    the entity **Soft-Delete**. That means it is never deleted from the database but
    just *marked as deleted*. ABP automatically handles all the Soft-Delete logic.
    You delete the entity as you normally do, but it is not actually deleted. The
    next time you query, deleted entities are automatically filtered, and you don''t
    get them in the query result unless you intentionally request them. We will return
    to that feature in the *Using the data filtering system* section of [*Chapter
    8*](B17287_08_Epub_AM.xhtml#_idTextAnchor249), *Using the Features and Services
    of ABP*.'
  prefs: []
  type: TYPE_NORMAL
- en: About the Navigation Properties
  prefs: []
  type: TYPE_NORMAL
- en: In this example, `Product.Category` is a navigation property for the `Category`
    entity. If you use MongoDB or want to implement DDD truly, you should not add
    navigation properties to other aggregates. However, for relational databases,
    it works perfectly and provides flexibility to our code. We will discuss alternative
    approaches in [*Chapter 10*](B17287_10_Epub_AM.xhtml#_idTextAnchor316), *DDD –
    The Domain Layer*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new files in the solution should look like *Figure 3.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Adding domain objects to the solution'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.2_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Adding domain objects to the solution
  prefs: []
  type: TYPE_NORMAL
- en: We've created the domain objects. In addition, we will create a few `const`
    values to be used later in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to define constant values for the properties of the entities. We will
    then use them in the input validation and database mapping phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a *Categories* folder inside the *ProductManagement.Domain.Shared*
    project and add a `CategoryConsts` class inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `MaxNameLength` value will be used to implement the constraint for
    the `Name` property of a `Category` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, create a `ProductConsts` class inside the *Products* folder of the *ProductManagement.Domain.Shared*
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `MaxNameLength` value will be used to implement the constraint for a `Product`
    instance's `Name` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *ProductManagement.Domain.Shared* project should look similar to *Figure
    3.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Adding constant classes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.3_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Adding constant classes
  prefs: []
  type: TYPE_NORMAL
- en: Now that the domain layer has been completed, we can now configure the database
    mappings for EF Core.
  prefs: []
  type: TYPE_NORMAL
- en: EF Core and database mappings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are using **EF Core** in this application. EF Core is an **Object-Relational
    Mapping** (**ORM**) provider provided by Microsoft. ORMs provide abstractions
    to make you feel like you are working with objects in your application code rather
    than the database tables. We will cover ABP's EF Core integration in [*Chapter
    6*](B17287_06_Epub_AM.xhtml#_idTextAnchor177), *Working with the Data Access Infrastructure*.
    However, for now, let's focus on how we can use it practically.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will add entities to the `DbContext` class and define the mappings
    between entities and database tables. Then, we will use EF Core's **Code First
    Migration** approach to build the necessary code that creates the database tables.
    Following this, we will look at ABP's **Data Seeding** system to insert some initial
    data into the database. Finally, we will apply the migrations and seed data to
    the database to prepare it for the application.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's start by defining the `DbSet` properties for the entities.
  prefs: []
  type: TYPE_NORMAL
- en: Adding entities to the DbContext class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: EF's `DbContext` class is the main class that is used to define mappings between
    entities and database tables. Additionally, it is used to access the database
    and perform database operations for the related entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ProductManagementDbContext` class in the *ProductManagement.EntityFrameworkCore*
    project, and add the following `DbSet` properties inside it (you will need to
    import the namespaces of the `Product` and `Category` objects):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding a `DbSet` property for an entity relates the entity with the `DbContext`
    class. Then, we can use that `DbContext` class to perform database operations
    for the entity. EF Core can make most of the mapping using conventions based on
    the property names and types. If you want to customize the default mapping configuration
    or perform additional configurations, you have two options: **Data Annotations**
    (attributes) and **Fluent API**.'
  prefs: []
  type: TYPE_NORMAL
- en: In the data annotation approach, you add attributes, such as `[Required]` and
    `[StringLength]`, to your entity properties. It is very practical and easy to
    use. It also makes it easier to understand when you read the source code of your
    entity.
  prefs: []
  type: TYPE_NORMAL
- en: One problem with the data annotation attributes is that they are limited (compared
    to the Fluent API) and make your domain layer dependant on the EF Core NuGet package
    when you need to use EF Core's custom attributes, such as `[Index]` and `[Owned]`.
    If that's not a problem for you, you can use the data annotation attributes and
    combine them with the Fluent API where they are not sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will prefer the Fluent API approach, which keeps the entity
    cleaner and places all the ORM logic inside the infrastructure layer.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping entities to the database tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ProductManagementDbContext` class (in the *ProductManagement.EntityFrameworkCore*
    project) contains an `OnModelCreating` method to configure mappings of the entities
    to the database tables. When you first create your solution, this method looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code after the preceding comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This code part defines the `Category` and `Product` mapping configurations.
  prefs: []
  type: TYPE_NORMAL
- en: About Namespaces
  prefs: []
  type: TYPE_NORMAL
- en: You might need to add `using` statements for the namespaces of the `Product`
    class, the `Category` class, and any other classes used in the code. If you have
    trouble, you can always refer to the source code in the GitHub repository that
    I've shared in the *Technical requirements* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `Category` entity is mapped to the *Categories* database table. We use `CategoryConsts.MaxNameLength`
    that was defined before to set the maximum length of the `Name` field in the database.
    The `Name` field is also a *required* property. Finally, we define a *unique*
    database index for the `Name` property because it helps search categories by the
    `Name` field.
  prefs: []
  type: TYPE_NORMAL
- en: The `Product` mapping is similar to the `Category` mapping. Additionally, it
    defines a relationship between the `Category` entity and the `Product` entity;
    a `Product` entity belongs to a `Category` entity, while a `Category` entity can
    have many related `Product` entities.
  prefs: []
  type: TYPE_NORMAL
- en: EF Core Fluent Mapping
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to the EF Core documentation to learn about all the details and
    other options for the Fluent Mapping API.
  prefs: []
  type: TYPE_NORMAL
- en: The mapping configuration is complete. It is time to create a database migration
    to update the database schema for the newly added entities.
  prefs: []
  type: TYPE_NORMAL
- en: The Add-Migration command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you create a new entity or make changes to an existing entity, you should
    also create or alter the related table in the database. EF Core's **Code First
    Migration** system is a perfect way to keep the database schema aligned with the
    application code. Typically, you generate migrations and apply them to the database.
    A migration is an incremental schema change for the database. When you update
    the database, all the migrations are applied since the last update, and the database
    becomes aligned with the application code.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to generate a new migration.
  prefs: []
  type: TYPE_NORMAL
- en: With Visual Studio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are using Visual Studio, open **Package Manager Console (PMC)** from
    the **View** | **Other Windows** | **Package Manager Console** menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Package Manager Console'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.4_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Package Manager Console
  prefs: []
  type: TYPE_NORMAL
- en: Select the *ProductManagement.EntityFrameworkCore* project as the **Default
    project** type. Ensure that the *ProductManagement.Web* project is selected as
    the startup project. You can right-click on the *ProductManagement.Web* project
    and click on the **Set as Startup Project** action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can type the following command into the PMC to add a new migration
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this command should be similar to *Figure 3.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Output of the Add-Migration command'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.5_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – Output of the Add-Migration command
  prefs: []
  type: TYPE_NORMAL
- en: If you get an error such as *No DbContext was found in assembly…*, be sure that
    you've set the **Default project** type to the *ProductManagement.EntityFrameworkCore*
    project.
  prefs: []
  type: TYPE_NORMAL
- en: If everything goes well, a new migration class should be added inside the *Migrations*
    folder of the *ProductManagement.EntityFrameworkCore* project.
  prefs: []
  type: TYPE_NORMAL
- en: In the command line
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are not using Visual Studio, you can use the EF Core command-line tools.
    If you haven''t installed it yet, execute the following command in a command-line
    terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open a command-line terminal in the root directory of the *ProductManagement.EntityFrameworkCore*
    project, and type in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A new migration class should be added inside the *Migrations* folder of the
    *ProductManagement.EntityFrameworkCore* project.
  prefs: []
  type: TYPE_NORMAL
- en: Before applying the newly created migration to the database, I want to mention
    the data seeding feature of ABP Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Seeding data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The data seeding system is used to add some initial data when you migrate the
    database. For example, the identity module creates an admin user in the database
    with all permissions granted to log in to the application.
  prefs: []
  type: TYPE_NORMAL
- en: While data seeding is not essential in our scenario, I want to add some example
    categories and products to the database to make it easier to develop and test
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: About the EF Core Data Seeding
  prefs: []
  type: TYPE_NORMAL
- en: This section uses ABP's data seed system, while EF Core has its own data seeding
    feature. The ABP data seed system allows you to inject runtime services and implement
    advanced logic in your data seed code, and it is suitable for development, test,
    and production environments. However, for simpler development and test scenarios,
    you can use EF Core's data seeding system. Please check the official documentation
    at [https://docs.microsoft.com/en-us/ef/core/modeling/data-seeding](https://docs.microsoft.com/en-us/ef/core/modeling/data-seeding).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `ProductManagementDataSeedContributor` class in the *Data* folder
    of the *ProductManagement.Domain* project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This class implements the `IDataSeedContributor` interface. ABP automatically
    discovers and calls its `SeedAsync` method when you want to seed the database.
    You can implement constructor injection and use any service in your class (such
    as the repositories in this example).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, write the following code inside the `SeedAsync` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We've created two categories with three products and inserted them into the
    database. This class is executed whenever you run the *DbMigrator* application
    (please refer to the following section). Additionally, we checked `if (await _categoryRepository.CountAsync()
    > 0)` to prevent us from inserting the same data in every run.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to migrate the database, which will update the database schema
    and seed the initial data.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ABP application startup template includes a *DbMigrator* console application
    that is pretty useful in development and production environments. When you run
    it, all pending migrations are applied in the database, and the data seeder classes
    are executed. It supports multi-tenant, multi-database scenarios, which is not
    possible if you use the standard `Update-Database` command. This application can
    be deployed and executed in the production environment, typically, as a stage
    of your **Continuous Deployment** (**CD**) pipeline. Separating the migration
    from the main application is a good approach, as the main application doesn't
    require permission to alter the database schema in such cases. Also, you can get
    rid of any concurrency issues you might have if you apply migrations in your main
    application and run multiple instances of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Run the *ProductManagement.DbMigrator* application to migrate the database (that
    is, set it as the startup project, and hit *Ctrl* + *F5*). Once the application
    exits, you can check the database to see that the *Categories* and *Products*
    tables have the initial data inserted (if you are using Visual Studio, you can
    use **SQL Server Object Explorer** to connect to **LocalDB** and explore the databases).
  prefs: []
  type: TYPE_NORMAL
- en: The EF Core configuration is complete, and the database is ready for development.
    We will continue by showing the product data on the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Listing the product data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I prefer to develop the application functionality feature by feature. This section
    will explain how to show a list of the products in a data table on the UI.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by defining a `ProductDto`, for the `Product` entity. Then, we
    will create an application service method that returns a list of products to the
    presentation layer. Additionally, we will learn how to map the `Product` entity
    to `ProductDto` automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Before creating the UI, I will show you how to write an **Automated Test** for
    the application service. In this way, we will be sure that the application service
    is working properly before starting the UI development.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the development, we will explore some benefits of ABP Framework,
    such as the automatic API controller and dynamic JavaScript Proxy systems.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will create a new page, add a data table inside it, get a list of
    the products from the server, and show it on the UI.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will begin by creating a `ProductDto` class.
  prefs: []
  type: TYPE_NORMAL
- en: The ProductDto class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DTOs are used to transfer data between the application and presentation layers.
    It is best practice to return DTOs to the presentation (UI) layer instead of the
    entities. DTOs allow you to expose data in a controlled way and abstract your
    entities from the presentation layer. Directly exposing entities to the presentation
    layer might cause serialization and security problems, too. We will discuss the
    benefits of using DTOs in [*Chapter 11*](B17287_11_Epub_AM.xhtml#_idTextAnchor340),
    *DDD – The Application Layer*.
  prefs: []
  type: TYPE_NORMAL
- en: 'DTOs are defined in the *Application.Contracts* project to make them available
    within the UI layer. So, we start by creating a `ProductDto` class inside the
    *Products* folder of the *ProductManagement.Application.Contracts* project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ProductDto` class is a similar class to the `Product` entity with the
    following differences:'
  prefs: []
  type: TYPE_NORMAL
- en: It is derived from `AuditedEntityDto<Guid>`, which defines the `Id`, `CreationTime`,
    `CreatorId`, `LastModificationTime`, and `LastModifierId` properties (we don't
    need to delete auditing properties, such as `DeletionTime`, since the deleted
    entities are not read from the database).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of adding a navigation property to the `Category` entity, we used a
    `string` `CategoryName` property, which is enough to show on the UI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use the `ProductDto` class to return a list of products from the `IProductAppService`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: IProductAppService
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Application Services** implement the use cases of an application. The UI
    uses them to perform business logic on user interactions. Typically, an application
    service method gets and returns DTOs.'
  prefs: []
  type: TYPE_NORMAL
- en: Application Services versus API Controllers
  prefs: []
  type: TYPE_NORMAL
- en: You could compare application services with API controllers in an ASP.NET Core
    MVC application. While they have similarities for some use cases, application
    services are plain classes that better fit into DDD. They don't depend on a particular
    UI technology. In addition, ABP can automatically expose your application services
    as HTTP APIs, as we will discover in the *Auto API Controllers and the Swagger
    UI* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define interfaces for application services in the *Application.Contracts*
    project of the solution. Create an `IProductAppService` interface inside the *Products*
    folder of the *ProductManagement.Application.Contracts* project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see some predefined ABP types in the preceding code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IProductAppService` is derived from the `IApplicationService` interface. In
    this way, ABP can recognize the application services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GetListAsync` method gets `PagedAndSortedResultRequestDto`, which is a
    standard DTO class of ABP Framework that defines the `MaxResultCount` (int), `SkipCount`
    (int), and `Sorting` (string) properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GetListAsync` method returns `PagedResultDto<ProductDto>`, which contains
    a `TotalCount` (long) property and an `Items` collection of `ProductDto` objects.
    That is a convenient way of returning paged results with ABP Framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could use your own DTOs instead of these predefined DTO types. However,
    they are pretty helpful when you want to standardize some common patterns and
    use the same naming everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous Methods
  prefs: []
  type: TYPE_NORMAL
- en: It is a best practice to define all the application service methods as asynchronous.
    If you define synchronous application service methods, in some cases, certain
    ABP features (such as Unit of Work) might not work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can implement the `IProductAppService` interface to perform the use
    case.
  prefs: []
  type: TYPE_NORMAL
- en: ProductAppService
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a `ProductAppService` class inside the *Products* folder of the *ProductManagement.Application*
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `ProductAppService` class is derived from `ProductManagementAppService`,
    which was defined in the startup template, and can be used as the base class for
    your application services. It implements the `IProductAppService` interface that
    was previously defined. It injects the `IRepository<Product, Guid>` service. This
    is called a **Default Repository**. A repository is a collection-like interface
    that allows you to perform operations on the database. ABP automatically provides
    default repository implementations for all aggregate root entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement the `GetListAsync` method, as shown in the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, `_productRepository.WithDetailsAsync` returns an `IQueryable<Product>`
    object by including the categories (the `WithDetailsAsync` method is similar to
    EF Core's `Include` extension method, which loads the related data into the query).
    We can use the standard `Skip`, `Take`, and `OrderBy` on the queryable object.
  prefs: []
  type: TYPE_NORMAL
- en: The `AsyncExecuter` service (which is pre-injected in the base class) is used
    to execute the `IQueryable` object to perform a database query asynchronously.
    This makes it possible to use the async LINQ extension methods without depending
    on the EF Core package in the application layer.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we are using the `ObjectMapper` service (pre-injected in the base class)
    to map a list of `Product` (entity) objects to a `ProductDto` (DTO) object list.
    In the next section, we will explain how the object mapping is configured.
  prefs: []
  type: TYPE_NORMAL
- en: Repositories and Async Query Execution
  prefs: []
  type: TYPE_NORMAL
- en: We will explore `IRepository` and `AsyncExecuter` in greater detail in [*Chapter
    6*](B17287_06_Epub_AM.xhtml#_idTextAnchor177), *Working with the Data Access Infrastructure*.
  prefs: []
  type: TYPE_NORMAL
- en: Object to object mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ObjectMapper` (the `IObjectMapper` service) automates type conversions and
    uses the **AutoMapper** library by default. It requires you to define the mapping
    before using it. The startup template contains a profile class that you can create
    the mappings inside.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ProductManagementApplicationAutoMapperProfile` class in the *ProductManagement.Application*
    project, and change it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, `CreateMap` defines the mapping. Then, you can automatically convert `Product`
    objects into `ProductDto` objects where you need them.
  prefs: []
  type: TYPE_NORMAL
- en: One of the interesting AutoMapper features is `Product` class has a `Category`
    property, and the `Category` class has a `Name` property. So, if you want to access
    the category name of a product, you should use the `Product.Category.Name` expression.
    However, `ProductDto` has a direct `CategoryName` property that can be accessed
    using the `ProductDto.CategoryName` expression. AutoMapper automatically maps
    these expressions by flattening `Category.Name` into `CategoryName`.
  prefs: []
  type: TYPE_NORMAL
- en: The application layer is complete. Before starting the UI, I want to show you
    how to write automated tests for the application layer.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the ProductAppService class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The startup template comes with the test infrastructure properly configured
    using the **xUnit**, **Shouldly**, and **NSubstitute** libraries. It uses the
    *SQLite in-memory* database to mock the database. A separate database is created
    for each test. It is seeded and destroyed at the end of the test. In this way,
    tests do not affect each other, and your real database remains untouched.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 17*](B17287_17_Epub_AM.xhtml#_idTextAnchor476), *Building Automated
    Tests*, will explore all the details of testing. However, here, I want to show
    you how you can easily write some automated test code for the `GetListAsync` method
    of the `ProductAppService` class. It is good to write the test code for the application
    services before using them on the UI.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a *Products* folder in the *ProductManagement.Application.Tests* project,
    and create a `ProductAppService_Tests` class inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This class inherits from the `ProductManagementApplicationTestBase` class (which
    is included in your solution) that integrates ABP Framework and other infrastructure
    libraries and makes it possible to write our tests. Instead of constructor injection
    (which is not possible in tests), we use the `GetRequiredService` method to resolve
    dependencies in the test code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can write the first test method. Add the following method inside the
    `ProductAppService_Tests` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This method calls the `GetListAsync` method and checks whether the result is
    correct. If you open the **Test Explorer** window (under the **View** | **Test
    Explorer** menu in Visual Studio), you can see the test method that we''ve added.
    **Test Explorer** is used for showing and running the tests in the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – The Test Explorer window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.6_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – The Test Explorer window
  prefs: []
  type: TYPE_NORMAL
- en: Run the test to check whether it is working as expected. If the `GetListAsync`
    method works properly, you will see a green icon on the left-hand side of the
    test method name, as shown in *Figure 3.6*. Unit and integration tests will be
    covered in [*Chapter 17*](B17287_17_Epub_AM.xhtml#_idTextAnchor476), *Building
    Automated Tests*.
  prefs: []
  type: TYPE_NORMAL
- en: Auto API Controllers and the Swagger UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Swagger** is a popular tool in which to explore and test HTTP APIs. It comes
    preinstalled with the startup template.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the *ProductManagement.Web* project to start the web application (set it
    as the startup project if not done so already, and hit *Ctrl* + *F5*). Once the
    application starts, enter the `/swagger` URL, as shown in *Figure 3.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – The Swagger UI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.7_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – The Swagger UI
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see a lot of API endpoints coming from the modules installed in the
    application. If you scroll down, you will see a **Product** endpoint, too. You
    can test it to get the list of products:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – The Product endpoint'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.8_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – The Product endpoint
  prefs: []
  type: TYPE_NORMAL
- en: We haven't created a *ProductController* endpoint yet. So, how is this endpoint
    available here? This is known as the **Auto API Controller** feature of ABP Framework.
    It automatically exposes your application services as HTTP APIs based on naming
    conventions and configurations. Typically, we don't write the controllers manually.
  prefs: []
  type: TYPE_NORMAL
- en: The Auto API Controller feature will be covered in [*Chapter 14*](B17287_14_Epub_AM.xhtml#_idTextAnchor429),
    *Building HTTP APIs and Real-Time Services*, in detail.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have the HTTP API to get the list of products. The next step is to consume
    this API from the client code.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic JavaScript proxies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Typically, you call the HTTP API endpoints from your JavaScript code. ABP dynamically
    creates client-side proxies for all HTTP APIs. Then, you can use these dynamic
    JavaScript functions to consume your APIs from the client application.
  prefs: []
  type: TYPE_NORMAL
- en: Run the *ProductManagement.Web* project again, and open the **Developer Console**
    of the browser while you are on the application's landing page. The developer
    console is available in any modern browser and is typically opened using the *F12*
    shortcut key (on Windows). It is used to explore, trace, and debug the application
    by developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **Console** tab, and type in the following JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you execute this code, a request is made to the server, and the returning
    result is logged in the **Console** tab, as shown in *Figure 3.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Using the dynamic JavaScript proxies'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.9_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – Using the dynamic JavaScript proxies
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the product list is logged in the **Console** tab. That means
    we can easily consume server-side APIs from JavaScript code without having to
    deal with the low-level details.
  prefs: []
  type: TYPE_NORMAL
- en: If you are wondering where that `getList` JavaScript is defined, you can check
    the `/Abp/ServiceProxyScript` endpoint in your application to see the JavaScript
    proxy functions dynamically created by ABP Framework.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will create a **Razor Page** to show the table of products
    on the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a products page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Razor Pages is the recommended way of creating a UI in the ASP.NET Core MVC
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a *Products* folder under the *Pages* folder of the *ProductManagement.Web*
    project. Then, add a new, empty razor page by right-clicking on the *Products*
    folder and then selecting `Index.cshtml`. *Figure 3.10* shows the location of
    the page that we''ve added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Creating a Razor Page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.10_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – Creating a Razor Page
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `Index.cshtml` content, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, I've just placed an `h1` element as the page header. When we create a
    page, typically, we want to add an item to the main menu to open this page.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new menu item
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ABP provides a dynamic and modular menu system. Every module can add items to
    the main menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ProductManagementMenuContributor` class in the *Menus* folder of
    the *ProductManagement.Web* project, and add the following code at the end of
    the `ConfigureMainMenuAsync` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This code adds a *Product Management* main menu item with the *Products* menu
    item inside it. It uses localization keys (with the `l["…"]` syntax) that we should
    define. Open the `en.json` file in the *Localization/ProductManagement* folder
    of the *ProductManagement.Domain.Shared* project, and add the following entries
    to the end of the `texts` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Localization keys are arbitrary, which means you can use any string value as
    the localization key. I prefer to use the `Menu:` prefix for the localization
    keys of menu items, such as `Menu:Products`, in this example. We will return to
    the topic of localization in [*Chapter 8*](B17287_08_Epub_AM.xhtml#_idTextAnchor249),
    *Using the Features and Services of ABP*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can rerun the application and open the *Products* page using the new
    *Product Management* menu item, as shown in *Figure 3.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – The Products page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.11_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – The Products page
  prefs: []
  type: TYPE_NORMAL
- en: So, we've created a page and can open the page using the menu element. We are
    ready to create a data table to show the list of products.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the products data table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a data table to show the list of products with paging and sorting.
    The ABP startup template comes with the **Datatables.net** JavaScript library
    preinstalled and configured. It is a flexible and feature-rich library to show
    tabular data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Index.cshtml` page (in the *Pages/Products* folder), and change its
    contents to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, `abp-script` is an ABP tag helper for adding script files to the page
    with automatic bundling, minification, and versioning support. `abp-card` is another
    tag helper to render a card component in a type-safe and easy way (it renders
    a Bootstrap card).
  prefs: []
  type: TYPE_NORMAL
- en: We could use the standard HTML tags. However, ABP tag helpers dramatically simplify
    UI creation in MVC/Razor Page applications. Additionally, they prevent errors
    with the help of IntelliSense and compile-time type checking. We will investigate
    tag helpers in [*Chapter 12*](B17287_12_Epub_AM.xhtml#_idTextAnchor356), *Working
    with MVC/Razor Pages*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new JavaScript file, named `Index.cshtml.js` (you might prefer a different
    naming style, such as `index.js`; that''s fine, as long as you use the same file
    name in the `abp-script` tag), under the *Pages/Products* folder with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: ABP allows you to reuse the localization texts in your JavaScript code. In this
    way, you can define them on the server side and use them on both sides. `abp.localization.getResource`
    returns a function to localize the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'ABP simplifies the data table''s library configuration and provides built-in
    integrations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`abp.libs.datatables.normalizeConfiguration` is a helper function defined by
    ABP Framework. It simplifies the data table''s configuration by providing conventional
    default values for missing options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abp.libs.datatables.createAjax` is another helper function that adapts ABP''s
    dynamic JavaScript client proxies to the data table''s parameter format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`productManagement.products.product.getList` is the dynamic JavaScript proxy
    function introduced earlier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Define the columns of the data table inside the `columnDefs` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Typically, a column definition has a `title` field (display name) and a `data`
    field. The data field matches the property names in the `ProductDto` class, formatted
    as **camelCase** (a naming style in which the first letter of each word is capitalized,
    except for the first word; it is commonly used in the JavaScript language).
  prefs: []
  type: TYPE_NORMAL
- en: The `render` option can be used to finely control how to show the column data.
    We are providing a function to customize the rendering of the stock state column.
  prefs: []
  type: TYPE_NORMAL
- en: 'On this page, we''ve used some localization keys. We should define them in
    the localization resource. Open the `en.json` file in the *Localization/ProductManagement*
    folder of the *ProductManagement.Domain.Shared* project, and add the following
    entries at the end of the `texts` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the web application again to see the product data table in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – The Products data table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.12_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – The Products data table
  prefs: []
  type: TYPE_NORMAL
- en: We've created a fully working page that lists the products with paging and sorting
    support. In the next sections, we will add functionality to create, edit, and
    delete the products.
  prefs: []
  type: TYPE_NORMAL
- en: Creating products
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create the necessary functionality to add a new product.
    A product should have a category. So, we should select a category while adding
    a new product. We will define new application service methods to get categories
    and create products. In the UI section, we will use ABP's dynamic form feature
    to automatically generate the product creation form, based on a C# class.
  prefs: []
  type: TYPE_NORMAL
- en: Application service contracts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by adding two new methods to the `IProductAppService` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We will use the `GetCategoriesAsync` method to show a drop-down list of categories
    on product creation. We've introduced two new DTOs, and we should define them.
  prefs: []
  type: TYPE_NORMAL
- en: '`CreateUpdateProductDto` is used to create and update products (we will reuse
    it in the *Editing products* section). Define it in the *Products* folder of the
    *ProductManagement.Application.Contracts* project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define a `CategoryLookupDto` class in the *Categories* folder of the
    *ProductManagement.Application.Contracts* project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We've created the contracts, so now we can implement the contracts in the application
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: Application service implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implement the `CreateAsync` and `GetCategoriesAsync` methods in `ProductAppService`
    (in the *ProductManagement.Application* project), as shown in the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, `_categoryRepository` is a type of `IRepository<Category, Guid>` service.
    You inject it just as you did for `_productRepository` earlier. I think the method
    implementations are pretty simple, and there is no need for additional explanation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve used object mapping in two places, and now we have to define the mapping
    configuration. Open the `ProductManagementApplicationAutoMapperProfile.cs` file
    in the *ProductManagement.Application* project, and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This code sets up the AutoMapper configuration for the object mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Automated Tests
  prefs: []
  type: TYPE_NORMAL
- en: I will not show any more automated tests in this chapter; however, I have added
    them to the solution. You can check the source code in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can go and consume these methods from the UI layer.
  prefs: []
  type: TYPE_NORMAL
- en: UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new `CreateProductModal.cshtml` Razor Page under the *Pages/Products*
    folder of the *ProductManagement.Web* project. Open the `CreateProductModal.cshtml.cs`
    file, and change the `CreateProductModalModel` class using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, `ProductManagementPageModel` is a base class defined in the startup template.
    You can inherit it to create `PageModel` classes. `Categories` will be used to
    show a list of the categories in a drop-down list. `[BindProperty]` is a standard
    ASP.NET Core attribute to bind the post data to the `Product` property on an HTTP
    Post request. We are injecting the `IProductAppService` interface to use the methods
    defined earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve already used `CreateEditProductViewModel`, so we need to define it.
    Define it in the same folder as `CreateProductModal.cshtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`SelectItems` tells us that the `CategoryId` property will be selected from
    the `Categories` list. We will reuse this class in the edit modal dialog. That''s
    why I named it `CreateEditProductViewModel`.'
  prefs: []
  type: TYPE_NORMAL
- en: DTOs versus ViewModels
  prefs: []
  type: TYPE_NORMAL
- en: It might seem unnecessary to define the view model (`CreateEditProductViewModel`)
    since it is very similar to the DTO (`CreateUpdateProductDto`). However, it has
    just a few more attributes. These attributes can be easily added to the DTO, and
    we can reuse the DTO on the view side. It is up to your design decision, and you
    can do it. However, I think it is better practice to separate each concern, considering
    these classes have different purposes and evolve in different directions over
    time. For example, the `[SelectItems("Categories")]` attribute refers to the Razor
    Page model, and it has no meaning in the application layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can implement the `OnGetAsync` method in the `CreateProductModalModel`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We are creating the `Product` class with default values, then filling the `Categories`
    list using the product application service. `Clock` is a service provided by ABP
    Framework to get the current time without dealing with time zones and Local/UTC
    times. We use it instead of `DateTime.Now`. This will be explained in [*Chapter
    8*](B17287_08_Epub_AM.xhtml#_idTextAnchor249), *Using the Features and Services
    of ABP*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement `OnPostAsync`, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are mapping `CreateEditProductViewModel` to `CreateProductDto`, we
    need to define the mapping configuration. Open the `ProductManagementWebAutoMapperProfile`
    class in the *ProductManagement.Web* project, and change the content using the
    following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This class defines the object mappings for the AutoMapper library.
  prefs: []
  type: TYPE_NORMAL
- en: We've completed the C# side of the product creation UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can start to build the UI markup and JavaScript code. To do this, open
    the `CreateProductModal.cshtml` file, and change the content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, `abp-dynamic-form` automatically creates the form elements based on the
    C# model class. `abp-form-content` is where the form elements are rendered. `abp-modal`
    is used to create a modal dialog.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the standard Bootstrap HTML elements and ASP.NET Core's bindings
    to create form elements. However, ABP's Bootstrap and dynamic form tag helpers
    simplify the UI code a lot. We will cover ABP tag helpers in [*Chapter 12*](B17287_12_Epub_AM.xhtml#_idTextAnchor356),
    *Working with MVC/Razor Pages*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve completed the product creation modal code. Now, we will add a `Index.cshtml`
    file in the *Pages/Products* folder, and change the `abp-card-header` section
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: I've added 2 columns where each column has a `size-md="_6"` attribute (that
    is half of the 12-column Bootstrap grid). Then, I placed a button on the right-hand
    side by keeping the card title on the left-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this, I added the following code to the end of the `Index.cshtml.js`
    file (right before the final `});` code part):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`abp.ModalManager` is used to manage modal dialogs on the client side. Internally,
    it uses Twitter Bootstrap''s standard modal component but abstracts many details
    by providing a simple API. `createModal.onResult()` is a callback that is called
    when the modal is saved. `createModal.open();` is used to open the modal dialog.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to define some localization texts in the `en.json` file in
    the *Localization/ProductManagement* folder of the *ProductManagement.Domain.Shared*
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the web application again and try to create a new product:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – The New Product modal'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.13_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 – The New Product modal
  prefs: []
  type: TYPE_NORMAL
- en: ABP has automatically created the form fields based on the C# class model. Localization
    and validation also work automatically by reading the attributes and using the
    conventions. Try to leave the name field empty and save the modal to see an example
    of the validation error mesage. We will cover the validation and localization
    topics in more detail in [*Chapter 12*](B17287_12_Epub_AM.xhtml#_idTextAnchor356),
    *Working with MVC/Razor Pages*.
  prefs: []
  type: TYPE_NORMAL
- en: We can now create products on the UI. Now, let's see how to edit products.
  prefs: []
  type: TYPE_NORMAL
- en: Editing products
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Editing a product is similar to adding a new product. This time, we need to
    get the product to edit and prepare the edit form.
  prefs: []
  type: TYPE_NORMAL
- en: Application service contracts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by defining two new methods for the `IProductAppService` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The first method will be used to obtain the product data by ID. We are reusing
    `CreateUpdateProductDto` (which was defined earlier) in the `UpdateAsync` method.
  prefs: []
  type: TYPE_NORMAL
- en: We haven't introduced a new DTO, so we can go straight to the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Application service implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implementing these new methods is pretty simple. Add the following methods
    to the `ProductAppService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `GetAsync` method uses `productRepository.GetAsync` to get the product from
    the database and returns it by mapping it to a `ProductDto` object. The `UpdateAsync`
    method gets the product and maps the given input properties to the product's properties.
    In this way, we overwrite the product properties with new values.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we don't need to call `_productRepository.UpdateAsync` because
    EF Core has a change tracking system. ABP's **Unit of Work** system automatically
    saves the changes at the end of the request if it doesn't throw an exception.
    We will cover the Unit of Work system in [*Chapter 6*](B17287_06_Epub_AM.xhtml#_idTextAnchor177),
    *Working with the Data Access Infrastructure*.
  prefs: []
  type: TYPE_NORMAL
- en: The application layer is now complete. In the next section, we'll create a product
    editing UI.
  prefs: []
  type: TYPE_NORMAL
- en: UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new `EditProductModal.cshtml` Razor Page under the *Pages/Products*
    folder of the *ProductManagement.Web* project. Open `EditProductModal.cshtml.cs`,
    and change the content using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `Id` property will be a hidden field in the form. It should also support
    an HTTP GET request since a GET request opens this modal, and we need the product's
    ID to prepare the edit form. The `Product` and `Categories` properties are similar
    to the create modal. We are also injecting the `IProductAppService` interface
    into the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement the `OnGetAsync` method, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: First, we are getting the product (`ProductDto`) to edit. We are converting
    it into `CreateEditProductViewModel`, which is then used on the UI to create the
    edit form. Then, we are getting the categories to select on the form, as we did
    earlier for the creation form.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve mapped `ProductDto` to `CreateEditProductViewModel`, so now we need
    to define the mapping configuration in the `ProductManagementWebAutoMapperProfile`
    class (in the *ProductManagement.Web* project) just like we''ve done previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnPostAsync` method is simple; we call the `UpdateAsync` method by converting
    `CreateEditProductViewModel` into `CreateUpdateProductDto`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can switch to `EditProductModal.cshtml`, and change its content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This page is very similar to `CreateProductModal.cshtml`. I just added the `Id`
    field to the form (as a hidden input) to store the `Id` property of the product
    being edited.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can add an `Index.cshtml.js` file, and add a new `ModalManager`
    object on top of the `dataTable` initialization code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add a new column definition as the first item in the `columnDefs` array
    within the `dataTable` initialization code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This code adds a new `rowAction` is a special option provided by ABP Framework.
    It is used to add one or more actions for a row in the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the following code after the `dataTable` initialization code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This code refreshes the data table after saving a product edit dialog, so we
    can see the latest data on the table. The final UI looks similar to *Figure 3.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Editing an existing product'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.14_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.14 – Editing an existing product
  prefs: []
  type: TYPE_NORMAL
- en: We can now see the products, create new products, and edit existing ones. The
    final section will add a new action to delete an existing product.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting products
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deleting a product is pretty simple compared to the create or edit actions
    since, in this case, we don''t need to build a form. First, add a new method to
    the `IProductAppService` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, implement it in the `ProductAppService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add a new action to the product data table. Open `Index.cshtml.js`,
    and add the following definition just after the `rowAction.items` array):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Here, `confirmMessage` is a function that is used to get a confirmation from
    the user before executing the action. The `productManagement.products.product.delete`
    function is dynamically created by ABP Framework, as explained earlier. In this
    way, you can directly call server-side methods in your JavaScript code. We are
    just passing the current record's ID. It returns a promise so that we can register
    a callback to the `then` function. Finally, we use `abp.notify.info` to send a
    notification to inform the user, then refresh the data table.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve used some localization texts, so we need to add the following lines
    to the localization file (the `en.json` file in the *Localization/ProductManagement*
    folder of the *ProductManagement.Domain.Shared* project):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the web project again to see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – The Delete action'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.15_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.15 – The Delete action
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Edit** button automatically turns into an **Action** drop-down button
    since we now have two actions. When you click on the **Delete** action, you get
    a confirmation message to delete the product:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – The delete confirmation message'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.16_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.16 – The delete confirmation message
  prefs: []
  type: TYPE_NORMAL
- en: If you click on the **Yes** button, you will see a notification on the page,
    and the data table will be refreshed.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing product deletion was pretty simple. ABP's built-in features helped
    us by implementing common patterns such as client-to-server communication, confirmation
    dialogs, and UI notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `Product` entity has been inherited from the `FullAuditedAggregateRoot`
    class that made it Soft-Delete. Check the database after deleting a product. You
    will see that it was not really deleted, but the `IsDeleted` field is set to `true`.
    Setting `IsDeleted` to `true` makes the product entity soft-deleted (that is,
    deleted logically but not physically). The next time you query products, deleted
    products are automatically filtered and not included in the query result. That's
    done by the data filtering system of ABP Framework and will be covered in [*Chapter
    6*](B17287_06_Epub_AM.xhtml#_idTextAnchor177), *Working with the Data Access Infrastructure*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a fully working CRUD page. We went through all layers
    of the application and have seen the fundamental approaches of ABP-based application
    development.
  prefs: []
  type: TYPE_NORMAL
- en: You were introduced to many different concepts, such as entities, repositories,
    database mapping and migrations, automated tests, API controllers, dynamic JavaScript
    proxies, object to object mapping, Soft-Delete, and more. If you're building a
    serious software solution, you will use all of them, with ABP or not. ABP is a
    full-stack application framework that helps you implement these concepts with
    best practices. It provides the necessary infrastructure to make your daily development
    easier.
  prefs: []
  type: TYPE_NORMAL
- en: You might not understand all of the details at this point. That's not a problem
    because the purpose of the remaining chapters is to deep dive into these concepts
    and show their details and different use cases.
  prefs: []
  type: TYPE_NORMAL
- en: This example application was relatively simple. It doesn't contain any important
    business logic because I've introduced many concepts and tried to keep the application
    simple to focus on these concepts rather than business complexities. I've ignored
    authorization in this example. Authorization will be explained in [*Chapter 7*](B17287_07_Epub_AM.xhtml#_idTextAnchor213),
    *Exploring Cross-Cutting Concerns*.
  prefs: []
  type: TYPE_NORMAL
- en: Demonstrating an example application with real-world complexity is not easy
    in a book. However, I've prepared a complete reference application with real-world
    qualities and complexities for the readers of this book. The reference application
    is open source and available on GitHub. Additionally, it is a live application,
    so you can try it directly.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will introduce that reference application and show the reference
    solution's functionalities, layers, and code structure. The remaining chapters
    frequently refer to the source code of that application.
  prefs: []
  type: TYPE_NORMAL
