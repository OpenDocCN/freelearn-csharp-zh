- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Building Your Own Types with Object-Oriented Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用面向对象编程创建自己的类型
- en: This chapter is about making your own types using **object-oriented programming**
    (**OOP**). You will learn about all the different categories of members that a
    *type* can have, including fields to store data and methods to perform actions.
    You will use OOP concepts such as aggregation and encapsulation. You will also
    learn about language features such as tuple syntax support, `out` variables, inferred
    tuple names, and default literals. Finally, you will learn about pattern matching
    and defining records to make the equality of variables and immutability easier
    to implement.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于使用**面向对象编程**（**OOP**）创建自己的类型。你将了解一个*类型*可以拥有的所有不同成员类别，包括用于存储数据的字段和执行动作的方法。你将使用OOP概念，如聚合和封装。你还将了解语言特性，如元组语法支持、`out`变量、推断的元组名称和默认字面量。最后，你将学习模式匹配和定义记录，以使变量的相等性和不可变性更容易实现。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Talking about OOP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论面向对象编程
- en: Building class libraries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建类库
- en: Storing data in fields
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在字段中存储数据
- en: Working with methods and tuples
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方法和元组进行操作
- en: Controlling access with properties and indexers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性和索引器控制访问
- en: Pattern matching with objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象进行模式匹配
- en: Working with record types
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用记录类型
- en: Talking about OOP
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论面向对象编程
- en: An object in the real world is a thing, such as a car or a person, whereas an
    object in programming often represents something in the real world, such as a
    product or bank account, but it can also be something more abstract.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上一个对象是一个东西，比如汽车或人，而在编程中，一个对象通常代表现实世界中的某个东西，比如产品或银行账户，但它也可以是更抽象的东西。
- en: In C#, we use the C# keywords `class`, `record`, and `struct` to define a type
    of object. You will learn about `struct` types in *Chapter 6*, *Implementing Interfaces
    and Inheriting Classes*. You can think of a type as being a blueprint or template
    for an object.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，我们使用C#关键字`class`、`record`和`struct`来定义对象的类型。你将在*第6章*，*实现接口和继承类*中学习`struct`类型。你可以将类型视为对象的蓝图或模板。
- en: 'The concepts of OOP are briefly described here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这里简要描述了OOP的概念：
- en: '**Encapsulation** is the combination of the data and actions that are related
    to an object. For example, a `BankAccount` type might have data, such as `Balance`
    and `AccountName`, as well as actions, such as `Deposit` and `Withdraw`. When
    encapsulating, you often want to control what can access those actions and the
    data, for example, restricting how the internal state of an object can be accessed
    or modified from the outside.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**是指与对象相关的数据和动作的组合。例如，`BankAccount`（银行账户）类型可能包含数据，如`Balance`（余额）和`AccountName`（账户名称），以及动作，如`Deposit`（存款）和`Withdraw`（取款）。在封装时，你通常想要控制可以访问那些动作和数据的内容，例如，限制从外部访问或修改对象内部状态的方式。'
- en: '**Composition** is about what an object is made of. For example, a `Car` is
    composed of different parts, such as four `Wheel` objects, several `Seat` objects,
    and an `Engine`.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合**是指对象由什么组成。例如，`Car`（汽车）由不同的部分组成，如四个`Wheel`（轮子）对象、几个`Seat`（座位）对象和一个`Engine`（引擎）。'
- en: '**Aggregation** is about what can be combined with an object. For example,
    a `Person` is not part of a `Car` object, but they could sit in the driver’s `Seat`
    and then become the car’s `Driver`—two separate objects that are aggregated together
    to form a new component.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合**是指可以与对象结合的内容。例如，`Person`（人）不是`Car`（汽车）对象的一部分，但它们可以坐在司机的`Seat`（座位）上，然后成为汽车的`Driver`（驾驶员）——两个独立的对象聚合在一起形成一个新的组件。'
- en: '**Inheritance** is about reusing code by having a **subclass** derive from
    a **base** or **superclass**. All functionality in the base class is inherited
    by, and becomes available in, the **derived** class. For example, the base or
    super `Exception` class has some members that have the same implementation across
    all exceptions, and the sub or derived `SqlException` class inherits those members
    and has extra members that are only relevant when a SQL database exception occurs,
    like a property for the database connection.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继承**是通过让**子类**从**基类**或**超类**派生来重用代码。基类中的所有功能都被继承，并在**派生类**中可用。例如，基类或超`Exception`（异常）类有一些成员在所有异常中具有相同的实现，而子类或派生`SqlException`（SQL异常）类继承了这些成员，并具有仅在SQL数据库异常发生时相关的额外成员，例如数据库连接的属性。'
- en: '**Abstraction** is about capturing the core idea of an object and ignoring
    the details or specifics. C# has the `abstract` keyword that formalizes this concept
    but do not confuse the concept of abstraction with the use of the `abstract` keyword
    because it is more than that. The concept of abstraction can also be achieved
    using interfaces. If a class is not explicitly **abstract**, then it can be described
    as being **concrete**. Bases or superclasses are often abstract; for example,
    the superclass `Stream` is abstract, and its subclasses, like `FileStream` and
    `MemoryStream`, are concrete. Only concrete classes can be used to create objects;
    abstract classes can only be used as the base for other classes because they are
    missing some implementation. Abstraction is a tricky balance. If you make a class
    more abstract, more classes will be able to inherit from it, but at the same time,
    there will be less functionality to share. A real-world example of abstraction
    is the approach car manufacturers have taken to **electric vehicles** (**EVs**).
    They create a common “platform” (basically just the battery and wheels) that is
    an abstraction of what all EVs need, and then add on top of that to build different
    vehicles like cars, trucks, vans, and so on. The platform on its own is not a
    complete product, like an abstract class.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象**是指捕捉一个对象的核心思想，忽略细节或具体内容。C#有`abstract`关键字来正式化这个概念，但不要将抽象的概念与`abstract`关键字的使用混淆，因为抽象不仅仅是这个。抽象的概念也可以通过接口实现。如果一个类没有明确地声明为**抽象**，那么它可以被描述为**具体**的。基类或超类通常是抽象的；例如，超类`Stream`是抽象的，它的子类，如`FileStream`和`MemoryStream`，是具体的。只有具体的类才能用来创建对象；抽象类只能用作其他类的基类，因为它们缺少一些实现。抽象是一个棘手的平衡。如果你使一个类更抽象，更多的类将能够从它继承，但与此同时，将会有更少的功能可以共享。抽象的一个现实世界例子是汽车制造商对**电动汽车**（**EVs**）采取的方法。他们创建了一个共同的“平台”（基本上就是电池和轮子），这是所有电动汽车所需内容的抽象，然后在此基础上构建不同的车辆，如汽车、卡车、面包车等等。这个平台本身不是一个完整的产品，就像一个抽象类。'
- en: '**Polymorphism** is about allowing a derived class to override an inherited
    action to provide custom behavior.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多态**是指允许派生类覆盖继承的动作以提供自定义行为。'
- en: There is a lot to cover in the next two chapters about OOP, and some parts of
    it are difficult to learn. At the end of *Chapter 6*, *Implementing Interfaces
    and Inheriting Classes*, I have written a summary of the categories of custom
    types and their capabilities with example code. This will help you review the
    most important facts and highlight the differences between choices, like an `abstract`
    class or an `interface`, and when to use them.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在接下来的两章中，有很多关于面向对象编程（OOP）的内容要介绍，其中一些部分是难以学习的。在*第6章*的结尾，*实现接口和继承类*，我编写了一个关于自定义类型类别及其功能的总结，并附有示例代码。这将帮助你回顾最重要的事实，并突出不同选择之间的差异，例如`abstract`类或`interface`，以及何时使用它们。
- en: Building class libraries
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建类库
- en: '**Class library** assemblies group types together into easily deployable units
    (DLL files). Apart from when you learned about unit testing, you have only created
    console apps to contain your code. To make the code that you write reusable across
    multiple projects, you should put it in class library assemblies, just like Microsoft
    does.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**类库**程序集将类型组合成易于部署的单元（DLL文件）。除了你学习了单元测试之外，你只创建了控制台应用程序来包含你的代码。为了使你编写的代码可以在多个项目中重用，你应该将其放入类库程序集中，就像微软所做的那样。'
- en: Creating a class library
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建类库
- en: 'The first task is to create a reusable .NET class library:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个任务是创建一个可重用的.NET类库：
- en: 'Use your preferred code editor to create a new project, as defined in the following
    list:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的代码编辑器创建一个新项目，如下列所示：
- en: 'Project template: **Class Library** / `classlib`'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**类库** / `classlib`
- en: 'Project file and folder: `PacktLibraryNet2`'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`PacktLibraryNet2`
- en: 'Solution file and folder: `Chapter05`'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter05`
- en: 'Open the `PacktLibraryNet2.csproj` file, and note that, by default, class libraries
    created by the .NET 9 SDK target .NET 9 and, therefore, can only be referenced
    by other .NET 9-compatible assemblies, as highlighted in the following markup:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`PacktLibraryNet2.csproj`文件，并注意，默认情况下，由.NET 9 SDK创建的类库针对.NET 9，因此只能被其他.NET
    9兼容的程序集引用，如下面的标记所示：
- en: '[PRE0]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Modify the framework to target .NET Standard 2.0, add an entry to explicitly
    use the C# 13 compiler, and statically import the `System.Console` class for all
    C# files, as highlighted in the following markup:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改框架以针对 .NET Standard 2.0，添加一个条目以显式使用 C# 13 编译器，并静态导入所有 C# 文件中的 `System.Console`
    类，如下面的标记所示：
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Although we can use the C# 13 compiler, some modern compiler features require
    a modern .NET runtime. For example, we cannot use default implementations in an
    interface (introduced in C# 8) because it requires .NET Standard 2.1\. We cannot
    use the `required` keyword (introduced in C# 11) because it requires an attribute
    introduced in .NET 7\. But many useful modern compiler features, like raw literal
    strings, will be available to us.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以使用 C# 13 编译器，但一些现代编译器功能需要现代 .NET 运行时。例如，我们不能在接口中使用默认实现（C# 8 中引入），因为它需要
    .NET Standard 2.1。我们不能使用 `required` 关键字（C# 11 中引入），因为它需要 .NET 7 中引入的属性。但许多有用的现代编译器功能，如原始字面量字符串，将对我们可用。
- en: Save and close the file.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭文件。
- en: Delete the file named `Class1.cs`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除名为 `Class1.cs` 的文件。
- en: 'Compile the project so that other projects can reference it later:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译项目以便其他项目以后可以引用它：
- en: In Visual Studio, navigate to **Build** | **Build PacktLibraryNet2**.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，导航到 **构建** | **构建 PacktLibraryNet2**。
- en: 'In VS Code, enter the following command: `dotnet build`.'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 VS Code 中，输入以下命令：`dotnet build`。
- en: '**Good practice**: To use all the latest C# language and .NET platform features,
    put types in a .NET 9 class library. To support legacy .NET platforms, like .NET
    Core, .NET Framework, and Xamarin, put types that you might reuse in a .NET Standard
    2.0 class library. By default, targeting .NET Standard 2.0 uses the C# 7 compiler,
    but this can be overridden so you get the benefits of the newer SDK and compiler
    even though you are limited to .NET Standard 2.0 APIs.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：为了使用最新的 C# 语言和 .NET 平台功能，将类型放在 .NET 9 类库中。为了支持旧版 .NET 平台，如 .NET Core、.NET
    Framework 和 Xamarin，将可能重用的类型放在 .NET Standard 2.0 类库中。默认情况下，针对 .NET Standard 2.0
    使用 C# 7 编译器，但可以覆盖它，以便即使你受限于 .NET Standard 2.0 API，也能获得较新 SDK 和编译器的优势。'
- en: Understanding file-scoped namespaces
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解文件作用域命名空间
- en: 'Traditionally, you define types like a class nested in a namespace, as shown
    in the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，你定义像在命名空间中嵌套的类这样的类型，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you define multiple types in the same code file, then they can be in different
    namespaces, since the types must be explicitly inside the curly braces for each
    namespace.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在同一个代码文件中定义多个类型，那么它们可以位于不同的命名空间中，因为类型必须显式地位于每个命名空间的括号内。
- en: 'If you use C# 10 or later, you can simplify your code by ending a namespace
    declaration with a semicolon and removing the curly braces, so the type definitions
    do not need to be indented, as shown in the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 C# 10 或更高版本，可以通过在命名空间声明末尾添加分号并删除花括号来简化你的代码，这样类型定义就不需要缩进，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is known as a **file-scoped namespace** declaration. You can only have
    one file-scoped namespace per file. This feature is especially useful for book
    writers who have limited horizontal space.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为 **文件作用域命名空间** 声明。每个文件只能有一个文件作用域命名空间。这个特性对于空间有限的书籍作者特别有用。
- en: '**Good practice**: Put each type that you create in its own code file, or at
    least put types in the same namespace in the same code file so that you can use
    file-scoped namespace declarations.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：将你创建的每个类型放在其自己的代码文件中，或者至少将同一命名空间中的类型放在同一代码文件中，这样你就可以使用文件作用域命名空间声明。'
- en: Defining a class in a namespace
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在命名空间中定义类
- en: 'The next task is to define a class that will represent a person:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务是定义一个将代表人的类：
- en: In the `PacktLibraryNet2` project, add a new class file named `Person.cs`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PacktLibraryNet2` 项目中，添加一个名为 `Person.cs` 的新类文件。
- en: 'In `Person.cs`, delete any existing statements and set the namespace to `Packt.Shared`,
    and for the `Person` class, set the access modifier to `public`, as shown in the
    following code:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 中，删除任何现有语句并将命名空间设置为 `Packt.Shared`，对于 `Person` 类，将访问修饰符设置为 `public`，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Good practice**: We’re doing this because it is important to put your classes
    in a logically named namespace. A better namespace name would be domain-specific,
    for example, `System.Numerics` for types related to advanced numbers. In this
    case, the types we will create are `Person`, `BankAccount`, and `WondersOfTheWorld`,
    and they do not have a typical domain, so we will use the more generic `Packt.Shared`.'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**良好实践**：我们这样做是因为将您的类放在一个逻辑命名的命名空间中很重要。更好的命名空间名称应该是特定领域的，例如，对于与高级数字相关的类型，可以使用`System.Numerics`。在这种情况下，我们将创建的类型是`Person`、`BankAccount`和`WondersOfTheWorld`，它们没有典型的领域，因此我们将使用更通用的`Packt.Shared`。'
- en: Understanding type access modifiers
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解类型访问修饰符
- en: Note that the C# keyword `public` is applied before `class`. This keyword is
    an **access modifier**, and it allows for any other code to access this class
    even outside this class library.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，C#关键字`public`在`class`之前使用。这个关键字是一个**访问修饰符**，它允许任何其他代码在类库外部访问这个类。
- en: If you do not explicitly apply the `public` keyword, then it will only be accessible
    within the assembly that defined it. This is because the implicit access modifier
    for a class is `internal`. We need this class to be accessible outside the assembly,
    so we must make sure it is `public`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有明确应用`public`关键字，那么它只能在定义它的程序集内部访问。这是因为类的隐式访问修饰符是`internal`。我们需要这个类在程序集外部可访问，所以我们必须确保它是`public`。
- en: If you have nested classes, meaning a class defined in another class, then the
    inner class could have the `private` access modifier, which would mean it is not
    accessible outside its parent class.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有嵌套类，即在一个类中定义的类，那么内部类可以具有`private`访问修饰符，这意味着它在其父类之外不可访问。
- en: Introduced with .NET 7, the `file` access modifier applied to a type means that
    type can only be used within its code file. This would only be useful if you define
    multiple classes in the same code file, which is rarely good practice but is used
    with source generators.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从.NET 7开始引入，应用于类型的`file`访问修饰符意味着该类型只能在它的代码文件中使用。这只有在您在同一个代码文件中定义多个类时才有用，这很少是好的实践，但与源生成器一起使用。
- en: '**More information**: You can learn more about the `file` access modifier at
    the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/file](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/file).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：您可以在以下链接中了解更多关于`file`访问修饰符的信息：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/file](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/file).'
- en: '**Good practice**: The two most common access modifiers for a class are `public`
    and `internal` (the default access modifier for a class if not specified). Always
    explicitly specify the access modifier for a class to make it clear what it is.
    Other access modifiers include `private` and `file`, but they are rarely used.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：对于类来说，最常见的访问修饰符是`public`和`internal`（如果未指定，则为类的默认访问修饰符）。始终明确指定类的访问修饰符，以便使其清晰。其他访问修饰符包括`private`和`file`，但它们很少使用。'
- en: Understanding members
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解成员
- en: 'The `Person` type does not yet have any members encapsulated within it. We
    will create some over the following pages. Members can be fields, methods, or
    specialized versions of both. You’ll find a description of them here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`类型目前还没有封装任何成员。我们将在接下来的几页中创建一些。成员可以是字段、方法或两者的特殊版本。您可以在以下内容中找到它们的描述：'
- en: '**Fields** are used to store data. You can think of fields as variables that
    belong to a type. There are also three specialized categories of field, as shown
    in the following bullets:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字段**用于存储数据。您可以将字段视为属于类型的变量。还有三个专门的字段类别，如下所示：'
- en: '**Constant**: The data never changes. The compiler literally copies the data
    into any code that reads it. For example, `byte.MaxValue` is always `255`. Constants
    must be set to a literal value. Literal values can only be a `string` surrounded
    by `""`, a `char` surrounded with single quotes, a Boolean like `true` or `false`,
    or a number like `3`, `3L`, `3.0`, `3.0F`, or `3.0M`. Non-literal values are not
    supported, so you cannot have a constant date/time value.'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常量**：数据永远不会改变。编译器将数据字面量地复制到任何读取它的代码中。例如，`byte.MaxValue`始终是`255`。常量必须设置为字面量值。字面量值只能是一个由`""`包围的`string`，一个由单引号包围的`char`，一个布尔值如`true`或`false`，或一个数字如`3`、`3L`、`3.0`、`3.0F`或`3.0M`。不支持非字面量值，因此您不能有常量日期/时间值。'
- en: '**Read-only**: The data cannot change after the class is instantiated, but
    the data can be calculated or loaded from an external source at the time of instantiation.
    For example, `String.Empty` is `""`, `Guid.Empty` is a **GUID** (**globally unique
    identifier**) with all zeros, `TimeSpan.Zero` is a time interval of zero, `DateTime.MinValue`
    is `00:00:00.0000000 UTC, January 1, 0001` in the Gregorian calendar, and `Path.DirectorySeparatorChar`
    is `\` on Windows.'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**只读**：在类实例化后，数据不能更改，但在实例化时可以从外部源计算或加载数据。例如，`String.Empty`是`""`，`Guid.Empty`是一个**GUID**（**全局唯一标识符**）所有位都是零，`TimeSpan.Zero`是零时间间隔，`DateTime.MinValue`是格里高利历中的`00:00:00.0000000
    UTC，0001年1月1日`，而`Path.DirectorySeparatorChar`在Windows上是`\`。'
- en: '`DateTime.UnixEpoch` is `00:00:00.0000000 UTC, January 1, 1970,` in the Gregorian
    calendar but this field was introduced after .NET Standard 2.0, so you won’t be
    able to try it in your current class library.'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DateTime.UnixEpoch`在格里高利历中是`00:00:00.0000000 UTC，1970年1月1日`，但这个字段是在.NET Standard
    2.0之后引入的，所以你无法在当前的类库中尝试它。'
- en: '**Event**: The data references one or more methods that you want to execute
    when something happens, such as clicking on a button or responding to a request
    from some other code. Events will be covered in *Chapter 6*, *Implementing Interfaces
    and Inheriting Classes*. For example, `Console.CancelKeyPress` happens when *Ctrl*
    + *C* or *Ctrl* + *Break* are pressed in a console app.'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**：当发生某些事情时，数据引用一个或多个你想要执行的方法，例如点击按钮或响应其他代码的请求。事件将在*第6章*，*实现接口和继承类*中介绍。例如，`Console.CancelKeyPress`会在控制台应用程序中按下*Ctrl*
    + *C*或*Ctrl* + *Break*时发生。'
- en: '**Methods** are used to execute statements. You saw some examples when you
    learned about functions in *Chapter 4*, *Writing, Debugging, and Testing Functions*.
    There are also four specialized categories of methods:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**用于执行语句。当你学习*第4章*，*编写、调试和测试函数*时，你看到了一些例子。还有四种特殊的方法类别：'
- en: '**Constructor**: The statements execute when you use the `new` keyword to allocate
    memory to instantiate a class. For example, to instantiate Christmas Day, 2023,
    you could write the following code: `new DateTime(2023, 12, 25)`.'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造函数**：当你使用`new`关键字为实例化类分配内存时执行语句。例如，要实例化2023年圣诞节，你可以编写以下代码：`new DateTime(2023,
    12, 25)`。'
- en: '**Property**: The statements execute when you get or set data. The data is
    commonly stored in a field but can be stored externally or calculated at runtime.
    Properties are the preferred way to encapsulate fields unless the memory address
    of the field needs to be exposed; for example, `Console.ForegroundColor` to set
    the current color of text in a console app.'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：当你获取或设置数据时执行语句。数据通常存储在字段中，但也可以在外部存储或在运行时计算。除非需要暴露字段的内存地址，否则属性是封装字段的首选方式；例如，`Console.ForegroundColor`用于设置控制台应用程序中文本的颜色。'
- en: '**Indexer**: The statements execute when you get or set data using “array”
    syntax `[]`. For example, use `name[0]` to get the first character in the `name`
    variable, which is a `string`.'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**索引器**：当你使用“数组”语法`[]`获取或设置数据时执行语句。例如，使用`name[0]`获取`name`变量中的第一个字符，它是一个`string`。'
- en: '**Operator**: The statements execute when you apply an operator like `+` and
    `/` to operands of your type. For example, use `a + b` to add two variables together.'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运算符**：当你对你的类型操作数应用运算符（如`+`和`/`）时执行语句。例如，使用`a + b`将两个变量相加。'
- en: Importing a namespace to use a type
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入命名空间以使用类型
- en: In this section, we will make an instance of the `Person` class.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建`Person`类的实例。
- en: 'Before we can instantiate a class, we need to reference the assembly that contains
    it from another project. We will use the class in a console app:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实例化一个类之前，我们需要从另一个项目中引用包含它的程序集。我们将在控制台应用程序中使用这个类：
- en: Use your preferred code editor to add a new **Console App** / `console` named
    `PeopleApp` to the `Chapter05` solution. Make sure you *add* the new project to
    the existing `Chapter05` solution because you are about to reference from the
    console app project to the existing class library project so both projects must
    be in the same solution.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的代码编辑器将一个新的**控制台应用程序**/ `console`命名为`PeopleApp`添加到`Chapter05`解决方案中。确保你*添加*新的项目到现有的`Chapter05`解决方案中，因为你即将从控制台应用程序项目引用现有的类库项目，所以两个项目必须在同一个解决方案中。
- en: 'If you use Visual Studio:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用Visual Studio：
- en: Configure the startup project for the solution to the current selection.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置解决方案的启动项目为当前选择。
- en: In **Solution Explorer**, select the `PeopleApp` project, navigate to **Project**
    | **Add Project Reference…**, check the box to select the `PacktLibraryNet2` project,
    and then click **OK**.
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **解决方案资源管理器** 中，选择 `PeopleApp` 项目，导航到 **项目** | **添加项目引用…**，勾选复选框以选择 `PacktLibraryNet2`
    项目，然后单击 **确定**。
- en: 'In `PeopleApp.csproj`, add an entry to statically import the `System.Console`
    class, as shown in the following markup:'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PeopleApp.csproj` 中添加一个条目以静态导入 `System.Console` 类，如下所示标记：
- en: '[PRE5]'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Navigate to **Build** | **Build PeopleApp**.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **构建** | **构建 PeopleApp**。
- en: 'If you use VS Code:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用 VS Code：
- en: 'Edit `PeopleApp.csproj` to add a project reference to `PacktLibraryNet2`, and
    add an entry to statically import the `System.Console` class, as highlighted in
    the following markup:'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `PeopleApp.csproj` 以添加对 `PacktLibraryNet2` 的项目引用，并添加一个条目以静态导入 `System.Console`
    类，如下所示标记：
- en: '[PRE6]'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In a terminal, compile the `PeopleApp` project and its dependency `PacktLibraryNet2`
    project, as shown in the following command:'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，编译 `PeopleApp` 项目及其依赖项 `PacktLibraryNet2` 项目，如下所示命令：
- en: '[PRE7]'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the `PeopleApp` project, add a new class file named `Program.Helpers.cs`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PeopleApp` 项目中添加一个名为 `Program.Helpers.cs` 的新类文件。
- en: 'In `Program.Helpers.cs`, delete any existing statements, and define a `partial
    Program` class with a method to configure the console to enable special symbols,
    like the euro currency, and to control the current culture, as shown in the following
    code:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Helpers.cs` 中删除任何现有语句，并定义一个 `partial Program` 类，其中包含一个配置控制台以启用特殊符号（如欧元货币）和控制当前文化的方法，如下所示代码：
- en: '[PRE8]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By the end of this chapter, you will understand how the preceding method uses
    C# features like partial classes, optional parameters, and so on. If you would
    like to learn more about working with languages and cultures, as well as dates,
    times, and time zones, then there is a chapter about globalization and localization
    in my companion book, *Apps and Services with .NET 8*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解前面提到的方法如何使用 C# 的特性，如部分类、可选参数等。如果你想了解更多关于与语言和文化以及日期、时间和时区工作的内容，那么在我的配套书籍
    *Apps and Services with .NET 8* 中有一个关于全球化和本地化的章节。
- en: Instantiating a class
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例化一个类
- en: 'Now, we are ready to write statements to instantiate the `Person` class:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好编写语句来实例化 `Person` 类：
- en: 'In the `PeopleApp` project, in the `Program.cs` file, delete the existing statements,
    then add statements to import the namespace for our `Person` class, and then call
    the `ConfigureConsole` method without any arguments so that it sets the current
    culture to US English, allowing all readers to see the same output, as shown in
    the following code:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PeopleApp` 项目中，在 `Program.cs` 文件中删除现有语句，然后添加语句导入我们的 `Person` 类的命名空间，然后不带任何参数调用
    `ConfigureConsole` 方法，以便将其设置为美国英语当前文化，使所有读者都能看到相同的输出，如下所示代码：
- en: '[PRE9]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Although we could import the `Packt.Shared` namespace globally, it will be clearer
    to anyone reading this code where we import the types we use from if the `import`
    statement is at the top of the file, and the `PeopleApp` project will only have
    this one `Program.cs` file that needs the namespace imported.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以全局导入 `Packt.Shared` 命名空间，但如果 `import` 语句位于文件顶部，那么阅读此代码的人将更清楚地知道我们从哪里导入使用的类型，并且
    `PeopleApp` 项目将只有一个需要导入命名空间的 `Program.cs` 文件。
- en: 'In `Program.cs`, add statements to:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中添加语句：
- en: Create an instance of the `Person` type.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `Person` 类型的实例。
- en: Output the instance using a textual description of itself.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用实例自身的文本描述输出实例。
- en: 'The `new` keyword allocates memory for the object and initializes any internal
    data, as shown in the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`new` 关键字为对象分配内存并初始化任何内部数据，如下所示代码：'
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下所示输出：
- en: '[PRE11]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You might be wondering, “Why does the `bob` variable have a method named `ToString`?
    The `Person` class is empty!” Don’t worry, we’re about to find out!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，“为什么 `bob` 变量有一个名为 `ToString` 的方法？`Person` 类是空的！”别担心，我们很快就会找到答案！
- en: Inheriting from System.Object
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承自 System.Object
- en: Although our `Person` class did not explicitly choose to inherit from a type,
    all types ultimately inherit directly or indirectly from a special type named
    `System.Object`. The implementation of the `ToString` method in the `System.Object`
    type outputs the full namespace and type name.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的 `Person` 类没有明确选择继承自某个类型，但所有类型最终都直接或间接地继承自一个名为 `System.Object` 的特殊类型。`System.Object`
    类型中 `ToString` 方法的实现会输出完整的命名空间和类型名称。
- en: 'Back in the original `Person` class, we could have explicitly told the compiler
    that `Person` inherits from the `System.Object` type, as shown in the following
    code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始的 `Person` 类中，我们可以明确地告诉编译器 `Person` 继承自 `System.Object` 类型，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When class B is inherited from class A, we say that A is the base or superclass,
    and B is the derived or subclass. In this case, `System.Object` is the base or
    superclass, and `Person` is the derived or subclass. You can also use the C# keyword
    `object`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当类 B 从类 A 继承时，我们说 A 是基类或超类，B 是派生类或子类。在这种情况下，`System.Object` 是基类或超类，`Person`
    是派生类或子类。你也可以使用 C# 关键字 `object`。
- en: 'Let’s make our class explicitly inherit from `object` and then review what
    members all objects have:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们的类显式继承自 `object`，然后回顾所有对象都具有哪些成员：
- en: 'Modify your `Person` class to explicitly inherit from `object`, as shown in
    the following code:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的 `Person` 类修改为显式继承自 `object`，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Click inside the `object` keyword and press *F12*, or right-click on the `object`
    keyword and choose **Go to Definition**.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `object` 关键字内单击并按 *F12*，或者右键单击 `object` 关键字并选择 **转到定义**。
- en: 'You will see the Microsoft-defined `System.Object` type and its members. This
    is something you don’t need to understand the details of yet, but note that the
    class is in a .NET Standard 2.0 class library assembly, as shown in *Figure 5.1*:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到微软定义的 `System.Object` 类型及其成员。这目前你不需要了解其细节，但请注意，该类位于 .NET Standard 2.0 类库程序集，如图
    *5.1* 所示：
- en: '![](img/B22322_05_01.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_05_01.png)'
- en: 'Figure 5.1: The System.Object class definition in .NET Standard 2.0'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：.NET Standard 2.0 中的 System.Object 类定义
- en: If you scroll down the class code file, note that the `Object` class has a method
    named `ToString`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向下滚动类代码文件，请注意 `Object` 类有一个名为 `ToString` 的方法。
- en: '**Good practice**: Assume other programmers know that if inheritance is not
    specified, the class will inherit from `System.Object`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：假设其他程序员知道，如果没有指定继承，则类将继承自 `System.Object`。'
- en: Avoiding a namespace conflict with a using alias
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免使用 using 别名与命名空间冲突
- en: We need to learn a bit more about namespaces and their types. It is possible
    that there are two namespaces that contain the same type name, and importing both
    namespaces causes ambiguity. For example, `JsonOptions` exists in multiple Microsoft-defined
    namespaces. If you use the wrong one to configure JSON serialization, then it
    will be ignored and you’ll be confused as to why!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要了解更多关于命名空间及其类型的知识。可能存在两个包含相同类型名称的命名空间，导入这两个命名空间会导致歧义。例如，`JsonOptions` 存在于多个微软定义的命名空间中。如果你使用错误的一个来配置
    JSON 序列化，那么它将被忽略，你可能会困惑为什么会出现这种情况！
- en: 'Let’s review a made-up example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一个虚构的例子：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we build this project, then the compiler would complain with the following
    error:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们构建这个项目，编译器会报以下错误：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can define an alias for one of the namespaces to differentiate it, as shown
    in the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为其中一个命名空间定义一个别名以区分它，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Renaming a type with a using alias
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 using 别名重命名类型
- en: 'Another situation where you might want to use an alias is if you would like
    to rename a type. For example, if you use the `Environment` class in the `System`
    namespace a lot, you could rename it with an alias to make it shorter, as shown
    in the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想使用别名的另一种情况是，如果你想重命名一个类型。例如，如果你在 `System` 命名空间中大量使用 `Environment` 类，你可以使用别名将其重命名以使其更短，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Starting with C# 12, you can alias any type. This means you can rename existing
    types or give a type name to unnamed types like tuples, as you will see later
    in this chapter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 12 开始，你可以对任何类型进行别名。这意味着你可以重命名现有的类型，或者给未命名的类型（如元组）命名，就像你将在本章后面看到的那样。
- en: 'You can learn how to refactor your code using alias any type at the following
    link: [https://devblogs.microsoft.com/dotnet/refactor-your-code-using-alias-any-type/](https://devblogs.microsoft.com/dotnet/refactor-your-code-using-alias-any-type/).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中学习如何使用别名任何类型重构你的代码：[https://devblogs.microsoft.com/dotnet/refactor-your-code-using-alias-any-type/](https://devblogs.microsoft.com/dotnet/refactor-your-code-using-alias-any-type/)。
- en: Storing data in fields
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在字段中存储数据
- en: In this section, we will define a selection of fields in the class to store
    information about a person.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将定义类中的一系列字段来存储有关个人的信息。
- en: Defining fields
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义字段
- en: 'Let’s say that we have decided that a person is composed of a name and a date
    and time of birth. We will encapsulate these two values inside a person, and the
    values will be visible outside it:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经决定一个人由姓名和出生日期组成。我们将这两个值封装在一个人中，并且这些值将对外可见：
- en: 'Inside the `Person` class, write statements to declare two public fields to
    store a person’s name and the date of when they were born, as highlighted in the
    following code:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Person` 类内部，编写语句声明两个公共字段以存储一个人的姓名和他们出生的日期，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We have multiple choices for the data type of the `Born` field. .NET 6 introduced
    the `DateOnly` type. This would store only the date without a time value. `DateTime`
    stores the date and time when the person was born, but it varies between local
    and **Universal Coordinated Time** (**UTC**). The best choice is `DateTimeOffset`,
    which stores the date, time, and hours offset from **UTC**, which is related to
    the time zone. The choice depends on how much detail you need to store.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Born` 字段的数据类型，我们有多种选择。.NET 6 引入了 `DateOnly` 类型。这将仅存储日期而没有时间值。`DateTime`
    存储出生人的日期和时间，但它在本地时间和 **协调世界时**（**UTC**）之间有所不同。最佳选择是 `DateTimeOffset`，它存储日期、时间和从
    **UTC** 的偏移量，这与时区相关。选择取决于您需要存储多少细节。
- en: Types for fields
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段类型
- en: Since C# 8, the compiler has had the ability to warn you if a reference type,
    like a `string`, could have a `null` value and, therefore, potentially throw a
    `NullReferenceException`. Since .NET 6, the SDK enables those warnings by default.
    You can suffix the `string` type with a question mark, `?`, to indicate that you
    accept this, and the warning disappears. You will learn more about nullability
    and how to handle it in *Chapter 6*, *Implementing Interfaces and Inheriting Classes*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 自 C# 8 开始，编译器有了警告您如果引用类型（如 `string`）可能具有 `null` 值并因此可能抛出 `NullReferenceException`
    的能力。自 .NET 6 开始，SDK 默认启用这些警告。您可以在 `string` 类型后缀一个问号 `?` 来表示您接受这一点，警告就会消失。您将在 *第
    6 章*，*实现接口和继承类* 中了解更多关于可空性和如何处理它的信息。
- en: You can use any type for a field, including arrays and collections, such as
    lists and dictionaries. These would be used if you needed to store multiple values
    in one named field. In this example, a person only has one name and one date and
    time of birth.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用任何类型作为字段，包括数组集合，如列表和字典。如果您需要在一个命名字段中存储多个值，就会使用这些类型。在这个例子中，一个人只有一个姓名和一个出生日期和时间。
- en: Member access modifiers
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成员访问修饰符
- en: Part of encapsulation is choosing how visible members are to other code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 封装的一部分是选择其他代码可以访问成员的程度。
- en: Note that, as we did with the class, we explicitly applied the `public` keyword
    to these fields. If we hadn’t, then they would be implicitly `private` to the
    class, which means they are accessible only inside the class.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，就像我们对类所做的那样，我们明确地应用了 `public` 关键字到这些字段上。如果我们没有这样做，那么它们将隐式地成为类的 `private`，这意味着它们只能在类内部访问。
- en: 'There are four **member access modifier** keywords, and two combinations of
    access modifier keywords that you can apply to a class member, like a field or
    method. Member access modifiers apply to an individual member. They are similar
    to but separate from type access modifiers that apply to the whole type. The six
    possible combinations are shown in *Table 5.1*:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个 **成员访问修饰符** 关键字，以及两种可以应用于类成员（如字段或方法）的访问修饰符关键字组合。成员访问修饰符应用于单个成员。它们与应用于整个类型的类型访问修饰符类似，但却是分开的。六种可能的组合在
    *表 5.1* 中显示：
- en: '| **Member Access Modifier** | **Description** |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **成员访问修饰符** | **描述** |'
- en: '| `private` | The member is accessible inside the type only. This is the default.
    |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `private` | 该成员仅可在类型内部访问。这是默认设置。|'
- en: '| `internal` | The member is accessible inside the type and any type in the
    same assembly. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `internal` | 该成员可在类型内部及其同一程序集的任何类型内部访问。|'
- en: '| `protected` | The member is accessible inside the type and any type that
    inherits from the type. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `protected` | 该成员可在类型内部及其继承类型的任何类型内部访问。|'
- en: '| `public` | The member is accessible everywhere. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `public` | 该成员可在任何地方访问。|'
- en: '| `internal protected` | The member is accessible inside the type, any type
    in the same assembly, and any type that inherits from the type. Equivalent to
    a fictional access modifier named `internal_or_protected`. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `internal protected` | 该成员可在类型内部、同一程序集的任何类型以及继承自该类型的任何类型内部访问。等同于一个虚构的访问修饰符
    `internal_or_protected`。|'
- en: '| `private protected` | The member is accessible inside the type and any type
    that inherits from the type and is in the same assembly. Equivalent to a fictional
    access modifier named `internal_and_protected`. This combination is only available
    with C# 7.2 or later. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `private protected` | 成员在类型内部及其继承自该类型的任何类型中是可访问的，并且在该类型所在的程序集内。等同于一个虚构的访问修饰符名称
    `internal_and_protected`。这种组合仅在 C# 7.2 或更高版本中可用。|'
- en: 'Table 5.1: Six member access modifiers'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1：六个成员访问修饰符
- en: '**Good practice**: Explicitly apply one of the access modifiers to all type
    members, even if you want to use the implicit access modifier for members, which
    is `private`. Additionally, fields should usually be `private` or `protected`,
    and you should then create `public` properties to get or set the field values.
    This is because the property then controls access. You will do this later in the
    chapter.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：明确地将一个访问修饰符应用于所有类型成员，即使你想为成员使用隐式访问修饰符，即 `private`。此外，字段通常应该是 `private`
    或 `protected`，然后创建 `public` 属性来获取或设置字段值。这是因为属性控制访问。你将在本章的后面这样做。'
- en: Setting and outputting field values
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置和输出字段值
- en: 'Now, we will use those fields in your code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在你的代码中使用这些字段：
- en: 'In `Program.cs`, after instantiating `bob`, add statements to set his name
    and date and time of birth, and then output those fields formatted nicely, as
    shown in the following code:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，在实例化 `bob` 之后，添加语句设置他的姓名和出生日期和时间，然后格式化输出这些字段，如下所示：
- en: '[PRE19]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The format code for `arg1` is one of the standard date and time formats. `D`
    means a long date format and `d` would mean a short date format. You can learn
    more about standard date and time format codes at the following link: [https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings](https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`arg1` 的格式代码是标准日期和时间格式之一。`D` 表示长日期格式，而 `d` 则表示短日期格式。你可以在以下链接中了解更多有关标准日期和时间格式代码的信息：[https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings](https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings)。'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下所示：
- en: '[PRE20]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you change the call to `ConfigureConsole` to use your local computer culture
    or a specified culture, like French in France (`"``fr-FR"`), then your output
    will look different.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将调用`ConfigureConsole`改为使用你本地的计算机文化或指定的文化，例如法国的法国文化（`"fr-FR"`），那么你的输出将看起来不同。
- en: Setting field values using object initializer syntax
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用对象初始化器语法设置字段值
- en: 'You can also initialize fields using a shorthand **object initializer** syntax
    with curly braces, which was introduced with C# 3\. Let’s see how:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用花括号简写**对象初始化器**语法来初始化字段，这是从 C# 3.0 开始引入的。让我们看看如何：
- en: 'Add statements underneath the existing code to create another new person named
    Alice. Note the different standard format code for the date and time of birth
    when writing her to the console, as shown in the following code:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有代码下方添加语句以创建另一个名为 Alice 的新人物。注意在写入控制台时，她的出生日期和时间的标准格式代码与以下代码所示的不同：
- en: '[PRE21]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We could have used string interpolation to format the output, but for long strings,
    it will wrap over multiple lines, which can be harder to read in a printed book.
    In the code examples in this book, remember that `{0}` is a placeholder for `arg0`,
    and so on.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用字符串插值来格式化输出，但对于长字符串，它将在多行中换行，这在打印的书中可能更难阅读。在本书的代码示例中，请记住 `{0}` 是 `arg0`
    的占位符，依此类推。
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下所示：
- en: '[PRE22]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Good practice**: Use named parameters to pass arguments, so it is clearer
    what the values mean, especially for types like `DateTimeOffset` where there are
    a bunch of numbers one after the other.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：使用命名参数传递参数，这样更清楚地知道这些值的含义，特别是对于像`DateTimeOffset`这样的类型，其中有一系列数字连续出现。'
- en: Storing a value using an enum type
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用枚举类型存储值
- en: Sometimes, a value needs to be one of a limited set of options. For example,
    there are seven ancient wonders of the world, and a person may have one favorite.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个值需要是有限选项集中的一个。例如，有七个古代世界奇迹，一个人可能有一个最喜欢的。
- en: At other times, a value needs to be a combination of a limited set of options.
    For example, a person may have a bucket list of ancient world wonders they want
    to visit. We can store this data by defining an `enum` type.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他时候，一个值可能需要是有限选项集的组合。例如，一个人可能有他们想要参观的古代世界奇迹的愿望清单。我们可以通过定义`enum`类型来存储这些数据。
- en: 'An `enum` type is a very efficient way of storing one or more choices because,
    internally, it uses integer values in combination with a lookup table of `string`
    descriptions. Let’s see an example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`类型是一种非常高效的存储一个或多个选择的方法，因为它在内部使用整数值与`string`描述的查找表的组合。让我们看看一个例子：'
- en: Add a new file to the `PacktLibraryNet2` project named `WondersOfTheAncientWorld.cs`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`PacktLibraryNet2`项目添加一个名为`WondersOfTheAncientWorld.cs`的新文件。
- en: 'Modify the `WondersOfTheAncientWorld.cs` contents, as shown in the following
    code:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`WondersOfTheAncientWorld.cs`的内容，如下所示：
- en: '[PRE23]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In `Person.cs`, define a field to store a person’s favorite ancient world wonder,
    as shown in the following code:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，定义一个字段来存储一个人的最喜欢的古代世界奇迹，如下所示：
- en: '[PRE24]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In `Program.cs`, set Bob’s favorite ancient wonder of the world and output
    it, as shown in the following code:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，设置Bob最喜欢的古代世界奇迹并输出，如下所示：
- en: '[PRE25]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`PeopleApp`项目并查看结果，如下所示：
- en: '[PRE26]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `enum` value is internally stored as an `int` for efficiency. The `int`
    values are automatically assigned, starting at `0`, so the third world wonder
    in our `enum` has a value of `2`. You can assign `int` values that are not listed
    in the `enum`. They will output as the `int` value instead of a name since a match
    will not be found.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`值在内部以`int`的形式存储以提高效率。`int`值自动分配，从`0`开始，所以我们在`enum`中的第三个世界奇迹有一个值为`2`。你可以分配`enum`中没有列出的`int`值。它们将输出为`int`值而不是名称，因为找不到匹配项。'
- en: Storing multiple values using an enum type
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`enum`类型存储多个值
- en: 'For the bucket list, we could create an array or collection of instances of
    the `enum`, and collections as fields will be shown later in this chapter, but
    there is a better approach for this scenario. We can combine multiple choices
    into a single value using `enum` flags. Let’s see how:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于愿望清单，我们可以创建一个`enum`实例的数组或集合，集合作为字段将在本章后面介绍，但针对这种情况有一个更好的方法。我们可以使用`enum`标志将多个选择组合成一个值。让我们看看如何：
- en: 'Modify the `enum` by decorating it with the `[Flags]` attribute, and explicitly
    set a `byte` value for each wonder that represents different bit columns, as highlighted
    in the following code:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`[Flags]`属性装饰`enum`，并显式为每个奇迹设置代表不同位列的`byte`值，修改`enum`，如下所示：
- en: '[PRE27]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The integer types that an `enum` is allowed to inherit from are `Byte`, `SByte`,
    `Int16`, `Int32`, `Int64`, `UInt16`, `UInt32`, and `UInt64`. The new integer types
    `Int128` and `UInt128` are not supported.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`可以继承的整数类型有`Byte`、`SByte`、`Int16`、`Int32`、`Int64`、`UInt16`、`UInt32`和`UInt64`。新的整数类型`Int128`和`UInt128`不受支持。'
- en: We assign explicit values for each choice that will not overlap when looking
    at the bits stored in memory. We should also decorate the `enum` type with the
    `System.Flags` attribute so that when the value is returned, it can automatically
    match with multiple values as a comma-separated `string` instead of returning
    an `int` value.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个选择分配显式值，这些值在查看内存中存储的位时不会重叠。我们还应该使用`System.Flags`属性装饰`enum`类型，以便当返回值时，它可以自动与多个值匹配，作为以逗号分隔的`string`，而不是返回`int`值。
- en: Normally, an `enum` type uses an `int` variable internally, but since we don’t
    need values that big, we can reduce memory requirements by 75%, that is, 1 byte
    per value instead of 4 bytes, by telling it to use a `byte` variable. As another
    example, if you wanted to define an `enum` for days of the week, there will only
    ever be seven of them.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`enum`类型在内部使用`int`变量，但由于我们不需要那么大的值，我们可以通过将其告知使用`byte`变量来减少内存需求，即每个值1字节而不是4字节。例如，如果你想要定义一个表示一周中每一天的`enum`，那么将只有七个值。
- en: 'If we want to indicate that our bucket list includes the *Hanging Gardens of
    Babylon* and the *Mausoleum at Halicarnassus* ancient world wonders, then we would
    want the `16` and `2` bits set to `1`. In other words, we would store the value
    `18`, as shown in *Table 5.2*:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想表明我们的愿望清单包括了**巴比伦空中花园**和**哈利卡纳苏斯的陵墓**这些古代世界的奇迹，那么我们希望将`16`和`2`位设置为`1`。换句话说，我们将存储值`18`，如*表5.2*所示：
- en: '| 64 | 32 | 16 | 8 | 4 | 2 | 1 |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 64 | 32 | 16 | 8 | 4 | 2 | 1 |'
- en: '| 0 | 0 | 1 | 0 | 0 | 1 | 0 |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 0 | 0 | 1 | 0 |'
- en: 'Table 5.2: Storing 18 as bits in an enum'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.2：在枚举中用位存储18
- en: 'In `Person.cs`, leave the existing field to store a single favorite ancient
    world wonder and add the following statement to your list of fields to store multiple
    ancient world wonders:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 中，保留现有的字段以存储单个最喜欢的古代世界奇迹，并添加以下语句到您的字段列表中，以存储多个古代世界奇迹：
- en: '[PRE28]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In `Program.cs`, add statements to set the bucket list using the `|` operator
    (the bitwise logical `OR`) to combine the `enum` values. We could also set the
    value using the number `18` cast into the `enum` type, as shown in the comment,
    but we shouldn’t because that would make the code harder to understand, as shown
    in the following code:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加语句使用 `|` 运算符（位逻辑或）来组合枚举值。我们也可以使用将数字 `18` 强制转换为枚举类型的值来设置该值，如注释所示，但我们不应该这样做，因为这会使代码更难以理解，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看以下输出结果：
- en: '[PRE30]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Good practice**: Use the `enum` values to store combinations of discrete
    options. Derive an `enum` type from `byte` if there are up to eight options, from
    `ushort` if there are up to 16 options, from `uint` if there are up to 32 options,
    and from `ulong` if there are up to 64 options.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：使用枚举值来存储离散选项的组合。如果有最多八个选项，则从 `byte` 派生枚举类型；如果有最多16个选项，则从 `ushort`
    派生；如果有最多32个选项，则从 `uint` 派生；如果有最多64个选项，则从 `ulong` 派生。'
- en: Now that we have decorated the `enum` with the `[Flags]` attribute, combinations
    of values can be stored in a single variable or field. Now, a programmer could
    store a combination of values in the `FavoriteAncientWonder` too when it should
    only store one value. To enforce this, we should convert the field into a property
    that allows us to take control over how other programmers can get and set the
    value. You will see how to do this later in this chapter.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经用 `[Flags]` 属性装饰了 `enum`，值的组合可以存储在一个单独的变量或字段中。现在，当应该只存储一个值时，程序员也可以在 `FavoriteAncientWonder`
    中存储值的组合。为了强制执行这一点，我们应该将字段转换为属性，这样我们就可以控制其他程序员如何获取和设置值。您将在本章后面看到如何做到这一点。
- en: Changing an enum base type for performance
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变枚举基类型以提高性能
- en: The preceding section was about storing multiple values using an `enum` type.
    It’s about `enum` types decorated with the `[Flags]` attribute that use bitwise
    operations to efficiently store those multiple values. In the code example, we
    defined an `enum` for the Seven Wonders of the Ancient World, so it only needed
    seven combinable values (and `0` for `None`).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节是关于使用枚举类型存储多个值。这是关于带有 `[Flags]` 属性的枚举类型，它们使用位操作有效地存储这些多个值。在代码示例中，我们定义了一个用于古代世界七大奇迹的枚举，因此只需要七个可组合的值（以及
    `0` 表示 `None`）。
- en: The preceding section was not about making all your `enum` types derive from
    `byte` to make your code faster because that would be bad advice.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节并不是关于将所有枚举类型派生为 `byte` 以使您的代码更快，因为这将是糟糕的建议。
- en: 'On March 18, 2024, Nick Chapsas posted a YouTube video titled, *Turn All Your
    Enums Into Bytes Now! | Code Cop #014*, which you can watch at the following link:
    [https://www.youtube.com/watch?v=1gWzE9SIGkQ](https://www.youtube.com/watch?v=1gWzE9SIGkQ).
    He criticized blog articles that recommend changing the default base integer type
    of `enum` types from `int` to `byte` to improve performance.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '在2024年3月18日，尼克·查帕斯（Nick Chapsas）发布了一个YouTube视频，标题为 *Turn All Your Enums Into
    Bytes Now! | Code Cop #014*，您可以通过以下链接观看：[https://www.youtube.com/watch?v=1gWzE9SIGkQ](https://www.youtube.com/watch?v=1gWzE9SIGkQ)。他批评了一些博客文章，这些文章建议将枚举类型的默认基整数类型从
    `int` 改为 `byte` 以提高性能。'
- en: The original designers of the C# language spent effort on implementing the ability
    for `enum` types to derive from other integers than just the default `int`. For
    example, you can use fewer bytes by using a positive integer like `byte` or `ushort`,
    or the same or more bytes by using a positive integer like `uint` or `ulong`.
    They implemented this feature because sometimes a .NET developer will need this
    capability.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: C#语言的原始设计者花费了努力来实现枚举类型可以从除了默认的 `int` 之外的其他整数类型派生的能力。例如，您可以通过使用正整数如 `byte` 或
    `ushort` 来使用更少的字节，或者使用正整数如 `uint` 或 `ulong` 来使用相同或更多的字节。他们实现了这个特性，因为有时.NET开发者将需要这种能力。
- en: 'I think it is important that my readers know that they can do it when necessary.
    Microsoft’s official guidance states, “Even though you can change this underlying
    type, it is not necessary or recommended for most scenarios. No significant performance
    gain is achieved by using a data type that is smaller than `Int32`.”, as you can
    read at the following link: [https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca1028](https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca1028).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为让我的读者知道在必要时他们可以这样做是很重要的。微软的官方指南指出，“尽管你可以更改此基础类型，但在大多数情况下并不必要或推荐这样做。使用小于 `Int32`
    的数据类型并不会带来显著的性能提升。”，正如你可以在以下链接中阅读的那样：[https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca1028](https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca1028)。
- en: 'For those developers who object to changing any `enum` from `int` to some other
    integer, there is a compiler code analysis warning that I linked to above. If
    enabled, it will trigger if you set an `enum` to anything other than `int`: “CA1028:
    Enum storage should be Int32.” This warning is not enabled by default because
    Microsoft knows that there are legitimate reasons why a developer might need to
    use it.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '对于那些反对将任何 `enum` 从 `int` 更改为其他整数的开发者，编译器代码分析警告如上所述。如果启用，当将 `enum` 设置为除 `int`
    之外的内容时，它将触发：“CA1028: `enum` 存储应该是 Int32。”此警告默认未启用，因为微软知道开发者可能有合法的理由需要使用它。'
- en: 'Let’s see some real-life examples of when you would need to change an `enum`
    from deriving from `int` to deriving from another integer type:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些现实生活中的例子，说明你为什么需要将 `enum` 从派生自 `int` 改为派生自其他整数类型：
- en: 'You want to increase the size of the integer to store more than 16 options
    in a flag `enum`. The default `int` only allows 16 options: 0, 1, 2, 4, 8, 16,
    32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, and 16384\. Changing to `uint`
    would double the number of choices to 32 without using any more space in memory.
    Changing to `ulong` would give 64 options. Changing to `ushort` would allow the
    same 16 options in half the bytes.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想增加整数的尺寸，以便在标志 `enum` 中存储超过 16 个选项。默认的 `int` 只允许 16 个选项：0, 1, 2, 4, 8, 16,
    32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 和 16384。改为 `uint` 会将选择数量加倍到 32，而不会占用更多内存空间。改为
    `ulong` 会提供 64 个选项。改为 `ushort` 会允许在半字节的相同 16 个选项。
- en: You need to transfer data as a binary stream via a serial connection to an embedded
    device and you must carefully follow the protocol, or you are defining your own
    serial messaging protocol, and you want to reduce the packet size to make the
    best use of your available bandwidth.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要通过串行连接将数据作为二进制流传输到嵌入式设备，并且必须仔细遵循协议，或者你正在定义自己的串行消息协议，并且你希望减小数据包大小以充分利用可用带宽。
- en: 'You have SQL tables with millions of records where some of the columns are
    `enum` values. Setting those columns to `tinyint` with a matching `enum` : `byte`
    property in the C# entity class can make indexes perform better by being smaller
    and reducing the number of page reads from disk. Some developers will work on
    systems that are 30 or more years old with spinning metal disks. Not everyone
    is deploying to a modern 64-bit OS with modern hardware.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '你有包含数百万条记录的 SQL 表，其中一些列是 `enum` 值。将这些列设置为 `tinyint`，并在 C# 实体类中匹配 `enum` : `byte`
    属性，可以使索引通过变得更小并减少从磁盘读取的页面数来提高性能。一些开发者会处理 30 年或更老的系统，这些系统使用旋转金属磁盘。并不是每个人都部署到现代
    64 位操作系统和现代硬件上。'
- en: You need to reduce the size of a `struct` because it will be created 100,000
    times per second on resource-constrained hardware, or you have game code that
    is set to use `byte` and `short` because you have millions of them in contiguous
    arrays for the game’s data. You would gain a fair bit of performance doing this,
    especially from a cache point of view.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要减小 `struct` 的大小，因为它将在资源受限的硬件上每秒创建 100,000 次，或者你有游戏代码设置为使用 `byte` 和 `short`，因为你有为游戏数据在连续数组中有数百万个它们。这样做可以获得相当大的性能提升，尤其是在缓存方面。
- en: Now, let’s see how to store multiple values using collections.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用集合存储多个值。
- en: Storing multiple values using collections
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用集合存储多个值
- en: 'Let’s now add a field to store a person’s children. This is an example of aggregation
    because children are instances of a class that is related to the current person,
    but they are not part of the person itself. We will use a generic `List<T>` collection
    type that can store an ordered collection of any type. You will learn more about
    collections in *Chapter 8*, *Working with Common .NET Types*. For now, just follow
    along:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个字段来存储一个人的孩子。这是一个聚合的例子，因为孩子是相关于当前人的类的实例，但它们不是人本身的一部分。我们将使用可以存储任何类型有序集合的泛型
    `List<T>` 集合类型。你将在 *第 8 章*，*使用常见的 .NET 类型* 中了解更多关于集合的内容。现在，只需按照以下步骤操作：
- en: 'In `Person.cs`, declare a new field to store multiple `Person` instances that
    represent the children of this person, as shown in the following code:'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 文件中，声明一个新的字段来存储代表此人的多个 `Person` 实例，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`List<Person>` is read aloud as “list of `Person`,” for example, “the type
    of the property named `Children` is a list of `Person` instances.”'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<Person>` 读作“`Person` 的列表”，例如，“名为 `Children` 的属性类型是 `Person` 实例的列表。”'
- en: We must ensure the collection is initialized to a new instance before we can
    add items to it; otherwise, the field will be `null` and throw runtime exceptions
    when we try to use any of its members, like `Add`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向集合中添加项目之前，必须确保集合被初始化为一个新的实例；否则，该字段将为 `null`，并在我们尝试使用其任何成员（如 `Add`）时抛出运行时异常。
- en: Understanding generic collections
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解泛型集合
- en: The angle brackets in the `List<T>` type is a feature of C# called **generics**
    that was introduced in 2005 with C# 2\. It’s a fancy term for making a collection
    **strongly typed**, that is, the compiler knows specifically what type of object
    can be stored in the collection. Generics improve the performance and correctness
    of your code.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<T>` 类型中的尖括号是 C# 中称为 **泛型** 的特性，该特性于 2005 年随 C# 2.0 引入。这是一个用于创建 **强类型**
    集合的术语，即编译器知道可以存储在集合中的特定类型的对象。泛型可以提高代码的性能和正确性。'
- en: '**Strongly typed** has a different meaning than **statically typed**. The old
    `System.Collection` types are statically typed to contain weakly typed `System.Object`
    items. The newer `System.Collection.Generic` types are statically typed to contain
    strongly typed `<T>` instances.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**强类型** 与 **静态类型** 有不同的含义。旧的 `System.Collection` 类型是静态类型，用于包含弱类型的 `System.Object`
    项目。较新的 `System.Collection.Generic` 类型是静态类型，用于包含强类型的 `<T>` 实例。'
- en: Ironically, the term *generics* means we can use a more specific static type!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 具有讽刺意味的是，术语 *泛型* 意味着我们可以使用更具体的静态类型！
- en: 'In `Program.cs`, add statements to add three children for `Bob`, and then show
    how many children he has and what their names are, as shown in the following code:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加语句为 `Bob` 添加三个孩子，然后显示他有多少孩子以及他们的名字，如下面的代码所示：
- en: '[PRE32]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下面的输出所示：
- en: '[PRE33]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We could also use a `foreach` statement to enumerate over the collection. As
    an optional challenge, change the `for` statement to output the same information
    using `foreach`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 `foreach` 语句遍历集合。作为一个可选挑战，将 `for` 语句改为使用 `foreach` 输出相同的信息。
- en: Making a field static
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使字段成为静态
- en: The fields that we have created so far have all been **instance** members, meaning
    that a different value of each field exists for each instance of the class that
    is created. The `alice` and `bob` variables have different `Name` values.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止创建的字段都是 **实例成员**，这意味着每个创建的类的每个字段都有一个不同的值。`alice` 和 `bob` 变量有不同的 `Name`
    值。
- en: Sometimes, you want to define a field that only has one value that is shared
    across all instances.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你想要定义一个字段，该字段只有一个值，这个值在所有实例之间共享。
- en: These are called **static members** because fields are not the only members
    that can be static. Let’s see what can be achieved using `static` fields using
    a bank account as an example. Each instance of `BankAccount` will have its own
    `AccountName` and `Balance` values, but all instances will share a single `InterestRate`
    value.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这些被称为 **静态成员**，因为字段不是唯一可以静态的成员。让我们以银行账户为例，看看使用 `static` 字段可以实现什么。`BankAccount`
    的每个实例都将有自己的 `AccountName` 和 `Balance` 值，但所有实例将共享一个单一的 `InterestRate` 值。
- en: 'Let’s do it:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们动手做：
- en: In the `PacktLibraryNet2` project, add a new class file named `BankAccount.cs`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PacktLibraryNet2` 项目中，添加一个名为 `BankAccount.cs` 的新类文件。
- en: 'Modify the class to give it three fields – two instance fields and one static
    field – as shown in the following code:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改类，使其具有三个字段——两个实例字段和一个静态字段——如下面的代码所示：
- en: '[PRE34]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In `Program.cs`, add statements to set the shared interest rate, and then create
    two instances of the `BankAccount` type, as shown in the following code:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加语句来设置共享利率，然后创建两个 `BankAccount` 类型的实例，如下面的代码所示：
- en: '[PRE35]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Run the `PeopleApp` project and view the additional output:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看附加输出：
- en: '[PRE36]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Remember that `C` is a format code that tells .NET to use the current culture’s
    currency format for the decimal numbers.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 `C` 是一个格式代码，它告诉 .NET 使用当前文化的货币格式来格式化十进制数字。
- en: Fields are not the only members that can be static. Constructors, methods, properties,
    and other members can also be static.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 字段不是唯一可以静态的成员。构造函数、方法、属性和其他成员也可以是静态的。
- en: Static methods do not need an object instance to be called. For example, `Console.WriteLine`
    does not need an object instance; the method is called directly from the class
    name. Static methods are covered in *Chapter 6, Implementing Interfaces and Inheriting
    Classes*.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法不需要对象实例即可调用。例如，`Console.WriteLine` 不需要对象实例；方法直接从类名调用。静态方法在 *第 6 章，实现接口和继承类*
    中介绍。
- en: Making a field constant
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将字段设置为常量
- en: 'If the value of a field will never change, you can use the `const` keyword
    and assign a literal value at compile time. Any statement that changes the value
    will cause a compile-time error. Let’s see a simple example:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个字段的值永远不会改变，你可以使用 `const` 关键字并在编译时分配一个字面量值。任何更改该值的语句都会导致编译时错误。让我们看看一个简单的例子：
- en: 'In `Person.cs`, add a `string` constant for the species of a person, as shown
    in the following code:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 文件中，添加一个表示人的物种的 `string` 常量，如下面的代码所示：
- en: '[PRE37]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To get the value of a constant field, you must write the name of the class,
    not the name of an instance of the class. In `Program.cs`, add a statement to
    write Bob’s name and species to the console, as shown in the following code:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取常量字段的值，你必须写出类的名称，而不是类的实例名称。在 `Program.cs` 文件中，添加一个语句将鲍勃的名字和物种写入控制台，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下面的输出所示：
- en: '[PRE39]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Examples of `const` fields in Microsoft types include `System.Int32.MaxValue`
    and `System.Math.PI` because neither value will ever change, as you can see in
    *Figure 5.2*:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft 类型中 `const` 字段的示例包括 `System.Int32.MaxValue` 和 `System.Math.PI`，因为这两个值永远不会改变，如
    *图 5.2* 所示：
- en: '![](img/B22322_05_02.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_05_02.png)'
- en: 'Figure 5.2: Examples of constants in the System.Math class'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：System.Math 类中常量的示例
- en: '**Good practice**: Constants are not always the best choice for two important
    reasons: the value must be known at compile time, and it must be expressible as
    a literal `string`, `Boolean`, or number value. Every reference to the `const`
    field is replaced with the literal value at compile time, which will, therefore,
    not be reflected if the value changes in a future version and you do not recompile
    any assemblies that reference it to get the new value.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：常量并不总是最佳选择，有两个重要原因：值必须在编译时已知，并且必须可以用字面量 `string`、`Boolean` 或数字值表示。对
    `const` 字段的每个引用在编译时都会被替换为字面量值，因此，如果值在未来版本中更改，并且你没有重新编译引用它的任何程序集以获取新值，则将不会反映出来。'
- en: Making a field read-only
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将字段设置为只读
- en: 'Often, a better choice for fields that should not change is to mark them as
    read-only:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不应更改的字段，通常更好的选择是将它们标记为只读：
- en: 'In `Person.cs`, add a statement to declare an instance read-only field to store
    a person’s home planet, as shown in the following code:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 文件中，添加一个语句来声明一个实例只读字段以存储一个人的家乡星球，如下面的代码所示：
- en: '[PRE40]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In `Program.cs`, add a statement to write Bob’s name and home planet to the
    console, as shown in the following code:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加一个语句将鲍勃的名字和家乡星球写入控制台，如下面的代码所示：
- en: '[PRE41]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下面的输出所示：
- en: '[PRE42]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**Good practice**: Use read-only fields over constant fields for two important
    reasons: the value can be calculated or loaded at runtime and can be expressed
    using any executable statement. So, a read-only field can be set using a constructor
    or a field assignment. Every reference to the read-only field is a live reference,
    so any future changes will be correctly reflected by the calling code.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：与常量字段相比，使用只读字段有两个重要原因：值可以在运行时计算或加载，并且可以使用任何可执行语句表示。因此，只读字段可以使用构造函数或字段赋值来设置。对只读字段的每个引用都是一个活动引用，因此任何未来的更改都将被调用代码正确地反映出来。'
- en: You can also declare `static` `readonly` fields whose values will be shared
    across all instances of the type.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以声明`static` `readonly`字段，其值将在类型的所有实例之间共享。
- en: Requiring fields to be set during instantiation
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在实例化时要求字段必须设置
- en: 'C# 11 introduced the `required` modifier. If you use it on a field or property,
    the compiler will ensure that you set the field or property to a value when you
    instantiate it. It requires targeting .NET 7 or later, so we need to create a
    new class library first:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: C# 11引入了`required`修饰符。如果你在字段或属性上使用它，编译器将确保你在实例化时将该字段或属性设置为值。它需要目标.NET 7或更高版本，因此我们需要首先创建一个新的类库：
- en: In the `Chapter05` solution, add a new class library project named `PacktLibraryModern`
    that targets .NET 9\. (The oldest supported version for the `required` modifier
    is .NET 7.)
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter05`解决方案中，添加一个名为`PacktLibraryModern`的新类库项目，目标为.NET 9。（`required`修饰符支持的最旧版本是.NET
    7。）
- en: In the `PacktLibraryModern` project, rename `Class1.cs` to `Book.cs`.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibraryModern`项目中，将`Class1.cs`重命名为`Book.cs`。
- en: 'Modify the code file contents to give the class four fields, with two set as
    `required`, as shown in the following code:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改代码文件内容，给类添加四个字段，其中两个设置为`required`，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that all `three` string properties are nullable. Setting a property or
    field to be `required` does not mean that it cannot be `null`. It just means that
    it must be explicitly set to `null`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 注意所有`三个`字符串属性都是可空的。将属性或字段设置为`required`并不意味着它不能是`null`。它只是意味着它必须显式设置为`null`。
- en: 'In the `PeopleApp` console app project, add a reference to the `PacktLibraryModern`
    class library project:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PeopleApp`控制台应用程序项目中，添加对`PacktLibraryModern`类库项目的引用：
- en: If you use Visual Studio, then in **Solution Explorer**, select the `PeopleApp`
    project, navigate to **Project** | **Add Project Reference…**, check the box to
    select the `PacktLibraryModern` project, and then click **OK**.
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用Visual Studio，那么在**解决方案资源管理器**中，选择`PeopleApp`项目，导航到**项目** | **添加项目引用…**，勾选复选框以选择`PacktLibraryModern`项目，然后点击**确定**。
- en: 'If you use VS Code, then edit `PeopleApp.csproj` to add a project reference
    to `PacktLibraryModern`, as highlighted in the following markup:'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用VS Code，那么编辑`PeopleApp.csproj`以添加对`PacktLibraryModern`的引用，如下面的标记所示：
- en: '[PRE44]'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Build the `PeopleApp` project. This will compile its referenced dependencies
    and copy the class library `.dll` to the correct subdirectory in the local `bin`
    folder.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目`PeopleApp`。这将编译其引用的依赖项，并将类库`.dll`复制到本地`bin`文件夹的正确子目录中。
- en: 'In the `PeopleApp` project, in `Program.cs`, attempt to instantiate a `Book`
    without setting the `Isbn` and `Title` fields, as shown in the following code:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PeopleApp`项目中的`Program.cs`中，尝试不设置`Isbn`和`Title`字段来实例化`Book`，如下面的代码所示：
- en: '[PRE45]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Note that you will see a compiler error, as shown in the following output:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意你将看到编译器错误，如下面的输出所示：
- en: '[PRE46]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In `Program.cs`, modify the statement to set the two required properties using
    object initialization syntax, as highlighted in the following code:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，修改语句以使用对象初始化语法设置两个必需的属性，如下面的代码所示：
- en: '[PRE47]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note that the statement now compiles without errors.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意现在这个语句可以无错误地编译。
- en: 'In `Program.cs`, add a statement to output information about the book, as shown
    in the following code:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以输出有关书籍的信息，如下面的代码所示：
- en: '[PRE48]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Before we run the project and view the output, let’s talk about an alternative
    way that we could initialize fields (or properties) for a type.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行项目并查看输出之前，让我们讨论一种初始化类型字段（或属性）的替代方法。
- en: Initializing fields with constructors
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用构造函数初始化字段
- en: 'Fields often need to be initialized at runtime. You can do this in a constructor
    that will be called when you make an instance of a class using the `new` keyword.
    Constructors execute before any fields are set by the code that uses the type:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 字段通常需要在运行时进行初始化。你可以在使用`new`关键字创建类的实例时调用的构造函数中这样做。构造函数在代码设置任何字段之前执行：
- en: 'In `Person.cs`, add statements after the existing read-only `HomePlanet` field
    to define a second read-only field, and then set the `Name` and `Instantiated`
    fields in a constructor, as highlighted in the following code:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，在现有的只读`HomePlanet`字段之后添加语句以定义第二个只读字段，然后在构造函数中设置`Name`和`Instantiated`字段，如下面的代码所示：
- en: '[PRE49]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In `Program.cs`, add statements to instantiate a new person and then output
    its initial field values, as shown in the following code:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以实例化一个新的`Person`对象，然后输出其初始字段值，如下面的代码所示：
- en: '[PRE50]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Run the `PeopleApp` project and view the result from both the code about the
    book as well as the blank person, as shown in the following output:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`PeopleApp`项目并查看关于书籍以及空白人物的代码结果，如下所示输出：
- en: '[PRE51]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Defining multiple constructors
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义多个构造函数
- en: 'You can have multiple constructors in a type. This is especially useful to
    encourage developers to set initial values for fields:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在一个类型中拥有多个构造函数。这特别有用，可以鼓励开发者为字段设置初始值：
- en: 'In `Person.cs`, add statements to define a second constructor that allows a
    developer to set initial values for the person’s name and home planet, as shown
    in the following code:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，添加定义第二个构造函数的语句，允许开发者为人的姓名和家园行星设置初始值，如下所示代码：
- en: '[PRE52]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In `Program.cs`, add statements to create another person using the constructor
    with two parameters, as shown in the following code:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加使用两个参数的构造函数创建另一个人的语句，如下所示代码：
- en: '[PRE53]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Run the `PeopleApp` project and view the result:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`PeopleApp`项目并查看结果：
- en: '[PRE54]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Setting required fields with a constructor
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用构造函数设置必需字段
- en: 'Now, let’s return to the `Book` class example with its `required` fields:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到具有`required`字段的`Book`类示例：
- en: 'In the `PacktLibraryModern` project, in `Book.cs`, add statements to define
    a pair of constructors, one that supports object initializer syntax and one to
    set the two required properties, as highlighted in the following code:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibraryModern`项目中，在`Book.cs`中，添加定义一对构造函数的语句，一个支持对象初始化器语法，另一个用于设置两个必需属性，如下所示代码：
- en: '[PRE55]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In `Program.cs`, comment out the statement that instantiates a book using object
    initializer syntax, add a statement to instantiate a book using the constructor,
    and then set the non-`required` properties for the book, as highlighted in the
    following code:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，注释掉使用对象初始化器语法实例化书籍的语句，添加一个使用构造函数实例化书籍的语句，然后设置书籍的非`required`属性，如下所示代码：
- en: '[PRE56]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note that you will see a compiler error as before because the compiler cannot
    automatically tell that calling the constructor will have set the two `required`
    properties.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，你将看到与之前相同的编译器错误，因为编译器无法自动判断调用构造函数是否会设置这两个`required`属性。
- en: 'In the `PacktLibraryModern` project, in `Book.cs`, import the namespace to
    perform code analysis and then decorate the constructor with the attribute to
    tell the compiler that it sets all the required properties and fields, as highlighted
    in the following code:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibraryModern`项目中，在`Book.cs`中，导入命名空间以执行代码分析，然后使用属性装饰构造函数，告诉编译器它设置了所有必需属性和字段，如下所示代码：
- en: '[PRE57]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In `Program.cs`, note the statement that calls the constructor now compiles
    without errors.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，注意现在调用构造函数的语句可以无错误地编译。
- en: 'Optionally, run the `PeopleApp` project to confirm it behaves as expected,
    as shown in the following output:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，运行`PeopleApp`项目以确认其行为符合预期，如下所示输出：
- en: '[PRE58]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '**More information**: You can learn more about `required` fields and how to
    set them using a constructor at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/required](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/required).'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：你可以在以下链接中了解更多关于`required`字段以及如何使用构造函数设置它们的信息：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/required](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/required)。'
- en: Constructors are a special category of method. Let’s look at methods in more
    detail.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是方法的一种特殊类别。让我们更详细地看看方法。
- en: Working with methods and tuples
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与方法和元组一起工作
- en: '**Methods** are members of a type that execute a block of statements. They
    are functions that belong to a type.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法**是类型的成员，执行一组语句。它们是属于类型的函数。'
- en: Returning values from methods
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从方法返回值
- en: 'Methods can return a single value or nothing:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 方法可以返回单个值或无返回值：
- en: A method that performs some actions but does not return a value indicates this
    with the `void` type before the name of the method.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行某些操作但不返回值的函数通过在方法名称之前使用`void`类型来表示。
- en: A method that performs some actions and returns a value indicates this with
    the type of the return value before the name of the method.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行某些操作并返回值的函数通过在方法名称之前返回值的类型来表示。
- en: 'For example, in the next task, you will create two methods:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下一个任务中，你将创建两个方法：
- en: '`WriteToConsole`: This will perform an action (writing some text to the console),
    but it will return nothing from the method, indicated by the `void` keyword.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WriteToConsole`：这将执行一个操作（将一些文本写入控制台），但方法将不返回任何内容，这由`void`关键字表示。'
- en: '`GetOrigin`: This will return a text value, indicated by the `string` keyword.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetOrigin`：这将返回一个由 `string` 关键字指示的文本值。'
- en: 'Let’s write the code:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写代码：
- en: 'In `Person.cs`, add statements to define the two methods that I described earlier,
    as shown in the following code:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 文件中，添加语句来定义我之前描述的两个方法，如下面的代码所示：
- en: '[PRE59]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In `Program.cs`, add statements to call the two methods, as shown in the following
    code:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加语句来调用两个方法，如下面的代码所示：
- en: '[PRE60]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下面的输出所示：
- en: '[PRE61]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Defining and passing parameters to methods
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和传递方法参数
- en: 'Methods can have parameters passed to them to change their behavior. Parameters
    are defined a bit like variable declarations but inside the parentheses of the
    method declaration, as you saw earlier in this chapter with constructors. Let’s
    see more examples:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 方法可以通过传递参数来改变其行为。参数的定义有点像变量声明，但位于方法声明的括号内，就像你在本章前面看到的构造函数一样。让我们看看更多的例子：
- en: 'In `Person.cs`, add statements to define two methods, the first without parameters
    and the second with one parameter, as shown in the following code:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 文件中，添加语句来定义两个方法，第一个不带参数，第二个带一个参数，如下面的代码所示：
- en: '[PRE62]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In `Program.cs`, add statements to call the two methods, and write the return
    value to the console, as shown in the following code:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加语句来调用两个方法，并将返回值写入控制台，如下面的代码所示：
- en: '[PRE63]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Run the `PeopleApp` project and view the result:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果：
- en: '[PRE64]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: When typing a statement that calls a method, IntelliSense shows a tooltip with
    the name, the type of any parameters, and the return type of the method.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 当你键入调用方法的语句时，IntelliSense 会显示一个工具提示，显示方法名称、任何参数的类型以及方法的返回类型。
- en: Overloading methods
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重载方法
- en: Instead of having two different method names, we could give both methods the
    same name. This is allowed because the methods each have a different signature.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是有两个不同的方法名称，我们可以给这两个方法相同的名称。这是允许的，因为每个方法都有不同的签名。
- en: 'A **method signature** is a list of parameter types that can be passed when
    calling the method. Overloaded methods must differ in their list of parameter
    types. Two overloaded methods cannot have the same list of parameter types and
    differ only in their return types. Let’s code an example:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法签名**是一组可以在调用方法时传递的参数类型。重载方法必须在参数类型列表上有所不同。两个重载方法不能有相同的参数类型列表，并且仅在返回类型上有所不同。让我们通过一个示例来编写代码：'
- en: In `Person.cs`, change the name of the `SayHelloTo` method to `SayHello`.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 文件中，将 `SayHelloTo` 方法的名称更改为 `SayHello`。
- en: 'In `Program.cs`, change the method call to use the `SayHello` method, and note
    that the quick info for the method tells you that it has an additional overload,
    **1 of 2**, as well as **2 of 2**, in Visual Studio, although other code editors
    may be different, as shown in *Figure 5.3*:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，将方法调用更改为使用 `SayHello` 方法，并注意方法快速信息告诉你它有一个额外的重载，**1 of 2**，以及
    **2 of 2**，在 Visual Studio 中，尽管其他代码编辑器可能不同，如图 *5.3* 所示：
- en: '![](img/B22322_05_03.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_05_03.png)'
- en: 'Figure 5.3: An IntelliSense tooltip for an overloaded method'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：一个重载方法的 IntelliSense 工具提示
- en: '**Good practice**: Use overloaded methods to simplify your class by making
    it appear to have fewer methods.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：使用重载方法通过使类看起来有更少的方法来简化你的类。'
- en: Passing optional parameters
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递可选参数
- en: Another way to simplify methods is to make parameters optional. You make a parameter
    optional by assigning a default value inside the method parameter list. Optional
    parameters must always come last in the list of parameters.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 简化方法的另一种方法是使参数可选。你通过在方法参数列表中分配默认值来使参数可选。可选参数必须始终位于参数列表的末尾。
- en: 'We will now create a method with three optional parameters:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个有三个可选参数的方法：
- en: 'In `Person.cs`, add statements to define the method, as shown in the following
    code:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 文件中，添加语句来定义方法，如下面的代码所示：
- en: '[PRE65]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In `Program.cs`, add a statement to call the method and write its return value
    to the console, as shown in the following code:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加语句来调用方法，并将返回值写入控制台，如下面的代码所示：
- en: '[PRE66]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Watch IntelliSense appear as you type the code. You will see a tooltip showing
    the three optional parameters with their default values.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你键入代码时，IntelliSense 会显示出来。你会看到一个工具提示，显示三个带有默认值的可选参数。
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下面的输出所示：
- en: '[PRE67]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In `Program.cs`, add a statement to pass a `string` value for the `command`
    parameter and a `double` value for the `number` parameter, as shown in the following
    code:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加一条语句以传递 `command` 参数的 `string` 值和 `number` 参数的 `double`
    值，如下面的代码所示：
- en: '[PRE68]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Run the `PeopleApp` project and see the result, as shown in the following output:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下面的输出所示：
- en: '[PRE69]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The default values for the `command` and `number` parameters have been replaced,
    but the default for `active` is still `true`.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`command` 和 `number` 参数的默认值已被替换，但 `active` 的默认值仍然是 `true`。'
- en: Naming parameter values when calling methods
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用方法时命名参数值
- en: 'Optional parameters are often combined with naming parameters when you call
    the method because naming a parameter allows the values to be passed in a different
    order than how they were declared:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用方法时，可选参数通常与命名参数结合使用，因为命名参数允许以不同于声明时的顺序传递值：
- en: 'In `Program.cs`, add a statement to pass a `string` value for the `command`
    parameter and a `double` value for the `number` parameter, but using named parameters,
    so that the order they are passed through can be swapped around, as shown in the
    following code:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加一条语句以传递 `command` 参数的 `string` 值和 `number` 参数的 `double`
    值，但使用命名参数，这样它们传递的顺序可以互换，如下面的代码所示：
- en: '[PRE70]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下面的输出所示：
- en: '[PRE71]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: You can even use named parameters to skip over optional parameters.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以使用命名参数来跳过可选参数。
- en: 'In `Program.cs`, add a statement to pass a `string` value for the `command`
    parameter using positional order, skip the `number` parameter, and use the named
    `active` parameter, as shown in the following code:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加一条语句以使用位置顺序传递 `command` 参数的 `string` 值，跳过 `number` 参数，并使用命名的
    `active` 参数，如下面的代码所示：
- en: '[PRE72]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下面的输出所示：
- en: '[PRE73]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '**Good practice**: Although you can mix named and positional parameter values,
    most developers prefer to read code that uses one or the other within the same
    method call.'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**良好实践**：虽然可以混合命名和位置参数值，但大多数开发者更喜欢在同一个方法调用中只使用一种或另一种方式来阅读代码。'
- en: Mixing optional and required parameters
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合可选和必需参数
- en: At the moment, all the parameters in the `OptionalParameters` method are optional.
    What if one of them is required?
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`OptionalParameters` 方法中的所有参数都是可选的。如果其中一个参数是必需的怎么办？
- en: 'In `Person.cs`, add a fourth parameter without a default value to the `OptionalParameters`
    method, as highlighted in the following code:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 文件中，将 `OptionalParameters` 方法添加一个不带默认值的第四个参数，如下面的代码所示：
- en: '[PRE74]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Build the project and note the compiler error:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目并注意编译器错误：
- en: '[PRE75]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'In the `OptionalParameters` method, move the `count` parameter before the optional
    parameters, as shown in the following code:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `OptionalParameters` 方法中，将 `count` 参数移动到可选参数之前，如下面的代码所示：
- en: '[PRE76]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In `Program.cs`, modify all the calls to the `OptionalParameters` method to
    pass an `int` value as the first argument, for example, as shown in the following
    code:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，修改所有对 `OptionalParameters` 方法的调用，将 `int` 值作为第一个参数传递，例如，如下面的代码所示：
- en: '[PRE77]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Remember that if you name the arguments, then you can change their positions,
    for example: `bob.OptionalParameters(number: 52.7, command: "Hide!", count: 3)`.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '记住，如果你命名了参数，那么你可以改变它们的顺序，例如：`bob.OptionalParameters(number: 52.7, command:
    "Hide!", count: 3)`。'
- en: 'As you call the `OptionalParameters` method, note the tooltip that shows the
    one required, three optional parameters, and their default values in Visual Studio,
    as shown in *Figure 5.4*:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你调用 `OptionalParameters` 方法时，注意 Visual Studio 中显示的工具提示，它显示了必需的一个参数、三个可选参数及其默认值，如图
    *5.4* 所示：
- en: '![](img/B22322_05_04.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_05_04.png)'
- en: 'Figure 5.4: IntelliSense showing the required and optional parameters as you
    type code'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：IntelliSense 显示了你键入代码时必需和可选参数
- en: Controlling how parameters are passed
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制参数的传递方式
- en: 'When a parameter is passed into a method, it can be passed in one of several
    ways:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个参数传递给方法时，它可以以几种方式之一传递：
- en: 'By **value** (this is the default): Think of these as being *in-only*. Although
    the value can be changed, this only affects the parameter in the method.'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 **值**（这是默认方式）：将这些视为*单向的*。虽然值可以被更改，但这只会影响方法中的参数。
- en: 'As an `out` parameter: Think of these as being *out-only*. `out` parameters
    cannot have a default value assigned in their declaration and cannot be left uninitialized.
    They must be set inside the method; otherwise, the compiler will give an error.'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 `out` 参数：将这些视为*只写*。`out` 参数在其声明中不能有默认值，也不能未初始化。它们必须在方法内部设置；否则，编译器会报错。
- en: 'By **reference** as a `ref` parameter: Think of these as being *in-and-out*.
    Like `out` parameters, `ref` parameters also cannot have default values, but since
    they can already be set outside the method, they do not need to be set inside
    the method.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过**引用**作为 `ref` 参数：将这些视为*读写*。与 `out` 参数一样，`ref` 参数也不能有默认值，但由于它们可以在方法外部设置，因此不需要在方法内部设置。
- en: 'As an `in` parameter: Think of these as being a reference parameter that is
    *read-only*. `in` parameters cannot have their values changed and the compiler
    will show an error if you try.'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 `in` 参数：将这些视为*只读*的引用参数。`in` 参数的值不能被更改，如果你尝试更改，编译器会报错。
- en: 'Let’s see some examples of passing parameters in and out of a method:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些在方法中传递参数进出的示例：
- en: 'In `Person.cs`, add statements to define a method with three parameters, one
    `in` parameter, one `ref` parameter, and one `out` parameter, as shown in the
    following method:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 文件中，添加语句来定义一个具有三个参数的方法，一个 `in` 参数，一个 `ref` 参数和一个 `out` 参数，如下面的方法所示：
- en: '[PRE78]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In `Program.cs`, add statements to declare some `int` variables and pass them
    into the method, as shown in the following code:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加语句来声明一些 `int` 变量并将它们传递到方法中，如下面的代码所示：
- en: '[PRE79]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下面的输出所示：
- en: '[PRE80]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Note the following about the preceding output:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下关于前面输出的内容：
- en: When passing a variable as a parameter by default, its current value gets passed,
    not the variable itself. Therefore, `w` has a copy of the value of the `a` variable.
    The `a` variable retains its original value of `10` even after `w` is incremented
    to 11.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当默认地以参数的形式传递变量时，传递的是变量的当前值，而不是变量本身。因此，`w` 有 `a` 变量的值的副本。即使 `w` 增加到 11，`a` 变量仍然保留其原始值
    `10`。
- en: When passing a variable as an `in` parameter, a reference to the variable gets
    passed into the method. Therefore, `x` is a reference to `b`. If the `b` variable
    gets incremented by some other process while the method is executing, then the
    `x` parameter would show that.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当将变量作为 `in` 参数传递时，变量的引用被传递到方法中。因此，`x` 是 `b` 的引用。如果在方法执行过程中 `b` 变量被其他过程增加，则 `x`
    参数会显示这一点。
- en: When passing a variable as a `ref` parameter, a reference to the variable gets
    passed into the method. Therefore, `y` is a reference to `c`. The `c` variable
    gets incremented when the `y` parameter gets incremented.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当将变量作为 `ref` 参数传递时，变量的引用被传递到方法中。因此，`y` 是 `c` 的引用。当 `y` 参数增加时，`c` 变量也会增加。
- en: When passing a variable as an `out` parameter, a reference to the variable gets
    passed into the method. Therefore, `z` is a reference to `d`. The value of the
    `d` variable gets replaced by whatever code executes inside the method.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当将变量作为 `out` 参数传递时，变量的引用被传递到方法中。因此，`z` 是 `d` 的引用。`d` 变量的值会被方法内部执行的任何代码替换。
- en: We could simplify the code in the `Main` method by not assigning the value `40`
    to the `d` variable since it will always be replaced anyway. In C# 7 and later,
    we can simplify code that uses the `out` parameter.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过不将值 `40` 赋给 `d` 变量来简化 `Main` 方法中的代码，因为它的值无论如何都会被替换。在 C# 7 及以后的版本中，我们可以简化使用
    `out` 参数的代码。
- en: 'In `Program.cs`, add statements to declare some more variables, including an
    `out` parameter named `h` declared inline, as shown in the following code:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加语句来声明一些额外的变量，包括一个名为 `h` 的 `out` 参数，该参数是内联声明的，如下面的代码所示：
- en: '[PRE81]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下面的输出所示：
- en: '[PRE82]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Passing a variable number of parameters
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递可变数量的参数
- en: The `params` keyword in C# is used to specify a method parameter that takes
    a variable number of arguments. It allows you to pass an array of arguments to
    a method, or to pass a list of arguments that the compiler will automatically
    convert to an array.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的 `params` 关键字用于指定一个可以接受可变数量参数的方法参数。它允许你将一个参数数组传递给方法，或者传递一个编译器会自动转换为数组的参数列表。
- en: With C# 13 and later, as well as passing an array, you can pass any type that
    can be constructed via a collection expression, for example, a `List<T>` or `IEnumerable<T>`.
    Collection expressions are covered in detail in *Chapter 8, Working with Common
    .NET Types*, but basically, you can define a collection of items by surrounding
    a comma-separated list of items in square brackets `[ ]`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 13 及更高版本中，除了传递数组外，还可以传递任何可以通过集合表达式构造的类型，例如 `List<T>` 或 `IEnumerable<T>`。集合表达式在
    *第 8 章，使用常见的 .NET 类型* 中有详细说明，但基本上，你可以通过在方括号 `[ ]` 中包围逗号分隔的项列表来定义一个项集合。
- en: The benefits of using `params` include flexibility. It allows methods to accept
    any number of arguments and is easy to use because it simplifies the method signature
    by avoiding the need to explicitly create an array before calling the method.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `params` 的好处包括灵活性。它允许方法接受任意数量的参数，并且易于使用，因为它通过避免在调用方法之前显式创建数组来简化方法签名。
- en: 'There are some considerations when using the `params` keyword:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `params` 关键字时有一些考虑事项：
- en: The `params` keyword can only be used for one parameter in a method, and it
    must be the last parameter if the method has more than one.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`params` 关键字只能用于方法中的一个参数，如果方法有多个参数，它必须是最后一个参数。'
- en: You can pass individual arguments, and the compiler will automatically package
    them into an array. Alternatively, you can pass an array or collection expression.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以传递单个参数，编译器会自动将它们打包成一个数组。或者，你可以传递一个数组或集合表达式。
- en: When using `params`, you can call the method without passing any arguments for
    that parameter, and an empty array will be passed.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 `params` 时，你可以不传递任何参数调用该方法，并将传递一个空数组。
- en: 'Let’s see some code examples:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些代码示例：
- en: 'In `Person.cs`, add statements to define a method with two parameters, one
    normal parameter and one `params` parameter, as shown in the following method:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 中，添加语句定义一个方法，包含两个参数，一个普通参数和一个 `params` 参数，如下所示的方法：
- en: '[PRE83]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: With C# 12 and earlier, `params int[]` must be an array, although the items
    can by any data type, not just `int`. With C# 13 and later, `params int[]` could
    be any data type supported by collection expressions, like `params List<int>`
    or `IEnumerable<int>`, although the items can by any data type, not just `int`.
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 C# 12 及更早版本中，`params int[]` 必须是一个数组，尽管项目可以是任何数据类型，而不仅仅是 `int`。在 C# 13 及更高版本中，`params
    int[]` 可以是集合表达式支持的任何数据类型，如 `params List<int>` 或 `IEnumerable<int>`，尽管项目可以是任何数据类型，而不仅仅是
    `int`。
- en: 'In `Program.cs`, add statements to pass a string and some numbers into the
    method in various ways, as shown in the following code:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加语句以各种方式将字符串和一些数字传递给方法，如下面的代码所示：
- en: '[PRE84]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下面的输出所示：
- en: '[PRE85]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The `params` keyword is a powerful feature in C# that enhances the flexibility
    and readability of your code by allowing methods to accept a variable number of
    arguments.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '`params` 关键字是 C# 中一个强大的功能，它通过允许方法接受可变数量的参数，增强了代码的灵活性和可读性。'
- en: Understanding ref returns
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 `ref` 返回值
- en: 'In C# 7 or later, the `ref` keyword is not just for passing parameters into
    a method; it can also be applied to the `return` value. This allows an external
    variable to reference an internal variable and modify its value after the method
    call. This might be useful in advanced scenarios, for example, passing placeholders
    into big data structures, but it’s beyond the scope of this book. If you are interested
    in learning more, then you can read the information at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/ref#reference-return-values](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/ref#reference-return-values).'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 7 及更高版本中，`ref` 关键字不仅用于将参数传递给方法；它还可以应用于 `return` 值。这允许外部变量引用内部变量，并在方法调用后修改其值。这在高级场景中可能很有用，例如，将占位符传递给大数据结构，但这超出了本书的范围。如果你有兴趣了解更多，可以阅读以下链接中的信息：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/ref#reference-return-values](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/ref#reference-return-values)。
- en: Now, let’s return to looking at more advanced scenarios of methods that return
    values.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到查看方法返回值的更高级场景。
- en: Combining multiple returned values using tuples
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用元组组合多个返回值
- en: Each method can only return a single value that has a single type. That type
    could be a simple type, such as `string` in the previous example; a complex type,
    such as `Person`; or a collection type, such as `List<Person>`.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法只能返回一个具有单个类型的单一值。该类型可以是简单类型，如前例中的`string`；复杂类型，如`Person`；或集合类型，如`List<Person>`。
- en: 'Imagine that we want to define a method named `GetTheData` that needs to return
    both a `string` value and an `int` value. We could define a new class named `TextAndNumber`
    with a `string` field and an `int` field, and return an instance of that complex
    type, as shown in the following code:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要定义一个名为`GetTheData`的方法，该方法需要返回一个`string`值和一个`int`值。我们可以定义一个名为`TextAndNumber`的新类，其中包含一个`string`字段和一个`int`字段，并返回该复杂类型的实例，如下代码所示：
- en: '[PRE86]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: But defining a class just to combine two values is unnecessary because, in modern
    versions of C#, we can use **tuples**. Tuples are an efficient way to combine
    two or more values into a single unit. I pronounce them as *tuh-ples* but I have
    heard other developers pronounce them as *too-ples*. To-may-toe, to-mah-toe, po-tay-toe,
    po-tah-toe, I guess.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 但仅仅为了组合两个值而定义一个类是不必要的，因为在现代版本的C#中，我们可以使用**元组**。元组是将两个或更多值组合成一个单元的高效方式。我读作*tuh-ples*，但我听说其他开发者读作*too-ples*。To-may-toe,
    to-mah-toe, po-tay-toe, po-tah-toe，我想。
- en: Tuples have been a part of some languages, such as F#, since their first version,
    but .NET only added support for them with .NET 4 in 2010, using the `System.Tuple`
    type.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是某些语言的一部分，如F#，自其第一个版本以来就有，但.NET直到2010年的.NET 4才添加了对它们的支持，使用`System.Tuple`类型。
- en: It was only with C# 7 in 2017 that C# added language syntax support for tuples
    using the parentheses characters `()`, and at the same time, .NET added a new
    `System.ValueTuple` type that is more efficient in some common scenarios than
    the old .NET 4 `System.Tuple` type. The C# tuple syntax uses the more efficient
    one.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 直到2017年的C# 7版本，C#才添加了对元组的语言语法支持，使用括号字符`()`，同时.NET添加了一个新的`System.ValueTuple`类型，在某些常见场景中比旧的.NET
    4 `System.Tuple`类型更高效。C#的元组语法使用更高效的那个。
- en: 'Let’s explore tuples:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索元组：
- en: 'In `Person.cs`, add statements to define a method that returns a tuple combining
    a `string` and `int`, as shown in the following code:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，添加语句定义一个返回组合`string`和`int`的元组的方法，如下代码所示：
- en: '[PRE87]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'In `Program.cs`, add statements to call the `GetFruit` method, and then output
    the tuple’s fields, which are automatically named `Item1` and `Item2`, as shown
    in the following code:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句调用`GetFruit`方法，然后输出元组的字段，这些字段自动命名为`Item1`和`Item2`，如下代码所示：
- en: '[PRE88]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`PeopleApp`项目并查看结果，如下所示输出：
- en: '[PRE89]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Naming the fields of a tuple
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为元组的字段命名
- en: To access the fields of a tuple, the default names are `Item1`, `Item2`, and
    so on.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问元组的字段，默认名称是`Item1`、`Item2`等。
- en: 'You can explicitly specify the field names:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以显式指定字段名称：
- en: 'In `Person.cs`, add statements to define a method that returns a tuple with
    named fields, as shown in the following code:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，添加语句定义一个返回具有命名字段的元组的方法，如下代码所示：
- en: '[PRE90]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'In `Program.cs`, add statements to call the method and output the tuple’s named
    fields, as shown in the following code:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句调用该方法并输出元组的命名字段，如下代码所示：
- en: '[PRE91]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We use `var` to shorten the following full syntax:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`var`来缩短以下完整语法：
- en: '[PRE92]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`PeopleApp`项目并查看结果，如下所示输出：
- en: '[PRE93]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: If you construct a tuple from another object, you can use a feature introduced
    in C# 7.1 called **tuple name inference**.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从一个对象构造元组，你可以使用C# 7.1中引入的一个特性，称为**元组名称推断**。
- en: 'In `Program.cs`, create two tuples, each made of a `string` and `int` value,
    as shown in the following code:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，创建两个元组，每个元组由一个`string`值和一个`int`值组成，如下代码所示：
- en: '[PRE94]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: In C# 7, both things would use the `Item1` and `Item2` naming schemes. In C#
    7.1 and later, `thing2` can infer the names `Name` and `Count`.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 7中，两者都会使用`Item1`和`Item2`命名方案。在C# 7.1及以后版本中，`thing2`可以推断出`Name`和`Count`名称。
- en: Aliasing tuples
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 别名元组
- en: 'The ability to alias a tuple was introduced in C# 12 so that you could name
    the type and use that as the type name when declaring variables and parameters,
    for example, as shown in the following code:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 12中引入了为元组别名的功能，以便你可以命名类型，并在声明变量和参数时使用该类型名，例如，如下代码所示：
- en: '[PRE95]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: When aliasing tuples, use the title case naming convention for its parameters,
    for example, `Name`, `Number`, and `BirthDate`.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在别名元组时，使用标题大小写命名约定为其参数命名，例如，`Name`、`Number` 和 `BirthDate`。
- en: 'Let’s see an example:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：
- en: 'In `Program.cs`, at the top of the file, define a named tuple type, as shown
    in the following code:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件顶部，定义一个命名元组类型，如下所示代码：
- en: '[PRE96]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'In `Program.cs`, copy and paste the statement that calls the `GetNamedFruit`
    method and change `var` to `Fruit`, as shown in the following code:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，复制并粘贴调用 `GetNamedFruit` 方法的语句，并将 `var` 更改为 `Fruit`，如下所示代码：
- en: '[PRE97]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Run the `PeopleApp` project and note the result is the same.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并注意结果相同。
- en: Deconstructing tuples
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分解元组
- en: 'You can also deconstruct tuples into separate variables. The deconstructing
    declaration has the same syntax as named field tuples but without a named variable
    for the tuple, as shown in the following code:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将元组分解到单独的变量中。分解声明具有与命名字段元组相同的语法，但没有为元组命名变量，如下所示代码：
- en: '[PRE98]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Deconstruction has the effect of splitting the tuple into its parts and assigning
    those parts to new variables. Let’s see it in action:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 分解的效果是将元组拆分为其部分，并将这些部分分配给新的变量。让我们看看它是如何工作的：
- en: 'In `Program.cs`, add statements to deconstruct the tuple returned from the
    `GetFruit` method, as shown in the following code:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加语句来分解 `GetFruit` 方法返回的元组，如下所示代码：
- en: '[PRE99]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下所示输出：
- en: '[PRE100]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Deconstructing other types using tuples
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用元组分解其他类型
- en: 'Tuples are not the only type that can be deconstructed. Any type can have special
    methods, named `Deconstruct`, that break down an object into parts. You can have
    as many `Deconstruct` methods as you like as long as they have different signatures.
    Let’s implement some for the `Person` class:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 元组不是唯一可以分解的类型。任何类型都可以有特殊方法，名为 `Deconstruct`，将对象分解为部分。只要它们的签名不同，您就可以有任意多的 `Deconstruct`
    方法。让我们为 `Person` 类实现一些：
- en: 'In `Person.cs`, add two `Deconstruct` methods with `out` parameters defined
    for the parts we want to deconstruct into, as shown in the following code:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 中，添加两个具有 `out` 参数的 `Deconstruct` 方法，这些参数定义了我们想要分解的部分，如下所示代码：
- en: '[PRE101]'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'In `Program.cs`, add statements to deconstruct `bob`, as shown in the following
    code:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加语句来分解 `bob`，如下所示代码：
- en: '[PRE102]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: You do not explicitly call the `Deconstruct` method. It is called implicitly
    when you assign an object to a tuple variable.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要显式调用 `Deconstruct` 方法。当您将对象分配给元组变量时，它会隐式调用。
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下所示输出：
- en: '[PRE103]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Implementing functionality using local functions
  id: totrans-495
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用局部函数实现功能
- en: A language feature introduced in C# 7 is the ability to define a **local function**.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7 中引入的一项语言特性是定义 **局部函数** 的能力。
- en: Local functions are the method equivalent of local variables. In other words,
    they are methods that are only accessible from within the containing method in
    which they have been defined. In other languages, they are sometimes called **nested**
    or **inner functions**.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 局部函数是方法的局部变量的等效。换句话说，它们是仅在定义它们的包含方法内部可访问的方法。在其他语言中，它们有时被称为 **嵌套** 或 **内部函数**。
- en: 'Local functions can be defined anywhere inside a method: the top, the bottom,
    or even somewhere in the middle!'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 局部函数可以在方法内部定义任何位置：顶部、底部，甚至在中间的某个位置！
- en: 'We will use a local function to implement a factorial calculation:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用局部函数来实现阶乘计算：
- en: 'In `Person.cs`, add statements to define a `Factorial` function that uses a
    local function inside itself to calculate the result, as shown in the following
    code:'
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 中，添加语句来定义一个使用内部局部函数来计算结果的 `Factorial` 函数，如下所示代码：
- en: '[PRE104]'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'In `Program.cs`, add statements to call the `Factorial` function, and write
    the return value to the console, with exception handling, as shown in the following
    code:'
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加语句来调用 `Factorial` 函数，并将返回值写入控制台，带有异常处理，如下所示代码：
- en: '[PRE105]'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下所示输出：
- en: '[PRE106]'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Change the number to `-1` so that we can check the exception handling.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数字更改为 `-1` 以便我们可以检查异常处理。
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下所示输出：
- en: '[PRE107]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Splitting classes using partial
  id: totrans-509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用部分拆分类
- en: When working on large projects with multiple team members, or when working with
    especially large and complex class implementations, it is useful to be able to
    split the definition of a class across multiple files. You do this using the `partial`
    keyword.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 当在具有多个团队成员的大型项目上工作，或者与特别大且复杂的类实现一起工作时，能够将类的定义拆分到多个文件中非常有用。你可以使用 `partial` 关键字来完成此操作。
- en: Imagine that we want to add statements to the `Person` class that are automatically
    generated by a tool, like an object-relational mapper, that reads schema information
    from a database. If the class is defined as `partial`, then we can split the class
    into an autogenerated code file and a manually edited code file.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要向 `Person` 类添加由工具自动生成的语句，例如从数据库读取模式信息的对象关系映射器。如果类被定义为 `partial`，则可以将类拆分为自动生成的代码文件和手动编辑的代码文件。
- en: 'Let’s write some code that simulates this example:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些模拟此示例的代码：
- en: 'In `Person.cs`, add the `partial` keyword, as highlighted in the following
    code:'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 中添加 `partial` 关键字，如下所示代码中突出显示：
- en: '[PRE108]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: In the `PacktLibraryNet2` project/folder, add a new class file named `PersonAutoGen.cs`.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PacktLibraryNet2` 项目/文件夹中，添加一个名为 `PersonAutoGen.cs` 的新类文件。
- en: 'Add statements to the new file, as shown in the following code:'
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码所示，向新文件中添加语句：
- en: '[PRE109]'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Build the `PacktLibraryNet2` project. If you see the `CS0260 Missing partial
    modifier on declaration of type 'Person'; another partial declaration of this
    type exists` error, then make sure you have applied the `partial` keyword to both
    `Person` classes.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目 `PacktLibraryNet2`。如果你看到 `CS0260 Missing partial modifier on declaration
    of type 'Person'; another partial declaration of this type exists` 错误，请确保你已将 `partial`
    关键字应用于两个 `Person` 类。
- en: The rest of the code we write for this chapter will be written in the `PersonAutoGen.cs`
    file.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 本章剩余的代码将编写在 `PersonAutoGen.cs` 文件中。
- en: Partial methods
  id: totrans-520
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局部方法
- en: Partial methods were introduced with C# 3 on .NET Framework in 2007\. They are
    a feature that allows the definition of method signatures in one part of a `partial`
    `class` or `struct`, with the actual implementation provided in another part.
    Partial methods are particularly useful in scenarios where code generation and
    manual code coexist, such as in code generated by tools like Entity Framework
    Core or a source code generator.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 局部方法于 2007 年在 .NET Framework 上的 C# 3 中引入。这是一个允许在 `partial` `class` 或 `struct`
    的一个部分中定义方法签名，并在另一部分提供实际实现的功能。局部方法在代码生成和手动代码共存的情况下特别有用，例如在由 Entity Framework Core
    或源代码生成器等工具生成的代码中。
- en: 'There are some key characteristics of `partial` methods, as shown in the following
    list:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示列表中列出了 `partial` 方法的几个关键特性：
- en: Partial methods are declared with the `partial` keyword. The declaration provides
    the method signature, while the implementation provides the method body.
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部方法使用 `partial` 关键字声明。声明提供了方法签名，而实现提供了方法体。
- en: The implementation of a partial method is optional. If a partial method is declared
    but not implemented, the compiler removes the call to the method and no error
    is thrown.
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部方法的实现是可选的。如果声明了局部方法但没有实现，编译器将删除对方法的调用，并且不会抛出错误。
- en: Partial methods are implicitly private and cannot have access modifiers. They
    must also return `void` and cannot have `out` parameters.
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部方法是隐式私有的，不能有访问修饰符。它们还必须返回 `void`，并且不能有 `out` 参数。
- en: Partial methods cannot be `virtual`.
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部方法不能是 `virtual`。
- en: Partial methods are often used in scenarios involving code generation where
    a base structure is provided, and custom logic can be added without modifying
    the generated code.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 局部方法通常用于涉及代码生成的场景，其中提供了一个基本结构，并且可以在不修改生成的代码的情况下添加自定义逻辑。
- en: 'Imagine that you have a class file, as shown in the following code:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个类文件，如下所示：
- en: '[PRE110]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Now, imagine that you have another class file, as shown in the following code:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你还有一个类文件，如下所示：
- en: '[PRE111]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: In the preceding examples, `OnSomethingHappened` is a partial method declared
    in `MyClass1.cs` and implemented in `MyClass2.cs`. The method `DoWork` calls the
    partial method, which prints a message if the implementation is provided.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`OnSomethingHappened` 是在 `MyClass1.cs` 中声明并在 `MyClass2.cs` 中实现的局部方法。`DoWork`
    方法调用局部方法，如果提供了实现，则会打印一条消息。
- en: If in the example, `OnSomethingHappened` is declared but not implemented, then
    the C# compiler will remove the call to `OnSomethingHappened` in `DoWork`, and
    no error will be thrown.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在示例中，`OnSomethingHappened` 已声明但未实现，则 C# 编译器将删除 `DoWork` 中的 `OnSomethingHappened`
    调用，并且不会抛出错误。
- en: Partial methods are often used in auto-generated code where developers can hook
    into the process without modifying the generated code. This would be the case
    if the `MyClass1.cs` file was generated automatically.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 部分方法通常用于自动生成的代码中，开发者可以挂钩到该过程而无需修改生成的代码。如果 `MyClass1.cs` 文件是自动生成的，那么就会是这样的情况。
- en: Partial methods in C# provide a powerful way to extend and customize generated
    code without modifying it directly. They offer a clean mechanism for inserting
    custom behavior, ensuring that code generation and custom logic can coexist. By
    leveraging partial methods, developers can maintain a clear separation between
    generated and custom code, enhancing maintainability and readability. Now that
    you’ve seen lots of examples of fields and methods, we will look at some specialized
    types of methods that can be used to access fields to provide control and improve
    the developer’s experience.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的部分方法提供了一种强大的方式来扩展和自定义生成的代码，而无需直接修改它。它们提供了一种干净的机制来插入自定义行为，确保代码生成和自定义逻辑可以共存。通过利用部分方法，开发者可以在生成的代码和自定义代码之间保持清晰的分离，从而提高可维护性和可读性。现在你已经看到了许多字段和方法的示例，我们将探讨一些可以用来访问字段并提供控制和改进开发者体验的专用方法类型。
- en: Controlling access with properties and indexers
  id: totrans-536
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用属性和索引器控制访问
- en: Earlier, you created a method named `GetOrigin` that returned a `string` containing
    the name and origin of the person. Languages such as Java do this a lot. C# has
    a better way, and it is called properties.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，你创建了一个名为 `GetOrigin` 的方法，该方法返回一个包含人名和出身的 `string`。像 Java 这样的语言经常这样做。C# 有一个更好的方法，它被称为属性。
- en: A **property** is simply a method (or a pair of methods) that acts and looks
    like a field when you want to get or set a value, but it acts like a method, thereby
    simplifying the syntax and enabling functionality, like validation and calculation,
    when you set and get a value.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性**简单地说是一个方法（或一对方法），当你想要获取或设置值时，它表现得像一个字段，但当你设置和获取值时，它表现得像一个方法，从而简化了语法，并使功能（如验证和计算）成为可能。'
- en: A fundamental difference between a field and a property is that a field provides
    a memory address to data. You could pass that memory address to an external component,
    like a Windows API C-style function call, and it could then modify the data. A
    property does not provide a memory address to its data, which provides more control.
    All you can do is ask the property to get or set the data. The property then executes
    statements and can decide how to respond, including refusing the request!
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 字段和属性之间的基本区别在于，字段提供了一个数据内存地址。你可以将这个内存地址传递给外部组件，比如 Windows API C 风格的函数调用，然后它可以修改数据。属性不提供其数据的内存地址，这提供了更多的控制。你所能做的就是要求属性获取或设置数据。然后属性执行语句，并可以决定如何响应，包括拒绝请求！
- en: Defining read-only properties
  id: totrans-540
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义只读属性
- en: 'A `readonly` property only has a `get` implementation:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '`readonly` 属性仅有一个 `get` 实现：'
- en: 'In `PersonAutoGen.cs`, in the `Person` class, add statements to define three
    properties:'
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PersonAutoGen.cs` 文件中，在 `Person` 类中添加语句以定义三个属性：
- en: The first property will perform the same role as the `GetOrigin` method, using
    the property syntax that works with all versions of C#.
  id: totrans-543
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个属性将执行与 `GetOrigin` 方法相同的功能，使用与所有版本 C# 兼容的属性语法。
- en: The second property will return a greeting message, using the lambda expression
    body `=>` syntax from C# 6 and later.
  id: totrans-544
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个属性将返回一个问候消息，使用 C# 6 及以后的 lambda 表达式体 `=>` 语法。
- en: The third property will calculate the person’s age.
  id: totrans-545
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个属性将计算人的年龄。
- en: 'Here’s the code:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码：
- en: '[PRE112]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '**Good practice**: This isn’t the best way to calculate someone’s age, but
    we aren’t learning how to calculate an age from a date and time of birth. If you
    need to do that properly, then read the discussion at the following link: [https://stackoverflow.com/questions/9/how-do-i-calculate-someones-age-in-c](https://stackoverflow.com/questions/9/how-do-i-calculate-someones-age-in-c).'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：这不是计算某人年龄的最佳方式，但我们不是在学习如何从出生日期和时间计算年龄。如果你需要正确地这样做，请阅读以下链接的讨论：[https://stackoverflow.com/questions/9/how-do-i-calculate-someones-age-in-c](https://stackoverflow.com/questions/9/how-do-i-calculate-someones-age-in-c)。'
- en: 'In `Program.cs`, add the statements to get the properties, as shown in the
    following code:'
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加获取属性的语句，如下面的代码所示：
- en: '[PRE113]'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下面的输出所示：
- en: '[PRE114]'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The output shows `54` because I ran the console app on July 5, 2023, when Sam
    was 54 years old.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示 `54`，因为我是在 2023 年 7 月 5 日运行控制台应用程序时，Sam 已经 54 岁了。
- en: Defining settable properties
  id: totrans-554
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义可设置属性
- en: 'To create a settable property, you must use the older syntax and provide a
    pair of methods—not just a `get` part, but also a `set` part:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可设置的属性，你必须使用较旧的语法并提供一对方法——不仅是一个`get`部分，还包括一个`set`部分：
- en: 'In `PersonAutoGen.cs`, add statements to define a `string` property that has
    both a `get` and `set` method (also known as a **getter** and **setter**), as
    shown in the following code:'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PersonAutoGen.cs`中，添加语句来定义一个具有`get`和`set`方法（也称为**getter**和**setter**）的`string`属性，如下所示代码：
- en: '[PRE115]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Although you have not manually created a field to store the person’s favorite
    ice cream, it is there, automatically created by the compiler for you.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你没有手动创建一个字段来存储人的最喜欢的冰淇淋，但它确实在那里，由编译器自动为你创建。
- en: Sometimes, you need more control over what happens when a property is set. In
    this scenario, you must use a more detailed syntax and manually create a `private`
    field to store the value of the property.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要对属性设置时发生的事情有更多的控制。在这种情况下，你必须使用更详细的语法并手动创建一个`private`字段来存储属性的值。
- en: 'In `PersonAutoGen.cs`, add statements to define a `private` `string` field,
    known as a **backing field**, as shown in the following code:'
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PersonAutoGen.cs`中，添加语句来定义一个名为**后置字段**的`private` `string`字段，如下所示代码：
- en: '[PRE116]'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '**Good practice**: Although there is no formal standard to name private fields,
    the most common is to use camel case with an underscore as a prefix.'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：尽管没有正式的标准来命名私有字段，但最常见的是使用带下划线前缀的驼峰式命名法。'
- en: 'In `PersonAutoGen.cs`, add statements to define a `string` property that has
    both `get` and `set` and validation logic in the setter, as shown in the following
    code:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PersonAutoGen.cs`中，添加语句来定义一个具有`get`和`set`以及验证逻辑的`string`属性，如下所示代码：
- en: '[PRE117]'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '**Good practice**: Avoid adding too much code to your getters and setters.
    This could indicate a problem with your design. Consider adding private methods
    that you then call in the `set` and `get` methods to simplify your implementations.'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：避免在getter和setter中添加过多的代码。这可能表明你的设计存在问题。考虑添加私有方法，然后在`set`和`get`方法中调用这些方法以简化你的实现。'
- en: 'In `Program.cs`, add statements to set Sam’s favorite ice cream and color,
    and then write them out, as shown in the following code:'
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句来设置Sam的最喜欢的冰淇淋和颜色，然后将其写入，如下所示代码：
- en: '[PRE118]'
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The print book is limited to about 820 pages. If I added exception handling
    code to all code examples as we have done here, then I would probably have to
    remove at least one chapter from the book to make enough space. In the future,
    I will not explicitly tell you to add exception handling code, but get into the
    habit of adding it yourself when needed.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 打印的书籍限制在大约820页。如果我在所有代码示例中添加异常处理代码，就像我们在这里所做的那样，那么我可能不得不从书中删除至少一章来腾出足够的空间。在将来，我不会明确告诉你添加异常处理代码，但我会养成在需要时自己添加它的习惯。
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`PeopleApp`项目并查看结果，如下所示输出：
- en: '[PRE119]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Try to set the color to any value other than red, green, or blue, like black.
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试将颜色设置为除了红色、绿色或蓝色以外的任何值，例如黑色。
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`PeopleApp`项目并查看结果，如下所示输出：
- en: '[PRE120]'
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '**Good practice**: Use properties instead of fields when you want to execute
    statements during a read or write to a field without using a method pair, like
    `GetAge` and `SetAge`.'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：当你想在读取或写入字段时执行语句，而不使用方法对，如`GetAge`和`SetAge`时，请使用属性而不是字段。'
- en: Partial properties
  id: totrans-575
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分属性
- en: In the previous section, you learned about partial classes and partial methods.
    With C# 13 on .NET 9, you can define partial properties, and they work in a similar
    way. The main benefit is to support source-generated types. Partial properties
    make it easier for source generator designers to create natural feeling APIs,
    as you will see in *Chapter 8, Working with Common .NET Types*, when we see the
    Regex source generator.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了关于部分类和部分方法的内容。在.NET 9的C# 13中，你可以定义部分属性，并且它们的工作方式类似。主要好处是支持源生成的类型。部分属性使得源生成器设计者更容易创建自然感觉的API，正如你在*第8章，使用常见的.NET类型*中将会看到的，当我们看到正则表达式源生成器时。
- en: Limiting flags enum values
  id: totrans-577
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制标志枚举值
- en: 'Earlier in this chapter, we defined a field to store a person’s favorite ancient
    wonder. But we then made the `enum` able to store combinations of values. Now,
    let’s limit the favorite to one:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们定义了一个字段来存储一个人的最喜欢的古代奇迹。但后来我们使`enum`能够存储值的组合。现在，让我们将最喜欢的限制为一个：
- en: 'In `Person.cs`, comment out the `FavoriteAncientWonder` field and add a comment
    to note it has moved to the `PersonAutoGen.cs` code file, as shown in the following
    code:'
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 中，注释掉 `FavoriteAncientWonder` 字段并添加注释说明它已移动到 `PersonAutoGen.cs`
    代码文件中，如下代码所示：
- en: '[PRE121]'
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'In `PersonAutoGen.cs`, add a `private` field and `public` property for `FavoriteAncientWonder`,
    as shown in the following code:'
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PersonAutoGen.cs` 中，为 `FavoriteAncientWonder` 添加一个 `private` 字段和一个 `public`
    属性，如下代码所示：
- en: '[PRE122]'
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: We could simplify the validation by only checking if the value is defined in
    the original `enum` because `IsDefined` returns `false` for multiple values and
    undefined values. However, I want to show a different exception for multiple values,
    so I will use the fact that multiple values formatted as a string would include
    a comma in the list of names. This also means we must check for multiple values
    before we check if the value is defined. A comma-separated list is how multiple
    `enum` values are represented as a `string`, but you cannot use commas to set
    multiple `enum` values. You should use `|` (the bitwise `OR`).
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过仅检查值是否定义在原始 `enum` 中来简化验证，因为 `IsDefined` 对多个值和未定义的值返回 `false`。然而，我想展示一个针对多个值的不同的异常，所以我将使用事实，即格式化为字符串的多个值将包括名称列表中的逗号。这也意味着我们必须在检查值是否定义之前检查多个值。逗号分隔列表是表示多个
    `enum` 值作为 `string` 的方式，但您不能使用逗号来设置多个 `enum` 值。您应该使用 `|`（位或）。
- en: 'In `Program.cs`, in the *Storing a value using an enum type* region, set Bob’s
    favorite wonder to more than one `enum` value, as shown in the following code:'
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，在 *使用枚举类型存储值* 区域，将鲍勃的最爱奇迹设置为超过一个 `enum` 值，如下代码所示：
- en: '[PRE123]'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Run the `PeopleApp` project and note the exception, as shown in the following
    output:'
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并注意异常，如下所示输出：
- en: '[PRE124]'
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'In `Program.cs`, set Bob’s favorite wonder to an invalid `enum` value like
    128, as shown in the following code:'
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，将鲍勃的最爱奇迹设置为一个无效的 `enum` 值，如 128，如下代码所示：
- en: '[PRE125]'
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Run the `PeopleApp` project and note the exception, as shown in the following
    output:'
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并注意异常，如下所示输出：
- en: '[PRE126]'
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: In `Program.cs`, set Bob’s favorite wonder back to a valid single `enum` value.
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，将鲍勃的最爱奇迹设置回一个有效的单个 `enum` 值。
- en: Defining indexers
  id: totrans-593
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义索引器
- en: '**Indexers** allow the calling code to use the array syntax to access a property.
    For example, the `string` type defines an indexer so that the calling code can
    access individual characters in the `string`, as shown in the following code:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '**索引器**允许调用代码使用数组语法来访问属性。例如，`string` 类型定义了一个索引器，以便调用代码可以访问 `string` 中的单个字符，如下代码所示：'
- en: '[PRE127]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: You can overload indexers so that different types can be used for their parameters.
    For example, as well as passing an `int` value, you could also pass a `string`
    value.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以重载索引器，以便可以使用不同的类型作为它们的参数。例如，除了传递一个 `int` 值外，您还可以传递一个 `string` 值。
- en: 'We will define an indexer to simplify access to the children of a person:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个索引器来简化对一个人子代的访问：
- en: 'In `PersonAutoGen.cs`, add statements to define an indexer to get and set a
    child using the index of the child, as shown in the following code:'
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PersonAutoGen.cs` 中，添加语句来定义一个索引器，通过子代的索引来获取和设置一个子代，如下代码所示：
- en: '[PRE128]'
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Note the use of `this[]` to define an indexer. It is not to be confused with
    the use of the `this` keyword to refer to the current instance of an object, or
    the use of `this()` to refer to the current type’s constructor.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用 `this[]` 来定义一个索引器。它不要与使用 `this` 关键字来引用对象的当前实例，或者使用 `this()` 来引用当前类型的构造函数混淆。
- en: 'In `PersonAutoGen.cs`, add statements to define an indexer to get and set a
    child using the name of the child, as shown in the following code:'
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PersonAutoGen.cs` 中，添加语句来定义一个索引器，通过子代的名称来获取和设置一个子代，如下代码所示：
- en: '[PRE129]'
  id: totrans-602
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: You will learn more about collections like `List<T>` in *Chapter 8*, *Working
    with Common .NET Types*, and how to write lambda expressions using `=>` in *Chapter
    11*,*Querying and Manipulating Data Using LINQ*.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在 *第8章*，*使用常见的 .NET 类型* 中学习更多关于 `List<T>` 等集合的知识，以及如何在 *第11章*，*使用 LINQ 查询和操作数据*
    中使用 `=>` 编写 lambda 表达式。
- en: 'In `Program.cs`, add statements to add two children to `Sam`, and then access
    the first and second children using the longer `Children` field and the shorter
    indexer syntax, as shown in the following code:'
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加语句向 `Sam` 添加两个子代，然后使用较长的 `Children` 字段和较短的索引器语法访问第一个和第二个子代，如下代码所示：
- en: '[PRE130]'
  id: totrans-605
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下所示输出：
- en: '[PRE131]'
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '`sam[0].Name` calls the indexer aka `this` on the `Person` class because `[]`
    are the symbols that call an indexer. `sam.Children[0].Name` calls the indexer
    on the collection named `Children`, which is a `List<Person>`. We have implemented
    the indexer on `Person` to do the same thing so we can use a shorter syntax.'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '`sam[0].Name` 调用了 `Person` 类的索引器或 `this`，因为 `[]` 是调用索引器的符号。`sam.Children[0].Name`
    调用了名为 `Children` 的集合的索引器，它是一个 `List<Person>`。我们已经在 `Person` 上实现了索引器以执行相同的功能，这样我们就可以使用更短的语法。'
- en: It’s similar with `string` values. If I have `string name = "Mark";` then imagine
    that it has a property named `Characters` that is a `List<char>`. I could use
    `name.Characters[0]` to return the character `M`. But since `string` has an indexer
    defined, I can do the same with `name[0]`.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `string` 值也是类似的。如果我有一个 `string name = "Mark";`，那么想象它有一个名为 `Characters` 的属性，它是一个
    `List<char>`。我可以用 `name.Characters[0]` 返回字符 `M`。但由于 `string` 已经定义了索引器，我可以用 `name[0]`
    做同样的事情。
- en: Most types do not define an indexer. It’s just a way to define a property that
    is called using `[]` instead of a name. It can actually do anything you want.
    But it should be used to define an array/collection style getter/setter. If your
    type doesn’t need that, it doesn’t need an indexer.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数类型没有定义索引器。它只是定义一个使用 `[]` 而不是名称来调用的属性的一种方式。实际上它可以做任何你想做的事情。但是，它应该用来定义数组/集合风格的获取器/设置器。如果你的类型不需要这个，那么它不需要索引器。
- en: 'For any type you define, just imagine another developer using your type. What
    would they expect the indexer to do? For example, what if you get the first index,
    as shown in the following code:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你定义的任何类型，只需想象另一个开发者正在使用你的类型。他们会期望索引器做什么？例如，如果你获取第一个索引，如下面的代码所示：
- en: '[PRE132]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '`thing1` might be the first passenger in the car or the first wheel of the
    car. `thing2` might be the first table in the database or the first user. For
    custom types, it is up to you to decide what makes the most sense for your type.'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '`thing1` 可能是车上的第一个乘客或车的第一个轮子。`thing2` 可能是数据库中的第一个表或第一个用户。对于自定义类型，由你来决定什么最适合你的类型。'
- en: Pattern matching with objects
  id: totrans-614
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象的模式匹配
- en: In *Chapter 3*, *Controlling Flow, Converting Types, and Handling Exceptions*,
    you were introduced to basic pattern matching. In this section, we will explore
    pattern matching in more detail.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第3章*，*控制流程、转换类型和处理异常* 中，你被介绍了基本的模式匹配。在本节中，我们将更详细地探讨模式匹配。
- en: Pattern-matching flight passengers
  id: totrans-616
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式匹配飞行乘客
- en: 'In this example, we will define some classes that represent various types of
    passengers on a flight, and then we will use a switch expression with pattern
    matching to determine the cost of their flight:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将定义一些代表航班上各种类型乘客的类，然后我们将使用带有模式匹配的 switch 表达式来确定他们的飞行费用：
- en: In the `PacktLibraryNet2` project/folder, add a new file named `FlightPatterns.cs`.
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PacktLibraryNet2` 项目/文件夹中，添加一个名为 `FlightPatterns.cs` 的新文件。
- en: If you use Visual Studio, in `FlightPatterns.cs`, delete the existing statements,
    including the class named `FlightPatterns`, because we will define multiple classes,
    and none match the name of the code file.
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用 Visual Studio，在 `FlightPatterns.cs` 中删除现有的语句，包括名为 `FlightPatterns` 的类，因为我们将会定义多个类，并且没有类名与代码文件名匹配。
- en: 'In `FlightPatterns.cs`, add statements to define three types of passenger with
    different properties, as shown in the following code:'
  id: totrans-620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FlightPatterns.cs` 文件中，添加语句来定义三种具有不同属性的乘客类型，如下面的代码所示：
- en: '[PRE133]'
  id: totrans-621
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: You will learn about overriding the `ToString` method in *Chapter 6*, *Implementing
    Interfaces and Inheriting Classes*.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在 *第6章*，*实现接口和继承类* 中学习如何重写 `ToString` 方法。
- en: 'In `Program.cs`, add statements to define an object array containing five passengers
    of various types and property values, and then enumerate them, outputting the
    cost of their flight, as shown in the following code:'
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加语句来定义一个包含五种不同类型和属性值的乘客对象数组，然后枚举它们，输出他们的飞行费用，如下面的代码所示：
- en: '[PRE134]'
  id: totrans-624
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'While reviewing the preceding code, note the following:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查前面的代码时，请注意以下内容：
- en: Most code editors do not align the lambda symbols => as I have done above.
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数代码编辑器都不会像上面那样对齐 lambda 符号 =>。
- en: To pattern match the properties of an object, you must name a local variable,
    like `p`, which can then be used in an expression.
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要对对象的属性进行模式匹配，你必须命名一个局部变量，例如 `p`，然后可以在表达式中使用它。
- en: To pattern match on a type only, you can use `_` to discard the local variable;
    for example, `FirstClassPassenger _` means that you match on the type but you
    don’t care what values any of its properties have, so a named variable like `p`
    is not needed. In a moment, you will see how we can improve the code even more.
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要仅对类型进行模式匹配，可以使用 `_` 来丢弃局部变量；例如，`FirstClassPassenger _` 表示你匹配类型，但你不在乎其任何属性的值，因此不需要命名变量如
    `p`。稍后，你将看到我们如何进一步改进代码。
- en: The `switch` expression also uses `_` to represent its default branch.
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch` 表达式也使用 `_` 来表示其默认分支。'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下所示输出：
- en: '[PRE135]'
  id: totrans-631
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Enhancements to pattern matching in modern C#
  id: totrans-632
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现代 C# 中模式匹配的增强
- en: 'The previous examples worked with C# 8\. Now, we will look at some enhancements
    in C# 9 and later. First, you no longer need to use the underscore to discard
    the local variable when doing type matching:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例使用的是 C# 8，现在我们将看看 C# 9 及以后的增强功能。首先，你不再需要使用下划线来丢弃局部变量以进行类型匹配：
- en: 'In `Program.cs`, comment out the C# 8 syntax, and add C# 9 and later syntax
    to modify the branches for first-class passengers to use a nested `switch` expression
    and the new support for conditionals, like `>`, as highlighted in the following
    code:'
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，注释掉 C# 8 语法，并添加 C# 9 及以后的语法来修改一等舱乘客的分支，使用嵌套的 `switch` 表达式和新的条件支持，如以下代码中突出显示：
- en: '[PRE136]'
  id: totrans-635
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Run the `PeopleApp` project to view the results, and note that they are the
    same as before.
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目以查看结果，并注意它们与之前相同。
- en: 'You could also use the relational pattern in combination with the property
    pattern to avoid the nested `switch` expression, as shown in the following code:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将关系模式与属性模式结合使用，以避免嵌套的 `switch` 表达式，如下所示代码：
- en: '[PRE137]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Working with record types
  id: totrans-639
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与记录类型一起工作
- en: Before we dive into the new `record` language feature, let us see some other
    related new features of C# 9 and later.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨新的 `record` 语言特性之前，让我们看看 C# 9 及以后的其它相关新特性。
- en: Init-only properties
  id: totrans-641
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅初始化属性
- en: You have used object initialization syntax to instantiate objects and set initial
    properties throughout this chapter. Those properties can also be changed after
    instantiation.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章中使用了对象初始化语法来实例化对象并设置初始属性。这些属性也可以在实例化后更改。
- en: Sometimes, you want to treat properties like `readonly` fields so that they
    can be set during instantiation but not after. In other words, they are immutable.
    The `init` keyword enables this. It can be used in place of the `set` keyword
    in a property definition.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你希望将属性视为 `readonly` 字段，以便它们可以在实例化时设置，但不能在之后设置。换句话说，它们是不可变的。`init` 关键字可以实现这一点。它可以在属性定义中替代
    `set` 关键字。
- en: 'Since this is a language feature not supported by .NET Standard 2.0, we cannot
    use it in the `PacktLibraryNet2` project. We must use it in the modern project:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个不受 .NET Standard 2.0 支持的语言特性，我们无法在 `PacktLibraryNet2` 项目中使用它。我们必须在现代项目中使用它：
- en: In the `PacktLibraryModern` project, add a new file named `Records.cs`.
  id: totrans-645
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PacktLibraryModern` 项目中，添加一个名为 `Records.cs` 的新文件。
- en: 'In `Records.cs`, define a person class with two immutable properties, as shown
    in the following code:'
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Records.cs` 中，定义一个具有两个不可变属性的人员类，如下所示代码：
- en: '[PRE138]'
  id: totrans-647
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'In `Program.cs`, add statements to instantiate a new immutable person, and
    then try to change one of its properties, as shown in the following code:'
  id: totrans-648
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加语句以实例化一个新的不可变人员，然后尝试更改其属性之一，如下所示代码：
- en: '[PRE139]'
  id: totrans-649
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Compile the console app and note the compile error, as shown in the following
    output:'
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译控制台应用程序并注意编译错误，如下所示输出：
- en: '[PRE140]'
  id: totrans-651
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Comment out the attempt to set the `FirstName` property after instantiation.
  id: totrans-652
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉在实例化后尝试设置 `FirstName` 属性的尝试。
- en: Even if you do not set `FirstName` in the object initializer, you still would
    not be able to set it post-initialization. If you need to force a property to
    be set, then apply the `required` keyword that you learned about earlier in this
    chapter.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你在对象初始化器中没有设置 `FirstName`，你仍然无法在初始化后设置它。如果你需要强制设置属性，那么请应用本章早些时候学到的 `required`
    关键字。
- en: Defining record types
  id: totrans-654
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义记录类型
- en: Init-only properties provide some immutability to C#. You can take the concept
    further by using **record types**. These are defined by using the `record` keyword
    instead of (or as well as) the `class` keyword. That can make the whole object
    immutable, and it acts like a value when compared. We will discuss equality and
    comparisons of classes, records, and value types in more detail in *Chapter 6*,
    *Implementing Interfaces and Inheriting Classes*.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 仅初始化属性为 C# 提供了一些不可变性。你可以通过使用 **record 类型** 来进一步扩展这个概念。这些类型是通过使用 `record` 关键字而不是（或以及）`class`
    关键字来定义的。这样可以使整个对象不可变，并且在比较时表现得像一个值。我们将在 *第 6 章*，*实现接口和继承类* 中更详细地讨论类、记录和值类型的相等性和比较。
- en: 'Immutable records should not have any state (properties and fields) that change
    after instantiation. Instead, the idea is that you create new records from existing
    ones. The new record has the changed state. This is called non-destructive mutation.
    To do this, C# 9 introduced the `with` keyword:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变记录不应该有任何在实例化后改变的状态（属性和字段）。相反，想法是从现有的记录中创建新的记录。新的记录具有改变后的状态。这被称为非破坏性变异。为此，C#
    9 引入了 `with` 关键字：
- en: 'In `Records.cs`, add a record named `ImmutableVehicle` after the `ImmutablePerson`
    class, as shown in the following code:'
  id: totrans-657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Records.cs` 类中，在 `ImmutablePerson` 类之后添加一个名为 `ImmutableVehicle` 的记录，如下面的代码所示：
- en: '[PRE141]'
  id: totrans-658
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'In `Program.cs`, add statements to create a `car` and then a mutated copy of
    it, as shown in the following code:'
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加语句来创建一个 `car` 对象，然后创建它的一个变异副本，如下面的代码所示：
- en: '[PRE142]'
  id: totrans-660
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Run the `PeopleApp` project to view the results, and note the change to the
    car color in the mutated copy, as shown in the following output:'
  id: totrans-661
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目以查看结果，并注意变异副本中汽车颜色的变化，如下面的输出所示：
- en: '[PRE143]'
  id: totrans-662
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: You could also release the memory for the `car` variable and the `repaintedCar`
    would still fully exist.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以释放 `car` 变量的内存，而重新喷漆的 `repaintedCar` 仍然完全存在。
- en: Equality of record types
  id: totrans-664
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录类型的相等性
- en: 'One of the most important behaviors of `record` types is their equality. Two
    records with the same property values are considered equal. This may not sound
    surprising, but if you used a normal class instead of a record, then they would
    *not* be considered equal. Let’s see:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '`record` 类型最重要的行为之一是它们的相等性。具有相同属性值的两个记录被认为是相等的。这可能听起来并不令人惊讶，但如果你使用的是普通类而不是记录，那么它们就不会被认为是相等的。让我们看看：'
- en: In the `PacktLibraryModern` project, add a new file named `Equality.cs`.
  id: totrans-666
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PacktLibraryModern` 项目中，添加一个名为 `Equality.cs` 的新文件。
- en: 'In `Equality.cs`, define a `class` and a `record` type, as shown in the following
    code:'
  id: totrans-667
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Equality.cs` 中，定义一个 `class` 和一个 `record` 类型，如下面的代码所示：
- en: '[PRE144]'
  id: totrans-668
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'In `Program.cs`, add statements to create two instances of `AnimalClass` and
    two instances of `AnimalRecord`, and then compare them for equality, as shown
    in the following code:'
  id: totrans-669
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加语句来创建 `AnimalClass` 的两个实例和 `AnimalRecord` 的两个实例，然后比较它们的相等性，如下面的代码所示：
- en: '[PRE145]'
  id: totrans-670
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Run the `PeopleApp` project to view the results, and note that two class instances
    are not equal even if they have the same property values, and two record instances
    are equal if they have the same property values, as shown in the following output:'
  id: totrans-671
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目以查看结果，并注意即使两个类的实例具有相同的属性值，它们也不相等，而两个记录实例如果具有相同的属性值则相等，如下面的输出所示：
- en: '[PRE146]'
  id: totrans-672
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Class instances are only equal if they are literally the same object. This is
    true when their memory addresses are equal. You will learn more about the equality
    of types in *Chapter 6*, *Implementing Interfaces and Inheriting Classes*.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 类实例只有在它们确实是同一个对象时才相等。当它们的内存地址相等时这是正确的。你将在 *第 6 章*，*实现接口和继承类* 中了解更多关于类型相等性的内容。
- en: Equality of other types
  id: totrans-674
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他类型的相等性
- en: It is common to compare two variables using the `==` and `!=` operators. The
    behavior of these two operators is different for reference types and value types.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `==` 和 `!=` 运算符比较两个变量是很常见的。这两个运算符的行为对于引用类型和值类型是不同的。
- en: 'When you check the equality of two value type variables, .NET literally compares
    the *values* of those two variables on the stack and returns `true` if they are
    equal:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查两个值类型变量的相等性时，.NET 实际上会比较这两个变量在栈上的 *值*，如果它们相等则返回 `true`：
- en: 'In `Program.cs`, add statements to declare two integers with equal values and
    then compare them, as shown in the following code:'
  id: totrans-677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加语句来声明两个具有相等值的整数，然后比较它们，如下面的代码所示：
- en: '[PRE147]'
  id: totrans-678
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-679
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下面的输出所示：
- en: '[PRE148]'
  id: totrans-680
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: When you check the equality of two reference type variables, .NET compares the
    memory addresses of those two variables and returns `true` if they are equal.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查两个引用类型变量的相等性时，.NET会比较这两个变量的内存地址，如果它们相等则返回`true`。
- en: 'In `Program.cs`, add statements to declare two `Person` instances with equal
    names, and then compare the variables and their names, as shown in the following
    code:'
  id: totrans-682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以声明两个具有相同名称的`Person`实例，然后比较变量及其名称，如下面的代码所示：
- en: '[PRE149]'
  id: totrans-683
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`PeopleApp`项目并查看结果，如下面的输出所示：
- en: '[PRE150]'
  id: totrans-685
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: This is because they are not the same object. If both variables literally pointed
    to the same object on the heap, then they would be equal.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为它们不是同一个对象。如果两个变量实际上都指向堆上的同一个对象，那么它们就是相等的。
- en: 'Add statements to declare a third `Person` object and assign `p1` to it, as
    shown in the following code:'
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以声明第三个`Person`对象并将`p1`分配给它，如下面的代码所示：
- en: '[PRE151]'
  id: totrans-688
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-689
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`PeopleApp`项目并查看结果，如下面的输出所示：
- en: '[PRE152]'
  id: totrans-690
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: The one exception to this behavior of reference types is the `string` type.
    It is a reference type, but the equality operators have been overridden to make
    them behave as if they were value types.
  id: totrans-691
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 引用类型这种行为的一个例外是`string`类型。它是一个引用类型，但相等运算符已被重写，使其表现得像值类型一样。
- en: 'Add statements to compare the `Name` properties of two `Person` instances,
    as shown in the following code:'
  id: totrans-692
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以比较两个`Person`实例的`Name`属性，如下面的代码所示：
- en: '[PRE153]'
  id: totrans-693
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-694
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`PeopleApp`项目并查看结果，如下面的输出所示：
- en: '[PRE154]'
  id: totrans-695
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: You can do the same as `string` with your classes to override the equality operator
    `==` to return `true`, even if the two variables are not referencing the same
    object (the same memory address on the heap) but, instead, their fields have the
    same values. However, that is beyond the scope of this book.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用与`string`相同的方式在你的类中重写相等运算符`==`，使其返回`true`，即使两个变量不是引用同一个对象（堆上的相同内存地址），而是它们的字段具有相同的值。然而，这超出了本书的范围。
- en: '**Good practice**: Alternatively, use a `record class` because one of its benefits
    is that it implements this equality behavior for you.'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：或者，使用`record class`，因为它的一个好处是它为你实现了这种相等行为。'
- en: Positional data members in records
  id: totrans-698
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录中的位置数据成员
- en: 'The syntax for defining a record can be greatly simplified using positional
    data members. Instead of using object initialization syntax with curly braces,
    sometimes you might prefer to provide a constructor with positional parameters,
    as you saw earlier in this chapter. You can also combine this with a deconstructor
    to split the object into individual parts, as shown in the following code:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 使用位置数据成员定义记录的语法可以大大简化。与使用花括号的对象初始化语法相比，有时你可能更喜欢提供一个具有位置参数的构造函数，正如你在这章前面所看到的。你还可以将此与析构函数结合使用，将对象拆分为单独的部分，如下面的代码所示：
- en: '[PRE155]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'The properties, constructor, and deconstructor can be generated for you:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 属性、构造函数和析构函数可以为你生成：
- en: 'In `Records.cs`, add statements to define another record using simplified syntax,
    known as positional records, as shown in the following code:'
  id: totrans-702
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Records.cs`中，添加语句以使用简化语法定义另一个记录，这种语法称为位置记录，如下面的代码所示：
- en: '[PRE156]'
  id: totrans-703
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'In `Program.cs`, add statements to construct and deconstruct immutable animals,
    as shown in the following code:'
  id: totrans-704
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以构造和析构不可变的动物，如下面的代码所示：
- en: '[PRE157]'
  id: totrans-705
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Run the `PeopleApp` project and view the results, as shown in the following
    output:'
  id: totrans-706
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`PeopleApp`项目并查看结果，如下面的输出所示：
- en: '[PRE158]'
  id: totrans-707
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: You will see records again when we look at C# 10 or later support to create
    `struct` records in *Chapter 6*, *Implementing Interfaces and Inheriting Classes*.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看第6章“实现接口和继承类”中C# 10或更高版本的`struct`记录支持时，你将再次看到记录。
- en: '**More information**: There are many more ways to use records in your projects.
    I recommend that you review the official documentation at the following link:
    [https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/records](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/records).'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：在你的项目中使用记录的方式还有很多。我建议你查看以下链接中的官方文档：[https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/records](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/records)。'
- en: Defining a primary constructor for a class
  id: totrans-710
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义类的主构造函数
- en: Introduced with C# 12, you can define one constructor as part of the class definition.
    This is called the primary constructor. The syntax is the same as for positional
    data members in records, but the behavior is slightly different.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 12 中引入的功能允许你将一个构造函数作为类定义的一部分来定义。这被称为主构造函数。其语法与记录中位置数据成员的语法相同，但行为略有不同。
- en: 'Traditionally, we separate the class definition from any constructors, as shown
    in the following code:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，我们将类定义与任何构造函数分开，如下面的代码所示：
- en: '[PRE159]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'With class primary constructors, you combine both into a more succinct syntax,
    as shown in the following code:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类的主构造函数，你可以将两者结合成一个更简洁的语法，如下面的代码所示：
- en: '[PRE160]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Let’s see an example:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：
- en: In the `PacktLibraryModern` project, add a class file named `Headset.cs`.
  id: totrans-717
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PacktLibraryModern` 项目中，添加一个名为 `Headset.cs` 的类文件。
- en: 'Modify the code file contents to give the class two parameters for manufacturer
    and product name respectively, as shown in the following code:'
  id: totrans-718
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改代码文件内容，为类提供两个参数，分别用于制造商和产品名称，如下面的代码所示：
- en: '[PRE161]'
  id: totrans-719
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'In `Program.cs`, add statements to instantiate a headset, as shown in the following
    code:'
  id: totrans-720
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加语句来实例化一个头盔，如下面的代码所示：
- en: '[PRE162]'
  id: totrans-721
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: One of the differences between a `record` and a `class` type with a primary
    constructor is that its parameters don’t become public properties automatically,
    so you will see `CS1061` compiler errors. Neither `ProductName` nor `productName`
    are accessible outside the class.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '`record` 类型与具有主构造函数的 `class` 类型之间的一个区别是，其参数不会自动成为公共属性，因此你会看到 `CS1061` 编译器错误。`ProductName`
    和 `productName` 都无法在类外访问。'
- en: 'In `Headset.cs`, add statements to define two properties and set them using
    the parameters passed to the primary constructor, as highlighted in the following
    code:'
  id: totrans-723
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Headset.cs` 中，添加语句来定义两个属性并使用传递给主构造函数的参数来设置它们，如下面的代码所示：
- en: '[PRE163]'
  id: totrans-724
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Run the `PeopleApp` project and view the results, as shown in the following
    output:'
  id: totrans-725
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下面的输出所示：
- en: '[PRE164]'
  id: totrans-726
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'In `Headset.cs`, add a default parameterless constructor, as highlighted in
    the following code:'
  id: totrans-727
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Headset.cs` 中，添加一个默认的无参数构造函数，如下面的代码所示：
- en: '[PRE165]'
  id: totrans-728
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Note the use of `this()` to call the constructor of the base class and pass
    two parameters to it when the default constructor of `Headset` is called.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用 `this()` 调用基类的构造函数，并在调用 `Headset` 的默认构造函数时向其传递两个参数。
- en: 'In `Program.cs`, create an uninitialized instance of a headset and an instance
    for Meta Quest 3, as shown in the following code:'
  id: totrans-730
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，创建一个未初始化的头盔实例和一个 Meta Quest 3 的实例，如下面的代码所示：
- en: '[PRE166]'
  id: totrans-731
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Run the `PeopleApp` project and view the results, as shown in the following
    output:'
  id: totrans-732
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下面的输出所示：
- en: '[PRE167]'
  id: totrans-733
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '**More information**: You can learn more about primary constructors for classes
    and structs at the following links: [https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/primary-constructors](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/primary-constructors)
    and [https://devblogs.microsoft.com/dotnet/csharp-primary-constructors-refactoring/](https://devblogs.microsoft.com/dotnet/csharp-primary-constructors-refactoring/).
    In particular, it is worth reading the comments at the bottom of the second link
    to understand why many developers do not like primary constructors in classes.'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：你可以在以下链接中了解更多关于类和结构的主构造函数的信息：[https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/primary-constructors](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/primary-constructors)
    和 [https://devblogs.microsoft.com/dotnet/csharp-primary-constructors-refactoring/](https://devblogs.microsoft.com/dotnet/csharp-primary-constructors-refactoring/)。特别是，值得阅读第二个链接底部的评论，以了解为什么许多开发者不喜欢类中的主构造函数。'
- en: '**Good practice**: Only use a primary constructor in a class if it will only
    initialize non-read-only private fields, and does not need to execute other statements.'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：只有当主构造函数仅用于初始化非只读私有字段，并且不需要执行其他语句时，才在类中使用主构造函数。'
- en: Practicing and exploring
  id: totrans-736
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习和探索
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring this chapter’s topics with deeper research.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题、进行一些实际操作练习，并深入研究本章的主题来测试你的知识和理解。
- en: Exercise 5.1 – online material
  id: totrans-738
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.1 – 在线材料
- en: Online material can be extra content written by me for this book, or it can
    be references to content created by Microsoft or third parties.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 在线材料可以是我为这本书写的额外内容，也可以是引用 Microsoft 或第三方创建的内容。
- en: Pattern matching
  id: totrans-740
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模式匹配
- en: 'There are many ways to use pattern matching in your projects. I recommend that
    you review the official documentation at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/pattern-matching](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/pattern-matching).'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目中使用模式匹配有很多种方法。我建议你查看以下链接中的官方文档：[https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/pattern-matching](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/pattern-matching).
- en: Exercise 5.2 – practice exercises
  id: totrans-742
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.2 – 练习
- en: Practice exercises go deeper into the topics for this chapter.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 练习将更深入地探讨本章的主题。
- en: Practice access modifiers
  id: totrans-744
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习访问修饰符
- en: Imagine that you are the compiler. What errors would you show when building
    the following projects? What would need to change to fix it?
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你是编译器。在构建以下项目时，你会显示哪些错误？需要更改什么才能修复它？
- en: 'In a class library project, in `Car.cs`:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 在类库项目中，在 `Car.cs`：
- en: '[PRE168]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'In a console app project that references the class library project, in `Program.cs`:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个引用类库项目的控制台应用程序项目中，在 `Program.cs`：
- en: '[PRE169]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Exercise 5.3 – test your knowledge
  id: totrans-750
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.3 – 测试你的知识
- en: 'Answer the following questions:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题：
- en: What are the seven access modifier keywords and combinations of keywords, and
    what do they do?
  id: totrans-752
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有七个访问修饰符关键字和关键字的组合，它们分别是什么，以及它们的作用？
- en: What is the difference between the `static`, `const`, and `readonly` keywords
    when applied to a type member?
  id: totrans-753
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用于类型成员时，`static`、`const` 和 `readonly` 关键字之间的区别是什么？
- en: What does a constructor do?
  id: totrans-754
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数的作用是什么？
- en: Why should you apply the `[Flags]` attribute to an `enum` type when you want
    to store combined values?
  id: totrans-755
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你想存储组合值时，为什么应该将 `[Flags]` 属性应用于 `enum` 类型？
- en: Why is the `partial` keyword useful?
  id: totrans-756
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么 `partial` 关键字很有用？
- en: What is a tuple?
  id: totrans-757
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 元组是什么？
- en: What does the `record` keyword do?
  id: totrans-758
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`record` 关键字的作用是什么？'
- en: What does overloading mean?
  id: totrans-759
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 载荷过载是什么意思？
- en: What is the difference between the following two statements? (Do not just say
    a > character!)
  id: totrans-760
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下两个语句之间的区别是什么？（不要只是说 a > 字符！）
- en: '[PRE170]'
  id: totrans-761
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: How do you make a method parameter optional?
  id: totrans-762
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使方法参数成为可选的？
- en: Why can’t a `DateTime` field be a constant?
  id: totrans-763
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么 `DateTime` 字段不能是一个常量？
- en: Exercise 5.4 – explore topics
  id: totrans-764
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.4 – 探索主题
- en: 'Use the links on the following page to learn more about the topics covered
    in this chapter:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下页面上的链接了解更多关于本章涵盖的主题：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-5---building-your-own-types-with-object-oriented-programming](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-5---building-your-own-types-with-object-oriented-programming)'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-5---building-your-own-types-with-object-oriented-programming](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-5---building-your-own-types-with-object-oriented-programming)'
- en: Summary
  id: totrans-767
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned about:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了以下内容：
- en: Making your own types using OOP.
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用面向对象编程（OOP）创建自己的类型。
- en: Some of the different categories of members that a type can have, including
    fields to store data and methods to perform actions.
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型可以拥有的不同成员类别，包括用于存储数据的字段和执行操作的函数。
- en: OOP concepts, such as aggregation and encapsulation
  id: totrans-771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）概念，例如聚合和封装
- en: How to use modern C# features, like relational and property pattern matching
    enhancements, `init`-only properties, and record types.
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用现代 C# 功能，如关系和属性模式匹配增强、仅初始化属性和记录类型。
- en: In the next chapter, you will take these concepts further by defining operators,
    delegates, and events, implementing interfaces, and inheriting from existing classes.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将通过定义运算符、委托和事件、实现接口以及从现有类继承来进一步探讨这些概念。
