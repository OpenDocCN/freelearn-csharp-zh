- en: 11 Structural Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11种结构模式
- en: 'Before you begin: Join our book community on Discord'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开始之前：加入我们的Discord书籍社区
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向作者本人提供反馈，并在我们的Discord服务器上与其他早期读者聊天（在“architecting-aspnet-core-apps-3e”频道下找到“EARLY
    ACCESS SUBSCRIPTION”）。
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
- en: '![Qr code Description automatically generated](img/file47.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![二维码描述自动生成](img/file47.png)'
- en: 'This chapter explores four design patterns from the well-known Gang of Four
    (GoF). We use Structural patterns to build and organize complex object hierarchies
    in a maintainable fashion. They allow us to dynamically add behaviors to existing
    classes, whether we designed the initial system this way or as an afterthought
    that emerges out of necessity later in the program’s lifecycle. Structural patterns
    promote reusability and enhance the overall flexibility of the system.In this
    chapter, we cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了来自著名的四人帮（GoF）的四个设计模式。我们使用结构模式以可维护的方式构建和组织复杂对象层次结构。它们允许我们动态地向现有类添加行为，无论我们最初是这样设计系统，还是作为程序生命周期后期因必要性而出现的后续想法。结构模式促进重用性并增强系统的整体灵活性。在本章中，我们将涵盖以下主题：
- en: Implementing the Decorator design pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现装饰者设计模式
- en: Implementing the Composite design pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现组合设计模式
- en: Implementing the Adapter design pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现适配器设计模式
- en: Implementing the Façade design pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现外观设计模式
- en: The first two patterns help us extend a class dynamically and efficiently manage
    a complex object structure. The last two help us adapt an interface to another
    or shield a complex system with a simple interface.Let's dive into unlocking the
    power of structural patterns!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个模式帮助我们动态地扩展类并有效地管理复杂对象结构。最后两个模式帮助我们适配接口或将复杂系统用简单接口屏蔽。让我们深入挖掘结构模式的力量！
- en: Implementing the Decorator design pattern
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现装饰者设计模式
- en: The Decorator Pattern allows us to dynamically add new functionality to an object
    by wrapping it with one or more decorator objects. This pattern follows the Open-Closed
    principle, allowing us to add additional behaviors to an object at runtime without
    modifying its original code. This pattern enables us to separate responsibilities
    into multiple smaller pieces. It is a simple but powerful pattern. In this section,
    we explore how to implement this pattern in the traditional way and how to leverage
    an open-source tool named **Scrutor** to help us create powerful dependency injection-ready
    decorators.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰者模式允许我们通过包装一个或多个装饰者对象来动态地向对象添加新功能。这种模式遵循开闭原则，允许我们在运行时向对象添加额外的行为，而不修改其原始代码。这种模式使我们能够将责任分离成多个更小的部分。这是一个简单但强大的模式。在本节中，我们将探讨如何以传统方式实现此模式，以及如何利用名为**Scrutor**的开源工具来帮助我们创建强大的依赖注入准备好的装饰者。
- en: Goal
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标
- en: The decorator aims to extend an existing object at runtime without changing
    its code. Moreover, the decorated object should remain unaware of the decoration
    process, making this approach an excellent fit for complex or long-lasting systems
    that necessitate evolution. This pattern fits systems of all sizes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰者的目标是运行时扩展现有对象，而不改变其代码。此外，被装饰的对象应该对装饰过程一无所知，这使得这种方法非常适合需要进化的复杂或长期系统。这种模式适用于所有规模的系统。
- en: I often use this pattern to add flexibility and create adaptability to a program
    for next to no cost. In addition, small classes are easier to test, so the Decorator
    pattern adds ease of testability into the mix, making it worth mastering.
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我经常使用这种模式以极低的成本增加灵活性，并为程序创建适应性。此外，小型类更容易测试，因此装饰者模式将测试的便利性融入其中，使其值得掌握。
- en: The Decorator pattern makes it easier to encapsulate responsibilities into multiple
    classes, instead of packing multiple responsibilities inside a single class. Having
    multiple classes with a single responsibility makes the system easier to manage.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰者模式使得将责任封装到多个类中变得更容易，而不是将多个责任打包在一个类中。拥有多个具有单一责任的类使得系统更容易管理。
- en: Design
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计
- en: 'A **decorator** class must implement and use the interface the **decorated**
    class implements. Let’s see this step by step, starting with a non-decorated class
    design:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**装饰者**类必须实现并使用**被装饰**类实现的接口。让我们一步一步来看，从非装饰类的设计开始：'
- en: '![Figure 11.1: A class diagram representing the ComponentA class implementing
    the IComponent interface](img/file48.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1：表示实现IComponent接口的ComponentA类的类图](img/file48.png)'
- en: 'Figure 11.1: A class diagram representing the ComponentA class implementing
    the IComponent interface'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1：表示实现IComponent接口的ComponentA类的类图
- en: 'In the preceding diagram, we have the following components:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们有以下组件：
- en: A client that calls the `Operation()` method of the `IComponent` interface.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`IComponent`接口的`Operation()`方法的客户端。
- en: '`ComponentA`, which implements the `IComponent` interface.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`IComponent`接口的`ComponentA`。
- en: 'This translates into the following sequence diagram:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应以下序列图：
- en: '![Figure 11.2: A sequence diagram showing a consumer calling the Operation
    method of the ComponentA class](img/file49.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2：显示消费者调用ComponentA类的Operation方法的序列图](img/file49.png)'
- en: 'Figure 11.2: A sequence diagram showing a consumer calling the Operation method
    of the ComponentA class'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：显示消费者调用ComponentA类的Operation方法的序列图
- en: 'Now, say that we want to add a behavior to `ComponentA`, but only in some cases.
    In other cases, we want to keep the initial behavior. To do so, we could choose
    the Decorator pattern and implement it as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想在某些情况下向`ComponentA`添加行为，在其他情况下则保持初始行为。为此，我们可以选择装饰者模式，并按以下方式实现它：
- en: '![Figure 11.3: Decorator class diagram](img/file50.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图11.3：装饰者类图](img/file50.png)'
- en: 'Figure 11.3: Decorator class diagram'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：装饰者类图
- en: 'Instead of modifying the `ComponentA` class, we created `DecoratorA`, which
    also implements the `IComponent` interface. This way, the `Client` object can
    use an instance of `DecoratorA` instead of `ComponentA` and leverage the new behavior
    without impacting the other consumers of `ComponentA`. Then, to avoid rewriting
    the whole component, an implementation of the `IComponent` interface (say `ComponentA`)
    is injected when creating a new `DecoratorA` instance (constructor injection).
    This new instance is stored in the `component` field and used by the `Operation()`
    method (implicitly using the **Strategy** pattern).We can translate the updated
    sequence like so:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有修改`ComponentA`类，而是创建了`DecoratorA`，它也实现了`IComponent`接口。这样，`Client`对象可以使用`DecoratorA`的实例而不是`ComponentA`，并且可以利用新的行为而不影响`ComponentA`的其他消费者。然后，为了避免重写整个组件，在创建新的`DecoratorA`实例时（构造函数注入）注入了`IComponent`接口的实现（例如`ComponentA`）。这个新实例存储在`component`字段中，并由`Operation()`方法使用（隐式使用**策略模式**）。我们可以这样翻译更新的序列：
- en: '![Figure 11.4: Decorator sequence diagram](img/file51.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图11.4：装饰者序列图](img/file51.png)'
- en: 'Figure 11.4: Decorator sequence diagram'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：装饰者序列图
- en: In the preceding diagram, instead of calling `ComponentA` directly, `Client`
    calls `DecoratorA`, which in turn calls `ComponentA`. Finally, `DecoratorA` does
    some postprocessing by calling its private method, `AddBehaviorA()`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，客户端不是直接调用`ComponentA`，而是调用`DecoratorA`，然后`DecoratorA`再调用`ComponentA`。最后，`DecoratorA`通过调用其私有方法`AddBehaviorA()`进行一些后处理。
- en: Nothing from the Decorator pattern limits us from doing preprocessing, postprocessing,
    wrapping the decorated class’s call (the `Operation` method in this example) with
    some logic (like an `if` statement or a `try`-`catch`), or all of that combined.
    The use of adding a postprocessing behavior is only an example.
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 装饰者模式中的任何内容都不会限制我们进行预处理、后处理、用一些逻辑（如`if`语句或`try`-`catch`）包装被装饰类的调用（在这个例子中是`Operation`方法），或者所有这些的组合。添加后处理行为的用法只是一个例子。
- en: 'To show you how powerful the Decorator pattern is before we jump into the code,
    know this: we can chain decorators! Since our decorator depends on the interface
    (not the implementation), we could inject another decorator, let’s call it `DecoratorB`,
    inside `DecoratorA` (or vice versa). We could then create a long chain of rules
    that decorate one another, leading to a very powerful yet simple design.Let’s
    take a look at the following class diagram, which represents our chaining example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们跳入代码之前，让我们看看装饰者模式有多强大：我们可以链式使用装饰者！由于我们的装饰者依赖于接口（而不是实现），我们可以在`DecoratorA`内部注入另一个装饰者，比如叫`DecoratorB`（或者反过来）。然后我们可以创建一个装饰彼此的规则链，从而得到一个非常强大且简单的设计。让我们看看以下表示我们的链式示例的类图：
- en: '![Figure 11.5: Decorator class diagram, including two decorators](img/file52.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图11.5：包括两个装饰者的装饰者类图](img/file52.png)'
- en: 'Figure 11.5: Decorator class diagram, including two decorators'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5：包括两个装饰者的装饰者类图
- en: Here, we created the `DecoratorB` class, which looks very similar to `DecoratorA`
    but has a private `AddBehaviorB()` method instead of `AddBehaviorA()`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了`DecoratorB`类，它看起来与`DecoratorA`非常相似，但有一个私有的`AddBehaviorB()`方法而不是`AddBehaviorA()`。
- en: How we implement the decorator logic is irrelevant to the pattern, so I excluded
    the `AddBehaviorA()` method from *Figure 9.3* to show you only the pattern. However,
    I added it to *Figure 9.5* to clarify the idea behind having a second decorator.
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们实现装饰器逻辑的方式与模式无关，因此我从*图9.3*中排除了`AddBehaviorA()`方法，以便只向您展示模式。然而，我在*图9.5*中添加了它，以阐明第二个装饰器背后的理念。
- en: 'Let’s take a look at the sequence diagram for this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个的序列图：
- en: '![Figure 11.6: Sequence diagram of two nested decorators](img/file53.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图11.6：两个嵌套装饰器的序列图](img/file53.png)'
- en: 'Figure 11.6: Sequence diagram of two nested decorators'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6：两个嵌套装饰器的序列图
- en: With this, we are beginning to see the power of decorators. In the preceding
    diagram, we can assess that the behaviors of `ComponentA` have been changed twice
    without `Client` knowing about it. All those classes are unaware of the next `IComponent`
    in the chain. They don’t even know that they are being decorated. They only play
    their role in the plan—that’s all.It is also important to note that the decorator’s
    power resides in its dependency on the interface, not on an implementation, making
    it reusable. Based on that fact, we could swap `DecoratorA` and `DecoratorB` to
    invert the order the new behaviors are applied without touching the code itself.
    We could also apply the same decorator (say `DecoratorC`) to multiple `IComponent`
    implementations, like decorating both `DecoratorA` and `DecoratorB`. A decorator
    could even decorate itself.Let’s now dig into some code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们开始看到装饰器的强大之处。在先前的图中，我们可以评估`ComponentA`的行为被改变两次，而客户端并不知道这一点。所有这些类都对链中的下一个`IComponent`一无所知。它们甚至不知道自己正在被装饰。它们只是在计划中扮演自己的角色——仅此而已。重要的是要注意，装饰器的力量在于它依赖于接口，而不是实现，这使得它可重用。基于这个事实，我们可以交换`DecoratorA`和`DecoratorB`以反转应用新行为的顺序，而不必触及代码本身。我们还可以将相同的装饰器（比如`DecoratorC`）应用于多个`IComponent`实现，比如装饰`DecoratorA`和`DecoratorB`。装饰器甚至可以装饰自己。现在让我们深入研究一些代码。
- en: Project – Adding behaviors
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 - 添加行为
- en: 'Let''s implement the previous example to help visualize the Decorator pattern,
    which adds some arbitrary behaviors. Each `Operation()` method returns a string
    that is then outputted to the response stream. It is not fancy but visually shows
    how the pattern works.First, let’s look at the `IComponent` interface:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现前面的示例，以帮助可视化添加一些任意行为的装饰器模式。每个`Operation()`方法返回一个字符串，然后输出到响应流。它并不复杂，但直观地显示了模式的工作原理。首先，让我们看看`IComponent`接口：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `IComponent` interface only states that an implementation should have an
    `Operation()` method that returns a `string`.Next, let’s look at the `ComponentA`
    class:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`IComponent`接口只声明实现应该有一个返回`string`的`Operation()`方法。接下来，让我们看看`ComponentA`类：'
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `Operation()` method of the `ComponentA` class returns a literal string.Now
    that we described the first pieces, let’s look at the consumer:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComponentA`类的`Operation()`方法返回一个字面字符串。现在我们已经描述了第一部分，让我们看看消费者：'
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the `Program.cs` file above, we register `ComponentA` as the implementation
    of `IComponent`, with a singleton lifetime. We then inject an `IComponent` implementation
    when an HTTP request hits the `/` endpoint. The delegate then calls the `Operation()`
    method and outputs the result to the response.At this point, running the application
    results in the following response:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的`Program.cs`文件中，我们将`ComponentA`注册为`IComponent`的实现，具有单例生命周期。然后，当HTTP请求击中`/`端点时，我们注入一个`IComponent`实现。然后代理调用`Operation()`方法并将结果输出到响应。此时，运行应用程序会产生以下响应：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So far, it's pretty simple; the client calls the endpoint, the container injects
    an instance of the `ComponentA` class into the endpoint delegate, then the endpoint
    returns the results of `Operation` method to the client.Next, we add the first
    decorator.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，它相当简单；客户端调用端点，容器将`ComponentA`类的实例注入到端点代理中，然后端点将`Operation`方法的结果返回给客户端。接下来，我们添加第一个装饰器。
- en: DecoratorA
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 装饰器A
- en: 'Here, we want to modify the response without touching the code of the `ComponentA`
    class. To do so, we chose to create a decorator named `DecoratorA` that wraps
    the `Operation()` result into a `<DecoratorA>` tag:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们想要修改响应，而不触及`ComponentA`类的代码。为此，我们选择创建一个名为`DecoratorA`的装饰器，它将`Operation()`结果包装到`<DecoratorA>`标签中：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`DecoratorA` implements and depends on the `IComponent` interface. It uses
    the injected `IComponent` implementation in its `Operation()` method and wraps
    its result in an HTML-like (XML) tag.Now that we have a decorator, we need to
    tell the IoC container to send an instance of `DecoratorA` instead of `ComponentA`
    when injecting an `IComponent` interface.`DecoratorA` should decorate `ComponentA`.
    More precisely, the container should inject an instance of the `ComponentA` class
    into the `DecoratorA` class.To achieve this, we could register it as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`DecoratorA` 实现并依赖于 `IComponent` 接口。它在 `Operation()` 方法中使用注入的 `IComponent`
    实现并使用类似 HTML（XML）的标签包装其结果。现在我们有了装饰器，我们需要告诉 IoC 容器在注入 `IComponent` 接口时发送 `DecoratorA`
    的实例而不是 `ComponentA`。`DecoratorA` 应该装饰 `ComponentA`。更准确地说，容器应该将 `ComponentA` 类的实例注入到
    `DecoratorA` 类中。为了实现这一点，我们可以按照以下方式注册它：'
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we are telling ASP.NET Core to inject an instance of `DecoratorA` that
    decorates an instance of `ComponentA` when injecting an `IComponent` interface.
    When we run the application, we should see the following result in the browser:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在告诉 ASP.NET Core 在注入 `IComponent` 接口时注入一个装饰了 `ComponentA` 实例的 `DecoratorA`
    实例。当我们运行应用程序时，我们应该在浏览器中看到以下结果：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You may have noticed a few `new` keywords there, but even though it is not very
    elegant, we can manually create new instances in the composition root without
    jeopardizing our application’s health. We learn how to get rid of some of them
    later with the introduction of Scrutor.
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可能注意到了一些 `new` 关键字，尽管这并不非常优雅，但我们可以在组合根中手动创建新实例，而不会危及我们应用程序的健康。我们将在介绍 Scrutor
    后学习如何消除其中的一些。
- en: Next, let’s create the second decorator.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建第二个装饰器。
- en: DecoratorB
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: DecoratorB
- en: 'Now that we have a decorator, it is time to create a second decorator to demonstrate
    the power of chaining decorators.**Context**: we need another content wrapper
    but don’t want to modify existing classes. To achieve this, we concluded that
    creating a second decorator would be perfect, so we created the following `DecoratorB`
    class:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了装饰器，现在是时候创建第二个装饰器来展示链式装饰器的强大功能了。**背景**：我们需要另一个内容包装器，但又不想修改现有的类。为了实现这一点，我们得出结论，创建第二个装饰器将非常完美，因此我们创建了以下
    `DecoratorB` 类：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code is similar to `DecoratorA`, but the XML tag is `DecoratorB`
    instead. The important part is that the decorator depends on and implements the
    `IComponent` interface and doesn’t depend on a concrete class. This is what gives
    us the flexibility of decorating any `IComponent`, and this is what enables us
    to chain decorators.To complete this example, we need to update our composition
    root like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码与 `DecoratorA` 类似，但 XML 标签是 `DecoratorB`。重要的是，装饰器依赖于并实现了 `IComponent` 接口，而不依赖于具体类。这就是我们能够装饰任何
    `IComponent` 的灵活性所在，这也是我们能够链式使用装饰器的原因。为了完成这个示例，我们需要像这样更新我们的组合根：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, `DecoratorB` decorates `DecoratorA`, which decorates `ComponentA`. When
    running the application, you see the following output:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`DecoratorB` 装饰了 `DecoratorA`，而 `DecoratorA` 又装饰了 `ComponentA`。当运行应用程序时，你会看到以下输出：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: And voilà! These decorators allowed us to modify the behavior of `ComponentA`
    without impacting the code. However, our composition root is beginning to get
    messy as we instantiate multiple dependencies inside each other, making our application
    harder to maintain. Moreover, the code is becoming harder to read. Furthermore,
    the code would be even harder to read if the decorators were also depending on
    other classes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这些装饰器使我们能够修改 `ComponentA` 的行为，而不影响代码。然而，随着我们在每个依赖项内部实例化多个依赖项，我们的组合根开始变得混乱，这使得我们的应用程序更难维护。此外，代码的可读性也在下降。更进一步，如果装饰器还依赖于其他类，代码的可读性将变得更差。
- en: We can use decorators to change the behavior or state of an object. We can be
    very creative with decorators; for example, you could create a class that queries
    remote resources over HTTP and then decorate that class with a small component
    that manages a memory cache of the results, limiting the round trip to the remote
    server. You could create another decorator that monitors the time needed to query
    those resources and then log that to Application Insights—so many possibilities.
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们可以使用装饰器来改变对象的行为或状态。我们可以非常富有创意地使用装饰器；例如，你可以创建一个类，它通过 HTTP 查询远程资源，然后使用一个小组件来管理结果的内存缓存，限制往返远程服务器的次数。你可以创建另一个装饰器来监控查询这些资源所需的时间，并将其记录到
    Application Insights 中——有如此多的可能性。
- en: Next, we eliminate the `new` keywords and clean up our composition root.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们消除 `new` 关键字并清理我们的组合根。
- en: Project – Decorator using Scrutor
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 - 使用 Scrutor 的装饰器
- en: 'This update aims to simplify the composition of the system we just created.
    To achieve this, we use **Scrutor**, an open-source library that allows us to
    do just that, among other things.We first need to install the Scrutor NuGet package
    using Visual Studio or the CLI. When using the CLI, run the following command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这次更新旨在简化我们刚刚创建的系统结构。为了实现这一点，我们使用 **Scrutor**，这是一个开源库，它允许我们做这件事，以及其他事情。我们首先需要使用
    Visual Studio 或 CLI 安装 Scrutor NuGet 包。当使用 CLI 时，运行以下命令：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once Scrutor is installed, we can use the `Decorate` extension method on the
    `IServiceCollection` to add decorators.By using Scrutor, we can update the following
    messy line:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Scrutor，我们就可以使用 `Decorate` 扩展方法在 `IServiceCollection` 上添加装饰器。通过使用 Scrutor，我们可以更新以下混乱的行：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And convert it into these three more elegant lines:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 将其转换为这三行更加优雅的代码：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding code, we registered `ComponentA` as the implementation of
    `IComponent`, with a singleton lifetime, just like the first time.Then, by using
    Scrutor, we told the IoC container to override that first binding and to decorate
    the already registered `IComponent` (`ComponentA`) with an instance of `DecoratorA`
    instead. Then, we overrode the second binding by telling the IoC container to
    return an instance of `DecoratorB` that decorates the last known binding of `IComponent`
    instead (`DecoratorA`).The result is the same as we did previously, but the code
    is now more elegant. On top of that improved readability, this lets the container
    create the instances instead of us using the `new` keyword, adding more flexibility
    and stability to our system.As a reminder, the IoC container serves the equivalent
    of the following `instance` when an `IComponent` interface is requested:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将 `ComponentA` 注册为 `IComponent` 的实现，具有单例生命周期，就像第一次一样。然后，通过使用 Scrutor，我们告诉
    IoC 容器覆盖第一个绑定，并用 `DecoratorA` 的实例装饰已注册的 `IComponent` (`ComponentA`)。然后，我们通过告诉
    IoC 容器返回一个实例 `DecoratorB` 来覆盖第二个绑定，该实例装饰了 `IComponent` 的最后一个已知绑定（`DecoratorA`）。结果是和之前一样，但现在代码更加优雅。除了提高了可读性之外，这还让容器创建实例，而不是我们使用
    `new` 关键字，这增加了我们系统的灵活性和稳定性。作为提醒，当请求 `IComponent` 接口时，IoC 容器提供相当于以下 `instance`
    的功能：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Why am I talking about elegance and flexibility? This code is a simple example,
    but if we add other dependencies to those classes, it could quickly become a complex
    code block that could become a maintenance nightmare, very hard to read, and have
    manually managed lifetimes. Of course, if the system is simple, you can always
    instantiate the decorators manually without loading an external library.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我要谈论优雅和灵活性？这个代码只是一个简单的例子，但如果我们向这些类添加其他依赖项，它可能会迅速变成一个复杂的代码块，这可能成为一个维护噩梦，非常难以阅读，并且需要手动管理生命周期。当然，如果系统很简单，你总是可以手动实例化装饰器而不需要加载外部库。
- en: Whenever possible, keep your code simple. Using Scrutor is one way to achieve
    this. Code simplicity helps in the long run as it is easier to read and follow,
    even for someone else reading it. Consider that someone will most likely read
    your code one day.
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在可能的情况下，保持你的代码简单。使用 Scrutor 是实现这一目标的一种方法。代码的简洁性从长远来看有助于阅读和跟踪，即使对其他人来说也是如此。考虑到总有一天会有人阅读你的代码。
- en: ''
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Moreover, adding any external dependency to a project should be considered carefully.
    Remember that you must keep the dependency up to date, so having too many can
    take maintenance time. The library's author can also stop maintaining it, and
    the library will become outdated. The library may introduce breaking changes forcing
    you to update your code. And so on.
  id: totrans-85
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此外，向项目中添加任何外部依赖都应该仔细考虑。记住，你必须保持依赖项更新，所以依赖项太多可能会占用维护时间。库的作者也可能停止维护它，库就会变得过时。库可能会引入破坏性更改，迫使你更新代码。等等。
- en: ''
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Furthermore, there is the security aspect to consider. Supply chain attacks
    are not uncommon. If you work in a regulated place, you may have to go through
    a cybersecurity vetting process, etc.
  id: totrans-87
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此外，还需要考虑安全性方面。供应链攻击并不罕见。如果你在一个受监管的地方工作，你可能必须通过网络安全审查过程，等等。
- en: ''
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Besides those general tips, I’ve been using Scrutor for many years; I find it
    very stable and don’t remember any breaking changes that caused me issues.
  id: totrans-89
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除了这些一般性建议之外，我已经使用了 Scrutor 多年；我发现它非常稳定，并且不记得有任何破坏性更改导致我遇到问题。
- en: 'To ensure both programs behave the same, with or without Scrutor, let’s explore
    the following integration test that runs for both projects, ensuring their correctness:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保两个程序的行为相同，无论是否有 Scrutor，让我们探索以下集成测试，它运行在两个项目上，确保它们的正确性：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding test sends an HTTP request to one of the applications running
    in memory and compares the server response to the expected value. Since both projects
    should have the same output, we reuse this test in both the `DecoratorPlainStartupTest`
    and `DecoratorScrutorStartupTest` classes. They are empty and only routes the
    test to the correct program. Here’s an example of the Visual Studio Test Explorer:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试向内存中运行的一个应用程序发送HTTP请求，并将服务器响应与预期值进行比较。由于两个项目应该有相同的输出，我们在`DecoratorPlainStartupTest`和`DecoratorScrutorStartupTest`类中重用这个测试。它们是空的，只将测试路由到正确的程序。以下是一个Visual
    Studio测试资源管理器的示例：
- en: '![Figure 11.7: A Visual Studio Explorer screenshot displaying the Decorator
    integration tests.](img/file54.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图11.7：显示装饰器集成测试的Visual Studio资源管理器截图。](img/file54.png)'
- en: 'Figure 11.7: A Visual Studio Explorer screenshot displaying the Decorator integration
    tests.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7：一个显示装饰器集成测试的Visual Studio资源管理器截图。
- en: You can also do assembly scanning using Scrutor ([https://adpg.link/xvfS](https://adpg.link/xvfS)),
    which allows you to perform automatic dependency registration. This is outside
    the scope of this chapter, but it is worth looking into. Scrutor allows you to
    use the built-in IoC container for more complex scenarios, postponing the need
    to replace it with a third-party one.
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你还可以使用Scrutor进行组件扫描（[https://adpg.link/xvfS](https://adpg.link/xvfS)），这允许你执行自动依赖注册。这超出了本章的范围，但值得研究。Scrutor允许你在更复杂的场景中使用内置的IoC容器，推迟了替换第三方容器的需求。
- en: Conclusion
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'The Decorator pattern is one of our toolbox''s simplest yet most powerful design
    patterns. It augments existing classes without modifying them. A decorator is
    an independent block of logic that we can use to create complex and granular object
    trees that fit our needs.We also explored the Scrutor open-source library to assist
    us in registering our decorator with the container.The Decorator pattern helps
    us stay in line with the **SOLID** principles (and vice versa), as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式是我们工具箱中最简单但最强大的设计模式之一。它在不修改现有类的情况下增强它们。装饰器是一个独立的逻辑块，我们可以用它来创建复杂和细粒度的对象树，以满足我们的需求。我们还探讨了Scrutor开源库，以帮助我们注册装饰器到容器中。装饰器模式帮助我们遵循**SOLID**原则（反之亦然），如下所示：
- en: '**S**: The Decorator pattern suggests creating small classes to add behaviors
    to other classes, segregating responsibilities, and fostering reuse.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**：装饰器模式建议创建小的类来为其他类添加行为，分离责任，并促进复用。'
- en: '**O**: Decorators add behaviors to other classes without modifying them, which
    is literally the definition of the OCP.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**：装饰器在不修改其他类的情况下为它们添加行为，这实际上就是OCP的定义。'
- en: '**L**: N/A'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**：不适用'
- en: '**I**: By following the ISP, creating decorators for your specific needs should
    be easy. However, implementing the Decorator pattern may become difficult if your
    interfaces are too complex. Having a hard time creating a decorator is a good
    indicator that something is wrong with the design—a code smell. A well-segregated
    interface should be easy to decorate.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**：遵循ISP，为你的特定需求创建装饰器应该很容易。然而，如果你的接口过于复杂，实现装饰器模式可能会变得困难。难以创建装饰器是一个很好的指标，表明设计中存在问题——一个代码异味。一个良好分离的接口应该很容易装饰。'
- en: '**D**: Depending on abstractions is the key to the Decorator’s power.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**：依赖于抽象是装饰器强大功能的关键。'
- en: Next, we explore the Composite pattern, which helps us manage complex objects’
    structures differently than the decorator does.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨组合模式，它帮助我们以不同于装饰器的方式管理复杂对象的结构。
- en: Implementing the Composite design pattern
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现组合设计模式
- en: The Composite design pattern is another structural GoF pattern that helps us
    manage complex object structures.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 组合设计模式是另一个GoF的结构型设计模式，它帮助我们管理复杂的对象结构。
- en: Goal
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标
- en: The goal behind the Composite pattern is to create a hierarchical data structure
    where you don’t need to differentiate groups from single components, making the
    traversal and manipulation of the hierarchy easy for its consumers.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式背后的目标是创建一个层次化的数据结构，其中你不需要区分组与单个组件，使得消费者对层次结构的遍历和操作变得容易。
- en: You could think of the Composite pattern as a way of building a graph or a tree
    with self-managing nodes.
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以将组合模式视为一种构建具有自我管理节点的图或树的方法。
- en: Design
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计
- en: 'The design is straightforward; we have *components* and *composites*. Both
    implement a common interface that defines the shared operations. The *components*
    are single nodes, while the *composites* are collections of *components*. Let’s
    take a look at a diagram:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 设计很简单；我们有 `components` 和 `composites`。两者都实现了一个定义共享操作的公共接口。`components` 是单个节点，而
    `composites` 是 `components` 的集合。让我们看看一个图例：
- en: '![Figure 11.7: Composite class diagram](img/file55.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7：组合类图](img/file55.png)'
- en: 'Figure 11.7: Composite class diagram'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7：组合类图
- en: 'In the preceding diagram, `Client` depends on an `IComponent` interface and
    is unaware of the underlying implementation—it could be an instance of a `Component`
    or a `Composite`; it does not matter. Then, we have two implementations:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，`Client` 依赖于一个 `IComponent` 接口，并且对底层实现一无所知——它可能是一个 `Component` 或 `Composite`
    的实例；这并不重要。然后，我们有两种实现：
- en: '`Component` represents a single element; a leaf.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Component` 代表单个元素；一个叶节点。'
- en: '`Composite` represents a collection of `IComponent`. The `Composite` object
    uses its children to manage the hierarchy’s complexity by delegating part of the
    process to them.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Composite` 代表一组 `IComponent`。`Composite` 对象通过将部分过程委托给其子对象来使用其子对象来管理层次结构的复杂性。'
- en: Those three pieces put together create the Composite design pattern. Considering
    that it is possible to add instances of the `Composite` and `Component` classes
    as children of other `Composite` objects, it is possible to create complex, non-linear,
    and self-managed data structures with next to no effort.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个部分组合在一起就形成了组合设计模式。考虑到可以将 `Composite` 和 `Component` 类的实例添加为其他 `Composite`
    对象的子对象，我们可以几乎不费吹灰之力地创建复杂、非线性、自我管理的数据结构。
- en: You are not limited to one type of component and one type of composite; you
    can create as many implementations of the `IComponent` interface as you need.
    Then, you can even mix and match them to create a non-linear tree.
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您不仅限于一种组件和一种组合；您可以根据需要创建尽可能多的 `IComponent` 接口的实现。然后，您甚至可以将它们混合匹配以创建一个非线性树。
- en: Project – BookStore
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 – BookStore
- en: '**Context**: We built a program in the past to support a bookstore. However,
    the store is going so well that our little program is not enough anymore. Our
    fictional company now owns multiple stores. They want to divide those stores into
    sections and manage book sets and single books. After a few minutes of gathering
    information and asking them questions, we realize they can have sets of sets,
    subsections, and think of creating sub-stores, so we need a flexible design.We
    have decided to use the Composite pattern to solve this problem. Here’s our class
    hierarchy:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文**：我们过去编写了一个程序来支持书店。然而，商店经营得如此之好，我们的小程序已经不够用了。我们虚构的公司现在拥有多个商店。他们希望将这些商店划分为区域并管理书籍集合和单本书。在收集信息和询问他们几分钟之后，我们意识到他们可以有集合的集合、子部分，并考虑创建子商店，因此我们需要一个灵活的设计。我们决定使用组合模式来解决这个问题。以下是我们的类层次结构：'
- en: '![Figure 11.8: the BookStore project composite class hierarchy](img/file56.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.8：BookStore 项目的组合类层次结构](img/file56.png)'
- en: 'Figure 11.8: the BookStore project composite class hierarchy'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8：BookStore 项目的组合类层次结构
- en: 'Due to the complexity of our class hierarchy and the uncertainty of a project
    in an early stage, we decided that a factory would be adequate to create our class
    hierarchy, showcase our design, and validate it with the customer. Here’s the
    high-level design:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的类层次结构复杂，且项目早期阶段的不确定性，我们决定使用工厂来创建我们的类层次结构，展示我们的设计，并让客户验证。以下是高级设计：
- en: '![Figure 11.9: high-level design of the BookStore project](img/file57.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.9：BookStore 项目的概要设计](img/file57.png)'
- en: 'Figure 11.9: high-level design of the BookStore project'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9：BookStore 项目的概要设计
- en: 'We decided to aim for the smallest possible interface to get the ball rolling.
    Since we want to know how many items are available in any part of the store and
    what type of component we are interacting with, we created the following interface:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定追求尽可能小的接口以启动项目。由于我们想知道商店任何部分有多少可用项目以及我们正在与哪种类型的组件交互，我们创建了以下接口：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `Count` property allows us to calculate how many items are available under
    the corporation, a store, a section, a set, or any other composite component we
    create in the future. The `Type` property forces each component to display its
    type linearly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Count` 属性使我们能够计算在公司、商店、部分、集合或未来创建的任何其他组合组件下有多少可用项目。`Type` 属性强制每个组件线性显示其类型。'
- en: We can create such a minimal interface because we are not executing any operations
    on the data structure but counting the elements, then serializing it to JSON.
    The serializer will take care of navigating the class hierarchy for us. In another
    context, the minimal subset of properties might be more than this. For example,
    in this case, we could have added a `Name` property to the interface, but the
    book's name is its title, so I decided not to include it.
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们能够创建这样一个最小化界面，因为我们不是在数据结构上执行任何操作，而是在计数元素，然后将它序列化为JSON。序列化器将为我们处理遍历类层次结构。在另一个上下文中，属性的最小子集可能比这更多。例如，在这种情况下，我们可以在接口中添加一个`Name`属性，但书籍的名称就是它的标题，所以我决定不包含它。
- en: 'Next, let’s create our composite structure, starting with the `Book` class
    (the *Component*):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建我们的复合结构，从`Book`类（即*组件*）开始：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding `Book` class implements the interface by always returning a count
    of 1 because it is a single book, a leaf in the tree. The `Type` property is also
    hard-coded. As a book, the class requires a title upon construction that it stores
    in the `Title` property (not inherited and only available to `Book` instances).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`Book`类通过总是返回1个计数来实现接口，因为它是一本书，是树中的一个叶节点。`Type`属性也是硬编码的。作为一个书籍类，它在构造时需要一个标题，并将其存储在`Title`属性中（不是继承的，并且仅对`Book`实例可用）。
- en: In a real scenario, we’d have more properties, like the ISBN and author, but
    doing so here would just clutter the example. We are not designing a real bookstore
    but learning about the Composite pattern.
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在实际场景中，我们会有更多的属性，比如ISBN和作者，但这样做在这里只会使示例变得混乱。我们不是在设计一个真正的书店，而是在学习复合模式。
- en: 'Next, let’s create our composite component, the `BookComposite` class:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建我们的复合组件，`BookComposite`类：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `BookComposite` class implements the following shared features:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookComposite`类实现了以下共享功能：'
- en: Children management (highlighted in the code).
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 儿童管理（在代码中突出显示）。
- en: Setting the `Name` property of the composite object and forcing the classes
    inheriting it to set a name upon construction.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置复合对象的`Name`属性并强制其继承的类在构造时设置一个名称。
- en: Automatically finds and sets the `Type` name of its derived class.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动查找并设置其派生类的`Type`名称。
- en: Counting the number of children (and, implicitly, the children’s children).
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算子项的数量（以及隐含的子项的子项数量）。
- en: Exposing the children through the `Children` property and ensuring consumers
    can’t modify the collection from the outside by returning a `ReadOnlyCollection`
    object.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`Children`属性公开子项，并确保消费者不能从外部修改集合，通过返回一个`ReadOnlyCollection`对象来实现。
- en: Using the LINQ `Sum()` extension method in the `children.Sum(child =>` `child.Count());`
    expression allowed us to replace a more complex `for` loop and an accumulator
    variable.
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在`children.Sum(child => child.Count());`表达式中使用LINQ的`Sum()`扩展方法，使我们能够替换一个更复杂的`for`循环和一个累加变量。
- en: ''
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Adding the `virtual` modifier to the `Type` property allows sub-types to override
    the property in case their type’s name does not reflect the type that should be
    displayed in the program.
  id: totrans-143
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过将`virtual`修饰符添加到`Type`属性，允许子类型在它们类型名称不反映应显示在程序中的类型时覆盖该属性。
- en: 'Now, we can start implementing the other classes of our complex composite hierarchy
    and assign a responsibility to each class, showing how flexible the Composite
    pattern is.The following classes inherit from the `BookComposite` class:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始实现我们复杂复合层次结构中的其他类，并为每个类分配一个责任，展示复合模式是多么灵活。以下类继承自`BookComposite`类：
- en: The `Corporation` class represents the corporation that owns multiple stores.
    However, it is not limited to owning stores; a corporation could own other corporations,
    stores, or any other `IComponent`.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Corporation`类代表拥有多个商店的公司。然而，它不仅限于拥有商店；公司可以拥有其他公司、商店或任何其他`IComponent`。'
- en: The `Store` class represents a bookstore.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Store`类代表书店。'
- en: The `Section` class represents a section of a bookstore, an aisle, or a category
    of books.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Section`类代表书店的一个部分，一个通道或书籍的一个类别。'
- en: The `Set` class represents a book set, such as a trilogy.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set`类代表一个书籍集合，例如三部曲。'
- en: 'These can be composed of any `IComponent`, making this an ultra-flexible data
    structure. Let’s look at the code for these `BookComposite` sub-types, starting
    with the `Corporation` class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以由任何`IComponent`组成，这使得这是一个超灵活的数据结构。让我们看看这些`BookComposite`子类型的代码，从`Corporation`类开始：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The corporation contributes a CEO to the model because someone has to manage
    the place.Next, we look at the `Store` class:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 公司向模型贡献了一位首席执行官，因为有人需要管理这个地方。接下来，我们看看 `Store` 类：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: On top of the `BookComposite` members, a store has a manager and a location.Now,
    the `Section` class does not add anything, but we can use it as a flexible organizer:namespace
    Composite.Models;
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `BookComposite` 成员之上，商店有一个经理和位置。现在，`Section` 类没有添加任何内容，但我们可以将其用作灵活的组织者：namespace
    Composite.Models;
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, the `Set` class allows creating the book set upon construction through
    the books parameter:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Set` 类允许通过书籍参数在构造时创建书籍集合：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Composing a set of books upon creation of the instance will be convenient later
    when we assemble the tree.Next, let’s explore the last part of the program that
    helps encapsulate the data structure’s creation: the factory.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建实例时组合书籍集合将方便我们稍后组装树。接下来，让我们探索程序的最后部分，它有助于封装数据结构的创建：工厂。
- en: The factory is not part of the Composite pattern, but now that we know what
    a factory is, we can use one to encapsulate the creation logic of our data structure
    and talk about it.
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 工厂不是复合模式的一部分，但现在我们知道了工厂是什么，我们可以使用一个工厂来封装我们数据结构的创建逻辑并讨论它。
- en: 'The factory interface looks like the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂接口看起来如下所示：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The default concrete implementation of the `ICorporationFactory` interface
    is the `DefaultCorporationFactory` class. It creates a large non-linear data structure
    with sections, subsections, sets, and subsets. This whole structure is defined
    using our composite model in the `DefaultCorporationFactory` class. Due to its
    large size, let’s start with the class’s skeleton and its `Create` method:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`ICorporationFactory` 接口的默认具体实现是 `DefaultCorporationFactory` 类。它创建了一个包含部分、子部分、集合和子集的大型非线性数据结构。整个结构是在
    `DefaultCorporationFactory` 类中使用我们的复合模型定义的。由于其大小庞大，让我们从类的骨架及其 `Create` 方法开始：'
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding `Create` method, we create the corporation, add two stores,
    then return the result.The `CreateTaleTowersStore` and `CreateEpicNexusStore`
    methods create a store, set their name, address, and manager, and create three
    sections each:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的 `Create` 方法中，我们创建了公司，添加了两个商店，然后返回结果。`CreateTaleTowersStore` 和 `CreateEpicNexusStore`
    方法创建了一个商店，设置了其名称、地址和经理，并为每个商店创建了三个部分：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Both stores share two sections (have the same books; highlighted code), each
    with a unique section. If we look at the `CreateFictionSection` method, it adds
    an imaginary book and a subsection:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 两个商店共享两个部分（有相同的书籍；高亮代码），每个部分都有独特的部分。如果我们查看 `CreateFictionSection` 方法，它添加了一本虚构的书籍和一个子部分：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `CreateScienceFictionSection` method adds an invented book and the Star
    Wars book set composed of three trilogies (a set of sets):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateScienceFictionSection` 方法添加了一本虚构的书籍和由三部曲组成的星球大战书籍集合（一个集合的集合）：'
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, if we look at this part of the data structure, we have the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们查看数据结构的一部分，我们有以下内容：
- en: '![Figure 11.10: The Fiction section of the Epic Nexus store data](img/file58.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.10：Epic Nexus 商店数据的小说部分](img/file58.png)'
- en: 'Figure 11.10: The Fiction section of the Epic Nexus store data'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10：Epic Nexus 商店数据的小说部分
- en: 'In the big scheme of things, the whole organizational structure, down to the
    section level (without the books and sets), looks like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在更大的体系中，整个组织结构，直到部分级别（不包括书籍和集合），看起来如下所示：
- en: '![Figure 11.11: the composite hierarchy without the books and sets](img/file59.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.11：没有书籍和集合的复合层次结构](img/file59.png)'
- en: 'Figure 11.11: the composite hierarchy without the books and sets'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11：没有书籍和集合的复合层次结构
- en: I omitted to publish the whole data structure, including the books, as an image
    because it is too large and would be hard to read. Rest assured, the content itself
    is unimportant, and the section we are studying is enough to understand the flexibility
    the composite pattern brings to the design.
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我省略了整个数据结构（包括书籍）的图像发布，因为它太大，难以阅读。请放心，内容本身并不重要，我们正在研究的部分足以理解复合模式为设计带来的灵活性。
- en: 'As we explore this, we can see how flexible the design is. We can create almost
    any organizational structure we want.Now, let’s look at the `Program.cs` file
    and register our dependencies and an endpoint to query the data structure:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索过程中，我们可以看到设计是多么灵活。我们可以创建几乎任何我们想要的组织结构。现在，让我们看看 `Program.cs` 文件并注册我们的依赖项以及一个用于查询数据结构的端点：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding code registers the factory that creates the corporation data
    structure with the container and an endpoint to serve it.When we execute the code,
    we get the full data structure or the corporation. For brevity reasons, the following
    JSON represents the fiction section, excluding the books:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将创建公司数据结构的工厂与容器以及一个用于提供服务的端点注册。当我们执行代码时，我们得到完整的数据结构或公司。为了简洁起见，以下JSON表示虚构部分，不包括书籍：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The value of the `count` fields reflect the total count. In this case, there
    is no book so the count should be 0\. If you run the program and play with the
    preprocessor symbols define in the `DefaultCorporationFactory.cs` file (`ADD_BOOKS`,
    `ADD_SETS`, and `ONLY_FICTION`), you will end up with different number.
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`count`字段的值反映了总数。在这种情况下，没有书籍，所以计数应该是0。如果你运行程序并玩转在`DefaultCorporationFactory.cs`文件中定义的预处理器符号（`ADD_BOOKS`、`ADD_SETS`和`ONLY_FICTION`），你将得到不同的数字。'
- en: The Composite pattern allowed us to render a complex data structure in a small
    method call. Since each component autonomously handles itself, the Composite pattern
    removes the burden of managing this complexity from the consumer.I encourage you
    to play around with the existing data structure so that you understand the pattern.
    You could also try adding a `Movie` class to manage movies; a bookstore must diversify
    its activities. You could also differentiate movies from books so that customers
    are not confused. The bookstores could have physical and digital books as well.If
    you are still looking for more, try building a new application from scratch and
    use the Composite pattern to create, manage, and display a multi-level menu structure
    or a file system API.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式允许我们在一个小的方法调用中渲染复杂的数据结构。由于每个组件都自主处理自身，组合模式从消费者那里移除了管理这种复杂性的负担。我鼓励你尝试与现有的数据结构互动，以便理解这个模式。你也可以尝试添加一个`Movie`类来管理电影；书店必须多样化其活动。你还可以区分电影和书籍，以免顾客混淆。书店可以有实体书和数字书。如果你还在寻找更多，尝试从头开始构建一个新的应用程序，并使用组合模式来创建、管理和显示多级菜单结构或文件系统API。
- en: Conclusion
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'The Composite pattern effectively builds, manages, and maintains complex non-linear
    data structures. Its power is primarily in its self-management capabilities. Each
    node, component, or composite is responsible for its own logic, leaving little
    to no work for the composite’s consumers. Of course, a more complex scenario would
    have led to a more complex interface.Using the Composite pattern helps us follow
    the **SOLID** principles in the following ways:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式有效地构建、管理和维护复杂的非线性数据结构。它的力量主要在于其自我管理能力。每个节点、组件或组合都负责自己的逻辑，留给组合消费者的工作很少或没有。当然，更复杂的场景会导致更复杂的接口。使用组合模式有助于我们以下方式遵循**SOLID**原则：
- en: '**S**: It helps divide multiple elements of a complex data structure into small
    classes to split responsibilities.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**: 它有助于将复杂数据结构中的多个元素划分为小类，以分割责任。'
- en: '**O**: By allowing us to “mix and match” different implementations of `IComponent`
    interface, the Composite pattern allows us to extend the data structure without
    impacting the other existing classes. For example, you could create a new class
    that implements `IComponent` and start using it immediately without modifying
    any other component classes.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**: 通过允许我们“混合匹配”`IComponent`接口的不同实现，组合模式使我们能够在不影响其他现有类的情况下扩展数据结构。例如，你可以创建一个新的实现`IComponent`的类，并立即开始使用它，而无需修改任何其他组件类。'
- en: '**L**: N/A'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**: 无'
- en: '**I**: The Composite pattern may violate the ISP when single items implement
    operations that only impact the collections, like the `Add` and `Remove` methods,
    but we have not done this here.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**: 当单个项目实现仅影响集合的操作时，如`Add`和`Remove`方法，组合模式可能会违反ISP原则，但在这里我们没有这样做。'
- en: '**D**: The Composite pattern actors depend solely on `IComponent` which invert
    the dependency flow.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**: 组合模式的行为者仅依赖于`IComponent`，这反转了依赖关系流。'
- en: Next, we move to a different type of structural pattern that adapts one interface
    to another.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将转向另一种类型的结构模式，它将一个接口适配到另一个接口。
- en: Implementing the Adapter design pattern
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现适配器设计模式
- en: The Adapter pattern is another structural design pattern that allows two incompatible
    interfaces to work together without modifying their existing code. This pattern
    introduces a wrapper class called the *Adapter*, which bridges the gap between
    the interfaces.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式是另一种结构型设计模式，它允许两个不兼容的接口在不修改它们现有代码的情况下一起工作。该模式引入了一个名为 *适配器* 的包装类，它桥接了接口之间的差距。
- en: Goal
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标
- en: The Adapter design pattern is applicable when we want to use an existing class,
    but its interface is incompatible with what we want to use it for. Instead of
    refactoring the class, which could introduce bugs or errors in the existing codebase
    or even cascade changes to other parts of the system, we can use an *Adapter*
    class to make the class's interface compatible with the *Target* interface. The
    Adapter pattern is handy when we cannot change the *Adaptee’s* code or do not
    want to change it.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要使用现有的类，但其接口与我们想要使用它的方式不兼容时，适配器设计模式适用。我们不是重构该类，这可能会在现有的代码库中引入错误或错误，甚至可能将更改级联到系统的其他部分，而是可以使用一个
    *适配器* 类使该类的接口与 *目标* 接口兼容。当我们不能更改 *适配者* 的代码或不想更改它时，适配器模式非常有用。
- en: Design
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计
- en: 'You can think of the adapter as a power outlet’s universal adapter; you can
    connect a North American device to a European outlet by connecting it to the adapter
    and then to the power outlet. The Adapter design pattern does precisely that but
    for APIs.Let’s start by looking at the following diagram:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将适配器想象成电源插座的通用适配器；你可以通过将其连接到适配器，然后连接到电源插座，将北美设备连接到欧洲插座。适配器设计模式正是如此，但针对的是
    API。让我们先看看以下图示：
- en: '![Figure 11.12: Adapter class diagram](img/file60.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.12：适配器类图](img/file60.png)'
- en: 'Figure 11.12: Adapter class diagram'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12：适配器类图
- en: 'In the preceding diagram, we have the following actors:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们有以下参与者：
- en: The `ITarget` interface holds the contract we want (or have) to use.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ITarget` 接口包含我们想要（或已经）使用的合约。'
- en: The `Adaptee` class represents the concrete component we want to use that does
    not conform to `ITarget.`
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Adaptee` 类代表我们想要使用的具体组件，它不符合 `ITarget`。'
- en: The `Adapter` class adapts the `Adaptee` class to the `ITarget` interface.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Adapter` 类将 `Adaptee` 类适配到 `ITarget` 接口。'
- en: 'There is a second way of implementing the Adapter pattern that implies inheritance.
    If you can go for composition, go for it, but if you need access to `protected`
    methods or other internal states of `Adaptee`, you can go for inheritance instead,
    like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 实现适配器模式的第二种方法涉及到继承。如果你可以选择组合，那就选择组合，但如果你需要访问 `protected` 方法或其他 `Adaptee` 的内部状态，你可以选择继承，如下所示：
- en: '![Figure 11.13: Adapter class diagram inheriting the Adaptee](img/file61.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.13：继承适配者的适配器类图](img/file61.png)'
- en: 'Figure 11.13: Adapter class diagram inheriting the Adaptee'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13：继承适配者的适配器类图
- en: The actors are the same, but instead of composing the `Adapter` class with the
    `Adaptee` class, the `Adapter` class inherits from the `Adaptee` class. This design
    makes the `Adapter` class become both an `Adaptee` and an `ITarget`.Let’s explore
    how this looks in code.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 参与者相同，但不是通过组合 `Adapter` 类与 `Adaptee` 类，而是 `Adapter` 类从 `Adaptee` 类继承。这种设计使 `Adapter`
    类同时成为 `Adaptee` 和 `ITarget`。让我们探索一下这在代码中是如何实现的。
- en: Project – Greeter
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 – 问候器
- en: '**Context**: We’ve programmed a highly sophisticated greeting system that we
    want to reuse in a new program. However, its interface does not match the new
    design, and we cannot modify it because other systems use that greeting system.To
    fix this problem, we decided to apply the Adapter pattern. Here is the code of
    the external greeter (`ExternalGreeter`) and the new interface (`IGreeter`) used
    in the new system. This code must not directly modify the `ExternalGreeter` class
    to prevent any breaking changes from occurring in other systems:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文**：我们编写了一个高度复杂的问候系统，我们希望在新的程序中重用它。然而，它的接口与新设计不匹配，我们无法修改它，因为其他系统使用该问候系统。为了解决这个问题，我们决定应用适配器模式。以下是外部问候器（`ExternalGreeter`）和在新系统中使用的新的接口（`IGreeter`）的代码。这段代码不得直接修改
    `ExternalGreeter` 类，以防止对其他系统造成破坏性更改：'
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next is how the external greeter is adapted to meet the latest requirements:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是如何将外部问候器适配以满足最新要求：
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the preceding code, the actors are as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，参与者如下：
- en: The `IGreeter` interface represents the *Target* and is the interface that we
    must use.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IGreeter` 接口代表 *目标*，是我们必须使用的接口。'
- en: The `ExternalGreeter` class represents the *Adaptee* and is the external component
    that already contains all the logic that someone programmed and tested. That code
    could be in an external assembly or installed from a NuGet package.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExternalGreeter`类代表*适配器*，是包含所有逻辑的外部组件，这些逻辑是由某人编写的并经过测试。该代码可能位于外部程序集或通过NuGet包安装。'
- en: The `ExternalGreeterAdapter` class represents the *Adapter* and is where the
    adapter does its job. In this case, the `Greeting` method calls the `GreetByName`
    method of the `ExternalGreeter` class, which implements the greeting logic.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExternalGreeterAdapter`类代表*适配器*，这是适配器执行其工作的地方。在这种情况下，`Greeting`方法调用`ExternalGreeter`类的`GreetByName`方法，该类实现了问候逻辑。'
- en: Now, we can call the `Greeting` method and get the result of the `GreetByName`
    call. With this in place, we can reuse the existing logic through the `ExternalGreeterAdapter`
    class.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以调用`Greeting`方法并获取`GreetByName`调用的结果。有了这个，我们可以通过`ExternalGreeterAdapter`类重用现有的逻辑。
- en: We can also test `IGreeter` consumers by mocking the `IGreeter` interface without
    dealing with the `ExternalGreeterAdapter` class.
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们还可以通过模拟`IGreeter`接口来测试`IGreeter`消费者，而不必处理`ExternalGreeterAdapter`类。
- en: 'In this case, the “complex logic” is pretty simple, but we are here for the
    Adapter pattern, not for imaginary business logic. Now, let’s take a look at the
    consumer:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，“复杂逻辑”相当简单，但我们在这里是为了适配器模式，而不是为了想象中的业务逻辑。现在，让我们看看消费者：
- en: '[PRE31]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding code, we composed our application by registering the `ExternalGreeterAdapter`
    class as a singleton bound to the `IGreeter` interface. We also informed the container
    to provide a single instance of `ExternalGreeter` class whenever requested (in
    this case, we inject it into the `ExternalGreeterAdapter` class).Then, the consumer
    (*Client* in the class diagrams) is the highlighted endpoint where the `IGreeter`
    interface is injected as a parameter. Then, the delegate calls the `Greeting`
    method on that injected instance and outputs the greeting message to the response.The
    following diagram represents what’s happening in this system:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过将`ExternalGreeterAdapter`类注册为与`IGreeter`接口绑定的单例来构建我们的应用程序。我们还通知容器，每当请求时（在这种情况下，我们将其注入到`ExternalGreeterAdapter`类中）提供`ExternalGreeter`类的单个实例。然后，消费者（在类图中为*客户端*）是突出显示的端点，其中`IGreeter`接口作为参数注入。然后，委托调用注入实例的`Greeting`方法并将问候消息输出到响应。以下图表示这个系统正在发生的事情：
- en: '![Figure 11.14: Greeter system sequence diagram](img/file62.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图11.14：问候系统序列图](img/file62.png)'
- en: 'Figure 11.14: Greeter system sequence diagram'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14：问候系统序列图
- en: And voilà! We’ve adapted the `ExternalGreeterAdapter` class to the `IGreeter`
    interface with little effort.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们几乎不费吹灰之力就将`ExternalGreeterAdapter`类适配到了`IGreeter`接口。
- en: Conclusion
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'The Adapter pattern is another simple pattern that offers flexibility. With
    it, we can use older or non-conforming components without rewriting them. Of course,
    depending on the *Target* and *Adaptee* interfaces, you may need to put more or
    less effort into writing the code of the *Adapter* class.Now, let’s learn how
    the Adapter pattern can help us follow the **SOLID** principles:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式是另一种提供灵活性的简单模式。通过它，我们可以使用旧的或不符合规范的组件，而无需重写它们。当然，根据*目标*和*适配器*接口，你可能需要投入更多或更少的精力来编写*适配器*类的代码。现在，让我们学习适配器模式如何帮助我们遵循**SOLID**原则：
- en: '**S**: The Adapter pattern has only one responsibility: make an interface work
    with another interface.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**：适配器模式只有一个职责：使一个接口与另一个接口协同工作。'
- en: '**O**: The Adapter pattern allows us to modify the *Adaptee’s* interface without
    the need to modify its code.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**：适配器模式允许我们修改*适配器*的接口，而无需修改其代码。'
- en: '**L**: Inheritance is not much of a concern regarding the Adapter pattern,
    so this principle does not apply once again. If *Adapter* inherits from *Adaptee*,
    the goal is to change its interface, not its behavior, which should conform to
    the LSP.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**：关于适配器模式，继承不是一个大问题，因此这个原则再次不适用。如果*适配器*从*适配器*继承，目标是改变其接口，而不是其行为，这应该符合LSP。'
- en: '**I**: We can view the *Adapter* class as a facilitator to the ISP, with the
    *Target* interface as the ultimate destination. The Adapter pattern relies on
    the design of the *Target* interface but doesn''t directly influence it. Per this
    principle, our primary focus should be to design the *Target* interface in a manner
    that abides by the ISP.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**：我们可以将*适配器*（Adapter）类视为ISP的促进者，以*目标*（Target）接口作为最终目的地。适配器模式依赖于*目标*接口的设计，但并不直接影响它。根据这一原则，我们的主要焦点应该是以遵守ISP的方式设计*目标*接口。'
- en: '**D**: The Adapter pattern introduces only an implementation of the *Target*
    interface. Even if the *Adapter* depends on a concrete class, it breaks the direct
    dependency on that external component by adapting it to the *Target* interface.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**：适配器模式仅引入了*目标*接口的一个实现。即使*适配器*依赖于一个具体类，它通过将其适配到*目标*接口来打破对该外部组件的直接依赖。'
- en: Next, we explore the last structural pattern of the chapter that teaches foundational
    concepts.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索本章的最后一个结构型模式，它教授基础概念。
- en: Implementing the Façade design pattern
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现外观设计模式
- en: The Façade pattern is a structural pattern that simplifies the access to a complex
    system. It is very similar to the Adapter pattern, but it creates a wall (a façade)
    between one or more subsystems. The big difference between the adapter and the
    façade is that instead of adapting an interface to another, the façade simplifies
    the use of a subsystem, typically by using multiple classes of that subsystem.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式是一种结构型模式，它简化了对复杂系统的访问。它与适配器模式非常相似，但它在一或多个子系统之间创建了一堵墙（外观）。适配器和外观之间的主要区别在于，外观不是将一个接口适配到另一个接口，而是通过使用该子系统的多个类来简化子系统的使用。
- en: We can apply the same idea to shielding one or more programs, but in this case,
    we call the façade a gateway—more on that in *Chapter 19*, *Introduction to Microservices
    Architecture*.
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们可以将同样的想法应用于保护一个或多个程序，但在这个情况下，我们将外观称为网关——更多内容请参阅第19章，“微服务架构简介”。
- en: The Façade pattern is extremely useful and can be adapted to multiple situations.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式非常实用，并且可以适应多种情况。
- en: Goal
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标
- en: The Façade pattern aims to simplify the use of one or more subsystems by providing
    an interface that is easier to use than the subsystems themselves, shielding the
    consumers from that complexity.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式旨在通过提供一个比子系统本身更容易使用的接口来简化一个或多个子系统的使用，从而保护消费者免受这种复杂性。
- en: Design
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计
- en: 'Imagine a system with a multitude of complex classes. Direct interaction between
    the consuming code and these classes can become problematic due to coupling, complexity,
    and low code readability and maintainability. The Facade design pattern offers
    a solution by providing a unified interface to a set of APIs in a subsystem, making
    it easier to use.The Facade class contains references to the objects of the complex
    subsystem and delegates client requests to the appropriate subsystem object. From
    a client''s perspective, it only interacts with a single, simplified interface
    represented by the Facade. Behind the scenes, the Facade coordinates with the
    subsystem''s components to fulfill the client''s request.We could create multiple
    diagrams representing a multitude of subsystems, but let’s keep things simple.
    Remember that you can replace the single subsystem shown in the following diagram
    with as many subsystems as you need to adapt:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个拥有众多复杂类的系统。由于耦合、复杂性和代码的可读性和可维护性低，直接在消费代码和这些类之间进行交互可能会变得有问题。外观设计模式通过提供一个统一的接口来访问子系统中的一组API，从而提供了一种解决方案，使得使用更加容易。外观类包含对复杂子系统对象的引用，并将客户端请求委派给适当的子系统对象。从客户端的角度来看，它只与外观表示的单个简化接口进行交互。幕后，外观与子系统的组件协调以满足客户端的请求。我们可以创建多个表示众多子系统的图表，但让我们保持简单。记住，你可以将以下图表中显示的单个子系统替换为你需要适配的任意数量的子系统：
- en: '![Figure 11.15: A class diagram representing a Façade object that hides a complex
    subsystem](img/file63.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图11.15：表示隐藏复杂子系统的外观对象的类图](img/file63.png)'
- en: 'Figure 11.15: A class diagram representing a Façade object that hides a complex
    subsystem'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.15：表示隐藏复杂子系统的外观对象的类图
- en: 'The *Façade* plays the intermediary between the *Client* and the subsystem,
    simplifying its usage. Let’s see this in action as a sequence diagram:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*外观*（Façade）在*客户端*和子系统之间扮演着中介的角色，简化了其使用。让我们通过一个时序图来观察这一过程：'
- en: '![Figure 11.16: A sequence diagram representing a Façade object that interacts
    with a complex subsystem](img/file64.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.16：表示 Façade 对象与复杂子系统交互的序列图](img/file64.png)'
- en: 'Figure 11.16: A sequence diagram representing a Façade object that interacts
    with a complex subsystem'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.16：表示 Façade 对象与复杂子系统交互的序列图
- en: 'In the preceding diagram, the *Client* calls the *Façade* once, while the *Façade*
    places multiple calls against different classes.There are multiple ways of implementing
    a façade:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，客户端调用一次 `Façade`，而 `Façade` 对不同的类进行了多次调用。实现外观有多种方式：
- en: '**Opaque façades**: In this form, the `Façade` class is inside the subsystem.
    All other classes of the subsystem have an `internal` visibility modifier. This
    way, only the classes inside the subsystem can interact with the other internal
    classes, forcing the consumers to use the `Façade` class.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不透明外观**: 在这种形式中，`Façade` 类位于子系统内部。子系统中的所有其他类都有一个 `internal` 可见性修饰符。这样，只有子系统内部的类可以与其他内部类交互，迫使消费者使用
    `Façade` 类。'
- en: '**Transparent façades**: In this form, the classes can have a `public` modifier,
    allowing the consumers to use them directly or to use the `Façade` class. This
    way, we can create the `Façade` class inside or outside the subsystem.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**透明外观**: 在这种形式中，类可以有一个 `public` 修饰符，允许消费者直接使用它们，或者使用 `Façade` 类。这样，我们可以在子系统内部或外部创建
    `Façade` 类。'
- en: '**Static façades**: In this form, the `Façade` class is `static`. We can implement
    a static façade as opaque or transparent.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态外观**: 在这种形式中，`Façade` 类是 `static` 的。我们可以将静态外观实现为不透明或透明。'
- en: I recommend using static façades as a last resort because `static` elements
    limit flexibility and testability.
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我建议将静态外观作为最后的手段，因为 `static` 元素限制了灵活性并降低了可测试性。
- en: We look at some code next.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们看看一些代码。
- en: Project – The façades
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 – 外观
- en: 'In this example, we play with the following C# projects:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们玩以下 C# 项目：
- en: The *OpaqueFacadeSubSystem* class library showcases an **opaque façade**.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OpaqueFacadeSubSystem` 类库展示了 **不透明外观**。'
- en: The *TransparentFacadeSubSystem* class library showcases a **transparent façade**.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TransparentFacadeSubSystem` 类库展示了 **透明外观**。'
- en: The *Facade* project is a REST API that consumes the façades. It exposes two
    endpoints to access the *OpaqueFacadeSubSystem* project, and two others that target
    the *TransparentFacadeSubSystem* project.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Facade` 项目是一个消耗外观的 REST API。它公开了两个端点以访问 `OpaqueFacadeSubSystem` 项目，还有两个端点针对
    `TransparentFacadeSubSystem` 项目。'
- en: Let’s start with the class libraries.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从类库开始。
- en: To follow the SOLID principles, adding some interfaces representing the elements
    of the subsystem seemed appropriate. In subsequent chapters, we explore how to
    organize our abstractions to be more reusable, but for now, both abstractions
    and implementations are in the same assembly.
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了遵循 SOLID 原则，添加一些代表子系统元素的接口似乎是合适的。在随后的章节中，我们将探讨如何组织我们的抽象以使其更具可重用性，但到目前为止，抽象和实现都在同一个程序集中。
- en: Opaque façade
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不透明外观
- en: 'In this assembly, only the façade is public; all the other classes are internal,
    which means they are hidden from the external world. In most cases, this is not
    ideal; hiding everything makes the subsystem less flexible and harder to extend.However,
    you may want to control access to your internal APIs in some scenarios. This may
    be because they are not mature enough and you don’t want any third party to depend
    on them, or for any other reasons you deem appropriate for your specific use case.Let’s
    start by taking a look at the following subsystem code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序集中，只有外观是公开的；所有其他类都是 `internal`，这意味着它们对外部世界是隐藏的。在大多数情况下，这并不是理想的；隐藏一切使得子系统更不灵活，更难扩展。然而，在某些情况下，您可能希望控制对内部
    API 的访问。这可能是因为它们还不够成熟，您不希望任何第三方依赖它们，或者出于您认为适合您特定用例的任何其他原因。让我们先看看以下子系统代码：
- en: '[PRE32]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `OpaqueFacade` class is coupled with `ComponentA`, `ComponentB`, and `ComponentC`
    directly. There was no point in extracting any `internal` interfaces since the
    subsystem is not extensible anyway. We could have done this to offer some kind
    of internal flexibility, but in this case, there was no advantage.Besides this
    coupling, `ComponentA`, `ComponentB`, and `ComponentC` define two methods each,
    which return a string describing their source. With that code in place, we can
    observe what is happening and how the final result was composed.`OpaqueFacade`
    also exposes two methods, each composing a different message using the underlying
    subsystem’s components. This is a classic use of a façade; the façade queries
    other objects more or less complicatedly and then does something with the results,
    taking away the caller’s burden of knowing the subsystem.Since the members use
    the `internal` visibility modifier, we can’t directly register the dependencies
    with the IoC container from the program. To solve this problem, the subsystem
    can register its dependencies by adding an extension method. The following extension
    method is accessible by the consuming application:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpaqueFacade`类直接与`ComponentA`、`ComponentB`和`ComponentC`耦合。由于子系统本身不可扩展，提取任何`internal`接口都没有意义。我们本可以这样做以提供某种内部灵活性，但在这个情况下，这样做没有优势。除了这种耦合之外，`ComponentA`、`ComponentB`和`ComponentC`各自定义了两个方法，这些方法返回一个描述其来源的字符串。有了这些代码，我们可以观察正在发生的事情以及最终结果是如何组合的。`OpaqueFacade`还公开了两个方法，每个方法都使用底层子系统的组件组合不同的消息。这是外观的经典用法；外观以更多或更少的复杂性查询其他对象，然后对结果进行操作，从而减轻调用者了解子系统的负担。由于成员使用`internal`可见性修饰符，我们无法直接从程序中将依赖关系注册到IoC容器中。为了解决这个问题，子系统可以通过添加扩展方法来注册其依赖关系。以下扩展方法对消费应用程序是可访问的：'
- en: '[PRE33]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding code manually creates the dependencies and adds a binding to the
    `IOpaqueFacade` interface so the system can use it. This hides everything but
    the interface from the consumer.Before exploring the REST API, we look at the
    transparent façade implementation.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码手动创建了依赖关系，并将绑定添加到`IOpaqueFacade`接口，以便系统可以使用它。这样，除了接口之外，所有内容都从消费者那里隐藏起来。在探索REST
    API之前，我们来看看透明外观的实现。
- en: Transparent façade
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 透明外观
- en: 'The transparent façade is the most flexible type of façade and is exceptionally
    suitable for a system that leverages dependency injection. The implementation
    is similar to the opaque façade, but the `public` visibility modifier changes
    how consumers can access the class library elements. For this system, it was worth
    adding interfaces to allow the consumers of the subsystem to extend it when needed.First,
    let’s take a look at the abstractions:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 透明外观是最灵活的外观类型，非常适合利用依赖注入的系统。实现方式与不透明外观类似，但`public`可见性修饰符改变了消费者访问类库元素的方式。对于这个系统，添加接口以允许子系统消费者在需要时扩展它是值得的。首先，让我们看看抽象：
- en: '[PRE34]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The API of this subsystem is the same as the opaque façade. The only difference
    is how we can use and extend the subsystem (from a consumer standpoint). The implementations
    are mostly the same as well, but the classes implement the interfaces and are
    `public`; the highlighted elements represent those changes:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这个子系统的API与不透明外观相同。唯一的区别是我们如何使用和扩展子系统（从消费者角度来看）。实现方式也大致相同，但类实现了接口并且是`public`的；突出显示的元素代表这些变化：
- en: '[PRE35]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To simplify the use of the subsystem, we create the following extension method
    as a good practice that makes consuming the subsystem easier. Everything that
    we define in that method can be overridden from the composition root (which is
    not the case for the opaque façade):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化子系统的使用，我们创建以下扩展方法作为良好实践，这使得消费子系统更容易。在该方法中定义的所有内容都可以从组合根（对于不透明外观来说并非如此）中进行覆盖：
- en: '[PRE36]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: All the `new` elements are gone and have been replaced by simple dependency
    registration (singleton lifetimes, in this case). These little differences give
    us the tools to reimplement any part of the subsystem if we want to, as we cover
    soon.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 所有新的元素都已消失，并被简单的依赖注册（在这种情况下是单例生命周期）所取代。这些小小的差异为我们提供了工具，如果我们想的话，可以重新实现子系统的任何部分，正如我们很快就会看到的。
- en: We can register bindings in the transparent façade extension method because
    classes and interfaces are `public`. The container needs a public constructor
    to do its work.
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们可以在透明外观扩展方法中注册绑定，因为类和接口都是`public`的。容器需要一个公共构造函数来完成其工作。
- en: ''
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the opaque façade, we had to define the constructor of the `OpaqueFacade`
    class as `internal` because the type of its parameters (`ComponentA`, `ComponentB`,
    and `ComponentC`) are internal, making it impossible to leverage the container.
    Changing the visibility modifier of the opaque façade constructor from `internal`
    to `public` would have yielded a *CS0051 Inconsistent accessibility* error.
  id: totrans-273
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在不透明门面中，我们必须将`OpaqueFacade`类的构造函数定义为`internal`，因为其参数的类型（`ComponentA`、`ComponentB`和`ComponentC`）是`internal`，这使得无法利用容器。将不透明门面构造函数的可见性修饰符从`internal`更改为`public`将产生一个*CS0051
    可访问性不一致*错误。
- en: Besides those differences, the transparent façade plays the same role as the
    opaque façade, outputting the same result.We consume those two façades next.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些差异之外，透明门面与不透明门面扮演着相同的作用，输出相同的结果。接下来，我们将消费这两个门面。
- en: The program
  id: totrans-275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 程序
- en: 'Now, let’s analyze the consumer, an ASP.NET Core application that forwards
    HTTP requests to the façades and return the result as their response.The first
    step is to register the dependencies like this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析消费者，这是一个将HTTP请求转发到门面并返回其响应的ASP.NET Core应用程序。第一步是注册依赖项，如下所示：
- en: '[PRE37]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: With these extension methods, the application root is so clean that it is hard
    to know that we registered two subsystems against the IoC container. This is a
    good way of keeping your code organized and clean, especially when you’re building
    class libraries.
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用这些扩展方法，应用程序的根目录如此干净，以至于很难知道我们针对IoC容器注册了两个子系统。这是一种保持代码组织良好和干净的好方法，尤其是在构建类库时。
- en: 'Now that everything has been registered, the second thing we need to do is
    route those HTTP requests to the façades. Let’s take a look at the code first:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都已经注册，我们需要做的第二件事是将这些HTTP请求路由到门面。让我们首先看看代码：
- en: '[PRE38]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the preceding block, we define four routes. Each route dispatches the request
    to one of the façade’s methods (highlighted code) using the façade that is injected
    in its delegate.If you run the program and navigate to the `/transparent/a` endpoint,
    the page should display the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们定义了四个路由。每个路由使用注入在其委托中的门面将请求调度到门面的一个方法（突出显示的代码）。如果你运行程序并导航到`/transparent/a`端点，页面应该显示以下内容：
- en: '[PRE39]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'What happened is located inside the delegates. It uses the injected `ITransparentFacade`
    service and calls its `ExecuteOperationA()` method, and then outputs the `result`
    variable to the response stream.Now, let’s define how `ITransparentFacade` is
    composed:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的事情位于委托内部。它使用注入的`ITransparentFacade`服务并调用其`ExecuteOperationA()`方法，然后将`result`变量输出到响应流。现在，让我们定义`ITransparentFacade`是如何组成的：
- en: '`ITransparentFacade` is an instance of `TransparentFacade`.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ITransparentFacade`是`TransparentFacade`的一个实例。'
- en: We inject `IComponentA`, `IComponentB`, and `IComponentC` in the `TransparentFacade`
    class.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`TransparentFacade`类中注入`IComponentA`、`IComponentB`和`IComponentC`。
- en: These dependencies are instances of `ComponentA`, `ComponentB`, and `ComponentC`,
    respectively.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些依赖项分别是`ComponentA`、`ComponentB`和`ComponentC`的实例。
- en: 'Visually, the following flow happens:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 从视觉上看，以下流程发生：
- en: '![Figure 11.17: A representation of the call hierarchy that occurs when the
    consumer executes the ExecuteOperationA method](img/file65.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图11.17：消费者执行ExecuteOperationA方法时出现的调用层次结构表示](img/file65.png)'
- en: 'Figure 11.17: A representation of the call hierarchy that occurs when the consumer
    executes the ExecuteOperationA method'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17：消费者执行ExecuteOperationA方法时出现的调用层次结构表示
- en: 'In the preceding diagram, we can see the shielding that’s done by the façade
    and how it has made the consumer’s life easier: one call instead of four.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到门面（facade）所执行的屏蔽作用以及它是如何使消费者的生活变得更简单的：一次调用而不是四次。
- en: One of the hardest parts of using dependency injection is its abstractness.
    If you are not sure how all those parts are assembled, add a breakpoint into Visual
    Studio (let’s say, on the `var result = transparentFacade.ExecuteOperationA()`
    line) and run the application in debug mode. From there, **Step Into** each method
    call. That should help you figure out what is happening. Using the debugger to
    find the concrete types and their states can help find details about a system
    or diagnose bugs.
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用依赖注入最难的部分之一是其抽象性。如果你不确定所有这些部分是如何组装的，在Visual Studio中添加一个断点（比如说，在`var result
    = transparentFacade.ExecuteOperationA()`这一行）并以调试模式运行应用程序。从那里，**单步进入**每个方法调用。这应该有助于你弄清楚发生了什么。使用调试器查找具体类型及其状态可以帮助找到有关系统或诊断错误的详细信息。
- en: ''
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To use **Step Into**, you can use the following button or hit **F11**:'
  id: totrans-293
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要使用**单步进入**，你可以使用以下按钮或按**F11**：
- en: '![Figure 11.18: The Visual Studio Step Into (F11) button](img/file66.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.18：Visual Studio 的 Step Into（F11）按钮](img/file66.png)'
- en: 'Figure 11.18: The Visual Studio Step Into (F11) button'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.18：Visual Studio 的 Step Into（F11）按钮
- en: 'Calling the other endpoints lead to similar results. As a reference, here’s
    the result from the other endpoints.Here’s the result for the `/transparent/b`
    endpoint:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 调用其他端点会导致类似的结果。作为参考，这里是从其他端点得到的结果。这是 `/transparent/b` 端点得到的结果：
- en: '[PRE40]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here’s the results for the `/opaque/a` endpoint:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `/opaque/a` 端点得到的结果：
- en: '[PRE41]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here’s the result for the `/opaque/b` endpoint:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `/opaque/b` 端点得到的结果：
- en: '[PRE42]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Next, let’s update some results without changing the component’s code.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更新一些结果，而不改变组件的代码。
- en: Flexibility in action
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 灵活性在行动
- en: 'As discussed, the transparent façade adds more flexibility. Here, we explore
    this flexibility in action.**Context**: We want to change the behavior of the
    `TransparentFacade` class. At the moment, the result of the `transparent/b` endpoint
    looks like this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 正如讨论的那样，透明外观增加了更多的灵活性。在这里，我们探索这种灵活性在实际中的应用。**上下文**：我们想要改变 `TransparentFacade`
    类的行为。目前，`transparent/b` 端点得到的结果如下：
- en: '[PRE43]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To demonstrate we can extend and change the subsystem without altering the
    it, let’s change the output to the following:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示我们可以扩展和改变子系统而不改变它，让我们将输出更改为以下内容：
- en: '[PRE44]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Because the `ComponentB` class provides the first two lines, we must replace
    it with a new implementation of the `IComponentB` interface. Let’s call this class
    `UpdatedComponentB`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `ComponentB` 类提供了前两行，我们必须用 `IComponentB` 接口的新实现来替换它。让我们称这个类为 `UpdatedComponentB`：
- en: '[PRE45]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The preceding code does exactly what we want. However, we have to tell the
    IoC container about it, like this:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码正好做了我们想要的事情。然而，我们必须像这样告诉 IoC 容器：
- en: '[PRE46]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If you run the program, you should see the desired result!
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行程序，你应该能看到期望的结果！
- en: Adding a dependency for a second time makes the container resolves that dependency,
    thus overriding the first one. However, both registrations remain in the services
    collection; for example, calling `GetServices<IComponentB>()` on `IServiceProvider`
    would return two dependencies. Do not confuse the `GetServices()` and `GetService()`
    methods (plural versus singular); one returns a collection while the other returns
    a single instance. That single instance is always the last that has been registered.
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第二次添加依赖会使容器解析该依赖，从而覆盖第一个。然而，两个注册都保留在服务集合中；例如，在 `IServiceProvider` 上调用 `GetServices<IComponentB>()`
    会返回两个依赖。不要混淆 `GetServices()` 和 `GetService()` 方法（复数与单数）；一个返回一个集合，而另一个返回一个单一实例。这个单一实例总是最后注册的那个。
- en: That’s it! We updated the system without modifying it. This is what dependency
    injection can do for you when designing a program around it.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们没有修改系统就更新了它。这就是围绕它设计程序时依赖注入能为你做到的。
- en: Alternative façade patterns
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 交替的外观模式
- en: 'One alternative would be to create a *hybrid between a transparent façade and
    an opaque façade* by exposing the abstractions using the `public` visibility modifier
    (all of the interfaces) while keeping the implementations hidden under an `internal`
    visibility modifier. This hybrid design offers the right balance between **control
    and flexibility**.Another alternative would be to create *a façade outside of
    the subsystem*. In the previous examples, we created the façades inside the class
    libraries, but this is not mandatory; the façade is just a class that creates
    an accessible wall between your system and one or more subsystems. It should be
    located wherever you see fit. Creating external façades like this would be especially
    useful when you do not control the source code of the subsystem(s), such as if
    you only have access to the binaries. This could also be used to create project-specific
    façades over the same subsystem, giving you extra flexibility without cluttering
    your subsystems with multiple façades, shifting the maintenance cost from the
    subsystems to the client applications that use them.This one is more of a note
    than an alternative: you do not need to create an assembly per subsystem. I did
    it because it helped me explain different concepts in the examples, but you could
    create multiple subsystems in the same assembly. You could even create a single
    assembly that includes all your subsystems, façades, and the client code (all
    in a single project).'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 一种替代方案是创建一个介于**透明外观和不透明外观**之间的**混合外观**，通过使用`public`可见性修饰符（所有接口）暴露抽象，同时将实现隐藏在`internal`可见性修饰符之下。这种混合设计在**控制和灵活性**之间提供了正确的平衡。另一种替代方案是创建**子系统之外的的外观**。在之前的例子中，我们在类库内部创建了外观，但这不是强制性的；外观只是一个创建系统与一个或多个子系统之间可访问墙的类。它应该位于你认为合适的位置。创建这样的外部外观特别有用，当你不控制子系统（例如，你只能访问二进制文件）的源代码时。这也可以用来在相同的子系统上创建项目特定的外观，这为你提供了额外的灵活性，而不会使你的子系统因多个外观而变得杂乱，将维护成本从子系统转移到使用它们的客户端应用程序。这一点更像是一个注释而不是替代方案：你不需要为每个子系统创建一个程序集。我这样做是因为它有助于我在例子中解释不同的概念，但你可以在同一个程序集中创建多个子系统。你甚至可以创建一个包含所有子系统、外观和客户端代码（所有都在一个项目中）的单个程序集。
- en: Whether talking about subsystems or REST APIs, layering APIs is an excellent
    way to create low-level functionalities that are atomic but harder to use while
    providing a higher-level API to access them through the façade, leading to a better
    consumer experience.
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无论是在谈论子系统还是REST API，分层API是创建原子但难以使用的基础功能的一种优秀方式，同时通过外观提供高级API来访问它们，从而提升用户体验。
- en: Conclusion
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'The Façade pattern is handy for simplifying consumers’ lives, allowing us to
    hide subsystems’ implementation details behind a wall. There are multiple flavors
    to it; the two most prominent ones are:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式对于简化用户生活非常有用，它允许我们通过一堵墙隐藏子系统的实现细节。它有多种变体；其中最突出的是：
- en: The **transparent façade**, which increases flexibility by exposing at least
    part of the subsystem(s)
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**透明外观**，通过暴露至少部分子系统来增加灵活性'
- en: The **opaque façade**, which controls access by hiding most of the subsystem(s)
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不透明外观**，通过隐藏大多数子系统来控制访问'
- en: 'Now, let’s see how the **transparent façade** pattern can help us follow the
    **SOLID** principles:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看**透明外观**模式如何帮助我们遵循**SOLID**原则：
- en: '**S**: A well-designed **transparent façade** serves this exact purpose by
    providing a cohesive set of functionalities to its consumers by hiding overly
    complex subsystems or internal implementation details.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**：一个设计良好的**透明外观**通过隐藏过于复杂的子系统或内部实现细节，向其用户提供一组连贯的功能，从而实现这一目的。'
- en: '**O**: A well-designed **transparent façade** and its underlying subsystem’s
    components can be extended without direct modification, as we saw in the *Flexibility
    in action* section.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**：一个设计良好的**透明外观**及其底层子系统的组件可以在不直接修改的情况下进行扩展，正如我们在*灵活性实践*部分所看到的。'
- en: '**L**: N/A'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**：N/A'
- en: '**I**: By exposing a façade that uses different smaller objects implementing
    small interfaces, we could say that the segregation is done at both the façade
    and the component levels.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**：通过暴露使用不同较小对象实现小型接口的外观，我们可以说这种隔离是在外观和组件层面同时进行的。'
- en: '**D**: The Façade pattern does not specify anything about interfaces, so it
    is up to the developers to enforce this principle by using other patterns, principles,
    and best practices.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**：外观模式没有指定任何关于接口的内容，因此开发者必须通过使用其他模式、原则和最佳实践来强制执行此原则。'
- en: 'Finally, let’s see how the **opaque façade** pattern can help us follow the
    **SOLID** principles:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看**不透明的外观**模式如何帮助我们遵循**SOLID**原则：
- en: '**S**: A well-designed **opaque façade** serves this exact purpose by providing
    a cohesive set of functionalities to its clients by hiding overly complex subsystems
    or internal implementation details.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**：一个设计良好的**不透明外观**通过提供一组功能一致的服务给其客户端，通过隐藏过于复杂的子系统或内部实现细节来实现这一目的。'
- en: '**O**: By hiding the subsystem, the **opaque façade** limits our ability to
    extend it. However, we could implement a **hybrid façade** to help with that.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**：通过隐藏子系统，**不透明的外观**限制了我们的扩展能力。然而，我们可以实现一个**混合外观**来帮助解决这个问题。'
- en: '**L**: N/A'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**：N/A'
- en: '**I**: The **opaque façade** does not help nor diminish our ability to apply
    the ISP.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**：**不透明的外观**并不能帮助或减少我们应用ISP（接口隔离原则）的能力。'
- en: '**D**: The Façade pattern does not specify anything about interfaces, so it
    is up to the developers to enforce this principle by using other patterns, principles,
    and best practices.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**：外观模式没有指定任何关于接口的内容，因此开发者必须通过使用其他模式、原则和最佳实践来强制执行此原则。'
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we covered multiple fundamental GoF structural design patterns.
    They help us extend our systems from the outside without modifying the actual
    classes, leading to a higher degree of cohesion by composing our object graph
    dynamically.We started with the Decorator pattern, a powerful tool that allows
    us to dynamically add new functionality to an object without altering its original
    code. Decorators can also be chained, allowing even greater flexibility (decorating
    other decorators). We learned that this pattern adheres to the Open-Closed principle
    and promotes the separation of responsibilities into smaller, manageable pieces.We
    also used an open-source tool named Scrutor that simplifies the decorator pattern
    usage by extending the built-in ASP.NET Core dependency injection system. Then,
    we covered the Composite pattern, which allows us to create complex, non-linear,
    and self-managed data structures with minimal effort. That hierarchical data structure
    where groups and single components are indistinguishable makes the hierarchy''s
    traversal and manipulation easier. We use this pattern to build graphs or trees
    with self-managing nodes.After that, we covered the Adapter pattern, which allows
    two incompatible interfaces to work together without modifying their code. This
    pattern is very helpful when we need to adapt the components of external systems
    that we have no control over, do not want to change, or can’t change.Finally,
    we dug into the Façade pattern, similar to the Adapter pattern, but at the subsystem
    level. It allows us to create a wall in front of one or more subsystems, simplifying
    its usage. It could also be used to hide the implementation details of a subsystem
    from its consumers.The next chapter explores two GoF behavioral design patterns:
    the Template method and the Chain of Responsibility design pattern.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了多个GoF（设计模式）的基本结构设计模式。它们帮助我们在不修改实际类的情况下从外部扩展我们的系统，通过动态组合我们的对象图，从而实现更高的内聚度。我们首先介绍了装饰者模式，这是一种强大的工具，允许我们在不改变对象原始代码的情况下动态地向对象添加新功能。装饰者也可以链式使用，从而提供更大的灵活性（装饰其他装饰者）。我们了解到这种模式遵循开闭原则，并促进了责任分离到更小、更易于管理的部分。我们还使用了一个名为Scrutor的开源工具，通过扩展内置的ASP.NET
    Core依赖注入系统来简化装饰者模式的使用。然后，我们介绍了组合模式，它允许我们以最小的努力创建复杂、非线性、自我管理的数据结构。这种组群和单个组件无法区分的分层数据结构使得层次结构的遍历和处理更加容易。我们使用这种模式来构建具有自我管理节点的图或树。之后，我们介绍了适配器模式，它允许两个不兼容的接口在不修改其代码的情况下协同工作。当我们需要适应我们无法控制、不想改变或无法改变的外部系统的组件时，这种模式非常有用。最后，我们深入探讨了外观模式，它与适配器模式类似，但处于子系统级别。它允许我们在一个或多个子系统前面创建一个墙，简化其使用。它也可以用来隐藏子系统对消费者的实现细节。下一章将探讨两个GoF行为设计模式：模板方法和责任链设计模式。
- en: Questions
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'Here are a few revision questions:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些复习问题：
- en: What is the main advantage of the Decorator pattern?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 装饰者模式的主要优势是什么？
- en: Can we decorate a decorator with another decorator?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能否用另一个装饰者装饰一个装饰者？
- en: What is the primary goal of the Composite design pattern?
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合设计模式的主要目标是什么？
- en: Can we use the Adapter pattern to migrate an old API to a new system in order
    to adapt its APIs before rewriting it?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能否使用适配器模式将旧API迁移到新系统，以便在重写之前适配其API？
- en: What is the primary responsibility of the Adapter pattern?
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适配器模式的主要责任是什么？
- en: What is the difference between the Adapter and the Façade patterns?
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适配器模式和外观模式之间的区别是什么？
- en: What is the main difference between an Opaque façade and a Transparent façade?
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不透明的外观模式和透明的外观模式的主要区别是什么？
- en: Further reading
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To learn more about Scrutor, please visit [https://adpg.link/xvfS](https://adpg.link/xvfS)
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于Scrutor的信息，请访问[https://adpg.link/xvfS](https://adpg.link/xvfS)
- en: Answers
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 答案
- en: The Decorator pattern allows us to dynamically add new functionality to an object
    at runtime without modifying its original code, promoting flexibility, testability,
    and manageability.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 装饰器模式允许我们在运行时动态地向对象添加新功能，而无需修改其原始代码，从而提高灵活性、可测试性和可管理性。
- en: Yes, we can decorate decorators by depending only on interfaces because they
    are just another implementation of the interface, nothing more.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，我们可以通过仅依赖于接口来装饰装饰器，因为它们只是接口的另一种实现，没有更多。
- en: The Composite design pattern aims to simplify handling complex structures by
    treating individual and group elements indistinguishably.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合设计模式旨在通过将单个和组元素视为不可区分的来简化处理复杂结构。
- en: Yes, we could use an adapter for this.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，我们可以使用适配器。
- en: The Adapter pattern's primary responsibility is to adapt one interface to work
    with another interface that is incompatible to use directly.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适配器模式的主要责任是将一个接口适配到另一个接口，该接口直接使用时是不兼容的。
- en: The Adapter and Façade design patterns are almost the same but are applied to
    different scenarios. The Adapter pattern adapts an API to another API, while the
    Façade pattern exposes a unified or simplified API, hiding one or more complex
    subsystems.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适配器模式和外观模式几乎相同，但它们应用于不同的场景。适配器模式将一个API适配到另一个API，而外观模式则暴露一个统一或简化的API，隐藏一个或多个复杂的子系统。
- en: An Opaque façade hides most of the subsystem (`internal` visibility), controlling
    access to it, while a Transparent façade exposes at least part of the subsystem
    (`public` visibility), increasing flexibility.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不透明的外观模式隐藏了大部分子系统（`内部可见性`），控制对其的访问，而透明的外观模式至少暴露了部分子系统（`公共可见性`），增加了灵活性。
