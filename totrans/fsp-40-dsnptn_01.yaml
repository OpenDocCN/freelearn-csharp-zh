- en: Chapter 1. Begin Thinking Functionally
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 开始函数式思考
- en: '*A man with a chainsaw enters a hardware shop and says to the assistant: "Two
    weeks ago, you told me this thing would allow me to chop down 30 trees in an hour.
    But I can only manage one tree. I want to return this for a refund". The assistant
    says "let me see" and starts the chainsaw. The visitor jumps back screaming "What''s
    that noise?!"- *An old joke**'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*一个手持链锯的人走进一家五金店，对店员说：“两周前，你告诉我这个工具可以让我在一小时内砍倒30棵树。但我只能砍倒一棵。我想退货。”店员说：“让我看看。”然后启动了链锯。参观者吓得跳回去尖叫：“这是什么声音？！”-
    *一个古老的笑话**'
- en: 'The joke opening my narrative is very relevant to the subject of this chapter:
    in order to achieve the benefits expected from the use of any tool, you should
    know how to use that tool the right way. Moreover, an advanced tool used in a
    wrong manner may be even less productive than the corresponding simple one used
    the right way. A hammer outperforms a microscope when it comes to nailing wooden
    boards together.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我的故事开头的笑话与本章的主题非常相关：为了获得使用任何工具的预期好处，你应该知道如何正确使用该工具。此外，错误使用的高级工具可能甚至比正确使用相应的简单工具还要低效。在钉木板时，锤子比显微镜更有效。
- en: '[Chapter 1](text00015.html#page "Chapter 1. Begin Thinking Functionally") ,
    *Begin Thinking Functionally* , should help you develop a manner of solving day-to-day
    software engineering problems that are usually associated with the functional
    paradigm. This means presenting the solution by verbs rather than nouns, avoiding
    the use of mutable entities to carry states, avoiding relying upon side-effects,
    and minimizing the amount of moving parts in the code.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](text00015.html#page "第1章. 开始函数式思考")，*开始函数式思考*，应有助于你培养一种解决日常软件工程问题的方法，这些问题通常与函数式范式相关。这意味着通过动词而不是名词来呈现解决方案，避免使用可变实体来传递状态，避免依赖副作用，并最小化代码中的移动部件数量。'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The multi-paradigm nature of F#
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F#的多范式特性
- en: 'A comparison of F# paradigms by solving the sample problem applying:'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过解决以下示例问题来比较F#范式：
- en: An imperative monolithic solution
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种命令式单体解决方案
- en: An object-oriented solution
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种面向对象的解决方案
- en: A functional solution
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种函数式解决方案
- en: Properties of the functional paradigm
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式范式的特性
- en: I will wrap up this chapter with a list of key concepts to retain and recognize,
    as well as skills to reuse in your functional solutions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我将以一个关键概念列表来结束本章，这些概念需要保留和识别，以及在你函数式解决方案中可以重用的技能。
- en: Relationship between F# and programming paradigms
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: F#与编程范式之间的关系
- en: This chapter, as well as the other chapters, will teach you how to look at any
    given software problem from the functional paradigm angle. This view may differ
    significantly from paradigmatic views that you may have already developed while
    practising other programming approches. This assumption of the required paradigmatic
    shift is a much anticipated scenario, taking into consideration the factor of
    the programming language popularity of the so called  **TIOBE** **Programming
    Community index**  ([http://www.tiobe.com/tiobe_index?page=index](http://www.tiobe.com/tiobe_index?page=index)
    ), which can be considered an indicator of the popularity of programming languages.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以及其他章节将教会你如何从函数式范式的角度看待任何给定的软件问题。这种观点可能与你练习其他编程方法时已经形成的范式观点有显著差异。这种对所需范式转变的假设是一个备受期待的场景，考虑到所谓的**TIOBE编程社区指数**（[http://www.tiobe.com/tiobe_index?page=index](http://www.tiobe.com/tiobe_index?page=index)）的编程语言流行度因素，它可以被认为是编程语言流行度的指标。
- en: 'At the time of this writing (February 2016):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时（2016年2月）：
- en: 'The winning Rank #1 of TIOBE index is held by the Java programming language,
    which is strongly associated with the object-oriented programming paradigm'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TIOBE指数的获胜排名#1由Java编程语言获得，它与面向对象编程范式紧密相关
- en: 'Rank #2 belongs to the C programming language, which can be considered representing
    as the traditional imperative procedural programming paradigm'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排名#2属于C编程语言，它可以被认为是代表传统的命令式过程式编程范式
- en: 'Programming languages associated with the functional programming paradigm make
    it into the TIOBE index ranks only for the rank range of 21 to 50, where F# carries
    modest Rank #36'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与函数式编程范式相关的编程语言仅在TIOBE指数排名中位于21到50的范围内，其中F#以适度的排名#36
- en: Nevertheless, if you've managed to read upto this point, I can safely assume
    that your interest in F# is not driven by its mere popularity, which, in turn,
    is driven by factors that do not belong to the scope of this book. For me, the
    bearer of an advanced degree in applied math and computer science, engineering
    program code within the F# ecosystem carries these intangible aesthetic qualities
    similar to ones of exploring a beautiful solution of a math problem or from analyzing
    a great chess play.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，如果你已经读到这一点，我可以安全地假设你对F#的兴趣并不仅仅是因为它的流行，而这种流行是由不属于本书范围的因素驱动的。对我来说，作为一个应用数学和计算机科学高级学位的持有者，在F#生态系统内编写工程程序代码具有类似探索数学问题的美丽解决方案或分析伟大棋局的美学品质。
- en: Talking seriously, I personally value most of the functional paradigm benefits
    of the functional code readability and maintainability. The same qualities of
    a typical monolithic imperative C code might be quite poor. However, are these
    code qualities automatically granted for anyone who has grasped mere F# syntax?
    Certainly not.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 认真地说，我个人最重视函数式编程范式的益处，包括函数式代码的可读性和可维护性。典型的单体命令式C代码的这些品质可能相当差。然而，这些代码品质是否自动赋予任何掌握了F#语法的人？当然不是。
- en: 'In addition to learning the F# syntax, the preceding point means acquiring
    certain skills in order to use this programming language in an idiomatic manner.
    F# is a multi-paradigm programming language indeed. It allows programmers to entertain
    many programming paradigms. The functional manner of laying out the program code
    can be used side by side with the imperative monolithic programming manner, or
    an object-oriented approach may surface when interoperability with the environment
    is important . Nevertheless, F# makes a claim of being a functional-first programming
    language. This means that the congenial programming paradigm for F# is the functional
    one; the language will bring to the table most benefits if it''s used in a functional
    manner, in which case:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了学习F#语法之外，前面的观点意味着需要获得某些技能，以便以惯用的方式使用这种编程语言。F#确实是一种多范式编程语言。它允许程序员采用许多编程范式。程序代码的函数式布局方式可以与命令式单体编程方式并行使用，或者当与环境的互操作性很重要时，可能会出现面向对象的方法。然而，F#声称自己是函数式优先的编程语言。这意味着F#的天然编程范式是函数式；如果以函数式方式使用，该语言将带来最多的好处。在这种情况下：
- en: '*"it empowers users and organizations to tackle complex computing problems
    with simple, maintainable and robust code"-([http://fsharp.org/](http://fsharp.org/)
    ).*'
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"它使用户和组织能够用简单、可维护和健壮的代码来解决复杂的计算问题" - ([http://fsharp.org/](http://fsharp.org/)).'
- en: You may wonder what, exactly, idiomatic usage means and whether it will be possible
    to always use it. The best way of illustrating idiomatic F# use would be by performing
    a comparative study of correspondent coding examples. Let me take an arbitrary,
    simple problem and solve it by sticking to imperative, then to object-oriented,
    and finally, to functional paradigms. Then, I am going to compare solutions to
    highlight functional approach features. In order to make this comparison absolutely
    fair, the programming language of implementation in all three cases is going to
    be F#.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道什么是惯用用法，以及是否总是可以使用它。通过对应编码示例的比较研究来展示惯用F#使用的方法是最好的。让我拿一个任意简单的问题，并按照命令式、面向对象，最后是函数式范式来解决它。然后，我将比较解决方案以突出函数式方法的特点。为了使这种比较完全公平，所有三种情况下的实现编程语言都将使用F#。
- en: A sample problem to solve
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个需要解决的问题示例
- en: 'I will use as a problem for the purpose the slightly amended version of Problem
    8 of Project Euler ([https://projecteuler.net/problem=8](https://projecteuler.net/problem=8)
    ):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用Project Euler的第8题的略微修改版作为问题（[https://projecteuler.net/problem=8](https://projecteuler.net/problem=8)）：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: An imperative monolithic solution
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令式单体解决方案
- en: 'Let me begin by approaching the solution in a straightforward monolithic imperative
    manner: convert the 1000-character string representing the number into a character
    array, and then convert it into a cycle across all 996 groups of the five adjacent
    digits, calculating the digit product of each group and maintaining the current
    maximum. The final value of the current maximum will be the solution; it''s that
    simple.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我先以直接的单体命令式方式来接近解决方案：将表示数字的1000个字符字符串转换为字符数组，然后将其转换为跨越所有996组五个相邻数字的循环，计算每个组的数字乘积并保持当前最大值。当前最大值的最终值将是解决方案；就这么简单。
- en: 'In order to remove the input number from the way, let''s put it into a separate
    source code file, `HugeNumber.fs` , pulled to the solution scripts with the F#
    `#load` directive. The F# source file `HugeNumber.fs` is shown as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从输入数字中移除，让我们将其放入一个单独的源代码文件`HugeNumber.fs`中，使用F#的`#load`指令将其拉入解决方案脚本。F#源文件`HugeNumber.fs`如下所示：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This file is going to be used by all variants of the problem solutions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件将被所有问题解决方案的变体使用。
- en: 'Then, F# script `Ch1_1.fsx` implementing an imperative solution will look as
    follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，实现命令式解决方案的F#脚本`Ch1_1.fsx`将如下所示：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The line `#load "HugeNumber.fs"` brings a `string` value `HugeNumber.hugeNumber`
    from the external code file `HugeNumber.fs` into the scope of this script.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`#load "HugeNumber.fs"`这一行将外部代码文件`HugeNumber.fs`中的`string`值`HugeNumber.hugeNumber`引入到本脚本的作用域中。'
- en: The next line, `let number = hugeNumber.ToCharArray()` converts this `string`
    value into an array of 1000 individual characters, each representing a single
    digit.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行`let number = hugeNumber.ToCharArray()`将此`string`值转换为包含1000个单独字符的数组，每个字符代表一个单独的数字。
- en: The next line, `let mutable maxProduct = 0` introduces a mutable `int` value
    used to carry the running tally of a maximal product of five adjacent digits.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行`let mutable maxProduct = 0`引入了一个用于携带五个相邻数字最大乘积的运行总账的可变`int`值。
- en: The following line `let charZero = int('0')` is just a helper value used for
    converting a character code of a digit into an actual `int` value in the range
    of 0 to 9\. It represents integer `48` indeed, not `0` as some of you may expect.
    But given `char` values of decimal digits `'0'` to `'9'` all have adjacent values
    after being converted to `int` , the simple subtraction of `charZero` from the
    result of converting a `char` digit `x` into an `int` will yield exactly `x` as
    an integer. More details on this matter will be given as we proceed further in
    this chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行`let charZero = int('0')`只是一个辅助值，用于将数字的字符码转换为0到9范围内的实际`int`值。它实际上代表整数`48`，而不是像一些人可能期望的`0`。但是，由于十进制数字的字符`'0'`到`'9'`在转换为`int`后都有相邻的值，所以从`char`数字`x`转换为`int`的结果中减去`charZero`将正好得到整数`x`。关于这个问题的更多细节将在本章进一步讨论。
- en: 'The following seven lines of F# code are the gist of implementation:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下七行F#代码是实现的精髓：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This part of the script performs the following actions:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本部分执行以下操作：
- en: The outer numerical `for` loop traverses the number array from the leftmost
    to the rightmost chunk of the five adjacent character digits, keeping the sequential
    number of the chunk (`0,1,2,...,955` ) in the counter value `i` .
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部数值`for`循环遍历数字数组从最左边的到最右边的五个相邻字符数字块，保持块序列号（`0,1,2,...,955`）在计数器值`i`中。
- en: The binding `let mutable currentProduct = 1` provides a mutable placeholder
    for the product of the current chunk's digits.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定`let mutable currentProduct = 1`提供了一个可变的占位符，用于当前块数字的乘积。
- en: The inner numerical `for` loop traverses a subarray of length 5, calculating
    `currentProduct` by multiplying the intermediary result by the `int` value of
    each digit having sequential number `j` using the expression `(int(number.[i +
    j]) - charZero)` . For example, if a current digit is `5` , then `int('5') - int('0')
    = 5` .
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部数值`for`循环遍历长度为5的子数组，通过将中间结果乘以具有连续编号`j`的每个数字的`int`值来计算`currentProduct`，使用表达式`(int(number.[i
    + j]) - charZero)`。例如，如果当前数字是`5`，则`int('5') - int('0') = 5`。
- en: An `if` statement closing the outer loop ensures that `maxProduct` always contains
    the maximal product of already traversed chunks; hence, when the loop completes
    iterating, `maxProduct` contains the sought value.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`if`语句关闭外部循环确保`maxProduct`始终包含已遍历块的最大乘积；因此，当循环完成迭代时，`maxProduct`包含所求的值。
- en: Finally, the line `printfn "%s %d" "Imperative solution:" maxProduct` outputs
    the final result to the system console.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`printfn "%s %d" "Imperative solution:" maxProduct`这一行将最终结果输出到系统控制台。
- en: 'Running the script in its entirety with **F# Interactive** ( **FSI** ) yields
    the following solution:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**F#交互式环境**（**FSI**）运行整个脚本将得到以下解决方案：
- en: '![An imperative monolithic solution](img/Image00001.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![一个命令式单体解决方案](img/Image00001.jpg)'
- en: Running an imperative solution script in F# Interactive
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#交互式环境中运行命令式解决方案脚本
- en: 'There are a few points that I would like to accentuate prior to covering other
    approaches to solving the problem as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍其他解决问题的方法之前，我有几个要点想强调：
- en: The solution represents detailed "how-to" instructions
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该解决方案表示详细的“如何做”指导。
- en: The solution has been expressed in terms of low-level computer notions, such
    as statements, loops, and global values
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该解决方案已用低级计算机概念表达，例如语句、循环和全局值
- en: Values change along the execution, representing the changing state
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值在执行过程中发生变化，表示状态的变化
- en: The solution code does not look structured, it just flows
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案代码看起来并不结构化，它只是流动
- en: An object-oriented solution
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象的解决方案
- en: 'Now let me turn to the object-oriented manner of solving the same problem.
    It is typical for this kind of approach to hide implementation details inside
    instances of custom classes and manipulate them with the help of their own methods.
    I will use for this purpose the F# `type` feature representing the concept of
    the .NET object type also known as **class** ([https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/classes](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/classes)
    ). An object-oriented solution to the problem is present in the following code
    (script `Ch1_2.fsx` ):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我转向以面向对象的方式解决相同的问题。这种方法的典型做法是在自定义类的实例内部隐藏实现细节，并使用它们自己的方法来操作它们。为此，我将使用 F#
    的 `type` 功能，它代表 .NET 对象类型的概念，也称为 **类** ([https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/classes](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/classes)
    )。以下代码（脚本 `Ch1_2.fsx` ）展示了该问题的面向对象解决方案：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This solution is going to manipulate the objects of two classes. The first
    class named `OfDigits` represents the entity of the digit sequence, the product
    of which is the subject of our interest. An instance of `OfDigits` can be created
    from an array of a certain size of `char` elements carrying digits used as an
    argument to the `OfDigits` type constructor `OfDigits(digits: char[])` .'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '此解决方案将操作两个类的对象。第一个类名为 `OfDigits`，代表数字序列的实体，其乘积是我们关注的主题。可以通过 `OfDigits` 类型构造函数
    `OfDigits(digits: char[])` 从一定大小的 `char` 元素数组创建 `OfDigits` 的实例，这些数组用作 `OfDigits`
    类型构造函数的参数。'
- en: 'Upon its creation, each instance is associated with the `product` field representing
    the product of its digits. There is a reason for it not being possible to initialize
    `product` at once: in order to be representable as a positive integer value, the
    product can be constituted of nine digits or fewer (because the product of 10
    or more 9 would exceed the maximum 32-bit `int` value 2147483647). In order to
    validate this, `product` is kept `mutable` and initially gets a value of `1` as
    given in the following line:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建实例时，每个实例都与表示其数字乘积的 `product` 字段相关联。无法一次性初始化 `product` 的原因在于：为了表示为正整数值，乘积可以由九位或更少的数字组成（因为10个或更多9的乘积将超过最大32位
    `int` 值2147483647）。为了验证这一点，`product` 被保持为 `mutable`，并初始时获得 `1` 的值，如下所示：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, after the length validity check, the `OfDigits` constructor provides
    the genuine value to the field by performing the calculation:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在长度有效性检查之后，`OfDigits` 构造函数通过执行计算来向字段提供真实值：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This value can be accessed via the instance property, `Product` as shown in
    the following line:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此值可以通过实例属性 `Product` 访问，如下所示：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The another class required to implement the object-oriented solution represents
    the entity taking a string of digits of arbitrary length and represents it as
    a generic collection of type `OfDigits` , allowing enumeration in order to traverse
    it and find a member with the maximum `Product` property.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个类用于实现面向对象的解决方案，它代表一个可以表示任意长度数字字符串的实体，并将其表示为类型 `OfDigits` 的通用集合，允许枚举以遍历它并找到具有最大
    `Product` 属性的成员。
- en: 'For this purpose, the class named `SequenceOfDigits` has been equipped with
    a constructor parameterized by the digits string carrying the input number''s
    digits and the `itemLen` length of individual `OfDigits` instance arguments. During
    the `SequenceOfDigits` instance construction, all `OfDigits` instances are created
    as elements of the collection field array. The `GetEnumerator()` instance method
    allows you to enumerate this array by upcasting to the `System.Collections.Generic.IEnumerable<OfDigits>`
    interface type and delegating the call to the `GetEnumerator()` method of the
    latter in the following instance method definition:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一目的，名为 `SequenceOfDigits` 的类被配备了构造函数参数，该参数携带输入数字的数字字符串和单个 `OfDigits` 实例参数的
    `itemLen` 长度。在 `SequenceOfDigits` 实例构建期间，所有 `OfDigits` 实例都作为集合字段数组的元素创建。`GetEnumerator()`
    实例方法允许您通过向上转换为 `System.Collections.Generic.IEnumerable<OfDigits>` 接口类型并将调用委托给后者的
    `GetEnumerator()` 方法来枚举此数组，如下所示实例方法定义：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Having the preceding two classes at your disposal makes composing the solution
    of the original problem rather simple: you construct a `SequenceOfDigits` instance
    of five digit `OfDigits` elements off `hugeNumber` and traverse it with the help
    of the `for...in` cycle, maintaining the maximum product tally similarly to the
    imperative solution as shown in the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在拥有前面两个类的情况下，构建原始问题的解决方案相当简单：你从`hugeNumber`构建一个五位`OfDigits`元素的`SequenceOfDigits`实例，并使用`for...in`循环遍历它，保持最大乘积计数，类似于以下代码中所示的操作式解决方案：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the end, place the result on the system console. Running the script in its
    entirety with F# FSI yields the result of object-oriented solution as shown in
    the following screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将结果放置在系统控制台上。使用F# FSI运行整个脚本会得到面向对象解决方案的结果，如下面的截图所示：
- en: '![An object-oriented solution](img/Image00002.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![面向对象的解决方案](img/Image00002.jpg)'
- en: Running object-oriented solution script in F# Interactive
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#交互式环境中运行面向对象解决方案脚本
- en: 'For those of you familiar with the object-oriented manner of approaching problem
    solutions, you may anticipate that the second solution rather differs from the
    first one:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些熟悉面向对象解决问题方式的人来说，你们可能会预期第二个解决方案与第一个有所不同：
- en: It is distinctively structured, with the segregation of definitions of pertinent
    classes from the usage of these classes
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的结构明显不同，相关类的定义与这些类的使用分离
- en: Classes hide details of implementation, allowing usage only through exposed
    properties and methods
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类隐藏了实现的细节，只允许通过公开的属性和方法使用
- en: The solution follows one of the well-known design patterns, namely the **iterator**
    pattern
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案遵循一个众所周知的设计模式，即**迭代器**模式
- en: The amount of effort required for scaffolding substantially exceeds the effort
    required for the solution per se
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建脚手架所需的努力远远超过实际解决方案所需的努力
- en: A functional solution
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式解决方案
- en: 'Finally, let me turn to the solution manner that this book targets, namely,
    functional. Let''s think of it as a series of data transformations. Let''s look
    at it in a backward direction, from the sought solution back to the input string
    of digits as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我转向这本书所针对的解决方案方式，即函数式。让我们将其视为一系列数据转换。让我们从求解的解决方案开始，逆向查看，回到数字的输入字符串，如下所示：
- en: The sought solution is the result of the `max` aggregate function application
    to the sequence of all products of five digit sequences.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所求的解决方案是`max`聚合函数应用于所有五位数字序列乘积序列的结果。
- en: The sequence of all five digit sequences products is the result of the function
    application that maps each five digit sequence instance from the sequence of such
    sequences to the reduce of five digit sequence digits to their product.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有五位数字序列乘积的序列是函数应用的结果，该函数将每个五位数字序列实例从此类序列映射到五位数字序列数字的乘积的reduce。
- en: The sequence of all five digit sequences can be produced from the sequence of
    all initial digits by applying the F# core library windowing function `Seq.windowed<'T>`
    to the latter. In other words, this means taking a copy sequence of the first
    five digits from the left-hand side, placing this sequence in the output, shifting
    to the right of the source sequence by one digit, taking the first five digit
    copy and putting them after the first group in the output, shifting to the right
    by one digit of the source again, taking the first five digits, and so on, until
    there is no more possibility of taking the first five digits from the source.
    The output sequence of sequences is the sought function application result.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有五位数字序列的序列可以通过将F#核心库的窗口函数`Seq.windowed<'T>`应用于后者来生成。换句话说，这意味着从左侧复制前五个数字，将其放入输出中，然后将源序列向右移动一个数字，取第一个五个数字的副本并将其放在输出中的第一组之后，再次将源序列向右移动一个数字，取前五个数字，依此类推，直到无法再从源中取出前五个数字。序列的输出序列是所求的函数应用结果。
- en: Finally, the sequence of all initial digits is simply the initial string split
    by single digits, each converted into correspondent `int` from 0 to 9.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，所有初始数字的序列只是通过单个数字分割的初始字符串，每个数字都转换为对应的`int`类型，从0到9。
- en: Each preceding step describes what transformation I want to apply to the single
    input argument in order to get the single result. Each next step takes the result
    of the previous step and treats it as its own input.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每个前一步描述了我想要应用于单个输入参数以获得单个结果要应用哪种转换。每个后续步骤都取前一步的结果并将其作为自己的输入。
- en: 'Let me show you how I usually derive the working code from the data transformation
    sketch similar to the preceding one with the help of the **Read-Evaluate-Print-Loop**
    ( **REPL** ) mode provided by FSI and the shrinking task dimension. The process
    of sequential progress toward the solution is shown in *Fig.1.3* , where I gradually
    start adding transformation steps to reproduce the data transformation process
    sketched earlier for a string consisting of just 10 digits `"0918273645"` by following
    these steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我向您展示我通常如何借助FSI提供的**读取-评估-打印循环**（**REPL**）模式和缩小任务维度，从类似前面一个的数据转换草图推导出工作代码。向解决方案逐步进展的过程在*图1.3*中显示，我在此过程中逐渐开始添加转换步骤，以重现前面草图中的数据转换过程，该过程针对仅由10个数字组成的字符串`"0918273645"`：
- en: The input string is piped forward with the F# operator of the same name **pipe-forward **
    `|>` as the second argument of `Seq.map string` . The result is the sequence of
    10 strings, each representing a single digit.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入字符串通过与同名的F#运算符**管道传递** `|>` 作为`Seq.map string`的第二个参数传递。结果是10个字符串的序列，每个字符串代表一个单独的数字。
- en: The result of step 1 is piped forward with `|>` as the second argument of `Seq.map
    int` . Now, the result is also the sequence, but it is a sequence of 10 `int`
    numbers, each representing the single digit.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第1步的结果通过`|>`作为`Seq.map int`的第二个参数传递。现在，结果也是一个序列，但它是一个包含10个`int`数字的序列，每个数字代表一个单独的数字。
- en: The result of step 2 is piped forward with `|>` as the second argument of `Seq.windowed
    5` . The result is the sequence of six arrays, each representing five sequentially
    taken digits of the result of step 2, each time shifting the beginning of the
    sequence to the right by one position.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第2步的结果通过`|>`作为`Seq.windowed 5`的第二个参数传递。结果是六个数组的序列，每个数组代表第2步结果的五个连续数字，每次将序列的起始位置向右移动一个位置。
- en: The result of step 3 is piped forward with `|>` as the second argument of `Seq.map
    (Seq.reduce (*))` . The first argument is the higher-order function `Seq.reduce`
    converting its argument, which is an array of five numbers to the product of these
    numbers with the help of the multiplication operator (`*` ). The result of this
    transformation step is just six numbers, each representing the product of the
    elements of the corresponding digit array.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第3步的结果通过`|>`作为`Seq.map (Seq.reduce (*))`的第二个参数传递。第一个参数是高阶函数`Seq.reduce`，它将它的参数（一个包含五个数字的数组）转换为这些数字的乘积，这要归功于乘法运算符（`*`）。这个转换步骤的结果是六个数字，每个数字代表相应数字数组元素的乘积。
- en: 'The result of step 5 is piped into the `Seq.max` aggregate function, which
    produces the sought maximal product that equals `2520(7 * 3 * 6 * 4 * 5)w` :'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第5步的结果传递到`Seq.max`聚合函数中，该函数产生所求的最大乘积，等于`2520(7 * 3 * 6 * 4 * 5)w`：
- en: '![A functional solution](img/Image00003.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![一个函数式解决方案](img/Image00003.jpg)'
- en: The incremental process of getting to the smaller problem solution with REPL
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用REPL逐步获得较小问题解决方案的增量过程
- en: 'Now, after becoming pretty confident that the thought-out solution is good,
    I can combine the preceding steps 1 to 5 with just another F# **function composition**
    operator `>>` , which just glues the result of the function to the left as an
    argument of the function to the right into a very compact F# script provided in
    the file `Ch1_3.fsx` as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在相当有信心认为所考虑的解决方案是好的之后，我可以将前面的步骤1到5与另一个F# **函数组合**运算符`>>`结合起来，该运算符只是将函数的结果作为参数粘接到右侧函数的左侧，形成一个非常紧凑的F#脚本，如下所示，该脚本在文件`Ch1_3.fsx`中提供：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The only difference between the preceding complete problem solution code and
    the smaller problem solution that I was running through a few REPL steps is the
    input value dimension. The final code uses the same 1000 digit `hugeNumber` taken
    from the source file `HugeNumber.fs` in the same manner as the imperative and
    object-oriented solutions did previously.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的完整问题解决方案代码与我在几个REPL步骤中运行的较小问题解决方案之间的唯一区别是输入值维度。最终的代码使用了与命令式和面向对象解决方案相同的方式，从同一源文件`HugeNumber.fs`中取出的1000位`hugeNumber`。
- en: 'Running the script in its entirety with FSI yields the functional solution
    result shown in the following figure:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用FSI完整运行脚本产生以下图所示的函数式解决方案结果：
- en: '![A functional solution](img/Image00004.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![一个函数式解决方案](img/Image00004.jpg)'
- en: Running the functional solution script in F# Interactive
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在F# Interactive中运行函数式解决方案脚本
- en: 'The code quality achieved by the functional solution, despite somewhat lengthy
    accompanying comments, is quite outstanding:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管附带注释有些冗长，但函数式解决方案所达到的代码质量相当出色：
- en: It does not utilize even a single value carrying an intermediate state
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它甚至不利用携带中间状态的单一值
- en: It contains just one arithmetic multiplication operator absolutely needed for
    product calculation
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只包含一个绝对必要的算术乘法运算符，用于乘法计算
- en: It is extremely succinct
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它非常简洁
- en: It almost literally reflects the original "what to do" considerations
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它几乎字面地反映了原始的“做什么”考虑
- en: It uses solely half a dozen core F# library functions combined in a certain
    way, and we may strongly believe that the implementations of these functions are
    error-free and performant
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它仅使用六种核心 F# 库函数以某种方式组合，我们可能坚信这些函数的实现是错误-free 和高效的
- en: The preceding bullet points reflect pretty much all the properties typical for
    an idiomatic functional solution of a small-scale problem. Now I'm going to decipher
    these properties one by one.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的要点反映了典型的小规模问题惯用函数式解决方案的所有属性。现在我将逐一解释这些属性。
- en: Immutability of participating data entities
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参与数据实体的不可变性
- en: 'The positive qualities of the approach of not using mutable program entities
    are well known:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用可变程序实体的方法的积极品质是众所周知的：
- en: Given the right state upon construction the immutable cannot be invalidated
    it during its whole lifetime
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构造时给定正确的状态，不可变实体在其整个生命周期内不能被无效化
- en: Immutable entities are easy to test
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变实体易于测试
- en: They do not require cloning or copy constructors
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不需要克隆或复制构造函数
- en: Immutable entities are automatically thread-safe
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变实体自动是线程安全的
- en: I must note that F# is not 100% strict about using immutable entities. As you
    may have already noticed, I used values, changing the state in my imperative and
    object-oriented solutions earlier. But the language requires the programmer to
    make an extra effort to introduce a changeable state (with the `mutable` modifier
    to `let`  binding or via `ref` cells, although F# 4.0 pretty much eliminates the
    need for the latter).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须指出，F# 并不是100% 严格关于使用不可变实体。正如你可能已经注意到的，我之前在我的命令式和面向对象的解决方案中使用了值，改变了状态。但语言要求程序员额外努力引入可变状态（通过
    `let` 绑定的 `mutable` 修饰符或通过 `ref` 单元，尽管 F# 4.0 几乎消除了对后者的需求）。
- en: Also, the majority of data structures introduced by the language are also immutable,
    which means that a typical data transformation produces a new immutable instance
    of a data structure from the existing data structure. This consideration requires
    a certain caution from programmers when dealing with bulk in-memory instances,
    but as my experience has taught me, developers get used to this feature easily.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，语言引入的大多数数据结构也是不可变的，这意味着典型的数据转换会产生一个新的不可变实例的数据结构，从现有的数据结构中。在处理大量内存实例时，这需要程序员有一定的谨慎，但正如我的经验所教导的，开发者很容易习惯这个特性。
- en: Thinking in verbs rather than nouns
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用动词而不是名词思考
- en: Considering the process of data transformations in terms of verbs rather than
    nouns is very typical for a functional approach as functions are intuitively associated
    in our brains with actions, not objects. You may notice the single data item in
    the script `Ch1_3.fsx` , which is `hugeNumber` . The rest are few library functions
    combined in a certain manner, which transform the `hugeNumber` data item into
    a line of the console output. This manner of function combination allows persons
    reading this code to completely ignore intermediate results of the data transformations
    at each point where the operator >> occurs in the expression.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据转换的过程视为动词而不是名词，对于函数式方法来说是非常典型的，因为在我们的大脑中，函数与动作而不是对象直观地相关联。你可能注意到脚本 `Ch1_3.fsx`
    中的单个数据项 `hugeNumber`。其余的都是以某种方式组合的少数库函数，它们将 `hugeNumber` 数据项转换成控制台输出的一行。这种函数组合的方式允许阅读此代码的人完全忽略在表达式中每个出现操作符
    >> 的数据转换的中间结果。
- en: The less obvious corollary of this combination is the opportunity for the F#
    compiler to perform a so-called fusion or the manner of code optimization by merging
    together some adjacent data transformation steps. For example, when adjacent steps
    are fused together, the amount of data traversals may decrease.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种组合的不那么明显的推论是，F# 编译器有机会执行所谓的融合，或者说是通过合并一些相邻的数据转换步骤来优化代码的方式。例如，当相邻步骤融合在一起时，数据遍历的量可能会减少。
- en: '"What" prevailing over "how"'
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “什么”胜过“如何”
- en: This property of the functional solution mental process is easier to demonstrate
    with an example. I paraphrase here the great one from the early days of F# that's
    been used by several insiders previously. Imagine yourself in Starbucks for Caffè
    Americano.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 功能解决方案心智过程的这一特性，通过一个例子更容易展示。我在这里引用了F#早期的一些伟大例子，这些例子之前被几位内部人士使用过。想象一下，你自己在星巴克喝美式咖啡。
- en: 'The "how" approach would be to give detailed instructions such as:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: “如何”的方法是给出详细的说明，例如：
- en: Take a roasted coffee
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 喝一杯烤咖啡
- en: Brew two espresso shots
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 烹制两杯浓缩咖啡
- en: Top them with hot water to produce a layer of crema
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用热水冲泡，以产生一层奶泡
- en: Put it into a cap of 12 oz size
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其放入12盎司大小的杯中
- en: The "what" approach would be to just ask "May I have a tall Caffè Americano?".
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: “什么”的方法就是简单地问“我可以来一杯高杯美式咖啡吗？”
- en: The second approach is evidently much more succinct and minimizes an opportunity
    of getting a result that deviates from the desired one. If you revisit now our
    three preceding solutions you should spot this property there.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法显然更加简洁，并且最大限度地减少了得到与预期结果偏差的结果的机会。如果你现在回顾我们前面的三个解决方案，你应该会注意到这个特性。
- en: Generalization over specialization
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛化胜过专业化
- en: Another outstanding feature of the functional paradigm is generalization. By
    this, I mean preferring a general solution over a concrete one, when a concrete
    problem can be solved by applying a general solution that is accordingly parameterized.
    Let's turn to our sample problem for evidence of generalization. Adjusting the
    functional solution to a different length of digit sequences (for example, 8 instead
    of 5), another math operation on the group (for example, the sum instead of the
    product), another aggregation property (for example, minimum instead of maximum)
    are mere changes of parameter values for the correspondent functions. A comparison
    of how much the code changes will be required in case of the other approaches,
    which I leave for you as an exercise.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 函数范式的另一个显著特性是泛化。通过这种方式，我的意思是，当具体问题可以通过应用相应参数化的通用解决方案来解决时，更倾向于选择通用解决方案而不是具体解决方案。让我们转向我们的样本问题，以证明泛化的证据。调整功能解决方案以适应不同长度的数字序列（例如，8而不是5），对组进行另一种数学运算（例如，求和而不是乘积），另一种聚合属性（例如，最小值而不是最大值）只是对应函数参数值的更改。在其他方法中，代码需要更改多少的比较将留给你作为练习。
- en: Minimizing moving parts over hiding them
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在隐藏它们之上，最小化移动部件
- en: This property is specifically related to a functional approach in comparison
    with an object-oriented one. Recall F# script file `Ch1_2.fsx` , which involved
    custom classes encapsulating details of implementation and exposing them outside
    the constructor, the iterator, and the aggregated property. In comparison with
    the object-oriented approach, the functional approach is flat and does not hide
    anything; it just combines some known parts.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与面向对象的方法相比，这一特性特别与函数式方法相关。回想一下F#脚本文件`Ch1_2.fsx`，它涉及自定义类封装实现细节，并在构造函数、迭代器和聚合属性之外暴露它们。与面向对象的方法相比，函数式方法是扁平的，不隐藏任何东西；它只是组合了一些已知部分。
- en: Reduction to known parts over producing custom parts
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产生定制部分胜过将部分还原为已知部分
- en: One of the amazing properties of a functional paradigm differentiating it from
    the others is the limited need for producing custom parts at the level of manipulating
    data structures. Usually, functional programming newbies tend to implement their
    own functions for each case of data transformation. This infantile sickness normally
    ends with finding out from practice that pretty much any transformation upon typical
    data structures can be expressed as a combination of `filter` , `map` , and `fold`
    operations. I will devote a substantial amount of contents in relation to this
    phenomenon.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 函数范式与其他范式区分开来的一个惊人的特性是，在操作数据结构级别上产生定制部分的需求有限。通常，函数式编程新手倾向于为每种数据转换的情况实现自己的函数。这种幼稚的疾病通常以从实践中发现几乎任何对典型数据结构的转换都可以表示为`filter`、`map`和`fold`操作的组合而告终。我将专门用大量内容来讨论这一现象。
- en: Lazy over eager data collections
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒惰的数据收集胜过急切的数据收集
- en: Let me turn your attention to the comparison of memory consumption of the previously
    mentioned object-oriented and functional solutions. The object-oriented solution
    eagerly creates, materializes in computer memory the collection of 996 `OfDigits`
    objects; that is, its memory consumption is a linear function of the problem dimensions.
    In contrast to this approach, the functional solution does not require more than
    a single instance of `OfDigits` at any moment of the `max` aggregation, lazily
    producing the same 996 objects one by one according to the demand of the `max`
    aggregator function, hence having memory consumption that is constant and (almost)
    independent of the problem dimensions. This is a rather complex quality. If you
    imagine that the initial condition has suddenly changed and `hugeNumber` is really
    huge, then the object-oriented solution may become non-applicable due to the lack
    of required memory, while the functional solution, being agnostic to this factor,
    will continue to work. Generalizing this observation, the functional paradigm
    allows you to solve problems of a bigger scale, rather than taking other approaches
    by utilizing the lazy manner of data manipulation. The interesting corollary stemming
    from this approach is the technique of manipulating data sequences of unlimited
    length that do not require their complete materialization in the memory.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我将你的注意力转向之前提到的面向对象和函数式解决方案在内存消耗方面的比较。面向对象的解决方案急切地创建并实体化996个`OfDigits`对象集合；也就是说，其内存消耗是问题维度的线性函数。与此相反，函数式解决方案在任何时刻的`max`聚合中不需要超过一个`OfDigits`实例，根据`max`聚合函数的需求惰性逐个产生相同的996个对象，因此内存消耗是恒定的，并且（几乎）与问题维度无关。这是一个相当复杂的特点。如果你想象初始条件突然改变，`hugeNumber`真的很大，那么面向对象的解决方案可能会因为缺乏所需的内存而变得不可应用，而函数式解决方案，由于对此因素不敏感，将继续工作。概括这个观察结果，函数式范式允许你解决更大规模的问题，而不是通过利用数据操作的惰性方式来采取其他方法。从这个方法中产生的有趣推论是，可以操作无限长度的数据序列的技术，这些序列不需要在内存中完全实体化。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'The following are the key concepts and the list of skills you should take away
    after finishing this chapter and strive for absorbing and mastering:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在完成本章学习后你应该掌握的关键概念和技能列表：
- en: 'Avoid mutable state and achieve data transformations over immutable values
    and data structures. Think of programming solutions in terms of verbs rather than
    nouns. Avoid expressing a solution in highly detailed imperative "how" statements;
    use the "what to do" approach instead. Generalize: prefer a general parameterized
    solution to a concrete one. Strive to minimize the moving parts of your solution
    instead of hiding these moving parts into classes. Try expressing solutions by
    a few well-known facilities instead of delving into producing custom ones. When
    appropriate, prefer lazy data collections (sequences) over eager ones.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用可变状态，并在不可变值和数据结构上实现数据转换。以动词而非名词来思考编程解决方案。避免用高度详细的行为性“如何”语句来表述解决方案；相反，使用“做什么”的方法。进行泛化：优先选择参数化的通用解决方案，而不是具体的解决方案。努力最小化解决方案中的移动部分，而不是将这些移动部分隐藏到类中。尝试通过一些众所周知的功能来表述解决方案，而不是深入到创建自定义解决方案中。当适用时，优先选择惰性数据集合（序列）而非急切的数据集合。
- en: This process of mastering the functional manner of thinking may be framed around
    the following three Rs - **Retain** , **Recognize** , and **Reuse** . The sooner
    you learn to recognize idiomatic functional design patterns which I'm going to
    cover with a great amount of detail in this book and the sooner you reuse these
    patterns again and again in your day-to-day coding activities, the better functional
    programmer you will become.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握函数式思维方式的这个过程可以概括为以下三个R——**保留**、**识别**和**重用**。你越早学会识别我将在本书中详细介绍的惯用函数式设计模式，并且越早将这些模式反复应用于日常编码活动中，你将越成为一名优秀的函数式程序员。
- en: In the upcoming chapters, I will walk you over the many idiomatic uses of F#
    in certain development situations. These repeated usages will represent genuine
    functional programming design patterns. Please keep in mind that many of these
    patterns only to a certain extent correlate with traditional **object-oriented
    design patterns** ([https://en.wikipedia.org/wiki/Design_Patterns](https://en.wikipedia.org/wiki/Design_Patterns)
    ), as well as other architecture design patterns of **software engineering** ([http://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420](http://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420)
    ).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我将向您介绍 F# 在特定开发场景中的许多惯用用法。这些重复的使用将代表真正的函数式编程设计模式。请记住，许多这些模式仅在一定程度上与传统**面向对象设计模式**([https://en.wikipedia.org/wiki/Design_Patterns](https://en.wikipedia.org/wiki/Design_Patterns))相关，以及其他**软件工程**架构设计模式([http://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420](http://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420))。
- en: In the next chapter, I'll give you a 360-degree high-level view of the F# language
    features and parts with their origins and evolvement.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将为您提供一个全方位的高层次视角，涵盖 F# 语言特性和组成部分及其起源和演变。
