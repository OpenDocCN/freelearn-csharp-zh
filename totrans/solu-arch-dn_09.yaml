- en: '*Chapter 7*: Securing ASP.NET Web Applications'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we explored the architecture considerations that should
    be taken into account when designing and implementing a solution architecture.
    *Why do we need to learn this?* Because creating an innovative and robust software
    solution requires us to plan for various aspects and consider different attributes
    for balancing short-term and long-term product goals and priorities. Paying attention
    to the quality of attributes, logging, and tracing, along with a proper deployment
    strategy, will help you deliver a good-quality product that is scalable, maintainable,
    and secure.
  prefs: []
  type: TYPE_NORMAL
- en: It is exciting for any solution architect to design and build a fancy product;
    however, this achievement can be ruined if we don't pay attention to the security
    risks involved. Security is an integral part of any software solution, especially
    **ASP.NET** web applications. By nature, these applications are exposed to a large
    number of users, therefore security isn't a luxury in this case and can no longer
    be an afterthought—it's a necessity.
  prefs: []
  type: TYPE_NORMAL
- en: The **.NET Core** framework provides a set of powerful features and built-in
    functionalities to secure our applications if we implement and configure them
    the right way. However, this is not enough, as we still need to apply a set of
    security measures and write secure code to protect our application from threats
    and vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Securing ASP.NET Core applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web **application programming interface** (**API**) security recommendations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting web apps and APIs hosted on Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will have explored a set of security measures,
    tips, and tricks that will help us build secure ASP.NET web applications. Furthermore,
    we will get to know some security recommendations to protect our RESTful APIs
    (where **REST** stands for **REpresentational State Transfer**), along with some
    tips to securely host our solution on **Azure**.
  prefs: []
  type: TYPE_NORMAL
- en: Most essentially, this chapter provides us with a roadmap to secure our solution.
    We'll get a deep understanding of how we can incorporate security into our solution
    architecture, and we'll see what the most important factors are for creating secure
    software.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's dig deeper into each of those security measures.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing key security practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore key security measures to be taken into consideration
    while building our ASP.NET web application. There are some **C#** code samples
    in the following sections that we will use to explain various security vulnerabilities
    we may face. This code syntax was prepared based on **ASP.NET Core** and **.NET
    5**, but the concept is the same even if you have an ASP.NET Web Forms application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of the security measures we will learn about in this
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anti-**cross-site scripting** (**XSS**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-site request forgery** (**CSRF**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cookie stealing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overposting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing open redirection attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking brute-force attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File-upload protection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing **Structured Query Language** (**SQL**) injection attacks in ADO.NET
    and **Entity Framework** (**EF**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General security recommendations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Authentication is the process of validating the identity of a user who is trying
    to access an application. It starts by obtaining the credentials of the user,
    then validating them against the identity provider such as **Windows Active Directory**
    that can be on-premises or in the cloud as part of **Microsoft 365** services.
    The user is considered authenticated if the validation process of the credentials
    is successful. After authentication, the system should start the authorization
    process to check the access level of the user and decide which data and resources
    are accessible for this user. Without knowing who the user is, authorization cannot
    take place.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four different authentication modes in ASP.NET Core that we must
    know about, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`identity` module. This module will automatically create the authentication
    and authorization SQL tables, along with the UI that includes the `Register`,
    `Login`, `LogOut`, and `RegisterConfirmation` views, which will be added to Visual
    Studio through the scaffolding functionality. The following screenshot shows the
    SQL tables that will be created when we apply the migrations in the package manager
    console:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.1: ASP.NET identity SQL tables](img/Figure_7.01_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: ASP.NET identity SQL tables'
  prefs: []
  type: TYPE_NORMAL
- en: By using this mode, the unauthenticated users will be automatically redirected
    to a login page where they can supply their login credentials and submit them
    back to the server. If the IdP authenticates the request, ASP.NET issues a cookie
    that contains the ID token of the authenticated user, which will be attached to
    all subsequent requests in each request header. This means that all subsequent
    requests are automatically authenticated using the authentication token stored
    in this cookie.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a Microsoft reference on how to configure this authentication mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity?view=aspnetcore-5.0&tabs=visual-studio](https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity?view=aspnetcore-5.0&tabs=visual-studio'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '`appSettings.json` file; we can get these settings from the Azure Active Directory
    after we register the app:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Configuration in the appsettings.json file](img/Figure_7.02_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Configuration in the appsettings.json file
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding screenshot, we first need to set the `Domain` name
    that we are using in the application. Then, we need to set `TenantId` and `ClientId`
    that we get from Azure when we register the application. As for `CallbackPath`,
    this is the **Uniform Resource Locator** (**URL**) where we want to redirect users
    after successful login.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how the authentication with the Microsoft identity
    platform works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: Authentication process using the Microsoft identity platform](img/Figure_7.3_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Authentication process using the Microsoft identity platform'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, unauthenticated users will be redirected to the Windows login
    page where they are prompted to provide their credentials, and then an access
    token is created if the credentials are valid. After that, the user gets redirected
    to the landing page or redirects the URL specified in the **HTTP** response returned
    by the identity provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a Microsoft reference on how to configure the Microsoft identity platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-v2-aspnet-core-webapp](https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-v2-aspnet-core-webapp'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows**: This is also known as **Negotiate**, **Kerberos**, or **New Technology
    LAN Manager** (**NTLM**) authentication. This authentication mode is best suited
    for apps running in intranet environments under the same Windows domain. It can
    be configured for apps hosted with **Internet Information Services** (**IIS**)
    or **Kestrel** while the server runs on a corporate network using Active Directory
    domain identities. This authentication process relies on the operating system
    to get the ID of the user and confirm the authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a Microsoft reference on how to configure Windows authentication:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/core/security/authentication/windowsauth?view=aspnetcore-5.0&tabs=visual-studio](https://docs.microsoft.com/en-us/aspnet/core/security/authentication/windowsauth?view=aspnetcore-5.0&tabs=visual-studio'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '**None**: When we choose this mode, it means the identity of users is not needed.
    This type of mode is used in two cases—either when our application is public and
    anyone is allowed to access it or when we want to build our own custom authentication
    module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are a few tips to consider when we implement a custom authentication process:'
  prefs: []
  type: TYPE_NORMAL
- en: Enforce the user to use a complex password and hash it before storing it in
    the users' table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never store a password in a hidden field or in any state management object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider encrypting the password input using a client-side library before submitting
    it to the server along with the request header and body. On the server, when you
    receive the password you will need to decrypt it, hash it, and then compare it
    to the hashed password in the database. If they are equal, then the user is considered
    authenticated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using sessions, make sure to clear them on logout and modify the
    session ID, and on login generate a new session ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider implementing **two-factor authentication** (**2FA**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never grant any user `db_owner` access to our SQL database, including the user
    used in the connection string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Authorization is the process of deciding whether a user ID should be granted
    access to a specific resource in an application. Usually, authorization starts
    immediately after authentication, and there are different types of resource authorizations
    that can be given to a user, listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL authorization**: This is performed to selectively grant users and roles
    access to particular URLs in the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File authorization**: This process is used to protect the assets of an application
    and prevent unauthorized users from browsing the directories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UI authorization**: This is also known as **UI trimming**. This process is
    performed to selectively allow or deny access to arbitrary parts of a page for
    specific users or roles. The section will be completely removed from the page
    if a user has no access to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s quite easy to apply authorization in `[Authorize]` attribute to the controller
    class or to actions that are not anonymous. Here is an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you allow anonymous access to a particular action within a controller class
    that has the `[Authorize]` attribute on top of it, you need to use `[AllowAnonymous]`
    on top of the action. You can use the `[Authorize]` attribute to grant access
    to roles and not only users.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-XSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**XSS** is considered the number-one security vulnerability on the web and,
    unfortunately, a large number of web developers are not familiar with the risks
    of this vulnerability. XSS is a type of injection attack in which an attacker
    tries to execute malicious client-side scripts in the web browser of another end
    user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two scenarios in terms of XSS attacks: the first one is called **passive
    injection**, where an attacker inputs a vulnerable script in an input field that
    will be stored in the database and will be displayed on the page when users access
    it. The second one is called **active injection**, where a user enters a vulnerable
    script into an input that will be displayed immediately onscreen.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore these two scenarios with some examples in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Passive injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This type of XSS attack occurs when the web page accepts unsanitized text input
    that can be later displayed to a victim who is accessing this page. Suppose we
    have an online blog post that allows users to post comments and interact with
    each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the input field, where we should specify our comment, is accepting the text
    as is without validation or sanitization, then the attacker will inject a client
    script in the comment field, which will be triggered whenever a user is accessing
    this blog post. Here is an example of a comment that contains malicious input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the comment contains **JavaScript** code that will trigger
    an alert with a nasty message. This message will be stored in the comments table,
    and every time a user tries to access the page, the script will be triggered and
    the message will be displayed to the end user, which is very annoying.
  prefs: []
  type: TYPE_NORMAL
- en: 'The attacker can inject JavaScript code to manipulate the **HTML** code of
    the page, such as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, you will notice that the attacker injected a client-side
    library that can manipulate the HTML code of your page and display different content.
  prefs: []
  type: TYPE_NORMAL
- en: Active injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This type of XSS attack occurs when the user input is immediately displayed
    on the web page and is not saved on the server. Suppose we have a web page that
    is reading metadata from the query string of the URL, and it shows a welcome message
    when we access the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, an attacker can manipulate the query string and pass the following
    input script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will display an `XSS attack! weak security` alert message on the web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the following recommendations to help protect your application
    against XSS attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: Don't trust any user input, even if the user is authenticated. You should always
    validate the input provided by the end users. Moreover, you should encode query
    strings and escape single quotes before storing the text in a database or displaying
    it on a web page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure the URL query string is encoded, and always validate the value in the
    query string before using it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform content sanitization before you store untrusted content in your database.
    **HTML sanitization** is the process of checking content that is dynamic and only
    preserving tags that match with the whitelist.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should always use `@Html.Raw` to render untrusted content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can encode untrusted data before displaying it in your HTML code. This way,
    you make sure no one can inject an input with a script code because the encoding
    mechanism will convert `<` to `&lt;`, which will be treated as regular text.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure to set the `HttpOnly` flag to protect our cookies from being accessible
    through client-side code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-Site Request Forgery (CSRF)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**CSRF** (also known by the acronym **XSRF**, and pronounced *sea-surf* or
    *c-surf*) is a type of attack that is performed by a malicious website that enforces
    a trusted but vulnerable site to perform an undesirable action when the user is
    still authenticated.'
  prefs: []
  type: TYPE_NORMAL
- en: A CSRF attack is possible because browser requests include cookies that encapsulate
    the authentication tokens. In this case, the attacker is taking advantage of the
    authentication cookie to fool the trusted website, which cannot distinguish between
    legitimate requests and forged requests, by executing a malicious request using
    the authentication cookie from the trusted website. This type of attack is also
    known as a **one-click attack** or **session riding**.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to perform a CSRF attack is by attracting the attention of users
    to a malicious website by sending millions of phishing emails claiming that users
    won a big amount of money or a trip to Las Vegas. Usually, there is a link included
    in the email that will take us to the malicious website, and to collect our prize
    the malicious website would ask us to click a fancy button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, users would not hesitate to do so, for different reasons. One such
    reason is that they don''t know the risks or the consequences of clicking the
    button. Once the button is clicked, the malicious website sends the nasty request
    to the trusted website while attaching an authentication cookie with the request.
    If the vulnerable website is not taking precautions such as validating the incoming
    request (as in this case), the attack will, unfortunately, be successful. Here
    is a diagram showing a CSRF attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: Steps of a CSRF attack](img/Figure_7.04_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Steps of a CSRF attack'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some recommendations that should be considered to prevent CSRF attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate a user-specific CSRF token and store it in a hidden field. This token
    should be submitted with every request, and it should be validated on the server
    on all `POST`, `PUT`, and `DELETE` requests. The token should be regenerated on
    every request to prevent attackers from simulating this token and fooling the
    validation process on the server side. In MVC, we can use the following code to
    generate an anti-forgery token:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will output the following HTML code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[HttpPost]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[ValidateAntiForgeryToken]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public async Task<IActionResult>    Create (ProductViewModel newProduct)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <!-- rest of the action code goes here -->
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Consider checking the `referer` header of incoming requests, which should be
    referencing the same domain of the trusted site. This will prevent or cancel requests
    submitted from a different domain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cookie stealing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cookies are an essential part of a website because they usually hold the session
    details of the logged-in user. A **cookie** is an object that is transmitted back
    and forth between the client browser and the server. So, instead of authenticating
    the user on every request, the authentication token or claims can be stored in
    the cookie, and it will be used to identify the user after login. Without cookies,
    the user will need to log in again on every request.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to secure cookies if you are using them in your application.
    **Cookie stealing** (also known as **session hijacking**) is a type of attack
    that allows hackers to steal the cookie of a logged-in user, then impersonate
    that user and start sending requests on their behalf. In this case, the server
    is fooled because the request sent by the attacker looks authentic since it contains
    a valid authentication cookie.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent cookie stealing, we must apply the following recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a **Secure Sockets Layer** (**SSL**) certificate and only allow **HTTP Secure**
    (**HTTPS**) requests to encrypt all requests passed between the user and the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider applying `secure` and `HttpOnly` flags in the `web.config` file to
    protect the cookie and to ensure that it is only sent over an SSL connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regenerate the session ID immediately after login.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider clearing the authentication cookie on logout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overposting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Model binding** in ASP.NET handles the mapping of data between incoming requests
    and the .NET application model. It is a powerful feature that simplifies the process
    of populating the model properties with the user input data, based on a naming
    convention. However, this may cause another security breach by allowing an attacker
    to populate some properties in the model that are not presented in the form. This
    type of attack is called an **overposting** or **mass assignment**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the following example to understand the overposting vulnerability.
    Assume we have a user model that we are using to register a new user in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is pretty much a simple user model. You will notice that there is a property
    named `IsAdmin` in the model—this is used to specify if the user has an administration
    access level on the entire application. The **CSHTML** view should not include
    this property because we don''t want end users to decide their access level. The
    view should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – User registration sample form](img/Figure_7.05_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – User registration sample form
  prefs: []
  type: TYPE_NORMAL
- en: 'When the form is submitted, it will produce the following HTTP `POST` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: However, when using a debugging proxy-server tool, we can modify this HTTP request
    and include additional values and properties in the request. In this case, the
    attacker would include `IsAdmin:True` in the `POST` request. As a result, the
    user will be registered in the system with admin privileges.
  prefs: []
  type: TYPE_NORMAL
- en: '*How can we prevent this kind of attack?* Well, there are a few solutions to
    prevent this vulnerability, such as the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public IActionResult Register(User model)`, we can use `public IActionResult
    Register(string firstName, string lastName, string email, string password)`, and
    in the implementation of the action, we populate the model using the fields passed
    in the action''s parameters. In this case, any additional property that is added
    by the attacker will be ignored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegisterUserViewModel`. In this new model, we only add the properties needed
    for registration, so the action will become `public IActionResult Register(RegisterUserViewModel
    model)`. I like this option and I usually apply it as a common practice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BindAttribute` class on the method parameters and just include (whitelist)
    the properties we want to allow for binding. So, the action should look like this:
    `public IActionResult Register(([Bind("FirstName,LastName,Email,Password") User
    model)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a good practice, we must not use our database entities directly as models
    in the MVC views and actions.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing open redirection attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's first understand what an open redirection attack is. If you have logic
    in your web application that redirects users to a URL that is specified in the
    query string or via the HTTP request's parameters, this can potentially be tampered
    with to redirect users to a malicious URL, to steal their credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume an attacker sent an email with a redirect link such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Usually, some users won't look at the query string, and others won't even check
    the domain in the first part of the URL. When they click this URL, they will get
    redirected to a login page provided by the malicious website. This login page
    is very similar in terms of look and feel to the original login page in the trusted
    website. In this case, users will provide their credentials, assuming they log
    in normally.
  prefs: []
  type: TYPE_NORMAL
- en: However, the attacker will steal the credentials and redirect them to the original
    login page in the trusted website. Users will feel as though they provided the
    wrong username or password, so they will provide these again and continue what
    they wanted to do on the trusted website.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, the attacker steals the user credentials without the victim ever
    knowing about it. This type of attack is called an **open redirection attack**.
    Now, let's get to the part about how to prevent it.
  prefs: []
  type: TYPE_NORMAL
- en: When using such redirection logic in your web applications, treat all users
    as untrustworthy. Therefore, we need to make sure to only redirect to local URLs
    within our application or make use of a new method available in ASP.NET, named
    `LocalRedirect`. This is used to redirect to a local URL within the app itself,
    which means it validates the URL before triggering the redirection, and if the
    URL is not local, the method will throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Also, there is a method to validate whether a URL is local or not—you can make
    use of `Url.IsLocalUrl(..)`. This method will return a Boolean to indicate whether
    the URL is local or not.
  prefs: []
  type: TYPE_NORMAL
- en: Blocking brute-force attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In cryptography, a **brute-force attack** (also known as an **exhaustive search**)
    involves an attacker attempting to guess a password by thoroughly trying every
    possible combination of letters, numbers, and symbols until discovering the correct
    combination that works. In many cases, the attacker will use a bot tool to perform
    an automatic attack and predict the password. To prevent this type of attack,
    we can apply the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Lock the user account after a specific number of failed login attempts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a **Completely Automated Public Turing test to tell Computers and
    Humans Apart** (**CAPTCHA**) on the login page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider allowing logins from specific **Internet Protocol** (**IP**) addresses
    and restrict these from all other IP addresses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforce complex passwords.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider enabling 2FA.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Block the attackers' IP addresses, but this is not a guaranteed solution because
    the attackers can change the IP addresses from which they are performing the attacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider using a proper username and avoid using `admin`, `administrator`, or
    any other easy-to-guess usernames.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File-upload protection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A file upload allows users to upload files while submitting a form. A career
    form is a simple example of the usage of a file upload, where users need to attach
    their resume when applying for a job position. Attackers can make use of the file
    upload and try to upload malicious files to the server. Here are a few security
    steps that should reduce the likelihood of using a file upload to perform a successful
    attack:'
  prefs: []
  type: TYPE_NORMAL
- en: Disable the execute permissions on the folder where you are storing the uploaded
    files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure to use a whitelist to only allow approved file extensions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable client-side validation to check the file extension before uploading it
    to the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the size of the uploaded file and restrict the uploading of large files
    that exceed the size limit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure to check the header of the uploaded file, using the server-side code
    in .NET, to prevent the upload of malicious files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encode the filename, especially if you are displaying the filename in the HTML
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing SQL injection in ADO.NET and Entity Framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **SQL injection** is a vulnerability that enables an attacker to bypass the
    security measures taken in an application to execute malicious SQL commands directly
    in the application's database.
  prefs: []
  type: TYPE_NORMAL
- en: With these SQL commands, attackers can query the data of other users. They can
    also modify data and even delete some tables or the entire database, which can
    cause a major loss to the client business, especially if there is no proper backup
    process in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, they can escalate an attack to compromise the entire SQL server.
    A SQL injection attack is one of the most dangerous attacks we can face because
    it affects the entire database and possibly all databases hosted on the same server.
    Let''s get to know how to prevent this type of attack, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Check for malicious input data by enforcing constraints, validating the type
    and format of the data, and enforcing sanitization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider using parameterized SQL stored procedures for data access and avoid
    using text concatenation with inline SQL statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never grant administrative privileges to SQL users that are used in the data
    access layer—the read/write permissions should be enough.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid disclosing the details of database errors that may occur in the application.
    Actual errors should be logged properly in a centralized location, and the end
    user should be redirected to a custom error page with no technical details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypt the SQL connection in the `web.config` file to secure connectivity with
    the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL injection vulnerabilities are applicable in **NoSQL** databases such as
    **Azure Cosmos DB** and **MongoDB**, and therefore all the previous recommendations
    are also applicable in this case as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General security recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous sections, we learned about the major security vulnerabilities.
    In this section, we will highlight some security recommendations that will increase
    the security level of the solution, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider enabling audit trails, logging, and tracing to monitor all events and
    incoming requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always upgrade the .NET version used in your solution by installing .NET patches
    to benefit from the security enhancements released by the Microsoft team.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider encrypting passwords before sending them to the server to avoid sniffing
    attacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One of the common security steps is to enable the following response headers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'a. `Content-Security-Policy`: This allows us to specify a source whitelist
    of content that can be loaded onto the website. It helps to prevent XSS, `X-Content-Type-Options`:
    This helps in preventing `X-XSS-Protection`: This enables the XSS filter.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Block `X-Frame-Options` response header.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prevent disclosing sensitive data related to the hosting server and .NET Framework
    by removing the following response headers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'a. `Server`: This header specifies the web server version (IIS version).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'b. `X-Powered-By`: This header indicates that the website is powered by ASP.NET.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'c. `X-AspNet-Version`: This header specifies the version of ASP.NET used.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Avoid using third-party components and libraries with known vulnerabilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider updating **NuGet** packages periodically to make use of the latest
    fixes and enhancements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are hosting your app with IIS, make sure to encrypt the connection string
    because it contains the credentials of the user who can access the database. If
    you are hosting your app with Azure App Service, consider storing the connection
    string in the Azure application settings instead of the `web.config` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we explored a set of key security practices to help secure
    our ASP.NET web applications against malicious attacks. Once each of these practices
    is applied, it will add a security layer to the application. The objective is
    to highlight various areas that a solution architect should focus on while designing
    a robust web solution.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to secure a web API with a set of security
    recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: Web API security recommendations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With an increasing demand to build modern web and mobile apps, web APIs have
    become essential to empower these applications, with an easy way to communicate
    with the data access layer. This should be accompanied by proper security measures
    to protect web APIs. In addition to the security recommendations we discussed
    in the previous section, here are some essential tips to secure your web API:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider using the latest **Transport Layer Security** (**TLS**) version to
    encrypt communication between the app and the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticate users who are trying to consume the RESTful API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Act like a stalker by enabling audit logs, tracing, and logging to monitoring
    all events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider protecting your API by applying throttling and quotas, such as limiting
    the number of messages per a specific time. This is important to control the bandwidth
    of the server according to the available capacity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always validate the **JavaScript Object Notation** (**JSON**) data input to
    avoid SQL injection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable proper firewall configuration on the server where you host the web API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider having an API gateway, which is a middleware layer that sits between
    the client application and the RESTful API. This helps you to secure, control,
    and monitor the traffic to the RESTful API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prevent a **distributed denial-of-service** attack (also known as a **DDoS**
    attack), which sends a large number of useless requests to overwhelm the memory
    and capacity of the hosting server by flooding it with concurrent connections.
    You can prevent DDoS attacks in IIS by enabling the dynamic IP restrictions extension
    that can block incoming requests from certain IP addresses based on the number
    of concurrent requests. If the application is hosted in Azure, then we can enable
    **Azure DDoS protection**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider enforcing a timestamp in every request by adding it to the request
    header. This timestamp should be validated on the server to only accept requests
    if their timestamp is within a particular timeframe. This approach can help you
    protect the web API against brute-force attacks (explained in the *Blocking brute-force
    attacks* section) and replay attacks that allow attackers to maliciously complete
    duplicate requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we discussed a set of security recommendations that should
    be applied to secure an ASP.NET web API.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting web apps and APIs hosted on Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will highlight some security recommendations to bear in
    mind if you are hosting your web application or your web API on Azure, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider enabling **Azure Defender** to protect your app service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always run the integrated vulnerability assessment scanner available in Azure
    Defender for SQL servers to extend the protection of SQL servers along with stored
    databases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can keep your app service up to date by using the latest versions of supported
    platforms, frameworks, and protocols.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disable anonymous access to the blob storage to protect uploaded files. You
    can enable anonymous access to specific folders if needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforce the usage of the **SSL**/**TLS** protocol to provide a secure connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always use **File Transfer Protocol Secure** (**FTPS**) instead of the regular
    **FTP** to deploy your files and disable the FTP protocol if you are not using
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider using environment variables to store your database credentials, API
    tokens, and any application settings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider using a cloud **Windows Application Firewall** (**WAF**), which can
    help to protect your web applications from malicious attacks and common web vulnerabilities
    such as SQL injection and XSS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned that security is an essential part of a web solution.
    We outlined the fundamental security measures and techniques to help in understanding
    the possible security vulnerabilities that will allow us to protect an ASP.NET
    web application against malicious attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we highlighted some key guidelines to secure our RESTful API. Later,
    in this chapter, we explored some tips to secure our app that can be hosted on
    Azure. These security practices allow us to build robust yet secure ASP.NET apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the recommendations shared in this chapter, I strongly recommend
    you keep updating your knowledge about the security features in ASP.NET by reading
    the online official documentation shared by the Microsoft .NET team. Here is the
    link to the documentation: [https://docs.microsoft.com/en-us/aspnet/core/security/?view=aspnetcore-5.0](https://docs.microsoft.com/en-us/aspnet/core/security/?view=aspnetcore-5.0).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the different types of testing that we
    may need to conduct before releasing our solution.
  prefs: []
  type: TYPE_NORMAL
