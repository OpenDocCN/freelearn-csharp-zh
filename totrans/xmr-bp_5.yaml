- en: Chapter 5. Building a Stocklist Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we step back into `Xamarin.Forms` and look at detailing our XAML
    interfaces using CustomRenderers, Styles, and ControlTemplates. We will also look
    at the use of animations and a basic introduction to compound animations. Then,
    we are going to build a simple web service providing our mobile application with
    a JSON feed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expected knowledge:'
  prefs: []
  type: TYPE_NORMAL
- en: JSON serialization/deserialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some understanding of API controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some understanding of Linq queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some understanding of Observables and IObservables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some knowledge of IIS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an ASP.Net Web API 2 project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an API controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up mobile projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building core mobile projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving app performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a global `App.xaml`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Theming with `ControlTemplates`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the `MainPageViewModel`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Stocklist web service controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListViews` and `ObservableCollections`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value converters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further optimization with XAML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating `StockItemDetailsPage`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom renderers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding styles for custom elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the `StockItemDetailsPageViewModel`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up native platform projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hosting the Web API project locally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mobile developers, we are client side developers. We build user interfaces
    and absorb JSON data from web services. One advantage of developing in both server
    and client is the ability to tailor the back end to meet the needs of the mobile
    application. This can result in enhancing performance with data transactions on
    a web API. Building fast and reliable mobile applications can be difficult if
    we have to build off an old, slow-running back end. If users experience slow and
    unstable applications, they will normally never return to use it again.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will build a simple web service that our mobile application
    will use. Let's begin by opening up Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an ASP.Net Web API 2 project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to start with creating a new project in Microsoft Visual Studio.
    Go to **File** | **New Project** and select a new Visual C# ASP.Net project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an ASP.Net Web API 2 project](img/B05293_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We want to then select the **Empty** template and click the **Web API** checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an ASP.Net Web API 2 project](img/B05293_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can actually test the project right away and click **Run**, it will automatically
    deploy the site and run the application in your default browser. We now have our
    base **ASP.NET** application template, let's look more closely at the project
    structure. In the Solution Explorer, starting with the `Models` folder, this is
    where we create all our data objects that represent the data in the application,
    which are the objects that will be serialized to JSON and sent over HTTP requests.
    Then, in the `Controllers` folder, this is where we have our API controllers,
    which are objects that handle HTTP requests. These are the main two areas we are
    going to be focusing on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with creating a data model for a single stock item. Add a new
    file to the `Models` folder called `StockItem.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This object will be serialized into JSON and passed through our API controllers
    for the mobile application to retrieve. Normally, in every `MVC` / `ASP.NET` application,
    we have a data source layer and a Web API layer. In our data source layer, this
    is where the database sits, we store data here where our business logic layer
    will perform reads and writes. Our API layer will normally use the business logic
    layer to access the data and send over the network, a visual representation can
    be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an ASP.Net Web API 2 project](img/B05293_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building an API controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web API controllers are used to handle web requests. 99% of the time, mobile
    applications will always use an API layer in which it will call web requests to
    retrieve data, perform login, and so on. For our example, we are going to add
    a new empty `WEBAPI 2` controller.
  prefs: []
  type: TYPE_NORMAL
- en: '![Building an API controller](img/B05293_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking more closely at the code above, the API has two functions, one for
    returning all stock items, and another for returning a particular stock item.
    If we want to access this API controller via HTTP requests, the URLs will be:'
  prefs: []
  type: TYPE_NORMAL
- en: Get all stock items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Get a particular stock item by ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Does this format look familiar?
  prefs: []
  type: TYPE_NORMAL
- en: We will use these two calls inside our mobile application to retrieve data we
    have sitting on the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to have this API live we have two options: we can either deploy the
    site online (that is, using Azure or Amazon), or we can host it locally (using
    localhost).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's test the API layer and run the project. When the browser opens, paste
    the following URL into the browser: `localhost:{PORT}/api/GetAllStockItems`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The port number will be automatically assigned when the project is run so make
    sure you paste the correct port number specific to your project.
  prefs: []
  type: TYPE_NORMAL
- en: You should see an XML displayer with the results from the items in the API controller.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the mobile projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Moving back to the client side, we now need to start building our mobile applications.
    Let''s start with creating a blank `Xamarin.Forms` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the mobile projects](img/B05293_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Call the application `Stocklist`, and let's start with the iOS application.
  prefs: []
  type: TYPE_NORMAL
- en: Building core mobile projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's add two new PCL projects, call them `Stocklist.XamForms` and `Stocklist.Portable`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Building core mobile projects](img/B05293_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the **Stocklist.Portable** project we want to add the following nuget packages:'
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft HTTP client libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autofac
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Newtonsoft.Json
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive extensions (main library)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `Stocklist.XamForms` project we want to add the following nuget packages:'
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft HTTP client libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autofac
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xamarin.Forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive extensions (main library)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just copy the exact names of the libraries to bring up the libraries you require
    via the Package Manager tool.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our projects ready to go we can begin coding. From our previous
    solution in [Chapter 3](ch03.html "Chapter 3. Building a GPS Locator Application"),
    *Building a GPS Locator Application*, we want to reuse some major parts, such
    as the `IoC` container, modules, and cross-platform navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keeping mobile solutions modular and decoupled makes it easier to share code
    between different solutions. Why do you think we have nuget packages?
  prefs: []
  type: TYPE_NORMAL
- en: Like our `Locator` application, we will reuse the `MainPage` and `MainPageViewModel` objects.
    Copy these items over to your new projects and place the XAML page into a new
    folder called `Pages` in `Stocklist.XamForms`, and place the view-model object
    into a new folder called `ViewModels` inside `Stocklist.Portable`.
  prefs: []
  type: TYPE_NORMAL
- en: Improving app performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at a few ways we can improve application performance. Mobile phones
    do not have desktop processors, users typically run your application an older
    devices, meaning the performance power maybe be lacking. This is why we must test
    applications on older and newer devices to compare the performance difference
    and any API/OS changes that may effect behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Running applications on simulators can give different results when running on devices.
    Make sure you always test on physical devices before releasing.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the `MainPage.xaml` page from the `Locator` project. Here
    we will make small tweaks in the XAML layout to slightly improve the performance.
    The changes are very minor and will only improve performance by a millisecond
    here and there, but when you combine 100s of these small improvements, the end
    result will make a difference.
  prefs: []
  type: TYPE_NORMAL
- en: We can see a **Grid** with three elements inside, now why did we pick a Grid?
    Grids are good for views which we use to control any overlaying, or covering entire
    section/pages in which it is placed. Our first question is do we need to cover
    the entire screen for the landing page? No we don't, so we can replace the Grid
    with a `StackLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: One rule to apply, don't use a Grid when a `StackLayout` will do, and don't
    use multiple StackLayouts when a Grid will do.
  prefs: []
  type: TYPE_NORMAL
- en: 'One `StackLayout` will render faster than a single Grid when we don''t need
    to cover the screen or do any overlaying. Let''s replace the containing Grid with
    a `StackLayout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t stop now, let''s add some more. Turn attention to the `DescriptionLabel`,
    creating bindings for static text values that never change is wasteful. Instead,
    we will use `Spans` because they are a tad faster to render. First, create a new
    `.resx` file called `LabelResources.resx`, add a new variable called `DescriptionMessage`,
    and set the value to the string `Welcome to the Grocery Store`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ignore everything above the first `data` tag; this will be automatically generated
    when the file is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s import the `namespace` prefix in our `MainPage`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the preceding line to the starting tag of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s rebuild the label item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Looking at this more closely, we have a `Span` that is enclosed by a `FormattedString`
    tag, and the `FormattedString` tag is enclosed in the `Label.FormattedText` property.
    The `Span` is taking a static reference from our new `LabelResources`, and we
    have also moved the `OnPlatform` changes into the `Span` object (exactly the same
    as the label, but instead of the `TextColor` property, we are using the `Foreground`
    property).
  prefs: []
  type: TYPE_NORMAL
- en: These are two tiny enhancements for one label, you probably won't notice much
    of a difference in performance. If we had a page with a lot of static labels,
    it would make a small difference in loading speeds. Rendering labels is expensive.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also apply these performance improvements to both button titles. Let''s
    remove the bindings for the `Text` property on both buttons and replace them with
    the static values. Open up the `LabelResources` file and add the static values
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we apply it to the properties of the buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish off the landing page, let''s add an image above the buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All image files can be retrieved from the GitHub link: [https://github.com/flusharcade/chapter5-stocklist](https://github.com/flusharcade/chapter5-stocklist).'
  prefs: []
  type: TYPE_NORMAL
- en: The property `IsOpaque` is flagged to true on this image because the image is
    opaque. Setting this property to `true` allows another small performance enhancement.
    Transparent images are expensive to render.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our last addition to the page is to set the title of the page to another static
    value from our `LabelResources`. Add a new value called `WelcomeTitle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add it to the starting flag for `MainPage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Our finished implementation will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s review the small changes we made to this one `ContentPage`:'
  prefs: []
  type: TYPE_NORMAL
- en: Don't use a `StackLayout` when a Grid will do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't use multiple StackLayouts, use a Grid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace bindings with static values where possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the `IsOpaque` flag to `true` when the image is opaque
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `FormattedText` and `Span` on labels with static label values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The more enhancements we can apply, the faster your application will run. We
    will look at more enhancements in later projects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a global App.xaml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In all `Xamarin.Forms` projects we must create an `Application` file that inherits the
    `Application` class. We are going to extend this `Application` file and create
    a global resource dictionary. If you came from WPF you will recognize the use
    of a global resource dictionary that we can reference in all XAML sheets. This
    global resource dictionary is kept in the `App.xaml` file. It will have references
    to different converters, styles, and data templates. Rather than declaring static
    resource dictionaries at the top of every `ContentPage` or `ContentView`, we want
    to create only one dictionary that every XAML interface can access. This means
    we only create one dictionary at startup throughout the entire life of the application,
    rather than creating multiple dictionaries on views when they are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new `ContentPage`, call it `App.xaml`, and place it in the
    `Stocklist.XamForms` project. We can now remove the `App.cs` file that already
    exists in this project. Inside the `App.xaml` file, implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare an `Application` object using XAML, and in the resources section
    of the application we create the global dictionary. We also need to open the `App.xaml.cs`
    file and initialize the component (exactly the same as the initialization of the
    `ContentPage` and `ContentView`), the resource dictionary, and the `MainPage`
    object in the Application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Didn't we forget to do something prior to resolving `NavigationPage`?
  prefs: []
  type: TYPE_NORMAL
- en: 'We must add our `XamForms` module to the `IoC` container. First, let''s reuse
    the navigation setup from the `Locator` project. Create a new folder called `UI`
    and copy the following files from the `Xamarin.Forms` project in the `Locator`
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`INavigableXamarinFormsPage.cs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NavigationService.cs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XamarinNavigationExtensions.cs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will need to change the namespace in each file from `Locator.UI` to `Stocklist.XamForms.UI`,
    and make changes to the `PageNames` enum in the `GetPage` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! We now have the navigation service ready, let''s register this with
    the `XamFormsModule`. Create a new folder in the `Stocklist.XamForms` project,
    add a new file for `XamFormsModule`, implementing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now that our `XamFormsModule` is registered, we can resolve the `NavigationPage`
    and `NavigationService`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start building the items that will be contained in the global resource
    dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Theming with ControlTemplates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ControlTemplates` allow separation of logical view hierarchy from visual hierarchy.
    Similar to a `DataTemplate`, a `ControlTemplate` will produce the visual hierarchy
    for your controller page. One advantage of `ControlTemplates`, is the concept
    of theming. Many software applications provide settings to change user interface
    styles (Visual Studio and Xamarin Studio offer a dark and light theme). We are
    going to implement two themes for the `MainPage` and provide a `Button` to switch
    between the two.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with opening the `App.xaml` page, and adding the first `ControlTemplate`
    for the black theme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here we simply copy the content of the `MainPage` apply minor color changes
    as the templates are changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add another `ControlTemplate` for the white theme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notice the use of the `ContentPresenter` object in each template?
  prefs: []
  type: TYPE_NORMAL
- en: 'This is used to position content that will be shared across multiple templates.
    Open up `MainPage.xaml` and replace the content with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The content placed on the `MainPage` will be positioned where the `ContentPresenter`
    objects are situated in the `ControlTemplates`. The content is simply a button
    that will be shared across both `ControlTemplates`. We will start by setting the
    default `ControlTemplate` to the black theme.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the two command bindings set up on the `ContentPage`?
  prefs: []
  type: TYPE_NORMAL
- en: 'As our `ControlTemplates` need to bind to the `Commands` in our `MainPageViewModel`,
    we have to add some extra work setting up these bindings. Open up the `MainPage.xaml.cs`
    and implement these custom bindings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: These custom bindings will set up the link between each `ControlTemplate` and
    the view-model. Now each `Command` inside the `ControlTemplate` will respond to
    the `Command` implemented in the view-model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s finish off the **Change Theme** addition. First, let''s add the
    two template definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `originalTemplate Boolean` is used as a flag for switching to the opposite
    template with every button click. Next, we must initiate `ControlTemplate` from
    our global resource dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Each time the button is pressed, it will check to see if we are on the default
    template (the black theme) and switch to the white template if we are on the black
    template. We will also switch the background color between black and white to
    match the current theme.
  prefs: []
  type: TYPE_NORMAL
- en: All done. Now let's move over to the `MainPageViewModel` to finish up the page's
    `BindingContext`.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the MainPageViewModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have rebuilt our `MainPage`, let's make some small changes to the
    `MainPageViewModel`. Since we replaced the label bindings with static values,
    we remove the following variables, `DescriptionMessage`, `ExitTitle`, and `LocationTitle`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we should have the following `private` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now simply update `LocationCommand` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We must also update our constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here we simply rename some variables to match our application. We must also
    copy over the `Enums` and `Extras` folder, and replace the  `LocationPage` enum
    to `StocklistPage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to add the `PortableModule`. Create a new folder called `Modules`
    and copy the `PortableModule` from `Location.Portable`. Change the `PortableModule`
    class to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we need to add `INavigationService`. Create a new folder called `UI`
    and add `INavigationService` from `Location.Portable` into the new `UI` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Building project templates can reduce time spent setting up projects and recreating
    similar modules.
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the MainPageViewModel](img/B05293_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before we move any further we must update the namespaces in the code sheets
    copied from the `Locator` project. The easiest way is by using **Search** | **Replace
    in Files...**. We want to replace the text `Location.Portable` with the text.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be careful doing this; only apply a global replacement when the string is specific.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Stocklist web service controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s build our client web service controller to access the API. Since we
    built the back end, we should be able to whip this up very quickly. Our first step
    is to create the object which will deserialize a `StockItem`. We refer to these
    as contracts. Add a new folder in your `Stocklist.Portable` project called `StocklistWebServiceController`,
    and add another folder in this called `Contracts`. Create a new file called `StockItemContract.cs`
    and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s go ahead and build the `IStocklistWebServiceController` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The functions match the exact functions we have in the API controller. Before
    we implement this interface we have to create a new file called `Config.resx`
    in the `Resources` folder. For now, let''s just add some empty values for each
    URL path because we don''t know these until we either have the site running locally,
    or if we deploy it somewhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s implement the `IStocklistWebServiceController` interface. Starting
    the constructor; we will have to retrieve the `HttpClientHandler` (we will register
    this in the `IoC` container later):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s implement the first function to retrieve all the items. It will
    use a `HttpClient` to create an `Observable` from the asynchronous function `SendAsync`
    via an `HttpClient`. The `Observable` stream will be generated from the results
    returned from this function. We will then retrieve the response as a string (this
    will be JSON), and deserialize the string into multiple `StockItemContracts`,
    which then (using Linq) will be passed into the `Observable` stream and returned
    to the result of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And now for the `GetStockItem` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! We now have our `StocklistWebServiceController`; we now need to register
    this object to the interface inside the IoC container. Open up the `PortableModule`
    class and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: ListViews and ObservableCollections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we move on to `StocklistPage` and `StocklistPageViewModel`; these will be
    used to display all the items we pull down from the API. On the frontend we will
    be using<span highlight="">&nbsp;</span>`ListView`, they are the most common UI
    elements for displaying lists of data that are pulled down from any API. The beauty
    of `ListViews` is how they are presented via each platform. Placing a `ListView`
    in our XAML sheet via `Xamarin.Forms` on iOS will render a `UITableView`, on Android
    a native `ListView`, and in Windows a `FrameworkElement`. We can also create custom
    cell items and set up data bindings specific to each item, so with each contract
    that is deserialized, we want to have a separate view-model that will be used
    for representing the data on each cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a new file to the `ViewModels` folder in the `Stocklist.Portable`
    project called `StockItemViewModel.cs` and implement the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we want to add the `private` properties; they will be the same properties
    as in `StockItemContract`:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can choose to only represent certain items in a custom view cell. Inside
    the view-model we only create properties that will be displayed on the view.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we simply create the `public` properties for each `private` variable,
    following is one to get you started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here we are building a translation layer between the objects we deserialize and
    the objects we want to display. This is good for separating the logic contained
    in the view-models, as they have extra logic for processing the data to be displayed.
    We want our contracts to purely reflect the properties in the JSON object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add a public method on the view-model called `Apply`. This will take
    a `StockItemContract` as a parameter and update the properties of the view-model.
    It will be called when we want to update the data to be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Our next step is to implement the StocklistPageViewModel. This view-model will
    contain an `ObservableCollection`, which will be used to bind to the `ListView`.
    After we retrieve a list of contracts, we build another list of `StockItemViewModels`.
    Each item will apply the data from the contract and the new `StockItemViewModel`
    will be added to the `ObservableCollection`. We will apply the contract to update
    the data and then add the view-model to `ObservableCollection`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by adding a new file to the `ViewModels` folder called `StocklistPageViewModel.cs`,
    and start by creating a new view-model with its constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The navigation service is the same as the one used in the `Locator` project.
    We will register this later on in `Stocklist.XamForms` project. We use the `IStocklistWebServiceController`
    to fetch the `StockItems` from the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then need to register our `StockItemViewModel` inside `PortableModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we are using the `InstancePerDependency` function instead of `SingleInstance`?
    Since we are instantiating multiple items, if we used `SingleInstance`, the same
    data would be copied and changed across all `StockItemViewModels`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add the `private` and `public` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have all the properties, we can build the list of items for the `ObservableCollection`.
    Next, we add the `LoadAsync` function, it is responsible for creating the list
    of `StockItemViewModels`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `LoadAsync` function will be used to retrieve all contracts and build a
    list of `StockItemViewModels`. Every time we add a new `StockItemViewModel` to `ObservableCollection`,
    a `CollectionChanged` event will be fired to notify the `ListView` to update.
  prefs: []
  type: TYPE_NORMAL
- en: Have a look at how we are instantiating `StockItemViewModel` through `stockItemfactory`.
    It uses `Func` (`Func<StockItemViewModel>`) to generate a new view model every
    time we execute `Func`. This is why we need to call `InstancePerDependency`, so
    separate items are created. If we left the ending function on the registration
    as `SingleInstance`, even though we are calling `Func` on `StockItemViewModel`,
    it will only ever create one object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s build the user interface for the `StocklistPage`. It will contain
    the `ListView` for displaying the `StockItems` from the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Why can't we use StackLayout?
  prefs: []
  type: TYPE_NORMAL
- en: Since we need one element overlaying another, we have to use Grid. The `ActivityIndicator`
    is used to show the loading progress of our `LoadAync` function. When this is
    loading, our `ListView` will be invisible and the loading indicator is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Value converters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, there are times when we need to data bind two properties of incompatible
    types. A `Converter` is an object that converts the value from source to target
    and vice versa. Each converter must implement the `IValueConverter` interface,
    which implements two functions, `Convert` and `ConvetBack`. We are going to create
    a converter that will take a `bool` as the source, and simply return the opposite
    value to the value in the source.
  prefs: []
  type: TYPE_NORMAL
- en: The `ConvertBack` method will only be used if the data binding is a `TwoWay`
    binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Stocklist.XamForms` project, add a new folder called `Converters`,
    and inside this folder create a new file called `NotConverter.cs`, implement the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Even though the `InProgress` property doesn't use a two way binding, we still
    have to implement the `ConvertBack` function as part of the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Now back to the `StocklistPage.xaml`. When the `bool` property in the view-model
    changes, the `Convert` function of the `NotConverter` will be called. When the
    `IsProgress` value changes, the converter will be called and will return the opposite
    value for the `IsVisible` state on the `ListView`. When the progress is running,
    the `ListView` is invisible, and when the progress is not running, the `ListView`
    is visible.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are going to look at creating an `App.xaml` which will contain the DataTemplate
    used for each cell.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a DataTemplate to the global resource dictionary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's get back to the `App.xaml` file. Since we require a custom cell in
    our `ListView` on the `StocklistPage`, we are going to create a `DataTemplate`
    in the global resource dictionary. `DataTemplate` can be created in two ways,
    as an inline template or in a resource dictionary. There is no better method,
    it's more on personal preference. In our example, we are going to be creating
    ours in a resource dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the `App.xaml` file and insert the `DataTemplate` in the resource dictionary
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we want to set the `ItemTemplate` property on our `ListView` in the `StocklistPage`.
    Open up the `StocklistPage` and add the following to the `ListView` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to use the inline template approach, we would do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our custom cell we have three labels without any styling or font assignation.
    We are going to spice up the look of each cell using `Style`. A `Style` groups
    a collection of property values into one object that can be applied to multiple
    visual element instances. The idea of this is to reduce repetitive markup so we
    can reuse similar styles across similar controls in our XAML. There are multiple
    ways to apply styling to a control in `Xamarin.Forms`. In this example, we will
    show you how to create a global style in the `App.xaml` file, and apply it to
    different controls in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first global style will be for the title label in our custom cell. Let''s
    open up the `App.xaml` file and insert the following into our resource dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In preceding markup, each style will contain a list of `Setter` properties.
    These refer to the `BindableProperties` on our control. Now that we have our `Style`,
    we can refer to this static resource inside our `DataTemplate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! We have just created and set our first style on a `Label`. Let''s add
    some more styles to `MainPageControlTemplates`. We are going to style the buttons
    as they both share the same styled properties. Add the following to the global
    resource dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Looking closer at the preceding style, we can even use the `<OnPlatform>` tags
    to change setter values based on the platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s apply this `Style` to our `MainPage` buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: See how we are reducing the size of the markup?
  prefs: []
  type: TYPE_NORMAL
- en: This is one example of how we can apply `Styles`, we will see more techniques
    in further chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Further optimization with XAML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we talked about some minor changes we can apply to our XAML to improve
    on the performance. Let's look at how we can apply some performance enhancements
    on a `ListView`. If you have worked with any native `ListView` or `UITableView`,
    one of the biggest problems is the memory usage when we have a lot of elements
    to load whilst we are scrolling (that is, loading an image into each bitmap for
    every cell).
  prefs: []
  type: TYPE_NORMAL
- en: How do we solve this issue?
  prefs: []
  type: TYPE_NORMAL
- en: 'We use techniques for caching cells and reusing cells. Since `Xamarin.Forms`
    2.0, they have introduced some new features and enhancements around cell recycling
    mechanisms and caching strategies on `ListViews`. In order to set a caching strategy,
    we have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RetainElement`: This is the default behavior. It will generate a cell for
    each item in the list, cell layout will run for each cell creation. We should
    only be using this method if the cell layout is frequently changing, or if a cell
    has a large number of bindings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RecycleElement`: This takes advantage of native cell recycling mechanisms
    on iOS and Android. It will minimize the memory footprint and maximize the performance
    of a `ListView`. We should use this method if cells have a small to moderate amount
    of bindings, are similar in layout, and the cell view-model contains all the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We should always be aiming to use the second element, try to design your cells
    around this setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use the second caching strategy on our `ListView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '`RecycleElement` should be used as much as possible as we always want to tailor
    our apps to maximize performance wherever we can. Since we have a fairly simple
    cell design with a small amount of bindings and we keep all the data inside our
    view-model, we are able to use this setting.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s have a look at another simple addition we can use to improve the
    loading speed of our XAML sheets. Turning on XAML compilation allows your XAML
    sheets to be compiled rather than interpreted, which can provide multiple benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Helps markup errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduces application size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removes load and instantiation time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is highly recommended to have this setting on with all your `Xamarin.Forms`
    applications as it will increase the loading speed of your user interfaces (in
    particular with Android). We can add the compiled XAML by opening up the `App.xaml.cs`
    file and pasting the code below the preceding namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: If we add up all the performance additions we have applied to the project, we should
    see some improvement in the user interfaces as they present between different screens.
  prefs: []
  type: TYPE_NORMAL
- en: Creating StockItemDetailsPage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we move on to our last page of the application. We are going to add another
    page for displaying the details of a selected stock item from the previous `StocklistPage`.
    Firstly, we need to handle items selected from `ListView`, so open up `StocklistPage.xaml`
    and update the `ListView` element with the `SelectedItem` object bound to the
    `Selected` item in our view-model (we will add this after the XAML update). This
    will be set as a `TwoWay` binding because the data will change from both sides
    (from the view as we selected items, and the view-model as we will need the selected
    object data when we navigate to the stock details page):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add to the `StocklistPageViewModel`; we need to add a `public``StockItemViewModel`
    property that will hold the data of our binding when an item is selected from
    the list. The ID property of the selected `StockItemViewModel` will be passed
    through the navigation parameters for our `StockItemDetailsPage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add the new `StocklistItemDetailsPage`. Create a new XAML `ContentPage`
    and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking more closely at the code, we have added four labels and `ActivityIndicator`,
    which are used to show the progress of our page loading the data. We have also
    included a custom control `CustomLabel`, we reference this item via the namespace
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whatever name follows the `xmlns` keyword, this name must be called first to
    reference the item within the namespace we are trying to use, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we must create our `CustomLabel` object, which will be used for a `CustomRenderer`
    for Android, as we are going to set the font of this label to a custom `Typeface`,
    which we will include in both native projects. Create a new folder called `Controls`
    in the `Stocklist.XamForms` project, and create the following file, called `CustomLabel.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In our `CustomLabel`, we are adding a custom binding, which will be used specifically
    to set the font style for Android. When we set the font style on the native side,
    we have to set the custom font by the filename not the font name, whereas in iOS
    we reference the custom font by the font name and not the filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we set up custom bindings, we must always include a `static` property,
    this is our `BindableProperty`, which is used to reference the item of the UI
    element that we are binding on. Then we must always include the actual property
    which is referenced in the XAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Custom renderers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will find `Xamarin.Forms` covers most of the native controls via cross-platform
    elements such as XAML objects, but there are some UI elements which we must implement
    ourselves using `CustomRenderers`. `CustomRenderers` allows anyone to override
    the rendering process for specific controls placed in our XAML, and render native
    elements on the platform side. We must place a renderer specific to each platform,
    but for this example, we are only going to apply a custom renderer for the Android
    project as we want our custom labels to use custom fonts. iOS doesn''t need a
    renderer to allow custom fonts; all we have to do is add the reference to our
    font file in the `info.plist` file. Open up the `info.plist` file in your iOS
    project and add a new entry called `Fonts provided by application` (for an array
    element we simply add the path of our font file `GraCoRg_.ttf`). Then add the
    font file into the `Resources` folder of the iOS project, make sure the build
    action of the font file is set to `BundleResource` (do this by right-clicking
    on the file):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom renderers](img/B05293_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We also want to add this font file into the `Assets` folder of the Android project,
    and make sure we set the build action to `AndroidAsset`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can grab this font file from the GitHub link: [https://github.com/flusharcade/chapter5-stocklist](https://github.com/flusharcade/chapter5-stocklist).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the equivalent for Android, we must create a `CustomRenderer`
    for the `CustomLabel` item in our `Controls` folder. Open the Android project,
    create a new folder called `Renderers`, and add a new file called `CustomLabelRenderer`,
    and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In just about all the renderers, we are exposed to the `OnElementChanged` function
    which is called when a `Xamarin.Forms` custom control is created in order to render
    the corresponding native control. In some circumstances, the `OnElementChanged`
    method can be called multiple times, so care must be taken when instantiating
    a new native control in order to prevent memory leaks, which can have a large
    performance impact. In our case, we are not rendering a new control, so we only
    need to check that the `NewElement` and `Control` objects are not null when the
    function is called. We must also cast the `NewElement` item to our custom item,
    as this is the object which contains the custom binding for the `AndroidFontStyle`
    property. The `NewElement` will always be the custom item, so we can always cast
    it.
  prefs: []
  type: TYPE_NORMAL
- en: We can also now access the native UI frameworks; in this case, we are using
    the Android `Typeface` framework to create a custom `Typeface` which will use
    our font file. Then this `Typeface` is set to the `Typeface` property of the `Control`
    element (this is the actual element which will be displayed), in this case, because
    it is a `LabelRenderer`, the `Control` element is an Android `TextView`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In other renderers, we can set this control element to specific native elements,
    which we will be doing in further chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have to add the following line to export and register the renderer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Adding styles for custom elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We still have one more addition to finalise the `StockItemDetailsPage`. We
    are going to add a style for the `CustomLabel`. Open up the `App.xaml` file and
    add the following style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We have included a `Setter` for the `AndroidFontStyle` property we created
    earlier. Don''t forget we must also add the namespace reference for the `Controls`:'
  prefs: []
  type: TYPE_NORMAL
- en: That's everything for the user interface. Now let's move on to implementing
    the view-model for the `StockItemDetailsPage`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating StockItemDetailsPageViewModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we move on to the last view-model in our application. Add a new file called
    `StockItemDetailsPageViewModel` to our ViewModels folder in the `Stocklist.Portable`
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by implementing the `private` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be able to add the `public` properties yourself. Here is the first
    to get you started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to add the `LoadAsync` function, which will use `StocklistWebServiceController`
    to pull the data from our API for a specific `StockItem`. Notice the use of the
    `InProgress` property, this is used to track the loading progress; as we are downloading
    in the background we want to display this progress to the user interface via an
    `ActivityIndicator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add our constructor which will pull out the registered IoC objects
    and assign our `private` properties accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to register the view-model in the `CommonModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the extra enum for the `StockItemDetailsPage` to `PageEnums.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'And add the extra switch case to `NavigationService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the native platform projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we move on to the native platform layer and prepare the iOS, Android, and
    Windows Phone projects. We are going to start with iOS; let''s start by adding
    the NuGet packages required for the project:'
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft HTTP client libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modern HTTP client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autofac
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive extensions (main library)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we''ve added these packages to the project, let''s open the `AppDelegate`
    file and add the same `InitIoC` function we used in the `Locator` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Then call this method before we load the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Before running the iOS application, let''s also set up the Android project.
    We want to start by adding the same libraries as iOS, then opening `MainActivity.cs`,
    and adding the same function `InitIoC` as shown in the preceding example. Then,
    finally, we call the `InitIoC` function before we load the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? See how much code we are simply copying from another project?
  prefs: []
  type: TYPE_NORMAL
- en: The more problems we solve in other projects, the quicker we can piece together
    apps that have similar functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Hosting the Web API project locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can access the API layer from our mobile application, we have to set
    up hosting. For this example, we are going to walkthrough setup for hosting locally.
  prefs: []
  type: TYPE_NORMAL
- en: Hosting locally does not require much work, but it will require an instance
    of Windows and Mac OSX running together. You can achieve this by simply running
    parallels, or using a **Windows** and **Mac** computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first step is to open Visual Studio from our Windows instance and click
    the run button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hosting the Web API project locally](img/B05293_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the project starts, it will automatically open up your default web browser
    and show the application.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we don't have any visible web pages, we don't need to have the browser
    open. If the project is running, the web API will be running so we will be able
    to ping it over an HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the backend running, how do we access the API?
  prefs: []
  type: TYPE_NORMAL
- en: If you are running via two separate computers, we should be able to simply access
    the API through the IP address of the computer. In order to find out the IP address
    of the computer, open up a new command prompt window and type in `ipconfig`. This
    will display the IPv4 address that the computer has been assigned to on the current
    network.
  prefs: []
  type: TYPE_NORMAL
- en: '![Hosting the Web API project locally](img/B05293_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order for the local set up to work, please make sure both the mobile device
    and the computer hosting the WEB API are both on the same **WIFI/LAN** connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm we have this working, paste the following URL into a web browser
    on the Windows instance and see if we get results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The port is automatically assigned when the project is run, so when the browser
    appears with the localhost URL, paste the URL extension `api/StockItems`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we want to test this link on the Mac instance, but before we do, we have
    to change some settings in the `applicationhost.config` file located in `"C:\Users[YourName]\Documents\IISExpress\config\applicationhost.config"`.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Visual Studio 2015, it will be located in `/{project folder}/.vs/config/applicationhost.config`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven''t got **Internet Information Services** (**IIS**) switched on,
    follow these steps, to install IIS to serve static content:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the Start button, click **Control Panel**, click **Programs**, and then
    click **Turn Windows features** on or off.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the list of **Windows features**, select **Internet Information Services**,
    and then click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Look through the file until you can file your application entry like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The best way to find your particular entry is by searching for the `port` number.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `<bindings>` section, we want to add another row:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we want to allow incoming connections on this `PORT` and `IPv4 Address`
    from other computers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're running Windows 7, most incoming connections are locked down, so you
    need to specifically allow incoming connections to your application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, start an administrative command prompt and run these commands, replacing
    `{IPv4}:{PORT}` with the `IPv4 Address` and `PORT` you are using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This just tells `http.sys that it''s OK to talk to this URL`. Next, run the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This adds a rule in the Windows Firewall, allowing incoming connections to the
    port for computers on your local subnet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we should be able to access the running API from our Mac instance. This
    time, paste the URL with the IPv4 address instead of `localhost: {IPv4 address}:{port}/api/StockItems`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all was successful, we should have the following XML layout displayed like
    this:![Hosting the Web API project locally](img/B05293_05_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Excellent! Now let''s add these URL settings to our mobile application. Open
    up the `Config.resx` file in the `Resources` folder of the `Stocklist.Portable`
    project, and fill in these values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's test our project on iOS and Android, and we should be able to see
    our `StocklistPage` fill with items from our API controller.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have built an application for retrieving a web service using `Xamarin.Forms`.
    We set up a `ListView` and created an `ObservableCollection` for displaying JSON
    objects. We also learned how to set up a simple web service on the back end. In
    the next chapter, we will create an application for both iOS and Android using
    the native libraries. We will use Signal R on the client and server side, and
    set up a hub and proxy connections via a client.
  prefs: []
  type: TYPE_NORMAL
