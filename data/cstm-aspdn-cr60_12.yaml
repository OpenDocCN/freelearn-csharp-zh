- en: '*Chapter 12*: Content Negotiation Using a Custom OutputFormatter'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 12 章*：使用自定义 OutputFormatter 进行内容协商'
- en: In this chapter, we are going to learn about how to send your data to the client
    in different formats and types. By default, the ASP.NET Core web API sends data
    as JSON, but there are some more ways to distribute data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何以不同的格式和类型将数据发送到客户端。默认情况下，ASP.NET Core Web API 以 JSON 格式发送数据，但还有一些其他的数据分发方式。
- en: 'We''ll cover the following sections in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Introducing `OutputFormatter` objects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 `OutputFormatter` 对象
- en: Creating custom `Outputformatter` objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义 `Outputformatter` 对象
- en: 'The topics in this chapter relate to the WebAPI layer of the ASP.NET Core architecture:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的主题与 ASP.NET Core 架构的 WebAPI 层相关：
- en: '![Figure 12.1 – The ASP.NET Core architecture](img/Figure_12.1_B17996.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1 – ASP.NET Core 架构](img/Figure_12.1_B17996.jpg)'
- en: Figure 12.1 – The ASP.NET Core architecture
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – ASP.NET Core 架构
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the examples in this chapter, you will need to create an ASP.NET
    Core MVC application. To do this, open your console, shell, or Bash terminal,
    and change to your working directory. Then, use the following command to create
    a new MVC application:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章中的示例，你需要创建一个 ASP.NET Core MVC 应用程序。为此，打开你的控制台、shell 或 Bash 终端，切换到你的工作目录。然后，使用以下命令创建一个新的
    MVC 应用程序：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, open the project in Visual Studio by double-clicking the project file,
    or in Visual Studio Code by typing the following command in the already-open console:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过双击项目文件或在 Visual Studio Code 中在已打开的控制台中输入以下命令来打开项目：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All of the code samples in this chapter can be found in the **GitHub** repository
    for this book at [https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter12).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有的代码示例都可以在本书的**GitHub**仓库中找到，仓库地址为[https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter12)。
- en: Introducing OutputFormatter objects
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 OutputFormatter 对象
- en: In ASP.NET Core, `OutputFormatters` are classes that transform your existing
    data into different formats to send it through HTTP to clients. The web API uses
    a default `OutputFormatters` to turn objects into JSON, which is the default format
    to send structured data. Other built-in formatters include an XML formatter and
    a plain text formatter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 中，`OutputFormatters` 是将现有数据转换为不同格式以通过 HTTP 发送到客户端的类。Web API 使用默认的
    `OutputFormatters` 将对象转换为 JSON，这是发送结构化数据的默认格式。其他内置格式化程序包括 XML 格式化程序和纯文本格式化程序。
- en: With so-called *content negotiation*, clients are able to decide which format
    they want to retrieve. The client needs to specify the content type of the format
    in the `Accept` header. Content negotiation is implemented in `ObjectResult`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过所谓的 *内容协商*，客户端能够决定他们想要检索哪种格式。客户端需要在 `Accept` 标头中指定格式的内容类型。内容协商在 `ObjectResult`
    中实现。
- en: By default, the web API always returns JSON, even if you accept text/XML in
    the header. This is why the built-in XML formatter is not registered by default.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Web API 总是返回 JSON，即使你在标头中接受 text/XML。这就是为什么内置的 XML 格式化程序默认未注册。
- en: 'There are two ways to add `XmlSerializerOutputFormatter` to ASP.NET Core:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 向 ASP.NET Core 添加 `XmlSerializerOutputFormatter` 有两种方式：
- en: 'The first is shown in the following code snippet:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码片段展示了第一种方式：
- en: '[PRE2]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Or, alternatively, you can use the following:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，你也可以使用以下方法：
- en: '[PRE3]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You might need to add the `Microsoft.AspNetCore.Mvc.Formatters` namespace to
    the `using` statements.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要将 `Microsoft.AspNetCore.Mvc.Formatters` 命名空间添加到 `using` 语句中。
- en: There is also a formatter called `XmlDataContractSerializerOutputFormatter`
    available, which uses `DataContractSerializer` internally and is more flexible
    in its configurations.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为 `XmlDataContractSerializerOutputFormatter` 的格式化程序可用，它内部使用 `DataContractSerializer`，并且在配置上更加灵活。
- en: By default, any `Accept` header will automatically be turned into `application/json`,
    even if you use one of these methods. However, we can fix that.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，任何 `Accept` 标头都会自动转换为 `application/json`，即使你使用了这些方法之一。然而，我们可以解决这个问题。
- en: 'If you want to allow the clients to accept different headers, you need to switch
    that translation off:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要允许客户端接受不同的标头，你需要关闭这种转换：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Some third-party components that don't completely support ASP.NET Core 5.0 or
    later won't write asynchronously to the response stream, but the default configuration
    since ASP.NET Core 3.0 *only* allows asynchronous writing.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一些第三方组件可能不完全支持 ASP.NET Core 5.0 或更高版本，不会异步写入响应流，但自 ASP.NET Core 3.0 起的默认配置仅允许异步写入。
- en: 'To enable synchronous writing access, you will need to add these lines to the
    `ConfigureServices` method:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用同步写入访问，你需要在 `ConfigureServices` 方法中添加以下行：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Add the `Microsoft.AspNetCore.Server.Kestrel.Core` namespace to the `using`
    statements to get access to the options.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Microsoft.AspNetCore.Server.Kestrel.Core` 命名空间添加到 `using` 语句中，以便访问选项。
- en: To try the formatters, let's set up a small test project.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试格式化程序，让我们设置一个小型的测试项目。
- en: Preparing a test project
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备测试项目
- en: 'Using the console, we will create a small ASP.NET Core web API project, using
    the command shown previously in the *Technical requirements* section:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用控制台，我们将创建一个小型的 ASP.NET Core 网络API项目，使用之前在 *技术要求* 部分中显示的命令：
- en: First, execute the following commands to add the necessary `GenFu` is an awesome
    library to easily create test data, and the second package, `CsvHelper`, helps
    us to easily write CSV data.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，执行以下命令以添加必要的 `GenFu` 是一个易于创建测试数据的优秀库，第二个包 `CsvHelper` 帮助我们轻松写入 CSV 数据。
- en: 'Now, open the project in Visual Studio or in VS Code and create a new API controller
    called `PersonsController` in the `controller` folder:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 Visual Studio 或 VS Code 中打开项目，并在 `controller` 文件夹中创建一个新的 API 控制器 `PersonsController`：
- en: '[PRE6]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Open `PersonsController.cs` and add a `Get()` method like this:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `PersonsController.cs` 文件，并添加一个 `Get()` 方法，如下所示：
- en: '[PRE7]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You might need to add the following `using` statements at the beginning of
    the file:'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能需要在文件开头添加以下 `using` 语句：
- en: '[PRE8]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This creates a list of 25 persons by using `GenFu`. The properties will automatically
    be filled with realistic data. `GenFu` is an open source, fast, lightweight, and
    extendable test data generator. It contains built-in lists of names, cities, countries,
    phone numbers, and so on, and it fills the data automatically into the right properties
    of a class, depending on the property names. For example, a property called `City`
    will be filled with the name of a city, and a property called `Phone`, `Telephone`,
    or `Phonenumber` will be filled with a well-formatted fake phone number. You'll
    see the magic of `GenFu` and the results later on.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `GenFu` 创建一个包含 25 个人的列表。属性将自动填充真实数据。`GenFu` 是一个开源、快速、轻量级且可扩展的测试数据生成器。它包含内置的姓名、城市、国家、电话号码等列表，并自动将数据填充到类的正确属性中，具体取决于属性名称。例如，名为
    `City` 的属性将填充城市名称，而名为 `Phone`、`Telephone` 或 `Phonenumber` 的属性将填充格式良好的假电话号码。你将在稍后看到
    `GenFu` 的魔法和结果。
- en: 'Now, create a `Models` folder, and create a new file called `Person.cs` with
    the `Person` class inside:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个 `Models` 文件夹，并在其中创建一个名为 `Person.cs` 的新文件，并在其中包含 `Person` 类：
- en: '[PRE9]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Open `Program.cs` as well, add the XML formatters, and allow other `AcceptHeader`,
    as described earlier:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也要打开 `Program.cs` 文件，添加 XML 格式化程序，并允许其他 `AcceptHeader`，如前所述：
- en: '[PRE10]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That's it for now. Now, you are able to retrieve the data from the web API.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到此为止。现在，你能够从网络 API 中检索数据。
- en: Start the project by using the `dotnet run` command.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `dotnet run` 命令启动项目。
- en: Next, we'll test the API.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将测试 API。
- en: Testing the web API
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试网络 API
- en: 'The best tools to test a web API are **Fiddler** ([https://www.telerik.com/fiddler](https://www.telerik.com/fiddler))
    or **Postman** ([https://www.postman.com/](https://www.postman.com/)). I prefer
    Postman because I find it easier to use. You can use either tool, but in these
    demos, we will use Postman:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 测试网络 API 的最佳工具是 **Fiddler** ([https://www.telerik.com/fiddler](https://www.telerik.com/fiddler))
    或 **Postman** ([https://www.postman.com/](https://www.postman.com/))。我更喜欢 Postman，因为它更容易使用。你可以使用这两个工具中的任何一个，但在这些建议中，我们将使用
    Postman：
- en: In Postman, create a new request. Enter the API URL, which is [https://localhost:5001/api/persons](https://localhost:5001/api/persons)
    (the port of the URL might vary), into the `address` field, and then, add a header
    with the `Accept` key and the `application/json` value.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Postman 中创建一个新的请求。将 API URL（[https://localhost:5001/api/persons](https://localhost:5001/api/persons)（URL的端口号可能不同））输入到
    `address` 字段中，然后添加一个带有 `Accept` 键和 `application/json` 值的标题。
- en: 'After clicking `GenFu` object puts the data into the person''s properties,
    based on the property type and the property name: real first names and real last
    names, as well as real cities and properly formatted phone numbers.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在点击 `GenFu` 对象将数据放入人员的属性中后，基于属性类型和属性名称：真实的首字母和姓氏，以及真实的城市和格式良好的电话号码。
- en: 'Next, let''s test the XML output formatter. In Postman, change the `Accept`
    header from `application/json` to `text/xml` and click **Send**:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们测试 XML 输出格式化器。在 Postman 中，将 `Accept` 标头从 `application/json` 更改为 `text/xml`，然后点击
    **发送**：
- en: '![Figure 12.3 – A screenshot of XML output in Postman'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.3 – Postman 中 XML 输出的截图'
- en: '](img/Figure_12.3_B17996.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.3_B17996.jpg)'
- en: Figure 12.3 – A screenshot of XML output in Postman
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – Postman 中 XML 输出的截图
- en: We now have an XML-formatted output. Now, let's go a step further and create
    some custom `OutputFormatter` objects.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了 XML 格式的输出。现在，让我们更进一步，创建一些自定义 `OutputFormatter` 对象。
- en: Creating custom OutputFormatter objects
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义 OutputFormatter 对象
- en: In this example, our aim is to create a **VCard** output to be able to import
    the person's contact details directly into **Microsoft** **Outlook** or any other
    contact database that supports VCards. Later in this section, we also want to
    create a CSV output formatter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的目标是创建一个 **VCard** 输出，以便能够直接将个人的联系详情导入到 **Microsoft** **Outlook** 或任何支持
    VCards 的其他联系数据库。在本节后面的内容中，我们还想创建一个 CSV 输出格式化器。
- en: 'Both are text-based output formatters, and they will derive their values from
    `TextOutputFormatter`. Let''s look at the steps to create the VCard output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个都是基于文本的输出格式化器，它们将从 `TextOutputFormatter` 继承其值。让我们看看创建 VCard 输出的步骤：
- en: Create a new class in a new file called `VcardOutputFormatter.cs`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件中创建一个名为 `VcardOutputFormatter.cs` 的新类。
- en: 'Now, insert the following class skeleton in the new file. You will find the
    implementations of the empty methods in the following code snippets. The constructor
    contains the supported media types and content encodings:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在新文件中插入以下类骨架。你将在下面的代码片段中找到空方法的实现。构造函数包含支持的媒体类型和内容编码：
- en: '[PRE11]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You might need to add the following `using` statements:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能需要添加以下 `using` 语句：
- en: '[PRE12]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The next code snippet shows the implementation of the `CanWriteType` method.
    It is optional to override this method, but it makes sense to restrict it to a
    specific condition. In this case, the `OutputFormatter` can only format objects
    of the `Person` type:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的代码片段显示了 `CanWriteType` 方法的实现。重写此方法是可选的，但限制特定条件是有意义的。在这种情况下，`OutputFormatter`
    只能格式化 `Person` 类型的对象：
- en: '[PRE13]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You need to override `WriteResponseBodyAsync` to convert the actual `Person`
    objects into the output you want to have. To get the objects to convert, you need
    to extract them from `OutputFormatterWriteContext` object that gets passed into
    the method. You also get the HTTP response from this context. This is needed to
    write the results and send them to the client.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要重写 `WriteResponseBodyAsync` 方法，将实际的 `Person` 对象转换为所需的输出。为了获取要转换的对象，你需要从传递给方法的
    `OutputFormatterWriteContext` 对象中提取它们。你还可以从该上下文中获取 HTTP 响应。这是写入结果并发送给客户端所需的。
- en: 'Inside the method, we check whether we get one person or a list of persons
    and call the not yet implemented `FormatVcard` method:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法内部，我们检查是否得到一个人或人的列表，并调用尚未实现的 `FormatVcard` 方法：
- en: '[PRE14]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To format the output to support standard `Vcard`, you need to do some manual
    work:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将输出格式化为支持标准的 `Vcard`，你可能需要做一些手动工作：
- en: '[PRE15]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we need to register the new `VcardOutputFormatter` object in `Program.cs`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要在 `Program.cs` 中注册新的 `VcardOutputFormatter` 对象：
- en: '[PRE16]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You might need to add a `using` statement to `OutputFormatterSample`.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能需要在 `OutputFormatterSample` 中添加一个 `using` 语句。
- en: Start the app again using `dotnet run`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `dotnet run` 再次启动应用程序。
- en: Now, change the `Accept` header to `text/vcard`, and let's see what happens:![Figure
    12.4 – A screenshot of VCard output in Postman
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 `Accept` 标头更改为 `text/vcard`，看看会发生什么：![图 12.4 – Postman 中 VCard 输出的截图
- en: '](img/Figure_12.4_B17996.jpg)'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_12.4_B17996.jpg)'
- en: Figure 12.4 – A screenshot of VCard output in Postman
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 12.4 – Postman 中 VCard 输出的截图
- en: We now should see all of our data in `VCard` format.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们应该能看到所有数据都以 `VCard` 格式呈现。
- en: 'Now, let''s do the same for a CSV output. We already added the `CsvHelper`
    library to the project. So, go to the following URL and download `CsvOutputFormatter`
    to put it into your project: [https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/blob/main/Chapter12/OutputFormatterSample6.0/CsvOutputFormatter.cs](https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/blob/main/Chapter12/OutputFormatterSample6.0/CsvOutputFormatter.cs)'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为 CSV 输出做同样的事情。我们已经将 `CsvHelper` 库添加到项目中。所以，前往以下 URL 下载 `CsvOutputFormatter`
    并将其放入你的项目中：[https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/blob/main/Chapter12/OutputFormatterSample6.0/CsvOutputFormatter.cs](https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/blob/main/Chapter12/OutputFormatterSample6.0/CsvOutputFormatter.cs)
- en: 'Let''s have a quick look at the `WriteResponseBodyAsync` method:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们快速看一下`WriteResponseBodyAsync`方法：
- en: '[PRE17]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This almost works the same way as `VcardOutputFormatter`. We can pass the response
    stream via `StreamWriter` directly into `CsvWriter`. After that, we are able to
    feed the persons or the list of persons to the writer. That's it.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它几乎与`VcardOutputFormatter`以相同的方式工作。我们可以通过`StreamWriter`直接将响应流传递给`CsvWriter`。之后，我们就能将个人或个人列表喂给写入器。就是这样。
- en: 'We also need to register `CsvOutputFormatter` before we can test it:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试之前，我们还需要注册`CsvOutputFormatter`：
- en: '[PRE18]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In Postman, change the `Accept` header to `text/csv` and click **Send** again:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Postman中，将`Accept`头改为`text/csv`，然后再次点击**发送**：
- en: '![Figure 12.5 – A screenshot of text/CSV output in Postman'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5 – Postman中text/CSV输出的截图](img/Figure_12.5_B17996.jpg)'
- en: '](img/Figure_12.5_B17996.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5 – Postman中text/CSV输出的截图](img/Figure_12.5_B17996.jpg)'
- en: Figure 12.5 – A screenshot of text/CSV output in Postman
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – Postman中text/CSV输出的截图
- en: There we go – Postman was able to open all of the formats we tested.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做到了——Postman能够打开我们测试的所有格式。
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Isn't that cool? The ability to change the format based on the `Accept` header
    is very handy. This way, you are able to create a web API for many different clients
    – an API that accepts many different formats, depending on the clients' preferences.
    There are still many potential clients out there that don't use JSON and prefer
    XML or CSV.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 难道这不酷吗？根据`Accept`头改变格式的功能非常方便。这样，你就能为许多不同的客户端创建一个Web API——一个接受多种不同格式的API，具体取决于客户端的偏好。仍然有许多潜在的客户不使用JSON，而更喜欢XML或CSV。
- en: The other way around would be an option to consume CSV or any other format inside
    the web API. For example, let's assume your client sends you a list of people
    in CSV format. How would you solve this? Parsing the string manually in the `action`
    method would work, but it's not an easy option.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，也可以选择在Web API中消费CSV或其他任何格式。例如，假设你的客户端以CSV格式发送给你一串人名。你会如何解决这个问题？在`action`方法中手动解析字符串是可行的，但这不是一个容易的选择。
- en: This is what `ModelBinder` objects can do for us. Let's see how they work in
    the next chapter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`ModelBinder`对象能为我们做的。让我们看看它们在下一章是如何工作的。
