- en: Chapter 7. View Elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will find introductory information about **User Experience**
    (**UX**) design concepts and explanations on the differences and similarities
    of design principles on Xamarin platforms. Correlation between the UI elements
    will be illustrated and useful design patterns will be demonstrated with real-life
    examples to create a consistent user experience across platforms without compromising
    the native look-and-feel. This chapter is divided into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Design philosophy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User interaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design philosophy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the biggest pitfalls while designing an application for cross-platform
    use is to impose the design patterns from one OS to the other one. In the mobile
    world, each platform and users of those platforms have certain expectations from
    an application. These expectations can be as insignificant as an icon on a common
    feature access button (for example, the share button on iOS and Android), or as
    important as the layout of a view (for example, tab buttons on the bottom and
    top of a view on iOS and Windows Phone, respectively). In this paradigm, the designer's
    responsibility becomes much more complex, since the design, while creating a brand
    for the application, would need to be inviting and appealing for the users of
    the platform.
  prefs: []
  type: TYPE_NORMAL
- en: User expectations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mobile platform users are creatures of habit. One of the key deciding factors
    of the adoption rate of a mobile application is how easy it is to use and how
    discoverable the features are for the platform users. It is important to remember
    that when users become acquainted with a specific platform, they will expect certain
    patterns and behaviors while interacting with that device. Trying to change these
    habits and forcing the users into usage patterns that they are not accustomed
    to might be costly.
  prefs: []
  type: TYPE_NORMAL
- en: Platform imperatives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both iOS and Windows Runtime have well-defined design guidelines that were refined
    over the years with the help of Microsoft's and Apple's experience on various
    software platforms. Android, being an open source development platform, has been
    searching for an identity since the early versions and it was a general implementation
    principle to design first on iOS and port the design to Android. However, with
    the release of Material Design guidelines by Google, the Android platform and
    app developers finally seem to have found a scheme to adhere to and create a unified
    experience on the Android platform across different applications.
  prefs: []
  type: TYPE_NORMAL
- en: With the emergence of minimalism and flat design patterns in software design,
    Microsoft was the pioneer to release the Microsoft design language (the Modern
    UI, codenamed Metro). Modern UI design heavily depended on typograph and geometry.
    The motto of this design pattern is "content over chrome", and application developers
    were encouraged to use the content itself to provide the interactivity and remove
    any unnecessary ornaments that are not crucial to the content or the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '![Platform imperatives](img/B04693_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Panorama View from Windows Phone 7
  prefs: []
  type: TYPE_NORMAL
- en: With the release of iOS 7, Apple joined the minimalist movement with an overhaul
    of their user interface, which is described by Jonathan Ive (Senior VP of Design)
    as bringing order to complexity. Translucency, typography, and layering were the
    highlighted features of this new design. It was a major change of Apple's design
    direction which, at the time, was famous for its skeuomorphic designs on various
    applications and platforms.
  prefs: []
  type: TYPE_NORMAL
- en: '![Platform imperatives](img/B04693_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: iOS 7 Home Page and an Android dialog
  prefs: []
  type: TYPE_NORMAL
- en: Google's take on flat design principles, Material Design (codenamed Quantum
    Paper), tries to address the same type of design concerns by reducing the design
    elements to their very basics and recreating interactive surfaces with strong
    typography resembling paper and ink in essence.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware dependency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to web applications, on Xamarin target platforms, especially on Windows
    and Android, the hardware that the Xamarin application is going to be running
    or displayed on varies greatly. An application designed for a specific platform
    can be used on a low-end touchscreen device with a mediocre resolution or on a
    high-end phablet with an HD display on landscape or portrait rotations. This hardware
    dependency should be one of the main concerns while designing the UI for mobile
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, pre-Android 3.0 phones used to have hardware buttons that helped
    with the navigation throughout the application and the OS itself. These buttons
    consisted of a back, menu, search, and home buttons. Even though the hardware
    buttons were replaced with the bottom system navigation bar (software buttons)
    on later devices, this trait is followed by Windows Phone devices that still have
    the back, Windows, and search hardware buttons. On iOS, the navigation hierarchy
    implementation is completely up to the application and generally handled by the
    back button placed on the top navigation bar.
  prefs: []
  type: TYPE_NORMAL
- en: Design metrics on Android
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For varying resolutions, in order to create an adaptive user interface, each
    platform uses different methodologies. However, in each platform, the important
    metric unit is the pixel density. Pixel density can be defined as the number of
    pixels that can fit into an inch in length. According to the pixel density (PPI
    or pixels per inch), independent from the total physical width and height of the
    screen, developers can create consistent views across various mobile devices.
    In other words, total screen resolution (pixel density multiplied by screen dimensions)
    is a declining trait that is taken into consideration while designing cross device/platform
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: On the Android platform, to create a uniform experience on different pixel densities,
    developers and designers are encouraged to use density-independent pixels (dp)
    unit for expressing various dimensions and measurements of UI controls. Density-independent
    pixels are calculated by considering the 160 pixel density as a norm and calculating
    the display size in normalized pixel values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following table for more information on Android density-independent
    pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Screen Density | Density Bucket | Screen Resolution (pixels) | Screen Resolution
    (dp) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 120 | LDPI | 360 x 480 | 480 x 640 |'
  prefs: []
  type: TYPE_TB
- en: '| 160 | MDPI | 480 x 640 | 480 x 640 |'
  prefs: []
  type: TYPE_TB
- en: '| 240 | HDPI | 720 x 960 | 480 x 640 |'
  prefs: []
  type: TYPE_TB
- en: '| 320 | XHDPI | 960 x 1280 | 480 x 640 |'
  prefs: []
  type: TYPE_TB
- en: '*Android Density-Independent pixels (dp)*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In order to demonstrate the scaling and density independent pixels, we can
    compare the following views on different devices. Using the pixels to design the
    content would be visualized differently on different devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design metrics on Android](img/B04693_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using pixels to design the UI
  prefs: []
  type: TYPE_NORMAL
- en: However, if we were to use the same design elements with dp as the measurement
    unit, the UI would be much more uniform.
  prefs: []
  type: TYPE_NORMAL
- en: '![Design metrics on Android](img/B04693_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using dp to design the UI
  prefs: []
  type: TYPE_NORMAL
- en: Similar to dp, another density-independent measure unit on Android is "sp",
    or scalable pixels. The main difference between dp and sp is that sp is scaled
    according to the user's font settings and generally associated with text content,
    while dp is managed by the operating system and the user generally does not have
    any control over it.
  prefs: []
  type: TYPE_NORMAL
- en: For media resources (for example, images) and layouts, the Android solution
    structure supports creating specialized design elements. Icons and other graphics
    can be provided in alternative sizes and resolutions using the correct density
    bucket identifier as a suffix to the `drawable` folder (for example, `drawable-xhdpi`
    for extra high density). Similarly, if needed, multiple alternative layouts can
    be provided according to the screen size groups in the layouts folder (for example,
    `layout-xlarge` or `layout-xlarge-land` for portrait and landscape displays on
    an extra-large screen).
  prefs: []
  type: TYPE_NORMAL
- en: Design metrics on iOS
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the iOS ecosystem, there are only a handful of devices and screen resolutions.
    On this platform, the identifier on display scaling is the point (pt) notation.
    A point is displayed as one physical pixel on a non-retina display. On retina
    display and higher configurations (iPhone 6 Plus), the scaling factor is calculated
    as 2x and 3x, respectively, while the point measurements are kept as they are.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: iPhone 6 Plus has the scale factor of 3 and screen resolution of 414 x 736 points.
    This would translate to 1242 x 2208 pixel resolution. However, the physical supported
    resolution on this device is 1080 x 1920\. For this reason, images rendered (or
    rasterized) with the 3x scale factor are then down-sampled with a ratio of 1:1.15
    on this device.
  prefs: []
  type: TYPE_NORMAL
- en: Design metrics on Windows Runtime
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: On Windows Runtime, the scaling of the application view is taken care of by
    the scaling algorithms that normalize the size of controls, fonts, and other UI
    elements. This normalization process occurs on the runtime and developers generally
    do not need to deal with it. When designing Windows Runtime applications, the
    measurement unit is pixels. However, the pixels are referred to as effective pixels.
    Effective pixels are the normalized size unit of the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: '![Design metrics on Windows Runtime](img/B04693_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Effective Pixels on Windows Runtime
  prefs: []
  type: TYPE_NORMAL
- en: A common example for the effective pixels is to consider a font of size 24px.
    Text visualized with this font is displayed the same way on a phone 5-10 cm away
    from the user and on a surface hub couple of meters away.
  prefs: []
  type: TYPE_NORMAL
- en: Design elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to create a consistent layout across platforms, while conforming to
    the platform requirements, developers and designers need to familiarize themselves
    with each platform and draw parallels between the layouts and UI controls on these
    platforms. We will discuss this in the next chapter within the scope of Xamarin.Forms.
    The existence of parallels between these platforms makes the foundation of the
    Xamarin.Forms framework.
  prefs: []
  type: TYPE_NORMAL
- en: The basic layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main layout elements in all three platforms are very similar to each other.
    However, the placement of these elements differs greatly according to the platform.
  prefs: []
  type: TYPE_NORMAL
- en: '![The basic layout](img/B04693_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The User Interface Layout
  prefs: []
  type: TYPE_NORMAL
- en: On each platform, the status bar displaying the system information is located
    at the top of the screen (marked as "1" in the preceding screenshot). This section
    is one of the constant elements that should be kept in mind when designing applications
    for Xamarin target platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On Windows 10 operating system, the system bar can be expanded on user's initiative
    to give detailed information about the system. This expansion causes the elements
    to be hidden on the application canvas. However, this does not cause elements
    to offset, and the expansion occurs on a different layer of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: On all three platforms, the second element is generally the navigation bar (marked
    as "2" on the screenshot). This element is only used to display information about
    the current view on Windows Phone. However, on iOS and especially on Android,
    the navigation bar has additional functions. The navigation bar on iOS applications
    can be used for hierarchical navigational items. However, on the Android platform,
    the so-called app-bar contains the context-related commands and navigation items.
    The context menu presenting the additional context-related commands that do not
    fit on the main app-bar (navigation panel on the right-hand side) and the Navigation
    Drawer that reveals the left navigation panel are the functional and structural
    elements of the main app-bar on Android applications. Having application and content-related
    buttons or links on the title area on Windows Phone applications has been discouraged.
    However, on Windows 10, similar to the Navigation Drawer on the Android platform,
    developers can implement an application-level switch.
  prefs: []
  type: TYPE_NORMAL
- en: On Windows platform, context-related application commands and the additional
    items that are displayed inside a context menu are generally located at the bottom
    of the screen on the application bar (marked as "5"). Even though the application
    bar can be created on the top of the screen, this is generally a use case for
    applications that use the peer-to-peer/horizontal navigation patterns (refer to
    the next section, *Navigation*).
  prefs: []
  type: TYPE_NORMAL
- en: The system navigation bar (marked as "4") is located at the bottom of the screen
    on the Android platform. This bar contains three buttons, namely Back, Home, and
    History. These buttons used to be hardware buttons prior to Android 4.0.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of the bottom app-bar on Windows Phone and the system navigation bar
    on Android, on iOS this area is generally occupied by the tab bar (marked as "3").
    The tab bar provides the main navigation functionality in iOS applications and
    should be available on each screen of the application (similar to the peer-to-peer
    navigation app-bar on Windows Phone).
  prefs: []
  type: TYPE_NORMAL
- en: Navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In application design, the navigation strategy should be one of the first decision
    items. According to the requirements of the application or the elements to focus
    on, developers can adopt different navigations strategies.
  prefs: []
  type: TYPE_NORMAL
- en: 'While building the navigation tree and preparing the flowchart for the application,
    you can make use of two types of traverses: hierarchical (vertical) and peer-to-peer
    (horizontal). Horizontal navigation occurs when the user wants to navigate between
    pages that are on the same level of the navigation tree. Hierarchical navigation
    can be on either direction on the vertical path. As a rule of thumb, as the user
    navigates deeper, the number of similarly typed objects on the screen decreases
    and the details about a single object increases. In other words, it is rare to
    see list views in the lower nodes of a sub-tree in an app navigation hierarchy.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Navigation](img/B04693_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Navigation Hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: On top of the traditional navigation methods, jump links among the pages on
    various levels and sub-trees can also be used to provide easy access to these
    nodes (for example, a Home link navigating from the bottom of the hierarchy back
    to the main page).
  prefs: []
  type: TYPE_NORMAL
- en: In order to demonstrate the navigation design, we will be creating an interface
    for the TravelTrace application that was used as an example for functional implementations
    in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal navigation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Navigation between peers or siblings can provide an easy way to switch context
    between the items on the *top level*. In this case, peers would be representing
    the main features of an application that should generally be accessible to the
    user at all times. On this level, the navigation can be implemented with tabbed
    controls or application-level navigation providers such as the Navigation Drawer
    on the Android platform. The homepage should have clear design and focus; it should
    make a statement about what your app is tailored to do.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if we were to use our travel application to demonstrate the top-level
    peers, we would first need to decide on the main features that the application
    has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Possible features of this travel companion application could be:'
  prefs: []
  type: TYPE_NORMAL
- en: Get detailed information on nearby attractions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow users to plan their trips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and share travel memorabilia (photos, notes, tips, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Identifying features of the application could be:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a social medium to share and re-use travel experience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assisting the user before and during travels and cultural visits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, we want to emphasize the social aspect and also provide personal assistance
    for users during their visits. In the light of this "decision", we can start designing
    the initial concept for our application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Horizontal navigation](img/B04693_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Home Screen Sample
  prefs: []
  type: TYPE_NORMAL
- en: On the Windows Phone platform, the home screen can be either implemented as
    a hub or a pivot view. Although each view has similar navigational properties,
    pivot control is generally used to display segregated groups of content that carry
    similar traits.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, it is generally preferable to use a hub view as a homepage to make different
    top level sections of the application available and sub-nodes easily discoverable.
  prefs: []
  type: TYPE_NORMAL
- en: '![Horizontal navigation](img/B04693_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hub View (Windows Phone)
  prefs: []
  type: TYPE_NORMAL
- en: When considering Windows Phone and `HubView`, the only possible way of navigating
    between the top-level items in the hierarchy is a swipe gesture, while it is possible
    to tap on the tab bar buttons on the other platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Another type of horizontal navigation can occur when navigating through different
    categories or filtered views of content items. On the Android platform, the main
    app-bar can host a filter dropdown to select the proper category to display content
    items. On iOS, the navigation bar, or a secondary bottom tool bar, can be used
    to create a button to display a picker (aka spinner) to select the proper sibling
    on the navigation tree. Another possible horizontal navigation provider control
    on iOS would be the `SegmentedView` control, which can be used to display different
    perspectives of the same type of content (for example, previous trips as opposed
    to future plans or recent guides and recent albums).
  prefs: []
  type: TYPE_NORMAL
- en: '![Horizontal navigation](img/B04693_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SegmentedView control on iOS
  prefs: []
  type: TYPE_NORMAL
- en: On the Windows platform, it is generally a better idea to choose a master/detail
    type of implementation for use-cases with more than "several" categories where
    the possible categories are always visible and displayed side-by-side with the
    content area. It is also possible to use a drop-down menu on a fly-out attached
    to one of the command bar buttons. If the number of categories is limited, the
    `PivotView` control can be employed in the view implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Horizontal navigation](img/B04693_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Command bar flyout on Windows Phone
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible, on all platforms, to include in-content selection controls
    that help the user navigate between the categories (dropdowns, pickers, spinners,
    hyperlinks, buttons, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: For instance, a catalog view for our travel application that allows users to
    browse the uploaded content freely would need to categorize the country items
    on different continents.
  prefs: []
  type: TYPE_NORMAL
- en: '![Horizontal navigation](img/B04693_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Main App Bar Filter on Android
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Next/Previous buttons used on the top navigation bar and the main
    app-bar on iOS and Android, respectively, together with the swipe left/right gestures
    on Windows Phone, can create a pleasant experience when navigating between the
    siblings and/or collection items. This type of navigation is generally used at
    the bottom of the hierarchical navigation tree or at the bottom of a sub-tree.
  prefs: []
  type: TYPE_NORMAL
- en: Vertical navigation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Elements that have a parent-child relationship (for example, the parent page
    can be the country view and the child views can be the city details) can use the
    vertical traversal of the navigation tree. The simplest and most common way of
    vertical traversal is navigating to the details view of a content element when
    the user clicks on the item.
  prefs: []
  type: TYPE_NORMAL
- en: A common mistake related to the details concept is to make it a two-step process
    where the user first needs to select the item and then click on a details command
    button. In modern applications, it is crucial to make the UI intuitive by means
    of using the content elements themselves as interaction elements.
  prefs: []
  type: TYPE_NORMAL
- en: Once the user is in the details view, backward navigation to ascend in the navigation
    tree is implemented either with a back button on the main app-bar (on Android)
    and the navigation bar (on iOS), or by using the hardware back button (on Windows
    Phone) and the soft back button on the system bar (on Android). It is not recommended
    to use an additional back button on the Windows Phone platform since the design
    real estate is already limited and the same functionality can be implemented with
    the hardware button, as opposed to its desktop counterpart where there is no hardware
    button and the design canvas is relatively generous.
  prefs: []
  type: TYPE_NORMAL
- en: '![Vertical navigation](img/B04693_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Semantic Zoom on Windows Phone
  prefs: []
  type: TYPE_NORMAL
- en: On the Windows Phone platform, another way of creating a different perspective
    on the content elements without having to implement a secondary view is to use
    the `SemanticZoom` control. The `SemanticZoom` control provides two views of the
    same list of content elements where the first one is generally a categorized view
    with a smaller number of elements and the second one is the full list view with
    additional details on content items. The navigation between the two views is generally
    implemented with pinch-in and pinch-out gestures (see the *Gestures* section for
    details).
  prefs: []
  type: TYPE_NORMAL
- en: Jump navigation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jump or cross navigation occurs when the application navigates between different
    nodes without conforming to the navigation hierarchy (for example, it is possible
    to navigate to the details view of an item that is on the third-level from the
    hub page that is on the top level of a Windows Phone application).
  prefs: []
  type: TYPE_NORMAL
- en: This type of navigation is generally used with very particular features that
    do not relate to the general outline of the application. The navigation commands
    can be included on the navigation bar or as hyperlinks embedded into the content.
    It is also common to use the command bars to create item related navigation links.
  prefs: []
  type: TYPE_NORMAL
- en: '![Jump navigation](img/B04693_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Navigation Drawer on Android
  prefs: []
  type: TYPE_NORMAL
- en: Another possible way to create navigation access points for switching the context
    in an easy way is to use the Navigation Drawer type functionality on Android.
    A similar experience can be achieved with the persistent tab bar on iOS. As mentioned
    before, comparable functionality was added to the Windows Phone platform with
    the release of Windows 10.
  prefs: []
  type: TYPE_NORMAL
- en: Content elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each Xamarin target platform puts forward certain strategies and guidelines
    to visualize the content. Although developers are given the freedom to create
    appealing and innovative design blocks, especially on the Android and Windows
    Phone platforms, there are strict guidelines to adhere to. We can group these
    content blocks and controls in several categories.
  prefs: []
  type: TYPE_NORMAL
- en: Collection views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Collection views provide an efficient way to display collection-based content
    elements. In most implementation use cases, collection elements are interactive
    and display attributes of the content items with text and image controls. It is
    also common to add item-related commands or flags on the content items themselves
    in the shape of tokens (for example, the command to add an item to favorites,
    display a status icon, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: UITableView (iOS)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: On the iOS platform, `UITableView` provides a flexible way to display collection
    data on a customizable layout. On a table view, each cell can be customized to
    display a batch of attributes from the content items and developers are free to
    make use of the inbuilt events and commands to implement additional command logic
    (for example, row actions).
  prefs: []
  type: TYPE_NORMAL
- en: '![UITableView (iOS)](img/B04693_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Grouped table view & table view with details
  prefs: []
  type: TYPE_NORMAL
- en: Another out-of-the-box feature of the `UITableView` and the associated controller
    (`UITableViewSource`) is the so-called indexing of the content elements. Indexing
    works in a similar way as the jump lists on the Windows platform and provides
    an easy way to catalog the content items and enables the user to easily jump into
    the correct section or the group.
  prefs: []
  type: TYPE_NORMAL
- en: A search display controller can also be associated with a `UITableView`, creating
    a standard iOS search experience on a collection of items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the possible artefacts that can be included in a table view cell by
    default are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![UITableView (iOS)](img/B04693_07_16-a.jpg) | Checkmark | Signifies that
    the row is selected |'
  prefs: []
  type: TYPE_TB
- en: '| ![UITableView (iOS)](img/B04693_07_16-b.jpg) | Disclosure indicator | Signifies
    that another table is associated with the row |'
  prefs: []
  type: TYPE_TB
- en: '| ![UITableView (iOS)](img/B04693_07_16-c.jpg) | Detail disclosure indicator
    | Identifies that the user can click tosee details about the current row (for
    example, Popover) |'
  prefs: []
  type: TYPE_TB
- en: '| ![UITableView (iOS)](img/B04693_07_16-d.jpg) | Row reorder | Identifies that
    the row can be dragged to re-order |'
  prefs: []
  type: TYPE_TB
- en: '| ![UITableView (iOS)](img/B04693_07_16-e.jpg) | Row insert | Adds a new row
    to the table |'
  prefs: []
  type: TYPE_TB
- en: '| ![UITableView (iOS)](img/B04693_07_16-f.jpg) | Delete view/hide | Reveals
    or hides the delete button for the current row |'
  prefs: []
  type: TYPE_TB
- en: '| ![UITableView (iOS)](img/B04693_07_16-g.jpg) | Delete button | Deletes the
    row |'
  prefs: []
  type: TYPE_TB
- en: '*Table view artifacts*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: UICollectionView (iOS)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`UICollectionView` is used to create a grid-like layout on the iOS platform.
    Collection views are also customizable using the in-built properties and base-classes.
    Collection views are more flexible in nature compared to the table views which
    are inherently bound by the table structure and contained cells.'
  prefs: []
  type: TYPE_NORMAL
- en: Collection views are also made up of cells that can be displayed in numerous
    layouts. The default layout can be customized using a `UICollectionViewFlowLayout`.
    The flow layout can define parameters such as the minimum line spacing between
    the rows, the minimum interim spacing between the items, item sizes, and section
    insets (margins assigned to the sections in the collection).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code sample creates a simple flow layout structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Another option for customizing the layout of a collection view is to inherit
    the `UICollectionViewLayout` class and implement a custom layout. In the custom
    layout implementation, the class is responsible for providing the layout attributes
    such as the size and the location of the cells according to the collection size
    and available layout area.
  prefs: []
  type: TYPE_NORMAL
- en: '`UICollectionViewController` is used to normalize the data that is to be presented
    and act as a delegate for the collection and item level events such as cell selection
    and context menus.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `SupplementaryView` and `DecorationView` classes provide additional
    customizations by giving section related details and UI customizations on the
    collection view layer.
  prefs: []
  type: TYPE_NORMAL
- en: ListView (Android)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Listview` is one of the most overused components on the Android Platform.
    While it can be used to display a relatively small list of menu items, with adapters
    it can also be used to visualize data from other applications and services. It
    is possible to compare the `ListView` control to the `UITableView` control on
    the iOS platform and the data provider interfaces. Adapters on Android can be
    compared to `UITableViewSource` on iOS.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, `ListView` has 12 built-in views that can be accessed through the
    `Android.Resource.Layout` class. These layouts vary from simple single line of
    text to expandable grouped category views. Each layout uses several control references
    such as Text1, Text2, and Icon, which should be populated by the adapter assigning
    the values to the content fields. Implementing a custom layout is also possible
    by creating an AXML markup file and later referencing the markup in the adapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample custom layout implementation could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We can also extend the style by adding visual state selectors (see the background
    color assignment in the previous sample).
  prefs: []
  type: TYPE_NORMAL
- en: 'The custom visual state selector implementation could be defined as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the list adapter implementation would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code should generate a view similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ListView (Android)](img/B04693_07_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: List View with custom layout
  prefs: []
  type: TYPE_NORMAL
- en: GridView (Android)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Other than the `ListView` control, on the Android platform, collections can
    be visualized in `ViewGroup`. View groups are used to bundle different visual
    trees and display the items in a scrollable view element. The most common implementation
    of the `ViewGroup` is the `GridView` widget. `GridView` is a scrollable grid control
    where content items are again provided with a `ListAdapter` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '`GridView` is generally used with a homogenous set of content items. These
    content items consist of a set of text content and a related image item. Content
    items are generally referred to as tiles and they can also include several content
    related commands.'
  prefs: []
  type: TYPE_NORMAL
- en: Tiles are conceptually similar to the live tile blocks of Modern UI design of
    Windows applications. They are made up of primary and secondary content. The primary
    content fills the entire cell (for example, album cover in a photo gallery application),
    while the secondary is represented by icons or text. The primary action is, in
    most cases, a vertical descending navigation command (navigating to the details
    view). Context actions related to the content item are generally considered to
    be the secondary content on a tile.
  prefs: []
  type: TYPE_NORMAL
- en: If the amount of actions on a content item or the content is not homogenous,
    it is advised to consider using cards rather than tiles in a grid view.
  prefs: []
  type: TYPE_NORMAL
- en: CardView (Android)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `CardView` control was introduced in Android 5.0, and it can be described
    as a self contained content unit. The term self-contained here would refer to
    the fact that cards generally include multiple actions and various content-related
    items. Users generally do not need to resort to secondary actions (select and
    then use the context menu) to interact with these content items.
  prefs: []
  type: TYPE_NORMAL
- en: '![CardView (Android)](img/B04693_07_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A standard card layout
  prefs: []
  type: TYPE_NORMAL
- en: Cards are generally used when there is neither the need nor the possibility
    for direct comparison between the collection elements and the content consists
    of various types of data. Cards can be interactive through the use of action buttons
    or, in some cases, in-content input controls. They can be expandable and generally
    have a fixed width.
  prefs: []
  type: TYPE_NORMAL
- en: '`CardView` is implemented as a `FrameLayout` widget and can be used in association
    with a `ListView` or `GridView` to represent content elements.'
  prefs: []
  type: TYPE_NORMAL
- en: ListView and ListBox (Windows Phone)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`ListView` and `ListBox` are the main collection visualization controls on
    the Windows Phone platform. `ListView` is a more specialized implementation of
    `ListBox`, and it is primarily used for displaying text-based content. Its counterpart
    `ListBox` is highly customizable and can be adopted to display content composed
    of multiple data types.'
  prefs: []
  type: TYPE_NORMAL
- en: Both of these containers can be used for item-level context actions. However,
    `ListBox`, similar to `CardViews` on the Android platform, is used to create interactive
    content elements that might include actions and input controls.
  prefs: []
  type: TYPE_NORMAL
- en: Two-way data binding is available for both of these controls and items can be
    styled and customized using behaviors, item templates, and/or control styles.
    Orientation is vertical by default for both controls, but this can be set to horizontal
    if the content items are desired to be displayed on a horizontal line.
  prefs: []
  type: TYPE_NORMAL
- en: In case there is the need for more customization on the template level and how
    the items are laid out, developers can also use the `ItemsControl`, which is the
    base implementation for most of the collection views on the Windows Phone platform.
  prefs: []
  type: TYPE_NORMAL
- en: In order to customize how the items are displayed on a `ListView`, we would
    first need to create the `DataTemplate` that will be the template used for `ListViewItems`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample DataTemplate declaration could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once our template is ready, we can assign the template to our `ListView` together
    with the collection data source, which is a list of simple `SampleItem` objects
    with the properties described in the `DataTemplate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, the content items are displayed in the `ListView` in a two-column style
    with an image, title, and description text.
  prefs: []
  type: TYPE_NORMAL
- en: GridView (Windows Phone)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`GridView` is another implementation of the `ItemsControl` on the Windows Phone
    platform, which allows the developers to create collection views in a flow layout.
    `GridView` should generally be preferred over `ListBox` or `ListView` when dealing
    with media elements.'
  prefs: []
  type: TYPE_NORMAL
- en: '![GridView (Windows Phone)](img/B04693_07_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: ListView versus GridView
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the previously defined elements, `GridView` supports two-way data
    binding and can be customized using standard methodologies.
  prefs: []
  type: TYPE_NORMAL
- en: Virtualizing panels (Windows Phone)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It is important to realize the fact that mobile platforms are not as performant
    as desktop or tablet devices. Especially when dealing with big sets of data, even
    though applications can perform well visually on a desktop workstation, memory
    resources might cause the UI to flicker, lag, or even block on a mobile device.
    In order to decrease the memory usage and improve performance by means of loading
    only the needed data, Windows Runtime provides the virtualizing panel controls
    (for example, `VirtualizingStackPanel`). `ItemsControl`, which is the base for
    most of the collection view controls described here, supports both data and UI
    virtualizations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Virtualizing panels (Windows Phone)](img/B04693_07_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: UI Virtualization on Windows Runtime
  prefs: []
  type: TYPE_NORMAL
- en: UI virtualization deals with the controls being rendered on the application
    viewport. The application list view bound to a large number of items, in this
    case, does not need to render and keep the controls in the runtime memory but
    only deal with the ones that are in the viewport. In this paradigm, controls that
    are removed from the screen with a scrolling action need to be destroyed and redrawn
    if the user scrolls back.
  prefs: []
  type: TYPE_NORMAL
- en: Data virtualization deals with paged data sources. For instance, with a "virtualizable"
    data source (a collection that implements `ISupportIncrementalLoading`), only
    the data needed for the current viewport is loaded into the application and additional
    batches are requested from the data source when the UI control needs to display
    additional items. Random access virtualization lets developers retrieve a subset
    of data on any random ordinal. For this type of data virtualization, the data
    source needs to implement `INotifyCollectionChanged` and `IObservableVector`.
  prefs: []
  type: TYPE_NORMAL
- en: Modal views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modal views are temporary view components that can provide an interactive interface
    to get the user's input on a certain task or decide on the execution path of a
    workflow. It is also common to use alert dialogs to inform the user about critical
    information that is crucial for the execution of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Popover and alerts (iOS)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The iOS platform provides various modal dialogs to display, edit, and manipulate
    data in different scenarios. Each of these dialog types look different but the
    common denominator is the fact that they always get the focus and are displayed
    on the highest layer on the screen, while the content under the dialog is hidden
    with a translucent overlay layer.
  prefs: []
  type: TYPE_NORMAL
- en: Action sheets are one of the most-frequently used modal dialogs. This dialog
    type is generally used to give the user an option before starting a task or cancelling
    the task. It is generally displayed as a list of buttons; the last of which is
    generally the "cancel" button, at the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Popover and alerts (iOS)](img/B04693_07_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Action sheet display on iOS
  prefs: []
  type: TYPE_NORMAL
- en: Action sheets can be initialized using a `UIAlertController` and specifying
    the `UIAlertControllerStyleActionSheet`. If the screen size permits (on a horizontally
    regular environment), action sheets are displayed as a popover.
  prefs: []
  type: TYPE_NORMAL
- en: Alert dialogs are another type of modal dialogs on iOS. Alerts are generally
    used to inform or ask consent from the user about an issue that affects the execution
    of the application. Unlike action sheets, alert dialogs can contain descriptive
    text, a title, and even a text input field.
  prefs: []
  type: TYPE_NORMAL
- en: '![Popover and alerts (iOS)](img/B04693_07_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Alert dialog with input field and with only description and title
  prefs: []
  type: TYPE_NORMAL
- en: Alert dialogs can be invoked with `UIAlertController`, using the `UIAlertControllerStyleAlert`.
    Alert dialogs should avoid any kind of redundant, informal, and negative content.
    If the title provides enough information for the user to continue with the execution,
    description text could be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: Popovers are another type of temporary context views on the iOS platform. However,
    popovers only are displayed on a horizontally regular environment (in both portrait
    and landscape in iPad, and only in landscape rotation in iPhone 6 Plus). In horizontally
    compact environments, they are displayed as full screen modal dialogs.
  prefs: []
  type: TYPE_NORMAL
- en: In order to initialize a popover, `UIPopoverPresentationController` can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Modal dialogs are another type of temporary view display used on iOS. Modal
    dialogs can be used in scenarios where a self-contained and compact view is needed
    to execute a very particular task or workflow.
  prefs: []
  type: TYPE_NORMAL
- en: '![Popover and alerts (iOS)](img/B04693_07_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Modal dialog with page sheet style
  prefs: []
  type: TYPE_NORMAL
- en: Modal dialogs can be created using the `UIPresentationController` with various
    modal presentation styles (full screen, page sheet, form sheet, and current context).
    However, the presentation styles associated with modal dialogs behave almost the
    same on horizontally compact environments (all iPhone models except iPhone 6 Plus
    in landscape orientation).
  prefs: []
  type: TYPE_NORMAL
- en: Flyout, popups, and menus (Windows Phone)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Flyouts are the main modal dialogs on the Windows Phone platform. They can be
    used in various scenarios, including showing a context menu, showing additional
    details of an item, or getting consent from the user. The common behavior of different
    types of flyouts is that they are always displayed with the highest z-index on
    screen and the elements underneath are disabled with a translucent overlay. Flyouts
    have, by default, a light-dismiss mechanism. In other words, they can be dismissed
    if the user taps anywhere outside the flyout control's borders.
  prefs: []
  type: TYPE_NORMAL
- en: Flyouts are generally associated with another control on the current view either
    by using the attached properties or using the `ShowAt` function of the `Flyout`
    class. The Content property of the Flyout class is used to assign a `UIElement`
    to display on screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding sample code would create a flyout which has text content, an
    input field, and a button as its content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Flyout, popups, and menus (Windows Phone)](img/B04693_07_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Simple flyout menu on Windows Phone
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In spite of the fact that flyouts are always attached to a `UIElement` (either
    using XAML or through code) and the dialog should be displayed in the vicinity
    of the associated element, on Windows Phone, flyouts behave like message dialogs
    displaying on the top of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In Windows Runtime, it is possible to use the derived types of flyouts for specific
    scenarios. `MenuFlyout`, `TimePickerFlyout`, and `DateTimePickerFlyout` are examples
    for these implementations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Flyout, popups, and menus (Windows Phone)](img/B04693_07_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Menu Flyout Usage
  prefs: []
  type: TYPE_NORMAL
- en: Other than flyouts, popup control can also be used to display a temporary view
    or details of a content item. Popups are generally stand-alone controls and can
    directly be included in the view XAML. They can optionally use light-dismiss and
    can be shown or hidden using the `IsOpen` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'For alert dialogs or critical input requirements, the `MessageDialog` class
    provides developers a familiar implementation tool. `MessageDialog` is a simple
    dialog used to display text content and numerous UI commands. The `UICommand`
    class represents a button and the associated action (if any) and is used to display
    actions on the dialog and provide a result to the dialog once selected by the
    user. The following implementation creates a message dialog with a text field
    and two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This would be shown on the UI similar to how flyouts are visualized:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Flyout, popups, and menus (Windows Phone)](img/B04693_07_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: MessageDialog example on Windows Phone
  prefs: []
  type: TYPE_NORMAL
- en: Dialogs (Android)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Dialogs on Android can be implemented as simple as an alert dialog or a full
    screen dialog that retrieves the required form data to continue the current task.
    Dialogs behave the same way as modal dialog implementations on other platforms;
    they interrupt the current task and are displayed on top of the underlying layer.
    The content underneath is hidden with a translucent grey overlay layer.
  prefs: []
  type: TYPE_NORMAL
- en: Simple alert dialogs, like their parallel implementations on other platforms,
    consist of a title, a descriptive content, and confirmation actions. They are
    invoked on critical scenarios where the user's input is crucial to continue with
    the execution.
  prefs: []
  type: TYPE_NORMAL
- en: '![Dialogs (Android)](img/B04693_07_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Android Alert Dialog
  prefs: []
  type: TYPE_NORMAL
- en: It is important to be careful to avoid any ambiguity in the descriptive content
    and the action button contents.
  prefs: []
  type: TYPE_NORMAL
- en: Another popular dialog used in Android applications are the context menu dialogs.
    This type of dialog does not require any confirmation once the item from the list
    is selected. They also have the light dismiss behavior. If the dialogs have additional
    information about the selection item and maybe additional actions, they are referred
    to as simple dialogs. The selection on these dialogs do not require confirmation
    either.
  prefs: []
  type: TYPE_NORMAL
- en: '![Dialogs (Android)](img/B04693_07_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Android Dialogs
  prefs: []
  type: TYPE_NORMAL
- en: If the dialog implementation requires the user to explicitly confirm the choice
    made, these dialogs are generally referred to as confirmation dialogs. It is common
    to have a "cancel" button at the bottom of the dialog screen so the previous selected
    option can be kept.
  prefs: []
  type: TYPE_NORMAL
- en: Text views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On all three platforms, with the emergence of the minimalist design inclinations,
    typography and text content items became the focus of UX design. Each platform
    has well-defined guidelines on font sizes and typefaces for different scenarios.
    More importantly, each of these platforms has specialized ways to display and
    edit rich text formats.
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows**: On the Windows Phone platform, Run elements are used to define
    specific sections of text that have a certain formatting applied to. Run elements
    can then be included in `TextBlock` elements or `RichTextBlock` controls. In addition
    to the Runs, `RichTextBlocks` can be used in conjunction with html-like styling
    elements (for example, bold, span, italics, and so on). Using the `RichTextBlocks`
    and `RichTextBlockOverflow` as a container, any shape and style text displays
    can be supported in Windows Phone applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Android**: On the Android platform, text formatting is achieved using the
    so-called spans. There are numerous pre-styled span implementations such as `RelativeSizeSpan`,
    `ForegroundColorSpan`, and `ClickableSpan`. These span implementations are used
    to set certain sections of a `SpannableString` with the described styles. There
    is a `SpannableStringBuilder` class that can be used to create the styled paragraphs/text
    content. Once the `SpannableString` is complete, it can be used as content for
    the `TextView` control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iOS**: On the iOS platform, text-related features and controls are introduced
    by the Core Text library. The `UITextView` control is the visualization element
    in this library. Text formatting is achieved by using the `NSMutableAttributedText`
    class. For attributed text content, different text ranges can be set to use certain
    attributes such as `NSUnderlineStyleAttribute`, `NSBackgroundColorAttribute`,
    and so on. When displaying attributed text blocks a `NSTextContainer` can be used
    to describe a shape as line fragments in which the text should be displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Web view controls are used to display rich HTML content on Xamarin target platforms.
    These web view controls build their own navigation stack independent from the
    application runtime. On Android and Windows phone, it is also possible to inject
    JavaScript into the HTML content that is being displayed on the control.
  prefs: []
  type: TYPE_NORMAL
- en: On all the platforms, it is possible to load not only remote, but also local
    web applications from the application resources.
  prefs: []
  type: TYPE_NORMAL
- en: Feedback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the pillars of modern application design is keeping the user informed
    at all times about the actions being executed by the application and the progress
    of these tasks. Even if the application is dealing with a blocking call (the execution
    cannot continue before finishing the task), displaying a progress ring creates
    the illusion that the application is still responsive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Progress indicators can be categorized into two groups: indeterminate and determinate.'
  prefs: []
  type: TYPE_NORMAL
- en: Indeterminate progress
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Indeterminate tasks and the associated progress indicators are related to the
    operations where the application cannot provide neither an estimated completion
    time nor progress information. These operations might depend on completion of
    multiple sub-procedures and might be related to the whole application or only
    a single UI element.
  prefs: []
  type: TYPE_NORMAL
- en: With indeterminate processes, we first need to decide on how crucial the process
    is for the application. If the application cannot continue without completing
    the current process, this would be an application-level blocking call. In cases
    of blocking calls (involving single step or multiple steps), it is a good idea
    to use a progress ring on the main content area. A good example for this scenario
    would be a main client trying to retrieve e-mail messages from the server without
    knowing how many items there are on the server. If there are multiple steps involved
    in this process, you can additionally show an information text near or over the
    progress ring.
  prefs: []
  type: TYPE_NORMAL
- en: This implementation on Android can be achieved with the `ProgressDialog` class.
    Instantiating this control provides a modal dialog with the possibility to include
    a descriptive text. It is important to set the indeterminate flag to true before
    displaying it on the UI.
  prefs: []
  type: TYPE_NORMAL
- en: '![Indeterminate progress](img/B04693_07_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Progress rings on Android, iOS and Windows Phone
  prefs: []
  type: TYPE_NORMAL
- en: On iOS, the same visualization is achieved with the `UIActivityIndicatorView`.
    You can modify the behavior to animate and change the color.
  prefs: []
  type: TYPE_NORMAL
- en: On Windows Phone, the `ProgressRing` class provides the same type of functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In indeterminate scenarios where the process being executed does not stop the
    user from continuing with application interaction, it is better to give a more
    subtle indication about the process and the controls involved in the execution.
    This can be achieved by using a progress ring or a bar in the vicinity of or over
    the control where the process started. On iOS, the only distinction between the
    progress bar and the ring is the process being determinate or indeterminate. However,
    on Android and Windows Phone, a progress bar can also act as an indeterminate
    task indicator. On the Windows Phone platform, it is also general practice to
    display an indeterminate progress bar on top of the screen if the process is an
    application level task, but the interaction with the application can continue
    without waiting for the result of this process.
  prefs: []
  type: TYPE_NORMAL
- en: Determinate progress
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Determinate tasks and associated indicators are related to processes where the
    application can provide a current state information to the user. A determinate
    progress indicator of choice on Xamarin target platforms is the progress bar.
    Progress bars, while providing a visual indication of the current completion state
    of the process, can also include a label giving a text description of the current
    state of the task.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to also provide a cancellation method (for example, a cancel
    button near the progress bar) if the process is relatively long.
  prefs: []
  type: TYPE_NORMAL
- en: '![Determinate progress](img/B04693_07_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Android determinate progress bar displays
  prefs: []
  type: TYPE_NORMAL
- en: On the Android platform, in addition to the progress indication, a buffering
    percentage can also be displayed on the progress bar.
  prefs: []
  type: TYPE_NORMAL
- en: User interaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important element in cross-platform development projects is the set
    of user interaction patterns for the application. Users already using the application
    on other platforms would want to find the same interaction patterns on clients
    running on another platform. This decision process gets even more complicated
    with platform specific interaction patterns, since the application should provide
    a familiar interface for platform users. It is important to achieve a balanced
    compromise between platform nativity and application identity in such scenarios
    and find the optimum solution.
  prefs: []
  type: TYPE_NORMAL
- en: A good example for branding by means of using an interaction pattern, would
    be the "pull-to-refresh" interactive pattern used in iOS applications. Most application
    providers dealing with information feeds (for example, Facebook, Twitter, and
    so on) used this implementation in their iOS applications. Even though this is
    not a native interaction pattern on Android and Windows Phone, a similar approach
    quickly became popular on these platforms; hence, most developers and users are
    now adopting this use-case on various platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In most cases, applications built for Xamarin target platforms would require
    input and other interactive controls to collect necessary information from the
    user. By interactive, we are referring to almost all the UI controls that can
    be used in a Xamarin application. In this case, even a simple filter dropdown
    control to select a different view perspective would be an interaction control,
    requesting information from the user display appropriate data or perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Text input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Text input fields are one of the most used type of input fields. Text fields
    can be implemented as a single line of text or as a multiline. An important aspect
    of text fields is the fact that as soon as a text input field gets selected on
    a touch-enabled device, the virtual keyboard appears on the screen. It is generally
    a good idea to keep this in mind while designing the user interface and implementing
    it later on.
  prefs: []
  type: TYPE_NORMAL
- en: On iOS, while the `UITextField` provides an input mechanism for single line
    of text requirements, `UITextView` can be used to create editable rich text content.
    Both of these controls provide options such as capitalization and correction.
  prefs: []
  type: TYPE_NORMAL
- en: '![Text input](img/B04693_07_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: UITextView Edit and Read-only Views
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, `UITextView` provides detectors that can transform Internet addresses
    to links, addresses to map links, phone numbers into deep-links to make a phone
    call, and date/time values to calendar event items.
  prefs: []
  type: TYPE_NORMAL
- en: Android text input fields are similar to the ones on iOS platform. The key difference
    is that on Android, instead of two different controls, only the `EditText` control
    exists for multiline and single line text inputs. This is achieved by settings
    the `InputType` property of the control (or `inputType` attribute in AXML). Other
    input scopes, besides the text format, can be set such as postal address, capitalized
    words, autocorrect, and capitalized sentence beginnings. Note that these scope
    parameters are bit-wise combinations. Another specialized control that provides
    auto suggestions is the `AutoCompleteTextView`, to which developers can assign
    an `ArrayAdapter` as a source for suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: On Windows Phone, `TextBox` is the most commonly used text input control. It
    can be highly customized to meet the previously mentioned requirements. Moreover,
    the input scope field lets developers control the virtual keyboard displayed for
    entering the value. For instance, setting the scope to be a telephone number would
    display a keyboard with only digits. `AutoSuggestBox`, `PasswordBox`, and `RichEditBox`
    are other controls that can be used for more specialized scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Dropdown selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dropdown elements can be used, on each platform, utilizing the specialized controls.
    While the `UIPickerView` is used on iOS, the same implementation is achieved on
    Android by so-called spinners. Spinners, very much like other content-driven controls,
    are populated with a `SpinnerAdapter`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Dropdown selection](img/B04693_07_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Dropdown controls on iOS, Android and Windows Phone
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the spinner control, simple menu dialogs can also be used for
    users' input. Windows Runtime provides additional specialized controls, the `ComboBox`
    and `ListView`, for different selection use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Option selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to the radio or check boxes on HTML forms, each platform provides options
    related UI elements. On Android, specialized controls for this scenario are Checkbox,
    RadioButton, and ToggleButton. Starting with Android 4.0 (API 14), Switch control
    can also be used. Other than the visual difference between these controls, the
    behavior is the same. On iOS, the main toggle control for Boolean data types is
    the Switch. Similar to Android, Windows Phone offers checkbox, radio button, and
    toggle switch control with option selections and Boolean types.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many other controls on each platform, and each provides a specific
    use case for different UI interaction scenarios. UX guides for Windows Runtime
    and Material Design are great resources for the respective platforms. Even though
    the Apple human interface design documents do not provide extensive UX guidelines
    as the other platforms, they are great resources to learn about user control use
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: Gestures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When developing for Xamarin target platforms, you should always keep in mind
    that the devices that are going to run the application will most probably have
    a touchscreen.
  prefs: []
  type: TYPE_NORMAL
- en: Touchscreen devices, apart from the classic pointer-like gestures (for example,
    tap, double tap, scroll, and so on), also provide various interaction gestures
    that help developers create an interface that can interact with the user in a
    more natural way.
  prefs: []
  type: TYPE_NORMAL
- en: '| ![Gestures](img/B04693_07_33.jpg) | Tap | In most scenarios, the tap gesture
    is analogous to a single click with a pointer device. It is primarily used to
    select a control. |'
  prefs: []
  type: TYPE_TB
- en: '| Long Press | Long press or tap and hold is used to access a context menu
    on Windows Phone. It is used for item selection on Android. |'
  prefs: []
  type: TYPE_TB
- en: '| Double-Tap | Double tap is generally used for scaling up / zooming-in on
    a control. |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe Down | Swipe down or pan down is used on vertical scroll scenarios.
    Also, list controls support swipe down for selection on Windows. It is also common
    to be used with "Pull to Refresh" implementations. |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe Right | Similar to swipe down, swipe right is used on vertical scroll
    scenarios and sibling navigation scenarios. It is called "flick" if the gesture
    is fast. |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe Left | This is same as other pan gestures. It can also be used to delete
    a list item on iOS and Windows Phone 10. |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe Up | This is another panning gesture. It can additionally be used to
    reveal a bottom sheet on Android applications. |'
  prefs: []
  type: TYPE_TB
- en: '| Tap & Drag | This is generally used as an active gesture to interact with
    draggable components. |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch Out | This is used in active canvas application patterns. It is used
    to zoom in on a view. On Windows, semantic zoom control makes use of this. |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch In | This is similar to the Pinch-Out gesture and is used to zoom out
    of an active content area of application screen (for example, zoom in on a photo).
    |'
  prefs: []
  type: TYPE_TB
- en: '| Rotate | This is another gesture used on active canvas applications (for
    example, a map client). It is used to rotate the current view-port. |'
  prefs: []
  type: TYPE_TB
- en: '*Common Gestures*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: While some of these gestures are already implemented by out-of-box controls
    on Xamarin platforms, there might be scenarios where you need to use them to create
    a new interaction use case in your application. For these type of requirements,
    specialized implementations can be found on respective frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: On the iOS platform, the starting point for gesture recognizer implementation
    is the abstract class `UIGestureRecognizer`. There are numerous implementations
    of gesture recognizer in the `UIKit` and they can be combined and used with delegate
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: On Android, the `GestureDetector` class and the `IOnGestureListener` interface
    can be used to provide implementations for various gesture events and user actions.
    Classic interaction events such as pan gestures and tap actions can already be
    accessed through the `OnTouchEvent` method of any `Activity` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: On the Windows Phone platform, most of the default controls provide interaction
    with pointer or touch events for classic manipulation scenarios. However, for
    more complicated gestures, the `GestureRecognizer` class available in the `Windows.UI.Input`
    namespace can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presented an overview of the design philosophy of, and patterns
    on, Xamarin target platforms. The design elements section outlined the main controls
    and layouts that are at the disposal of designers and developers while providing
    various content display strategies. There were additional sections about interactive
    and modern user interface design.
  prefs: []
  type: TYPE_NORMAL
- en: Even though each platform provides its own UI design patterns and guidelines,
    the main focus of the design effort in a cross-platform application is to find
    an optimal compromise between native look-and-feel and application brand design.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the Xamarin.Forms framework and make use
    of the correlation between the design elements that are outlined here.
  prefs: []
  type: TYPE_NORMAL
