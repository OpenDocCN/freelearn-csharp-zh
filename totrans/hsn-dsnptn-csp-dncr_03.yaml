- en: Modern Software Design Patterns and Principles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代软件开发模式和原则
- en: In the previous chapter, **object-oriented programming** (**OOP**) was discussed
    in preparation for exploring different patterns. As many patterns rely on concepts
    in OOP, it is important to introduce and/or revisit these concepts. Inheritance
    between classes allows us to define an *is-a-type-of relationship*. This provides
    a higher degree of abstraction. For example, with inheritance it is possible to
    perform comparisons such as a *cat* is a type of *animal* and a *dog* is a type
    of *animal*. Encapsulation provides a way of controlling the visibility and access
    of details of a class. Polymorphism provides the ability to handle different objects
    using the same interface. With OOP, a higher level of abstraction can be achieved,
    providing a more manageable and understandable way to deal with large solutions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，为了探索不同的模式，讨论了**面向对象编程**（**OOP**）。由于许多模式依赖于OOP中的概念，因此介绍和/或回顾这些概念很重要。类之间的继承使我们能够定义一个*is-a-type-of*关系。这提供了更高的抽象程度。例如，使用继承可以进行诸如*cat*是*animal*类型和*dog*是*animal*类型的比较。封装提供了一种控制类细节可见性和访问性的方法。多态提供了使用相同接口处理不同对象的能力。通过OOP，可以达到更高的抽象层次，提供了一种更易于管理和理解的方式来处理大型解决方案。
- en: This chapter catalogs and introduces different patterns used in modern software
    development. This book takes a very broad view of what a pattern is. A pattern
    in software development is any solution to a general problem that software programmers
    face during development. They are built from experience on what works and what
    does not. Also, these solutions are trialed and tested by numerous developers
    in various situations. The benefit of using a pattern is based on this past activity
    both in not repeating the effort and in the assurance that the problem will be
    solved without introducing a defect or issue.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章对现代软件开发中使用的不同模式进行了目录化和介绍。本书对模式的概念采取了非常宽泛的看法。在软件开发中，模式是对软件开发人员在开发过程中遇到的一般问题的任何解决方案。它们是从经验中构建的，这些经验包括哪些有效和哪些无效。此外，这些解决方案在多种情况下由众多开发者进行了试验和测试。使用模式的好处基于过去的活动，既不重复努力，又确保问题在没有引入缺陷或问题的情况下得到解决。
- en: Especially when taking technology-specific patterns into consideration, there
    are too many to cover in a single book so this chapter will highlight specific
    patterns to illustrate different types of pattern. We have tried to pick out the
    commonest and most influential patterns based on our experience. In subsequent
    chapters, specific patterns will be explored in more detail.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在考虑特定技术模式时，模式太多，一本书难以涵盖，因此本章将突出特定的模式来展示不同类型的模式。我们根据经验挑选出了最常见和最有影响力的模式。在随后的章节中，将更详细地探讨特定模式。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Design principles, including SOLID
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计原则，包括SOLID
- en: Pattern catalogs, including **Gang of Four** (**GoF**) patterns and **Enterprise
    Integration Pattern** (**EIP**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式目录，包括**设计模式**（**GoF**）模式和**企业集成模式**（**EIP**）
- en: Software development life cycle patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件开发生命周期模式
- en: Patterns and practices for solution development, cloud development, and service
    development
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案开发、云开发和服务开发的模式和惯例
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter contains various code examples to explain the concepts. The code
    is kept simple and is just for demonstration purposes. Most of the examples involve
    a .NET Core console application written in C#.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种代码示例来解释概念。代码保持简单，仅用于演示目的。大多数示例涉及使用C#编写的.NET Core控制台应用程序。
- en: 'To run and execute the code, you need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行和执行代码，您需要以下内容：
- en: Visual Studio 2019 (you can also run the application using Visual Studio 2017
    version 3 or later)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019（您也可以使用Visual Studio 2017版本3或更高版本运行应用程序）
- en: .NET Core
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core
- en: SQL Server (the Express Edition is used in this chapter)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server（本章使用的是Express版本）
- en: Installing Visual Studio
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Visual Studio
- en: 'To run these code examples, you need to install Visual Studio or you can use
    your preferred IDE. To do this, follow these instructions:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些代码示例，您需要安装Visual Studio，或者您可以使用您首选的IDE。为此，请按照以下说明操作：
- en: 'Download Visual Studio from the following link: [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载Visual Studio：[https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).
- en: Follow the installation instructions included. Multiple versions are available
    for Visual Studio installation. In this chapter, we are using Visual Studio for
    Windows.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照包含的安装说明进行操作。Visual Studio安装有多个版本可用。在本章中，我们使用的是Windows版本的Visual Studio。
- en: Setting up .NET Core
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置.NET Core
- en: 'If you do not have .NET Core installed, you need to follow these instructions:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有安装.NET Core，你需要遵循以下说明：
- en: 'Download .NET Core from the following link: [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载.NET Core：[https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).
- en: 'Follow the Installation instructions and related library: [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照安装说明和相关库：[https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).
- en: 'The complete source code is available in GitHub. The source code shown in the
    chapter might not be complete so it is advisable to retrieve the source in order
    to run the examples: [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter2](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter2).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可在GitHub上找到。章节中显示的源代码可能不完整，因此建议检索源代码以运行示例：[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter2](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter2).
- en: Design principles
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计原则
- en: Arguably, the most important aspect of good software development is software
    design. Developing software solutions that are both functionally accurate and
    easy to maintain is challenging and relies considerably on using good development
    principles. Over time, some decisions that were made early in the project can
    cause solutions to become too costly to maintain and extend, forcing systems to
    be rewritten, while others with a good design can be extended and adapted as business
    requirements and technology change. There are many software development design
    principles and this section will highlight some popular and important ones you
    need to be familiar with.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 不可否认，软件开发最重要的方面之一是软件设计。开发既功能准确又易于维护的软件解决方案具有挑战性，并且很大程度上依赖于使用良好的开发原则。随着时间的推移，项目早期做出的某些决策可能导致解决方案变得过于昂贵，难以维护和扩展，迫使系统需要重写，而那些设计良好的解决方案则可以根据业务需求和技术的变化进行扩展和适应。有许多软件开发设计原则，本节将突出一些你需要熟悉的流行且重要的原则。
- en: DRY – Don't Repeat Yourself
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DRY – 不要重复自己
- en: The guiding thought behind the **Don't Repeat Yourself** (**DRY**) principle
    is that duplication is a waste of time and effort. The repetition could take the
    form of processes and code. Handling the same requirement multiple times is a
    waste of effort and creates confusion within a solution. When first viewing this
    principle, it might not be clear how a system could end up duplicating a process
    or code. For example, once someone has determined how to do a requirement, why
    would someone else take the effort to duplicate the same functionality? There
    are many circumstances in which this happens in software development, and understanding
    why this happens is key to understanding the value of this principle.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要重复自己**（DRY）原则背后的指导思想是，重复是时间和精力的浪费。重复可能以流程和代码的形式出现。处理相同的要求多次是浪费精力，并在解决方案中造成混乱。当首次看到这个原则时，可能不清楚一个系统是如何最终重复一个流程或代码的。例如，一旦有人确定如何完成一个需求，为什么其他人还要费力去重复相同的功能？在软件开发中，这种情况有很多，理解为什么会发生这种情况是理解这个原则价值的关键。'
- en: 'The following are some common causes of code duplication:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些常见的代码重复原因：
- en: '**Lack of understanding**: In large solutions, a developer might not have a
    full understanding of an existing solution and/or does not know how to apply abstraction
    to solve the problem with existing functionality.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺乏理解**：在大型的解决方案中，开发者可能对现有解决方案没有全面的理解，或者不知道如何应用抽象来解决现有功能的问题。'
- en: '**Copy and paste**: To put this simply, the code is duplicated in multiple
    classes instead of refactoring the solution to allow for multiple classes to access
    the shared functionality.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复制粘贴**：简单来说，代码在多个类中重复，而不是重构解决方案以允许多个类访问共享的功能。'
- en: KISS – Keep It Simple Stupid
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: KISS – 保持简单，傻瓜
- en: Similar to DRY, **Keep It Simple Stupid** (**KISS**) has been an important principle
    in software development for many years. KISS stresses that simplicity should be
    the goal and complexity should be avoided. The key here is to avoid unnecessary
    complexity and thus reduce the chances of things going wrong.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与DRY类似，**保持简单，傻瓜**（**KISS**）在软件开发中已经是一个重要的原则很多年了。KISS强调简单应该是目标，复杂性应该被避免。这里的关键是避免不必要的复杂性，从而减少出错的可能性。
- en: YAGNI – You Aren't Gonna Need It
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: YAGNI – 你不会需要它
- en: '**You Aren''t Gonna Need It** (**YAGNI**) simply states that functionality
    should only be added when it is required. Sometimes in software development, there
    is a tendency to *futureproof* a design in case something changes. This can create
    requirements that are actually not needed currently or in the future:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**你不会需要它**（**YAGNI**）简单地说，只有在需要时才应该添加功能。在软件开发中，有时有一种趋势，即为了防止设计发生变化而进行**未来化**设计。这可能会产生实际上目前或未来都不需要的需求：'
- en: '"Always implement things when you actually need them, never when you just foresee
    that you need them."'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: “总是在你需要的时候实现事物，而不是仅仅预见你需要它们的时候。”
- en: '*- Ron Jeffries*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*- 罗恩·杰弗里斯*'
- en: MVP – Minimum Viable Product
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVP - 最小可行产品
- en: By taking a **Minimum Viable Product** (**MVP**) approach, the scope of a piece
    of work is limited to the smallest set of requirements in order to produce a functioning
    deliverable. MVP is often combined with Agile software development (see the *Software
    development life cycle patterns* section later in the chapter) by limiting requirements
    to a manageable amount that can be designed, developed, tested, and delivered.
    This approach lends itself well to smaller website or application development,
    where a feature set can be progressed all the way to production in a single development
    cycle.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用**最小可行产品**（**MVP**）的方法，一项工作的范围被限制在最小的需求集，以便产生一个可工作的交付成果。MVP通常与敏捷软件开发（见本章后面的*软件开发生命周期模式*部分）结合使用，通过限制需求到一个可管理的数量，以便设计、开发、测试和交付。这种方法非常适合小型网站或应用程序开发，其中功能集可以在单个开发周期中从生产中逐步推进。
- en: In [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml), *Implementing Design
    Patterns - Basics Part 1*, MVP will be illustrated in a fictitious scenario where
    the technique will be used to limit the scope of changes as well as to help the
    team focus during the design and requirement gathering phases.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml)，*实现设计模式 - 基础部分1*中，将通过一个虚构场景来展示MVP，其中将使用该技术来限制变更范围，并在设计和需求收集阶段帮助团队集中精力。
- en: SOLID
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID
- en: SOLID is one of the most influential design principles and we will cover it
    in more detail in [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml), *Implementing
    Design Patterns - Basics Part 1*. Actually made up of five design principles,
    the intention of SOLID is to encourage designs that are more maintainable and
    easier to understand. These principles encourage code bases that are easier to
    modify and they reduce the risk of issues being introduced.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID是最有影响力的设计原则之一，我们将在[第3章](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml)，*实现设计模式
    - 基础部分1*中更详细地介绍它。SOLID实际上由五个设计原则组成，其目的是鼓励更易于维护和理解的代码设计。这些原则鼓励代码库更容易修改，并减少引入问题的风险。
- en: In [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml), *Implementing Design
    Patterns - Basics Part 1,* SOLID will be covered in more detail by being applied
    to a C# application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml)，*实现设计模式 - 基础部分1*中，将更详细地介绍SOLID原则，通过将其应用于C#应用程序来展示。
- en: Single responsibility principle
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: 'A class should have only one responsibility. The goal of this principle is
    to simplify our classes and logically structure them. Classes with multiple responsibilities
    are harder to understand and modify, as they are more complex. Responsibility
    in this circumstance is simply a reason for the change. Another way of looking
    at responsibility is to define it as a single part of the functionality:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类应该只有一个职责。这个原则的目标是简化我们的类并逻辑地组织它们。具有多个职责的类更难以理解和修改，因为它们更复杂。在这个情况下，职责简单地说就是改变的理由。另一种看待职责的方式是将其定义为功能的一个单独部分：
- en: '"A class should have one, and only one, reason to change."'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: “一个类应该只有一个，且仅有一个，改变的理由。”
- en: '*- Robert C. Martin*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*- 罗伯特·C·马丁*'
- en: Open/closed principle
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开放/封闭原则
- en: The open/closed principle is best described in terms of OOP. A class should
    be designed with inheritance as a means of extending its functionality. Change,
    in other words, is planned for and considered while the class is being designed.
    By defining and using an interface that the class implements, the open/closed
    principle is applied. The class is *open* for modification, while its description,
    the interface, is *closed* for modification.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 开放/封闭原则最好用面向对象编程（OOP）来描述。一个类应该通过继承作为扩展其功能的方式来进行设计。换句话说，改变是在类设计时就已经计划和考虑的。通过定义和使用类实现的接口，应用了开放/封闭原则。类对于修改是*开放*的，而其描述，即接口，对于修改是*封闭*的。
- en: Liskov substitution principle
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 李斯克夫替换原则
- en: Being able to substitute objects at runtime is the basis of the Liskov substitution
    principle. In OOP, if a class inherits from a base class or implements an interface,
    then it can be referenced as an object of the base class or interface. This is
    easier to describe with a simple example.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在运行时替换对象是李斯克夫替换原则的基础。在面向对象编程中，如果一个类从基类继承或实现了一个接口，那么它可以被引用为基类或接口的对象。这可以通过一个简单的例子来更容易地描述。
- en: 'We''ll define an interface for an animal and implement two animals, `Cat` and
    `Dog`, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个动物的接口，并实现两个动物，`Cat`（猫）和`Dog`（狗），如下所示：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then we can refer to the `Cat` and `Dog` as an animal as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将`Cat`（猫）和`Dog`（狗）作为动物来引用，如下所示：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Interface segregation principle
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: Similar to the single responsibility principle, the interface segregation principle
    states that an interface should be limited to containing only methods that are
    relevant to a single responsibility. By reducing the complexity of the interface,
    the code becomes easier to refactor and understand. An important benefit of adhering
    to this principle in a system is that it aids in decoupling a system by reducing
    the number of dependencies.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与单一职责原则类似，接口隔离原则指出一个接口应该仅包含与单一职责相关的方法。通过减少接口的复杂性，代码变得更容易重构和理解。遵循这个原则的系统的一个重要好处是，它通过减少依赖项的数量来帮助解耦系统。
- en: Dependency inversion principle
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: The **dependency inversion principle** (**DIP**), also referred to as the dependency
    injection principle, states that modules should not depend on details but on abstractions
    instead. This principle encourages writing loosely coupled code to enhance readability
    and maintenance, especially in a large complex code base.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖倒置原则**（**DIP**），也称为依赖注入原则，指出模块应该依赖于抽象而不是细节。这个原则鼓励编写松散耦合的代码，以增强可读性和维护性，尤其是在大型复杂的代码库中。'
- en: Software patterns
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件模式
- en: Over the years, many patterns have been compiled into catalogs. This section
    will use two catalogs as an illustration. The first catalog is a collection of
    OOP-related patterns by the **GoF**. The second relates to the integration of
    systems and remains technologically agnostic. At the end of the chapter, there
    are some references for additional catalogs and resources.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，许多模式被汇编成目录。本节将使用两个目录作为说明。第一个目录是**GoF**（ Gang of Four，四人帮）收集的与面向对象编程相关的模式。第二个与系统和技术的集成相关，保持技术中立。本章末尾有一些关于其他目录和资源的参考文献。
- en: GoF patterns
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GoF 模式
- en: 'Potentially, the most influential and well-known OOP collection of patterns
    comes from the *Design Patterns: Elements of Reusable Object-Oriented Software*
    book by *GoF.* The aim of the patterns in the book is on a lower level—that is,
    object creation and interaction—instead of a larger software architecture concern.
    The collection consists of templates that can be applied to particular scenarios
    with the goal of producing solid building blocks while avoiding common pitfalls
    in object-oriented development.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最有影响力和最著名的面向对象模式集合来自**GoF**（Gang of Four，四人帮）的《设计模式：可复用面向对象软件元素》一书。书中模式的目标是在较低层次上——即对象创建和交互——而不是更大的软件架构关注点。这个集合由可以应用于特定场景的模板组成，目标是产生坚实的构建块，同时避免面向对象开发中的常见陷阱。
- en: '*Erich Gamma, John Vlissides, Richard Helm*, and *Ralph Johnson* are referred
    to as the GoF because of their widely influential publications in the 1990s. The
    book *Design Patterns: Elements of Reusable Object-Oriented Software* has been
    translated into several languages and contains examples in both C++ and Smalltalk.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*Erich Gamma, John Vlissides, Richard Helm* 和 *Ralph Johnson* 被称为GoF，因为他们90年代广泛影响的出版物。这本书
    *设计模式：可复用面向对象软件元素* 已被翻译成多种语言，并包含C++和Smalltalk的示例。'
- en: 'The collection is broken into three categories: creational patterns, structural
    patterns, and behavioral patterns which will be explained in the following sections.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 该集合分为三个类别：创建型模式、结构型模式和行为型模式，将在以下章节中解释。
- en: Creational patterns
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建型模式
- en: 'The following five patterns are concerned with the instantiation of objects:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下五个模式与对象的实例化有关：
- en: '**Abstract Factory**: A pattern for the creation of objects belonging to a
    family of classes. The specific object is determined at runtime.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象工厂模式**：一种用于创建属于一组类对象的模式。具体的对象在运行时确定。'
- en: '**Builder**: A useful pattern for more complex objects where the construction
    of the object is controlled externally to the constructed class.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**建造者模式**：一种对于更复杂对象有用的模式，其中对象的构建由构建类外部控制。'
- en: '**Factory Method**: A pattern for creating objects derived from a class where
    the specific class is determined at runtime.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工厂方法模式**：一种在运行时确定具体类的情况下创建派生对象的模式。'
- en: '**Prototype**: A pattern for copying or cloning an object.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原型模式**：一种用于复制或克隆对象的模式。'
- en: '**Singleton**: A pattern for enforcing only one instance of a class.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例模式**：一种确保只有一个类实例的模式。'
- en: In [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml), *Implementing Design
    Patterns - Basics Part 1*, the Abstract Factory pattern will be explored in more
    detail. In [Chapter 4](4f644693-85a7-4543-af8c-109d8519b2e5.xhtml), *Implementing
    Design Patterns - Basics Part 2*, the Singleton and Factory Method patterns will
    be explored in detail, including using the .NET Core framework support for these
    patterns.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第3章](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml)，*实现设计模式 - 基础部分1*，将更详细地探讨抽象工厂模式。在
    [第4章](4f644693-85a7-4543-af8c-109d8519b2e5.xhtml)，*实现设计模式 - 基础部分2*，将详细探讨单例和工厂方法模式，包括使用.NET
    Core框架对这些模式的支持。
- en: Structural patterns
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构型模式
- en: 'The following patterns are concerned with defining relationships between classes
    and objects:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下模式与定义类和对象之间的关系有关：
- en: '**Adapter**: A pattern for providing a match between two different classes'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适配器模式**：一种提供两个不同类之间匹配的模式'
- en: '**Bridge**: A pattern for allowing the implementation details of a class to
    be replaced without requiring the class to be modified'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**桥接模式**：一种允许在不修改类的情况下替换类的实现细节的模式'
- en: '**Composite**: Used to create a hierarchy of classes in a tree structure'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合模式**：用于在树结构中创建类层次'
- en: '**Decorator**: A pattern for replacing the functionality of a class at runtime'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**装饰器模式**：一种在运行时替换类功能模式的模式'
- en: '**Facade**: A pattern used to simplify complex systems'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外观模式**：一种用于简化复杂系统的模式'
- en: '**Flyweight**: A pattern used to reduce the resource usage for complex models'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**享元模式**：一种用于减少复杂模型资源使用的模式'
- en: '**Proxy**: A pattern used to represent another object allowing for an additional
    level of control between the calling and called objects'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理模式**：一种用于表示另一个对象，允许在调用对象和被调用对象之间增加一个控制层的模式'
- en: Decorator patterns
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器模式
- en: 'To illustrate a structural pattern, let''s take a closer look at the Decorator
    pattern by using an example. This example will print messages on a console application.
    First, a base message is defined with a corresponding interface:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明一个结构型模式，让我们通过一个示例来更详细地看看装饰器模式。这个示例将在控制台应用程序上打印消息。首先，定义一个基消息及其相应的接口：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The base class allows for the storage of a text string and requires that child
    classes implement the `PrintMessage()` method. This will then be extended into
    two new classes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 基类允许存储一个文本字符串，并要求子类实现 `PrintMessage()` 方法。这将扩展到两个新的类。
- en: 'The first class is a `SimpleMessage` that writes the given text to the console:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个类是一个 `SimpleMessage`，它将给定的文本写入控制台：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The second class is an `AlertMessage` that also writes the given text to the
    console but performs a beep as well:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个类是一个 `AlertMessage`，它也将给定的文本写入控制台，但还会执行一个蜂鸣声：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The difference between the two is that the `AlertMessage` class will issue a
    beep instead of only printing the text to the screen like the `SimpleMessage`
    class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 两者之间的区别在于，`AlertMessage` 类将发出蜂鸣声而不是像 `SimpleMessage` 类一样仅将文本打印到屏幕上。
- en: 'Next, a base decorator class is defined that will contain a reference to a
    `Message` object as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义了一个基装饰者类，它将包含对 `Message` 对象的引用，如下所示：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The following two classes illustrate the Decorator pattern by providing additional
    functionality for our existing implementation of `Message`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个类通过为我们现有的 `Message` 实现提供额外的功能来展示装饰者模式。
- en: 'The first is a `NormalDecorator` that prints the message whose foreground is
    green:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是打印前景为绿色的消息的 `NormalDecorator`：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`ErrorDecorator` uses a red foreground color to make the message more pronounced
    when printed to the console:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`ErrorDecorator` 使用红色前景色使消息在打印到控制台时更加突出：'
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`NormalDecorator` will print the text in green while the `ErrorDecorator` will
    print the text in red. The important thing with this example is that the decorator
    is extending the behavior of the referenced `Message` object.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`NormalDecorator` 将以绿色打印文本，而 `ErrorDecorator` 将以红色打印文本。这个例子中的重要之处在于装饰者正在扩展引用的
    `Message` 对象的行为。'
- en: 'To complete the example, the following shows how new messages can be used:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成示例，以下展示了如何使用新消息：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Running the example will illustrate how the different Decorator patterns can
    be used to change the referenced functionality as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例将说明不同的装饰者模式如何被用来改变引用的功能，如下所示：
- en: '![](img/38b95d57-b790-4f1f-bb20-6984784a8d82.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38b95d57-b790-4f1f-bb20-6984784a8d82.png)'
- en: This is a simplified example but imagine a scenario where a new requirement
    is added to the project. Instead of using the beep sound, the system sound for
    exclamation should be played.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简化的例子，但想象一下，如果项目中添加了新的需求，而不是使用蜂鸣声，系统应该播放感叹号的声音。
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we have a structure in place to handle this, the amendment is a one-line
    change as shown in the previous code block.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有一个处理这种结构的机制，所以修改就像之前代码块中显示的那样，只是一行更改。
- en: Behavioral patterns
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为模式
- en: 'The following behavioral patterns can be used to define the communication between
    classes and objects:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行为模式可以用来定义类和对象之间的通信：
- en: '**Chain** **of** **Responsibility**: A pattern for handling a request between
    a collection of objects'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**责任链**：一种在对象集合之间处理请求的模式'
- en: '**Command**: A pattern used to represent a request'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令**：一种用于表示请求的模式'
- en: '**Interpreter**: A pattern for defining syntax or language for instructions
    in a program'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解释器**：一种为程序中的指令定义语法或语言的模式'
- en: '**Iterator**: A pattern for traversing a collection of items without detailed
    knowledge of the elements in a collection'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代器**：一种在不知道集合中元素详细情况的情况下遍历项目集合的模式'
- en: '**Mediator**: A pattern for simplifying communication between classes'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中介者**：一种简化类之间通信的模式'
- en: '**Memento**: A pattern for capturing and storing the state of an object'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**备忘录**：一种捕获和存储对象状态的模式'
- en: '**Observer**: A pattern for allowing objects to be notified of changes to another
    object''s state'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察者**：一种允许对象被通知另一个对象状态变化的模式'
- en: '**State**: A pattern for altering an object''s behavior when its state changes'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：一种在对象状态改变时改变对象行为的模式'
- en: '**Strategy**: A pattern for implementing a collection of algorithms where a
    specific algorithm can be applied at runtime'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略**：一种实现算法集合的模式，其中可以在运行时应用特定的算法'
- en: '**Template** **Method**: A pattern for defining the steps of an algorithm while
    leaving the implementation details in a subclass'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板方法**：一种定义算法步骤的模式，同时将实现细节留给子类'
- en: '**Visitor**: A pattern promoting loose coupling between data and functionality,
    allowing for additional operations to be added without requiring changes to the
    data classes'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问者**：一种促进数据与功能之间松散耦合的模式，允许在不修改数据类的情况下添加额外的操作'
- en: Chain of responsibility
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 责任链
- en: A useful pattern you need to be familiar with is the Chain of Responsibility
    pattern so we will use it as an example. With this pattern, we will set up a collection
    or chain of classes for handling a request. The idea is the request will pass
    through each class until it is handled. This illustration uses a car service center,
    where each car will pass through the different sections of the center until the
    service is complete.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要熟悉的一个有用模式是责任链模式，因此我们将使用它作为示例。使用此模式，我们将设置一个用于处理请求的类集合或链。想法是请求将穿过每个类，直到被处理。此说明使用了一个汽车服务中心，其中每辆车将穿过中心的各个部分，直到服务完成。
- en: 'Let''s start by defining a collection of flags that will be used to indicate
    the services required:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义一组标志，这些标志将用于指示所需的服务：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `FlagsAttribute` in C# is a great way of using a bit field to hold a collection
    of flags. The single field will be used to indicate the enum values that are *turned
    on* by using bitwise operations.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的`FlagsAttribute`是一种使用位字段来持有标志集合的绝佳方式。单个字段将用于通过位运算指示已**开启**的枚举值。
- en: 'The `Car` will contain a field to capture what servicing is required and a
    field that returns true when the service has been completed:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Car`将包含一个字段来捕获所需的服务，以及一个字段，当服务完成时返回true：'
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: One thing to point out is that a `Car` is considered to have its service completed
    once all the requirements have been completed, as represented by the `IsServiceComplete`
    property.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 需要指出的一点是，一旦所有要求都已完成，`Car`被认为其服务已完成，这由`IsServiceComplete`属性表示。
- en: 'An abstract base class will be used to represent each of our service technicians
    in the following manner:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将用于表示我们每个服务技术员的抽象基类如下所示：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Take note that the service provided by the class that extends the `ServiceHandler`
    class, in other words the technician, is required to be passed in.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，提供服务的`ServiceHandler`类扩展的类，换句话说，是技师，需要被传递进来。
- en: 'The service will then be performed by using the bitwise `NOT` operation (`~`)
    to *turn off* the bit on the given `Car`, indicating the service is required in
    the `Service` method:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将通过使用位运算符`NOT` (`~`) 来**关闭**给定`Car`上的位，在`Service`方法中指示需要服务：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If all services have been completed on the car and/or there are no more services,
    the chain is stopped. If there is another service and a car is not ready, then
    the next service handler is called.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果汽车上的所有服务都已完成，或者没有更多的服务，则停止链。如果有其他服务且汽车未准备好，则调用下一个服务处理程序。
- en: 'This approach requires the chain to be set and the preceding example shows
    this being done using the `SetNextServiceHandler()` method to set the next service
    to be performed:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法需要设置链，前面的示例展示了这是如何通过使用`SetNextServiceHandler()`方法来设置下一个要执行的服务来完成的：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The service specialists include a `Detailer`, `Mechanic`, `WheelSpecialist`,
    and a `QualityControl` engineer. The `ServiceHandler` representing a `Detailer`
    is shown in the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 服务专家包括`Detailer`、`Mechanic`、`WheelSpecialist`和`QualityControl`工程师。代表`Detailer`的`ServiceHandler`在以下代码中展示：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The mechanic, whose specialty is tuning the engine, is shown in the following
    code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 机械师，其专业是调整引擎，在以下代码中展示：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The wheel specialist is shown in the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 车轮专家在以下代码中展示：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And last is quality control, who will take the car for a test drive:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是质量控制，他将进行试驾：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The service center technicians have been defined, so the next step is to service
    a couple of cars. This will be illustrated in the `Main` code block, starting
    with constructing the required objects:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 服务中心的技师已经定义，所以下一步是为几辆汽车提供服务。这将在`Main`代码块中展示，从构建所需的对象开始：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The next step will be to set up the handling order for the different services:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是设置不同服务的处理顺序：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then two calls will be made to the mechanic, which is the start of the chain
    of responsibility:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将调用两次机械师，这是责任链的开始：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: An important thing to note is the order in which the chain is set. For this
    service center, the mechanic first performs tuning, followed by the wheels being
    aligned. Then, a test drive is performed and after that, the car is worked up
    in detail. Originally, the test drive used to be performed as the last step, but
    the service center determined that, on rainy days, this required the car details
    to be repeated. A bit of a silly example, but it illustrates the benefit of having
    the chain of responsibility defined in a flexible manner.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个重要事项是链的设置顺序。对于这个服务中心，机械师首先进行调校，然后进行车轮定位。接着进行试驾，之后对汽车进行详细的工作。最初，试驾是作为最后一步进行的，但服务中心确定，在雨天，这需要重复汽车细节。这是一个有点愚蠢的例子，但它说明了以灵活的方式定义责任链的好处。
- en: '![](img/50fb4e09-4160-462b-91f8-2a84ddde769c.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50fb4e09-4160-462b-91f8-2a84ddde769c.png)'
- en: The preceding screenshot shows the display after our two cars have been serviced.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示了我们的两辆车完成维修后的显示。
- en: Observer pattern
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式
- en: 'An interesting pattern to explore in more detail is the **Observer pattern**.
    This pattern allows for instances to be informed of when a particular event happens
    in another instance. In this way, there are many observers and a single subject.
    The following diagram illustrates this pattern:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值得详细探索的有趣模式是 **观察者模式**。这个模式允许实例在另一个实例中发生特定事件时得到通知。这样，就有许多观察者和一个主题。以下图示说明了这个模式：
- en: '![](img/c945ea79-025c-437f-a14b-f61c6af08216.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c945ea79-025c-437f-a14b-f61c6af08216.png)'
- en: Let's provide an example by creating a simple C# console application that will
    create a single instance of a `Subject` class and multiple `Observer` instances.
    When a quantity value changes in the `Subject` class, we want each `Observer`
    instance to be notified.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个简单的 C# 控制台应用程序来提供一个示例，该应用程序将创建一个 `Subject` 类的单个实例和多个 `Observer` 实例。当
    `Subject` 类中的数量值发生变化时，我们希望通知每个 `Observer` 实例。
- en: 'The `Subject` class contains a private quantity field that is updated by a
    public `UpdateQuantity` method:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subject` 类包含一个私有数量字段，该字段通过公共的 `UpdateQuantity` 方法进行更新：'
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In order to alert any observers, we use the C# keywords, `delegate` and `event`.
    The `delegate` keyword defines the format or handler that will be called. The
    delegate to be used when the quantity is updated is shown in the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通知任何观察者，我们使用 C# 的 `delegate` 和 `event` 关键字。`delegate` 关键字定义了将被调用的格式或处理程序。当数量更新时将使用的代理如下所示：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The delegate defines `QuantityUpdated` to be a method that receives an integer
    and does not return any value. An event is then added to the `Subject` class as
    follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 代理定义 `QuantityUpdated` 为接收一个整数且不返回任何值的方法。然后，在 `Subject` 类中添加如下所示的事件：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And, in the `UpdateQuantity` method, it is called as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `UpdateQuantity` 方法中，它被调用如下：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this example, we will define a method in the `Observer` class that has the
    same signature as the `QuantityUpdated` delegate:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将在 `Observer` 类中定义一个方法，该方法与 `QuantityUpdated` 代理具有相同的签名：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This implementation will be alerted when the quantity of the `Subject` instance
    changes and will print a message to the console in a specific color.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Subject` 实例的数量发生变化时，此实现将收到警报，并将消息以特定颜色打印到控制台。
- en: 'Let''s put these together in a simple application. At the start of the application,
    a single `Subject` and three `Observer` objects will be created:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个简单的应用程序中将这些放在一起。在应用程序开始时，将创建一个 `Subject` 对象和三个 `Observer` 对象：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, each `Observer` instance will register to be alerted by the `Subject`
    when the quantity changes:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每个 `Observer` 实例将注册以在数量变化时由 `Subject` 通知：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we will update the quantity twice, as shown here:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将数量更新两次，如下所示：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When the application is run, we get three messages printed in different colors
    for each update statement, as shown in the following screenshot:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序运行时，我们会看到每个更新语句都打印出不同颜色的三条消息，如下面的截图所示：
- en: '![](img/6bd7a38b-7646-41ff-b808-139593727342.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6bd7a38b-7646-41ff-b808-139593727342.png)'
- en: This was a simple sample using the C# `event` keyword, but, hopefully, it illustrates
    how this pattern could be used. The advantage here is it loosely couples the subject
    from the observers. The subject does not have to have knowledge of the different
    observers, or even knowledge of whether any exist.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的示例，使用了 C# 的 `event` 关键字，但希望它能说明这种模式如何被使用。这里的优点是它松散地将主题与观察者耦合起来。主题不需要了解不同的观察者，甚至不需要知道是否存在任何观察者。
- en: Enterprise integration patterns
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业集成模式
- en: '**Integration** is a discipline of software development that benefits greatly
    from leveraging the knowledge and experience of others. With this in mind, many
    catalogs of EIPs exist, some of which are technology agnostic while others are
    tailored to a particular technology stack. This section will highlight some popular
    integration patterns.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成**是软件开发的一个学科，它极大地受益于利用他人的知识和经验。考虑到这一点，存在许多EIPs目录，其中一些是技术无关的，而另一些则是针对特定技术栈定制的。本节将突出一些流行的集成模式。'
- en: '*Enterprise Integration Patterns*, by *Gregor Hohpe* and *Bobby Woolf*, provides
    a solid resource for many integration patterns across a variety of technologies.
    This book is often referenced when discussing EIPs. The book is available at [https://www.enterpriseintegrationpatterns.com/](https://www.enterpriseintegrationpatterns.com/).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 《*企业集成模式*》，作者*Gregor Hohpe*和*Bobby Woolf*，为各种技术下的许多集成模式提供了一个坚实的资源。这本书在讨论EIPs时经常被引用。本书可在[https://www.enterpriseintegrationpatterns.com/](https://www.enterpriseintegrationpatterns.com/)找到。
- en: Topology
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拓扑
- en: 'An important consideration for enterprise integration is the topology of the
    systems being connected. In general, there are two distinct topologies: hub-and-spoke
    and enterprise service bus.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 企业集成的一个重要考虑因素是连接系统的拓扑结构。一般来说，有两种不同的拓扑结构：中心辐射和企业服务总线。
- en: 'A **hub-and-spoke** (hub) topology describes an integration pattern where a
    single component, the hub, is centralized and it communicates with each application
    explicitly. This centralizes the communication so that the hub only needs to know
    about the other applications, as illustrated in the following diagram:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**中心辐射**（中心）拓扑描述了一种集成模式，其中单个组件，即中心，是集中的，并且它明确地与每个应用程序进行通信。这样集中了通信，使得中心只需要了解其他应用程序，如下面的图表所示：'
- en: '![](img/04877dd8-6fef-492a-9f17-cdde6bd30f1c.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/04877dd8-6fef-492a-9f17-cdde6bd30f1c.png)'
- en: The diagram shows the hub, in blue, as having explicit knowledge of how to communicate
    with the different applications. This means that, when a message is to be sent
    from A to B, it is sent from A to the hub and then forwarded on to B. The advantage
    of this approach for an enterprise is that connectivity to B has to be defined
    and maintained only in one place, the hub. The significance here is that the security
    is controlled and maintained in one central location.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图表显示，中心（蓝色）明确知道如何与不同的应用程序进行通信。这意味着，当要从A发送消息到B时，消息是从A发送到中心，然后转发到B。这种方法的优点是，对于企业来说，只需要在中心一个地方定义和维护到B的连接。这里的重点是安全在中央位置得到控制和维护。
- en: 'An **enterprise service bus** (**ESB**) relies on a messaging model comprising
    of publishers and subscribers (Pub-Sub). A publisher submits messages to the bus
    and a subscriber registers to receive published messages. The following diagram
    illustrates this topology:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**企业服务总线**（ESB）依赖于由发布者和订阅者（Pub-Sub）组成的消息模型。发布者向总线提交消息，订阅者注册接收发布的消息。以下图表说明了这种拓扑：'
- en: '![](img/5707b39e-5129-49e1-aa5c-cac62cc3f58f.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5707b39e-5129-49e1-aa5c-cac62cc3f58f.png)'
- en: In the preceding diagram, if a message is to be routed from **A** to **B**,
    **B** subscribes to the ESB for messages published from **A**. When **A** publishes
    a new message, the message is sent to **B**. In practice, the subscription can
    be more complex. For example, in an ordering system, there might be two subscribers
    for priority orders and normal orders. In this situation, priority orders might
    then be handled differently from normal orders.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，如果要将消息从**A**路由到**B**，**B**将订阅ESB以接收从**A**发布的消息。当**A**发布一条新消息时，该消息被发送到**B**。在实践中，订阅可能更复杂。例如，在一个订单系统中，可能会有两个订阅者分别用于优先订单和普通订单。在这种情况下，优先订单可能会与普通订单的处理方式不同。
- en: Patterns
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式
- en: 'If we define an integration between two systems as having distinct steps, we
    can then define patterns in each step. Let''s take a look at the following diagram
    to discuss an integration pipeline:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将两个系统之间的集成定义为具有不同的步骤，那么我们就可以在每个步骤中定义模式。让我们看一下以下图表来讨论集成管道：
- en: '![](img/b23a2329-2813-437d-8cfa-914e26954910.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b23a2329-2813-437d-8cfa-914e26954910.png)'
- en: 'This pipeline is simplified as there could be more or fewer steps in a pipeline
    depending on the technology used. The purpose of the diagram is to provide some
    context as we look at some common integration patterns. These can be broken into
    categories as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个管道被简化了，因为根据所使用的技术的不同，管道中可能会有更多或更少的步骤。图表的目的在于当我们查看一些常见的集成模式时提供一些上下文。这些可以按以下类别划分：
- en: '**Messaging**: Patterns related to the handling of messages'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息处理**：与消息处理相关的模式'
- en: '**Transformation**: Patterns related to altering message content'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换**：与更改消息内容相关的模式'
- en: '**Routing**: Patterns related to the exchange of messages'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由**：与消息交换相关的模式'
- en: Messaging
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息处理
- en: 'Patterns related to messaging can take the form of message construction and
    channels. A channel, in this context, is the endpoint and/or how the message enters
    and exits the integration pipeline. Some examples of construction-related patterns
    are the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与消息相关的模式可以采取消息构建和通道的形式。在这个上下文中，通道是端点以及/或者消息如何进入和退出集成管道。以下是一些与构建相关的模式示例：
- en: '**Message Sequence**: The message contains a sequence to indicate a particular
    processing order.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息序列**：消息包含一个序列，以指示特定的处理顺序。'
- en: '**Correlation Identifier**: The message contains a medium to identify related
    messages.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关联标识符**：消息包含一个中等程度的标识符，用于识别相关消息。'
- en: '**Return Address**: The message identifies information about returning a response
    message.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回地址**：消息标识有关返回响应消息的信息。'
- en: '**Expiration**: The message has a finite time that it is considered valid.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过期**：消息有一个有限的时间被认为是有效的。'
- en: 'In the *Topology* section, we covered some patterns related to channels but
    the following are additional patterns you should consider in integration:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在*拓扑*部分，我们讨论了一些与通道相关的模式，但以下是一些在集成中应考虑的附加模式：
- en: '**Competing Consumers**: Multiple processes could handle the same message.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**竞争消费者**：多个进程可以处理同一个消息。'
- en: '**Selective Consumer**: Consumers use criteria to determine the message to
    process.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择性消费者**：消费者使用标准来确定要处理的消息。'
- en: '**Dead Letter Channel**: Handles messages that are not successfully processed.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**死信通道**：处理未成功处理的消息。'
- en: '**Guaranteed Delivery**: Ensures reliable handling of messages, where no message
    is lost.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保证投递**：确保可靠地处理消息，确保没有消息丢失。'
- en: '**Event-driven Consumer:** The handling of messages is based on published events.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件驱动消费者**：消息的处理基于发布的事件。'
- en: '**Polling Consumer:** Handles messages that are retrieved from a source system.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轮询消费者**：处理从源系统检索的消息。'
- en: Transformation
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换
- en: 'When integrating complex enterprise systems, transformation patterns allow
    for flexibility in how messages are handled in the system. With transformation,
    a message between two applications can be altered and/or enhanced. Here are some
    transformation-related patterns:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当集成复杂的业务系统时，转换模式允许在系统中灵活处理消息。通过转换，两个应用之间的消息可以被更改和/或增强。以下是一些与转换相关的模式：
- en: '**Content Enricher**: A message is *enriched* by adding information.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容丰富器**：通过添加信息来丰富消息。'
- en: '**Canonical Data Model**: A message is transformed into an application-neutral
    message format.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规范数据模型**：将消息转换为一个应用中立的格式。'
- en: '**Message Translator**: A pattern for translating one message to another.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息转换器**：将一个消息转换为另一个消息的模式。'
- en: 'The **Canonical Data Model** (**CDM**) is a good pattern to highlight. With
    this pattern, a message can be exchanged between multiple applications without
    having to perform a translation for each specific message type. This is best shown
    by an example of multiple systems exchanging messages, as illustrated in the following
    diagram:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**规范数据模型**（**CDM**）是一个值得强调的模式。使用此模式，多个应用之间可以交换消息，而无需为每种特定的消息类型执行转换。以下是一个示例，展示了多个系统交换消息，如图所示：'
- en: '![](img/00eb3fd5-9c81-45d5-8c3a-8c9703de4bed.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00eb3fd5-9c81-45d5-8c3a-8c9703de4bed.png)'
- en: In the diagram, applications **A** and **C** want to send their messages in
    their format to application **B** and **D**. If we used the Message Translator
    pattern, only the process, which is handling the transformation, would need to
    know how to translate from **A** to **B** and from **A** to **D** as well as **C**
    to **B** and **C** to **D**. This becomes increasingly difficult as the number
    of applications increases and when the publisher might not know the details of
    its consumers. With the CDM, source application messages for **A** and **B** are
    translated into a neutral schema X.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，应用**A**和**C**希望以它们的格式向应用**B**和**D**发送消息。如果我们使用消息转换器模式，只有处理转换的过程需要知道如何从**A**转换到**B**以及从**A**转换到**D**，以及从**C**转换到**B**和从**C**转换到**D**。随着应用数量的增加，以及发布者可能不知道其消费者的详细信息时，这变得越来越困难。使用CDM，**A**和**B**的源应用消息被转换为一个中立的模式X。
- en: Canonical schema
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 规范模式
- en: A canonical schema is sometimes referred to as a neutral schema, meaning it
    is not aligned directly with a source or destination system. The schema is then
    thought of as being impartial.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 经典模式有时被称为中立模式，这意味着它没有直接与源或目标系统对齐。该模式被认为是中立的。
- en: 'The message in the neutral schema format is then translated to the message
    formats for **B** and **D** as shown in the following diagram:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将中立模式格式的消息转换为**B**和**D**的消息格式，如下图所示：
- en: '![](img/16e7e2ad-8684-4ee0-beaf-add4d3bcb4d3.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16e7e2ad-8684-4ee0-beaf-add4d3bcb4d3.png)'
- en: 'In the enterprise, this becomes unmanageable without some standards, and fortunately,
    many organizations have been created to produce as well as govern standards in
    many industries, including the following examples (but there are many more!):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业中，如果没有一些标准，这将成为难以管理的情况，幸运的是，已经创建了众多组织来生产并管理许多行业的标准，以下是一些例子（但还有更多！）：
- en: '**Electronic Data Interchange For Administration, Commerce and Transport**
    (**EDIFACT**): An international standard for trade'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电子数据交换行政管理、商业和运输** (**EDIFACT**)：贸易的国际标准'
- en: '**IMS Question and Test Interoperability specification** (**QTI**)**:** Standards
    for the representation of assessment content and results produced by the **Information
    Management System** **(****IMS**) **Global Learning Consortium** (**GLC**)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IMS 问题和测试互操作性规范** (**QTI**)：**信息管理系统** **(IMS**) **全球学习联盟** (**GLC**) 产生的评估内容和结果的表示标准'
- en: '**Hospitality Industry Technology Integration Standards (HITIS)**: Standards
    for property management systems maintained by the American Hotel and Motel Association'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**酒店业技术集成标准 (HITIS)**: 由美国酒店和汽车旅馆协会维护的物业管理系统标准'
- en: '**X12 EDI (X12)**: Collection of schemas for health care, insurance, government,
    finance, transportation, and other industries maintained by the Accredited Standards
    Committee X12'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**X12 EDI (X12)**：由认证标准委员会 X12 维护的医疗保健、保险、政府、金融、运输和其他行业的模式集合'
- en: '**Business Process Framework** (**eTOM**): Telecommunications operating model
    maintained by the TM Forum'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务流程框架** (**eTOM**)：由 TM Forum 维护的电信运营模型'
- en: Routing
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: 'Routing patterns provide different approaches to handling messages. Here are
    some examples of patterns that fall into this category:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 路由模式提供了处理消息的不同方法。以下是一些属于这一类别的模式示例：
- en: '**Content-based Routing**: The route or destination application(s) is determined
    by the content in the message.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于内容的路由**: 路由或目标应用程序由消息中的内容决定。'
- en: '**Message Filtering**: Only messages of interest are forwarded on to the destination
    application(s).'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息过滤**: 只有感兴趣的邮件才会转发到目标应用程序。'
- en: '**Splitter**: Multiple messages are generated from a single message.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分割器**: 从单个消息生成多个消息。'
- en: '**Aggregator**: A single message is generated from multiple messages.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合器**: 从多个消息生成单个消息。'
- en: '**Scatter-Gather**: A pattern for handling a broadcast of multiple messages
    and aggregating the responses into a single message.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分散-收集**: 处理多个消息广播并将响应聚合为单个消息的模式。'
- en: The Scatter-Gather pattern is a very useful pattern and, as it combines both
    the Splitter and Aggregator patterns, it is a great example to explore. With this
    pattern, a more complex business process can be modeled.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 分散-收集模式是一个非常实用的模式，因为它结合了分割模式和聚合模式，是一个很好的探索例子。使用这个模式，可以模拟更复杂的业务流程。
- en: In our scenario, we will take the fulfillment of an ordering system of widgets.
    The good news is, several vendors, sell widgets, but the price of widgets fluctuates
    often. So, which vendor has the best price changes? Using the Scatter-Gather pattern,
    the ordering system can query multiple vendors, select the best price, and then
    return the result back to the calling system.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，我们将考虑小工具订购系统的履行。好消息是，有几个供应商销售小工具，但小工具的价格经常波动。那么，哪个供应商的价格最好？使用分散-收集模式，订购系统可以查询多个供应商，选择最佳价格，然后将结果返回给调用系统。
- en: 'The Splitter pattern will be used to generate multiple messages to the vendors
    as shown in the following diagram:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 下图将展示如何使用分割模式向供应商生成多个消息：
- en: '![](img/fb4565e5-a899-41d0-8c81-1d050bf2f76f.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb4565e5-a899-41d0-8c81-1d050bf2f76f.png)'
- en: 'The routing then waits until the vendor responses are received. Once the responses
    have been received, the Aggregator pattern is used to compile the results into
    a single message to the calling application:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 路由等待直到收到供应商的响应。一旦收到响应，就使用聚合器模式将结果编译成单个消息发送给调用应用程序：
- en: '![](img/451c57f7-ef45-48ee-ae38-abd3ee2493e2.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/451c57f7-ef45-48ee-ae38-abd3ee2493e2.png)'
- en: It is worth noting that there are many variations and circumstances for this
    pattern. The Scatter-Gather pattern might require all vendors to respond or just
    some of them. Another scenario might require a limit on the amount of time the
    process should wait for a response from a vendor. Some messages might take milliseconds
    for a response while other scenarios might take days for a response to be returned.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这种模式有很多变体和情况。散点-聚合模式可能要求所有供应商都做出响应，也可能只是其中的一些。另一种情况可能要求对处理过程等待供应商响应的时间进行限制。有些消息可能只需毫秒级响应，而其他情况下可能需要几天才能返回响应。
- en: An integration engine is software that supports many integration patterns. The
    integration engine can range from locally installed services to cloud-based solutions.
    Some of the more popular engines are Microsoft BizTalk, Dell Boomi, MuleSoft Anypoint
    Platform, IBM WebSphere, and SAS Business Intelligence.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 集成引擎是一种支持多种集成模式的软件。集成引擎的范围可以从本地安装的服务到基于云的解决方案。其中一些更受欢迎的引擎包括微软BizTalk、戴尔Boomi、MuleSoft
    Anypoint平台、IBM WebSphere和SAS商业智能。
- en: Software development life cycle patterns
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件开发生命周期模式
- en: There are many approaches to managing software development and the two most
    common **software development life cycle** (**SDLC**) patterns are **Waterfall**
    and **Agile**. There are many variations of these two SDLC methodologies and often
    an organization will adapt a methodology to fit the project and team(s) as well
    as the company culture.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 管理软件开发有许多方法，其中最常见的是两种**软件开发生命周期**（**SDLC**）模式：**瀑布**和**敏捷**。这两种SDLC方法的变体很多，通常组织会根据项目、团队以及公司文化调整方法。
- en: The Waterfall and Agile SDLCs patterns are just two examples and there are several
    other patterns for software development that may suit a company's culture, software
    maturity, and industry better than others.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 水平瀑布和敏捷SDLC模式只是两个例子，还有许多其他软件开发模式可能比其他模式更适合公司的文化、软件成熟度和行业。
- en: Waterfall SDLC
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 水平瀑布SDLC
- en: 'The Waterfall approach comprises distinct phases that a project or piece of
    work goes through sequentially. Conceptually, it is simple to understand and it
    follows patterns used in other industries. The following is an example of the
    different phases:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 水平瀑布方法包括项目或工作按顺序经历的不同阶段。从概念上讲，它很容易理解，并且遵循其他行业使用的模式。以下是一个不同阶段的例子：
- en: '**Requirements phase**: All requirements to be implemented are gathered and
    documented.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**需求阶段**：所有要实施的需求都被收集和记录。'
- en: '**Design phase**: Using the documentation produced in the previous step, the
    design that which is to be implemented is completed.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计阶段**：使用上一步产生的文档，完成要实施的设计。'
- en: '**Development phase**: Using the design from the previous step, the changes
    are implemented.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发阶段**：使用上一步的设计，实施更改。'
- en: '**Testing phase**: The changes implemented in the previous step are verified
    against the specified requirements.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试阶段**：上一步实施的变化与指定的要求进行验证。'
- en: '**Deployment phase**: Once the testing has been completed, the changes performed
    by the project are deployed.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署阶段**：一旦完成测试，项目所做的更改就会被部署。'
- en: There are many strengths to the Waterfall model. The model is easy to understand
    and easy to manage, as each phase has a clear definition of what has to be done
    and what has to be delivered out of each phase. By having a series of phases,
    milestones can be defined, allowing for easier reporting on progress. Also, with
    distinct phases, the roles and responsibilities of the resources required can
    be more easily planned.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 水平瀑布模型有许多优点。该模型易于理解和管理，因为每个阶段都有一个明确的定义，说明每个阶段必须完成什么以及必须交付什么。通过一系列阶段，可以定义里程碑，从而更容易报告进度。此外，由于有明确的阶段，可以更容易地规划所需资源的角色和责任。
- en: But what if something does not go to plan or things change? The Waterfall SDLC
    does have some disadvantages, and many of the disadvantages stem from its lack
    of flexibility for change, or the instances when things are discovered, requiring
    input from a previous step. In Waterfall, if a situation occurs requiring information
    from a previous phase, the previous phase is repeated. This poses several problems.
    As phases might be reported, reporting becomes difficult because a project (that
    had passed a phase or milestone) is now repeating the phase. This could promote
    a *witch-hunt* company culture, where the effort is diverted to finding blame
    rather than measures to prevent recurring issues. Also, resources might no longer
    be available, as they have been moved onto other projects and/or have left the
    company.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果事情没有按计划进行或发生变化怎么办？瀑布SDLC确实有一些缺点，其中许多缺点源于其缺乏对变化的灵活性，或者在某些情况下，需要从先前步骤中获得输入。在瀑布模型中，如果出现需要从先前阶段获取信息的情况，则重复先前的阶段。这会带来几个问题。由于阶段可能会被报告，因此报告变得困难，因为已经通过一个阶段或里程碑的项目现在正在重复该阶段。这可能会促进一种*猎巫*的公司文化，其中努力被转向寻找责任而不是预防重复问题的措施。此外，资源可能不再可用，因为它们已经被转移到其他项目上，或者员工已经离职。
- en: 'The following diagram illustrates how the cost and time increase the further
    into the phases that an issue is discovered:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了问题发现得越晚，成本和时间增加的情况：
- en: '![](img/0fd85921-da03-4dc6-a7fa-96788393df98.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0fd85921-da03-4dc6-a7fa-96788393df98.png)'
- en: Because of the cost associated with change, the Waterfall SDLC tends to suit
    smaller projects with a lower risk of change. Larger and more complex projects
    increase the potential for change, as requirements might be altered or the business
    drivers change during the project.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于变化相关的成本，瀑布软件开发生命周期（SDLC）通常适合较小、变更风险较低的项目。较大和更复杂的项目增加了变更的可能性，因为需求可能会改变，或者业务驱动因素在项目期间发生变化。
- en: Agile SDLC
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敏捷SDLC
- en: The Agile SDLC approach to software development attempts to embrace change and
    uncertainty. This is achieved by using a pattern that allows for change and/or
    the occurrence of issues that are discovered during the life of a project or product
    development. The key concept is to break the project into smaller iterations of
    development, often referred to as development cycles. In each cycle, the basic
    Waterfall stages are repeated so each cycle has requirements, design, development,
    testing, and deployment phase.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷SDLC软件开发方法试图拥抱变化和不确定性。这是通过使用一种允许变化和/或项目或产品开发生命周期中发现的问题的模式来实现的。关键概念是将项目分解为更小的开发迭代，通常称为开发周期。在每个周期中，基本的瀑布阶段被重复，因此每个周期都有需求、设计、开发、测试和部署阶段。
- en: 'This is a simplification but the strategy of breaking the project into cycles
    has several advantages over Waterfall:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简化，但将项目分解为周期的方法与瀑布模型相比有几个优点：
- en: The impact of shifting business requirements is lessened as the scope is smaller.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于范围较小，业务需求变更的影响减小。
- en: The stakeholders get a visibly working system earlier than with Waterfall. Though
    not complete, this provides value as it allows for feedback to be incorporated
    earlier into a product.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与瀑布模型相比，利益相关者可以更早地获得一个可见的、可工作的系统。虽然还不完整，但这提供了价值，因为它允许在产品早期就纳入反馈。
- en: Resourcing might benefit as the type of resources has fewer fluctuations.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源可能受益，因为资源类型的变化幅度较小。
- en: '![](img/f843873a-17d4-4174-8ca2-3a977d04bf18.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f843873a-17d4-4174-8ca2-3a977d04bf18.png)'
- en: The preceding diagram provides a summary of the two approaches.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表提供了两种方法的总结。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have discussed major design patterns used in modern software
    development that were introduced in the previous chapter. We started with the
    discussion of various software development principles such as the DRY, KISS, YAGNI,
    MVP, and SOLID programming principles. Then, we covered software development patterns
    including GoF and EIPs. The methodology for SDLC was covered, including Waterfall
    and Agile. The purpose of this chapter was to illustrate how patterns are used
    across all levels of software development.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了在现代软件开发中使用的、在前一章中引入的主要设计模式。我们首先讨论了各种软件开发原则，如DRY、KISS、YAGNI、MVP和SOLID编程原则。然后，我们涵盖了软件开发模式，包括GoF和EIPs。本章还涵盖了SDLC的方法，包括瀑布和敏捷。本章的目的是说明模式在软件开发的所有级别是如何被使用的。
- en: As the software industry matures, patterns emerge as experience evolves, techniques
    grow, and technology advances. Some patterns have been developed to help different
    phases of the SDLC. For example in [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml),
    *Implementing Design Patterns - Basics Part 1*, **Test-driven development** (**TDD**)
    will be explored, where the definitions of tests are used to provide both measurable
    progress as well as clear requirements, during the development phase. As the chapters
    progress, we will discuss higher levels of abstraction in software development,
    including patterns for web development as well as modern architecture patterns
    for on-premise and cloud-based solutions.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 随着软件行业的成熟，随着经验的积累、技术的增长和技术的进步，模式逐渐出现。一些模式是为了帮助SDLC的不同阶段而开发的。例如，在[第3章](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml)，“实现设计模式
    - 基础部分1”，将探讨**测试驱动开发**（**TDD**），其中测试的定义被用来在开发阶段提供可衡量的进度以及明确的需求。随着章节的推进，我们将讨论软件开发中的更高层次抽象，包括Web开发模式以及本地和基于云的解决方案的现代架构模式。
- en: In the next chapter, we will start by building a fictitious application in .NET
    Core. Also, we will explain the various patterns discussed in this chapter, including
    programming principles such as SOLID, and illustrate several GoF patterns.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从构建一个虚构的.NET Core应用程序开始。同时，我们将解释本章讨论的各种模式，包括SOLID等编程原则，并展示几个GoF模式。
- en: Questions
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题将帮助您巩固本章包含的信息：
- en: In SOLID, what does the S stand for? What is meant by a responsibility?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在SOLID原则中，S代表什么？责任是什么意思？
- en: 'Which SDLC method is built around cycles: Waterfall or Agile?'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个SDLC方法是以周期为基础构建的：瀑布还是敏捷？
- en: Is the Decorator pattern a creational or structural pattern?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 装饰器模式是创建型模式还是结构型模式？
- en: What does Pub-Sub integration stand for?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pub-Sub集成代表什么？
