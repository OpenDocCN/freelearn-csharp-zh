<html><head></head><body>
        

                            
                    <h1 class="header-title">Dependency Injection in Other JavaScript Frameworks</h1>
                
            
            
                
<p>In <a href="58f9e2e8-6e57-473a-9ccf-89a9a90f1858.xhtml" target="_blank">Chapter 9</a>, <em>Anti-Patterns and Misconceptions on Dependency Injection</em>, we covered the most important anti-patterns when using Dependency Injection, together with some typical misconceptions when it comes to how to use it. In this chapter, we're going to deal with Dependency Injection in other framework, specifically in TypeScript 2.3 and Angular 4+.</p>
<p>The reason for reviewing the very basics of TypeScript is that Angular 2+ uses this language, so we need some understanding of how class creation and module management is undertaken to really grasp the main concepts behind this architecture.</p>
<p>In this chapter, we will cover:</p>
<ul>
<li>Class creation and module management in TypeScript 2.3+</li>
<li>Native implementation and usage of DI techniques in AngularJS (version 1.x)</li>
<li>Native implementation and customizable options to use DI in Angular 4+</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">TypeScript</h1>
                
            
            
                
<p>You probably already know the role that TypeScript plays in the development of modern JavaScript frameworks, and even by itself as an improved replacement for JavaScript.</p>
<p>TypeScript has many times been defined as a strongly typed superset of JavaScript. It is a superset because it includes everything JavaScript has (and that extends to versions 3, 5, and 6, also called ES2015), plus a number of features to allow programmers to code in an object-oriented paradigm. At the time of writing, the latest version available is 2.3:</p>
<div><img height="211" width="260" src="img/4c4122d3-ea45-48e1-b556-b0fd41235c5d.png"/></div>
<p>(Image courtesy: <a href="http://blog.soat.fr/2016/08/feedback-typescript/">http://blog.soat.fr/2016/08/feedback-typescript/</a>)</p>
<p>Consequently, we find many syntactical benefits while it still lets you write normal JavaScript if you want to (an important point is that any valid JavaScript is valid TypeScript).</p>
<p>In this way, TypeScript fosters a more declarative style of programming by using interfaces and static typing, it offers the concepts of modules and classes, and it's capable of integrating well with most existing JavaScript libraries and code. We can see it as a strongly static layer over JavaScript with a bunch of features to make the programmer's work (especially debugging) much more manageable.</p>
<p>If you want to get a nice introduction to the TypeScript language, you can read <em>Introducing Object-Oriented Programming with TypeScript</em>, by Remo H. Jansen, (see <a href="https://www.packtpub.com/books/content/introducing-object-oriented-programmng-typescript">https://www.packtpub.com/books/content/introducing-object-oriented-programmng-typescript</a>) and, if you prefer to delve deeply into the language and its possibilities, take a look at the excellent <em>Mastering TypeScript</em> by Nathan Rozentals, available at <a href="https://www.packtpub.com/web-development/mastering-typescript">https://www.packtpub.com/web-development/mastering-typescript</a>.</p>
<p>The main goals of Anders Hejlsberg (the TypeScript Chief Architect) when creating the language were:</p>
<ul>
<li>Creating a totally object-oriented language that would convert into JavaScript at compilation time (it's called <strong>transpilation</strong> since it just produces another language and not a compiled module), allowing the final JavaScript generated to be executed in any browser (or Web platform).</li>
<li>Make the language statically typed, so the tools could offer modern development technologies in any editor: Intellisense, Code Completion, Intelligent Refactoring, and so on.</li>
<li>Engage the community in the project by making the language completely open source. You can see the current state of the project and collaborate on its website at <a href="http://www.typescriptlang.org/">http://www.typescriptlang.org/</a>.</li>
</ul>
<p>Actually, TypeScript has been so successful that the Angular development team adopted it for the creation of Angular 2 and keeps on working with the language for coming versions (the most recent being Angular 4.1).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Architectural changes</h1>
                
            
            
                
<p>Understanding some architectural changes is fundamental to realize how you can implement DI in a language that, once transpiled, is not object-oriented, except if you are doing that transpilation into ES2015.</p>
<p>One of the biggest changes in ES2015 (or ES6, for short) is the presence of modules. A module is, basically, a piece of JavaScript code stored into a file. Once written, you can say that you have one file per module and one module per file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Modules in TypeScript</h1>
                
            
            
                
<p>TypeScript defines two different types of modules--internal and external. Moreover, we could still differentiate internal ones into two more categories: those that have a name and those that don't (you could call them implicit). The difference, in this case, is in the way you define them and use them.</p>
<p>Say you have a TypeScript file including the following:</p>
<pre>    // Implicit module (goes to the global namespace) 
    // It appears as part of the window object 
    class ClassA { 
      private x = "The String"; 
      public y = 4; 
    }; 
    var ca = new ClassA();   </pre>
<p>This code by itself is an implicit module. It becomes a part of the global namespace and you can find it inside the <kbd>window</kbd> object at runtime. You could also consider the global namespace as the implicit (default) module.</p>
<p>Of course, we have better solutions than polluting the global namespace. The most obvious one is the <kbd>module</kbd> keyword which allows defining a private code section.</p>
<p>By definition, everything declared inside a module is private to that module. Therefore, the new reserved words <kbd>import</kbd> and <kbd>export</kbd> are used to allow access to a piece of code inside a named module.</p>
<p>If we wrap the previous class inside a module definition, any attempt to reference a module's member outside the module is not recognized (see the following screenshot, inside the Visual Studio 2017 editor):</p>
<div><img height="201" width="323" class=" image-border" src="img/0ff8b7b8-20d9-4ff5-9cae-58563dc37040.png"/></div>
<p>To make a module's members available outside the module you should use the <kbd>export</kbd> keyword. Change the previous declaration into this:</p>
<pre>    export class ClassA </pre>
<p>Then, you can use the module's name to access its public members:</p>
<pre>    var c = new MyClasses.ClassA(); 
    console.log(c.y); // Logs 4 in the console window. </pre>
<p>Notice that the <kbd>ClassA.x</kbd> member is not accessible either due to its private declaration. In this manner, we have a convenient way to keep things tied to the namespace they should belong to.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">External modules</h1>
                
            
            
                
<p>However, the most useful approach when you're dealing with large applications is the use of external modules. Actually, as John Papa suggests (<a href="https://johnpapa.net/typescriptpost4/">https://johnpapa.net/typescriptpost4/</a>), it may be useful to organize the functionality of an application in terms of the modules you'll need.</p>
<p>Let's say we have a module definition inside the <kbd>ES6Code.ts</kbd> file. To export the <kbd>foo()</kbd>function and <kbd>Timer</kbd> class, you declare them as follows:</p>
<pre>    // File ES6Code.ts  
    module ES6Code { 
      export function foo() { console.log("Foo executed"); } 
      export class Timer { 
        localTime: string; 
        currentDate: string; 
        constructor( todaysDate:Date ) { 
            this.localTime = todaysDate.toTimeString(); 
            this.currentDate = todaysDate.toLocaleDateString(); 
        } 
      } 
    } </pre>
<p>Now, in a distinct module or script section we can access that functionality using a slightly different reference:</p>
<pre>    // File: app.ts --------- 
    // Simple Function Import  
    import foo = ES6Code.foo; 
    foo();  // OK. </pre>
<p>The same goes for the <kbd>Timer</kbd> class, except that we can also adopt another approach to reference the class:</p>
<pre>    // File: app.ts --------- 
    // Reference Class Import (alternative syntax) 
    var timer = new ES6Code.Timer(new Date()); 
    console.log(timer.currentDate); 
    console.log(timer.localTime); </pre>
<p>In this case, the module's name is used as a prefix to the class instantiation, in a similar way to what you find in C# code when dealing with namespaces.</p>
<p>To test this code, we just have to include references to the corresponding transpiled files (<kbd>.js</kbd> extension), inside an HTML page, or test it inside the Node console. For instance, if you use a blank HTML page, you could include the files in this manner:</p>
<pre>    &lt;head&gt; 
      &lt;meta charset="utf-8" /&gt; 
      &lt;title&gt;&lt;/title&gt; 
      &lt;link rel="icon" href="data:;base64,iVBORw0KGgo="&gt; 
      &lt;script src="img/ES6Code.js"&gt;&lt;/script&gt; 
      &lt;script src="img/app.js"&gt;&lt;/script&gt; 
  &lt;/head&gt; </pre>
<p>Note: The <kbd>&lt;link&gt;</kbd> tag is a fake favicon to prevent Chrome from presenting a File Not Found error in the console, next to the output.</p>
<p>In both cases, the reference is correct, and the code is executed as expected, as we can see in the following screenshot (remember: <kbd>F12/Console</kbd> inside the developer's tools of any modern browser. I'm using Chrome here):</p>
<div><img height="136" width="382" class=" image-border" src="img/4efb9134-695c-4612-b276-7070d1815d10.png"/></div>
<p>This is possible because, once the files are referenced inside a page, their members become accessible as long as they are marked as <kbd>export</kbd>.</p>
<p>Actually, we can reference several files, and they'll be loaded and executed in sequence. Notice also that the console window indicates which code is responsible for the execution of which entry in the console.</p>
<p>In the initial example, <kbd>MyClasses</kbd> was stored inside the <kbd>app1.ts</kbd> file. So, now, we could also reference it, before the <kbd>&lt;/head&gt;</kbd> tag, and check how a third source origin shows up in the console, which outputs the number 4, in the last position (check it in the following screenshot):</p>
<div><img height="143" width="431" class=" image-border" src="img/4ac5e5ae-8c88-4016-b656-f93411c52070.png"/></div>
<p>Also, you'll notice that Chrome is smart enough to reference the original <kbd>.ts</kbd> files and not the transpiled ones, allowing you to debug any of these files, setting breakpoints, and so on. In the following screenshot, I'm showing the debugging window inside Chrome after setting a breakpoint before printing the date and time values:</p>
<div><img height="214" width="387" class=" image-border" src="img/fcc46658-0505-44bf-821b-3009b34a7095.png"/></div>
<p>Besides these options, now it's possible to debug within Visual Studio 2017 using Chrome as default browser.</p>
<p>This module separation is important because, as you'll see later, that implies file separation, which becomes crucial in the way TypeScript and, especially, Angular organize the distinct components of an application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Dependency Injection in TypeScript</h1>
                
            
            
                
<p>All that said, TypeScript itself doesn't have a DI container. However, you could use some of the third-party options available. Some of the most popular are <kbd>Infuse.js</kbd> (available at <a href="https://github.com/soundstep/infuse.js">https://github.com/soundstep/infuse.js</a>) and TypeScript IoC, which you can find on the NPMJS site (<a href="https://www.npmjs.com/package/typescript-ioc">https://www.npmjs.com/package/typescript-ioc</a>), both of which work in a very similar way to what we've already seen in .NET Core.</p>
<p>That is, you have to make definitions that map an interface to a class or even a descriptor to a class and then register those options. Later on, you can make a reference to the type required and expect the DI container to provide you with the corresponding type.</p>
<p>Let's review the way TypeScript IoC works to define a simple injection scenario, the way it's shown on its official page.</p>
<p>First, assuming you have TypeScript installed, you should also install TypeScript IoC, with a typical <kbd>npm</kbd> command:</p>
<pre>    <strong>npm install typescript-ioc</strong>  </pre>
<p>Besides that, some modern options are also required inside the configuration file (the <kbd>tsconfig.json</kbd> file):</p>
<pre>    { 
      "compilerOptions": { 
        "experimentalDecorators": true, 
        "emitDecoratorMetadata": true 
      } 
    } </pre>
<p>Once that is configured, you use one of the <kbd>import</kbd> syntax variants to put it to work:</p>
<pre>    import {AutoWired, Inject} from "typescript-ioc"; 
    class PersonDAO { 
      @Inject restProxy: PersonRestProxy; 
    } </pre>
<p>As you can see, the <kbd>restProxy</kbd> property, which is of another type (<kbd>PersonRestProxy</kbd>), is marked with an <kbd>@Inject</kbd> decorator (a new feature in the latest versions of JavaScript and available in TypeScript), to indicate that it can be injected later on inside other code).</p>
<p>Somewhere else in the code, you'll be able to use these definitions with a very simple syntax:</p>
<pre>    let personDAO: PersonDAO = new PersonDAO();  </pre>
<p>The <kbd>restProxy</kbd> property will be provided by the container, resolving the dependencies. Parameter injection is also provided, using a class with a constructor, as we can see in the following code:</p>
<pre>    class PersonService { 
     private personDAO: PersonDAO; 
     constructor( @Inject personDAO: PersonDAO ) { 
       this.personDAO = personDAO; 
     } 
   } </pre>
<p>If, later on, you have another class that uses <kbd>PersonService</kbd> as a property, you mark that property with <kbd>@Inject</kbd>, like in this code:</p>
<pre>    class PersonController {<br/>     @Inject private personService: PersonService;<br/>    }</pre>
<p>You can rely on the chain of dependencies being managed by the container, which will go through all references previously marked as <kbd>@Inject</kbd>.</p>
<p>However, in practice, it's rare to see applications in TypeScript itself and the most common use of this language is to provide other frameworks, such as Angular or Ionic, with a consistent development language.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Angular</h1>
                
            
            
                
<p>As mentioned in <a href="9b8972f9-fedb-457b-a60a-8f62098bfa00.xhtml" target="_blank">Chapter 2</a>, <em>Dependency Injection and IoC Containers</em>, Angular is a development framework created by a team at Google (led by MiskoHevery), that has become very popular now (you can access the official information at <a href="http://angularjs.org">http://angularjs.org</a>).</p>
<p>Nowadays, Angular is available in two flavors that follow different release paths or branches:</p>
<ul>
<li><strong>Version 1.x</strong>:  Also called <strong>AngularJS</strong>. It's recommended for small/medium applications and uses the MVC model to implement a suitable separation of concerns, from the beginning:
<ul>
<li>It's composed of a set of JavaScript libraries, each one supplying a part of the functionality required. However, all libraries depend on the basic AngularJS library.</li>
<li>At the time of writing, the latest version is 1.6.4, and the team guarantees support and future updates. It can also be downloaded via CDN at <a href="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.4/angular.min.js">https://ajax.googleapis.com/ajax/libs/angularjs/1.6.4/angular.min.js</a>.</li>
</ul>
</li>
<li><strong>Version 2+</strong>: It's just named <strong>Angular</strong> and it follows a semantic versioning path, which means no breaking changes are allowed in minor revisions, only in new versions. There was a version number jump that avoided 3.0, so the latest version is Angular 4 (4.1, to be precise). It has a dedicated website apart from AngularJS at <a href="https://angular.io/">https://angular.io/</a>:
<ul>
<li>Perhaps the biggest change is that Angular is not backward-compatible with AngularJS since it embraces a number of changes that appeared in ES6 and directly affects the way modules are managed.</li>
<li>Its main features are cross-compatibility, improved speed and performance, excellent tooling, and an increasing adoption by the community all over the world.</li>
<li>Angular is built in TypeScript thanks to a joint venture with Microsoft's TypeScript team, which actively collaborates in the project. Recently, one of the lead members of the team announced: <em>TypeScript has become allowed for unrestricted client development as of March 2017. TypeScript and Angular on TypeScript are used in Google Analytics, Firebase, and Google Cloud Platform and critical internal tools such as bug tracking, employee reviews, and product approval and launch tools</em>.</li>
</ul>
</li>
</ul>
<p>Both versions have some points in common from an architectural point of view. They foster SOLID principles, and especially SRP and DIP, so they both rely on Dependency Injection containers. Furthermore, the adoption of the MVC model helps to structure the separation of concerns.</p>
<p>Let's see how these two popular architectures implement Dependency Injection (although in different ways).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">AngularJS</h1>
                
            
            
                
<p>Creating a very basic Angular application is easy, once the basic principles of the MVC are clear. The MVC model proposes a foundational separation of application components into three parts (see the following figure): </p>
<div><img height="254" width="222" src="img/dabe33e4-815f-4207-adb1-a5d71c704cb4.png"/></div>
<p>(Image courtesy: Wikipedia: <a href="https://en.wikipedia.org/wiki/Model-view-controller">https://en.wikipedia.org/wiki/Model-view-controller</a>)</p>
<p>The user's interaction generates a circuit in which the three pillars of MVC are present:</p>
<ul>
<li>The <strong>MODEL</strong> is created automatically in the loading process of the AngularJS library.</li>
<li>The <strong>VIEW</strong> corresponds to the HTML side, which is marked with custom attributes (all starting with <strong><em>ng-</em></strong>) to indicate the distinct functionality required. Views also use a syntax called <strong>mustache</strong> to indicate which parts are subject to data-binding.</li>
<li>The <strong>CONTROLLERS</strong> are JavaScript fragments, coded to reflect any changes requested by the user, and manipulate the Model if required.</li>
</ul>
<p>When the user interacts with a UI element in the page, a controller takes care of the corresponding action, modifies the model if it is necessary, and Angular updates the view reflecting the changes. Finally, the view is received by the user and this cycle continues uninterruptedly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Examples using Visual Studio 2017</h1>
                
            
            
                
<p>Once you have an HTML page that loads the AngularJS library, you should mark one DOM element with a special attribute (ng-app) to notify Angular of its working scope. This defines the area of action for AngularJS inside the page.</p>
<p>Let's see all this in a very simple example. We can use Visual Studio 2017 as well, for example creating a new website (notice that we don't need a project since we don't need any compiled code on the server: it all happens on the client side).</p>
<p>So, I suggest choosing an ASP.NET Empty Website for this initial demo. That will create a folder to hold the solution and will include a <kbd>Web.config</kbd> file just in case you want to instruct the server about some behavior or require some compiled code as well.</p>
<p>Next, we add an HTML page and save the solution to be able to use the Manage NuGet packages option and search for the AngularJS.Core library. Make sure you're selecting AngularJS.Core and not just angularjs if you don't want to be overloaded with all available libraries for this framework (see the following screenshot):</p>
<div><img height="364" width="685" class=" image-border" src="img/b2496a17-6026-47f4-9948-4c2e58998b24.png"/></div>
<p>Once installed, a new Scripts folder will show up in the Solution Explorer, including a few libraries. You just need to drag and drop the angular.js library inside the <kbd>&lt;head&gt;</kbd> tag, to let Visual Studio create a <kbd>&lt;script&gt;</kbd> tag pointing to the library and you're ready to go!</p>
<p>The next step is adding the <kbd>ng-app</kbd> attribute (for example, to the <kbd>&lt;body&gt;</kbd> tag) and giving it a valid name, such as <kbd>app</kbd>. Currently, we have a page, the angular library loaded, and a scope defined.</p>
<p>How can we see some AngularJS in action with this? We can create an HTML tag, such as <kbd>&lt;h2&gt;</kbd>, <kbd>&lt;h3&gt;</kbd>, <kbd>&lt;div&gt;</kbd>, <kbd>&lt;article&gt;,</kbd> and so on, and include a moustache link inside (they're called AngularJS binding expressions) that should be resolved at runtime, for example, a <kbd>&lt;h2&gt;</kbd> tag that will show the current time. In all, up to this point, we should have a page like this:</p>
<pre>    &lt;!DOCTYPE html&gt; 
    &lt;html&gt; 
    &lt;head&gt; 
      &lt;meta charset="utf-8" /&gt; 
      &lt;title&gt;AngularJS initial demo&lt;/title&gt; 
      &lt;script src="img/angular.js"&gt;&lt;/script&gt; 
    &lt;/head&gt; 
    &lt;body ng-app="app"&gt; 
      &lt;h2&gt;Current time: {{time}}&lt;/h2&gt; 
    &lt;/body&gt; 
    &lt;/html&gt; </pre>
<p>Observe the two identifiers (<kbd>app</kbd> and <kbd>time</kbd>) that are not defined yet. That will be our JavaScript section of this page. So, before the closing <kbd>&lt;/body&gt;</kbd> tag, we will include an <kbd>&lt;script&gt;</kbd> tag with the following code:</p>
<pre>    &lt;script&gt; 
      var app = angular.module("app", []); 
      app.controller("TimeController", function ($scope) { 
         $scope.time = new Date().toLocaleTimeString(); 
      }); 
   &lt;/script&gt; </pre>
<p>This needs some explanation: first, we create a <kbd>module</kbd> named <kbd>app</kbd>. That is an object managed by AngularJS to establish the DOM area of interest, and it is created by calling the <kbd>method</kbd> module on the <kbd>angular</kbd> object that the library created at loading time. We cache the return value in a variable of the same name just to make the following code a bit clearer.</p>
<p>The next step is crucial. Here we create a controller called <kbd>TimeController</kbd> and assign a callback function to it. Well, that function is using Dependency Injection by default! If you notice the function's definition, there's a <kbd>$scope</kbd> variable defined. Where does it come from?</p>
<p>The explanation is that, in several angular's constructions, when you define a callback function and declare a recognizable service as a parameter (such as <kbd>$scope</kbd>), a singleton instance of that service is provided by the <kbd>$injector</kbd> object to you with no intervention on our own.</p>
<p>And it is precisely that <kbd>$injector</kbd> object that provides DI container services in AngularJS. Every object managed by a module has its own instance of that service and takes care of resolving all dependencies.</p>
<p>The official AngularJS documentation defines its implementation in this way:</p>
<p class="packt_quote">The AngularJS injector subsystem is in charge of creating components, resolving their dependencies, and providing them to other components as requested.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the structure of AngularJS bootstrap</h1>
                
            
            
                
<p>The following diagram shows the structure of the bootstrap process that takes place when loading an Angular app:</p>
<div><img height="312" width="381" src="img/fbb8428a-d617-418a-b24f-52f42df59c2f.png"/></div>
<p>The detailed explanation is this: HTML elements marked with attributes starting with <kbd>ng-</kbd> denote a part of the DOM called Dynamic DOM (where no <kbd>ng-</kbd> attributes are present, considered to be static DOM).</p>
<p>Let's briefly reproduce the steps used:</p>
<ul>
<li>When the DOM is loaded, AngularJS searches for a <kbd>ng-app</kbd>-marked element and defines a <kbd>$injector</kbd> linked to it.</li>
<li>In turn, that injector defines a <kbd>$compile</kbd> service that teaches the HTML interpreter some new syntax. To be precise, the documentation explains this point by stating that:</li>
</ul>
<p style="padding-left: 90px"><em>The compiler allows you to attach behavior to any HTML element or attribute and even create new HTML elements or attributes with custom behavior. AngularJS calls these behavior extensions directives.</em></p>
<ul>
<li>With all that in memory, AngularJS also creates a special service called <kbd>$rootScope</kbd>, which serves as the root model for the module. Of course, you can use it as well in your own code.</li>
<li>Now, every controller that you create has a child of that <kbd>$rootScope</kbd>, called simply <kbd>$scope</kbd>: that's the section of the model that such a controller manages.</li>
<li>As the last step, the <kbd>$compile</kbd> object traverses the module, searching for elements that have <kbd>ng-*</kbd> attributes, here called directives, or AngularJS expressions (<kbd>{{moustache}}</kbd> annotations), and substitutes those elements with the required data or code.</li>
</ul>
<p>Consequently, the final aspect of our HTML code will be (I'm including only the contents of the <kbd>&lt;body&gt;</kbd> element):</p>
<pre>     &lt;body ng-app="app"&gt; 
      &lt;h2 ng-controller="TimeController"&gt;Current time: {{time}}&lt;/h2&gt; 
    &lt;script&gt; 
       var app = angular.module("app", []); 
       app.controller("TimeController", function ($scope) { 
          $scope.time = new Date().toLocaleTimeString(); 
       }); 
      &lt;/script&gt; 
    &lt;/body&gt; </pre>
<p>So, what I'm doing here is creating a model's variable (<kbd>time</kbd>) assigned to the controller named <kbd>TimeController</kbd>. Its value is equal to a string representing the current's system time.</p>
<p>Finally, we need to indicate which AngularJS element is managed by which controller: in this case, it is the <kbd>&lt;h2&gt;</kbd> element containing the <kbd>time</kbd> variable defined in the model. At runtime, AngularJS substitutes the variable's value for the <kbd>{{time}}</kbd> expression.</p>
<p>The output in the browser changes every time you refresh the page (see the following screenshot):</p>
<div><img height="97" width="327" class=" image-border" src="img/85b8713d-4c16-4128-9c84-59c529808163.png"/></div>
<p>This is a very simple demo, but it illustrates the basics of AngularJS and how DI is pervasive throughout the framework since you'll find it all over.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Data access and Dependency Injection</h1>
                
            
            
                
<p>Actually, we can see a better implementation of a controller and how to use the <kbd>$injector</kbd> object if we access some real data using another AngularJS service, called <kbd>$http</kbd>.</p>
<p>The following code reads all data from the <kbd>BookStore2.json</kbd> file that we used in <a href="58f9e2e8-6e57-473a-9ccf-89a9a90f1858.xhtml" target="_blank">Chapter 9</a>, <em>Anti-Patterns and Misconceptions on Dependency Injection</em>, demos and creates a list of its elements. I'll show you the code first, and then we'll move to the explanation:</p>
<pre>    &lt;!DOCTYPE html&gt; 
    &lt;html&gt; 
    &lt;head&gt; 
      &lt;meta charset="utf-8" /&gt; 
      &lt;title&gt;AngularJS Data Access Demo&lt;/title&gt; 
      &lt;link rel="icon" href="data:;base64,iVBORw0KGgo="&gt; 
      &lt;link href="Content/bootstrap.css" rel="stylesheet" /&gt; 
      &lt;script src="img/angular.js"&gt;&lt;/script&gt; 
    &lt;/head&gt; 
    &lt;body ng-app="app" class="container"&gt; 
      &lt;h2&gt;A list of ASP.NET Core Books (by PACKT)&lt;/h2&gt; 
      &lt;ul ng-controller="ListController"&gt; 
        &lt;li ng-repeat="book in Books"&gt; 
            {{book.Title}}, &lt;strong&gt;&lt;em&gt;{{book.Author}}&lt;/em&gt;&lt;/strong&gt; 
        &lt;/li&gt; 
      &lt;/ul&gt; 
      &lt;script&gt; 
        angular.module("app", []); 
        var ListController = function ($scope, $http) { 
               $http.get("BookStore.json"). 
               then(function (response) { 
                     $scope.Books = response.data; 
               }). 
               catch(function (error) { 
                     alert(error.statusText); 
               }); 
        };         
        ListController.$inject = ["$scope", "$http"]; 
        angular.module("app").controller("ListController", <br/>           ListController); 
      &lt;/script&gt; 
    &lt;/body&gt; 
    &lt;/html&gt; </pre>
<p>Before commenting this out, let us note that I'm also using the BootStrap library, but that's only for presentation purposes; it has nothing to do with DI.</p>
<p>If you look at the previous code in any browser, it will present an output very similar to the one that's shown in the following screenshot:</p>
<div><img height="210" width="510" class=" image-border" src="img/8780a472-7196-42ea-973a-e4bcdc67b170.png"/></div>
<p>Let's review the most important changes in this code. On the JavaScript side:</p>
<ul>
<li>Module creation is not cached into a variable (this avoids unnecessary variables in the global space).</li>
<li>The controller is created using a function expression assigned to a variable of the same name. It declares two variables to be injected later on:
<ul>
<li><kbd>$scope</kbd>: The reference to the model linked to the controller</li>
<li><kbd>$http</kbd>: A service that facilitates request/response actions with HTTP servers, either using the <kbd>XmlHttpRequest</kbd> object (AJAX) or JSONP inside AngularJS</li>
</ul>
</li>
<li>Inside the function, <kbd>$http</kbd> is used to get data by calling its <kbd>get</kbd> method and passing it the URL of the resource to recover. That call returns a promise, which is resolved asynchronously:
<ul>
<li>When the promise is resolved, it returns the expected information, and the callback functions linked to it will receive an object with the following properties, according to the official site's documentation:
<ul>
<li><kbd>data{string|Object}</kbd>: The response body transformed with the transform functions</li>
<li><kbd>status{number}</kbd>: HTTP status code of the response</li>
<li><kbd>headers{function([headerName])}</kbd>: Header getter function</li>
<li><kbd>config{Object)</kbd>: The configuration object that was used to generate the request</li>
<li><kbd>statusText{string}</kbd>: HTTP status text of the response</li>
</ul>
</li>
<li>If the status code is a number between 200 and 299, the process is successful, and a subsequent call to <kbd>.then()</kbd> receives the information inside its <kbd>[parameter].data</kbd> property</li>
<li>Otherwise (if you get a different status code) there's an error and you should catch it with an extra call to <kbd>.catch(),</kbd> just as we do in the preceding code</li>
</ul>
</li>
<li>The <kbd>$injector</kbd> object is able to resolve the names of the variables as singleton instances of the services they represent, but what happens when you package your application and the <em>minifiers</em> change the name of those variables? This is where the <kbd>$inject</kbd> array comes in:
<ul>
<li>It allows the <em>minifiers</em> to rename the function's parameters and still be able to inject the referred services. Notice that it is an array linked to the controller, and it can grow or shrink at will.</li>
</ul>
</li>
<li>The final step is to define the controller itself inside the module. That's why we use the <kbd>angular.module("app")</kbd> syntax, which accesses the module and invokes the required methods inside (notice this time we don't pass the second argument: that means to access, not creation).</li>
</ul>
<p>Of course, there is much more to AngularJS using DI and the framework itself, but I hope now have some idea of how Dependency Injection is implemented here. Let's summarize and complete the most important points about this pattern inside AngularJS.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summing up Dependency Injection features inside AngularJS</h1>
                
            
            
                
<p>Dependency creation in AngularJS is the responsibility of the <kbd>injector</kbd> object. This object, by the way, uses the constructor injection paradigm. Actually, the injector behaves as a service locator that takes care of construction and look up for dependencies.</p>
<p>This is achieved using the declarative notation in HTML templates. When the HTML is processed (parsed), it passes the responsibility for component creation to the injector, thus avoiding the need to pass the injector throughout the application. All that work is done "behind the scenes".</p>
<p>As the documentation states, working in this manner <em>t</em><em>he application code simply declares the dependencies it needs, without having to deal with the injector. This setup does not break the Law of Demeter</em>.</p>
<p>Let's now focus on the latest versions of Angular (versions 2.0+), that are, in several ways, based on many of these principles but change its implementation quite a bit since they embrace ES6 and related technologies.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Angular 2+</h1>
                
            
            
                
<p>Since the release of AngularJS (version 1.x) in 2009, the web has changed immensely. We now have a multitude of build systems, modular loading capabilities, and Web components available to use. JavaScript development has also come on in leaps and bounds.</p>
<p>Those changes were not reflected in AngularJS, so it was not as performant as the team wanted, mainly due to the digest cycles (related to the DOM parsing that we mentioned previously), and directly related to change detection.</p>
<p>Change detection in Angular can be imagined as a tree working in one direction from the root to its leaves so that it's both faster and more predictable.</p>
<p>The name of any version higher than 1.x is just Angular, without the <kbd>JS</kbd> suffix</p>
<p>Angular has observable and immutable objects that greatly speed up how many properties are checked.</p>
<p>Besides, observable objects are triggered only if an input that they rely on emits an event. Immutable objects are only checked if one of their input properties has changed. In most cases though, these two types of object don't have to be checked, meaning that your whole application will be speeded up.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Microsoft's TypeScript is the preferred language in Angular 2+ </h1>
                
            
            
                
<p>Another big change is the use of TypeScript as the preferred language (the Angular team also uses TypeScript language services and Visual Studio Code, to detect failures and inconsistencies in code, as Brad Green declared recently).</p>
<p>TypeScript has great support in editors such as Visual Studio Code and WebStorm and it behaves as a permanent assistant when you are importing modules and autocompleting intelligent suggestions.</p>
<p>Moreover, since it is a typed language, hints provided are far more in-depth than JavaScript's Intellisense. Additionally, any JavaScript is valid TypeScript, so you can use as much or as little of it as you're comfortable with. Many areas help Angular, such as interfaces, constructors, public variables, classes, typed arguments, and so on.</p>
<p>But perhaps the biggest change in Angular is that its architecture is based on the concept of the component. And those components are defined using class annotations or decorators, a feature that allows adding metadata to a class.</p>
<p>Before delving into it, let's first remind ourselves of the required tooling to work with Angular.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Angular tools</h1>
                
            
            
                
<p>To work with the latest versions of Angular you can certainly choose from a variety of tools, but I'm going to use those that the official site recommends, plus those you need as a requirement.</p>
<p>First, you need a recent version of Node.js installed. At the time of writing, two versions are available on its website (<a href="https://nodejs.org/es/">https://nodejs.org/es/</a>): 6.10.3 and 7.10.0. Either one will be fine, although I have installed 7.10.0. This installation provides two basic tools to work with Angular: Node and <strong>NPM</strong> (<strong>Node Package Manager</strong>).</p>
<p>Once you have completed the installation, make sure the versions are correct by typing the following in a console window:</p>
<pre><strong>      node-v</strong></pre>
<p>And by typing the following too:</p>
<pre><strong>     npm -v </strong></pre>
<p>With that in place, there are a number of editors suitable for Angular, but you could try the free cross-platform Visual Studio Code, which has debugging capabilities and works fine in Windows, Linux, and OSX.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with Angular</h1>
                
            
            
                
<p>Let's install Angular CLI, a command line interface to work with Angular, which helps a lot in the initial steps with this framework. We will be able to create the early application very easily and understand how the architecture changes.</p>
<p>Angular CLI has a dedicated website (<a href="https://cli.angular.io/">https://cli.angular.io/</a>), where you'll find the installation process, downloads, and the related documentation. However, the easiest way to install it is via NPM. You just have to type the following in a Command Prompt:</p>
<pre>    <strong>npm install -g @angular/cli</strong>  </pre>
<p>This installs the Angular-CLI tools globally, so it is available all over the filesystem.</p>
<p>Once again, it's a good practice to check the final state of the installation, which you can do by typing the following:</p>
<pre>    <strong>ng --version</strong></pre>
<p>The output should show the following information:</p>
<div><img height="295" width="658" class=" image-border" src="img/1b2a8589-50ea-4255-ad24-903883c1ac12.png"/></div>
<p>And we're all set! If you want to take a look at the list of commands that Angular CLI holds, just type <kbd>ng --help</kbd>. A long list will show up, so you can have an idea of how powerful this tool is in current versions.</p>
<p>To create the first application, open a Command Prompt (you can use the Developer Command Prompt link that Visual Studio installs), go to the directory where you want your demos to be located, create a new directory, and type the following:</p>
<pre><strong>     ng new [your-app-name]</strong></pre>
<p>In my case, I typed <kbd>ng new ng4-demo</kbd> and then you wait until the bunch of libraries from NPM is downloaded and installed in the directory of your choice.</p>
<p>Inside the new directory, you can now see the list of files and directories created by the tool, and ready to launch. Notice that there are three new directories: <kbd>e2e</kbd>, <kbd>node_modules,</kbd> and <kbd>src</kbd>.</p>
<p>The first one contains end-to-end tests for the application. That's done by default and you should modify those definitions further on to suit your needs.</p>
<p>The second and largest one holds the large list of JavaScript libraries required for almost any Angular application. Don't get scared by its length: they're downloaded and installed locally to provide programmers with the tools they might need, but at deploying time only those required will be included in the bundling and minifying process prior to deployment (it is called <strong>tree-shaking</strong>).</p>
<p>Finally, in the <kbd>src</kbd> directory, you'll find all the files required for this initial demo. The rest are files used by Angular CLI and other tools (such as the editors) to manage the project (especially, <kbd>package.json</kbd>, <kbd>tsconfig.json</kbd>, and <kbd>angular-cli.json</kbd>).</p>
<p>You should end up with a list like the following:</p>
<div><img height="236" width="437" class=" image-border" src="img/ef11a241-5f06-4ac6-8ae3-1f6dee9c8b01.png"/></div>
<p>To see it in action, just type <kbd>ng serve</kbd>. That will run the Webpack tool to get everything ready and launch a server on port 4200 (by default).</p>
<p>The final step will be to open any browser with the URL <kbd>http://localhost:4200</kbd> and see the very simple page saying <kbd>app works</kbd> (I omit the output; it is pretty obvious).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Editing the initial project</h1>
                
            
            
                
<p>Now that we know everything works, let's view the project inside Visual Studio Code (or the editor of your choice), and try to understand the architecture behind this.</p>
<p>So, I'll open the editor from the Command Prompt, just by typing <kbd>code .</kbd> on the main project's directory.</p>
<p>For more information about the VSCode, visit <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>.</p>
<p>Perhaps, the most amazing thing about this initial demo (especially if you compare it to our previous demos in Angular 1.6) is the lack of references and directives inside the main HTML page of this app:</p>
<pre>    &lt;!doctype html&gt; 
    &lt;html&gt; 
    &lt;head&gt; 
     &lt;meta charset="utf-8"&gt; 
     &lt;title&gt;Ng4demo&lt;/title&gt; 
     &lt;base href="/"&gt; 
     &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; 
     &lt;link rel="icon" type="image/x-icon" href="favicon.ico"&gt; 
    &lt;/head&gt; 
    &lt;body&gt; 
     &lt;app-root&gt;Loading...&lt;/app-root&gt; 
    &lt;/body&gt; 
    &lt;/html&gt; </pre>
<p>The only non-static HTML is marked in bold: <kbd>&lt;app-root&gt;</kbd>. Angular resolves this customized element into the real page you saw in the browser through a complex process of component-related architectures, in which every component defines its behavior, its visual elements (if it has any), and the way it communicates with the rest of the application.</p>
<p>If you look inside the <kbd>src</kbd> directory, you'll see several TypeScript files. The module responsible for instructing the browser what to do when <kbd>http://localhost:4200</kbd> is invoked appears inside the <kbd>angular-cli.json</kbd> file. This file contains a bunch of definitions about editor and server behaviors, and so on.</p>
<p>It holds an app's entry containing that <kbd>main</kbd> property and also the entry point of the application, which is linked to an <kbd>index</kbd> field (see the following screenshot):</p>
<div><img height="241" width="313" class=" image-border" src="img/40ec42a2-507e-4a5c-a169-569022036138.png"/></div>
<p>With those definitions, the browser knows which page to launch, and the server which components should be resolved: whatever the <kbd>main</kbd> module indicates. And what it shows is a basic environment configuration:</p>
<div><img height="194" width="512" class=" image-border" src="img/afc0ddac-9403-43ff-b497-80fd1711ff66.png"/></div>
<p>So, this is how Angular manages the initialization of the app. Whatever is inside <kbd>AppModule</kbd> will be loaded and resolved.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The structure of the main module</h1>
                
            
            
                
<p>However, as it turns out that every angular application must consist of at least one module, the <kbd>app.module.ts</kbd> becomes the one that sets up the application. It's mandatory to understand how it works:</p>
<div><img height="284" width="538" class=" image-border" src="img/4f8c1e04-cc51-44f4-be70-e0b82eed4403.png"/></div>
<p>First, we find <kbd>import</kbd> statements that load some previously exported components inside the Angular libraries, such as <kbd>platform-browser</kbd>, <kbd>core</kbd>, <kbd>forms</kbd>, and <kbd>http</kbd>. Some of these libraries are not needed in this basic demo, however.</p>
<p>The last <kbd>import</kbd> statement is the one that links this module with the rest of the functionality, loading <kbd>app.component</kbd>.</p>
<p>The way you define a module is by means of a class (here named <kbd>AppModule</kbd>), marked with a <kbd>@NgModule</kbd> decorator. There are no functionalities or definitions inside. Only the decorator provides the correct link with the rest of the app's elements.</p>
<p>Actually, the <kbd>bootstrap</kbd> property indicates which component will be in charge of launching the application.</p>
<p>Let's see how that component is made up:</p>
<div><img height="248" width="548" class=" image-border" src="img/1282f3d2-3cd8-4bc5-be35-6163ed34f975.png"/></div>
<p>Now we have the <kbd>AppComponent</kbd> class marked with the <kbd>@Component</kbd> decorator. Inside, we find the HTML part that we see in the browser. It's the title field of the class.</p>
<p>But, inside the decorator, we have some clues:</p>
<ul>
<li><kbd>selector</kbd>: Indicates the customized piece of dynamic DOM that will be translated into a real fragment of HTML at runtime. Remember, the only foreign part of HTML inside <kbd>Index.html</kbd> is that reference to the <kbd>&lt;app-root&gt;</kbd> element.</li>
<li><kbd>templateUrl</kbd> (optionally just template, if indicated next): The file containing the HTML fragments that will replace the selector. They admit <kbd>{{moustache}}</kbd> syntax, as it happens here.</li>
<li><kbd>styleUrls</kbd>: An array of CSS files that will be loaded at runtime for presentation purposes. They will only affect the component that defines them, and not the whole page.</li>
</ul>
<p>Finally, the <kbd>app works</kbd> sentence that we saw in the browser's initial page is just the <kbd>title</kbd> property of the <kbd>AppComponent</kbd> class. And, yes, it is linked via data-binding to the HTML inside the template, which is just a <kbd>&lt;h1&gt;</kbd> element:</p>
<pre>    &lt;h1&gt; 
     {{title}} 
    &lt;/h1&gt; </pre>
<p>So, let's make a couple of changes, to see how it goes. Instead of <kbd>app works</kbd>, I'll change the <kbd>title</kbd> property to <kbd>First demo in Angular 4</kbd>, and the CSS file, which is empty, will also hold some formatting rules:</p>
<pre>    h1 { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      font-size: 2em; 
      border: 3px solid navy; 
    } </pre>
<p>Of course, we can also add any static content to the <kbd><strong>index.html</strong></kbd> itself (an image, for example, next to the selector):</p>
<pre>    &lt;img src="img/business" alt=""&gt; </pre>
<p>The environment will take care of every change in the application and incrementally recompile those changes.</p>
<p>Notice that, at the end, the text we see is the class' <kbd>title</kbd> property, which is evaluated and managed by the component architecture of the Angular framework, and it is this component architecture that facilitates the implementation of Dependency Injection.</p>
<p>So, we should see those changes without any more intervention:</p>
<div><img height="295" width="354" class=" image-border" src="img/d7fd9cc0-f66b-4eaa-aa72-46f81c7eb9fa.png"/></div>
<p>Some of the procedures implied in this model use types of dependencies that are solved at compile time and runtime. But how can we see the DI in action?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">DI in Angular 4</h1>
                
            
            
                
<p>Well, DI in Angular follows the construction injection pattern; thus, since we are dealing with classes (components) here, most of the injection is required in the constructor's parameter definitions.</p>
<p>A dedicated page on the official Angular documentation site supplies more information about Dependency Injection at <a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html">https://angular.io/docs/ts/latest/guide/dependency-injection.html</a>.</p>
<p>As with AngularJS, Angular creates an injector object in the bootstrap process, so you don't have to do it by yourself (remember, the <kbd>platformBrowserDynamic().bootstrapModule(AppModule)</kbd>sentence inside <kbd>main.ts</kbd>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The concept of a provider</h1>
                
            
            
                
<p>With that in mind, the programmer's responsibility is to register those classes that will be served via DI later on. You can do that, either in the <kbd>NgModule</kbd>, or inside any <kbd>Component</kbd>, but, in either case, the way to declare an injectable class is by adding its name to the <kbd>provider's</kbd> collection of a component or module.</p>
<p>The difference will be that, when declared inside a <kbd>@<strong>NgModule</strong></kbd>, those services will be available alongside the entire application. In the remaining cases, it will be limited to the component's hierarchy.</p>
<p>Let's modify the previous example, so you can see this technique in action. Actually, it is quite simple.</p>
<p>The first step is to create a class that provides the injected information required (I'll call it <kbd>DIClass</kbd>). Let's imagine we want an extra text property and a picture. Since we only need the picture's URL, we'll define two string properties.</p>
<p>But to make the class injectable, we need to mark it as such. We do that by importing the "<kbd>Injectable</kbd>" definition from <kbd>@angular/core</kbd> and decorating the class with that annotation. The final aspect of this class' code will be:</p>
<div><img height="121" width="502" class=" image-border" src="img/b4d6086e-6d07-4c26-a03f-42a807a00f45.png"/></div>
<p>Now, we can get rid of the <kbd>&lt;img&gt;</kbd> element we inserted in <kbd>index.html</kbd> and pass the task of inserting the image to the component.</p>
<p>Besides that, and only for presentation purposes, I've modified the <kbd>app.component.css</kbd> code to mark the injected information inside a border, so those fragments become clearly visible.</p>
<p>With the class ready, we now define the scope of this service. Since we only need it for our <kbd>AppComponent</kbd>, we'll add a new definition of <kbd>providers</kbd> in the <kbd>@Component</kbd> decorator's class; this will make our <kbd>DIClass</kbd> content available inside the component.</p>
<p>Finally, we can modify our class to hold two extra properties (<kbd>subtitle</kbd> and <kbd>fotosource</kbd>), whose values are received by injection. In practice, this injected class will often be data access services or any other type of resource that might be needed in more than one application's component.</p>
<p>Since the way those values are received is by declaring the injected class (or values) in the constructor, the final version will be:</p>
<div><img height="276" width="409" class=" image-border" src="img/bb1b2adb-1090-4c00-8933-c3ae394459b7.png"/></div>
<p>Now, if you keep the server running and take a look at the new aspect of the page, next to the initial message, we should see those injected elements, formatted according to the CSS rules inside the <kbd><strong>app.component.css</strong></kbd> file:</p>
<p>And that's it. We can inject as many items as needed as long as we have previously declared those values with the <kbd><strong>@Injectable</strong></kbd> decorator; however, if you need more customizable services or data, I recommend reading the documentation's reference I mentioned previously.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Wrapping it up</h1>
                
            
            
                
<p>These techniques make your code more maintainable and scalable, and also less dependent on further changes. Since you only have to reference the required services, a change in the implementation of one doesn't necessarily mean a change in the high-level classes that use those services.</p>
<p>Of course, there is much more in DI in Angular 4 than the basic information included in this chapter. By now I hope you have a better understanding of how DI is present in these frameworks, and why it is becoming universally popular implementation design pattern.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have covered DI in other frameworks, with a special focus on Angular in its two current branches.</p>
<p>First, we've seen the very basics of TypeScript on which Angular 2+ is based and how its capabilities for class definitions and module loading allow the construction of JavaScript-based applications with a more object-oriented, modular approach.</p>
<p>Next, we went through the implementation of DI inside AngularJS (the legacy branch of Angular), still in use in more than 70 percent of Angular projects worldwide.</p>
<p>Finally, we explored the basics of Angular 4 (the latest version available at thetime of writing this), and how the aforementioned object orientation and its component architecture (based on annotations) allow the implementation of Dependency Injection in a very easy way.</p>
<p>In <a href="a437ff1b-c4af-41ac-b502-8718dc132272.xhtml" target="_blank">Chapter 11</a>, <em>Best Practices and Other Related Techniques</em>, we'll cover some of the most common best practices in DI and other related techniques.</p>
<p class="mce-root"/>


            

            
        
    </body></html>