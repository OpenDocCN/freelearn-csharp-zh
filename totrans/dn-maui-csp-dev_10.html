<html><head></head><body>
		<div id="_idContainer113">
			<h1 id="_idParaDest-179" class="chapter-number"><a id="_idTextAnchor187"/>10</h1>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor188"/>Consuming REST Services</h1>
			<p>Up until now, when we needed data, we faked it by using hardcoded objects. In a real-world program, however, you will get most of your data from local databases (as discussed in <a href="B19723_08.xhtml#_idTextAnchor144"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>), or you will interact with a service in the cloud through an API. You can interact using one of several architectures, of which the most popular for .NET MAUI is, arguably, <strong class="bold">Representational State </strong><span class="No-Break"><strong class="bold">Transfer</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">REST</strong></span><span class="No-Break">).</span></p>
			<p>REST is a pattern that describes how classes interact across the internet. The key to REST is that it is stateless – that is, a sustained connection between the client and the API is <span class="No-Break">not needed.</span></p>
			<p>The Forget Me Not architecture is designed to use a REST service and database, which will manage membership, authentication, and persistence of user data. In this chapter, we will look at <span class="No-Break">the following:</span></p>
			<ul>
				<li>Using <span class="No-Break">REST services</span></li>
				<li>The Forget Me Not <span class="No-Break">API architecture</span></li>
				<li>API <span class="No-Break">domain objects</span></li>
				<li><strong class="bold">Data Transfer </strong><span class="No-Break"><strong class="bold">Objects</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">DTOs</strong></span><span class="No-Break">)</span></li>
				<li>The API <span class="No-Break">Client class</span></li>
				<li>Using <span class="No-Break">the API</span></li>
			</ul>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor189"/>Technical requirements</h1>
			<p>To follow along with this chapter, you will need Visual Studio. If you are going to enter the code as you follow along, you’ll want the branch for the <span class="No-Break">previous chapter.</span></p>
			<p>The source code for the finished project for this chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/REST"><span class="No-Break">https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/REST</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor190"/>Using REST Services</h1>
			<p>Until now, all the work<a id="_idIndexMarker417"/> we’ve been doing has been local to a device (a phone, Windows, or Mac). The design of Forget Me Not entails the use of a service in the cloud that will manage all our data – invitations to a program, registration, authentication, data persistence, and <span class="No-Break">so on.</span></p>
			<p>A client interacts with a server<a id="_idIndexMarker418"/> through a <strong class="bold">REST API</strong> (also called a <span class="No-Break">RESTful API).</span></p>
			<p>An <strong class="bold">Application Program Interface</strong> (<strong class="bold">API</strong>) is a set<a id="_idIndexMarker419"/> of definitions and protocols to interact with an application. In our case, the API we care about is the <span class="No-Break">cloud-based </span><span class="No-Break"><strong class="source-inline">ForgetMeNot.API</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Knowing more about REST</p>
			<p class="callout">For our purposes, that is really all you need to know about REST, but if you are curious, you can find out more <span class="No-Break">at </span><a href="https://en.wikipedia.org/wiki/Representational_state_transfer"><span class="No-Break">https://en.wikipedia.org/wiki/Representational_state_transfer</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor191"/>The Forget Me Not API architecture</h1>
			<p>When we looked at getting a user’s preferences in <a href="B19723_08.xhtml#_idTextAnchor144"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, we used the Preference Service. That service, until now, used a method to return hardcoded values. That, of course, was a temporary <a id="_idIndexMarker420"/>expedient so that we could focus on one thing at a time. We are ready now to interact with the <span class="No-Break">online API.</span></p>
			<p class="callout-heading">Where’s the service?</p>
			<p class="callout">I have created an online web service on Azure <span class="No-Break">at </span><a href="https://forgetmenotapi20230113114628.azurewebsites.net/"><span class="No-Break">https://forgetmenotapi20230113114628.azurewebsites.net/</span></a><span class="No-Break">.</span></p>
			<p class="callout">It is my goal to keep this up and running so that you can implement the client and get meaningful results, but given that there may be maintenance costs, by the time you read this, the service may no longer be in place. If that is true, you can still get 95% of what you need by reading the API code and using hardcoded data, as we’ve been doing up <span class="No-Break">until now.</span></p>
			<p class="callout">Also, note that just going to the URL won’t get you anywhere. It is when we combine that base URL with the specific task-based additions that the magic happens. You can test whether the API is still available by creating an account or signing into one. If that works, then the rest of the API should work <span class="No-Break">as well.</span></p>
			<p>To facilitate our REST interactions<a id="_idIndexMarker421"/> with the API, we will use the extremely popular open source <strong class="source-inline">RestSharp</strong> library (<a href="https://restsharp.dev/">https://restsharp.dev/</a>). It will do all the heavy lifting for us. (We’ll be using the <strong class="source-inline">class</strong> <span class="No-Break">library template.)</span></p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor192"/>Creating the projects</h2>
			<p>To get started, we’ll need three<a id="_idIndexMarker422"/> new projects. Right-click on <strong class="bold">Solution</strong> and choose <strong class="bold">Add New Project</strong>. The three projects <span class="No-Break">are named:</span></p>
			<ul>
				<li><strong class="source-inline">ForgetMeNot.API.Domain</strong> (API <span class="No-Break">domain objects)</span></li>
				<li><span class="No-Break"><strong class="source-inline">ForgetMeNot.API.Dto</strong></span><span class="No-Break"> (DTOs)</span></li>
				<li><strong class="source-inline">ForgetMeNot.ApiClient</strong> (a wrapper for <span class="No-Break">the API)</span></li>
			</ul>
			<p><strong class="source-inline">Api.Doman</strong> and <strong class="source-inline">API.Dto</strong> are both class libraries. <strong class="source-inline">APIClient</strong> is <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">webapi</strong></span><span class="No-Break">.</span></p>
			<p>We’ll look at each of these in turn, filling in all <span class="No-Break">the details.</span></p>
			<p>Because we’ll be using the API database, we can remove the local SQLite database. To do so, comment out or remove the <strong class="source-inline">Constants</strong> file and the entire <span class="No-Break"><strong class="source-inline">ForgetMeNotDemoDatabase.cs</strong></span><span class="No-Break"> file.</span></p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor193"/>Fleshing out the models</h2>
			<p>Before we <a id="_idIndexMarker423"/>create classes that correspond to the items in our model classes, we need to flesh <span class="No-Break">them out.</span></p>
			<p>Let’s start with the <strong class="source-inline">Preference</strong> class in the <strong class="source-inline">Model</strong> directory. We had added an <strong class="source-inline">Id</strong> property for SQLite; we won’t need that anymore, so we can remove it. Remove it from <strong class="source-inline">PreferencesTests.AfterCallingInitPreferencesIsNotEmpty()</strong> <span class="No-Break">as well.</span></p>
			<p>The design spec says that a user can invite a friend to be a buddy. We’ll need to add a model to describe <span class="No-Break">the invitation:</span></p>
			<pre class="source-code">
using CommunityToolkit.Mvvm.ComponentModel;
namespace ForgetMeNotDemo.Model;
[ObservableObject]
public partial class Invitation
{
  [ObservableProperty] private string buddyCode;
  [ObservableProperty] private int buddyId;
}</pre>
			<p>Similarly, we need to <a id="_idIndexMarker424"/>keep track of <em class="italic">occasions</em>, such as birthdays and anniversaries, so that we remember to use Forget Me Not to buy <span class="No-Break">a present:</span></p>
			<pre class="source-code">
[ObservableObject]
public partial class Occasion
{
  [ObservableProperty] private string name;
  [ObservableProperty] private DateTime date;
  [ObservableProperty] private int numDaysToNotify;
}</pre>
			<p>We’ll need a couple more <strong class="source-inline">Model</strong> classes, such as <strong class="source-inline">User</strong> and its derived class, <strong class="source-inline">Buddy</strong>. The owner of the app is a user, as are all their buddies. Here is the <strong class="source-inline">User </strong><span class="No-Break"><strong class="source-inline">Model</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
[ObservableObject]
public partial class User
{
  [ObservableProperty] private string name;
  [ObservableProperty] private string id;    [1]
  [ObservableProperty] private List&lt;Buddy&gt; buddies; [2]
  [ObservableProperty] private List&lt;Invitation&gt;
    invitations; [3]
  [ObservableProperty] private List&lt;Preference&gt;
    preferences; [4]</pre>
			<p><strong class="source-inline">[1]</strong> We’ve migrated the ID up here to the base class. We won’t need it for the (now non-existent) local <a id="_idIndexMarker425"/>database, but we will need the ID on the server. It is a <a id="_idIndexMarker426"/>string because the server will create a <strong class="bold">Globally Unique </strong><span class="No-Break"><strong class="bold">ID</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">GUID</strong></span><span class="No-Break">).</span></p>
			<p><strong class="source-inline">[2]</strong> Each user can have any number <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">Buddies</strong></span><span class="No-Break">.</span></p>
			<p><strong class="source-inline">[3]</strong> Each user can send out any number <span class="No-Break">of invitations.</span></p>
			<p><strong class="source-inline">[4]</strong> Each user will have a list of <span class="No-Break"><strong class="source-inline">Preference</strong></span><span class="No-Break"> objects.</span></p>
			<p class="callout-heading">Commented-out code</p>
			<p class="callout">Note that the <strong class="source-inline">invitations</strong> property is commented out in the code present in the GitHub repository. Please <span class="No-Break">uncomment it.</span></p>
			<p>The <strong class="source-inline">Buddy</strong> class builds<a id="_idIndexMarker427"/> <span class="No-Break">on this:</span></p>
			<pre class="source-code">
public partial class Buddy : User
{
  [ObservableProperty] private string emailAddress;
  [ObservableProperty] private string? phoneNumber;
  [ObservableProperty] private string? mailingAddressLine1;
  [ObservableProperty] private string? mailingAddressLine2;
  [ObservableProperty] private string? website;
  [ObservableProperty] private string? twitter;
  [ObservableProperty] private string? facebook;
  [ObservableProperty] private string? instagram;
  [ObservableProperty] private string? linkedIn;
  [ObservableProperty] private string? venmoName;
  [ObservableProperty] private InvitationStatus status;
  [ObservableProperty] private List&lt;OccasionModel&gt;
    occasions;
  [ObservableProperty] private DateTime buddySince;
}</pre>
			<p class="callout-heading">Commented-out code</p>
			<p class="callout">For now, do not uncomment <strong class="source-inline">InvitationStatus</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">OccasionModel</strong></span><span class="No-Break">.</span></p>
			<p>We store a lot of information about each buddy, including how long they’ve been our buddy, shared occasions, and the status of the invitation we sent to the <span class="No-Break"><strong class="source-inline">Buddy</strong></span><span class="No-Break"> class.</span></p>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor194"/>Examining the API domain objects</h1>
			<p>The API domain objects are a<a id="_idIndexMarker428"/> superset of the <strong class="source-inline">client model</strong> classes. This is because there is data that the API will need that will not be visible on the client side. Right-click on <strong class="bold">ForgetMeNot.API.Domain</strong> and create the <span class="No-Break">following classes:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">InvitationStatus</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Invite</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Occasion</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Related</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Roles</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">User</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">UserPreference</strong></span></li>
			</ul>
			<p>Let’s walk through them, starting with <strong class="source-inline">User</strong> (note that this uses <strong class="source-inline">UserPreference</strong>, defined in the following code, so do not build until you have <span class="No-Break">both classes):</span></p>
			<pre class="source-code">
public class User
{
    public Guid Id { get; set; }
    public string FullName { get; set; }
    public string Email { get; set; }
    public string HashedPassword { get; set; }
    public bool IsEmailConfirmed { get; set; }
    public string Role { get; set; }
    public List&lt;UserPreference&gt; Preferences { get; set; }
}</pre>
			<p>As you can see, on the server, each <strong class="source-inline">User</strong> instance has a unique ID. Most of the other properties are the same as on the client, although they may not have the same identifier (for example, <strong class="source-inline">FullName</strong> rather than <strong class="source-inline">Name</strong>). This is not a problem, as we’ll do the mapping when we get the objects <a id="_idIndexMarker429"/>from <span class="No-Break">the server.</span></p>
			<p>There are a few new fields, however – for example, <strong class="source-inline">IsEmailConfirmed</strong>, <strong class="source-inline">HashedPassword</strong>, and <strong class="source-inline">Role</strong>. These are used by the server <span class="No-Break">for authentication.</span></p>
			<p>Let’s create the <strong class="source-inline">Roles</strong> file. It is a static class with the two roles <span class="No-Break">we’ll support:</span></p>
			<pre class="source-code">
public static class Roles
{
    public static string Admin = "admin";
    public static string User = "user";
}</pre>
			<p>Next, we’ll turn our attention to the <strong class="source-inline">UserPreference</strong> class. This corresponds to the <strong class="source-inline">Preference</strong> class in our client’s <span class="No-Break"><strong class="source-inline">Model</strong></span><span class="No-Break"> folder:</span></p>
			<pre class="source-code">
public class UserPreference
{
    public string PreferencePrompt { get; set; }
    public string PreferenceValue { get; set; }
}</pre>
			<p>Note that the API is, in some ways, independent of the client. We’re calling the class by a different name, and we’re not using the <span class="No-Break">code generators.</span></p>
			<p>Next, we need classes to represent <strong class="source-inline">Invitation</strong> and <strong class="source-inline">Occasion</strong>. Let’s start <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">Invitation</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class Invite
{
    public Invite()
    {
        Id = Guid.NewGuid();
    }
    public Guid Id { get; set; }
    public User CreatedByUser { get; set; }
    public User? AcceptedByUser { get; set; }
    public InvitationStatus Status { get; set; }
    public DateTime CreationDate { get; set; }
    public DateTime? EndDate { get; set; }
    public string InvitedUserName { get; set; }
    public string InvitedUserCustomMessage { get; set; }
}</pre>
			<p>This class has a property of the <strong class="source-inline">InvitationStatus</strong> type. Create a file for that as well. This is just<a id="_idIndexMarker430"/> <span class="No-Break">an enumeration:</span></p>
			<pre class="source-code">
public enum InvitationStatus
 {
     Waiting,
     Expired,
     Accepted,
     Rejected
 }</pre>
			<p>Here’s the <span class="No-Break"><strong class="source-inline">Occasion</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
public class Occasion
{
    public Occasion()
    {
        Id = Guid.NewGuid();
    }
    public Guid Id { get; set; }
    public User? ForUser { get; set; }
    public string? OccasionName { get; set; }
    public DateTime Date { get; set; }
    public int NumDaysToNotify { get; set; }
}</pre>
			<p>The purpose of <strong class="source-inline">NumDaysToNotify</strong> is to allow a user to designate how many days in advance of an occasion they want to be notified (that functionality is left as an exercise <span class="No-Break">for you!).</span></p>
			<p>Finally, we add a class whose job is to tie a user to all their <strong class="source-inline">Occasions</strong> and buddies. Note that we <a id="_idIndexMarker431"/>use <strong class="source-inline">User</strong> for <strong class="source-inline">Buddy</strong>, as the base class has all the information <span class="No-Break">we need:</span></p>
			<pre class="source-code">
public class Related
{
    public Related()
    {
        Occasions = new List&lt;Occasion&gt;();
        Users = new List&lt;User&gt;();
    }
    public Guid Id { get; set; }
    public string RelatedDescription { get; set; }
    public List&lt;User&gt; Users { get; set; }
    public List&lt;Occasion&gt; Occasions { get; set; }
    public DateTime Since { get; set; }
}</pre>
			<p>That’s it for that project. There are no methods; it really is just a set of server-based <span class="No-Break">model objects.</span></p>
			<p>Once we have the <a id="_idIndexMarker432"/>models, we need to determine how to transfer this data to and from the server. For that, we <span class="No-Break">need DTOs.</span></p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor195"/>Reviewing DTOs</h1>
			<p>The <strong class="source-inline">ForgetMeNot.Api.Dto</strong> project will, as you might have guessed, hold DTOs. These will correspond to the <a id="_idIndexMarker433"/>model objects but are designed to be passed back and forth between the server and <span class="No-Break">the client.</span></p>
			<p class="callout-heading">Project reference</p>
			<p class="callout">You will need to add a project reference from <strong class="source-inline">ForgetMeNot.Api.Dto</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">ForgetMeNot.Api.Domain</strong></span><span class="No-Break">.</span></p>
			<p>Let’s start <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">BuddyDto.cs</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
using ForgetMeNot.Api.Domain;
namespace ForgetMeNot.Api.Dto
{
    public class BuddyDto
    {
        public BuddyDto()
        {
        }
        public BuddyDto(User user)
        {
            UserId = user.Id;
            FullName = user.FullName;
            Email = user.Email;
            Preferences = new List&lt;UserPreference&gt;();
            if (user.Preferences?.Any(p =&gt;
                p.PreferenceValue != null) ?? false)
            {
                Preferences = user.Preferences.Where(p =&gt;
                    p.PreferenceValue != null).ToList();
            }
            Occasions = new List&lt;OccasionDto&gt;();
        }
        public Guid UserId { get; set; }
        public string FullName { get; set; }
        public string Email { get; set; }
        public List&lt;UserPreference&gt; Preferences { get; set; }
        public List&lt;OccasionDto&gt; Occasions { get; set; }
    }
}</pre>
			<p>Note that the<a id="_idIndexMarker434"/> constructor for <strong class="source-inline">Buddy</strong> takes <strong class="source-inline">User</strong>. As noted earlier, the <strong class="source-inline">Buddy</strong> class derives from <strong class="source-inline">User</strong>, and by passing <strong class="source-inline">User</strong> into the constructor, we can set <strong class="source-inline">Buddy</strong>’s <span class="No-Break"><strong class="source-inline">User</strong></span><span class="No-Break"> properties.</span></p>
			<p>Note that we are also using a list of <strong class="source-inline">OccasionDto</strong> objects. These are in the <span class="No-Break"><strong class="source-inline">ForgetMeNot.Api.Dto</strong></span><span class="No-Break"> project.</span></p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor196"/>Other DTO files</h2>
			<p>The other key files in <strong class="source-inline">ForgetMeNot.Api.Dto</strong> are not tied to model classes but, rather, are data that is <a id="_idIndexMarker435"/>exchanged between client and server to facilitate managing the account – for <span class="No-Break">example, </span><span class="No-Break"><strong class="source-inline">AccountCreateRequest</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class AccountCreateRequest
{
    public string FullName { get; set; }
    public string Email { get; set; }
    public string PlainPassword { get; set; }
}</pre>
			<p>This is all that needs to be sent to the server when creating an account. There is a DTO to request an update to a user record that just contains <strong class="source-inline">Id</strong>, <strong class="source-inline">FullName</strong>, and <strong class="source-inline">Email</strong>. One important DTO is <strong class="source-inline">UserResponse</strong>, which contains information that corresponds to the <strong class="source-inline">User </strong><span class="No-Break"><strong class="source-inline">Domain</strong></span><span class="No-Break"> object:</span></p>
			<pre class="source-code">
public class UserResponse
{
  public Guid Id { get; set; }
  public string FullName { get; set; }
  public string Email { get; set; }
  public bool IsEmailConfirmed { get; set; }
  public string Role { get; set; }
  public List&lt;UserPreference&gt; Preferences { get; set; }
  public UserResponse()
  {
  }
  public UserResponse(User user)
  {
    Id = user.Id;
    FullName = user.FullName;
    Email = user.Email;
    Role = user.Role;
    IsEmailConfirmed = user.IsEmailConfirmed;
    Preferences = user.Preferences;
  }
}</pre>
			<p>You pass in a <strong class="source-inline">User</strong> object and <strong class="source-inline">UserResponse</strong> turns it into <span class="No-Break">a DTO.</span></p>
			<p>Similarly, you can <a id="_idIndexMarker436"/>pass a <strong class="source-inline">User</strong> object into <strong class="source-inline">ProfileResponse</strong> and get back a <span class="No-Break"><strong class="source-inline">ProfileResponse</strong></span><span class="No-Break"> DTO:</span></p>
			<pre class="source-code">
public class ProfileResponse
{
  public Guid Id { get; set; }
  public string FullName { get; set; }
  public string Email { get; set; }
  public bool IsEmailConfirmed { get; set; }
  public string Role { get; set; }
  public List&lt;UserPreference&gt; Preferences { get; set; }
  public ProfileResponse(User user)
  {
    Id = user.Id;
    FullName = user.FullName;
    Email = user.Email;
    Role = user.Role;
    IsEmailConfirmed = user.IsEmailConfirmed;
    Preferences = user.Preferences;
  }
}</pre>
			<p>The final piece in the<a id="_idIndexMarker437"/> puzzle is to wrap the API in a client-side class to facilitate interactions with data in <span class="No-Break">the cloud.</span></p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor197"/>Understanding ForgetMeNot.APIClient</h1>
			<p>The third API project, <strong class="source-inline">ForgetMeNot.APIClient</strong>, has only one class in it – <strong class="source-inline">Client.cs</strong>. This is the wrapper <a id="_idIndexMarker438"/>of the REST service that the client (<strong class="source-inline">ForgetMeNotDemo</strong>) will <span class="No-Break">interact with.</span></p>
			<p>We start with four <span class="No-Break">member variables:</span></p>
			<pre class="source-code">
public class Client
{
    RestClient client; [1]
    string baseUrl;   [2]
    string username;   [3]
    string password;</pre>
			<p><strong class="source-inline">[1]</strong> As noted earlier, <strong class="source-inline">RestClient</strong> is the library we are using to manage the REST interactions (obtained through NuGet, as <span class="No-Break">discussed earlier).</span></p>
			<p><strong class="source-inline">[2]</strong> <strong class="source-inline">baseURL</strong> is the prefix<a id="_idIndexMarker439"/> for all the API calls and was created when we moved the API to Azure. As noted earlier, it is available <span class="No-Break">at </span><a href="https://forgetmenotapi20230113114628.azurewebsites.net/"><span class="No-Break">https://forgetmenotapi20230113114628.azurewebsites.net/</span></a><span class="No-Break">.</span></p>
			<p><strong class="source-inline">[3]</strong> <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong> are used by the client to access the <span class="No-Break">user’s record.</span></p>
			<p>The constructor to <strong class="source-inline">Client</strong> takes <strong class="source-inline">baseUrl</strong>, assigns it to the field, and then <span class="No-Break">calls </span><span class="No-Break"><strong class="source-inline">SetClient()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public Client(string baseUrl)
{
    this.baseUrl = baseUrl;
    SetClient();
}
void SetClient()
{
    var options = new RestClientOptions(baseUrl)  [1]
    {
        ThrowOnAnyError = false,
        MaxTimeout = 10000
    };
    client = new RestClient(options); [2]
}</pre>
			<p><strong class="source-inline">[1]</strong> The options we want for this REST client create a robust interface; we won’t throw an exception on any error and we won’t time out for <span class="No-Break">10 seconds.</span></p>
			<p><strong class="source-inline">[2]</strong> With the options set, we can create a new <strong class="source-inline">RestClient</strong>, which is defined <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">RestSharp</strong></span><span class="No-Break">.</span></p>
			<p>The rest of the file is divided into <a id="_idIndexMarker440"/>sections for important behavior by the client, beginning with the code needed to authenticate <span class="No-Break">the user.</span></p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor198"/>Authentication</h2>
			<p>We set a <strong class="source-inline">IsAuthenticated</strong> property, which is <a id="_idIndexMarker441"/>set to whether or not <strong class="source-inline">client.Authenticator</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break">.</span></p>
			<p>We then have a <strong class="source-inline">Login</strong> method that takes a <strong class="source-inline">LoginRequest</strong> object, sets <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong>, and <span class="No-Break">calls </span><span class="No-Break"><strong class="source-inline">Authenticate</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public async Task Login(LoginRequest request)
{
    username = request.Username;
    password = request.Password;
    await Authenticate();
}</pre>
			<p class="callout-heading">Project reference</p>
			<p class="callout">You will need a reference to the <span class="No-Break">DTO project.</span></p>
			<p><strong class="source-inline">LoginRequest</strong> is defined in the DTO project and simply has two string properties, <strong class="source-inline">Username</strong> and <strong class="source-inline">Password</strong> (refer to the following <span class="No-Break">code block).</span></p>
			<p>The <strong class="source-inline">Authenticate</strong> method<a id="_idIndexMarker442"/> uses <strong class="source-inline">RestSharp</strong>’s OAuth authentication – that is, again, the heavy lifting is done <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">RestSharp</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
async Task Authenticate()
{
    var request = new RestRequest("auth/gettoken");
    request.AddBody(new { username, password });
    var accessToken = await client.PostAsync&lt;string&gt;
        (request);
    client.Authenticator = new OAuth2Authorization
        RequestHeaderAuthenticator(accessToken, "Bearer");
}</pre>
			<p>Fortunately, you don’t need to understand how to make this work; you just pass in the username and password and <strong class="source-inline">RestSharp</strong> takes care of the rest of it <span class="No-Break">for you.</span></p>
			<p class="callout-heading">Client versus client</p>
			<p class="callout">Remember that even though you are in the <strong class="source-inline">Client</strong> class, the <strong class="source-inline">client</strong> field is the <span class="No-Break"><strong class="source-inline">RestSharp</strong></span><span class="No-Break"> object.</span></p>
			<p>We have a helper method to get the current <span class="No-Break">API version:</span></p>
			<pre class="source-code">
public Task&lt;string?&gt; Version()
{
    var request = new RestRequest("util/version");
    return client.GetAsync&lt;string?&gt;(request);
}</pre>
			<p>And that takes us to the<a id="_idIndexMarker443"/> profile section of the file, where we can get and update the <span class="No-Break"><strong class="source-inline">profile</strong></span><span class="No-Break"> object.</span></p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor199"/>Profile</h2>
			<p>There are two methods<a id="_idIndexMarker444"/> needed for the profile. The first gets <span class="No-Break">the profile:</span></p>
			<pre class="source-code">
public Task&lt;ProfileResponse?&gt; GetProfile()
{
    var request = new RestRequest("profile/me");
    return client.GetAsync&lt;ProfileResponse?&gt;(request);
}</pre>
			<p>This uses the <strong class="source-inline">ProfileResponse</strong> DTO we examined earlier. The second method in this section is used to update <span class="No-Break">the profile:</span></p>
			<pre class="source-code">
public Task UpdateProfile(ProfileUpdateRequest
    profileUpdateRequest)
{
    var request = new RestRequest("profile/me");
    request.AddBody(profileUpdateRequest);
    return client.PutAsync(request);
}</pre>
			<p>This code uses the <strong class="source-inline">ProfileUpdateRequest</strong> object defined <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">ForgetMeNot.Api.Dto</strong></span><span class="No-Break">.</span></p>
			<p>Again, all the interesting work here is being done by <strong class="source-inline">RestSharp</strong>. As you can see, the client is really just a <a id="_idIndexMarker445"/>wrapper around the <span class="No-Break"><strong class="source-inline">RestSharp</strong></span><span class="No-Break"> methods.</span></p>
			<p>Let’s reinforce this by looking at a couple more methods that are used to manage the <span class="No-Break"><strong class="source-inline">Buddy</strong></span><span class="No-Break"> object.</span></p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor200"/>The Buddy region</h2>
			<p>This region consists of the <a id="_idIndexMarker446"/>methods we need to interact with buddies, <strong class="source-inline">GetBuddy</strong> and <strong class="source-inline">CreateInvitation</strong>. <strong class="source-inline">GetBuddy</strong> returns a list of <span class="No-Break"><strong class="source-inline">BuddyDto</strong></span><span class="No-Break"> objects:</span></p>
			<pre class="source-code">
public Task&lt;List&lt;BuddyDto&gt;?&gt; GetBuddy()
{
    var request = new RestRequest("buddy");
    return client.GetAsync&lt;List&lt;BuddyDto&gt;?&gt;(request);
}</pre>
			<p><strong class="source-inline">CreateInvitation</strong> returns <strong class="source-inline">Guid</strong>, which is the <strong class="source-inline">Id</strong> attribute of the resulting <span class="No-Break"><strong class="source-inline">Invitation</strong></span><span class="No-Break"> object:</span></p>
			<pre class="source-code">
public Task&lt;Guid?&gt; CreateInvitation(InviteCreateRequest
  inviteCreateRequest)
{
    var request = new RestRequest("buddy/invite");
    request.AddBody(inviteCreateRequest);
    return client.PostAsync&lt;Guid?&gt;(request);
}</pre>
			<p>This code uses <strong class="source-inline">InviteCreateRequest</strong>, which is defined <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">ForgetMeNot.Api.Dto</strong></span><span class="No-Break">.</span></p>
			<p>Finally, we have a method to get all the users – that is, all this <span class="No-Break">user’s buddies:</span></p>
			<pre class="source-code">
public Task&lt;List&lt;UserResponse&gt;?&gt; GetUserList()
{
    var request = new RestRequest("user");
    return client.GetAsync&lt;List&lt;UserResponse&gt;?&gt;(request);
}</pre>
			<p>What we get back is a list of <strong class="source-inline">UserResponse</strong> DTO objects that we <span class="No-Break">saw earlier.</span></p>
			<p>Now that we’ve examined<a id="_idIndexMarker447"/> all the projects provided by the server, we are ready to have <strong class="source-inline">ForgetMeNotDemo</strong> interact with the API to get, store, and <span class="No-Break">retrieve data.</span></p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor201"/>Using the API</h1>
			<p>With the <strong class="source-inline">Client</strong> class and its supporting <strong class="source-inline">DTO</strong> and <strong class="source-inline">API</strong> domain classes in place, we’re ready to interact with the API to <a id="_idIndexMarker448"/>create accounts and log in, as well as store and retrieve <span class="No-Break">our preferences.</span></p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor202"/>Creating the account</h2>
			<p>The first thing a new user will do is create an account. To make this work, we need to bring the user to the <strong class="bold">Login</strong> page when<a id="_idIndexMarker449"/> the app starts. Here, the user can log in, or if they don’t have an account, they can click on <strong class="bold">Create Account</strong>, which will take them to <strong class="source-inline">CreateAccount.xaml</strong>, where they can fill in their name, email, and password. To implement this, we have to make some substantial changes to the <strong class="bold">Login</strong> and <strong class="bold">Create </strong><span class="No-Break"><strong class="bold">Account</strong></span><span class="No-Break"> pages.</span></p>
			<p>Let’s begin by pointing the application to start with login. Modify the <strong class="source-inline">App.xaml.cs</strong> <strong class="source-inline">App</strong> method to look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
public App(LoginViewModel loginViewModel) [1]
{
  InitializeComponent();
  MainPage = new LoginPage(loginViewModel); [2]
}</pre>
			<p><strong class="source-inline">[1]</strong> Have the IoC container pass in an instance <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">LoginViewModel</strong></span><span class="No-Break">.</span></p>
			<p><strong class="source-inline">[2]</strong> Set <strong class="source-inline">MainPage</strong> (the entry point to the program) <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">LoginPage</strong></span><span class="No-Break">.</span></p>
			<p>The job of the <strong class="bold">Login</strong> page will <a id="_idIndexMarker450"/>now be to either allow the user to log in or take them to the <strong class="bold">Create </strong><span class="No-Break"><strong class="bold">Account</strong></span><span class="No-Break"> page.</span></p>
			<p>Be sure to add routing for <strong class="source-inline">CreateAccount</strong> <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">AppShell.xaml.cs</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
Routing.RegisterRoute("createaccount",
  typeof(CreateAccountPage));</pre>
			<p>Next, let’s modify the <span class="No-Break"><strong class="bold">Login</strong></span><span class="No-Break"> page.</span></p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor203"/>Modifying the Login page</h2>
			<p>Now that we’re going to turn<a id="_idIndexMarker451"/> management of authentication over to the server, we need a different <strong class="bold">Login</strong> page. Completely empty out <strong class="source-inline">LoginPage.xaml.cs</strong> and replace it with this <span class="No-Break">simple version:</span></p>
			<pre class="source-code">
using CommunityToolkit.Maui.Core.Views;
using ForgetMeNotDemo.ViewModel;
namespace ForgetMeNotDemo.View;
public partial class LoginPage : ContentPage
{
  public LoginPage(LoginViewModel viewModel)
  {
    BindingContext = viewModel;
    InitializeComponent();
  }
}</pre>
			<p><strong class="source-inline">LoginViewModel</strong> is passed in from <strong class="source-inline">App</strong>, as shown in the <span class="No-Break">preceding code.</span></p>
			<p>Now, let’s modify <strong class="source-inline">LoginPage</strong> to focus on<a id="_idIndexMarker452"/> either logging a user in or redirecting them to create a <span class="No-Break">new account.</span></p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor204"/>Updating LoginPage</h2>
			<p>We’re going to make some <a id="_idIndexMarker453"/>significant changes to <strong class="source-inline">LoginPage</strong>. To avoid confusion, delete all you have there and replace it <span class="No-Break">with this:</span></p>
			<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;ContentPage
    x:Class="ForgetMeNot.View.LoginPage"
    xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
    xmlns:iOsSpecific="clr-namespace:Microsoft.Maui
      .Controls.PlatformConfiguration.iOSSpecific;
        assembly=Microsoft.Maui.Controls"
    Title="Login"
    iOsSpecific:Page.UseSafeArea="True"
    Shell.NavBarIsVisible="False"
    Shell.PresentationMode="ModalAnimated"&gt;
    &lt;ContentPage.Resources&gt;
        &lt;ResourceDictionary&gt;
            &lt;Style x:Key="Prompt" TargetType="Label"&gt;   [1]
              &lt;Setter Property="TextColor" Value="Black" /&gt;
              &lt;Setter Property="FontSize" Value="Medium" /&gt;
              &lt;Setter Property="FontAttributes"
                  Value="Bold" /&gt;
                &lt;Setter Property="HorizontalTextAlignment"
                  Value="Center" /&gt;
                &lt;Setter Property="VerticalTextAlignment"
                  Value="Center" /&gt;
                &lt;Setter Property="VerticalOptions"
                  Value="Center" /&gt;
                &lt;Setter Property="HorizontalOptions"
                  Value="End" /&gt;
            &lt;/Style&gt;
            &lt;Style x:Key="LoginButton" TargetType="Button"&gt;
              &lt;Setter Property="BackgroundColor"
                Value="LightGray" /&gt;
              &lt;Setter Property="Margin" Value="0,20,0,0" /&gt;
              &lt;Setter Property="TextColor" Value="Black" /&gt;
             &lt;Setter Property="WidthRequest" Value="125" /&gt;
            &lt;/Style&gt;
        &lt;/ResourceDictionary&gt;
    &lt;/ContentPage.Resources&gt;</pre>
			<p>With the styles in place, we’re<a id="_idIndexMarker454"/> ready to create the <strong class="source-inline">Labels</strong> and <strong class="source-inline">Entry</strong> controls to get a user’s name <span class="No-Break">and password:</span></p>
			<pre class="source-code">
&lt;VerticalStackLayout&gt;
        &lt;Grid
            ColumnDefinitions="*,*,*"
            RowDefinitions="Auto,Auto,Auto,Auto"
            RowSpacing="10"&gt;
            &lt;Label
                Grid.Row="0"
                Grid.Column="0"
                Style="{StaticResource Prompt}"
                Text="User name" /&gt;
            &lt;Entry
                Grid.Row="0"
                Grid.Column="1"
                Grid.ColumnSpan="2"
                Placeholder="User name"
                Text="{Binding LoginName}"
                WidthRequest="150" /&gt;
            &lt;Label
                Grid.Row="1"
                Grid.Column="0"
                HorizontalOptions="End"
                Style="{StaticResource Prompt}"
                Text="Password" /&gt;
            &lt;Entry
                Grid.Row="1"
                Grid.Column="1"
                Grid.ColumnSpan="2"
                IsPassword="True"
                Placeholder="Password"
                Text="{Binding Password}"
                WidthRequest="150" /&gt;
            &lt;Button
                Grid.Row="2"
                Grid.Column="0"
                Command="{Binding DoLoginCommand}"
                Style="{StaticResource LoginButton}"
                Text="Submit" /&gt;  [2]</pre>
			<p>Once a user has filled in the<a id="_idIndexMarker455"/> fields (or is unable to do so because they’ve forgotten their password), we will offer them the <span class="No-Break">following choices:</span></p>
			<pre class="source-code">
             &lt;Button
                Grid.Row="2"
                Grid.Column="1"
                Command="{Binding DoCreateAccountCommand}"
                Style="{StaticResource LoginButton}"
                Text="Create Account" /&gt; [3]
            &lt;Button
                Grid.Row="2"
                Grid.Column="2"
                BackgroundColor="LightGray"
                Command="{Binding ForgotPasswordCommand}"
                Style="{StaticResource LoginButton}"
                Text="Forgot Password" /&gt; [4]
        &lt;/Grid&gt;
        &lt;ActivityIndicator  [6]
            x:Name="activityIndicator"
            HeightRequest="50"
            IsRunning="{Binding ShowActivityIndicator}"
            Color="Blue" /&gt;
    &lt;/VerticalStackLayout&gt;
&lt;/ContentPage&gt;</pre>
			<p><strong class="source-inline">[1]</strong> I’ve expanded the two <a id="_idIndexMarker456"/>styles a bit to minimize the styling in <span class="No-Break">the controls.</span></p>
			<p><strong class="source-inline">[2]</strong> Click <strong class="bold">Submit</strong> to submit the username and password to the API (as we’ll see in <strong class="source-inline">ViewModel</strong> a <span class="No-Break">little later).</span></p>
			<p><strong class="source-inline">[3]</strong> Click <strong class="bold">Create Account</strong> to go to the <span class="No-Break"><strong class="source-inline">CreateAccount</strong></span><span class="No-Break"> page.</span></p>
			<p><strong class="source-inline">[4]</strong> Forgot password is (as they say) left as an exercise <span class="No-Break">for you.</span></p>
			<p>With this new API-oriented <strong class="bold">Login</strong> page, we need to <span class="No-Break">update </span><span class="No-Break"><strong class="source-inline">LoginViewModel</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor205"/>The AccountService class</h2>
			<p>Before updating <strong class="source-inline">LoginViewModel</strong>, we’ll need <a id="_idIndexMarker457"/>to create the <strong class="source-inline">AccountService</strong> class and its <span class="No-Break">associated interface:</span></p>
			<pre class="source-code">
using ForgetMeNot.Api.Dto;
using ForgetMeNot.ApiClient;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace ForgetMeNotDemo.Services
{
  public class AccountService : IAccountService
  {
    readonly Client apiClient;
    public AccountService(Client apiClient)
    {
      this.apiClient = apiClient;
    }
    public async Task CreateAccount(AccountCreateRequest
      accountCreateRequest)
    {
      await apiClient.CreateAccount(accountCreateRequest);
    }
    public async Task GetNewPassword()
    {
    }
    public async Task Login(LoginRequest request)
    {
      await apiClient.Login(request);
    }
    public bool IsLoggedIn()
    {
      return apiClient.IsAuthenticated;
    }
  }
}</pre>
			<p>This class is used in the creation <a id="_idIndexMarker458"/>and authentication of the account. With this in place, we are ready to <span class="No-Break">update </span><span class="No-Break"><strong class="source-inline">LoginViewModel</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor206"/>Updating LoginViewModel</h2>
			<p><strong class="source-inline">LoginViewModel</strong> must be updated to meet the<a id="_idIndexMarker459"/> new requirements of the updated <strong class="source-inline">LoginPage</strong> class. Once again, delete all that you have and replace it <span class="No-Break">with this:</span></p>
			<pre class="source-code">
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using ForgetMeNot.API.Dto;
using ForgetMeNotDemo.Services;
using ForgetMeNotDemo;
namespace ForgetMeNotDemo.ViewModel
{
  [ObservableObject]
  public partial class LoginViewModel
  {
    private AccountService;           [1]
    [ObservableProperty] private string loginName;
    [ObservableProperty] private string password;
    [ObservableProperty] private bool showActivityIndicator
      = false;</pre>
			<p>The constructor is <a id="_idIndexMarker460"/>passed by <strong class="source-inline">AccountService</strong> by way of the <strong class="bold">Inversion of Control</strong> (<strong class="bold">IoC</strong>) container and holds <a id="_idIndexMarker461"/>onto that service for its <span class="No-Break">other methods:</span></p>
			<pre class="source-code">
    public LoginViewModel(AccountService accountService)
      [2]
    {
      this.accountService = accountService;
    }
    [RelayCommand]
    public async Task DoLogin()
    {
      try
      {
        LoginRequest loginRequest = new LoginRequest [3]
        {
          Username = LoginName,
          Password = Password
        };</pre>
			<p>We’ll set <strong class="source-inline">ActivityIndicator</strong> to display<a id="_idIndexMarker462"/> while we ask the API to log a <span class="No-Break">user in:</span></p>
			<pre class="source-code">
        ShowActivityIndicator = true;
        await accountService.Login(loginRequest); [4]
        ShowActivityIndicator = false;
        if (accountService.IsLoggedIn()) [5]
        {
          Application.Current.MainPage = new AppShell();
          await Shell.Current.GoToAsync("mainpage");
        }
        else [6]
        {
          await Application.Current.MainPage.DisplayAlert
            ("Login failure",
              "Your username and password do not match our
                records", "Ok");
        }
      }
      catch (Exception exception)
      {
        await Application.Current.MainPage.DisplayAlert
          ("Authorization failure",
            "Your username and password do not match our
              records", "Ok");
        Console.WriteLine(exception);
      }</pre>
			<p>Implementing the logic to<a id="_idIndexMarker463"/> manage a forgotten password is left as an exercise <span class="No-Break">for you:</span></p>
			<pre class="source-code">
    }
    [RelayCommand]
    public async Task ForgotPassword()
    {
[7]
    }</pre>
			<p>We delegate to the server the responsibility for creating <span class="No-Break">new accounts:</span></p>
			<pre class="source-code">
    [RelayCommand]
    public async Task DoCreateAccount() [8]
    {
      try
      {
        Application.Current.MainPage = new AppShell();
        await Shell.Current.GoToAsync($"createaccount");
      }
      catch (Exception e)
      {
        Console.WriteLine(e);
      }
    }
  }
}</pre>
			<p><strong class="source-inline">[1]</strong> We create the <strong class="source-inline">AccountService</strong> field, which will mediate between <strong class="source-inline">ViewModel</strong> and the <span class="No-Break"><strong class="source-inline">Client</strong></span><span class="No-Break"> class.</span></p>
			<p><strong class="source-inline">[2]</strong> The IoC passes in the <strong class="source-inline">AccountService</strong> we need, which we will assign to the <strong class="source-inline">AccountService</strong> member <a id="_idIndexMarker464"/>we <span class="No-Break">just created.</span></p>
			<p><strong class="source-inline">[3]</strong> We bundle up the username and password into a <strong class="source-inline">LoginRequest</strong> object. We get this class <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">ForgetMeNot.API.DTO</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class LoginRequest
{
    public string Username { get; set; }
    public string Password { get; set; }
}</pre>
			<p><strong class="source-inline">[4]</strong> We turn <strong class="source-inline">ActivityIndicator</strong> on, pass <strong class="source-inline">LoginRequest</strong> to the API, and then, when we get a response, turn <strong class="source-inline">ActivityIndicator</strong> off. We’ll look at what <strong class="source-inline">AccountService</strong> is actually doing in the <span class="No-Break">next step.</span></p>
			<p><strong class="source-inline">[5]</strong> We ask <strong class="source-inline">AccountService</strong> whether the login was successful. If it was (the happy path), we reset <strong class="source-inline">MainPage</strong> (away from <strong class="source-inline">LoginPage</strong>) and <span class="No-Break">navigate there.</span></p>
			<p><strong class="source-inline">[6]</strong> If login fails (the sad path), we inform the user that we are unable to log them in and give them another chance to <span class="No-Break">do so.</span></p>
			<p><strong class="source-inline">[7]</strong> This book will not<a id="_idIndexMarker465"/> implement the code to reset <span class="No-Break">a password.</span></p>
			<p><strong class="source-inline">AccountService</strong> was responsible for the login. Let’s look at <span class="No-Break">that next.</span></p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor207"/>Using AccountService to log in</h2>
			<p>For security purposes, we want a server to be responsible for authenticating a user based on an email address <span class="No-Break">and </span><span class="No-Break"><a id="_idIndexMarker466"/></span><span class="No-Break">password:</span></p>
			<pre class="source-code">
public async Task Login(LoginRequest request) [1]
{
  await apiClient.Login(request);
}
public bool IsLoggedIn() [2]
{
  return apiClient.IsAuthenticated;
}</pre>
			<p>Among other methods in <strong class="source-inline">AccountService</strong> (which we will return to shortly) are the following <span class="No-Break">two methods:</span></p>
			<p><strong class="source-inline">[1]</strong> Login simply delegates to <strong class="source-inline">apiClient</strong> the responsibility to handle the <em class="italic">login</em> through the <em class="italic">API</em>, passing in <strong class="source-inline">LoginRequest</strong>, which contains the username <span class="No-Break">and password.</span></p>
			<p><strong class="source-inline">[2]</strong> Similarly, the <strong class="source-inline">IsLoggedIn</strong> Boolean method uses <strong class="source-inline">apiClient</strong> to see whether the current user <span class="No-Break">is </span><span class="No-Break"><em class="italic">authenticated</em></span><span class="No-Break">.</span></p>
			<p>A second option exists for a user, which is to tap on the <strong class="bold">Create Account</strong> button. This brings us <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">CreateAccountPage</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor208"/>Setting up the Create Account page</h2>
			<p>The <strong class="bold">Create Account</strong> page prompts a user for a username and a password, as well as their email. To keep things simple, in this <a id="_idIndexMarker467"/>example, we only ask for the password once, but we do <span class="No-Break">implement validation:</span></p>
			<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;ContentPage
    x:Class="ForgetMeNotDemo.View.CreateAccountPage"
    xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
    xmlns:behaviors="http://schemas.microsoft.com/dotnet/
      2022/maui/toolkit"
    Title="CreateAccount"&gt;
    &lt;VerticalStackLayout&gt;
        &lt;Entry
            HorizontalOptions="FillAndExpand"
            Keyboard="Text"
            Placeholder="Enter Name"
            Text="{Binding Name}"&gt;
            &lt;Entry.Behaviors&gt;
                &lt;behaviors:UserStoppedTypingBehavior
      <a id="_idTextAnchor209"/>          Command="{Binding  ValidateNameCommand}"
                StoppedTypingTimeThreshold="500" /&gt;  [1]
            &lt;/Entry.Behaviors&gt;
        &lt;/Entry&gt;</pre>
			<p><strong class="source-inline">[1]</strong> We use the Community Toolkit’s <strong class="source-inline">StoppedTypingBehavior</strong> to detect when a user has finished entering a field. We set <strong class="source-inline">StoppedTypingTimeThreshold</strong> to <strong class="source-inline">500</strong> – that is, half a second. This indicates that once the user has not entered anything for half a second, we assume <a id="_idIndexMarker468"/>they are done and kick in the validation. Note that the command is set to <strong class="source-inline">ValidateNameCommand</strong>. This is handled in <strong class="source-inline">ViewModel</strong> (as shown later) but returns a Boolean, which indicates whether or not the user has entered a <span class="No-Break">valid name:</span></p>
			<pre class="source-code">
        &lt;Label
            FontSize="13"
            IsVisible="{Binding ShowNameErrorMessage}"
              [1]
            Text="{Binding NameErrorMessage}"
            TextColor="Red" /&gt;
        &lt;Entry
            HorizontalOptions="FillAndExpand"
            Keyboard="Email"
            Placeholder="Enter Email"
            Text="{Binding Email}"&gt;
            &lt;Entry.Behaviors&gt;
                &lt;behaviors:UserStoppedTypingBehavior
                  Command="{Binding ValidateEmailCommand}"
                    StoppedTypingTimeThreshold="500" /&gt;
                      [2]
            &lt;/Entry.Behaviors&gt;
        &lt;/Entry&gt;</pre>
			<p><strong class="source-inline">[1]</strong> Only show the label if the name <span class="No-Break">validation fails.</span></p>
			<p><strong class="source-inline">[2]</strong> Now, do the same for email as<a id="_idIndexMarker469"/> you did for the name, calling <strong class="source-inline">ValidateEmailCommand</strong> when the user <span class="No-Break">stops typing:</span></p>
			<pre class="source-code">
        &lt;Label
            FontSize="13"
            IsVisible="{Binding ShowEmailErrorMessage}"
            Text="{Binding EmailErrorMessage}"
            TextColor="Red" /&gt;
        &lt;Entry
            HorizontalOptions="FillAndExpand"
            IsPassword="True"   [1]
            Keyboard="Default"
            Placeholder="Enter Password"
            Text="{Binding Password}"&gt;
            &lt;Entry.Behaviors&gt;
                &lt;behaviors:UserStoppedTypingBehavior
                Command="{Binding ValidatePasswordCommand}"
                  StoppedTypingTimeThreshold="500" /&gt;
            &lt;/Entry.Behaviors&gt;
        &lt;/Entry&gt;
        &lt;Label
            FontSize="13"
            IsVisible="{Binding ShowPasswordErrorMessage}"
            Text="{Binding PasswordErrorMessage}"
            TextColor="Red" /&gt;
        &lt;Button
            Margin="0,30,0,0"
            BackgroundColor="LightGray"
            Command="{Binding SignUpCommand}" [2]
            CornerRadius="5"
            HorizontalOptions="Center"
            IsEnabled="{Binding EnableButton}"
            Text="Sign up"
            TextColor="Black"
            TextTransform="None"
            WidthRequest="100" /&gt;
    &lt;/VerticalStackLayout&gt;
&lt;/ContentPage&gt;</pre>
			<p><strong class="source-inline">[1]</strong> The <strong class="source-inline">IsPassword</strong> property of the entry is set to <strong class="source-inline">true</strong>, and the password will be displayed as a series of asterisks <a id="_idIndexMarker470"/>as a user enters <span class="No-Break">a character.</span></p>
			<p><strong class="source-inline">[2]</strong> Once the fields are valid, the <strong class="bold">Signup</strong> Button will be enabled, and tapping it will invoke the <span class="No-Break"><strong class="source-inline">Signup</strong></span><span class="No-Break"> command.</span></p>
			<p>All of the supporting commands and validation are <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">CreateAccountViewModel</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor210"/>Setting up CreateAccountViewModel</h2>
			<p>The first thing we see in this file are<a id="_idIndexMarker471"/> all <span class="No-Break">the properties:</span></p>
			<pre class="source-code">
[ObservableProperty] accountService;
[ObservableProperty] private string name;
[ObservableProperty] private string email;
[ObservableProperty] private string password;
[ObservableProperty] private string nameErrorMessage;
[ObservableProperty] private string emailErrorMessage;
[ObservableProperty] private string passwordErrorMessage;
[ObservableProperty] private bool showNameErrorMessage;
[ObservableProperty] private bool showEmailErrorMessage;
[ObservableProperty] private bool showPasswordErrorMessage;
[ObservableProperty] private bool enableButton;
[ObservableProperty] private bool isValidName;
[ObservableProperty] private bool isValidEmail;
[ObservableProperty] private bool isValidPassword;</pre>
			<p>Note that there are properties for the error messages along with the prompts. There is also a Boolean<a id="_idIndexMarker472"/> property, <strong class="source-inline">EnableButton</strong>, which defaults to <strong class="source-inline">false</strong> (if you don’t set a Boolean, it defaults <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">).</span></p>
			<p>The constructor takes <strong class="source-inline">AccountService</strong>, passed in by the IoC (this was registered in <strong class="source-inline">MauiProgram.cs</strong>). Update the Client constructor to take a string serving <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">baseUrl</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
var apiClient = new Client("https://forgetmenotapi
  20230113114628.azurewebsites.net/");
builder.Services.AddSingleton(apiClient);
builder.Services.AddTransient&lt;AccountService&gt;();</pre>
			<p>We’ll turn to the <span class="No-Break"><strong class="source-inline">CreateAccountViewModel</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
public CreateAccountViewModel(AccountService
  accountService)
{
  this.accountService = accountService;
}</pre>
			<p>Let’s examine a <span class="No-Break"><strong class="source-inline">Validation</strong></span><span class="No-Break"> method.</span></p>
			<p>The business requirement is<a id="_idIndexMarker473"/> that a valid name has at least two characters. The code to validate is a simple <strong class="source-inline">if</strong> statement, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
[RelayCommand]
public Task ValidateName()
{
  if (!string.IsNullOrEmpty(Name) &amp;&amp; Name.Length &gt;= 2)
  {
    IsValidName = true;
    ShowNameErrorMessage = false;
    EnableButton = IsValidName &amp;&amp; IsValidEmail &amp;&amp;
      IsValidPassword; [1]
  }
  else
  {
    NameErrorMessage = "*Please enter a name with at least
      two characters";
    IsValidName = false;
    ShowNameErrorMessage = true;  [2]
    EnableButton = IsValidName &amp;&amp; IsValidEmail &amp;&amp;
      IsValidPassword;
  }
  return Task.CompletedTask;
}</pre>
			<p><strong class="source-inline">[1]</strong> The <strong class="source-inline">EnableButton</strong> property (which is used to determine whether the <strong class="bold">Submit</strong> button is enabled) is only<a id="_idIndexMarker474"/> set as <strong class="source-inline">true</strong> when the name, email, and password are <span class="No-Break">all valid.</span></p>
			<p><strong class="source-inline">[2]</strong> If the name is not valid, the <strong class="source-inline">ShowNameErrorMessage</strong> property is set to <strong class="source-inline">true</strong>, and the error message <span class="No-Break">is displayed.</span></p>
			<p>In the next chapter, we’ll look at the support that .NET MAUI provides for a more elegant <span class="No-Break">validation approach.</span></p>
			<p>The most important command in this file is the one that responds <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">SignUpCommand</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor211"/>Handling the SignUp command</h2>
			<p>The <strong class="source-inline">SignUp</strong> method checks to <a id="_idIndexMarker475"/>ensure that the fields are<a id="_idIndexMarker476"/> valid (by making sure <strong class="source-inline">EnableButton</strong> is true) and then creates an <strong class="source-inline">AccountCreateRequest</strong> object, which is defined <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">ForgetMeNot.Api.Dto</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class AccountCreateRequest
{
    public string FullName { get; set; }
    public string Email { get; set; }
    public string PlainPassword { get; set; }
}</pre>
			<p>It passes that object to the <strong class="source-inline">CreateAccount</strong> method on <strong class="source-inline">accountService</strong>. Let’s look at the entire<a id="_idIndexMarker477"/> method in <span class="No-Break"><strong class="source-inline">ForgetMeNot.Api.Dto AccountCreateRequest</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
[RelayCommand]
async Task SignUp()
{
  if (EnableButton)
  {
    AccountCreateRequest = new() [1]
    {
      Email = this.Email,
      FullName = Name,
      PlainPassword = Password
    };
    try
    {
      await accountService.CreateAccount
        (accountCreateRequest); [2]
      await Application.Current.MainPage.DisplayAlert(
        "Sign up  completed",
          "Your user has been created successfully", "Ok");
            [3]
      await Shell.Current.GoToAsync(".."); [4]
    }
    catch (Exception e)
    {
      await Application.Current.MainPage.DisplayAlert("Sign
        up failed",
          "We were not able to create an account with that
            user name", "Ok");
    }
  }
}</pre>
			<p><strong class="source-inline">[1]</strong> Start by creating <strong class="source-inline">AccountCreateRequest</strong> object, as <span class="No-Break">explained earlier.</span></p>
			<p><strong class="source-inline">[2]</strong> Call <strong class="source-inline">CreateAccount</strong> on the<a id="_idIndexMarker478"/> service. We’ll look at that method in just <span class="No-Break">a moment.</span></p>
			<p><strong class="source-inline">[3]</strong> If everything works, show a dialog box (or, as we did earlier, <span class="No-Break">a toast).</span></p>
			<p><strong class="source-inline">[4]</strong> Once a user account has been <a id="_idIndexMarker479"/>created, go back a page to the <span class="No-Break"><strong class="bold">Login</strong></span><span class="No-Break"> page.</span></p>
			<p>All that the <strong class="source-inline">CreateAccount</strong> method in <strong class="source-inline">AccountService</strong> does is pass along the <strong class="source-inline">AccountCreateRequest</strong> object to the <strong class="source-inline">apiClient</strong> <span class="No-Break"><strong class="source-inline">CreateAccount</strong></span><span class="No-Break"> method.</span></p>
			<p>The mechanisms described here are correct as far as they go, but they do not include the invitation response that the final app should have (a user invites a buddy who then creates <span class="No-Break">an account).</span></p>
			<p>Let’s not forget that we originally created <strong class="source-inline">LoginCS</strong> as a way to mimic the XAML in C#. You’ll need to fix up <strong class="source-inline">LoginCS</strong> to match the naming conventions in the XAML file or comment it out altogether, as we are not <span class="No-Break">using it.</span></p>
			<p>It’s time to run the program and make sure everything we did works. However, sometimes, you will get unexplained build errors when you make this <span class="No-Break">many changes.</span></p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor212"/>What to do if it won’t build</h2>
			<p>Assuming you’ve checked all your code, it is correct, and you are getting weird build errors (such as <strong class="source-inline">InitializeComponents not found</strong>), it may be time to clean everything out. To do so, close Visual<a id="_idIndexMarker480"/> Studio and navigate to the folder where your files are. Delete the <strong class="source-inline">bin</strong> and <strong class="source-inline">obj</strong> directories within each project, as shown in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="image/Figure_10.1_B19723.jpg" alt="Figure 10.1 – Deleting the bin and obj directories&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Deleting the bin and obj directories</p>
			<p>Follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Restart Visual Studio and immediately select <strong class="bold">Build</strong> | <strong class="bold">Clean Solution</strong> from the menu. Finally, select <strong class="bold">Build</strong> | <strong class="bold">Rebuild Solution</strong>, which forces a complete rebuild rather than <a id="_idIndexMarker481"/>an incremental build. Give your project a moment or two to settle down and <span class="No-Break">run it.</span></li>
			</ol>
			<p>You should be brought directly to the <strong class="bold">Login</strong> page, as shown in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/Figure_10.2_B19723.jpg" alt="Figure 10.2 – The Login page&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – The Login page</p>
			<ol>
				<li value="2">Next, click on <strong class="bold">Create</strong>, and you’ll be brought to the <strong class="bold">CreateAccount</strong> page, as shown in <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.3</em>. Note that there are no field name prompts on this page; instead, we use the <strong class="source-inline">Placeholder</strong> property of the <span class="No-Break"><strong class="source-inline">Entry</strong></span><span class="No-Break"> control.</span></li>
			</ol>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/Figure_10.3_B19723.jpg" alt="Figure 10.3 – The CreateAccount page&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – The CreateAccount page</p>
			<ol>
				<li value="3">Fill in the fields <a id="_idIndexMarker482"/>and click <strong class="bold">Sign up</strong>. Your account will be created on the server, and a dialog box will appear to let you know it worked, as shown in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="image/Figure_10.4_B19723.jpg" alt="Figure 10.4 – A successful sign-up&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – A successful sign-up</p>
			<p>If you try to log in, you<a id="_idIndexMarker483"/> will get an <strong class="source-inline">unauthorized</strong> message. The problem is that the system does not want the username; it wants the <span class="No-Break">user’s email.</span></p>
			<p class="callout-heading">Unauthorized</p>
			<p class="callout">You will, of course, get an unauthorized message with any bad username or <span class="No-Break">invalid password.</span></p>
			<p>Let’s fix <strong class="source-inline">LoginPage.xaml</strong> and log in, as shown in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/Figure_10.5_B19723.jpg" alt="Figure 10.5 – Logging in with our new account&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – Logging in with our new account</p>
			<p>When the login is<a id="_idIndexMarker484"/> authenticated, you are taken directly to the <span class="No-Break">home page.</span></p>
			<p>It is important to note and revel in the fact that the account creation and the authentication both take place in the cloud via <span class="No-Break">the API.</span></p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor213"/>Summary</h1>
			<p>In this chapter, we reviewed how to interact with an API. We gained insight into the internals of that interaction by examining the API domain and DTO projects, and we saw how the <strong class="source-inline">APIClient</strong> class wraps all the API calls to make life easier and more intuitive on the <span class="No-Break">client side.</span></p>
			<p>This is a reasonably advanced topic, and in the next chapter, we will dive into even more advanced topics to move you from being a novice .NET MAUI programmer to <span class="No-Break">an expert.</span></p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor214"/>Quiz</h1>
			<ol>
				<li value="1">What is <span class="No-Break">a DTO?</span></li>
				<li>Why don’t we need a local <span class="No-Break">SQLite database?</span></li>
				<li>What does the API Client <span class="No-Break">class do?</span></li>
				<li>Where does account <span class="No-Break">creation occur?</span></li>
				<li>Where does <span class="No-Break">authentication occur?</span></li>
			</ol>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor215"/>You try it</h1>
			<p>Implement the <em class="italic">Forgot Password</em> <span class="No-Break">client-side code.</span></p>
		</div>
		<div>
			<div id="_idContainer114" class="IMG---Figure">
			</div>
		</div>
	</body></html>