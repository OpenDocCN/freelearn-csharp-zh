- en: '*Chapter 4***: Creating an AR User Framework**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will develop a framework for building **Augmented Reality**
    (**AR**) applications that manage user interaction modes and the corresponding
    **user interface** (**UI**). The framework includes important **user experience**
    (**UX**) steps when starting up the AR session at runtime and interacting with
    AR features. This framework will form the basis for new scenes for projects later
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: This is a Unity framework for building mode-based applications. It generalizes
    some of the scene structure that I have found myself repeating from one project
    to the next. For example, when an AR app first starts, it must verify that the
    device supports AR. Once the AR session is initialized, the app may prompt the
    user to begin scanning the environment to establish tracking. At some point later
    in the application, the user might be prompted to tap the screen to place a virtual
    object, often in *Add-object mode*. These steps are common to many AR applications,
    including the projects in this book, so we will set up some infrastructure beforehand
    in a scene that may be used as a template.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter involves some advanced C# coding. If you're already an intermediate
    or advanced programmer, you should be able to follow along fairly easily. If you're
    a novice, you can just copy/paste the code provided here and learn from it. Or,
    you have the option of skipping the chapter altogether and using the scene template
    from this chapter found in this book's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing prerequisite assets for our framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting with a new scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the UI canvas and panels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the UI controller, using a Singleton class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an interaction modes controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the interaction modes, including startup, scan, main, and non-AR modes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usng the Unity onboarding UX assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a scene template for new scenes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you'll have a scene template, named `ARTemplate`,
    with AR onboarding features, and a user interaction framework that can be used
    as a starting point for other AR projects.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement the project in this chapter, you need Unity installed on your
    development computer, connected to a mobile device that supports AR applications.
    We''ll use the Unity project set up for AR development in [*Chapter 1*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013),
    *Setting Up for AR Development*. In review, the project configuration included
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It created a new project (via **Unity Hub**) using the **Universal Render Pipeline**
    template.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It set **Target Platform** for **Android** or **iOS** in **Build Settings**,
    and the corresponding required **Player Settings**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It installed an **XR Plugin**, **AR Foundation** package, and configured the
    **URP Forward Renderer** for AR.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It installed the **Input System** package and sets **Active Input Handling**
    (to **Input System Package** or **Both**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The completed scene from this chapter can be found in this book's GitHub repository
    at [https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation](https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding AR interaction flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In an Augmented Reality application, one of the first things the user must
    do is scan the environment with the device camera, slowly moving their device
    around until it detects geometry for tracking. This might be horizontal planes
    (floor, tabletop), vertical planes (walls), a human face, or other objects. A
    simplistic user flow given in many example scenes is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – A simple AR onboarding user workflow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.01-OnboardingFlow.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – A simple AR onboarding user workflow
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding diagram, the app starts by checking for AR support,
    asking the user for permission to access the device camera and other initializations.
    Then, the app asks the user to scan the environment for trackable objects, and
    may need to report scanning problems, such as if the room is too dark or there's
    not enough texture to detect features. Once tracking is achieved, the user is
    prompted to tap the screen to place a virtual object in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is great for demo scenes but is probably too simplistic for a real AR
    application. For example, in the Art Gallery app that we are going to build in
    [*Chapter 6*](B15145_06_Final_SB_epub.xhtml#_idTextAnchor136), *Gallery: Building
    an AR App*, after the application starts, the environment is scanned for vertical
    planes (walls).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the app enters **Main** mode, where the user must tap an **Add** button
    to add a new picture. That, in turn, displays a modal **Select Image** menu. With
    pictures added to the scene, the user can pick one and enter **Edit** mode to
    move, resize, or otherwise modify the virtual object. Part of this general interaction
    flow is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – User interaction flow, including Main, Add, and Edit modes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.02-userflow-add-edit.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – User interaction flow, including Main, Add, and Edit modes
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, each application has its own interaction flows. The framework we
    are building in this chapter supports this scenario and can be adapted for other
    projects that require managing a current modal state and corresponding UI.
  prefs: []
  type: TYPE_NORMAL
- en: This framework implements a **state machine** design pattern, where the scene
    has a current *state* (interaction mode and visible UI). Specific conditions must
    be met to then transition from one state to another.
  prefs: []
  type: TYPE_NORMAL
- en: There are two major areas of this framework – the UI panels and the interaction
    modes. Generally, there will be a one-to-one correlation between the modes and
    the UI used by the modes. For example, in *Main mode*, there will be the main
    menu UI. In *Add-object mode*, there will be a UI prompt for the user to tap to
    place an object in the scene. This implements a design pattern called **view-controller**,
    with UI views and mode controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now begin to implement this basic workflow in our scene by adding a number
    of additional prerequisite packages to the project.
  prefs: []
  type: TYPE_NORMAL
- en: Installing prerequisite assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our user interaction framework uses several additional packages that need to
    be installed in your project, namely, TextMeshPro, DOTween, and Serialized Dictionary
    Lite. In this section, I will also include some utility assets. Let's install
    them now.
  prefs: []
  type: TYPE_NORMAL
- en: TextMeshPro
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TextMeshPro provides high-quality text assets that replace the built-in text
    element. It is not mandatory, but I strongly recommend it. To import **TextMeshPro**,
    if you haven''t installed it yet in your project, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **Window | TextMeshPro | Import TMP Essential Resources**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Import Unity Package** window, click **Import**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The TextMeshPro package is now installed. You may also install the **TMP Examples
    and Extras** package, which includes additional fonts and other assets that may
    be useful and fun for your projects.
  prefs: []
  type: TYPE_NORMAL
- en: DOTween
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DOTween is, in my opinion, an indispensable free package for doing small, lightweight
    animation effects on just about any `MonoBehaviour` property. Without it, you
    may need to write a dozen lines of code to do what DOTween does in one. Documentation
    for DOTween can be found online at [http://dotween.demigiant.com/documentation.php](http://dotween.demigiant.com/documentation.php).
  prefs: []
  type: TYPE_NORMAL
- en: 'To add DOTween, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to its Unity Asset Store page: [https://assetstore.unity.com/packages/tools/animation/dotween-hotween-v2-27676](https://assetstore.unity.com/packages/tools/animation/dotween-hotween-v2-27676).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press **Add to My Assets** and/or **Open In Unity**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will take you to the **Package Manager** window in your Unity project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure **My Assets** is selected from the **Packages** filter dropdown in the
    upper-left corner of the **Package Manager** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for `DOTween` using the search text input field in the upper-right corner
    of the **Package Manager** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **DOTween** package and then click **Install**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once imported, you are prompted to **Open DOTween Utility Panel** to set up
    the package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click the **Setup DOTween** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DOTween is now installed and set up on your project.
  prefs: []
  type: TYPE_NORMAL
- en: Serialized Dictionary Lite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A C# **dictionary** is a key-value list structure where values in the list
    can be referenced by a key value. For example, we will use dictionaries to look
    up a UI panel or interaction mode object by name. Unfortunately, Unity does not
    provide native support for dictionaries in the Editor''s **Inspector** window.
    **Serialized Dictionary Lite** is a free extension to the Unity Editor that allows
    dictionaries to be edited using **Inspector**. To add Serialized Dictionary Lite
    to your project, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to its Unity Asset Store page, [https://assetstore.unity.com/packages/tools/utilities/serialized-dictionary-lite-110992](https://assetstore.unity.com/packages/tools/utilities/serialized-dictionary-lite-110992)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press **Add to My Assets** and/or **Open In Unity**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will take you to the **Package Manager** window in your Unity project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure **My Assets** is selected from the **Packages** filter dropdown in the
    upper-left corner of the **Package Manager** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for `Serialized` using the search text input field in the upper-right
    corner of the **Package Manager** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Serialized Dictionary Lite** package and click **Install** (or,
    if prompted, click **Download** and then **Import**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Serialized Dictionary Lite is now installed in your project.
  prefs: []
  type: TYPE_NORMAL
- en: Other prerequisite assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the aforementioned packages, we will assume that you have the
    following already added to your Unity project:'
  prefs: []
  type: TYPE_NORMAL
- en: Assets from the Unity `ARF-samples.unity` package created in [*Chapter 2*](B15145_02_Final_SS_epub.xhtml#_idTextAnchor037),
    *Your First AR Scene*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B15145_02_Final_SS_epub.xhtml#_idTextAnchor037), *Your First
    AR Scene*, we also created an **AR Input Actions** asset containing an **Action
    Map** named **ARTouchActions**, including (at least) one **PlaceObject** action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With our prerequisite assets present, we can get started with building the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with a new scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start this project with a new empty scene and set it up with the AR Foundation
    objects: `ARFramework` using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene using **File | New Scene**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the **Basic (Built-in)** template. Press **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene using `Assets/Scenes/` folder, give it the name `ARFramework`,
    and then click **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we''ll set up the scene with the basic AR Foundation game objects as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete **Main Camera** from the **Hierarchy** window by *right-clicking* and
    selecting **Delete** (or the pressing *Del* key on your keyboard).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an AR session by selecting **GameObject** from the main menu, and then **XR
    | AR Session**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an **AR Session Origin** object by selecting **GameObject** from the main
    menu, and then **XR | AR Session Origin**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `raycast`, and then add an **AR Raycast Manager** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfold **AR Session Origin** and select its child **AR Camera**. In the **Inspector**
    window, use the **Tag** selector in the upper-left corner to set its tag to **MainCamera**.
    (This is not required, but it is a good practice to have one camera in the scene
    tagged as MainCamera).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `audio listener`, and add an **Audio Listener** component to the camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For demo purposes, we''ll add an **AR Plane Manager** component for detecting
    and tracking horizontal planes. This may change based on the requirements of a
    specific project:'
  prefs: []
  type: TYPE_NORMAL
- en: With `ar plane manager`, and then add an **AR Plane Manager** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose an AR plane visualizer prefab and add it to the `ARF-samples/Prefabs`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can also set up some basic AR light estimation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Main Camera** in the **Hierarchy** window. On its **AR Camera Manager**
    component, set **Light Estimation** to **Everything**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `light estimation`, and then add a **Basic Light Estimation** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **AR Camera** object from the **Hierarchy** window onto the **Basic
    Light Estimation | Camera Manager** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your work using **File | Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have a scene named `ARFramework` with a few things set up, including
    the AR Session, AR Session Origin, AR Camera, and basic light estimation. We can
    now begin to construct our framework's UI panels.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the UI canvas and panels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main screen space UI canvas will contain various user interface panels that
    may be displayed at various times throughout the application. Presently, we'll
    include the following UI panels.
  prefs: []
  type: TYPE_NORMAL
- en: The Startup UI panel with any initialization messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Scan UI panel, which prompts the user to scan for trackable features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Main UI panel for the main mode that could display the main menu buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The NonAR UI panel, which could be shown when the device does not support Augmented
    Reality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the screen space canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need to create a Canvas to contain these panels. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the main menu, select `UI Canvas`. We can leave the default **Render Mode**
    as **Screen Space – Overlay**. This will also add an **Event System** game object
    to the scene if one is not already present.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, the new Canvas is in screen space, and this is what we want here.
    Some people prefer to change **Canvas Scaler UI Scale Mode** from **Constant Pixel
    Size** to **Scale With Screen Size**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To edit a Screen Space canvas, let's switch the **Scene** window to a 2D view
    by clicking the **2D** button in the **Scene** window toolbar. Then, double-click
    the **UI Canvas** object in the **Hierarchy** window to focus the **Scene** view
    on this object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's also helpful to arrange the **Game** window and **Scene** window side by
    side. Because we're developing for AR, set the **Game** window's display to a
    fixed portrait aspect ratio, such as **2160x1080 Portrait** using the dimension
    select list in the **Game** window's top toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On this canvas, we will add the separate panels. First, let's add an app title
    at the top of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an app title
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s add a placeholder for an app title as a text panel positioned at the
    top of the screen. Add the title using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Right-click* on `App Title Panel`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the **App Title Panel** object selected, in its **Inspector** window, open
    the **Anchor Presets** menu (found in the upper-left corner of the **Rect Transform**
    component), and click the **Stretch-Top** button. The **Anchor Presets** menu
    is shown open in the following screenshot, to the left of the **Rect Transform**
    component:![Figure 4.3 – Anchor Presets menu for App Title Panel set to Top-Stretch
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.03-apptitle-anchorpreset.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.3 – Anchor Presets menu for App Title Panel set to Top-Stretch
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, press *Shift + Alt +* **Stretch-Top** to set its pivot and position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `100`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, *right-click* on `Title Text`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its `My AR Project`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the **Anchor Presets** menu in the upper-left corner of **Rect Transform**,
    select **Stretch-Stretch**. Then, press *Shift + Alt +* **Stretch-Stretch**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Alignment** to **Center** and **Middle**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may also choose to adjust the **Font Size** and **Vertex Color** fields
    as you wish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There isn''t much to see, but the **Game** window, along with the title of
    the app, is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Game window (cropped) with the App Title panel anchored as Top-Stretch'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.04-apptitlepanel.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Game window (cropped) with the App Title panel anchored as Top-Stretch
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have experience using the **Anchor Presets** menu, I'll abbreviate
    the instructions going forward. Next, we'll add a panel for the start up mode.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the UI panels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll now create the UI panels for each of the initial interaction modes supported
    by the framework. Since they are all very similar, we'll create the first one,
    and then duplicate and modify it for the others.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first UI panel, **Startup UI**, will be a text panel displayed when the
    app is initializing. Create it using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Startup UI`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We don't need a background image so, in the **Inspector** window, remove the
    **Image** component using the *3-dot context menu* **| Remove Component**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `canvas group`, and add a **Canvas Group** component to the panel.
    We're going to use this component to fade panels on and off later in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* the **Startup UI** object and select **UI | Text – TextMeshPro**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `Initializing…`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using its **Anchor Presets** menu, select **Stretch-Stretch**. Then, press *Shift
    + Alt +* **Stretch-Stretch**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Alignment** to **Center** and **Middle.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we can add a panel that can be displayed if the device we''re running
    on does not support AR. Create this panel as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Right-click* the `NonAR UI`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfold the object and select its child text object. Change the text content
    to `Augmented reality not supported on this device`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Scan UI panel will be used to prompt the user to scan the room while the
    app tries to detect AR features. Create the panel by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Right-click* the `Scan UI`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfold the object and select its child text object. Change the text content
    to `Scanning… Please move device slowly`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, we''ll add a placeholder panel for the main mode UI. This panel could
    later include, for example, a main menu for the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Right-click* the `Main UI`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfold the object and select its child text object. For development purposes,
    change the text content to `Main Mode Running`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The current UI Canvas hierarchy is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – UI Canvas hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.05-uicanvas-hier.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – UI Canvas hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have created a simple hierarchy of UI panels under a screen space
    UI Canvas. The panels are acting as a placeholder, for the most part, containing
    a text element so that you can see which panel is active at runtime. As you build
    your own apps from this scene, you'll fill in the panels with app-specific UI
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll create the UI controller script.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the UI controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It will be convenient to have a script with a small API that makes it easy to
    switch between UI panels. For the controller scripts in our framework, I've decided
    to define them as singletons.
  prefs: []
  type: TYPE_NORMAL
- en: A `Instance` in the class definition. Learn more at [https://wiki.unity3d.com/index.php/Singleton](https://wiki.unity3d.com/index.php/Singleton).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we'll write a `UIController` script that controls the visibility of your
    UI panels. Lastly, we'll implement some code to fade in and out for a more pleasing
    user experience when we hide and show the panels.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Singleton class script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll begin by writing a `Singleton` class to use (or, if you already have
    a favorite, feel free to use that `Singleton` class definition instead). You can
    find some singleton implementations available as packages in the Unity Asset Store,
    but all we need is a short script that you can now create as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In your `Scripts/` folder by *right-clicking* and selecting `Singleton`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the script as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Info: A singleton as an anti-pattern'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that the singleton pattern can be abused, and some programmers are adamantly
    opposed to using it, as it can cause problems down the road should your application
    grow and get more complex. But it's a powerful tool when you are certain that
    the app will only ever require one instance of the class, as will be the case
    in this interaction framework. One of the main advantages of singletons is that
    you can then reference the object instance as a static variable on the object
    class itself. An alternative technique is to find the instance to the component
    at runtime, for example, by calling `FindObjectOfType<T>()` from the script's
    `Start()` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This script can be used to declare a singleton's `MonoBehaviour` class, as we'll
    see next in `UIController` and other scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the UIController script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With our Singleton class in hand, we can now write a UI controller. This component
    provides a way to switch between UI panels visible to the user. Perform the following
    steps to write the `UIController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Begin by creating a new script in your `Scripts/` folder by *right-clicking
    and selecting* `UIController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Double-click* the file to open it for editing and replace the default content,
    starting with the following declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the top, we declare a serializable dictionary, `UIPanelDictionary`, using
    the `CanvasGroup` component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Instead of declaring `UIController` as a `MonoBehaviour` class, we declare
    it a `Singleton` (which itself derives from `MonoBehaviour`). Don''t worry about
    the syntax of the declaration, `public class UIController : Singleton<UIController>`.
    This is what our `Singleton` class expects.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The script declares a `uiPanels` variable as a `UIPanelDictionary`. We also
    declare a `currentPanel` variable to track which panel is presently active.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, add the following functions to the script, which ensure all the UI panels
    are disabled when the app is started, by iterating through the `uiPanels` list
    and calling `SetActive(false)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that `Awake` calls `base.Awake()` because the parent `Singleton` class
    also has an `Awake` that must be called in order for this to work. Then it calls
    `ResetAllUI`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, add the following functions to the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`_ShowUI` is an instance function that, given a panel name, calls `ChangeUI`.
    `ChangeUI` hides the current panel and then activates the required one (note that
    I''m using an underscore prefix to distinguish private instance functions from
    the public one). The C# dictionary, `TryGetValue`, looks up the value for the
    given key.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The static `ShowUI` class function simply calls the instance's `_ShowUI` function.
    In this way, another script can show a panel by calling `UIController.ShowUI(panelname);`
    without requiring a direct reference to the instance. It uses the null-conditional
    operator ([https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/member-access-operators#null-conditional-operators--and-](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/member-access-operators#null-conditional-operators--and-))
    as a shortcut to make sure the instance is defined before we reference it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the script as a component on the UI Canvas and set up its properties
    by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, select **UI Canvas**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `UIController` script onto **UI Canvas**, adding it as a component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** window, on the **UI Controller** component, unfold the
    **UI Panels** dictionary list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **+** button in the bottom-right corner of the UI Panels list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the elements `Startup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfold the element and then, from the **Hierarchy** window, drag the **Startup
    UI** game object onto the **Value** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat steps 4 – 6 three times for each of the following: `NonAR` : `Scan`
    : `Main` : **Main UI**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The UI Controller component should now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – UI Controller component populated with UI panel references'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.06-uipanels-insp.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.6 – UI Controller component populated with UI panel references
  prefs: []
  type: TYPE_NORMAL
- en: Thus far, we have created a simple UI for an AR application, organized on one
    canvas as a set of separate panels. Our plan is to present only one panel at a
    time to the user, depending on what the application is doing. We also wrote a
    `UIController` script to handle switching between panels.
  prefs: []
  type: TYPE_NORMAL
- en: Fading the UI panels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An improvement we can make is to fade the UI in and out while transitioning
    instead of abruptly hiding/showing a panel. Presently, we call `SetActive` to
    change the panel''s visibility. Instead, we can use the panel''s `CanvasGroup`
    component and animate its Alpha value, and the `DOTween` library is very handy
    for this. (You can skip this modification if you do not want to install DOTween).
    To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `UIController` script for editing and add the following declaration
    at the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add these two fader helper functions at the bottom of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, modify the `ChangeUI` function to call the fader helps instead of `SetActive`,
    as shown here (the lines in comments are replaced):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Eventually, when you run the scene, the UI panels will fade in and out when
    shown and hidden, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will write an Interaction Controller that handles the application interaction
    modes and uses the UI Controller to display the specific UI it needs.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Interaction Controller mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our user framework, we will make a clever use GameObject with a mode script
    on it to represent interaction modes. Modes will be enabled (and disabled) by
    enabling (and disabling) the corresponding objects. We''ll organize these objects
    in a hierarchy, like the UI panels we created in the previous section, but separated
    to keep the "controllers" apart from the "views," as prescribed by the controller/view
    software pattern. Presently, we''ll include the following modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Startup mode**: Active while the AR session is initializing, and then it
    initiates Scan mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NonAR mode**: A placeholder should you want your application to run even
    if the device does not support AR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scan mode**: This prompts the user to scan for trackable features until the
    AR session is ready, and then it initiates Main mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Main mode**: This displays the main menu and handles non-modal interactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, we'll create the object hierarchy representing each of these modes, under
    an Interaction Controller game object. With separate GameObjects representing
    each mode, we'll be able to enable one mode or another separately.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the interaction mode hierarchy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create the interaction mode hierarchy, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the main menu, select `Interaction Controller`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* the `Startup Mode`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *step 2* three more times to create objects named `NonAR Mode`, `Scan
    Mode`, and `Main Mode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The mode hierarchy game objects now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Interaction Controller modes hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.07-internactionmode-hier.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7 – Interaction Controller modes hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: Now we can write and set up the `InteractionController` script.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Interaction Controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The role of our Interaction Controller is to manage the top-level user interaction
    of the application. We''ll begin by writing the script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new script in your `Scripts/` folder by *right-clicking* `InteractionController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Double-click* the file to open it for editing and replace the default content,
    starting with the following declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the top, we declare a serializable dictionary, `InteractionModeDictionary`,
    using the `InteractionController` as a `MonoBehaviour` class, we declare it a
    `Singleton` (which itself derives from `MonoBehaviour`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then we declare the `interactionModes` variable as this type of dictionary.
    We also declare a `currentMode` variable that tracks the current enabled mode.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, add the following functions to the script, which ensures all the modes
    are disabled when the app is started, by iterating through the `interactionModes`
    list by calling `SetActive(false)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that `Awake` calls `base.Awake()` because the parent `Singleton` class
    also has an `Awake` that must be called in order for this to work. It then calls
    `ResetAllModes`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, add the following functions to the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`_EnableMode` is an instance function that, given a mode name, calls `ChangeMode`.
    `ChangeMode` disables the current mode and then activates the requested one.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that `ChangeMode` is called as a `EnableMode` class function simply calls
    the instance's `_EnableMode` function. In this way, another script can show a
    panel by calling `InteractionController.EnableMode(modename);` without requiring
    a direct reference to the instance. It uses the null-conditional operator ([https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/member-access-operators#null-conditional-operators--and-](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/member-access-operators#null-conditional-operators--and-))
    as a shortcut to make sure the instance is defined before we reference it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Lastly, assuming we want the app to start in `Startup` mode, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This assumes we will include a `"Startup"` mode in the `interactionModes` dictionary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`UIController` will contain references to each of the app''s mode game objects.
    When the app needs to switch modes, it will call `InteractionController.EnableMode(modeName)`
    with the name of the mode. The current mode will be disabled, and the required
    one will be enabled.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the script as a component on the Interaction Controller game object and
    set up its properties by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, select the **Interaction Controller** game object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `InteractionController` script onto the **Interaction Controller**,
    adding it as a component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** window, on the **Interaction Controller** component, unfold
    the **Interaction Modes** dictionary list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **+** button in the bottom-right corner of the **Interaction Modes**
    list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the elements `Startup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfold the element and then, from the **Hierarchy** window, drag the **Startup
    Mode** game object onto the **Value** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat steps 4 – 6 three times for each of the following: `NonAR` : `Scan`
    : `Main` : **Main Mode**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **Interaction Controller** component should now look like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Interaction Controller component populated with interaction
    mode object references'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_4.08-interactionmode-list-insp.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.8 – Interaction Controller component populated with interaction mode
    object references
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The **Interaction Controller** component will be responding to user input, so
    we need to add a **Player Input** component (assuming your project is using the
    new Input system).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With **Interaction Controller** selected in the **Hierarchy** window, click
    **Add Component** in the **Inspector** window.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Search for `player inp ut` and add a **Player Input** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the `Inputs/` folder) and drag it to the **Player Input | Actions** slot.
    (As noted in the *Technical requirements* earlier in the chapter, I assume you
    already have this asset as created in [*Chapter 2*](B15145_02_Final_SS_epub.xhtml#_idTextAnchor037),
    *Your First AR Scene*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Player Input | Behavior** to **Broadcast Messages**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*THIS IS IMPORTANT!* We need to make sure the player actions are forwarded
    to the child mode objects.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this section, we have created a hierarchy for interaction modes, organized
    under one Interaction Controller game object that has a script for enabling/disabling
    mode objects. Our plan is to allow only one mode to be active at a time. Of course,
    we still need to write the scripts that control each mode, and handle conditions
    when it's time to transition from one particular mode to a different one.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the interaction modes behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the app enables a mode, it will enable the corresponding game object,
    which has a script that controls the behavior of that mode. When the app changes
    modes, the current mode object will be disabled, and the new one enabled. Each
    mode is responsible for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying its corresponding UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transitioning to a different mode when specific conditions are met
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will write mode scripts for each of the modes.
  prefs: []
  type: TYPE_NORMAL
- en: The StartupMode script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Startup mode begins when the application starts (it's enabled from the `InteractionController`
    `Start()` function). It displays the Startup UI panel. Then it waits for the `ARSession`
    state to become ready, and transitions to Scan mode. Or, if the `ARSession` reports
    that AR is not supported on the current device, it transitions to NonAR mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create Startup mode:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new script in your `Scripts/` folder by *right-clicking* and selecting
    `StartupMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `StartupMode` script onto the **Startup Mode** game object in the **Hierarchy**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Double-click* the `StartupMode` script file to open it for editing and write
    it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The script uses the AR Foundation''s `ARSession` class state variable, `ARSession.state`,
    to determine when the session is initialized or whether AR is unsupported. The
    state is an `enum ARSessionState` with one of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`None`: The session has not yet been initialized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Unsupported`: The device does not support AR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CheckingAvailability`: The session is in the process of checking availability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NeedsInstall`: The device needs to install or update AR support software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Installing`: The device is in the process of installing AR support software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ready`: The device supports AR and you can enable the `ARSession` component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SessionInitializing`: The AR session is scanning the environment and trying
    to detect trackable objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SessionTracking`: The AR session has found trackable objects and can determine
    the device''s location within the real-world 3D environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When `state` is `Unsupported`, we transition to NonAR mode.
  prefs: []
  type: TYPE_NORMAL
- en: When `state` is `Ready` (or higher), we transition to Scan mode.
  prefs: []
  type: TYPE_NORMAL
- en: The ScanMode script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scan mode is enabled when the device is scanning the environment, trying to
    detect trackable features in the real world. It displays a prompt asking the user
    to point the camera into the room and slowly move the device.
  prefs: []
  type: TYPE_NORMAL
- en: The conditions for ending Scan mode may vary depending on the AR application.
    For example, it may wait until at least one horizontal or vertical plane has been
    detected, or a reference image has been recognized, or a selfie face is being
    tracked. Presently, we'll check `ARPlaneManager` if any trackables have been detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to create Scan mode:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new script in your `Scripts/` folder by *right-clicking* and selecting
    `ScanMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `ScanMode` script onto the **Scan Mode** game object in the **Hierarchy**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Double-click* the `ScanMode` script file to open it for editing and write
    it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Drag the **AR Session Origin** object from the **Hierarchy** window onto the
    **Scan Mode | Plane Manager** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When Scan mode is enabled, the `planeManager.trackables.count > 0` before switching
    to Main mode.
  prefs: []
  type: TYPE_NORMAL
- en: The MainMode script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Main mode, as its name implies, is the main operating mode of the application.
    It may display the main menu, for example, and handle main user interactions.
    For our default framework, there's not much to do yet apart from display the Main
    UI panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to create Main mode:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new script in your Project's `Scripts/` folder by *right-clicking*
    and selecting `MainMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `MainMode` script onto the **Main Mode** game object in the **Hierarchy**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Double-click* the `MainMode` script file to open it for editing and write
    it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lastly, we define NonAR mode.
  prefs: []
  type: TYPE_NORMAL
- en: The NonARMode script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NonAR mode will be enabled when the device you're running does not support AR.
    You might simply notify the user that the app cannot run, and gracefully exit.
    Alternatively, you may continue to run the app without AR capabilities if that
    makes sense for your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to create a NonAR mode placeholder:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new script in your Project's `Scripts/` folder by *right-clicking and
    selecting* `NonARMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `NonARMode` script onto the **NonAR Mode** game object in the **Hierarchy**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Double-click* the `NonARMode` script file to open it for editing and write
    it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That about does it. We've created a hierarchy with each of the interaction modes
    as children of `InteractionController.EnableMode()`, which disables the current
    mode and activates a new one. When a mode is enabled, its mode script begins running,
    showing its UI, and potentially interacting with the user until specific conditions
    are met, and then transitions to a different mode. Let's try running the scene
    on your device.
  prefs: []
  type: TYPE_NORMAL
- en: Testing it out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now is a good time to **Build And Run** the scene to make sure things are working
    as expected so far. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, be sure to save your work by using **File | Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **File | Build Settings** to open the **Build Settings** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click `ARFramework` scene to **Scenes In Build**, and ensure it is the only
    scene in the list with a checkmark.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that your target device is plugged into a USB port and that it is ready.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Build And Run** to build the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the project builds without errors and launches on your device in **Startup**
    mode. You'll first see the words **Initializing…** from the **Startup** UI panel.
  prefs: []
  type: TYPE_NORMAL
- en: Once the AR Session is started, the app transitions to Scan mode and you will
    see the words **Scanning... Please move device slowly**.
  prefs: []
  type: TYPE_NORMAL
- en: Once a horizontal plane is being tracked, Scan mode transitions to Main mode.
    You will then see on the screen the words **Main Mode Running...**.
  prefs: []
  type: TYPE_NORMAL
- en: If all goes well, the framework is working as intended. To accomplish this,
    we have implemented the Canvas UI and child panels for the user interface. We
    have implemented the Interaction Controller and child mode controllers with scripts
    that implement the UI and interactions required in each mode. And it's all wired
    together. This is a basic framework for an AR project that we will use for projects
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways in which we can improve and build on this framework. For
    one, we can make the UI a little more interesting by replacing some of the text
    prompts with animated graphics from the AR Onboarding UX from Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Unity onboarding UX assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity provides a set of AR onboarding UX assets useful for prompting users in
    an AR application. **Onboarding** refers to the user experience when your app
    starts up and prompts the user to interact with AR features. First, I'll explain
    some of what this package provides. Then we'll prepare the assets for use in our
    own projects.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the onboarding assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The onboarding UX assets are part of the AR Foundation Demos project found at
    [https://github.com/Unity-Technologies/arfoundation-demos](https://github.com/Unity-Technologies/arfoundation-demos).
    (This is different from the *AR Foundation Samples* project we explored in [*Chapter
    2*](B15145_02_Final_SS_epub.xhtml#_idTextAnchor037), *Your First AR Scene*). And
    its documentation can be found on that project's GitHub page.
  prefs: []
  type: TYPE_NORMAL
- en: The onboarding UX assets include icons and video graphics to prompt the user
    when scanning is required. It automatically tells the user the reasons why tracking
    may be failing, such as the room is too dark, or the camera view does not see
    sufficient details. It provides components to manage that process that are composed
    into an example prefab, named **ScreenspaceUI**, which can be customized to the
    look and feel of your own project.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when the app is scanning, you can use an animated graphic prompt
    to *Move Device Slowly* while scanning the room. If there''s a problem, it will
    display the reason, as shown in the left-side panel of the following image (where
    I have my finger covering the camera lens). It says **Look for more textures or
    details in the area**. If you want to prompt the user to tap the screen to place
    an object, there''s a **Tap to Place** animated graphic, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Using the onboarding UX assets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.09-OnboardingStepsCapture.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.9 – Using the onboarding UX assets
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the package supports localization of the text prompts, should your
    project require multi-language support for various countries. It also includes
    some good default assets for visualizing AR planes and point clouds that you can
    use.
  prefs: []
  type: TYPE_NORMAL
- en: The package includes the following components.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARUX Animation Manager**: This displays instructional graphic animations
    to prompt the user to find a plane or tap to place, for example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ARUX Reasons Manager**: This checks the AR Session''s status and displays
    reasons why tracking may be failing as hints to the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Localization Manager**: This supports localized text and graphics for adapting
    the instructional and reasons UI to different languages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIManager` script from the AR Foundation Demos project is a useful control
    script, but it is only an example of how to interface with the `ARUXAnimationManager`.
    Reading the script is informative but not reusable. In our framework, we have
    implemented our own solution for the user flow that replaces the `UIManager` script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UI Manager** lets you set up one or two goals via the **Inspector** window.
    A goal may be **Found a Plane** or **Placed an Object**. You then set the instructional
    UI to prompt the user to perform the current activity until its goal has been
    completed.'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the Unity AR onboarding assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the onboarding UX assets are also available as a package in the Unity
    Asset Store, I recommend you clone the GitHub project version because it has more
    examples and assets, including **Universal Render Pipeline** (**URP**) shader-graph
    shaders. Both versions are full Unity projects, so either way, you will need to
    open it in a new Unity project and then export the assets into a package that
    you can import into your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: We will clone the project and then export the AR Foundation Demos assets into
    a `.unitypackage` file that we can import into our own project. I will also provide
    a copy of this Unity package with the files for this book in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'To clone the project and export the folders we want, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Clone a copy of the project from GitHub to your local machine. The project can
    be found at [https://github.com/Unity-Technologies/arfoundation-demos](https://github.com/Unity-Technologies/arfoundation-demos).
    Please use whatever cloning method you prefer, for example, GitHub Desktop ([https://desktop.github.com/](https://desktop.github.com/))
    or Command Line ([https://git-scm.com/download/](https://git-scm.com/download/)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Unity Hub** application on your desktop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the project to **Unity Hub** by selecting **Projects | Add**, navigating
    to the cloned project's root folder, and then press **Select Folder**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Unity Hub** projects list, if you see a yellow warning icon indicating
    that the Unity version used by the cloned project is not presently installed on
    your system, use the **Unity Version** selection to choose a newer version of
    the editor that you do have installed (preferably the same major release number).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the project by selecting it from the **Unity Hub** projects list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're going to move selected folders into a root folder named `ARFoundationDemos`
    that we can export into a package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Unity, in the `ARFoundationDemos`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With your mouse, move the following four folders into this `ARFoundationDemos/`
    folder: **AddressableAssetsData**, **Common**, **Shaders**, and **UX**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `ARFoundationDemos/` folder and select **Export Package**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Exporting Package** window will open. Click **Export**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a directory outside of this project's root and name the file (such as
    `ARF-OnboardingUX`). Then, click **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before you close the `ARFoundationDemos` project, you may want to look in the
    **Package Manager** window and note the **AR Foundation** package version used
    in the given project, to make sure your own project uses the same or later version
    of AR Foundation.
  prefs: []
  type: TYPE_NORMAL
- en: You can close the `ARFoundationDemos` project now. You now have an asset package
    you can use in this and other projects.
  prefs: []
  type: TYPE_NORMAL
- en: Installing dependency packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The AR onboarding UX has some dependencies on other Unity packages that you
    must install in your own project: *Addressables* and *Localization*. Open your
    AR project and install them now.'
  prefs: []
  type: TYPE_NORMAL
- en: The Addressable Asset system simplifies loading assets at runtime with a unified
    scheme. Assets can be loaded from any location with a unique address, whether
    they reside in your application or on a content delivery network. Assets can be
    accessed via direct references, traditional asset bundles, or `Resource` folders.
    The **Addressables** package is required by the onboarding UX assets. To learn
    more, see [https://docs.unity3d.com/Packages/com.unity.addressables@1.16/manual/index.html](mailto:https://docs.unity3d.com/Packages/com.unity.addressables@1.16/manual/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'To import the **Addressables** package, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Package Manager** window by using **Window | Package Manager**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure **Unity Registry** is selected from the **Packages** filter dropdown
    in the upper-left corner of the **Package Manager** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for `Addressables` using the search text input field in the upper-right
    corner of the **Package Manager** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Addressables** package and click **Install**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Addressables** package is now installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Localization** package translates text strings and other assets into
    local languages. See [https://docs.unity3d.com/Packages/com.unity.localization@1.0/manual/index.html](mailto:https://docs.unity3d.com/Packages/com.unity.localization@1.0/manual/index.html).
    To import the **Localization** package, perform the following steps (these steps
    may have changed by the time you read this):'
  prefs: []
  type: TYPE_NORMAL
- en: If you have not already done so, enable **Preview Packages** by navigating to
    the **Edit | Project Settings | Package Manager** settings and checking the **Enable
    Preview Packages** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, in the **Package Manager** window, use the **+** button in the top-left
    corner and select **Add Package From Git URL**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, type `com.unity.localization` to begin installing the package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Info: Using Preview packages and Git URLs'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As I write this, the **Localization** package is in *preview*, that is, not
    yet fully released by Unity. Also, it is not yet included in the Unity package
    registry. To enable preview packages, you must click **Enable Preview Packages**
    in **Project Settings**. Also if a package is not included in the built-in Unity
    registry, you can add a package from a Git URL, from disk, or from a tarball file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The **Localization** package is now installed. We can now install the AR onboarding
    UX assets themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the OnboardingUX package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We saved the assets exported from the AR Foundation Demos project into a file
    named `OnboardingUX.unitypackage`. Importing the package is straightforward. Follow
    these steps to add it to your project. Back in your own Unity project, do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Select `OnboardingUX.unitypackage` file from your Explorer or Finder directly
    into the Unity **Project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Import Unity Package** window, click **Import**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The assets include materials that use the built-in render pipeline. Since our
    project is using the URP, you need to convert the materials by selecting `ARFoundationDemos/Common/Materials/`
    folder and, in the **Inspector** window, change its **Shader**, using the drop-down
    menu, to **ShaderGraphs/BlurredShadowPlane**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The onboarding UX assets are now imported into your project. We can now add
    it to our framework scene.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, our app renders a UI panel with text to prompt the user to scan the
    environment. This panel is a game object that is enabled when needed. Basically,
    we want to replace the panel text with animated graphics.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the AnimatedPrompt script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by writing a new script, `AnimatedPrompt`, that displays a specific
    animation when it is enabled and hides the animation when disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new script in your `Scripts/` folder by *right-clicking and selecting*
    `AnimatedPrompt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Double-click* the file to open it for editing and replace the default content,
    starting with the following declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this script, we declare a public property, `instruction`, whose value is
    an `enum InstructionUI` type that indicates which animation to play (borrowed
    from the `UIManager` script from the onboarding assets, to be consistent).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When the script is started or enabled, it will initiate the animated graphics.
    Inversely, when the object is disabled, the graphics are turned off:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I've added a fix to ensure the animation does not restart when both `Start`
    and `OnEnable` are called at the start.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When the script is enabled, it calls the helper function, `ShowInstructions`,
    which calls a corresponding function in `ARUXAnimationManager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we can add this to our scene.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the onboarding graphics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To integrate the onboarding graphics, we can add the demo prefab (unfortunately
    named `ScreenspaceUI`) from the AR Foundation Demos package. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `ARFoundationDemos/UX/Prefabs/` folder and drag the **ScreenspaceUI**
    prefab into the **Hierarchy** window root of the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give it a more indicative name; rename the object `OnboardingUX`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our framework replaces the demo **UI Manager** component, so you should remove
    this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the **OnboardingUX** object selected in **Hierarchy**, click the *3-dot
    context menu* in the top-right corner of the **UI Manager** component in the **Inspector**
    window and select **Remove Component**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now use `AnimatedPrompt` to replace the text in our UI prompt panels.
    To use it, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Animated Prompt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `AnimatedPrompt` script from the **Project** window onto the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Animated Prompt | Instruction** to **Cross-Platform Find A Plane.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Hierarchy** window, drag the **OnboardingUX** object into the **Inspector**
    window and drop it on to the **Animation Manager** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can disable the **Text (TMP)** child element of **Scan Prompt Panel** so
    that it won't be rendered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you **Build And Run** the project again, when it enters Scan mode, you will
    be greeted with nice, animated graphics instead of the text prompt.
  prefs: []
  type: TYPE_NORMAL
- en: With a working AR user framework, let's make this scene into a template that
    we can use when creating new scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a scene template for new scenes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can save this **ARFramework** scene we've been working on as a template to
    use for starting new scenes in this Unity project. To create a scene template,
    perform the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: With the **ARFramework** scene open, select **File | Save As Scene Template**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Scenes/` folder, verify the template name (`ARFramework.scenetemplate`),
    and then press **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subsequently, when you want to start a new AR scene, use this template. By default,
    Unity will duplicate any dependencies within the scene into a separate folder.
    In our case, this is generally *not* what we want to do.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To prevent cloning the scene dependencies when the template is used, click on
    this new scene template file in your `Assets/` window.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In its `ARFramework`. Just remember to check the **Dependencies** list in the
    template if you've added any new assets to the scene as these will default to
    be cloned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To use the template when creating a new scene in this project, use **File |
    New Scene** as usual. The dialog box will now contain the **ARFramework** template
    as an option. Select the location in your assets folder and press **Create**.
    If the template specifies any assets to be cloned, those copies will be added
    to a subfolder with the same name as the new scene.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to build upon the work we did in this chapter, using the **ARFramework**
    template for new project scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we developed a framework for building AR applications and saved
    it as a template we can use for projects in this book. The framework provides
    a state-machine structure for implementing modes and identifying the conditions
    when to transition to a different mode. The framework also offers a controller-view
    design pattern where, when a mode is active, its corresponding UI is visible,
    keeping the mode control objects separate from the UI view objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the framework template, we implemented four modes: Startup mode, Scan mode,
    Main mode, and NonAR mode, along with four UI panels: Startup UI, Scan UI, Main
    UI, and NonAR UI. Scan mode uses the onboarding UX assets from the AR Foundation
    Demos project to prompt the user to scan for trackable features and report problems
    with detection and the AR session.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, I will demonstrate the use of this framework with a simple
    demo project and then build upon the framework more extensively in subsequent
    chapters.
  prefs: []
  type: TYPE_NORMAL
