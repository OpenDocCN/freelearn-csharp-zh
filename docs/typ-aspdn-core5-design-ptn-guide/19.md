# 十九、答案

各章练习问题的答案如下：

# 第一章

1.  不
2.  长方法是指一种方法处理了太多的责任，应该进行拆分。
3.  对通过以.NET 标准为目标，您可以达到多个运行时版本，包括.NET Core 和.NET 框架。
4.  代码气味代表一个潜在的设计缺陷，可以从重写中获益。

# 第二章

1.  是的，这是真的。
2.  测试代码单元，如方法的逻辑代码路径。
3.  3.尽可能小。单元测试旨在孤立地测试尽可能最小的代码单元。
4.  集成测试通常用于此类任务。
5.  不，有多种编写代码的方法，TDD 只是其中之一。

# 第三章

1.  五点：S.O.L.I.D。（SRP、OCP、LSP、ISP 和 DIP）。
2.  不，想法正好相反：创建更小的组件。
3.  不，您希望封装相似的逻辑，而不是外观相似的代码块。
4.  是的，重用较小的组件比适应较大的组件更容易。
5.  这是 SRP，但关注点分离原则也指出了这一点。

# 第四章

1.  **控制器**操纵**模型**并选择**视图**进行渲染。
2.  `@model`指令。
3.  **视图模型**应该与**视图**有一对一的关系。
4.  对
5.  对

# 第五章

1.  201 已创建。
2.  2.`[FromBody]`属性。
3.  `GET`方法。
4.  是的，这些正是 DTO 的目标：将*ins*和*OUT*与**模型**解耦。
5.  对

# 第六章

1.  它有助于管理运行时的行为，例如在程序中间更改算法。
2.  创建模式负责创建对象。
3.  `v1`和`v2`是两个不同的实例。每次调用属性的 getter 时，都会执行 arrow 操作符旁边的代码。
4.  是的，这是真的。这是该模式的主要目标，正如我们在`MiddleEndVehicleFactor`代码示例中演示的那样。
5.  单例模式违反了坚实的原则，鼓励使用全局（静态）变量。

# 第七章

1.  瞬态、作用域、单态。
2.  组合根目录包含描述如何组合程序的代码——抽象和实现之间的所有注册和绑定。
3.  是的，这是真的。应注入易失性依赖项，而不是实例化。
4.  战略模式。
5.  服务定位器模式是所有三种模式。它是 DI 库在内部使用的一种设计模式，但在应用代码中成为一种代码气味。如果被误用，这是一种反模式，与直接使用`new`关键字具有相同的缺点。

# 第八章

1.  辛格尔顿。
2.  范围。
3.  转瞬即逝的
4.  是的，您可以根据需要配置任意多个提供程序。一个用于控制台，另一个用于将条目附加到文件。
5.  不，您不应该在生产中记录跟踪级别的条目。调试问题时，应该只记录调试级别的条目。

# 第九章

1.  是的，我们可以通过仅依赖接口来装饰装饰器，因为它们只是接口的另一个实现，仅此而已。
2.  当涉及到管理复杂性时，复合模式增加了简单性。
3.  是的，我们可以用一个适配器。
4.  我们通常使用立面来简化一个或多个子系统的使用，在它们前面创建一堵墙。
5.  Adapter 和 Façade 设计模式几乎相同，但适用于不同的场景。适配器模式将一个 API 适配到另一个 API，而 Façade 模式公开了一个统一或简化的 API，隐藏了一个或多个复杂的子系统。

# 第十章

1.  错误的您可以创建任意数量的`abstract`（必需）或`virtual`（可选）扩展点，只要类与单个职责相衔接。
2.  是的，没有理由不这样做。
3.  不，没有比任何其他代码更大的限制。
4.  是的，每个消息可以有一个处理程序，或者每个消息可以有多个处理程序。这取决于您和您的要求。
5.  它有助于在班级之间划分职责。

# 第 11 章

1.  对实际上，`HttpMessageInvoker`.Send 方法返回的`HttpResponseMessage`实例就是一个操作结果。`HttpClient`继承自`HttpMessageInvoker`并公开了其他不同的方法，这些方法也返回`HttpResponseMessage`的实例。
2.  我们实现了两种**静态工厂方法**。
3.  是的，返回对象比抛出异常更快。

# 第 12 章

1.  不，您可以根据需要拥有任意多的层，并且可以根据需要命名和组织它们。
2.  不，两者都有各自的位置、优点和缺点。
3.  对`DbContext`是工作单元模式的实现。`DbSet<T>`是存储库模式的一个实现。
4.  不，您可以按任何方式查询任何系统。例如，您可以使用 ADO.NET 查询关系数据库，使用`DataReader`手动创建对象，使用`DataSet`跟踪更改，或者执行任何符合您需要的操作。尽管如此，ORMs 还是非常方便。
5.  对层永远不能访问外部层，只能访问内部层。

# 第 13 章

1.  是的，可以，但不一定。移动依赖项并不能修复设计缺陷；它只是将这些缺陷转移到其他地方。
2.  是的，制图员应该帮助我们遵循 SRP。
3.  不，它可能不适用于所有场景。例如，当映射逻辑变得复杂时，请考虑不使用 AutoMapper。
4.  是的，使用概要文件来连贯地组织映射规则。
5.  四个或更多。再一次，这只是一个指导方针；在一个类中注入四个服务是可以接受的。

# 第 14 章

1.  是的，你可以。这就是调解模式的目标：调解同事之间的沟通。
2.  在 CQRS 的原始意义上：不，命令不能返回值。其思想是，查询读取数据，而命令改变数据。在 CQR 更宽松的意义上，是的，一个命令可以返回一个值。例如，没有任何东西可以阻止 create 命令部分或全部返回所创建的实体。您总是可以用一点模块化来换取一点性能。
3.  MediatR 是一个根据 Apache 许可证 2.0 授权的免费开源项目。
4.  是的，你应该；使用标记接口添加元数据通常是错误的。然而，您应该单独分析每个用例，在得出结论之前考虑利弊。

# 第 15 章

1.  您知道的任何可以帮助您实现解决方案的模式和技术。这就是它的美：你不受限制；只有你自己。
2.  不，您可以在每个垂直切片内为作业选择最佳工具；你甚至不需要图层。
3.  应用很可能会变成一个大泥球，很难维护，这对你的压力水平不好。
4.  我们可以在任何 ASP.NET MVC 应用中创建 MVC 过滤器。我们可以在任何使用 MediatR 的应用中使用行为来扩充 MediatR 管道。我们还可以在非 MVC 应用中实现 ASP.NET 中间件，或者在进入 MVC 管道之前执行代码。
5.  内聚性是指应作为一个统一的整体共同工作的要素。
6.  紧密耦合描述了不能独立改变的元素；这直接依赖于彼此。

# 第 16 章

1.  消息队列获取一条消息，并有一个订阅者将其出列。如果没有任何东西使消息出列，它将无限期地留在队列中（FIFO 模型）。发布子模型获取消息并将其发送给零个或多个订阅者。
2.  事件源是按时间顺序累积系统中发生的事件的过程。它允许您通过重播这些事件来重新创建应用的状态。
3.  是的，您可以混合网关模式（或子模式）。
4.  不，如果愿意，您可以在本地部署微应用（微服务）。此外，在*第 14 章，Mediator 和 CQRS 设计模式*中，我们发现我们甚至可以在单个应用中使用 CQRS。
5.  不，如果愿意，可以不使用容器部署微服务。在任何情况下，容器都很可能为您省去许多麻烦（并创建新的麻烦）。

# 第 17 章

1.  Razor Pages 最擅长创建面向 web 页面的应用。
2.  是的，我们可以访问与 MVC 基本相同的内容。
3.  从技术上讲，是的，您可以，但您应该只使用局部视图来呈现部分 UI 和 UI 逻辑，而不是域逻辑和数据库查询。
4.  是的，你可以。您还可以创建新标记。
5.  是的，你可以。视图组件类似于渲染一个或多个视图的基于组件的单动作控制器。
6.  是的，它可以编译。它使用 C#9 中引入的**目标类型**`new`**表达式**。
7.  不，没有。如果我们将`class`关键字替换为`record`关键字，它将编译，如下所示：`public record MyDTO(int Id, string Name);.`
8.  一个类可以有与视图/页面层次结构中的级别一样多的显示模板。
9.  显示模板和编辑器模板与类型直接相关。

# 第 18 章

1.  否，它被编译为 WebAssembly。
2.  没有一个这三个选项都是可以接受的，这取决于你在建什么，和谁一起建。
3.  模型（状态）–视图（组件）–更新（减速器）。
4.  不，MVU 模式是关于一个单向的数据流，以简化状态管理。
5.  对 Blazor 可以与 JavaScript 交互，反之亦然。