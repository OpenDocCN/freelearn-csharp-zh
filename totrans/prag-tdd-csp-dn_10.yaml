- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building an App with Repositories and Document DB
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 8*](B18370_08_RN.xhtml#_idTextAnchor209), *Designing an Appointment
    Booking App*, we laid the technical specifications and the design decisions for
    building an appointment booking system for a barber salon called Heads Up Barbers.
    This chapter is a continuation of [*Chapter 8*](B18370_08_RN.xhtml#_idTextAnchor209),
    so I strongly advise you to be familiar with it first.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will implement the requirements in TDD style and will use the repository
    pattern with **Azure Cosmos DB**. The implementation will be applicable to other
    **document databases** aka **NoSQL** such as **MongoDB**, **Amazon DynamoDB**,
    **GCP Firestore**, and others.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: If you are a fan of document DBs or you are using one at work, then this chapter
    is for you, while if you are using a relational database, then you might want
    to skip this chapter and go back to the previous chapter, [*Chapter 9*](B18370_09.xhtml#_idTextAnchor226).
    Both chapters, [*Chapter 9*](B18370_09.xhtml#_idTextAnchor226) and [*Chapter 10*](B18370_10.xhtml#_idTextAnchor245)
    have the same outcome, but they use different backend DB categories.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The chapter assumes you are familiar with a document DB service and the idea
    behind document DBs, not necessarily Cosmos DB, as from a TDD perspective, the
    implementation between different DB products is almost identical.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Planning the code and the project structure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the web APIs with TDD
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answering frequently asked questions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have experienced the implementation of an
    end-to-end app using TDD with mocks and document DB backend. Also, you will witness
    the analysis process that precedes writing unit tests.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found at the following GitHub repository:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch10](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch10)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the project, you will need to have an instance of Cosmos DB installed.
    This can be one of the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Azure Cosmos DB on the cloud under an Azure account
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Cosmos DB Emulator**, which can be installed locally on Windows, Linux,
    and macOS and can run from Docker'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The implementation doesn’t use any advanced Cosmos feature, so feel free to
    use any Cosmos flavor. I have tested the application with Azure Cosmos DB Emulator
    on Windows locally. You can find more about it here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/cosmos-db/local-emulator](https://docs.microsoft.com/en-us/azure/cosmos-db/local-emulator%0D)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing the local emulator, you need to grab the connection string,
    which you can do by browsing to `https://localhost:8081/_explorer/index.xhtml`
    and copying the connection string from the **Primary Connection String** field:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Finding Cosmos DB connection string ](img/Figure_10.1_B18370.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 查找 Cosmos DB 连接字符串](img/Figure_10.1_B18370.jpg)'
- en: Figure 10.1 – Finding Cosmos DB connection string
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 查找 Cosmos DB 连接字符串
- en: 'To run the project, you have to set the connection string to your specific
    DB instance in `Uqs.AppointmentBooking.WebApi/AppSettings.json`, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行项目，你必须将连接字符串设置为 `Uqs.AppointmentBooking.WebApi/AppSettings.json` 中的特定数据库实例，如下所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The connection string is pointing to `LocalMachine` and will connect to a database
    called `AppointmentBooking`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串指向 `LocalMachine` 并连接到名为 `AppointmentBooking` 的数据库。
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I am not concerned in this chapter regarding setting multiple environments,
    but you may want to create multiple `AppSettings` for different environments and
    change the connection string accordingly.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我并不关心设置多个环境，但你可能希望为不同的环境创建多个 `AppSettings` 并相应地更改连接字符串。
- en: The previous DB configuration steps are optional. You can implement the requirements
    for this chapter without using a DB, but you won’t be able to run the project
    and interact with it in the browser.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的数据库配置步骤是可选的。你可以不使用数据库来实现本章的要求，但你将无法运行项目并在浏览器中与之交互。
- en: Planning your code and project structure
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划代码和项目结构
- en: In [*Chapter 8*](B18370_08_RN.xhtml#_idTextAnchor209), *Designing an Appointment
    Booking App*, we planned our domain and analyzed what we needed to do. The project
    architecture will follow the classical three-tier applications of the client application
    (the website), business logic (the web APIs), and database (Cosmos DB). Let’s
    translate this into VS solutions and projects.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B18370_08_RN.xhtml#_idTextAnchor209)，*设计预约应用*，我们规划了我们的领域并分析了我们需要做什么。项目架构将遵循经典的客户端应用（网站）、业务逻辑（Web
    API）和数据库（Cosmos DB）的三层应用。让我们将其转换为 VS 解决方案和项目。
- en: In this section, we will create the solution and create the projects, and wire
    up the components.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建解决方案和项目，并连接组件。
- en: Analyzing projects’ structure
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析项目结构
- en: Get a group of senior developers to agree on one project structure, and you
    will end up with multiple structures! In this section, we will discuss a way of
    organizing your project structure that I have developed over the years.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让一组高级开发者就一个项目结构达成一致，最终你可能会得到多个结构！在本节中，我们将讨论一种我多年来开发的项目结构组织方式。
- en: Given that we are first going to build a website for the user and later a mobile
    app (not covered in this book), it makes sense to isolate the business logic to
    a web API project that can be shared by both the website and the mobile app. So,
    we will build a website project based on Blazor WebAssembly called `Uqs.AppointmentBooking.Website`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们首先将构建一个用户网站，然后是移动应用（本书未涵盖），因此将业务逻辑隔离到一个可以被网站和移动应用共享的 Web API 项目中是有意义的。因此，我们将基于
    Blazor WebAssembly 构建一个名为 `Uqs.AppointmentBooking.Website` 的网站项目。
- en: The domain logic will be exposed as APIs, so we will create an ASP.NET API project
    for this one called `Uqs.AppointmentBooking.WebApi`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 领域逻辑将以 API 的形式公开，因此我们将为这个项目创建一个名为 `Uqs.AppointmentBooking.WebApi` 的 ASP.NET
    API 项目。
- en: The previous two projects needed to exchange data in an agreed structure called
    `Uqs.AppointmentBooking.Contracts`. This project will be referenced by both the
    website and the web API projects.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 之前两个项目需要在一个称为 `Uqs.AppointmentBooking.Contracts` 的约定结构中交换数据。此项目将由网站和 Web API
    项目引用。
- en: The web API project translates web requests into something we can understand
    in C#. In technical terms, this will manage our communication layer of HTTP with
    RESTful style APIs. So, the WebApi project will not contain business logic. The
    business logic will be in our domain project. We will create a domain project
    called `Uqs.AppointmentBooking.Domain`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Web API 项目将 Web 请求转换为我们可以用 C# 理解的内容。从技术角度来说，这将管理我们的 HTTP 通信层，采用 RESTful 风格的
    API。因此，WebApi 项目将不包含业务逻辑。业务逻辑将在我们的领域项目中。我们将创建一个名为 `Uqs.AppointmentBooking.Domain`
    的领域项目。
- en: Your business logic will live in two places – the UI and the domain layer. The
    UI business logic will manage UI functionalities such as toggling dropdowns, blocking
    calendar days, responding to drag and drop, and disabling/enabling buttons, among
    others. This logic will live in the website project.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你的业务逻辑将存在于两个地方 – UI 和领域层。UI 业务逻辑将管理 UI 功能，如切换下拉菜单、锁定日历日、响应拖放操作以及启用/禁用按钮等。这种逻辑将存在于网站项目中。
- en: Important Note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: UI frameworks such as Blazor and Angular act as standalone applications. These
    frameworks facilitate, by design, using a design pattern called **Model View View-Model**
    (**MVVM**), which makes dependency injection and, therefore, unit testing easy.
    However, unit testing the UI-specific elements (razor files in Blazor) requires
    a more specialized framework such as **bUnit**.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: The language used in writing the code depends on the UI framework in use, such
    as Angular, React, and Blazor. In our implementation, we will have little code
    in the UI layer, so we will not be doing any UI unit tests.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The sophisticated business logic will live in the domain layer, and we will
    be writing it following the concepts of TDD. So, we shall create a project that
    will hold our domain unit tests and call it `Uqs.AppointmentBooking.Domain.Tests.Unit`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'To put these projects into perspective and map them to our three-tier architecture,
    we can have the following diagram:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – The relationship between the projects and the application design
    ](img/Figure_10.2_B18370.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – The relationship between the projects and the application design
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The previous diagram shows the functionality that each project provides to form
    the three-tier application. Let’s start by creating the VS solution structure.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Creating projects and configuring dependencies
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the boring inevitable part, creating the solution and the projects and
    then linking them together. In the following section, we will take the command
    line approach rather than the UI.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: I have added a text file, `create-projects.bat`, to the project source control
    that contains all the command lines, so you don’t have to write them manually.
    You can copy and paste this file to your desired directory, then, from your command
    line, execute the file.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the list of commands that will create your VS solution and
    its projects:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'From your OS console, navigate to the directory where you want to create your
    new solution and execute the following to create the solution file:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Execute this to create the projects and notice that we are using a different
    template for each project:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the projects to the solution:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now let’s set up dependencies between projects:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And the last bit is adding the required NuGet packages to the project. The
    domain project will communicate with Cosmos DB using the Cosmos SDK from the `Microsoft.Azure.Cosmos`
    package. Add this library to the `Domain` project as such:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The unit testing project will require `NSubstitute` for mocking, so let’s add
    its NuGet:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For visual inspection, you can open the solution file with VS, and it should
    look as such:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – A view of VS Solution Explorer ](img/Figure_10.3_B18370.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – A view of VS Solution Explorer
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, your solution structure should look similar.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Now that the project structure is in place, we will modify the code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the domain project
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the domain analysis in [*Chapter 8*](B18370_08_RN.xhtml#_idTextAnchor209),
    *Designing an Appointment Booking App*, we have created a list of the domain objects.
    I will not go through them again; I will just create and add them to the `Domain`
    project under `DomainObjects`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Added domain objects ](img/Figure_10.4_B18370.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Added domain objects
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'These are just data structures with no business logic. Here is the source code
    of one of them, the `Customer` domain object:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can view the rest of the files in the chapter’s GitHub repository online.
    This is the interface of the previous class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`IEntity` is an interface that ensures every domain object that is going to
    be persisted to a document container has an `Id`.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '`Id` is a string as this is what a document DB is expecting and usually, but
    not necessarily, the string is a `GUID`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: What is the relationship between our document containers and our domain objects?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Designing your containers
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I am assuming that you are familiar with the basics of document DBs, so I won’t
    be going into much detail. Let me start first by defining what a **container**
    is so that we have the same understanding across the chapter. A container is a
    storage unit that stores a similar document type. A container in a document DB
    shares similar characteristics to a table of a relational DB.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: There are many schools and opinions regarding designing containers and the factors
    to take into consideration, but our focus in this book is TDD, so we shall keep
    this short and to the point. Obviously, designing in DDD, while it has some guidelines,
    is still a subjective process. It feels that our aggregate routes, `Service`,
    `Employee`, `Customer`, and `Appointment`, are direct contenders for becoming
    containers, so we will set them to be.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need a way for our domain services to interact with the database. This
    is done through the repository pattern.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the repository pattern
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our containers are now defined. We just need the mechanism of interacting with
    these containers. DDD employs the repository pattern for this purpose. Let’s shed
    some light on the role of the pattern and where it sits in our application.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the repository pattern
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The repository layer is code that knows how to interact with a database, it
    doesn’t matter what type of database is underlying (it doesn’t matter whether
    this is Cosmos, SQL Server, a text file, or others), document, relational, or
    others. The layer is meant to isolate the domain layer from understanding the
    specifics of the database. Instead, the domain services will only be concerned
    about what data to persist rather than how they will be persisted.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'The next diagram shows the repository as the bottom layer in the domain layer:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – The repositories within DDD ](img/Figure_10.5_B18370.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – The repositories within DDD
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: You can see from the diagram that any domain object to be persisted in the database
    passes through the repositories layer.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中可以看出，任何要持久化到数据库的域对象都会通过存储库层。
- en: 'The common practice of creating a repository is creating a repository per container.
    So, for our application, we will have four repositories:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 创建存储库的常见做法是每个容器创建一个存储库。因此，对于我们的应用程序，我们将有四个存储库：
- en: '`ServiceRepository`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServiceRepository`'
- en: '`CustomerRepository`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CustomerRepository`'
- en: '`AppointmentRepository`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppointmentRepository`'
- en: '`EmployeeRepository`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmployeeRepository`'
- en: Given that we will have to unit test our implementation, our repositories need
    to be unit test-ready.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们必须要对实现进行单元测试，因此我们的存储库需要是单元测试就绪的。
- en: Repositories and unit testing
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 存储库和单元测试
- en: We suddenly started speaking about repositories in a chapter about TDD. The
    reason is that when you think of unit testing, the first thing that comes to mind
    is dependencies and how to isolate the database.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们突然在关于 TDD 的章节中开始讨论存储库。原因是当你想到单元测试时，首先想到的是依赖项以及如何隔离数据库。
- en: Repositories are the answer to this question, as they should provide the abstraction
    necessary to convert the database into an injectable dependency. You will see
    this clearly later on in this chapter.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库是解决这个问题的答案，因为它们应该提供将数据库转换为可注入依赖项所需的抽象。你将在本章后面清楚地看到这一点。
- en: Note
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you have worked with a relational database using an **object-relational mapper**
    (**ORM**) such as **Entity Framework** or **NHibernate**, then you have probably
    not used the repository pattern directly as the ORM frameworks eliminate the need
    to use it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用过像 **Entity Framework** 或 **NHibernate** 这样的对象关系映射器（ORM）与关系数据库一起工作，那么你可能没有直接使用存储库模式，因为
    ORM 框架消除了使用它的需要。
- en: You will see that our repositories will have interfaces that will allow them
    to be injection-ready. Enough of the theory and let me show you some code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到我们的存储库将具有接口，这将使它们能够进行注入就绪。理论就到这里，让我给你展示一些代码。
- en: Implementing the repository pattern
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现存储库模式
- en: 'Now that you have an idea about what repositories are, let’s start with an
    example. One of the repositories needed is `ServiceRepository`, which will interact
    with the Service repository:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对存储库有了概念，让我们从一个例子开始。所需的存储库之一是 `ServiceRepository`，它将与服务存储库交互：
- en: '![Figure 10.6 – The Service repository ](img/Figure_10.6_B18370.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – 服务存储库](img/Figure_10.6_B18370.jpg)'
- en: Figure 10.6 – The Service repository
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 服务存储库
- en: 'The `ServiceRepository` class contains methods for adding a service, deleting
    it and searching for a specific service, and more. Let’s pick a random method
    from the `GetActiveService` repository class:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServiceRepository` 类包含添加服务、删除服务和搜索特定服务等方法。让我们从 `GetActiveService` 存储库类中随机选择一个方法：'
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The method above uses Cosmos DB-specific code to access the database and returns
    a service by its ID.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的方法使用针对 Cosmos DB 的特定代码来访问数据库，并通过其 ID 返回一个服务。
- en: Note that the repository is implementing the `IServiceRepository` interface,
    which will become handy later during unit testing.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到存储库正在实现 `IServiceRepository` 接口，这在单元测试期间会很有用。
- en: There is plenty of repetition in how a repository interacts with a container.
    It stores a document, it reads a document, it deletes a document, it searches
    for a document, and so forth. So, we can create a small framework to embed these
    behaviors and reduce the repeated code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库与容器交互的方式有很多重复。它存储文档，读取文档，删除文档，搜索文档，等等。因此，我们可以创建一个小的框架来嵌入这些行为，并减少重复的代码。
- en: Utilizing a repository pattern framework
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用存储库模式框架
- en: 'Every time I’ve seen a project accessing a document DB, I notice that the developers
    create a small repository framework in advance to simplify the code. Here is an
    excerpt from a framework that I created to access Cosmos DB, the `CosmosRepository<T>`
    class, which is inherited by all repositories:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我看到一个项目访问文档数据库时，我都会注意到开发者提前创建了一个小的存储库框架来简化代码。以下是我创建的一个用于访问 Cosmos DB 的框架的摘录，即
    `CosmosRepository<T>` 类，它是所有存储库的基类：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code above provides the repository with the basic methods required to interact
    with the database, such as `AddItemAsync`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码为存储库提供了与数据库交互所需的基本方法，例如 `AddItemAsync`。
- en: Going into details about the specifics of Cosmos DB is beyond the scope of the
    book, but the code is easy to read and you can find the complete implementation
    in the `Uqs.AppointmentBooking.Domain/Repository` directory in the source code.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 详细介绍 Cosmos DB 的具体细节超出了本书的范围，但代码易于阅读，你可以在源代码的 `Uqs.AppointmentBooking.Domain/Repository`
    目录中找到完整的实现。
- en: Now that we have created the repositories, for development purposes, we might
    need some test data to fill the pages with some meaningful data. We shall do this
    next.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了仓库，为了开发目的，我们可能需要一些测试数据来填充页面，使其包含一些有意义的数据。我们将在下一步做这件事。
- en: Adding seed data
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加种子数据
- en: Newly created DBs have empty containers, and the `seed` class is meant to pre-populate
    the tables with sample data.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的数据库具有空容器，`seed` 类旨在预先填充表中的示例数据。
- en: I will not list the code here as it is outside the scope of the chapter, but
    you can look at the code in the `Domain` project in `Database/SeedData.cs`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里列出代码，因为它超出了本章的范围，但你可以在 `Database/SeedData.cs` 中的 `Domain` 项目的代码中查看。
- en: We’ve just finished the setup for the `WebApi` project that is going to be consumed
    by the website, so let’s create the website next.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚完成了 `WebApi` 项目的设置，该项目将被网站使用，所以让我们创建网站。
- en: Setting up the website project
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置网站项目
- en: Phase I of this implementation includes creating a website to access the APIs
    to provide a UI for the user, which we did previously in this chapter by command
    line. However, website implementation is outside the scope of this chapter and
    the book, in general, as it is not related to TDD, so I will not be going through
    the code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本实施的第一阶段包括创建一个网站来访问 API，为用户提供 UI，这是我们之前在本章中通过命令行完成的。然而，网站实现超出了本章的范围，也超出了本书的范围，因为它与
    TDD 无关，所以我不打算展示代码。
- en: Although, we are interested in one aspect – what does `Website` require from
    `WebApis`? We will need to understand this in order to build the required functionality
    in `WebApis` the TDD way.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们感兴趣的是一方面——`网站` 需要什么 `WebApis`？我们需要理解这一点，以便以 TDD 的方式在 `WebApis` 中构建所需的功能。
- en: We will answer this question bit by bit in the next section of this chapter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的下一节逐步回答这个问题。
- en: In this section, we did the setup and configuration aspect of the project, and
    we have not done anything that is affected by TDD. You may have noticed that I
    referred you to the companion source code on multiple occasions, as I wanted to
    keep the focus on the next section while still providing you with the source code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们完成了项目的设置和配置方面，我们没有做任何受 TDD 影响的事情。你可能已经注意到，我多次提到了配套源代码，因为我想要保持对下一节的关注，同时仍然提供源代码。
- en: Implementing the WebApis with TDD
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TDD 实现 WebApis
- en: To build the WebApi project, we are going to look at each requirement from [*Chapter
    8*](B18370_08_RN.xhtml#_idTextAnchor209), *Designing an Appointment Booking App*,
    and provide the implementation that satisfies it using the TDD style.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建 WebApi 项目，我们将查看来自 [*第 8 章*](B18370_08_RN.xhtml#_idTextAnchor209)，*设计预约预订应用*
    的每个需求，并使用 TDD 风格提供满足这些需求的实现。
- en: The requirements are all stated in terms of `Website` and its functionality,
    and they do not dictate how to build our APIs. `Website` will have to call `WebApis`
    for any business logic as it has no access to the DB and does UI-related business
    logic only.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 需求都是用 `网站` 和其功能来表述的，并没有规定如何构建我们的 API。`网站` 将必须调用 `WebApis` 来执行任何业务逻辑，因为它无法访问数据库，并且只处理与
    UI 相关的业务逻辑。
- en: In this section, we will go through working in TDD mode, taking into consideration
    our persistence provider, the repositories.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过 TDD 模式进行工作，考虑到我们的持久化提供者，即仓库。
- en: Implementing the first story
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现第一个故事
- en: 'The first story in our requirement is very easy. The website is going to display
    all the available services that we have. Since the website will request this data
    from `WebApi` through a RESTful API call, the domain layer will have a service
    that will return this list. Let’s dig further if the website is to display this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需求中的第一个故事非常简单。网站将展示我们拥有的所有可用服务。由于网站将通过 RESTful API 调用从 `WebApi` 请求这些数据，因此域层将有一个服务来返回这个列表。如果网站要显示这些内容，让我们进一步挖掘：
- en: '![Figure 10.7 – A UI of the requirements of Story 1 ](img/Figure_10.7_B18370.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7 – 故事 1 的需求 UI](img/Figure_10.7_B18370.jpg)'
- en: Figure 10.7 – A UI of the requirements of Story 1
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 故事 1 的需求 UI
- en: 'It will need to issue a RESTful call to the WebApi, which can look as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 它将需要向 WebApi 发出 RESTful 调用，这可能看起来如下所示：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This UI will require a few data properties that should be returned by this
    API. So, the fetched JSON can look like an array of this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个UI将需要一些应该由这个API返回的数据属性。所以，获取的JSON可以看起来像这样一个数组：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can see where each part is used on the page, but maybe `ServiceId` is not
    very clear. It will be used to construct the URL of the *Select* hyperlink. So,
    we can now design the contract type that will render this JSON, which could look
    like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在页面上看到每个部分的使用情况，但也许`ServiceId`不是很清楚。它将被用来构造*Select*超链接的URL。因此，我们现在可以设计一个将渲染此JSON的合约类型，它可能看起来像这样：
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This `record` contract will render the previous JSON code, and the full returned
    array contract could look like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`record`合约将渲染之前的JSON代码，完整的返回数组合约可能看起来像这样：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can find these contract types and all the other contracts in the `Contract`
    project.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`Contract`项目中找到这些合约类型和所有其他合约。
- en: Adding the first unit test via TDD
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过TDD添加第一个单元测试
- en: 'Thinking along the lines of DDD, we will have a domain service called `ServicesService`,
    which will handle retrieving all the available services. So, let’s have the structure
    of this service. We will create it in the `Domain` project under `Services`. Here
    is the code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着DDD的思路，我们将有一个名为`ServicesService`的领域服务，它将处理检索所有可用服务。所以，让我们看看这个服务的结构。我们将在`Services`下的`Domain`项目中创建它。以下是代码：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There is nothing special here. I have just helped VS understand when I type
    `ServicesService`, it will guide me to this class.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的。我只是帮助VS理解，当我输入`ServicesService`时，它会引导我到这个类。
- en: Note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I have added the previous `ServicesService` class manually. Some TDD practitioners
    like to code-generate this file while they are writing their unit test rather
    than writing it first. Any method is fine as long as you are more productive.
    I chose to create the file first because sometimes VS creates this file in a different
    directory from where I intend to.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经手动添加了之前的`ServicesService`类。一些TDD实践者喜欢在编写单元测试时生成这个文件，而不是先编写它。只要你能更高效，任何方法都可以。我选择先创建文件，因为有时候VS会创建这个文件在不同的目录下，而不是我想要的目录。
- en: 'I will create my unit tests class, which is called `ServicesServiceTests`,
    with the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我将创建我的单元测试类，命名为`ServicesServiceTests`，以下代码：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: I have added `IServiceRepository` immediately because I know that I am going
    to be dealing with the database in my unit tests and this interface is going to
    be my mocked dependency.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我立即添加了`IServiceRepository`，因为我知道我将在单元测试中处理数据库，这个接口将是我模拟的依赖。
- en: 'Now, I need to think of what I need from my service and build a unit test accordingly.
    The straightforward way to start is to pick the easiest scenario. If we have no
    barber service, then no service is returned:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我需要考虑我需要从我的服务中获取什么，并据此构建一个单元测试。最直接的方法是从最简单的情况开始。如果我们没有理发服务，则不会返回任何服务：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: I have decided in the test that there will be a method named `GetActiveServices`,
    and when this method is called, it will return a collection of active services.
    At this stage, the code doesn’t compile; as such, a method doesn’t exist. We have
    got our TDDs fail!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我在测试中决定将有一个名为`GetActiveServices`的方法，当这个方法被调用时，它将返回一个活动服务的集合。在这个阶段，代码无法编译；因此，不存在该方法。我们已经得到了我们的TDD失败！
- en: 'Now, we can instruct VS to generate this method, and then we can write the
    implementation:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以指示VS生成这个方法，然后我们可以编写实现：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is getting, through the repository, all the available services, and since
    the repository is not mocked to return any service, an empty collection will return.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过仓库获取所有可用服务，由于仓库没有模拟返回任何服务，所以会返回一个空集合。
- en: If you run the test again, it will pass. This is our TDD test pass. There is
    no need for the refactor stage, as this is a simple implementation. Congratulations,
    you have finished your first test!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次运行测试，它将通过。这是我们TDD测试通过。由于这是一个简单的实现，不需要重构阶段，恭喜你，你已经完成了第一个测试！
- en: Note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This test is simple, and it seems like a waste of time. However, this test is
    a valid test case, and it also helps us create our domain class and inject the
    right dependencies. Starting with a simple test helps to progress in steady steps.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试很简单，看起来像是在浪费时间。然而，这是一个有效的测试用例，它还帮助我们创建领域类并注入正确的依赖。从一个简单的测试开始可以帮助我们稳步前进。
- en: Adding the second unit test via TDD
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过TDD添加第二个单元测试
- en: 'The second feature that we need to add is the ability to get active services.
    So, let’s start with this unit test:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加的第二个功能是获取活动服务的功能。所以，让我们从这个单元测试开始：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What is interesting here is the way we are mocking the `GetActiveServices` repository
    method. The method is mocked to return an array of `Service` when the service
    calls it. This is how we have substituted the database for the relevant repository.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的是我们模拟`GetActiveServices`存储库方法的方式。当服务调用它时，该方法被模拟以返回一个`Service`数组。这就是我们用数据库替换了相关存储库的方式。
- en: If you run this, it should pass from the first time without failure, so it is
    not going to fail then pass. It just happened to be this way. In this scenario,
    I would debug my code to see why the unit test passed without me implementing
    the code, and it is obvious the implementation code for the first unit test made
    was enough to cover the second scenario.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行这个程序，它应该一次通过而不会失败，所以它不会先失败再通过。这只是一个偶然。在这种情况下，我会调试我的代码，看看为什么单元测试在没有我实现代码的情况下通过了，很明显，第一个单元测试的实现代码已经足够覆盖第二个场景。
- en: This was an easy requirement. In fact, all the stories are straightforward except
    story number 5\. We will not list the other stories here because they are similar,
    but you can find them in the companion source code. Instead, we will focus on
    story number 5 as its complexity matches a real-life production code and would
    reveal the main benefit of TDD.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的要求。实际上，除了第五个故事之外，所有故事都很直接。我们不会在这里列出其他故事，因为它们很相似，但您可以在配套源代码中找到它们。相反，我们将专注于第五个故事，因为它的复杂性符合现实生活中的生产代码，并且会揭示TDD的主要好处。
- en: Implementing the fifth story (time management)
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现第五个故事（时间管理）
- en: This story is about a time management system. It tries to manage the barbers’
    time fairly, taking rest time into consideration. If you take a moment to think
    about this story, it is a complex one with many edge cases.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事是关于一个时间管理系统。它试图公平地管理理发师的时间，考虑到休息时间。如果您花点时间思考这个故事，它很复杂，有很多边缘情况。
- en: This story reveals the power of TDD as it will help you find a starting point
    and adds little incremental steps to build the requirement. When you finish, you
    will notice that you have automatically documented the story in the unit tests.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事揭示了TDD的力量，因为它将帮助您找到一个起点，并添加少量增量步骤来构建需求。当您完成时，您会注意到您已经自动在单元测试中记录了故事。
- en: In the next sections, we will find a way to start with the easier-to-implement
    scenarios and climb up to more sophisticated test scenarios.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将找到一种方法，从更容易实现的情况开始，逐步过渡到更复杂的测试场景。
- en: Checking for records
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查记录
- en: One gentle way to start our implementation that will make us think of the signature
    of the method is by checking the parameters.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一种温和的开始实现的方法是检查参数，这样我们会考虑方法的签名。
- en: 'Logically, to determine an employee’s availability, we need to know who this
    employee is by using `employeeId` and the length of the time required. The length
    can be acquired from the service by `serviceId`. A logical name for the method
    can be `GetAvailableSlotsForEmployee`. Our first unit test is this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 从逻辑上讲，为了确定员工的可用性，我们需要通过`employeeId`和所需时间的长度来知道这位员工是谁。长度可以通过`serviceId`从服务中获取。这个方法的一个合理的名字可以是`GetAvailableSlotsForEmployee`。我们的第一个单元测试就是这个：
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It doesn’t compile; it is a fail. Now create the method in `SlotsService`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 它无法编译；这是一个失败。现在在`SlotsService`中创建方法：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that you have the implementation in place, run the tests again, and they
    will pass. You can do the same for `employeeId` and follow what we did for `serviceId`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了实现，再次运行测试，它们将通过。您可以为`employeeId`做同样的事情，并遵循我们对`serviceId`所做的一切。
- en: Starting with the simplest scenario
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从最简单的情况开始
- en: 'Let’s add the simplest possible business logic to start with. Let’s assume
    that the system has one employee called Tom. Tom has no shifts available in the
    system. Also, the system has one service only:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加最简单的可能业务逻辑来开始。让我们假设系统有一个名为Tom的员工。Tom在系统中没有可用的班次。此外，系统只有一个服务：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can see how the repositories are being populated via mocking. This is how
    we set up our database and do the dependency injection. We were able to do this
    as `SlotsService` is accessing the database through the repositories and if the
    repositories are mocked, then we have replaced our database.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过模拟来查看如何填充存储库。这就是我们设置数据库和进行依赖注入的方式。我们之所以能够这样做，是因为`SlotsService`通过存储库访问数据库，如果存储库被模拟，那么我们就替换了我们的数据库。
- en: Note
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Replacing the database with mocked repositories is a hot interview question
    that goes like *how do you clean the database after each unit test?*. This is
    a trick question, as you don’t interact with the database during the unit test
    and you mock your repositories instead. The question comes in multiple variations.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 用模拟仓库替换数据库是一个热门的面试问题，其内容类似于*如何在每次单元测试后清理数据库？* 这是一个陷阱问题，因为在单元测试期间你并不与数据库交互，而是模拟你的仓库。这个问题有多种变体。
- en: 'This will fail, as we have `null` returned by the method, whatever the input
    is. We need to continue adding bits of code to the solution. We can start with
    the following code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这将失败，因为我们无论输入什么，方法都会返回`null`。我们需要继续添加代码片段来完善解决方案。我们可以从以下代码开始：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The previous code is exactly what is required to pass the test. The test is
    green now.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码正是通过测试所必需的。现在测试是绿色的。
- en: Elevating the scenarios’ complexity
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提高场景的复杂性
- en: 'The rest of the unit tests follow the same way of elevating test scenario complexity
    slightly. Here are other scenarios you might want to add:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的单元测试以相同的方式略微提高测试场景的复杂性。以下是一些你可能想要添加的场景：
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The previous test is, in fact, multiple tests (because we are using `Theory`)
    with each `InlineData` elevating complexity. As usual, do the red then green to
    let it pass before adding another suite of tests:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的测试实际上是多个测试（因为我们使用了`Theory`），每个`InlineData`都提高了复杂性。像往常一样，先做红色测试，再做绿色测试，以便在添加另一套测试之前通过：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is also a test with multiple `InlineData`. Obviously, we cannot fit all
    the code here, so please have a look in `SlotsServiceTests.cs` for the complete
    unit tests.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个包含多个`InlineData`的测试。显然，我们无法在这里放入所有代码，所以请查看`SlotsServiceTests.cs`以获取完整的单元测试。
- en: As you start adding more test cases, whether by using `Theory` with `InlineData`
    or using `Fact`, you will notice that the code complexity in the implementation
    is going up. This is all right! Do you feel the readability is suffering? Then
    it is time to refactor.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始添加更多的测试用例时，无论是使用`Theory`和`InlineData`，还是使用`Fact`，你都会注意到实现中的代码复杂性正在增加。这是正常的！你感觉可读性变差了吗？那么是时候重构了。
- en: Now you have the advantage of unit tests protecting the code from being broken.
    Refactoring when the method is doing what you want it to do is part of the *Red-Green-Refactor*
    mantra. In fact, if you look at `SlotsService.cs`, I did refactor to improve readability
    by creating multiple private methods.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了单元测试保护代码不被破坏的优势。当方法做你想要它做的事情时进行重构是*红-绿-重构*格言的一部分。实际上，如果你查看`SlotsService.cs`，我确实重构了，通过创建多个私有方法来提高可读性。
- en: This story is complex, I will give you that. I could have picked an easier example,
    and everybody would be happy, but real-life code has ups and downs and varies
    in complexity, so I wanted to include one sophisticated scenario following the
    pragmatism theme of the book.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事很复杂，我承认。我本可以选择一个更容易的例子，大家都会很高兴，但现实生活中的代码有起有落，复杂性各异，所以我想要包含一个复杂的场景，遵循书籍的实用主义主题。
- en: After this section, you might have some questions. I hope I am able to answer
    some of them below.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节之后，你可能会有一些问题。我希望我能在下面回答一些。
- en: Answering frequently asked questions
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回答常见问题
- en: Now that we have written the unit tests and the associated implementation, let
    me explain the process.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了单元测试和相关的实现，让我解释一下这个过程。
- en: Are these unit tests enough?
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这些单元测试足够了吗？
- en: The answer to this question depends on your target coverage and your confidence
    that all cases are covered. Sometimes, adding more unit tests increases the future
    maintenance overhead, so with experience, you would strike the right balance.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案取决于你的目标覆盖率以及你对所有情况都被覆盖的信心。有时，添加更多的单元测试会增加未来的维护开销，所以随着经验的积累，你会找到正确的平衡点。
- en: Why didn’t we unit test the controllers?
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么我们没有对控制器进行单元测试？
- en: The controllers should not contain business logic. We pushed all the logic to
    the services, then tested the services. What is left in the controllers is minimal
    code concerned with mapping different types to each other. Have a look at the
    controllers in `Uqs.AppointmentBooking.WebApi/Controllers` to see what I mean.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器不应该包含业务逻辑。我们将所有逻辑推送到服务中，然后测试服务。控制器中剩下的只是将不同类型映射到彼此的最小代码。查看`Uqs.AppointmentBooking.WebApi/Controllers`中的控制器，看看我的意思。
- en: Unit tests excel in testing business logic or areas where there are conditions
    and branching. The controllers in the coding style that we chose do not have that.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试在测试业务逻辑或存在条件和分支的区域方面表现卓越。我们选择的编码风格中的控制器没有这些。
- en: The controllers should be tested but through a different type of test.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器应该被测试，但通过不同类型的测试。
- en: Why didn’t we unit test the repositories implementation?
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么我们没有对代码库的实现进行单元测试？
- en: The repositories contain specific code for Cosmos DB with minimal to no business
    logic. The code there is interacting with the SDK directly and testing it doesn’t
    prove anything, as you will be making assumptions (through test doubles) about
    the behavior of the framework.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 代码库包含针对 Cosmos DB 的特定代码，其中包含最小或没有业务逻辑。那里的代码直接与 SDK 交互，测试它并不能证明任何问题，因为你将通过测试替身对框架的行为做出假设。
- en: Sometimes a repository contains a bit of business logic, such as `ServiceRepository`
    picking the active services only, rather than all services. It is still hard to
    test this logic as it is embedded in SQL-like syntax, which is hard to unit test.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有时一个代码库包含一些业务逻辑，例如 `ServiceRepository` 仅选择活动服务，而不是所有服务。这个逻辑仍然很难测试，因为它嵌入在类似 SQL
    的语法中，这使得单元测试变得困难。
- en: On the contrary, testing your repositories expands your unit tests footprint
    in a negative way, which makes your code more brittle.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，测试你的代码库以负面的方式扩大了单元测试的范围，这使得你的代码更加脆弱。
- en: Some developers still unit test their repositories for code coverage purposes,
    but the mistake here is that code coverage is the combination of all types of
    tests and not just unit tests. Your repositories should be covered by a different
    type of test such as Sintegration testing.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者仍然为了代码覆盖率的目的对他们的代码库进行单元测试，但这里的错误是代码覆盖率是所有类型测试的组合，而不仅仅是单元测试。你的代码库应该由不同类型的测试，如
    S集成测试来覆盖。
- en: Did we test the system enough?
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们是否测试了系统足够？
- en: No, we didn’t! We did the unit tests part. We have not tested the controllers
    or the boot of the system (the content of `Program.cs`) and other small bits of
    the code.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 不，我们没有！我们完成了单元测试部分。我们没有测试控制器或系统的启动（`Program.cs` 的内容）以及其他一些小的代码片段。
- en: We did not test them via unit tests, as they are not business logic. However,
    they need testing, but unit tests are not the best testing type to check for the
    quality of these areas. You can cover these by other types of testing such as
    integration, Sintegration, and system tests, as per our discussion in [*Chapter
    4*](B18370_04.xhtml#_idTextAnchor097), *Real Unit Testing with Test Doubles*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有通过单元测试测试它们，因为它们不是业务逻辑。然而，它们需要测试，但单元测试并不是检查这些区域质量的最佳测试类型。你可以通过其他类型的测试来覆盖这些区域，例如集成测试、S集成测试和系统测试，正如我们在
    [*第 4 章*](B18370_04.xhtml#_idTextAnchor097)，*使用测试替身的真实单元测试* 中讨论的那样。
- en: We omitted testing some areas, how can we achieve high coverage?
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们省略了一些区域的测试，我们如何实现高覆盖率？
- en: Some areas of the code are not unit tested, such as `Program.cs` and the controllers.
    If you are aiming for high code coverage, such as 90%, you might not achieve it
    via unit testing alone, as there is a good amount of code that went here.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的一些区域没有进行单元测试，例如 `Program.cs` 和控制器。如果你目标是高代码覆盖率，例如 90%，你可能无法仅通过单元测试实现，因为这里有很多代码。
- en: Achieving coverage by unit tests alone is unfair, or the developers would start
    cheating by adding meaningless tests to boost coverage. These tests do more harm
    than good as they will create a maintenance overhead.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过单元测试实现覆盖率是不公平的，否则开发者会通过添加无意义的测试来提高覆盖率进行作弊。这些测试弊大于利，因为它们将产生维护负担。
- en: Coverage calculation should include other types of tests, rather than relying
    on units alone. If this is the case, 90% is a realistic target and can lead to
    a high-quality product.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率计算应包括其他类型的测试，而不仅仅是依赖单元测试。如果是这样，90% 是一个现实的目标，并且可以导致高质量的产品。
- en: Sometimes it is hard to configure a coverage meter tool to measure the sum of
    multiple test types, so in this case, it makes sense to lower your coding coverage
    target to maybe 80% or so. Because not all tests run locally, a local test coverage
    tool (such as *Fine Code Coverage*, which was discussed earlier, in [*Chapter
    6*](B18370_06.xhtml#_idTextAnchor140), *The FIRSTHAND Guidelines of TDD*), can
    only calculate the coverage for the locally executed tests.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 有时很难配置覆盖率测量工具来测量多种测试类型的总和，因此在这种情况下，将你的编码覆盖率目标降低到大约 80% 是有意义的。因为并非所有测试都在本地运行，本地测试覆盖率工具（例如前面讨论过的
    *Fine Code Coverage*），只能计算本地执行的测试覆盖率。
- en: So the short answer is your coverage should be made to include all your testing
    types, which takes some effort. Or you can reduce your coverage to unit test only
    and go for lower coverage.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen implementing realistic stories by setting up the system with repositories
    and Cosmos DB, then building it a bit at a time by incrementally adding unit tests
    and increasing the complexity with every additional unit test.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: We had to select multiple important scenarios to encourage you to examine the
    full source code. Otherwise, the pages will be filled with code.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: If you have read and understood the code, then I assure you that this is the
    peak of the complexity, as other chapters should be easier to read and follow.
    So congratulations, you have made it through the hard part of this book! I trust
    you can now go ahead and start your TDD-based project with a document DB.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: This chapter ended with the implementation of a realistic project based on TDD.
    Hopefully, by understanding this part of the book, you are equipped to write your
    TDD-based project with a relational DB or a document DB.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: The next part of the book goes about introducing unit tests to your project
    and organization, dealing with existing legacy code, and building a continuous
    integration system. I call that the fun part, where you take your TDD knowledge
    and expand it.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Applying TDD to Your Projects'
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know how to build an application with TDD, we want to take the
    next step. In this part, we will cover how to combine unit testing with continuous
    integration, how to deal with legacy projects, and how to implement TDD in your
    organization. The following chapters are included in this part:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B18370_11.xhtml#_idTextAnchor265), *Implementing Continuous
    Integration with GitHub Actions*'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B18370_12.xhtml#_idTextAnchor279), *Dealing with Brownfield
    Projects*'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B18370_13_RN.xhtml#_idTextAnchor297), *The Intricacies of Rolling
    Out TDD*'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
