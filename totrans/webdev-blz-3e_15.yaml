- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving from, or Combining with, an Existing Site
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will take a look at how we can combine different technologies
    and frameworks with Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: What if we already have a site?
  prefs: []
  type: TYPE_NORMAL
- en: There are different options when it comes to moving from an existing site; the
    first question is, do we want to move from it, or do we want to combine it with
    the new technology?
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft has a history of making it possible for technologies to co-exist,
    and this is what this chapter is all about.
  prefs: []
  type: TYPE_NORMAL
- en: How can we use Angular and React in our Blazor site, or how can we introduce
    Blazor into an existing Angular and React site?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing web components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring custom elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the Blazor component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Blazor to an Angular site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Blazor to a React site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Blazor to MVC/Razor Pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding web components to a Blazor site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migrating from web forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining technologies can be very useful, either because we can’t convert a
    whole site in one go or because other technologies are a better fit for what we
    are trying to accomplish.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, I prefer using one technology on my site, not mixing Blazor
    with Angular or React. But during a migration period or if our team is mixed,
    there are benefits to mixing.
  prefs: []
  type: TYPE_NORMAL
- en: There is a cost to mixing technologies, which we will look at throughout the
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: While writing this chapter, revisiting Angular and React, I must take the opportunity
    to say how much I love the Razor syntax. React is JavaScript with HTML tags inside,
    and Angular has templates, which I find pretty nice and remind me of what the
    Razor syntax looks like.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are a lot of things involved: almost 300 MB of Node.js modules,
    npm, TypeScript, and webpack. Well, the list is long.'
  prefs: []
  type: TYPE_NORMAL
- en: I love working with Blazor because I don’t need to work with everything I just
    mentioned. In my opinion, Blazor has the best syntax out of the three options.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a reference chapter and is not connected in any way with the
    other chapters of the book.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code for this chapter’s examples at [https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter15](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter15).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing web components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To work with JavaScript, whether it’s bringing JavaScript to Blazor or bringing
    Blazor into JavaScript, we can use a technology called web components.
  prefs: []
  type: TYPE_NORMAL
- en: Web components are a set of web platform APIs that allow us to create new, custom,
    reusable HTML tags. They are packaged in an encapsulated way, and we can use them
    very similarly to how we use components in Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: The really nice thing is that we can use them in any JavaScript library or framework
    that supports HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Web components are built on top of existing web standards like shadow DOM, ES
    modules, HTML templates, and custom elements.
  prefs: []
  type: TYPE_NORMAL
- en: We will also recognize some of these technologies or variations of them in Blazor.
    Shadow DOM is the same as Blazor’s render tree, and ES modules are the type of
    JavaScript modules we looked at in *Chapter 10*, *JavaScript Interop*.
  prefs: []
  type: TYPE_NORMAL
- en: The technology we are going to take a look at in this chapter is **custom elements**.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring custom elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To bring Blazor into an existing Angular or React site, we use a feature called
    `CustomElements`. It was introduced as an experimental feature in .NET 6 and has
    been a part of the framework since .NET 7.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to create parts of your site in Blazor without having to migrate
    fully over to Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: For this feature to work, we need to have an ASP.NET backend or manually make
    sure the `_framework` files are available. This is so that we can serve the Blazor
    framework files.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways of running `CustomElements`;we can run it as Blazor WebAssembly
    or as the Blazor Server. Since we are adding Blazor to a client framework like
    React or Angular, the most relevant method is to run it as Blazor WebAssembly.
    Therefore, the examples in these first sections will be for Blazor WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: In the GitHub repo, there is a folder called `CustomElements` in which you will
    find the code for the projects, from which we will see sample code in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that since the components are being served and used on
    the client, there is nothing that hinders us (or people who mean us harm) from
    decompiling the code (if we are using WebAssembly). This is something client-side
    developers of all frameworks deal with all the time, but it is worth mentioning
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Blazor component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we need to try out is a Blazor component. I have created a `counter`
    component inside a Blazor WebAssembly project named `BlazorCustomElements`.
  prefs: []
  type: TYPE_NORMAL
- en: The default template comes with a lot of things, and the repo project is stripped
    to the bare minimum, so it is easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component is nothing different from what we have seen in the book previously;
    it’s a `counter` component with a parameter that sets how much the counter should
    count up. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The project also needs a reference to the NuGet package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Program.cs`, we need to register the component/custom element like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That’s it for the Blazor project.
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to use our custom element.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Blazor to an Angular site
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s look at how we can add Blazor to an existing Angular site. This demo is
    based on the Angular and ASP.NET Core template in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: The folder is called `Angular`.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need a reference to our Blazor library. I added the `BlazorCustomElement`
    project as a reference to the server project.
  prefs: []
  type: TYPE_NORMAL
- en: We need a reference to the `Microsoft.AspNetCore.Components.WebAssembly.Server
    NuGet` package; this is so we can serve the framework files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our site serve the framework files, we need to add the following to
    `Program.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, Angular will be upset when we add our custom element because it
    does not recognize the tag. To fix this, we need to tell Angular that we are using
    custom elements. In the `angularproject.client/src/app/app.module.ts`, add the
    following things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Make sure to replace the row that already has an import for `NgModule`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A bit further down in the same file, add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now Angular is okay with having custom elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, it’s time to add our component. In `angularproject.client /src/app/app.component.html`,
    we add our custom tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we set the `increment-amount` parameter to `10`, which will increase
    the counter by `10` every time we click it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this all work, we need to load a couple of JavaScript scripts. In `angularproject.client/src/index.html`,
    we need to add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We have one last thing we need to fix. When running the Angular project, it
    spins up a developer server. Actually, it spins up two: one for the ASP.NET backend
    and one for the Angular frontend. We need to make the Angular server send all
    the framework requests to the ASP.NET backend.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the default project template, this is already done for the `/weatherforecast`
    path. Add the following code to the `angularproject.client/proxy.conf.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We tell the developer server that if there is a request going to `weatherforecast`,
    `_framework`, or `_content`, we want to redirect that request to the ASP.NET backend.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a working Angular/Blazor WebAssembly hybrid. I was honestly amazed
    at how easy and straightforward this was the first time I tried it. It makes it
    so easy to include some Blazor components on your Angular site, so you can convert
    it into Blazor step by step, and component by component.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will do the same using a React site.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Blazor to a React site
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding Blazor to a React site is very similar to Angular. This demo is based
    on the React and ASP.NET Core template in Visual Studio. The project is called
    `ReactProject`.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need a reference to our Blazor library, and I added the `BlazorCustomElement`
    project as a reference.
  prefs: []
  type: TYPE_NORMAL
- en: We need a reference to the `Microsoft.AspNetCore.Components.WebAssembly.Server
    NuGet` package; this is so we can serve the framework files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our site serve the framework files, we need to add the following to
    `Program.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, it’s time to add our component. In `reactproject.client/src/ /App.tsx`,
    we add our custom tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we set the `increment-amount` parameter to `10`, which will increase
    the counter by `10` every time we click it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this all work, we need to load a couple of JavaScript. In `reactproject.client/index.html`,
    we need to add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: These scripts will make sure our components load.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one last thing we need to fix. When running the React project, it spins
    up a developer server. Actually, it spins up two: one for the ASP.NET backend
    and one for the React frontend.'
  prefs: []
  type: TYPE_NORMAL
- en: We need to make the React server send all the framework requests to the ASP.NET
    backend. In the default project template, this is already done for the `/weatherforecast`
    path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `reactproject.client/vite.config.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We tell the developer server that if a request goes to `weatherforecast`, `_framework`,
    or `_content`, we want to redirect that request to the ASP.NET backend.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a working React/Blazor WebAssembly hybrid. This is very similar
    to Angular, and I was amazed at how easy and straightforward this was as well.
    It makes it so easy to include some Blazor components on your React site, so you
    can convert it to Blazor step by step, component by component.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will do the same using a Razor Pages site.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Blazor to MVC/Razor Pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I started with Blazor, this was exactly the scenario we wanted to address.
    We had an MVC/Razor Pages mix, and it was time for an upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: We solved it by implementing Razor Pages that referred to Razor components.
    Looking back at it now, it was not a pretty solution, at least not for a while,
    until we got to the point where most of the code was rewritten in Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: The challenge is that if we navigate to a page that has a Blazor component (a
    Razor component), that page is connected to the server and establishes a WebSocket.
    If we navigate away from a Blazor page to an MVC page, for example, we reload
    the entire page, and the script gets reloaded as well. A new connection was established,
    leaving the old one on the server for 3 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t have many users, and for us, that technique works long enough for us
    to finish the migration and launch a new Blazor version of the site.
  prefs: []
  type: TYPE_NORMAL
- en: But I have some good news!
  prefs: []
  type: TYPE_NORMAL
- en: We can also use the same custom elements to run on a Razor Pages site.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look!
  prefs: []
  type: TYPE_NORMAL
- en: The project is called `RazorPagesProject`.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous examples with Angular and React, those technologies are client
    side; therefore, we used WebAssembly. Razor Pages is server side, and even though
    we could use WebAssembly here as well, this is an excellent opportunity to take
    a look at making the **custom component** use Blazor Server.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need a reference to our Blazor library. I added the `BlazorCustomElement`
    project as a reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we need to enable Blazor Server in our Razor Pages by adding the following
    code to `Program.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In `Pages/Shared/_Layout.cshtml`, we need to add the JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we add the script for Blazor Server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, we need to add our component. In `Pages/Index.cshtml`,
    we add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: And we are done; the custom component is now running inside our Razor Pages
    site (which, of course, is an ASP.NET site with Razor Pages turned on).
  prefs: []
  type: TYPE_NORMAL
- en: The cool part is that with only a few changes, we can switch this implementation
    to run WebAssembly instead of Blazor Server for the Blazor components.
  prefs: []
  type: TYPE_NORMAL
- en: Again, I am super impressed by this; it makes it so simple to migrate existing
    sites to Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at how we can use Angular or React controls on our Blazor
    website.
  prefs: []
  type: TYPE_NORMAL
- en: Adding web components to a Blazor site
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have looked at adding Blazor to an existing Angular, React, and even MVC/Razor
    Pages site.
  prefs: []
  type: TYPE_NORMAL
- en: But sometimes, that perfect library you love to use might not have a Blazor
    counterpart. We know that we can make a JavaScript interop and build it ourselves,
    but can we also use Angular and React libraries from Blazor?
  prefs: []
  type: TYPE_NORMAL
- en: We have two options here; either we can convert our site into an Angular/React
    site and use those examples, or we can convert the JavaScript library into a web
    component and use it from Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we haven’t used npm or anything like that because, in most cases,
    we don’t need it. But now we are mixing technologies, and for that, npm is the
    easiest way. `npm` is outside the scope of this book, so I will not go into any
    details about it.
  prefs: []
  type: TYPE_NORMAL
- en: How to convert Angular/React or anything else into a web component is also outside
    the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The project is called `BlazorProject`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can browse some of the web components on this site: [https://www.webcomponents.org/](https://www.webcomponents.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: I found a Markdown editor from GitHub. Even though we are not implementing it
    on our blog, feel free to go back and do so if you want to.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can read about the editor here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.webcomponents.org/element/@github/markdown-toolbar-element](mailto:https://www.webcomponents.org/element/@github/markdown-toolbar-element)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the required JavaScript files, we need to set up `npm`. In the project
    folder (`BlazorProject.Client`), run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will bring down the JavaScript we need.
  prefs: []
  type: TYPE_NORMAL
- en: Next, copy the `BlazorProject\node_modules\@github\markdown-toolbar-element\`
    folder to the `wwwroot` folder (in the server project) and include it in the project.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the JavaScript will be accessible from our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `app.razor`, we need to add a reference to the JavaScript, and we put it
    below the Blazor JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This component is an ES6 module, so we set the type to `"module"`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, all that is remaining is to add our component. In the demo project, I added
    it to the `MarkdownDemo` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the text area with binding to a C# variable, `markdown`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The C# variable changes as soon as we edit the textbox, either by using the
    toolbar or typing some text.
  prefs: []
  type: TYPE_NORMAL
- en: We have integrated a web component into our Blazor project, which binds to a
    C# variable.
  prefs: []
  type: TYPE_NORMAL
- en: This is super powerful and gives us new possibilities to add existing functionality
    to our Blazor site.
  prefs: []
  type: TYPE_NORMAL
- en: Now we know how to handle SPA frameworks like React and Angular. But what about
    server frameworks like Web Forms? This is what we will look at next.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating from Web Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Last but not least, we have **web forms**.
  prefs: []
  type: TYPE_NORMAL
- en: There is honestly not any good upgrade path for web forms; there was a project
    that aimed for code reuse when migrating to Blazor, but it is not being actively
    worked on.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we should know is that Blazor is in many ways very similar to
    web forms, so the learning curve to get to Blazor is almost nonexistent since
    we have state management in web forms as well as Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: There are some migration strategies where you would use **Yet Another Reverse
    Proxy** (**YARP**). Still, my recommendation would be to migrate a part of the
    website to Blazor and have two sites running, until we reach the point where it
    is feature-complete. Moving to Blazor is fairly quick to do, and in the end, I
    believe it will save you time.
  prefs: []
  type: TYPE_NORMAL
- en: When we moved our site from MVC to Blazor, we realized that, in some cases,
    it was faster to rewrite the component to Blazor than trying to solve it in MVC.
  prefs: []
  type: TYPE_NORMAL
- en: Web forms should be even faster to convert since the backend code is more similar
    to Blazor than MVC.
  prefs: []
  type: TYPE_NORMAL
- en: So, what should we do? Should we upgrade or keep using web forms? Upgrade –
    you will not be disappointed!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed adding Blazor to other technologies, like Angular, React, and Razor
    Pages, using web components in this chapter. We looked at how to add web components
    to a Blazor project and leverage JavaScript libraries in our Blazor app.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading a current site to Blazor can be a lot of work. At my former employer,
    we made this journey 4 years ago. In our case, we wanted to update our MVC site
    to be more interactive. We went for Blazor, and I would argue it saved our project
    and made us more productive, resulting in a more interactive user experience.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will delve deeper into Blazor WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/WebDevBlazor3e](https://packt.link/WebDevBlazor3e)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2668029180838459906.png)'
  prefs: []
  type: TYPE_IMG
