- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting Up a Backend for a Game Using Azure Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will set up a backend for a game app with real-time communication.
    We will not only create a backend that can scale up to handle a large number of
    users but also scale down when the number of users is reduced. To build that backend,
    we will use a serverless architecture based on services in **Microsoft Azure**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the different Azure serverless services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a **SignalR** service in Microsoft Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Azure Functions as an **application programming** **interface** (**API**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to complete this project, you need to have Visual Studio for Mac
    or PC installed, as well as the necessary .NET MAUI components. See *Chapter 1*,
    *Introduction to .NET MAUI*, for more details on how to set up your environment.
  prefs: []
  type: TYPE_NORMAL
- en: You also need an Azure account. If you have a Visual Studio subscription, there
    are a specific amount of Azure credits included each month. To activate your Azure
    benefits, go to [https://my.visualstudio.com](https://my.visualstudio.com).
  prefs: []
  type: TYPE_NORMAL
- en: You can also create a free account, where you can use selected services for
    free over 12 months. You will get $200 worth of credit to explore any Azure service
    for 30 days, and you can also use the free services at any time. Read more at
    [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
  prefs: []
  type: TYPE_NORMAL
- en: If you do not have and do not want to sign up for a free Azure account, you
    can use local development tools to run the services without Azure.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the full source for the code in this chapter at [https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition](https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main aim of this project will be to set up the backend for a game. A large
    part of the project will be the configuration that we will carry out in the Azure
    portal. We will also write some code for the Azure functions that will handle
    the SignalR connections and a bit of the game logic and state. SignalR is a library
    that makes real-time communication in applications easier. Azure SignalR is a
    service that makes it easier to connect multiple clients to send messages via
    the SignalR library. SignalR is described in more detail later. There will be
    functions to return information about the SignalR connection, manage matching
    players to play against each other, and post the result of each player’s turn
    to the SignalR service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows an overview of the architecture of this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19214_09_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Application architecture
  prefs: []
  type: TYPE_NORMAL
- en: The estimated time to complete this part of the project is about 2 hours.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Sticks & Stones* is a turn-based social game based on the concepts of two
    childhood games mashed into one, Dots and Boxes and Tic-Tac-Toe. The game board
    is laid out in a 9x9 grid. Each player will take a turn placing a stick along
    the side of a box, earning one point. If a stick completes a box, then the player
    takes ownership of the box, earning five points. The game is won when a player
    owns three boxes in a row, horizontally, vertically, or diagonally. If no player
    can own three boxes in a row, the winner of the game is determined by the player
    with the highest score.'
  prefs: []
  type: TYPE_NORMAL
- en: To keep the app and the service side relatively simple, we will eliminate a
    lot of state management. When the player opens the app, they will have to connect
    to the game service. They will have to provide a gamer tag or username and an
    email address. Optionally, they can upload a picture of themselves to use as a
    profile picture.
  prefs: []
  type: TYPE_NORMAL
- en: Once connected, the player will see a list of all the other players connected
    to the same game service; this is called the lobby. The player’s status, either
    “Ready to play” or “In a match,” will be displayed along with the player’s gamer
    tag and profile picture. If the player is not in a match, then there will also
    be a button to challenge the player to a match.
  prefs: []
  type: TYPE_NORMAL
- en: Challenging a player to a match will cause the app to prompt the opponent to
    respond to the challenge, either accept or decline. If the opponent accepts the
    challenge, then both players are navigated to a new game board where the player
    who received the challenge will have the first turn. Both players’ statuses will
    update to “In a match” in all the other players’ lobbies. Play will alternate
    between players as they choose a location to place a single stick. Each time a
    stick is placed by a player, the game board and score will update on both players’
    devices. When a stick is placed that completes one or more squares, the player
    then “owns” that square, and a pile of stones is placed in the center of the square.
    When all sticks have been placed, or a player owns three stones in a row, the
    game is over, the players navigate back to the lobby, and their status is updated
    to “Ready to play.”
  prefs: []
  type: TYPE_NORMAL
- en: If a player leaves the app during a game, then they will have forfeited the
    game and the remaining opponent will be credited with the win and navigated back
    to the lobby.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot should give you an idea of what the app will look
    like when it’s completed in *Chapter 10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – The main game screens](img/B19214_09_2_Merged.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – The main game screens
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the different Azure serverless services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start to build a backend with a serverless architecture, we need to
    define what **serverless** means. In a serverless architecture, the code will
    run on a server, but we don’t need to worry about that; the only thing we need
    to focus on is building our software. We let someone else handle everything to
    do with servers. We don’t need to think about how much memory or **central processing
    units** (**CPUs**) the server needs, or even how many servers we need. When we
    use services in Azure, Microsoft takes care of this for us.
  prefs: []
  type: TYPE_NORMAL
- en: Azure SignalR Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Azure SignalR Service** is a service in **Microsoft Azure** for real-time
    communication between a server and clients. The service will push content to the
    clients without them having to poll the server to get content updates. SignalR
    can be used for multiple types of applications, including mobile applications,
    web applications, and desktop applications.'
  prefs: []
  type: TYPE_NORMAL
- en: SignalR will use **WebSockets** if that option is available. If it is not, SignalR
    will use other techniques for communication, such as **Server-Sent Events** (**SSEs**)
    or **long polling**. SignalR will detect which transport technology is available
    and use it without the developer having to think about it at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'SignalR can be used in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chat applications**: Where the application requires updates from the server
    as soon as new messages are available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collaborative applications**: For example, meeting applications or when users
    on multiple devices are working with the same document'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiplayer games**: Where all users need live updates about other users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dashboard applications**: Where users need live updates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Azure Functions is a Microsoft Azure service that allows us to run code in a
    serverless way. We will deploy small pieces of code called **functions**. Functions
    are deployed in groups, called **function apps**. When we are creating a function
    app, we need to select whether we want it to run on a Consumption plan or an App
    Service plan. We select a Consumption plan if we want the application to be completely
    serverless, while with an App Service plan, we have to specify the requirements
    of the server. With a Consumption plan, we pay for the execution time and for
    how much memory the function uses. One benefit of an App Service plan is that
    you can configure it to be **Always-On**, and you won’t have any cold starts,
    so long as you don’t have to scale up to more instances. The big benefit of a
    Consumption plan is that it will always scale according to which resources are
    needed at that time.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways in which a function can be triggered to run. Two examples
    are `HttpTrigger` and `TimeTrigger`. `HttpTrigger` will trigger the function to
    run when an HTTP request is calling the function. With `TimeTrigger`, functions
    will run at an interval that we specify. There are also triggers for other Azure
    services. For example, we can configure a function to run when a file is uploaded
    to Azure Blob storage, when a new message is posted to an event hub or service
    bus, or when data is changed in an Azure Cosmos DB service.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand what features Azure SignalR Service and Functions offer,
    let’s use them to build our game backend.
  prefs: []
  type: TYPE_NORMAL
- en: Building the serverless backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will set up the backend based on the services described
    in the preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a SignalR service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first service that we will set up is the one for SignalR. To create such
    a service, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the Azure portal at [https://portal.azure.com](https://portal.azure.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new resource. The **SignalR Service** resource is in the **Web &**
    **Mobile** category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a name for the resource in the form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the subscription you want to use for this project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We recommend that you create a new **Resource group** and use it for all the
    resources that we will create for this project. The reason that we want one resource
    group is that it is easier to track which resources are related to this project,
    and it is also easier to delete all the resources together.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select a location that is close to your users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a pricing tier. For this project, we will use the **Free** tier. We can
    always use the **Free** tier for development and later scale up to a tier that
    can handle more connections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Service mode** to **Serverless**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Review + create** to review the settings before creating the SignalR
    service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Create** to create the storage account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refer to the following screenshot to view the preceding information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Creating the SignalR service](img/B19214_09_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Creating the SignalR service
  prefs: []
  type: TYPE_NORMAL
- en: This is all we need to do to set up a SignalR service. We will return to it
    in the Azure portal later to grab a connection string to it.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to set up a storage account in which we can store the images
    that are uploaded by the users.
  prefs: []
  type: TYPE_NORMAL
- en: With the Computer Vision service created, we can now create the Azure Functions
    service, which will run our game logic and use SignalR, Blob storage, and Cognitive
    Services, which we just created.
  prefs: []
  type: TYPE_NORMAL
- en: Using Azure Functions as an API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the code we will write for the backend will be in Azure Functions. We will
    use a Visual Studio project to write, debug, and deploy our functions. Before
    we create the project, we will have to set up and configure the Azure Functions
    service. Then, we will implement the function to connect the player to the game
    and provide the client with a list of current players. Next, we will write the
    functions that allow one player to challenge another to a game. Finally, we will
    wrap up by writing the function that allows players to take turns placing sticks
    on the board.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin by creating the Azure Functions service.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Azure Functions service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we write any code, we will create the function app. This will contain
    the functions in the Azure portal. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **Function App** resource. **Function App** can be found under
    the **Compute** category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a subscription for the function app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a resource group for the function app. This should be the same as the
    other resources we have created in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the function app a name. The name will also be the start of the URL of
    the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Code** as the deployment mechanism.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **.NET** as the runtime stack for the functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **.NET 6.0 (Long Term Support)** for the version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a location that is closest to your users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Windows** for **Operating System**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will use the **Consumption** plan as our **Hosting** plan, so we’ll only
    pay for what we use. **Function app** will scale both up and down according to
    our requirements – without us having to think about it at all – if we select a
    **Consumption** plan.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refer to the following screenshot to view the preceding information:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: "![Figur\uFEFFe 9.4 – Create Function App – Basics](img/B19214_09_4.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Create Function App – Basics
  prefs: []
  type: TYPE_NORMAL
- en: Click **Review + create** to review the settings before creating the function
    app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Create** to create the function app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the projects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want, you can create functions in the Azure portal. I prefer to use
    Visual Studio, however, because the code editing experience is better, and you
    can use source control. For this project, we will need to separate projects as
    part of our solution – an Azure Functions project and a class library for shared
    code between the functions and the .NET MAUI app that will be built in *Chapter
    10*. To create and configure the projects, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project in Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `function` in the search field to find the template for Azure Functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **Azure Functions** template to continue, as illustrated in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Create a new project](img/B19214_09_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Create a new project
  prefs: []
  type: TYPE_NORMAL
- en: Name the project `SticksAndStones.Functions`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name the solution `SticksAndStones.Functions`, as illustrated in the following
    screenshot, and click **Next**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figu\uFEFFre 9.6 – Configure your new project](img/B19214_09_7.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Configure your new project
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create our first function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **.Net 6.0 (Long Term Support)** for **Functions worker** at the top
    of the dialog box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Http trigger** as the trigger for our first function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Create** to continue; our functions project will be created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refer to the following screenshot to view the preceding information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Creating a new Azure Functions application – Additional information](img/B19214_09_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Creating a new Azure Functions application – Additional information
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first function will return the connection information for the SignalR service.
    To do that, we need to connect the function by adding a connection string to the
    SignalR service, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the **SignalR Service** resource in the Azure portal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Keys** tab on the left and copy the connection string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `AzureSignalRConnectionString` as the name for the setting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the connection string to the `local.settings.json` file in the Visual Studio
    project to be able to run the function locally on the development machine, as
    illustrated in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, in the `SticksAndStones.Functions` project, we need to reference the `Microsoft.Azure.WebJobs.Extensions.SignalRService`
    NuGet package. This package contains the classes we need to communicate with the
    SignalR service. If an error occurs during this and you are not able to install
    the package, make sure that you have the latest version of all other packages
    in the project and try again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last change we need to make is to adjust the automatic namespace generation.
    By default, the default namespace is the name of the project, which means all
    types in this project would have a root namespace of `SticksAndStones.Functions`.
    We don’t need the `Functions` part of that, so let’s remove it:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the `SticksAndStones.Functions` project in **Solution Explorer**
    and select **Properties**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Default namespace`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `$(MSBuildProjectName.Split(".")[0].Replace(" ", "``_"))`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will split the project name on `.`, using only the first part and replacing
    any spaces with underscores.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, when we create a new class, the namespace will start with just `SticksAndStones`.
    It’s time to create a shared project so that we can reuse code in both the .NET
    MAUI client and the Azure Functions service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shared code will go into a class library project. To create the project
    and reference it from the `SticksAndStones.Functions` project, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `SticksAndStones` solution node in **Solution Explorer**
    and select **Add**, then **New Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Search for `Class Library` in the **Add a new project** dialog box, as shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Add a new project](img/B19214_09_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Add a new project
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Class Library** template, then click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `StickAndStones.Shared` for the name, as shown in the following screenshot,
    and click **Next**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Configure your new project](img/B19214_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Configure your new project
  prefs: []
  type: TYPE_NORMAL
- en: Select the **.NET 6.0 (Long Term Support)** framework project in the **Additional
    information** dialog, then click **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the `Class1.cs` file that is created as part of the project template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a reference to `SticksAndStones.Shared` in the `SticksAndStones.Functions`
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As we did for the `SticksAndStones.Functions` project, we will change the default
    namespace by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the `SticksAndStones.Functions` project in **Solution Explorer**
    and select **Properties**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Default namespace`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `$(MSBuildProjectName.Split(".")[0].Replace(" ", "``_"))`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will split the project name on `.`, using only the first part and replacing
    any spaces with underscores.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, we can write the code for the function that will return the connection
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting a player to the game
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step in the game is to get connected. Being connected adds you to
    the list of available players so that you or other players can then join a game.
    As we have done in other projects in this book, first, we will create the models
    that we need to store or transfer data between the service and the clients. Then,
    we will implement the `Connect` function itself.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the models
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will need a few functions for the app in *Chapter 10* to call during the
    life cycle of the app. The first is to establish a connection with the game services,
    called `Connect`. Essentially, this tells the service that a new or existing player
    is active and ready for play. The `Connect` function will register the player
    details and return the connection string to the SignalR hub so that the app can
    receive messages. We will need a few models before we can complete the function.
    There needs to be a `Player` model, a `Game` model, and models to assist with
    passing data between Azure Functions and the SignalR service to the app.
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into creating the library, we should discuss the naming convention
    used in this chapter. Having a convention for how you name things will make it
    easier to determine how the class is used. When the app calls any Azure function,
    if it needs to send any data, it will do so using a class that has a suffix of
    `-Request`, and any Azure function that returns data will do so using a class
    that ends with `-Response`. For any data that is sent via the SignalR hub, we
    will use a class that has an `EventArgs` suffix. These classes will contain references
    to our actual models, and just act as a container for the data. Having these classes
    in place means that you can modify the data being sent or received without affecting
    the models themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is a two-player game, we need to track a little bit of the state
    so that we know who is online and what matches are in play. For this project,
    we will keep the state simple and not involve an actual database, but we will
    still use Entity Framework to do most of the work for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have created and referenced the new project, and we have a naming
    convention in place, we can start creating the classes we will need. We will start
    with the two models, `Player` and `Match`. `Player` represents each person, while
    `Game` is a match between two `Player instances` and the state of play. To create
    the two models, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder in the `SticksAndStones.Shared` project called `Models`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class in the `Models` folder called `Player`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `public` property in the `Player` class called `Id` as `Guid` and initialize
    it to `Guid.Empty`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another `public` property called `GamerTag` as `string` and initialize
    it to `string.Empty`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `public` property named `GameId` as `Guid` and initialize it to `Guid.Empty`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your `Player` class should now resemble the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our model classes will use the `Id` field as a unique identifier so that we
    can locate each one individually. It will be used to locate specific players for
    messaging and relating `Match` instances to `Player` instances. `GamerTag` will
    be the display name for the player, and `EmailAddress` is how we can correlate
    players if they leave the app and then log back in again. Finally, the `MatchId`
    property will track whether the player is actively in a game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined the `Player` class, it’s time to define the `Match`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class in the `Models` folder called `Match`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `public` property in the `Game` class called `Id` as `Guid` and initialize
    it to `Guid.Empty`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `public` property called `PlayerOneId` as `Guid`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `public` property named `PlayerOneScore` as `int`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another `public` property called `PlayerTwoId` as `Guid`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `public` property named `PlayerTwoScore` as `int`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `public` property called `NextPlayerId` as `Guid`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `public` property called `Sticks` as `List<int>` and initialize it
    to `new List<int>(24)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `public` property called `Stones` as `List<int>` and initialize it
    to `new List<int>(9)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `public` property called `Scores` as `List<int>` and initialize it
    to `new List<int>(2)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `public` property called `Completed` as `bool` and initialize it to
    `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `public` property called `WinnerId` as `Guid` and initialize it to
    `Guid.Empty`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `public` `static` method named `New` that takes two parameters, both of
    the `Guid` type, called `challengerId` and `opponentId`. The method returns an
    object of the `Game` type. The method should return a new instance of `Game` and
    assign the `Id` property to `Guid.NewGuid()`, `PlayerOneId` and `NextPlayerId`
    to `opponentId`, and `PlayerTwoId` to `challengerId`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Player` class should now resemble the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Player` and `Match` classes will be used for data storage and data transfer
    between the client and server. Before we go any further with creating our models,
    let’s add the database using Entity Framework. Perform the following steps to
    add a reference to Entity Framework and create the database context so that the
    `Player` and `Match` classes can be stored in an `InMemory` database:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a package reference to `Microsoft.EntityFrameworkCore.InMemory` to the `SticksAndStones.Functions`
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder called `Repository` in the `SticksAndStones.Functions` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class named `GameDbContext` in the `Repository` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the constructor for the class to set database options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a public `Players` property to store the `Player` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a public `Matches` property to store the `Match` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an override to the `OnModelCreating` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method is where we specify to Entity Framework how to relate our classes
    together in a relational database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start by declaring the identifiers for each class in the `OnModelCreating`
    method, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Entity Framework does not handle our `List<int>` properties properly. It assumes
    that since it is a list, they are related instances. To change the default behavior
    in Entity Framework, we can use the following highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What each block does is define a conversion for the property. A conversion has
    two Lambda expressions – one from the C# object to the database and the other
    from the database to the C# object. For our `List<int>` properties, we want to
    convert a C# `List<int>` into a comma-separated string of integers, and then a
    comma-separated string of integers to `List<int>`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`toDB` is an instance of `List<int>`, so to convert that into a comma-separated
    list of numbers, we can use the `String.Join` function to join each element of
    the list with `,` between them.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`fromDb` is a `string` value containing numbers separated by commas. To convert
    that into `List<int>`, we can use the `String.Split` method to isolate each number,
    then pass each number into the `Int.Parse` method to convert the number into an
    `int` value. `Select` will produce `IEnumberable<int>`; we can use the `ToList`,
    to convert that into `List<int>`. If it doesn’t create a list, we can supply a
    default list of values, just like we did in the `Match` class itself.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To initialize Entity Framework to use an in-memory database, we need to create
    a `Startup` method. To create the method and initialize the database, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class named `Startup` in the root of the `SticksAndStones.Functions`
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the class file with the following highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Startup` method will now be called when the `SticksAndStones.Functions`
    project is loaded at runtime. It will then create a factory for creating instances
    of the `GameDbContext` class we created previously and initialize it with an in-memory
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'That concludes our setup for Entity Framework and our basic models, `Player`
    and `Game`. There is one final model that we need to send the SignalR connection
    information to the client. To create this model, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class in the `Models` folder named `ConnectionInfo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a public property `Url` that is a `string` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add another public property named `AccessToken` that is also a `string` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `ConnectionInfo` class should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the models now created, we can start creating the `Connect` function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Connect function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We will start with a function to connect our player to the game, aptly named
    `Connect`. This function will expect a partially filled `Player` object to be
    sent in the request body. The function will return a fully populated `Player`
    object, a list of the currently connected players, and the connection information
    needed by the client to connect to the SignalR hub. To make the inputs and outputs
    cleaner, we will wrap them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the input and output classes, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class in the `Messages` folder called `ConnectMessages`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify `ConnectMessages.cs` so that it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For all the classes that will be used to transfer data between the client and
    Azure Functions or the SignalR service, we will use the `record` syntax. Since
    these classes will not have any real functionality, their sole purpose is to contain
    our models. By using a `record` struct, we also improve the memory usage of our
    functions since a new instance would be created in local memory and not global
    memory, which requires additional handling. The `record` syntax combines the constructor
    and property declarations into a single line of code, eliminating a lot of boilerplate
    code that adds no real benefit.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that we are using the conventions we discussed in the *Creating
    the models* section. Classes that have a suffix of `Request` or `Response` are
    used as input and output for any Azure function. For any data that is sent via
    the SignalR service, the class will use a suffix of `EventArgs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a new client is connecting, a message will be sent to other users via
    the SignalR service to indicate that they have connected. This message will also
    be used to notify when players start or end a game. To create such a message,
    proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class called `PlayerUpdatedEventArgs` in the `Messages` folder
    of the `SticksAndStones.Shared` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the class so that it’s a `record` struct with a single `Player` parameter,
    as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have created the structures needed for the `Connect` function,
    we can start writing the function itself:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder called `Hubs`. We will put our service class into this folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the `Function1.cs` file into the `Hubs` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Respond **Yes** to the next two prompts for moving the file and adjusting the
    namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the `Function1.cs` file `GameHub.cs` and click **Yes** in the rename
    prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `GameHub.cs` file and rename the class `GameHub`, replace the `internal
    static` access modifiers and replace them with `public`, and derive it from the
    `ServerlessHub` base class, as highlighted here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rename the default `Function1` function `Connect`, removing the `static` modifier
    as well. The method signature should look like the following highlighted code
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To send a message to all clients connected to the SignalR hub, we will need
    another SignalR binding. This time, it is an `HubName` and is of the `IAsyncCollector<SignalRMessage>`
    type, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove the contents of the `Connect` method and proceed as follows to implement
    the function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Logging is important in Azure Functions as it helps when debugging in production
    environments. So, let’s add a `log` message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The client, a .NET MAUI app, will send `ConnectRequest` in the body of the
    HTTP request as JSON. To get an instance of `ConnectRequest` from the request
    body, use the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will have to add `using System.Text.Json` to the namespace declarations
    as well. This uses the `System.Text.Json.JsonSerializer` class to read the contents
    of the request body and create a `ConnectRequest` object from it. It uses `jsonOptions`
    to properly deserialize the object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we need to define the `jsonOptions` field. Add the following line of code
    above the `Connect` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`JsonSerializerDefaults.Web` ensures that the JSON is formatted properly so
    that Azure Functions and the SignalR service will properly serialize and deserialize
    the objects. Mainly, it will enforce the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Property names are case-insensitive
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All property and object names will be formatted as camelCase
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Numbers can be quoted
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we receive bad player data, return `ArgumentException` to the client, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since the return type of the function is `IActionResult`, we can’t simply return
    our custom objects. Instead, we need to create an object that derives or implements
    `IActionResult` and pass in our result. In the case of errors, we will use `BadRequestObjectResult`,
    which will accept `Exception` as a parameter in the constructor. `BadRequestObjectResult`
    will set the HTTP status code to `400`, indicating an error. This status code
    can then be checked by the client to know whether the request succeeded or not
    before parsing the body of the response.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next couple of steps will require us to query the database, so we need
    to add the database context factory to the class. Add the `Microsoft.EntityFrameworkCore`
    namespace declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: private readonly JsonSerializerOptions jsonOptions = new JsonSerializerOptions(JsonSerializerDefaults.Web);
    private readonly IDbContextFactory <GameDbContext> dbContextFactory;public GameHub(IDbContextFactory<GameDbContext>
    dbcontext){    contextFactory = dbContextFactory;}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[FunctionName("Connect")]public async Task<IActionResult> Connect('
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a namespace declaration for `System.Linq` to allow the use of **Linq**
    queries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: using var context = contextFactory.CreateDbContext();log.LogInformation("Checking
    for GameTag usage");var gamerTagInUse = (from p in context.Players                      where
    string.Equals(p.GamerTag, newPlayer.GamerTag, StringComparison.InvariantCultureIgnoreCase)                     &&
    !string.Equals(p.EmailAddress, newPlayer.EmailAddress, StringComparison.OrdinalIgnoreCase)                     select
    p).Any();if (gamerTagInUse){    var error = new ArgumentException($"The GamerTag
    {newPlayer.GamerTag} is in use, please choose another.", "GamerTag");    log.LogError(error,
    "GamerTag in use.");    return new BadRequestObjectResult(error);}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, query the `Players` dataset for a player with a matching email:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If there is no `Player` in `Players` that matches, then add `Player` to the
    dataset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We assign the `Player` object a new `Guid` so that each `Player` has a unique
    identifier. This could also be done by Entity Framework; however, we will take
    care of it here. The context is then used to add the `Player` instance so that
    it is tracked for any changes. After this, `SaveChangesAsync` will commit all
    changes to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step in the `Connect` function is to send a message to all the connected
    players that a new player has joined. We can do that using the `SendAsync` method.
    The `SendAsync` method takes two parameters – the method name as a `string` value
    that the message is intended for, and the message as an `object` value. To ensure
    we are sending and receiving the right method, we will create a constant value.
    Create a new class named `Constants` in the root of the `SticksAndStones.Shared`
    project, then update it so that it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can notify other connected players that a new player has connected.
    Open the `GameHub` class and, at the end of the `Connect` method, add the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code uses the `SendAsync` method from the `Clients.All` collection in the
    `ServerlessHub` base class to send a message to all connected clients. We pass
    `Constants.Events.PlayerUpdated`, which is the `"PlayerUpdated"` string, as the
    method name. As arguments, we are sending the `Player` instance wrapped in `PlayerUpdatedEventArgs`.
    We will handle this message in *Chapter 10*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, get the set of available players from the database to send back to the
    client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using Linq, we can easily query the `Players` collection and exclude the current
    player.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, we need to get the SignalR connection information from the SignalR
    service. This can be accomplished by calling the `NegotiateAsync` method of the
    `ServerlessHub` base class. Additionally, so that we can send directed messages
    to individual users, we will set the `UserId` value for the connection to the
    player ID value. Add the following line of code to configure and retrieve the
    SignalR connection information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have all the information that we need to return to the client,
    we can construct the `ConnectResponse` object. We will use the `ConnectionInfo`
    class and map the `SignalRConnection` properties to it so that we avoid having
    to reference the SignalR service in the shared library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once `ConnectResponse` has been initialized, we can return it by using `OkObjectResult`,
    which will use an HTTP response code of **200 OK**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To test the function we just wrote, you can use a PowerShell command prompt
    and the following command, after pressing *F5* in Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The port number used in the `Uri` parameter may be different for your project.
    You can get the correct port number by opening the `launchSettings.json` file
    in the `Properties` folder of the `SticksAndStones.Functions` project. The port
    number is set in the `commandLineArgs` property, as highlighted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '''{     "player": {        "gamerTag": "NewPlayer2",        "emailAddress":
    "newplayer2@gmail.com",    }}'''
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke-WebRequest -Headers @{ ContentType = "application/json" } -Uri http://localhost:7024/api/Connect
    -Method Post -Body ''{     "player": {        "gamerTag": "NewPlayer2",        "emailAddress":
    "newplayer2@gmail.com",    }}'''
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: using SticksAndStones.Models;namespace SticksAndStones.Messages;public record
    struct GetAllPlayersResponse(List<Player> Players);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[FunctionName("GetAllPlayers")]public IActionResult GetAllPlayers([HttpTrigger(AuthorizationLevel.Function,
    "get", Route = "Players/GetAll")] HttpRequest req,ILogger log){}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: // Exclude the playerId if provided Guid playerId = Guid.Empty;if (req.Query.ContainsKey("id")){    string
    id = req.Query["id"];    if (!string.IsNullOrEmpty(id))    {        playerId =
    new Guid(id);    }}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: using var context = contextFactory.CreateDbContext();// Get the set of available
    players log.LogInformation("Getting the set of available players.");var players
    = (from player in context.Players                where player.Id != playerId                select
    player).ToList();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: return new OkObjectResult(new GetAllPlayersResponse(players));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: using SticksAndStones.Models;using System;namespace SticksAndStones.Messages;public
    record struct IssueChallengeRequest(Player Challenger, Player Opponent);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: namespace SticksAndStones.Models;public enum ChallengeResponse {    None,    Accepted,    Declined,    TimeOut
    }
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public record struct IssueChallengeResponse(ChallengeResponse Response);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public record struct AcknowledgeChallengeRequest(Guid Id, ChallengeResponse
    Response);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: using SticksAndStones.Models;using System;namespace SticksAndStones.Messages;public
    record struct ChallengeEventArgs(Guid Id, Player Challenger, Player Opponent);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public static class Events {    public static readonly string PlayerUpdated
    = nameof(PlayerUpdated);    public static readonly string Challenge = nameof(Challenge);}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: using System;namespace SticksAndStones.Models;public record struct Challenge(Guid
    Id, Player Challenger, Player Opponent, ChallengeResponse Response);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public static class Events {    public static readonly string PlayerUpdated
    = nameof(PlayerUpdated);    public static readonly string Challenge = nameof(Challenge);
    public static readonly string GameStarted = nameof(MatchStarted);}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: using SticksAndStones.Models;namespace SticksAndStones.Messages;public record
    struct MatchStartedEventArgs(Match Match);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[FunctionName("IssueChallenge")]public async Task<IssueChallengeResponse> IssueChallenge(    [HttpTrigger(AuthorizationLevel.Function,
    "post", Route = $"Challenge/Issue")] HttpRequest req,    ILogger log){}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '{    var result = await JsonSerializer.DeserializeAsync<IssueChallengeRequest>(req.Body,
    jsonOptions);}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: using var context = contextFactory.CreateDbContext();Guid challengerId = result.Challenger.Id;var
    challenger = (from p in context.Players                   where p.Id == challengerId
                      select p).FirstOrDefault();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Guid opponentId = result.Opponent.Id;var opponent = (from p in context.Players
                    where p.Id == opponentId                 select p).FirstOrDefault();if
    (challenger is null)    throw new ArgumentException(paramName: nameof(challenger),
    message: $"{challenger.GamerTag} is not a valid player.");if (opponent is null)    throw
    new ArgumentException(paramName: nameof(opponent), message: $"{opponent.GamerTag}
    is not a valid player.");'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: var challengerInMatch = (from g in context.Matches
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: where g.PlayerOneId == challengerId || g.PlayerTwoId == challengerId
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: select g).Any();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: var opponentInMatch = (from g in context.Matches
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: where g.PlayerOneId == opponentId || g.PlayerTwoId == opponentId
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: select g).Any();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (challengerInMatch)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'throw new ArgumentException(paramName: nameof(challenger), message: $"{challenger.GamerTag}
    is already in a match!");'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (opponentInMatch)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'throw new ArgumentException(paramName: nameof(opponent), message: $"{opponent.GamerTag}
    is already in a match!");'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Guid matchId = Guid.Empty;log.LogInformation($"{challenger.GamerTag} has challenged
    {opponent.GamerTag} to a match!");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: private readonly TimeSpan ackThreshold;private readonly Timer timer;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'public ChallengeHandler(bool completeAcksOnTimeout, TimeSpan ackThreshold,
    TimeSpan ackInterval){    if (completeAcksOnTimeout)    {        timer = new Timer(_
    => CheckAcks(), state: null, dueTime: ackInterval, period: ackInterval);    }    this.ackThreshold
    = ackThreshold;}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'private readonly Timer timer; public ChallengeHandler() : this(    completeAcksOnTimeout:
    true,    ackThreshold: TimeSpan.FromSeconds(30),    ackInterval: TimeSpan.FromSeconds(1))    {    }'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public ChallengeHandler(bool completeAcksOnTimeout, TimeSpan ackThreshold, TimeSpan
    ackInterval)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public (Guid id, Task<Challenge> responseTask) CreateChallenge(Player challenger,
    Player opponent){    var id = Guid.NewGuid();    var tcs = new TaskCompletionSource<Challenge>(TaskCreationOptions.RunContinuationsAsynchronously);    handlers.TryAdd(id,
    new(id, tcs, DateTime.UtcNow, new(id, challenger, opponent, ChallengeResponse.None)));    return
    (id, tcs.Task);}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: private record struct ChallengeRecord(Guid Id, TaskCompletionSource<Challenge>
    ResponseTask, DateTime Created, Challenge Challenge);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: private readonly ConcurrentDictionary<Guid, ChallengeRecord> handlers = new();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: using SticksAndStones.Models;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: using System;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: using System.Collections.Concurrent;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: using System.Threading;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'AcknowledgeChallenge function will call a method named Respond. The Respond
    method will remove ChallengeRecord from the dictionary, if it exists, and return
    the associate Challenge. If there is no ChallengeRecord, then a new empty Challenge
    record is returned, as shown in the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: private void CheckAcks(){    foreach (var pair in handlers)    {        var
    elapsed = DateTime.UtcNow - pair.Value.Created;        if (elapsed > ackThreshold)        {            pair.Value.ResponseTask.TrySetException(new
    TimeoutException("Response time out"));        }    }}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public void Dispose(){    timer?.Dispose();    foreach (var pair in handlers)    {        pair.Value.ResponseTask.TrySetCanceled();    }}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: private readonly GameDbContext context;private readonly ChallengeHandler challengeHandler;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public GameHub(GameDbContext dbcontext, ChallengeHandler handler){    context
    = dbcontext;    challengeHandler = handler;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: builder.Services.AddSingleton<ChallengeHandler>();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: var challengeInfo = challengeHandler.CreateChallenge(challenger, opponent);log.LogInformation($"Challenge
    [{challengeInfo.id}] has been created.");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: log.LogInformation($"Waiting on response from {opponent.GamerTag} for challenge[{challengeInfo.id}].");await
    Clients.User(opponent.Id.ToString()).SendAsync(Constants.Events.Challenge, new
    ChallengeEventArgs(challengeInfo.id, challenger, opponent));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: ChallengeResponse response;try {    var challenge = await challengeInfo.responseTask.ConfigureAwait(false);    log.LogInformation($"Got
    response from {opponent.GamerTag} for challenge[{challengeInfo.id}].");    response
    = challenge.Response;}catch {    log.LogInformation($"Never received a response
    from {opponent.GamerTag} for challenge[{challengeInfo.id}], it timed out.");    response
    = ChallengeResponse.TimeOut;}return new(response);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[FunctionName("AcknowledgeChallenge")]public async Task AcknowledgeChallenge(    [HttpTrigger(AuthorizationLevel.Function,
    "post", Route = $"Challenge/Ack")] HttpRequest req,    ILogger log)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: var result = await JsonSerializer.DeserializeAsync<AcknowledgeChallengeRequest>(req.Body,
    jsonOptions);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: var challenge = challengeHandler.Respond(result.Id, result.Response);if (challenge.Id
    == Guid.Empty){    return;}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: var challenger = challenge.Challenger;var opponent = challenge.Opponent;if (result.Response
    == ChallengeResponse.Declined){    log.LogInformation($"{opponent.GamerTag} has
    declined the challenge from {challenger.GamerTag}!");}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: if (result.Response == ChallengeResponse.Accepted)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: log.LogInformation($"{opponent.GamerTag} has accepted the challenge from {challenger.GamerTag}!");
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: using var context = contextFactory.CreateDbContext();
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: var game = Match.New(challenger.Id, opponent.Id);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: context.Matches.Add(game);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: opponent.MatchId = challenger.MatchId = match.Id;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: context.Players.Update(opponent);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: context.Players.Update(challenger);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: context.SaveChanges();
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: log.LogInformation($"Created match {match.Id} between {opponent.GamerTag} and
    {challenger.GamerTag}!");
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // Create Group for Game
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: await UserGroups.AddToGroupAsync(opponent.Id.ToString(), $"Match[{match.Id}]");
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: await UserGroups.AddToGroupAsync(challenger.Id.ToString(), $"Match[{match.Id}]");
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: await Clients.Group($"Match[{match.Id}]").SendAsync(Constants.Events.MatchStarted,
    new MatchStartedEventArgs(match));
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: await Clients.All.SendAsync(Constants.Events.PlayerUpdated, new PlayerUpdatedEventArgs(opponent));
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: await Clients.All.SendAsync(Constants.Events.PlayerUpdated, new PlayerUpdatedEventArgs(challenger));
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: using SticksAndStones.Models;namespace SticksAndStones.Messages;public record
    struct GetMatchResponse(Match Match);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[FunctionName("GetMatch")]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public IActionResult GetMatch(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[HttpTrigger(AuthorizationLevel.Function, "get", Route ='
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"Match/{id}")] HttpRequest req,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Guid id,    ILogger log){}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: using var context = contextFactory.CreateDbContext();Match match = (from m in
    context.Matches where m.Id == id select m).FirstOrDefault();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: return new OkObjectResult(new GetMatchResponse(match));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '{    "match": null }'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: using SticksAndStones.Models;using System;namespace SticksAndStones.Messages;public
    record struct ProcessTurnRequest(Guid MatchId, Player Player, int Position);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public record struct ProcessTurnResponse(Match Match);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public static class Events     {        public static readonly string PlayerUpdated
    = nameof(PlayerUpdated);        public static readonly string Challenge = nameof(Challenge);        public
    static readonly string MatchStarted = nameof(MatchStarted);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public static readonly string MatchUpdated = nameof(MatchUpdated);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: using SticksAndStones.Models;namespace SticksAndStones.Messages;public record
    struct MatchUpdatedEventArgs(Match Match);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[FunctionName("ProcessTurn")]public async Task<IActionResult> ProcessTurn('
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[HttpTrigger(AuthorizationLevel.Function, "post", Route = $"Game/Move")] HttpRequest
    req,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ILogger log)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: private Exception ValidateProcessTurnRequest(ProcessTurnRequest args)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{    return null;}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: private Exception VerifyMatchState(Match match, ProcessTurnRequest args)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{    return null;}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: if (args.Position <= 0 || args.Position > 23)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return new IndexOutOfRangeException("Position is out of range, must be between
    1 and 24");}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: if (args.Player is null){    return new ArgumentException("Invalid Player");}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: if (args.MatchId == Guid.Empty){
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return new ArgumentException("Invalid MatchId");}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: if (match.Sticks[args.Position] != 0){    return new ArgumentException($"Position
    [{args.Position}] has already been played");}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: if (args.Player.Id != game.NextPlayerId){    return new ArgumentException($"It
    is not {args.Player.GamerTag}'s turn");}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: if (match.WinnerId != Guid.Empty){    return new ArgumentException("Match is
    complete");}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: if (match is null)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return new ArgumentException("Invalid MatchId");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: var args = await JsonSerializer.DeserializeAsync<ProcessTurnRequest>(req.Body,
    jsonOptions);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: var error = ValidateProcessTurnRequest(args);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (error is not null)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: log.LogError(error, "Error validating turn request");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return new BadRequestObjectResult(error);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: using var context = contextFactory.CreateDbContext();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: var game = (from g in context.Matches where m.Id == args.MatchId select m).FirstOrDefault()
    ?? throw new ArgumentException("Invalid MatchId.");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: error = VerifyGameState(game, args);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (error is not null)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: log.LogError(error, "Error validating game state");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return new BadRequestObjectResult(error);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: if (turnHandler.EndTurn(args.GameId) == TurnHandler.TurnStatus.Forfeit)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: error = new ArgumentException($"The turn has expired.");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: log.LogError(error, $"Player did not respond in the time alloted.");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return new BadRequestObjectResult(error);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: (int stone, int[] sticks)[][] stickToStoneMap = new (int, int[])[][] {/* 1 */
    new (int, int[])[] { (1, new int[] { 4, 5, 8}), (0, new int[] { 0, 0, 0})},/*
    2 */ new (int, int[])[] { (2, new int[] { 5, 6, 9}), (0, new int[] { 0, 0, 0})},/*
    3 */ new (int, int[])[] { (3, new int[] { 6, 7,10}), (0, new int[] { 0, 0, 0})},/*
    4 */ new (int, int[])[] { (1, new int[] { 1, 5, 8}), (0, new int[] { 0, 0, 0})},/*
    5 */ new (int, int[])[] { (1, new int[] { 1, 4, 8}), (2, new int[] { 2, 6, 9})},/*
    6 */ new (int, int[])[] { (2, new int[] { 2, 5, 9}), (3, new int[] { 3, 7,10})},/*
    7 */ new (int, int[])[] { (3, new int[] { 3, 6,10}), (0, new int[] { 0, 0, 0})},/*
    8 */ new (int, int[])[] { (1, new int[] { 1, 4, 5}), (4, new int[] {11,12,15})},/*
    9 */ new (int, int[])[] { (2, new int[] { 2, 5, 6}), (5, new int[] {12,13,16})},/*10
    */ new (int, int[])[] { (3, new int[] { 3, 6, 7}), (6, new int[] {13,14,17})},/*11
    */ new (int, int[])[] { (4, new int[] { 8,12,15}), (0, new int[] { 0, 0, 0})},/*12
    */ new (int, int[])[] { (4, new int[] { 8,11,15}), (5, new int[] { 9,13,16})},/*13
    */ new (int, int[])[] { (5, new int[] { 9,12,16}), (6, new int[] {10,14,17})},/*14
    */ new (int, int[])[] { (6, new int[] {10,13,17}), (0, new int[] { 0, 0, 0})},/*15
    */ new (int, int[])[] { (4, new int[] { 8,11,12}), (7, new int[] {18,19,22})},/*16
    */ new (int, int[])[] { (5, new int[] { 9,12,13}), (8, new int[] {19,20,23})},/*17
    */ new (int, int[])[] { (6, new int[] {13,14,17}), (9, new int[] {20,21,24})},/*18
    */ new (int, int[])[] { (7, new int[] {15,19,22}), (0, new int[] { 0, 0, 0})},/*19
    */ new (int, int[])[] { (7, new int[] {15,18,22}), (8, new int[] {16,20,23})},/*20
    */ new (int, int[])[] { (8, new int[] {16,19,23}), (9, new int[] {17,21,24})},/*21
    */ new (int, int[])[] { (9, new int[] {17,20,24}), (0, new int[] { 0, 0, 0})},/*22
    */ new (int, int[])[] { (7, new int[] {15,18,19}), (0, new int[] { 0, 0, 0})}, /*23
    */ new (int, int[])[] { (8, new int[] {16,19,20}), (0, new int[] { 0, 0, 0})},/*24
    */ new (int, int[])[] { (9, new int[] {17,20,21}), (0, new int[] { 0, 0, 0})},};
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'match.Sticks[args.Position] = args.Player.Id == match.PlayerOneId ? 1 : -1;'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: if (args.Player.Id == game.PlayerOneId){    match.PlayerOneScore += 1;}else
    {    match.PlayerTwoScore += 1;}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: // Determine if this play creates a square
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: foreach (var tuple in stickToStoneMap[args.Position])
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (tuple.stone == 0) continue;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: var stickCompletesABox =
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Math.Abs(match.Sticks[tuple.sticks[0] - 1]) +
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Math.Abs(match.Sticks[tuple.sticks[1] - 1]) +
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Math.Abs(match.Sticks[tuple.sticks[2] - 1])
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ) == 3;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if (stickCompletesABox)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // If so, place stone, and adjust score
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'var player = args.Player.Id == match.PlayerOneId ? 1 : -1;'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: match.Stones[tuple.stone - 1] = player;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if (player > 0)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: match.PlayerOneScore += 5;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: else
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: match.PlayerTwoScore += 5;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: private static bool AllSticksHaveBeenPlayed(Match match)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return !(from s in match.Sticks where s == 0 select s).Any();
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: private static int HasThreeInARow(List<int> stones){    for (var rc = 0; rc
    < 3; rc++)    {        var rowStart = rc * 3;        var rowValue = stones[rowStart]
    + stones[rowStart + 1] + stones[rowStart + 2];        if (Math.Abs(rowValue) ==
    3) // we Have a winner!        {            return rowValue;        }        var
    colStart = rc;        var colValue = stones[colStart] + stones[colStart + 3] +
    stones[colStart + 6];        if (Math.Abs(colValue) == 3) // We have a winner!        {            return
    colValue ;        }    }    var tlbrValue = stones[0] + stones[4] + stones[8];    var
    trblValue = stones[2] + stones[4] + stones[6];    if (Math.Abs(tlbrValue) == 3)
    { return tlbrValue; }    if (Math.Abs(trblValue) == 3) { return trblValue; }    return
    0;}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: // Does one player have 3 stones in a row?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: var winner = Guid.Empty;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: var threeInARow = HasThreeInARow(match.Stones);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (threeInARow != 0)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'winner = threeInARow > 0 ? match.PlayerOneId : match.PlayerTwoId;'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if (winner == Guid.Empty) // No Winner yet
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Have all sticks been played, if yes, use top score.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if (HaveAllSticksBeenPlayed(match))
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'winner = match.PlayerOneScore > match.PlayerTwoScore ? match.PlayerOneId :
    match.PlayerTwoId;'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: if (winner == Guid.Empty)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'match.NextPlayerId = args.Player.Id == match.PlayerOneId ? match.PlayerTwoId
    : match.PlayerOneId;'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: else
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: match.NextPlayerId = Guid.Empty;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: match.WinnerId = winner;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: match.Completed = true;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: private async Task SaveMatchAndSendUpdates(GameDbContext context, Match match)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: context.Matches.Update(match);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: await context.SaveChangesAsync();
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: await Clients.Group($"Match[{match.Id}]").SendAsync(Constants.Events.MatchUpdated,
    new MatchUpdatedEventArgs(match));
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if (match.Completed)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: await UserGroups.RemoveFromGroupAsync(match.PlayerOneId.ToString(), $"Match[{match.Id}]");
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: await UserGroups.RemoveFromGroupAsync(game.PlayerTwoId.ToString(), $"Match[{match.Id}]");
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: await SaveMatchAndSendUpdates(context, match);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return new OkObjectResult(new ProcessTurnResponse(match));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: error = VerifyMatchState(game, args);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (error is not null)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: await SaveMatchAndSendUpdates(game);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: log.LogError(error, "Error validating match state.");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return new BadRequestObjectResult(error);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
