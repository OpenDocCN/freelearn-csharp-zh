- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The One with the Filesystem Chronicles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*File Systems* *and IO*'
  prefs: []
  type: TYPE_NORMAL
- en: Computers are incredible machines, but they have one downside. If the power
    goes off, they forget everything. If we do not want to lose our work, we must
    store it elsewhere. We can print data, put it on the network, or store it in permanent
    storage. This is the most common option. Of course, we need to have a way to get
    data into the CPU. We can read data from a file or a network. We can even use
    the keyboard to enter data. This is something that both you (a programmer) and
    I (a writer) are very familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: When we are programming software, we refer to the concept of **streams**. A
    stream represents a sequence of data elements made available over time. This sequence
    can be stored on a disk, it can be data flowing over network wires, or it can
    be the state of a memory chip. Data must flow back and forth no matter what physical
    medium we use. This chapter handles that topic, covering streams, files, and other
    ways of **Input and** **Output** (**IO**).
  prefs: []
  type: TYPE_NORMAL
- en: One thing that we will not dive into in this chapter is the topic of networking.
    Networking is such a different concept that a separate chapter will deal with
    this topic. You can find all the low-level networking details in [*Chapter 8*](B20924_09.xhtml#_idTextAnchor181).
    However, the concepts of data handling over that network are the same for files
    and other media. So, the principles laid out here still apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to work with files using .NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Win32 APIs to work with the filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work with Directory and Path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why and how we should use asynchronous IO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use encryption and compression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a lot of ground to cover, so let’s dive in!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To view all the code in this chapter, you can visit the following link: [https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter05](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter05).'
  prefs: []
  type: TYPE_NORMAL
- en: File writing basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There cannot be anything more straightforward than writing to a file, right?
    That’s why I think that that is a good starting point. Here is the code to do
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first line gets the system `temp` path. Then we specify the filename, add
    that to the `temp` path, and write a line of text to that file.
  prefs: []
  type: TYPE_NORMAL
- en: This example is simple enough, but it already shows something useful. First,
    we can get to the `temp` folder quickly; we don’t have to specify where that is
    in our code. Second, we can combine the filename and the path without worrying
    about the path separator. On Windows, the parts of the path are separated by a
    backslash, while on Linux, this is a forward slash. The CLR figures out what it
    should use and uses the correct one.
  prefs: []
  type: TYPE_NORMAL
- en: The `File.WriteAllText` then takes that data and creates a file, opens it, writes
    the string, and closes the file. If the file is already there, the system overwrites
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to have a temporary filename instead of `WriteLines.Text`, the
    code could have been even easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The system looks up the path for `temp` files, generates a new file with a unique
    filename, and uses that to write the string. The downside is that we now have
    no idea which file it is. We have to log that somewhere; otherwise, our `temp`
    folder will fill up quickly with unused files (most operating systems clean up
    the `temp` folder though, so no real worries there).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can obviously use any folder you want. However, if you want to use some
    of the special folders, such as the `Documents` folder on Windows, the system
    can help you get to those as well. Have a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This code looks up the location of `My Documents` on my machine and returns
    that so that I can write the file to that location. You can choose from a long
    list of special locations, all of which are part of the `SpecialFolder` enum.
    I will not list all of them; you can find them here: [https://learn.microsoft.com/en-us/dotnet/api/system.environment.specialfolder?view=net-8.0](https://learn.microsoft.com/en-us/dotnet/api/system.environment.specialfolder?view=net-8.0).'
  prefs: []
  type: TYPE_NORMAL
- en: This way of writing files is effortless. However, as we have seen many times
    before, ease comes with less control. As systems programmers, we want all the
    control we can get. Let’s take back some control.
  prefs: []
  type: TYPE_NORMAL
- en: FileStream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The static `File` class is easy to use and very convenient if you quickly want
    to write something to, or read something from, a file. However, it is not the
    fastest way. At least, it is not the fastest if we are referring to execution
    time. As systems programmers, we are very interested in speed, even if it means
    giving up on ease of coding.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is about 20% faster than the previous one, but it does
    the same things. It just needs a few more lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This sample uses the `FileStream` that `File.Create()` returns. We can, of
    course, create one ourselves. Replace the line where we created the `FileStream`
    through `File` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'I have used the most extensive overload here to show you some of the options
    that you can use. Most are self-explanatory, but I want to highlight two parameters:
    **share** and **options**.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Share` is a flag that tells the operating system how to share the file while
    we use it. It has the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Flag** | **Value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `None` | 0 | No sharing is allowed. Any other process trying to access the
    file will fail to do so. |'
  prefs: []
  type: TYPE_TB
- en: '| `Read` | 1 | Other processes can read the file while we are still using it.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Write` | 2 | Other processes might write to the file at the same time. |'
  prefs: []
  type: TYPE_TB
- en: '| `ReadWrite` | 3 | This combines the `Read` and `Write` flags. |'
  prefs: []
  type: TYPE_TB
- en: '| `Delete` | 4 | This allows requests for deletion of the file while we are
    using it. |'
  prefs: []
  type: TYPE_TB
- en: '| `Inheritable` | 16 | The file handle is inheritable by child processes. However,
    this does not work on Win32 applications. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.1: Share options for files'
  prefs: []
  type: TYPE_NORMAL
- en: Although specifying a flag from this list might indicate that other processes
    can do things with our files while we use them, there is no guarantee that these
    other processes can actually do so. Usually, they need other permissions as well.
  prefs: []
  type: TYPE_NORMAL
- en: '`Delete` is a nice flag. It allows for deletion while we are still working
    with the file. That could lead to weird situations. If we create a file and specify
    that we allow deletion, we might write to the file while another process has already
    deleted it. The system does not complain and continues running. However, you will
    end up without that file, which means losing your data forever. Let me show you
    what I mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This example is straightforward. We will first get a temporary filename. Then,
    we will get the bytes that form our payload. After that, we will create an instance
    of the `FileStream`, setting a couple of properties as we do so.
  prefs: []
  type: TYPE_NORMAL
- en: One of them is the `Share` option. We have set it to `FileShare.Delete`.
  prefs: []
  type: TYPE_NORMAL
- en: We will write some data to the file and then pause the program. If you run it,
    this is the moment to take the output that tells you the name and location of
    the file and delete it. You should notice that you can do that. Then continue
    the program. As you can see, the following line writes the same data again to
    the file we just deleted. Nothing happens. Really, nothing happens. There are
    no errors, but no data is written anywhere either.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, this is a behavior you would want to avoid. However, maybe your
    use case calls for just this kind of behavior. In that case, now you know how
    to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Even faster – Win32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a faster way to write files. If we remove the overhead of the CLR,
    we can write files about 20% faster. A 20% increase in speed can mean the difference
    between a sluggish application and one that seems lightning-fast. As usual, this
    comes with a price. All the good things the CLR provides us with are now in our
    own hands. We have to do a lot more work. However, if you are looking for the
    fastest way to write data to a file, theWin32 approach is, again, the best way
    to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin by declaring some constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`GENERIC_WRITE` tells the system that we want to write to a file. `CREATE_ALWAYS`
    specifies that we want to create a new file every time we call this. `FILE_APPEND_DATA`
    means that we want to add to the current file (which doesn’t make much sense,
    since we just created the file).'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is time to import the Win32 APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will import three methods from `kernel32.dll`. `CreateFile` creates a file,
    `WriteFile` writes to that file, and `CloseHandle` closes handles and, in our
    case, the handle to the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is all we need to write. Let me show you how that works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With the knowledge you have right now, you should be able to follow along. We
    will first create a file with the correct parameters. If that works, we will get
    the bytes we want to write and then use `WriteFile` to do the actual writing.
    After that, we will close the handle. We do that in the `finally` block; handles
    are expensive and they lock access to the file. We want to close it so other processes
    can access the file.
  prefs: []
  type: TYPE_NORMAL
- en: You are partially correct if you think that this does not look too bad. This
    was very simple. However, I omitted a lot of things, such as error checking. Do
    you remember what I told you about performance? I said in the previous chapters
    that file IO takes forever compared to normal CPU operations. Thus, we must use
    the asynchronous approach as much as we can. You can do that with Win32, but that
    is pretty complex. I will not show you how to do that here, but if you do a quick
    search on the Win32 API, `CreateFile`, and `FILE_FLAG_OVERLAPPED`, you can find
    out how it all works. In short, you will have to check everything yourself. My
    advice is to stick to the CLR functions. We will discuss asynchronous I/O later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have learned how to write to files and all that goes with doing that. However,
    that is only one part of the story. Let’s move to the other half of the equation:
    reading a file.'
  prefs: []
  type: TYPE_NORMAL
- en: File reading basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Great. We have written a file. Now we should be able to read it as well, right?
    Okay, let’s dive into that. We will start with a simple example: a file with some
    lines of text that we want to read into a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'I can’t make it simpler than this. We have the static `ReadAllText` method,
    which takes a filename and reads all text into the string. Then we return that.
    Keep in mind that not all files contain text. I even dare to say that *most* files
    do not contain text. They are binary. Now, technically, a `text` file is also
    a `binary` file. So, let’s read the file again, but now by reading the actual
    bytes. I use the `FileStream` this time, so we have a bit more control over what
    is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The nice thing about the `FileStream` is that it knows the length of the stream.
    That means that we can allocate enough space for our array to contain all the
    data.
  prefs: []
  type: TYPE_NORMAL
- en: We will read all data through one call to `fs.Read()`, giving it the byte array,
    the start position `0`, and the total number of bytes to read. Again, we will
    close the stream when we are done with it.
  prefs: []
  type: TYPE_NORMAL
- en: Last, we will convert the file to a string, assuming the contents are ASCII
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: This way of reading works fine if you have a relatively small file. In that
    case, you can read it all in one go. However, if the file is too big, you must
    read it in chunks.
  prefs: []
  type: TYPE_NORMAL
- en: For that, the `Read()` method helps you by telling you how much data it has
    read. You can create a loop and iterate through the complete file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can rewrite the part where we read the file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is a silly way to do this, but it illustrates my point. We will keep reading
    the file until we have all the data, in which case `fs.Read()` returns `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Reading binary data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have a `binary` file that you know the structure of, you can use a `BinaryReader`
    to help.
  prefs: []
  type: TYPE_NORMAL
- en: Binary data is usually much more memory-efficient than text data. Since we,
    as systems programmers, are always searching for more efficient code, this is
    worth looking into.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume that I have the following class. This doesn’t mean anything special;
    it is just a data collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Let us assume that I have created an instance of this class with the properties
    `42`, `3.1415`, `True`, `MyFlags.One | MyFlags.Three` and `Hello, Systems Programmers`.
    I can write it to a file using JSON serialization. That results in a file of 114
    bytes. If I use a binary format, I can shrink it down to 44 bytes. That is a considerable
    saving, especially when putting that data on a network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading that file is straightforward using the `BinaryReader` class. Let me
    show you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Doing it this way means that you have to be very careful. You have to know the
    structure of the file precisely. You are responsible for getting all data in the
    correct order and knowing each field’s type exactly. However, doing it this way
    ensures efficiency and can save you many CPU cycles.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now know all about how to read and write files. However, files are not the
    only things we can find in file systems. We need a way to organize all those files.
    That brings us to the next topic in IO: directories!'
  prefs: []
  type: TYPE_NORMAL
- en: Directory operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine having a file system with one root folder. All files on your drive
    are stored there. You would have a tough time finding all your files. Luckily,
    operating systems all support the notion of folders or directories. The CLR helps
    us by giving us two classes to work with paths, folders, and directories: **Path**
    and **Directory**.'
  prefs: []
  type: TYPE_NORMAL
- en: The Path class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Path` is a class that has helper methods for dealing with paths. With `Path`,
    I mean the string that denotes the name of a directory. You should use the `Directory`
    class when dealing with the actual directory and files.'
  prefs: []
  type: TYPE_NORMAL
- en: We have already seen the `Path` class in previous samples. I used it to get
    a temporary filename and the name of the `Documents` folder. I also used it to
    combine a path and a filename to avoid dealing with path separators myself.
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few handy methods and properties in the `Path` class. You
    can see some of the most-used ones in the following table.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.Combine` | Combines two or more strings into a path |'
  prefs: []
  type: TYPE_TB
- en: '| `ath.GetFileName` | Returns the filename and extension of the specified path
    string |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.GetFileNameWithoutExtension` | Returns the filename of the specified
    path string without the extension |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.GetExtension` | Gets the extension (including the period) of the specified
    path string |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.GetDirectoryName` | Gets the directory information for the specified
    path string |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.GetFullPath` | Converts a relative path to an absolute path |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.GetTempPath` | Returns the path to the system’s temporary folder |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.GetRandomFileName` | Returns a random filename that is not already
    in use |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.GetInvalidFileNameChars` | Returns an array of characters that are
    not allowed in filenames on the current platform |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.GetInvalidPathChars` | Returns an array of characters that are not
    allowed in path strings on the current platform |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.ChangeExtension` | Changes the extension of a file path |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.HasExtension` | Determines whether a path includes a filename extension
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.IsPathRooted` | Gets a value indicating whether the specified path
    string contains a root |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.DirectorySeparatorChar` | A platform-specific separator character that
    is used in path strings |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.2: The Path class and its methods and properties'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `Path` class has a set of nice and convenient helpers. We
    will encounter them again when we investigate other platforms, but for now, please
    remember to use them as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: The Directory class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Directory` class deals with the actual directory in your filesystem. This
    class works closely with the `Path` class. If you need to specify the directory’s
    name (and thus its location), you would use the `Path` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume that we want to list all images in our `Pictures` folder on our
    Windows machine. You would do that like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: I use `Environment.SpecialFolder.MyPictures` here to identify the folder that
    has all my pictures. The actual path depends on your operating system, the username,
    and how you have set up your machine. That means there are a lot of possible variations,
    but we need not bother much about that. Let the operating system figure that out,
    as long as we get the correct folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'I used the `Directory.GetFiles()` method to iterate through that folder. I
    want all the JPEG images I have collected in all subfolders. Notice how I spelled
    the extension in the `searchPattern` variable: `*.jPg`. On Windows, filenames
    are not case-sensitive. On Linux, they are. So, on a Linux-based machine, this
    would not work. Okay, it will work, but it does not return all the files you might
    expect to get. Unfortunately, `GetFiles()` cannot set up a filter for case insensitivity.
    If you want to get all JPG images, no matter what their extensions look like,
    you have to do this another way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: I have created a regular expression here, saying I want to filter on strings
    that end in `.jpg` or `jpeg` and ignore the case. Then I use `Directory.EnumerateFiles()`
    and apply the `Where()` LINQ operator to apply the `regex` filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method works fine on all platforms. You could have avoided the `regex`
    filter by using the following code, which is more verbose but, I assume, more
    readable to many people:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'I have collected the most-used methods and properties of the `Directory` class
    for you in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** **or property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Directory.CreateDirectory` | Creates all directories and subdirectories
    in the specified path unless they already exist |'
  prefs: []
  type: TYPE_TB
- en: '| `Directory. Delete` | Deletes the specified directory and, optionally, any
    subdirectories and files in the directory |'
  prefs: []
  type: TYPE_TB
- en: '| `Directory.Exists` | Determines whether the given path refers to an existing
    directory on the disk |'
  prefs: []
  type: TYPE_TB
- en: '| `Directory.GetCurrentDirectory` | Gets the current working directory of the
    application |'
  prefs: []
  type: TYPE_TB
- en: '| `Directory.GetDirectories` | Gets the names of subdirectories (including
    their paths) in the specified directory |'
  prefs: []
  type: TYPE_TB
- en: '| `Directory.GetFiles` | Returns the names of files (including their paths)
    in the specified directory |'
  prefs: []
  type: TYPE_TB
- en: '| `Directory.GetFileSystemEntries` | Returns the names of all the files and
    subdirectories in a specified directory |'
  prefs: []
  type: TYPE_TB
- en: '| `Directory.GetLastAccessTime` | Returns the date and time when the specified
    file or directory was last accessed |'
  prefs: []
  type: TYPE_TB
- en: '| `Directory.GetLastWriteTime` | Returns the date and time when the specified
    file or directory was last written to |'
  prefs: []
  type: TYPE_TB
- en: '| `Directory.GetParent` | Retrieves the parent directory of the specified path,
    including both absolute and relative paths |'
  prefs: []
  type: TYPE_TB
- en: '| `Directory.Move` | Moves a file or a directory and its contents to a new
    location |'
  prefs: []
  type: TYPE_TB
- en: '| `Directory.SetCreationTime` | Sets the creation date and time for the specified
    file or directory |'
  prefs: []
  type: TYPE_TB
- en: '| `Directory.SetCurrentDirectory` | Sets the application’s current working
    directory to the specified directory |'
  prefs: []
  type: TYPE_TB
- en: '| `Directory.SetLastAccessTime` | Sets the date and time when the specified
    file or directory was last accessed |'
  prefs: []
  type: TYPE_TB
- en: '| `Directory.SetLastWriteTime` | Sets the date and time when the specified
    file or directory was last written to |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.3: The methods and properties of the Directory class'
  prefs: []
  type: TYPE_NORMAL
- en: The `Directory` has some nice helpers and properties. You could figure out all
    of these properties yourself, but why bother if the CLR is friendly enough to
    help you? These properties will also be beneficial when we move to other platforms
    later on.
  prefs: []
  type: TYPE_NORMAL
- en: The DirectoryInfo class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is one more class I want to discuss: the `DirectoryInfo` class. The difference
    between `Directory` and `DirectoryInfo` is that the former uses static methods,
    whereas the latter is used as an instance. `Directory` returns information about
    directories as strings. `DirectoryInfo` returns objects with much more information.
    Let me give you an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: I created an instance of the `DirectoryInfo` class and gave it the path to our
    `images` folder. This instance has a lot of valuable properties, such as the full
    name, time of creation, attributes, and many more. I have listed the most-used
    properties and methods in the following table.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** **or property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `DirectoryInfo.Create` | Creates a directory |'
  prefs: []
  type: TYPE_TB
- en: '| `DirectoryInfo.Delete` | Deletes this instance of a `DirectoryInfo`, specifying
    whether to delete subdirectories and files |'
  prefs: []
  type: TYPE_TB
- en: '| `DirectoryInfo.Exists` | Gets a value indicating whether the directory exists
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DirectoryInfo.Extension` | Gets the string representing the extension part
    of the directory |'
  prefs: []
  type: TYPE_TB
- en: '| `DirectoryInfo.FullName` | Gets the full path of the directory or file |'
  prefs: []
  type: TYPE_TB
- en: '| `DirectoryInfo.Name` | Gets the name of this `DirectoryInfo` instance |'
  prefs: []
  type: TYPE_TB
- en: '| `DirectoryInfo.Parent` | Gets the parent directory of a specified subdirectory
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DirectoryInfo.Root` | Gets the root portion of a path |'
  prefs: []
  type: TYPE_TB
- en: '| `DirectoryInfo.GetFiles` | Returns a file list from the current directory
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DirectoryInfo.GetDirectories` | Returns the subdirectories of the current
    directory |'
  prefs: []
  type: TYPE_TB
- en: '| `DirectoryInfo.GetFileSystemInfos` | Retrieves an array of `FileSystemInfo`
    objects representing the files and subdirectories of the current directory |'
  prefs: []
  type: TYPE_TB
- en: '| `DirectoryInfo.MoveTo` | Moves a `DirectoryInfo` instance and its contents
    to a new path |'
  prefs: []
  type: TYPE_TB
- en: '| `DirectoryInfo.Refresh` | Refreshes the state of the object |'
  prefs: []
  type: TYPE_TB
- en: '| `DirectoryInfo.EnumerateFiles` | Returns an enumerable collection of file
    information in the current directory |'
  prefs: []
  type: TYPE_TB
- en: '| `DirectoryInfo.EnumerateDirectories` | Returns an enumerable collection of
    directory information in the current directory |'
  prefs: []
  type: TYPE_TB
- en: '| `DirectoryInfo.Enumerate FileSystemInfos` | Returns an enumerable collection
    of file system information in the current directory |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.4: DirectoryInfo properties and methods'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `Path`, `Directory`, and `DirectoryInfo` can greatly help when
    dealing with files.
  prefs: []
  type: TYPE_NORMAL
- en: File system monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As systems programmers, we must find ways to communicate with our apps. After
    all, there is no user interface wherein the user can indicate their desired actions.
  prefs: []
  type: TYPE_NORMAL
- en: Most apps in that category listen to network ports or have other ways for systems
    to communicate with them. One of those ways is to wait for changes in files or
    directories.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping an eye on files or folders is a fairly common scenario. For instance,
    we could build a system that processes the files that we get through an email
    system. As soon as a file is delivered as an attachment, the mail client places
    it in a directory and our system picks it up.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we need to have a way to keep an eye on that folder. Luckily,
    that is not too hard to do. It does require some explanation, so let me walk you
    through it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin with the class that other classes interact with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We will need to clean up some resources later, so I have implemented the `IDisposable`
    interface here. The class that we need to clean up is an instance of the `FileSystemWatcher`
    type. This class, when instantiated, keeps an eye on a folder and, optionally,
    a filter for the filenames. If something of interest happens there, the `FileSystemWatcher`
    notifies us. It is up to us to define what “something of interest” means.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s set it up as a private member of our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We could change our `Dispose`(bool disposing) method to clean this up, but I
    will hold on to that for now. We need to do more than just dispose of the `FileSystemWatcher`.
  prefs: []
  type: TYPE_NORMAL
- en: A `FileSystemWatcher` is resource-intensive. Keeping an eye on a folder can
    lead to much CPU pressure. Therefore, we must be sure to only enable it when we
    need it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we will add a method that enables the watcher and set some settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We will start with two checks. First, we will see whether the watcher has not
    already been created. If it has, we will throw an error. The second is to check
    whether the supplied path exists or not.
  prefs: []
  type: TYPE_NORMAL
- en: If those two checks both pass, we will create an instance of the `FileSystemWatcher`
    class and give it the path we want to monitor.
  prefs: []
  type: TYPE_NORMAL
- en: You can specify what you want to monitor. This is controlled by the `NotifyFilter`
    property. This property takes an enum or a combination of the `NotifyFilter` enums.
    You can see what your options are in the following table.
  prefs: []
  type: TYPE_NORMAL
- en: '| **NotifyFilters enum** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Attributes` | Watches for changes in the attributes of the file or folder
    |'
  prefs: []
  type: TYPE_TB
- en: '| `CreationTime` | Monitors changes to the creation times of files and directories
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DirectoryName` | Watches for changes in the names of directories |'
  prefs: []
  type: TYPE_TB
- en: '| `FileName` | Watches for changes in the names of files |'
  prefs: []
  type: TYPE_TB
- en: '| `LastAccess` | Monitors changes to the last access times of files and directories
    |'
  prefs: []
  type: TYPE_TB
- en: '| `LastWrite` | Watches for changes to the last write times of files and directories
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Security` | Monitors changes in the security settings of files and directories
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Size` | Watches for changes in the sizes of files and directories |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.5: NotifyFilters options'
  prefs: []
  type: TYPE_NORMAL
- en: I am only interested in new or changed files in our folder. So, I have given
    it the `NotifyFilters.FileName` | `NotifyFilters.LastWrite` value. The `FileName`
    of a file changes, of course, when you first create the file. I could also have
    chosen `CreationTime`, which hardly ever changes. I will also keep a watch on
    `LastWrite`, which tells me when a file has changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, I will give the `_watcher` a callback to call when either of the
    two events I care about are raised. Since all events share the same signature,
    I can get away with just one method. That method is what we will look at next.
    However, before we do that, we need to start the watcher by setting `_watcher.EnableRaisingEvents`
    to `True`. The next piece of code contains the body of the `eventhandler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When the watcher calls this callback, we get an instance of the `FileSystemEventArgs`
    class. This class contains a field called `ChangeType` that indicates what type
    of change triggered this call. It also contains the full path and name of the
    file affected in the `FullPath` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will switch on that `ChangeType` field and call one of the two event handlers
    for our class. Those two event handlers that are part of our class look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FileCreatedEventArgs` and `FileChangedEventArgs` types for the `EventHandler`
    are straightforward as well. I could have used only one type. However, for future
    uses, I decided to give them distinct classes that I might extend at some point
    with more information. They look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`FileSystemWatcher` implements `IDisposable`. So, we must dispose of it when
    we no longer use it. We need to rewrite our own `Dispose(bool disposing)` method
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: After doing some checks, we will stop the system from receiving any events.
    Then we will clear the events. If we do not do this, other objects might hold
    a reference to our class and thus prevent this class from being freed from memory.
  prefs: []
  type: TYPE_NORMAL
- en: When that is done, we dispose of `_watcher` and set it to null.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it. If you run it from your program, give it a folder, and attach some
    `eventhandlers` to it, you will be able to see what happens when you add or change
    files in that folder.
  prefs: []
  type: TYPE_NORMAL
- en: It is almost perfect. Almost – but not quite.
  prefs: []
  type: TYPE_NORMAL
- en: If you add a file, you will get multiple events. If you think about that, it
    makes sense. After all, a file is created on the file system and then it is changed
    immediately. If you wanted to, you could change our class to consider that. It
    is not hard to do, so I will leave that up to you.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I have said it before, but this is so important that I have to repeat it here:
    IO is slow. Every piece of code that works with IO should be done asynchronously.
    Luckily, most of the classes in the `System.IO` namespace have asynchronous members
    that we can use with async/await.'
  prefs: []
  type: TYPE_NORMAL
- en: I would be happy if Microsoft decided to mark all non-asynchronous methods in
    `System.IO` as obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: The naïve approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the methods you know in `System.IO` have an asynchronous version. So,
    just add the `async` postfix to the method name and await it. Simple!
  prefs: []
  type: TYPE_NORMAL
- en: On second thought, no. It is not that simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me show you an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This method creates a file and then writes a string line to it. Once finished,
    it closes the file and nicely disposes of it. It does that asynchronously. So
    this is the way things should be, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Add these two lines to your main Console application. Run it and let it run
    for a few seconds. Note what line is written to the file on the screen (it should
    say something to the effect of *This is the line n*, where `n` is the number of
    the line). Then press *Ctrl* + *C* to cancel the operation. The program will stop.
    Now, please open the file and see how far it got. There is a big chance that you
    will see that the last line written on the file is not the number that you saw
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Why is that, you might wonder? The CLR ensures that performance is as high as
    possible for our code. So, all data written to a file system is buffered into
    a cache before it is sent to the SSD or other media. After all, writing to storage
    is slow. However, since we killed the process, the CLR did not have time to flush
    the cache.
  prefs: []
  type: TYPE_NORMAL
- en: Using CancellationTokens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, this would not happen often in the real world. However, you might
    want to cancel a long-running IO process, and then you might encounter this.
  prefs: []
  type: TYPE_NORMAL
- en: There is a solution to this. Remember the chapter where we talked about threads?
    Remember that I said that there was this thing called a `CancellationToken`? That
    is the one that we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s rewrite the code that writes the file. Let’s remove the `naïve` from
    the method name; we know better now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We have added quite a bit of code here. Let me walk you through it. First, we
    added a parameter of the `CancellationToken` type to the method. We will constantly
    check to see whether `Cancel` has been requested in our loop. If so, we will print
    the message on the screen and graciously exit the loop.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Task.Delay()`, we also passed the `CancellationToken`. After all, while
    the system waits for this delay, the cancellation can also be requested. However,
    when that happens during a `Task.Delay()`, the CLR will throw an exception of
    the `TaskCanceledException` type. We have to catch that to prevent our program
    from crashing and stopping. That’s why we have the `try..catch` block here. We
    need that `try..catch` block to prevent the exception from bubbling up the call
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to mimic breaking up the loop from the outside. Change the code that
    calls this method into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: First, we will create a new `CancellationtokenSource`. Then, we will pull a
    thread from the `ThreadPool` and give it something to do. After waiting for 10
    seconds, it will request a cancellation.
  prefs: []
  type: TYPE_NORMAL
- en: The call to `CreateBigFile` now has a `CancellationTokenSource`.
  prefs: []
  type: TYPE_NORMAL
- en: Run it and see that it stops after 10 seconds. Notice which line it stopped
    on and check the actual file to see whether that was the last line written to
    it. On my machine, this works nicely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: when dealing with asynchronous file handling, no matter what you
    do, try to use a `CancellationSourceToken`. Also, be sure that you deal with any
    side effects. Be sure to clean up after the cancellation has been requested so
    that the CLR can properly flush the cache and clean up its resources.'
  prefs: []
  type: TYPE_NORMAL
- en: BufferedStream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The CLR is pretty good at maximizing performance for your I/O operations. As
    we saw, it can cache data before writing to external devices. This caching speeds
    up our code since we no longer have to wait for the slow write operations to finish.
    However, the CLR makes an educated guess about those caches. Sometimes it gets
    it wrong. If we know the size of the data we want to write, we can use that knowledge
    to get even more performance out of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say that we have a system that writes the following record to the I/O:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This block is 24 bytes long. We can quickly determine that by adding up the
    sizes of `int`, `DateTime`, and double.
  prefs: []
  type: TYPE_NORMAL
- en: If we write that to a file, the CLR will cache it until the systems find a suitable
    moment to do the actual writing of the data to the storage. However, we can improve
    that. We can use the `BufferedStream` class to write this data to a buffer first.
    Then the CLR can flush that buffer to the underlying storage when it thinks it
    is the best time. The advantage here is that we control the size of that buffer
    or cache. If we specify the size just right, we will not waste memory. However,
    we are also not making it too small so that it flushes too often. It is just right
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to do that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: First, we will create a `FileStream`. This `FileStream` is the actual handle
    to the file we are writing to. Then, we will create a `BufferedStream` and give
    it the `FileStream` and the size of the record that we want to write. After that,
    we will create a `BinaryWriter` to take our data and write it to the buffer as
    efficiently as possible.
  prefs: []
  type: TYPE_NORMAL
- en: When that has all been set up, we will do the writing.
  prefs: []
  type: TYPE_NORMAL
- en: A word of warning
  prefs: []
  type: TYPE_NORMAL
- en: If you are not sure of the size of the data, having a `BufferedStream` might
    work against you. `BufferedStream` works best if you are doing a lot of smaller,
    frequent writes of data that you know the size of. Otherwise, the cache management
    is best left to the CLR.
  prefs: []
  type: TYPE_NORMAL
- en: File system security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Files are where we store things. Those things might not be for everybody to
    see. Sometimes, we must hide data or ensure that only programs that we trust can
    access it. OSs can help. Every OS has a way of handling access to files and directories.
    You can generally allow or disallow read- or write access to them.
  prefs: []
  type: TYPE_NORMAL
- en: However, what happens when you want to share files? Let us assume that you want
    to transfer data over a wire or store it on another drive such as a removable
    USB drive. In that case, ensuring that level of security is quite challenging.
    This means that you might have to encrypt data to prevent it from being abused.
  prefs: []
  type: TYPE_NORMAL
- en: Security – a topic of its own
  prefs: []
  type: TYPE_NORMAL
- en: I am only covering the basics of security and encryption here. This is not a
    complete guide to this complicated and extensive topic. There have been hundreds
    of books written on this topic alone. I want you to know that you can do security
    and encryption. However, if you want to take this seriously, I suggest that you
    go out and find a few good resources on those topics and learn from there.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Basically, we have two encryption flavors: **symmetric** and **asymmetric**
    algorithms. Although there are many similarities between them, one big difference
    is in how they handle keys.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s discuss an elementary sample. We’ll say that you have a message and want
    to transmit it to someone else. Since the contents of the message are sensitive,
    you do not want anyone else to be able to read it, so you decided to encrypt it.
    That means that you will change the contents of your message so that nobody can
    make any sense of it. The recipient then decrypts it to change your text into
    something intelligible. We call the text that people can actually read and understand
    **cleartext**. In contrast, the encrypted, unreadable text is something we call
    **ciphertext**. People read cleartext; ciphertext needs decrypting.
  prefs: []
  type: TYPE_NORMAL
- en: This way of protecting information is not new. Julius Caesar did such a thing
    over 2,000 years ago. He used a straightforward substitution algorithm. All he
    did was take a piece of text he wanted to send to his commanders in the field
    and then shift all characters left or right by a certain number of positions.
    The number here is what we call his key.
  prefs: []
  type: TYPE_NORMAL
- en: So, if Ceasar chose a key of `3`, all As in his message would become Ds. The
    character B would become an E, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: If you knew the key, you could take his ciphertext and reverse the operation
    to get back to the cleartext.
  prefs: []
  type: TYPE_NORMAL
- en: The problem here is to transmit the actual number to use. Both parties need
    to know the key, or things never work out. You need a secure way of telling the
    other person which key to use so that they can decrypt your ciphertext into cleartext.
  prefs: []
  type: TYPE_NORMAL
- en: If you know the other person, sharing this key is not hard. You can walk up
    to them, give them the key on a piece of paper in a sealed envelope, and tell
    them to open it only when they receive the encrypted message. These days, however,
    that is a lot harder to do. Computers do not know the other computer they want
    to talk to. It is hard to exchange keys safely.
  prefs: []
  type: TYPE_NORMAL
- en: 'A possible solution for this is asymmetric encryption and decryption. This
    solution is complicated, but the basis is this: you have two keys. One key is
    used to encrypt the data and another is used to decrypt the data. One of the keys
    is kept private and the other is made public. The private key is yours and yours
    alone. You use it to encrypt a file. Anyone with the public key can then decrypt
    it. Of course, if you want the message to only be read by one other party, you
    can reverse this. You can request that the other party share their public key
    with you. You would then take that key and encrypt the message. Now, only the
    other party can decrypt it again with their private key.'
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric algorithms are much faster than asymmetric ones. However, they face
    the issue of key sharing. This issue is why most algorithms combine the two methods.
    They use an asymmetric algorithm to encrypt a key, which can be used for symmetric
    encryption. The key is relatively tiny, so encrypting and decrypting can be done
    reasonably quickly. Then that symmetric key is used to encrypt the complete message.
    This way, the symmetric key can be part of the message. It is encrypted itself,
    so only the intended recipient can decrypt the key and, thus, the rest of the
    message.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this sounds complicated, I have some good news: the CLR has many classes
    to help us do this. They are pretty simple to use as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric encryption and decryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s see whether we can encrypt and decrypt a simple message in C# code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This method takes the names of an input file, an output file, and a key. Then,
    it opens the input file, reads its contents, encrypts it, and writes the cyphertext
    to the output file.
  prefs: []
  type: TYPE_NORMAL
- en: The way this works is pretty straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will create the two streams. Then we will take the key and generate
    its byte array. The key must be a 128-bit, 192-bit, or 256-bit array. In other
    words, it has to be 16, 24, or 32 bytes long. The longer the key, the harder it
    is to hack. However, a long key also slows down the encryption and decryption
    processes. The choice is yours.
  prefs: []
  type: TYPE_NORMAL
- en: We will create an instance of the `Aes` class. **Advanced Encryption Standard**
    (**AES**) is widely considered a good and safe encryption algorithm. To make things
    even safer, the key we will use is augmented with an **Initialization Vector**
    (**IV**). You can think of this as something we add to the key to make it less
    readable. We will write that IV as the first thing in our file.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will create an instance of the `CryptoStream` class. This class helps
    us write encrypted data, as you can see in the ensuing code block. We will take
    arrays of bytes and write them to the `CryptoStream` class. Since we initialized
    the `CryptoStream` class with our AES class (well, the result of the call to `CreateEncryptor`
    of that class, to be more precise), it uses our key to encrypt data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decrypting is also simple. It works along the same principle: get the files
    from the key, read the IV from the file, then decrypt the rest and store it in
    a new file. That looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Instead of getting an `Encryptor` from the `CryptoStream`, we now get a `Decryptor`.
    The rest should be self-explanatory by now.
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric encryption and decryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example, we generated a simple 128-bit, 192-bit, or 256-bit
    key. For instance, you can pass it a string such as `SystemSoftware42` and get
    the bytes. The same key is used for encrypting and decrypting.
  prefs: []
  type: TYPE_NORMAL
- en: 'For asymmetric encryption, keys are a bit harder to get. However, there are
    helper classes for that, so it’s not hard to do in practice. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: I used the `RSA` class to generate the key pair. The **Rivest, Shamir, and Adleman**
    (**RSA**) class was named after the three cryptographers who invented this algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: We will create an instance of `RSA` by calling `Create()`. Then, we will call
    `ExportRSAPublicKey()` and `ExportRSAPrivateKey()` to get the generated keys out
    of it.
  prefs: []
  type: TYPE_NORMAL
- en: Since the keys are byte arrays, we will use `ToBase64String()` to make them
    more or less readable. That makes it easier to share the keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a key pair, we can use it to encrypt a message. Of course,
    we can also decrypt it again. That code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This code is simple enough. I only want to point out the last parameter in the
    `rsa.Encrypt()` and `rsa.Decrypt()` methods. We will use padding here to add extra
    data to the results (and we will remove it again when decrypting). This padding
    makes it harder for attackers to try to hack our message.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the three methods combined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: First, we will create a key pair. Our method returns that pair as strings so
    we can print them (I am again using our handy `Dump()` extension method). However,
    the keys need to be in a binary format, so I am reverting them to byte arrays.
  prefs: []
  type: TYPE_NORMAL
- en: I will define the message I want to encrypt, get the bytes of that message,
    and encrypt it. Then, I will print the encrypted message. If you do this, I think
    you will agree that it is hard to see the actual message. It is a mess of characters.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will reverse it by calling `DecryptWithPrivateKey()`. This method returns
    our string.
  prefs: []
  type: TYPE_NORMAL
- en: If we send the `Base64` version of our public key to someone and then transmit
    the encoded message, they can decode it with that public key. They would be sure
    that we sent that message; no one, other than us, can generate a message that
    can be decrypted by that public key but us. After all, private and public keys
    are a pair. You need one to encrypt so the second can decrypt.
  prefs: []
  type: TYPE_NORMAL
- en: Julius Caesar would be proud of us!
  prefs: []
  type: TYPE_NORMAL
- en: However, we have one more thing to talk about. We need to lose weight. Well,
    not us personally, but the payload in our files could benefit from this. Let’s
    talk about file compression.
  prefs: []
  type: TYPE_NORMAL
- en: File compression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Files can get quite large. As we have already discussed, file IO and network
    IO take a long time, especially compared to CPUs’ speeds. Anything we can do to
    minimize the time it takes to read from or write to IO could be worth it. This
    is even true if it means that we must make the CPU do a lot more. Of course, you
    need to measure this and see whether that also applies in your situation, but
    sometimes, sacrificing CPU time to speed up IO can make a huge difference.
  prefs: []
  type: TYPE_NORMAL
- en: One of the ways to do this is by limiting the amount of data we write in a file
    or a network stream. That can be done using compression.
  prefs: []
  type: TYPE_NORMAL
- en: In the CLR, you have a choice. You can use `DeflateStream` or `GZipStream` to
    do this. `GZipStream` uses `DeflateStream` internally, so `DeflateStream` is obviously
    faster. `GZipStream`, however, produces compressed files that can be read by external
    software. GZip is a standardized compression algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Compressing some data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s compress a string using `GZipStream`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Since compression and decompression might take a long time to finish, we really
    should use the `Async/Await` pattern here.
  prefs: []
  type: TYPE_NORMAL
- en: We will take some strings that we want to compress and pass them to the input
    variable. I use a `MemoryStream` in this example, but you could use any stream
    you like. Most real-world examples use a `FileStream` of some sort.
  prefs: []
  type: TYPE_NORMAL
- en: I will create an instance of the `GZipStream` class and give it the `MemoryStream`
    instance. This memory stream is where it writes the data. I will also tell the
    class that I want to compress data.
  prefs: []
  type: TYPE_NORMAL
- en: Then I just write data to it, flush the buffers, and get the bytes out of it.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! I have just compressed a string.
  prefs: []
  type: TYPE_NORMAL
- en: Decompressing some data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Decompressing is just as easy. Look at the following code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, I used two instances of the `MemoryStream` class. I used one as the source
    of the data and one as the destination of the uncompressed data. Again, please
    use any stream you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: That was not too hard, was it?
  prefs: []
  type: TYPE_NORMAL
- en: However, we are not done yet. The data that we want to store or read needs to
    be in a certain format. If you have a C# class with data in it, you cannot simply
    write that to a file. We need to translate that somehow. That’s where serialization
    comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Serialization – JSON and Binary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, we saw how to write binary data to a stream. We can
    call all the `write` methods to write all sorts of types to a file. However, that
    can be pretty hard and also quite error-prone. You have to keep track of the format
    of the data. One simple mistake will make your files unreadable.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better way would be to serialize your data in a format that the streams can
    understand. There are two ways to do that: **JSON** and **Binary**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'JSON is simple: most programming languages and platforms understand it. JSON
    has become the de facto standard for displaying a structure in text. In most places,
    JSON has replaced XML. JSON is smaller and more lightweight.'
  prefs: []
  type: TYPE_NORMAL
- en: However, it can be even more lightweight. You can also serialize your data as
    a binary stream. That requires more coding but usually results in much smaller
    files and data streams. Again, that might be precisely what we, as system programmers,
    are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: JSON serialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To serialize an object to the JSON format, people used to turn to `NewtonSoft.JSON`
    by default. `NewtonSoft.JSON` was the library of choice. It was easy to use (and
    still is) and offered many features that people liked, such as custom converters.
    However, Microsoft has since released `System.Text.Json`, which does the same
    but is much more efficient. As system programmers, we care about memory efficiency
    and speed, so I will focus on that one here.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can serialize something, we need something to serialize. The advantage
    of `System.Text.Json` is that I do not need to change my classes with attributes.
    The framework is smart enough to figure out what is needed and does that.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will use the same data class we saw earlier in this chapter in these examples.
    However, to save you from flipping through pages, I present it to you here once
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to serialize this to JSON to store it as text and later reread it,
    we will use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The code presented here is pretty straightforward. We will take the `MyData`
    class and give it to the static `Serialize` method, `System.Text.Json.JsonSerializer`.
    There are a couple of overloads for this method. I will use the one that takes
    an instance of the `JsonSerializerOptions` class. This way, I can format the output.
    I will set the `WriteIdented` property to `True`. I would get the whole string
    on one line if I had not done that. Granted, that would have saved me a couple
    of newline and tab characters, but for readability, I prefer this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will get the following result if we run this with some values in our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Deserializing, thereby reversing the process, is just as simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the process is simple enough.
  prefs: []
  type: TYPE_NORMAL
- en: Binary serialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is not the most efficient way to encode an object so you can store it in
    a file. It is relatively fast, but the actual data is also pretty large. Binary
    formatting is more work and the result is not human-readable, but it does lead
    to smaller files. That means that the time spent reading and writing data to a
    slow storage medium is significantly reduced. Of course, the tradeoff is that
    the CPU gets a bit busier, but that might be worth it. As always, measure and
    then decide whether this applies to your situation.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET Framework, before the days of .NET Core and .NET, we had a class named
    `BinaryFormatter`. That class, however, is now marked as obsolete. There are serious
    security concerns associated with that class, so Microsoft decided to get rid
    of it.
  prefs: []
  type: TYPE_NORMAL
- en: There are third-party packages you can use to achieve the same goal. However,
    if you do not want to use those, you can always do it yourself. We already discussed
    the `BinaryWriter` class and its methods. There is nothing wrong with using that
    class, but the downside is that you must write all the code, writing and reading
    each field or property. The `BinaryFormatter` class did that. That was quite handy,
    to be honest.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best package these days to achieve the same thing is `protobuf-net`. This
    package is available on NuGet, making it easy to install in your project. If you
    want to use `protobuf-net`, you must annotate your classes before you can serialize
    them. Using our `MyData` class again, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We have decorated the class with the `ProtoContract` attribute. Then, we decorated
    the properties with the `ProtoMember` attribute. This attribute can have associated
    data, but the first one is mandatory. This is the tag and it defines where the
    field is stored in the file. There is no hard rule on the numbering or the order
    aside from one: you cannot start with 0\. Yes. Indeed. I heard you gasp there.
    This is the only example I can think of in programming where starting with 0 is
    forbidden. If you want to start with 42, you can do that. However, the number
    has to be a positive integer, and 0 is not a positive integer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Serializing and deserializing are simple. You have to ensure that the data
    is available in a memory stream or can be written to a memory stream, but that
    is the only slightly complicated thing. This is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: That is it. I promised you that it would be simple, didn’t I?
  prefs: []
  type: TYPE_NORMAL
- en: If I take the same data as in the JSON serialization and compare the sizes,
    I can see that the binary version is much smaller. Even if I use the option not
    to write intended files, thus saving on newlines and tabs, the JSON version is
    131 bytes. In comparison, the binary version is only 60 bytes long. That is a
    big difference!
  prefs: []
  type: TYPE_NORMAL
- en: Next steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I/O is essential for all software. No software runs in isolation, especially
    software written for systems. After all, these applications do not have a traditional
    user interface; they are meant to be used by other software. The only way to communicate
    with that software is by exchanging data in one way or another.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has looked at ways to serialize and deserialize data to and from
    storage. We saw that JSON is simple and produces human-readable data. However,
    the data can be pretty big. In contrast, the binary version results in much smaller
    data, but that data is not human-readable anymore. Additionally, it requires a
    third-party package. What is the best solution? That depends on your use cases!
    It doesn’t matter whether you use files or a network connection; they are all
    approaches of I/O. In this chapter, you saw how to do that efficiently, quickly,
    and safely.
  prefs: []
  type: TYPE_NORMAL
- en: However, one way that is much more efficient for systems software to communicate
    is through direct communication over **Interprocess Communications** (**IPC**).
    IPC is a perfect way for systems software to establish an interface layer that
    other software can talk to or listen to. It is also the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
