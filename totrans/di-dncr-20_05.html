<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Object Composition</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In </span><a href="06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml" target="_blank"><span class="koboSpan" id="kobo.3.1">Chapter 4</span></a><span class="koboSpan" id="kobo.4.1">, </span><em><span class="koboSpan" id="kobo.5.1">Dependency Injection in ASP.NET Core</span></em><span class="koboSpan" id="kobo.6.1">, we got an insight into Dependency Injection with .NET Core and ASP.NET Core with default DI Container. </span><span class="koboSpan" id="kobo.6.2">We explored how to apply DI to different components of the application like controllers and views. </span><span class="koboSpan" id="kobo.6.3">Now it's time to deep dive into the actual fundamentals behind Dependency Injection.</span></p>
<p class="mce-root"><span class="koboSpan" id="kobo.7.1">Before moving forward with the main topic, we need to first understand why do we even care to read about this topic. </span><span class="koboSpan" id="kobo.7.2">The programming world is surrounded with objects and their interactions. </span><span class="koboSpan" id="kobo.7.3">We achieve certain solutions or build features getting help from classes that we generate for two basic reasons that are </span><strong><span class="koboSpan" id="kobo.8.1">code reuse</span></strong><span class="koboSpan" id="kobo.9.1"> and </span><strong><span class="koboSpan" id="kobo.10.1">maintainability</span></strong><span class="koboSpan" id="kobo.11.1">.</span></p>
<p class="mce-root"><span class="koboSpan" id="kobo.12.1">Now you might ask me why create classes at all! </span><span class="koboSpan" id="kobo.12.2">Yes, I second you, unless you ask me to alter code after some days. </span><span class="koboSpan" id="kobo.12.3">Then, even I can't help you because that will be a nightmare for me. </span><span class="koboSpan" id="kobo.12.4">And you know why? </span><span class="koboSpan" id="kobo.12.5">That is because I might have to repeat the codes (you have already written) in my new classes.</span></p>
<p class="mce-root"><span class="koboSpan" id="kobo.13.1">Suppose you have a class named </span><kbd><span class="koboSpan" id="kobo.14.1">Customer</span></kbd><span class="koboSpan" id="kobo.15.1"> with the properties </span><kbd><span class="koboSpan" id="kobo.16.1">CustomerId</span></kbd><span class="koboSpan" id="kobo.17.1">, </span><kbd><span class="koboSpan" id="kobo.18.1">FirstName</span></kbd><span class="koboSpan" id="kobo.19.1">, </span><kbd><span class="koboSpan" id="kobo.20.1">LastName</span></kbd><span class="koboSpan" id="kobo.21.1">, </span><kbd><span class="koboSpan" id="kobo.22.1">Email</span></kbd><span class="koboSpan" id="kobo.23.1">, </span><kbd><span class="koboSpan" id="kobo.24.1">MobileNumber</span></kbd><span class="koboSpan" id="kobo.25.1">, </span><kbd><span class="koboSpan" id="kobo.26.1">Address1</span></kbd><span class="koboSpan" id="kobo.27.1">, </span><kbd><span class="koboSpan" id="kobo.28.1">Address2</span></kbd><span class="koboSpan" id="kobo.29.1">, </span><kbd><span class="koboSpan" id="kobo.30.1">City</span></kbd><span class="koboSpan" id="kobo.31.1"> and so on. </span><span class="koboSpan" id="kobo.31.2">I come in and start working on another entity named as </span><kbd><span class="koboSpan" id="kobo.32.1">Seller</span></kbd><span class="koboSpan" id="kobo.33.1"> with the properties </span><kbd><span class="koboSpan" id="kobo.34.1">SellerId</span></kbd><span class="koboSpan" id="kobo.35.1">, </span><kbd><span class="koboSpan" id="kobo.36.1">FirstName</span></kbd><span class="koboSpan" id="kobo.37.1">, </span><kbd><span class="koboSpan" id="kobo.38.1">LastName</span></kbd><span class="koboSpan" id="kobo.39.1">, </span><kbd><span class="koboSpan" id="kobo.40.1">Email</span></kbd><span class="koboSpan" id="kobo.41.1">, </span><kbd><span class="koboSpan" id="kobo.42.1">MobileNumber</span></kbd><span class="koboSpan" id="kobo.43.1">, </span><kbd><span class="koboSpan" id="kobo.44.1">Address1</span></kbd><span class="koboSpan" id="kobo.45.1">, </span><kbd><span class="koboSpan" id="kobo.46.1">Address2</span></kbd><span class="koboSpan" id="kobo.47.1">, </span><kbd><span class="koboSpan" id="kobo.48.1">City</span></kbd><span class="koboSpan" id="kobo.49.1"> and so on.</span></p>
<p class="mce-root"><span class="koboSpan" id="kobo.50.1">I think you are smart enough to identify the problem. </span><span class="koboSpan" id="kobo.50.2">We can see the properties </span><span><span class="koboSpan" id="kobo.51.1">which are </span><em><span class="koboSpan" id="kobo.52.1">italicised</span></em></span><span class="koboSpan" id="kobo.53.1"> are getting repeated. </span><span class="koboSpan" id="kobo.53.2">One solution to this problem would be to create another class, something named </span><kbd><span class="koboSpan" id="kobo.54.1">User</span></kbd><span class="koboSpan" id="kobo.55.1"> with all those common properties. </span><span class="koboSpan" id="kobo.55.2">Then, the </span><kbd><span class="koboSpan" id="kobo.56.1">Customer</span></kbd><span class="koboSpan" id="kobo.57.1"> and </span><kbd><span class="koboSpan" id="kobo.58.1">Seller</span></kbd><span class="koboSpan" id="kobo.59.1"> classes become its children. </span><span class="koboSpan" id="kobo.59.2">Thus, we will achieve a simple design to deal with future entities as well. </span><span class="koboSpan" id="kobo.59.3">I can easily reuse the </span><kbd><span class="koboSpan" id="kobo.60.1">User</span></kbd><span class="koboSpan" id="kobo.61.1"> class to create some other child class, which would inherit the common properties if needed.</span></p>
<p><span class="koboSpan" id="kobo.62.1">Therefore, this chapter plays an important role in helping you grab these relationships. </span><span class="koboSpan" id="kobo.62.2">Designing a complex class with smaller flexible and reusable classes is an essential part of a software project, which will be the focused of this chapter. </span><span class="koboSpan" id="kobo.62.3">The following are the key topics that we will cover:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.63.1">Relationships</span></li>
<li><span class="koboSpan" id="kobo.64.1">Composition</span></li>
<li><span class="koboSpan" id="kobo.65.1">Aggregation</span></li>
<li><span class="koboSpan" id="kobo.66.1">Association</span></li>
<li><span class="koboSpan" id="kobo.67.1">Inheritance</span></li>
<li><span class="koboSpan" id="kobo.68.1">Composition over Inheritance</span></li>
<li><span class="koboSpan" id="kobo.69.1">The importance of Object Composition in Dependency Injection</span></li>
<li><span class="koboSpan" id="kobo.70.1">Object Composition in .NET Core 2.0 Console and MVC Apps</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Understanding object relationships</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's </span><span><span class="koboSpan" id="kobo.3.1">try to understand object relationships by first considering human relationships. </span><span class="koboSpan" id="kobo.3.2">The examples may not be the aptest but if we want to learn about object relationships, then why not look into it?</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.4.1">You depend on your parents till you get a job</span></li>
<li><span class="koboSpan" id="kobo.5.1">You have a wife and two children</span></li>
<li><span class="koboSpan" id="kobo.6.1">Trees have blossom and leaves on them</span></li>
<li><span class="koboSpan" id="kobo.7.1">A motherboard is part of a computer</span></li>
</ul>
<p><span class="koboSpan" id="kobo.8.1">All these relationships possess unique characteristics. </span><span class="koboSpan" id="kobo.8.2">Let me simplify my statement. </span><span class="koboSpan" id="kobo.8.3">You depend on your parents. </span><span class="koboSpan" id="kobo.8.4">However, if they become jobless, you are not going to die. </span><span class="koboSpan" id="kobo.8.5">You will find some way to deal with the situation. </span><span class="koboSpan" id="kobo.8.6">On the contrary, if a tree dies, its blossom and leaves will die eventually. </span><span class="koboSpan" id="kobo.8.7">The relationship between the tree and its parts are tightly coupled. </span><span class="koboSpan" id="kobo.8.8">After the tree gets a life (instantiated), within a short period of time, its parts come to life as well. </span><span class="koboSpan" id="kobo.8.9">A motherboard without a computer is useless. </span><span class="koboSpan" id="kobo.8.10">It comes into play when it becomes a component of a computer.</span></p>
<p><span class="koboSpan" id="kobo.9.1">Let's consider the following code snippet to understand the relationship between classes:</span></p>
<pre><span class="koboSpan" id="kobo.10.1">    class Organisation</span><br/><span class="koboSpan" id="kobo.11.1">    {</span><br/><span class="koboSpan" id="kobo.12.1">      public Organisation() { }</span><br/><span class="koboSpan" id="kobo.13.1">      public string Name { get; set; }</span><br/><span class="koboSpan" id="kobo.14.1">      public string OfficialFacebookLink { get; set; }</span><br/><span class="koboSpan" id="kobo.15.1">    }</span><br/><br/><span class="koboSpan" id="kobo.16.1">    class Packt : Organisation</span><br/><span class="koboSpan" id="kobo.17.1">    {</span><br/><span class="koboSpan" id="kobo.18.1">      public Packt() { }</span><br/><span class="koboSpan" id="kobo.19.1">      public int TotalBooksPublished { get; set; }</span><br/><br/><span class="koboSpan" id="kobo.20.1">      public void PrintPacktInfo()</span><br/><span class="koboSpan" id="kobo.21.1">      {</span><br/><span class="koboSpan" id="kobo.22.1">        Console.WriteLine($"This is {Name}!\n" +</span><br/><span class="koboSpan" id="kobo.23.1">            $"Our official facebook page link is </span><br/><span class="koboSpan" id="kobo.24.1">              {OfficialFacebookLink}.\n" +</span><br/><span class="koboSpan" id="kobo.25.1">            $"We have published {TotalBooksPublished} books.\n");</span><br/><br/>        <strong><span class="koboSpan" id="kobo.26.1">Account account = new Account();</span></strong><br/>        <strong><span class="koboSpan" id="kobo.27.1">account.PrintAcountInfo(1, "Packt Account");</span></strong><br/><span class="koboSpan" id="kobo.28.1">      }</span><br/><span class="koboSpan" id="kobo.29.1">    }</span><br/><br/><span class="koboSpan" id="kobo.30.1">    public class Account</span><br/><span class="koboSpan" id="kobo.31.1">    {</span><br/><span class="koboSpan" id="kobo.32.1">      public int AccountId { get; set; }</span><br/><span class="koboSpan" id="kobo.33.1">      public string AccountName { get; set; }</span><br/><br/><span class="koboSpan" id="kobo.34.1">      public void PrintAcountInfo(int accId, string accName) </span><br/><span class="koboSpan" id="kobo.35.1">      {</span><br/><span class="koboSpan" id="kobo.36.1">        Console.WriteLine("Account Id: " + accId + "</span><br/><span class="koboSpan" id="kobo.37.1">            and Account Name: " + accName);</span><br/><span class="koboSpan" id="kobo.38.1">      }</span><br/><span class="koboSpan" id="kobo.39.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.40.1">We have one </span><kbd><span class="koboSpan" id="kobo.41.1">Organisation</span></kbd><span class="koboSpan" id="kobo.42.1"> class and </span><kbd><span class="koboSpan" id="kobo.43.1">Packt</span></kbd><span class="koboSpan" id="kobo.44.1">, being an organization, derives the parent class </span><kbd><span class="koboSpan" id="kobo.45.1">Organisation</span></kbd><span class="koboSpan" id="kobo.46.1">. </span><span class="koboSpan" id="kobo.46.2">This relationship is denoted as </span><em><span class="koboSpan" id="kobo.47.1">is a</span></em><span class="koboSpan" id="kobo.48.1"> relationship because </span><kbd><span class="koboSpan" id="kobo.49.1">Packt</span></kbd><span class="koboSpan" id="kobo.50.1"> is an organization. </span><kbd><span class="koboSpan" id="kobo.51.1">Account</span></kbd><span class="koboSpan" id="kobo.52.1"> is a class, which can become </span><em><span class="koboSpan" id="kobo.53.1">a part of</span></em><span class="koboSpan" id="kobo.54.1"> a </span><kbd><span class="koboSpan" id="kobo.55.1">Packt</span></kbd><span class="koboSpan" id="kobo.56.1"> class. </span><span class="koboSpan" id="kobo.56.2">Thus, there is another relationship between </span><kbd><span class="koboSpan" id="kobo.57.1">Packt</span></kbd><span class="koboSpan" id="kobo.58.1"> and </span><kbd><span class="koboSpan" id="kobo.59.1">Account</span></kbd><span class="koboSpan" id="kobo.60.1">. </span><span class="koboSpan" id="kobo.60.2">The name of the relationship is </span><em><span class="koboSpan" id="kobo.61.1">a part of</span></em><strong><span class="koboSpan" id="kobo.62.1">.</span></strong></p>
<p><span class="koboSpan" id="kobo.63.1">Notice the method </span><kbd><span class="koboSpan" id="kobo.64.1">PrintPacktInfo()</span></kbd><span class="koboSpan" id="kobo.65.1"> inside </span><kbd><span class="koboSpan" id="kobo.66.1">Packt</span></kbd><span class="koboSpan" id="kobo.67.1"> class, which prints all information regarding </span><kbd><span class="koboSpan" id="kobo.68.1">Packt</span></kbd><span class="koboSpan" id="kobo.69.1">. </span><span class="koboSpan" id="kobo.69.2">However, that is not all, because you can see there is an </span><kbd><span class="koboSpan" id="kobo.70.1">Account</span></kbd><span class="koboSpan" id="kobo.71.1"> class instance generated inside the method by which we are able to print the account information of </span><kbd><span class="koboSpan" id="kobo.72.1">Packt</span></kbd><span class="koboSpan" id="kobo.73.1">.</span></p>
<p><span class="koboSpan" id="kobo.74.1">The </span><kbd><span class="koboSpan" id="kobo.75.1">Main</span></kbd><span class="koboSpan" id="kobo.76.1"> method looks as follows, where we create an instance of </span><kbd><span class="koboSpan" id="kobo.77.1">Packt</span></kbd><span class="koboSpan" id="kobo.78.1"> and provide any necessary details through properties and then call </span><kbd><span class="koboSpan" id="kobo.79.1">PrintPacktInfo()</span></kbd><span class="koboSpan" id="kobo.80.1">:</span></p>
<pre><span class="koboSpan" id="kobo.81.1">    static void Main(string[] args)</span><br/><span class="koboSpan" id="kobo.82.1">    {</span><br/><span class="koboSpan" id="kobo.83.1">      Packt packt = new Packt</span><br/><span class="koboSpan" id="kobo.84.1">      {</span><br/><span class="koboSpan" id="kobo.85.1">         Name = "Packt Publications",</span><br/><span class="koboSpan" id="kobo.86.1">         OfficialFacebookLink = "https://www.facebook.com/PacktPub/",</span><br/><span class="koboSpan" id="kobo.87.1">         TotalBooksPublished = 5000</span><br/><span class="koboSpan" id="kobo.88.1">      };</span><br/><br/>      <strong><span class="koboSpan" id="kobo.89.1">packt</span></strong><strong><span class="koboSpan" id="kobo.90.1">.PrintPacktInfo(); // Prints the Account information.</span></strong><br/><span class="koboSpan" id="kobo.91.1">      Console.ReadKey();</span><br/><span class="koboSpan" id="kobo.92.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.93.1">The code produces the following output:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.94.1"><img src="assets/c1e32247-cae9-4cf4-9e49-f75a0129a769.png"/></span></div>
<p><span class="koboSpan" id="kobo.95.1">The important thing to take away from this example is the way the </span><kbd><span class="koboSpan" id="kobo.96.1">Packt</span></kbd><span class="koboSpan" id="kobo.97.1"> class depends on the </span><kbd><span class="koboSpan" id="kobo.98.1">Account</span></kbd><span class="koboSpan" id="kobo.99.1"> class. </span><kbd><span class="koboSpan" id="kobo.100.1">Dependency</span></kbd><span class="koboSpan" id="kobo.101.1"> is generated inside the </span><kbd><span class="koboSpan" id="kobo.102.1">Packt</span></kbd><span class="koboSpan" id="kobo.103.1"> class.</span></p>
<p class="mce-root"><span class="koboSpan" id="kobo.104.1">Like the preceding one, we can find patterns, relationships, and hierarchies in programming. </span><span class="koboSpan" id="kobo.104.2">Let's investigate these in more detail and learn how to improve code reusability and elasticity of classes.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Object Composition</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">When I searched for the word </span><span class="packt_screen"><span class="koboSpan" id="kobo.3.1">composition</span></span><span class="koboSpan" id="kobo.4.1"> in Google, the first thing I saw was:</span></p>
<div class="packt_quote"><span class="koboSpan" id="kobo.5.1">the nature of something's ingredients or constituents; the way in which a whole or mixture is made up.</span></div>
<p><span class="koboSpan" id="kobo.6.1">Now it's very simple to guess what Object Composition would be. </span><span class="koboSpan" id="kobo.6.2">Objects collectively mix themselves to constitute (be a part of) complex objects.</span></p>
<p><span class="koboSpan" id="kobo.7.1">A simple real life example would be a car whose whole body consists of different types of components like engine, break, gear, battery, door, etc. </span><span class="koboSpan" id="kobo.7.2">Thus, these parts are actually the building blocks of the car and are composed in a very innovative way by the maker of the car.</span></p>
<p><span class="koboSpan" id="kobo.8.1">Likewise, as we discussed, the </span><kbd><span class="koboSpan" id="kobo.9.1">Account</span></kbd><span class="koboSpan" id="kobo.10.1"> class reference inside the </span><kbd><span class="koboSpan" id="kobo.11.1">Packt</span></kbd><span class="koboSpan" id="kobo.12.1"> class method in the last section, which generates a relationship among them. </span><span class="koboSpan" id="kobo.12.2">We can consider that as a dependency too, as we can't execute the method of the </span><kbd><span class="koboSpan" id="kobo.13.1">Packt</span></kbd><span class="koboSpan" id="kobo.14.1"> class without an instance of </span><kbd><span class="koboSpan" id="kobo.15.1">Account</span></kbd><span class="koboSpan" id="kobo.16.1"> class. </span><span class="koboSpan" id="kobo.16.2">Clearly, we can say that the </span><kbd><span class="koboSpan" id="kobo.17.1">Packt</span></kbd><span class="koboSpan" id="kobo.18.1"> object composes itself with the help of the </span><kbd><span class="koboSpan" id="kobo.19.1">Account</span></kbd><span class="koboSpan" id="kobo.20.1"> instance.</span></p>
<p><span class="koboSpan" id="kobo.21.1">Did you notice the bracketed phrase in the first paragraph </span><em><span class="koboSpan" id="kobo.22.1">be</span></em> <em><span class="koboSpan" id="kobo.23.1">a part of</span></em><span class="koboSpan" id="kobo.24.1">? </span><span class="koboSpan" id="kobo.24.2">Confused! </span><span class="koboSpan" id="kobo.24.3">Let's discuss again and get hold of this phrase. </span><span class="koboSpan" id="kobo.24.4">In other words, this phrase can also be represented as </span><em><span class="koboSpan" id="kobo.25.1">has a,</span></em><span class="koboSpan" id="kobo.26.1"> if I form the sentence from the complex object point of view. </span><span class="koboSpan" id="kobo.26.2">Refer the lines below.</span></p>
<ul>
<li><span class="koboSpan" id="kobo.27.1">A computer </span><em><span class="koboSpan" id="kobo.28.1">has a</span></em><span class="koboSpan" id="kobo.29.1"> keyboard. </span><span class="koboSpan" id="kobo.29.2">(Keyboard </span><em><span class="koboSpan" id="kobo.30.1">is a part of</span></em><span class="koboSpan" id="kobo.31.1"> computer)</span></li>
<li><span class="koboSpan" id="kobo.32.1">A car </span><em><span class="koboSpan" id="kobo.33.1">has an</span></em><span class="koboSpan" id="kobo.34.1"> engine. </span><span class="koboSpan" id="kobo.34.2">(Engine </span><em><span class="koboSpan" id="kobo.35.1">is a part of</span></em><span class="koboSpan" id="kobo.36.1"> car)</span></li>
</ul>
<p><span class="koboSpan" id="kobo.37.1">It's pretty clear now, as you can see how these complex objects are made up of small objects conceptualizing Object Composition.</span></p>
<p><span class="koboSpan" id="kobo.38.1">As you already know, different fundamental data types like </span><kbd><span class="koboSpan" id="kobo.39.1">int</span></kbd><span class="koboSpan" id="kobo.40.1">, </span><kbd><span class="koboSpan" id="kobo.41.1">string</span></kbd><span class="koboSpan" id="kobo.42.1">, boolean, and so on, or other class types, can be packaged into one structure or another class type, therefore, classes are often considered composite types.</span></p>
<p><span class="koboSpan" id="kobo.43.1">The most important benefit of applying this concept to your projects is to get more easily manageable parts. </span><span class="koboSpan" id="kobo.43.2">Not only does it reduces the complexity of the application, but it also helps us to write code faster. </span><span class="koboSpan" id="kobo.43.3">Another noticeable advantage is code reuse, which leads to fewer errors as you will be using codes which have already been verified after testing.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Types of Object Composition</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">There are two subtypes of Object Composition, </span><strong><span class="koboSpan" id="kobo.3.1">Composition</span></strong><span class="koboSpan" id="kobo.4.1"> and </span><strong><span class="koboSpan" id="kobo.5.1">aggregation</span></strong><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">Let's discuss one by one.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Composition</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A Composition is a way through which you can bind objects together. </span><span class="koboSpan" id="kobo.2.2">One object can contain another object of the same/another class as a building block.</span></p>
<p><span class="koboSpan" id="kobo.3.1">In other words, in our last example, </span><kbd><span class="koboSpan" id="kobo.4.1">Packt</span></kbd><span class="koboSpan" id="kobo.5.1"> was dependent upon the </span><kbd><span class="koboSpan" id="kobo.6.1">Account</span></kbd><span class="koboSpan" id="kobo.7.1"> class for its operation. </span><span class="koboSpan" id="kobo.7.2">The instance is created by the </span><kbd><span class="koboSpan" id="kobo.8.1">Packt</span></kbd><span class="koboSpan" id="kobo.9.1"> class, giving life to it and then operated some function with the instance. </span><span class="koboSpan" id="kobo.9.2">You can add another class like </span><kbd><span class="koboSpan" id="kobo.10.1">Packt</span></kbd><span class="koboSpan" id="kobo.11.1"> and do the same using an </span><kbd><span class="koboSpan" id="kobo.12.1">Account</span></kbd><span class="koboSpan" id="kobo.13.1"> instance. </span><span class="koboSpan" id="kobo.13.2">Thus, you are trying to compose the objects to form a more complex one, which enables us to execute behavior (methods) of all composed/part objects with one composite object.</span></p>
<p><span class="koboSpan" id="kobo.14.1">The following are the relationships, which is satisfied by the object and it's member or part, qualify as a Composition.</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.15.1">The part</span></strong> <strong><span class="koboSpan" id="kobo.16.1">(member) is a component of the object (class)</span></strong><span class="koboSpan" id="kobo.17.1">: As we have already discussed, the part or smaller class should be a part of the bigger complex class. </span><span class="koboSpan" id="kobo.17.2">For example, your kidney is a part of your body.</span></li>
<li><strong><span class="koboSpan" id="kobo.18.1">The part (member) can only belong to one object (class) at a time</span></strong><span class="koboSpan" id="kobo.19.1">: If the smaller class is referred to the complex class at a certain period, then it can't be a part of other classes at the same time. </span><span class="koboSpan" id="kobo.19.2">For example, your kidney, which is a part of your body, can't be a part of someone else's body at the same time.</span></li>
<li><strong><span class="koboSpan" id="kobo.20.1">The part (member) has its existence managed by the object (class)</span></strong><span class="koboSpan" id="kobo.21.1">: The object is responsible for the existence of the parts in a Composition relationship. </span><span class="koboSpan" id="kobo.21.2">In simple words, the part is created when the object is created and destroyed when the object is destroyed. </span><span class="koboSpan" id="kobo.21.3">This means the object manages the part's lifetime in such a way that the user of the object does not need to get involved. </span><span class="koboSpan" id="kobo.21.4">For example, when a body is created, the kidney is created too. </span><span class="koboSpan" id="kobo.21.5">When a person's body is destroyed, their kidney is destroyed too. </span><span class="koboSpan" id="kobo.21.6">Because of this, the Composition is sometimes called a </span><strong><span class="koboSpan" id="kobo.22.1">Death Relationship</span></strong><span class="koboSpan" id="kobo.23.1">.</span></li>
<li><strong><span class="koboSpan" id="kobo.24.1">The part (member) does not know about the existence of the object (class):</span></strong><span class="koboSpan" id="kobo.25.1"> A particular part in a Composition doesn't know about the existence of the whole object. </span><span class="koboSpan" id="kobo.25.2">Your kidney is unaware that it is part of a larger structure but works as expected. </span><span class="koboSpan" id="kobo.25.3">This is called a </span><strong><span class="koboSpan" id="kobo.26.1">Unidirectional Relationship</span></strong><span class="koboSpan" id="kobo.27.1">. </span><span class="koboSpan" id="kobo.27.2">For example, the body knows about the kidney, but not the other way around.</span></li>
</ul>
<div class="packt_infobox"><span class="koboSpan" id="kobo.28.1">If you are thinking that as body parts can be transferable, why not member classes, then you are assuming right. </span><span class="koboSpan" id="kobo.28.2">Member classes can also be transferred. </span><span class="koboSpan" id="kobo.28.3">Thus, the new larger class is now the owner of the member class and the member class is no more related to the previous owner unless that is transferred again.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Consider an example</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Our favorite </span><kbd><span class="koboSpan" id="kobo.3.1">Student</span></kbd><span class="koboSpan" id="kobo.4.1"> class:</span></p>
<pre class="mce-root"><span class="koboSpan" id="kobo.5.1">    public class Student
    {
      private int Id { get; set; }
      private string Name { get; set; }
      private DateTime Dob { get; set; }
      private Address Address { get; set; }
      private ICollection&lt;Book&gt; Books { get; set; }</span><br/><br/><span class="koboSpan" id="kobo.6.1">      public void PrintStudent()</span><br/><span class="koboSpan" id="kobo.7.1">      {</span><br/><span class="koboSpan" id="kobo.8.1">        Console.WriteLine("Student: " + Name);</span><br/><span class="koboSpan" id="kobo.9.1">        Console.WriteLine("City: " + Address.City + "");</span><br/><span class="koboSpan" id="kobo.10.1">        Console.WriteLine("-----------------------");</span><br/><span class="koboSpan" id="kobo.11.1">      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.12.1">Come on, don't be so surprised and please don't scold me now. </span><span class="koboSpan" id="kobo.12.2">I know this looks like a very basic class, but that is what Composition is all about, in short. </span><span class="koboSpan" id="kobo.12.3">Don't believe me? </span><span class="koboSpan" id="kobo.12.4">Alright, allow me to match those relationships with this </span><kbd><span class="koboSpan" id="kobo.13.1">Student</span></kbd><span class="koboSpan" id="kobo.14.1"> class:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.15.1">Rule 1: Part of a complex class</span></strong><span class="koboSpan" id="kobo.16.1">: You can see the class members which are of different types such as </span><kbd><span class="koboSpan" id="kobo.17.1">Integer</span></kbd><span><span class="koboSpan" id="kobo.18.1">,</span></span> <kbd><span class="koboSpan" id="kobo.19.1">string</span></kbd><span><span class="koboSpan" id="kobo.20.1">,</span></span> <kbd><span class="koboSpan" id="kobo.21.1">DateTime</span></kbd><span><span class="koboSpan" id="kobo.22.1">,</span></span> <kbd><span class="koboSpan" id="kobo.23.1">Class</span></kbd> <span><span class="koboSpan" id="kobo.24.1">and</span></span> <kbd><span class="koboSpan" id="kobo.25.1">List&lt;Class&gt;</span></kbd> <span><span class="koboSpan" id="kobo.26.1">type.</span></span> <kbd><span class="koboSpan" id="kobo.27.1">Integer</span></kbd><span><span class="koboSpan" id="kobo.28.1">,</span></span> <kbd><span class="koboSpan" id="kobo.29.1">string</span></kbd><span class="koboSpan" id="kobo.30.1">, </span><span><span class="koboSpan" id="kobo.31.1">and</span></span> <kbd><span class="koboSpan" id="kobo.32.1">DateTime</span></kbd> <span><span class="koboSpan" id="kobo.33.1">are the data types already defined inside the</span></span> <kbd><span class="koboSpan" id="kobo.34.1">System</span></kbd> <span><span class="koboSpan" id="kobo.35.1">namespace of .NET Framework, whereas the</span></span> <kbd><span class="koboSpan" id="kobo.36.1">Address</span></kbd> <span><span class="koboSpan" id="kobo.37.1">and</span></span> <kbd><span class="koboSpan" id="kobo.38.1">Book</span></kbd> <span><span><span class="koboSpan" id="kobo.39.1">classes are user-defined classes. </span><span class="koboSpan" id="kobo.39.2">All are part of a complex class </span><kbd><span class="koboSpan" id="kobo.40.1">Student</span></kbd><span class="koboSpan" id="kobo.41.1">. </span><span class="koboSpan" id="kobo.41.2">Thus, the first condition is satisfied.</span></span></span></li>
<li><strong><span class="koboSpan" id="kobo.42.1">Rule 2: Members should belong to one object</span></strong><span class="koboSpan" id="kobo.43.1">: If I create an instance of the </span><kbd><span class="koboSpan" id="kobo.44.1">Student</span></kbd><span class="koboSpan" id="kobo.45.1"> class, with a constructor, the members will only belong to the student object at that time. </span><span class="koboSpan" id="kobo.45.2">It can't be a member of another instance. </span><span class="koboSpan" id="kobo.45.3">Moreover, the members are private, which prevents them being used by any other class.</span></li>
</ul>
<pre><span class="koboSpan" id="kobo.46.1">        Student student = new Student(1, "Bhagirathi Panda", </span><br/><span class="koboSpan" id="kobo.47.1">          new DateTime(1990, 4, 23));</span></pre>
<p style="padding-left: 60px"><span class="koboSpan" id="kobo.48.1">The constructor will look like the following:</span></p>
<pre><span class="koboSpan" id="kobo.49.1">        public Student(int id, string name, DateTime dob)
        {
          Id = id;
          Name = name;
          Dob = dob;
        }</span></pre>
<ul>
<li><strong><span class="koboSpan" id="kobo.50.1">Rule 3: Members gets a life by the complex class (Death Relationship)</span></strong><span class="koboSpan" id="kobo.51.1">: As you can see, members don't have any existence until we instantiate the </span><kbd><span class="koboSpan" id="kobo.52.1">Student</span></kbd><span class="koboSpan" id="kobo.53.1"> class and they get destroyed when the object is dead; proving our rule 3.</span></li>
<li><strong><span class="koboSpan" id="kobo.54.1">Rule 4: Members are unaware of the existence of the complex object (Unidirectional Relationship):</span></strong><span class="koboSpan" id="kobo.55.1"> The members are very obedient. </span><span class="koboSpan" id="kobo.55.2">They just store whatever value is assigned to them and don't even bother about who is assigning them for what reasons. </span><span class="koboSpan" id="kobo.55.3">The complex instance is their parent but these members behave like orphans and don't recognize it. </span><span class="koboSpan" id="kobo.55.4">Likewise, we don't mind what they are doing because our rule 4 is proved.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.56.1">Another important thing to note here is that the complex class can have a multiplicative member like </span><kbd><span class="koboSpan" id="kobo.57.1">List&lt;Book&gt; Books</span></kbd><span class="koboSpan" id="kobo.58.1">.</span></p>
<div class="packt_tip CDPAlignCenter CDPAlign">
<p><span class="koboSpan" id="kobo.59.1">Do you know the shortcut to create a constructor? </span><span class="koboSpan" id="kobo.59.2">Just type </span><strong><span class="koboSpan" id="kobo.60.1">ctor</span></strong><span class="koboSpan" id="kobo.61.1"> at the line where you want the constructor and then hit the </span><em><span class="koboSpan" id="kobo.62.1">Tab</span></em><span class="koboSpan" id="kobo.63.1"> key two times. </span><span class="koboSpan" id="kobo.63.2">You will see an empty constructor block available for you. </span><span class="koboSpan" id="kobo.63.3">Moreover, Visual Studio tooltip tells you how to handle the command:</span></p>
<p><span class="koboSpan" id="kobo.64.1"><img src="assets/211734ba-9e84-4120-bcf5-997859ff6c4a.png"/></span></p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Contrasting features of Composition</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The parts are created with the composite class's creation. </span><span class="koboSpan" id="kobo.2.2">That means the composite class is responsible for the creation. </span><span class="koboSpan" id="kobo.2.3">Also, the destruction of the part depends upon the destruction of their creator composite class. </span><span class="koboSpan" id="kobo.2.4">However, rules are meant to be broken and that happens in the case of Composition too.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Consider the following scenarios:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.4.1">The creation of a part is postponed till it is actually used. </span><span class="koboSpan" id="kobo.4.2">For instance, our </span><kbd><span class="koboSpan" id="kobo.5.1">Student</span></kbd><span class="koboSpan" id="kobo.6.1"> class doesn't create the list of books until the user or any other method assigns some data to it.</span></li>
<li><span class="koboSpan" id="kobo.7.1">A Composition assigns the responsibility of destructing the part to some other object. </span><span class="koboSpan" id="kobo.7.2">We are already aware of such routine named </span><strong><span class="koboSpan" id="kobo.8.1">Garbage Collector</span></strong><span class="koboSpan" id="kobo.9.1">, who manages the destruction of unused objects from time to time.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.10.1">Composition acts like a guardian, where all care of the members is taken by the composite class. </span><span class="koboSpan" id="kobo.10.2">Creation, assignment, and destruction; all are mostly managed by the composite class.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Why are subclasses inside Composition?</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">There is always a decision you need to take while you program. </span><span class="koboSpan" id="kobo.2.2">If you closely analyze our </span><kbd><span class="koboSpan" id="kobo.3.1">Student</span></kbd><span class="koboSpan" id="kobo.4.1"> class, you will realize a few things. </span><span class="koboSpan" id="kobo.4.2">The properties of the </span><kbd><span class="koboSpan" id="kobo.5.1">Address</span></kbd><span class="koboSpan" id="kobo.6.1"> class be can directly be declared inside the </span><kbd><span class="koboSpan" id="kobo.7.1">Student</span></kbd><span class="koboSpan" id="kobo.8.1"> class instead of declared as a different entity.</span></p>
<p><span class="koboSpan" id="kobo.9.1">So, instead of the following:</span></p>
<pre><span class="koboSpan" id="kobo.10.1">    public class Student
    {
      // Other properties.

      </span><span class="koboSpan" id="kobo.10.2">int AddressId {get; set;}
      string City {get; set;}
      string State {get; set;}
      string Country {get; set;}
    }</span></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.11.1">We did this. </span><span class="koboSpan" id="kobo.11.2">Basically, we just separated out the address properties in a container class named </span><kbd><span class="koboSpan" id="kobo.12.1">Address</span></kbd><span class="koboSpan" id="kobo.13.1">. </span><span class="koboSpan" id="kobo.13.2">The following code block shows how we can extract out </span><kbd><span class="koboSpan" id="kobo.14.1">Address</span></kbd><span class="koboSpan" id="kobo.15.1"> class:</span></p>
<pre><span class="koboSpan" id="kobo.16.1">    public class Student
    {
      // Other properties.
      </span><span class="koboSpan" id="kobo.16.2">private Address Address { get; set; }
    }
    public class Address
    {
      public int AddressId { get; set; }
      public string City { get; set; }
      public string State { get; set; }
      public string Country { get; set; }</span><br/><br/><span class="koboSpan" id="kobo.17.1">      // Constructor. </span><span class="koboSpan" id="kobo.17.2">Just initialising City for now.</span><br/><span class="koboSpan" id="kobo.18.1">      public Address(string city)</span><br/><span class="koboSpan" id="kobo.19.1">      {</span><br/><span class="koboSpan" id="kobo.20.1">        City = city;</span><br/><span class="koboSpan" id="kobo.21.1">      }
    }</span></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.22.1">These are some of the advantages of doing a subclass instead of directly adding them to the composite class:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.23.1">The subclass is independent and simplifies the architecture. </span><span class="koboSpan" id="kobo.23.2">The code seems very easy to understand. </span><span class="koboSpan" id="kobo.23.3">The actual benefit you get out of it is when you try to do something extra on it, in the future. </span><span class="koboSpan" id="kobo.23.4">Suppose, I tell you to include another member </span><span class="packt_screen"><span class="koboSpan" id="kobo.24.1">Street</span></span><span class="koboSpan" id="kobo.25.1"> for </span><kbd><span class="koboSpan" id="kobo.26.1">Address</span></kbd><span class="koboSpan" id="kobo.27.1">. </span><span class="koboSpan" id="kobo.27.2">If you have designed address properties directly inside composite classes, then you have to manually go to each class and add another member. </span><span class="koboSpan" id="kobo.27.3">However, in the case of the subclass, you just need to add that to the subclass and all composite classes using that will get the access automatically.</span></li>
<li><span class="koboSpan" id="kobo.28.1">The more you break down the classes into subclasses, the more you make them be reusable. </span><span class="koboSpan" id="kobo.28.2">The address class, for instance, can be reused in some other class as well. </span><span class="koboSpan" id="kobo.28.3">It is no more tightly coupled with the Composition.</span></li>
<li><span class="koboSpan" id="kobo.29.1">Due to the introduction of subclasses, the composite class is not complex anymore. </span><span class="koboSpan" id="kobo.29.2">Moreover, the subclasses can have methods defined in them which makes the life of the composite object easy. </span><span class="koboSpan" id="kobo.29.3">That is because the subclass can define it's related functions which can be called by the composite class. </span><span class="koboSpan" id="kobo.29.4">For example, if we want to get the full address, we can easily have a method inside the </span><kbd><span class="koboSpan" id="kobo.30.1">Address</span></kbd><span class="koboSpan" id="kobo.31.1"> class, which will return a string using all those address properties. </span><span class="koboSpan" id="kobo.31.2">Thus, the composite class does not need to do anything on </span><kbd><span class="koboSpan" id="kobo.32.1">Address</span></kbd><span class="koboSpan" id="kobo.33.1"> related stuff.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Important notes</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Thinking of a better design, such that it distributes responsibilities among different entities, is tough. </span><span class="koboSpan" id="kobo.2.2">But it is not impossible. </span><span class="koboSpan" id="kobo.2.3">When we start building the app, we don't always have full specifications or realize what could happen next. </span><span class="koboSpan" id="kobo.2.4">Eventually, when more specifications come in, we face problems as we ignore building subclasses for a certain common usage. </span><span class="koboSpan" id="kobo.2.5">Therefore, you will also see bad and repeated codes in many classes which can be packaged in a subclass and could easily be reused.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Composite or main classes should be responsible for what it is designed. </span><span class="koboSpan" id="kobo.3.2">A </span><kbd><span class="koboSpan" id="kobo.4.1">Student</span></kbd><span class="koboSpan" id="kobo.5.1"> class is responsible for managing student information. </span><span class="koboSpan" id="kobo.5.2">There is no doubt that the address of the student is something it should handle. </span><span class="koboSpan" id="kobo.5.3">But, what if we get another entity like </span><kbd><span class="koboSpan" id="kobo.6.1">Teacher</span></kbd><span class="koboSpan" id="kobo.7.1"> who also has an address? </span><span class="koboSpan" id="kobo.7.2">We have to repeat the same set of properties inside the </span><kbd><span class="koboSpan" id="kobo.8.1">Teacher</span></kbd><span class="koboSpan" id="kobo.9.1"> class to achieve this. </span><span class="koboSpan" id="kobo.9.2">Code smell isn't it! </span><span class="koboSpan" id="kobo.9.3">That is when you should decide to separate </span><kbd><span class="koboSpan" id="kobo.10.1">Address</span></kbd><span class="koboSpan" id="kobo.11.1">--related information to another class.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Aggregation</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Aggregation is another type of object Composition. </span><span class="koboSpan" id="kobo.2.2">Let's explore this in details.</span></p>
<p><span class="koboSpan" id="kobo.3.1">It is the process by which you bring existing objects together to form a new object. </span><span class="koboSpan" id="kobo.3.2">At first, it looks similar to Composition. </span><span class="koboSpan" id="kobo.3.3">But in reality, it has differences. </span><span class="koboSpan" id="kobo.3.4">To qualify as an aggregation, the complex object and its parts must satisfy the following relationships:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.4.1">The part (member) is a component of the object (class)</span></strong><span class="koboSpan" id="kobo.5.1">: It is similar to Composition. </span><span class="koboSpan" id="kobo.5.2">That means the smaller object is a part of the complex object. </span><span class="koboSpan" id="kobo.5.3">For example, a person has a Google Drive folder.</span></li>
<li><strong><span class="koboSpan" id="kobo.6.1">The part (member) can belong to more than one object (class) at a time</span></strong><span class="koboSpan" id="kobo.7.1">: Unlike Composition, here the member is independent of the class. </span><span class="koboSpan" id="kobo.7.2">It might be referenced by other classes as well at the same time. </span><span class="koboSpan" id="kobo.7.3">For example, a Drive folder can be shared by many users at the same time.</span></li>
<li><strong><span class="koboSpan" id="kobo.8.1">The part (member) does not have its existence managed by the object (class):</span></strong><span class="koboSpan" id="kobo.9.1"> As the last point states the member is not tied to the complex class, so it's creation and destruction is not managed by it. </span><span class="koboSpan" id="kobo.9.2">For example, all those people with whom the folder is shared have not created it. </span><span class="koboSpan" id="kobo.9.3">Unless they are provided with admin rights, they can't delete the folder.</span></li>
<li><strong><span class="koboSpan" id="kobo.10.1">The part (member) does not know about the existence of the object (class):</span></strong><span class="koboSpan" id="kobo.11.1"> The member does not know whether the complex object exists or not, same as Composition. </span><span class="koboSpan" id="kobo.11.2">For example, a person does not know if the Drive folder exists or not.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Consider an example</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Now, we will try to alter the </span><kbd><span class="koboSpan" id="kobo.3.1">Student</span></kbd><span class="koboSpan" id="kobo.4.1"> class which was illustrated in the Composition lesson. </span><span class="koboSpan" id="kobo.4.2">I am doing it because we have an </span><kbd><span class="koboSpan" id="kobo.5.1">Address</span></kbd><span class="koboSpan" id="kobo.6.1"> property there. </span><span class="koboSpan" id="kobo.6.2">See how the constructor is updated to have the address as an argument:</span></p>
<pre><span class="koboSpan" id="kobo.7.1">    public Student(int id, string name, DateTime dob, Address address)
    {
        Id = id;
        Name = name;
        Dob = dob;
        Address = address;
    }</span></pre>
<p class="mce-root"><span><span class="koboSpan" id="kobo.8.1">This is not new to you. </span><span class="koboSpan" id="kobo.8.2">Let's try to elaborate it.</span></span><span class="koboSpan" id="kobo.9.1"> We are simply passing the </span><kbd><span class="koboSpan" id="kobo.10.1">Address</span></kbd><span class="koboSpan" id="kobo.11.1"> object into the constructor, which is then assigned to the </span><kbd><span class="koboSpan" id="kobo.12.1">Address</span></kbd><span class="koboSpan" id="kobo.13.1"> property of the composite class </span><kbd><span class="koboSpan" id="kobo.14.1">Student</span></kbd><span class="koboSpan" id="kobo.15.1">.</span></p>
<p><span class="koboSpan" id="kobo.16.1">The next confusion is what is the difference then? </span><span class="koboSpan" id="kobo.16.2">Let me explain. </span><span class="koboSpan" id="kobo.16.3">The </span><kbd><span class="koboSpan" id="kobo.17.1">Address</span></kbd><span class="koboSpan" id="kobo.18.1"> property is declared inside the composite class gets created/destroyed like other members. </span><span class="koboSpan" id="kobo.18.2">But inside the constructor, we are assigning an external </span><kbd><span class="koboSpan" id="kobo.19.1">Address</span></kbd><span class="koboSpan" id="kobo.20.1"> object to it. </span><span class="koboSpan" id="kobo.20.2">That means the composite class does not have any control over that incoming external object.</span></p>
<p><span class="koboSpan" id="kobo.21.1">The </span><kbd><span class="koboSpan" id="kobo.22.1">Student</span></kbd><span class="koboSpan" id="kobo.23.1"> class initialization will also be altered as follows:</span></p>
<pre><span class="koboSpan" id="kobo.24.1">    static void Main(string[] args)
    {
      Address add = new Address("Dhenkanal");
      Student pallu = new Student(1, "Pallavi Praharaj", </span><br/><span class="koboSpan" id="kobo.25.1">        new DateTime(1990, 6, 12), add);
    }</span></pre>
<p><span class="koboSpan" id="kobo.26.1">Let's analyze how this change can be considered as an Aggregation.</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.27.1">Rule 1: The part (member) is a component of the object (class)</span></strong><span class="koboSpan" id="kobo.28.1">: The </span><kbd><span class="koboSpan" id="kobo.29.1">Address</span></kbd><span class="koboSpan" id="kobo.30.1"> property is referenced inside the </span><kbd><span class="koboSpan" id="kobo.31.1">Student</span></kbd><span class="koboSpan" id="kobo.32.1"> class. </span><span class="koboSpan" id="kobo.32.2">Thus, it becomes a part.</span></li>
<li><strong><span class="koboSpan" id="kobo.33.1">Rule 2: The part (member) can belong to more than one object (class) at a time</span></strong><span class="koboSpan" id="kobo.34.1">: I passed an </span><kbd><span class="koboSpan" id="kobo.35.1">Address</span></kbd><span class="koboSpan" id="kobo.36.1"> object into the constructor, which is used inside the composite class, for further operation. </span><span class="koboSpan" id="kobo.36.2">However, the object </span><kbd><span class="koboSpan" id="kobo.37.1">add</span></kbd><span class="koboSpan" id="kobo.38.1"> is </span><span><span class="koboSpan" id="kobo.39.1">pretty much independent as it is created by the routine (</span></span><kbd><span class="koboSpan" id="kobo.40.1">Main</span></kbd><span><span class="koboSpan" id="kobo.41.1">, as shown in the preceding code). </span><span class="koboSpan" id="kobo.41.2">Let me allow it to be used by another </span><kbd><span class="koboSpan" id="kobo.42.1">Student</span></kbd><span class="koboSpan" id="kobo.43.1"> as well:</span></span></li>
</ul>
<pre><span class="koboSpan" id="kobo.44.1">        static void Main(string[] args)
        {
          Address add = new Address("Nayagarh");
          Student rinu = new Student(1, "Jayashree Satapathy", </span><br/><span class="koboSpan" id="kobo.45.1">            new DateTime(1995, 11, 14), add);    </span><br/><span class="koboSpan" id="kobo.46.1">          Student gudy = new Student(2, "Lipsa Rath", </span><br/><span class="koboSpan" id="kobo.47.1">            new DateTime(1995, 4, 23), add);</span><br/><br/><span class="koboSpan" id="kobo.48.1">         rinu.PrintStudent();</span><br/><span class="koboSpan" id="kobo.49.1">         gudy.PrintStudent();</span><br/><span class="koboSpan" id="kobo.50.1">         Console.ReadKey();
       }</span></pre>
<p><span class="koboSpan" id="kobo.51.1">I know you </span><span><span class="koboSpan" id="kobo.52.1">might have some reservations about whether this will work or not</span></span><span class="koboSpan" id="kobo.53.1">. </span><span class="koboSpan" id="kobo.53.2">Here is the output for you:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.54.1"><img height="109" width="365" src="assets/d96c6715-c721-4cfb-8a68-133bc34fff36.png"/></span></div>
<p><span class="koboSpan" id="kobo.55.1">Straightforward, isn't it! </span><span class="koboSpan" id="kobo.55.2">The </span><kbd><span class="koboSpan" id="kobo.56.1">Main</span></kbd><span class="koboSpan" id="kobo.57.1"> method is the creator, so it can be used inside the scope anywhere till it is destroyed by it or by Garbage Collector. </span><span class="koboSpan" id="kobo.57.2">The </span><kbd><span class="koboSpan" id="kobo.58.1">add</span></kbd><span class="koboSpan" id="kobo.59.1"> object is passed as a reference to both of the students. </span><span class="koboSpan" id="kobo.59.2">From these facts, we can infer that </span><span><kbd><span class="koboSpan" id="kobo.60.1">Jayashree</span></kbd><span class="koboSpan" id="kobo.61.1"> and</span></span> <kbd><span class="koboSpan" id="kobo.62.1">Lipsa</span></kbd><span class="koboSpan" id="kobo.63.1"> and are two students who stay at the same address.</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.64.1">Rule 3: The part (member) does not have its existence managed by the object (class)</span></strong><span class="koboSpan" id="kobo.65.1">: Since it is wrapped inside the </span><kbd><span class="koboSpan" id="kobo.66.1">Main</span></kbd> <span><span class="koboSpan" id="kobo.67.1">method, the composite object can't destroy it. </span><span class="koboSpan" id="kobo.67.2">By the way, it did not create it either. </span><span class="koboSpan" id="kobo.67.3">It was</span></span> <kbd><span class="koboSpan" id="kobo.68.1">Main</span></kbd> <span><span><span class="koboSpan" id="kobo.69.1">who gave birth to that.</span></span></span></li>
<li><strong><span class="koboSpan" id="kobo.70.1">Rule 4: The part (member) does not know about the existence of the object (class)</span></strong><span class="koboSpan" id="kobo.71.1">: The </span><kbd><span class="koboSpan" id="kobo.72.1">Address</span></kbd><span class="koboSpan" id="kobo.73.1"> object does not have any idea about these student objects. </span><span class="koboSpan" id="kobo.73.2">It is autonomous inside the </span><kbd><span class="koboSpan" id="kobo.74.1">Main</span></kbd><span class="koboSpan" id="kobo.75.1"> block.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Composition versus Aggregation</span></h1>
                </header>
            
            <article>
                
<p><span><span class="koboSpan" id="kobo.2.1">Now that we have explored both types of Object Composition, let's look at the differences:</span></span></p>
<table>
<tbody>
<tr>
<td>
<div><strong><span class="koboSpan" id="kobo.3.1">Composition</span></strong></div>
</td>
<td>
<div><strong><span class="koboSpan" id="kobo.4.1">Aggregation</span></strong></div>
</td>
</tr>
<tr>
<td>
<p><span class="koboSpan" id="kobo.5.1">Generally, contains built-in type member variables</span></p>
<p><span class="koboSpan" id="kobo.6.1">Manages member's creation and destruction</span></p>
</td>
<td>
<p><span class="koboSpan" id="kobo.7.1">Generally contains reference variables which live out of the scope of the composite class</span></p>
<p><span class="koboSpan" id="kobo.8.1">Does not manage member's creation and destruction</span></p>
</td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.9.1">While these concepts have such tiny but important differences, they can still be mixed up in a composite class. </span><span class="koboSpan" id="kobo.9.2">That means a </span><kbd><span class="koboSpan" id="kobo.10.1">Student</span></kbd><span class="koboSpan" id="kobo.11.1"> class having simple parts like </span><kbd><span class="koboSpan" id="kobo.12.1">Id</span></kbd><span class="koboSpan" id="kobo.13.1">, </span><kbd><span class="koboSpan" id="kobo.14.1">Name</span></kbd><span class="koboSpan" id="kobo.15.1">, </span><kbd><span class="koboSpan" id="kobo.16.1">Address</span></kbd><span class="koboSpan" id="kobo.17.1">, and so on as an Aggregation will be treated as a mix of both these concepts.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Advantages and disadvantages</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In case of Composition, you have the control to manage those members as you like. </span><span class="koboSpan" id="kobo.2.2">However, they are not independent and you can't use them in other places.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Whereas in Aggregation, there is no control of the member's life and if you forget to destroy the member after creation, it will be a culprit of memory leaks.</span></p>
<p><span class="koboSpan" id="kobo.4.1">While both of them have their own pros and cons, it is just a matter of deciding which one to use where, according to the scenario. </span><span class="koboSpan" id="kobo.4.2">Moreover, you can mix them up and do amazing things. </span><span class="koboSpan" id="kobo.4.3">For example, some properties like </span><kbd><span class="koboSpan" id="kobo.5.1">Id</span></kbd><span class="koboSpan" id="kobo.6.1">, </span><kbd><span class="koboSpan" id="kobo.7.1">Name</span></kbd><span class="koboSpan" id="kobo.8.1">, etc. </span><span class="koboSpan" id="kobo.8.2">are used exclusively inside the class, so ideally we won't reuse these properties anywhere in the application. </span><span class="koboSpan" id="kobo.8.3">Therefore, if you build another class with all these properties and reference (aggregate) in the first class, that becomes unnecessary because the other class has no such usage outside the first class.</span></p>
<p><span class="koboSpan" id="kobo.9.1">On the other hand, when you identify that some properties that can be packed up as a subclass (</span><kbd><span class="koboSpan" id="kobo.10.1">AddressId</span></kbd><span class="koboSpan" id="kobo.11.1">, </span><kbd><span class="koboSpan" id="kobo.12.1">Address</span></kbd><span class="koboSpan" id="kobo.13.1">, </span><kbd><span class="koboSpan" id="kobo.14.1">State</span></kbd><span class="koboSpan" id="kobo.15.1">, </span><kbd><span class="koboSpan" id="kobo.16.1">City</span></kbd><span class="koboSpan" id="kobo.17.1">, </span><kbd><span class="koboSpan" id="kobo.18.1">Country</span></kbd><span class="koboSpan" id="kobo.19.1">, and so on), you might have a requirement in future to refer to that new subclass somewhere in the code. </span><span class="koboSpan" id="kobo.19.2">Better to aggregate that. </span><span class="koboSpan" id="kobo.19.3">Let the caller manage its lifetime. </span><span class="koboSpan" id="kobo.19.4">Just get that into your composite class and use as required and forget it's management.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Other important relationships</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">There are a few other relationships which you should be aware of. </span><span class="koboSpan" id="kobo.2.2">Unless you know these, you won't be able to visualize how objects typically work with each other.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Association</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">So far we have completed two types of Object Composition, Composition, and Aggregation. </span><span class="koboSpan" id="kobo.2.2">Just to confirm that we are on the same page, Object Composition is used to package relationships into a complex object that is from one or more simpler objects (parts/members).</span></p>
<p><span class="koboSpan" id="kobo.3.1">Now, we'll take a look at a type of relationship between two otherwise unrelated objects, called an </span><strong><span class="koboSpan" id="kobo.4.1">Association</span></strong><span class="koboSpan" id="kobo.5.1">. </span><span class="koboSpan" id="kobo.5.2">An Association is a bonding between two unrelated objects and they must satisfy the following conditions:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.6.1">Object (member) associated is unrelated to the other object (class):</span></strong><span class="koboSpan" id="kobo.7.1"> Here the objects, which are going to be associated, are not related to the object. </span><span class="koboSpan" id="kobo.7.2">Rather than being a part of a complex object as in a composition or aggregation, it is totally independent in nature. </span><span class="koboSpan" id="kobo.7.3">For example, a </span><kbd><span class="koboSpan" id="kobo.8.1">Teacher</span></kbd><span class="koboSpan" id="kobo.9.1"> and </span><kbd><span class="koboSpan" id="kobo.10.1">Student</span></kbd><span class="koboSpan" id="kobo.11.1"> are two independent objects, but not contained in each other. </span><span class="koboSpan" id="kobo.11.2">These entities get associated with each other while in a class for lessons.</span></li>
<li><strong><span class="koboSpan" id="kobo.12.1">Object (member) associated can belong to more than one object (class) at a time:</span></strong><span class="koboSpan" id="kobo.13.1"> Like aggregation, the associated object can belong to multiple objects at the same time. </span><span class="koboSpan" id="kobo.13.2">For example, a </span><kbd><span class="koboSpan" id="kobo.14.1">Student</span></kbd><span class="koboSpan" id="kobo.15.1"> can be associated with many teachers and vice versa.</span></li>
<li><strong><span class="koboSpan" id="kobo.16.1">Object (member) associated does not have its existence managed by the other object (class)</span></strong><span class="koboSpan" id="kobo.17.1">: All aggregated objects are independent here. </span><span class="koboSpan" id="kobo.17.2">Everyone manages themselves. </span><span class="koboSpan" id="kobo.17.3">For example, neither </span><kbd><span class="koboSpan" id="kobo.18.1">Teacher</span></kbd><span class="koboSpan" id="kobo.19.1"> is going to decide what a </span><kbd><span class="koboSpan" id="kobo.20.1">Student</span></kbd><span class="koboSpan" id="kobo.21.1"> will do nor does the </span><kbd><span class="koboSpan" id="kobo.22.1">Student</span></kbd><span class="koboSpan" id="kobo.23.1"> decides what the actions of the </span><kbd><span class="koboSpan" id="kobo.24.1">Teacher</span></kbd><span class="koboSpan" id="kobo.25.1"> should be.</span></li>
<li><strong><span class="koboSpan" id="kobo.26.1">Object (member) associated may or may not know about the existence of the object (class)</span></strong><span class="koboSpan" id="kobo.27.1">: Association relationships might be unidirectional or bidirectional. </span><span class="koboSpan" id="kobo.27.2">That means the two associated objects may or may not know each other. </span><span class="koboSpan" id="kobo.27.3">We will get more clarification on this once we see the code snippet. </span><span class="koboSpan" id="kobo.27.4">For example, a </span><kbd><span class="koboSpan" id="kobo.28.1">Student</span></kbd><span class="koboSpan" id="kobo.29.1"> may or may not recognize a </span><kbd><span class="koboSpan" id="kobo.30.1">Teacher</span></kbd><span class="koboSpan" id="kobo.31.1">.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.32.1">Association can be defined as </span><em><span class="koboSpan" id="kobo.33.1">uses...a</span></em><span class="koboSpan" id="kobo.34.1"> relationship. </span><span class="koboSpan" id="kobo.34.2">The </span><kbd><span class="koboSpan" id="kobo.35.1">Teacher</span></kbd> <em><span class="koboSpan" id="kobo.36.1">uses</span></em><span class="koboSpan" id="kobo.37.1"> the </span><kbd><span class="koboSpan" id="kobo.38.1">Student</span></kbd><span class="koboSpan" id="kobo.39.1"> to teach the lessons. </span><span class="koboSpan" id="kobo.39.2">The </span><kbd><span class="koboSpan" id="kobo.40.1">Student</span></kbd><span class="koboSpan" id="kobo.41.1"> uses the </span><kbd><span class="koboSpan" id="kobo.42.1">Teacher</span></kbd><span class="koboSpan" id="kobo.43.1"> to clarify doubts.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Example</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's take an example of a cricket player and bat. </span><span class="koboSpan" id="kobo.2.2">Consider the following:</span></p>
<pre><span class="koboSpan" id="kobo.3.1">    public class CricketPlayer
    {
      public string PlayerName { get; set; }

      public CricketPlayer(string name)
      {
        PlayerName = name;
      }

      public void Play(Bat bat)
      {
        bat.StartPlay(this);
      }

      public string GetPlayerName()
      {
        return PlayerName;
      }
    }

    public class Bat
    {
      public string BrandName { get; set; }

      public void StartPlay(CricketPlayer player)
      {
        // Do something with the player.
        </span><span class="koboSpan" id="kobo.3.2">Console.WriteLine("Player Named as " + player.PlayerName</span><br/><span class="koboSpan" id="kobo.4.1">           + " is playing.");
        Console.ReadLine();
      }

      public string GetBrandName()
      {
        return "Some Brand Name";
      }
    }</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Explanation of the preceding code</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We have two different classes, </span><kbd><span class="koboSpan" id="kobo.3.1">CricketPlayer</span></kbd><span class="koboSpan" id="kobo.4.1"> and </span><kbd><span class="koboSpan" id="kobo.5.1">Bat</span></kbd><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">Now let me create the objects as follows:</span></p>
<pre><span class="koboSpan" id="kobo.7.1">    var cPlayer = new CricketPlayer("Hardik Pandya");
    Bat bat = new Bat();

    cPlayer.Play(bat);
    bat.StartPlay(cPlayer);</span></pre>
<p><span class="koboSpan" id="kobo.8.1">The output is as shown in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.9.1"><img height="83" width="404" src="assets/366514c2-bb00-4a94-9786-07d076c94e2b.png"/></span></div>
<p><span class="koboSpan" id="kobo.10.1">The methods </span><kbd><span class="koboSpan" id="kobo.11.1">Play</span></kbd><span class="koboSpan" id="kobo.12.1"> inside the </span><kbd><span class="koboSpan" id="kobo.13.1">CricketPlayer</span></kbd><span class="koboSpan" id="kobo.14.1"> class and </span><kbd><span class="koboSpan" id="kobo.15.1">StartPlay</span></kbd><span class="koboSpan" id="kobo.16.1"> inside the </span><kbd><span class="koboSpan" id="kobo.17.1">Bat</span></kbd><span class="koboSpan" id="kobo.18.1"> class are the ones, which you should be concentrating on at this point. </span><span class="koboSpan" id="kobo.18.2">Both are taking a reference param pointing to the other class's object. </span><span class="koboSpan" id="kobo.18.3">The whole point of this type of relationship between the player and bat is the common cause of starting t0 play.</span></p>
<p><span><span class="koboSpan" id="kobo.19.1">Let's look at the rules which this relationship follows.</span></span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.20.1">Rule 1: Object (member) associated is unrelated to the other object (class)</span></strong><span class="koboSpan" id="kobo.21.1">: Neither the bat relates to the player nor the player relates to the bat. </span><span class="koboSpan" id="kobo.21.2">But we will gradually see how they get associated.</span></li>
<li><strong><span class="koboSpan" id="kobo.22.1">Rule 2: Object (member) associated can belong to more than one object (class) at a time:</span></strong><span class="koboSpan" id="kobo.23.1"> The bat can be used by many other players in the team, not just by one.</span></li>
<li><strong><span class="koboSpan" id="kobo.24.1">Rule 3: Object (member) associated does not have its existence managed by the other object (class)</span></strong><span class="koboSpan" id="kobo.25.1">: The player is not responsible for managing the bat. </span><span class="koboSpan" id="kobo.25.2">It is created even before the player comes to the team. </span><span class="koboSpan" id="kobo.25.3">Likewise, the bat is not going to give birth to or be the cause of death of a player unless the player hits himself with the bat, which is not going to happen.</span></li>
<li><strong><span class="koboSpan" id="kobo.26.1">Rule 4: Object (member) associated may or may not know about the existence of the object (class)</span></strong><span class="koboSpan" id="kobo.27.1">: The player knows about the bat as the bat is passed as an argument in the </span><kbd><span class="koboSpan" id="kobo.28.1">Play</span></kbd><span class="koboSpan" id="kobo.29.1"> method. </span><span class="koboSpan" id="kobo.29.2">Similarly, the bat knows about the player as that got passed to the </span><kbd><span class="koboSpan" id="kobo.30.1">StartPlay</span></kbd><span class="koboSpan" id="kobo.31.1"> method.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.32.1">If you understand cricket a little bit, you must know that a player uses a bat to bat. </span><span class="koboSpan" id="kobo.32.2">That means it depends on the bat object. </span><span class="koboSpan" id="kobo.32.3">The bat object, however, can be used by any batsman in the team, which leads to a </span><kbd><span class="koboSpan" id="kobo.33.1">StartPlay</span></kbd><span class="koboSpan" id="kobo.34.1"> method in the </span><kbd><span class="koboSpan" id="kobo.35.1">Bat</span></kbd><span class="koboSpan" id="kobo.36.1"> class. </span><span class="koboSpan" id="kobo.36.2">Obviously, the bat object needs to get associated with a player, which eventually commences the game.</span></p>
<p><span class="koboSpan" id="kobo.37.1">Both of the objects depend on each other in order to start the game. </span><span class="koboSpan" id="kobo.37.2">They still exist as independent objects. </span><span class="koboSpan" id="kobo.37.3">Suppose, you don't call the </span><kbd><span class="koboSpan" id="kobo.38.1">Play</span></kbd><span class="koboSpan" id="kobo.39.1"> and </span><kbd><span class="koboSpan" id="kobo.40.1">StartPlay</span></kbd><span class="koboSpan" id="kobo.41.1"> method, nothing will change. </span><span class="koboSpan" id="kobo.41.2">The code will compile. </span><span class="koboSpan" id="kobo.41.3">That defines the association with each other for a common cause:</span></p>
<pre><span class="koboSpan" id="kobo.42.1">    CricketPlayer cPlayer = new CricketPlayer("Hardik Pandya");
    Bat bat = new Bat();

    //cPlayer.Play(bat);
    //bat.StartPlay(cPlayer);
</span><br/><span class="koboSpan" id="kobo.43.1">    Console.WriteLine($"Name of the Player is: { </span><br/><span class="koboSpan" id="kobo.44.1">        cPlayer.GetPlayerName() }");</span><br/><span class="koboSpan" id="kobo.45.1">    Console.WriteLine($"Brand of Bat is: { bat.GetBrandName() }");</span></pre>
<p><span class="koboSpan" id="kobo.46.1">Here, I just commented out codes for play. </span><span class="koboSpan" id="kobo.46.2">That did not have any impact on the objects and they still exist. </span><span class="koboSpan" id="kobo.46.3">Then I used them to call other methods like </span><kbd><span class="koboSpan" id="kobo.47.1">GetPlayerName</span></kbd><span class="koboSpan" id="kobo.48.1"> and </span><kbd><span class="koboSpan" id="kobo.49.1">GetBrandName</span></kbd><span class="koboSpan" id="kobo.50.1">.</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.51.1"><img height="88" width="424" src="assets/788af1ce-221c-4b96-8f6e-9ff2a7beb171.png"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Types of Association</span></h1>
                </header>
            
            <article>
                
<p><span><span class="koboSpan" id="kobo.2.1">We have learned a bit about Association. </span><span class="koboSpan" id="kobo.2.2">However, there are different types and it would be handy for us to know about them.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Reflexive Association</span></h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="koboSpan" id="kobo.2.1">When two objects of the same type get associated, that association is called as </span><strong><span class="koboSpan" id="kobo.3.1">Reflexive Association</span></strong><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">Let's consider the class </span><kbd><span class="koboSpan" id="kobo.5.1">Medicine</span></kbd><span class="koboSpan" id="kobo.6.1">:</span></p>
<pre><span class="koboSpan" id="kobo.7.1">    public class Medicine
    {
      public string Name { get; set; }
      public Medicine AlternateMedicine { get; set; }

      public Medicine(string name, Medicine altMedicine)
      {
        Name = name;
        AlternateMedicine = altMedicine;
      }   
    }</span></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.8.1">This is very useful in many scenarios when we have dependencies of the same entity. </span><span class="koboSpan" id="kobo.8.2">We know that a medicine might have one alternate medicine, which again might have another alternate and so on.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Indirect Association</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Association, when formed by other means and not directly between two objects, is called an </span><strong><span class="koboSpan" id="kobo.3.1">Indirect Association</span></strong><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">We will try to grasp this concept with the help of the following example:</span></p>
<pre><span class="koboSpan" id="kobo.5.1">    public class SoftwareEngineer
    {
        public string Name { get; set; }
        public int LaptopId { get; set; }

        public SoftwareEngineer(string name, int laptopId)
        {
                Name = name;
                LaptopId = laptopId;
        }
     }

     public class Laptop
     {
        public int LaptopId { get; set; }
        public string LaptopName { get; set; }

        public Laptop(int id, string name)
        {
           LaptopId = id;
           LaptopName = name;
        }
      }

      public class AvailableLaptops
      {
        public static List&lt;Laptop&gt; Laptops { get; set; }
        static AvailableLaptops()
        {
          Laptops = new List&lt;Laptop&gt;
          {
            new Laptop(1, "Laptop1"),
            new Laptop(2, "Laptop2"),
            new Laptop(3, "Laptop3"),
            new Laptop(4, "Laptop4"),
          };
        }

        public static Laptop GetLaptop(int id)
        {
          return Laptops.Find(l =&gt; l.LaptopId == id);
        }
      }
      static void Main(string[] args)
      {
        SoftwareEngineer softEng = new SoftwareEngineer("Tworit Dash", 3);
        // Get the Laptop object from AvailableLaptops class by id.
        </span><span class="koboSpan" id="kobo.5.2">Laptop usedLaptop = AvailableLaptops.GetLaptop(3);
        Console.WriteLine(softEng.Name + " is using " + </span><br/><span class="koboSpan" id="kobo.6.1">          usedLaptop.LaptopName);
        Console.ReadLine();
      }</span></pre>
<p><span class="koboSpan" id="kobo.7.1">We have two classes named </span><kbd><span class="koboSpan" id="kobo.8.1">SoftwareEngineer</span></kbd><span class="koboSpan" id="kobo.9.1"> and </span><kbd><span class="koboSpan" id="kobo.10.1">Laptop</span></kbd><span class="koboSpan" id="kobo.11.1"> which are meant to be associated with each other. </span><span class="koboSpan" id="kobo.11.2">In this case, we are trying to relate them indirectly via a static class </span><kbd><span class="koboSpan" id="kobo.12.1">AvailableLaptops</span></kbd><span class="koboSpan" id="kobo.13.1"> which has a list of </span><kbd><span class="koboSpan" id="kobo.14.1">Laptop</span></kbd><span class="koboSpan" id="kobo.15.1"> objects containing their </span><kbd><span class="koboSpan" id="kobo.16.1">Id</span></kbd><span class="koboSpan" id="kobo.17.1"> and </span><kbd><span class="koboSpan" id="kobo.18.1">Name</span></kbd><span class="koboSpan" id="kobo.19.1">.</span></p>
<p><span class="koboSpan" id="kobo.20.1">Let's focus on the </span><kbd><span class="koboSpan" id="kobo.21.1">Main</span></kbd><span class="koboSpan" id="kobo.22.1"> method now. </span><span class="koboSpan" id="kobo.22.2">A </span><kbd><span class="koboSpan" id="kobo.23.1">SoftwareEngineer</span></kbd><span class="koboSpan" id="kobo.24.1"> is instantiated (</span><kbd><span class="koboSpan" id="kobo.25.1">Name Tworit Dash</span></kbd><span class="koboSpan" id="kobo.26.1"> with a </span><kbd><span class="koboSpan" id="kobo.27.1">LaptopId 3</span></kbd><span class="koboSpan" id="kobo.28.1">). </span><span class="koboSpan" id="kobo.28.2">We need to print his name and the laptop name he is using. </span><span class="koboSpan" id="kobo.28.3">We have the </span><kbd><span class="koboSpan" id="kobo.29.1">LaptopId</span></kbd><span class="koboSpan" id="kobo.30.1">. </span><span class="koboSpan" id="kobo.30.2">If you closely look at the </span><kbd><span class="koboSpan" id="kobo.31.1">AvailableLaptops</span></kbd><span class="koboSpan" id="kobo.32.1"> class, there is a static method </span><kbd><span class="koboSpan" id="kobo.33.1">GetLaptop</span></kbd><span class="koboSpan" id="kobo.34.1"> which takes </span><kbd><span class="koboSpan" id="kobo.35.1">laptopId</span></kbd><span class="koboSpan" id="kobo.36.1"> as an argument and then finds the laptop from the list it already has.</span></p>
<p><span class="koboSpan" id="kobo.37.1">So, </span><kbd><span class="koboSpan" id="kobo.38.1">Laptop usedLaptop = AvailableLaptops.GetLaptop(3);</span></kbd><span class="koboSpan" id="kobo.39.1"> would get us the required </span><kbd><span class="koboSpan" id="kobo.40.1">Laptop</span></kbd><span class="koboSpan" id="kobo.41.1"> object which has ID </span><kbd><span class="koboSpan" id="kobo.42.1">3</span></kbd><span class="koboSpan" id="kobo.43.1"> and </span><kbd><span class="koboSpan" id="kobo.44.1">Name Laptop3</span></kbd><span class="koboSpan" id="kobo.45.1">. </span><span class="koboSpan" id="kobo.45.2">Now, it is just a matter of printing the engineer's name and the name of the laptop returned by the static class:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.46.1"><img height="85" width="377" src="assets/234d4192-1dbf-46a9-aca4-3b138a01321d.png"/></span></div>
<p><span class="koboSpan" id="kobo.47.1">This is called </span><strong><span class="koboSpan" id="kobo.48.1">Indirect Association</span></strong><span class="koboSpan" id="kobo.49.1"> because the association is established with the help of another class which can interact with a class and returns the results to another class requesting any data from the first class.</span></p>
<p><span class="koboSpan" id="kobo.50.1">To summarise the relationships, let's do a quick recap.</span></p>
<p><strong><span class="koboSpan" id="kobo.51.1">Composition:</span></strong></p>
<ul>
<li><span class="koboSpan" id="kobo.52.1">Part of a complex class.</span></li>
<li><span class="koboSpan" id="kobo.53.1">Members can't be a part of multiple classes.</span></li>
<li><span class="koboSpan" id="kobo.54.1">Members are created and destroyed by a complex class.</span></li>
<li><span class="koboSpan" id="kobo.55.1">Unidirectional: Members do not know about the complex object.</span></li>
<li><em><span class="koboSpan" id="kobo.56.1">A part of</span></em><span class="koboSpan" id="kobo.57.1"> relationship</span></li>
</ul>
<p><strong><span class="koboSpan" id="kobo.58.1">Aggregation:</span></strong></p>
<ul>
<li><span class="koboSpan" id="kobo.59.1">Part of a complex class</span></li>
<li><span class="koboSpan" id="kobo.60.1">Members can be a part of multiple classes</span></li>
<li><span class="koboSpan" id="kobo.61.1">Member</span><span><span class="koboSpan" id="kobo.62.1">s are</span></span><span class="koboSpan" id="kobo.63.1"> neither created nor destroyed by a complex class</span></li>
<li><span class="koboSpan" id="kobo.64.1">Unidirectional: Members do not know about the complex object</span></li>
<li><em><span class="koboSpan" id="kobo.65.1">Has a</span></em><span class="koboSpan" id="kobo.66.1"> relationship</span></li>
</ul>
<p><strong><span class="koboSpan" id="kobo.67.1">Association:</span></strong></p>
<ul>
<li><span class="koboSpan" id="kobo.68.1">Classes are not related but require each other when needed</span></li>
<li><span class="koboSpan" id="kobo.69.1">Associated members or objects can be used by multiple objects</span></li>
<li><span class="koboSpan" id="kobo.70.1">Members are neither created or destroyed by a complex class</span></li>
<li><span class="koboSpan" id="kobo.71.1">Unidirectional or Bidirectional: Objects may or may not know each other</span></li>
<li><em><span class="koboSpan" id="kobo.72.1">Uses a</span></em><span class="koboSpan" id="kobo.73.1"> relationship</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Composition over Inheritance</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">This topic is very interesting and is discussed online in many websites and blogs. </span><span class="koboSpan" id="kobo.2.2">As the topic headline says </span><strong><span class="koboSpan" id="kobo.3.1">Composition is preferred over Inheritance</span></strong><span class="koboSpan" id="kobo.4.1">, we need to understand why it is so important by identifying the problems. </span><span class="koboSpan" id="kobo.4.2">The better the design from the beginning of your software development, the better the maintainability and reuse.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Inheritance and Composition are two pillars of OOPs concepts. </span><span class="koboSpan" id="kobo.5.2">Unless they are used wisely according to your architecture, they will create problems in the future when you start adding complexity to your application.</span></p>
<p><span class="koboSpan" id="kobo.6.1">We have already discussed Composition, now, let's discuss Inheritance before we move towards the main topic of discussion.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Inheritance</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As the name suggests, the act of acquiring or deriving some behavior from someone is called </span><strong><span class="koboSpan" id="kobo.3.1">Inheritance</span></strong><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">In the programming world, when a certain class is inherited from another class, it creates an Inheritance. </span><span class="koboSpan" id="kobo.4.3">Some basic examples are written as follows:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.5.1">A car </span><em><span class="koboSpan" id="kobo.6.1">is a</span></em><span class="koboSpan" id="kobo.7.1"> vehicle. </span><span class="koboSpan" id="kobo.7.2">The vehicle has a certain behavior which the car acquires when it is built.</span></li>
<li><span class="koboSpan" id="kobo.8.1">A rectangle </span><em><span class="koboSpan" id="kobo.9.1">is a</span></em><span class="koboSpan" id="kobo.10.1"> shape.</span></li>
<li><span class="koboSpan" id="kobo.11.1">An </span><kbd><span><span class="koboSpan" id="kobo.12.1">HourlyEmployee</span></span></kbd> <em><span class="koboSpan" id="kobo.13.1">is an</span></em><span class="koboSpan" id="kobo.14.1"> employee. </span><span class="koboSpan" id="kobo.14.2">A </span><kbd><span><span class="koboSpan" id="kobo.15.1">MonthlyEmployee</span></span></kbd> <em><span class="koboSpan" id="kobo.16.1">is an</span></em><span class="koboSpan" id="kobo.17.1"> employee too.</span></li>
<li><span class="koboSpan" id="kobo.18.1">Chicken curry </span><em><span class="koboSpan" id="kobo.19.1">is a</span></em><span class="koboSpan" id="kobo.20.1"> dish.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.21.1">Notice, they all have something in common. </span><span class="koboSpan" id="kobo.21.2">That is the phrase </span><em><span class="koboSpan" id="kobo.22.1">is a</span></em><span class="koboSpan" id="kobo.23.1">. </span><span class="koboSpan" id="kobo.23.2">Inheritance is defined as an </span><em><span class="koboSpan" id="kobo.24.1">is a</span></em><span class="koboSpan" id="kobo.25.1"> relationship.</span></p>
<p><span class="koboSpan" id="kobo.26.1">The car is a vehicle, but it might have a music system as well, which is not a common behavior of a vehicle. </span><span class="koboSpan" id="kobo.26.2">Thus, the derived or child classes can have their own behavior as well. </span><kbd><span class="koboSpan" id="kobo.27.1">HourlyEmployee</span></kbd><span class="koboSpan" id="kobo.28.1"> and </span><kbd><span class="koboSpan" id="kobo.29.1">MonthlyEmployee</span></kbd><span class="koboSpan" id="kobo.30.1"> are employees of a certain company who share many benefits from the company. </span><span class="koboSpan" id="kobo.30.2">However, their salary is not the same.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Example on User class</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's see how we can implement Inheritance.</span></p>
<pre><span class="koboSpan" id="kobo.3.1">    public abstract class User
    {
        public int Id { get; set; }
        public int RoleId { get; set; }
        public string Name { get; set; }
        public string EmailId { get; set; }
        public string MobileNumber { get; set; }

        public int SaveUser(int userId)
        {
           // Database operation to save the user.
           </span><span class="koboSpan" id="kobo.3.2">return userId;
        }
      }

      public class Admin : User
      {
        public string CompanyDepartment { get; set; }
        public Admin()
        {
          RoleId = 1;
        }
      }

      public class Manager : User
      {
        public List&lt;TeamLead&gt; TeamLeads { get; set; }
        public Manager()
        {
          RoleId = 2;
        }
      }

      public class TeamLead : User
      {
        public List&lt;string&gt; Projects { get; set; }
        public TeamLead()
        {
          RoleId = 3;
        }
      }</span></pre>
<p><span class="koboSpan" id="kobo.4.1">We have different types of users in our company such as </span><kbd><span class="koboSpan" id="kobo.5.1">Admin</span></kbd><span class="koboSpan" id="kobo.6.1">, </span><kbd><span class="koboSpan" id="kobo.7.1">Manager</span></kbd><span class="koboSpan" id="kobo.8.1">, </span><kbd><span class="koboSpan" id="kobo.9.1">TeamLeads</span></kbd><span class="koboSpan" id="kobo.10.1">, </span><kbd><span class="koboSpan" id="kobo.11.1">HR</span></kbd><span class="koboSpan" id="kobo.12.1">, and more. </span><span class="koboSpan" id="kobo.12.2">Although these entities are different, they have some properties in common. </span><span class="koboSpan" id="kobo.12.3">They must have an </span><kbd><span class="koboSpan" id="kobo.13.1">Id</span></kbd><span class="koboSpan" id="kobo.14.1">, </span><kbd><span class="koboSpan" id="kobo.15.1">RoleId</span></kbd><span class="koboSpan" id="kobo.16.1">, </span><kbd><span class="koboSpan" id="kobo.17.1">Name</span></kbd><span class="koboSpan" id="kobo.18.1">, </span><kbd><span class="koboSpan" id="kobo.19.1">EmailId</span></kbd><span class="koboSpan" id="kobo.20.1">, </span><kbd><span class="koboSpan" id="kobo.21.1">MobileNumber</span></kbd><span class="koboSpan" id="kobo.22.1">, and so on.</span></p>
<p><span class="koboSpan" id="kobo.23.1">As they have common properties and behavior we make an abstract base class </span><kbd><span class="koboSpan" id="kobo.24.1">User</span></kbd><span class="koboSpan" id="kobo.25.1"> which has all those declared inside it. </span><span class="koboSpan" id="kobo.25.2">We won't be instantiating this class, so it is restricted by using an abstract keyword. </span><span class="koboSpan" id="kobo.25.3">Every type of user is going to have some operation. </span><span class="koboSpan" id="kobo.25.4">The simplest operation is </span><kbd><span class="koboSpan" id="kobo.26.1">SaveUser()</span></kbd><span class="koboSpan" id="kobo.27.1">, which is defined inside the base class so that it will be available for all child classes.</span></p>
<p><span class="koboSpan" id="kobo.28.1">In this example, we have different properties declared inside child classes as well.</span></p>
<p><span class="koboSpan" id="kobo.29.1">Consider the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.30.1">Admin--</span><kbd><span class="koboSpan" id="kobo.31.1">public string CompanyDepartment { get; set; }</span></kbd></li>
<li><span class="koboSpan" id="kobo.32.1">Manager--</span><kbd><span class="koboSpan" id="kobo.33.1">public List&lt;TeamLead&gt; TeamLeads { get; set; }</span></kbd></li>
<li><span class="koboSpan" id="kobo.34.1">TeamLead--</span><kbd><span class="koboSpan" id="kobo.35.1">public List&lt;string&gt; Projects { get; set; }</span></kbd></li>
</ul>
<p><span class="koboSpan" id="kobo.36.1">We can also define different methods specific to them inside these child classes. </span><span class="koboSpan" id="kobo.36.2">When we try to create objects, or in other words, create an </span><kbd><span class="koboSpan" id="kobo.37.1">Admin</span></kbd><span class="koboSpan" id="kobo.38.1"> and </span><kbd><span class="koboSpan" id="kobo.39.1">Manager</span></kbd><span class="koboSpan" id="kobo.40.1">, it will look something like as follows:</span></p>
<pre><span class="koboSpan" id="kobo.41.1">    static void Main(string[] args)
    {
        Admin admin = new Admin()
        {
          Id = 12
        };
        admin.SaveUser(admin.Id);

        Manager manager = new Manager
        {
          Id = 13
        };
        manager.SaveUser(manager.Id);
         Console.WriteLine("Admin (Role Id: {0}) with UserId {1} </span><br/><span class="koboSpan" id="kobo.42.1">            is saved", admin.RoleId, admin.Id);
        Console.WriteLine("Manager (Role Id: {0}) with UserId {1}</span><br/><span class="koboSpan" id="kobo.43.1">            is saved", manager.RoleId, manager.Id);
    }</span></pre>
<p><span class="koboSpan" id="kobo.44.1">You can see we are creating each type of user and then sending their IDs to the save method for further database processing. </span><kbd><span class="koboSpan" id="kobo.45.1">RoleId</span></kbd><span class="koboSpan" id="kobo.46.1"> is assigned inside the constructors of each type of </span><kbd><span class="koboSpan" id="kobo.47.1">User</span></kbd><span class="koboSpan" id="kobo.48.1"> class. </span><span class="koboSpan" id="kobo.48.2">This produces output as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.49.1"><img height="86" width="440" src="assets/095ed841-57ce-4638-903f-e14c08a99c8b.png"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">New User Type</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The company decides to have a new type of employee named  Delivery Manager, who will be having certain privileges, but not all. </span><span class="koboSpan" id="kobo.2.2">This role will take partial responsibilities from </span><kbd><span class="koboSpan" id="kobo.3.1">Manager</span></kbd><span class="koboSpan" id="kobo.4.1"> as well as from </span><kbd><span class="koboSpan" id="kobo.5.1">TeamLead</span></kbd><span class="koboSpan" id="kobo.6.1">.</span></p>
<p><span class="koboSpan" id="kobo.7.1">A Delivery Manager can </span><kbd><span class="koboSpan" id="kobo.8.1">CreateProject</span></kbd><span class="koboSpan" id="kobo.9.1"> (like a TeamLead) and  ;</span><kbd><span class="koboSpan" id="kobo.10.1">AssignProjectToTeamLead</span></kbd><span class="koboSpan" id="kobo.11.1"> (like a </span><kbd><span class="koboSpan" id="kobo.12.1">Manager</span></kbd><span class="koboSpan" id="kobo.13.1">). </span><span class="koboSpan" id="kobo.13.2">Also while doing all these, he/she can </span><kbd><span class="koboSpan" id="kobo.14.1">SendNotificationToCto</span></kbd><span class="koboSpan" id="kobo.15.1"> which is a new method. </span><span class="koboSpan" id="kobo.15.2">So, those two methods will have additional codes which are not an exact copy from the  </span><kbd><span class="koboSpan" id="kobo.16.1">Manager</span></kbd><span class="koboSpan" id="kobo.17.1"> and </span><kbd><span class="koboSpan" id="kobo.18.1">TeamLead</span></kbd><span class="koboSpan" id="kobo.19.1"> classes:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.20.1"><img height="125" width="496" src="assets/e6bad7a4-a498-4945-95b5-7839807fdeef.png"/></span></div>
<div class="packt_infobox"><strong><span class="koboSpan" id="kobo.21.1">Multiple Inheritance</span></strong><span class="koboSpan" id="kobo.22.1"> is a language-specific feature which enables a class to inherit features of more than one parent class. </span><span class="koboSpan" id="kobo.22.2">This feature can introduce complexities in the design and the supported languages have their own way of handling such scenarios. </span><span class="koboSpan" id="kobo.22.3">C#, Java, Swift etc. </span><span class="koboSpan" id="kobo.22.4">does not support Multiple Inheritance, but they allow implementing multiple protocols which are named </span><strong><span class="koboSpan" id="kobo.23.1">Interfaces</span></strong><span class="koboSpan" id="kobo.24.1">. </span><span class="koboSpan" id="kobo.24.2">I just wanted to show you that we have to go with some alternative approach to solve the problem in hand instead of inheriting from multiple classes as shown above, which is anyway not supported by C#.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Problem which we come across</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Visual Studio complains to me that I can't code like this, which is actually termed Multiple Inheritance. </span><span class="koboSpan" id="kobo.2.2">Moreover, when a company introduces more roles, the system gets complex to manage when we have responsibilities (methods) defined in each class. </span><span class="koboSpan" id="kobo.2.3">Because when we have to mix responsibilities for a certain user role, we will have to create duplicate codes that would have been already written in some class.</span></p>
<p><span class="koboSpan" id="kobo.3.1">To explain what I'm saying, imagine a </span><kbd><span class="koboSpan" id="kobo.4.1">Car</span></kbd><span class="koboSpan" id="kobo.5.1"> class, which gets inherited by classes like </span><kbd><span class="koboSpan" id="kobo.6.1">Toyota</span></kbd><span class="koboSpan" id="kobo.7.1">, </span><kbd><span class="koboSpan" id="kobo.8.1">BMW</span></kbd><span class="koboSpan" id="kobo.9.1">, </span><kbd><span class="koboSpan" id="kobo.10.1">Volkswagen</span></kbd><span class="koboSpan" id="kobo.11.1">, and more. </span><span class="koboSpan" id="kobo.11.2">For some reason, I got mad and brought both </span><kbd><span class="koboSpan" id="kobo.12.1">Toyota</span></kbd><span class="koboSpan" id="kobo.13.1"> and </span><kbd><span class="koboSpan" id="kobo.14.1">Volkswagen</span></kbd><span class="koboSpan" id="kobo.15.1"> to my workshop and then built a new brand out of them. </span><span class="koboSpan" id="kobo.15.2">I will name it </span><span class="packt_screen"><span class="koboSpan" id="kobo.16.1">VolksTaditToy</span></span><span class="koboSpan" id="kobo.17.1">. </span><span class="koboSpan" id="kobo.17.2">Please don't kill me for this name.</span></p>
<p><span class="packt_screen"><span class="koboSpan" id="kobo.18.1">VolksTaditToy</span></span><span class="koboSpan" id="kobo.19.1"> now has a combination of functions from both of these cars. </span><span class="koboSpan" id="kobo.19.2">But there is no way to deal with them in my program. </span><span class="koboSpan" id="kobo.19.3">Don't be so surprised, if you see more of such cars on the road because there is no scarcity of such fools in this world. </span><span class="koboSpan" id="kobo.19.4">Gradually your program will be in a situation where there is no escape.</span></p>
<p><span class="koboSpan" id="kobo.20.1">How can we write this class with the concept of inheritance? </span><span class="koboSpan" id="kobo.20.2">Impossible right! </span><span class="koboSpan" id="kobo.20.3">Let's make that possible for our initial </span><kbd><span class="koboSpan" id="kobo.21.1">User</span></kbd><span class="koboSpan" id="kobo.22.1"> problem.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The solution to the problem</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The composition is our savior here. </span><span class="koboSpan" id="kobo.2.2">Let's see how we can solve this problem using this relationship. </span><span class="koboSpan" id="kobo.2.3">We will introduce a </span><kbd><span class="koboSpan" id="kobo.3.1">Role</span></kbd><span class="koboSpan" id="kobo.4.1"> class. </span><span class="koboSpan" id="kobo.4.2">Obvious right! </span><kbd><span class="koboSpan" id="kobo.5.1">Manager</span></kbd><span class="koboSpan" id="kobo.6.1">, </span><kbd><span class="koboSpan" id="kobo.7.1">TeamLead</span></kbd><span class="koboSpan" id="kobo.8.1">, and </span><kbd><span class="koboSpan" id="kobo.9.1">DeliveryManager</span></kbd><span class="koboSpan" id="kobo.10.1"> are different roles played by employees:</span></p>
<pre><span class="koboSpan" id="kobo.11.1">    public class Role
    {
        public int RoleId { get; set; }
        public string RoleName { get; set; }
    }</span></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.12.1">Now every other user type class will derive from this class:</span></p>
<pre><span class="koboSpan" id="kobo.13.1">    public class Admin : Role
    {
        public string CompanyDepartment { get; set; }
        public Admin()
        {
          RoleId = 1;
        }
    }

    public class Manager : Role
    {
        public List&lt;TeamLead&gt; TeamLeads { get; set; }
        public Manager()
        {
          RoleId = 2;
        }
    }
    public class TeamLead : Role
    {
        public List&lt;string&gt; Projects { get; set; }
        public TeamLead()
        {
          RoleId = 3;
        }
    }
    public class DeliveryHead : Role
    {
       public DeliveryHead()
        {
          RoleId = 4;
        }
    }</span></pre>
<p><span class="koboSpan" id="kobo.14.1">Alright, what is the next step? </span><span class="koboSpan" id="kobo.14.2">The remaining class is </span><kbd><span class="koboSpan" id="kobo.15.1">User</span></kbd><span class="koboSpan" id="kobo.16.1">. </span><span class="koboSpan" id="kobo.16.2">We need to do a couple of modifications in that, shown as follows:</span></p>
<pre><span class="koboSpan" id="kobo.17.1">    public class User
    {
        public int Id { get; set; }
        public List&lt;Role&gt; RoleIds { get; set; }
        public string Name { get; set; }
        public string EmailId { get; set; }
        public string MobileNumber { get; set; }

        public int SaveUser(int userId)
        {
           // Database operation to save the user.
           </span><span class="koboSpan" id="kobo.17.2">return userId;
        }
    }</span></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.18.1">The first modification is to remove the abstract keyword because we will now create objects of this class. </span><span class="koboSpan" id="kobo.18.2">Next is to have a property </span><kbd><span class="koboSpan" id="kobo.19.1">public List&lt;Role&gt; RoleIds { get; set; }</span></kbd><span class="koboSpan" id="kobo.20.1"> instead of </span><kbd><span class="koboSpan" id="kobo.21.1">public int RoleId { get; set; }</span></kbd><span class="koboSpan" id="kobo.22.1">. </span><span class="koboSpan" id="kobo.22.2">We did this to allow assigning multiple roles to a user/employee.</span></p>
<p><span class="koboSpan" id="kobo.23.1">Observe, how we can create a user with multiple roles in the following main method:</span></p>
<pre><span class="koboSpan" id="kobo.24.1">    static void Main(string[] args)
    {
        User deliveryManager = new User()
        {
            RoleIds = new List&lt;Role&gt;
            {
               new Manager(),
               new TeamLead()
            }
        };
        Console.WriteLine(string.Format("User has Roles:\n\n\t- </span><br/><span class="koboSpan" id="kobo.25.1">           {0}", string.Join("\n\t- ", deliveryManager.RoleIds)));
    }</span></pre>
<p><span class="koboSpan" id="kobo.26.1">While creating a </span><kbd><span class="koboSpan" id="kobo.27.1">DeliveryManager</span></kbd><span class="koboSpan" id="kobo.28.1"> type of </span><kbd><span class="koboSpan" id="kobo.29.1">User</span></kbd><span class="koboSpan" id="kobo.30.1">, we are assigning multiple roles to the user by creating a list of </span><kbd><span class="koboSpan" id="kobo.31.1">Manager</span></kbd><span class="koboSpan" id="kobo.32.1"> and </span><kbd><span class="koboSpan" id="kobo.33.1">TeamLead</span></kbd><span class="koboSpan" id="kobo.34.1"> types. </span><span class="koboSpan" id="kobo.34.2">As they inherit from </span><kbd><span class="koboSpan" id="kobo.35.1">Role</span></kbd><span class="koboSpan" id="kobo.36.1"> base class, so </span><kbd><span class="koboSpan" id="kobo.37.1">RoleIds</span></kbd><span class="koboSpan" id="kobo.38.1"> recognize these types.</span></p>
<p class="mce-root"><span class="koboSpan" id="kobo.39.1">This piece of code produces the following output:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.40.1"><img height="137" width="415" src="assets/5707a7e8-fbbb-4fbe-8ef6-3838aa1269af.png"/></span></div>
<p><span class="koboSpan" id="kobo.41.1">We conclude that Composition takes over Inheritance in many of such cases. </span><span class="koboSpan" id="kobo.41.2">That means you need to be very careful when you start designing the classes. </span><span class="koboSpan" id="kobo.41.3">Otherwise, the situation will get worse in the future when your system grows as you will create a mess. </span><span class="koboSpan" id="kobo.41.4">You should definitely avoid duplicate codes. </span><span class="koboSpan" id="kobo.41.5">When you see that you are writing something which has already been written before, stop and think before you proceed. </span><span class="koboSpan" id="kobo.41.6">Try to normalize as much as possible at that moment.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Role of Object Composition in Dependency Injection</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Now that we understand the concept of Object Composition, let's analyze an actual software project problem and how that can be trapped using Object Composition. </span><span class="koboSpan" id="kobo.2.2">In the process, we will find out the importance of this concept in a DI context:</span></p>
<pre><span class="koboSpan" id="kobo.3.1">    class Mail
    {
      protected bool SendMail(string mailId, string message)
      {   
         // Logic to send an email
         return true;
      }
    }
    class Notification : Mail
    {
       void SendNotification(string mailId, string message)
       {
          SendMail(mailId, message);
       }
    }</span></pre>
<p><span class="koboSpan" id="kobo.4.1">So, the </span><kbd><span class="koboSpan" id="kobo.5.1">Notification</span></kbd><span class="koboSpan" id="kobo.6.1"> class is inheriting the </span><kbd><span class="koboSpan" id="kobo.7.1">Mail</span></kbd><span class="koboSpan" id="kobo.8.1"> class, so that it can call </span><kbd><span class="koboSpan" id="kobo.9.1">SendMail()</span></kbd><span class="koboSpan" id="kobo.10.1">. </span><span class="koboSpan" id="kobo.10.2">This structure is not wrong, but it will create complications going forward.</span></p>
<p><span class="koboSpan" id="kobo.11.1">Imagine another class for </span><kbd><span class="koboSpan" id="kobo.12.1">Sms</span></kbd><span class="koboSpan" id="kobo.13.1">, where we can have a method something like </span><kbd><span class="koboSpan" id="kobo.14.1">SendSms()</span></kbd><span class="koboSpan" id="kobo.15.1">. </span><span class="koboSpan" id="kobo.15.2">There is no way here for the </span><kbd><span class="koboSpan" id="kobo.16.1">Notification</span></kbd><span class="koboSpan" id="kobo.17.1"> class to call that method as multiple inheritances is not possible.</span></p>
<p><span class="koboSpan" id="kobo.18.1">To solve this problem, we can easily use Object Composition along with Dependency Injection. </span><span class="koboSpan" id="kobo.18.2">Let's alter the code first. </span><span class="koboSpan" id="kobo.18.3">This is shown as follows:</span></p>
<pre><span class="koboSpan" id="kobo.19.1">    interface IMail
    {
        bool SendMail(string mailId, string message);
    }

    interface ISms
    {
        bool SendSms(string mobile, string message);
    }

    public class Mail : IMail
    {
       public bool SendMail(string mailId, string message)
       {
          // Logic to send an email
          Console.WriteLine("SendMail Called");
          return true;
       }
     }

     public class Sms : ISms
     {
        public bool SendSms(string mailId, string message)
        {
          // Logic to send a Sms
          Console.WriteLine("SendSms Called");
          return true;
        }
      }

      class Notification
      {
         private readonly IMail _mail;
         private readonly ISms _sms;

         public Notification(IMail mail, ISms sms)
         {
           _mail = mail;
           _sms = sms;
         }

        public void SendNotification(string mailId, string mobile,</span><br/><span class="koboSpan" id="kobo.20.1">           string message)
        {
           _mail.SendMail(mailId, message);
           _sms.SendSms(mobile, message);
        }
      }</span></pre>
<p><kbd><span class="koboSpan" id="kobo.21.1">IEmail</span></kbd><span class="koboSpan" id="kobo.22.1"> and </span><kbd><span class="koboSpan" id="kobo.23.1">ISms</span></kbd><span class="koboSpan" id="kobo.24.1"> are interfaces which have </span><kbd><span class="koboSpan" id="kobo.25.1">SendMail()</span></kbd><span class="koboSpan" id="kobo.26.1"> and </span><kbd><span class="koboSpan" id="kobo.27.1">SendSms()</span></kbd><span class="koboSpan" id="kobo.28.1"> methods respectively. </span><span class="koboSpan" id="kobo.28.2">The next thing is to implement these interfaces in classes </span><kbd><span class="koboSpan" id="kobo.29.1">Mail</span></kbd><span class="koboSpan" id="kobo.30.1"> and </span><kbd><span class="koboSpan" id="kobo.31.1">Sms</span></kbd><span class="koboSpan" id="kobo.32.1">. </span><span class="koboSpan" id="kobo.32.2">We will write our sending logic inside the methods implemented in these classes.</span></p>
<p><span class="koboSpan" id="kobo.33.1">Notice the </span><kbd><span class="koboSpan" id="kobo.34.1">Notification</span></kbd><span class="koboSpan" id="kobo.35.1"> class, which is not inheriting any class, rather it is referencing new interfaces. </span><span class="koboSpan" id="kobo.35.2">Then inside a parameterized constructor, we have </span><kbd><span class="koboSpan" id="kobo.36.1">IMail</span></kbd><span class="koboSpan" id="kobo.37.1"> and </span><kbd><span class="koboSpan" id="kobo.38.1">ISms</span></kbd><span class="koboSpan" id="kobo.39.1"> as arguments. </span><span class="koboSpan" id="kobo.39.2">The </span><kbd><span class="koboSpan" id="kobo.40.1">SendNotification()</span></kbd><span class="koboSpan" id="kobo.41.1"> method now takes the necessary details like </span><kbd><span class="koboSpan" id="kobo.42.1">mailId</span></kbd><span class="koboSpan" id="kobo.43.1">, </span><kbd><span class="koboSpan" id="kobo.44.1">mobile</span></kbd><span class="koboSpan" id="kobo.45.1"> and </span><kbd><span class="koboSpan" id="kobo.46.1">message</span></kbd><span class="koboSpan" id="kobo.47.1"> to call the methods using the interfaces.</span></p>
<p><span class="koboSpan" id="kobo.48.1">What's the advantage then? </span><span class="koboSpan" id="kobo.48.2">We wrote more code, didn't we? </span><span class="koboSpan" id="kobo.48.3">The point here is very interesting. </span><span class="koboSpan" id="kobo.48.4">If you look at the code to instantiate </span><kbd><span class="koboSpan" id="kobo.49.1">Notification</span></kbd><span class="koboSpan" id="kobo.50.1"> class, you will get some hint. </span><span class="koboSpan" id="kobo.50.2">Let's look at that:</span></p>
<pre><span class="koboSpan" id="kobo.51.1">    static void Main(string[] args)
    {
        Notification notify = new Notification(new Mail(),</span><br/><span class="koboSpan" id="kobo.52.1">           new Sms());
        notify.SendNotification("taditdash@gmail.com", </span><br/><span class="koboSpan" id="kobo.53.1">          "9132994288", "Hello Tadit!");
        Console.ReadLine();
    }</span></pre>
<p><span class="koboSpan" id="kobo.54.1">Got the hint? </span><span class="koboSpan" id="kobo.54.2">Let me explain. </span><span class="koboSpan" id="kobo.54.3">We injected the </span><kbd><span class="koboSpan" id="kobo.55.1">Mail</span></kbd><span class="koboSpan" id="kobo.56.1"> and </span><kbd><span class="koboSpan" id="kobo.57.1">Sms</span></kbd><span class="koboSpan" id="kobo.58.1"> class instances into the </span><kbd><span class="koboSpan" id="kobo.59.1">Notification</span></kbd><span class="koboSpan" id="kobo.60.1"> constructor which is assigned to the properties </span><kbd><span class="koboSpan" id="kobo.61.1">_mail</span></kbd><span class="koboSpan" id="kobo.62.1"> and </span><kbd><span class="koboSpan" id="kobo.63.1">_sms</span></kbd><span class="koboSpan" id="kobo.64.1">. </span><span class="koboSpan" id="kobo.64.2">It would automatically call the methods inside </span><kbd><span class="koboSpan" id="kobo.65.1">Mail</span></kbd><span class="koboSpan" id="kobo.66.1"> and </span><kbd><span class="koboSpan" id="kobo.67.1">Sms</span></kbd><span class="koboSpan" id="kobo.68.1"> classes. </span><span class="koboSpan" id="kobo.68.2">So, we composed </span><kbd><span class="koboSpan" id="kobo.69.1">Notification</span></kbd><span class="koboSpan" id="kobo.70.1"> class with </span><kbd><span class="koboSpan" id="kobo.71.1">IMail</span></kbd><span class="koboSpan" id="kobo.72.1"> and </span><kbd><span class="koboSpan" id="kobo.73.1">ISms</span></kbd><span class="koboSpan" id="kobo.74.1"> references. </span><span class="koboSpan" id="kobo.74.2">This is where Object Composition came into the picture along with Dependency Injection.</span></p>
<p><span class="koboSpan" id="kobo.75.1">Suppose at some point in time you want to include another class for mail sending (something like </span><kbd><span class="koboSpan" id="kobo.76.1">SmtpMail</span></kbd><span class="koboSpan" id="kobo.77.1">). </span><span class="koboSpan" id="kobo.77.2">You just need to write that class implementing the same </span><kbd><span class="koboSpan" id="kobo.78.1">IMail</span></kbd><span class="koboSpan" id="kobo.79.1"> interface and define the </span><kbd><span class="koboSpan" id="kobo.80.1">SendMail</span></kbd><span class="koboSpan" id="kobo.81.1"> method. </span><span class="koboSpan" id="kobo.81.2">Bang, it's done. </span><span class="koboSpan" id="kobo.81.3">No need to make the </span><kbd><span class="koboSpan" id="kobo.82.1">Notification</span></kbd><span class="koboSpan" id="kobo.83.1"> class dirty anymore. </span><span class="koboSpan" id="kobo.83.2">It will work as expected.</span></p>
<pre><span class="koboSpan" id="kobo.84.1">    public class SmtpMail : IMail
    {
       public bool SendMail(string mailId, string message)
       {
          // Logic to send an email
          Console.WriteLine("SmtpMail Called");
          return true;
       }
    }
    static void Main(string[] args)
    {
        Notification notify = new Notification(new SmtpMail(),</span><br/><span class="koboSpan" id="kobo.85.1">            new Sms());
        notify.SendNotification("taditdash@gmail.com", </span><br/><span class="koboSpan" id="kobo.86.1">           "9132994288", "Hello Tadit!");
        Console.ReadLine();
    }</span></pre>
<p><span class="koboSpan" id="kobo.87.1">As you can see, I just declared the new class and injected the object like </span><kbd><span class="koboSpan" id="kobo.88.1">new SmtpMail()</span></kbd><span class="koboSpan" id="kobo.89.1"> instead of </span><kbd><span class="koboSpan" id="kobo.90.1">new Mail()</span></kbd><span class="koboSpan" id="kobo.91.1">. </span><span class="koboSpan" id="kobo.91.2">That is the only change. </span><span class="koboSpan" id="kobo.91.3">The rest will work as expected because I have injected the object instead of directly referencing it inside the </span><kbd><span class="koboSpan" id="kobo.92.1">Notification</span></kbd><span class="koboSpan" id="kobo.93.1"> class.</span></p>
<p><span class="koboSpan" id="kobo.94.1">To summarise, the following is what we achieved:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.95.1">We introduced flexibility through interfaces for concrete dependencies.</span></li>
<li><span class="koboSpan" id="kobo.96.1">We can easily plug in new concrete class dependency just by implementing the interface abstraction.</span></li>
<li><span class="koboSpan" id="kobo.97.1">We composed </span><kbd><span class="koboSpan" id="kobo.98.1">Notification</span></kbd><span class="koboSpan" id="kobo.99.1"> object with the dependency objects just with one go.</span></li>
<li><span class="koboSpan" id="kobo.100.1">We moved all initialization code to one place inside the </span><kbd><span class="koboSpan" id="kobo.101.1">Main</span></kbd><span class="koboSpan" id="kobo.102.1"> method</span></li>
</ul>
<p><span class="koboSpan" id="kobo.103.1">When I said we moved the initialization code to one place, that location is denoted as the </span><strong><span class="koboSpan" id="kobo.104.1">Composition Root</span></strong><span class="koboSpan" id="kobo.105.1"> of the application.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Composition Root</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Composition Root composes all the independent modules of the application. </span><span class="koboSpan" id="kobo.2.2">During runtime, Object Composition is the first thing that happens before any other operations. </span><span class="koboSpan" id="kobo.2.3">As soon as the object graph is wired up with dependencies, Object Composition is finished, then the components related to the application can take over. </span><span class="koboSpan" id="kobo.2.4">Object Composition should happen as close as possible to the application's entry point.</span></p>
<p><span class="koboSpan" id="kobo.3.1">The entry points in .NET Core 2.0 Console App and ASP.NET Core 2.0 MVC app are the same and that is inside the </span><kbd><span class="koboSpan" id="kobo.4.1">Main</span></kbd><span class="koboSpan" id="kobo.5.1"> method of the </span><kbd><span class="koboSpan" id="kobo.6.1">Program.cs</span></kbd><span class="koboSpan" id="kobo.7.1"> class. </span><span class="koboSpan" id="kobo.7.2">.NET Core 2.0 Console App's </span><kbd><span class="koboSpan" id="kobo.8.1">Main</span></kbd><span class="koboSpan" id="kobo.9.1"> method is clean, but on the other hand, ASP.NET Core 2.0 MVC has some bootstrapping codes inside the </span><kbd><span class="koboSpan" id="kobo.10.1">Main</span></kbd><span class="koboSpan" id="kobo.11.1"> method. </span><span class="koboSpan" id="kobo.11.2">However, we usually write composition codes inside a </span><kbd><span class="koboSpan" id="kobo.12.1">ConfigureServices</span></kbd><span class="koboSpan" id="kobo.13.1"> method which can be called inside the </span><kbd><span class="koboSpan" id="kobo.14.1">Main</span></kbd><span class="koboSpan" id="kobo.15.1"> method.</span></p>
<p><span class="koboSpan" id="kobo.16.1">When you do a </span><span class="packt_screen"><span class="koboSpan" id="kobo.17.1">File</span></span><span class="koboSpan" id="kobo.18.1"> | </span><span class="packt_screen"><span class="koboSpan" id="kobo.19.1">New</span></span><span class="koboSpan" id="kobo.20.1"> | </span><span class="packt_screen"><span class="koboSpan" id="kobo.21.1">Project</span></span><span class="koboSpan" id="kobo.22.1"> | </span><span class="packt_screen"><span class="koboSpan" id="kobo.23.1">.NET Cor</span></span><span class="koboSpan" id="kobo.24.1">e | </span><span class="packt_screen"><span class="koboSpan" id="kobo.25.1">Console App (.NET Core)</span></span><span class="koboSpan" id="kobo.26.1"> in Visual Studio 2017, you will see the following in the </span><kbd><span class="koboSpan" id="kobo.27.1">Main</span></kbd><span class="koboSpan" id="kobo.28.1"> method:</span></p>
<pre><span class="koboSpan" id="kobo.29.1">    namespace PacktConsoleApp</span><br/><span class="koboSpan" id="kobo.30.1">    {</span><br/><span class="koboSpan" id="kobo.31.1">      class Program</span><br/><span class="koboSpan" id="kobo.32.1">      {</span><br/><span class="koboSpan" id="kobo.33.1">        static void Main(string[] args)</span><br/><span class="koboSpan" id="kobo.34.1">        {</span><br/><strong><span class="koboSpan" id="kobo.35.1">          // We will do all Object Composition here directly or </span><br/><span class="koboSpan" id="kobo.36.1">              calling a ConfigureServices method.</span></strong><br/><span class="koboSpan" id="kobo.37.1">          Console.WriteLine("Hello World!");</span><br/><span class="koboSpan" id="kobo.38.1">        }</span><br/><span class="koboSpan" id="kobo.39.1">      }</span><br/><span class="koboSpan" id="kobo.40.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.41.1">In the case of ASP.NET Core 2.0 MVC App, when you select </span><span><span class="koboSpan" id="kobo.42.1"> </span></span><span class="packt_screen"><span class="koboSpan" id="kobo.43.1">File</span></span><span><span class="koboSpan" id="kobo.44.1"> | </span></span><span class="packt_screen"><span class="koboSpan" id="kobo.45.1">New</span></span><span><span class="koboSpan" id="kobo.46.1"> | </span></span><span class="packt_screen"><span class="koboSpan" id="kobo.47.1">Project</span></span><span><span class="koboSpan" id="kobo.48.1"> |</span></span><span class="koboSpan" id="kobo.49.1"> </span><span class="packt_screen"><span class="koboSpan" id="kobo.50.1">Web</span></span><span class="koboSpan" id="kobo.51.1"> | </span><span class="packt_screen"><span class="koboSpan" id="kobo.52.1">ASP.NET Core Web Application</span></span><span class="koboSpan" id="kobo.53.1"> (in the next screen, select appropriate template), the template for </span><span class="packt_screen"><span class="koboSpan" id="kobo.54.1">Web Application</span></span><span class="koboSpan" id="kobo.55.1"> generates the </span><kbd><span class="koboSpan" id="kobo.56.1">Main</span></kbd><span class="koboSpan" id="kobo.57.1"> method in the </span><kbd><span class="koboSpan" id="kobo.58.1">Program</span></kbd><span class="koboSpan" id="kobo.59.1"> class and </span><kbd><span class="koboSpan" id="kobo.60.1">Startup</span></kbd><span class="koboSpan" id="kobo.61.1"> would look like the following:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.62.1"><img src="assets/b43a5769-7a5c-4917-b9c0-ffc24875d597.png"/></span></div>
<p><span class="koboSpan" id="kobo.63.1">The way we composed the </span><kbd><span class="koboSpan" id="kobo.64.1">Notification</span></kbd><span class="koboSpan" id="kobo.65.1"> object in the last section is known as </span><strong><span class="koboSpan" id="kobo.66.1">Poor Man's DI</span></strong><span class="koboSpan" id="kobo.67.1">. </span><span class="koboSpan" id="kobo.67.2">Instead of doing that, we should apply DI Containers to compose and manage objects in that location.</span></p>
<p><span class="koboSpan" id="kobo.68.1">Object Composition is the fundamental building block of DI and the easiest one to understand because we already know how to compose objects with many examples. </span><span class="koboSpan" id="kobo.68.2">Now it's time to learn what are the challenges we would face composing objects for DI due to the framework capabilities. </span><span class="koboSpan" id="kobo.68.3">The issues are related to a framework and nothing to do with the Object Composition concept. </span><span class="koboSpan" id="kobo.68.4">Let's find out in the upcoming sections.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Composing .NET Core 2.0 Console application</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Inside the </span><kbd><span class="koboSpan" id="kobo.3.1">Main</span></kbd><span class="koboSpan" id="kobo.4.1"> method, we can easily compose objects with built-in DI Container. </span><span class="koboSpan" id="kobo.4.2">If you remember, we have already discussed that from container initialization, registration of objects to the container, resolving dependencies and then release the components from the container, everything should happen inside the Composition Root, which is considered as the </span><kbd><span class="koboSpan" id="kobo.5.1">Main</span></kbd><span class="koboSpan" id="kobo.6.1"> method here.</span></p>
<p><span class="koboSpan" id="kobo.7.1">Consider an example of the </span><kbd><span class="koboSpan" id="kobo.8.1">Main</span></kbd><span class="koboSpan" id="kobo.9.1"> method inside a console application:</span></p>
<pre class="mce-root"><span class="koboSpan" id="kobo.10.1">    static void Main(string[] args)</span><br/><span class="koboSpan" id="kobo.11.1">    {</span><br/><span class="koboSpan" id="kobo.12.1">      // Setup container and register dependencies.</span><br/><span class="koboSpan" id="kobo.13.1">      var serviceProvider = new ServiceCollection()</span><br/><span class="koboSpan" id="kobo.14.1">      .AddTransient&lt;IEmployeeService, EmployeeService&gt;()</span><br/><span class="koboSpan" id="kobo.15.1">      .BuildServiceProvider();</span><br/><br/><span class="koboSpan" id="kobo.16.1">      // Get the service instance from the container and </span><br/><span class="koboSpan" id="kobo.17.1">      do actual operation.</span><br/><span class="koboSpan" id="kobo.18.1">      var emp = serviceProvider.GetService&lt;IEmployeeService&gt;();</span><br/><span class="koboSpan" id="kobo.19.1">      emp.HelloEmployee();</span><br/><br/><span class="koboSpan" id="kobo.20.1">      Console.ReadKey();</span><br/><span class="koboSpan" id="kobo.21.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.22.1">This is simple code which leverages the extension method available, </span><kbd><span class="koboSpan" id="kobo.23.1">Add***</span></kbd><span class="koboSpan" id="kobo.24.1">, to register the dependency with the container. </span><span class="koboSpan" id="kobo.24.2">Then we used the </span><kbd><span class="koboSpan" id="kobo.25.1">GetService</span></kbd><span class="koboSpan" id="kobo.26.1"> method to get the implemented type by the interface. </span><span class="koboSpan" id="kobo.26.2">With the instance, we then can do everything we want further in the application.</span></p>
<p><span class="koboSpan" id="kobo.27.1">Recall that Composition Root is the place where we should do all operations related to Dependency Management. </span><span class="koboSpan" id="kobo.27.2">It's not recommended to use the </span><kbd><span class="koboSpan" id="kobo.28.1">serviceProvider</span></kbd><span class="koboSpan" id="kobo.29.1"> outside the Composition Root or </span><kbd><span class="koboSpan" id="kobo.30.1">Main</span></kbd><span class="koboSpan" id="kobo.31.1"> method to be specific. </span><span class="koboSpan" id="kobo.31.2">The same rule applies to ASP.NET Core MVC as well. </span><span class="koboSpan" id="kobo.31.3">We are going to explore that in a while.</span></p>
<p><span class="koboSpan" id="kobo.32.1">You can, of course, introduce another method and you can name it </span><kbd><span class="koboSpan" id="kobo.33.1">ConfigureServices</span></kbd><span class="koboSpan" id="kobo.34.1"> (shown as follows) for a cleaner code structure. </span><span class="koboSpan" id="kobo.34.2">You can give any name to the method, but this name resembles the name of the method specially dedicated in ASP.NET Core MVC app for dependency injection configurations as we saw in the picture in the last section. </span><span class="koboSpan" id="kobo.34.3">This new method added is shown in the following code snippet:</span></p>
<pre><span class="koboSpan" id="kobo.35.1">    static void Main(string[] args)</span><br/><span class="koboSpan" id="kobo.36.1">    {</span><br/><strong><span class="koboSpan" id="kobo.37.1">      ConfigureServices(new ServiceCollection());</span></strong><br/><span class="koboSpan" id="kobo.38.1">      Console.ReadKey();</span><br/><span class="koboSpan" id="kobo.39.1">    }</span><br/><br/><span class="koboSpan" id="kobo.40.1">    public static void ConfigureServices(IServiceCollection </span><br/><span class="koboSpan" id="kobo.41.1">      serviceCollection)</span><br/><span class="koboSpan" id="kobo.42.1">    {</span><br/><span class="koboSpan" id="kobo.43.1">      // Setup container and register dependencies.</span><br/><span class="koboSpan" id="kobo.44.1">      var serviceProvider = serviceCollection</span><br/><span class="koboSpan" id="kobo.45.1">      .AddTransient&lt;IEmployeeService, EmployeeService&gt;()</span><br/><span class="koboSpan" id="kobo.46.1">      .BuildServiceProvider();</span><br/><br/><span class="koboSpan" id="kobo.47.1">      // Get the service instance from the container and</span><br/><span class="koboSpan" id="kobo.48.1">         do actual operation.</span><br/><span class="koboSpan" id="kobo.49.1">      var emp = serviceProvider.GetService&lt;IEmployeeService&gt;();</span><br/><span class="koboSpan" id="kobo.50.1">      emp.HelloEmployee();</span><br/><span class="koboSpan" id="kobo.51.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.52.1">Notice that we are not manually releasing the objects or the container. </span><span class="koboSpan" id="kobo.52.2">The reason is that release is automatically handled by the DI Container according to the life style you decide. </span><kbd><span class="koboSpan" id="kobo.53.1">AddTransient</span></kbd><span class="koboSpan" id="kobo.54.1">, </span><kbd><span class="koboSpan" id="kobo.55.1">AddSingleton</span></kbd><span class="koboSpan" id="kobo.56.1"> and </span><kbd><span class="koboSpan" id="kobo.57.1">AddScoped</span></kbd><span class="koboSpan" id="kobo.58.1"> are readily available methods which helps to perform different types of lifetime for the objects. </span><span class="koboSpan" id="kobo.58.2">We will explore more about Object Lifetime in </span><a href="72113d11-0af8-431f-91d0-ced4cb35af21.xhtml" target="_blank"><span class="koboSpan" id="kobo.59.1">Chapter 6</span></a><span class="koboSpan" id="kobo.60.1">, </span><em><span class="koboSpan" id="kobo.61.1">Object Lifetime</span></em><span class="koboSpan" id="kobo.62.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Object Composition in ASP.NET Core MVC 2.0</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Like Console Application, we can follow the same procedure to deal with dependencies inside ASP.NET Core MVC 2.0 apps. </span><span class="koboSpan" id="kobo.2.2">Unlike the console app, the </span><kbd><span class="koboSpan" id="kobo.3.1">Main</span></kbd><span class="koboSpan" id="kobo.4.1"> method inside the </span><kbd><span class="koboSpan" id="kobo.5.1">Program.cs</span></kbd><span class="koboSpan" id="kobo.6.1">, in this case, is populated with default codes to initiate the MVC App with required configurations. </span><span class="koboSpan" id="kobo.6.2">It is that location from which it instructs the framework to load the Startup class. </span><span class="koboSpan" id="kobo.6.3">The </span><kbd><span class="koboSpan" id="kobo.7.1">host</span></kbd><span class="koboSpan" id="kobo.8.1"> inside the </span><kbd><span class="koboSpan" id="kobo.9.1">Main</span></kbd><span class="koboSpan" id="kobo.10.1"> method executes the </span><kbd><span class="koboSpan" id="kobo.11.1">Startup</span></kbd><span class="koboSpan" id="kobo.12.1"> class </span><kbd><span class="koboSpan" id="kobo.13.1">ConfigureServices</span></kbd><span class="koboSpan" id="kobo.14.1"> method.</span></p>
<p><span class="koboSpan" id="kobo.15.1">ASP.NET Core MVC is designed to be DI-friendly. </span><span class="koboSpan" id="kobo.15.2">But it does not force you to apply DI always. </span><span class="koboSpan" id="kobo.15.3">To deal with dependencies in ASP.NET MVC, we can take the Poor Man's DI approach to manually manage them or leverage built-in/third party DI Container's technique to register, resolve, and release dependencies. </span><span class="koboSpan" id="kobo.15.4">Let's dive a little deep into the controller initiation process and see if we find anything useful.</span></p>
<p><span class="koboSpan" id="kobo.16.1">The heart of MVC lies in controllers. </span><span class="koboSpan" id="kobo.16.2">Controllers handle requests, process them, and return the response back to the client. </span><span class="koboSpan" id="kobo.16.3">Thus, the controllers should delegate their responsibility to the other modules as required. </span><span class="koboSpan" id="kobo.16.4">That means the controller will refer to other classes for certain tasks. </span><span class="koboSpan" id="kobo.16.5">It will use the </span><kbd><span class="koboSpan" id="kobo.17.1">new</span></kbd><span class="koboSpan" id="kobo.18.1"> keyword for the dependency object creation inside the action methods, which we can easily avoid as we are using DI Container. </span><span class="koboSpan" id="kobo.18.2">With the dependency injection technique, we should be able to inject dependencies into the controllers with Constructor Injection.</span></p>
<p><kbd><span class="koboSpan" id="kobo.19.1">IControllerFactory</span></kbd><span class="koboSpan" id="kobo.20.1"> is an interface inside </span><kbd><span class="koboSpan" id="kobo.21.1">Microsoft.AspNetCore.Mvc.Controllers</span></kbd><span class="koboSpan" id="kobo.22.1"> namespace which enables us to create and release controllers. </span><span class="koboSpan" id="kobo.22.2">The interface contains two methods, shown as follows:</span></p>
<pre><span class="koboSpan" id="kobo.23.1">    namespace Microsoft.AspNetCore.Mvc.Controllers</span><br/><span class="koboSpan" id="kobo.24.1">    {</span><br/><span class="koboSpan" id="kobo.25.1">      /// &lt;summary&gt;</span><br/><span class="koboSpan" id="kobo.26.1">      /// Provides methods for creation and disposal of controllers.</span><br/><span class="koboSpan" id="kobo.27.1">      /// &lt;/summary&gt;</span><br/><span class="koboSpan" id="kobo.28.1">      public interface IControllerFactory</span><br/><span class="koboSpan" id="kobo.29.1">      {</span><br/><span class="koboSpan" id="kobo.30.1">        object </span><strong><span class="koboSpan" id="kobo.31.1">CreateController</span></strong><span class="koboSpan" id="kobo.32.1">(ControllerContext context);</span><br/><span class="koboSpan" id="kobo.33.1">        void </span><strong><span class="koboSpan" id="kobo.34.1">ReleaseController</span></strong><span class="koboSpan" id="kobo.35.1">(ControllerContext context,</span><br/><span class="koboSpan" id="kobo.36.1">         object controller);</span><br/><span class="koboSpan" id="kobo.37.1">      }</span><br/><span class="koboSpan" id="kobo.38.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.39.1">ASP.NET Core MVC 2.0 ships with a </span><kbd><span class="koboSpan" id="kobo.40.1">DefaultControlFactory</span></kbd><span class="koboSpan" id="kobo.41.1"> which implements this interface. </span><span class="koboSpan" id="kobo.41.2">Let's have a look at the source code:</span></p>
<pre><span class="koboSpan" id="kobo.42.1">    namespace Microsoft.AspNetCore.Mvc.Controllers</span><br/><span class="koboSpan" id="kobo.43.1">    {</span><br/><span class="koboSpan" id="kobo.44.1">      /// &lt;summary&gt;</span><br/><span class="koboSpan" id="kobo.45.1">      /// Default implementation for &lt;see cref="IControllerFactory"/&gt;.</span><br/><span class="koboSpan" id="kobo.46.1">      /// &lt;/summary&gt;</span><br/><span class="koboSpan" id="kobo.47.1">      public class DefaultControllerFactory : IControllerFactory</span><br/><span class="koboSpan" id="kobo.48.1">      {</span><br/><span class="koboSpan" id="kobo.49.1">        private readonly IControllerActivator _controllerActivator;</span><br/><span class="koboSpan" id="kobo.50.1">        private readonly IControllerPropertyActivator[]</span><br/><span class="koboSpan" id="kobo.51.1">            _propertyActivators;</span><br/><strong><span class="koboSpan" id="kobo.52.1">        public DefaultControllerFactory(</span></strong><br/><strong><span class="koboSpan" id="kobo.53.1">            IControllerActivator controllerActivator,</span></strong><br/><strong><span class="koboSpan" id="kobo.54.1">            IEnumerable&lt;IControllerPropertyActivator&gt; propertyActivators)</span></strong><br/><span class="koboSpan" id="kobo.55.1">            {</span><br/><span class="koboSpan" id="kobo.56.1">              if (controllerActivator == null)</span><br/><span class="koboSpan" id="kobo.57.1">              {</span><br/><span class="koboSpan" id="kobo.58.1">                throw new ArgumentNullException(nameof(</span><br/><span class="koboSpan" id="kobo.59.1">                 controllerActivator));</span><br/><span class="koboSpan" id="kobo.60.1">              }</span><br/><br/><span class="koboSpan" id="kobo.61.1">              if (propertyActivators == null)</span><br/><span class="koboSpan" id="kobo.62.1">               {</span><br/><span class="koboSpan" id="kobo.63.1">                throw </span><br/><span class="koboSpan" id="kobo.64.1">                  new ArgumentNullException(nameof(propertyActivators));</span><br/><span class="koboSpan" id="kobo.65.1">               }</span><br/><br/><span class="koboSpan" id="kobo.66.1">               _controllerActivator = controllerActivator;</span><br/><span class="koboSpan" id="kobo.67.1">               _propertyActivators = propertyActivators.ToArray();</span><br/><span class="koboSpan" id="kobo.68.1">            }</span><br/><span class="koboSpan" id="kobo.69.1">            public virtual object CreateController</span><br/><span class="koboSpan" id="kobo.70.1">              (ControllerContext context)</span><br/><span class="koboSpan" id="kobo.71.1">            {</span><br/><span class="koboSpan" id="kobo.72.1">               // Codes removed just for book.</span><br/><span class="koboSpan" id="kobo.73.1">                   You can find codes in Github.</span><br/><span class="koboSpan" id="kobo.74.1">             }</span><br/><br/><span class="koboSpan" id="kobo.75.1">             public virtual void ReleaseController(ControllerContext</span><br/><span class="koboSpan" id="kobo.76.1">               context, object controller)</span><br/><span class="koboSpan" id="kobo.77.1">            {</span><br/><span class="koboSpan" id="kobo.78.1">              // Codes removed just for book. </span><span class="koboSpan" id="kobo.78.2">You can</span><br/><span class="koboSpan" id="kobo.79.1">                  find codes in Github.</span><br/><span class="koboSpan" id="kobo.80.1">            }</span><br/><span class="koboSpan" id="kobo.81.1">      }</span><br/><span class="koboSpan" id="kobo.82.1">    }</span></pre>
<p><kbd><span class="koboSpan" id="kobo.83.1">DefaultControllerFactory</span></kbd><span class="koboSpan" id="kobo.84.1"> has a constructor injection with the required dependencies for the </span><kbd><span class="koboSpan" id="kobo.85.1">ControllerActivator</span></kbd><span class="koboSpan" id="kobo.86.1"> and </span><kbd><span class="koboSpan" id="kobo.87.1">PropertyActivators</span></kbd><span class="koboSpan" id="kobo.88.1">. </span><span class="koboSpan" id="kobo.88.2">Thus, this factory is composed of activators. </span><span class="koboSpan" id="kobo.88.3">Like a factory, there is an interface for </span><kbd><span class="koboSpan" id="kobo.89.1">Activator</span></kbd><span class="koboSpan" id="kobo.90.1"> also named </span><kbd><span class="koboSpan" id="kobo.91.1">IControllerActivator</span></kbd><span class="koboSpan" id="kobo.92.1">. </span><span class="koboSpan" id="kobo.92.2">There are providers for Factory and Activators named </span><kbd><span class="koboSpan" id="kobo.93.1">ControllerFactoryProvider</span></kbd><span class="koboSpan" id="kobo.94.1"> and </span><kbd><span class="koboSpan" id="kobo.95.1">ControllerActivatorProvider</span></kbd><span class="koboSpan" id="kobo.96.1"> respectively.</span></p>
<p><span><span class="koboSpan" id="kobo.97.1">Now, the most important part. </span><span class="koboSpan" id="kobo.97.2">The Object Composition of these factories is actually done inside the </span></span><kbd><span class="koboSpan" id="kobo.98.1">AddMvcCore()</span></kbd> <span><span class="koboSpan" id="kobo.99.1">method of class </span></span><kbd><span class="koboSpan" id="kobo.100.1">MvcServiceCollectionExtensions</span></kbd> <span><span class="koboSpan" id="kobo.101.1">which stays inside </span><kbd><span class="koboSpan" id="kobo.102.1">namespace</span></kbd></span> <kbd><span><span class="koboSpan" id="kobo.103.1">Microsoft.Extensions.DependencyInjection</span></span></kbd><span><span class="koboSpan" id="kobo.104.1">. </span><span class="koboSpan" id="kobo.104.2">The </span><kbd><span class="koboSpan" id="kobo.105.1">namespace</span></kbd><span class="koboSpan" id="kobo.106.1"> name contains </span><kbd><span class="koboSpan" id="kobo.107.1">DependencyInjection</span></kbd><span class="koboSpan" id="kobo.108.1">, which itself gives us a hint that we are going to do some injection for sure to initiate these activators and factories. </span><span class="koboSpan" id="kobo.108.2">Let's see a snapshot of</span></span><span class="koboSpan" id="kobo.109.1"> the </span><kbd><span class="koboSpan" id="kobo.110.1">AddMvcCoreServices()</span></kbd><span><span class="koboSpan" id="kobo.111.1"> method (</span><span><span class="koboSpan" id="kobo.112.1"> which is another method called from </span></span><kbd><span class="koboSpan" id="kobo.113.1">AddMvcCore()</span></kbd><span class="koboSpan" id="kobo.114.1">) responsible for composing all required dependencies for controller activation and</span></span><span class="koboSpan" id="kobo.115.1"> initialization</span><span><span class="koboSpan" id="kobo.116.1">:</span></span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.117.1"><img src="assets/e5e5e48a-e6fa-4263-8628-a0a148146ea7.png"/></span></div>
<p><span class="koboSpan" id="kobo.118.1">You can see how the interfaces are registered as the concrete classes. </span><span class="koboSpan" id="kobo.118.2">This method contains many other service registrations for all the background work needed for the controller process. </span><span class="koboSpan" id="kobo.118.3">But we got an idea about how Object Composition is implemented inside the framework itself.</span></p>
<p><span class="koboSpan" id="kobo.119.1">If we want to design our own custom controller factory, we can do that as well by registering the required factory and provider inside this method for initiation.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">This chapter touched upon important relationships between objects in programming. </span><span class="koboSpan" id="kobo.2.2">We created very basic classes and tried to grasp the concepts. </span><span class="koboSpan" id="kobo.2.3">Then we moved our focus to Object Composition, and it's types, Composition, and Aggregation.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Moreover, we discussed Association. </span><span class="koboSpan" id="kobo.3.2">With code examples and outputs, we saw how these relationships matter a lot while coding.</span></p>
<p><span class="koboSpan" id="kobo.4.1">Finally, we were introduced to Inheritance with an example. </span><span class="koboSpan" id="kobo.4.2">Once we completed all these, we moved towards a very important saying </span><em><span class="koboSpan" id="kobo.5.1">Composition over Inheritance</span></em><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">This is a real-time issue which developers face while applying new requirements to existing class structures.</span></p>
<p><span class="koboSpan" id="kobo.7.1">Then, we discussed the important role played by Object Composition in Dependency Injection. </span><span class="koboSpan" id="kobo.7.2">Also, we saw how this pattern is followed in ASP.NET Core MVC 2.0.</span></p>
<p><span class="koboSpan" id="kobo.8.1">It's time to see how objects are created, how they live and are then destroyed in </span><a href="72113d11-0af8-431f-91d0-ced4cb35af21.xhtml" target="_blank"><span class="koboSpan" id="kobo.9.1">Chapter 6</span></a><span class="koboSpan" id="kobo.10.1">, </span><em><span class="koboSpan" id="kobo.11.1">Object Lifetime</span></em><span class="koboSpan" id="kobo.12.1">. </span><span class="koboSpan" id="kobo.12.2">We will relate the object lifetime with what we already know from this chapter.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>