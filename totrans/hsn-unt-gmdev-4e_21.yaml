- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: 'Animated Realities: Creating Animations with Animator, Cinemachine, and Timeline'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画现实：使用Animator、Cinemachine和Timeline创建动画
- en: Sometimes, we need to move objects in a predetermined way, such as with cutscenes,
    or specific character animations, such as jumping, running, and so on. In this
    chapter, we will go over several Unity animation systems to create all the possible
    movements of objects we can get without scripting.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要以预定的方式移动对象，例如使用过场动画，或特定的角色动画，如跳跃、奔跑等。在本章中，我们将介绍几个Unity动画系统，以创建我们可以通过脚本获得的所有可能的物体运动。
- en: 'In this chapter, we will examine the following animation concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下动画概念：
- en: Using skinning animation with Animator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Animator进行蒙皮动画
- en: Scripting animations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写动画脚本
- en: Creating dynamic cameras with Cinemachine
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cinemachine创建动态摄像机
- en: Creating cutscenes with Timeline
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用时间轴创建过场动画
- en: By the end of this chapter, you will be able to create cutscenes to tell the
    history of your game or highlight specific areas of your level, as well as create
    dynamic cameras that are capable of giving an accurate look to your game, regardless
    of the situation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够创建过场动画来讲述你游戏的历史或突出你关卡中的特定区域，以及创建能够准确呈现游戏场景的动态摄像机，无论情况如何。
- en: Using skinning animation with Animator
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Animator进行蒙皮动画
- en: So far, we have used what are called static meshes, which are solid three-dimensional
    models that are not supposed to bend or animate in any way (aside from moving
    separately, like the doors of a car).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的是所谓的静态网格，它们是固体三维模型，不应该以任何方式弯曲或动画化（除了像汽车门那样单独移动）。
- en: We also have another kind of mesh, called skinned meshes, which are meshes that
    have the ability to deform based on a skeleton so they can emulate the muscle
    movements of the human body. We are going to explore how to integrate animated
    humanoid characters into our project to create enemy and player movements.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一种另一种类型的网格，称为蒙皮网格，这种网格可以根据骨骼变形，因此可以模拟人体肌肉运动。我们将探讨如何将动画化的类人角色集成到我们的项目中，以创建敌人和玩家的动作。
- en: 'In this section, we will examine the following skeletal mesh concepts:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下骨骼网格概念：
- en: Understanding skinning
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解蒙皮
- en: Importing skinned meshes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入蒙皮网格
- en: Integration using Animator Controllers
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Animator控制器进行集成
- en: Using avatar masks
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用头像蒙版
- en: Now that we’ve introduced skinned meshes, let’s delve deeper into how skinning
    functions and its pivotal role in character animation. Then, we are going to bring
    animated meshes into our project to finally apply animations to them. Let’s start
    by discussing how to bring skeletal animations into our project.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了蒙皮网格，让我们更深入地探讨蒙皮的功能及其在角色动画中的关键作用。然后，我们将把动画网格带入我们的项目，最终对它们应用动画。让我们先讨论如何将骨骼动画带入我们的项目。
- en: Understanding skinning
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解蒙皮
- en: 'In order to get an animated mesh, we need to have four pieces, starting with
    the mesh that will be animated, which is created the same way as any other mesh.
    Then, we need the skeleton, which is a set of bones that will match the desired
    mesh topology, such as the arms, fingers, feet, and so on. In *Figure 17.1*, you
    can see an example of a set of bones aligned with our target mesh:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得一个动画网格，我们需要四个部分，首先是将要动画化的网格，其创建方式与任何其他网格相同。然后，我们需要骨骼，它是一组与所需网格拓扑相匹配的骨骼，例如手臂、手指、脚等。在*图17.1*中，你可以看到一个与我们的目标网格对齐的骨骼示例：
- en: '![](img/B21361_17_01_PE.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_01_PE.png)'
- en: 'Figure 17.1: A ninja mesh with a skeleton matching its default pose'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.1：一个与默认姿势匹配的骨骼忍者网格
- en: Once the artist has created the model and its bones, the next step is to do
    skinning, which is the act of associating every vertex of the model to one or
    more bones. This way, when you move a bone, the associated vertices will move
    with it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦艺术家创建了模型及其骨骼，下一步就是进行蒙皮，即把模型的每个顶点关联到一到多个骨骼上。这样，当你移动一个骨骼时，相关的顶点也会随之移动。
- en: 'In *Figure 17.2*, you can see the triangles of a mesh being painted according
    to the color of the bone, which affects it as a way to visualize the influence
    of the bones. You will notice blending between colors, meaning that those vertexes
    are affected differently by different bones to allow the vertexes near an articulation
    to bend nicely. Also, *Figure 17.2* illustrates an example of a two-dimensional
    mesh used for two-dimensional games, but the concept is the same:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图17.2*中，你可以看到网格三角形的着色是根据骨骼的颜色进行的，这以可视化的方式影响了骨骼。你会注意到颜色之间的混合，这意味着这些顶点受到不同骨骼的不同影响，以便使接近关节的顶点弯曲得更好。此外，*图17.2*还展示了用于二维游戏的二维网格的示例，但概念是相同的：
- en: '![](img/B21361_17_02_PE.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_17_02_PE.png)'
- en: 'Figure 17.2: Mesh skinning weights visually represented as colors'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.2：网格蒙皮权重以颜色形式直观表示
- en: Finally, the last piece you need is the actual animation, which will simply
    consist of a blending of different poses of the mesh bones. The artist will create
    keyframes in an animation, determining which pose the model needs to have at different
    moments, and then the animation system will simply interpolate between them. Basically,
    the artist will animate the bones, and the skinning system will apply this animation
    to the whole mesh.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要的是实际的动画，它将简单地由网格骨骼的不同姿势的混合组成。艺术家将在动画中创建关键帧，确定模型在不同时刻需要具有的姿势，然后动画系统将简单地在这之间进行插值。基本上，艺术家将动画化骨骼，蒙皮系统将此动画应用于整个网格。
- en: In order to get the four parts, we need to get the proper assets containing
    them. The usual format in this scenario is **Filmbox** (**FBX**), which we used
    previously to import 3D models. This format can contain every piece we need—the
    model, the skeleton with the skinning, and the animations—but usually, those pieces
    will come split into several files to be re-utilized.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得这四个部分，我们需要获取包含它们的适当资产。在这种情况下，通常的格式是**Filmbox**（**FBX**），我们之前用它来导入3D模型。此格式可以包含我们需要的每一部分——模型、带有蒙皮的骨骼和动画，但通常这些部分将分成几个文件以供重新利用。
- en: Imagine a city simulator game where we have several citizen meshes with different
    aspects, and all of them must be animated. If we have a single FBX per citizen
    containing the mesh, the skinning, and the animation, it will cause each model
    to have its own animation, or at least a clone of the same one, repeating them.
    When we need to change that animation, we will need to update all the mesh citizens,
    which is a time-consuming process.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个城市模拟器游戏，其中我们有几个具有不同外观的市民网格，并且所有这些都必须进行动画处理。如果我们为每个市民有一个包含网格、蒙皮和动画的FBX文件，那么每个模型都将有自己的动画，或者至少是相同的克隆，重复它们。当我们需要更改该动画时，我们需要更新所有网格市民，这是一个耗时的过程。
- en: 'Instead of this, we can have one FBX per citizen, containing the mesh and the
    bones with the proper skinning based on that mesh, as well as a separate FBX for
    each animation, containing the same bones that all the citizens have with the
    proper animation, but without the mesh. This will allow us to mix and match the
    citizen FBX with the animation’s FBX files. You may be wondering why both the
    model FBX and the animation FBX must have the mesh. This is because they need
    to match in order to make both files compatible. In *Figure 17.3*, you can see
    how the files should look:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是这样，我们可以为每个市民有一个包含网格、基于该网格的正确蒙皮的骨骼的FBX文件，以及每个动画一个单独的FBX文件，包含所有市民都具有的正确动画的相同骨骼，但没有网格。这将使我们能够混合和匹配市民FBX文件与动画FBX文件。你可能想知道为什么模型FBX和动画FBX都必须有网格。这是因为它们需要匹配才能使两个文件兼容。在*图17.3*中，你可以看到文件应该如何看起来：
- en: '![](img/B21361_17_03_PE.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_17_03_PE.png)'
- en: 'Figure 17.3: The animation and model FBX files of the package we will use in
    our project'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.3：我们将在项目中使用的动画和模型FBX文件
- en: Also, it is worth mentioning a concept called retargeting. As we said before,
    in order to mix a model and an animation file, we need them to have the same bone
    structure, which means the same number of bones, hierarchy, and names.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个概念叫做重定向。正如我们之前所说，为了混合模型和动画文件，我们需要它们具有相同的骨骼结构，这意味着相同的骨骼数量、层次结构和名称。
- en: Sometimes, this is not possible, especially when we mix custom models created
    by our artist with external animation files that you can record from an actor
    using motion-capture techniques or just by buying a **mocap** (**motion-capture**)
    library, a set of animations captured on real humans using specific mocap hardware.
    In such cases, it is highly likely that you will encounter different bone structures
    between the one in the mocap library and your character model, so this is where
    retargeting kicks in. This technique allows Unity to create a generic mapping
    between two different humanoid-only bone structures to make them compatible. In
    the next section, *Importing skeletal animations*, we will see how to enable this
    feature.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这可能不可行，尤其是在我们将我们艺术家创建的定制模型与您可以使用动作捕捉技术记录或仅通过购买**mocap**（动作捕捉）库（使用特定动作捕捉硬件在真实人类上捕获的一系列动画）的外部动画文件混合时。在这种情况下，您很可能会在mocap库和您的角色模型之间遇到不同的骨骼结构，因此这就是重定向发挥作用的地方。这项技术允许Unity在两个不同的人形骨骼结构之间创建通用的映射，使它们兼容。在下一节*导入骨骼动画*中，我们将看到如何启用此功能。
- en: Now that we understand the basics behind skinned meshes, let’s see how we can
    get the model’s assets with bones and animations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了带皮肤网格的基本原理，让我们看看我们如何获取带有骨骼和动画的模型资产。
- en: Importing skeletal animations
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入骨骼动画
- en: 'We can download a character model by searching for it in the Asset Store in
    the **3D** | **Characters** | **Humanoids** section. You can also use external
    sites, such as the website called Mixamo, to download them. Note that sometimes
    you will need to download several packages because some packages come only with
    the skinned model, and others with animation only. Luckily, the models we downloaded
    in *Chapter 4, Seamless Integration: Importing and Integrating Assets*, already
    contain the skinned meshes and the animations.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在**3D** | **Characters** | **Humanoids**部分在资产商店中搜索来下载角色模型。您还可以使用外部网站，例如名为Mixamo的网站来下载它们。请注意，有时您可能需要下载几个包，因为一些包只包含带皮肤的模型，而另一些只包含动画。幸运的是，我们在*第4章，无缝集成：导入和整合资产*中下载的模型已经包含了带皮肤的网格和动画。
- en: In my package content, I can find the animation’s FBX files in the `Animations`
    folder and the FBX file of my model called `Polyart_Mesh` in the `Mesh` folder.
    Remember that sometimes you won’t have them separated like this, and the animations
    may be located in the same FBX as the model if any animations are present at all.
    Now that we have the required files, let’s discuss how to properly configure them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的包内容中，我可以在`Animations`文件夹中找到动画的FBX文件，以及我在`Mesh`文件夹中名为`Polyart_Mesh`的模型的FBX文件。请记住，有时它们可能不会像这样分开，如果存在任何动画，动画可能位于与模型相同的FBX文件中。现在我们已经有了所需的文件，让我们讨论如何正确配置它们。
- en: 'Let’s start by selecting the **Model** file and checking the **Rig** tab. Within
    this tab, you will find a setting called **Animation Type**, as shown in *Figure
    17.4*:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从选择**模型**文件并检查**绑定**选项卡开始。在此选项卡中，您将找到一个名为**动画类型**的设置，如图*17.4*所示：
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_17_04_PE.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图 描述自动生成，置信度低](img/B21361_17_04_PE.png)'
- en: 'Figure 17.4: The Rig properties'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.4：绑定属性
- en: 'This property contains the following options:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性包含以下选项：
- en: '**None**: Mode for non-animated models; every static mesh in your game will
    use this mode.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**None**：用于非动画模型的模式；您游戏中的每个静态网格都将使用此模式。'
- en: '**Legacy**: The mode to be used in old Unity projects and models; do not use
    this in new projects.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Legacy**：用于旧Unity项目和模型的模式；不要在新项目中使用此模式。'
- en: '**Generic**: A new animation system that can be used in all kinds of models
    but is commonly used in non-humanoid models, such as horses, octopuses, and so
    on. If you use this mode, both the model and animation FBX files must have the
    exact same bone names and structure, thereby reducing the possibility of combining
    animation from external sources.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Generic**：一种可用于所有类型模型的新动画系统，但通常用于非人类模型，如马、章鱼等。如果您使用此模式，模型和动画FBX文件必须具有完全相同的骨骼名称和结构，从而降低从外部来源组合动画的可能性。'
- en: '**Humanoid**: New animation systems designed to be used in humanoid models.
    It enables features such as retargeting and **Inverse Kinematics** (**IK**). These
    allow you to use models with different bone structures than the animation bones.
    To do so, Unity converts the bone structure of the models and animations using
    this mode into a standard humanoid bone structure, making them compatible with
    each other. This structure is called an *Avatar*. Take into account that sometimes
    the automatic mapping can fail, and you will need to correct it manually; so,
    if your generic model has everything you need, I recommend you stick to **Generic**
    if that’s the default configuration of the FBX.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**人类模型**：为人类模型设计的新动画系统。它启用诸如重定向和**逆运动学**（**IK**）等功能。这些功能允许您使用与动画骨骼不同的骨骼结构的模型。为此，Unity使用此模式将模型和动画的骨骼结构转换为标准的人类骨骼结构，使它们相互兼容。这种结构称为**Avatar**。请注意，有时自动映射可能会失败，您可能需要手动纠正；因此，如果您的通用模型包含您所需的一切，我建议您如果FBX的默认配置是**通用**，则坚持使用**通用**。'
- en: In my case, the FBX files in my package have the modes set to **Humanoid**,
    so that’s good, but remember, only switch to other modes if it is absolutely necessary
    (for example, if you need to combine different models and animations). Now that
    we have discussed the **Rig** settings, let’s talk about the **Animation** settings.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，我包中的FBX文件的模式设置为**人类模型**，这是好的，但请记住，只有当绝对必要时才切换到其他模式（例如，如果您需要组合不同的模型和动画）。现在我们已经讨论了**绑定**设置，让我们谈谈**动画**设置。
- en: 'To do this, select any animation FBX file and look for the **Animation** tab
    in the **Inspector** window. You will find several settings, such as the **Import
    Animation** checkbox, which must be marked if the file has an animation (not the
    model files), and the **Clips** list, where you will find all the animations in
    the file. In the following screenshot, you can see the **Clips** list for one
    of our animation files:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，选择任何动画FBX文件，并在**检查器**窗口中查找**动画**选项卡。您将找到几个设置，例如，如果文件包含动画（不是模型文件），则必须标记**导入动画**复选框，以及**剪辑**列表，其中您将找到文件中的所有动画。在以下截图中，您可以看到我们的动画文件之一的**剪辑**列表：
- en: '![A picture containing text, screenshot, number, font  Description automatically
    generated](img/B21361_17_05_PE.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、数字和字体的图片，自动生成描述](img/B21361_17_05_PE.png)'
- en: 'Figure 17.5: The Clips list in the Animation settings'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.5：动画设置中的剪辑列表
- en: 'An FBX file with animations usually contains a single large animation track,
    which can contain one or several animations. Either way, by default, Unity will
    create a single animation based on that track, but if that track contains several
    animations, you will need to split them manually. In our case, our FBX contains
    a single animation, but in order to learn how to split it in other cases, do the
    following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 带有动画的FBX文件通常包含一个单独的大动画轨道，该轨道可以包含一个或多个动画。无论如何，默认情况下，Unity将根据该轨道创建一个单独的动画，但如果该轨道包含多个动画，您将需要手动拆分它们。在我们的案例中，我们的FBX包含一个单独的动画，但为了了解如何在其他情况下拆分它，请按照以下步骤操作：
- en: From the **Clips** list, select any animation that you want to recreate; in
    my case, I will choose `Run_guard_AR`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**剪辑**列表中，选择您想要重新创建的任何动画；在我的情况下，我将选择`Run_guard_AR`。
- en: 'Take a look at the **Start** and **End** values below the animation timeline
    and remember them; we will use them to recreate this clip:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看动画时间线下面的**开始**和**结束**值，并记住它们；我们将使用它们来重新创建此剪辑：
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_17_06_PE.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图，自动生成描述，置信度低](img/B21361_17_06_PE.png)'
- en: 'Figure 17.6: The clip settings'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.6：剪辑设置
- en: Use the **+** button to create a new clip and select it.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**+**按钮创建一个新的剪辑并选择它。
- en: Rename it to something similar to the original using the input field that currently
    says something like `Take 001`. In my case, I will name it `Run`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用当前显示为类似`Take 001`的输入字段将其重命名为与原始名称类似的内容。在我的情况下，我将将其命名为`Run`。
- en: Set the **End** and **Start** properties with the values we needed to remember
    in *step 2*. In my case, I have `20` for **End** and `0` for **Start**. This information
    usually comes from the artist who made the animation, but you can just try the
    number that works best or simply drag the blue markers in the timeline on top
    of these properties.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们在*步骤2*中需要记住的值设置**结束**和**开始**属性。在我的情况下，我将**结束**设置为`20`，将**开始**设置为`0`。这些信息通常来自制作动画的艺术家，但您可以尝试最适合的数字，或者简单地拖动时间轴顶部的蓝色标记到这些属性上。
- en: 'If an animation needs to loop, check the **Loop Time** checkbox to guarantee
    that. This will make the animation repeat constantly, which is required in most
    animations like **Walk** or **Run**. If not, the animation will play once and
    never repeat:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果动画需要循环播放，请勾选**循环时间**复选框以确保这一点。这将使动画不断重复，这在大多数动画如**行走**或**跑步**中是必需的。如果不勾选，动画将只播放一次，不会重复：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_17_07_PE.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成，置信度中等](img/B21361_17_07_PE.png)'
- en: 'Figure 17.7: Looping the animation'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.7：循环动画
- en: 'Preview the clip by clicking on the bar titled for your animation (**Run**,
    in my case) at the very bottom of the **Inspector** window and click on the **Play**
    button. You can see the default Unity model in some cases, but you can see your
    own by dragging the model file to the preview window because it is important to
    check whether our models are properly configured. If the animation does not play,
    you will need to check whether the **Animation Type** setting matches the animation
    file:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**检查器**窗口底部为您的动画命名的栏（在我的例子中是**跑**），然后点击**播放**按钮来预览片段。在某些情况下，您可以看到默认的 Unity
    模型，但您可以通过将模型文件拖动到预览窗口中来查看自己的模型，因为检查我们的模型是否正确配置非常重要。如果动画无法播放，您需要检查**动画类型**设置是否与动画文件匹配：
- en: '![](img/B21361_17_08_PE.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_08_PE.png)'
- en: 'Figure 17.8: Animation preview'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.8：动画预览
- en: 'Open the animation asset (the FBX) by clicking the arrow on its left, and check
    the sub-assets. You will see that there is an asset with the same title as your
    animation:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击左侧的箭头打开动画资产（FBX），并检查子资产。您会看到与您的动画具有相同名称的资产：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_17_09_PE.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成，置信度中等](img/B21361_17_09_PE.png)'
- en: 'Figure 17.9: Generated animation clips'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.9：生成的动画片段
- en: Remember that there are plenty of other settings aside from the **Init** frame,
    **End** frame, and **Loop Time**. The character I downloaded required other settings
    like **Root Transform** **Rotation**, **Root Transform Position**, and **Mask**
    to make it work, and the mileage may vary between character packages. If you are
    recreating an existing animation, consider copying all settings as they were or
    just use the default one. These mentioned settings are beyond the scope of the
    book, but you can always consult them in the Unity documentation at [https://docs.unity3d.com/Manual/class-AnimationClip.html](https://docs.unity3d.com/Manual/class-AnimationClip.html).
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请记住，除了**初始帧**、**结束帧**和**循环时间**之外，还有很多其他设置。我下载的角色需要其他设置，如**根变换** **旋转**、**根变换位置**和**遮罩**才能使其工作，不同角色包之间的差异可能很大。如果您正在重新创建现有的动画，请考虑复制所有设置或仅使用默认设置。这些提到的设置超出了本书的范围，但您始终可以在
    Unity 文档中查阅它们，网址为 [https://docs.unity3d.com/Manual/class-AnimationClip.html](https://docs.unity3d.com/Manual/class-AnimationClip.html)。
- en: Now that we have covered the basic configuration, let’s learn how to integrate
    animations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了基本配置，让我们学习如何集成动画。
- en: Integration using Animation Controllers
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用动画控制器进行集成
- en: When adding animations to our characters, we need to think about the flow of
    the animations, which means thinking about which animations must be played, when
    each animation must be active, and how transitions between animations should happen.
    In previous Unity versions, you needed to code that manually, generating complicated
    scripts of C# code to handle complex scenarios, but now, we have **Animation Controllers**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将动画添加到角色时，我们需要考虑动画的流程，这意味着思考哪些动画必须播放，每个动画何时必须处于活动状态，以及动画之间的过渡应该如何发生。在之前的
    Unity 版本中，您需要手动编写代码来实现这一点，生成复杂的 C# 代码脚本以处理复杂场景，但现在，我们有**动画控制器**。
- en: Animation Controllers are a state machine-based asset where we can diagram the
    transition logic between animations with a visual editor called **Animator**.
    The idea is that each animation is a separate state, and our model will have several
    of them. Only one state can be active at a time, so we need to create transitions
    in order to change them, which will have conditions that must be met in order
    to trigger the transition process. Conditions are comparisons of data about the
    character to be animated, such as its velocity, whether it’s shooting or crouched,
    and so on.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 动画控制器是基于状态机的资产，我们可以使用名为**动画器**的可视编辑器来绘制动画之间的转换逻辑。想法是每个动画都是一个单独的状态，我们的模型将拥有几个这样的状态。一次只能有一个状态处于活动状态，因此我们需要创建转换来改变它们，这将具有必须满足的条件才能触发转换过程。条件是对要动画化的角色的数据进行比较，例如其速度、是否在射击或蹲下等。
- en: 'So, basically, an Animation Controller or state machine is a set of animations
    with transition rules that will dictate which animation should be active. Let’s
    start creating a simple Animation Controller by doing the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，动画控制器或状态机是一组具有转换规则的动画，它将决定哪个动画应该是活动的。让我们通过以下步骤开始创建一个简单的动画控制器：
- en: Click the **+** button under the **Project** view, click on **Animator Controller**,
    and call it `Player`. Remember to locate your asset within a folder for proper
    organization; I will call mine `Animations`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**视图下点击**+**按钮，点击**动画控制器**，并将其命名为`Player`。请记住将你的资产定位在文件夹中以进行适当的组织；我将我的命名为`Animations`。
- en: Double-click on the asset to open the **Animator** window. Don’t confuse this
    window with the **Animation** window; the **Animation** window serves to create
    new animations, but for now, we will stick with the downloaded ones. The **Animator**
    window is in charge of creating and editing the animation state machines in a
    visual way, similar to Visual Scripting.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击资产以打开**动画器**窗口。不要将此窗口与**动画**窗口混淆；**动画**窗口用于创建新动画，但到目前为止，我们将坚持使用下载的动画。**动画器**窗口负责以可视方式创建和编辑动画状态机，类似于视觉脚本。
- en: 'Search for the **Idle** animation clip of your character in the **Animations**
    folder of your characters package and drag it into the **Animator** window. In
    my case, it was called **Idle_guard_ar**. Remember to drag the sub-asset, not
    the entire file. This will create a box in the Animator Controller representing
    the animation that will be connected to the entry point of the Controller, indicating
    that the animation will be the default one because it is the first one that we
    dragged. If you don’t have an **Idle** animation, I encourage you to download
    one from the Asset Store, maybe searching in other characters’ packages. We will
    need at least one **idle** and one **walking**/**running** animation clip:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的角色包的**动画**文件夹中搜索你角色的**空闲**动画片段，并将其拖入**动画器**窗口。在我的例子中，它被命名为**Idle_guard_ar**。请记住拖动子资产，而不是整个文件。这将在动画控制器中创建一个代表动画的框，该框将连接到控制器的入口点，表示该动画将是默认的，因为它是我们首先拖动的。如果你没有**空闲**动画，我鼓励你从资产商店下载一个，也许可以在其他角色的包中搜索。我们需要至少一个**空闲**和一个**行走**/**跑步**动画片段：
- en: '![](img/B21361_17_10_PE.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_10_PE.png)'
- en: 'Figure 17.10: Dragging an animation clip from an FBX asset into an Animator
    Controller'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.10：将动画片段从FBX资产拖入动画控制器
- en: Drag the running animation in the same way, which is **Run_guard_AR** in my
    case.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以相同的方式拖动跑步动画，在我的例子中是**Run_guard_AR**。
- en: Right-click on the **Idle** animation box in the **Animator** window, select
    **Make Transition**, and left-click on the **Run** animation. This will create
    a transition between **Idle** and **Run**.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**动画器**窗口中右键单击**空闲**动画框，选择**创建转换**，然后左键单击**跑步**动画。这将创建**空闲**和**跑步**之间的转换。
- en: 'Create another transition from **Run** to **Idle** in the same way:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以相同的方式从**跑步**创建到**空闲**的另一个转换：
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_17_11_PE.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述由低置信度自动生成](img/B21361_17_11_PE.png)'
- en: 'Figure 17.11: Transitions between two animations'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.11：两个动画之间的转换
- en: 'Transitions must have conditions in order to prevent animations from swapping
    constantly, but in order to create conditions, we need data to make comparisons.
    We will add properties to our Controller, which will represent data used by the
    transitions. Later, in the *Scripting animations* section of this chapter, we
    will set that data to match the current state of our object. But for now, let’s
    create the data and test how the Controller reacts to different values. In order
    to create conditions based on properties, do the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 转换必须具有条件，以防止动画不断交换，但为了创建条件，我们需要数据来进行比较。我们将向我们的控制器添加属性，这些属性将代表转换使用的数据。稍后在本章的*脚本动画*部分，我们将设置这些数据以匹配我们对象当前的状态。但到目前为止，让我们创建数据并测试控制器对不同值的反应。为了根据属性创建条件，请执行以下操作：
- en: Click on the **Parameters** tab in the top-left part of the **Animator** window.
    If you don’t see it, click on the button that looks like an eye crossed by a line
    to display the tabs. The icon will change to an uncrossed eye.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**动画器**窗口左上角的**参数**选项卡。如果您看不到它，点击看起来像被横线穿过眼睛的按钮以显示选项卡。图标将变为未交叉的眼睛。
- en: 'Click on the **+** button and select **Float** to create a number that will
    represent the velocity of our character, naming it `Velocity`. If you missed the
    renaming part, just left-click on the variable and rename it:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**+**按钮并选择**浮点数**来创建一个将代表我们角色速度的数字，命名为`Velocity`。如果您错过了重命名部分，只需左键单击变量并重命名它：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_17_12_PE.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  描述由中等置信度自动生成](img/B21361_17_12_PE.png)'
- en: 'Figure 17.12: The Parameters tab with a float Velocity property'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.12：带有浮点速度属性的参数选项卡
- en: Click on the **Idle to Run** transition (the white line with an arrow in the
    middle) and look at the **Conditions** property in the **Inspector** window.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**怠速到运行**转换（中间带有箭头的白色线条）并查看**检查器**窗口中的**条件**属性。
- en: 'Click on the **+** button at the bottom of the list, which will create a condition
    that will rule the transition. The default setting will take the first parameter
    of our animator (in this case, it is **Velocity**) and will set the default comparer,
    in this case, **Greater**, to a value of `0`. This tells us that the transition
    will execute from **Idle** to **Run** if **Idle** is the current animation and
    the velocity of the Player is greater than `0`. I recommend you set a slightly
    higher value, such as `0.01`, to prevent any float rounding errors (a common CPU
    issue). Also, remember that the actual value of **Velocity** needs to be set manually
    via scripting, which we will do in this chapter’s *Scripting animations* section:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击列表底部的**+**按钮，这将创建一个将控制转换的条件。默认设置将取我们动画器的第一个参数（在这种情况下，它是**速度**），并将默认比较器，在这种情况下，**大于**，设置为`0`的值。这告诉我们，如果**怠速**是当前动画且玩家的速度大于`0`，则转换将从**怠速**到**运行**执行。我建议您设置一个略高的值，例如`0.01`，以防止任何浮点舍入错误（一个常见的CPU问题）。此外，请记住，**速度**的实际值需要通过脚本手动设置，我们将在本章的*脚本动画*部分进行设置：
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_17_13_PE.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  描述由低置信度自动生成](img/B21361_17_13_PE.png)'
- en: 'Figure 17.13: Condition to check whether the velocity is greater than 0.01'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.13：检查速度是否大于0.01的条件
- en: 'Do the same to the **Run** **to** **Idle** transition, but this time, change
    **Greater** to **Less** and again set the value to `0.01`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对**运行到怠速**的转换也做同样的操作，但这次，将**大于**改为**小于**，并将值设置为`0.01`：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_17_14_PE.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  描述由中等置信度自动生成](img/B21361_17_14_PE.png)'
- en: 'Figure 17.14: Condition to check whether a value is less than 0.01'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.14：检查值是否小于0.01的条件
- en: Applying the Controller to your character
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将控制器应用于您的角色
- en: 'Now that we have set up our first Animator Controller, it’s time to apply it
    to an object. In order to do that, we will need a series of components. First,
    when we have an animated character, rather than a regular Mesh Renderer, we use
    the **Skinned Mesh Renderer**. If you select your player or enemy characters and
    view their children GameObjects, you will see the Skinned Mesh Renderer in one
    or more of them:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了第一个Animator Controller，是时候将其应用到对象上了。为了做到这一点，我们需要一系列组件。首先，当我们有一个动画角色时，而不是使用常规的Mesh
    Renderer，我们使用**皮肤网格渲染器**。如果你选择你的玩家或敌人角色并查看它们的子GameObject，你将看到它们中的一个或多个有皮肤网格渲染器：
- en: '![](img/B21361_17_15_PE.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_15_PE.png)'
- en: 'Figure 17.15: A Skinned Mesh Renderer component'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.15：一个皮肤网格渲染器组件
- en: This component will be in charge of applying the bones’ movements to the mesh.
    If you search the children of the model, you will find some bones; you can try
    rotating, moving, and scaling them to see the effect, as shown in the following
    screenshot.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件将负责将骨骼的运动应用到网格上。如果你搜索模型的子项，你会找到一些骨骼；你可以尝试旋转、移动和缩放它们以查看效果，如以下屏幕截图所示。
- en: 'Bear in mind that your bone hierarchy might be different from mine if you downloaded
    another package from the Asset Store:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果你的骨骼层次结构与我的不同，如果你从Asset Store下载了另一个包：
- en: '![](img/B21361_17_16_PE.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_16_PE.png)'
- en: 'Figure 17.16: Rotating the neckbone'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.16：旋转颈骨
- en: 'The other component that we need is **Animator**, which is automatically added
    to the skinned meshes at its root GameObject. This component will be in charge
    of applying the state machine that we created in the Animator Controller if the
    animation FBX files are properly configured, as we mentioned earlier. In order
    to apply the Animator Controller, do the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要另一个组件，即**Animator**，它将自动添加到根GameObject的皮肤网格中。如果动画FBX文件配置正确，如我们之前提到的，该组件将负责应用我们在Animator
    Controller中创建的状态机。为了应用Animator Controller，请执行以下操作：
- en: Select the player in the **Hierarchy** and locate the **Animator** component
    in the root GameObject.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**中选择玩家，并在根GameObject中定位**Animator**组件。
- en: Click on the circle to the right of the **Controller** property and select the
    **Player** controller we created earlier. You can also just drag it from the **Project**
    window.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**控制器**属性右侧的圆圈，并选择我们之前创建的**Player**控制器。你也可以直接从**项目**窗口拖动它。
- en: 'Make sure that the **Avatar** property is set to the avatar inside the FBX
    model of the character (`Polyart_Mesh` being the FBX model in our example project);
    this will tell the animator that we will use that skeleton. You can identify the
    avatar asset by its icon of a person, as shown in the following screenshot. Usually,
    this property is correctly set automatically when you drag the FBX model to the
    scene:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将**Avatar**属性设置为角色FBX模型内部的头像（在我们的示例项目中，`Polyart_Mesh`是FBX模型）；这将告诉动画师我们将使用那个骨骼。你可以通过以下屏幕截图中显示的人形图标来识别头像资产。通常，当你将FBX模型拖动到场景中时，此属性会自动正确设置：
- en: '![](img/B21361_17_17_PE.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_17_PE.png)'
- en: 'Figure 17.17: Animator using the Player controller and the robot avatar'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.17：使用玩家控制器和机器人头像的Animator
- en: 'Without stopping the game, open the Animator Controller asset again by double-clicking
    it and selecting the character in the **Hierarchy** pane. By doing this, you should
    see the current state of the animation being played by that character, using a
    bar to represent the current part of the animation:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不停止游戏的情况下，通过双击它并选择**层次**面板中的角色，再次打开Animator Controller资产。通过这样做，你应该能看到该角色正在播放的动画的当前状态，使用条形图表示动画的当前部分：
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_17_18_PE.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述由低置信度自动生成](img/B21361_17_18_PE.png)'
- en: 'Figure 17.18: The Animator Controller in Play mode while an object is selected,
    showing the current animation and its progress'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.18：选择对象时Play模式下的Animator Controller，显示当前动画及其进度
- en: 'Using the **Animator** window, change the value of **Velocity** to `1.0` and
    see how the transition will execute. Feel free to disable the **WaveSpawners**
    to test this, given they will probably kill the player before we can safely do
    so:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**Animator**窗口，将**速度**的值更改为`1.0`并查看过渡将如何执行。如果你愿意，可以禁用**WaveSpawners**来测试这个，因为它们可能会在我们安全这样做之前杀死玩家：
- en: '![](img/B21361_17_19_PE.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_19_PE.png)'
- en: 'Figure 17.19: Setting the velocity of the Controller to trigger a transition'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.19：设置控制器的速度以触发过渡
- en: Depending on how the **Run** animation was set, your character might start to
    move instead of executing the animation in place. This is caused by root motion,
    a feature that will move the character based on the animation movement. Sometimes,
    this is useful, but due to the fact that we will fully move our character using
    scripting, we want that feature to be turned off. You can do that by unchecking
    the **Apply Root Motion** checkbox in the **Animator** component of the **Character**
    object, as seen in *Figure 17.17*.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据如何设置**运行**动画，你的角色可能会开始移动而不是在原地执行动画。这是由根运动引起的，这是一个基于动画运动移动角色的功能。有时，这很有用，但由于我们将完全通过脚本移动我们的角色，我们希望该功能被关闭。你可以通过在**角色**对象的**动画器**组件中取消选中**应用根运动**复选框来实现，如图*图17.17*所示。
- en: 'You will also notice a delay between changing the **Velocity** value and the
    start of the animation transition. That’s because, by default, Unity will wait
    for the original animation to end before executing a transition, but in this scenario,
    we don’t want that. We need the transition to start immediately. In order to do
    this, select each transition of the Controller, and in the **Inspector** window,
    uncheck the **Has Exit Time** checkbox. When this property is checked, a hidden
    condition for the transition to execute is waiting for the animation to end. But
    with this unchecked, the transition can execute at any moment during the animation,
    which we want, given that we don’t want any delay between the player being idle
    and running:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也会注意到在更改**速度**值和动画过渡开始之间有一个延迟。这是因为默认情况下，Unity会在执行过渡之前等待原始动画结束，但在这个场景中，我们不想这样。我们需要过渡立即开始。为了做到这一点，选择每个过渡的控制器，并在**检查器**窗口中取消选中**具有退出时间**复选框。当此属性被选中时，过渡执行的一个隐藏条件是等待动画结束。但取消选中后，过渡可以在动画的任何时刻执行，这正是我们想要的，因为我们不希望在玩家空闲和跑步之间有任何延迟：
- en: '![A screenshot of a computer  Description automatically generated](img/B21361_17_20_PE.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成](img/B21361_17_20_PE.png)'
- en: 'Figure 17.20: Disabling the Has Exit Time checkbox to execute the transition
    immediately'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.20：取消选中“具有退出时间”复选框以立即执行过渡
- en: You can start dragging other animations into the Controller and create complex
    animation logic, such as adding jump, fall, or crouched animations. I invite you
    to try other parameter types, such as a Boolean, that use checkboxes instead of
    numbers. Also, as you develop your game further, your Controller will grow in
    the number of animations it can handle. To manage that, there are other features
    worth researching, such as **Blend Trees** and sub-state machines, but that’s
    beyond the scope of this book.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其他动画拖动到控制器中，并创建复杂的动画逻辑，例如添加跳跃、跌倒或蹲下动画。我邀请你尝试其他参数类型，例如布尔值，它使用复选框而不是数字。此外，随着你游戏的进一步开发，你的控制器可以处理的动画数量将会增加。为了管理这一点，有一些其他值得研究的功能，例如**混合树**和子状态机，但这超出了本书的范围。
- en: In this section, we learned how to integrate animation clips into our characters
    through Animator Controllers. We added all the required animations and created
    the necessary transitions between them to react to the game circumstances, like
    the character velocity changes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何通过Animator Controllers将动画剪辑集成到我们的角色中。我们添加了所有必要的动画，并创建了它们之间的必要过渡，以应对游戏情况，如角色速度变化。
- en: Now that we have integrated the idle and run animations, let’s integrate the
    shoot animation, which requires us to use **Avatar Masks**.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经集成了空闲和跑步动画，让我们集成射击动画，这需要我们使用**Avatar Masks**。
- en: Using Avatar Masks
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Avatar Masks
- en: Unity offers a powerful feature known as Avatar Masks, which allows for selective
    animation of character parts. This feature is particularly useful in complex scenarios
    like the one we’re about to explore.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了一个名为Avatar Masks的强大功能，它允许对角色部分进行选择性动画。这个功能在即将探索的复杂场景中特别有用。
- en: 'At first, this case seems as simple as dragging a shoot animation and making
    transitions that use the `Shooting` Boolean parameter as a condition. Consider,
    however, that we can shoot while walking and while running, so that leads to two
    shooting animations: **Walking Shooting** and **Idle Shooting**. If you follow
    this logic, you can think of shooting while falling, jumping, etc., which leads
    to a greater number of animation combinations. Imagine having different shooting
    animations for different weapons! Luckily, we have a better solution: a way to
    combine several animations using Avatar Masks. **Avatar Masks** in Unity are tools
    that allow selective animation of specific parts of a character’s body, enabling
    precise control over complex animations within the Animator Controller.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这个案例看起来就像拖动射击动画并使用`Shooting`布尔参数作为条件来创建转换那样简单。然而，考虑到我们可以在行走和奔跑时射击，这导致有两个射击动画：**行走射击**和**空闲射击**。如果您遵循这个逻辑，您可以考虑在跌倒、跳跃等情况下射击，这将导致更多的动画组合。想象一下为不同武器拥有不同的射击动画！幸运的是，我们有一个更好的解决方案：使用Avatar
    Masks结合多个动画的方法。在Unity中，**Avatar Masks**是允许选择性地对角色身体特定部分进行动画的工具，使得在Animator Controller中可以精确控制复杂的动画。
- en: The animation state machine we created in the Animator Controller is what is
    called a **layer**, and an Animator Controller can have several layers. This means
    that we can have more than one state machine in an Animator Controller. There
    are several reasons to use this, but the common one is to combine layers with
    Avatar Masks, an asset that allows us to make a specific Animator Controller layer
    or state machine to affect certain bones, so we can set different state machines
    for different parts of the body.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在Animator Controller中创建的动画状态机被称为**层**，一个Animator Controller可以有多个层。这意味着我们可以在Animator
    Controller中拥有多个状态机。使用这种方法有几个原因，但常见的一个是将层与Avatar Masks结合，这是一个允许我们使特定的Animator Controller层或状态机影响某些骨骼的资产，因此我们可以为身体的不同部分设置不同的状态机。
- en: 'We can use this to solve the shooting scenario we discussed previously, splitting
    our player animation logic into two parts: the upper part of the body and the
    lower part. The idea is that the lower part will switch between idle and running
    animations, while the upper part can switch between idle, running, and shooting.
    This allows us to have scenarios where the lower part is running while the upper
    part is shooting or the lower part is idle and the upper part is as well, or any
    combination we can imagine.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用这个来解决之前讨论的射击场景，将我们的玩家动画逻辑分成两部分：身体的上半部分和下半部分。想法是下半部分将在空闲和奔跑动画之间切换，而上半部分可以在空闲、奔跑和射击之间切换。这允许我们拥有下半部分在奔跑而上半部分在射击，或者下半部分空闲而上半部分也空闲，或者任何我们可以想象到的组合。
- en: 'Let’s start by creating the second layer by doing the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下步骤开始创建第二个层：
- en: Download a shooting animation from the internet or the Asset Store if you don’t
    have one already. In our case, we already have several shooting animations, and
    we are going to pick the one called `Idle_Shoot_ar`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有，可以从互联网或Asset Store下载射击动画。在我们的例子中，我们已经有几个射击动画，我们将选择名为`Idle_Shoot_ar`的动画。
- en: 'In the Animator Controller, do a single click in **Base Layer** and rename
    it **LowerBody** for organization purposes. If you don’t see the layers list,
    click the **Layers** button at the top-left part of the **Animator** window:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Animator Controller中，在**基础层**上单击一次，为了组织目的将其重命名为**LowerBody**。如果您看不到层列表，请点击**Animator**窗口右上角的**层**按钮：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_17_21_PE.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成，置信度中等](img/B21361_17_21_PE.png)'
- en: 'Figure 17.21: Renaming the base layer'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.21：重命名基础层
- en: Add a second layer to the Controller using the **+** button and rename it `UpperBody`.
    This one will handle the upper body animations.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**+**按钮向控制器添加第二个层，并将其重命名为`UpperBody`。这个层将处理上半身的动画。
- en: Select the layer and add the **Idle**, **Run**, and **Shoot** animations to
    it, connecting the states with transitions. Remember to uncheck **Has Exit Time**
    in each transition. With this, the upper body has the same animations as the lower
    one, but also the shooting one.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择该层，并向其添加**Idle**、**Run**和**Shoot**动画，通过转换连接状态。请记住在每个转换中取消选中**Has Exit Time**。这样，上半身就有与下半身相同的动画，还有射击动画。
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_17_22_PE.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成，置信度中等](img/B21361_17_22_PE.png)'
- en: 'Figure 17.22: UpperBody state machine'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.22：UpperBody 状态机
- en: Add the same transition logic between **Idle** and **Run** used before, using
    **Velocity** as the parameter for the conditions, as before.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前在 **Idle** 和 **Run** 之间使用的相同转换逻辑，使用 **Velocity** 作为条件参数，如之前所述。
- en: 'For the shooting transitions, create a Boolean parameter called **Shooting**:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于射击转换，创建一个名为 **Shooting** 的布尔参数：
- en: '![A picture containing text, screenshot, font, number  Description automatically
    generated](img/B21361_17_23_PE.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、数字的图片，自动生成描述](img/B21361_17_23_PE.png)'
- en: 'Figure 17.23: Shooting Boolean'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.23：射击布尔值
- en: Make both transitions to shooting (**Idle** to **Shoot** and **Run** to **Shoot**)
    execute when the **Shooting** Boolean is **true**.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 **Shooting** 布尔值为 **true** 时，执行两种射击转换（**Idle** 到 **Shoot** 和 **Run** 到 **Shoot**）。
- en: 'Make the return transition from **Shoot** to **Idle** when the **Shooting**
    Boolean is **false**, and **Velocity** is less than `0.01`, and the return from
    **Shoot** to **Run** when **Shooting** is **true**, and **Velocity** is greater
    than `0.01`:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 **Shooting** 布尔值为 **false** 且 **Velocity** 小于 `0.01` 时，从 **Shoot** 返回到 **Idle**，当
    **Shooting** 为 **true** 且 **Velocity** 大于 `0.01` 时，从 **Shoot** 返回到 **Run**：
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_17_24_PE.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图，自动生成描述，置信度低](img/B21361_17_24_PE.png)'
- en: 'Figure 17.24: The Shoot to Idle transition at the top, the Shoot to Run transition
    in the middle, and both the Idle to Shoot and Run to Shoot transitions at the
    bottom'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.24：顶部为射击到空闲状态的转换，中间为射击到运行状态的转换，底部为空闲到射击和运行到射击的两种转换
- en: 'Now that we have the layers created, let’s apply the Avatar Masks to them:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了层，让我们将这些 Avatar Masks 应用到它们上：
- en: Create an Avatar Mask using the **+** button in the **Project View**, and name
    the first one `UpperBodyMask`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **Project View** 中的 **+** 按钮创建一个 Avatar Mask，并将其命名为 `UpperBodyMask`。
- en: Select the `UpperBodyMask` asset in the **Inspector** and click the arrow on
    the left where it says **Humanoid** to expand this section.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Inspector** 中选择 `UpperBodyMask` 资产，并点击左侧显示 **Humanoid** 的箭头以展开此部分。
- en: 'Click the lower parts of the body displayed in the **Inspector** until they
    become red:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Inspector** 中点击显示的身体下半部分，直到它们变成红色：
- en: '![](img/B21361_17_25_PE.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_25_PE.png)'
- en: 'Figure 17.25: UpperBodyMask asset configs'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.25：UpperBodyMask 资产配置
- en: In the Animator Controller, select the **UpperBody** layer and click on the
    gear icon to its right to display some options.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Animator Controller 中，选择 **UpperBody** 层，并点击其右侧的齿轮图标以显示一些选项。
- en: Click on the circle at the right of the **Mask** property and select the **UpperBodyMask**
    asset in the window that appears.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Mask** 属性右侧的圆圈，并在出现的窗口中选择 **UpperBodyMask** 资产。
- en: 'Click again at the wheel of the **UpperBody** layer and set its **Weight**
    to `1`. Since the two layers affect different parts of the body, both of them
    have the same priority. In scenarios where two layers affect the same bones, the
    weight is used to calculate which one has more influence:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击 **UpperBody** 层的轮子，并将其 **Weight** 设置为 `1`。由于两个层影响身体的不同部分，它们具有相同的优先级。在两个层影响相同骨骼的情况下，权重用于计算哪个层有更大的影响：
- en: '![](img/B21361_17_26_PE.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_26_PE.png)'
- en: 'Figure 17.26: Setting the Weight and the Mask of a layer'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.26：设置层的权重和遮罩
- en: Click again on the wheel and observe how the **Blending** parameter is set to
    **Override**, meaning that the bones that this layer affects (driven by the Avatar
    Mask) will override whatever animation the base layer has—the base layer, in this
    case, being **LowerBody**. That’s how this layer takes ownership of the upper
    part of the body.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击轮子，观察 **Blending** 参数是否设置为 **Override**，这意味着此层影响的骨骼（由 Avatar Mask 驱动）将覆盖基础层（在这种情况下为
    **LowerBody**）的任何动画。这就是此层如何接管身体上半部分的原因。
- en: Test this again, changing the values of the parameters while in **Play** mode.
    For example, try checking **Shooting** and then setting **Velocity** to `1` and
    then to `0` to finally uncheck **Shooting** and see how the transitions execute.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Play** 模式下测试此操作，同时更改参数的值。例如，尝试勾选 **Shooting**，然后将 **Velocity** 设置为 `1`，然后设置为
    `0`，最后取消勾选 **Shooting**，看看转换是如何执行的。
- en: 'You might notice that our character might not be pointing in the right direction
    when shooting. This is because the orientation of the character is modified for
    this **Shoot** animation compared to **Idle** and **Run**, but the **Base Layer**
    still has ownership of that. We can make the **UpperBodyMask** control the orientation
    by clicking the circle at the bottom of the human figure in the **Humanoid** section
    of the Avatar Mask until it becomes green:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能会注意到，当我们的角色射击时，可能不会指向正确的方向。这是因为与**Idle**和**Run**动画相比，角色的方向被修改了，但**Base Layer**仍然拥有这个控制权。我们可以通过点击**Avatar
    Mask**中**Humanoid**部分的人形图底部的圆圈来让**UpperBodyMask**控制方向，直到它变成绿色：
- en: '![A picture containing footwear, cartoon, art  Description automatically generated](img/B21361_17_27_PE.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![包含鞋类、卡通、艺术作品的图片  自动生成的描述](img/B21361_17_27_PE.png)'
- en: 'Figure 17.27: Giving the mask authority over the player orientation'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.27：赋予掩模对玩家方向的权限
- en: The issue here is that you will now see the character moving the feet sideways
    when running and shooting. There’s no easy solution here other than to modify
    the original animations. In this case, this character has **Idle**, **Idle Shooting**,
    **Run**, and **Run Shooting** animations, so it clearly has been created without
    having Avatar Masks in mind instead of just having all possible animation combinations.
    An alternative is to find another package that works better with Avatar Masks.
    For learning purposes, we will stick with this, but note that Avatar Masks are
    not a must; you might be good to go just using all possible animation permutations
    in a single Animator Controller state machine with all the needed transitions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，你现在会看到角色在跑步和射击时将脚向侧面移动。除了修改原始动画外，这里没有简单的解决方案。在这种情况下，这个角色有**Idle**、**Idle
    Shooting**、**Run**和**Run Shooting**动画，所以很明显它是在没有考虑到**Avatar Masks**的情况下创建的，而不是仅仅考虑所有可能的动画组合。一个替代方案是寻找另一个与**Avatar
    Masks**配合得更好的包。为了学习目的，我们将坚持使用这个方案，但请注意，**Avatar Masks**不是必需的；你可能只需要使用单个Animator
    Controller状态机中的所有可能的动画排列，并添加所有需要的转换，就可以很好地进行。
- en: 'Another issue you might notice when firing when the **Shoot** animation is
    playing is that the muzzle effect will stay in the original position of the weapon.
    Since the weapon mesh is affected by the skinning animation but not its **Transform**
    position, the muzzle cannot follow it. In order to solve this, you can reparent
    the **Muzzle Effect** to one of the bones of the weapons—in this case, the GameObject
    called **Trigger_Right**, one of the children of the **Hips** GameObject. Not
    all animations will have bones for the weapons, so this is one of the possible
    scenarios you could face:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当**Shoot**动画正在播放时，你可能会注意到另一个问题是，炮口效果将保持在武器的原始位置。由于武器网格受到皮肤动画的影响，但不受其**Transform**位置的影响，炮口无法跟随它。为了解决这个问题，你可以将**Muzzle
    Effect**重新分配到武器的一个骨骼上——在这个例子中，是**Hips** GameObject的一个子对象**Trigger_Right**。并非所有动画都会有武器的骨骼，所以这是你可能会遇到的可能场景之一：
- en: '![](img/B21361_17_28_PE.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![包含鞋类、卡通、艺术作品的图片  自动生成的描述](img/B21361_17_28_PE.png)'
- en: 'Figure 17.28: Reparenting the Muzzle Effect to one of the weapon’s bones'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.28：将炮口效果重新分配到武器的一个骨骼上
- en: Remember to apply the same changes we made to our player to the enemy, which
    means adding and setting the Player Animator Controller to its **Animator** component
    and changing the `Muzzle effect` parent.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将我们对玩家所做的相同更改应用到敌人身上，这意味着向敌人的**Animator**组件添加并设置Player Animator Controller，并更改`Muzzle
    effect`的父级。
- en: With our Animator Controller now set up with Avatar Masks, the next step is
    to bring these animations to life in our game environment through scripting.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了Animator Controller并使用Avatar Masks，下一步是通过脚本将这些动画在我们的游戏环境中激活。
- en: Scripting animations
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本动画
- en: Scripting is crucial in bringing our animations in sync with gameplay. Here,
    we’ll script our animations to respond dynamically to player actions, making our
    game more immersive and responsive.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本编写对于将我们的动画与游戏玩法同步至关重要。在这里，我们将编写脚本，使我们的动画能够动态地响应玩家动作，使我们的游戏更加沉浸和响应。
- en: 'With our player’s Animator Controller ready, it is time to do some scripting
    to make these parameters be affected by the actual behavior of the player and
    match the player’s. In this section, we will do the following to achieve this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的玩家Animator Controller准备就绪时，是时候进行一些脚本编写，使这些参数受到玩家实际行为的影响，并与玩家的行为相匹配。在本节中，我们将执行以下操作以实现这一点：
- en: Script shooting animations
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本射击动画
- en: Script movement animations
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本移动动画
- en: Let’s start making our characters execute the **Shoot** animation when necessary.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始制作我们的角色在必要时执行**射击**动画。
- en: Scripting player shooting animations
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写玩家射击动画脚本
- en: So far, we have created a behavior to shoot each time we press a key, but the
    animation is prepared for sustained fire. We can make our `PlayerShooting` script
    shoot a bullet every X number of seconds while we keep the **Fire** key pressed
    to match the animation instead of having to press the key repeatedly.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个每次按下键时射击的行为，但动画是为持续开火准备的。我们可以让我们的`PlayerShooting`脚本在保持**开火**键按下时，每X秒发射一颗子弹，以匹配动画，而不是需要反复按下键。
- en: 'By adding a `fireRate` variable, we control the shooting speed, ensuring it
    aligns with our animation timing. Let’s see how to do this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加一个`fireRate`变量，我们控制射击速度，确保它与我们的动画时间同步。让我们看看如何做到这一点：
- en: In the **PlayerShooting** script, add a public float field called `fireRate`,
    which will measure the seconds between bullet spawns. Remember to set this value
    in the **Inspector** of the player.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**PlayerShooting**脚本中，添加一个名为`fireRate`的公共float字段，它将测量子弹生成的秒数。请记住在玩家的**检查器**中设置此值。
- en: 'Change the **OnFire** method to the code seen in *Figure 17.29*. The idea is
    to start a repeating action when we press the key and stop it when we release
    the key. We are using **InvokeRepeating** to repeatedly execute a function called
    **Shoot,** which we will be creating in the next step. The rate of execution will
    be controlled by the **fireRate** field we created in *step 1*:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**OnFire**方法更改为*图17.29*中看到的代码。我们的想法是在我们按下键时启动重复动作，在我们释放键时停止它。我们正在使用**InvokeRepeating**来重复执行一个名为**Shoot**的函数，我们将在下一步创建它。执行速率将由我们在*步骤1*中创建的**fireRate**字段控制：
- en: '![A picture containing text, screenshot, font, line  Description automatically
    generated](img/B21361_17_29_PE.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、行描述的图片，自动生成](img/B21361_17_29_PE.png)'
- en: 'Figure 17.29: OnFire changes needed for sustained fire'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.29：持续开火所需的OnFire更改
- en: 'Add the **Shoot** method, as seen in *Figure 17.30* , to our **PlayerShooting**
    script. This is essentially the same code we had before in the **OnFire** method
    but separated into a function, so we can execute it several times with the **InvokeRepeating**
    function:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*图17.30*中看到的**Shoot**方法添加到我们的**PlayerShooting**脚本中。这基本上是我们之前在**OnFire**方法中拥有的相同代码，但现在被分离成一个函数，这样我们就可以通过**InvokeRepeating**函数多次执行它：
- en: '![](img/B21361_17_30_PE.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_17_30_PE.png)'
- en: 'Figure 17.30: OnFire changes needed for sustained fire'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.30：持续开火所需的OnFire更改
- en: 'If you try these changes now, you will notice the bullets will never stop shooting
    once we click the **Fire** button. Even worse, as we press repeatedly, more and
    more bullets will be shot. With some debugging or educated guessing, you might
    figure out that the **CancelInvoke** method is not being executed. The reason
    behind this is that the **Fire** input mapping is not configured by default to
    inform us about the release of keys, just when they were pressed. Luckily, the
    solution is pretty simple:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在尝试这些更改，你会注意到一旦我们点击**开火**按钮，子弹将永远不会停止发射。更糟糕的是，随着我们不断按下，发射的子弹会越来越多。通过一些调试或合理的猜测，你可能发现**CancelInvoke**方法没有被执行。背后的原因是**Fire**输入映射默认没有配置来通知我们关于键的释放，而是在它们被按下时。幸运的是，解决方案相当简单：
- en: 'Double-click the **SuperShooter** inputs asset, the one we created in *Chapter
    6*, *Dynamic Motion: Implementing Movement and Spawning*, that contains all the
    inputs our game supports.'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**SuperShooter**输入资产，这是我们*第6章*中创建的，它包含我们游戏支持的所有输入。
- en: Select the **Fire** action in the **Actions** list (the middle column).
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**动作**列表（中间列）中选择**开火**动作。
- en: Click the **+** button at the right of the **Interactions** section and click
    **Press**.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**交互**部分右侧的**+**按钮，然后点击**按下**。
- en: 'Set the **Trigger Behavior** of the **Press** section to **Press And Release**:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**按下**部分的**触发行为**设置为**按下并释放**：
- en: '![](img/B21361_17_31_PE.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_17_31_PE.png)'
- en: 'Figure 17.31: OnFire changes needed for sustained fire'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.31：持续开火所需的OnFire更改
- en: With this, we have configured the input to tell us not only when the key was
    pressed but also when it was released, making our **CancelInvoke** method execute
    now.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经配置了输入，不仅告诉我们何时按下键，还告诉我们何时释放键，使得我们的**CancelInvoke**方法现在执行。
- en: 'Now that we have our constant fire behavior, we can do the following to make
    the animation reflect this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了持续开火的行为，我们可以做以下操作来使动画反映这一点：
- en: 'Add a reference to `Animator` using **GetComponent** in **Awake** and cache
    it in a field, as seen in *Figure 17.32*:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Awake**中使用**GetComponent**添加对`Animator`的引用，并将其缓存在一个字段中，如图17.32所示：
- en: '![](img/B21361_17_32_PE.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_32_PE.png)'
- en: 'Figure 17.32: Caching the Animator reference'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.32：缓存Animator引用
- en: 'Add the line `animator.SetBool(“Shooting”, value.isPressed);` at the beginning
    of the **OnFire** method:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**OnFire**方法的开头添加行`animator.SetBool(“Shooting”, value.isPressed);`：
- en: '![](img/B21361_17_33_PE.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_33_PE.png)'
- en: 'Figure 17.33: Setting the Shooting animation parameter to reflect input'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.33：设置射击动画参数以反映输入
- en: The idea behind this change is to make sure the **Shooting** animation parameter
    reflects the state of the fire key, meaning that the `Shoot` animation will play
    as long as the **Fire** button is pressed and will stop when we release it.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种更改背后的想法是确保**Shooting**动画参数反映了火键的状态，这意味着只要按下**Fire**按钮，就会播放**Shoot**动画，当我们释放它时，动画会停止。
- en: 'One thing you will notice is that the bullets are still being shot from the
    player’s chest because our **ShootPoint** GameObject, the one that defines the
    shooting position, is not positioned in front of the weapon. Just re-parent the
    **ShootPoint** to the weapon bone (**Trigger_Right** in our case) and position
    it to be in front of the weapon. Remember to make the forward vector (the blue
    arrow in the **Scene** view) point along the weapon:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，子弹仍然是从玩家的胸部发射出来的，因为我们定义射击位置的**ShootPoint**GameObject没有位于武器的前面。只需将**ShootPoint**重新设置为武器的骨骼（在我们的例子中是**Trigger_Right**）并将其定位在武器前面。记住，让前向向量（**Scene**视图中蓝色的箭头）沿着武器方向：
- en: '![](img/B21361_17_34_PE.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_34_PE.png)'
- en: 'Figure 17.34: Adapting the ShootPoint to follow the animation'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.34：使ShootPoint跟随动画
- en: 'For the Visual Scripting version, in order to get the bullet to be shot constantly,
    you should change the **Input** nodes of **PlayerShooting** like in *Figure 17.35*:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于视觉脚本版本，为了使子弹能够持续发射，你应该像*图17.35*中那样更改**PlayerShooting**的**Input**节点：
- en: '![A screenshot of a computer program  Description automatically generated with
    low confidence](img/B21361_17_35_PE.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序截图 自动生成，置信度低](img/B21361_17_35_PE.png)'
- en: 'Figure 17.35: Creating a shoot loop'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.35：创建射击循环
- en: As you can see, we used a new node called **Timer**. The idea of a **Timer**
    is similar to the **Wait For Seconds** node we used before because it allows us
    to delay the execution of one action. One of the main differences is that it allows
    us to cancel the timer before it executes again, meaning we can start the timer
    when we press the **Fire** key and stop it when we release it. We did that by
    connecting the **InputSystemEventButton** node that has the **OnPressed** mode
    to the **Start** pin of the **Timer** and the one with the **OnReleased** mode
    to the **Pause** pin. Also, we created a new variable called **fireRate** and
    connected it to the **Duration** pin of the **Timer**, so we need to specify how
    much time the **Timer** will wait before instantiating our bullets. See how we
    connected the **Completed** pin of the **Timer** to the **If** node that checks
    if we have enough bullets to instantiate; we used to connect to the input node
    here before.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用了一个新的节点叫做**Timer**。**Timer**的想法与之前我们使用的**Wait For Seconds**节点类似，因为它允许我们延迟执行一个动作。主要区别在于它允许我们在再次执行之前取消定时器，这意味着我们可以在按下**Fire**键时启动定时器，并在释放它时停止。我们通过将具有**OnPressed**模式的**InputSystemEventButton**节点连接到**Timer**的**Start**引脚，将具有**OnReleased**模式的节点连接到**Pause**引脚来实现这一点。我们还创建了一个名为**fireRate**的新变量，并将其连接到**Timer**的**Duration**引脚，因此我们需要指定定时器在实例化子弹之前将等待多长时间。看看我们是如何将**Timer**的**Completed**引脚连接到检查我们是否有足够子弹实例化的**If**节点的；我们之前在这里连接到输入节点。
- en: 'One little missing detail here is that when we press a key, time will pass
    (**fireRate**), and then a bullet will be instantiated, but then nothing else.
    We need to connect the end of the **Bullet** shoot sequence (the **AudioSource:
    Play** node in this case) of nodes again to the **Start** pin of the **Timer**
    to create a spawn loop. That loop will be interrupted when we release the key
    to prevent it from being executed forever:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '这里有一点小细节需要注意，当我们按下键时，时间会过去（**fireRate**），然后实例化一颗子弹，但之后就没有其他动作了。我们需要再次将**Bullet**射击序列的末尾（在这种情况下是**AudioSource:
    Play**节点）连接到**Timer**的**Start**引脚，以创建一个生成循环。当我们释放键时，这个循环会被中断，以防止它无限执行：'
- en: '![](img/B21361_17_36_P.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_36_P.png)'
- en: 'Figure 17.36: Completing the shoot loop'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.36：完成射击循环
- en: 'Finally, we need to add the proper `Animator: SetBool(Name, Value)` node to
    the Input nodes to turn on and off the Boolean and trigger the animation:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，我们需要向输入节点添加适当的`Animator: SetBool(Name, Value)`节点来打开和关闭布尔值并触发动画：'
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_17_37_PE.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，中等置信度自动生成](img/B21361_17_37_PE.png)'
- en: 'Figure 17.37: Executing the Shoot animation'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.37：执行射击动画
- en: 'Now that we have configured the player’s shooting animations, let’s apply similar
    principles to script the enemy’s animations for consistency in gameplay mechanics:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了玩家的射击动画，让我们应用类似的原则来脚本化敌人的动画，以保持游戏机制的一致性：
- en: 'Cache a reference to the parent animator in the **EnemyFSM** script using **GetComponentInParent**
    as we did with the **NavMeshAgent**:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**GetComponentInParent**在**EnemyFSM**脚本中缓存父动画器的引用，就像我们处理**NavMeshAgent**时做的那样：
- en: '![A picture containing text, screenshot, font, line  Description automatically
    generated](img/B21361_17_38_PE.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、行描述的图片，自动生成](img/B21361_17_38_PE.png)'
- en: 'Figure 17.38: Accessing the parent’s Animator reference'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.38：访问父的Animator引用
- en: 'Turn on the **Shooting** animator parameter inside the **Shoot** function to
    make sure that every time we shoot, that parameter is set to **true** (checked):'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Shoot**函数内部打开**Shooting**动画器参数，以确保每次射击时该参数都设置为**true**（已检查）：
- en: '![A close-up of a logo  Description automatically generated with low confidence](img/B21361_17_39_PE.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![标志的特写，低置信度自动生成](img/B21361_17_39_PE.png)'
- en: 'Figure 17.39: Turning on the shooting animation'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.39：打开射击动画
- en: 'Turn off the `Shooting` parameter in all non-shooting states, such as **GoToBase**
    and **ChasePlayer**:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有非射击状态中关闭`Shooting`参数，例如**GoToBase**和**ChasePlayer**：
- en: '![](img/B21361_17_40_PE.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_17_40_PE.png)'
- en: 'Figure 17.40: Turning off the shooting animation'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.40：关闭射击动画
- en: 'Regarding the Visual Scripting version, the **GoToBase** state in the **EnemyFSM**
    will look like this:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于视觉脚本版本，**EnemyFSM**中的**GoToBase**状态将如下所示：
- en: '![](img/B21361_17_41_PE.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_17_41_PE.png)'
- en: 'Figure 17.41: GoToBase state'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.41：GoToBase状态
- en: 'Note that we needed the **GetParent** node again to access the enemy’s parent
    **Transform** (the **root**), which we connected to the **Animator: SetBool**
    node in order to access the Animator in the enemy’s root. Then, the **ChasePlayer**
    state actions will look like this:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '注意，我们再次需要使用**GetParent**节点来访问敌人的父**Transform**（即**根**），我们将它与**Animator: SetBool**节点连接，以便访问敌人根中的Animator。然后，**ChasePlayer**状态的动作将如下所示：'
- en: '![](img/B21361_17_42_PE.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_17_42_PE.png)'
- en: 'Figure 17.42: ChasePlayer state'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.42：ChasePlayer状态
- en: 'Then, both the **AttackBase** and **AttackPlayer** initial actions will look
    like this:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，**AttackBase**和**AttackPlayer**初始动作将如下所示：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_17_43_PE.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，中等置信度自动生成](img/B21361_17_43_PE.png)'
- en: 'Figure 17.43: AttackBase state'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.43：AttackBase状态
- en: With this, both our player and enemies have a constant shooting behavior and
    a **Shoot** animation to reflect this. Now, let’s handle the movement animations
    for both.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的玩家和敌人都有恒定的射击行为和**Shoot**动画来反映这一点。现在，让我们处理两者的移动动画。
- en: Scripting movement animations
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本化移动动画
- en: Scripting movement animations is essential to translating the physical movement
    of game characters into visual animations. Let’s see how we can dynamically adjust
    our character’s velocity in the game.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本化移动动画是将游戏角色的物理运动转换为视觉动画的关键。让我们看看我们如何动态调整游戏中的角色速度。
- en: For the Animator Controller’s `Velocity` parameter, we can detect the magnitude
    of the velocity vector of the Rigidbody, the velocity in meters per second, and
    set that as the current value. Separating this script enhances modularity and
    allows for easier reuse in different game scenarios.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Animator Controller的`Velocity`参数，我们可以检测Rigidbody的速度向量的幅度，即每秒米的速度，并将其设置为当前值。将此脚本分离出来增强了模块化，并允许在不同游戏场景中更容易地重用。
- en: 'So, we need to create a script such as the one in the following image, which
    just connects the `Rigidbody` component’s velocity with the animator’s `Velocity`
    parameter and adds it to the Player GameObject:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要创建一个如图所示的脚本，该脚本仅将`Rigidbody`组件的速度与动画器的`Velocity`参数连接，并将其添加到Player GameObject中：
- en: '![](img/B21361_17_44_PE.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_17_44_PE.png)'
- en: 'Figure 17.44: Setting VelocityAnimator variables'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.44：设置VelocityAnimator变量
- en: 'And regarding the Visual Scripting version, this is what it would look like:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 关于视觉脚本版本，它看起来是这样的：
- en: '![](img/B21361_17_45_PE.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_45_PE.png)'
- en: 'Figure 17.45: Setting Velocity Animator variables in Visual Scripting'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.45：在视觉脚本中设置速度动画器变量
- en: You may need to increase the `0.01` transitions threshold used so far in the
    conditions of the transitions of the Animator Controller because **Rigidbody**
    keeps moving after releasing the keys. Using `1` worked perfectly for me. Another
    option would be to increase the drag and the velocity of the player to make the
    character stop faster. Pick whatever method works best for you. Remember the transitions
    of both layers (**UpperBody** and **LowerBody**).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要增加Animator Controller过渡条件中迄今为止使用的`0.01`过渡阈值，因为**Rigidbody**在释放按键后仍然会继续移动。对我来说，使用`1`效果完美。另一个选择是增加玩家的阻力和速度，使角色更快地停止。选择对你来说效果最好的方法。记住两个层（**UpperBody**和**LowerBody**）的过渡。
- en: 'Now, we can add the movement animations to the enemy. Create and add a script
    to the enemy prefab called **NavMeshAnimator**, which will take the current velocity
    of its **NavMeshAgent** and set it to the Animator Controller. This will work
    similarly to the **VelocityAnimator** script, but this time, checking the velocity
    of the **NavMeshAgent**. We didn’t use **VelocityAnimator** here because our AI
    doesn’t use **Rigidbody** to move, so it won’t work:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为敌人添加移动动画。为敌人预制体创建并添加一个名为**NavMeshAnimator**的脚本，该脚本将获取其**NavMeshAgent**的当前速度并将其设置为Animator
    Controller。这将与**VelocityAnimator**脚本类似工作，但这次是检查**NavMeshAgent**的速度。我们没有使用**VelocityAnimator**，因为我们的AI不使用**Rigidbody**来移动，所以它不会工作：
- en: '![A screenshot of a computer program  Description automatically generated with
    low confidence](img/B21361_17_46_PE.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序截图，描述由低置信度自动生成](img/B21361_17_46_PE.png)'
- en: 'Figure 17.46: Connecting the NavMeshAgent to our Animator Controller'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.46：将NavMeshAgent连接到我们的Animator Controller
- en: 'The Visual Scripting version will look like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉脚本版本将看起来像这样：
- en: '![](img/B21361_17_47_PE.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_47_PE.png)'
- en: 'Figure 17.47: Setting the animator’s velocity parameter the same as our NavMeshAgent'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.47：将动画器的速度参数设置为与我们的NavMeshAgent相同
- en: Notice that we don’t need the `GetParent` node here, given that this graph is
    located at the enemy’s root object alongside the **Animator** and the **NavMeshAgent**.
    With that, we have scripted our Player and enemy animations.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于这个图位于敌人的根对象旁边，与**Animator**和**NavMeshAgent**一起，所以我们这里不需要`GetParent`节点。有了这个，我们就已经编写了玩家的动画和敌人的动画脚本。
- en: 'Sometimes, animation clips are not enough to create a believable animation,
    given they are pre-defined and they don’t adapt to the player’s surroundings.
    One example is the case of a player standing on a staircase, where the player’s
    feet should be placed at different heights, but the idle animation was probably
    designed for standing on flat ground. While you could play around blending animations
    with feet at different heights, that would be difficult to manage. Instead, you
    can mix static animations (the regular Animation package) with procedural animations,
    animations that modify the character rig via scripting. You can achieve this using
    the following Unity package: [https://docs.unity3d.com/Packages/com.unity.animation.rigging@1.0/manual/index.html](mailto:https://docs.unity3d.com/Packages/com.unity.animation.rigging@1.0/manual/index.html).'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，动画剪辑不足以创建一个可信的动画，因为它们是预定义的，并且不能适应玩家的环境。一个例子是玩家站在楼梯上，玩家的脚应该放在不同的高度，但空闲动画可能是为站在平地上设计的。虽然你可以尝试混合不同高度的脚的动画，但这很难管理。相反，你可以将静态动画（常规动画包）与过程动画混合，这些动画通过脚本修改角色绑定。你可以使用以下Unity包实现这一点：[https://docs.unity3d.com/Packages/com.unity.animation.rigging@1.0/manual/index.html](mailto:https://docs.unity3d.com/Packages/com.unity.animation.rigging@1.0/manual/index.html)。
- en: Now, we are ready to keep learning about animations using Cinemachine to create
    cutscene cameras and much more.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好继续学习使用Cinemachine创建场景相机和更多动画知识。
- en: Creating dynamic cameras with Cinemachine
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cinemachine创建动态相机
- en: Cameras are a very important subject in video games. They allow the player to
    see their surroundings and make decisions based on what they see. The game designer
    usually defines how they behave to get the exact gameplay experience they want,
    and that’s no easy task. A lot of behaviors must be layered to get the exact feeling.
    Also, for cutscenes, it is important to control the path that the camera will
    be traversing and where the camera is looking to focus the action during those
    constantly moving scenes.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 相机在视频游戏中是一个非常重要的主题。它们允许玩家看到他们的周围环境并根据他们所看到的内容做出决策。游戏设计师通常定义它们的行为以获得他们想要的精确游戏体验，这并不容易。必须分层很多行为才能获得精确的感觉。此外，对于场景镜头，控制相机将要穿越的路径以及相机在那些不断移动的场景中聚焦于何处以集中动作也非常重要。
- en: Cinemachine is Unity’s advanced suite for camera control, enabling developers
    to craft dynamic and responsive camera behaviors that enhance the gaming experience.
    In this chapter, we will use the `Cinemachine` package to create both the dynamic
    cameras that will follow the player’s movements, which we will code in *Section
    3*, *Elevating Visuals, Effects, and Audio* and also the cameras to be used during
    cutscenes.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Cinemachine是Unity的高级相机控制套件，使开发者能够制作出动态和响应式的相机行为，从而增强游戏体验。在本章中，我们将使用`Cinemachine`包来创建动态相机，这些相机将跟随玩家的移动，我们将在第3节*提升视觉效果、效果和音频*中编码，以及用于场景镜头的相机。
- en: 'In this section, we will examine the following Cinemachine concepts:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下Cinemachine概念：
- en: Creating camera behaviors
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建相机行为
- en: Creating dolly tracks
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建轨道推车
- en: Let’s start by discussing how to create a Cinemachine-controlled camera and
    configure behaviors in it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来讨论如何创建一个由Cinemachine控制的相机并配置其中的行为。
- en: Creating camera behaviors
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建相机行为
- en: Cinemachine revolutionizes camera control by offering a suite of flexible and
    intuitive behaviors, significantly simplifying the complex camera setups commonly
    seen in video games.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Cinemachine通过提供一系列灵活直观的行为，彻底革新了相机控制，显著简化了在视频游戏中常见的复杂相机设置。
- en: Cinemachine is a Unity package containing a collection of different behaviors
    that can be used in a camera, which, when properly combined, can generate all
    kinds of common camera types in video games, including following the player from
    behind, first-person cameras, top-down cameras, and so on. In order to use these
    behaviors, we need to understand the concept of brains and virtual cameras.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Cinemachine是一个Unity包，包含了一系列可用于相机的不同行为，当正确组合时，可以生成视频游戏中所有种类的常见相机类型，包括从背后跟随玩家、第一人称相机、俯视相机等等。为了使用这些行为，我们需要了解大脑和虚拟相机的概念。
- en: In Cinemachine, we will only keep one main camera, as we have done so far, and
    that camera will be controlled by virtual cameras, separated by GameObjects that
    have the aforementioned behaviors. We can have several virtual cameras and swap
    between them at will, but the active virtual camera will be the only one that
    will control our main camera. This is useful for switching cameras at different
    points of the game, such as switching between our player’s third-person camera
    and a cutscene camera. In order to control the main camera with the virtual cameras,
    it must have a **Brain** component, which will monitor all active virtual cameras
    and pick the proper position to use them.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cinemachine中，我们将只保留一个主相机，就像我们迄今为止所做的那样，而这个相机将由具有上述行为的GameObject控制的虚拟相机来控制。我们可以有多个虚拟相机，并且可以随意在它们之间切换，但活动的虚拟相机将是唯一一个将控制我们的主相机。这在游戏的不同阶段切换相机非常有用，例如在玩家的第三人称相机和场景镜头之间切换。为了用虚拟相机控制主相机，它必须有一个**Brain**组件，该组件将监控所有活动的虚拟相机并选择合适的位姿来使用它们。
- en: 'To start using Cinemachine, first, we need to check if it is installed in the
    Package Manager, as we did previously with other packages. If you don’t remember
    how to do this, just do the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Cinemachine，首先，我们需要检查它是否已安装在包管理器中，就像我们之前安装其他包时那样。如果您不记得如何操作，只需按照以下步骤进行：
- en: Go to **Window** | **Package Manager**.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**Window** | **Package Manager**。
- en: 'Ensure that the **Packages** option in the top-left part of the window is set
    to **Unity Registry**:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保窗口左上角的**Packages**选项设置为**Unity Registry**：
- en: '![](img/B21361_17_48.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_48.png)'
- en: 'Figure 17.48: The Packages filter mode'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.48：包过滤器模式
- en: Wait a moment for the left panel to populate all packages from the servers (an
    internet connection is required).
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 稍等片刻，让左侧面板从服务器填充所有包（需要互联网连接）。
- en: Look for the **Cinemachine** package from the list and select it. At the moment
    of writing this book, the latest available version is 2.9.7, but you can use newer
    versions if you prefer, always ensuring that the following steps work as expected;
    if not, you can always install the closest version to ours.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中查找 **Cinemachine** 包并选择它。在撰写本书时，最新可用的版本是 2.9.7，但如果你更喜欢，可以使用更新的版本，始终确保以下步骤按预期工作；如果不按预期工作，你始终可以安装与我们最接近的版本。
- en: If you see the **Install** button in the bottom-right corner of the screen,
    it means it is not installed. Just click that button.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你看到屏幕右下角的 **安装** 按钮，这意味着它尚未安装。只需点击该按钮。
- en: 'Now that we have it installed, we can start creating a virtual camera to follow
    the player. So far, we just simply parented the camera to the player for it to
    follow them, but now we will unparent the camera and let Cinemachine handle it
    to learn how to use this tool:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了它，我们可以开始创建一个虚拟相机来跟随玩家。到目前为止，我们只是简单地将相机连接到玩家，使其跟随他们，但现在我们将取消连接相机，让 Cinemachine
    处理它，以便学习如何使用这个工具：
- en: Select the **MainCamera** inside the player and unparent it (drag it outside
    the player) in such a way that it becomes a root object of our scene, having no
    parent at all.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在玩家内部选择 **MainCamera** 并将其取消连接（将其拖出玩家），使其成为我们场景的根对象，没有任何父对象。
- en: 'Click **GameObject | Cinemachine | Virtual Camera**. This will create a new
    object called `CM vcam1`:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **游戏对象 | Cinemachine | 虚拟相机**。这将创建一个名为 `CM vcam1` 的新对象：
- en: '![](img/B21361_17_49.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_49.png)'
- en: 'Figure 17.49: Virtual camera creation'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.49：虚拟相机创建
- en: 'If you select the **MainCamera** from the **Hierarchy** pane, you will also
    notice that a `CinemachineBrain` component has been automatically added to it,
    making our main camera follow the virtual camera. Try to move the created virtual
    camera, and you will see how the main camera follows it:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你从 **层次结构** 窗格中选择 **MainCamera**，你也会注意到一个 `CinemachineBrain` 组件已经被自动添加到它上面，使我们的主相机跟随虚拟相机。尝试移动创建的虚拟相机，你会看到主相机是如何跟随它的：
- en: '![](img/B21361_17_50.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_50.png)'
- en: 'Figure 17.50: The CinemachineBrain component'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.50：CinemachineBrain 组件
- en: 'Select the virtual camera (`CM vcam1`) and drag the character to the **Follow**
    and **Look At** properties of the **CinemachineVirtualCamera** component. This
    will make the movement and looking behaviors use that object to do their jobs:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择虚拟相机 (`CM vcam1`) 并将其拖动到 **CinemachineVirtualCamera** 组件的 **跟随** 和 **注视**
    属性。这将使移动和注视行为使用该对象来完成它们的工作：
- en: '![](img/B21361_17_51_PE.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_51_PE.png)'
- en: 'Figure 17.51: Setting the target of our camera'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.51：设置我们相机的目标
- en: 'You can see how the **Body** property of the virtual camera is set to **Transposer**,
    which will move the camera relative to the target set at the **Follow** property—in
    our case, the character. You can open the **Body** options (the arrow to its left),
    change the **Follow Offset** property, and set it to the desired distance you
    want the camera to have from the target. In my case, I used the `0`, `3`, and
    `-3` values:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以看到虚拟相机的 **Body** 属性被设置为 **Transposer**，这将使相机相对于在 **跟随** 属性中设置的目标移动——在我们的案例中，是角色。你可以打开
    **Body** 选项（左侧的箭头），更改 **跟随偏移** 属性，并将其设置为相机与目标之间的所需距离。在我的案例中，我使用了 `0`、`3` 和 `-3`
    的值：
- en: '![](img/B21361_17_52_PE.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_52_PE.png)'
- en: 'Figure 17.52: The camera following the character from behind'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.52：相机从背后跟随角色
- en: '*Figure 17.52* shows the **Game** view; you can see a small, yellow rectangle
    indicating the target position to look at the character, and it’s currently pointing
    at the pivot of the character—its feet. If you don’t see it, open the **Aim**
    section of the virtual camera in the **Inspector** by clicking the arrow to its
    left.'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*图 17.52* 展示了 **游戏** 视图；你可以看到一个小的、黄色的矩形，它指示了观察角色的目标位置，目前它指向角色的支点——其脚部。如果你看不到它，请通过点击其左侧的箭头在
    **检查器** 中打开虚拟相机的 **瞄准** 部分。'
- en: 'We can apply an offset in the **Tracked Object Offset** property of the **Aim**
    section of the virtual camera. In my case, values of `0`, `1.8`, and `0` worked
    well to make the camera look at the head instead:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在虚拟相机 **瞄准** 部分的 **跟踪对象偏移** 属性中应用一个偏移。在我的情况下，`0`、`1.8` 和 `0` 的值工作得很好，使相机看向头部：
- en: '![](img/B21361_17_53_PE.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_53_PE.png)'
- en: 'Figure 17.53: Changing the Aim offset'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.53：更改瞄准偏移
- en: As you can see, using Cinemachine is pretty simple, and, in our case, the default
    settings were mostly enough for the kind of behavior we needed. However, if you
    explore the other **Body** and **Aim** modes, you will find that you can create
    any type of camera for any type of game.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用 Cinemachine 非常简单，在我们的情况下，默认设置大多数情况下已经足够满足我们所需的行为。然而，如果你探索其他 **Body**
    和 **Aim** 模式，你会发现你可以为任何类型的游戏创建任何类型的摄像机。
- en: 'We won’t cover the other modes in this book, but I strongly recommend you look
    at the documentation for Cinemachine to check what the other modes do. To open
    the documentation, follow these steps:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在本书中介绍其他模式，但我强烈建议你查看 Cinemachine 的文档，以了解其他模式的功能。要打开文档，请按照以下步骤操作：
- en: Open the Package Manager by going to **Window** | **Package Manager**.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到 **Window** | **Package Manager** 来打开包管理器。
- en: Find **Cinemachine** in the left-hand side list. Wait a moment if it doesn’t
    show up. Remember that you need an internet connection for it to work.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧列表中找到 **Cinemachine**。如果它没有显示，请稍等片刻。请记住，你需要一个互联网连接才能使其工作。
- en: 'Once Cinemachine is selected, scroll down in the right panel until you see
    the **Documentation** link in blue. Click on it:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦选择了 Cinemachine，在右侧面板中向下滚动，直到你看到蓝色的 **Documentation** 链接。点击它：
- en: '![](img/B21361_17_54.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_54.png)'
- en: 'Figure 17.54: The Cinemachine documentation link'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.54：Cinemachine 文档链接
- en: 'You can explore the documentation using the navigation menu on the left:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用左侧的导航菜单来探索文档：
- en: '![](img/B21361_17_55_PE.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_55_PE.png)'
- en: 'Figure 17.55: The Cinemachine documentation'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.55：Cinemachine 文档
- en: As you did with Cinemachine, you can find other packages’ documentation in the
    same way. Now that we have achieved the basic camera behavior that we need, let’s
    explore how we can use Cinemachine to create a camera for our intro cutscene.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 就像使用 Cinemachine 一样，你可以以相同的方式找到其他包的文档。现在我们已经实现了所需的相机基本行为，让我们探索如何使用 Cinemachine
    为我们的开场剪辑创建一个摄像机。
- en: Creating dolly tracks
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建摇臂轨道
- en: When the player starts the level, we want a little cutscene with a pan over
    our scene and the base before entering the battle. This will require the camera
    to follow a fixed path, and that’s exactly what Cinemachine’s dolly camera does.
    It creates a path where we can attach a virtual camera so that it will follow
    it. We can set Cinemachine to move automatically through the track or follow a
    target to the closest point to the track; in our case, we will use the first option.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家开始关卡时，我们希望在进入战斗前有一个小型的场景切换，将镜头从我们的场景和基地上扫过。这需要摄像机沿着固定路径移动，这正是 Cinemachine
    的摇臂摄像机所做到的。它创建了一条路径，我们可以在这里附加一个虚拟摄像机，使其跟随路径。我们可以设置 Cinemachine 自动通过轨道或跟随目标到轨道的最近点；在我们的情况下，我们将使用第一种选项。
- en: 'In order to create a dolly camera, follow these steps:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个摇臂摄像机，请按照以下步骤操作：
- en: 'Let’s start creating the track with a cart, which is a little object that will
    move along the track, which will be the target to follow the camera. To do this,
    click on **GameObject | Cinemachine | Dolly Track with Cart**:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从用一辆手推车开始创建轨道，这辆手推车是一个沿着轨道移动的小物体，它将成为跟随摄像机的目标。为此，点击 **GameObject | Cinemachine
    | 带手推车的摇臂轨道**：
- en: '![](img/B21361_17_56_PE.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_56_PE.png)'
- en: 'Figure 17.56: A dolly camera with a default straight path'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.56：一个默认直线路径的摇臂摄像机
- en: If you select the `DollyTrack1` object, you can see two circles with the numbers
    `0` and `1` in the **Scene** view. These are the control points of the track.
    Select one of them and move it as you move other objects, using the arrows of
    the translation gizmo. If you don’t see them, press the *W* key to enable the
    **Translation** gizmo.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你选择 `DollyTrack1` 对象，你可以在 **Scene** 视图中看到两个带有数字 `0` 和 `1` 的圆圈。这些是轨道的控制点。选择其中一个，并使用平移工具的箭头将其移动，就像移动其他对象一样。如果你看不到它们，请按
    *W* 键启用 **Translation** 工具。
- en: 'You can create more control points by clicking the **+** button at the bottom
    of the **Waypoints** list of the `CinemachineSmoothPath` component of the `DollyTrack1`
    object:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过点击 **DollyTrack1** 对象的 `CinemachineSmoothPath` 组件的 **Waypoints** 列表底部的
    **+** 按钮来创建更多的控制点：
- en: '![](img/B21361_17_57.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_57.png)'
- en: 'Figure 17.57: Adding a path control point'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.57：添加路径控制点
- en: 'Create as many waypoints as you need to create a path that will traverse the
    areas you want the camera to oversee in the intro cutscene. Remember, you can
    move the waypoints by clicking on them and using the translation gizmo:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建所需数量的航点，以创建一个路径，该路径将穿越你希望在开场剪辑中摄像机监督的区域。记住，你可以通过点击它们并使用平移工具来移动航点：
- en: '![](img/B21361_17_58_PE.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_58_PE.png)'
- en: 'Figure 17.58: A dolly track for our scene. It ends right behind the character'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.58：场景中的推车轨道。它正好在角色后面结束
- en: Create a new virtual camera. If you go to the **Game** view after creating it,
    you will notice that the character camera will be active. In order to test how
    the new camera looks, select the previous one (**CM vcam1**) and temporarily disable
    it by clicking the checkbox to the left of the GameObject’s name in the **Inspector**.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的虚拟相机。创建后，如果你转到**游戏**视图，你会注意到角色相机将是激活的。为了测试新相机的效果，选择之前的相机（**CM vcam1**），并通过点击**检查器**中GameObject名称左侧的复选框暂时禁用它。
- en: Set the **Follow** target this time to the `DollyCart1` object that we previously
    created with the track.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次将**跟随**目标设置为之前用轨道创建的`DollyCart1`对象。
- en: Set the **Follow Offset** of the **Body** section to `0`, `0`, and `0` to keep
    the camera in the same position as the cart.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**身体**部分的**跟随偏移**设置为`0`，`0`和`0`，以保持相机与卡车的相同位置。
- en: 'Set **Aim** to **Same As Follow Target** to make the camera look in the same
    direction as the cart, which will follow the track’s curves:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**目标**设置为**与跟随目标相同**，使相机朝与卡车相同的方向看，这将跟随轨道的曲线：
- en: '![](img/B21361_17_59.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_17_59.png)'
- en: 'Figure 17.59: Configuration to make the virtual camera follow the dolly track'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.59：配置虚拟相机跟随推车轨道
- en: 'Select the **DollyCart1** object and change the **Position** value to see how
    the cart moves along the track. Do this while the game window is focused and **CM
    vcam2** is in solo mode to see how the camera will look:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**DollyCart1**对象，并更改**位置**值以查看卡车如何沿着轨道移动。在游戏窗口聚焦且**CM vcam2**处于独奏模式时进行此操作，以查看相机的效果：
- en: '![](img/B21361_17_60.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_17_60.png)'
- en: 'Figure 17.60: The dolly cart component'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.60：推车组件
- en: Re-enable `CM vcam1`.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启用`CM vcam1`。
- en: With the dolly track properly set, we can create our cutscene using **Timeline**
    to sequence it.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在推车轨道设置正确后，我们可以使用**时间轴**来创建我们的场景，并对其进行序列化。
- en: Creating cutscenes with Timeline
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用时间轴创建场景
- en: We have our intro camera, but that’s not enough to create a cutscene. A proper
    cutscene is a sequence of actions happening at the exact moment that they should
    happen, coordinating several objects to act as intended. We can have actions such
    as enabling and disabling objects, switching cameras, playing sounds, moving objects,
    and so on. To do this, Unity offers **Timeline**, which is a sequencer of actions
    to coordinate those kinds of cutscenes. We will use **Timeline** to create an
    intro cutscene for our scene, showing the level before starting the game.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了开场相机，但这还不足以创建场景。一个合适的场景是一个动作序列，这些动作将在它们应该发生的确切时刻发生，协调多个对象按预期行事。我们可以有启用和禁用对象、切换相机、播放声音、移动对象等动作。为此，Unity提供了**时间轴**，这是一个动作序列器，用于协调这类场景。我们将使用**时间轴**为我们的场景创建一个开场场景，显示游戏开始之前的水准。
- en: 'In this section, we will examine the following Timeline concepts:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下时间轴概念：
- en: Creating animation clips
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动画剪辑
- en: Sequencing our intro cutscene
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序我们的开场场景
- en: We are going to see how to create our own animation clips in Unity to animate
    our GameObjects and then place them inside a cutscene to coordinate their activation
    using the Timeline sequencer tool. Let’s start by creating a camera animation
    to use later in Timeline.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在Unity中创建自己的动画剪辑来动画化我们的GameObject，然后将它们放置在场景中，并使用时间轴序列器工具协调它们的激活。让我们先创建一个用于稍后时间轴的相机动画。
- en: Creating animation clips
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建动画剪辑
- en: This is actually not a Timeline-specific feature but rather a Unity feature
    that works great with Timeline. When we downloaded the character, it came with
    animation clips that were created using external software, but you can create
    custom animation clips using Unity’s **Animation** window. Don’t confuse it with
    the **Animator** window, which allows us to create animation transitions that
    react to the game situation. This is useful to create small object-specific animations
    that you will coordinate later in Timeline with other objects’ animations.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上不是一个时间轴特有的功能，而是一个Unity功能，它与时间轴配合得很好。当我们下载角色时，它附带了一些使用外部软件创建的动画剪辑，但你可以使用Unity的**动画**窗口创建自定义动画剪辑。不要将其与**动画控制器**窗口混淆，后者允许我们创建对游戏情况做出反应的动画过渡。这有助于创建小对象特定的动画，你将在稍后使用时间轴与其他对象的动画进行协调。
- en: 'These animations can control any value of an object’s component properties,
    such as the positions, colors, and so on. In our case, we want to animate the
    dolly track’s **Position** property to make it go from start to finish in a given
    time. In order to do this, do the following:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这些动画可以控制对象组件属性的任何值，例如位置、颜色等。在我们的例子中，我们想要动画化轨道的**位置**属性，使其在给定时间内从起点到终点移动。为了做到这一点，请执行以下操作：
- en: Select the `DollyCart1` object.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`DollyCart1`对象。
- en: Open the **Animation** (not **Animator**) window by going to **Window | Animation
    | Animation**.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**窗口 | 动画 | 动画**打开**动画**（不是**动画器**）窗口。
- en: 'Click on the **Create** button at the center of the **Animation** window. Remember
    to do this while the dolly cart (not track) is selected:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**动画**窗口中央的**创建**按钮。记住，在选择了购物车（不是轨道）时执行此操作：
- en: '![A picture containing text, font, software, screenshot  Description automatically
    generated](img/B21361_17_61_PE.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、字体、软件、屏幕截图的图片，描述自动生成](img/B21361_17_61_PE.png)'
- en: 'Figure 17.61: Creating a custom animation clip'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.61：创建自定义动画剪辑
- en: After doing this, you will be prompted to save the animation clip somewhere.
    I recommend you create an `Animations` folder in the project (inside the `Assets`
    folder) and call it `IntroDollyTrack`.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行此操作后，你将被提示将动画剪辑保存到某个位置。我建议你在项目（`Assets`文件夹内）中创建一个`Animations`文件夹，并将其命名为`IntroDollyTrack`。
- en: If you pay attention, the dolly cart now has an **Animator** component with
    an Animator Controller created, which contains the animation we just created.
    As with any animation clip, you need to apply it to your object with an Animator
    Controller; custom animations are no exception. So, the **Animation** window created
    them for you.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意的话，购物车现在有一个**动画器**组件和一个创建的动画控制器，其中包含我们刚刚创建的动画。与任何动画剪辑一样，你需要使用动画控制器将它们应用到你的对象上；自定义动画也不例外。所以，**动画**窗口为你创建了它们。
- en: Animating in this window consists of specifying the value of its properties
    at given moments. In our case, we want **Position** to have a value of `0` at
    the beginning of the animation, at 0 seconds on the timeline, and have a value
    of `254` at the end of the animation, at 5 seconds. I chose `254` because that’s
    the last possible position in my cart, but that depends on the length of your
    dolly track. Just test which is the last possible position in yours. Also, I chose
    `5` seconds because that’s what I feel is the correct length for the animation,
    but feel free to change it as you wish. Now, whatever happens between the animation’s
    0 and 5 seconds is an interpolation of the `0` and `254` values, meaning that
    in 2.5 seconds, the value of `Position` will be `127`. Animating always consists
    of interpolating different states of our object at different moments.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在此窗口中动画化包括指定其属性在给定时刻的值。在我们的例子中，我们希望**位置**在动画开始时，即时间轴上的0秒，值为`0`，在动画结束时，即5秒，值为`254`。我选择`254`是因为那是我的购物车中可能达到的最后一个位置，但这取决于你的轨道长度。只需测试一下你的最后一个可能的位置是什么。此外，我选择`5`秒，因为这是我认为动画的正确长度，但你可以随意更改它。现在，动画的0到5秒之间发生的事情是`0`和`254`值之间的插值，这意味着在2.5秒时，`位置`的值将是`127`。动画始终包括在不同时刻插值我们对象的不同状态。
- en: 'In order to do this, follow these steps:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，请按照以下步骤操作：
- en: In the **Animation** window, click on the record button (the red circle in the
    top-left section). This will make Unity detect any changes in our object and save
    them to the animation. Remember to do this while you have selected the dolly cart.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**动画**窗口中，点击记录按钮（左上角的红色圆圈）。这将使Unity检测我们对象中的任何变化并将它们保存到动画中。记住，在选择了购物车时执行此操作。
- en: Set the **Position** setting of the dolly cart to `1` and then `0`. Changing
    this to any value and then to `0` again will create a keyframe, which is a point
    in the animation that says that at `0` seconds, we want the **Position** value
    to be `0`. We need to set it first to any other value if the value is already
    at `0`.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将购物车的**位置**设置设置为`1`然后`0`。将此值更改为任何值然后再次设置为`0`将创建一个关键帧，这是一个动画中的点，表示在`0`秒时，我们希望**位置**值为`0`。如果值已经为`0`，我们需要首先将其设置为任何其他值。
- en: 'You will notice that the **Position** property has been added to the animation:'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会注意到**位置**属性已经被添加到动画中：
- en: '![](img/B21361_17_62_PE.png)'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B21361_17_62_PE.png)'
- en: 'Figure 17.62: The animation in Record mode after changing the Position value
    to 0'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图17.62：将位置值更改为0后的记录模式动画
- en: 'Using the mouse scroll wheel, zoom out the timeline to the right of the **Animation**
    window until you see **5:00** seconds in the top bar:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用鼠标滚轮，将**动画**窗口右侧的时间轴缩放到可以看到顶部栏中的**5:00**秒：
- en: '![](img/B21361_17_63_PE.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![图17.63](img/B21361_17_63_PE.png)'
- en: 'Figure 17.63: The timeline of the Animation window seeing 5 seconds'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.63：动画窗口的时间轴显示5秒
- en: Click on the **5:00**-second label in the top bar of the timeline to position
    the playback header at that moment. This will locate the next change we make at
    that moment.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击时间轴顶部栏中的**5:00**秒标签，将播放头定位到那一刻。这将定位我们那一刻所做的下一个更改。
- en: 'Set the **Position** value of the dolly track to the highest value you can
    get; in my case, this is `240`. Remember to have the **Animation** window in **Record**
    mode:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将推车轨道的**位置**值设置为可以得到的最高值；在我的情况下，这是`240`。记得将**动画**窗口设置为**记录**模式：
- en: '![](img/B21361_17_64_PE.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![图17.65](img/B21361_17_64_PE.png)'
- en: 'Figure 17.64: Creating a keyframe with the 240 value 5 seconds into the animation'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.64：在动画5秒时创建具有240值的帧
- en: Hit the play button in the top-left section of the **Animation** window to see
    the animation playing. Remember to view it in the **Game** view while `CM vcam1`
    is disabled.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**动画**窗口的左上角点击播放按钮以查看动画播放。记得在`CM vcam1`禁用的情况下在**游戏**视图中查看。
- en: 'Sometimes, you will need to synchronize gameplay code with animations. One
    classic example is an attack animation, where you want the player to damage the
    attacked object when the sword hits the ground instead of as soon as the animation
    starts. To do this, you can use animation events: [https://docs.unity3d.com/Manual/script-AnimationWindowEvent.html](https://docs.unity3d.com/Manual/script-AnimationWindowEvent.html).
    You can also add animation events to imported animations: [https://docs.unity3d.com/Manual/class-AnimationClip.html](https://docs.unity3d.com/Manual/class-AnimationClip.html).'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你需要将游戏代码与动画同步。一个经典的例子是攻击动画，你希望玩家在剑触地时对被攻击对象造成伤害，而不是动画开始时。为此，你可以使用动画事件：[https://docs.unity3d.com/Manual/script-AnimationWindowEvent.html](https://docs.unity3d.com/Manual/script-AnimationWindowEvent.html)。你还可以将动画事件添加到导入的动画中：[https://docs.unity3d.com/Manual/class-AnimationClip.html](https://docs.unity3d.com/Manual/class-AnimationClip.html)。
- en: 'Now, if we hit **Play**, the animation will start playing, but that’s something
    we don’t want. In this scenario, the idea is to give control of the cutscene to
    the cutscene system, Timeline, because this animation won’t be the only thing
    that needs to be sequenced in our cutscene. One way to prevent the **Animator**
    component from automatically playing the animation we created is to create an
    empty animation state in the Controller and set it as the default state by following
    these steps:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们点击**播放**，动画将开始播放，但这不是我们想要的。在这种情况下，我们的想法是将场景控制权交给场景系统、时间轴，因为我们的动画不会是场景中唯一需要排序的东西。防止**动画器**组件自动播放我们创建的动画的一种方法是在控制器中创建一个空动画状态，并按照以下步骤将其设置为默认状态：
- en: Search the Animator Controller that we created at the same time as the animation
    and open it. If you can’t find it, just select the dolly cart and double-click
    on the **Controller** property of the **Animator** component on our GameObject
    to open the asset.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索我们与动画同时创建的动画器控制器并打开它。如果您找不到，只需选择推车并双击我们GameObject上的**动画器**组件的**控制器**属性以打开资产。
- en: 'Right-click on an empty state in the Controller and select **Create State**
    | **Empty**. This will create a new state in the state machine as if we created
    a new animation, but it is empty this time:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器中右键点击一个空状态，然后选择**创建状态** | **空**。这将像创建一个新的动画一样在状态机中创建一个新的状态，但这次它是空的：
- en: '![](img/B21361_17_65_PE.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![图17.65](img/B21361_17_65_PE.png)'
- en: 'Figure 17.65: Creating an empty state in the Animator Controller'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.65：在动画器控制器中创建空状态
- en: 'Right-click on **New State** and click on **Set as Layer Default State**. The
    state should become orange:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击**新建状态**并点击**设置为层默认状态**。状态应该变成橙色：
- en: '![](img/B21361_17_66_PE.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![图17.66](img/B21361_17_66_PE.png)'
- en: 'Figure 17.66: Changing the default animation of the Controller to an empty
    state'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.66：将控制器的默认动画更改为空状态
- en: Now, if you hit **Play**, no animation will play as the default state of our
    dolly cart is empty. No transition will be required in this case.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你点击**播放**，由于我们的推车默认状态为空，将不会播放任何动画。在这种情况下不需要任何过渡。
- en: Now that we have created our camera animation, let’s start creating a cutscene
    that switches from the intro cutscene camera to the player camera by using Timeline.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的相机动画，让我们开始创建一个场景，通过使用时间轴，从开场场景相机切换到玩家相机。
- en: Sequencing our intro cutscene
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编排我们的开场场景
- en: Timeline is already installed in your project, but if you go to the Package
    Manager of Timeline, you may see an **Update** button to get the latest version
    if you need some of the new features. In our case, we will keep the default version
    included in our project (1.5.2, at the time of writing this book).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 时间轴已经安装到您的项目中，但如果您进入时间轴的包管理器，您可能会看到一个**更新**按钮，如果您需要一些新功能，可以获取最新版本。在我们的例子中，我们将保持项目中包含的默认版本（1.5.2，本书编写时）。
- en: 'The first thing we will do is create a cutscene asset and an object in the
    scene responsible for playing it. To do this, follow these steps:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是创建一个场景资产和一个负责播放它的场景中的对象。为此，请按照以下步骤操作：
- en: Create an empty GameObject using the **GameObject** | **Create Empty** option.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**GameObject** | **创建空对象**选项创建一个空GameObject。
- en: Select the empty object and call it `Director`.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择空对象并将其命名为`导演`。
- en: Go to **Window** | **Sequencing** | **Timeline** to open the Timeline editor.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**窗口** | **编排** | **时间轴**以打开时间轴编辑器。
- en: Click the **Create** button in the middle of the **Timeline** window while the
    **Director** object is selected to convert that object into the cutscene player
    (or director).
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当选择**导演**对象时，点击**时间轴**窗口中间的**创建**按钮，将该对象转换为场景播放器（或导演）。
- en: After doing this, a window will pop up asking you to save a file. This file
    will be the cutscene or timeline; each cutscene will be saved in its own file.
    Save it in a `Cutscenes` folder in your project (the `Assets` folder).
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，将弹出一个窗口要求您保存文件。此文件将是场景或时间轴；每个场景都将保存在其自己的文件中。将其保存在您项目中的`Cutscenes`文件夹（`Assets`文件夹）中。
- en: 'Now, you can see that the Director object has a **Playable Director** component
    with the **Intro** cutscene asset saved in the previous step set for the **Playable**
    property, meaning this cutscene will be played by the Director:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以看到导演对象有一个**可播放导演**组件，其中保存了上一步中设置的**开场**场景资产作为**可播放**属性，这意味着这个场景将由导演播放：
- en: '![](img/B21361_17_67.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_17_67.png)'
- en: 'Figure 17.67: Playable Director prepared to play the Intro Timeline asset'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.67：准备播放开场时间轴资产的**可播放导演**
- en: Now that we have the Timeline asset ready to work with, let’s make it sequence
    actions. To start, we need to sequence two things—first, the cart position animation
    we did in the last step and then the camera swap between the dolly track camera
    (`CM vcam2`) and the player cameras (`CM vcam1`). As we said before, a cutscene
    is a sequence of actions executing at given moments, and in order to schedule
    actions, you will need tracks. In Timeline, we have different kinds of tracks,
    each one allowing you to execute certain actions on certain objects. We will start
    with the animation track.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可以工作的时间轴资产，让我们来编排动作。首先，我们需要编排两件事——首先，我们在上一步中做的购物车位置动画，然后是摇臂轨道相机（`CM vcam2`）和玩家相机（`CM
    vcam1`）之间的相机交换。正如我们之前所说的，场景是一个在给定时刻执行的动作序列，为了安排动作，你需要轨道。在时间轴中，我们有不同种类的轨道，每一种都允许你在某些对象上执行某些动作。我们将从动画轨道开始。
- en: 'The animation track will control which animation a specific object will play;
    we need one track per object to animate. In our case, we want the dolly track
    to play the **Intro** animation that we created, so let’s do that by following
    these steps:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 动画轨道将控制特定对象将播放哪个动画；我们需要为每个对象创建一个轨道来动画化。在我们的例子中，我们想要摇臂轨道播放我们创建的**开场**动画，所以让我们按照以下步骤操作：
- en: 'Add an Animation track by clicking **the plus button (+)** and then **Animation
    Track**:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**加号按钮 (+**) 然后选择**动画轨道**来添加一个动画轨道：
- en: '![](img/B21361_17_68_PE.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_17_68_PE.png)'
- en: 'Figure 17.68: Creating an animation track'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.68：创建动画轨道
- en: Select the **Director** object and check the **Bindings** list of the **Playable
    Director** component in the **Inspector** window.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，选择**导演**对象并检查**可播放导演**组件的**绑定**列表。
- en: Drag the **Cart** object to specify that we want the animation track to control
    its animation:![](img/B21361_17_69_PE.png)
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**购物车**对象拖动以指定我们想要动画轨道控制其动画：![图片](img/B21361_17_69_PE.png)
- en: 'Figure 17.69: Making the animation track control the dolly cart animation in
    this Director'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图17.69：在这个导演中使动画轨道控制摇臂购物车动画
- en: Timeline is a generic asset that can be applied to any scene, but as the tracks
    control specific objects, you need to manually bind them in every scene. In our
    case, we have an animation track that expects to control a single animator, so
    in every scene, if we want to apply this cutscene, we need to drag the specific
    animator to control it in the **Bindings** list.
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 时间轴是一个通用资产，可以应用于任何场景，但由于轨道控制特定的对象，您需要在每个场景中手动绑定它们。在我们的例子中，我们有一个期望控制单个动画器的动画轨道，因此在每个场景中，如果我们想应用这个剪辑场景，我们需要将特定的动画器拖动到**绑定**列表中，以控制它。
- en: 'Drag the **Intro** animation asset that we created to the animation track in
    the **Timeline** window. This will create a clip in the track showing when and
    for how long the animation will play. You can drag as many animations as possible
    that the cart can play into the track to sequence different animations at different
    moments, but right now, we want just that one:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们创建的**Intro**动画资产拖动到**时间轴**窗口中的动画轨道。这将在轨道中创建一个剪辑，显示动画何时以及持续多长时间播放。您可以尽可能多地拖动动画到轨道中，以便在不同的时刻序列不同的动画，但此时我们只想添加一个：
- en: '![](img/B21361_17_70_PE.png)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_70_PE.png)'
- en: 'Figure 17.70: Making the animator track play the intro clip'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.70：使动画器轨道播放开场剪辑
- en: You can drag the animation to change the exact moment you want it to play. Drag
    it to the beginning of the track.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以拖动动画以更改它播放的确切时刻。将其拖动到轨道的开始位置。
- en: 'Hit the **Play** button in the top-left part of the **Timeline** window to
    see it in action. You can also manually drag the white arrow in the **Timeline**
    window to view the cutscene at different moments. If that doesn’t work, try playing
    the game and then stopping:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**时间轴**窗口的右上角点击**播放**按钮，以查看其效果。您还可以手动在**时间轴**窗口中拖动白色箭头，以查看不同时刻的剪辑。如果不起作用，请尝试播放游戏然后停止：
- en: '![](img/B21361_17_71_PE.png)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_71_PE.png)'
- en: 'Figure 17.71: Playing a timeline and dragging the playback header'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.71：播放时间轴并拖动播放头
- en: 'Now, we will make our **Intro** timeline asset tell the `CinemachineBrain`
    component (the main camera) which camera will be active during each part of the
    cutscene, switching to the player camera once the camera animation is over. We
    will create a second track—a Cinemachine track—which specializes in making a specific
    `CinemachineBrain` component to switch between different virtual cameras. To do
    this, follow these steps:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使我们的**Intro**时间轴资产告诉`CinemachineBrain`组件（主摄像头）在剪辑的每个部分中哪个摄像头是活动的，摄像头动画结束后切换到玩家摄像头。我们将创建第二个轨道——一个Cinemachine轨道，它专门用于在特定的`CinemachineBrain`组件之间切换不同的虚拟摄像头。为此，请按照以下步骤操作：
- en: 'Click the **+** button again and click on **Cinemachine Track**. Note that
    you can install Timeline without **Cinemachine**, but this kind of track won’t
    appear in that case:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击**+**按钮，然后点击**Cinemachine轨道**。请注意，您可以在没有**Cinemachine**的情况下安装时间轴，但那种情况下不会出现这种类型的轨道：
- en: '![](img/B21361_17_72.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_72.png)'
- en: 'Figure 17.72: Creating a new Cinemachine track'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.72：创建一个新的Cinemachine轨道
- en: 'In the **Playable Director** component’s **Bindings** list, drag the main camera
    to **Cinemachine Track** to make it track control which virtual camera will control
    the main camera at different moments of the cutscene:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**可播放导演**组件的**绑定**列表中，将主摄像头拖动到**Cinemachine轨道**，使其跟踪控制在不同时刻的剪辑中哪个虚拟摄像头将控制主摄像头：
- en: '![](img/B21361_17_73_PE.png)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_73_PE.png)'
- en: 'Figure 17.73: Binding the main camera to the Cinemachine track'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.73：将主摄像头绑定到Cinemachine轨道
- en: 'The next step indicates which virtual camera will be active during specific
    moments of the timeline. To do so, our Cinemachine track allows us to drag virtual
    cameras to it, which will create virtual camera clips. Drag both **CM vcam2**
    and **CM vcam1**, in that order, to the Cinemachine track:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步指示在时间轴的特定时刻将激活哪个虚拟摄像头。为此，我们的Cinemachine轨道允许我们将虚拟摄像头拖动到它上面，这将创建虚拟摄像头剪辑。按照顺序，将**CM
    vcam2**和**CM vcam1**拖动到Cinemachine轨道：
- en: '![](img/B21361_17_74_PE.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_74_PE.png)'
- en: 'Figure 17.74: Dragging virtual cameras to the Cinemachine track'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.74：将虚拟摄像头拖动到Cinemachine轨道
- en: If you hit the **Play** button or just drag the **Timeline Playback** header,
    you can see how the active virtual camera changes when the playback header reaches
    the second virtual camera clip. Remember to view this in the **Game** view.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您点击**播放**按钮或只是拖动**时间轴播放**头，您可以看到当播放头到达第二个虚拟摄像头剪辑时，活动虚拟摄像头如何变化。请记住在**游戏**视图中查看这一点。
- en: If you place the mouse near the ends of the clips, a resize cursor will appear.
    If you drag them, you can resize the clips to specify their duration. In our case,
    we will need to match the length of the `CM vcam2` clip to the **Cart** animation
    clip and then put `CM vcam1` at the end of it by dragging it so that the camera
    will be active when the dolly cart animation ends. In my case, they were already
    the same length, but just try to change it anyway to practice. Also, you can make
    the `CM vcam1` clip shorter; we just need to play it for a few moments to execute
    the camera swap.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将鼠标放在剪辑的末端附近，会出现一个调整大小光标。如果你拖动它们，你可以调整剪辑的大小以指定它们的持续时间。在我们的例子中，我们需要将 `CM vcam2`
    剪辑的长度与 **Cart** 动画剪辑匹配，然后通过拖动将其放置在末尾，这样当推车动画结束时，摄像机就会变得活跃。在我的情况下，它们的长度已经相同，但只是为了练习，还是尝试改变它。此外，你还可以使
    `CM vcam1` 剪辑更短；我们只需要播放几秒钟来执行摄像机交换。
- en: 'You can also overlap the clips a little bit to make a smooth transition between
    the two cameras, instead of a hard switch, which will look odd:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以稍微重叠剪辑，以在两个摄像机之间创建平滑的过渡，而不是生硬的切换，这样看起来会很奇怪：
- en: '![](img/B21361_17_75_PE.png)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_75_PE.png)'
- en: 'Figure 17.75: Resizing and overlapping clips to interpolate them'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.75：调整大小和重叠剪辑以进行插值
- en: Increase the **Start Time** property of the **WaveSpawners** to prevent the
    enemies from being spawned before the cutscene begins.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **WaveSpawners** 的 **开始时间** 属性增加，以防止在场景剪辑开始之前生成敌人。
- en: 'If you wait for the full cutscene to end, you will notice how, at the very
    end, `CM vcam2` becomes active again. You can configure how Timeline will deal
    with the end of the cutscene, as, by default, it does nothing. This can cause
    different behavior according to the type of track—in our case, again giving control
    to pick the virtual camera to the `CinemachineBrain` component, which will pick
    the virtual camera with the highest **Priority** value. We can change the **Priority**
    property of the virtual cameras to be sure that **CM vcam1** (the player camera)
    is always the more important one or set the **Wrap Mode** of the **Playable Director**
    component to **Hold**, which will keep everything as the last frame of the timeline
    specifies. In our case, we will use the latter option to test the Timeline-specific
    features:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你等待完整的场景剪辑结束，你会注意到，在最后，`CM vcam2` 再次变得活跃。你可以配置时间轴如何处理场景剪辑的结束，因为默认情况下，它什么都不做。这可能会导致不同类型的轨道有不同的行为——在我们的例子中，再次将选择虚拟摄像机的控制权交给
    `CinemachineBrain` 组件，该组件将选择具有最高 **优先级** 值的虚拟摄像机。我们可以更改虚拟摄像机的 **优先级** 属性，以确保 **CM
    vcam1**（玩家摄像机）始终是更重要的一方，或者将 **可播放导演** 组件的 **Wrap Mode** 设置为 **Hold**，这将保持一切如时间轴最后帧所指定的那样。在我们的例子中，我们将使用后者选项来测试时间轴特定的功能：
- en: '![](img/B21361_17_76.png)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_17_76.png)'
- en: 'Figure 17.76: Wrap Mode set to Hold mode'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.76：Wrap Mode 设置为 Hold 模式
- en: Most of the different kinds of tracks work under the same logic; each one will
    control a specific aspect of a specific object using clips that will execute during
    a set time. I encourage you to test different tracks to see what they do, such
    as **Activation**, which enables and disables objects during the cutscene. Remember,
    you can check out the documentation of the Timeline package in the Package Manager.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数不同类型的轨道都遵循相同的逻辑；每个轨道都将控制特定对象的一个特定方面，使用在设定时间内执行的剪辑。我鼓励你测试不同的轨道，看看它们能做什么，例如
    **激活**，它可以在场景剪辑期间启用和禁用对象。记住，你可以在包管理器中查看时间轴包的文档。
- en: Summary
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the different animation systems that Unity provides
    for different requirements. We discussed importing character animations and controlling
    them with Animation Controllers. We also saw how to make cameras that can react
    to the game’s current situation, such as the player’s position, or that can be
    used during cutscenes. Finally, we looked at Timeline and the animation system
    to create an intro cutscene for our game. These tools are useful for making the
    animators in our team work directly in Unity without the hassle of integrating
    external assets (except for character animations) and also preventing the programmer
    from creating repetitive scripts to create animations, wasting time in the process.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Unity为不同需求提供的不同动画系统。我们讨论了导入角色动画以及使用动画控制器来控制它们。我们还看到了如何制作能够对游戏当前情况做出反应的相机，例如玩家的位置，或者可以在场景中使用的相机。最后，我们探讨了Timeline和动画系统，为我们的游戏创建一个开场场景。这些工具对于让我们的团队动画师直接在Unity中工作非常有用，无需集成外部资产（除了角色动画）的麻烦，同时也防止程序员创建重复的脚本来创建动画，从而节省时间。
- en: Now, you are able to import and create animation clips in Unity, as well as
    apply them to GameObjects to make them move according to the clips. Also, you
    can place them in the Timeline sequencer to coordinate them and create cutscenes
    for your game. Finally, you can create dynamic cameras to use in-game or in cutscenes.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在Unity中导入和创建动画剪辑，并将它们应用到GameObject上，使它们根据剪辑移动。您还可以将它们放置在Timeline序列器中，协调它们并为游戏创建场景。最后，您可以创建动态相机，用于游戏或场景中。
- en: With this, we end *Section 2*, *Mastering Programming and Gameplay Mechanics*
    where we learned about different Unity systems to improve several artistic aspects
    of our game. In the next chapter, the first chapter of *Section 3*, *Elevating
    Visuals, Effects, and Audio* we will wrap up the development of our game and see
    how to build and optimize it, and we will also provide a quick intro to augmented
    reality applications.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们结束了第二部分，*掌握编程和游戏玩法机制*，在这一部分中，我们学习了不同的Unity系统来提高我们游戏的艺术方面。在下一章，第三部分的第一章，*提升视觉效果、效果和音频*中，我们将完成我们游戏的开发，并了解如何构建和优化它，我们还将提供增强现实应用的快速介绍。
- en: Learn more on Discord
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'Read this book alongside other users, Unity game development experts, and the
    author himself. Ask questions, provide solutions to other readers, chat with the
    author via Ask Me Anything sessions, and much more. Scan the QR code or visit
    the link to join the community:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity游戏开发专家以及作者本人一起阅读这本书。提问、为其他读者提供解决方案、通过“问我任何问题”的环节与作者聊天，以及更多。扫描二维码或访问链接加入社区：
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/unitydev](https://packt.link/unitydev)'
- en: '![](img/QR_Code1498477041053909218.png)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1498477041053909218.png)'
