- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing, Debugging, and Testing Functions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about writing functions to reuse code, debugging logic errors
    during development, unit testing your code to remove bugs, and improving stability
    and reliability.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In an optional online-only section, you will learn about logging exceptions
    during runtime. You can find information on this at the end of the chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Writing functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging during development
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hot reloading during development
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throwing and catching exceptions in functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing functions
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A fundamental principle of programming is **don’t repeat yourself** (**DRY**).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: While programming, if you find yourself writing the same statements over and
    over again, then turn those statements into a **function**. Functions are like
    tiny programs that complete one small task. For example, you might write a function
    to calculate sales tax and then reuse that function in many places in a financial
    application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Like programs, functions usually have inputs and outputs. They are sometimes
    described as black boxes, where you feed in some raw materials at one end and
    a manufactured item emerges at the other. Once created and thoroughly debugged
    and tested, you don’t need to think about how they work.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Exploring top-level programs, functions, and namespaces
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 1*, *Hello, C#! Welcome, .NET!*, we learned that since C# 10 and
    .NET 6, the default project template for console apps uses the top-level program
    feature introduced with C# 9.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Once you start writing functions, it is important to understand how they work
    with the automatically generated `Program` class and its `<Main>$` method.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore how the top-level program feature works when you define functions:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to create a new solution and project, as defined
    in the following list:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Project template**: **Console App** / `console`'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project file and folder**: `TopLevelFunctions`'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution file and folder**: `Chapter04`'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do not use top-level statements**: Cleared'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enable native AOT** (**ahead-of-time**) **publish**: Cleared'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements, define a local function at
    the bottom of the file, and call it, as shown in the following code:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Good Practice**: Functions do not need to be at the bottom of the file, but
    it is good practice rather than mixing them up with other top-level statements.
    Types, like classes, *must* be declared at the bottom of the `Program.cs` file
    rather than in the middle of the file or you will see the compiler error `CS8803`,
    as shown at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-messages/cs8803](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-messages/cs8803).
    It would be better to define types like classes in a separate file.'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the console app and note that the namespace for the `Program` class is
    `null`, as shown in the following output:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What is automatically generated for a local function?
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The compiler automatically generates a `Program` class with a `<Main>$` function,
    then moves your statements and function inside the `<Main>$` method, which makes
    the function local, and renames the function, as shown highlighted in the following
    code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For the compiler to know what statements need to go where, you must follow
    some rules:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Import statements (`using`) must go at the top of the `Program.cs` file.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statements that will go in the `<Main>$` function can be mixed with functions
    in the middle of the `Program.cs` file. Any functions will become **local functions**
    in the `<Main>$` method.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last point is important because local functions have limitations, such as
    they cannot have XML comments to document them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: If the contents of the file which is code were the .NET SDK or some other tool
    that generated this code, then the code would need to be in a source code file
    that the compiler would then find in the filesystem and compile it. Because this
    code is generated by the compiler itself, there is no need for a source code file.
    The only way to discover what the compiler does is to use a decompiler on the
    assembly and reverse engineer the original code. You can also throw exceptions
    in the functions and methods to see some of the information, as I showed in *Chapter
    1*, *Hello, C#! Welcome, .NET!*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: You are about to see some C# keywords like `static` and `partial`, which will
    be formally introduced in *Chapter 5*, *Building Your Own Types with Object-Oriented
    Programming*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Defining a partial Program class with a static function
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A better approach is to write any functions in a separate file and define them
    as `static` members of the `Program` class:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Add a new class file named `Program.Functions.cs`. The name of this file does
    not actually matter but using this naming convention is sensible. You could name
    the file `Gibberish.cs` and it would have the same behavior.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Functions.cs`, delete any existing statements and then add statements
    to define a `partial Program` class. Cut and paste the `WhatsMyNamespace` function
    to move it from `Program.cs` into `Program.Functions.cs`, and then add the `static`
    keyword to the function, as shown highlighted in the following code:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In `Program.cs`, confirm that its entire content is now just three statements,
    as shown in the following code:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Run the console app and note that it has the same behavior as before.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is automatically generated for a static function?
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you use a separate file to define a `partial Program` class with `static`
    functions, the compiler defines a `Program` class with a `<Main>$` function and
    merges your function as a member of the `Program` class, as shown in the following
    highlighted code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Solution Explorer** shows that your `Program.Functions.cs` class file merges
    its `partial Program` with the auto-generated `partial Program` class, as shown
    in *Figure 4.1*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_04_01.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Solution Explorer showing the merged partial Program class'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Create any functions that you will call in `Program.cs`
    in a separate file and manually define them inside a `partial Program` class.
    This will merge them into the automatically generated `Program` class *at the
    same level* as the `<Main>$` method, instead of as local functions *inside* the
    `<Main>$` method.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note the lack of namespace declarations. Both the automatically
    generated `Program` class and the explicitly defined `Program` class are in the
    default `null` namespace.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** Do not define a namespace for your `partial Program` class. If
    you do, it will be in a different namespace and therefore will not merge with
    the auto-generated `partial Program` class.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, all the `static` methods in the `Program` class could be explicitly
    declared as `private` but this is the default anyway. Since all the functions
    will be called within the `Program` class itself, the access modifier is not important.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Times table example
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say that you want to help your child learn their times tables, so you
    want to make it easy to generate a times table for a number, such as the 7 times
    table:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Most times tables have 10, 12, or 20 rows, depending on how advanced the child
    is.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'You learned about the `for` statement earlier in this book, so you know that
    it can be used to generate repeated lines of output when there is a regular pattern,
    such as a 7 times table with 12 rows, as shown in the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: However, instead of always outputting the 7 times table with 12 rows, we want
    to make this more flexible so it can output times tables of any size for any number.
    We can do this by creating a function.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore functions by creating one to output any times table for numbers
    0 to 255 of any size up to 255 rows (but it defaults to 12 rows):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to create a new project, as defined in the following
    list:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console App** / `console`'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `WritingFunctions`'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `Chapter04`'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In Visual Studio, set the startup project for the solution to the current selection.
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `WritingFunctions.csproj`, after the `<PropertyGroup>` section, add a new
    `<ItemGroup>` section to statically import `System.Console` for all C# files using
    the implicit usings .NET SDK feature, as shown in the following markup:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Add a new class file to the project named `Program.Functions.cs`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Functions.cs`, replace any existing code with new statements to
    define a function named `TimesTable` in the `partial` `Program` class, as shown
    in the following code:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code, note the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '`TimesTable` must have a `byte` value passed to it as a parameter named `number`.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TimesTable` can optionally have a `byte` value passed to it as a parameter
    named `size`. If a value is not passed, it defaults to `12`.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TimesTable` is a `static` method because it will be called by the `static`
    method `<Main>$`.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TimesTable` does not return a value to the caller, so it is declared with
    the `void` keyword before its name.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TimesTable` uses a `for` statement to output the times table for the `number`
    passed to it with its number of rows equal to `size`.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements, and then call the function.
    Pass in a `byte` value for the `number` parameter, for example, `7`, as shown
    in the following code:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the code and then view the result, as shown in the following output:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Set the `size` parameter to `20`, as shown in the following code:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Run the console app and confirm that the times table now has 20 rows.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Good Practice**: If a function has one or more parameters where just passing
    the values may not provide enough meaning, then you can optionally specify the
    name of the parameter as well as its value, as shown in the following code: `TimesTable(number:
    7, size: 10)`.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Change the number passed into the `TimesTable` function to other `byte` values
    between `0` and `255` and confirm that the output times tables are correct.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that if you try to pass a non-`byte` number, for example, an `int`, `double`,
    or `string`, an error is returned, as shown in the following output:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A brief aside about arguments and parameters
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In daily usage, most developers will use the terms **argument** and **parameter**
    interchangeably. Strictly speaking, the two terms have specific and subtly different
    meanings. But just like a person can be both a parent and a doctor, the two terms
    often apply to the same thing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'A *parameter* is a variable in a function definition. For example, `startDate`
    is a parameter of the `Hire` function, as shown in the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When a method is called, an *argument* is the data you pass into the method’s
    parameters. For example, `when` is a variable passed as an argument to the `Hire`
    function, as shown in the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You might prefer to specify the parameter name when passing the argument, as
    shown in the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When talking about the call to the `Hire` function, `startDate` is the parameter,
    and `when` is the argument.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'If you read the official Microsoft documentation, they use the phrases **named
    and optional arguments** and **named and optional parameters** interchangeably,
    as shown at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'It gets complicated because a single object can act as both a parameter and
    an argument, depending on the context. For example, within the `Hire` function
    implementation, the `startDate` parameter could be passed as an argument to another
    function like `SaveToDatabase`, as shown in the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Naming things is one of the hardest parts of computing. A classic example is
    the parameter to the most important function in C#, `Main`. It defines a parameter
    named `args`, short for arguments, as shown in the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To summarize, parameters define inputs to a function; arguments are passed to
    a function when calling the function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Try to use the correct term depending on the context, but
    do not get pedantic with other developers if they “misuse” a term. I must have
    used the terms **parameter** and **argument** thousands of times in this book.
    I’m sure some of those times I’ve been imprecise. Please do not @ me about it.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Writing a function that returns a value
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous function performed actions (looping and writing to the console),
    but it did not return a value. Let’s say that you need to calculate sales or **value-added
    tax** (**VAT**). In Europe, VAT rates can range from 8% in Switzerland to 27%
    in Hungary. In the **United States** (**US**), state sales taxes can range from
    0% in Oregon to 8.25% in California.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Tax rates change all the time, and they vary based on many factors. The values
    used in this example do not need to be accurate.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement a function to calculate taxes in various regions around the
    world:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Functions.cs`, in the `Program` class, write a function named `CalculateTax`,
    as shown in the following code:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, note the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '`CalculateTax` has two inputs: a parameter named `amount`, which will be the
    amount of money spent, and a parameter named `twoLetterRegionCode`, which will
    be the region where the amount is spent.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CalculateTax` will perform a calculation using a `switch` expression and then
    return the sales tax or VAT owed on the amount as a `decimal` value; so, before
    the name of the function, we have declared the data type of the return value to
    be `decimal`.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the top of `Program.Functions.cs`, import the namespace to work with cultures,
    as shown in the following code:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In `Program.Functions.cs`, in the `Program` class, write a function named `ConfigureConsole`,
    as shown in the following code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This function enables UTF-8 encoding for the console output. This is necessary
    to output some special symbols like the Euro currency symbol. This function also
    controls the current culture used to format dates, times, and currency values.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, comment out any `TimesTable` method calls, and then call the
    `ConfigureConsole` method and the `CalculateTax` method, passing values for the
    amount, such as `149`, and a valid region code, such as `FR`, as shown in the
    following code:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the code, view the result, and note that it uses the US English culture,
    meaning US dollars for the currency, as shown in the following output:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In `Program.cs`, change the `ConfigureConsole` method to use your local computer
    culture, as shown in the following code:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the code, view the result, and note that the currency should now show your
    local currency. For example, for me in the UK, I would see `£29.80`, as shown
    in the following output:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In `Program.cs`, change the `ConfigureConsole` method to use the French culture,
    as shown in the following code:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the code, view the result, and note that the currency should now show Euros,
    as used in France, as shown in the following output:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Can you think of any problems with the `CalculateTax` function as written? What
    would happen if the user entered a code such as `fr` or `UK`? How could you rewrite
    the function to improve it? Would using a `switch` *statement* instead of a `switch`
    *expression* be clearer?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Converting numbers from cardinal to ordinal
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Numbers that are used to count are called **cardinal** numbers, for example,
    1, 2, and 3, whereas numbers used to order are **ordinal** numbers, for example,
    1st, 2nd, and 3rd. Let’s create a function to convert cardinals to ordinals:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Functions.cs`, write a function named `CardinalToOrdinal` that
    converts a cardinal `uint` value into an ordinal `string` value; for example,
    it converts the `uint` value of `1` into the `string` value `"1st"`, the `uint`
    value of `2` into the `string` value of `"2nd"`, and so on, as shown in the following
    code:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'From the preceding code, note the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '`CardinalToOrdinal` has one input, a parameter of the `uint` type named `number`,
    because we do not want to allow negative numbers, and one output: a return value
    of the `string` type.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `switch` *statement* is used to handle the special cases of `11`, `12`, and
    `13`.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `switch` *expression* then handles all other cases: if the last digit is
    `1`, then use `st` as the suffix; if the last digit is `2`, then use `nd` as the
    suffix; if the last digit is `3`, then use `rd` as the suffix; and if the last
    digit is anything else, then use `th` as the suffix.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `Program.Functions.cs`, write a function named `RunCardinalToOrdinal` that
    uses a `for` statement to loop from 1 to 150, calling the `CardinalToOrdinal`
    function for each number and writing the returned `string` to the console, separated
    by a space character, as shown in the following code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In `Program.cs`, comment out the `CalculateTax` statements and call the `RunCardinalToOrdinal`
    method, as shown in the following code:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Run the console app and view the results, as shown in the following output:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the `RunCardinalToOrdinal` function, change the maximum number to `1500`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the console app and view the results, as shown in the following output:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Calculating factorials with recursion
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The factorial of 5 is 120 because factorials are calculated by multiplying
    the starting number by one less than itself, and then by one less again, and so
    on until the number is reduced to 1\. An example can be seen here: 5 x 4 x 3 x
    2 x 1 = 120.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'The factorial function is defined for non-negative integers only, i.e., for
    0, 1, 2, 3, and so on, and it is defined as:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We could leave it to the compiler to reject negative numbers by declaring the
    input parameter as `uint` as we did for the `CardinalToOrdinal` function, but
    this time, let’s see an alternative way to handle that: throwing an argument exception.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Factorials are written like this: `5!`, where the exclamation mark is read
    as “bang,” so `5!` = 120, or *five bang equals one hundred and twenty*. Bang is
    a good term to use in the context of factorials because they increase in size
    very rapidly, just like an explosion.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write a function named `Factorial`; this will calculate the factorial
    for an `int` passed to it as a parameter. We will use a clever technique called
    **recursion**, which refers to a function that calls itself within its implementation,
    either directly or indirectly:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Functions.cs`, write a function named `Factorial`, as shown in
    the following code:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As before, there are several noteworthy elements in the preceding code, including
    the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: If the input parameter `number` is negative, `Factorial` throws an exception.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the input parameter `number` is `0`, `Factorial` returns `1`.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the input parameter `number` is more than `0` (which it will be in all other
    cases), `Factorial` multiplies the number by the result of calling itself and
    passing one less than `number`. This makes the function recursive.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**More Information**: Recursion is clever but it can lead to problems, such
    as a stack overflow due to too many function calls because memory is used to store
    data on every function call, and it eventually uses too much. Iteration is a more
    practical, if less succinct, solution in languages such as C#. You can read more
    about this at the following link: [https://en.wikipedia.org/wiki/Recursion_(computer_science)#Recursion_versus_iteration](https://en.wikipedia.org/wiki/Recursion_(computer_science)#Recursion_versus_iteration).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Functions.cs`, write a function named `RunFactorial` that uses
    a `for` statement to output the factorials of numbers from 1 to 15, calls the
    `Factorial` function inside its loop, and then outputs the result, formatted using
    the code `N0`, which refers to a number format using thousand separators with
    zero decimal places, as shown in the following code:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Comment out the `RunCardinalToOrdinal` method call and call the `RunFactorial`
    method.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the project and view the results, as shown in the following partial output:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It is not immediately obvious in the previous output, but factorials of 13 and
    higher overflow the `int` type because they are so big. `12!` is 479,001,600,
    which is about half a billion. The maximum positive value that can be stored in
    an `int` variable is about two billion. `13!` is 6,227,020,800, which is about
    six billion, and when stored in a 32-bit integer, it overflows silently without
    showing any problems.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: What should you do to get notified when an overflow happens? Of course, we could
    solve the problem for `13!` and `14!` by using a `long` (64-bit integer) instead
    of an `int` (32-bit integer), but we will quickly hit the overflow limit again.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'The point of this section is to understand and show you that numbers can overflow,
    and not specifically how to calculate factorials higher than `12!`. Let’s take
    a look:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `Factorial` function to check for overflows in the statement that
    calls itself, as shown highlighted in the following code:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Modify the `RunFactorial` function to change the starting number to `-2` and
    to handle overflow and other exceptions when calling the `Factorial` function,
    as shown highlighted in the following code:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Run the code and view the results, as shown in the following partial output:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Documenting functions with XML comments
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, when calling a function such as `CardinalToOrdinal`, code editors
    will show a tooltip with basic information.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s improve the tooltip by adding extra information:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using VS Code with the **C#** extension, you should navigate to
    **View** | **Command Palette** | **Preferences: Open Settings (UI)**, and then
    search for `formatOnType` and make sure that it is enabled. C# XML documentation
    comments are a built-in feature of Visual Studio and Rider, so you do not need
    to do anything to use them.'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the line above the `CardinalToOrdinal` function, type three forward slashes,
    `///`, and note that they are expanded into an XML comment that recognizes that
    the function has a single parameter named `number`, as shown in the following
    code:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Enter suitable information for the XML documentation comment for the `CardinalToOrdinal`
    function. Add a summary and describe the input parameter and the return value,
    as shown highlighted in the following code:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, when calling the function, you will see more details, as shown in *Figure
    4.2*:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_02.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: A tooltip showing the more detailed method signature'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth emphasizing that this feature is primarily designed to be used
    with a tool that converts the comments into documentation, like Sandcastle, which
    you can read more about at the following link: [https://github.com/EWSoftware/SHFB](https://github.com/EWSoftware/SHFB).
    The tooltips that appear while entering code or hovering over the function name
    are a secondary feature.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Local functions do not support XML comments because local functions cannot be
    used outside the member in which they are declared, so it makes no sense to generate
    documentation from them. Sadly, this also means no tooltip, which would still
    be useful, but neither Visual Studio nor VS Code recognizes that.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Add XML documentation comments to all your functions except
    your local functions.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Using lambdas in function implementations
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**F#** is Microsoft’s strongly typed functional-first programming language
    that, like C#, compiles to **Intermediate Language** (**IL**) to be executed by
    .NET. Functional languages evolved from lambda calculus, a computational system
    based only on functions. The code looks more like mathematical functions than
    steps in a recipe.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the important attributes of functional languages are defined in the
    following list:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '**Modularity**: The same benefit of defining functions in C# applies to functional
    languages. This breaks up a large, complex code base into smaller pieces.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Immutability**: Variables in the C# sense do not exist. Any data value inside
    a function cannot change. Instead, a new data value can be created from an existing
    one. This reduces bugs.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability**: Functional code is cleaner and clearer (for mathematically
    inclined programmers).'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since C# 6, Microsoft has worked to add features to the language to support
    a more functional approach, for example, adding **tuples** and **pattern matching**
    in C# 7, **non-null reference types** in C# 8, and improving pattern matching
    and adding records, that is, potentially **immutable objects**, in C# 9.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: In C# 6, Microsoft added support for **expression-bodied function members**.
    We will look at an example of this now. In C#, lambdas are the use of the `=>`
    character to indicate a return value from a function.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Fibonacci sequence** of numbers always starts with 0 and 1\. Then, the
    rest of the sequence is generated using the rule of adding together the previous
    two numbers, as shown in the following sequence of numbers:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The next term in the sequence would be 34 + 55, which is 89.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the Fibonacci sequence to illustrate the difference between an
    imperative and declarative function implementation:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Functions.cs`, write a function named `FibImperative`, which will
    be written in an imperative style, as shown in the following code:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In `Program.Functions.cs`, write a function named `RunFibImperative` that calls
    `FibImperative` inside a `for` statement that loops from 1 to 30, as shown in
    the following code:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In `Program.cs`, comment out the other method calls and call the `RunFibImperative`
    method.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the console app and view the results, as shown in the following partial
    output:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In `Program.Functions.cs`, write a function named `FibFunctional` written in
    a declarative style, as shown in the following code:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In `Program.Functions.cs`, write a function to call it inside a `for` statement
    that loops from 1 to 30, as shown in the following code:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In `Program.cs`, comment out the `RunFibImperative` method call and call the
    `RunFibFunctional` method.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the code and view the results (which will be the same as before).
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you have seen some examples of functions, let’s see how you can fix
    them when they have bugs.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Debugging during development
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to debug problems at development time. You
    must use a code editor that has debugging tools, such as Visual Studio or VS Code.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Creating code with a deliberate bug
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore debugging by creating a console app with a deliberate bug, which
    we will then use the debugger tools in your code editor to track down and fix:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `Debugging` to the `Chapter04` solution.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify `Debugging.csproj` to statically import `System.Console` for all code
    files.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete any existing statements, and then, at the bottom of
    the file, add a function with a deliberate bug, as shown in the following code:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Above the `Add` function, write statements to declare and set some variables
    and then add them together using the buggy function, as shown in the following
    code:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Run the console application and view the result, as shown in the following
    output:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: But wait, there’s a bug! 4.5 added to 2.5 should be 7, not 11.25!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: We will use the debugging tools to hunt for and squish the bug.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Setting a breakpoint and starting debugging
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Breakpoints allow us to mark a line of code that we want to pause at to inspect
    the program state and find bugs.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Using Visual Studio
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s set a breakpoint and then start debugging using Visual Studio:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Click in line 1, which is the statement that declares the variable named `a`.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to **Debug** | **Toggle Breakpoint** or press *F9*. A red circle will
    appear in the margin bar on the left-hand side and the statement will be highlighted
    in red to indicate that a breakpoint has been set, as shown in *Figure 4.3*:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_03.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Toggling breakpoints using Visual Studio'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Breakpoints can be toggled off with the same action. You can also left-click
    in the margin to toggle a breakpoint on and off or right-click a breakpoint to
    see more options, such as delete, disable, or edit conditions, or actions for
    an existing breakpoint.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to **Debug** | **Start Debugging** or press *F5*. Visual Studio starts
    the console application and then pauses when it hits the breakpoint. This is known
    as *break mode*. Extra windows titled **Locals** (showing the current values of
    local variables), **Watch 1** (showing any watch expressions you have defined),
    **Call Stack**, **Exception Settings**, and **Immediate Window** may appear. The
    **Debugging** toolbar appears. The line that will be executed next is highlighted
    in yellow, and a yellow arrow points at the line from the margin bar, as shown
    in *Figure 4.4*:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_04.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Break mode in Visual Studio'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: If you do not want to see how to use VS Code to start debugging, then you can
    skip the *Using VS Code* section and continue to the section titled *Navigating
    with the debugging toolbar*.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Using VS Code
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s set a breakpoint and then start debugging using VS Code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Click in line 1, which is the statement that declares the variable named `a`.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Run** | **Toggle Breakpoint** or press *F9*. A red circle will
    appear in the margin bar on the left-hand side to indicate that a breakpoint has
    been set.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Breakpoints can be toggled off with the same action. You can also left-click
    in the margin to toggle a breakpoint on and off; right-click to see more options,
    such as remove, edit, or disable an existing breakpoint; or add a breakpoint,
    conditional breakpoint, or Logpoint when a breakpoint does not yet exist. **Logpoints**,
    also known as **Tracepoints**, indicate that you want to record some information
    without having to stop executing the code at that point.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to **View** | **Run**, or in the left navigation bar, you can click
    the **Run and Debug** icon (the triangle “play” button and “bug”) or press *Ctrl*
    + *Shift* + *D* (on Windows).
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the **RUN AND DEBUG** window, click the **Run and Debug** button,
    and then select the **Debugging** project, as shown in *Figure 4.5*:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_05.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Selecting the project to debug using VS Code'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: If you are first prompted to choose a debugger, select **C#**, not .NET 5+ or
    .NET Core.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'VS Code starts the console app and then pauses when it hits the breakpoint.
    This is known as **break mode**. The line that will be executed next is highlighted
    in yellow, and a yellow block points at the line from the margin bar, as shown
    in *Figure 4.6*:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_06.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Break mode in VS Code'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Navigating with the debugging toolbar
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visual Studio has two debug-related buttons in its **Standard** toolbar to start
    or continue debugging and to hot reload changes to the running code, and a separate
    **Debug** toolbar for the rest of the tools.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: VS Code shows a floating toolbar with buttons to make it easy to access debugging
    features.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Both are shown in *Figure 4.7*:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_04_07.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Debugging toolbars in Visual Studio and VS Code'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list describes the most common buttons in the toolbars:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '**Start**/**Continue**/*F5*: This button is context-sensitive. It will either
    start running a project or continue running the project from the current position
    until it ends or hits a breakpoint.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hot Reload**: This button will reload compiled code changes without needing
    to restart the app.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Break All**: This button will break into the next available line of code
    in a running app.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stop Debugging**/**Stop**/*Shift* + *F5* (red square): This button will stop
    the debugging session.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Restart**/*Ctrl* or *Cmd* + *Shift* + *F5* (circular arrow): This button
    will stop and then immediately restart the program with the debugger attached
    again.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Show Next Statement**: This button will move the current cursor to the next
    statement that will execute.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step Into**/*F11*, **Step Over**/*F10*, and **Step Out**/*Shift* + *F11*
    (blue arrows over dots): These buttons step through the code statements in various
    ways, as you will see in a moment.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Show Threads in Source**: This button allows you to examine and work with
    threads in the application that you’re debugging.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging windows
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While debugging, both Visual Studio and VS Code show extra windows that allow
    you to monitor useful information, such as variables, while you step through your
    code.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'The most useful windows are described in the following list:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '**VARIABLES**, including **Locals**, which shows the name, value, and type
    of any local variables automatically. Keep an eye on this window while you step
    through your code.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WATCH**, or **Watch 1**, which shows the value of variables and expressions
    that you manually enter.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CALL STACK**, which shows the stack of function calls.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BREAKPOINTS**, which shows all your breakpoints and allows finer control
    over them.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When in break mode, there is also a useful window at the bottom of the edit
    area:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '**DEBUG CONSOLE**, or **Immediate Window**, enables live interaction with your
    code. You can interrogate the program state, for example, by entering the name
    of a variable. For example, you can ask a question such as “What is 1+2?” by typing
    `1+2` and pressing *Enter*.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stepping through code
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore some ways to step through the code using either Visual Studio
    or VS Code:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: The menu commands for debugging are on the **Debug** menu in Visual Studio or
    the **Run** menu in VS Code and Rider.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to **Run** or **Debug** | **Step Into**, click on the **Step Into**
    button in the toolbar, or press *F11*. The yellow highlight steps forward one
    line.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Run** or **Debug** | **Step Over**, click on the **Step Over**
    button in the toolbar, or press *F10*. The yellow highlight steps forward one
    line. At the moment, you can see that there is no difference between using **Step
    Into** or **Step Over** because we are executing single statements.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now be on the line that calls the `Add` method.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The difference between **Step Into** and **Step Over** can be seen when you
    are about to execute a method call.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: If you click on **Step Into**, the debugger steps *into* the method so that
    you can step through every line in that method.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: If you click on **Step Over**, the whole method is executed in one go; it does
    not skip over the method without executing it.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Step Into** to step inside the `Add` method.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hover your mouse pointer over the `a` or `b` parameters in the code editing
    window and note that a tooltip appears showing their current value.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the expression `a * b`, right-click the expression, and select **Add
    to Watch** or **Add Watch**. The expression is added to the **WATCH** or **Watch
    1** window, showing that this operator is multiplying `a` by `b` to give the result
    `11.25`.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **WATCH** or **Watch 1** window, right-click the expression and choose
    **Remove Expression** or **Delete Watch**.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fix the bug by changing `*` to `+` in the `Add` function.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart debugging by clicking the circular arrow **Restart** button or pressing
    *Ctrl* or *Cmd* + *Shift* + *F5*.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Step over the function, take a minute to note how it now calculates correctly,
    and click the **Continue** button or press *F5*.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With VS Code, note that when writing to the console during debugging, the output
    appears in the **DEBUG CONSOLE** window instead of the **TERMINAL** window, as
    shown in *Figure 4.8*:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_08.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Writing to the DEBUG CONSOLE during debugging'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Using the VS Code integrated terminal during debugging
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, the console is set to use the internal **DEBUG CONSOLE** during
    debugging, which does not allow interactions like entering text from the `ReadLine`
    method.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve the experience, we can change the setting to use the integrated
    terminal instead. First, let’s modify the code to require interaction with the
    user:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs`, add statements to prompt the user to enter a number
    and parse that as a `double` into the variable `a`, as shown highlighted in the
    following code:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Set a breakpoint on line 1 that writes the prompt `Enter a number`.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top of the **RUN AND DEBUG** window, click the **Run and Debug** button,
    and then select the **Debugging** project.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the `Enter a number` prompt is not written to either **TERMINAL**
    or **DEBUG CONSOLE** and neither window is waiting for the user to enter a number
    and press *Enter*.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop debugging.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the **RUN AND DEBUG** window, click the **create a launch.json
    file** link, and then, when prompted for the debugger, select **C#**, as shown
    in *Figure 4.9*:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_09.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Selecting a debugger for the launch.json file'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `launch.json` file editor, click the **Add Configuration...** button,
    and then select **.NET: Launch .NET Core Console App**, as shown in *Figure 4.10*:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_10.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: Adding a launch configuration for a .NET console app'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'In `launch.json`, make the following additions and changes, as shown highlighted
    in the following configuration:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Comment out the `preLaunchTask` setting.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `program` path, add the `Debugging` project folder after the `workspaceFolder`
    variable.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `program` path, change `<target-framework>` to `net9.0`.
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `program` path, change `<project-name.dll>` to `Debugging.dll`.
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Change the `console` setting from `internalConsole` to `integratedTerminal`:'
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Remember that with VS Code, we open the `Chapter04` folder to process the solution
    file, so the workspace folder is `Chapter04`, not the `Debugging` project.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the **RUN AND DEBUG** window, note the drop-down list of launch
    configurations, and click the **Start Debugging** button (green triangle), as
    shown in *Figure 4.11*.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **View** | **Terminal** and note the **TERMINAL** window is attached
    to `Debugging.dll`, as shown in *Figure 4.11*.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Step over the statement that writes `Enter a number:` to the console.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Step over the statement that calls `ReadLine`.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `5.5` and press *Enter*.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Continue stepping through the statements or press *F5* or click **Continue**,
    and note the output written to the integrated terminal, as shown in *Figure 4.11*:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_11.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: A launch configuration set to use the integrated terminal for
    user interaction'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Customizing breakpoints
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is easy to make more complex breakpoints:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: If you are still debugging, click the **Stop** button in the debugging toolbar,
    navigate to **Run** or **Debug** | **Stop Debugging**, or press *Shift* + *F5*.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Run** | **Remove All Breakpoints** or **Debug** | **Delete All
    Breakpoints**.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `WriteLine` statement that outputs the answer.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set a breakpoint by pressing *F9* or navigating to **Run** or **Debug** | **Toggle
    Breakpoint**.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click the breakpoint and choose the appropriate menu for your code editor:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In VS Code, choose **Edit Breakpoint...**.
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In Visual Studio, choose **Conditions...**.
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type an expression, such as the `answer` variable must be greater than `9`,
    and then press *Enter* to accept it, and note the expression must evaluate to
    `true` for the breakpoint to activate, as shown in *Figure 4.12*:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_12.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.12: Customizing a breakpoint with an expression using VS Code'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Start debugging and note the breakpoint is not hit.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop debugging.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the breakpoint or its conditions and change its expression to less than
    `9`.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start debugging and note the breakpoint is hit.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop debugging.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the breakpoint or its conditions (in Visual Studio, click **Add condition**),
    select **Hit Count**, then enter a number such as `3`, meaning that you would
    have to hit the breakpoint three times before it activates, as shown in *Figure
    4.13*:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_13.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.13: Customizing a breakpoint with an expression and hit count using
    Visual Studio'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'Hover your mouse over the breakpoint’s red circle to see a summary, as shown
    in *Figure 4.14*:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_14.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.14: A summary of a customized breakpoint in VS Code'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: You have now fixed a bug using some debugging tools and seen some advanced possibilities
    for setting breakpoints.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Hot reloading during development
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Hot Reload** is a feature that allows a developer to apply changes to code
    while the app is running and immediately see the effect. This is great for fixing
    bugs quickly. Hot Reload is also known as **Edit and Continue**. A list of the
    types of changes you can make that support Hot Reload is found at the following
    link: [https://aka.ms/dotnet/hot-reload](https://aka.ms/dotnet/hot-reload).'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Just before the release of .NET 6, a high-level Microsoft employee caused controversy
    by attempting to make the feature exclusive to Visual Studio. Luckily the open-source
    contingent within Microsoft successfully had the decision overturned. Hot Reload
    remains available using the command-line tool as well.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see it in action:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `HotReloading` to the `Chapter04` solution.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify `HotReloading.csproj` to statically import `System.Console` for all code
    files.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements, and then write a message to
    the console every two seconds, as shown in the following code:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Hot reloading using Visual Studio
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are using Visual Studio, Hot Reload is built into the user interface:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio, start the project and note that the message is output every
    two seconds.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the project running.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Program.cs`, change `Hello` to `Goodbye`.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Debug** | **Apply Code Changes** or click the **Hot Reload** button
    in the toolbar, as shown in *Figure 4.15*, and note the change is applied without
    needing to restart the console app.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drop down the **Hot Reload** button menu and select **Hot Reload on File Save**,
    as shown in *Figure 4.15*:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_15.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.15: Changing Hot Reload options'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Change the message again, save the file, and note the console app updates automatically.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hot reloading using VS Code and dotnet watch
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are using VS Code, you must issue a special command when starting the
    console app to activate Hot Reload:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'In VS Code, in **TERMINAL**, start the console app using `dotnet watch`, and
    note the output that shows that Hot Reload is active, as shown in the following
    output:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In VS Code, change `Hello` to `Goodbye`, and note that, after a couple of seconds,
    the change is applied without needing to restart the console app, as shown in
    the following output:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Press *Ctrl* + *C* to stop it running, as shown in the following output:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now that you’ve seen tools for finding and removing bugs during development,
    let’s see how you can track down less obvious problems that might happen during
    development and production by writing tests.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fixing bugs in code is expensive. The earlier that a bug is discovered in the
    development process, the less expensive it will be to fix.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is a good way to find bugs early in the development process because
    they test a small unit before they are integrated together or seen by user acceptance
    testers. Some developers even follow the principle that programmers should create
    unit tests before they write code, and this is called **test-driven development**
    (**TDD**).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft has a proprietary unit testing framework known as **MSTest**. There
    is also a framework named **NUnit**. However, we will use the free and open-source
    third-party framework **xUnit.net**. All three do basically the same thing. xUnit
    was created by the same team that built NUnit, but they fixed the mistakes they
    felt they made previously. xUnit is more extensible and has better community support.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are curious about the pros and cons of the various testing systems,
    then there are hundreds of articles written by proponents of each. Just google
    them: [https://www.google.com/search?q=xunit+vs+nunit](https://www.google.com/search?q=xunit+vs+nunit).'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Understanding types of testing
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unit testing is just one of many types of testing, as described in *Table 4.1*:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Description** |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
- en: '| Unit | Tests the smallest unit of code, typically a method or function. Unit
    testing is performed on a unit of code isolated from its dependencies by mocking
    them if needed. Each unit should have multiple tests: some with typical inputs
    and expected outputs, some with extreme input values to test boundaries, and some
    with deliberately wrong inputs to test exception handling. |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
- en: '| Integration | Tests if the smaller units and larger components work together
    as a single piece of software. Sometimes involves integrating with external components
    for which you do not have source code. |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
- en: '| System | Tests the whole system environment in which your software will run.
    |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
- en: '| Performance | Tests the performance of your software; for example, your code
    must return a web page full of data to a visitor in under 20 milliseconds. |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
- en: '| Load | Tests how many requests your software can handle simultaneously while
    maintaining required performance, for example, 10,000 concurrent visitors to a
    website. |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
- en: '| User Acceptance | Tests if users can happily complete their work using your
    software. |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
- en: 'Table 4.1: Types of testing'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class library that needs testing
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will create a function that needs testing. We will create it in a
    class library project separate from a console app project. A class library is
    a package of code that can be distributed and referenced by other .NET applications:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Class Library** / `classlib` project
    named `CalculatorLib` to the `Chapter04` solution.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, you will have created about a dozen new console app projects
    and added them to a solution. The only difference when adding a **Class Library**
    / `classlib` project is selecting a different project template. The rest of the
    steps are the same as adding a **Console App** / `console` project.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Visual Studio:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to **File** | **Add** | **New Project**.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Add a new project** dialog, search for and select **Class Library [C#]**
    and then click **Next**.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Configure your new project** dialog, for the **Project name**, enter
    `CalculatorLib`, leave the location as `C:\cs13net9\Chapter04`, and then click
    **Next**.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Additional information** dialog, select **.NET 9.0 (Standard Term Support)**,
    and then click **Create**.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are using VS Code:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: In **TERMINAL**, switch to a terminal in the `Chapter04` folder.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `dotnet` CLI to create a new class library project named `CalculatorLib`,
    as shown in the following command: `dotnet new classlib -o CalculatorLib`.'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `dotnet` CLI to add the new project folder to the solution, as shown
    in the following command: `dotnet sln add CalculatorLib`.'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note the results, as shown in the following output: ``Project `CalculatorLib\CalculatorLib.csproj`
    added to the solution``.'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For all code editors, in the `CalculatorLib` project, rename the file named
    `Class1.cs` to `Calculator.cs`.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Calculator.cs`, modify the file to define a `Calculator` class (with a
    deliberate bug), as shown in the following code:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Compile your class library project:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, navigate to **Build** | **Build CalculatorLib**.
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In VS Code, in a **TERMINAL** window for the `CalculatorLib` folder, enter the
    command `dotnet build`. (You could also run this command in the `Chapter04` folder
    but that would build the whole solution, which is unnecessary in this scenario.)
  id: totrans-418
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to add a new **xUnit Test Project [C#]** / `xunit`
    project named `CalculatorLibUnitTests` to the `Chapter04` solution. For example,
    at the command prompt or terminal in the `Chapter04` folder, enter the following
    commands:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In the `CalculatorLibUnitTests` project, add a project reference to the `CalculatorLib`
    project:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using Visual Studio, in **Solution Explorer**, select the `CalculatorLibUnitTests`
    project, navigate to **Project** | **Add Project Reference…**, check the box to
    select the `CalculatorLib` project, and then click **OK**.
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are using VS Code, use the `dotnet add reference` command, or in the
    file named `CalculatorLibUnitTests.csproj`, modify the configuration to add an
    item group with a project reference to the `CalculatorLib` project, as shown highlighted
    in the following markup:'
  id: totrans-423
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The path for a project reference can use either forward `(/)` or back slashes
    `(\)` because the paths are processed by the .NET SDK and changed if necessary
    for the current operating system.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Build the `CalculatorLibUnitTests` project.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writing unit tests
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A well-written unit test will have three parts:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrange**: This part will declare and instantiate variables for input and
    output.'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Act**: This part will execute the unit that you are testing. In our case,
    that means calling the method that we want to test.'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assert**: This part will make one or more assertions about the output. An
    assertion is a belief that, if not true, indicates a failed test. For example,
    when adding 2 and 2, we would expect the result to be 4.'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we will write some unit tests for the `Calculator` class:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: Rename the file `UnitTest1.cs` to `CalculatorUnitTests.cs` and then open it.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In VS Code, rename the class to `CalculatorUnitTests`. (Visual Studio prompts
    you to rename the class when you rename the file.)
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `CalculatorUnitTests`, import the `CalculatorLib` namespace, and then modify
    the `CalculatorUnitTests` class to have two test methods, one for adding 2 and
    2, and another for adding 2 and 3, as shown in the following code:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Visual Studio still uses an older project item template that uses a nested namespace.
    The preceding code shows the modern project item template used by `dotnet new`
    and Rider that uses a file-scoped namespace.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: Build the `CalculatorLibUnitTests` project.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running unit tests using Visual Studio
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we are ready to run the unit tests and see the results:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio, navigate to **Test** | **Run All Tests**.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In **Test Explorer**, note that the results indicate that two tests ran, one
    test passed, and one test failed, as shown in *Figure 4.16*:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_16.png)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.16: The unit test results in Visual Studio’s Test Explorer'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: Running unit tests using VS Code
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we are ready to run the unit tests and see the results:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: If you have not recently built the test project, then build the `CalculatorLibUnitTests`
    project to make sure that the new testing feature in the C# Dev Kit extension
    recognizes the unit tests that you have written.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In VS Code, navigate to **View** | **Testing**, and note the **TESTING** window
    has a mini toolbar with buttons to **Refresh Tests**, **Run Tests**, **Debug Tests**,
    and so on.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **TESTING** window, expand the **CalculatorLibUnitTests** project to
    show the two tests.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hover your mouse pointer over **CalculatorUnitTests** and then click the **Run
    Tests** button (black triangle icon) defined in that class.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **TEST RESULTS** tab and note that the results indicate that two
    tests ran, one test passed, and one test failed, as shown in *Figure 4.17*:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_04_17.png)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.17: The unit test results in VS Code’s TEST RESULTS'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the bug
  id: totrans-454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you can fix the bug:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Fix the bug in the `Add` method.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the unit tests again to see that the bug has now been fixed and both tests
    have passed.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we’ve written, debugged, logged, and unit-tested functions, let’s finish
    this chapter by looking at how to throw and catch exceptions in functions.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: Specifying multiple parameter values
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We created two unit test methods: the first to test adding 2 and 2, and the
    second to test adding 2 and 3\. Instead of writing two separate methods decorated
    with `[Fact]`, we could have written one method decorated with `[Theory]` and
    passed different parameter values using `[InlineData]`, as shown in the following
    code:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The order of parameters passed in the `[InlineData]` attribute must match the
    order of parameters in the test method.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s see how to throw and catch exceptions when something goes wrong.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: Throwing and catching exceptions in functions
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 3*,*Controlling Flow, Converting Types, and Handling Exceptions*,
    you were introduced to exceptions and how to use a `try-catch` statement to handle
    them. But you should only catch and handle an exception if you have enough information
    to mitigate the issue. If you do not, then you should allow the exception to pass
    up through the call stack to a higher level.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: Understanding usage errors and execution errors
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Usage errors** are when a programmer misuses a function, typically by passing
    invalid values as parameters. They could be avoided by that programmer changing
    their code to pass valid values. When some programmers first learn C# and .NET,
    they sometimes think exceptions can always be avoided because they assume all
    errors are usage errors. Usage errors should all be fixed before production runtime.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '**Execution errors** are when something happens at runtime that cannot be fixed
    by writing “better” code. Execution errors can be split into **program errors**
    and **system errors**. If you attempt to access a network resource but the network
    is down, you need to be able to handle that system error by logging an exception,
    and possibly backing off for a time and trying again. However, some system errors,
    such as running out of memory, simply cannot be handled. If you attempt to open
    a file that does not exist, you might be able to catch that error and handle it
    programmatically by creating a new file. Program errors can be programmatically
    fixed by writing smart code. System errors often cannot be fixed programmatically.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: Commonly thrown exceptions in functions
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Very rarely should you define new types of exceptions to indicate usage errors.
    .NET already defines many that you should use.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: When defining your own functions with parameters, your code should check the
    parameter values and throw exceptions if they have values that will prevent your
    function from properly functioning.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: For example, if a parameter to a function should not be `null`, throw `ArgumentNullException`.
    For other problems, throw `ArgumentException`, `NotSupportedException`, or `InvalidOperationException`.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: 'For any exception, include a message that describes the problem for whoever
    will have to read it (typically a developer audience for class libraries and functions,
    or end users if it is at the highest level of a GUI app), as shown in the following
    code:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '**Good Practice**: If a function cannot successfully perform its operation,
    you should consider it a function failure and report it by throwing an exception.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: Throwing exceptions using guard clauses
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of instantiating an exception using `new`, you can use static methods
    on the exception itself. When used in a function implementation to check argument
    values, they are known as **guard clauses**. Some were introduced with .NET 6,
    and more were added in .NET 8.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: 'Common guard clauses are shown in *Table 4.2*:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '| **Exception** | **Guard clause methods** |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
- en: '| `ArgumentException` | `ThrowIfNullOrEmpty`, `ThrowIfNullOrWhiteSpace` |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
- en: '| `ArgumentNullException` | `ThrowIfNull` |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
- en: '| `ArgumentOutOfRangeException` | `ThrowIfEqual`, `ThrowIfGreaterThan`, `ThrowIfGreaterThanOrEqual`,
    `ThrowIfLessThan`, `ThrowIfLessThanOrEqual`, `ThrowIfNegative`, `ThrowIfNegativeOrZero`,
    `ThrowIfNotEqual`, `ThrowIfZero` |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
- en: 'Table 4.2: Common guard clauses'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing an `if` statement and then throwing a `new` exception, we
    can simplify the previous example, as shown in the following code:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '**More Information**: To get a sense of how often Microsoft source code uses
    its own guard clauses, you can read the following section of an online blog article:
    [https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/#exceptions](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/#exceptions).
    For example, `ThrowIfNull` is called 4,795 times from within the `src` for the
    core libraries in `dotnet/runtime`.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the call stack
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The entry point for a .NET console application is the `Main` method (if you
    have explicitly defined this class) or `<Main>$` (if it was created for you by
    the top-level program feature) in the `Program` class.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Main` method will call other methods, which call other methods, and so
    on; these methods could be in the current project or referenced projects and NuGet
    packages, as shown in *Figure 4.18*:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_04_18.png)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.18: A chain of method calls that create a call stack'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a similar chain of methods to explore where we could catch and
    handle exceptions:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Class Library** / `classlib` project
    named `CallStackExceptionHandlingLib` to the `Chapter04` solution.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the `Class1.cs` file to `Processor.cs`.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Processor.cs`, modify its contents, as shown in the following code:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `CallStackExceptionHandling` to the `Chapter04` solution.
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `CallStackExceptionHandling` console app project, add a reference to
    the `CallStackExceptionHandlingLib` class library project, as shown in the following
    markup:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Build the `CallStackExceptionHandling` console app project to make sure dependent
    projects are compiled and copied to the local `bin` folder.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements, add statements to define two
    methods, and chain calls to them and the methods in the class library, as shown
    in the following code:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Run the console app *without* the debugger attached, and note the results,
    as shown in the following partial output:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Note that the call stack is upside down. Starting from the bottom, you see:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: The first call is to the `<Main>$` entry point function in the auto-generated
    `Program` class. This is where arguments are passed in as a `String` array.
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second call is to the `<<Main>$>g__Alpha|0_0` function. (The C# compiler
    renames it from `Alpha` when it adds it as a local function.)
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third call is to the `Beta` function.
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth call is to the `Gamma` function.
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fifth call is to the `Delta` function. This function attempts to open a
    file by passing a bad file path. This causes an exception to be thrown. Any function
    with a `try-catch` statement could catch this exception. If it does not, the exception
    is automatically passed up the call stack until it reaches the top, where .NET
    outputs the exception (and the details of this call stack).
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good Practice**: Unless you need to step through your code to debug it, you
    should always run your code without the debugger attached. In this case, it is
    especially important not to attach the debugger because, if you do, it will catch
    the exception and show it in a GUI dialog box instead of outputting it as shown
    in the book.'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: Where to catch exceptions
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programmers can decide if they want to catch an exception near the failure point
    or centralized higher up the call stack. This allows your code to be simplified
    and standardized. You might know that calling a function could throw one or more
    types of exception but you do not need to handle any of them at the current point
    in the call stack.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: Rethrowing exceptions
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you want to catch an exception, log it, and then rethrow it. For
    example, if you are writing a low-level class library that will be called from
    an application, your code may not have enough information to programmatically
    fix the error in a smart way, but the calling application might have more information
    and be able to. Your code should log the error in case the calling application
    does not, and then rethrow it up the call stack in case the calling application
    chooses to handle it better.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three ways to rethrow an exception inside a `catch` block, as shown
    in the following list:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: To throw the caught exception with its original call stack, call `throw`.
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To throw the caught exception as if it was thrown at the current level in the
    call stack, call `throw` with the caught exception, for example, `throw ex`. This
    is usually poor practice because you have lost some potentially useful information
    for debugging but it can be useful when you want to deliberately remove that information
    when it contains sensitive data.
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To wrap the caught exception in another exception that can include more information
    in a message that might help the caller understand the problem, throw a new exception,
    and pass the caught exception as the `innerException` parameter.
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If an error occurs when we call the `Gamma` function, then we could catch the
    exception and perform one of the three techniques of rethrowing an exception,
    as shown in the following code:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: This code is just illustrative. You would never use all three techniques in
    the same `catch` block!
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Let’s see this in action with our call stack example:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `CallStackExceptionHandling` project in `Program.cs`, in the `Beta`
    function, add a `try-catch` statement around the call to the `Gamma` function,
    as shown highlighted in the following code:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Note your code editor will show a squiggle under the `throw ex` to warn you
    that you will lose call stack information, as described in the code analyzer message
    `Re-throwing caught exception changes stack information`; more details can be
    found at the following link: [https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca2200](https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca2200).'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the console app and note that the output excludes some details of the call
    stack, as shown in the following output:'
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Remove the `ex` by replacing the statement `throw ex;` with `throw;`.
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the console app and note that the output includes all the details of the
    call stack.
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing the tester-doer and try patterns
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **tester-doer pattern** can avoid some thrown exceptions (but not eliminate
    them completely). This pattern uses pairs of functions: one to perform a test
    and the other to perform an action that would fail if the test was not passed.'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: .NET implements this pattern itself. For example, before adding an item to a
    collection by calling the `Add` method, you can test to see if it is read-only,
    which would cause `Add` to fail and, therefore, throw an exception.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, before withdrawing money from a bank account, you might test that
    the account is not overdrawn, as shown in the following code:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The tester-doer pattern can add performance overhead, so you can also implement
    the **try pattern**, which, in effect, combines the test and do parts into a single
    function, as we saw with `TryParse`.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with the tester-doer pattern occurs when you are using multiple
    threads. In this scenario, one thread calls the test function, and it returns
    a value that indicates that it is okay to proceed. But then another thread executes,
    which changes the state. Then the original thread continues executing, assuming
    that everything is fine, but it is not fine. This is called a *race condition*.
    This topic is too advanced to cover how to handle it in this book.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Use the try pattern in preference to the tester-doer pattern.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: 'If you implement your own try pattern function and it fails, remember to set
    the `out` parameter to the default value of its type and then return `false`,
    as shown in the following code:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '**More Information**: Now that you’ve been introduced to the basics of exceptions,
    you can learn more about the details by reading the official documentation at
    the following link: [https://learn.microsoft.com/en-us/dotnet/standard/exceptions/](https://learn.microsoft.com/en-us/dotnet/standard/exceptions/).'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  id: totrans-542
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring, with deeper research, the topics covered in
    this chapter.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.1 – online material
  id: totrans-544
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Online material can be extra content written by me for this book, or it can
    be references to content created by Microsoft or third parties.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: Logging during development and runtime
  id: totrans-546
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You should add code throughout your application to log what is happening, especially
    when exceptions occur, so that you can review the logs and use them to trace the
    issue and fix the problem. In an online-only section, you will learn how to implement
    basic logging; this is found at the following link:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch04-logging.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch04-logging.md)'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.2 – practice exercises
  id: totrans-549
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Practice exercises go deeper into the topics for this chapter.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: Writing functions with debugging and unit testing
  id: totrans-551
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Prime factors are a combination of the smallest prime numbers that, when multiplied
    together, will produce the original number. Consider the following examples:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: Prime factors of 4 are 2 x 2
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prime factor of 7 is 7
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prime factors of 30 are 5 x 3 x 2
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prime factors of 40 are 5 x 2 x 2 x 2
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prime factors of 50 are 5 x 5 x 2
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create three projects:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: A class library named `Exercise_PrimeFactorsLib` with a static class and static
    method named `PrimeFactors`, which, when passed an `int` variable as a parameter,
    returns a `string` showing its prime factors
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unit test project named `Exercise_PrimeFactorsTests` with a few suitable unit
    tests
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A console application to use it, named `Exercise_PrimeFactorsApp`
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To keep it simple, you can assume that the largest number entered will be 1,000.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: Use the debugging tools and write unit tests to ensure that your function works
    correctly with multiple inputs and returns the correct output.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.3 – test your knowledge
  id: totrans-564
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions. If you get stuck, try googling the answers,
    if necessary, while remembering that if you get totally stuck, the answers are
    in the *Appendix*:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: What does the C# keyword `void` mean?
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some differences between imperative and functional programming styles?
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In VS Code or Visual Studio, what is the difference between pressing *F5*, *Ctrl*
    or *Cmd* + *F5*, *Shift* + *F5*, and *Ctrl* or *Cmd* + *Shift* + *F5*?
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where does the `Trace.WriteLine` method write its output to?
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the five trace levels?
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `Debug` and `Trace` classes?
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When writing a unit test, what are the three “A”s?
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When writing a unit test using xUnit, which attribute must you decorate the
    test methods with?
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What `dotnet` command executes xUnit tests?
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What statement should you use to rethrow a caught exception named `ex` without
    losing the stack trace?
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 4.4 – explore topics
  id: totrans-576
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more about the topics covered
    in this chapter:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-4---writing-debugging-and-testing-functions](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-4---writing-debugging-and-testing-functions)'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-579
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: How to write reusable functions with input parameters and return values, in
    both an imperative and functional style
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用输入参数和返回值编写可重用函数，无论是命令式还是函数式风格
- en: How to use the Visual Studio and VS Code debugging and diagnostic features like
    logging and unit tests to identify and fix any bugs in them
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Visual Studio 和 VS Code 的调试和诊断功能，如日志和单元测试，来识别和修复其中的任何错误
- en: How to throw and catch exceptions in functions and understand the call stack
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在函数中抛出和捕获异常，并理解调用栈
- en: In the next chapter, you will learn how to build your own types using object-oriented
    programming techniques.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何使用面向对象编程技术构建自己的类型。
- en: Learn more on Discord
  id: totrans-585
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多信息
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的 Discord 社区——在那里您可以分享反馈，向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/csharp13dotnet9](https://packt.link/csharp13dotnet9)'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/csharp13dotnet9](https://packt.link/csharp13dotnet9)'
- en: '![](img/QR_Code281224304227278796.png)'
  id: totrans-588
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code281224304227278796.png)'
- en: Leave a Review!
  id: totrans-589
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下您的评价！
- en: Thank you for purchasing this book from Packt Publishing—we hope you enjoy it!
    Your feedback is invaluable and helps us improve and grow. Once you’ve completed
    reading it, please take a moment to leave an Amazon review; it will only take
    a minute, but it makes a big difference for readers like you.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您从 Packt Publishing 购买这本书——我们希望您喜欢它！您的反馈对我们来说是无价的，它帮助我们改进和成长。一旦您阅读完毕，请花一点时间在亚马逊上留下评价；这只需一分钟，但对像您这样的读者来说意义重大。
- en: Scan the QR or visit the link to receive a free ebook of your choice.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描二维码或访问链接，免费获取您选择的电子书。
- en: '[https://packt.link/NzOWQ](https://packt.link/NzOWQ)'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/NzOWQ](https://packt.link/NzOWQ)'
- en: '![A qr code with black squares  Description automatically generated](img/review1.png)'
  id: totrans-593
  prefs: []
  type: TYPE_IMG
  zh: '![带有黑色方块的二维码  自动生成的描述](img/review1.png)'
