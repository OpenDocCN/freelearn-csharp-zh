- en: Visitor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have to admit that I find the Visitor pattern confusing and strange. I wrestled
    with the concepts behind this pattern for a while before grasping its design,
    mostly because I seldom use it, and I mostly read about it from academic sources.
    But I began to appreciate this pattern when I started to visualize objects not
    just as chunks of data stored in the heap, but as a structure that can be visited
    and acted upon by another object. So, this means that it's possible to perform
    specific operations on elements of an object's structure without modifying it.
    This approach can be useful when you need to implement a system that needs to
    traverse a hierarchical structure and execute specific operations on individual
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The basic principles behind the Visitor pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a simulation of a one-armed factory robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is hands-on. You will need to have a basic understanding of Unity
    and C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the following Unity engine and C# language concept:'
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are unfamiliar with this concept, please review it before starting this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2OsR6d6](http://bit.ly/2OsR6d6)'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the Visitor pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary purpose of the Visitor pattern is simple once you grasp it; a *Visitable*
    object permits a Visitor object to operate on a specific element of its structure.
    This allows the visited object to receive new functionality from visitors.
  prefs: []
  type: TYPE_NORMAL
- en: This description might seem very abstract at first, but it's easier to visualize
    if you imagine an object as a data structure, instead of a closed-off container
    of data and logic. With this in mind, you can see that there's a broader array
    of possibilities in the way of manipulation objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, we can visualize those principals:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b278a21-5e74-4ca7-8fe9-66f68e73b167.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are two key participants in this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Visitor** is the interface for concrete visitors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Visitable** is the interface for objects that are accepting visitors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benefits and drawbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Visitor pattern is not as popular as the singleton pattern or the dependency
    injection pattern, so there''s less controversy surrounding its benefits and drawbacks,
    which are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Separation of data and logic**: The Visitor pattern offers a way to decouple
    an object''s data structures from its behaviors. This approach makes it easier
    to extend object capabilities by just adding more visitors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Double dispatch**: The Visitor pattern offers the ability to choose which
    method to use at runtime, depending on a given argument''s type, thereby making
    the code more dynamic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code complexity**: The most obvious drawback of the Visitor pattern is that
    it makes code more obscure. A programmer that''s not versed in the intricacies
    of the Visitor pattern might easily get lost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inflexibility**: The Visitor pattern is not an easy pattern to use, and demands
    consistency in its implementation. It can also be hard to remove once integrated
    into a code base, so it can be a long-term commitment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use case example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will make our use case simple, so we don't get lost in layers of abstraction
    while we try to grasp the intricacies of the Visitor pattern. Imagine that we
    are working on a project in which we need to design an interactive simulation
    of a robot with a mechanical arm.
  prefs: []
  type: TYPE_NORMAL
- en: The robot is very modular, and primarily built out of various components. So,
    we want our code to reflect this by making it possible for us to attach individual
    components to our skeleton robot object dynamically. To achieve this, we are going
    to use the Visitor pattern, because it offers us a way to dynamically add elements
    to an object's structure without modifying it directly.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it''s time to implement our one-armed robot, by attaching to it all the
    components it needs to operate while not modifying its basic structure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by implementing the Visitor interface, in which we declare those
    robot parts we are going to operate on with our Visitors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To help us out with our understanding of this pattern, let''s implement two
    concrete Visitor patterns as follows; the first visits all our robot parts and
    turns them on, while the other one shuts them off:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`RobotPartActivateVisitor`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`RobotPartShutdownVisitor`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it's quite straightforward at this point; we have a `Visit()`
    function for each robot part. This approach permits us to operate on them individually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our Visitors ready, it''s time for us to implement our Visitables.
    Let''s start by writing our `Visitable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now implement our concrete Visitables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Battery`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`ThermalImager`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`MechanicalArm`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we are referencing the Visitor interface inside the `Accept()` function.
    This piece of code is what makes it possible for our Visitors to operate on our
    Visitables.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time for us to build our `Robot`, attaching all its core parts by referencing
    them in its constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have our `Client` class, which acts as a proof of concept by actually
    triggering our Visitors to operate on our robot''s parts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So, we have implemented a simple, but flexible, use case of the Visitor pattern.
    The point to bear in mind is that any Visitor can operate on a Visitable object
    if it has implemented the `Accept()` function. This mechanism allows various operations
    to be performed on a Visitable object without directly modifying it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the Visitor, probably one of the most advanced
    patterns in this book, because it demands that we approach object-oriented programming
    from a different perspective and start viewing objects as structures instead of
    abstract entities that exist on the heap. We can now use what we have learned
    and extend the Visitor pattern to implement systems that need to operate on complex
    hierarchical data structures, such as XML files or directory trees.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to review a handy, but straightforward, pattern
    that's often over-used in Unity, the Façade pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Practical exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a practical exercise, I would recommend studying an advanced use of the Visitor
    pattern. A perfect example of this is the application of the Visitor pattern to
    navigate and process an **Abstract Syntax Tree** (**AST**). These types of implementations
    can showcase the architectural possibilities that the Visitor pattern offers.
  prefs: []
  type: TYPE_NORMAL
- en: For information on ASTs, please review the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Dive Into Design Patterns,* by Alexander Shvets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://refactoring.guru/design-patterns/book](https://refactoring.guru/design-patterns/book)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Abstract syntax tree*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Abstract_syntax_tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
