- en: Managing Dependencies with the Service Locator Pattern
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用服务定位器模式管理依赖项
- en: 'This chapter will be brief because the Service Locator pattern we will review
    is simple and efficient. The core idea of this pattern is straightforward: it
    revolves around having a central registry of initialized dependencies. But to
    be more precise, these dependencies are components that offer specific services
    that we can expose with interfaces we call "service contracts". Hence, when a
    client needs to call upon a particular service, it doesn''t need to know how to
    localize and initialize it; it just needs to ask the Service Locator pattern,
    and this will do all the legwork to fulfill the service contract.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将简短，因为我们将要审查的服务定位器模式简单且高效。该模式的核心理念非常直接：它围绕着一个中央注册表，该注册表包含初始化的依赖项。但为了更精确，这些依赖项是提供特定服务的组件，我们可以通过我们称之为“服务合约”的接口来公开这些服务。因此，当客户端需要调用特定的服务时，它不需要知道如何定位和初始化它；它只需要询问服务定位器模式，然后它将完成所有工作以满足服务合约。
- en: As we will see in this chapter, it's quite a simple design and is easy to implement.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本章中看到的，这是一个相当简单的设计，易于实现。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the Service Locator pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解服务定位器模式
- en: Implementing a Service Locator pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现服务定位器模式
- en: Reviewing alternative solutions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看替代解决方案
- en: We simplified this chapter's code example for learning purposes, to present
    the pattern's core concepts without being distracted by the implementation details.
    So, the code shown is neither optimized nor contextualized enough to be used as-is
    in a project.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了学习目的，我们简化了本章的代码示例，以展示模式的核心理念，而不被实现细节所分散。因此，显示的代码既未优化，也未充分上下文化，不能直接用于项目。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The following chapter is hands-on, so you will need to have a basic understanding
    of Unity and C#.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节是实践性的，因此您需要对Unity和C#有基本的了解。
- en: 'We will be using the following Unity-specific engine and C# language concepts:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下Unity特定的引擎和C#语言概念：
- en: Statics
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态
- en: Generics
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型
- en: If unfamiliar with these concepts, please review [Chapter 3](c71c8dd0-2787-43e0-a140-d9cc4ab41ff9.xhtml), *A
    Short Primer to Programming in Unity*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不熟悉这些概念，请查阅[第3章](c71c8dd0-2787-43e0-a140-d9cc4ab41ff9.xhtml)，《Unity编程简明指南》。
- en: The code files of this chapter can be found on GitHub, at [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter16](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter16).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到，地址为[https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter16](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter16)。
- en: Check out the following video to see the code in action: [https://bit.ly/36AKWli](https://bit.ly/36AKWli)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际运行情况：[https://bit.ly/36AKWli](https://bit.ly/36AKWli)
- en: Static is a keyword modifier. A method declared as static in a class can be
    called without instantiating an object.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 静态是一个关键字修饰符。在类中声明为静态的方法可以在不实例化对象的情况下调用。
- en: Understanding the Service Locator pattern
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解服务定位器模式
- en: Compared to more traditional patterns, the Service Locator pattern has less
    academic theory behind it and is very pragmatic in its overall design. As its
    name implies, its purpose is to locate services for a client. It achieves this
    by maintaining a central registry of objects that offer specific services.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与更传统的模式相比，服务定位器模式背后的学术理论较少，其整体设计非常实用。正如其名称所暗示的，其目的是为客户端定位服务。它通过维护一个提供特定服务的对象的中央注册表来实现这一点。
- en: 'Let''s review a diagram of a typical Service Locator implementation:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一个典型服务定位器实现的示意图：
- en: '![](img/0d532f91-cc29-465f-ac92-14affd8ebd4f.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d532f91-cc29-465f-ac92-14affd8ebd4f.png)'
- en: Figure 16.1 – Diagram of the Service Locator pattern
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1 – 服务定位器模式的示意图
- en: As we can see, we could easily say that the Service Locator pattern is acting
    as a proxy between the clients (requestors) and the service providers, and this
    approach decouples them to a certain degree. A client will only need to call the Service
    Locator pattern when it has a dependency to resolve and needs access to a service. We
    could say that the Service Locator pattern is acting similarly to a waiter in
    a restaurant, taking orders from clients and acting as an intermediary between
    the various services that the restaurant offers to its clientele.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们很容易说服务定位器模式充当了客户端（请求者）和服务提供者之间的代理，这种方法在一定程度上将它们解耦。客户端只有在需要解决依赖并需要访问服务时才需要调用服务定位器模式。我们可以说，服务定位器模式的作用类似于餐厅中的服务员，从客户端接收订单，并在餐厅提供的各种服务与其客户之间充当中间人。
- en: The Service Locator pattern has a bad reputation in some circles; experts often
    criticize it for being an anti-pattern. The core reason for this criticism is
    that it violates several coding best practices as it hides class dependencies
    instead of exposing them. In consequence, this could make your code harder to
    maintain and test.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些圈子中，服务定位器模式有一个坏名声；专家们经常批评它是一种反模式。这种批评的核心原因是它违反了几个编码最佳实践，因为它隐藏了类依赖关系而不是暴露它们。因此，这可能会使你的代码更难维护和测试。
- en: Benefits and drawbacks of the Service Locator pattern
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务定位器模式的好处和缺点
- en: 'Here are some of the potential benefits of using the Service Locator pattern:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用服务定位器模式的一些潜在好处：
- en: '**Runtime optimization**: The Service Locator pattern can optimize an application
    by dynamically detecting more optimized libraries or components to complete a
    specific service, depending on the runtime context.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时优化**：服务定位器模式可以通过动态检测更优化的库或组件来优化应用程序，以完成特定的服务，这取决于运行时环境。'
- en: '**Simplicity**: Service Locator is one of the most straightforward dependency
    management patterns to implement and doesn''t have the steep learning curve of
    a **dependency injection** (**DI**) framework. Hence, you can quickly start using
    it in a project or teach it to colleagues.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：服务定位器是实现依赖管理模式中最直接的一种，它没有依赖注入（**DI**）框架那样陡峭的学习曲线。因此，你可以快速在项目中开始使用它，或者教给同事。'
- en: 'Here are some drawbacks of using the Service Locator pattern:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用服务定位器模式的缺点如下：
- en: '**Black boxing**: The Service Locator pattern''s registry obfuscates class
    dependencies. Consequently, some issues might pop up at runtime instead of during
    compilation if dependencies are missing or incorrectly registered.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**黑盒化**：服务定位器模式的注册表模糊了类依赖关系。因此，如果依赖项缺失或注册不正确，一些问题可能会在运行时而不是在编译时出现。'
- en: '**Globally dependent**: If overly used and with the wrong intentions, the Service
    Locator pattern can become a global dependency in itself that''s arduous to manage.
    Your code will become excessively dependent on it, and eventually, it won''t be
    easy to decouple it from the rest of your core components.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局依赖**：如果过度使用且意图不正确，服务定位器模式本身可能会成为一个难以管理的全局依赖。你的代码将过度依赖它，最终，将其从其他核心组件中解耦将变得困难。'
- en: 'The Service Locator pattern was popular among Java developers; it was defined
    in part by Martin Fowler in a blog post published in 2004, which you can read
    here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 服务定位器模式在Java开发者中很受欢迎；它在2004年马丁·福勒（Martin Fowler）发表的一篇博客文章中被部分定义，你可以在这里阅读：
- en: '[https://martinfowler.com/articles/injection.html](https://martinfowler.com/articles/injection.html)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://martinfowler.com/articles/injection.html](https://martinfowler.com/articles/injection.html)'
- en: When to use the Service Locator pattern
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用服务定位器模式
- en: The question on when to use the Service Locator pattern is self-explanatory,
    based on its description. For example, if you have a list of services that you
    dynamically need to access but want to encapsulate the process involved in obtaining
    them, then this pattern can offer a solution.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 关于何时使用服务定位器模式的问题，根据其描述是显而易见的。例如，如果你有一系列需要动态访问的服务，但又想封装获取这些服务的过程，那么这种模式可以提供解决方案。
- en: But another aspect we should consider when contemplating using the Service Locator
    pattern is when not to use it. Because a Service Locator pattern is usually globally
    accessible, as its name implies, it should locate and provide access to services.
    Then, we should use it only to expose services that have a global scope.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但在考虑使用服务定位器模式时，我们还应该考虑不使用它的情况。因为服务定位器模式通常全局可访问，正如其名称所暗示的，它应该定位并提供对服务的访问。那么，我们只应该用它来暴露具有全局范围的服务。
- en: For instance, we need to access the **heads-up display** (**HUD**) to update
    one of its **user interface** (**UI**) components. Should we consider the HUD
    a global service that should be accessible through the Service Locator pattern?
    The answer should be no, as the HUD only appears during certain parts of the game
    and should be accessible only by particular components in a specific context.
    But if we design a custom logging system, we could justify exposing it through
    a Service Locator pattern, as we might need to log information from anywhere in
    our code independently of context and scope.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们需要访问**抬头显示**（**HUD**）来更新其**用户界面**（**UI**）组件之一。我们应该考虑将HUD视为一个全局服务，通过服务定位器模式来访问吗？答案应该是否定的，因为HUD只在游戏的某些部分出现，并且应该仅在特定上下文中由特定的组件访问。但是，如果我们设计一个自定义的日志系统，我们可以通过服务定位器模式来证明其暴露的合理性，因为我们可能需要在代码的任何地方独立于上下文和范围来记录信息。
- en: Now that we have gone through the theory, let's get our hands dirty and write
    a Service Locator pattern to provide access to a logger, an analytics system,
    and an **advertising network** (**ad network**) provider.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了理论，让我们动手编写一个服务定位器模式，以提供对日志记录器、分析系统和**广告网络**（**ad network**）提供者的访问。
- en: Implementing a Service Locator pattern
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现服务定位器模式
- en: 'We are going to implement a basic Service Locator pattern to expose three specific
    services, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个基本的服务定位器模式来公开三个特定的服务，如下所示：
- en: '**Logger**: A service that acts as a facade to a centralized logging system'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志记录器**：一个充当集中式日志系统门面的服务'
- en: '**Analytics**: A service that sends custom analytical information to a backend
    to provide insight on player behavior'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析**：一个将自定义分析信息发送到后端以提供对玩家行为的洞察的服务'
- en: '**Advertisement**: A service that pulls video **advertisements** (**ads**)
    from a network and displays them to monetize the game''s content at specific moments'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**广告**：一个从网络拉取视频**广告**（**ads**）并将其显示出来以在特定时刻为游戏内容赚钱的服务'
- en: 'We are adding these services to the registry of the Service Locator pattern
    because of their following characteristics:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些服务添加到服务定位器模式的注册表中，是因为它们具有以下特点：
- en: They offer a specific service.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供特定的服务。
- en: They need to be accessible from anywhere in the code base.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们需要从代码库的任何地方都可以访问。
- en: They can be mocked or removed without causing any regression in the gameplay
    code.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以被模拟或移除，而不会对游戏代码造成任何回归。
- en: 'As we are going to see from the following code example, implementing a basic
    Service Locator pattern is a straightforward process. These are the steps we''ll
    take:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在以下代码示例中看到的那样，实现基本的服务定位器模式是一个简单的过程。我们将采取以下步骤：
- en: 'Let''s start by implementing the most important ingredient—the `ServiceLocator` class,
    as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从实现最重要的成分——`ServiceLocator`类开始，如下所示：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This version of a Service Locator pattern has three primary responsibilities,
    outlined as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种服务定位器模式有三个主要职责，如下所述：
- en: It manages a registry of services in the form of a `Dictionary`.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它以`Dictionary`的形式管理服务注册表。
- en: It offers a static function named `RegisterService()` that permits an object
    to be registered as a service.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一个名为`RegisterService()`的静态函数，允许一个对象被注册为服务。
- en: It returns an instance of `service` of a specific type when requested through
    the `GetService()` function.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当通过`GetService()`函数请求时，它返回特定类型的`service`实例。
- en: It has to take into account that both `RegisterService()` and `GetService()`
    are static functions, hence they are accessible directly without needing to initialize
    the `ServiceLocator` class.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 它必须考虑到`RegisterService()`和`GetService()`都是静态函数，因此它们可以直接访问，无需初始化`ServiceLocator`类。
- en: The `Services` dictionary holds a list of available services, and we flagged
    it as `readonly` and `private`; thus, we protect it from being overridden or accessed
    directly. Instead, a client will have to go through the public methods that the
    Service Locator pattern exposes to add or get a service.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Services`字典包含可用的服务列表，我们将其标记为`readonly`和`private`；因此，我们保护它不被覆盖或直接访问。相反，客户端必须通过Service
    Locator模式公开的方法来添加或获取服务。'
- en: Now that we have our Service Locator class ready, we can now start implementing
    some service contracts in the form of interfaces.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了准备好的Service Locator类，我们现在可以开始以接口的形式实现一些服务合同。
- en: 'Our first interface is for the `Logger` service, as illustrated in the following
    code snippet:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一个接口是为`Logger`服务，如下面的代码片段所示：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next interface is for the `Analytics` service, as we can see here:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个接口是为`Analytics`服务，正如我们在这里看到的：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And lastly, we implement the code for our `Advertisement` service''s interface,
    as follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们实现了我们的`Advertisement`服务接口的代码，如下所示：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And now, we are going to implement concrete service classes, starting with
    the `Logger` class. The code to accomplish this is illustrated in the following
    snippet:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将实现具体的服务类，从`Logger`类开始。完成此任务的代码如下所示：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next up is the `Analytics` class. Here''s the code you''ll need to implement
    this:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`Analytics`类。以下是实现此功能所需的代码：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And lastly, we implement our concrete `Advertisement` service class, as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们实现了我们的具体`Advertisement`服务类，如下所示：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We now have a Service Locator pattern with services that we can register and
    access from anywhere.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个可以注册和从任何地方访问服务的Service Locator模式。
- en: Testing the Service Locator pattern
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试Service Locator模式
- en: 'To test our implementation of the Service Locator pattern, let''s write a client
    class that we will attach as a component to a GameObject in an empty Unity scene,
    as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们实现的Service Locator模式，让我们编写一个客户端类，我们将将其作为组件附加到一个空Unity场景中的GameObject上，如下所示：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It's important to note that in an actual implementation of the Service Locator
    pattern in a Unity project, we would register our services as early as possible
    during our game's lifespan so that they are made available at all times—for example,
    this task could be given to a `GameManager` object that we initialized in the
    first scene of our project. If we know that the scene and the Game Manager object
    will always be loaded when the player starts the game, we are sure the registry
    of the Service Locator pattern will be updated before clients start requesting
    access to services.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在实际的Unity项目中实现服务定位器模式时，我们应该尽可能早地在游戏的生命周期中注册我们的服务，以确保它们始终可用——例如，这个任务可以分配给我们在项目第一个场景中初始化的`GameManager`对象。如果我们知道当玩家开始游戏时场景和游戏管理器对象总是会被加载，我们就确信服务定位器模式的注册会在客户端开始请求访问服务之前更新。
- en: A key benefit of our approach is that we are registering services by referring
    to their interfaces, which means that at the moment we register services, we can
    choose which concrete implementation to use. Thus, we could easily have mock versions
    of each service running in a debug build. Furthermore, this approach will avoid
    adding noise to the logs and analytics during the **quality assurance** (**QA**)
    phase.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们方法的一个关键好处是我们通过引用它们的接口来注册服务，这意味着在我们注册服务的那一刻，我们可以选择使用哪个具体实现。因此，我们可以在调试构建中轻松地运行每个服务的模拟版本。此外，这种方法将避免在**质量保证**（**QA**）阶段向日志和数据分析中添加噪音。
- en: Hence, this is one of the cool features of this pattern; you can dynamically
    inject various service versions depending on the runtime context.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是该模式的一个酷特性；你可以根据运行时环境动态注入各种服务版本。
- en: One of the main benefits of using Unity as your engine is that it offers a range
    of integrated services, including ads and analytics services, therefore most of
    the time, you will not have to implement them by hand. You can read about the
    range of available Unity services at the following link: [https://docs.unity3d.com/Manual/UnityServices.html.](https://docs.unity3d.com/Manual/UnityServices.html)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Unity作为你的引擎的主要好处之一是它提供了一系列集成服务，包括广告和数据分析服务，因此大多数时候，你不需要手动实现它们。你可以在以下链接中了解可用的Unity服务范围：[https://docs.unity3d.com/Manual/UnityServices.html.](https://docs.unity3d.com/Manual/UnityServices.html)
- en: Reviewing alternative solutions
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查替代方案
- en: If you are having issues with the management of dependencies in your code base,
    it might be time to start investigating the use of a DI framework. DI is a technique
    in which an object receives dependencies it needs through an "injection mechanism."
    There are several ways an object can receive its dependencies—through the constructor,
    a setter, or even with an interface that provides an injector method.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在代码库中管理依赖项时遇到问题，可能该开始调查使用 DI 框架了。DI 是一种技术，其中对象通过“注入机制”接收它需要的依赖项。对象可以通过几种方式接收其依赖项——通过构造函数、setter
    或甚至是一个提供注入方法接口。
- en: The best way to start using DI in a structured manner is through a framework
    because this gives you a helping hand in managing complex relationships between
    objects, the initialization process, and the lifespan of dependencies. In conclusion,
    you should start considering using a DI framework when you see tight coupling
    between classes and when their dependencies are becoming a bottleneck to writing
    consistent, testable, and maintainable code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以结构化方式开始使用 DI 的最佳方式是通过框架，因为这为您在管理对象之间复杂关系、初始化过程和依赖项的生命周期提供了帮助。总之，当您看到类之间存在紧密耦合，并且它们的依赖项成为编写一致、可测试和可维护代码的瓶颈时，您应该开始考虑使用
    DI 框架。
- en: '**Extenject** is a free DI framework for Unity that can be downloaded from
    the Asset Store:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**Extenject** 是一个免费的 Unity DI 框架，可以从 Asset Store 下载：'
- en: '[https://assetstore.unity.com/packages/tools/utilities/extenject-dependency-injection-ioc-157735](https://assetstore.unity.com/packages/tools/utilities/extenject-dependency-injection-ioc-157735)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://assetstore.unity.com/packages/tools/utilities/extenject-dependency-injection-ioc-157735](https://assetstore.unity.com/packages/tools/utilities/extenject-dependency-injection-ioc-157735)'
- en: Summary
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed the Service Locator pattern. This pattern is a
    simple solution to resolving a recurring challenge of managing dependencies between
    objects relying on services (functionalities) that other objects offer. In its
    simplest form, the Service Locator pattern decouples the relationship between
    a client (requester) and a service provider.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了服务定位器模式。这个模式是解决对象之间依赖服务（功能）管理重复挑战的一个简单解决方案。在其最简单的形式中，服务定位器模式解耦了客户端（请求者）与服务提供者之间的关系。
- en: We have arrived at the end of our journey, as this is the last chapter of the
    book. We hope you enjoyed the content of each chapter. Please remember that the
    concepts presented throughout this book are just introductions, not the final
    word on the subject matter. There's a lot more to learn about design patterns,
    Unity, and game development—so much that we can't define it in a single book.
    Thus, we encourage you to continue learning, take what we reviewed together in
    each chapter, and make it better because there's always room for improvement.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的旅程已经到达终点，因为这是本书的最后一章。我们希望您喜欢每一章的内容。请记住，本书中提出的概念只是入门，不是关于主题的最终结论。关于设计模式、Unity和游戏开发还有很多东西要学习——多到我们无法在一本书中定义清楚。因此，我们鼓励您继续学习，将每一章中我们一起回顾的内容做得更好，因为总有改进的空间。
